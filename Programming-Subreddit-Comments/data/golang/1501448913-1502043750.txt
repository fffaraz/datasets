You have it quite confused. f is a local variable inside the loop and defer evaluates function arguments immediately, that's why it closes all files at the end of the function. And well, with the alternative semantics, defering on condition wouldn't be possible. The question I'm asking is: is it useful? EDIT: I meant exactly what I wrote, just assume I have it correct. I'm comparing two semantics, the actual one, and a virtual alternative one.
I do see this pattern a lot in my own code. What I often do end up looking like is this. func openManyFiles(filenames ...string) error { for _, filename := range filenames { err := func() error { f, err := os.Open(filename) if err != nil { return err } defer f.Close() return doSomething(f) }() if err != nil { return err } } return nil } 
So it looks like you would benefit from the alternative semantics, right?
defer is slow and bad, don't use defer
Im afraid you need to determin yourself which format youre dealing with. You can probably do a few contains() to determin it? 
?
I do this as well. Seems like a candidate for an experience report for go2.0. Although I don't have a solution in mind. I don't understand why defer is tried to a function rather than a scope. For example, in C++, RAII is scope based. I have experience needing to put functions inside loops, but I don't have experience needing to queue up a bunch of defers in a loop.
For mutexs I think it's useful more often to not have block scoping as on occasion you may want to wrap acquiring a Mutex in a if statement. But for files it can be a easy trap to fall into I suppose, but I almost always find myself just having openDescriptionOfFiles call a function under it of openDescriptionOfFile. Mostly because I don't want a bunch of file processing nested in a for loops block because it makes unit testing more annoying as well. If I'm doing something quick / temporarily, it's never an error to call file.Close multiple times. Go will ensure the underlying file handle is never double freed. So you can run the defer and just call f.Close after processing to prevent lingering file handles. Edit: for your example I would pass filename to dosomething and call it a day.
Yes, but only in one case. Sometimes it's nice to do conditional termination. For example if your program writes to stdout or to a file. You can make a function with an if statement where in one case you open a file and defer its closing, in another case you don't open anything, but set your io.Writer to os.Stdout. https://github.com/nsf/bin2go/commit/b4d735d0bf7e15d74f00bce527a4add710b59f56#diff-633e151079a12d77214c0c387e0c0717R100 While I don't see uses like that often, it is what it is.
Could make the argument that it isn't slices, but that bytes.Split could be implemented better. Only a slight alteration to bytes.go genSplit append would prevent overwriting bytes. https://play.golang.org/p/jP0soi1yQw 
A solution could be to just make defer scope based? Being scope-based, it would also be possible to implement defer with no performance penalty at all.
Instead of func openManyFiles(filenames ...string) { for _, filename := range filenames { f, _ := os.Open(filename) defer f.Close() // this executes at the end of openManyFiles doSomething(f) } } it should be something like func openManyFiles(filenames ...string) error { for _, filename := range filenames { if err := doSomething(filename); err != nil { return err } } } func doSomething(fn string) (err error) { if f, err := os.Open(fn); err != nil { return err } defer func() { if e := f.Close(); e != nil &amp;&amp; err == nil { err = e } }() // ... do something with f } 
That's not the point.
Then what _is_ the point of wrongly using `defer` in the wrong place?
I'm simply asking whether the current defer scoping is useful and I'm giving two toy code examples to demonstrate what I mean.
And the obvious answer is that the current defer scoping is not useful if used incorrectly. But the problem is in using it wrongly, not in how it works. It's like asking if the integer division is useful and providing an example where division by zero occurs.
The answer is not obvious. However, I don't see how my post implies that it is useful. I think it's not useful and my post should imply the same.
Asking if wrong code is useful is a question that cannot provide any useful answer beyond the obvious "the code is wrong".
First complaint: "Violates static type safety" First solution: "Use context.Value" (aka `interface{}`) Yeah, ok...
Alright, just for you: simply read the first paragraph of my post and imagine there's nothing more.
If you don't yet know Tensorflow, best to just learn it with Python first. I use Tensorflow a lot but haven't used tensorflow-go because, well, I haven't _needed_ to that badly. Golearn is fine for many academic tasks IMO. Dunno about Windows. (Probably?)
The trick with `context.Value` is to write use-specific tiny wrappers that are the only ones that use the context key, and take &amp; return strong types. That isolates the rest of the app from the `interface{}` and avoids the dynamic uncertainty. See https://blog.golang.org/context examples, package `userip`.
your alternative semantics is literally the exact same code with a different comment??
Yes. Semantics = how the code is executed, the meaning of the code. I show two ways of interpreting the same code.
FYI, in your first paragraph. "A good example is http.Flusher" is a link to http.Pusher. You probably want to fix that.
Pretty sure for-loops use a single scope until they complete execution, FYI. Similar behavior caught me off-guard in JavaScript with asynchronous callbacks before I learned about closures.
I'm not sure, the inner function makes the defer behavior explicit following simple rules. The code is also telling me to refactor it into two functions. The code is verbose, but I don't see any wast in semantics. What would an alternative look like?
hmm, in the context of talking only about the semantics of defer (by adding in the additional code block you make it seem like you're also trying to demonstrate different syntax), deferring just in the scoped context seems unnecessarily. Generally, scoped areas should be reasonably concise (or often ripe for refactor). If you need the 'scoped' symantics wrapped in an iife, as the top poster commented, or just don't use defer f, _ := os.Open(filename) err := doSomething(f) if err != nil { f.Close() return.... } Granted it could protect a little more against lazy error handling within a given scope. If anything, given people really wanted scoped defers, I'd rather have a second keyword, like `scdefer` 
The alternative would be that a deferred function is executed at the end of the scope / curly-braces block. So you could write your code like this: func openManyFiles(filenames ...string) error { for _, filename := range filenames { f, err := os.Open(filename) if err != nil { return err } defer f.Close() doSomething(f) } return nil }
Just to be sure, the whole function is also a scope. And thanks for an opinion.
What problem is this solving? I can think of several problems it would create... namely that you're defeating the TTL mechanism of a cache, doing so unpredictably, and in a way that's not obvious to the maintainer of the cache. 
Here is a nice example in influxdb's optional gzip content-encoding : https://github.com/influxdata/influxdb/blob/8bb80321d9bfe9f46a07ee43131ad96e355ae336/services/httpd/handler.go#L627 Rather than scopes in the if it defers closing the compressor at the end of the func 
Here is a nice example in influxdb's optional gzip content-encoding : https://github.com/influxdata/influxdb/blob/8bb80321d9bfe9f46a07ee43131ad96e355ae336/services/httpd/handler.go#L627 Rather than scopes in the if it defers closing the compressor at the end of the func 
Alright, that's a nice example. A lonely one, but nice.
Just thought I'd mention that most `Close` implementations are idempotent, or at least tolerant of being called again. You can usually just do this: func openManyFiles(filenames ...string) { for _, filename := range filenames { f, _ := os.Open(filename) defer f.Close() // guarantee you don't forget doSomething(f) f.Close() } } Also FWIW files are closed automatically anyway: // NewFile returns a new File with the given file descriptor and name. func NewFile(fd uintptr, name string) *File { fdi := int(fd) if fdi &lt; 0 { return nil } f := &amp;File{&amp;file{fd: fdi, name: name}} runtime.SetFinalizer(f.file, (*file).close) return f }
i do the same thing -- i use an anonymous function to limit a defer's scope.
or add another keyword like 'delay'.
Yes, the way slices are designed in Go requires the programmer to be mindful of ownership to ensure correct usage. Alternative designs exist which eliminate this as a concern. This doesn't mean the design of Go slices is wrong or bad, as there are tradeoffs involved in these other designs. However, it does mean that this is a legitimate point of critique. I'm not convinced by the argument that making something easier to trip over early really helps prevent bugs in real code. Yes, people might be mindful not to misuse the slices returned by bytes.Split (something which could be prevented entirely with capacity slicing), but that doesn't mean that they won't make mistakes in the more nuanced situations which capacity slicing wouldn't address. An example is that people new to C trip over invalid memory accesses early and regularly, and yet buffer overflows and use after free bugs, some trivial and some obscure, have been and still are regularly shipped in production code.
An example is this code used to enable profiling from the [Go Blog](https://blog.golang.org/profiling-go-programs): var cpuprofile = flag.String("cpuprofile", "", "write cpu profile to file") func main() { flag.Parse() if *cpuprofile != "" { f, err := os.Create(*cpuprofile) if err != nil { log.Fatal(err) } pprof.StartCPUProfile(f) defer pprof.StopCPUProfile() } ... This relies on being able to conditionally defer code to function exit, which you couldn't do if `defer` were block scoped rather than function scoped.
I sometimes get some flack for calling Go a 21st-century scripting language, considering it is statically typed. But this is one of those things that makes me say it. I still greatly prefer Go's ability to _definitively_ answer whether an `io.Writer` I have is also an `io.Flusher` to the vague duck-typed languages, but otherwise Go takes a relatively script-like approach to this problem. The languages that are more strongly-typed would generally write the core function to rigidly require all interfaces you're going to use, and require adapters to be wrapped around a value that may be lacking a given interface to make it conform. An example of this I've encountered several times is that if you want to _correctly_ extend an `io.Reader` or an `io.Writer`, you really ought to check for the underlying value being an `io.Flusher` as well, and correctly handle that. A "correct" statically-typed function would require you to declare a new `ReaderFlusher` interface (or `WriterFlusher`), which your new function uses, and then require all users to wrap their values if necessary. You can do this in Go right now: type FlushWrapper struct { io.Reader } func (fw *FlushWrapper) Flush() error { return nil } However, this has a major consequence of its own which is that what will be wrapped into the interface at that point is the &amp;FlushWrapper, not the underlying object, so any other code that queries for interface support will be querying the FlushWrapper and not the wrapped value, which could cause other problems. This can further cascade into composability problems if multiple packages independently try to extend values like this; a given wrapper will "win" and thus you must go to even more effort to create your own multi-wrappers if you go this route. Or, you just let the original object implement multiple methods, as Go does today. I disagree with the author here; this is a _very_ "Go" way of doing things. Go is not a strongly-statically-typed language. It's the statically-typed language that comes closest to being dynamically typed, in my opinion, for good and for ill. (Contrast this with "statically typed languages with an outright dynamically-typed subset", which is also an interesting category but not what I'm talking about here.) Any other solutions will very likely have their own weaknesses. That said, I would continue to strongly agree that interface assertions on things you already have in a non-empty interface is certainly a _code smell_. Part of the way the community mitigates the problems mentioned in the blog post (which certainly exist) is... don't do that. It's something for an application to do, not for a library to go crazy with, in most cases. (Though I can make a case for flush-aware Reader and Writer extensions.)
Yes, sometimes there is no failure so the success lives inside the if. Eg. f, err := os.Open(filename) if err == nil { defer f.Close() /// Do something with f but it needs to stay live until we hit a return } Also cases of logging in main like: logf := os.Stderr if loggingFilename != "" { logf, err := os.Create(loggingFilename) if err { /* blah */ } defer logf.Close() } ...although in theory leaking a file from main() is "ok", if you just removed it (dito. defer closing os.Stderr if you moved it out of the block as a workaround). My assumption is that this was done so the compiler didn't have to optimize out all of the block scope defer checks, and even if it might be better I don't want it to change.
Thank you for your thoughts. I agree that there's a definite good/bad line when it comes to custom implementations and removing safety, and I tried to be very explicit about then point at which I thought I was crossing that line. I'll be sure to keep your perspectives in mind for future articles.
Thank you for the suggestions on specificity of the interface/arguments. I agree that an `io.Reader` is more appropriate than a pointer to a file handle, and that's what I would use were I to put something like this in production. Great tip!
I've considered adding something like this to [Ply](https://github.com/lukechampine/ply). Other languages have constructs like `with` that automatically call a destructor when the scope ends. It would be nice to have something like that for Go. (It would also be nice if `defer` had no overhead...)
I do this fairly often for CLI tools (with stdin, usually), so it's been a recurring thing. Scope-based defers would make for a much more annoying flow here of likely needing a nop closer for stdin and deferring scope at the root of the function. Aside from that, there are also cases where I'll defer cancellation of a context inside of a conditional, but only if there was a timeout or something else configured. That's another case where I'd need a nop function, since the alternative would be using a conditional and goto to jump over a defer at the root of a function (because the conditional would introduce a new scope for the defer). There's little to gain, in my opinion, by having scope-based defers. The moment you need one, the correct answer always seems to be to write a new function. (This doesn't mean there's nothing to gain – only that I don't see much from my POV.)
This is well-written and made me smile.
Re-read my post title. TL;DR "could we add new concurrency models to Go 2"
Good iead :)
go back to promoting your framework(i know you dont want it to be called a framework because gophers hate frameworks) at every golang conference
[removed]
I'm currently working in a Go code base with tons of optional interfaces and it's *awful*. Except it goes farther by usually being interface{}.
&gt; Some of them have workarounds (see below), but all of them have drawbacks on their own. &gt; […] &gt; There are alternatives, though they also are not entirely satisfying. How could I have made it more clear, that none of the workarounds solve all of the problems?
Lonely? I don't think have `defer` inside an `if` or `else` is that uncommon. Remember that `defer` is not only for closing resources. You can also use it for logging and other stuff.
I had the same thought. Then I thought a little bit more and realized that this (usually) doesn't qualify. Code using `interface{}` usually either a) isn't interested in the data *at all* (e.g. `container/list`) and just passes it on, or b) uses reflection to walk it, in which case none of the drawbacks apply at all. If you have a contrary example, I'd be interested.
Thanks :) It seems unavoidable, that one or two of these kinds of errors always makes it in :)
I haven't thought about it too much. I've read the spec, understood the behavior, and used it as it's documented. It works well and I'm happy to focus my attention on my task at hand.
Need more info like a link to where in code it happens, sounds line an os.Exec on a prog that is exiting without reading from stdin fully or at all.. if so show me the exec statement. Likely need to change how you exec the program in windows or are getting permissions issues etc.
&gt; The languages that are more strongly-typed would generally write the core function to rigidly require all interfaces you're going to use, and require adapters to be wrapped around a value that may be lacking a given interface to make it conform. An example of this I've encountered several times is that if you want to correctly extend an io.Reader or an io.Writer, you really ought to check for the underlying value being an io.Flusher as well, and correctly handle that. A "correct" statically-typed function would require you to declare a new ReaderFlusher interface (or WriterFlusher), which your new function uses, and then require all users to wrap their values if necessary. I don't really understand what you are saying here. The basic issue is, that you don't know, at compile time, what method set the wrapped `Writer` will have and that enumerating all possibilities is untenable. Say you have something like [io.LimitReader](http://godoc.org/io#LimitReader). It has a required interface and a provided interface and both are `Reader`. It is fundamentally correct, that the required interface is `Reader`, as that is the only method required to make counting work. Restricting it further would mean, that your function becomes unusable with a whole lot of types that don't allow anything but `Read`. Also, what would be the correct set to restrict it to, because literally *every possible* method could be used as a de-facto optional interface. If we accept, however, that `Reader` is the correct *required* interface, how are we supposed to provide a different provided interface? The underlying issue here, is that you a) want to overwrite the Read-method, b) don't want to change the method set apart from that and c) don't know at compile time, which other methods might exist. So, in short, I guess: Can you give an example of how a "more strictly typed" language would solve this kind of "passing through API boundaries" problem? For example, how would, say, java (or a strictly typed language of your choice) implement `LimitReader`? Because I definitely want it solved; the composability and power of go interfaces, in my opinion, hinges in large part on these kinds of wrappers.
As somebody who has posted "stupid" questions before here, this same guy (epiris) has replied and been nothing but nice, as well as explaining in great detail what is going on. If you post "Fucking go slices" don't expect a kind reply :P. If he posted something like "Weird behavior with slices, what is going on here?" he might have gotten a polite reply.
I think this is much more interesting than the linked website as it proposes a solution that seems like a fair tradeoff to me. Disclaimer: I created both the issue and the website (for internal jokes after a day of debugging a "buffer overflow") 
You're absolutely right that *most* Go code that uses empty interfaces uses them as you describe. I'm on mobile, but I'm taking about functions that accept empty interface values and then do type switches or type assertions (sometimes inside of other type switches/assertions).
But you don't know when the finalizer is run. So there is a risk for many open files as garbage. However it's good to know. 
TL;DR If you are really serious about this then you should create a concrete proposal that describes why, what problems it solves, how it is going to be implemented (language change, library, tooling), the impact on existing codebases etc.
I'm a bit late to the party, but rounding is a bit more complicated than it first appears. https://www.cockroachlabs.com/blog/rounding-implementations-in-go/
&gt; I think the issue may be caused by my router using :8080, which is the same port my render package uses to launch its web server. Why are you using two servers? The package you import should expose an `http.Handler` which you will then use in `main.go` as a second argument to `http.ListenAndServe(":8080", handler)`.
Type switches or -assertions with interface types? It would be helpful if you could link to an example, once you're back on a Computer :)
Just for you: It's okay to propose a different semantics. Making your point by using wrong code as an example to show the current behavior is "bad" is wrong.
My bad, I did misread a key word: &gt; Lately though I’m working on a project in Go where generics would mean less and clearer code. Personally I’d love to see something like Typescript’s generics with their ability to interface on both methods and data. Can you guess which one? :) Thanks for the catch and keeping me honest.
ahh, that makes sense.
[Writing Web Applications](https://golang.org/doc/articles/wiki/) is a great resource for writing a webpage from scratch using Go. It walks you through building a simple wiki using go's `http` and `template` standard libraries.
Any decent API should have a 1:1 mapping of responses to status codes for each endpoint, so this shouldn't be an issue for APIs. Approaching the problem in a more general way, you could also Unmarshal the data into a struct. If required values are missing, then Unmarshal your second struct. Repeat until you get a populated struct.
&gt; Please stop being a jerk. Said the guy who called someone's project "harmful" and then locked GH issue so the project's maintainer cannot answer.
Usually when we are talking about a simple and well-designed API, as you mentioned, we are talking about 1:1 mapping. Each endpoint returns a standard response. But it can also return a standard error. This does not need a more generic and complex solution.
Actually I'm bit surprised why nobody gave you a proper answer. The thing is - bytes package (and by extend the Split) function comes from Go 1.0 and before. But the three index slices (aka slice with capacity) had been introduced in Go 1.2 ( https://golang.org/doc/go1.2#three_index ). So yeah - it's a weird behavior and could have been done better. But because of backwards compatibility promises we can't change the behavior of Split function. This is a subject for discussion of course, but I think this is why things are like they are. 
fucking-python-lists.com a = [1,2,3] b = a print a, b a += [4] print a, b Output: [1, 2, 3], [1, 2, 3] [1, 2, 3, 4], [1, 2, 3, 4] fucking-js-arrays.com a = [1, 2, 3] b = a console.log(a, b) a.push(4) console.log(a, b) Output: [1, 2, 3] [1, 2, 3] [1, 2, 3, 4] [1, 2, 3, 4] If you want halfway decent performance, you have to find a way to share storage and avoid copies. slices are Go's way of doing that (which is what distinguishes them from Go arrays). Just learn to deal with it, it has huge benefits.
&gt; However, existing APIs, like bytes.Split, haven't/can't change to take advantage of this Why couldn't they? I can see nothing in the API about the capacity of the returned slices. It would require using build-tags, but might be deemed worth it?
That would only prevent this particular instance, though, not the general issue of sharing a slice with something appending to it. I kinda hope in go2 they swap the behavior of slicing around and make a[i:j] mean "slice a from i to j and set capacity to j-i" and to make a[i:j:k] mean "slice a from i to j and set capacity to k-i". Would mean a) that most usages of slice would automatically cap, so appending would be safe-ish and b) that the order of indices better reflects the relationship of 0 &lt;= len(a) &lt;= cap(a).
That could be worked around with build-tags; the API doesn't mention anything about the capacity of the returned slices (and I can't really imagine people depending on it, tbh).
One could go with the java approach and allow default implementations where possible. You could then theoretically upgrade ResponseWriter with a new flush method that wouldn't do anything (or panic, or something else, depending on the need), and specific writer implementations can provide the flush method. The user will be able to call those methods without fear that they are missing, and they will quite possibly do something useful. type ResponseWriter interface { Header() Header Write([]byte) (int, error) WriteHeader(int) Flush() { panic("Flushing not supported.") } }
&gt; fucking-go-slices is maintained by GetStream. I have hard time believing that a private business can support this kind of childish behaviour. Really?
I don't see how it's childish. Unprofessional maybe, but 'childish' is a bit of an exaggeration
Not being able to control emotions and finding something to blame or offend? In my opinion childish.
Interesting! However I am not sure to understand the reason and advantages behind this. You mentioned that the benefits were mostly the simplified configuration and the support for load balancing. These two things can be achieved with gRPC when you introduce consul for service discovery. Same for metrics or anything that can be added with middlewares(called interceptor in the gRPC ecosystem). And since consul is only used for service discovery, there is no bottleneck with high throughput and streaming is supported :)
Your both examples ARE different from the provided one. Both JS and Python are in fact aliasing the same variable, so push affects both. In Go however, the situation IS different because: slice1 := []int{1,2,3} slice2 := slice1 slice1 = append(slice1, 4) // slice1 != slice2 But that is not relevant at this moment. In go, Split returns the slice of slices, and it's difficult for beginners to wrap their heads around the fact, that slices are just "views" with capacity.This is why append works in _"mysterious"_ ways sometimes. Edit: examples and clarification.
The problem is that this site doesn't provide you with any sort of solution to this problem. It just states that there is somewhat weird behavior/ And nothing else. 
Rather, just use play.golang.org
Much this. Also why the creators of http://go-database-sql.org/ did not just make http://fucking-go-database-sql.org, but instead listed and explained all quirks? This is mature behaviour in my opinion.
 - defer is slow and bad, don't use defer + Land_Apple is slow and bad, don't listen to Land_Apple
Ah, kind of suspected it but didn't know. Seems like a good rule if your slicing an existing slice that is being returned, limiting the capacity seems a good rule to follow. 
&gt; Your both examples ARE different from the provided one. Yes, because they are in a different language. But what I was trying to illustrate, is that this kind of confusing idiosyncrasies are inherent to the model of sharing memory for efficiency. Hating on go for one of those idiosyncrasies (and yes, that's what this website is) is just irrational. All languages have them and this particular one isn't even really specific to go. For example, if it where as simple as &gt; Both JS and Python are in fact aliasing the same variable then this python-behavior wouldn't be as surprising: a = [1, 2] b = a a += [3] print a, b a = a + [4] print a, b Can this be explained? Of course, that's pretty much the point. But a) it will always be confusing to beginners, when they stumble over it for the first time and b) it isn't necessarily *bad*. It's idiosyncratic but probably there for good reasons. These things *will* happen in any language and using any language will require learning them - most of the times, the hard way. &gt; But that is not relevant at this moment. In go, Split returns the slice of slices I agree, that the behavior of `bytes.Split` could be changed and maybe should (though I'm not terribly convinced either; it's possible to go from the uncapped slices to the capped one, but not the other way around. So *if* someone requires an uncapped slice, say for performance, they'd be out of luck with the changed behavior). But I honestly believe, you are misattributing the problem. This is *one* instance of a wide range of bugs caused by the append-behavior. Learning when and how to use `append` and/or finding a different solution for that wider issue is far more relevant than fixing this one particular instance.
&gt; You could then theoretically upgrade ResponseWriter with a new flush method that wouldn't do anything (or panic, or something else, depending on the need) The issue is that *none of these really help*. A nop is the semantically wrong thing to do on a `Flush` and panic'ing is exactly the same consequence as a failing type-assertion. If this would be a solution, you could just as well currently do func MaybeFlush(r http.ResponseWriter) { if f, ok := r.(http.Flusher); ok { f.Flush() } } In essence, this would do the same thing as what I replied to with [this comment](https://www.reddit.com/r/golang/comments/6qicgc/the_trouble_with_optional_interfaces/dkxsuf1/) and the same caveats apply.
It's not an equal example, as you don't handle doSomething() error return. Is rewriting as: err = doSomething(f) if err != nil { return err } somehow worth the rewrite? I don't think so, at least not in this particular case, xiegos example is clearer. And since it's a closure, the go compiler will do it's best to inline that code, so it's really just the difference of what you deduce from reading those 10 lines, the actual code output should be very much equal between the two.
In my experience these IndexByte, Index become bothersome, so I did a DSL where this parsing sequence firstTab := bytes.IndexByte(line, '\t') secondTab := bytes.IndexByte(line[firstTab+1:], '\t') + firstTab + 1 thirdTab := bytes.IndexByte(line[secondTab+1:], '\t') + secondTab + 1 key = ... val = ... describes as rule = _ '\t' # pass all characters until TAB inclusively Key(int32) '\t' Value(int32) '\t'; And then it is translated into // rule autogenerated parser type rule struct { rest []byte Key int32 Value int32 } // Parse autogenerated method of rule func (p *rule) Parse(line []byte) (bool, error) { var err error var pos int var tmp []byte var tmpInt int64 p.rest = line // Looking for '\t' symbol and then pass it pos = bytes.IndexByte(p.rest, '\t') if pos &gt;= 0 { p.rest = p.rest[pos+1:] } else { return false, nil } // Put data before '\t' into Key if pos = bytes.IndexByte(p.rest, '\t'); pos &gt;= 0 { tmp = p.rest[:pos] if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&amp;tmp)), 10, 32); err != nil { return false, fmt.Errorf("Error parsing \033[1m%s\033[0m value as int32 for field \033[1mKey\033[0m: %s", string(tmp), err) } p.Key = int32(tmpInt) p.rest = p.rest[pos+1:] } else { return false, nil } // Put data before '\t' into Value if pos = bytes.IndexByte(p.rest, '\t'); pos &gt;= 0 { tmp = p.rest[:pos] if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&amp;tmp)), 10, 32); err != nil { return false, fmt.Errorf("Error parsing \033[1m%s\033[0m value as int32 for field \033[1mValue\033[0m: %s", string(tmp), err) } p.Value = int32(tmpInt) p.rest = p.rest[pos+1:] } else { return false, nil } return true, nil } It is a bit more potent of course. More details here: https://github.com/glossina/ldetool 
This is cool! I'd like to try using this to implement a sort of hard coded yet semi-dynamic intent recognition, this could make my life a lot easier :). The named entity extraction will be really awesome!
More web dev than Go, but almost all of the tooling involved is written in Go, so I figured that makes it relevant.
Let's say we have types A, B, and C. A is `type A struct { io.Reader }`. B is a Reader with a WriteTo and C is a Reader without a WriteTo. Under current Go rules, A automatically gets a `Read` method. Under my rules, it would get a `WriteTo` method when the underlying concrete type was B but not when the underlying concrete type was C. I see what you mean about it not being in the spirit of Go to have explicit declarations, but OTOH, this would prevent the exponential explosion of method combinations problem, and in most cases the core interface should know about the optional methods.
I stopped reading at Method Overloading. I think OP is misinformed about the concept of Method Overloading. 
Sometimes you do things a different way than you normally do to change things up, because the deviation from what may have became mundane can create a little something people like to call "fun". 
If I were to type in the console while the bot was connected, these lines trigger the error https://github.com/FactoKit/FactoCord/blob/master/main.go#L81-L92 If I were to send a message on discord while the bot was connected, these lines would trigger an error: https://github.com/FactoKit/FactoCord/blob/master/main.go#L157-L161 
Both Python and JS variables can be explained using somewhat formal arguments about the fact that any complex type is a reference type there. This is why things work like that - you are essentially mutating the same thing. In Go its different. Slice have a value semantics until they don't. They don't share the length and the capacity. But they CAN share the underlying chunk of memory. There are also somewhat weird things, like the small slices occupying huge amounts of memory due slicing (even with capacity). Why? Because Go will never reallocate on slicing those it cannot free the underlying chunk. This is norm to you and me, but for the new developer it can be quite surprising. I come to a simple, if not accurate, analogy with real life. I treat them like windows - the ones you install in house or in car - each window can have a unique different size and shape. They do not share it. The view on other side however can be shared between many windows in many different variations. 
Wondering if this will solve my current workflow issue with dep that I did not have with Godeps, in that... Developing Pkg A, pkg A has a cmd/server folder which has a built binary (let's call this Cmd B) Cmd B imports Pkg A. With Godeps, I could work on Pkg A, and simply godep update ./... and my changes to A would be there. With dep I need to commit, push to remote, then go into Gopkg.toml update if necessary, then pull down again with remote. Just wondering if there was a way for dep to know if my local package is more up to date than the remote. Maybe set some variable in the toml so it knows I am the developer and its okay to do this?
You didn't include the command. Reduce all the noise into the simplest case is my best suggestion. Windows almost always boils down to acls or cmd syntax / availability with these sort of things, also I would capture the exit code, all stderr / stdout to teewriters for debugging.
This probably would have been the best design, I can't think of any scenarios that it puts you at a inconvenience really. When you are setting a range linearly by idx you usually make to a given len, when you over allocate and fill partially you make with a cap and 0 len and leave rest to append.
Virtualgo should solve your problem then. Although it won't detect automatically if local is newer than the remote one. You can easily override the remote one with the local one by doing: vg localInstall github.com/user/pkgA This changes the version used in your workspace to pkgA to the local one, until you do a `vg ensure` again. You can even keep the local one persist over `ensure`s by using the `-p`/`--persistent` flag of `vg localInstall`.
How about this. Please don't call people fools here. Especially when it has to do with failure to understand something about the language. Yes, even if they start off with an aggressively titled post. I think we've all said "fucking xxx in language yyy" when programming at some point. It's frustration, and we've all felt it. We were all newbies once. I remember taking a whole day debugging why returning a nil pointer as an interface didn't return a nil interface, among many other mistakes.
OOP is a bad joke. Just make something that does something. FP is perhaps a more helpful abstraction, but even then, it's more important to produce a basically working prototype than to hop onto the dick of lambda calculus.
+1 for go-task/task, been using it a lot in my current project, real time saver I run a blog using Hugo too, though, I use Caddy to serve the assets, which has minify and gzip extensions, it might not be the best solution, but I found it work pretty well for me. I also use github webhooks /w http.git extension to rebuild blog on git push. I wrote a post about it on that blog, poorly as I have little to no experience in that, but here you [go](https://zeta.pm/blog/building-this-blog/). (but yes, my pipeline is entirely Go based too)
Awesome! Please, one thing. I guess this is just personal opinion, but this business of moving the axes slightly such that they never can come together in the origin is, in my opinion, very ugly. If you decide to keep this feature, I would like to be able to turn that off with some setting. I mean this: http://imgur.com/BMUakZB
(Settle in kids!) While doing my bachelor thesis in QM, I had to construct an optimization algorithm better suited to my needs than any of the native ones I had accessible. 3D plots were crucial for displaying my progress during that work, and I ended up using a 3D plot in both my thesis (which admittedly was somewhat hard to read), and in my presentation I made an animation that displayed the results. Like this: http://imgur.com/a/UN7nQ Of course the plotting tool I was using at the time was interactive. So I guess I won't really be happy until I can do the same in Go.
^(Hi, I'm a bot for linking direct images of albums with only 1 image) https://i.imgur.com/XRCs2sA.gifv ^^[Source](https://github.com/AUTplayed/imguralbumbot) ^^| ^^[Why?](https://github.com/AUTplayed/imguralbumbot/blob/master/README.md) ^^| ^^[Creator](https://np.reddit.com/user/AUTplayed/) ^^| ^^[state_of_imgur](https://np.reddit.com/r/u_imguralbumbot/comments/6i1huv/imgur_has_gone_to_shit) ^^| ^^[ignoreme](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=ignoreme&amp;message=ignoreme) ^^| ^^[deletthis](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=delet%20this&amp;message=delet%20this%20dkytjac) 
I didn't call them a fool, I said they looked like one. I didn't say they looked like a fool because they didn't understand something, I said they looked like a fool for registering a domain with explicit language to criticize a subject they could have understood with much less effort. In addition I've never once called someone a fool for failure to understand a topic and never would, I go to great lengths to advocate security and general programming knowledge here. My post was a little harsh I don't deny that, but let's not pretend it didn't fall short of the ops expectations in that regard. I answered a question he didn't bother asking while giving the op a little of the reaction he wanted.
Thanks, building funny things make learning easier :)
Dep now also points to VirtualGo as an official recommendation: https://github.com/golang/dep I've been using this since Jelte created the tool, it works really well so far.
anytime. another good source to articles to learn from are the gophercon posts and the advent posts that happen at two different points throughout the year.
OOP has its uses, I can't knock it as an idea, though I think it's horribly abused by design pattern zombies. Go's strength is its simplicity, trying to do bastardized OOP in Go is just driving a nail with a screwdriver.
If you have used virtualgo before and have old workspaces that you want to convert to full isolation, you should do: vg destroy workspace vg activite workspace
I personally won't be able to help unless you reduce your code to the smallest reproducible case, we won't all set up a Factorio game server and create a Discord app to test it. Although I don't think that's related to the error and I'm not the most experienced user when it comes to spotting race condition but you seems to have one with the Pipe variable here. If I'm wrong I hope someone will correct me so I can learn and I'll edit my message accordingly. Pipe is a global in main.go. It's initialize inside a goroutine on line 61. It's used in a second goroutine on line 88 (no guarantee that line 61 was executed at this point), line 105 will execute before the 2 goroutine as it's synchronous code and so line 112 will pass the address of an uninitialized pipe to the admin.P global.
Just the thing I was looking for today, thanks for the thorough post!
yeah... I tried to also get rid of that: - https://github.com/gonum/plot/pull/245 - https://github.com/sbinet-gonum/plot/blob/c9e6ee6b18f0d9adbefa82edf2521f041a382f79/plotter/testdata/histogram-custom-style_golden.png but didn't find a way that was acceptable by all parties. in the end, I gave up on this (temporarily?)
&gt; Add to that what /u/0xjnml said. Look at the implementations of Int63, Uint64 and Uint32 -- there is no way to unify those generically. Of course, there is. The internal implementations have nothing to do with the public API.
defer is function scoped because that allows the implementation to cost significantly less. You don't put try-catches in tight loops for the same reason you don't put a `func(){defer()}()` in a tight loop loop. You get extra frames and calls and checks. If defer was lexical scoped additional frames would need to be created. 
You can't say "of course you can unify the implementations" and justify that by referencing the difference of internal implementation and API. The point of the sentence you quoted was, to show that adding generics to `math/rand` is not useful for the implementer of the package. The paragraph before that shows that it is not useful for the user of the package. Together, that means it's not useful for anyone.
API feedback: why bother making the different hashes return the same type, when `Distance` won't work across them anyway.
It might be my miss design API. My intent was reducing duplicate codes(because they are using same hamming distance algorithm.) and simplifying using hash type. also, it makes easy to load hash type from a database by using `NewImageHash`. But your feedback looks reasonable also. I never thought about that.
[removed]
I benefit greatly from it being well optimized. https://research.swtch.com/goabstract
That's not true. Scoped-based semantics allows for much more efficient implementation. You can just statically put the deferred function call to all places where the scope ends, such as break, return, end of scope, ...
In case you're the author, it's "Go" and "Golang" is a little search engine hack (as far as I've heard).
That's interesting! I have been introduced to go some weeks back. Most of the code I write is error handling in go. Is there a alternative way? Why has go community decided to take this approach? 
Interesting, I didn't know that. 
You'd need something similar to C++'s template specialization feature.
Please explain: &gt; but many companies are struggling to adopt Go due to a lack of support
"Golang" is officially only used in the domain name golang.org. The name of the language is simply Go.
I suggest to make something based on your interests. It's difficult to suggest you something without knowing more. Are you leaning towards web applications? Server code? Maybe command line tooling? One idea is to try and make something that automates a common task you do every day. Of course that can be quite hard because if you search there's probably already code that exists and does what you want. Maybe you can make something smaller and tailored to your needs. Another idea and probably one of the easiest things you can make is a client for a public API. Maybe there's a site out there that has a public API but no Go client exists. Just make sure that the API is small. If you happen to go with this idea, there's already a very good client for [github](https://github.com/google/go-github), nice and clean codebase which you could use as a guide. In general I'd suggest to try and make something that scratches your own itch to keep it interesting for you.
Looks like I'm going to have to go through my post and make some updates :) Thanks
Well, I think it kind of makes sense with the concurrency model of Go. However it does make it hard to keep your code DRY and fully tested. Its definitely something that I'm going to need to read up on more. I think I might start looking at some larger projects written in Go (like docker) and see what patterns they use to handle errors. 
 Whenever I hear someone complain about too many: if err != nil { return err } I am like that is all the places your shit usually breaks Source: u/kris-nova on the twitter (https://twitter.com/Kris__Nova/status/881342445157527552) EDIT for clarification: I know that you weren't complaining, u/aakashchan24. Your question just reminded me of this, and I thought it might help to provide an answer.
So, I'm learning this for a business. One of the business partners made something in go and we'd like to expand on it and continue to develop it. 1 of us is fluent in it and the other 2 are learning. I like the suggestions. Im so beginner at this but I've been used to learning from a class. Like I have 3 or 4 programming text books at the house but nothing for go. I also dont program for my job currently. That's not to say this wouldn't be useful for my full time job as well though. 
&gt; So, I'm learning this for a business. One of the business partners made something in go and we'd like to expand on it and continue to develop it. 1 of us is fluent in it and the other 2 are learning. So it seems you already have something to work on. Why don't you work directly on that and learn on the go? It's going to be hard no doubt but it will probably be faster. Also if one person is fluent they might also be experienced enough with the project to give you a small piece of work to do based on your current skills.
One of my most commonly used aliases right now, which I run pretty after finishing every commit, before pushing: alias ci='go test -race ./... &amp;&amp; gofmt -d -s .; go tool vet .; megacheck ./...; unconvert ./...' `megacheck` is `staticcheck` + `gosimple` + `unused` in one. The tools are really helpful and let me focus more of my attention on catching remaining issues—other than ones that I already know `staticcheck` can catch. I'm very thankful to Dominik for creating these and doing such a fantastic job of maintaining and actively developing them further (e.g., see https://github.com/dominikh/go-tools/issues?q=is%3Aissue). I hope companies support this, so he can spend more time on further development, which benefits the entire Go ecosystem.
Does anyone look at this subreddit for another reason that is not kataras? :P
That's actually a great idea. Thank you!
If you just want simple tasks to work through to get familiar with go I would suggest http://exercism.io/ I really love their approach 
It only makes it harder to fully test in that you end up testing more failure mode than in other languages, which is a good thing. The alternative to handling errors isn't just having them not occur it's just not planning for them. If you don't plan for errors are you sure you're fully testing things?
Why type PublicStructName struct {} type privateStructName struct {} The public/private are redundant with capitalization. Just type StructName struct {} type structName struct {} Though, personally I find it comes up much more commonly with functions than structs. With structs you can selectively choose which parts are public and private.
Have you tried converting to Canonical XML before comparison? https://www.w3.org/TR/xml-c14n
defer must execute even during a panic. So you can't do that in such a simple way do to how stack unwinding works.
There is golang plugin for SonarQube -&gt; https://github.com/uartois/sonar-golang
https://github.com/alecthomas/gometalinter seems to support staticcheck and a bunch of others
You are so missing the point...
I'm not sure I follow. Gometalinter uses the tools that this post is advertising, so we don't need the tools this post is advertising? There are certainly things you could discuss like if there's a better way to ask for investment or if the offer is reasonable for the price requested but the presence of the tooling is undebateably useful.
I was a little startled by the mention to use context.Value (although I make use of it extensively I am trying to get out of that habbit) because using it to modify behavior is considered a bad practice since it creates an undocumented side-channel API, or basically the same problem you run it with optional interfaces.
I think he used a different meaning of the word "support" than the one in title. His comment just notes that gometalinter is a useful project that includes staticcheck checks, so it'll also benefit from staticcheck improvements.
This is such a great question, and thanks for the twitter props charliegriefer! Error handling in Go is (almost) completely enforced.. meaning that the beauty of writing go is when you get `a, err := somefunc()` and you realize you have no way to handle the `err` in your current context, that you have officially reached the part in programming Go that says &gt; This is a sign you need to make a change, to handle errors better here. It's annoying, but the reason it's such a prominent part of the language is so that developers are inadvertently "encouraged" to write better, and more resilient code. Some say this is "enforced error handling" but in theory you could always ignore errors `a, _ := somefunc()` But that is grounds for a swift kick in the knee on pretty much any Go project you will work on, so please don't do it. More resources on errors in Go you should check out: 1. https://blog.golang.org/errors-are-values 2. https://blog.golang.org/error-handling-and-go 3. https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully
sorry if I wasn't clear in the post. I wasnt trying to say that you should prefix your structs with `Public` and `private`, just that the case would make it public or private. I guess I could also have written: type StructName struct {} //Public struct type structName struct {} //Private struct 
Sidebar: be thoughtful in how your communicate.
I totally agree, which is why I like Golang's error model in general. The problem is that it can be hard to artificially induce errors to test some of the error handling code. An toy example of this would be `os.MkdirAll`, which will rarely cause issues in normal use, but it can also be hard to induce errors in third party libraries. 
If its only a few variables, do something like getX() in your interface. 
This would force interfaces to behave significantly different from the way they do in Go 1.x Let's say you have a struct S that implements an interface I and that interface defines a variable V. When S is used in a place defined as an I for the first time, where does the value for V cone from? When that use of S as an I is no longer in scope, how does the value for V get preserved until the next use of S as an I? Whatever the merits of this proposal, it is at odds with Go 1.x interfaces. At best this would have to be a new kind of mechanism that would replace interfaces altogether or would have to exist alongside the current interface mechanism. Seems like a showstopper.
The main issue is you are enforcing more than behavior with this type of an interface. You're also defining mutability and thread safety. With interfaces if you want to add locking in front of a existing interface it's easy to wrap it with a Mutex, this pattern would be impossible with fields. I imagine most of the time you would want a group of fields in a interface, a better design would be a State() method that returns a snapshot of the fields you want to expose. Replacing state with something more appropriate to whatever it is. You could always have a Save method on the State struct to handle thread safe saving or a Update(s State) error method in the interface to commit it to the object. 
dotGo 2015 - Rob Pike - Simplicity is Complicated https://youtu.be/rFejpH_tAHM "interfaces are just set of methods.. people ask for variables there too all the time.. they ain't gonna get them" 
Ah! That I agree with.
&gt; I was a little startled by the mention to use context.Value So, first, to be clear, I also said explicitly that the workarounds have their own drawbacks :) &gt; using it to modify behavior is considered a bad practice since it creates an undocumented side-channel API I know that some people view it that way, but I tend to disagree. I view the ability to traverse API boundaries essential to build useful abstractions. And especially for networked, request-based servers (be it HTTP or RPC or…), having a notion of scoping things to a request seems pretty much essential and that's what `context.Value` does. When I debug my server, I am most often interested in debugging a single request (or a set of requests), as that's the level of isolation that is interesting. Scoping debbuging-tools like loggers is *immensely* useful, to not have it interleaved with noise from other, concurrent things. The same goes for example for authentication data, which should be request scoped. Or all kinds of things. It's unreasonable to expect any http-middleware to be aware and explicitly pass on anything the user might need. For broad reuse, it is very important that middleware sticks to something like the `func(http.Handler) http.Handler` pattern. And there is simply no way to scope, say, a logger to a request using that pattern, without *some* form of `context.Value`. `context.Value` has its drawbracks (IMO mainly its performance), but for a language like go, it is really important to have. &gt; basically the same problem you run it with optional interfaces. Part of the problem, yes. Other parts, not so much. The lack of static type safety vanishes (which is why the general guidance is to not put required functionality in a `context.Context`, but yeah, that doesn't necessarily help). It is inefficient, especially if you put a significant number of keys behind it, as it's just a linked list, so every retrieval is O(n). But the wrapping issue, at least, vanishes. If you need to pass data or behavior through API boundaries, in the current ecosystem, `context.Value` is simply the correct, widely applicable way to do that. That doesn't, of course, absolve you from being conscious of its problems.
Go could really use a supported linter for warning on usage of named return variables, which lead to accidental shadowing.
Please explain the problem with a minimal code sample that shows the problem.
The person could have made that point so that in turn we are not left guessing as to what was the intended message. Thus the person is missing the point of having any sense at all in that phrase.
&gt; I hope companies support this, so he can spend more time on further development, which benefits the entire Go ecosystem. This is really important. There's a few issues that he's trying to solve which are really hard problems. Having companies support this development means we may get: - Detecting unclosed io.Closer (ever forgot to close a http.Response.Body or sql.Rows?) https://github.com/dominikh/go-tools/issues/139 - Near real-time language server support: https://github.com/dominikh/go-tools/issues/136 - And others that have been discussed but I can't see an issue for. 
Not OP, but probably this: // always returns nil func fun() (err error) { if err := other(); err != nil { return } return }
Not sure why there are downvotes here, named return variables aren't always a bad thing (i.e. you can't flag them all as an issue), and shadowing also isn't always a bad thing either. Having a specific example might help find edge cases where a flag could be implemented. For example, I use named result parameters in defers to check for errors and if so, rollback a transaction and potentially add context to an error. I wouldn't want this flagged, even as a warning. But perhaps there are cases where we could flag them.
Agreed. I am most excited about VRP (value range propagation) [1] and the incredible future checks it will lead to. VRP allows the static analysis to know the exact range of values that can be in a variable at a given point in code (or a more accurate statement thereof, but that's the general idea). [1] https://github.com/dominikh/go-tools/commit/36af01aed87f5503b32cd671a78311c01ac4b041
Yep, I believe it's providing range checks on slices where it statically knows the index is invalid is great, but from my understanding it isn't in use yet? There were some false positives?
Speaker here. Any questions about the presentation, just let me know. I have received some feedback in the mean time, however, so I'll try to address a couple of the shortcomings of the talk here: 1) The motivation section was a little lacking. There is a server being built that uses this format underneath in the disk storage layer. The format was created to support the query operations in the talk. Other formats all had little problems with them which would be too long to list here. If you want to know about a specific one, let me know. 2) The format is not meant as a server &lt;-&gt; server format over the wire; it is meant to be on just one server as an internal format. 3) Talking about the format was meant to educate about how it worked (for those who enjoy that sort of detail like I do) as well as inspire people to take a closer look at problems that they have and perhaps keep creating a format in their back pocket for when they need it. It feels like people are scared to try even when it's obviously the best path to go down. If I think of more (there were more :) ) I will update this comment to include more. Thanks everyone!
VRP allows a multitude of checks -- out of bounds access and boolean expressions that always evaluate to the same result are two of the more obvious ones. The current VRP implementation is buggy (specifically, the e-SSA form that I produce is incorrect), so none of the checks currently relies on VRP. I'd love to change that.
Well damn he's honest about that
&gt; I know that some people view it that way, but I tend to disagree. I view the ability to traverse API boundaries essential to build useful abstractions. And especially for networked, request-based servers (be it HTTP or RPC or…), having a notion of scoping things to a request seems pretty much essential and that's what context.Value does. Could you elaborate why you view it that way? You state the reason why it is useful to have that abstraction, which I agree with, but didn't really explain why using context.Value is a good way of doing that. &gt; but for a language like go, it is really important to have. I think this might be a sleight to the fact that Go doesn't have generics? In any case, I don't see why it is important to have. &gt; If you need to pass data or behavior through API boundaries, in the current ecosystem, context.Value is simply the correct, widely applicable way to do that. If you had an endpoint that was expecting that data or behavior regardless, then you don't need to use an undocumented API with basically string keys that offer no compilation safety what so ever, only something that would, if left uncheck, would manifest itself into a runtime or logic error. Interfaces and Types would better solve this. I don't think you need this generic bucket to throw stuff in, because at the end of the day you need to know the value key to get the data out. Why not turn that magic string into a Type? Or if it's something that changes the behavior of your API make it a function parameter (if in the RPC world). That's actually been the case for many of my RPC functions. Things I found myself grabbing a lot out of context.Value were prime candidates to be turned into function parameters. 
This is a great idea in theory, but I'd need to see a real ORM package using this pattern before I totally buy into it. Lots of things work well in toy examples but fall apart in more complex real world situations.
I agree that nothing is 100% until it is actually battle tested, but this is a pattern I've seen used enough in the wild (in other scenarios) to have a lot of confidence in it. That said I don't expect to see any ORMs being rewritten anytime soon.
You in turn could have better explained what the intended point was. Your response reads as unnecessary hostility.
I disagree; an interface is really saying, "I need this to do something, *how* it's done I don't care about." Specifying a variable is specifying *how*, which runs contrary to the spirit of interfaces. The workaround is quite simple: int GetSomeVar() SetSomeVar(int) Getters and setters aren't always evil, just usually. ;-)
It looks like there are a lot of useful checks in there - and it's something that I'd consider incorporating into my toolset. However, the pricing model is absurd. I don't think I could consider bringing this to management to pay $800/mo for to support. There's not enough value added.
Struct literals aren't really a replacement for builders. The Go example is really no different than a giant Java constructor. Conversely builders are often used to: 1) create immutable objects (compiler enforced structs if done correctly) 2) perform clean, field level validation without regards to argument ordering usually based on preconditions and exceptions 3) ensure that no object reference can point to an incorrectly formed object None of these are really possible in Go. That doesn't discredit the approach of the article but to say that struct literals are a replacement for builders is not correct by any stretch. 
What I meant to express was that in Java you might see code like this: public class Book { private String title; private int pages; public Book() {} public Book(String title) { this.title = title } public Book(int pages) { this.pages = pages } public Book(String title, int pages) { this.title = title this.pages = pages } } This doesn't scale well. Instead, many java devs use builders. That isn't to say it is the only use case for builders, but it is one use case. This use case does not exist in Go because of struct literals. If struct literals were not a thing and we had to make constructors like this, then I suspect builders would be used more frequently in Go. I suspect I need to change the first part of the statement below in order to make that clearer. I'll go do that now. &gt; Builders are handy because they provide a simple way to construct objects where you might only want to set a subset of the attributes...
I'd disagree that modern Java would be written this way. When I said you'd create "structs" I meant that you'd have public final fields that you read by reference. Java that I see and advocate for doesn't overload constructors nor does it have private, non-final fields. 
Some thoughts on wrapping errors and more: https://dave.cheney.net/2016/06/12/stack-traces-and-the-errors-package
If it's a lot of variables, this is what I do: type A struct { c,d,e,f,g.... } type B interface { GetA() *A } func (a *A) GetA() *A { return a } Then anything composed of `A` can be used as a `B` to give easy access to the variables
Support as a commercial service to companies that need one (but can't get from open source projects). It's ActiveState's business model, as far as I can tell.
https://github.com/mpvl/errd This pkg looks good. Best practices towards go2
This is an excellent idea. I wish there would be an ORM using it. Another nice thing with it is that it would be possible to set a variable to hold a frequently used combination of function options, then insert them in the built query with var... This function options pattern is very promising for an ORM. I would say that this is how it should have been done in the first place. It's a brilliant idea. 
Defer at function level is useful because a function can contain many return statements, and `defer` ensures that resources are cleaned up no matter where and when the function exits. A simple block (e.g. a loop as in your example) usually has exactly one exit point (unless using one or more break statements). So you can easily put any cleanup code at the end of the loop body without risking a resource leak.
&gt; When is errors.New or fmt.Errorf preferred? Should those be the default, in the absence of additional requirements? Should values from those be reused, or should those calls be reinvoked every time? What about when there needs to be additional data attached to an error? var ErrEmailNotValid = errors.New("email not valid") if err != nil { return fmt.Errorf("error opening database: %v", err) } &gt; When is fmt.Errorf sufficient, vs when is something custom like a struct necessary? If you need your errors to carry more data that you need to inspect later then you define a custom struct that usually satisfies the `Error()` method. Read [this part](https://blog.golang.org/error-handling-and-go#TOC_2.). &gt; Suppose function A calls function B, function B returns an error, and function A is unable to resolve this error and must itself return an error. Should function A return the same error, the same error but wrapped, or a new error entirely? In the case of wrapping, how should this be structured to be more easily handled by further up the call stack? It really depends. Does function A know any additional information or context to wrap the error around? If it does then you can wrap the error with `fmt.Errorf` to provide that additional context. Need more fine grained wrapping? Use a custom error struct. &gt; How should errors be checked? In particular, what if a function needs more complex logic beyond just if err != nil? How is the recommended way to differentiate between error types and potentially destructure error values into their components? Is it considered good practice to use a series of type assertions on the possible types, or would that be too much of an abstraction leak? That's a very broad question and again it depends. A very useful technique is one that uses type assertions in just once place in the code to determine what kind of error it is and handle it appropriately. Read [this part](https://blog.golang.org/error-handling-and-go#TOC_3.). If you are writing a library and you are concerned about the surface of error variables you make public (which the clients will have to use), there's another useful technique. Read the "Assert errors for behaviour, not type" part in [this article](https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully). Also check how the Upspin team does [error handling](https://github.com/upspin/upspin/blob/master/errors/errors.go). I am not saying you should do that but it shows what the [Go proverb](https://www.youtube.com/watch?v=PAAkCSZUG1c&amp;t=16m13s) "Errors are values" [means](https://blog.golang.org/errors-are-values) in practice. Program with your errors to handle your specific case.
Am I the only one who finds that the errors are handled gracefully with these functional options? +1 for that. I think it would be a good fit for a simple ORM.
That shows that using naked returns is causing the issue, not named return parameters. I've asked about an example because most of the times people mix these up and it causes the problem mentioned.
They catch a variety of issues and Dominik says that this would help him dedicate more time to the project. What other value would you be looking for? What would make your company pay $800/month for supporting the future development of these tools? 
Interfaces are behavior contracts, not classes or structs. Data has no place in them.
Could be. Ty
[Here](https://play.golang.org/p/_3EhqhSQly) is an example. Hopefully this helps visualize what I'm talking about and how hard it is to reason about what this function is actually *for*.
Sure, my comment was quite short. My point was that people interested in staticcheck would probably also be interested in gometalinter
I see you're new to reddit. This sort of post should be posted as a link rather than text. With regards to self promotion the [wiki](https://www.reddit.com/wiki/selfpromotion) has some guidelines, only about 10% of your posts should be self promotion. As for the project I'd suggest you improve documentation. It wasn't immediately clear (and still isn't) what exactly your project does; what problem does it solve? You should also improve your doc comments. My guess is you're using `go lint` without really understanding how it should be written. See [this post on the go blog](https://blog.golang.org/godoc-documenting-go-code) for a complete guide. Would be good it you linked to you godoc page too.
&gt; didn't really explain why using context.Value is a good way of doing that. Any other currently possible way is functionally equivalent to it, to the best of my knowledge. I'd be happy to learn differently, though. The general acceptance of `context` in APIs is what then makes it *better* than any other way. &gt; I think this might be a sleight to the fact that Go doesn't have generics? It's not. &gt; Interfaces and Types would better solve this. No, they *can't* be used for this, because the question is, how to push that data through APIs that don't know about it. `net/http` *can not* know the types of data that you push through it, that's exactly the point. To pass request scoped data through, e.g., middleware *requires* a use of `interface{}` or something functionally similar. I tried to make that clear. Just try (really. Try. It's illustrative) coming up with the API of a middleware that authenticates HTTP-requests and annotates the request somehow with authentication data, that can then be used to authorize a request. Do so in a way, that can stay composable with other middleware, optimally, try to put it into `func (http.Handler) http.Handler`. You won't be able to do that (or rather: I wasn't able to do that, yet. Perfectly fine to be proven wrong), without sacrificing type-safety. The other issue, of course, is that putting it into types (like function parameters) requires large-scale plumbing whenever something changes. Some call deep inside your call-stack changes and now needs access to auth-data? That means, you now have to add a parameter for that to *every function* that this call could be reachable through. Then, after a while, all your functions start with the preamble `func Foo(ctx context.Context, t *trace.Span, l *log.Logger, a *auth.Data, …` -- do you really find that desirable?
Sadly, this is not really helpful to get an idea of what this is used for. I didn't have trouble visualizing what you meant by "type-switches/assertions on empty interface", but more the concrete use-case. FWIW, there might very well be encoders out there that contain very similar code, but in a perfectly reasonable fashion that doesn't qualify as optional interfaces and doesn't have the same drawbacks. Using this kind of illustrative toy code always has the issue that it doesn't really convey enough context to be judged/evaluated…
That's a fair question, and I don't think I have a satisfactory answer for you. A lower price point, or one time payment (with expiration) might make it seem more reasonable.
Is there a way to contribute something other than $0 and $800 right now? I agree that $800 seems very steep, and I would rather contribute a smaller sum, albiet with far less (or even zero) perks.
[removed]
Here is my small build script. The minify step is to remove whitespace and comments from HTML. # render everything inside master git clone -b master --single-branch . temp cd temp hugo # go get github.com/tdewolff/minify/cmd/minify minify --html-keep-document-tags --html-keep-end-tags --html-keep-whitespace -r -o public/ --match=\.html public/ scp upload public to caddy
Dominik also has a [Patreon page](https://www.patreon.com/dominikh). There you can donate as much as you want.
Shadowing can be argued to be unclear or have additional mental bandwidth requirements. Not sure where I stand on it other then avoiding the `for := range` gotcha. 
[removed]
I accidentally added MEGA
But the only way you can have a naked return is with named return values. I suppose if you avoid naked returns you can avoid the problem, but I'm pretty sure the argument was that naked returns when paired with shadowing can cause confusing problems.
Isn't that a bit useless? Unless you do some kind of transformation to the data, a get method is redundant since the struct variables are public. Also as said by /u/peterbourgon &gt; Interfaces are behavior contracts, not classes or structs. Data has no place in them. Supported by /u/DualRearWheels - [dotGo 2015 - Rob Pike - Simplicity is Complicated](https://youtu.be/rFejpH_tAHM) 
In a sense, providing a value is behaviour. And if he has massive amounts of typeswitching for one or two variables its kinda worth it. 
I guess adding them would defeat the intended purpose of interfaces, and they have given far more thought about it (and effect on delicate balance/interaction with the rest of the language) than you, me and all people on this thread combined. People should first read about Go history, problems it tries to solve and its design evolution, it is fascinating read (I spent on it 2 weeks before I started to learn the language itself). All the features, trade-offs and "limitations" I found later were in line with stated purpose and design goals. I don't have any major complain - they said they want to build something, they built it as they said it. And then some people come, don't know or want to know about its goals, and ask for kitchen sink because every other kitchen has it. /rant Read its history first, people.
Thanks for the link, that looks interesting. I'm more of a [Project Euler](https://projecteuler.net/) guy myself, but I'll have to check them out, the CLI tool and the included test suite seem great (edit: link)
Yeah, the test suite is what actually caught me.
I'd be happy to discuss price points and perks with individual companies. Feel free to contact me at dominik@honnef.co! I've based the price point roughly on what other, commercial static analysis tools charge, which tends to be in the thousands, for smaller teams. You could argue that I made the mistake of giving most of the value – the tools themselves – away for free. All of the paid perks are "peace of mind" perks, that is the guarantee that I won't get bored and stop working on the tools tomorrow, or ignore bugs for months while I work on other things. People suggested other perks, such as releasing new functionality to paying customers first, or extra functionality only to paying customers (a la nginx), but I'm not convinced that this is the right approach to an open source project.
No. Doesn't seem to be an easy way to do that. Maybe I will just ditch the indenting. 
I built mine on top of sdl: https://github.com/tanema/amore/tree/master/joystick I made most packages in my game lib independent so you could theoretically use it by itself but I think you would also need an SDL context running. Not exactly native Go either since it uses cgo for sdl.
There are no native go usb support libraries, afaik. It should be doable to do a c2go + a lot of work on libusb to create one, but there's a lot of code there to deal with.
What are the alternative error conditions?
I just scanned over your projects for a little bit so I might have missed something. The first thing that jumped me when I looked at it is that you do not comment any of the exported methods. As this is an API wrapper which should be used by other programs this is rather important. I can get why you might not have seen the need for comments though as your method names are really clear and transport your intentions well, so props for that. Also regarding your filenames I suggest that you just call them datatypes.go and querytypes.go and leaving the underscore out. Generally it seems that underscores are only used for _test files or for architecture specific files such as _amd64. A question that refers to that on stackoverflow was [this one].(https://stackoverflow.com/questions/25161774/what-are-conventions-for-filenames-in-go) A suggestion which might help you find standard things or shortcomings of your project might be [goreportcard](https://goreportcard.com/report/github.com/jm-duarte/setlistfm) which uses the most common tools such as golint or go_vet to calculate a score for your projects. You are already doing pretty good there.
FWIW, I came out of the talk thinking "I believe he just wants to use sqlite". That is the part I was missing from the motivation section. Why not just dump the data into an SQL table and then run your queries over that? Would save a bunch of time and likely end up more efficient. And while we're at efficiency: You talk a bunch about benchmarks in the end, but you don't properly contextualize the numbers you mentioned. I sat in the talk and just thought "is that fast? Is that slow?". You mention yourself that numbers depend a lot on a lot of factors. So, to actually make sense of them, we'd need at least know what kind of system you are running this on, better yet, compare it to an existing format. For example, I whipped up a quick, naive benchmark for `binary.Varint`; it takes ~9ns/op, so is roughly an order of magnitude faster than the number you show on that slide. Is that, because you used an exceptionally slow system? Is it because your code is slow? Is it because our benchmarks do completely different things? The benchmarks took up a significant chunk of the talk, but didn't actually contain any information, IMO.
If you are asking for all other possible errors, I'm using the standard `net` package. Else if you are asking for what other errors do I care about specifically, I don't: the only kind of error I treat specially is "use of closed network connection" error.
I'm asking why you need to know that the connection is closed. Just treat an error as any indication that the connection is no longer usable. edit: take a look at https://golang.org/pkg/net/#Error
The comments are not forgotten! I was just trying to get it done first and worry about them later! I also know my tests are totaly lackluster but I have no idea how to unit test a huge JSON. If you can pinpoint me to some resources I'd be grateful
~~The error that's being passed to you is defined in the net package source code as an unexported variable errClosing. There was an issue opened [here](https://github.com/golang/go/issues/4373) and a fix was committed for inclusion in 1.9 [here](https://github.com/golang/go/commit/fb4b4342fe298fda640bfa74f24b7bd58519deba). Basically, right now you need to check for the message string, but in 1.9 they will have net.ErrNetClosing for you to check.~~ Edit: nope. See below.
Ah okay! I have a goroutine reading from the socket and I close socket as a way to stop the goroutine without introducing a termination/stopping channel. So I care about why the error occurred. 
As far as I know this only works when sending UDP to localhost (maybe addresses pointing to your current machine as well). Otherwise you cannot detect if a UDP connection is closed, mainly because there's not really such a thing as a UDP connection. UDP is a fire and forget protocol. You send a message and expect nothing back. UDP just defines what the packet should look like. If the other end happens to be listening on the port then it will do something, otherwise not.
I haven't really worked on JSON in Go yet but maybe the tests the guys from google wrote for their [jsonapi] (https://github.com/google/jsonapi) might help you a bit. I might take a look at it later tonight to figure it out as it seems like a nice practice and also a field I can learn something. Can you give me an example of such a huge JSON in maybe a pastebin or gist? Also, just cause I am curious, do you plan to open source that project? Maybe someone sees it here and likes the idea and just contributes to it by enhancing your tests, who knows. 
It's in the readme, feel free to help! I'll give you an example later, on mobile rn
Most of the data that we're using is formatted in a hierarchical fashion and can't be easily represented in a SQL table. This type of system is fully dynamic such that the application can put any JSON document in and get any part of it out. SQLite has a json data type, but at this point it's an argument that you can fit any use case into nearly any data storage system. One of the main goals was to avoid schema knowledge on the server side in order to allow for more flexibility. This is why e.g. protobuf was not used. For the integers, that code uses binary.LittleEndian.Uint64 (not varint, for reasons I stated in the presentation) but also has sanity and data integrity checks as it goes through the process. It's necessary for robustness, but it does add a bit of time. The benchmarks were run on my 2015 MacBook Pro which has an i7 4770HQ CPU at 2.2 GHz. I did spend time trying to ensure repeatable results. I don't have examples for an existing format for the same benchmarks; that's mostly because I didn't use those formats for a reason. They don't do what this format does, so the comparisons are not super relevant. To answer directly: our benchmarks do different things. The benchmarks section was intended to be a little bit shorter but I happened to speak faster than intended in the rest of the talk so I spent a little more time on it to fill out the speaking time. A couple of times I was focusing on people perhaps newer to computer science and pointing out some big-O notation examples in a real world system. Apologies if that seemed a bit boring. Thank you (really!) for spending the time to write up your feedback. It's super useful to see which parts were valuable to you and which were not. This was my first time giving this talk, so it was a little rough around the edges.
Yeah, too bad if you're on a Mac with a 4k monitor IDEA can't even keep up with your typing. Its a two year old bug they know about but still can't seem to fix https://youtrack.jetbrains.com/issue/IDEA-144261
It's probably not an easy fix to do and that's why it takes so long to do it. From the looks of it it might be related to the JDK, which I suspect is a harder problem to fix. I've seen a number of patches they've done to the JDK to make it better so I wouldn't discount them fixing it at some point.
My work spent quite a bit of time working on firebase in Go and the libraries available just are not that strong to be honest. Any major Firebase work we do is in Node.js these days. I had begun a conversion of the v5 websocket API from their Node.js Admin SDK but the work was too much for the 70+ hour workweeks I've been doing the last 2 years.
Right I looked at nodejs and it looks much better
hey /u/jerf have you seen those links? 
what features does gogland have above and beyond vs code? some more refactoring stuff?
Pros: Refactoring, quick fixes, smart type (aware) completion, inspections as you type, integration with a bunch of SQL databases (in case you use that), no external dependencies on tools, aside from Go itself, better performance on medium / large projects, better vim mode plugin (according to the users of vim that try both vsc and gogland), better code navigation, support for injecting a language into the string literals, automatic detection of queries and data preview based on them, better (git) diff integration, etc. Also, you can run the linters you have in vsc on save or on demand, before running the project. Cons: It needs to index your GOPATH on first run, so depending on the size of your GOPATH and the machine you have that might take anywhere between a couple of minutes to 15-20 minutes. But then all the features are available and this is a one time operation only. Another issue could be a bit slower startup time, think 5-10 seconds (depending on the machine) vs 2-3 seconds for vsc. Future: There are a lot more things to come to it as well, keep in mind this is an "early access preview" but any feedback is welcomed. Also if you try it and have any issues with it, please ping me here, on Slack or open an issue: https://youtrack.jetbrains.com/issues/Go and I'll be happy to help you out. Hope it helps.
There's a basic 'tictactoe' example available in GCP's golang-samples: https://github.com/GoogleCloudPlatform/golang-samples/tree/master/docs/appengine/firebase/tictactoe I found the game itself didn't work 100% but the example for custom auth JWT and basic firego usage was enough to get me started.
[JSON Example](https://api.setlist.fm/docs/1.0/resource__1.0_search_countries.html) As you can see it can get pretty damn big, if you go back on the page and see others as well 
It's mostly "IDE" features. The biggest change I noticed is that it's much better at refactoring. Beyond that, it's mostly the same as VSCode, but you don't have to go find and install plugins to make it work. I've been trying it out, and to be honest, as someone coming from a text editor (instead of IDE) background, I haven't found anything compelling enough to make me want to switch. For people use to big Java/C++ IDEs, they'll probably enjoy it since Go hasn't had a full on IDE up til now, but for those of us perfectly content with VSCode it probably isn't worth it. It might also be more helpful on large projects. I think the biggest project I worked on in it is a couple thousand lines of code split across 3 packages. I did try some of the stuff to rename functions and variables, and that worked really well, I just question how often I would actually do that and how much time it would take me to do it manually. It's pretty easy to just run go build or do a search and get the line numbers where you need to change function names. It does ask whether you want to change the names in comments, which is nice and wouldn't show up on go build.
I think any profitable company, especially those larger than a small startup, that relies on and uses Go for their products and services, would find $800/mo a pleasure to pay for the value they get in this project.
also, just incase it saves someone who didn't know yet, using a macro that references its arguments more than once can have unintended side effects e.g. expand this: MIN(a++, b--) 
Totally, but you can still [`Close()`](https://golang.org/pkg/net/#UDPConn.Close) a [UDPConn](https://golang.org/pkg/net/#UDPConn) and any `ReadFrom()` &amp; `WriteTo()` operation return an error, as in my case.
That's the kind of answer I was looking for, thanks a ton!
that's because Close() will close the underlying socket on the operating system. Close() does not do anything about the UDP protocol, the other side could still be happily firing UDP packets in your direction or someone else could even fake your packets and continue firing packets to the other side or a number of other things. UDPConn is merely an open socket that points to some remote address, nobody on the internet or your computer actually cares what happens after it leaves your Ethernet connection.
Put it behind a suitable reverse proxy? Like apache with SSO (e.g. mod_mellon).
I use `minify` as well. However, for creating the gzipped versions I use [`zopfli`](https://github.com/google/zopfli) to squeeze out every last byte. To execute the build I use a standard Makefile, because that sucks less than YAML.
I've thought about adding Brotli support to monterey-jack, but I haven't done it yet just because browser support isn't there yet. I hadn't thought about zopfli. I'll look into it.
&gt; One could go with the java approach and allow default implementations where possible. I tried writing code that way, hacking around the lack of class inheritance. It turned into an overly complex mess and I ripped it all out.
Is this accessible to the public Internet or is it internal intranet only? If its private, how about just doing it by mac address? I assume your company has AD credential based logins for their workstations already, let them handle the auth. If not then third party is probably easiest, most have free plans for that few of users. My goto is Auth0 
Well, don't use naked returns then, seems as the logical solution, no? And that's exactly why I asked for a code sample of the issue, to understand the problem with named return parameters, not naked returns. Named return parameters are especially useful when used correctly as they can provide a lot of self documentation value for the function / method using them and reduces the cognitive load on the reader while setting the expectations of the code that's using them.
Second this. If you are used to IntelliJ or other IDEA IDE'S it will be a godsend, the muscle memory will translate over. If you are used to your text editor and command line, you won't gain too much.
The only thing I miss on Goglang is "just do a `go install`" without climbing through properties/project settings/run profiles/what have you. It's in a GOPATH, it is already a project. There's nothing to setup. Just `go install`, please? Did I miss the obvious?
Ok, that makes more sense then. In another comment I see you want to use the error to signal stopping of the program/transfer. This seems like a bad and error prone way to do it though. Only using the error of ReadFrom or WriteTo to check if the program should stop is not a good way to go. It could just as well be closed by the OS for some reason. You should signal stopping of the program/transfer by using a channel.
What exactly are you asking for? If you want to open the project in gogland just click open an select the project path. I'd you mean pulling in new packages as you add them to the project: alt+enter while your carat is on a red import, and it can get it for you. I'd you want to run a file/project: right click on your main file and select "build and run main.go". That will run the file in place.
You can just click on the green arrow next to the func main() or to the name of the package if it's a test file or the name of the test/benchmark function. Does it answer the question?
*This is a sign you need to make a change, to handle errors better here.* I'm a little confused by this advice. Quite a common pattern I run into is an error in a helper function or library that I want to bubble up and report properly to the user at the calling site (in a handler say). Not every error needs annotation at every level, sometimes it's far more sane to just bubble up a file permission error say in a lib, in fact if err != nil return err is a very common pattern in codebases like kubernetes. This seems to me more a wart of the language than the code concerned, shorthand for that would be welcome and not damaging IMO.
I respectfully disagree. There are many features that an IDE provide over the text editors / command line that you use either at all or in a fluid manner than an IDE can provide.
Release Notes: https://docs.aahframework.org/release-notes.html 
And I have used both command line + text editors and IDEs plenty in my career. I have 5+ years of experience on IDEA products (IntelliJ ultimate, mostly, but also PHPStorm, WebStorm, RubyMine, etc). Before settling on IntelliJ, I used Eclipse and Netbeans. When I was a M$ drone, I obviously used Visual Studio. My conclusions are as follows: If the language lends itself to be able to be developed without a full-fledged IDE, then I find minimal speedups (after the *decrease* in speed learning the features of the IDE). If the language lends itself to be in need of an IDE (java, C#) then yes the IDE is beneficial, even from simply using it. You must provide benefit to your users out of the gate. The "you need to learn it" rationale only goes so far. People want tools that will increase their productivity, not give them homework. Trying to learn a new IDE feels like homework to me. If I can't start it and see the productivity gains, I am not going to use it. 
&gt; Named return parameters are especially useful when used correctly I mostly only use them when manipulating the value in a defer. Otherwise I tend to avoid them, mostly due to their relatively confusing nature to new gophers.
Your example is very strange. https://play.golang.org/p/NpFR2z8kTW It works fine.
What I was trying to do something like this: // code to change "foo" constant to "bar" fmt.Println("foo") // would print "bar" Because all `"foo"` in your code share the same memory address. This does a copy, actually: bytes := []byte("foo")
&gt; If the language lends itself to be in need of an IDE (java, C#) then yes the IDE is beneficial, even from simply using it. I've heard this many times but I still don't see how it can be true. Unless you work in Notepad, for every language you have you'll have some integration or tool that runs, something to be checked for correctness, an integration with other languages, or databases, etc. Refactoring code alone is needed in basically every language there is. And if you look at configuration files like Terraform or CloudFormation templates, for which IntelliJ has some really good plugins, you'll see that the need for better tooling is there as well (and they are just configuration files). &gt; You must provide benefit to your users out of the gate. The "you need to learn it" rationale only goes so far. People want tools that will increase their productivity, not give them homework. Trying to learn a new IDE feels like homework to me. If I can't start it and see the productivity gains, I am not going to use it. You need to learn the command line tools to be equally productive with them so the whole argument as having to provide productivity out of the gate doesn't work out very well. I've listed a bunch of features here: https://www.reddit.com/r/golang/comments/6qwwdc/gogland_eap_11_faster_indexing_extractinline/dl0pupy/ that you simply do not have in those command line tools most of the times. And if you do, you have to learn them. I wonder what would you expect from a tool like a code editor (regardless of it's name/vendor) to provide so that you can have this "value out of the box" experience that's not listed there.
Hehe, good luck trying this on utf-8 strings.
This is as far as I got: https://play.golang.org/p/qpLrREIA_r
Depends on what you are going for, but... either SDL, glfw should be quite fine. (You can see a glfw example in [Zombies on Ice](https://github.com/loov/zombies-on-ice/blob/master/input.go)) PS: as requested, I'm author of that code.
Alright, thanks! :)
If the compiler knows the string at compile time it'll put it in read-only memory, which means you can't modify it with `unsafe`. However, if you convert a slice of bytes to a string and then use `unsafe` it'll work just like you want. All of the above is an implementation detail, though.
[removed]
It might be polite to mention this is a project of yours that you are plugging
This makes sense for me. Thanks for the explanation.
cheers
&gt; Yeah. I've patched the JDK, and have no problem with the 4k monitor attached to my lappy... running Ubuntu, if that makes such a difference. Have you shared the patch with them? As for OSes, yes, their probably is some difference, but I don't know about it. P.S. I've mixed up usernames when I replied so I've removed the previous comment. Thanks.
To this end, JSON-to-Go now runs `go fmt` on the output: https://mholt.github.io/json-to-go/ (JSON-to-Go converts JSON to Go structs instantly in the browser for you.) Edit: And so does curl-to-go: https://mholt.github.io/curl-to-go/ 😊 
Wasn't intended as a plug, but added a note nevertheless.
Unfortunately, as soon as I opened Gogland, the heat sink on my £1500 work Macbook Pro (2 years old) started to do its best jet engine impression, and it took a couple of minutes to load properly. Event then it was slow to autocomplete and even type at times. Also the theme situation... just not very nice on the eyes. I hate light themes, so switch to the dark theme, then the dark theme was black text on dark grey, not sure if this is a bug or intentional. I just feel as well like it's not really solving a problem I have with Go. I can understand why people would want to use a clunky IDE for Java perhaps. But I've never felt the value in it with Go. 
I use https://github.com/NaySoftware/go-fcm personally and find it works fantastic for my requirements.
People usually do this in SQL. Either with prepared statements + placeholders, or by safely quoting the user input.
Hi, nice article! My guidelines for choosing between `err` and `ok` is this: 1. One possible reason of failure? Choose `ok`. 2. More reasons of failure? Choose `err`.
&gt; I've heard this many times but I still don't see how it can be true. That's okay. The language provided tools get you most of the way. The IDE doesn't offer much in that regard. If there's not a tool out there, you write it or find it -- the same exact situation with IDEA (install Plugin) How do you think IntelliJ supported Go? It started as a plugin. &gt; You need to learn the command line tools to be equally productive with them so the whole argument as having to provide productivity out of the gate doesn't work out very well. The difference is the command line tools transfer. The IDE is specific to that IDE. Knowing VI and the Terminal and standard GNU / UNIX utilities has helped me in many more situations. 
What would be really useful in Go is something like ON ERROR operator in good old basic or something that shall automatically pass errors to return value to avoid if err != nil ... all the day.
Actually their JDK/JRE are open source https://github.com/JetBrains?utf8=✓&amp;q=Jdk&amp;type=&amp;language= But if they provided the patch and it works, then please make sure that they are aware of this as it's very important to have feedback like this.
Remote, open internet. Potentially needed to be accessed from a new machine or phone. Common use case is for remote IoT prototypes or experiments. 
&gt; Unfortunately, as soon as I opened Gogland, the heat sink on my £1500 work Macbook Pro (2 years old) started to do its best jet engine impression, and it took a couple of minutes to load properly. This is a one time operation to scan and build the GOPATH index so that all the features actually work after that as expected. The fan being used is normal since the IDE will try to finish this as soon as possible which means will use all the available resources (what's the point of having a powerful computer if you can't use it?) &gt; Event then it was slow to autocomplete and even type at times This could be a bug, if you can spare a couple of minutes to reproduce it and provide a performance snapshot in a ticket, that would be great. You can see how to do it here https://intellij-support.jetbrains.com/hc/en-us/articles/207241235-Reporting-performance-problems &gt; Also the theme situation... just not very nice on the eyes. I hate light themes, so switch to the dark theme, then the dark theme was black text on dark grey, not sure if this is a bug or intentional. The IDE will ask you to switch to Darcula as color scheme when you switch to Darcula as a IDE theme. I'll try to reproduce it to see if it doesn't. &gt; I just feel as well like it's not really solving a problem I have with Go. I can understand why people would want to use a clunky IDE for Java perhaps. But I've never felt the value in it with Go. I'll never understand this (nor the eternal comparison with Java, as if it would be the only other language on Earth), but if Gogland isn't for you, that's fine.
All three of you are meanies 
&gt; If there's not a tool out there, you write it or find it -- the same exact situation with IDEA (install Plugin) I wonder how many developers write their own static analysis tools. Or integrations with editors. Or any other of the bunch of things that are available in an editor? &gt; How do you think IntelliJ supported Go? It started as a plugin I know, I'm one of the core contributors to that plugin :) &gt; The difference is the command line tools transfer. The IDE is specific to that IDE. Knowing VI and the Terminal and standard GNU / UNIX utilities has helped me in many more situations. The IDE runs on Windows/macOS/Linux, I would say it's pretty much the same situation.
I'm not entirely sure why I got down voted for that comment, just a few observations from someone who's never used an IDE before, I wasn't trying to put down someone's hard work. I just don't get IDE's. Surely feedback is good? Just a personal opinion. 
I get the Java comparison is tedious, but I used Java because the setup and project management of Java codebases is tricky without an IDE. Whereas Go's very nimble. I wasn't trying to be offensive, I've never really used IDE's because I've felt they haven't helped me that much. I keep trying to give them a go, and Gogland is one I've tried several times. I did switch to the Dracula theme and it was difficult to read (black text on dark grey). I'll try to recreate that and raise a bug. Probably better to actually raise it than complain about it! And fair point about the available resources. Again, didn't mean to be offensive in anyway. Just some initial thoughts from an IDE-phobe. 
&gt; Again, didn't mean to be offensive in anyway. Just some initial thoughts from an IDE-phobe. I didn't saw the messages as offensive or defensive. It's plain text so I can't infer the intention (and it's probably better not to try to do it, based on past experiences). &gt; I keep trying to give them a go, and Gogland is one I've tried several times. I'd be very happy if you could either PM me or open an issue with what went wrong for you or what could be improved to make the experience better. Especially if you tried it a few times and it didn't worked out, it means there's something that could be improved. So if you could spare a few minutes at any point in the future to explain what went wrong then maybe there's a chance next time you'll try it that the issue is fixed. &gt; I did switch to the Dracula theme and it was difficult to read (black text on dark grey). Even if it's for IDEA, you can try the steps here to also change the appearance https://www.jetbrains.com/help/idea/switching-between-schemes.html and color scheme for the ide. It sounds like the IDE themes switched to Darcula but for some reason the editor Color Scheme remained for the default one. Thank you for reporting this.
It's reddit, I wouldn't worry too much about upvote/downvote ratio. It's much more important, for me at least, that you expressed your experience with the IDE. It seems some things could be improved and it's useful to know that.
Well then don't think lightweight and don't think back office. If you are opening up a channel to the back office and it's going to be accessible on the public web, you need to lock it down just as tightly as you would be anything else.
In case abusing Go one way wasn't enough, here's another: https://play.golang.org/p/uYW5UjbKYv
I am not sure what the point is? Is he trying to say that you should be spending most of your time writing error handling code or that most of your code should consist of error handling code?
README updated :-)
Why are you ranting about sjws?
You'll have to do SQL string concatenation but you have means to avoid SQL injections by validating parameters. For instance, the start and end should be numbers (and you'll concatenate those into OFFSET LIMIT clause), the order can be either ASC or DESC. The column must match one of the available columns - you should know the list of sortable columns for a given table and validate against it. That is how I do it. Also, I construct 2 SQL statements in parallel: one retrieves a range of data and another counts total number of records to implement proper pager widget. I typically have a search filter as well, hence counting records.
Writing an Interpreter in Go.
I guess I didn't do a good job at my point. I very much agree with your description here.. I almost exclusively return my errors up the chain to a single function at the base of the program. https://github.com/kris-nova/kubicorn/search?utf8=%E2%9C%93&amp;q=if+err+%21%3D+nil+%7B+return+err&amp;type= My advice that errors need to be handled better, was simply saying that if you run into an error in your code, please "bubble it up" as you put it.
Well for one: it's she/her For two: yes. that is exactly what I am saying. Go encourages handling errors, and the paradigm dictates that a large portion of your code will be managing those errors.. usually through a system like : ``` if err != nil { return err } ```
That's pretty shitty though. I am coming from a ruby background. I wanted to learn something that was closer to metal, was faster and had good typing so I learned Crystal which I enjoyed a lot. Unfortunately crystal doesn't yet have a large ecosystem so I thought I would learn go to fill the gaps. Coming from that background I find error handling in Go to be atrocious. BTW at least have if err be syntactic sugar for if err != nil 
Why are you replying to a burried 2 day old post? Humor me and I'll humor you, but I'm not in the mood to be troll food tonight if that's your aim, sorry
This is a problem that we've recently solved for [Paperboy](https://github.com/rykov/paperboy) by exposing an API in Go and then creating a separate Javascript single page app in Ember.js. Would that work for you?
I took a short glimpse and it looks not too complicated. Id recommend to start building a simple page with html. If you got the principles of html down (its really not that much) you can then fiddle a bit with the javascript getElementById/Class etc and change properties on them. After that you should be ready to go and learn this framework. What you will probably need too are ajax calls (id recommend jquery for that if you are allowed to use it) to communicate with your Servers api. Also id recommend to serialize data in json, because javascript makes it really easy to Parse it into an object. 
Thanks for the advice. Since the backend is already built and it can get all the data it needs already, I probably won't need ajax yet. And yeah, because the backend has REST calls I've had the chance to mess around with golang's JSON package - the logic of marshal/unmarshal still confuses me a bit, but hey, the code works as intended when running go test, so I'll assume I'm doing it right...
Sorry, I'm not familiar with Ember.js (or any .js) yet. Would that take long to learn?
Well the thing is, your gui will be running in the Browser of the Client, so if your gui is supposed to make any changes to the data of your server you will most likely need ajax. 
I typically use ok for type assertions and checking for the presence of a key in a map. Everything else I use error.
Cool idea, nice one
For lack of a better analogy, it's like Ruby on Rails for Javascript apps. It comes with all the pieces wired together to build a JS app, and has great tools and ecosystem around it. I'd say it's easier to learn than another Javascript framework and scales nicely as your app grows.
The only point against func options is, that they create for each call a new closure hence a new allocation ;-) Otherwise I like the idea and might think about a refactoring of my pkg.
I just want to pitch in and say that as soon as you start using vendoring in Go, which is fairly common, Gogland takes a big hit in performance. If I re-vendor, my Gogland locks up half a minute easily. I love the features Gogland offers, but anything vendoring-related is handled so poorly. I understand that indexing is required for the Gogland features. Re-indexing a vendor folder is a pain though. This is all on a powerful laptop, SSD, i7 and all.
Thank you for reporting this. I must admit I haven't noticed this (but it doesn't mean it's not a problem). Have you tried the latest EAP as well? It should speed up indexing by a sensible amount of time. Since this seems to be highly reproducible in your setup, if you could replicate the issue while taking a performance snapshot of the IDE, that would be awesome. You can find the details here on this to do the snapshot https://intellij-support.jetbrains.com/hc/en-us/articles/207241235-Reporting-performance-problems If you have any problems with it, please let me know. The problem is that this is the first time I see, in 4k issues on the tracker and countless other people talking with, a report about this so it's hard to fix something that's is not known to be a problem.
I see! Right now the server doesn't store any data - it simply manages and forwards requests to other servers, but I'll keep that in mind for when we add a local database (and we are planning to).
strings and slices have a different memory layout: [string](http://godoc.org/reflect#StringHeader) vs. [slice](http://godoc.org/reflect#SliceHeader). For both, the `Data` element points to the raw bytes. So, first, when you cast `*(*[]byte)(unsafe.Pointer(&amp;foo))`, you are setting the cap-element of that new slice to… something undefined. Whatever garbage lies behind that string-header. Secondly, Go decides to put the string-contents in read-only memory (because it's a compile-time constant), so trying to modify that will segfault, because you are violating the memory protection of that data. So to actually modify a string, you need to make sure that it's dynamically allocated. Lastly, you need to adhere to the [unsafe.Pointer rules](http://godoc.org/unsafe#Pointer), if you want even a *smidge* of safety here. Otherwise the GC might switch move around data under your nose and you end up with a pointer to invalid memory. So, [this works](https://play.golang.org/p/N9xKsDAwLu). I hope, the hoops this has to jump through, make clear how friggin' subtle usage of unsafe is. You could only ever use this, if you're *absolutely certain*, that the contents of the slice won't be modified when passing it on, or you're *absolutely certain*, that it's safe to do so. Usually, at least one of the two isn't given. And even if it is, you still need to be very aware of what you are doing. So, needless to say, *don't do this*, even if you think it's a good idea. It very, very likely isn't.
Upcoming "Concurrency in Go" by Katherine Cox-Buday is really good (I was a technical reviewer and genuinely enjoyed this book).
One more highly expected book: "Black Hat Go" https://www.nostarch.com/blackhatgo
I'm not being lightweight in security terms. I mean that 90% of the functionality of a user management security system is around user management, forgotten passwords, ease of use ect... I mean secure and small code footprint or low dependency graph because that's easier to maintain in a secure fashion. For when a dev is deving new tool X and needs a lib or toolset to use for remote access I can say okay we have Y use that.
I was thinking about it for a while and I might have misunderstood your question towards testing. Your issue is not that you do not know how to test JSON but that you do not know how to compare it with such a huge sample right? I don't know about setlist.fm enough but my last thought for this was that you might need some data which does not change or not very often for each test case and also have a copy of the expected result locally (maybe in some resource files) and then compare the results you get from setlist.fm with the data you already have locally. The data you have locally could be data you downloaded per hand or verified once as valid, so you know that, if the JSON you get in the test case is the same as you have locally, the data is valid.
Some strings are placed into read-only section in executable... but that can only be done to strings that exist at compile-time. For example, if the string is on the heap the modification would succeed: https://play.golang.org/p/QxBIGjbjWL *This, of course, isn't guaranteed behavior.*
Yes but the JSON string generated by the Go JSON lib is one-line, no tabs, newlines, whatsoever. And when I copy the JSON from Postman for example it comes with all that whitespace, so it won't be equal. Aaaand I just figured I can create a small script to clean the downloaded JSON to a "pure" string - no whitespace at all
Thanks for the explanation - I have something almost working - I guess I was just trying to avoid doing "ugly stuff" but ugly stuff will always exist somewhere..
What can you get out of this book that you can't from The Go Programming Language by Alan A. A. Donovan and Brian W. Kernighan?
Why is WaIiG good?
The older books are still good. Go hasn't changed much in the past few years. 
Why is min length so low? Length and entropy are the two factors that make a secure password.
If you are more comfortable with backend programming, you might take a look at Elm. It has a very Haskell look and feel, but compiles to javascript to run in the browser. Take a look at /elm or the docs on their website, the elm community is pretty awesome and helpful, I am on their Slack channel quite a bit also.
Agreed, but I've already read them :)
I will make that configurable, but this project started out as a 'raw' cracklib implementation in Golang. I stuck to their defaults for now.
Something like this https://gist.github.com/hugows/38cfdfcc5a6dff57b04621231a5d4c2b worked :)
EmberJS is a terrible choice for someone that never worked with javascript, heck, it's difficult for people with JS experience. Something like VueJS is much simpler to learn.
I've started doing all my frontend coding in Go, and use gopherjs to compile it to a javascript file. Makes everything easier since you only need one language, and you can copy-paste all your data structures. Gopherjs has a bunch of helper libraries for things like ajax and jquery. I still use a standard framework like bootstrap, uikit, or materialize, but all the functionality is programmed in Go instead of javascript.
&gt; correct horse battery staple
Oh I really like that one. How do I get FCM token or server key ? nvmd, I just found it ;) How I can see message stored in Firebase ? Got response like this: Status Code : 200 Success : 0 Fail : 0 Canonical_ids : 0 Topic MsgId : 5...8 Topic Err :
Sounds like a great tool, I'm eager to try it out. BTW, in the Usage section in the README, is there a `vg activate` or similar missing here: $ cd $GOPATH/src/github.com/Getstream/example (example) $ # This command also links the current directory to the created workspace. 
June 2018?!
FWIW, indexing is *significantly* faster for me with the latest EAP. But like /u/kapoof_euw said, it was very painful until this version.
Your backend server (the one that routes requests), you need to communicate with it from your HTML + JavaScript side. This is how you can display information it gives you and how your request information from it or tell it to do what it needs to do. How do you plan on doing that? The typical answer for that is "make ajax requests from the js."
It's easy to read and you learn about the basics of parsing and interpreting.
IMHO the following are all you need to get up to speed and stay there: 1)Introducing Go: Build Reliable, Scalable Programs 1st Edition by Caleb Doxsey 2)Network Programming with Go Essential Skills for Using and Securing Networks Authors: Newmarch, Jan A few key blogs to follow: 1)https://www.reddit.com/r/golang/ 2)https://golangweekly.com/issues/170 3)https://changelog.com/gotime 
??? Not sure what you're getting at here. I tend not to worry myself too much about "clean" this or "12 factor" that and focus mostly on just Not Repeating Myself (DRY).
Let's not start a JS flame war on a Go subreddit. The main reason I would recommend Ember.js in this particular case is because it is targeted at creating single-page-apps, which makes it easy to work with APIs. OP would be able to separate his Go server code from the JS app. &gt; it's difficult for people with JS experience OP seems to be coming from Java world which is more framework oriented than someone coming from HTML/JS world where progressive enhancement is still the status quo. 
&gt; but in 1.9 they will have net.ErrNetClosing for you to check. This is not true. The `ErrNetClosing` variable is in `internal/poll/fd.go` so it is inaccessible for comparison/testing by user code. User code sees an `*net.OpError` with an `Err` field set to a `*errors.errorString` value. All the commit you link to [effectively] does is revert a change to the text of that error to not break some code that was (incorrectly IMO) grokking around in errors strings to guess what the errors was. [Note, the change also does change the variable to an exported typed but the key detail is that it's exported from an internal/in-accessible package]. 
I've been on vacation, so I didn't get this earlier. Conversation is dead now, probably, but still. " a) want to overwrite the Read-method, b) don't want to change the method set apart from that and c) don't know at compile time, which other methods might exist." That isn't exactly what I thought you were asking for. There is no static language I know of that can do that dynamically at runtime. However, there are generics implementations that would allow you to do that at compile time without much hassle, if we extend them in the "obvious" way to work with Go's interface satisfaction. It'll generate a type at compile time, but in general that turns out to work out OK. Even in Go today you can do that for a concrete type: type OverrideReadForX struct { X } func (orfx *OverrideReadForX) Read([]byte) (n int, err error) { ... } But not for a "generic" type. "The basic issue is, that you don't know, at compile time, what method set the wrapped Writer will have and that enumerating all possibilities is untenable." And this I'd have to disagree with, though. You _can_ enumerate "all the things I know how to deal with" and that is almost always a very constrained set. It's just like how there's really no such thing as "schemaless" data, because unless you're doing something _very_ fancy with ML you can't write code that deals with "I dunno, just some data or something", you have to have a schema of some sort. If you care about Flushing, you can check for it sanely. If you don't know what to do with it anyhow, then skip it. Another possibility you may not be considering is that if you have something that happens to have a `Reader` implementation on it, but you are somehow _required_ to invoke some other method on it in order for the Read to work correctly, you may not really have a `Reader`. Arguably, things that require a Flush really shouldn't conform to the Reader interface in the first place. If you sit down and write out the full semantics of what `io.Writer` and `io.Reader` _ought_ to conform to, beyond just what the method interface says, you actually get something surprisingly complicated considering how casually most Go programmers use them, and how successful that casual use usually turns out to be. Writer is particularly complicated. (Some of the following is my opinion, but it's not "jerf's opinion about how all io.Writers 'should' be written", but "jerf's _observations_ of the implicit contract io.Writers are generally expected to follow by code that uses them.) * Every invocation of Write on a "concrete" type should result in an immediate write; i.e., a packet on a socket, a disk write for a file, etc. * If you want to Write lots of single-byte or small writes without that, it's your responsibility to wrap that in a byte.Buffer. * Writes involving Unicode should never split unicode code points into multiple writes and should probably not split unicode characters at all. (Otherwise filters based on those things don't work very well.) * The order of things being written to Writer should be the same as they will eventually be written back. (Personally, I'd argue that `net.UDPConn` should not actually implement `io.Reader` and `io.Writer`, as there is a _loooot_ of Reader- and Writer-based code that will be _very_ surprised by the resulting semantics.) * Writers should probably be thread-safe because even if you don't use them in threads you don't know where they're going. Ties can be broken arbitrarily, though; any code that may _cause_ aribtrary-ordered writes ought to be able to handle its own effects. However, you can't interleave particular Write calls, i.e., Write([]byte{0, 1, 2}) and Write([]byte{3,4,5}) shouldn't result in {0, 3, 1, 4, 2, 5}. And honestly there's some others, too, not all of which leap to mind. So I'd say another possibility, though it tends to work against composability, is that some things are Readers and Writers which shouldn't be.
Just to let you know, the site doesn't look very good on an iPhone 7 Plus. Looks like the divs aren't aligning vertically like you'd expect; rather they are really bunched up and cutoff by the screen size. Otherwise, looks pretty good.
We've build a dynamically scalable queue consumer! Hopefully it will be useful for your projects! :)
Actually I find the opinion interesting. I was just about to ask you how VueJS would compare in complexity to EmberJS for a novice, if there are any differences that would come to mind. For someone that's into VueJS and did a lot of things before with js/jquery/etc, it would be also interesting to know in which areas you think that EmberJS is a better implementation (if you have an opinion). You can send me a DM if you think this discussion is fame-y (I don't think it is).
For those that don't get the reference: https://xkcd.com/936/
[Image](https://imgs.xkcd.com/comics/password_strength.png) [Mobile](https://m.xkcd.com/936/) **Title:** Password Strength **Title-text:** To anyone who understands information theory and security and is in an infuriating argument with someone who does not \(possibly involving mixed case\), I sincerely apologize\. [Comic Explanation](https://www.explainxkcd.com/wiki/index.php/936#Explanation) **Stats:** This comic has been referenced 3256 times, representing 1.9765% of referenced xkcds. --- ^[xkcd.com](https://www.xkcd.com) ^| ^[xkcd sub](https://www.reddit.com/r/xkcd/) ^| ^[Problems/Bugs?](https://www.reddit.com/r/xkcd_transcriber/) ^| ^[Statistics](http://xkcdref.info/statistics/) ^| ^[Stop Replying](https://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=ignore%20me&amp;message=ignore%20me) ^| ^[Delete](https://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=delete&amp;message=delete%20t1_dl27or7)
+1 for GopherJS. But instead of copy-pasting all your data structures, it's cleaner to keep the shared code in a sub-package.
Ever since I read that xkcd I keep wondering how many people - who also read it - actually changed their password to that very phrase. Might be worth adding to a password-blacklist by now...
&gt; Another possibility you may not be considering is that if you have something that happens to have a Reader implementation on it, but you are somehow required to invoke some other method on it in order for the Read to work correctly, you may not really have a Reader. First: At some point, someone started associating `Flush` with `Reader`, which makes no sense. It might have been me who have started it but `Flush` very clearly belongs to `Writer`. So let's assume from here on out, that we're talking about that :) And I disagree with you. Particularly about: &gt; Writer is particularly complicated. For users, `Writer` is *much* less complicated than `Reader` (which is why, in general, you should never call `Read` directly, but instead almost universally use `io.ReadFull`). &gt; very invocation of Write on a "concrete" type should result in an immediate write; i.e., a packet on a socket, a disk write for a file, etc. I don't think this is an expectation that any code I've ever seen makes. If code makes that assumption, it's clearly buggy. &gt; If you want to Write lots of single-byte or small writes without that, it's your responsibility to wrap that in a byte.Buffer. No, if you want to write lots of single-byte or small writes, just *do them* and let someone further up the stack handle it, if it becomes a problem. Excessive buffering is counter-productive. That goes towards the previous point; you *shouldn't worry* about where the data goes, you where simply asked to write it to a stream. Whether that stream is `ioutil.Discard`, a network connection or a memory buffer is of no concern to you. If you care, you are buggy. I don't think it can really be argued, that `ResponseWriter` doesn't conform to the `io.Writer` interface itself. There is a clearly lined out contract and just because the writes are buffered or might not happen in one circumstance or another, doesn't mean you are violating the contract. I would be on board with something like specifying that `ResponseWriter` gives *stronger* guarantees than `io.Writer`. For example, that every write will trigger a flush to the underlying connection, so if you need buffering, you need to do it yourself. Or not doing that and instead adding a `Flush` method to the interface, so that anyone who requires flushing could request that (which would probably be better, as it would reduce the overhead for the common case). &gt; Personally, I'd argue that net.UDPConn should not actually implement io.Reader and io.Writer That I tend to agree with. `Reader` and `Writer` are stream interfaces by their nature, `UDPConn` is message-based. &gt; Writers should probably be thread-safe Like anything to do with concurrency-safety in go-land, I don't think this is reasonable. It's totally normal to document the safety-guarantees you do and do not give and put the responsibility of the user to use it safely or wrap it in a Mutex. If you take a reader/writer, specify if you are going to use it concurrently. If you provide a reader/writer, specify if it can be used concurrently.
/u/ksirutas Thank you, I appreciate it. I will improve the UI alignments. 
Looks nice. I would recommend you allow creating a type `crunchy.New(opts) Checker {...}`. Then in the opts allow passing in an io.Reader or similar for the dictionary (Windows doesn't have a dictionary anywhere normally). 
Yeah, I have roughly the same thing in mind. I'm not sure an io.Reader is really the nicer solution, though. Even on Windows you'd probably copy the wordlists to a local directory somewhere. On the plus side, you could easily load a dictionary from an HTTP resource - or pretty much anything that supports the interface, obviously.
Yeah, maybe not an io.Reader, but it might be nice to accommodate someone who wanted to embed the word list in the application.
Great explanation! &gt; So, needless to say, don't do this, even if you think it's a good idea. It very, very likely isn't. Don't worry, I know it's a good idea. I was just playing with the language, and looking for knowledge.
I think it would be simpler if you wrote about your use case and we could tell you if it sounds like a good fit for what go excels at. Having said that, Yes. We have quite a few of our services written in golang. They include a message queue, notification server, accounts service and a few other servers.
"Building a **web** GUI with Golang" = Building a website with a Go backend Pro tip: common web browsers only interpret HTML, CSS and JS... Astonishing. It's not like you have the choice. But JS can be avoided if you keep your app very simple (and old-school) or if you stick with the built-in components of your UI library (Atlassian, UIkit, ZURB Foundation, Bootstrap...). You can mix the frontend with your current backend (using Go [html/template](https://golang.org/pkg/html/template/)) and serve your web pages from this same piece of software. The day you'll have issues with scalability or code organization: 1. Make your backend a JSON REST API. 2. Put the frontend on its own server. 3. Connect to your API from the frontend server. The day you'll have crazy issues with scalability or code organization: 1. Ask your boss for a pay rise. Politely. 2. Split your backend into micro-services that communicate efficiently (with Protocol Buffers by example). AWS Lambda is a good platform for this. 3. Make your frontend an SPA (single page application, with React, Vue, Aurelia...) made of static files (served from a CDN if it's public). 4. Connect to your API directly from the browser, with AJAX and WebSockets. --- OP says he may never have written an "hello world" in JS or even an HTML page and some advise looking at Ember.js or Elm... Be serious. If his frontend is so complex, he will need to understand browser APIs first of all, which are documented in HTML and vanilla JS.
Since May 15th running on AWS ECS. So far, no issues.
whats wrong with this naive and mostly pseudo code example? https://play.golang.org/p/X3OdWEXPRq
I think it's a bit unfair to judge these frameworks head-to-head because they're built for different purposes. The libraries you've mentioned and many others (jQuery, VueJS, Backbone, React, Angular) come from the progressive enhancement world, so they're easy to add on top of your existing server-rendered HTML. When it comes to single-page apps, these frameworks promote a pick-and-choose approach to wiring things together. And although it may be more flexible, I found it to be more fragile and harder to maintain in the long run. EmberJS, on the other hand, originates from a history of "desktop app in a browser" frameworks (Sproutcore, Cappucino, etc) So it isn't as easy to just add it to existing HTML. But it is great at writing complex single-page apps with little configuration (more convention). And in my opinion, EmberJS has consistently been a bit ahead with the quality of their tooling (ember-cli), integration, and even performance when it comes to building single-page-apps. The other bonus is their community: the RFC and deprecation processes, as well as commitment to compatibility cannot be overlooked - stuff rarely breaks unexpectedly for me on upgrades, even with major versions. 
Nice! Its been many years since I did any code theory and crypto. The name Berlekamp still reminds me of the ingenious Berlekamp-Massey algorithm used to break LFSRs. Thanks for the reminder :-)
We did the same. Exposed API with go, and wrote front end in Ember. Actually really like what we've set up. We toyed a bit with using Go's own templates, and there are some interesting possibilities, but the process of reconnecting actions back to the Go API still seems pretty immature - especially when compared with Ember.
Ember.js was the first (and only?) JS I've learned after needing a front end for my Go API. I actually really like it as it's very similar in process and nature to programming in Objective-C. Though getting the API hooks into proper Ember shape took a bit of massaging with various adapters and serializers, once it was set up it's a really great separation of duties with two really powerful technologies assisting each other. Ember takes care of a lot of 'stupid javascript' stuff, if it does force a bit of convention on you. But (because?) I didn't know much Javascript, that was fine by me - fewer old traps for me to fall into because someone more knowledgable about javascript than I already laid out a safe path for me.
everything.
[removed]
What will the web UI have to do? If it just needs to display data, don't use any js library, no matter how easy they say it is, if tiu are new, it will take a while to get right. Instead use html/template 
On my smaller-screened iPhone SE, some pages are too wide for the screen. 
You can use libraries like [squirrel](https://github.com/Masterminds/squirrel) do that. They're concatenating your SQL statements correctly for you. No clumsy ORM required. What I do a lot is, I have some base parameters, like: var builder squirrel.SelectBuilder = squirrel.Select("turtles.id", "turtles.name").From("turtles") Things like `_start` and `_end` you could probably just append, if I'm interpreting the above correctly, so you get builder := builder.Limit(START).Offset(END) And then for more complicated things you could just use closures or something. Here's what I'd do to get all red and blue turtles: type Filter struct { Colors []string } func (self *Filter) Execute(sb squirrel.SelectBuilder) squirrel.SelectBuilder { if len(self.Colors) == 0 { return sb } return sb. LeftJoin("colors ON turtles.color_id = colors.id"). Where(squirrel.Eq{"colors.name": self.Colors}) } filter := Filter{ Colors: []string{"red", "blue"} } filtered := filter.Execute(builder) // turn everything into a correct string filtered.ToSQL() Surely this can be done nicer and more performant but I think the basic idea is sound
Hi! FYI: https://github.com/gobwas/ws-examples
/u/__crackers__, /u/ksirutas I have just deployed website with few UI improvements. Please give it try. Also I'm learning `css media query`, will do further improvements in upcoming days. Thanks for your time.
&gt; The IDE runs on Windows/macOS/Linux, I would say it's pretty much the same situation How easy is it to use the IDEs inspections in my CI environment?
I've started to create an library, (https://github.com/microo8/golymer) which will enable to easily create custom html elements. It has declarative data bindings. It yet isn't complete, and will run only under chrome. Maybe in an non-distant future I'll complete it and start to build some reusable gui components (buttons, tables, lists, ...) Then I'll be able to create the frontend entirely in go and also use the html platform directly.
&gt; How easy is it to use the IDEs inspections in my CI environment? We were talking about editors other tools :)
While I concur with you, Elm may not be a good choice if the impact of a notable learning curve cannot be absorbed. It is worth saying, though, I'm glad I took (am taking) the time.
We were talking about CLI tools being transferable, to use cameronjerrellnewton's words. CI is one example of many. Scripts automating tasks, integration in other applications are others.
I'm going to need to reread the blog and look a bit at your tests to digest this, but I'm interested to learn more. Does this ingest CSS and then call draw methods that you must implement in your application code? When reading the [Yoga docs for C#](https://facebook.github.io/yoga/docs/api/csharp/) I see that it seems to build data structures with a calculate method but does not seem to parse CSS or draw, so I'm having a little trouble understanding what it actually does. Is there a simple way to explain it?
It's a book about concurrency in a first place. It guides you through the very well explained nature of concurrency programming complexity, CSP, Go concurrency building blocks in details, following by extensive overview of concurrency patterns and ends with hardcore deep dive into concurrency at scale and explanation of Go runtime concurrency specific parts.
cameronjerrellnewton explicitly called out VI, so I just assumed we still talk about editors. Yes, some tools like a non-CLI editor do not have the a way to run in a CLI only environment, some do. However, one can make the opposite argument and say that not the CI is not something every developer is meant to work with (in order to set it up and so on). &gt; Scripts automating tasks, integration in other applications are others. In this particular case, Gogland can automate various tasks and integrate with external applications as well.
Ah so it's the same argument as Go vs. PHP :)
Done: https://www.reddit.com/r/golang/comments/6r76il/million_websockets_and_go/ :D
Done ;-)
It doesn't read CSS or draw. This is a library meant to be integrated with other code so it operates on abstract nodes. You define layout hierarchy by creating tree and setting flexbox properties on nodes. You then call layout function to calculate position of nodes and you can use that to position your real widgets. Tests (e.g. https://github.com/kjk/flex/blob/master/flex_wrap_test.go) are really the best way to get a feel for the API. API isn't great, partly because of the nature of the problem and partly because it's a direct port. On the other hand, writing a flexbox implementation from scratch is probably weeks of full-time work. 
I finally figured this out, go-fcm is perfect for I want to do , much appreciate
This is a very good article I learned alot, I just wish I had a popular enough project where this level of optimization was required haha
C10K problem isn't cool. You know what's cool? The C1M problem.
Not to take away from the author's accomplishments at all, but the biggest feature Go 2 could bring to me is a cross platform GUI capability that doesn't require cgo/can be cross compiled.
We don't need to wait for Go 2 and we don't need to wait for Go project to do it. This is already possible with Go and there are attempts like https://github.com/golang/exp/tree/master/shiny (not being worked on anymore). The issue here is: writing a decent cross-platform GUI is a lot of work and there are less and less people who are fluent in all relevant platforms (Windows/Linux/OSX/Android/iOS). 
Yeah, too bad about Shiny, it could have been an option. Unfortunately, I'm in the category of people who would like to use such a thing while not necessarily being able to create it myself.
That would be like `go run main.go`, but I want `go install`. I have direnv/.envrc that sets `GOPATH=/go/default:/go/someproject` when I want to work on someproject. It would be great to not set up the project any further than that; it is all there already. The _only_ thing I want to set up in an IDE is `$GOROOT`.
you should read on react or vue, compared to ember they are much easier to work with.
I find it hilarious that in order to show a diagram of the parts involved they made an RFC-like drawing, and then published a screen of it.
Just in case the original point wasn't clear, since I didn't really reinforce it on my other reply.. Making GUI an official priority for the Go team rather than one guy's unofficial attempt to do something on his own is much more likely to have a successful result. In the mean time, the only reasonable option in my mind is to point your web browser to your Go app. 
&gt; flush is on Writer, not Reader Mea culpa. I was in a hurry at the time. &gt; I don't think this is an expectation that any code I've ever seen makes. If code makes that assumption, it's clearly buggy. I _observe_ that the Writers packed in with Go all seem to work this way. If you do not deal with that fact, you will experience performance degradation. I think that despite my explicit disclaimer, you may be mistaking me for _advocating_ these things. I _observe_ them. If you just write to a socket without paying attention to this, it will _work_, but it will suffer performance degradation. If you just write to a file without paying attention to this, it will _work_, but it will suffer performance degradation. Possibly the code has changed since I last looked at it, but I doubt it. &gt; I don't think it can really be argued, that ResponseWriter doesn't conform to the io.Writer interface itself. There is a clearly lined out contract and just because the writes are buffered or might not happen in one circumstance or another, doesn't mean you are violating the contract. Actually, the problem with http.ResponseWriter is its interaction with writing the headers. You can get yourself in a bit of trouble if something starts writing blindly to what it thinks is "just" an io.Writer that it can write anything it wants any time it wants, but there's an additional constraint that you have to have the headers set up before the first byte is written. It is reasonable for code that receives an `*http.ResponseWriter` to be aware of this constraint, but not code that receives `io.Writer`. I'm not sure that `*http.ResponseWriter` should implement `io.Writer` because of this. What would be more sensible in theory would be that it doesn't implement `io.Writer`, but implements a method that allows you to _obtain_ an io.Writer which also comes with the contract that the headers are at that point written and any attempt to further modify them would somehow be an error. In practice it all mostly works out though. &gt; Like anything to do with concurrency-safety in go-land, I don't think this is reasonable. It's totally normal to document the safety-guarantees you do and do not give and put the responsibility of the user to use it safely or wrap it in a Mutex. But your entire concern with this line of discussion is about composability. This implies passing bits of code into other bits of code that know nothing more than "this implements `io.Writer`". At this level of composability, there is no mechanism for indicating whether something is thread safe or not, nor do we commonly label code as _using_ values in a concurrent manner. So I'd suggest that an `io.Writer` implementation _should_ (not _must_) be thread-safe, because once it leaves "your" code you don't really know what is going to be done with it.
&gt; I think that despite my explicit disclaimer, you may be mistaking me for advocating these things. I observe them. No no, I got that, don't worry :) It's just that I never observed that particular thing. It would be mildly interesting to see code that would actually depend on that kind of stuff (in particular the "writes must be immediate"), it seems completely alien to me. &gt; If you just write to a socket without paying attention to this, it will work, but it will suffer performance degradation. Then you need to wrap that in a `bufio.Writer`. But only a) when you actually see that to be a problem and b) only on the outermost layer, that is directly on the `net.Conn`. Code that takes an `io.Writer` (say, `json.Encoder`) shouldn't do any buffering, unless it is necessary for (or significantly simplifies) their implementation. imho, ymmv, etc. &gt; What would be more sensible in theory would be that it doesn't implement io.Writer, but implements a method that allows you to obtain an io.Writer which also comes with the contract that the headers are at that point written Sure, that would probably be safer. I still consider it fine; `ResponseWriter` is an interface in its own right and as such it can make any kind of assumption it wants to. Arguably, something like `type ResponseWriter interface { WriteHeader(code int) (body io.Writer) }` might have been a cleaner API, though, I agree. &gt; This implies passing bits of code into other bits of code that know nothing more than "this implements io.Writer". But someone needs to do the passing and that someone is the person responsible for knowing and, if necessary, enforcing that; if need be, by wrapping it in a [trivial locking writer](https://play.golang.org/p/S_htRqP7wL) (yes, I'm aware that erases any other methods of `w`; which is why optional interfaces aren't good :) ). &gt; At this level of composability, there is no mechanism for indicating whether something is thread safe or not Not compiler-enforced (technically speaking, you could probably pretty simply devise a separate interface for that, but so far, it seems it's fine), but via documentation, as is common in go. Yes, it does require of the programmer to be aware of whether or not an implementation of `io.Writer` is goroutine-safe and whether a function requires a value to be safe against that. It's not great, but it is a deliberate design decision of go, to put that burden on the programmer. &gt; nor do we commonly label code as using values in a concurrent manner. Isn't it? I grep'ed through the stdlib and it's at [least](http://godoc.org/database/sql/driver#Conn) [not](http://godoc.org/database/sql/driver#Stmt) [totally](http://godoc.org/net/rpc#ClientCodec) [unheard](http://godoc.org/net/http#CookieJar) [of](http://godoc.org/net/http#RoundTripper). I totally agree, though, that documentation in this regard is often lacking.
Always smile when I see these sorts of posts, where your starting point for scaling is already 10x, 100x, even 1000x more than you could reasonably do in languages that people consider existing in a similar space.
[Sublime improvement](https://i.imgur.com/oAcbjtZ.png). ^^^^It ^^^^did ^^^^go ^^^^away ^^^^after ^^^^refreshing
Just a heads up that I just committed crunchy.Validator, as well as crunchy.NewValidator() &amp; crunchy.NewValidatorWithOpts(...).
The new default is now 8 chars min length. You can also initialize a crunchy.Validator with your own settings now.
I'm not a TDD purist, but I would have started with tests for various bits of functionality, rather than structures.
Looks too much like java. For something this simple chan func() will do the same with less noise. Though (&lt;-c)() is pretty terse.
Actually with OpenResty and DPDK, people have started working on the C10M problem.
Any details or links for these? I'm genuinely interested.
I'd recommend a second form asking about places where there should be Go meetups. I'd be happy to host, but I don't think there's any demand near me 
I like the interface because it allows a convenient way to pass context type safely
But this is actually a pretty cool construct
A full-fledged cross-platform GUI framework would require quite tremendous commitment to be comparably useful in production against other mature ones. I imagine something like a QPA (Qt Platform Abstraction) equivalent for Go which has a minimal purpose would be nice to serve as an infrastructure that more sophisticated widgets can be built upon.
Is there a goroutine leak here? N goroutines are started writing to the channel but it can exit out early if it gets false returned from one of them func AllOf(predicates ...Predicate) Predicate { return func() (bool, error) { childChan := make(chan bool) errChan := make(chan error) for _, predicate := range predicates { go evalPredicate(predicate, childChan, errChan) } for i := 0; i &lt; len(predicates); i++ { select { case res := &lt;-childChan: // Short-circuit if !res { return false, nil } ...
I got a website hit the other day. Was so excited.
I guess the real joke is C1B. Oh well. 
You aren't wrong, and based on your wink I assume you aren't genuinely saying that is a reason to not use the pattern, but for anyone else out there... http://www.metabates.com/2017/03/03/youre-benchmarking-the-wrong-thing/
Probably another [Russian-proxy](https://deedlefake.com/img/misc/analytics-location.png) [spam bot](https://deedlefake.com/img/misc/analytics-language.png). 
Bravo on that write up. I actually understood the explanation with very little background. I learned something by reading that. 
This is the first time I've built a game with anything. I'm still getting to grips with Go so any constructive advice is very welcome!
If the IoT devices are capable enough to do OAuth, would they also be able to connect to a Virtual Private Network? With a VPN, you'd have a security layer beneath all of the application-level protocols. Which means less dependencies for the devs.
Hmm, true, but again for a 1-off case I find a closure is less verbiage than defining an interface and then a struct that implements the interface: var context *Context // the context you need, whatever it is c &lt;- func() { doWork(context) } 
&gt; Unfortunately structs can’t have the same API as interfaces, as the latter cannot define fields. I am not sure if I understand this complaint. Why should interfaces contain fields? It is the definite purpose of an interface to define a set of method to conform to, and nothing else. Interfaces define behavior, not state. What is the use case for "structs having the same API as interfaces"?
good catch! original author here. I'm new to go, but it sounds like using buffered channels and doing something like func AllOf(predicates ...Predicate) Predicate { return func() (bool, error) { childChan := make(chan bool, len(predicates)) errChan := make(chan error, len(predicates)) for _, predicate := range predicates { go evalPredicate(predicate, childChan, errChan) } ... would make sure all the goroutines could finish
&gt; And while more features != success, C++ has nearly as many features as D does. C++ may even have more features than D does. And C++ is a lot more successful than Go is. When C++ started, it was a quite simple language. It became popular a long time before the feature bloat set in. I daresay the feature bloat is a *result* of C++ popularity, as everyone and their dog chimed in to request adding another "indispensable" feature.
There's a team working on something over here: https://docs.google.com/document/d/1mXev7TyEnvM4t33lnqoji-x7EqGByzh4RpE4OqEZck4/edit# But I don't think they're looking at building what they're building in pure go. Conveniently they also list a whole bunch of attempts at this in Go already at the bottom of the page (I'm only aware of this project because they asked us to help with the project or give feedback and put us on that list twice).
You can contact me I'm currently finding out which person you can speak with it would help to know where you want to host a Go meetup ;)
Very nice! Yoga is a great library. I have a WIP Rust [wrapper](https://github.com/bschwind/yoga-rs/blob/master/src/lib.rs#L756-L807) of Yoga and also need to port all those tests...
\&gt; tfw you get all hyped up because you're hosting the official app and its backends for a Ski World Cup and do AWS autoscale voodoo for the first time to prepare for all the traffic you will get \&gt; tfw it turns out nobody watches Ski World Cups and you end up having at most 6 small instances running
You're going to have to post the code if you want any meaningful discussion.
&gt; for now I'm looking forward suggestions of how to get it performing better or a guess of what could be happening. I can guess a dozen of reasons of why it would this happen but would guessing be of any help to anyone? As /u/bschwind said: show me the code. I would at least expect Go to be on par with node on this, if not better. Also, which version of Go are you using?
Maybe you should contact GoBridge with this directly https://golangbridge.org/ You can register on https://forum.golangbridge.org/ and their Slack channel https://invite.slack.golangbridge.org/
So do I GO - go version go1.8.3 linux/amd64 NODE - v6.10.2 PS: Ill post on github, just don't have this time now, need to get the things tidy first But the debate is open, if there is a guess, just write it down
&gt; And yes, an answer saying why go doesn't excel on this scenario would be appreciate. Quite probably because of your bad code/wrong design of the same. That's not an insult. That's exactly what I think about my code whenever it runs slower than expected. Not always true, but most often it is. 
&gt; That would be like go run main.go, but I want go install So you want a button just to compile the app? If so, please follow: https://youtrack.jetbrains.com/issue/GO-2408 &gt; I have direnv/.envrc that sets GOPATH=/go/default:/go/someproject when I want to work on someproject. It would be great to not set up the project any further than that; it is all there already. The only thing I want to set up in an IDE is $GOROOT. Ok, so support for direnv is not something that was requested so far, I've added a feature request for it here: https://youtrack.jetbrains.com/issue/GO-4252 Thank you.
No, that's not how it works. Post the code and we'll help you figure out, I'm not going to waste my time on this. You can profile your Go solution by following this: https://blog.golang.org/profiling-go-programs
You are trying to compare 2 different things and most of the application tests that I have seen between nodejs and Go are wrong. Don't benchmark your app but your functionalities like: - HTTP server benchmark - MongoDB querying benchmark - JSON marshaling benchmark like this, you will see what's your problem and where it might come from. Make sure: - your MongoDB driver settings are exactly the same. - Nodejs doesn't have any cache activated. - your go app is running on ONE single core. PS: change the title of your post because it looks like you are a troll.
Show us code. Until then, we're just going to assume it's bad code. If your results were generally what we found elsewhere, we would not be doing Go, we'd be doing nodejs. If I can `go get` your code, and run it, I can profile it, improve it, etc. To be honest if that's slow I can probably eyeball it and tell you what you're doing wrong. There is absolutely 100% no way that nodejs is 3x faster than Go for this use case.
Other ways could involve a waitgroup (increment before spawning the goroutine) and passing a cancel-able context, and selecting against Done when trying to send to exit instead, ensuring that the wait group gets a Done call for each goroutine no matter how they exit.
Oh hey, this is awesome! I don't know why you got so little feedback. Will try playing ASAP!
[removed]
&gt;https://github.com/golang/exp/tree/master/shiny (not being worked on anymore). It's certainly stalled, but are you sure it's been dropped ? I saw a response on a bug from one of the shiny devs (nigel tao) as late as the 2nd of june, and nothing in it indicated that shiny was deprecated. https://github.com/golang/go/issues/20436 I recall reading somewhere that the reason for being stalled was some core problem on which the best solution needed to be chosen. And as this bug response shows, there is code being written and discussed by the shiny devs which has not been submitted to the project until they agree on it, so lack of public commits does not have to equal lack of development.
Thanks, this was helpful, Ill check them 
Ya, I know that, Ill push this code on github soon and update this thread
Not sure, maybe you did this on purpose, but you're missing out completely on Golang's world class support for testing. In the standard library there's even a package for integration testing web apps, `net/http/httptest`. Don't start a web server and check everything manually. Other than that in my mind you're relying (too?) heavily on external packages to do stuff that's rather simple. Like, logrus and negroni, when you're using gorilla and middleware is written quite easily by hand? IANAL, though! Keep it up!
I feel like it might be nice to have a language based-solution to the issue (like an optional keyword). so you could declare an interface as: type ResponseWriterFlusher interface { ResponseWriter optional Flusher } then you could have r.Flusher be nil if the object does not satisfy Flusher. NB: Not really a fully thought through proposal, but just follows my desire that the signature convey everything available.
I would suck it up and write all the code in Go. At the very least some of your validation and other logic like this could be reused and it will be easier to keep the app in sync. Btw can you use something like the "Using embedded data and an alias type to reduce code" section of this post - https://blog.gopheracademy.com/advent-2016/advanced-encoding-decoding/ - to reduce your code duplication on the JSON front?
https://www.reddit.com/r/golang/comments/6qicgc/the_trouble_with_optional_interfaces/dkxsuf1/
But now you are stuck to one job type :P 
I am currently building a project that requires an admin frontend of sorts, what I ended up doing is writing backend API in Go, using go-chi/chi &amp; go-chi/render. So a typical scenario for me similar to yours right now is managing storage mounts via frontend, I wrote a middleware for it that retrieves the mount, puts it into context, and passes it on. The actual http method handlers only handle IO (actually just calling go-chi/render stuff) and perform specific operation on mount in context that implements my own interface. ie. I use `render.Bind` to process request body into my struct with all the fields checked in the Bind function the struct implements, then I change the mount how I want to, finally call the `render.Render` (which again, my structs implement) to send the response back to user/client. [chi/_examples/rest](https://github.com/go-chi/chi/blob/master/_examples/rest/main.go) shows a good example of how to build a nice API
I have yet to stress my $10 linode instance with my blog :( haha
Thanks @Mikojan for looking at my code. For testing..agree I missed it. I have written some test cases but didn't commited it. I will add it. I am not sure, but i found over the internet many people prefer to use negroni middleware and in this case I found it easily fulfilling my request id need. However yes I agree when i want to write my own middleware, then I need to restrict it to negroni interfaces. For logging..any suggestions to make interface for any type of logger? 
Error handling in Go is beautiful. One of the things myself, and many others love about Go is that there is no magic and the sugar is extremely limited. At first it sucks, but after you *invest* a small amount of time into handling errors appropriately and you come up with a feature complete static binary.. it's kind of astonishing how stable your code is. Coming from an interpreted language like Ruby this should be an obvious win. Your code isn't breaking anymore.. and if it is.. you know *exactly* where and why.. no more hunting and pecking form mysterious bugs.
Yes, I have something like that, its the admin views that I wanted to auto generate somehow. Qor actually worked quite well - I don't use Gorm on the main app so there is some "concept" duplication now.. (SQL to generate my tables on my main app, same tables represented as Gorm models on the admin app). I'd have to choose between keeping it this way or migrating the main app to Gorm as well ....
For that approach, I think [errGroup](https://godoc.org/golang.org/x/sync/errgroup) would be a good fit
Had not seen that, thanks!
Make sure you're comparing apples to apples: http://godoc.org/gopkg.in/mgo.v2#Session.SetSafe http://godoc.org/gopkg.in/mgo.v2#Session.SetPrefetch http://godoc.org/gopkg.in/mgo.v2#Session.SetBatch
https://postgrest.com/en/v4.1/ and then use something like https://github.com/marmelab/admin-on-rest 
I'm still fairly novice at Go but currently I'm working on Go backends with HTML/JS front-ends. A few things: 1) If you're doing REST with separate HTML/JS code*, highly recommend to take a look at GRPC and GRPC Gateway. We've been very satisfied by it. https://github.com/grpc-ecosystem/grpc-gateway 2) For front-end I'm not sure how complex your things are. I recently picked up Vue JS but if you know absolutely nothing I definitely recommend starting off with some basic pages and getting comfortable with it. Also someone above said Ajax and JQuery, my understanding is that this is the current recommendation - https://github.com/mzabriskie/axios *You can do your HTML rendering in Go. Personally, this feels a bit less comfortable to me for reasons I can't articulate well. For example, I'd feel like debugging would be more difficult as you'd have to make sure your template is working. https://golang.org/pkg/html/template/
It does look like it does a bit more than the basic example, by changing the pool size dynamically. I'm not sure what benefit that type of thing gives though.
It was easy and fun to read until we got to the bit about Berlekamp-Welch. The author suddenly stopped explaining things with easily understood math and language. 
What does being static have to do with error handling? Crystal has a better typing system than go and has the same error handling as ruby. It also has generics, macros and a bunch of other features which go doesn't have and still manages to have a sane exception system. 
Yes, that would prevent the resource leak. I made a small example modeled after your logic where you can see goroutine count with or without buffered channels. https://play.golang.org/p/ex5gyNQULo
I was speaking on the stability of the program - having a static binary is handy. It solves the "but our environments were slightly different" problem - in the same way running an interpreted language in a container does. My point was that most Go programs are very stable, and we can thank the enforced (errr... encouraged) error handling, and those sweet sweet static binaries for that. I have never used crystal, and my ruby is shit. So I can't speak intelligently on your points regarding Crystal. I am sure it works just fine though. Just trying to speak for the errors in Go is all :) 
Tried it out, pretty cool! Just one problem, your `tickerMultiplex` function consumes 100% CPU, because it's busy waiting for channels. Submitted an issue.
Take a look at the gin framework and write everything as a REST API, then create examples of all the JSON response data you will return. There are tools for Go such as JSON-to-Go that will create all the struct declarations for you.
Thanks - will try that on future projects. BTW are you brazilian?
*Builder of said form here :) I would recommend just starting one! I've advised a lot of meetups in the past. Happy to chat. @cassandraoid on twitter or cassandraoid in the gopher slack :-D
Golang support for webRTC is not good. I am looking at doing this at my full time job for a project, and am projecting about 3 months of work to get something that will be close to production ready....and I have 2 developers that I can task on my team as well.
I think there are a lot of good reasons for wanting better package management, but "what if Github gets purchased and rebranded or if it becomes defunct" is not among them. If this happens, it would be a minor inconvenience for maintainers who consume your project--someone sets up a mirror and every maintainer has to `sed -i "s/&lt;old_url&gt;/&lt;new_url&gt;/g" $(find . -name \*.go)`. Most likely, it won't happen in the near future, and when it does consumers will be given months or years of advanced notice (like code.google.com). Similarly the odds of the U.S. government blocking internet access to Iran (or anywhere else) is as miniscule as the workaround is trivial. I don't mean this to be pedantic; it's just important to derive your requirements from reasonable use cases. I don't want concerns such as these to govern the design of package management.
&gt; To make critical fixes to packages in the standard library, one must wait 6 months for a new version of Go to ship (or a point release has to be shipped in the case of security issues, which drains team resources). I realize the article suggests breaking more functionality out into external projects to get around this, but I'll also advocate (again) for a shorter release cycle. 6 weeks makes more sense than 6 months, IMO. I'd be curious to hear arguments _for_ the long cycles though, as so far I haven't been convinced.
Make certain you're not opening a MongoDB connection per request. When you get the code right, go should blow away nodejs in terms latency, total throughput, memory consumption, etc.
I much prefer to have writers just hold a lock and write directly, instead of shoving work over a channel to a dedicated goroutine. Most of the rest of the article seems to advocate using your own poller and basic HTTP stack (just enough for websockets), instead of usual Go I/O and libraries. That's unlikely to be useful for many.
The talk about exposing compiler tools as a library sounds like Go could approach running code at compile time, like D or Jai offers! But maybe I'm reading too much into it / being too optimistic. 
I strongly agree.
Hilarious! Someone is annoyed. Came in and down-voted the post and all the comments. Who pissed in your cornflakes this morning?
As the article says, this is a nice intro to memory layout for those not coming from C.
I opened a proposal about this, please check it out and add a comment or vote. :) https://github.com/golang/go/issues/21296
If you have something mission critical and are really concerned, clone original repositories to your own server (something like `gitlab`, `gogs` or `gitea` running on your premises) and import that into projects. Regularly pull/merge from the origin as necessary.
Thanks! I appreciate you taking the initiative.
&gt;Another future usability improvement that dep might enable, is allowing Go to work from any directory (not just a workspace in the GOPATH), so that people can use the directory structures and workflows they're used to using with other languages. Yes, please!
Is there a reason for you to not contribute to [github.com/gopherjs/vecty](https://github.com/gopherjs/vecty) which is actually more advanced and usable?
Isn't this really solved quicker by vendoring your dependencies inside the repos that use them? 
I looked at this a while ago as well and I agree that it's definitely more than a month of work. Some of the crypto/transport primitives (like DTLS, SCTP, possibly others) which WebRTC uses simply don't have native-Go implementations yet. There are a few options for binding against C/C++ implementations but that makes cross-compiling to mobile targets a huge pain. I'd consider 3 months to be pretty optimistic. If this does get done, it would be hugely appreciated by many people though. Maybe focusing on DTLS/SCTP implementations in pure-Go that are compatible with WebRTC's would be a better first-step milestone. IIRC there are a few half-finished attempts out there.
What more do you need lol
This is one of the things I like about go. You have a simple language at the core, can easily exploit modern resources but still can reason about memory consumption and runtime behaviour of your code. Try that with Java for example: Memory usage is dependent on the respective platform implementation, so the specification makes no guarantees on memory allocation and layout.
C doesn't need the developer to disable a garbage collector manually since it doesn't come with one at first place.
Yea, I dunno why this is getting downvoted so hard. Maybe a little scant on details but don't think it violates any of the rules of this subreddit?
related q: are any of the gaps in this matrix closed/gonna be closed? https://github.com/Masterminds/glide/wiki/Go-Package-Manager-Comparison
He was so proud of r/golang he literally deleted his reddit account as he wanted nothing to do with the drama here.
What?
Someone run Godzilla on GopherJS output.
Well, I'm running a REST API that serve static content. In the last 24h I got 571,578 requests but I can't even stress test my software because everything is cached with my CDN lol.
It depends. If you want to be able to modify vendored libraries and have that immediately available to your other projects, fork it. You'll be able to send PRs proper too. the other nice thing is that you'll have your own stable URLs for forked packages, no matter if original moves from Github to Bitbucket, for instance. Canonical package import paths feature in Go may interfere with this setup. But I have seen only a couple projects enforcing canonical imports so far.
Should we find something in Python first and use Grumpy to get this party started?
IDK about deleting his account, but there was this discussion of deleting r/golang https://groups.google.com/forum/?_escaped_fragment_=topic/golang-nuts/XoOhzUClDPs#!topic/golang-nuts/XoOhzUClDPs
Oh wow. I wish Go team's position on Reddit was more visible.
"lol", huh. What I need is code that looks more like stdlib Go, not separate ecosystems within one compiler.
*a lot
I used protobuf, grpc, grpc-gateway to generate server side models and plumbing as well as a swagger file. Then I generate a TypeScript client from the swagger file giving me a JS API and models that match my grpc models. Then all I need to do is write proto files and everything except for business logic is generated code. 
did you try https://github.com/xlab/c-for-go
Thanks, will get that sorted!
I can't believe some of the recommendations on here. I've been a web developer for 3 years. I know thats not very long in the industry but In that time I've worked on java struts, angular 4 and node, angularjs, dot net mvc, jquery. You absolutely should not be doing a web gui in go. Not professionally. IMO not ever. You basically have these choices, Simple HTML and jquery, angular 4, Vue JS, or react. You should stay away from Ember, and angular 1. Those are old. If you are just learning front end development, a jquery app is the easiest but the most dated. 
I wonder how the generate file would compare to the actual source
I'm working on a Go to Typescript transpiler right now, the Go ast parser makes things really easy. 
nope
 _ = myTemporaryVariable Makes your code readable, allows you to pick up where you left off, makes sure you don't forget about unused variables, and tons of other benefits. Use it.
that's a lot of concurrency!
Great work-around! Although still a pain to go looking for your variable declarations when you comment out a section of code just for debugging purposes. Clearly the language isn't ready for serious use yet.
Is there something similar for unused packages? Sometimes I comment out a block of code to test something, which cascades to unused variables, which then cascades to unused imports.
Can't you access your servers remotely at all?
nobody's ever trolled on the internet before
Clearly some people have never seriously developed, either.
&gt; If the language lends itself to be able to be developed without I don't think a 'language lends itself' to that so much as a project does. If you mostly develop small software with limited complexity, something like an IDE will be less of a beneficial impact compared to working in a large sophisticated project.
Well, you have to remember we are [a wretched hive of scum and villainy that should be killed](https://groups.google.com/forum/#!msg/golang-nuts/XoOhzUClDPs/bYS9SKY7CAAJ).
&gt;I was speaking on the stability of the program - having a static binary is handy. It solves the "but our environments were slightly different" problem - in the same way running an interpreted language in a container does. Docker solves all of that for all languages. Anyway Crystal does build static binaries but they may depend on clib I don't know. &gt;My point was that most Go programs are very stable, and we can thank the enforced (errr... encouraged) error handling, and those sweet sweet static binaries for that. Crystal programs offer better typing and better error handling. Many languages offer better error handling. Seems like you have settled. 
Does this code (well, actually API) looks like stdlib Go? frame, err := ws.ReadFrame(conn) if err != nil { // handle error } // or even simplier: msg, err := wsutil.ReadClientText(conn) if err == nil { log.Printf("client sent: %q", msg) } The network poller is just one part of optimizations. It is not required to use it =)
unused variables is an error by design. Go uses a runtime GC, such variables would waste space and cpu cycles. The better question is: Have you matured to the point where you clean your own messes? 
Really? When the package manager (say `dep`) needs a package named `foo/bar`, the resolution process needs to **completely decouple** the name 'foo/bar' from both: - The source of the package 'foo/bar' - The set of available versions of the package 'foo/bar' - How the source code for package 'foo/bar version X' is returned and cached locally. Now, you can certainly have a repository server that you implement using DNS to lookup the name 'foo' and try to do some custom multi-step protocol resolution to resolve the remote and download the binaries. Or... you can have a fallback that somehow derives a remote git url from `foo/bar` and clones it and looks at the tags (how go get works). Or you can have some override file that defines a custom override remote svn archive, or a curl request to S3 that fetches a tar file with a versions.json in it... ...but ultimately what it boils down to is that the core functionality that the package management tool needs is **not** Discovery, Auditability, Publishing, Ownership and Namespacing: those are properties of a centralised package management *server*; what a package management *tool* needs is: - package name resolution - package version resolution - package binary fetching - local package caching I mean, really? Is building a new federated distributed mongodb backed package repository really the first step? Now, *why on earth* would you choose to build an entire new system that did all of the things described (which is currently what's happening --&gt; https://github.com/golang/dep/issues/286)? ...instead of building the tooling to support an arbitrary implementation of the required basic functionality, which currently doesn't exist? How about this: When `dep` needs to install a package, it calls the command line tool `dep-fetch`, which can: - return a list of versions - download a specific version to a specific local cache folder. That's it. That tool is independent of `dep` and can be implemented to be whatever the user wants it to be. Maybe the 'default' `dep-fetch` uses `go get xxx` semantics, and the super repository version talks some protobuf binary protocol to your federated DNS servers to whatever. ...but hey, if you want to take your own stab at rolling a solution, like say, an internal private repo, or a local shared drive... off you go. Maybe you can even just have a little local .fetch file that says what implementation to use at the top level of a project rather than globally installing one. I mean, if we already had that functionality, I could take this effort at least semi-seriously... but we don't. This solution is such a ridiculously complicated fix to the problem, I struggle to just stand idly by while it gets built. What are you doing guys!?
Please compare Berlekamp-Welch vs just reconstructing the data and recreating the erasure-coded chunks -- is all this complexity worth it?
certainly not in go, you can't find anything in that 
&gt; think we've all said "fucking xxx in language yyy" There's a difference between muttering that under your breath vs registering a domain and flaunting it to the world.
&gt; We even bought a special domain to show this off: http://fucking-go-slices.com/ -- from https://www.reddit.com/r/golang/comments/6p88m9/golang_slices_gotcha/dknfa3b/
If you want people to have a more positive view of reddit (and this subreddit), maybe stop being so inflammatory? Not only is that a movie quote (and he explained that), there's also an *insane* difference between saying a subreddit should be killed and the people *participating* in that subreddit should be killed.
On the contrary, I like people to remember that these things were said by people who react incredibly strongly to someone else saying anything negative; the whole CoC fiasco started because they wanted to stop *others* from saying little things like this. I am using "we" to mean the community, not you and me as individual.
I think you are vastly underestimating the pain it would cause (and the complexities of "setting up a mirror" of github, FWIW) if GitHub went belly-up… &gt; Similarly the odds of the U.S. government blocking internet access to Iran (or anywhere else) is as miniscule as the workaround is trivial. AFAIK, Iranians can't access golang.org *today* due to US export restrictions. Which have been in place since long before irrational madmen have taken over the wheel… IMHO if you publish a package, you should make sure that you own its name. It just seems common sense to me that you wouldn't want a third-party to own it, *even if* them exercising that ownership against your will is minimal.
I hope it doesn't. Go currently goes to great lengths to try and ensure that builds are fast, side-effect free and safe. The easiest way to destroy all of these is to add metaprogramming. Now you can't even issue "go build" without first being certain that the code isn't malicious (and, technically, not even do any static analysis, because the code doesn't have to be correct anymore, before being executed).
I'm imagining it as a way to initialize some memory at compile time instead of runtime, i.e. some large map or if you need prime numbers, run the sieve at compile time. The safety concerns are worth noting though.
Everything looks like stdlib if you make it idiomatic. Sometimes you can't rely 100% on stdlib, you have to write something more lol
After using the new version for a few days in my work-environment, I must say that it is indeed significantly faster. I've had minor hicups, but nothing lasting more than 5-10 seconds as you said. If my problem recurs, I'll be sure to report the performance issue. But so far, kudos on the work. The editor feels a lot smoother with this update :)
With protobufs are you able to define nullable fields. With thrift there is no way to define something all nullable which makes some database operations interesting.
&gt; Though it's good your showing your true colors here, before someone decides to work with you. Yeah, I'm wanting to pay for a developers time in forwarding the timeline of an "open-source" project that EVERYONE can benefit from. 
Flexible buffers require allocations at runtime, hence they can never be as fast as static-sized buffers. Plus, they increase the likeliness of memory exhaustion. And channels are a convenience layer on top of mutexes, so the same question applies here, too: How to make mutexes *plus* some functionality on top as fast as mutexes alone? In my eyes, the advantage of channels is that they provide higher safety and easier reasoning about correctness than bare mutexes. Neither ultimate speed nor ultimate abstraction are the primary goals.
That is cool. What stage is it at? Is there already anything to play with?
It depends on several things: 1. Does it have huge value to the end-user? 2. How critical is it in the big-picture? 3. Do you have to decide this now? 4. ... I would use the one that I can get up and running fastest... and revisit the question when there's some significant problem with the solution. You don't have to use multiple structs as long as you can store the same fields in the struct. _[See composed serialization](https://medium.com/@egonelbre/specification-types-ed9ddf35ec8f)_.
you wouldnt understand...
Looks nice. In the example HTML part, the client uses some StarX client, which looks like from another backend/server implementation of nano (also done by you). What is the difference between nano and starX?
Really liked Web Development With Go (especially accompanying screencasts): https://www.usegolang.com
given that nano is also one of the most commonly used editors on *nix systems these days that name may be some cause for confusion.
Orz, did not take this issue into account at that time
I don't think that's behaviour you want by default? You need to read the body, which can toss an error, and you have no way of knowing how large that body is, or what it contains. That would not be a very safe method of logging. Middleware like Gorilla allows you to set a custom logger though. You could simply wrap an existing logger with your body-reading functionality, and add that to the middleware? :)
I didn't know that vecty exists. But anyway, I want an go custom elements library, similar to polymer :) (but better, because it is in go)
StarX(https://github.com/lonnng/starx) was a complete clone from Pomelo(https://github.com/NetEase/pomelo/) but use multiple threads(goroutine), which was distributed, multiple threads model. Nano is a standalone, single-threaded model, which more easy to use. In most usage scenarios, the performance will not be a bottleneck, and GRPC could be used to implement distributed to gain better performance.
More than a day passed, are you going to allow us to actually help you? If it's as simple as you describe it you should be able to just publish it in a gist, it can't be more than 100 lines, with all the spaces included.
Nano compatible with pomelo protocol, all versions of the client SDK could be used for nano. Clients -------------- * **Javascript** * Websocket version: [pomelonode / pomelo-jsclient-websocket](https://github.com/pomelonode/pomelo-jsclient-websocket) * Socket.io version: [pomelonode / pomelo-jsclient-socket.io](https://github.com/pomelonode/pomelo-jsclient-socket.io) * **C** * Socket vesion: [NetEase / libpomelo](https://github.com/NetEase/libpomelo/) * **iOS** * Socket.io version: [NetEase / pomelo-iosclient](https://github.com/NetEase/pomelo-iosclient) * Socket version: [ETiV / PomeloClient-iOS-WebSocket](https://github.com/ETiV/PomeloClient-iOS-WebSocket) * WebSocket version: [GeforceLee / Websocket-Pomelo](https://github.com/GeforceLee/Websocket-Pomelo) * **Android &amp; Java** * [NetEase / pomelo-androidclient](https://github.com/NetEase/pomelo-androidclient) * [Jzsues / pomelo-websocket-java-client](https://github.com/jzsues/pomelo-websocket-java-client) * **Unity3d** * Socket.io version: [NetEase / pomelo-unityclient](https://github.com/NetEase/pomelo-unityclient) * Socket version: [NetEase / pomelo-unityclient-socket](https://github.com/NetEase/pomelo-unityclient-socket) * **Flash** * Socket.io version: [stokegames / pomelo-flashclient](https://github.com/stokegames/pomelo-flashclient) * Socket version: [D-Deo / pomelo-flash-tcp](https://github.com/D-Deo/pomelo-flash-tcp) * **Cocos2dx** * C++: [NetEase / pomelo-cocos2dchat](https://github.com/NetEase/pomelo-cocos2dchat)
I know it's not direct answer to your question, but you could try building your binaries in Docker container so all of these informations would be absent in the binary itself.
Might want to proof read your article, there's quite a few typos like $&amp;nbsp;go get github.com/kris-nova/kubicorn
This is first line of my Makefile: GOB=go build -ldflags "-s -w" -gcflags="-trimpath=${HOME}" -asmflags="-trimpath=${HOME}" Probably it doesn't strip everything, but at least will remove your username from the binary.
For production builds you should add the ldflags='-s' flag to randomize functions names, this makes it harder to reverse engineer the binary. However this does not affect the presence of your gopath in the binary. Compile in a docker container / vm if you really care about that 
&gt; For production builds you should add the ldflags='-s' I already do. &gt; Compile in a docker container / vm if you really care about that That's what I'm going to do.
The problem is the body of an HTTP request can be bigger than is practically logable...
I don't agree. c &lt;- func() { doWorkOfTypeOne(context1) } c &lt;- func() { differentWorkFunction(differentContext, MoreArgs, 123) } As long as the work can be expressed as something of type 'func()' it can be passed as a job. And func() seems to me to be a good definition of "work".
I see. I do write my logger to record request body, But I ignore the body size and content problem. Thank you everyone.
This might be a rendering issue on your end as they don't show up for me.
I just updated the article, OP was right there was an impostor `&amp;nbsp;`
But why?
I needed it, the existing implementations were incomplete and unmaintained. Now I'm sharing it. Usual story I suppose since this fancy "open source" stuff became all the rage.
Yes there is : `import _ "my/package"` ! Or better yet, use goimports to rewrite your imports to match your requirements.
I'd add a few more code examples if I were you, otherwise this seems nicely done assuming it's performance is ok... which brings me to my second point, add some benchmarks, those would help a lot, especially since I assume there are people that want to switch from pomelo due to the overall average performance of node and a faster drop in replacement might be very welcome as far as they are concerned.
I said commonly used, as in, doing a base install will almost always include nano. I believe Ubuntu's docs almost exclusively use nano as an editor by default when explaining how to edit config files by hand. Don't get me wrong. I fucking hate nano. Vim4lyfe and all that. But nano is a common editor.
Best practice is always to declare your variables as late as possible, if possible just before use. If your code follows this, then it is exceedingly easy to comment out a part of your code. However I agree some IDE tooling to automatically comment out unused variables when you comment out code would be nice. If you're so interested in looking at go as a potential development language for you, maybe you should build it ? Would be a nice introduction to this language you're so interested in.
There are also security implications of logging private details like passwords
Here's another example which glues the context and the func() together elegantly (IMO): type MyJob ... // something or other (the context) func (mj *MyJob) DoWork() { ... some work on mj ... } var mj MyJob = .... // construct a MyJob c &lt;- mj.DoWork Here I'm passing in the method value directly, since once it's bound to `mj` it has type `func()`. Internally the compiler generates a closure on mj and which calls `(*mj).DoWork(mj)`.
I did not read the "one of the" part and though the comment would come be funny, nvm it :p
X-Post referenced from [/r/netsec](http://np.reddit.com/r/netsec) by /u/arvanaghi [CheckPlease: Implant-Security Modules in PowerShell, Python, Go, Ruby, Perl, C, and C#](http://np.reddit.com/r/netsec/comments/6rgww1/checkplease_implantsecurity_modules_in_powershell/) ***** ^^I ^^am ^^a ^^bot. ^^I ^^delete ^^my ^^negative ^^comments. ^^[Contact](https://www.reddit.com/message/compose/?to=OriginalPostSearcher) ^^| ^^[Code](https://github.com/papernotes/Reddit-OriginalPostSearcher) ^^| ^^[FAQ](https://github.com/papernotes/Reddit-OriginalPostSearcher#faq)
Both of your examples are trivially done today with `go generate`.
That's actually not bad at all. The only other argument I have is with the interface you could a Name() which could make debugging easier later but yeah I kinda like what you did there
s/Golang/Go
&gt; we are a wretched hive of scum and villainy that should be killed. Yes, you are, son. Yes, you are.
It's used more widely than you might think - as one example .rpm packages are cpio format. A Go implementation is a useful thing.
&gt; the ldflags='-s' flag to randomize functions names `go build -h` says: "-ldflags […] arguments to pass on each go tool link invocation" `go tool link -h` says: "-s disable symbol table" How do you go from that to saying "to randomize functions names"? IMO symbol tables have a good reason for being there and I'll keep using (and more importantly, recommending) the default build flags.
Logging HTTP request bodies is probably only going to be worthwhile in a handful a scenarios like PUT and POST requests; the rest are going to end up being GET requests and use URL parameters and thus you don't NEED the body to determine the code paths in question. Additionally, as /u/Redundancy_ mentioned there are security implications in just dumping this information to disk or to a database or god forbid a service like Splunk or Logstash. You'd be dumping plaintext usernames/passwords, credit card info, whatever. FINALLY you mentioned that you *have* code that currently isn't working. If you can build a minimal reproducing sample ( cut out every possible piece of code that isn't directly related to the problem ) and post it, you might get some practical assistance.
https://en.wikipedia.org/wiki/Go_(programming_language)
**Go (programming language)** Go (often referred to as golang) is a free and open source programming language created at Google in 2007 by Robert Griesemer, Rob Pike, and Ken Thompson. It is a compiled, statically typed language in the tradition of Algol and C, with garbage collection, limited structural typing, memory safety features and CSP-style concurrent programming features added. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/golang/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.24
Sure, but that requires an additional command line action besides run, doesn't it?
Dave is... rather controversial. On the one hand he is very good developer, who values simplicity in things and truly understands how important this subject is in modern software development. The minimalism. He is also author of good libraries such as github.com/pkg/errors and tools like gb. On the other hand his condescending manner of speaking and being somewhat fanatical about things, does not make it easier to talk with him or even listen and read. I know it's just my impression, but many others had experienced similar feel too. Nevertheless he's one of the "stars" among Go community. Even if I disagree with him, most of the time he makes an interesting point. 
Stripping the symbol table leads to function (aka subroutines) names being stripped and randomized, example: myfunc() -&gt; sub_40f270. You can verify this in a dissassembler and it's generally a good practice for protecting proprietary code or make it harder to disable software licensing protections. It also shrinks the binary file size. The -w flag is also useful to remove DWARF debug information 
Excellent points. I think this would be a "systemd" level of a mistake to make. Do one thing well. 
If you have corrupted and not just missing data, which chunks do you reconstruct with?
More demo and docs coming.
Good point, I think it got lost somewhere when rewriting the docs. Just added it back, it was a `vg init` command btw.
Can someone explain why this information is needed in a statically linked binary? Is it just metadata, or does it serve a purpose?
Removing the symbols and debug info doesn't only removes the authors "notes" about what a function does. The functions are still there and still do what they were programmed to do. Removing symbols is like taking the pictures out of books, and numbering the characters. Sure it is annoying to read, but the story is there nonetheless. Point being, don't depend on this for doing much of anything. The easiest way to undo this sort of thing is to just add the names back in from your reading of the machine instructions - takes a little extra time and makes the problem all the more interesting for someone who likes challenges. I'm not saying you shouldn't try to protect your software, but if the only effort you are willing to put in is to scramble the symbols...the "protection" is only going to match the effort.
Of course. Still a good starting point, if you're interested in protecting your software!
I think a typical trick is to add integrity to each chunk, with a hash or CRC.
I think you meant "manner of speaking" instead of "[manure of speaking](https://giphy.com/gifs/9BIJWVFcstFhC/html5)." :)
You are absolutely right! I was really wondering why my auto correction kept suggesting me that word and I as a non english speaker just went ahead with it without actually checking the definition. I'm sorry if this came out wrong - I was not trying to offend. Tho I must admit it made a funny pun. Fixed anyway tho. 
I did one of these for Java: https://github.com/cretz/goahead
Files implement [io.Seeker](https://golang.org/pkg/io/#Seeker) via [File.Seek](https://golang.org/pkg/os/#File.Seek). This lets you move around within the file w/o actually reading every byte along the way. That being said, seeking backwards one byte at time and reading it is likely inefficient, so it might make more sense to seek in some fixed block length, read that into a byte array, and then just walk the byte array backwards to 'read' it byte by byte backwards.
Yes, why?
Fun! Although in the real world I'd probably just use awk (mawk for speed). Not nearly as fast to run but took 30 seconds to write... just change $2 and $3 to the columns you want for key and value [emg-ubuntu16 tmp]$ time mawk '{s[$2]+=$3}END{for(y in s)if(s[y]&gt;m){m=s[y];mi=y}print"max_key:",mi,"sum:",m}' googlebooks-eng-all-1gram-20120701-0 max_key: 2006 sum: 22569013 real 0m2.201s user 0m2.152s sys 0m0.044s more readable { sums[$2] += $3 } END { for (year in sums) { if (sums[year] &gt; max) { max = sums[year] maxyear = year } } print "max_key:", maxyear , "sum:", max } nothing beats awk for ease of use with tabular data
What was the motivation behind this? Are you planning to add more stuff to this, or are you aiming this to be just a framework library and not a standalone server?
Thanks, that makes sense. What about for a `response.Body` (`io.ReadCloser`)?
Out of curiosity, what was wrong with https://github.com/surma/gocpio ? I have some code using it.
Debugging
In general, sometimes you can 'check' if a struct inside an interface actually implements another interface with a [Type assertion](https://tour.golang.org/methods/15). So in some cases, the underlying struct might still implement io.Seeker and you could take advantage of that. However, I took a cursory glance at the different ways response.Body is set and didn't see any io.Seeker impls. Likely because response.Body is streamed to you as you read it, so you don't actually have the whole thing to seek within anyway. In cases where you basically only have access to an io.Reader, you're going to have to hold onto the entire thing in order to reverse it. In that case, either read into memory/file and go from there.
Maybe nanonet is still available! :)
&gt; I think you are vastly underestimating the pain it would cause (and the complexities of "setting up a mirror" of github, FWIW) if GitHub went belly-up… You don't need all of Github, you need mirrors for the repositories on which you depend. Moreover, there need only be one mirror per repository for everyone who depends on it. &gt; IMHO if you publish a package, you should make sure that you own its name. It just seems common sense to me that you wouldn't want a third-party to own it, even if them exercising that ownership against your will is minimal. Right, but my point is that this is the absolute least of all concerns in software development. Github going belly up or a restrictive government are the least of your risks.
Pretty sure your formatting is wrong. I can't comment on the format of the build tags themselves because I don't use them like that, but I'm fairly certain there needs to be a newline after them for them to be treated as such. Also, I'm fairly certain you need to have your package declaration in the file between the build tags and the C code you intend to import. I think it should look more like this: // #cgo windows CFLAGS: -I"E:/WindowsSDK/Include/10.0.15063.0/um" -I"E:/WindowsSDK/Include/10.0.15063.0/shared" package whatever // #include &lt;windows.h&gt; // // void test() { // // } import "C"
Hi there pknopf - Do you think you've ever found out what's wrong? I have the same issues as well especially when stepping into an imported package (working on database/sql), then the debugging highlight just jumps everywhere - Pressing F10 sometimes moves the highlight upwards instead of move forward on a perfectly sequential code. Also latest version of Go with dlv. 
You want https://golang.org/pkg/io/#ReaderAt Combined with the 2MB chunking logic from https://talks.golang.org/2013/oscon-dl.slide that'll even perform great.
Cue http://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/
Don't know how I forgot about ReadAt, probably better than seeking.
&gt; Plus, they increase the likeliness of memory exhaustion. So does a flat buffer if I use a struct channel and put big stuff into my structs ... &gt; Flexible buffers require allocations at runtime Like most things do at runtime? HTTP requests and such.
&gt; Right, but my point is that this is the absolute least of all concerns in software development. And it is your prerogative to set your own priorities. I disagree with that assessment. People and projects move hosting providers all the time.
No luck here. Sorry.
Hey no fault of yours - Cheers bud. I am half thinking of trying IntelliJ with Go extension and see how that works out. Will report back. Addendum: Just venting, but I found Golang rather frustrating to pick up, coming from .NET. Maybe this will come to pass, probably I am just way too familiar with Microsoft's platform. Fingers crossed!
I'm in same boat. I'm .NET guy. Also, intellij had same issues.
&gt; People and projects move hosting providers all the time. How many companies do you reckon went under because code.google.com was terminated? I guess I missed those post mortems...
never change, tv.
For one, if your program panics you'll see a trace of the files and line numbers.
I'm relatively new to Go and would appreciate any feedback, especially corrections. Thanks very much!
Interesting and perhaps an not uncommon approach. Should a self contained service contain the data inside it self? When I see lots of lines I see lots of coupling. Thought experiment, when you add a new piece of data to your system what has to change? Network calls between all components. I get there is a lot of flexibility offered by having everything communicating via the network, but is that an efficient thing to do? The network is very expensive compared with a local function call, a lot more things to go wrong too. 
epiris mentions a path traversal vulnerability and now it's replaced with this. "wtf", yes, very much. newFileModel := FileModel{Path: Configuration.FilePath + strings.Replace(name, "/", "wtf", -1) + extension, Name: name, TTL: int64(ttl), Birth: time.Now(), https://github.com/George3d6/Hermes/blob/1a7b30ab2b95eeecfc249ded267720fd09be2bcf/server/handlers.go#L204
To be concrete, and reading between the lines, are you trying to read from an incoming HTTP response body backwards without reading the whole thing into memory? It is impossible to read the last byte before all the other bytes have been sent to you, because that it how TCP works and is guaranteed to work. It doesn't matter what abstractions any language lays on top of that, because the abstractions can not magically manifest the end of a network stream they haven't received yet. Think about how the network packets look under the hood.
Author thinks `atomic.AddInt32` and `atomic.AddInt64` differ in nothing but the type, and that you can magically have `Add&lt;T&gt;` and everything will smell of roses.. in reality, the underlying asm is hand crafted for each.
That is… not what I was saying. Like, so much not what I was saying that I genuinely have no idea how you made that connection. I was saying that moving hosting providers is an enormous pain for a project, if their project identifier includes it. And that projects do that all the time. And that by making it more of a pain, by not decoupling your identifier from the hosting provider, you are going to make this pain part of the equation and are going to suffer unnecessarily because you are avoiding a move. And, as you brought it up: Yes, [code.google.com going down is a perfect example of that pain](https://github.com/search?q=language%3Ago+code.google.com&amp;type=Code&amp;utf8=%E2%9C%93).
I'm not new to Go, but this was fun to watch. "fizzbutt" lol. I've only watched the first 4 minutes, and everything you said so far has been solid: it was correct, and I didn't spot any issues. Edit: Watched the rest, everything was still good. Nice job! Edit 2: My comment is based on the content of his video, and my understanding of it as an exercise to play around with Go and its cool features, not to write idiomatic Go code that's most similar to what one would write if it were production Go code. He was careful not to make any incorrect statements like "this is definitely faster" or "this is the best code".
&gt; It’s not pretty and only implements the new ASCII format. From its README.md
The API seems perfectly workable, and this new library *also* only handles that same SVR4 format. Non-SVR4 cpios are pretty rare, these days.
¯\_(ツ)_/¯
[removed]
If you manage to do it for your full-time job. Will you be able to collaborate on lib2p2?
&gt; I genuinely have no idea how you made that connection. My argument was that having to change hosting providers was the least of all concerns facing a software project. There are many real, viable, existential threats facing software projects. You said you disagreed; if you disagree, then surely the largest identifier change event in the Go ecosystem to date (the demise of code.google.com) would have caused many software projects to shut down (given that identifiers are an existential threat and all). Anyway, your link doesn't depict any sort of problem; it depicts exactly my point--that changing an identifier is an effortless, automatic process. I also question your claim that projects are always changing hosting providers. I suspect any given project changes hosting providers once every five years (and the overwhelming majority of projects won't even see 5 years); I can live with a `sed` every five years.
It's definitely wrong to hardcode the output and formatting in sets of 15. The correct way to do this would involve the modulo operator. if i % 3 == 0 { //print fizz } if i % 5 == 0 { //print buzz } EDIT: For completeness, there is no need for a mod15 evaluation, and using elseifs is also unnecessary. By avoiding those two things, both mod3 **and** mod5 can evaluate to 0 in a single loop, reducing LOC by a good few. Print formatting (like spaces or newlines) can then be handled at the end of the loop, outside of an evaluation block.
&gt;&gt;Plus, they increase the likeliness of memory exhaustion. &gt;So does a flat buffer if I use a struct channel and put big stuff into my structs ... Good point, but a fixed-size channel with large structs eventually fills up and creates backpressure on the producer rather than continuing to grow and fill all available memory. &gt;&gt;Flexible buffers require allocations at runtime &gt;Like most things do at runtime? HTTP requests and such. My point was that allocations cost time and hence flexible-sized channels cannot be as fast as fixed-size channels, let alone bare mutexes.
Have a look at [virtualgo](https://github.com/GetStream/vg). It manages multiple Go workspaces. I tried it out yesterday and it looks really promising.
I mean, if the education is how turn bad C++ into bad Go, sure. Not intending to belittle someone new to coding, but a certain level of expertise should be required before teaching a subject.
&gt; which is probably close to the read speed limit of my SSD. the file is cached. 
/u/nathanpaulyoung nails it.
What you need is a reverse buffered reader that initializes from a ReaderSeeker. A ReaderAt is not sufficient, because the interface has no way to find the end of the file. The buffered reader would read at first the last buffersize bytes from the file and read from it until the buffer is exhausted and then read the second last buffersize bytes and so on.
Who says this opinion is unpopular? AFAIK, no one has counted the "pro generics" voices versus the "generics no thanks" voices yet.
Why are you using channels for this?
Next step: Port [FizzBuzz Enterprise Edition](https://github.com/EnterpriseQualityCoding/FizzBuzzEnterpriseEdition) to Go.
I deliberately eliminated the modulo operator in the [previous video](https://www.youtube.com/watch?v=kYQF0EhsDx0), feel free to downvote ;)
What do you mean? Everything is there: https://github.com/golang
&gt; I'm relatively new to Go It's fun to try out the new or unique features of a language when starting out. They're definitely overkill for fizz buzz, but who cares, right?
https://github.com/golang/go/blob/58ad0176ca280c07a966249a3208f707ee0b1989/src/cmd/go/main.go#L69 is the main function for the "go" binary.
It's also a quick solution to test an app. You take a snapshot of the data and redo the posts...
Every generics discussion in Go.
&gt; I heard Go was open source It is. &gt; but I can't seem to find it's source code. [Github](https://github.com/golang/go) &gt; All I seem to find is the source code for it's standard library, nothing with a main function or anything. So when you download and install Go onto your local computer you install some pieces of code (packages like 'fmt', 'bufio', 'crypto', etc.) that you can use within the Go program that you are creating. There is no 'main' function to speak of because you are dealing with code that cannot execute by itself it needs to be used in something. Now the tools like "go", "gofmt", "cgo", etc. do have a main function. Those tools can be found [here](https://github.com/golang/go/tree/master/src/cmd). It's the same github link as before in the /cmd directory (it's because the tools are commands :P) However, there should be little reason for you to poke around the source for the tools. Rather, based on your self describe 'novice' level with go, I'd recommend becoming more familiar with the standard library (the packages I spoke about before) and learn how to appropriately leverage them in whatever you are wanting to do. &gt; I'm pretty novice so sorry if this is a really cringey question If you are looking to familiarize yourself with Go, I'd highly recommend [Go By Example](https://gobyexample.com/) until you get down to the section titled "Variadic Functions". Then I'd try to start solving 'small problems' with Go ( /r/dailprogrammer is a good little list of programming problems ). We were all noobs at one time or another :P Overall, hopefully that clarified some things for you.
Thanks man you're really helpful
What I should have said is: 'why can't you stress test your servers by contacting them directly?'
I could drop the CDN so every requests hit the origin server to test it but then I'll quickly hit the bandwidth allowance and I'd have to pay an unreasonable amount of money.
Watched long enough through the video to hear that you "unrolled" the loop based on an article you read. I didn't read that article, but if the goal is code readability, "unrolling" completely misses the mark. In programming, we have a readability and maintainability principle called DRY: "Don't Repeat Yourself". As with all guidelines, it isn't a concrete rule, but it is an exceptionally strong candidate for an "almost always" guideline. By "unrolling" the loop, you: * **Lose readability** - experienced programmers can look at a loop and instantly grok what is going on, whereas with your "unrolled" loop, you have to take at least a few seconds longer to look over the whole thing, ponder why it increments by 15, etc. * **Lose maintainability** - should a bug arise, or you need to adjust the formatting otherwise, you now have at *least* 15 instances of the same code (with slight variation) that all need to be altered or troubleshot simultaneously * ***Maybe* gain a little performance** - Perhaps the overhead of a one to one evaluation and incrementation per loop is slower than 14 addition operations per loop, but I would be surprised if the compiler doesn't make those differences negligible or nonexistent. This is bad programming style, and I would caution you to reject learning styles like this, and moreso encourage you not to teach them. Some other poor newbie could come across your video and develop very bad habits as a result.
He explains in the preceding video that he read some article or another on "unrolling" loops for readability (and performance?) gains. Either very bad advice by the author or totally incorrectly received by the OP. Either way, in the interest of OP and his potential viewers, I feel it's important to take a strong stance on this. But that's just me.
Just wrap the block with anonymous function and you got something like with. Also, can you elaborate about the overhead on `defer`?
&gt; Watched long enough through the video to hear that you "unrolled" the loop based on an article you read. I don't remember reading any articles...? Let me quote myself: &gt; So, a couple of days ago, Tom Scott released an interesting video about optimizing FizzBuzz for readability and maintainability. (laughs) And, that kind of made me wonder, can we optimize FizzBuzz for performance? Not that you really need that, but **I thought it might be fun.** Maybe it isn't clear from the videos, but I think optimizing FizzBuzz for *anything* is completely pointless; unless you enjoy fun. Don't get me wrong, I'm open to feedback; the majority of people seem to think this is a terrible video, and if this trend continues, I'm going to delete it in a couple of days.
Gosh, that is *too* funny.
Author here. There were a couple of discussions regarding unexpected behavior of slices and their operations recently, so I made an attempt of visualizing what's going on behind the scenes when slices are created, re-sliced, or modified through `append()` or `bytes.Split()`. TL;DR: Slices are nothing but viewports to a part of an array. Many operations do NOT create copies of the original data. If you are not aware of this you might be surprised to see data being overwritten. One particular function - `append()` - also operates on the original array but only until space runs out. Then it creates a larger array and copies everything over. If you are not aware of this, you might conclude that `append()` acts in a quite random fashion.
Article...video, alright my brain mixed that up. I'm on mobile at work and double checking is hard. And TBH, don't delete the video. Adding a mention in the description and/or one of those new Youtube ending doodads they came out with a while ago that makes it clear it's a FOR FUN series/video and not representative of proper programming style would be enough. Like, I don't want to discourage you from learning and teaching. I started learning code when I was a young teen without the aid of youtube and tutorials, and wish I'd had the resources available today. Sharing knowledge is an awesome endeavor. Just be considerate to people who only watch a single video, or people who know so much less than you that an innocuous and fun experiment ends up causing them harm.
&gt; He explains in the preceding video that he read some article or another on "unrolling" loops for readability (and performance?) gains. Please provide an exact quote or at least a timestamp, because I don't remember reading an article or claiming that unrolling loops improves readability.
This is not fine. This is great!
I enjoyed watching this, you have a soothing voice. Please ignore some of the people here. Programming is about having fun and trying things out.
Sure eliminating modulo will improve performance over millions and billions of calculations but it's fizz buzz so that just makes it complicated and not really work
It works but there are conflicting goals here. OP said that the C video was about "performance" and that's why the loop is unrolled. But then he throws channels into the solution for something that doesn't need goroutines / communication... so why not just use modulo? I think that's what feels off to most of the people who are commenting negatively.
Not trying to make a big deal out of it, but to me it triggers a reflexive "code stink" reaction. There are better ways of demonstrating goroutines/channels.
My guess would be that it's for the same reason one of the examples on https://golang.org is to calculate pi using goroutines and channels. To try out a language feature and play around with it. It's an exercise after all, not code for production. He was also careful not to make incorrect claims that it's better or faster. He said it _might_ actually be faster if the overhead of string formatting is larger than the overhead of doing concurrency, and you have multiple cores. Which is an accurate statement. In reality, it probably isn't. But no one can say for sure without writing a bench.
&gt; It's definitely wrong to hardcode the output and formatting in sets of 15. The correct way to do this would involve the modulo operator. Unless it produces the wrong output, I don't think there's a "definitely wrong" solution to fizzbuzz. The goals of each solution might be different. It could be to write code that's close to what one would write in production. Or it might be to use a language's features for fun and learning purposes. Or to make an hilarious enterprise-level of verboseness implementation. I've watched the video and he never said this code was optimal or the best way, just one way it could be done.
I think that's probably a really good theory as to why it doesn't get an error.
&gt; There are better ways of demonstrating goroutines/channels. Like what? Can you think of any? I think it's pretty hard to come up with a good demo for goroutines/channels that's around 50 lines or less. Maybe it's just me.
The core library will be streamlined, a complete framework should be accomplished with a new REPO.
Padding?
Because that's an situation that's much harder to detect, and its consequences are not a very common trap that would deserve explicitly protecting against.
I'm indifferent to the generics discussion but I'll admit I chuckled.
The field could be in use by other packages. These packages could be future and not even in your GOPATH. Even unexported fields are exposed via reflect. (don't do this).
The article itself seems nice, and gives a good overview of slices as viewports onto the data backing them. However pretending that bytes.Split() is a normal/good API could mislead people to design similar APIs with similar problems for no good reason. Not sure if you read the upstream bug report about it, but even the core go devs. agreed that they would have lowered the cap() on the returned slices if that was possible when bytes.Split() was written: https://github.com/golang/go/issues/21149
It's a good package. I also was using and am grateful for it, but my needs outgrew its features. I needed and implemented: * SVR4 *CRC* format support and checksum calculation * Conversion of [Headers, to and from io.FileInfo](https://github.com/surma/gocpio/issues/3) * Interpretation of the Mode flags * Tests - particularly fuzz tests * Support for older formats (coming soon) A browse through Surma's project gives a strong indication of its maintenance status. If it meets your needs, I see no reason to switch to this new package.
The new package additionally implements SVR4+CRC - required to read newer RPM packages. Older CPIO formats are common in old RPM repositories, which I also require.
IANAL, this isn't legal advice. What I would do is, if you're planning on a commercial deal ever, consulting someone who is a lawyer / can give you legal advice. As long as you aren't doing that, what I would do is copy the license and include it in the repo I was using. Some people choose to apply their license to every file that needs it, as a header to the file. IMO that is excessive.
When I included another header, #include &lt;windows.h&gt; #include &lt;PortableDevice.h&gt; It can't find PortableDevice.h, which is actually in E:/WindowsSDK/Include/10.0.15063.0/um. .\main.go:8:10: fatal error: PortableDevice.h: No such file or directory #include &lt;PortableDevice.h&gt; ^~~~~~~~~~~~~~~~~~ 
If it's only one or two files, I'd put the license in those files only. There isn't a good answer to "how much is enough to justify the use of a license"
The pi example actually gathers results from a pool of workers so it is slightly different. The very nature of fizz buzz is linear with the most elegant solution being what /u/nathanpaulyount pointed out. He says the code is clearly superior to the C version but doesn't really know. Between the needless loop unrolling, the gratuitous channel usage and the claims without understanding or proof makes the value of the video questionable to me. Yes he's learning, as we all are, but this is little more than a video selfie. Sorry, not trying to be mean, just calling it as I see it. 
This. There are numerous places in the Go source that make use of struct padding for alignment reasons across 32 and 64 bit architectures. 
#
Here's one in 38 lines: https://play.golang.org/p/TA8ZzrvMQa
What is it supposed to do/show?
The code speaks for itself.
Some tools make use of that metadata (most notably of the path to the source), like gorebuild, gobin, binstale, and my own goman. I daresay that most Go binaries don't leave the machine they were compiled on, and for shipping binaries, I'd join those who have already suggested using a container system (Docker or other) as a "neutral" environment.
I came for the comedy, generics is as good punchline as any
The article does not mean to imply any kind of quality of `bytes.Split()` including the eligibility as a role model for API designers. This function is just there, and it works like it does, and AFAIK it is the only split function for byte slices in the standard library. I did not see the bug report until now (thanks for pointing to it), but I have seen the corresponding [web site](http://fucking-go-slices.com/) (cough cough). The point of the article is really just to explain how things work under the hood. I do not want to say that the way slices work is a one-size-fits-all model. Go's slice model is clearly optimized for efficiency at the cost of convenience, and the article just shall point this out without judgement. The bug report suggests setting the cap of the returned slices to their respective lengths, to avoid overwriting other slices on append(). This is indeed a good solution if you ask me, but the opponents also have a point in saying that this would affect performance as well as the Go 1 compatibility promise. So I doubt that we will see an append-safe `bytes.Split()` in the Go 1 stanard library. - - - Update: Added the scenario from the bug to the article. 
I don't but you should include instructions on how to install it
Thanks for this! Needed something like this the other day and had to wrap a node.js tool to get moving again. Might go back and incorporate your lib here. Thanks a ton!
When I use CGO and manually operate on C arrays.
I find this interesting, but I must admit I skipped a bit through the presentation, reading the slides instead, and I was curious about a few things: how complete is the translation? What's the speed/memory gain on largish files (if you tested that)? How are classes/inheritance implemented, and how are the basic types (numbers, strings, arrays) implemented? Would typescript ever be a possibility (it adds more type information, which enables more efficient execution, but also makes compilation harder)? If it's answered in the talk, just say so.
It's a BSD License + Patent Grant, it should be similar to this: https://tldrlegal.com/license/bsd-3-clause-license-(revised) TL;DR: Commercial Use, Modification, Distribution and placing warranties is allowed, however, you cannot use google's trademorks or hold them liable. You *must* include the copyright and license notice in all distributions of substantial parts of the source.
&gt; Yes he's learning, as we all are, but **this is little more than a video selfie.** Nicely put! I recorded the video on a whim because I wanted to share my excitement about goroutines, nothing more, nothing less :)
This is not really true. The memory layout is not defined by the spec. There's even an issue discussing changes to it to automatically create optimal packing: https://github.com/golang/go/issues/10014
Well, they shouldn't because it's not in the spec: https://github.com/golang/go/issues/10014
Those animations are slick!
Thank you very much for your feedback! :) Yes a dedicated data storage (stateful) should be part of the SCS. All services around should be stateless that they can easily scaled up and down. Adding a new service should be very easy: Assume that we have a database container running and a database service container running. Now I can add my logic service on top of it and have to communicate only to the database service to add data. The network overhead is there and should be optimized (like database calls) during development. The networking approach is also pretty common on big projects like kubernetes, where the different components talk via http/s even on the same machine. I guess it is the only way to think of "cloud computing" for now. It is definitely more complicated to implement it this way instead of relying on function calls. But another benefit is that even the communication interface can be exchanged... :)
So my explanation wasn't so wrong. But I didn't thought about libraries, which makes totally sense to not remove unused fields. Thank you :)
It's an unpopular opinion amongst some aggressive Go2-must-have-generics advocates.
~~You're~~[What's your] point? Wikipedia is often wrong. In this case they're missing the word "incorrectly" as in "often incorrectly referred to as". To anyone that spent even a moment of effort looking into it would know, the language is called ["The Go Programming Language"](https://golang.org/ref/spec) (fullname, short name "Go"). Only a link to somewhere on the [official web site](https://golang.org/) ever calling it anything else would be relevant.
Thanks! :) I made them with Tumult Hype (what a name), in case you are curious. 
Yes, if it is Go related, it is appropriate.
Even if it isn't enforced by the compiler for the reasons below, you might still want to run an analysis tool like [codecoroner](https://github.com/3rf/codecoroner) to find any dangling fields/functions that aren't used so they can be removed.
Definitely yes! We love hearing about people using Go.
One is incorrect though .. in *Fig. 3: The two outcomes of append()*, t should still be "abc" and not "abcdef".
Hi everyone. Another big release for you all. This release has one main feature: syntax based folding! Give it a try and let me know what you think about it. It also contains many improvements and bug fixes (and I really mean it). Definitely check it out. Here is the full changelog with much more detail: https://github.com/fatih/vim-go/blob/master/CHANGELOG.md#114---august-6-2017 As always many thanks for all the contributors and you all for using vim-go. Don't hesitate to give feedback and open an issue if you encounter something :)
I am looking for advice on structure, things like how to abstract a decent size API. All of our other SDKs are O.O but that's not really a thing in go. Code critique is also welcome since I am trying to learn go. 
Syntax based folding! 🙌 You're my hero Fatih!
I have submitted a patch to include this upstream by default. Will update with instructions today, thanks for the advice!
Why, yes, I'm point.
I'm always interested in reading more Go blogs!
Sorry, I was unclear. The memory size of types is defined by the golang spec, in contrast to Java, where this is not the case and implementation dependent. At least you can inspect the memory layout on golang easily.
You're right. Berlekamp-Welch is simply another option in the solution space for if that's not on the table.
As always, your work on this is greatly appreciated.
 #1 is a simple and valid approach, but #4 may be the best because it's easier to test (just make PostStore an interface). BTW, usually people would write it as `NewPostStore` instead of `PostStoreInit`.
#4 is how I do it.
Me too The reason being i would likely want to be passing to another layer in my application something with the interface GetFooById(id string) (Foo, error)` i dont want other parts of the system having to worry about database connections.
That seems to be a very useful tool. Thanks :D
Yaas!!!!
I would go with 5 since because database connections are not something I would store outside of request scoped objects. Because they have state, can fail and be closed. If you really wanted to bind it to these structs at init I would create an interface that describes how to get a dbconn that returns DB and error instead. It also gives you a nice place to expand on behavior of accessing a database, since you now have an object that describes how someone should do just that. For example if you ever add failover partners and add some failover logic for readonly mode or something having an interface you can add a IsReadOnly() or maybe user permission checks for rbac can be nice. I know that Go dbconns are pooled and in most simple apps you won't need to open them, so if you decide on 4 it's not a big deal if it's easier Go for it. This advice is for the type of objects rather than the specific implementations as well as yours but at the end of the day it doesn't matter all that much. Have fun. 
This would be my approach to creating a Go package to represent this API: * define structs that map to the request and response types for the API (you can save a lot of time by copy&amp;pasting JSON from API docs into https://mholt.github.io/json-to-go/ and get structs back that are a good starting point). If they are really simple request vars such as just a string needed for the request, you don't need to define a type. * create a primary struct that abstracts away the details of making the requests such as signing and headers and has methods for each of the calls you want to handle here is how I'd imagine using it: config := threatConnect.Config{APIKey: "abc123"} tc, err := threatConnect.New(config) if err != nil { return err } cfr := threatConnect.CreateFooRequest{X: "foo", Y: "bar"} var resp CreateFooResponse resp, err = tc.CreateFoo(cfr) (edit formatting) 
It's just a new base. 
2 years old "eats your file irretrievably" data loss bug is still not fixed - https://github.com/fatih/vim-go/issues/632 .
I looked in to it and I'm not sure how to reproduce/fix it ... suggestions welcome!
sql.DB isn't a database connection, though, it's a connection pool.
The title is terrible clickbait. Go slices are absolutely dynamic arrays. Just because stdlib api functions and some slice semantics is not what the author would have assumed does not make the slide not a dynamic array.
Yea like I said I know it's pooled and listed the reasons it's still something I would consider. It implements io.Closer which means its lifecycle _may_ be shorter than the application. It has an endpoint which means it can fail. Having it set once at startup time with no ways to ask if it's still valid just isn't how I would approach this problem space. Instead I would define an interface that an application may ask a for a new object when it experiences failure so I can handle that scenario in one place. Perhaps giving the interface a second method for getting a new object with an err parameter to and returning a new or same err and a nil db, or a nil err with a new db. Or maybe just provide an interface for clients to query directly so I can add the behavior suitable for my app. Then I can have logic to test the clients claim, if I agree I can then decide what to do. Ask service discovery if endpoint changed, failover to a new endpoint, or try to close the existing db and obtain a new one with exponential ease back. Like I said it may not matter and I can't say what op should do because I'm not deep in his problem space, I just wanted to raise other points than already mentioned. If someone else raised my points I may of only said if you don't see yourself needing any of these things, there is nothing wrong with option #4.
Great work, guys...
I have been looking for something like this so thanks for creating these examples thumbs up 👍 
Thanks for the detailed reply. I guess my point was all those interfaces between components need to change when new data is added. The layers introduce coupling and make software expensive to change, you need to version on those changes too. Sometimes layers are important, we did n-tier architecture for a couple of reasons, defence in depth more layers can make it harder to hack and database scaling. Layers also made the construction about technical specialty - I'm a database guy etc. Yeah http as Comms tool between components I do see as commonish, but I do think it is overused. I wonder if this has come out of example code more than real code bases? The fallacies of distributed computing calls this out as a dangerous idea. Do you add a circuit breaker in there? What if that service is down do you send a partial response, do you retry? Logging / debugging is harder too. The network does add a lot more failure modes. Corbra + Dcom were attempts at this in the 90's, networks are better but I still think of them as hostile components. Spotify are known for deep stacks of services, but they also recently disclosed that 40% of their compute was serialising and deserializing json! I like your tech I would just have a think about what you put inside each box. Think shopping service instead of shopping business logic service + shopping data service + shopping database. Thanks for the conversation, I hope it is coming across respectfully😀
Thanks for spotting this! I fixed it now.
Alright I take it back, namecalling and attitude definitely justifies downvoting and has no place on this subreddit. Let's try to be respectful to reach other.
OK. I applied. Now will see what happens!
I am not a fan of overly long titles, so I tried a short one. Apologies if it fails to transport the right message; no clickbait was intended. The concept of having multiple dynamic views onto the same static array is fairly unique to Go. At least, I know of no other languages whose dynamic arrays can overlap each other. And this quite unique property of Go slices can cause uncertainty and logical fallacies (and this is not restricted to Go newcomers). With this article, I intended to help avoiding these fallacies by explaining the Go-specific slice mechanisms, and the places where things can (and repeatedly do) go wrong. A strong mental image of the slice mechanisms, plus a working knowledge of critical slice operations, are usually a good way of preventing subtle bugs like the ones described in the article.
https://golang.org/pkg/regexp/#Regexp.MatchString
sometimes... you just feel stupid. This is one of those times. Thanks!
Your project should have a different structure. You should have the directories bin, pkg and src in projects and my_app should be in the source directory. The GOPATH environment variable should then be set to the path /Users/jeeves/projects. Inside the src directory, each subdirectory is one of an executable (package main) or a package. You may have subpackages like my_app/foo. But it is unclear that this is what you want. 
This only happens if you use netrw (and occasionally). You're saying like this happens for anyone and it happens at any single time. That's not the case. Also it's open source, feel free to fix it if you think it's important. edit: Not that I undervalue the problem, not at all, just it's a problem that affects a very small percentage of people. I wish I had unlimited time (or desire) to work on these kind of things, but nope I don't have it. So unless someone else fixes it (who is probably affected by this) I don't see this is going to be fixed in near future. 
I don't think you should be trying to get an absolute path. The program should either A) know that tmp is at ../tmp or B) should find out where tmp is through an environment variable.
I tend to post articles from my blog, https://scene-si.org about that once a month when I manage to collect some time to write an insightful post. I do make the effort to teach people something more than just basics :)
Yes, its great information for a go newcomer. I just hate your title.
That's the work of Martin (aka Carpetsmoker). So all the kudos goes to him. Not sure if he hangs out here (tried to find him on Twitter either with no luck). Anyway if you see this Martin, as always thanks for your great work!
It's a free world. I have the right to make shitty blog titles(*), and you have the right to hate them. :-) (*) Edit: completely unintentionally, of course!
Did you try sending a pull request?
Thank you :-) I go by arp242 on reddit (see my [website](https://arp242.net/)/[keybase](https://keybase.io/carpetsmoker) for proof if you're the distrusting sort). I don't have a Twitter account. As many open source contributions, it was entirely a selfish matter of "I want this, I have some spare time, therefore I will make this" ;-)
netrw is a part of default vim install. You are saying to entirely change the default vim and my own vim use behavior. Also, this "It is open source, I will only work on shiny features not data loss bugs." combined with a "If you don't fix it, it is somehow your fault for not contributing" is not really a cool attitude. I did what I could do...moved on to gogland.
Nice, judging me without even reading the changelog (where you could see that the bug fixes section is the largest in size) is not nice at all. Everyone who uses vim-go already knows how keen I'm to fix bugs. I love fixing bugs if they make sense and affect everyone. Anyway don't want to derail. Have fun on your new journey with gogland. Bye 👋
If this were a good idea, Go would behave that way, and it seems several people have attempted to explain that already. Use a `Context` to tell your senders to stop, a `WaitGroup` to know when they're done, and only then close the channel.
Either copy between the protobuf structs and your business logic structs, or use the protobuf structs for your business logic. Latter doesn't work 100%, former is more work.
&gt; If this were a good idea, Go would behave that way, and it seems several people have attempted to explain that already. That's extremely subjective, the Go1 promise prevents major language changes, so even if they wanted to, It'd have to wait until Go2. `Context` is great, however that adds complexity to the code which in most cases, at least for me, is not needed. `if !ch.Send(xxx, true) { move on }` Thank you for your input though.
The thing is that it's not so easy to fix unfortunately. I appreciate that it's a major issue for *you*, but it's not for *me* as I never use netrw (and I'm guessing it's not an issue for Fatih either). I have been fixing some vim-go bugs, and *did* look at this one briefly, and then decided that I wasn't willing to spend 2+ hours of my spare unpaid time on a bug that doesn't affect me **and** affects a very small portion of the vim-go user base. Sorry :-( There is a lot to that can be said about this, but in the end it's [just a few people](https://github.com/fatih/vim-go/graphs/contributors) (mostly Fatih) working on this in evenings and such next to our day jobs and other obligations in life. If you *really* want this fixed then the fastest route is not waiting for someone else but ... to do it yourself. You can say that you shouldn't have to, and that's perhaps not entirely unfair, but if you're a pragmatic person like me then it's results that count. And fixing it yourself will get you results; so it seems like the best course of action to me.
So the 1.0 spec was perfect, eh?
Based on all these trendy Go blogs, the idiom is to ignore preexisting libs and reinvent your own wheel every time.
Thanks for the tips, I will work towards that, go is still new so it will be a slow but rewarding process. 
No, it definitely wasn't. But this particular design decision has been defended several times, with what I subjectively would describe as no credible counter-argument. Follow the project readme, through the issue, to the mailing list.
That API is a timebomb: if you forget to check the result, and are trying to produce values on a channel, closing the channel causes a busy loop.
I liked it and I think /u/jrwren is being pedantic. The title illustrates your point succinctly: they're not [the] dynamic arrays [you're used to]. Carry on.
Keep in mind that once a binary is built, the source file may no longer be there. So looking for the source files may fail. That said, after you fix your workspace so that you have a valid GOPATH and packages with import paths inside (as other commenters said), you could use `build.Import` to find a directory corresponding to an import path in GOROOT. // importPathToDir resolves the absolute path from importPath. // There doesn't need to be a valid Go package inside that import path, // but the directory must exist. func importPathToDir(importPath string) (string, error) { p, err := build.Import(importPath, "", build.FindOnly) if err != nil { return "", err } return p.Dir, nil } Finally, from what it looks like, you should probably not be using a directory inside your project's directory but somewhere else. It's hard to know without knowing what you're trying to do. It'd help if you explained that.
https://www.theverge.com/2016/5/5/11592622/this-is-fine-meme-comic
you would not use attic these days anyway. borgbackup is the alive-and-maintained fork of attic (with meanwhile much more commits than attic), while attic seems rather dead these days and has known corruption and security issues (which are fixed in borg).
Many a time I have wanted this, as part of crazy build gymnastics. `go repo` or something - the top-level dir, in go import form, that is the VCS root.
ah ok, i've been exploring more since i asked this question and i've seen that directory structure a lot. One question on &gt; The GOPATH environment variable should then be set to the path /Users/jeeves/projects. Should it not be set to /Users/jeeves/projects/my_app/ since that's where the src, bin, pkg, etc.. reside? Or is the GOPATH intended to cover multiple projects at once?
Thank you. Just for my own newbie curiosity, why should I not be trying to get an absolute path? 
&gt;before quety this connection is cloned or copied, it really doesn't make any difference in this case It kind of does. A session copy will use a new socket and you will have some delay for the handshake. A session clone reuse the already existing socket but long operation can block other goroutines. The mode in which you operate also matters, Eventual supposedly giving you the fastest and less resource hungry option.
GOPATH workspaces are meant to contain all of your Go packages. You should read over https://golang.org/doc/code.html, it explains it in detail.
I have posted articles from my blog( https://lanreadelowo.com ) quite a bit here and I am new to the language( 4 months ish) 
Interfaces are not required for writing straightforward procedural code. Interfaces in Go are the primary means for decoupling components of our programs. Tight [coupling](https://en.wikipedia.org/wiki/Coupling_\(computer_programming\)) between modules generally makes them less reusable, more fragile, and more difficult to test. We therefore try to [minimize the coupling](https://en.wikipedia.org/wiki/Loose_coupling) between modules, and interfaces are a perfect tool for that.
Your argument can be dismantled through technical debate, but I don't think that would be productive or fair- after all you said "at least for me". So let me ask this- what about everyone else? Don't you think that writing Go code similiarly to other engineers is a worthwhile pursuit? I imagine that the languages design constraints has to be what draws you to it like many of us. Go has some good stuff don't get me wrong, but many, including me like all the stuff it's missing. If I read a Go program using concurrency with WaitGroup, context, some atomic pkg, etc, I know exactly what is going on the moment I see it. So will you, if you don't yet.. you will eventually and once you achieve mastery you master all concurrent programs. Now when I read programs you write, if ever, or your peers read programs you write.. we must now learn your library. Specially if we are debugging a issue. We can't debug the language, we have to debug your implementation of language features. We need to come up to speed with a solution to a solved problem space before solving our problem. I would say....... unfun. I'm not saying you shouldn't write libraries like this becaus they may not be useful or your wrong for wanting the use they may provide. It is subjective, design decisions around concurrency had to be made and people smarter than me have justified them already. What I am saying is you shouldn't write libraries like this because the design decisions around concurrency have been made. The language constraints are pretty much the best thing about Go and by stepping around them while you may be making Go a better language for yourself in the given moment, your peers, coworkers or even future you could be cursing you one day! It's not a big deal though, if you had fun writing it and learned anything than mission accomplished. Just giving a reason outside the standard for panics on send to a closed channel behavior.
Well, if anyone else tries to use the library, and you do something like expect it to lie in the GOPATH, then it could cause unexpected errors for someone who didn't put it there. Also, hardcoding an absolute path in the program will cause similar problems but also expose information about your directory structure unnecessarily.
Hi, OP here. This is a good high-level (abstract) explanation that aided in my understanding. (And you replied within a few minutes of my post.) Thank you. As I am still also learning semantics and syntax, if you or someone else could reply with the kind of "textbook" exposition that sort of derives it, from illustrative examples of what would happen if it did not exist, I would appreciate it. I know this takes a bit more work than the high-level explanation, but this kind of derivation is missing from the references I am using. For example, even your statement that it is not necessary for straightforward procedural code, took me by surprise. I would like a derivation/exposition with code samples that show how everything falls apart without it. I know I'm asking for a lot. :)
His Nazi Großvater considered Jews harmful. So you know where it comes from.
Here are a few articles that might help you along your path of understanding this topic: * https://8thlight.com/blog/javier-saldana/2015/02/06/loose-coupling-in-go-lang.html * https://appliedgo.net/di/ * https://dave.cheney.net/2016/08/20/solid-go-design I said that interfaces are not needed for writing straightforward procedural code because Go would still be a fully capable language without interfaces. But without interfaces it would be more difficult to write modular, flexible, maintainable, testable code in Go. Interfaces let our programs scale in size more gracefully, but they are not, strictly speaking, necessary to write working software.
Plus one for solid go design
I found your first link to be precisely the exposition I asked. It is exactly what I sought. I am adding it as an accepted answer to my post. (Your second link, with the poetry, is the type of example I already had. The third link is more abstract). So to reiterate, your first link is exactly what I sought and fully answers my question. Thank you.
You shouldn't be in the position to defend your hard work. IMHO there is a bug in gofmt itself: I truncates the target file instead of writing a temp file and renaming that to the target file (which is an atomic operation on serious operating systems). Probably unrelated, but there is a chance this is part of the problem, so I wanted to put this thought somewhere. 
Same, but I'd call it NewStore() or NewPostStore() or just NewDB() Edit: what gureggu said below.
Would appreciate if I get some feedback to improve my golang coding.
"...you're used to" - a few more words that would have made the intention clear.
Also keep in mind that if you read the body in the middleware the actual handler can't read it anymore, because the middleware already read it and the stream is closed. You have to create a new stream and set the body to it in order to have the handler read it too. See: [Stackoverflow](https://stackoverflow.com/questions/23070876/reading-body-of-http-request-without-modifying-request-state)
No problem. The pkg docs are good for the go stdlib, definitely worth reading through for every package you use as they often have good examples too. 
http://wiki.c2.com/?BeatingTheAverages http://wiki.c2.com/?BlubParadox
Generics, list comprehension and try/catch would improve the language though. Also, Go has lambda expressions.
Yes I agree that sensible versioning of the certain components is an important paradigm when working with SCS structures. If we follow semantic versioning it should work as intended and smaller development teams (I think around 1-3 people) can work more agile I guess. The fast development and hacking is solved by us using templates, which evolve with the complete structures. Yes, the database scaling is a common problem I guess. We could add new features like database replica sets or we split up the data and simply add an additional database instance. I did not found a generally working approach with e.g. MongoDB, because the replication is master driven and costs performance too. We are using Kubernetes and do not write the HTTP communication by our own. This means it will retry to connect and resend the request if another service is down, but also Kubernetes tries to revive the broken service as well. The network „should“ be save because it is an Kubernetes internal software defined network with TLS encryption. Logging can also be done cluster wide and tools like Kibana and Grafana allow an overall view on the cluster. I see your points and they are valid. On the other side I am impressed how good the RPC approach works. :) The modularity means also rethinking the current internally used technologies. JSON is a good example: Instead of JSON we decided to use protobuf which is quite fast. Also for the web there are solutions like GRPC web which can use protobuf directly. Yeah, it could be possible to add a whole logic + database inside one container. One problem we will came across is the scalability: it would not be possible any more to scale replicas up and down because the load balancing will lead into data inconsistencies. Internal network communication would not be needed any more, but I guess a lots of benefits of the container orchestration would be lost with such an architecture. Interesting discussion, thank you! :)
http://www.paulgraham.com/arcchallenge.html
[removed]
[removed]
&gt; Generics, list comprehension and try/catch would improve the language though. You say that almost as if it's a statement of fact, as opposed to just your opinion.
Reusable, readable and maintainable code isn't an opinion.
&gt;Generics * improved type safety * reusable data structures &gt; list comprehension * less boilerplate code &gt;try/catch * enforce error handling * no more `if err != nil { return err }` everywhere Those are facts, not opinions.
It's a fact supported by literally decades of experience and practice. Something Go developers seems to generally lack. 
Sure, but there are differing opinions on what constitutes those things, and you have you balance out adding in additional language features with any potential downsides.
So why weren't they baked in from the start of it's so obvious?
To be honest I'd like to see some of these features in Go eventually. But the picture is funny, you got my upvote, it made me laugh.
Why are the code in Go 1 the most readable that I can find?
What about the Go creators?
I don’t know, I did not designed Go. Why are they bad?
Did Go creators ever used languages such as Java, Python, Ruby?
Argumentum ad hominem.
Because it’s your opinion.
More than that, it is my personal experience, that why I appreciate to work Go.
Are you suggesting that if the creators of Go had used Java, Python and Ruby, then they would have obviously brought in those features because they're so good?
That's a pretty multipurpose looking whatever that is... I reckon it'd put up a good fight against C# and Java, which look similar if memory serves.
Have you ever used Go? Generics, I agree if they are done right, but list comprehensions and exceptions, no way. Exceptions were deliberately left out of the language because of the decades of experience with them. List comprehensions are just smart and can make code less readable, this is an experience from Python.
One of the core philosophies behind Go is that it's a small language, without too many different language constructs. This avoids situations where there are seven different ways of writing a small block of code. It becomes very easy to write idiomatic Go, which is important for readability and maintainability. There are some good articles and talk on the design ideas behind Go, which are worth checking out. The features you mentioned were intentionally not brought in, not simply left out because the creators didn't understand or know about them.
As a matter of fact they did, along with `C` and `C++`. Edit: And ken created B,a direct ancestor of C. Robert Griesemer contributed to Java HotSpot (A JVM) and worked on V8 (A javascript engine written in C++). And most of them created Plan9 (written in C), along with UTF-8.
Yes the logical vs physical views of the system do get intertwined in the container space. I might have misunderstood the data component, does it store data and run the database process or is it a component that provides an API which in turn calls the database in a separate persistent container? My take which possibly fewer network calls would be. 1. Persistent container for the database. 2. UI / API / business logic in another container. 3. Perhaps a container with some static UI composition bringing it together. I hear your point about scaling parts individually. Database scaling separate to what is rendering the UI. However the case for a separate business logic component that can scale separately to the other parts, I'm not convinced of. At what scale do you think scaling a business logic layer separately to the UI make more sense than just scaling the UI / API / business logic container horizontally? Also do you have any thoughts on the number of sub systems / network hops that should be chained together? Assuming we are shooting for 100ms response time for someone who is 50ms round trip away, how deep do you think you can afford to layer components together? The more parts you split your architecture into gives you more scaling options, but with each layer you incur a network, serialisation and a versioning tax for want of a better term. Logically I understand it, but physically I wonder about the runtime performance of it. I probably need to do some perf tests. Anyway thanks for the discussion😀
It's not an opinion, it was designed for that.
[removed]
lol Generics
And in my personnal experience, Python code is the more readable. It really does not mean anything at all.
Really insightful my man. https://en.m.wikipedia.org/wiki/Argument_from_fallacy Maybe we can argue all things axiomatic instead 
Non-Mobile link: https://en.wikipedia.org/wiki/Argument_from_fallacy *** ^HelperBot ^v1.1 ^/r/HelperBot_ ^I ^am ^a ^bot. ^Please ^message ^/u/swim1929 ^with ^any ^feedback ^and/or ^hate. ^Counter: ^98253
Yeah, you do not answer to my original question at all. 
&gt; try/catch &gt; enforce error handling How is exception handling 'enforced'?
[citation needed]
You have issues.
With exceptions, the program crashes if I do not catch them. Nothing happens with return values.
I think Go is objectively more readable than most other popular languages used in enterprise. 
Implementing a Go interface is done implicitly. In Go, there is no need to explicitly implement an interface into a concrete type by specifying any keyword. To implement an interface into a concrete type, just provide the methods with the same signature that is defined in the interface type.
&gt; I think Go is objectively Hum… &gt;than most other popular languages used in enterprise. Perhaps, but it does not invalidate my point.
The people "begging" for generics and these other stupid and unnecessary "features" are actually people who don't like Go and want to see it fail because they feel threatened by it. You can tell by looking at their post histories in subs related to Go. All they do is talk about how shitty it is because they're trying to push a narrative. Also the erlang/elixir camp has an anti-Go marketing team that posts on social media like reddit and hacker news. Go into literally any HN thread about Go and you see it. Erlang and Elixir are so unpopular that statistically it should be rare to have Elixir "programmers" show up in literally every Go thread. They hate us cause they ain't us. Fuck off Ericsson.
Exactly. There are dozens of programming languages out there. If you feel so crippled by the lack of generics, just use another language. Go is what it is. Many people like it for what it is. Stop trying to make it into the next C++ by adding every language feature under the sun, because C++ already exists. 
Are you familiar with the history of the Go team, particularly the original handful of developers?
I gave arguments in favor of these features, and the only thing you can answer is that I’m a hater? What about real arguments against those features?
Yes I did. And I miss those. No, list comps aren’t unreadable, at all. No, exceptions aren’t harmful.
That isn't enforcing anything. Enforcement is: &gt; the act of compelling observance of or compliance with a law, rule, or obligation. Exception handlers are optional. Enforcement would've required the compiler to statically determine whether all throws have corresponding catches. And we all know what that means in other languages. 
Rob Pike, Russ Cox and Ken Thompson? Yes, of course. That’s why I’m asking, because afaik, there is no JVM, nor Ruby interpreter on Plan9.
But at that point why not just use Java/C#? People switch to Go because it's simple and well-designed. If it doesn't work for you then that's that. Move on. Use the language if it works for you. Stop trying to mold it to your specific needs. Honestly if you really, really need more than one thing listed in the picture, you're better off using another language. Edit: Great concurrency is available in every single mainstream language in the form of third-party libraries. You just aren't looking hard enough. It's not worth switching to another language over that. Yes, you won't get "first class concurrency" (for whatever that's worth) but if you're coming from language X and you really, really love language X, you can probably make X concurrent. Stop trying to turn Go into X+concurrency. That's a misuse.
Here's what's funny about you posting links to these two things: One could interpret them as supporting or opposing the addition of these features to go.
Yes, sorry, I’m not native, and sometimes it’s difficult to say what I want in english. 
I hadn't realised.
No problem :)
do you think there are huge differences from older version vs june 2018 version?
No problem, I respect your opinion. There is a bunch of real arguments all over the internet against each of those things (by people using C++, Java, Python, etc).
You need to use this: u.(*User).id Because "u" in your context is of type *User, not User. Remember, you're storing a &amp;User{}, not a User{}. https://play.golang.org/p/VMjSUyX8Ug Then the code runs, but hits a deadlock.
I don't care about the first 2 features. I like how go is now. But i pray that try/catch stays out of go. Why ? Well you don't enforce error handling more than now. If i dont want to handle it ill just do an empty catch block and thats it. You have a lot more freedom now with errors. Bc sometimes you just dont need to handle errors so you drop em and thats that handeled. Or i specifically want to hand my errors to my caller to work with it there. And btw how are try catch blocks nicer than if err != nil ? i have my errorhandling right where i want it. Exactly after my function call. and i wont start packing every call in a try catch block. So pls no try catch
&gt;And btw how are try catch blocks nicer than if err != nil ? i have my errorhandling right where i want it. Exactly after my function call. and i wont start packing every call in a try catch block. So pls no try catch Because only one try/catch block can handle errors of a whole functionnal block. So instead of wrapping each call in a try/catch block, like you’re suggesting, you can do it for the entire function. And that’s cleaner than adding an `if err != nil { return err }` for each call.
Just watch a few talks by the Go designers. You will understand why things are the way they are.
I went to go to have a language made for concurrency...
But then i dont have the same freedom to decide whether i want to handle one error at a given point or drop it or hand it over to my caller you know. I see where you are coming from but trycatch strips you of some freedom on how to handle your errors.
Are you forgetting Robert Griesemer?
Reminds me of this https://hbfs.files.wordpress.com/2009/11/perl6book-parody.jpg 
Rob Pike said in one of the ~~articles~~ talks about the design decisions behind Go that many languages "borrow" features and ideas from each other, meaning they eventually become more or less the same, and that Go will never do that. Reading the discussion in the comments here only enforces the point he made. I suppose they'd have to have great reasons to go back on such a strong design decision Edit: can't seem to find the link to the article (or maybe it was a talk?). If someone remembers where it's from I'd be thankful for the link!
This was pretty much my exact reaction to it
Yeah, the groupthink is strong in the golang community.
Go 1 is fucking disgusting it has so many features you don't need. Code would be so much simpler without types. Just imagine. &gt;var x = new(4) creates a new variable of 4 bytes and then you manipulate these bytes like an integer and write all your own functions. Because seriously why would you want prewritten integer functions that's going to be slow and might not match your use case. Something has to be done, good programmers like ourselves don't need these stupid features and simple is better.
Spot the BCPL programmer. 
&gt; why things are the way they are. Not invented here syndrome?
Yeah, try-catch blocks are awful, and it lures people into weird error handling techniques, and is effectively a goto-statement. And we all agreed that gotos were a bad idea. Errors as values are actually useful, and with generics we could have established monadic patterns for error handling as values...
Wouldn't be surprised if that was the official cover.
Python look readable and can be readable. But it can also be full of traps. You can make your own dictionary, everybody will think it's a dictionary but it will not behave like the standard dict... The more I master Python the more I use magic features, it's fine for me, I build my own language. But it's not more readable for somebody else. And sometimes "somebody else" is me some years after ! So now I appreciate Go to prevent me to build something that I will not understand myself few years later. Go is explicit like wanted to become Python...
They should just challenge the Go 2 community to implement all these features in a repo and see how it works out.
Not really, by using *User it won't match the interface assertion. Either way, it's not working.
&lt;Insert joke about C#/Java not working in the first place&gt;
You may find these links helpful: https://medium.com/@cep21/preemptive-interface-anti-pattern-in-go-54c18ac0668a https://medium.com/@cep21/what-accept-interfaces-return-structs-means-in-go-2fe879e25ee8 I think one of the more compelling uses of interfaces in go is as a way of implementing 'generic' behavior. Consider: type MyAction struct { } func (*MyAction) foo() bool { return true } func execute(action *MyAction) bool { return action.foo() } If you have two actions, you need `executeMyAction` and `executeMyOtherAction`; or, you can do this: type MyAction struct { } func (*MyAction) foo() bool { return true } type MyOtherAction struct { } func (*MyOtherAction) foo() bool { return false } type Action interface { foo() bool } This sort of behavior would be extremely difficult to implement without interfaces. Notice that unlike say, java or C#, you don't have to *opt in* to interfaces in go; it's like duck typing in python; anything that implements `foo() bool` is now Action, and can be used by `execute`. I feel like this is really the key distinction about go interfaces that makes them useful and powerful as an alternative to what you would in another language. As a practical example, testing is extremely irritating without interfaces, because the 'real' implementation is the only way to test things. It makes unit testing basically impossible in complex systems. ...but, just in straight normal code, say, inside a function... there's not really any compelling reason for interfaces to exist. They're primarily for applying compile time type assertions about what enters and leaves functions in your code.
First of all, in regards to coding style, you really *should* user a pointer to a user as the other commentor said. However, to fix your code, it should be like that: https://play.golang.org/p/mtIk9AJ1yM You have to save the variable after casting so you can modify it. To make what the other commentor said work, you also have to do: ``` ctx := context.WithValue(r.Context(), "u", u) // no dereference here ```
You should create an issue on the Go tracker about it.
&gt; why not just use Java/C#? Class-based inheritance and they run in a VM. Those are two major differences nobody is asking for in Go. 
https://www.ponylang.org/discover/
Absolutely. If you're having to shoehorn, you're doing it wrong.
Using *User compiles. There is no interface in your code.
Running your code locally will give a wrong interface match..
Yep, that's working as expected, but when I come back to "/" path, the value remains unchanged..
Yes, really. Why ask for help if you discard the answers lol? This has nothing to do with context, it's basic Go. How to store a T in a interface and retrieve it again using a type assertion. 
https://golang.org/doc/faq &gt; We believe that coupling exceptions to a control structure, as in the try-catch-finally idiom, results in convoluted code. It also tends to encourage programmers to label too many ordinary errors, such as failing to open a file, as exceptional. Go takes a different approach. For plain error handling, Go's multi-value returns make it easy to report an error without overloading the return value. A canonical error type, coupled with Go's other features, makes error handling pleasant but quite different from that in other languages. Go also has a couple of built-in functions to signal and recover from truly exceptional conditions. The recovery mechanism is executed only as part of a function's state being torn down after an error, which is sufficient to handle catastrophe but requires no extra control structures and, when used well, can result in clean error-handling code. So that probably won't be added. However: &gt; Generics may well be added at some point. We don't feel an urgency for them, although we understand some programmers do.
That may be intended.
Try/catch do not enforce error handling.... So not a fact. And what does make a try/catch block better as if err != Nil? You just talk like you are the grandmaster of language design but you just are a prisionner in your little known universe.
[Instead of insulting me you can read what other said on that point](https://www.reddit.com/r/golang/comments/6rxfjo/go_2_please_dont_make_it_happen/dl8i9gq/). &gt;And what does make a try/catch block better as if err != Nil? [Once again, I already answered.](https://www.reddit.com/r/golang/comments/6rxfjo/go_2_please_dont_make_it_happen/dl8j1yc/)
 http: panic serving 127.0.0.1:50570: interface conversion: interface {} is main.User, not *main.User I'm not trying to be mean or whatever you might be thinking, but the code he provides throws this error that doesn't give me a straight answer..I'm starting to think that the way context.Context was build to work with http, will make changes locally on the specified path and using pointers won't solve it..
The full codebase for the project can be found here: https://gitlab.com/drakonka/gosnaillife/
That’s why I said it’s opinionated.
Oh yes. I picked up Go in addition to C# because it's nice to have a language that can compile to a native binary and isn't C/++. 
That’s fair for exceptions, although I disagree.
https://davidnix.io/post/error-handling-in-go/ really good article about that try/catch disaster
That simply means that your local code is different from what you put on play.golang.org.
go makes standalone executables. no extra unnecessary layer needed.
If the errors on play.golang.org and your machine are different, there isn't much we can do.
Linux all the way up, shouldn't be a problem. The most probably trying to make a http server on go playground might not bet allowed.
At the end of the day, I also want that language to be popular.
It’s an article advocating Go’s error handling, not an article criticizing exceptions. Really, except control flow, which is better than this article let you think, there is nothing against them.
Just add generics FFS and call it a day
Honestly the only thing I don't like about go is the short variable name thing that gets pushed so hard by the language. I want explicit variable names damnit. Lol
Eh I use Perl at my day job, and Perl 6 is pretty neat. IMO the biggest problem is calling it Perl 6.
Yeah I find all the discussions broadly ridiculous. The strawmen (like this illustration) are hugely unfair &gt; Go is great because it's simple, if you add X then it will become Haskell. If you dont like Go, ~~go to another country~~, use a different programming language. At the *same time*, there are people calling for a long list of features, which *does* make you wonder why they want to use Go in the first place. My position is, dogmatically saying "Go is simple so dont add any features" is an absurd standpoint. All good software evolves and that's true of programming languages too. Simple is also not the same as easy, just simply saying "less is more" is too simplistic. 
Coupling exceptions to a control structure, as in the try-catch-finally idiom, results in convoluted code. It also tends to encourage programmers to label too many ordinary errors, such as failing to open a file, as *exceptional*. For plain error handling, Go's multi-value returns make it easy to report an error without overloading the return value. A canonical error type, coupled with Go's other features, makes error handling actually pleasant. Go also has a couple of built-in functions to signal and recover from truly exceptional conditions. The recovery mechanism is executed only as part of a function's state being torn down after an error, which is sufficient to handle catastrophe but requires no extra control structures and, when used well, can result in cleaner error-handling code than what you see in languages like Java, where massive try-catch blocks are not only common, but the norm. 
Yup. Perl6 is so much different than Perl5 (and so backwards incompatible), that they may have called Perl6 a brand new language. Aw well.
go should be simple, that's why i love go. if go 2 become like that picture why not i just use js?
Really? Copy+pasting the Go FAQ without sourcing it? Well, as I said, I understand, but still disagree. I really prefer a large try/catch block that handle everything over `if err != nil { return err }` for every function call. It’s not really more convoluted. And it’s as opinionated as [the original text](https://golang.org/doc/faq#exceptions). &gt; **We believe that** coupling exceptions to a control structure, […]
Dude me too. I am so tired of looking at an unknown go codebade function and having to draw out on paper that: - "c" refers to a channel of strings - "v" refers to the local variable of checker square position - "ch" refers to a channel... wait if this is the channel of strings what was "c"? I don't mind the usual standard/meta identifiers such as "i" when used in a loop for iteration however. I understand the value when the goal is serious memory management in an embedded system, but a lot of what I typically see in the wild is not so constrained.
That is because you didn't change ALL your code, just one line. Your play example does this: u := &amp;User{"#$@!$!dsqd2"} ctx := context.WithValue(r.Context(), "u", *u) But this doesn't make sense. You create a variable using the address operation of type *User, then in the very next line you perform pointer indirection to store a type of User in the context value. Then to retrieve it later you tried to do: u := r.Context().Value("u") u.(*User).id This is wrong as the reply said, it's easier to see if you put it together without the context. u := &amp;User{"#$@!$!dsqd2"} // var u *User = &amp;User{...} var eface interface{} = *u // underlying type User (not a pointer) eface.(*User).id // This is impossible, eface is a User not *User So you need to store the type you want to access. Either store *User and access *User or store User and access User. My guess is you want a pointer because you complain "the interface doesn't match" later so you have a interface User implements that requires it's method receiver to be a pointer type. When you post problems you should post the complete code needed to reproduce it and make sure to be receptive to help if your goal is to get back to programming! :D
Reductio ad absurdum
Our communities are likely different but the people I've talked to that switch to go did so for the fast compilation and static binaries.
Sure, just sharing. It's an interesting project nonetheless. :)
The only reason I wanna use a pointer is to modify the context value for specific Request Path. For now, I figured it out that every path has it's local value, couldn't find a way to modify the value from path to path so I decided to use a pointer but didnt work as expected. Anyway, pretty much that's not how context was build to work..
He's comrade jim. They have little concept of ownership.
When he can't argue a point, he argues with the messenger. Classic ad hominem and the first thing people do when they've realized they've nothing of merit to say.
EXACTLY!
I absolutely agree!
Might as well write in assembly then.
You can have multiple catches wherever you want. That's also not ideal and can lead to more boilerplate but this reason you give is not necessarily correct.
Ironically enough, his comment made me check out Erlang and Elixir
I didn't even know there were buttons to click and that there would be animations until I read this comment the next day, went back and looked. I thought those were still images until it was pointed out to me. TY
Then let me rephrase: my code gets ugly and not maintainable if i have many catches after my try block. its much nicer to read if i have my handling where my error occurs.
Adding a feature or two, while making the language a bit larger, can make it simpler because it becomes easier to express your code. Try speaking using only a monosyllabic vocabulary. You would be using a smaller, simpler language, yet it would be much more difficult to communicate your thoughts.
I have been using the protobuf structs itself in my code. The only issue that I have encountered is the - `json:"omitempty"`feature. As a result, you cannot differentiate between fields which are not present, and fields which have 'zero' value, since they get omitted anyways. The 'hack' that I have been doing is if the field is not present, then put an absurd value for that and check for its presence in the consumer service. Other than this, it has been smooth sailing. 
Thanks for the feedback. I'll make it more obvious next time. Or maybe I can find a way to stick some kind of "this is a clickable animation" tag to every animation of all past and future articles.
&gt; dogmatically saying "Go is simple so dont add any features" is an absurd standpoint I agree, and I think the Go designers would agree too. Notably, I'm sure they wouldn't add plop to the language just because people want them to, but would make sure to implement it properly. It's best to aim for minimal - the perfect amount - not sub-minimal. 
Theres a good elixir boot camp course on udemy. It's a little slow if you're a seasoned programmer but worth the $10 if you get it on sale.
That's fair but I meant you can have a try catch around and at each function call like you would do an if after each one. Again not ideal but neither is it freedom reducing. I'm not unsympathetic to your point about aesthetics. Thanks for being civil. Upvote.
If you're not familiar with them, check out Scala's `Try[T]` (though perhaps `Either[L, R]` is closer, as `Try[T]` is often used for interop with code that does throw exceptions) or Rust's `Result&lt;T, Error&gt;`. They sound like _exactly_ what you want.
thx for the suggestion. But like im perfectly happy with the way i do it in go :D
But I want to reimplement my [collection type] every time I optimize!
Interfaces are convenient, but the behavior you are implementing is far from extremely difficult to implement otherwise. First, using interfaces: package main import "log" type MyAction struct{} type MyOtherAction struct{} func (*MyAction) foo() bool { return true } func (*MyOtherAction) foo() bool { return false } type Action interface { foo() bool } func execute(action Action) bool { return action.foo() } func main() { var a MyAction var b MyOtherAction log.Println(execute(&amp;a)) log.Println(execute(&amp;b)) } Using a function pointer, which is possible with a trivial example: package main import "log" type MyAction struct{} type MyOtherAction struct{} func (*MyAction) foo() bool { return true } func (*MyOtherAction) foo() bool { return false } func execute(action func() bool) bool { return action() } func main() { var a MyAction var b MyOtherAction log.Println(execute(a.foo)) log.Println(execute(b.foo)) } In Go you can use function pointers, because the receivers are passed along with them implicitly. You can use closures to the same effect. Then, in C, using plain structs: #include &lt;stdio.h&gt; typedef struct { void *receiver; int (*foo)(void *); } ActionInterface; typedef struct { } MyAction; typedef struct { } MyOtherAction; int MyAction_foo(void *a) { return 1; } int MyOtherAction_foo(void *a) { return 0; } int execute(ActionInterface a) { return a.foo(a.receiver); } int main(void) { MyAction a; MyOtherAction b; ActionInterface a_wrapped = { &amp;a, MyAction_foo }; ActionInterface b_wrapped = { &amp;b, MyOtherAction_foo }; printf("%d\n", execute(a_wrapped)); printf("%d\n", execute(b_wrapped)); return 0; } Of course we don't really need the receiver pointer for such a simple example, but this works generally for any number of methods and arbitrary struct fields.
I've grown to agree with this over time. Tools, community and support are important.
If you use a pointer, then you should be working on the one and only copy. If you're not using a pointer, then no wonder -&gt; you are owrking on a copy of the variable.
I wish there were a syntactic sugar to deal with long lists of call this, if err then return. But I agree with the authors that exceptions don't belong.
I just hope they don't mess up the language. I am one of those guys who don't want exceptions because I don't want another c# mess. I don't even want generics at this point because I have learned to go without and I like my final product every time. I even think making a go2 will fragment the libraries out there across both and get a python2/3 situation that I don't want to deal with either. We have a simple, powerful language that meets so many use cases. Don't mess up my language bro.
When you find an iOS question on stackoverflow and the answer contains 4 snippets: obj-c, swift 1, swift 2, swift 3
I haven't tried it, I just find r/orlybooks funny :-)
how do you approach adding methods? 
Operator overload is something that I would find extremely underwhelming and abused. To hell with `dataManager += data.record()`, it makes no bloody sense. What's wrong with `dataManager.insert(data.record())`?
"Just"
agree, the biggest mistake is calling it Perl 6 and some people expect it to replace Perl 5
The picture is somewhat amusing, but I'm downvoting because this post is doomed to decline into whining without understanding the trade-offs.
Elixir and/or Erlang?
Totally agree, just adds unneeded complexity to the language IMO
&gt; I even think making a go2 will fragment the libraries out there across both and get a python2/3 situation that I don't want to deal with either. One of the main goals (or constraints) for go2 is not dividing the go developer base: &gt; Go 2 must also bring along all the existing Go 1 source code. We must not split the Go ecosystem. Mixed programs, in which packages written in Go 2 import packages written in Go 1 and vice versa, must work effortlessly during a transition period of multiple years. We'll have to figure out exactly how to do that; automated tooling like go fix will certainly play a part. Source: https://blog.golang.org/toward-go2
I get the sentiment, adding features willy-nilly on top of each other doesn't result in nice languages. But the upper part isn't entirely true to the way things are. It should be [more like this](http://i.imgur.com/zSPaRLb.jpg). I mean, have you seen `syncmap`? That thing is as misshapen as the creature in the lower part. 
Am I missing something here? Go has `fmt.Printf` so you shouldn't need Sprint for that.
[Simplicity is Complicated](https://youtu.be/rFejpH_tAHM?t=1m5s)
You were not using a pointer... that is the entire point of my post. The error tells me this clearly as well as your code on play confirms it: interface conversion: interface {} is main.User, not *main.User Because your code is: ctx := context.WithValue(r.Context(), "u", *u) But it should be: ctx := context.WithValue(r.Context(), "u", u) // no ptr indirection Again you ignore the correct answers you asked for and create your own incorrrect discovery "I figured it out that every path has its own local value,". This doesn't make sense on its own but given what you've said this far I can infer this means you are still.... passing user by value, making changes to it in each handler and then expecting convergence to the top level context. Its been explained to you so I won't reiterate, good luck I guess.
Either you understand what those words mean, and you agree with /u/CountyMcCounterson, or you don't, and you're trying to disagree :)
It's almost like the real world can't be distilled into stupid cartoons.
Thanks for lowering the level of discourse.
Who is the author of this masterpiece? :)
So... now I know how ruby looks in real life =D But I'd be happy with nicer error handling. I don't like evaluating error.String() to guess what happened... Or maybe macros so that core language goes away without generics, mixins, lambdas, symbols etc but we can just create some sugar to implement them. Unreadable you say? Good editor will show you how the code looks "unfolded" 
The core language design team needs to stay true to itself and we wont need to worry about it no matter the version number. I agree with the author. There's just something about the language I like, but the lack of these language crutches have been very freeing for me in Go and I hope we don't see them. Chaining together crutches is why some other languages (particularly java), which are otherwise fine on their own, become so bloated.
Because Go isn't just meant to be simple, it's meant to make concurrency simple. That simplicity lies in channels and go-routines. Unfortunately, code written in Go can easily get to the point of "not easy to understand", or "not simple", and a lot of it has to do with the language design itself, not underlying complexity. We can say there's virtue in performing the `for` loop ourselves every time we want to remove an element from a collection, but the fact of the matter is that generics will solve a lot of common cases of bloat by enforcing a pattern across a common interface that will not only reduce repetition but mental overhead in understanding the patterns at large within the code. The way I look at it is that Go 1 included all of the features that were "safe". Go 2 has the same aim as 1 - simple code, strong well-made abstractions, easy to write, standard patterns - but it's starting to include all of the features that may be slightly less safe. While I can agree that some things scare me - particularly exceptions - I think we should at the very least stop fear mongering, "craftsman shaming", and projecting the will of the core team as some dark motive emanating from salty C# and Java programmers who just want total parity between Go and their old workhorse. A lot of feedback from the community was processed in making these decisions, and I think we should have a "wait and see" attitude towards how they will all turn out. Who knows? Maybe exceptions won't be terrible after all. 
Case aware lexing. XML primitives. Monadic guarantees. Brainfuck preprocessor. std::physics2d. Custom heredocs. JARs. Dynamic scope. Fucking ternary operator.
¯\_(ツ)_/¯ Depends on what you're used to, I guess. Printf is very natural coming from C or Python. Concatenation is more natural coming from Java or Ruby. Personally, I prefer format strings because you can immediately see what the output will look like in most cases.
Instructions unclear. Stuck dick in gopher and caused a stack overflow.
Just a side-note, you can simplify the following part: if u := r.Context().Value("u"); u != nil { ... u.(*User).id = "Changed" To: if u, ok := r.Context().Value("u").(*User); ok { ... u.id = "Changed" The same applies to map[string]interface{}, I seen the following code more than I wished to: if v, ok := m[key]; ok { if s, ok := v.(string); ok { ... It can be simplified to: if s, ok := m[key].(string); ok { ...
fmt.Fprintln https://golang.org/pkg/fmt/#Fprintln
I agree, though I hate writing A.Add(B) instead of A+B just because A and B are not floats or ints but some other numerical type like decimal or bit.Rat . It becomes worse since the syntax is very different. for big.Rat it would even be A.Add(A,B) iirc. I would appreciate some syntactic sugar if your type fulfills some 'math.Number' interface or whatever.
The picture is at worst a straw man. Most of those features have been suggested for Go 2 in one way or another, so you can't exactly call it absurd.
Go supports multi-CPU/Core/Thread out of the box. Node requires multiple instances. Go compiles to a single binary. Node does not. Go has easy concurrency. Node does not. Go is a great general purpose language. Node is not. 
Can someone ELI5 why this is a bad thing? As a python developer I got into go because it seemed like was a compiled language that had a relatively gentle learning curve, and could be written quickly. Why would more features be a bad thing?
Ah, thanks, that's going to save me some time and mental anguish in the near future. I still like concatenation a little more than formatting in some cases though, particularly while debugging (it's easier to smash out "label" + variable than think about specifying what format tag I want to use). 
Ruby supports both, but in modern use you will usually see string templating: `"expression: #{expression}" vs "expression: " + expression.` I actually prefer string templating, it typically has the win of being both the most representative of what will actually be output and being the easiest to write/read. It can get gross, but that's usually abuse and will look just as gross in string formatting or concatenation patterns.
i'd liI ke a handful of these - 1. lambda expressions 2. /regex/ 3. terneray operator These are the 3 things i can think of that are common place actions but aren't written cleanly right now. Implementing this could clean up code without having bloat the language itself with features. EDIT: lot of rustled jimmies aporently. And I thought I was making good suggestions ;(
&gt;I don't like evaluating error.String() to guess what happened... There are better ways to handle errors. See the famous post [Don't just check errors, handle them gracefully](https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully). It proposes multiple ways to handle errors​ that are better than substring matching.
Exceptions could be a case in point; operator overloading too. The current language makes it easy to know what happens when an error occurs. It's more verbose, but more predictable than exceptions. If Go were to get exceptions, some library might throw one, breaking all your assumptions. So then you want to have a safeguard against that, and there will have to be a 'func ... throws ...' construction, which will finally show up everywhere. It'll get messy. I personally think that generics, even if they only allow you to abstract from the type and avoid the type switch in places where you know what type to expect, would be a good thing, though.
The only times I find it useful is for defining what equality is, or if you have what is clearly a numeric value (eg math/big). But like you, I'm okay with not having them because I agree they would be abused far too much.
https://www.youtube.com/watch?v=rFejpH_tAHM
&gt;[**dotGo 2015 - Rob Pike - Simplicity is Complicated [23:12]**](http://youtu.be/rFejpH_tAHM) &gt;&gt;Go is often described as a simple language. It is not, it just seems that way. Rob explains how Go's simplicity hides a great deal of complexity, and that both the simplicity and complexity are part of the design. &gt; [*^dotconferences*](https://www.youtube.com/channel/UCSRhwaM00ay0fasnsw6EXKA) ^in ^Science ^&amp; ^Technology &gt;*^34,689 ^views ^since ^Dec ^2015* [^bot ^info](/r/youtubefactsbot/wiki/index)
Is Pike still in charge? I kinda trust him.
Wasn't he part of the original Plan9 team which eventually created the Go programming language. I thought Rob, Brain, Ken and Russ were part of Plan9 at some point of the time. The lessons learnt when designing Plan9 must have something to do with influencing Go.
It's pragmatic
You can define methods on generated structures for a protobuf file. Just make sure that helper files belong to same package as protobuf package. If naked protobuf structure use doesn't work, embed them around an exported struct and expose API using this exported struct. I have not tried this but worth a shot. Let me know if I am wrong. 
I really like go because it gives me that effortless freedom to write code without thinking the same as if I'm writing a blog post in English. The only other language I've felt this way with is C and I attribute it to the languages being simple enough you can keep most of the spec in your head. On the other hand with languages such as Python (production stuff), Java and C++ I'm always forced to look things up because there's just too much to keep it all in your head. For example with Python there 2 -&gt; 2.7, 2 vs 3, pep8, "pythonic" conventions, PyPy, CPython, Cython, the list goes on... The same with C++ boost, C++98/C++11/C++14, MS/GCC/Intel/Clang compilers, Make/Automake/Cmake/Gradle just thinking about it gives me anxiety!
Anything with channels and green threads, or enough power to implement them would get you there. It's not magic. https://github.com/andreas-gone-wild/blog/blob/master/diy_cpp_chan.md
x64 assembly has a better type system than that.
LOL, Kevlang! All vars are 8 chars or fewer!
Since you are speaking in the case that your own reply message fails to properly encode, it is considered a server error. Reply with code 500 Internal Server Error. Do log the error along with some contextual information to help you track the problem. I would consider it a bad practice to write something that isn't expected by the client (option b). Consider implementing an error response type across your application that way you will have all the necessary information at hand and clients can expect and correctly handle your reply. ie: { "code": 500, "description": "An error occurred while encoding the replyData", "location": "restFunction" }
Just add that Go copyright header to the top of the file, then add the license to the top of the file or in a file that accompanies your project. then add your own copyright header and compatible license in the same manner. I'd use a simplified 2-clause bsd license, as the third clause is considered implied in copyright law. The permissions in the license grant you to whatever so long as your changes are licensed under a compatible license. In fact some are banking on it- hoping to do with the Go ecosystem what so many did with the BSD source.