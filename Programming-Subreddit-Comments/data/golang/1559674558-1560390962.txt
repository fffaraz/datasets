I must have missed it. My bad.
Very well written article, I enjoyed it and learned a couple of things. Good luck with your project, looking forward to the day you publish it!
The same reduction of load also applies to storing pointers in a slice vs storing values. There is documentation on compiler optimizations: https://github.com/golang/go/wiki/CompilerOptimizations But I am not sure if that is what you are looking for. Strings are immutable in Go. That is why you will need to allocate a new copy, every time, you want to modify or pass the string. This is not a problem, unless you are doing so in a performance critical section, that runs many times a second. Even then, you should measure and not make premature optimization. Also, it‚Äôs easier to mess up with shared byte slice compared to strings, since they are mutable.
Best article I have read in a long time!!!
I played a little with the safe and I have some feedback for you, if you are interested. For reference, I use [pass](https://www.passwordstore.org/) for my own password, and I consider it pretty much ideal except for a few things. I also imagine that this is more of an exercise than a real application, at least at this point, so some of my feedback might simply be things that you ignored because of that, but I still think they are worth mentioning. With all that said, here is it: * I have noticed that the order of the parameters matter. That was very confusing at first, and I don't see a strong reason to keep it that way. I haven't played much with the flag package, so it might be their fault, but I thought it was worth mentioning. * Some of the error messages are too obscure for a general user, e.g. "missed record title". I would suggest an example of command for the user. * Also on error messages, the thumbs-up doesn't show up. I'm running urxvt with zsh on Linux. I imagine that emoji fonts aren't widely available, at least to Linuxes. * Another suggestion, is to check for validity of command before asking for password. I tried to push an empty entry, the program asked for my password and then it told me that my entry was empty. Also, I don't know if it failed properly, I got this message: &amp;#8203; Error: Title or Password is not set, invalid record üëç record successfully pushed to store '/home/daniel/go/src/github.com/lucasepe/pwsafe/cmd/test.dat' * Also, the reason that I tried an empty entry was because I expected the program to prompt me for my password. I don't want to write my password on the command line for it to be registered. Of all things I said, I think this is the most important. * The password structure also seems a little strict to me. While I could simple use the password field for whatever I want, is it always attached to a user and site entry? I need those way less often and it seems wasteful to always have the three. Is there also any limit on size? * Finally, is it possible to use something like ssh-agent or gpg in order to not have to type the password for every operation? I was going to say that I would like to be able to insert entries without typing my password, but I understand that to be a limitation of the system, but I would rather not have to type my password every time, since I could try to do many operations at one sitting; just entering all my passwords upon adopting this program would be very tiring. I think that is all that I have in mind right now. I hope it isn't too harsh, there was a lot of good work that went into this program, but I can't help and see how much it could grow. I'm also sorry if some of those are already addressed in the documentation, I swear that I tried to find them.
&gt;A session can have a controlling terminal. At any time, one (and only one) of the process groups in the session can be the foreground process group for the terminal; the remaining process groups are in the background. From `man setpgid`. Sounds like you need to set some of these in SysProcAttr: Setctty bool // Set controlling terminal to fd Ctty (only meaningful if Setsid is set) Noctty bool // Detach fd 0 from controlling terminal Ctty int // Controlling TTY fd Foreground bool // Place child's process group in foreground. (Implies Setpgid. Uses Ctty as fd of controlling TTY)
I use [errcheck](https://github.com/kisielk/errcheck) on all my projects. It doesn't allow unchecked errors, even in defer statements. How you handle it is up to you, of course.
&gt;"I hope it isn't too harsh...." On the contrary, thank you! first of all for the time you spent trying and testing this tool. It was born out of pure curiosity on the subject and mainly because I wanted something much simpler to store 'my web accounts data' ... ...but...I would like to strengthen it and transform this tool in something more \_"professional"\_ (but not too complex...for this \*'pass'\* is the top). I treasure your observations and I will start from these to make the software more robust. About the structure that's related to the `PWSafe` [file format](https://sourceforge.net/p/passwordsafe/bugs/1097/attachment/formatV3.txt) ...here the record. 3.3 Field types for database Records: Currently Name Value Type Implemented Comments -------------------------------------------------------------------------- UUID 0x01 UUID Y [1] Group 0x02 Text Y [2] Title 0x03 Text Y Username 0x04 Text Y Notes 0x05 Text Y Password 0x06 Text Y [3,4] Creation Time 0x07 time_t Y [5] Password Modification Time 0x08 time_t Y [5] Last Access Time 0x09 time_t Y [5,6] Password Expiry Time 0x0a time_t Y [5,7] *RESERVED* 0x0b 4 bytes - [8] Last Modification Time 0x0c time_t Y [5,9] URL 0x0d Text Y [10] Autotype 0x0e Text Y [11] Password History 0x0f Text Y [12] Password Policy 0x10 Text Y [13] Password Expiry Interval 0x11 2 bytes Y [14] Run Command 0x12 Text Y Double-Click Action 0x13 2 bytes Y [15] EMail address 0x14 Text Y [16] Protected Entry 0x15 1 byte Y [17] Own symbols for password 0x16 Text Y [18] Shift Double-Click Action 0x17 2 bytes Y [15] Password Policy Name 0x18 Text Y [19] End of Entry 0xff [empty] Y [20] What will be challenging (_read intriguing_) will be implementing gpg or ssh-agent. This weekend I'll start from the easy things after that I'll try the ssh-agent/gpg way (if you are a Go dev and have some hints about this topic any sharing will be welcome). Thank you, Luca
[removed]
Thanks, those didn't solve it but your comment put me on the right track. Setsid is the SysProcAttr that seems to have got it working how I need it.
It's worth noting that static languages like Go also provide a chance for the tooling to better explain your options and path choices. I think this is more frustrating when writing your first hello world program - but very helpful for applications of any reasonable size. &gt; Compiler: No, you can't pass a string here - we need a function with these arguments... &gt; Compiler: Oh, you want to use AwesomeLib2? Here are the three things you can do with it: Run(), Rollback(), and Commit()
Hate this, but valid
I'm glad you liked them. It really seems like a fun project to practice programming. I realize now that you are using a simple file for storage, while I was assuming that you were using something like SQLite. Now it the way your data is presented makes more sense, since a single file provides some limitations to storing and retrieving data. I hope it continues to grow and make you proud.
Non-go-fmt'd code ‚òπÔ∏è
New documentation: &gt;Close can be called multiple times and returns \*PathError if the file has been already closed. It is not safe to call close on the same file from multiple goroutines concurrently.
The Is() and As() interfaces are not so different from existing patterns, but it would be more in line with say json.Unmarshaller (or fmt.Formatter) if they were exposed on the package.
If it *couldn't* be solved as a library, I couldn't do it with xerrors at the moment, so I'm not sure that's the point. Part of the point was that the community illustrated a number of ways that the existing error patterns were insufficient to the point of generating quite a few libraries to help address them. I've shown a use-case where a common pattern (wrapping and dependency injection such as with http middleware) may want to pass specific error values or interfaces between code that is not guaranteed to be next to each other and where errors could end up being wrapped by others. The Go authors seem to have considered this sort of case as an extension of the pattern of wrapping errors, not just for the standard library. Wrapping and unwrapping stacks of errors create these questions, and I'm glad that the proposal solves the general problem rather than solving a subset and forcing people to do more themselves for potential questions they might want to ask against that stack.
Quite a post. Good luck with your project. I find go to be a pretty good language with a lot of good design decisions but I find the enthusiasm of the community surrounding it to be much more impressive.
Do the JetBrains IDEs provide $200 worth of benefit per year over other IDEs? I've looked at them over the years, and tried IntelliJ with Rust, but so far I haven't been sold on it.
Fantastic article! Really looking forward to following this project
(author of Badger here) Nice article! This reminds me of some puzzle slides from my Gophercon China talk about Badger at Shanghai in Apr 2018: * Dealing with Qu-err-key file systems. * Would a file delete reclaim space in the file system? Êñá‰ª∂ÊòØÂê¶‰ºöÂà†Èô§Êñá‰ª∂Á≥ªÁªü‰∏≠ÁöÑÂõûÊî∂Á©∫Èó¥Ôºü * Delete, no reclaim - No if err := t.fd.Truncate(0); err != nil { // This is very important to let the FS know // that the file is deleted. return err } - Truncate the file before deleting. * Would closing a file sync its contents to disk? ÂÖ≥Èó≠Êñá‰ª∂ÊòØÂê¶Â∞ÜÂÖ∂ÂÜÖÂÆπÂêåÊ≠•Âà∞Á£ÅÁõòÔºü * Close, no-sync - No if err := lf.fd.Sync(); err != nil { return errors.Wrapf(err, "Unable to sync value log: %q", lf.path) } if err := lf.fd.Close(); err != nil { return errors.Wrapf(err, "Unable to close value log: %q", lf.path) } - Explicitly sync file before closing. * Can a new synced file be lost? Êñ∞ÁöÑÂêåÊ≠•Êñá‰ª∂‰ºö‰∏¢Â§±ÂêóÔºü * Create, no-found - Yes f, err := os.Open(dir) if err != nil { return errors.Wrapf(err, "While opening directory: %s.", dir) } err = f.Sync() closeErr := f.Close() if err != nil { return errors.Wrapf(err, "While syncing directory: %s.", dir) } return errors.Wrapf(closeErr, "While closing directory: %s.", dir) - Sync a directory just like you would sync a file. * Can a crash add garbage data to end of file? Â¥©Ê∫ÉÂèØ‰ª•Â∞ÜÂûÉÂúæÊï∞ÊçÆÊ∑ªÂä†Âà∞Êñá‰ª∂ÁªìÂ∞æÔºü * Crash, no-clean - Yes. - Add checksums to know when to truncate a file.
No. Vscode does enough unless you need really advanced remote or debugging shit. You have to _really_ dive into and intimately learn their IDE to get the $200 worth of benefits. Even then, it crashes more than vscode for me. Vscode has intellij bindings so the switch is easy.
Yikes. No thanks. We have the syntax we do so we can handle the error correctly. Not just ‚Äúoh no panic‚Äù.
That syntax makes no sense whatsoever. If I write: a() try(b()) c() Suddenly, I may risk `c` not executing, because there's some magic `return` hidden behind `try` as if it was a C macro. We don't do that. If a function returns, we want to see it return. Can you think of any other function you can call that'd just magically return without using the `return` keyword? This is confusing and unintuitive. The philosophy of Go is to make a dead simple language that is easy to read and fast to pick up. There's a reason we don't have ternary operators or a lot of other syntactical sugar. It's because Go is supposed to be simple. `try` is anything but that. `try` is something you might find in Python that has a billion ways of doing the same thing with different syntaxes.
The proposed `try` doesn't panic.
This is actually a really neat way to accomplish this. I'd never suggest using it for production code, but certainly great for prototyping.
This is actually a really neat way to accomplish this. I'd never suggest using it for production code, but certainly great for prototyping.
So I've tried various golang IDEs but Goland is the best. It feels good, has all the right features for when you need it. $16 monthly is easy to justify to any company.
I might be missing something, but it seems like this would damage one of my favorite things about Go; that error handling is explicit and immediate. If I'm reading new code that uses \`try\`, it seems like I'd have to hunt around for the \`defer\` call to understand what happens in an error case. &amp;#x200B; Just taking the example straight from the proposal: func CopyFile(src, dst string) (err error) { defer func() { if err != nil { err = fmt.Errorf("copy %s %s: %v", src, dst, err) } }() r := try(os.Open(src)) defer r.Close() w := try(os.Create(dst)) defer func() { w.Close() if err != nil { os.Remove(dst) // only if a ‚Äútry‚Äù fails } }() try(io.Copy(w, r)) try(w.Close()) return nil } ... I'm not sure how this is cleaner than handling errors inline, basically every function call is wrapped in \`try\`.
\&gt;&gt; think simply returning the result of T.Close()is the best you can and should do. I don't agree, the error from f.Sync() is more important, it's better to just log the error of Close()
This feels sensible. That being said, my biggest complaint with error handling is really that everything ends up centralizing into the `error` type, which is practically useless (its just a string, after all). I really appreciate more powerful error handling, like being able to durably tell what kind of error you just got (for example; if I query a database and it couldn't find a record, I want to branch differently than if I query and my connection password is incorrect, or if the network is down). There are, of course, patterns to do this, but everyone does it differently. In some situations, including the standard library, we see durable error values returned, then you compare against the value, like: ``` v, err := a.DoThing() if err == a.NotFoundError {} ``` Other times we see packages export the string literals that the error will contain, like: ``` v, err := a.DoThing() if err.String() == a.NotFoundError {} ``` And even other times, like with the AWS SDK, we see custom error types with a Code parameter, like: ``` v, err := a.DoThing() if aErr, is := err.(a.Error); is &amp;&amp; aErr.Code === a.NotFound {} ``` This concern is valid to bring up w.r.t this proposal because I think custom error types are great, and this new `try` function further forces us into a culture of always returning `error` instead of custom error types. If you want to use `try` then the enclosing function has to return the most generic thing that is compatible with both `error` and the error which the enclosed function returns; practically speaking, given the lack of an inheritance system, this is always `error`. In other words, the only times when `try` would be useful is when the error isn't useful. Its boilerplate to reduce boilerplate, and no one is asking the question of why that error isn't useful in the first place. How can we make that error useful? Or, better put, how can we encourage actually handling it properly, instead of just propagating? What does "properly" even mean? In an ideal world, every character you type should provide value to your program; `if err != nil return` blocks don't provide value, they just pass the ball, and `try` is the same way. This proposal is a good step. It just feels like a good step down the wrong path to me.
I tried GoLand for a week, and the Git tooling drove me insane (...I just... want... to commit a file... now?). I wasn't a big vi user before, but decided that I would sharpen up my skills with it and that's paying off. Previously was using VSCode and was frustrated with its long delays before the linters would decide that you had a problem and should maybe perhaps... tell you about it in the Problems tab? Today? `fugitive` has been a no-BS get-git-done UX. Something about `ripgrep` and Vim is disturbingly slow so I'm looking into why that is next. Still exploring the features of vim-go's integration with `guru`.
&gt; Yes, but generally your latency to your user and/or the database will be much larger, so unless you are doing it millions or billions of times, there are probably other things which can be optimized first if you find it is getting slow Well sure, but if you want to make that argument, literally anything is "fast enough." Over time these decisions add up, especially if you're writing something that is fairly low level and you can't control how it's going to be used higher in the stack.
Why use the git stuff if it annoys you? I use GoLand but just ignore the git stuff and use git from the command line.
Its just a tooling thing. I could `git add xyz abc; git commit -m 'msg'` all day long, but in fugitive with a leader binding it turns the work more stream of consciousness where I'm just typing `&lt;Spc&gt;fs--cciType my commit message here&lt;Esc&gt;:wq` and I'm back to the buffer I was working on.
@k4kshi hi any idea?
Not that due to the lack of generics in go (at least for the moment) a library like this is awkward at best as you have to use `interface{}` for everything which loses a lot of type safety and causes more work for you clients. As such I would not really recommend it as a way to learn go. At least not idiomaticly.
Ok. Thanks for the reply.
Everyone is shitting on you because they can't imagine why people bother with any types more complicated than what ANSI C provided.
Sounds like a distribute system problem. It should be a good project, but since you already built one before, it doesn't seem challenging enough for you. So it's only a good project for you to learn go, not so much at anything else. For most hires, the original C project might look more impressive on your resume.
Here we go again. Where is the context? And no, one single defer, while enough in very simple cases, will not suffice in the more realistic ones. Adding that function will simply encourage people to return naked errors, which goes _against_ the two other Go 2 proposals about errors. I've had hard enough time rewriting non-contexted code to be properly wrapped, and imagining rewriting code sprinkled with ‚Äútry‚Äùs is just discouraging.
The torch metaphor is fabulous.
error is not just a string. It's an interface type, and can carry arbitrary details about the error if you type-assert it into a concrete class. I'm on mobile so i can't just pound out an explanation right here and now, but you may want to look into that a bit. You're missing out on features you have right now. The os package has several custom errors you can look into, and also provided functions for analyzing some of them, none of which involves treating them as strings.
go back to /r/ProgrammerHumor
Ah sorry, so yeah run go mod vendor whenever the dependency tree updates. I'm having problems with it as well at
it doesnt matter, gopls is not stable.
1. Can't say it's really a common code. At least in my recent \~5 C# projects I never wrote anything like this. Just some services that get some other services injected. No backtracing needed. 2. If you need it you either use rust libraries that allows it or 3. Use raw pointers
Hi, I work for JetBrains as a Developer Advocate and I'll try to clarify some points. &gt; You have to really dive into and intimately learn their IDE to get the $200 worth of benefits. I'd like to mention it's $89 for individual licenses (not paid by companies) and the licenses can be used for commercial development. And learning a tool to maximize your productivity is needed if you use one of our tools or not (e.g. vim). &gt; Even then, it crashes more than vscode for me. It's unfortunate that this happens. Can you please raise an issue on our tracker at https://youtrack.jetbrains.com/issues/Go and attach the IDE logs via Help | Compress Logs and Show in... with some additional steps on how to reproduce these issues? Those would help us fix the problems and hopefully not crash again when you try it next time. &gt; Edit: plus vscode is opensource. Supporting FOSS just makes you feel good. The IntelliJ IDEA Platform is also open-source, see here: https://github.com/JetBrains/intellij-community/ &gt; Can easily bypass microsoft telemetry spying with vscodium if desired too. Can't do that with intellij without a pihole. We do not send any telemetry out of the box for the stable releases unless the users explicitly agree to do so. We use an opt-in mechanism for this, and even then, we comply with the GDPR regulations for this.
What is the cost of defer? Assuming my function or method have an average depth of 5 (read, parsing input, query data, packing output, write) and all of them use defer-try. How much does it cost vs. non defer-try?
Recursive references? I'd say it's common enough when you want to have a pointer to a parent. You don't want to use raw pointers (that's over-complicating things and unsafe) and there's no need for additional Rust library. `Rc` and `Weak` form standard library are just for this case. struct X { children: Vec&lt;Rc&lt;Y&gt;&gt;, field: String, } struct Y { parent: Weak&lt;X&gt;, field: f32, } I think you've got the idea
Yeah, I forgot about \`Weak\`. Otherwise it's fine. &amp;#x200B; Yes, I have almost never seen cyclic references outside RDBMS which mapps on DTO without any references. Maybe it's just my experience.
Overall it looks good to me, but here are a few things that I'd improve: 1. Do some sort of validation on the expected configuration values, for example by declaring it as a conf struct. Your functionality relies on the right env variables to be set, e.g. ` dropboxKey := fmt.Sprintf("%s", os.Getenv("DROPBOX\_KEY")`, it would be friendlier to the user not even to start up and fail around here. 2. You tend to return only a generic error: ```values, err := utils.GetURLQueryParams(r.URL.String()) if err != nil { utils.InternalServerError(w) return } ``` this won't be very helpful to debug later on. In my experience it is more useful to return some interpretation of the error itself, either by defining a new, relevant error message on the spot, or simply wrapping and returning the error in the HTTP response itself. Moreover using only InternalServerError is not reflective of the error itself, its a neat exercise to find the right http error codes for each failure option :) 3. Your handlers are quite complex, and this makes functionality hard to test, as you probably felt it as well. I'd break the functionality up into functions that do one thing with well defined inputs and outputs, so its re-usable and testable. A good example is the `SaveToDropbox()` function. You return errors in it 5-6 times with the same error message, so debugging would be a nightmare. It also does several things, so you can't easily test it (e.g. save the file via the POST request).
One of the things that I like most about Go is that the flow of code is easy to follow, and that by convention, panic() is not used unless something that should probably blow your program up is encountered and cannot be used as a value: `fmt.Println(panic("hello world!"))` does not work, and that resulted in panic being used in a way that was relatively easy to spot, much like a return statement. This makes me viscerally dislike the idea of a function that has a return value that can be nested inside other calls, because it feels like it's breaking a contract that the language had with me to be clear. For my two cents, I really don't want to see anything that could cause the function to return that isn't a statement that I can see as the leftmost keyword. Hot on the heels of xerrors and proposals that improve the usability of error returns, this also feels like a step backwards.
My subjective suggestions, *. Always group and order imports by its origins (standard library first, third party packages, and then your own packages) *. Error check usually in the next line of function call that cause the error, without additional empty line. Non subjective suggestions, *. String concatenations is always faster than Sprintf. Use them. *. Any command or program should be under "cmd/&lt;program name&gt;". This rule may be subjective, but I really recommended to think on writing on the perspective of library first, and then write the program later. If you think it like that you did not need util and route package anymore (it should not). *. Don't stutter. weather.weatherInfo should be weather.info. *. If a type is unexported their fields also should unexported (lowercase)
Fixed üòâ
Prerendering is the way to Go
&gt;* How do I actually create the certificate chain for the system above? If we are talking about closed system, I would create a self-signed root certificate and use it to sign client and slave certificates. No need for intermediate. You can also set certificate purpose to "SSL Server" for slaves and "SSL Client" for clients and verify this on both ends. &gt;* How to the client verify the server? Does it need like the slaves(and root) public keys or is that handled within the client certificate itself? It verifies it by checking what CA signed the server certificate (it needs to know the CA public key, obviously) and optionally certificate purpose. Further verification can be done by comparing server certificate subject and you can even allow connections to servers with a specific attribute set in the subject, like OU=IT for example. All these cannot be changed without generating and signing the certificate. &gt;* Is it possible to white-list/blacklist several root CA, and or intermediet CAs? Yes. It's often needed when root/signer certificate is close to expiration and both - old and new must be honored. &gt;* Does the client certificates needs to be signed by the root certificate itself or can it be done by the intermediet CAs Depends on your method of verification and depth. You can trust only intermediate or only root or both. As I said, in closed systems there is no need for intermediate, so root CA should suffice.
Agree. Dynamic languages are such strange beasts! It "feels" good to be able to pass around the code whatever you want without caring about types, but it's only because you "keep" that in you head while writing code, and, as code grows more than "TODO list", it becomes harder and harder to work with. I enjoy reading tweets and articles of people who switch from dynamic to statically typed languages and discover the hell they lived in. Suprisingly, until they switched, they absolutely sure that types are "overvalued" and not that important. &amp;#x200B; As for the "active development" ‚Äì that's much more challenging task than just observing and navigating codebase, absolutely agree. But what if when you focus on the function's code, you'll get exactly the same experience that you have now with your favourite editor. Why wouldn't you use that? :)
I'm glad it resonates!
Thank you!
Thanks! Go community is gophabulous, yes :)
Thank you!
Thanks!
awesome read !!
&gt; I cannot extract &amp;obj using the casting syntax Well, for one because there _are_ no type casts in Go so there is no syntax for them so you cannot use it. Okay, let's get real: Why it might be technical appropriate to say an interface contains a pointer you have absolutely no way of accessing this. Forget about this, don't try. Never. This implementation detail could change with any release or even be different between gc and gcc. If you did `var a interface{} = obj` and `obj` is of type `T` then you can get it back with `var o = a.(T)`. See https://tour.golang.org/methods/15 . Dead simple. As you did not store a `*T` (i.e. a pointer to T) inside obj you cannot get back a `*T`: You can get back only what is inside. This should be clear by now (and I hope you forgot about the implementation detail!) If you need a `*T` you can take the address of your new variable `a`. Additional takeaway: Some things in Go are not addressable. That the thing resides somewhere in memory and that memory does have an address does not mean you are allowed to use or see that address.
Never thought it in that way, really good one
&gt; You're missing out on features you have right now. No, you are misunderstanding what he is saying. The only method defined by the `error` interface is `Error() string`, so unless you already know what the *actual error* is , you can't assert anything to get more detail out of it.
&gt; Isn't dealing with boxed values a substantial cost? I'm not too familiar with Go so I don't know how much of an impact it would have. `interface{}` is already boxed, and your value is lifted to heap each time you pass it to the function, accepting `interface{}` of any kind. So adding ML-style polymorphism would have no additional impact, only type-safety.
Yeah coming from python, usually using TRY/EXCEPT blocks is a no-no.
&gt; There are, of course, patterns to do this, but everyone does it differently. In fairness, Go 1.13 adds functionality to the errors package to try and standardize this.
This is accretion of weird stuff, not holistic language design
Thank you so much for the answers! &gt;If we are talking about closed system, I would create a self-signed root certificate and use it to sign client and slave certificates. No need for intermediate. You can also set certificate purpose to "SSL Server" for slaves and "SSL Client" for clients and verify this on both ends. Does this still stand if the client cannot access the master? Can the client signing request be passed from the slave to the master service securely and then when it has been signed by the master be passed to the client without the risk of interception? or it doesn't matter perhaps since the private key is not embedded in the signing request?
You should not transfer certificate signing request between clients/slaves and masters. Signing is done out of band and you place signed certificates and private keys on servers and clients. If you need to secure the transmission from dynamically connecting clients (you can't place certificate and key on them), you should consider other methods of authentication.
Additionally, perhaps you could describe what you're actually trying to achieve - asking the wrong questions will always give you the wrong answers.
So if I create the private key on the client, generate a signing request based off that private key and send that signing request to slave which passes it to the master. The master then signs it and passes it back through the slave to the client. (Without exposing the private keys at either ends) Is this then considered insecure?
I understand what you're saying. I suppose it wouldn't make any difference for Go. I meant additional impact over not boxing at all (either through `interface` or ML-style polymorphism). I'm curious if there are methods to eliminate the overhead while keeping the benefits of either (`interface` or ML).
Yes. How do you authorize the client? What prevents unauthorized party from generating their own CSR and sending it to sign? And if you already have a secure channel for sending CSR and authorizing clients, why do you need SSL on top of that?
In the system I have in mind a user has to acknowledge the slaves and clients from the masters frontend. After a client or slave has been acknowledged by the master it should not be able to communicate with any other master/slave/client that is not part of its original cluster/site. In this case (given that the user knows what the hell it is doing) it should be secure, I think? Or do you have a better alternative? :)
Disagree with over-packaging, with the exception of `routes`. That's a single-file, single-function package. Can just move that one up to top-level. letting the services be packages? Sure, I like that +1 to the rest of the suggestions here
I enjoyed reading this. I must say, I did it on some kind of browser, which later on became a torch ;-) Good stuff, and I hope you succeed in your project. The thing is, that I always say, when there is a possibility to program without all the hardware and stuff like that, I for sure want to test it. Perhaps, you will make a path to that dream :-)
But you don't just get random errors. On the boundaries you should produce your own errors and handle them appropriately up the ladder. Or, you can pass around unknown error, but then you might as well panic.
I think I misunderstand this proposal. how can this: ``` f, err := os.Open(filename) if err != nil { return ‚Ä¶, err // zero values for other results, if any } ``` become this and have the same functionality: ``` f := try(os.Open(filename)) ``` I totally mis that point. And also, if the os.Open returns 2 things, how would the language knows it's okay to ditch the second value? (it's still a strict language) I think, if you don't want to check the errors that much (or just don't want to type the error part that much), you can easily wrap things, handle the negative (the error) inside the wrapper and always return the positive. I'm not fond of typing too much myself, but the advantage now is that you somehow are forced to thing about what to do with the error on the moment it occurred. Which lead to easy to read software and maintainable too.
I explain the average interface{} to my students as an envelope. It's just a carrier but you need what's inside of it. Being able to tell what's inside, without opening it, would be a miracle. thing.(Bird), thing.(Plane), thing.(Superman) works for me ;-)
In the beginning, when your resume is made out of school projects, it's for sure a thing that you can do. However, you must not forget to take them out of the resume after 2-5 years of work, because all you did at school doesn't matter anymore by then.
Scanner is meant for buffered reading, i.e. not "reading bytes as they come". It expects to read things along some kind of delimiter (default is newline), so in your use case it was probably blocking until newline came along, and you perceived it as "slow".
I am trying to use interface{} as a C void\*/Java object equivalent, to work around the lack of generic support. Lets say I have lots of records: ``` type ComplexRecord struct{ // big struct } ``` I want to do some filtering on them, using a general purpose algorithm, which has a signature ``` type AlgoRecord struct{ RelevantField1 int RelevantField2 string Tag \*void // Here I use interface{}, this is a link to the original ComplexRecord } ``` I map all ComplexRecord-s to AlgoRecord, the feed it into the function. ``` func Filter(x \[\]AlgoRecord) \[\]AlgoRecord ``` Then I grab the pointers to the original ComplexRecord's from the result. Copying would be both expensive, and more importantly not correct in this scenario, so I need an untyped pointer to the objects, which I thought what interface{} was for.
This is still not very secure. An attacker can suppress client request and send their own, making the approver think it was the legitimate client that sent it. If that level of risk is acceptable for you, sending CSRs may be OK.
&gt;Copying would be both expensive, and more importantly not correct in this scenario, so I need an untyped pointer to the objects There's not enough information to determine whether any of these statements are correct, but the empty `interface{}` can hold any type, so: cr := &amp;ComplexRecord{} ar := AlgoRecord{ Tag: cr, } puts a pointer to a ComplexRecord into the AlgoRecord, though I'm not sure I see how this will be particularly useful, since you'll need the concrete type (or an interface with useful methods) to do anything with the data.
What? Where‚Äôd you get this idea?
I don't like the try approach.
What do you mean by " "read" the data out of casbin "? Casbin provides the API in their website: [https://casbin.org/docs/en/management-api](https://casbin.org/docs/en/management-api)
https://tour.golang.org/methods/15
I develop some projects with go and I'm using xerrors. I don't consider myself to be a part of the "community" though.
It really hasn't been adopted as far as I know. We're using it at [coder.com](https://coder.com) but I haven't really seen much open source usage. godoc has some usages listed: [https://godoc.org/golang.org/x/xerrors?importers](https://godoc.org/golang.org/x/xerrors?importers) &amp;#x200B; Its def a little annoying, I always forget to include err in the xerrors.Errorf because there is no warning but the upcoming vet check will fix this.
This is completely wrong. It‚Äôs generally considered idiomatic Python to use a try/except for a lot of cases.
What makes you think it's slow?
Love the torch :) &amp;#x200B; /u/divan0, do you know about [https://github.com/google/shenzhen-go](https://github.com/google/shenzhen-go)? \&gt; SHENZHEN GO (working title) is an **experimental** visual Go environment, inspired by programming puzzle games such as TIS-100 and SHENZHEN I/O. \&gt; SHENZHEN GO provides a UI for editing a "graph," where the nodes are goroutines and the arrows are channel reads and writes. (This is analogous to multiple "microcontrollers" communicating electrically in a circuit.) It can also convert a graph into pure Go source code, which can be compiled and run, or used as a library in a regular Go program.
The C programming language doesn't have generics either, so if u/fnetma is already accustomed to using `void *` everywhere, `interface{}` will already be a huge step up. Although I am really not sure why you would need to use `interface{}` in this particular case.
If you could monomorphise manually, you could do it anyway. Polymorphism is better, that `interface{}`, because it's safe. It also allows additional optimization, for example a compiler could produce a monomorphic version of your function, if it has the source.
Ahh, thanks! It seems the language creators have thought of this case.
I have to write similar systems sometimes. The way I do it is I make a service that can talk to a configurable number of devices (say 20). (In my case TCP barcode scanners on conveyor belts). Then I can scale it up by either installing multiple instances of the service or split it out onto multiple machines. Docker etc would work well for this. That way if a service dies for whatever reason at least the others continue on. I don't know what devices you are using but there shouldn't be any issues using the standard go net library. When I've done it in the past (not with GO) the GPS device has just emitted NMEA data out every couple of seconds. So you just read until you have at least one NMEA chunk (From memory CRLF delimited) and then parse it. I don't know what your definition of slow is but it should be pretty much instant. Put a network trace like Wire Shark on so you can see when the GPS is transmitting.
Love the article. Not sure it's useful yet but I'm biased being very experienced. I can't wait to see where you take it.
amazing article loved it, and I hate to be *this guy* but I ve found a typo üòÇ. At least, they‚Äôll be important to follow my though line further in the text I believe u meant to write thought?
If you're talking about augmenting the standard tree-view in an IDE with a 3D mapping of code structures and their relationships - but keeping text editing as the standard way to write code then I agree it would be useful. &gt; I enjoy reading tweets and articles of people who switch from dynamic to statically typed languages and discover the hell they lived in. haha, I'll have to quote you.
Adoption is huge actually, it's just that we're still using xerrors as https://github.com/pkg/errors
My approach is to wait until updated error handling is part of the standard library. At least for any production code. Playing around with it is different.
&gt;but keeping text editing as the standard way to write code then I agree it would be useful. Exactly, that's what I plan to experiment with ‚Äì either editing inside browser (unlikely to give great experience, but worth trying) or talking via IPC to editor in another window.
Wow, that looks interesting! Thank you for sharing, I'll watch the talk.
If you‚Äôre asking how to get hardware stats in a Go program in windows, I found gopsutil useful.
Oh, thanks! I've spent half a day proofreading article with Grammarly, but it still doesn't capture typos like this :) Thank you, will fix it along with some other typos)
I use on it on my projects it's pretty handy to get a stack trace on unexpected errors. But I use a quick wrapper function I wrote to avoid having the ": %w" verb thing all over my code.
Thanks! Yeah, me too. I actually experimented already with Leap Motion for hand tracking, and I do use VR for watching YouTube videos without distraction (Youtube app for DayDream is really awsome), so I really see some interesting options here. Also I used to program outside ‚Äì like on the beach or in the parks ‚Äì but small screen, bright sun, need to keep laptop on top of the lap :) make it often more then suboptimal setup for programming. &amp;#x200B; I'm not sure virtual keyboard typing is possible with LeapMotion, but what if yes :) [https://twitter.com/graycrawford/status/1134214686679941123?fbclid=IwAR1VHYkM-RmsX7NHQdV\_bdkExSYXRGbXpRe-zowDiOxXz3xHpu-8GjXKaw8](https://twitter.com/graycrawford/status/1134214686679941123?fbclid=IwAR1VHYkM-RmsX7NHQdV_bdkExSYXRGbXpRe-zowDiOxXz3xHpu-8GjXKaw8)
Thanks!
To be honest, the language you will learn makes less difference than the skill set and knowledge you'll need in order to do backend work. &amp;#x200B; Do as much exercise as possible, contribute to open source projects, write your own, etc, but make sure there is always someone to check your work, don't just assume that if it works, it's also okay.
I will gladly type ``` if err = stuff(); err != nil { return } ``` and ensure I have clean and easy to follow code. I hate all these proposals.
We adjust touched code to use xerrors. Is, As, etc. are not in heavy usages, actually I remember several places in all our codebase.
I don't know what is considered idomatic in C for this type of thing. But in go using interface{} for everything is a bit of a code smell. Required when you want to create container classes and functions like this but it doesn't really create clean go code. As such I would not recommend it as a way to learn go nor as a way to show off that you can write idomatic go code. &gt;Although I am really not sure why you would need to use interface{} in this particular case. How else are you going to map/reduce over vecs/maps? Unless you write the functions for each type or generate code that does this your functions will be limited to a single type and not generally useful. Creating container structs and related functions is not one of gos strengths, so is not something I would recommend starting with to learn the language.
&gt; I enjoy reading tweets and articles of people who switch from dynamic to statically typed languages and discover the hell they lived in. Let me guess, 95% javascripters, 0% Lispers.
Thank you for this explanation. As a C# programmer, this comparison really pointed me in the right direction on how to think about go interfaces.
I tend to agree. The idea is relatively sound, but it should be a keyword that has to be used immediately before variable assignment. I like `try`, but `check` would also work fine. ``` func Do() error { v, err := DangerousThing() v := try DangerousThing() } ```
You got it. A map access returns two values: the value of the key in the map (if any), and whether the key existed.
Ahhh so is this the same as: val, exists := colorsMap["Foobar"] if exists { // color is 'val' }
Mostly. It's the same idea, but val and exists will have different scopes. In the original, val, exists are scoped and exist only within the if block. In the second example, val and exists are available to the current scope.
&gt; I don't know what is considered idomatic in C for this type of thing. I would suggest that the C preprocessor is probably the most idiomatic way to provide generic-like functionality in C. However, as the name implies, it is a preprocessor that steps in before the C code is compiled. In fact, you can use C preprocessor directives in Go code as well. Which, I will also suggest that using a preprocessor on Go code is also the idiomatic way to implement generics at this time. While it is true that the Go programming language does not provide generics, the Go ecosystem absolutely does. Provided by Google, even. &gt; How else are you going to map/reduce over vecs/maps? Surely we're talking about MapReduce, not map/reduce? The latter would be pointless, even with generics.
O yeah map/reduce is an overloaded term, forgot about the big data meaning and was refering to the functional language pattern. The former will work in go, the latter is generally a bad idea.
Makes sense thank you.
Does it feel, to anyone else, that maybe the language team is approaching the three Go 2 proposals in the wrong order? Is there a reason why the generics spec isn't being flushed out first, there may be nuggets in there that could change the approach of solving the other two proposed language changes.
[removed]
Here's a virtual typing example, along with various others: https://twitter.com/crookookoo/status/1127621051758727169
Thoroughly enjoyed the read - love the codevis concept. You articulated many points well - as someone who has also grappled with mental models and code quality, these perspectives resonated with me. I had a conversation with a colleague about visual coding tools (I've used Scratch, Unreal Blueprints and Simulink) and I was convinced they couldn't "scale", but couldn't pinpoint why, beyond a simple discussion about the tradeoff between complexity and development speed. The point you raised about spatial vs temporal mapping is an interesting way of viewing this issue!
The one thing that I want to correct is that the 2nd value retuned isn't ever undefined. The 2nd value is a boolean and is either true or false.
Nice, thanks for sharing. Still far from 10-finger blind typing, but it's a start. Actually, I believe, using AR + voice recognition should work better than implementing QWERTY in VR space. Latest Apple's showcase of new iOS voice control feature gives me confidence in it. [https://www.youtube.com/watch?v=v72nu602WXU](https://www.youtube.com/watch?v=v72nu602WXU)
&gt;I am trying to use interface{} as a C void\*/Java object equivalent, to work around the lack of generic support. Don't do that.
Voice recognition has its own problems like dealing with passwords and noise pollution. It can be helpful when thoughtfully mixed with other options though.
Would something like this work? https://coderwall.com/p/l9jr5a/accessing-cocoa-objective-c-from-go-with-cgo Adapt it to fit the necessary libraries you need to call with Objective C or Swift.
I prefer Vim and VScode myself. The quality is more or less on par with Goland minus the memory hog (in the case of Vim at least) and the price. Also Vim and VScode are much more flexible. My colleague tried to open a different language file on his Goland the other time and there was no support unless of course you buy the ultimate package. He followed my advice and simply used VScode which automatically installed the appropriate extension.
We're using Is() and As() but intending to move away from Errorf() to a specific Wrapf() Unwrap(), Is() and As() seem to provide functionality we wanted, and testing with xerrors.Errorf() for the moment demonstrates that it's working.
thanks @koresho I am seeing very less information for windows hardware as compared to Linux. I have exporter for Linux and I want to support windows machine as well and I am struggling for windows hardware information with Golang
Yes, there is less information. Windows isn‚Äôt as well supported in the Go community, because the language is primarily used server side, which is primarily Linux. You always have the option of using Windows API calls directly.
We use [pkg/errors](https://github.com/pkg/errors) everywhere and in every project. We haven't used xerrors yet. I really like the idea of the \`Is\` method in the new error proposal. Together with a standardized, predefined list of error sentinels (e.g. ErrTimeout, ErrTemporary, etc.) which can be used to tag all kind of errors, error handling will become much simpler. The sentinels are part of the proposal and are part of the Go 1.13 tree already but are not part of xerrors. So there is in my opinion no advantage of using xerrrors at the moment. Not having a \`Wrap\` or \`Wrapf\` method like pkg/errors on the other hand is really annoying in my opinion. Wrapping errors using Errorf and a special verb is nice for backward compatibility, but is really awkward to read and write. I hope the team working on the error proposal will figure something out to solve this cyclic dependency problem.
Yeah, but that's not a Go problem, that's a programming problem in general. Computers aren't smart enough to get "something" and then "do the right thing" with it. Even in Python, if I throw an exception, you're going to have to understand what it is, or go down your default "this is just an error of some sort" path. Even in the dynamic languages you have to know that the details will be on the errno attribute or whatever, and at least some basic information about what type that going to have (i.e., your knowledge may itself be an interface-y sort of thing but you still need to know that) in it if you want to do anything sensible with it.
&gt; Being able to tell what's inside, without opening it, would be a miracle. Reflection is not enough. We need to add also package `roentgen`.
The main thing that needs adopting is the Wrapper interface. Everything else (creating or wrapping errors, Is, As) is trivial to reimplement or tweak and doesn't affect interop between packages.
I don‚Äôt about GCP, but with AWS the context object they pass in is documented, so you can mock it in your unit tests. I‚Äôm assuming they have a similar setup.
&gt;it seems like I'd have to hunt around for the `defer` call to understand what happens in an error case. That's not a new thing, though. If you want to know what a function does, you already have to "hunt around" for the defer statements, so that's not adding a new problem. In Go, functions are the smallest unit of code that can be truly understood in isolation. We've already got defer, there's possibilities with goto, and just in general, you have to swallow all the flow control to know what a function is going to do. &gt; ... I'm not sure how this is cleaner than handling errors inline, basically every function call is wrapped in `try`. This is why I'm lightly against the use of the word `try`, though not enough to throw a fuss over that particular detail. I feel like it still carries _extremely_ strong connotations from exception handling in it, and even when evaluating it in the Go context, we get cognitive crosstalk from the exceptions context. I would not really think of this as "wrapping it in try". I would say that `try` is a _positive assertion_ on the programmer's part that the default error handling written into the function is adequate for this particular line of code. In practice, this won't be how it really works, but I'd say in _theory_ the way you think of it is that thing, err := GetThingFromUnreliableNetwork() if err != nil { // I'm gonna do something custom with errors here that // you need to read every line of to truly understand // this function! } is in fact the _default_ thing you do, and that only if the code in the block is in fact the default handler given higher in the function do you have clearance to replace it with thing := try(GetThingFromUnreliableNetwork()) I say this because using my psychic powers, I can see a couple of years after this proposal is implemented and gets out to the public a continuous low-level stream of people posting &gt; Hey, Go's great and all, but I want to handle this one error separately and this seems really klunky, is there a better way to do it? handleDifferent := false defer func() { if handleDifferent { // log error and move on or whatever } else { // annotate and pass up } }() // lots of lines like thing := try(Errorable()) handleDifferent = true thing7 := try(Errorable()) handleDifferent = false // and lots more lines like thing22 := try(Errorable()) And the answer to that is, `try` is not the default thing we do. It's the thing we _can_ do when it happens that the correct error handling is in common with everything else. But if it isn't, we use the same error handling we do today. So it's not a thing we're going to do blindly. Well, OK, yes, newbies &amp; novices will. But _you_ don't have to. Personally I think pretty much every example with `try` other than the most basic should include an error being handled the old way.
Is putting the assignment and predicate on the same line like this idiomatic Go?
Thanks a lot, your suggestions are very helpful. I've implemented the first 2. Now the program will fail on start up if any of the required configuration values are not set ([commit](https://github.com/ayoisaiah/stellar-photos-server/commit/f68b9bf70143a68ddced80939fac6e63b700b0cd)) and also improved my error handling ([commit](https://github.com/ayoisaiah/stellar-photos-server/commit/798e61350be8ebdc020c026a486eebaf7dac7b18)). Will look into simplifying the handlers next.
https://cloud.google.com/functions/docs/bestpractices/testing#functions-testing-http-example-go
Yes and no. If the variables are only in scope for that if block then it is the norm, but it can also lead to very long lines
&gt; very less I know lots of Indian people say this. But FIY this is not English. "very little"!
Thanks! What I meant to say was in Indian English sir @[ironcunts](https://www.reddit.com/user/ironcunts/)
Thank you! Although I intimated that I was going to try to do it for 1.10 it dropped off my radar and I never got around to it. Bravo.
From the docs: &gt; With the upcoming Go2 error proposals this package is moving into maintenance mode. Oof. Since this is the case, seems pretty uncertain to keep using pkg/errors vs just writing your own simple error wrapping struct implementing Wrap and Wrapf if you need that sort of thing.
They make sense to go where there is the most context about what needs to be logged.
Yeah, that's what I would figure, and therefore think it makes the most sense in individual functions. Project in question is here: [https://github.com/jrdemasi/gh\_authkey\_checker](https://github.com/jrdemasi/gh_authkey_checker), and all of my logging is in the functions themselves.
Only minor thing I don't like about these proposals is the littered \`try()\` and \`check\` statements. I can't explain why but I find them a bit untidy even though the current \`if err != nil\` add a lot more litter. I wonder how somehow making error handling the default and adding mechanism to ignore errors would work? It would be backward incompatible, would be a lot more work to implement and might take away from clarity from the code at least in the beginning so I don't think can be a viable proposal but still for the sake of argument, what would it take to make Go by default behave as if all err returning function calls were wrapped in try? &amp;#x200B; \`\`\` func operation() (err error) { a, err := subOperationOne() err = subOperationTwo() return err } \`\`\` This would be identical to wrapping the two sub-operation function in \`try()\` meaning any function that returned an error as the last return value would immediately trigger a return from the calling function as well (just like try) but people could override the behavior by using a builtin. Something like: &amp;#x200B; \`\`\` func operation() (err error) { a, err := pass(subOperationOne()) err = subOperationTwo() return err } \`\`\` here \`pass\` would force the compiler to never auto return from subOperationOne even if it returned an error. &amp;#x200B; I know this is an idiotic "proposal" as it adds a lot more magic and makes the code surprising for people coming from most other languages including existing Go developers but I can't help but think if Go somehow could somehow flip error handling by making error handling implicit and automatic by default, and giving the programmer an option to ignore errors instead. In most idiomatic Go, most errors must be handled. I don't have numbers but in the Go code I written and read, I \_feel\_ almost 99% of errors are always handled. This brings up the question if Go can somehow make handling implicit without making it too surprising. Contrary to most other ideas, I think figuring out the correct syntax is probably the key here.
That is a good point and often raised with or without errors. I wonder if tooling can solve it. What if editors could turn defer statements into floating labels when a view scrolled past it? &amp;#x200B; Something like this: [http://jsfiddle.net/webtiki/spnSZ/](http://jsfiddle.net/webtiki/spnSZ/) Imagine a small blip showing up on the top edge of your screen left aligned to the position where the current function started. The blip would only show up when you scroll down past the defer definition while still browsing code for the same function. If you scrolled past the function or scrolled back up again to the point where the defer definition came back into the view, it would disappear.
What I don't like about this and the previous proposal is that it'll highly encourage people to add generic error wrapping messages instead of highly specific ones. &amp;#x200B; Instead of this: \`\`\` func getUser(id, orgID string) (user, error) { org, err := getOrg(orgId) if err != nil { return user{}, fmt.Errorf("err retrieving org with id %s: %v", orgID, err) } user, err := org.getUser(id) if err != nil { return user{}, fmt.Errorf("err retrieving user %s from org with id %s: %v", id, orgID, err) } &amp;#x200B; err := verifyAccount(user) if err != nil { return user{}, fmt.Errorf("err verifying user account %s from org with id %s: %v", id, orgID, err) } return user, nil } \`\`\` &amp;#x200B; we'll have: \`\`\` func getUser(id, orgID string) (user, err error) { defer func() { if err != nil { return fmt.Errorf("error fetching user %s: %v", id, err) } } org := try(getOrg(orgId)) user := try(org.getUser(id)) err := try(verifyAccount(user)) return user, nil } \`\`\` &amp;#x200B; While this is so much shorter and cleaner, we lose a lot of contextual information from errors and when erros are logged, this can be a paid to debug. I realize that ideally the sub-functions called should return errors that make it clear what failed but often such functions are 3rd party libs that themselves return naked errors so it can be really unclear what actually failed. &amp;#x200B; On the other hand, I really like that this will also make it possible to do things like: \`\`\` user := try(getOrg(orgId).getUser(id)) }
Can I ask why you want to move to Programming? Usually it's the other way around.
Go makes testing HTTP endpoints so easy and painless with the `httptest` stdlib package.
Checkout the error values proposal. I personally am way more excited about that than any proposal that only aims to reduce boilerplate. I think it's great that the Go team is indeed thinking about these two as separate problems.
The proposal mentions that as kind of a blocker but says that they are working on making function with defer almost as fast as functions without it.
I think generics going to be hard from a implementation and migration point of view. I am still not sure if it will be ever implemented. But I agree that with your comment
 f := try(os.Open(filename)) This would immediately return from the function just like the _if err!=nil_ version would. Compiler would detect if the last return value from `os.Open()` is an error type and would kind of expand the `try` function call into a full `if err != nil {return ..., err }`
I might be more aggressive on the removal and say use it till you have a first job that isn't an internship. It's fine to put project stuff on the resume now because it will give you a technical issue to talk about with an interviewer. For an entry level job, you won't be necessarily expected to know the tech you're going to work on, so your projects are a good way to gauge your abilities as you discuss what you've learned.
I'm pretty much entirely self taught and did most of my learning while I was a Project Manager (not a very good one). IMHO the best way to learn is to make things, not little sample apps, but real, usable, targeted applications that do something useful. Also, finish what you start, shop it. Then rewrite / tweak. But make sure you ship.
If you learn on the side by contributing to open source and have not worked as a backend engineer before in any language, I think your best shot will be landing an entry level backend engineer job if you manage to pick up the language well enough. I doubt you'd want this. &amp;#x200B; I don't know how your company works but I'd recommend to share this with your manager and seek their support in this transition. Start working on real tickets related to backend engineering at your current job, gradually taking more responsibility until you are confident about your skill as a backend engineer. Even if your company doesn't use Go, I'd still recommend this. I think acquiring general skill and knowledge that a backend engineer must posses is a lot more important than learning a syntax and specifics about one language. If you can grow into a backend engineer at your current job using any language, it'll be trivial to pick up Go on the side and then apply for a senior Go backend engineer position in 3 years.
Also to add: To be Go idiomatic, typically use the variable `ok` instead of `exists`
My general rule is to log as high up the stack (as close to main) as I can while still having all the information I need. This is particularly relevant for logging errors. I tend to pass in a logger all the way down my stacks (or, depending on project size and conventions, I might store a logger instance in a context and pass that down -- this is more error prone though).
so with my vague sketch of an idea, `collect` is usable in a similar way to `try` in the proposal, but without any implication to flow control (it does not cause a return), and with explicit assignment to a variable. Other than passing through the remaining return values except the error, it's almost possible to implement now, which means it's not very magic. `check` does potentially cause the function to exit, but can only be used in a similar way to `return`, as a statement, and the only difference is that it implicitly zeros other return values, and only exits if the error is non-nil. Also pretty easy to grok and hopefully not too magic. `wrap` is a proxy for something like errors.Wrapf(), which is really like most of the wrapping functions available at the moment with the guarantee that if an error is nil, the result of wrapping it is nil. No magic there at all. Combined, these could give you the ability to combine error checks, not need an if block, and support a low cost way of doing best practice error wrapping. `collect` can even be trivially made to only set an error if there is not an error there already, which could cover a case where you're not picky about which error you got, you just want to know if there was *any* error. To take one of the examples: (given an assumption that collect does not set errors that are already non-nil) func printSum1(a, b string) error { var anyError error x := collect(&amp;anyError, strconv.Atoi(a)) y := collect(&amp;anyError,strconv.Atoi(b)) fmt.Println("result:", x + y) return fmt.WrapIfErrorf(anyError, "sum %s %s: %w", a, b) } or perhaps: func printSum2(a, b string) error { var aErr, bErr error x := collect(&amp;aErr, strconv.Atoi(a)) check fmt.WrapIfErrorf(aErr, "failed to parse sum argument: %v", a) y := collect(&amp;bErr ,strconv.Atoi(b)) check fmt.WrapIfErrorf(bErr, "failed to parse sum argument: %v", b) fmt.Println("result:", x + y) return nil }
If you are familiar with similar IDEs, you might like it. A guy on my team lives by them. I paid for a license and got GoLand and I've spent maybe a whole hour or two in it in the last 6 months. I just find myself back in VS Code. I know the short cuts and all that. In GoLand, I had to learn basic usage like how to even find a string in any open file. It was a chore. However, the change to the module system has completely fucked up my VS Code experience. It thinks things are not defined that are, autocomplete is a trash fire, and now it is getting more in my way than helping. One time when I really needed autocomplete to help get through some library I was unfamiliar with, I opened GoLand and its go to declaration worked when VS Code's did not. Before Go 1.11, I would have said hands down, just go with VS Code. Now, with module support being terrible, it is possible that GoLand would be worth it.
My main beef with this and other proposals is that they don't clear up a fundamental flaw in Go: Multi-value returns with errors as a poor man's sum type. Most functions in Go a contract that they _either_ return a valid value or an error: if s, err := getString(); err != nil { // It returned an error, but "s" is of no use } // s is valid Of course, this isn't _always_ true. A commonly missed contract is that of the `Read` method of `io.Reader`, which says that when `io.EOF` is returned, the returned count must be honoured. This is an outlier, but because the _convention_ is that the multi-value return is mutually exclusive, many developers make this assumption,^1 and so it is, in my opinion, bad API design. As an aside, it's also true that multi-value returns beyond two values almost always become cumbersome and impractical, especially if said values are _also_ mutually exclusive. Structs, having named fields, are generally always better than &gt; 2 return values. I would much rather see a serious stab at actually supporting sum types, or at least mutually exclusive return values. For example, I could easily see this as being a practical syntax: func Get() Result | error { ... } Such a syntax would be a much better match for a `try()` function, since there's no longer any doubt about the flow of data ‚Äî there's never a result returned _with_ an error, it's always _either_ a result or an error: result := try(Get()) or simply support existing mechanisms for checking: if err, ok := Get().(error); ok { ... } if result, ok := Get().(Result); ok { ... } switch t := Get().(type) { case Result: // ... case error: // ... } Or fancy new syntaxes for matching: match Get() { case result := Result: log.Printf("got %d results", len(result.Items)) case err := error: log.Fatal(err) } A full-blown sum type syntax would be awesome, though I know it's been discussed before, and been shot down, partly for performance reasons. Personally, I think it's solveable. I'd love to be able to do things like: type Expression Plus | Minus | Integer type Plus struct { L, R Expression } type Minus struct { L, R Expression } type Integer struct { V int } --- ^1 Github is full of projects that make this mistakes, and do something like: for { c, err := r.Read(buf) if err != nil { if err == io.EOF { break } return err } // ... use buf ... } Instead, you have to do something like: end := false for !end { c, err := r.Read(buf) if err == io.EOF { end = true } else if err != nil { return err } // ... use buf ... }
Still using https://github.com/pkg/errors. Haven't taken the time to learn the new xerrors API. I kinda wish they would have kept the API. xerrors looks foreign.
Yeah I should definitely clarify. Putting all your shit in a generic exception block***, as in not catching exact Exceptions. Don‚Äôt even think my new response is valid lol.
&gt; I suppose a's data will be a pointer to a pointer to obj- thereby introducing double indirection. Nope, no double indirection. Pointer-shaped values (pointers, channels, maps and funcs) will be directly placed in the interface value. &gt; However if I write var a interface{} = obj I cannot extract &amp;obj using the casting syntax You *can* get the pointer out [using unsafe](https://play.golang.org/p/DqEiJoD-Pf_f) but note that that's a tremendously bad idea, violating every rule about using unsafe. In particular, a) this will break horribly if you mistype your program (i.e. pass a non-`*T`, which the compiler can't catch). b) this only works with `gc` and only on certain platforms and only on certain versions - there is no language-guarantee about how interface-values look, so any implementation might do that differently and it might change in the future. c) Given that you are changing values that are not allowed to change, the compiler might decide to not actually do the writes at all. Or assume no writes are happening and use cached values when you read it back again. Or any other weird optimization I can't think of now. And d) the pointer you get might point to read-only memory, meaning your program might crash if you ever change the pointer. So, it's a bad idea and you shouldn't do it :) Luckily, there is never a need to. If you know the value is a `*T`, just pass a `*T`, not an `interface{}`. `interface{}` is really only for cases where you want to specifically accept *any* value, or the type can't be expressed in the Go type-system.
&gt; Would this be an ok project to put on a resume or should it be bigger? (I am still in school) My answer would be: The resume is supposed to reflect and present your work as accurately (and positively) as possible. The question isn't really "is the project big enough to be on your resume", but "what does it tell your employer". If its a small project, but it has some real users and/or you're simply proud of it, then that's a good thing to tell your employer about. If you think it doesn't matter, the space might be better used for other things. In either case, you can always put a link to your github account on there and let them figure it out. FWIW, I don't really know what a map reduce library would be. That description could apply to anything ranging from a small toy project to learn or abstract Go channels, to a full-fledged Hadoop-competitor. Personally, I would tend to try and look at it from a "has it users" perspective, rather than a "is it big/small" perspective or what problem it solves - if it has users, it's obviously useful :) But if you're fresh out of school, it's IMO also okay not to have any big projects on there in any case.
Ok. Thanks for the reply.
[https://golang.org/doc/effective\_go.html#maps](https://golang.org/doc/effective_go.html#maps)
I believe that I don't read the part where they mention that. Can you point me to that?
This. As a backend dev, I started off with Ruby 10 years ago and now I'm working with Ruby, Python, and Go. Not by choice (although I love Go), but because I had enough knowledge with backend dev that I was able to switch between projects pretty easily.
I recently worked a similar lexing a strings. My project is lexing and parsing a GraphQL schema and merge it. As I checked your repo you are using strings module for it. As you might know, there is a good standard module, `scanner`, for it. The scanner is tokenizing a string and having methods to peek and convert a token to a string. Take a look at my work. https://github.com/mattdamon108/gqlmerge
Wow it looks amazing! I‚Äôll definitely check it out
I thought the scanner / tokenizer was for tokenizing go itself? Is it generic?
I thought the scanner / tokenizer was for tokenizing go itself? Is it generic?
Recommended talk for anyone building a lexer / string parser. Lexical Scanning in Go - Rob Pike: https://www.youtube.com/watch?v=HxaD_trXwRE
Meh.... we just wrote our own.
Just keep vendoring. It's easier and more reliable than online proxy module stuff. 1. 100% protected against disappearing dependencies 2. Don't have to learn, setup, maintain, and update extra infrastructure to serve you a module 3. CI won't break when your extra module proxy fails Vendoring is not going away. https://github.com/golang/go/wiki/Modules#how-do-i-use-vendoring-with-modules-is-vendoring-going-away &gt; feedback from the community resulted in retaining support for vendoring.
See also https://godoc.org/modernc.org/memory
Somehow this never came up in my search. I'm enjoying my read through cznic's implementation.
One thing I always do, is wrap the routes with a higher order function, which provides the configuration via an interface, this way it allows more flexibility to the overall design. You can then switch configurations on the fly, provide mocked implementations etc. I usually try to only read the environment at the beginning, and setup a configuration to share. Anyway, just my 5 cents worth.
`"-L(i)"` does not interpolate the string. If you want that, you could do `fmt.Sprintf("-L%d", i)` instead. Otherwise, what you do now works, but technically produces `-L 1` (with a space).
What do you mean 'generic'? If you mean it is standard module, yes it is standard module which go itself provides.
oh! thanks for sharing!
I'm doing a similar thing at the moment and am using a mixture between wmi and running Windows command line tools and capturing the output straight into go
 a = nil
&gt;richardmace Can you give me more idea, how you are doing? I mean WMI is giving Prometheus and instead of sending to Prometheus, can we extract with " Windows command line tools "? Which tools you are using as " Windows command line tools "?
I didn't try it out, but I would love to see an example of what the dingo.go file looks like. Also unclear to me right now, is if it has to be services? (or can I inject anything I want, and use it for anything I want?)
Ok, but who's to say that the occurrence of an error immediately have to return an error? What if the error is fixable on the spot?
roentgen.SeeThrough(interface{}) would do the trick. However I'm writing a predict package that can tell you exactly what the interface is. It's based on the quick-peek protocol ;-)
You are to say that but using try. If you don't want it to return then don't use try and catch the err into a variable. That is the whole point of this proposal.
No. That won't work. 'a' is an array and can't be assigned nil. The OP probably wants a slice, something like, a := make([]byte, 0, 48) Then do stuff... println(len(a), cap(a)) a = append(a, 1, 2, 3, 4) println(len(a), cap(a))
In the dingotest package you will find an example of both the dingo.yml and dingo.go: [https://github.com/elliotchance/dingo/tree/master/dingotest](https://github.com/elliotchance/dingo/tree/master/dingotest) Right now it supports any Go expression, but not multiline or block statements.
Apologies if I sound arrogant but it would be easier to just open the proposal and search for defer than asking someone else to find it for you. It's one of the major headlines and has a whole paragraph dedicated to it anyway. If you just scrolled enough. That said, now that I've already done the work, here it is: [https://github.com/golang/proposal/blob/master/design/32437-try-builtin.md#efficiency-of-defer](https://github.com/golang/proposal/blob/master/design/32437-try-builtin.md#efficiency-of-defer)
&gt; a = nil package main import "fmt" func main() { var a [48]byte a = nil fmt.Println(a) } Error:./prog.go:7:4: cannot use nil as type [48]byte in assignment
General information and errors should be logged as high as possible, preferably in main. Libraries and modules should log only debug and trace messages, when explicitly asked to do it. Very important warnings (about things in code that may break something badly, compatibility issues etc.) can be logged everywhere, but some people don't like that - if you have to issue such warning, better resolve the problem in code.
&gt;var a \[48\]byte var s = a\[:0\] Thank You, helpful!
Please define 'empty`. Do you mean the zero value of type `[48]byte`? That's what the value of `a` is by default. If you want to revert `a` to its zero value you can do it in a loop or you can do `a = [48]byte{}`.
those are default values for a=\[48\]byte{}gives \[0 0 ...0\] I want to make var a \[48\]byte value to empty
\[\]
the zero value `nil` is an empty slice, you can just say `var test []Exam`
Depends what you mean by empty, both of these tests are valid, for different definitions of `empty`. var test []string if (test == nil) { fmt.Println(`test uninitialized`) } if (len(test) == 0) { fmt.Println(`test empty`) }
I think `make` is what you need, something like this ``` test := make([]Exam, 0) ``` Now `test` is a slice which contains a reference to an array of `Exam` with both length and capacity equal 0
You still haven't told us what 'empty' is. There's nothing in the language specification about emptiness of an array. You have to describe what you want using the terms defined in the language specification. Do you need a slice instead? Even those have no 'empty' value, but they can be set to have zero length. `s = s[:0]`.
The cost of passing by reference in Go is undefined. Go passes everything by value. Do you mean the cost of passing a pointer to something? That cost is the same as passing `int` or `uintptr`. Maybe you're after the cost of passing a slice. A slice is a small struct value consisting of 3 words.
Passing references are less memory intense because it won't reserve new memory addresses. It will only pass the pointer to the address in the memory. So using the reference by **passing down** is indeed better since this will most of the time put the data onto the _stack_ while **passing up** will in most cases put it into the _heap_. You shouldn't really care about that, but sometimes it's nice to think about it when you eventually want to improve the performance and memory usage a bit. Note that the data might be put into the _heap_ even when passing down since it depends **if your slice escapes from the top function**. There are many documentations and talks like this one from the _GopherCon SG 2019_: [‚ÄûUnderstanding Allocations: the Stack and the Heap‚Äú](https://www.youtube.com/watch?v=ZMZpH4yT7M0)
https://github.com/donatj/sqlread Here‚Äôs a little MySQL dump parser I have been working on. The SELECT is pretty limited in its ability right now but I have used this to get just the data I needed out of a number of massive sql dumps.
yep I meant passing pointers like `func (array *[]client.op)`
Passing a pointer to a slice sometimes makes sense when the callee has to modify the caller's slice value (that's not about the values of the slice elements). Passing a pointer to a slice is rarely a good idea otherwise. But you have to benchmark because the impact can be both ways depending on the particular usage pattern.
&gt;Time uint32 &gt; &gt;LogType uint32 &gt; &gt;Data \[32\]byte Yes,It will return \[\]slice.
This is another way of making \[\]slice.
No, its my mistake. I was searching on the issue page instead of original proposal.
I'm mainly a Java developer (in a company of around 90 Java/PHP/front-end devs). About 3 of us (including me) work in Go for some of our customers.
Stop posting this video. It teaches code smells. ORMs have nothing to do with APIs. Also just don‚Äôt use ORMs please.
[removed]
Thanks!
I think the name "Goproxy" is confusing. It makes it sound too official.
It sounds like you don't understand pointers well enough yet to worry about the cost. Ignore that and focus on understanding what a slice is, what a pointer is, how calling works, etc. first. Everything in Go is "passed by copy" but some Go structures have internal pointer that make them behave more like references in other languages. Here is a sample program that should illuminate things somewhat: https://play.golang.org/p/hEgDCPTRtgn
It kinda is and isn't. It says on the docs for it that you can customise it, but it seems quite limited in terms of customisation. You can scan things it doesn't recognise with it, but it won't return them in a particularly useful way if you want to write a GraphQL parser. For example, scanning `...` as a "punctuator" in a single token isn't possible (as far as I can tell) with the `text/scanner.Scanner` type, but having it be recognised as an individual token is quite important. Also, it's not actually all that fast compared to how fast you can make a lexer for GraphQL queries. Disclaimer: Am writing a GraphQL parser, and it's currently as far as I can tell the fastest parser out there for Go currently (it's not finished yet).
We're using Athens at the moment at Icelolly, mainly because it supports private repositories. It sped up builds dramatically. Does "Goproxy" support private repositories? If not, is it planned? And do you have any ideas about how that might work? I've had a quite look around at Athens' codebase, and it's well organised, and not really all that large and confusing.
That's exactly what Microsoft would say /s
Yes
In my testing, my Athens instance was faster than this proxy, not to mention the oddity of being forced to write your own 10 line main package to go and use it... Though I'm happy it now supports more storage mechanisms than just dumping everything in /tmp as it did the first time you posted it. From my experience, not using any proxy is the fastest anyhow...
There are plenty of packages that start with Go and nobody seems to think they are "official"
Does the "Athens supports private repositories" you mentioned refer to [https://docs.gomods.io/configuration/upstream/](https://docs.gomods.io/configuration/upstream/) and [https://docs.gomods.io/configuration/filter/](https://docs.gomods.io/configuration/filter/)? If so, Goproxy supports what Athens calls "Upstream proxies" and "Filtering Modules" at the outset. You only need to set the GOPROXY and GONOPROXY environment variables when running the go program. Or use the [`os.Setenv\`](https://godoc.org/os#Setenv) to set them programmatically. See [https://github.com/goproxy/goproxy#features](https://github.com/goproxy/goproxy#features).
compiling and running that as you have it written gives me &gt;./megacli.go:43:32: syntax error: unexpected in, expecting := or = or comma which is the "in" between flag and [] I have changed it to &gt;for _, physical_drive_number := range []string{"[252:0]", "[252:1]"} { &gt; &gt; cmd := exec.Command("/opt/MegaRAID/MegaCli/MegaCli64", "-PDInfo", "-PhysDrv", physical_drive_number, "-a0") which works but when I print it out, it's just a bunch of numbers, probably because I'm just printing the buffer.
My bad. I meant to write "range" not "in" (which explains the random downvote...). Been reading a lot of python and c#. If you have `[]byte`, you'll need to convert it to a string, or use the `%s` format specifier when printing. If your output is line based, wrapping the process' stdout with a `bufio.Scanner` can be useful.
Yeah, I agree with you that it might be faster if we don't use proxies. But I think the existence of the Go module proxy itself makes sense. After all, Go 1.13 will have a default value ([https://proxy.golang.org](https://proxy.golang.org)) for the \`GOPROXY\` environment variable. So I think every team should have a local proxy of their own. For some reason, you know, like play with the private repositories, and solve the privacy problems, I guess.
&gt; Does the "Athens supports private repositories" you mentioned refer to https://docs.gomods.io/configuration/upstream/ and https://docs.gomods.io/configuration/filter/? Neither of those, this one: https://docs.gomods.io/configuration/authentication/ So that you can specify how it connects to private repositories hosted in places like BitBucket or GitHub, etc. I guess if your proxy just uses Git behind the scenes, maybe it doesn't need any other configuration...
Forgive my ignorance, but one references static builds. I thought Go builds static binaries by default, or is this for projects that use CGo?
If you do networking, some code is linked dynamically to support proper name resolution. This can be turned off, but then the resolver is selected from just `/etc/resolv.conf` which might not be what you need.
In practice, most non-trivial Go programs built with `go build` aren't static; you can check with a tool like `ldd`. One of the reasons is CGo, yes, but you can still get linked to libc even if you don't use Cgo directly. For example, importing packages like os/user or net can add Cgo under the hood. The issue is about adding a single flag that is equivalent to all the necessary flags to produce a fully static binary, without disabling CGo entirely. For example, it's still possible to link against libc, you just have to statically link it. The issue goes into detail: https://github.com/golang/go/issues/26492
Which VCS is supported is not determined by Goproxy, it depends on the `go` command itself. See [https://github.com/golang/go/blob/58de7c6d4838729c6c133d9b2461dc6b1f766b76/src/cmd/go/internal/get/vcs.go#L91](https://github.com/golang/go/blob/58de7c6d4838729c6c133d9b2461dc6b1f766b76/src/cmd/go/internal/get/vcs.go#L91). And a huge thanks to you for pointing out this kind of auth problems, I will think about it. :-)
Not really. `var t Type` or `t := new(Type)` declares your variable, but does not necessarily initialize it, leaving you open to a potential nil pointer panic. `t := make(Type,0)` both declares, and initializes it. `len(new(Type)) == panic` `len(make(Type,0)) == 0`
[removed]
I use xerrors now. Let‚Äôs me wrap the error. I just let the errors float up, and log it at the top level, then return a user understandable error. Users can‚Äôt do shit all about a server side error, so you can usually just give a ‚Äúserver error, try again shortly‚Äù.
I hope they didn‚Äôt break the WebAssembly API again. I‚Äôm getting tired rewriting the codebase.
Thanks, the talk by Jacob Walker really clearly explains it.
Sorry, the API is still being perfected. While efforts are being made not to make random changes, sometimes it is necessary to remove error prone APIs. In this case, TypedArrayOf API was removed in favor of CopyBytesToGo/CopyBytesToJS. This also gives you the additional advantage of being able to copy bytes to Go from JS directly without any additional hoops. https://tip.golang.org/pkg/syscall/js/?GOOS=js&amp;GOARCH=wasm#CopyBytesToGo
Can't access the code, seems you need to register first. Could you give a brief comparison explaining what was bloated or working incorrectly about the other libraries? Give us more insight into your decision to write another data binding library so we don't all have to duplicate the same task of searching this question out.
Consider
I think they've got `UserConfigDir` wrong on macOS. `~/Library/Preferences` is for native Mac apps and is basically managed by `NSUserDefaults`. Anything that isn't a property list doesn't really belong in there. It's more akin to the Windows registry than to `~/.config`. `~/.config` is much more appropriate for command-line tools, and `~/Library/Application Support` for GUI apps. (That's where users will expect such programs' config files/data to be.) The feature is described: &gt; the only remaining piece which is commonly needed and portable is a per-user directory to store persistent files. For that broad-ish purpose, `~/Library/Preferences` is very inappropriate. Putting a config file in `~/Library/Preferences` is one thing, but other application data most certainly doesn't belong in there.
I know the issue is already closed on github, but could you post your comments there anyway? if it's really a bad choice instead of merely not ideal then your commentary should be on the record, so to speak.
Come on! You just can show us benchmarks like this, without showing the source codes. Did you even use the compiler optimization options for C++?
Same. Also the base error object I'm using for my packages loads the stack at every level if compiling with non production tags. At the top level where I'm handling the error, I'm unwinding the error stack and print relevant information.
Looks like there are already nearly two dozen packages which do this, what is different about gengar? * **vfsgen** \- [https://github.com/shurcooL/vfsgen](https://github.com/shurcooL/vfsgen) * **go.rice** \- [https://github.com/GeertJohan/go.rice](https://github.com/GeertJohan/go.rice) * **statik** \- [https://github.com/rakyll/statik](https://github.com/rakyll/statik) * **esc** \- [https://github.com/mjibson/esc](https://github.com/mjibson/esc) * **go-embed** \- [https://github.com/pyros2097/go-embed](https://github.com/pyros2097/go-embed) * **go-resources** \- [https://github.com/omeid/go-resources](https://github.com/omeid/go-resources) * **packr** \- [https://github.com/gobuffalo/packr](https://github.com/gobuffalo/packr) * **statics** \- [https://github.com/go-playground/statics](https://github.com/go-playground/statics) * **templify** \- [https://github.com/wlbr/templify](https://github.com/wlbr/templify) * **gnoso/go-bindata** \- [https://github.com/gnoso/go-bindata](https://github.com/gnoso/go-bindata) * **shuLhan/go-bindata** \- [https://github.com/shuLhan/go-bindata](https://github.com/shuLhan/go-bindata) * **fileb0x** \- [https://github.com/UnnoTed/fileb0x](https://github.com/UnnoTed/fileb0x) * **gobundle** \- [https://github.com/alecthomas/gobundle](https://github.com/alecthomas/gobundle) * **parcello** \- [https://github.com/phogolabs/parcello](https://github.com/phogolabs/parcello) tech.townsourced .com/post/embedding-static-files-in-go
Lol
Do it one way then scrap it and do it the other way.
I'd like feedback/suggestions or anything that can make it better! &amp;#x200B; Thanks guise!
 1. If In fewer words, yes **it can help you**. You will **look more skilled and more ambitious** if you will **contribute to most well know projects**, I mean something like Kubernetes, Jupyter Notebook, Angular or something else of other great techs. It's just because these projects use and know by many developers too, so its code quality is high as well, if your pull requests had merged e.g were approved by projects maintainers it will be definitely great achieving as you can see. Just imagine you are highly contributing to Kubernetes with success and you want to work at Google.. well Kubernetes created and maintains by.. ryt! Google. I hope you got it why it'll be important actually :) It's a very dirty example, don't mind it haha. 3. **Practice, practice, and practice** again, just do it, I think there's **no secret sauce**
Nice
&gt;Should JSON properties should be snake\_case? No. I tried it and it doesn't really surprise me, but JSON properties that are not snake\_case work: [https://play.golang.org/p/tU80CIX9UA\_N](https://play.golang.org/p/tU80CIX9UA_N) using this modified User struct: type User struct { ID string `json:"Id"` Email string `json:"Email"` FirstName string `json:"FirstName"` } &amp;#x200B; &gt;Are their any reasons to do this instead of using the capitalized go fmt recommendations for names? [https://golang.org/pkg/encoding/json/#Marshal](https://golang.org/pkg/encoding/json/#Marshal) uses camelCase in the explanation. (myName) JSON object keys and Golang structs are not the same (JSON is way older) and the tags implementation is just a helper to convert between them. Conventions about casing and meaning of those are way different. As far as I know in JSON does not assign any meaning to the casing, where in Golang the case of the first character of a member decides if it's public or private. Note that Golang usually uses PascalCase for public fields and the golang JSON example uses camelCase.
http://www.cs.kent.edu/~jmaletic/papers/ICPC2010-CamelCaseUnderScoreClouds.pdf
http://www.cs.kent.edu/~jmaletic/papers/ICPC2010-CamelCaseUnderScoreClouds.pdf
JSON is used by a lot of languages and a lot of tools. Every one has their own conventions for key naming. The only important factor is to keep it consistent within your application and with the wider ecosystem you are developing within. If you are talking with an application or system that already has a convention use that. Otherwise I tend to see kabab-case and snake_case most commonly in the wild.
\o/ Let‚Äôs try to have regexp performance improvements in every release from now on :)
There isn't any reason to use the `json` struct tag if you're going to name the field the same as the struct property.
There is. Quoting straight from [https://golang.org/pkg/encoding/json/#Marshal](https://golang.org/pkg/encoding/json/#Marshal): // Field appears in JSON as key "Field" (the default), but // the field is skipped if empty. // Note the leading comma. Field int `json:",omitempty"`
I meant there isn't a reason in your example. As you've shown, even if you're adding functionality (omitempty) there still isn't a reason to rename the field to the same name.
What is the prediction on what release will contain generics? 2.0? This is not generic trolling im could consider adopting Go if it had generics so i really want to know if its coming.
You're right, [without the tags](https://play.golang.org/p/uTNjG4mdx5w), the code does exactly the same. I didn't know the default behaviour of the golang json lib, so I went with putting it up explicitly. The point of the entire tiny progam was to prove that the answer to "Should JSON properties should be snake\_case?" is no by running it with JSON that does not has snake\_case. Putting the tag out there explicitly made that more clear in my opinion, as some people (including myself until 5 minutes ago) may not know the json lib behaviour if the tag if absent.
I've been using go for 6+ years now and I don't know what generics are and I've never felt there was something I couldn't do without them. what are they even? is it to save time coding?
It's about creating reusable components and functions for different types. If you create a list that can hold Object you can put whatever subtype you want in there. If if you have a list of Cars and then put a Mushroom in there because of a bug your program will get an error when you try to retrieve all Cars . With generics you instantiate a list for example and specify the type that it should be able to contain. It's now impossible to put anything other than that type in that list. When Java didn't have generics it was very common to get ClassCastException in runtime . When generics came along all of those errors disappeared. Its actually a very easy concept to learn and also very powerful. I can really recommend that you learn them. You can definitely live without them just as Javascript lives without types. It just makes the code more stable and predictable.
I think this is more a question of style/convention.
As a semi-new user to Go, they're really not necessary or something you find yourself missing. Generics are only really useful for if the language uses inheritance, which Go simply doesn't have. Go uses composition instead, which makes it so situations where you would need generics don't really come up that much.
Generics is also used to create specialised versions of things. In go I guess you can put any type of object in a list at the same time. With generics you can limit the type of objects that can be used with a list. That makes a big difference in runtime quality. A class of errors that just disappears
&gt;wrap so, per [https://go.googlesource.com/proposal/+/master/design/29934-error-values.md](https://go.googlesource.com/proposal/+/master/design/29934-error-values.md) you can Wrap using the %w formatting directive. e.g. xerrors.Errorf("%w : %s", originalErr, message) and can also be used with fmt.Errorf
Not true. Slices (Go's list equivalent)/maps/etc. are all strictly typed so they only accept one type of object. I've never had a type error at runtime. Anyhow, the point I was trying to make is that most of the use cases for generics either don't come up or are largely replaced by other language features. Many design patterns from languages like Java or C# don't carry over to Go because the language is so different. (It's impossible to start making classes called like AbstractBaseEnterpriseFactoryBean or stuff like that)
Generic programming (in a very broad and I-am-not-an-expert way) is essentially the ability to say "I take a `Thing` and will give you back a `Thing`", for example a slice is technically a generic construct, as it works with arbitrary types. as is `make` you can get away with something kinda similar by "boxing" things into `interface{}`, which is what a good chunk of go code that needs to work with arbitrary types does. Generics is just special syntax for that behaviour, as well as not chucking types into a magic type that you have to drag them out of later eg: func myMagicFunc(stuff interface{}) interface{} { doTheThing() } Followed by a call such as var myThing string = "magic" out := myMagicFunc(myThing) theRealOut := out.(string) Having `myMagicFunc` be a generic function gets rid of the need for the type assertion and removes a "this might explode" aspect from the code (yes that can be fixed by checking that the assertion worked, but I digress) tl;dr it can make working with arbitrary types, for things like collections (see [sync.Map](https://golang.org/pkg/sync/#Map)) a little cleaner and (in theory?) faster, depending on the backend implementation of the generic behavior. Or, thats my understanding and .2c I have definitely run into places where I am type asserting all over the place, and that can get both confusing and messy. Perhaps that means I need a rewrite in those places, but it does not make the point less valid if that is the case
I agree. I know what generics are, but I've yet to seen an example in Golang where generics have *elegantly* solved a non trivial thing that hasn't otherwise been possible with the language.
You could try a pattern like this: ```go type server struct { routes *gin.Engine // other parameters } func newServer() *server { return &amp;server{ // initialize with parameters } } func (s *server) routes() *gin.Engine { r := gin.Default() r.Get("/", s.basicGet) return r } func (s *start) start() { s.routes.Run() } func (s *server) basicGet(ctx *gin.Context) { // Handle context } func main() { server := newServer() server.start() } ```
This doesn't relate to Go at all.
I'm not sure this is good r/golang material, but it does relate to Go. Docker is written in Go, and you can even see some in the linked screenshot.
I prefer kebab-case because it discourages users from using JSON objects without an adapter class.
Why don't you try to fork it, fix it and installing from there?
Ideally, it would be this: &amp;#x200B; [https://github.com/golang/go/issues/26640](https://github.com/golang/go/issues/26640)
Because I don't want to maintain a fork for a couple patches.
I too think it's not a good design. A locally caching resolver is much nicer in this regard. However, NSS is what the system's interface is, so Go must support it.
So it will be pretty tricky
I wrote a one character at a time scanner, and tried to use regex to lex them.. it worked 90% but it was flaky if you had to add grammar. I really think I should learn a pattern to design a fsm that I can encode my grammar rules into. Most of the transition trees I‚Äôve seen work from that character based scanning and work up through the transition tree / fsm.. but yeah, regex not the way to go.
It makes the code less stable and predictable, you mean - this is the number one reason the creators of Go cited for not including generics, that they are easy to abuse and become hard to reason about very easily. The fact that you would demonstrate generics by stuffing mushrooms into a list of cars as opposed to say, Cars and Quad bikes into a list of vehicles, is quite telling of the misuse of generics and the absolute shit storm of a codebase they can lead to.
Look at sync.Map. That‚Äôs all the justification for generics I need.
I'm not clear on exactly what is coming in the errors counter-proposal. [https://github.com/golang/go/issues/32463](https://github.com/golang/go/issues/32463) was filed, but it didn't sound like the conversation resolved to adopting that whole proposal instead of Is/As etc.
Sorry! The repository was `internal`. I've made it public now, so you shouldn't need to register to access it. Regarding the decision, I tried `go-bindata` and found it too clunky and difficult to get file data into a simple byte slice. One of the issues is that the files are stored as compressed `Assets`, and accessed via a library call with an identifier, which has to be the original path of the files/directories. Even with the `-nocompress` option, the library call layer still exists and I found it too redundant and adding bloat to the runtime. I also found this thread: https://stackoverflow.com/questions/13904441/whats-the-best-way-to-bundle-static-resources-in-a-go-program However, it seems the solutions listed here(besides the `go-bindata` answer), seem to involve manual work, which I wanted to eliminate as much as possible. I also found https://github.com/gobuffalo/packr, but quickly realised it presented the same issues I had with `go-bindata`. By myself, I tried to take advantage of go's compile-time injection by running something along the lines of ``` go build -ldflags "-X main.myTemplateData=$(cat file1.txt | base64)" . ``` But I quickly realised that there was a size limitation on the amount of text you could inject into a variable at compile-time. Smaller strings worked, but files were simply too large. My final resort was this trick mentioned in the golang wiki itself: https://github.com/golang/go/wiki/GcToolchainTricks#bundle-data-into-go-binary However I could not get it to work. --- With all those in mind, I simply decided to write my own single-purpose tool that would do the job for me.
Have you used the map type, or channel? Those are generic types. What about the append function? That one is generic as well
Workers that work with any kind of task
You‚Äôre right. I‚Äôm gonna go post in the C subreddit about random things written in C...
&gt; It makes the code less stable and predictable, you mean - this is the number one reason the creators of Go cited for not including generics Citation needed
Containers are the easy example to pick. There are other scenarios, but containers always come to mind first. Trees, Pools, Ordered Hashmaps, etc.. How often you use these depends entirely on the sort of work you are doing. I set up a radix tree the other day which used `interface{}` to hold the values. I wrote a wrapper to unbox the values when reading from the tree. It's not ideal but I just wrote the extra code and got on with my day.
All of the above use some form of `Asset` and/or `FileSystem` object to wrap the bundled file data, which has to be retrieved via some library call. I was looking for something that literally has no function calls or fancy asset compression, just a generator for go source code with this: ``` var myVar = []byte{....myfiledata in bytes....} ``` My reasoning for `gengar` comes from the Unix philosophy of having a tool that "does only one thing and does it really well". Simply put, it does only the above-mentioned code generation, and other features and functionality are cosmetic (`gofmt`, n-bytes-per-line, etc.). Regarding compression, users can always pre-compress the files in a build script before using `gengar` to bundle it with the executable. Having filesystem abstraction seems to me like a bloated abstraction layer on top of a bundle of files, and the access time always takes a hit, especially if the file data is accessed often. Hope my reasoning and motivations makes sense to you!
As someone who primally writes in C# and C++. Generics are an absolute godsend in certain instances. I'd hate to rewrite the same implemention 10 times over. Certain problems are just impossible or incredibly cumbersome without the use of generics. It's definitely a worthwhile investment to make into the language. The lack of generics and apparent lack of care by the developers is very frustrating because Go has a lot going for it, people want to like it and use it but are hindered. It's a nit ridiculous. I'm not saying is trivial to implement but it seems to have never been of any interest of the developers. Very little effort has been put into it even after years of development. It's become a meme. It's a major misstep for the language and I truly believe, Go would have had more adoption if the devs took their heads out of their asses just every once in a while and listened to the community.
&gt; The fact that you would demonstrate generics by stuffing mushrooms into a list of cars as opposed to say, Cars and Quad bikes into a list of vehicles, is quite telling of the misuse of generics and the absolute shit storm of a codebase they can lead to. /u/pure_x01 specifically cited this as a bug that the compiler would catch with generics. Without generics this would be a runtime error.
Bring possible doesn't mean it's implemented elegantly, succinctly or clearly. Why would we strive simply for possible? It's possible to ride across the US in a horse driven buggy, but why would you want to?
The Go Team: You're too stupid to use generics. We're going this for your own good.
Slices and maps ARE generic. The difference is that they are implemented by the language itself. Users of the language so not have the same liberties and cannot implement any of these types. That means if the language lacks something you need, you're shit out of luck. There is no option for you to create your own implementation.
no, bazel is huge and complicated and totally overkill for 99% of projects.
Ian Lance Taylor has been thinking about generics since [2010](https://www.airs.com/blog/archives/291), and Russ Cox confirms that he's been on the problem since before Go's open source release (https://go.googlesource.com/proposal/+/master/design/go2draft-generics-overview.md). To say that generics are of no interest to the team is not fair, the problem is really difficult to solve in a way that feels like Go.
A long way to go, and probably needs some better docs, but thought I'd share anyway
no
If you don't understand bazel you definitely don't need it. Go mod will handle your dependencies just fine and is built into the core go command. That plus a simple Makefile to automate basic tasks is going to go a long way for you.
The main point of bazel is ensuring widespread integration
We use bazel at my work for some of the monorepo stuff. It‚Äôs the worst thing ever. It may work for google, where they have teams of people dedicated to managing it, but for anything other than 100k+ companies it‚Äôs a nightmare. Go standard tooling works just fine
What issues are you experiencing?
There is some truth in it... Lack of generics in Go has always been considered an advantage to some and a disadvantage to others.
bazel might be overkill for simple Go projects, but it has several advantages over go build. Things we commonly do with Bazel: * build dependencies / tools in other languages than Go * build React.js apps (using react-scripts, babel, webpack, ...) and add them to the Go app (go-bindata) * setup and manage all tools within bazel automatically (Go compiler, protobuf compilers, npm, create-react-app, go-bindata, ...). "bazel build" just works, regardless of the development machine and the version of the tools installed there. * build tar.gz archives, Debian packages and Docker images (you do not need to be using Debian or running Docker to be able to build those things). * in case of Docker, we often build and add "tini" (a small init system written in C) to our "FROM scratch" images. It's really nice to just write "bazel build //hello-world:debian" for example, and let it figure out how to install and update the Go compiler, build and embed React if necessary, compile the protobuf compilers, generate the protobuf files, compile the Go stuff and generate a Debian package that can be easily installed. &amp;#x200B; Advantages over "make" are that dependencies are tracked much better. If you do not have listed a dependency explicitly (e.g. by forgetting to list a .h file in your current directory), then the dependency will not be available. Bazel uses a sandbox / virtual filesystem and only allows access to files listed as dependency. Therefore you do not need to run things like "make clean" ever. You can always build incrementally and your build is always up-to-date and correct. You can even add remote build caches and remote builders if you like. &amp;#x200B; Bazel might look complicated at first, but it really isn't. At least not compared to any other build systems... There are predefined rules for nearly everything (e.g. go\_package, go\_binary, go\_proto\_library, etc.) that are extremely simple to use. In case of Go, you can use "bazel run //:gazelle" to generate all Bazel rule files automatically. You have to copy a WORKSPACE and a BUILD file snippet from the README once in order to make it work, but after that it is as easy to use as "go build". If you need more complicated stuff, you can use "genrule" which allows you to write rules similar to a Makefile by specifying inputs, outputs and a command to run. The only difference is that you really must list all your dependencies. If you need even more advanced stuff, Bazel can be easily extended by writing Skylark (basically Python functions). Those function simply have to return a, possibly dynamically generated, graph of dependencies and commands to run and Bazel will do the rest. All the predefined rules mentioned above ("go\_package" etc.) are implemented this way.
I really loved this [one](https://github.com/demo-apps/go-gin-app?files=1) He set up his routes In a really clean way in my opinion
You are very very mistaken
Take a look at: https://github.com/ribice/gorsk-gin
You can use closures to wrap your gin handlers: [https://goplay.space/#jUhx689n81A](https://goplay.space/#jUhx689n81A)
Damn, you should dial back the bigotry a bit. Just because you don't know what generics are doesn't mean that they're a bad feature.
Can anyone perhaps explain the use-cases for [https://github.com/golang/go/issues/14295](https://github.com/golang/go/issues/14295) (allow go build to create multiple binaries)? Is this primarily for not having to rely on external buildscripts?
&gt; I've been using go for 6+ years now and I don't know what generics are and I've never felt there was something I couldn't do without them. what are they even? is it to save time coding? If you don't know why to use it then you just have to learn some more powerful languages (even if you won't use it and stick with go). Here is a wonerful quote [from the great article](http://www.paulgraham.com/avg.html): &gt; Programmers get very attached to their favorite languages, and I don't want to hurt anyone's feelings, so to explain this point I'm going to use a hypothetical language called Blub. Blub falls right in the middle of the abstractness continuum. It is not the most powerful language, but it is more powerful than Cobol or machine language. &gt; And in fact, our hypothetical Blub programmer wouldn't use either of them. Of course he wouldn't program in machine language. That's what compilers are for. And as for Cobol, he doesn't know how anyone can get anything done with it. It doesn't even have x (Blub feature of your choice). &gt; As long as our hypothetical Blub programmer is looking down the power continuum, he knows he's looking down. Languages less powerful than Blub are obviously less powerful, because they're missing some feature he's used to. But when our hypothetical Blub programmer looks in the other direction, up the power continuum, he doesn't realize he's looking up. What he sees are merely weird languages. He probably considers them about equivalent in power to Blub, but with all this other hairy stuff thrown in as well. Blub is good enough for him, because he thinks in Blub. I suggest you to read the whole article to have the context. One more quote to add some (but you still better read it all) &gt; All languages are equally powerful in the sense of being Turing equivalent, but that's not the sense of the word programmers care about. (No one wants to program a Turing machine.) The kind of power programmers care about may not be formally definable, but one way to explain it would be to say that it refers to features you could only get in the less powerful language by writing an interpreter for the more powerful language in it. If language A has an operator for removing spaces from strings and language B doesn't, that probably doesn't make A more powerful, because you can probably write a subroutine to do it in B. But if A supports, say, recursion, and B doesn't, that's not likely to be something you can fix by writing library functions. In a nutshell: any time you write `interface{}` or copy-paste Foo_i16, Foo_i32 you could write `Foo&lt;T&gt;` only once and reuse it accross the codebase
Thanks for the input. I wrote that proposal and CL, so that's partly on me. I searched a bit online and came to a conclusion, but I'm not a Mac expert by any means. Luckily enough, this hasn't shipped in any release yet, so we're in time to fix it.
r/docker ?
Sorry, the issue linked in that slide is /u/rogpeppe1's: https://github.com/golang/go/issues/32405 How did you find that link? I don't think it's in my slides, so I'm a bit confused.
Imagine when one does `go install ./cmd/...`. Why shouldn't you be able to do the same with `go build -o output/ ./cmd/...`? Technically you can already, with `GOBIN=$PWD/output/ go install ./cmd/...`, but that's not nearly as easy to find and use.
I see there's been quite a bit of discussion on this :) There is a generics draft as part of the Go2 plan, see https://blog.golang.org/go2draft. Error values turned into a proposal, and a limited version of that was merged in for 1.13. Generics needs to follow the same path. A specific proposal must be filed, discussed, approved, then implemented and merged during a release window. None of this has happened that I'm aware of, so I think it's unlikely that it will be available in 1.13 or 1.14. 1.13 saw some minor language changes, so I assume 1.14 will include some more minor language changes.
&gt; I searched a bit online and came to a conclusion Understandable. The people who do know macOS well should have piped up earlier. I should have posted my comment on the proposal, instead of moaning on reddit, though I see some good soul (matt0xFF) copied it over there and, more importantly, added the relevant official guidance, too.
Yeah, like languages that **highly** depends on inheritance like Haskell, MLs, Rust, etc.
You've already got the answers you need from here, but I'll add: &gt; Are there any benchmarks avaliable You can write your own quite easily, it's just like writing unit tests, but with a loop. Being able to write benchmarks and understand their results is incredibly powerful, and it's really not a difficult skill to begin to learn at all. Here's the official docs on it: https://golang.org/pkg/testing/#hdr-Benchmarks You can find some surprising things out about how Go works by using benchmarks and looking at the difference that using pointers makes, or for example, how you structure your structs can affect memory usage, etc.
&gt; what are they even? is it to save time coding? Slices and maps are generic. They're containers that you can put lots of different types into. `[]string` is a slice of strings, `[]int` a slice of ints etc. You can't define (type-safe) containers like that yourself, though. If you want a `Tree` data structure, you either need to write a different implementation for each type it can contain (`StringTree`, `IntTree`, `Float64Tree` etc.) or forgo type safety and use `interface{}` (as `sync.Map` does), which opens you up to runtime errors. With generics, you can write a single `Tree` container that can hold different types the way slices and maps can while preserving type safety.
True, thanks üôÇ I wasn‚Äôt aware that `go install` already supported `...` üôÇ
The changes to error looks interesting. I already do something similar in that I have my own code error type which be standalone or can wrap other errors and allows me to easily check what the error actually was. I also have some IsError of type utility functions. It was a bit difficult dealing with errors before I made this change so hopefully if something similar becomes standard it will help what can be a bit confusing for newcomers.
[removed]
You saved my day :D
&gt; Generics are only really useful for if the language uses inheritance, which Go simply doesn't have. Generics and inheritance are completely unrelated and orthogonal. You can have one without the other just fine and in fact many programming language are like that. If you want a very simple example of usage of generics unrelated to inheritance, think of the `Max` function. Right now, it only accepts floats and produces floats. If it were generic, it could accept any numeric type and return _the right type_ without any type casting.
This is awesome, thanks a lot, I think I'll use it at some point and write my own bot.
Great!
I haven't used bazel, but my experience is related. At my work we use the waf build system as a way to standardise the build/release process across a number of languages. The Go tool on its own is fine for building, but then we can layer more complicated steps like a common deploy path, various test processes, documentation, release notifications. Also, having the build system makes it easier to build cgo projects with the correct C/C++ dependencies and flags. So I would consider it similar to bazel, where you get the ability to string together a lot of rules and reproducible recipes for a consistent experience.
Maybe try http:// instead of https:// in your url? Looks like the google server where you are is not set up for HTTPS
[removed]
a simple Makefile is the way to go
I got it to work now. Google is configure only for https. The problem was with the proxy at my end.
&gt; It's impossible to start making classes called like AbstractBaseEnterpriseFactoryBean or stuff like that Bold claim. The thing is, having `interface` in go means that you effectively already have basic generics. Please consider [this example](https://gobyexample.com/interfaces). What people are actually missing is a series of more advanced / handy / efficient things that you can do with proper support from the compiler. So basically the language is not so different that you can't carry over patterns, it' more like the language lacks some features that make porting certain specific cases inconvenient.
https://www.udemy.com/course/learn-how-to-code/ - slow paced, but pretty good
You're on so thin ice you're practically walking on water now
I actually had a bug caused by expecting octal syntax to be a thing when it wasn't, so glad it's now a thing.
Elasticsearch will work with any language well since the interface into the application is a CRUD http API.
Oh ok ! I'll try it then. Thank you !!
Interesting write up! My big issue (worry) with Flutter is that I am excited for what I could do with it, and then I remember Google Reader and Google Hangouts and I think, "How long until they take this project behind the woodshed?"
Official Golang's Tour as for begginers, there's good explained key features https://tour.golang.org/welcome/1 I think you know it, anyway it's not kidding )
Considering that Google makes heavy use of Flutter in Fuchsia they will keep it alive in the foreseeable future.
[Learn Go With Tests](https://quii.gitbook.io/learn-go-with-tests/). Teaches Go using TDD
I'm not trolling here, but I thought that Fuchsia was just an experiment they were using to base new Android/ChromeOS work on?
just to be clear: go doesn't pass anything by reference -- only by value. also, there's a huge semantic difference between passing by reference and passing pointers or other values around. i think if you understand that difference, you'll understand the costs associated with it.
This was by far the most helpful resource I used for learning go: https://quii.gitbook.io/learn-go-with-tests/
Very interesting works! It's a funny question though, isn't it actullay run or build?
So you think using Flutter on mainframes be more serious because they are definitely not experiments and used heavily in important places.
If you think products like Google hangouts/reader and open source technology like Flutter or Go are comparable then obviously you are better off not using them.
https://www.airs.com/blog/archives/559
And if a Makefile gets frustrating, look at [Mage](https://magefile.org).
I am very sorry for offering an opinion with which you took exception. I was not trying to antagonize. I will unsubscribe from this subreddit so you won't have to see my questions or comments in it any longer. Thank you for your time.
Personally I convert to native types as soon as possible after receiving data, and convert back as late as possible before sending data. Otherwise conversion code spreads through the codebase, as you've discovered. By doing it at the interface between your code and the system, you can put it all in one place and test it carefully.
Google ad software is written using Flutter. They are big Flutter users. https://siliconangle.com/2018/12/04/googles-new-flutter-app-building-tool-ready-rumble/
Go has several excellent elasticsearch client libraries. Don't use elasticsearch as the primary store of your data, though - it's not an ACID datastore like a SQL database is (not that that's all that matters, but it can be confusing to create a document, then query for it and have it not show up).
The syscall/js package comment says: &gt; This package is EXPERIMENTAL. Its current scope is only to allow tests to run, but not yet to provide a comprehensive API for users. It is exempt from the Go compatibility promise. It‚Äôs too early to be able to not make any changes to it. The bar for changes is high.
I've also noticed a similar problem. I've wished that go-swagger had a struct tag I could use to override the type it thinks a field has. I've got a [big.Int](https://big.Int) in one of my structs, which can't be replaced by any sort of machine int, and it shows it as an object with no fields, because [big.Int](https://big.Int) is a struct type with no exported fields. I built a complicated mechanism that sort of works like some other [struct mappers in Golang](https://godoc.org/?q=struct+convert+map), but also gives the ability to declare type conversions. That is, you can say "when converting this struct Source to that struct Dest with this converter, when you see a field Source.Field that is a string and Dest.Field is a models.EncodedPubkey, use this conversion function (which can return an error to fail)". I kinda thought it might already exist, but I'm not sure it does. I'm... not sure how I feel about this complicated mechanism. It would make me feel slightly better about having it in my source code if it were something interesting to other people. I just double-checked my code base and I've got it isolated with no references to any other internal code. If there's interest, I could open source it today. Still, I'd have to call it "lightly tested". By its nature, if it works on a given pair of structs, it'll tend to keep working, but it could break on new structs. But I've also sort of wondered if it's overcomplicated. Part of that, though, is that a project I thought would be large has actually not grown that large yet, so I'm not actually pushing as many types through it as I thought I would. If you've got dozens or hundreds of external types, this may be more helpful. On the plus side, it does mean for each type conversion, you're only writing it once.
You might find this interesting: [chazapp/dante](https://github.com/chazapp/dante). It's a personal project I wrote in Go that stores data from a text file into either MongoDB or ElasticSearch. Feel free to DM me if you have any questions.
Huh no need to be so defensive. You could've said that you still do not agree with what I said or that you did not think of difference between the two.
I was about to doing this thanks for the advice, I found a lot of stuff about pro/cons using Elasticsearch and I should definitely not !
It's the issue that rsc filed that is mentioned in that proposal. I can't see very much else that indicates what parts of the proposal were accepted, but the discussion doesn't seem to indicate that it was.
https://groups.google.com/forum/#!searchin/golang-nuts/dependency$20injection%7Csort:date
I am looking at it right now, that's exactly the kind of stuff I am trying to learn, so I'll try to make something similar by myself and if I have some questions I'll let you know. Thank you for your help !
Bazel works well for managing monorepos and other large heterogeneous software projects. Make is for those awkwardly-sized projects that are too big for bash scripts but too small for a fully-fledged build system. And it's not even very well-suited for that.
Objectively wrong. See other replies for why. If you want to make a guess without knowing what you are talking about at least make it more clear that that is the case. Actually curious what language you could come from that gives you that impression.
Ah, I see. I don't think Russ has completely made up his mind about what will stay in 1.13. The only reason I included the link to Roger's proposal is to show that the errors API for 1.13 might not be set in stone yet.
Big FOSS projects with a strong leadership driven by a company die, if abandoned. They go to Apache Foundation and live in a perpetual semiconscious state, updated once a year to keep the copyright file up-to-date, forgotten by everyone but some bearded guys whom names are lost in the night of time
I converted your example to `python` (it uses the `requests` package instead of `http.Get` and it works perfectly (except that I get an error message saying, "The provided API key is invalid." which is fine): import requests def main(): key = "mysecretkey" location = "Bangalore" url = "https://maps.googleapis.com/maps/api/geocode/json?address="+location+"&amp;key="+key #fmt.Println("Starting the application...") resp = requests.get(url) print(resp.text) if __name__ == "__main__": main() So my understanding is that something could be wrong with your `golang` http setup. Is there some kind of configuration you forgot to change? I'm not aware of `golang`, so I can't comment.
If you're going to talk to people like a prick some of them are going to get defensive.
Really liked this approach as well. API is still small as of now but I'll definitely move to using a structure like this
Thanks for the reply! I'm trying to keep deps down to a minimum so I'm not sure this will fit for me, but I'm saving the link because it's definitely an awesome starter kit
Wow thank you so much, this works perfectly. I'm still fairly new to Go and so I had no idea about closures. Time to do some more reading :)
Thanks a bunch for the reply. Decided not to use this pattern in favor of using closures, but it helped a lot in visualizing what's going on under the hood
You never seem to mind your language. Do you?
I fixed the problem, you are right. Not a problem with golang per se, but my local proxy. Thanks anyway!
"never"? Do you know me?
Whoa! This is my exact feeling too. Even Angular.... 1 -&gt; 2 was a dog-show.
What are you trying to say?
This person summarized the benefits of Bazel quite well. I'd add that in larger project, Bazel helps quite a bit to reduce build times both through caching (local and remote), and tight dependency to make sure only affect targets are built. The latter may be slightly less relevant to Go since the language itself is already stricter with dependencies. Anyways, if anyone is interested in trying out Bazel, I have a boilerplate that I use for my own Go projects. https://github.com/rickypai/golang-boilerplate Feel free to try it out and/or ask any questions.
I don‚Äôt know why everyone gives me walls of texts instead of just saying this. thanks.
The standard library doesn‚Äôt make use of any hidden generics feature. They‚Äôre bound by the same constraints.
I don‚Äôt know what it is because everyone just gives back giant walls of text that say nothing of value. some of the code samples make sense though.
I thought that was angular dart.
There‚Äôs also a pretty good library, olivere elastic that will do quite a bit of the lifting for you. But if you want raw then by all means it‚Äôs just json
Make may be easier to read than bash depending on how the succinct the recipes are, however.
&gt;It reads YAML and generates the necessary Go code to build your container. So in an effort to avoid me forgetting to wire dependencies correctly in my code, I now need to wire dependencies correctly in a separate YAML config? Doesn't seem like a good trade off.
That‚Äôs the web client. Mobile is flutter
Glad I could help ; this project is still on-going, I plan on writing a REST API and a Front-End along to CRUD the data. Come back in a few days and there might be new stuff to see.
So you would provide e.g a SQL DB as my primary storage solution and use elastic than for what? I don't know exactly how I should these two things. Imagine having all your Posts of a blog saved to a SQL DB and have a synced version on elastic. Why would I use elastic then?
please stop :(
You would sync into elasticsearch to allow for powerful, fast searching, filtering, and faceting capabilities that a SQL database doesn't really do well at. Most importantly this applies to full-text search, but both MySQL and Postgres have pretty decent full-text search capabilities today.
I actually like these spreading through the codebase. They're strongly typed, and you can attach validation to them at both the contract and db validation layers. &amp;#x200B; Models typcially don't import anything else in the project, so it doesn't really cause import problems (though if it did you could have a special types package?) I don't see an argument for containing the types to a single place in the app.
I don't know of anyone using elastic search as a permanent datastore. Is that what you're intending?
So I want the DB and Elastic be the same, but would I do that, I would have to track, if there were any changes in SQL and always mirror elastic. So I would go for a external service, that would track for it, or doing two calls whenever something new is adding to the DB - adding something to the DB, refresh elastic state?
Let's just agree that NSS is GNU/Proper.
[removed]
[removed]
[removed]
[removed]
[removed]
[removed]
"Services" should own their own databases. You should generally not have more than one program that ever accesses a given database. I would recommend doing the second approach, but you may want to build up a queue of documents to update in elasticsearch and do them in batches in the background.
[removed]
it doesn't matter for us. this world live with changes and we will catch the changes. today we will write go and flutter. who knows what we will write tomorrow. for me go and flutter time saver. if i would find another time saver and more money offers techs I will use them. so we always have to be ready for change. in my opinion of course.
From what I remember, Apache Bench is single-core bound. If you want to test server you need to use https://github.com/tsenart/vegeta (or the older https://github.com/rakyll/hey)
As he is not using any premade http server but a simple socket in perl, he should do the same for go and then do the benchmark. There is a ton of additional stuff in net/http that he surely didnt do in perl
The raw results at the end have some peculiarities. The go server transferred 50% more bytes and had a higher requests/sec and higher transfer rate and lower time per request which seem to contradict the other data from apache bench. The Perl example is also very low level, directly writing to the socket whereas the Go example is using the net/http stack. It could be interesting to see this written with Go‚Äôs socket library. This is also not super practical in that if you care about absolute fastest static asset serving, you should use nginx or a CDN. It‚Äôs hard to make realistic benchmark scenarios, but I would be more wary than the blog author seems to be about extrapolating from a simple test like this.
[removed]
You'd generally get a wall of text because while the maps/channels do use generics it's not really a great explanation of why they need them to simply point out they do.
I really appreciate your time!! I will have to look for some approaches, because I'm really inexperienced with this.
[removed]
It's a senior developer retention project. Just playing, I've been thinking they're taking steps to fully owning the IP of an operating system.
In C#, generics can avoid boxing and unboxing of value types (struct). Boxing/unboxing leads to unneeded allocations and copying, which can plummet performance.
The standard library? No. The compiler built-ins? Yes. [https://golang.org/src/builtin/builtin.go](https://golang.org/src/builtin/builtin.go) the `type Type` and its use in defining the other builtins that work generically are pretty clearly generics. &gt; func append(slice []Type, elems ...Type) []Type append, for example, is declared as taking a slice of a given type and returning a slice of that same type. Generics. Simple demonstration they are generics ``` stuff := make([]int, 0) stuff = append(stuff, 10) ``` That works ``` stuff := make([]int, 0) stuff = append(stuff, "foo") ``` &gt; cannot use "foo" (type string) as type int in append This means the `make([]int, 0)` call returns a type that understands it's a container of `int`s, and the compiler knows that `"foo"` is not an int and therefore disallows it at compile time. You can do this with any other types - even ones you defined!. This behaviour *is* generics. It can only work if the compiler has the built-in mechanisms to work with generics for cases like the slice and the map, which it does. And you can tell it's 'hidden' because it's entirely impossible to express a new type (say a set type) that will operate in a similar fashion in go, you can only approximate it via runtime type checking (annoying, more error prone, less performant) or code generation/copy-pasting (doing the job of a compiler that supports generics manually as it were)
Really interesting! Having not used Flutter yet, this was kind of a wonderful, quirky introduction from an unusual angle. I think I may have a solution for your scaffolding issue. I'm not a Flutter expert obviously, so this may be crazy, but I really think not. The problem is needing to call constructors instead of just define structures directly. And we can solve that by writing a thin wrapper layer: https://gist.github.com/campadrenalin/d887da0843e114294f916360c2571042 It's still quite explicit with the call to Construct() at the end, but it allows you to create the structure in an entirely declarative way, that supports both positional and named arguments. Having the Construct at the end means you still end up with proper initialized objects. Essentially this solution is the one you picked, but with job of turning param structs into widgets, all moved to a central place instead of spread throughout your Build method.
How do you feel about Go?
Okay cool, yeah I would surprised if Google used http at all but based on the error message it looked like it could be a possibility
&gt; The Perl example is also very low level, directly writing to the socket whereas the Go example is using the net/http stack. It could be interesting to see this written with Go‚Äôs socket library. I think this is the most important part here. You are pitching the simplest possible HTTP server (actually, not even, as the server is not a behaving according to spec) against a full and complete HTTP server. That being said, I actually [whipped up a more direct translation](https://gist.github.com/Merovius/28a16cd1cb2d1b87986f72048238c362). When using Apache bench, I get pretty variable results, but it does look like the perl server is at least sometimes faster (though I'm honestly having trouble interpreting the output). When I use `hey`, as suggested by /u/Xeoncross, the Go server blows the perl implementation out the water. Like, it's not even a contest, there's a factor 40x between them or something. My personal hypothesis for why in some scenarios perl is faster, is that the only relevant thing we're doing is a regexp-match - and the perl regexp engine is famously optimized and the Go regexp engine is famously meh. If you would replace the regular expression with some hand-rolled parsing code, you'd probably get different results. But TBQH, I have already spent too much time on this :) The comparison from the article, in any case, is pretty bonkers.
Yet another dependency Injection I think I never found a reasonable situation for this
Cool. Thanks for posting that üòÅ
Hmmm one more question if you don't mind me asking. So essentially what I'm working on is translating this code here: https://github.com/plaid/plaid-go/blob/master/main.go into something more like this https://github.com/plaid/quickstart/blob/master/node/index.js Essentially, there are four variables that I need to use across my Go functions (client, access_token, item_id, and public_token). As you can see in the node example, these are simply set to global variables once the corresponding call is made, and then they are reused as fit. Would I accomplish this through the pattern you demonstrated of using closures? From what I understand, global variables are to be avoided in Go, so I'm just a tad unsure on how to accomplish this.
As others have pointed out, there are too many odd things about this to be a fair comparison. One thing that should be highlighted is that the Perl code appears to be **single threaded**. &amp;#x200B; First, comparing "single-threaded" performance against multi-threaded performance is nonsense. You should benchmark with GOMAXPROCS=1, so that Go isn't jumpping around CPUs. &amp;#x200B; Second, the way the Perl server is written, it looks like it is subject to a Slowloris attack. A bad client that connects and doesn't send headers will stop your server dead in it's tracks for 2 seconds. If the attacker makes 30 connections at once, your server is completely disabled for the next 60 seconds. &amp;#x200B; Third, ab is a terrible benchmark tool. There are far better ones. You should also have a more real-world benchmark involving multiple client computers, since the client CPU can easily become a bottleneck.
Excellent write up. This was something I always wondered myself, so it's nice to see a well researched answer to the question. Did not know about vecty either, so that's another interesting project I learnt about.
&gt;the problem is really difficult to solve in a way that feels like Go. Yes, it must be very hard to make a clever feature (generics) in a way that feels retarded (Go)
## lol pcj caught in the local minima of the jerk attractor, cannot escape unjerk trap.
no
Okay, so I have some domain expertise here, as I was involved in some of the very early work on the Perl/apache integration. As people here suspect, this is a flawed test, but one that points out an important advantage that some webserver interfaces have. Perl is hooking the apache requests at the lowest possible level and is performing only minimal startup overhead on each new call. Essentially this is comparing ***ways to interface with the webserver*** not languages. That being said, there's a lesson to be learned, here, about low level interfaces to webserver stacks... Also, Perl 5 is really as thin a high level language as you can find. Its data model isn't really much more than a struct of low-level C types and its execution has been hand-optimized in a single implementation for 30 years. So yeah... it's about as fast as non-machine-code-compiled language gets. Until the quasi-HLLs like go and Rust came along, it really was one of the best performing of the lot.
I don't think the article goes over the scalability aspect at all despite that being the title. More a beginners guide that touches on some basics.
Wow ok nevermind then. Doesn't seem worth the effort to learn it in that case. Thanks !
Promethius and grafana are awesome
I like the idea of [telescope.ac](https://telescope.ac); is that something you've been developing?
Looking at the project it seems like you're using lot conventions that are typically used in Java etc. And of course they are in fact best practices in those languages. But many are not in Go (some are even considered anti-pattern by many). I will list down a few of them here: 1. Due to the fact that packages are the units of compilation in Go, it is common to have packages representing parts of the domain instead of having packages like models, daos, services etc. (For example, if you're building a blogging application, packages like user, post, comment, etc. would be more appropriate.). This is a really useful idea since it reduces unnecessary coupling to almost zero and brings high cohesion. (E.g. all the stuff that deals with a user will be in a package user.) P.S. I did try a similar pattern like yours before thinking it is a good approach (https://gitHub.com/spy16/droplets). But after 3 years I've come to conclude and even advocate for the domain driven pattern 2. It is common to have multi binary projects in Go. Due to this, a `cmd` directory with main packages for different binaries are very common. (E.g. https://github.com/kubernetes/kubernetes). Don't create a `mains` package. This is not importable and also can't be used with go get. 3. Other small thing I noticed that goes against convention is usage of underscores in variable names. I don't have any justification for one way or another here. But I prefer to keep things consistent with the usage across community. So personally would prefer following language convention of using camel case here also.
I think article is not showing really an advantage because to be totally objective as long as you have a worker service that fetches data from source does something and returns result it can be anything not only go and it will scale. Example would be rabbitmq and a service generating thumbnails from images of you will write it in python and all it does is fetching from queue , generating thumbnails and putting them back on queue or writing into s3 you could scale the amount of workers services up to some really big numbers. And if you would dockerize it and your entire app is inside of Kubernetes cluster you could scale the fuck out of it as long as you have resources :) I prefer influxdb to Prometheus.
100% agree. The coding style you describe is what I use at work, and what many go devs i know follow.
"I have yet to write code in Golang"
Why not have a flat json file with a map[string]string&gt; type. Then you just namespace your properties until you're happy? Examples of a namespace: User.name:tower-rounder App.site.usehttps: true This way, you get an idea of the nesting and you can also move fast in terms of adding new properties
might end up doing that but just find the code to become so ugly to look at and therfore maybe thought there was something out there already done that people uses ?
Viper!
From this, should I infer that I should even queue user registration requests to RabbitMQ and let workers process them?
&gt; if the error is non-nil, it will return from the enclosing function, and if the error is not nil, it‚Äôll return the rest of the return values. you lost me there
Polymer 0.5 -&gt; 1.x -&gt; 2.x were two super annoying migrations too. All the while the dev experience got worse, so just felt bad. They removed lots of nifty features for speed. :(
Hi, there's a lot of examples in the Github repository of the official client here: [https://github.com/elastic/go-elasticsearch/tree/master/\_examples](https://github.com/elastic/go-elasticsearch/tree/master/_examples), so that might get you started.
I like these kind of remapping thought experiments. (I just started mapping KnockoutJS to Go to see if it's feasible.) There's a missing version, with `With` parameters instead of builder functions: ``` return NewScaffold( WithAppBar(NewAppBar(WithText("Flutter Go app"))), WithChild(NewCenter(WithChild(NewColumn(WithMainAxisAlignment(MainAxisCenterAlignment), WithChildren([]Widget{ Text("You have pushed the button this many times:"), Text(fmt.Sprintf("%d", m.counter), WithStyle(ctx.Theme.textTheme.display1)), })))... ```
Depends, if it is sending email or anything that can be done in background yes but I wouldn‚Äôt forcefully decouple user registration into micro services if it is in all just a simple insert and job to send email.
Anything not time sensitive you can, but it's easy to fall into a hole of queueing everything. Ultimately you can build the logic into your program to retry and distribute tasks its just generally a little more complicated. I think queues really win when there are multiple producers or consumers of certain message types where you don't trust the other clients as much as your own. For example your business writes analytical data to a database, you don't want to give direct access and instead throw together a service that reads from a queue. You don't have to worry anymore about other parts of the business spamming updates to you and you can easily throttle your writes to not overload the database.
I understood it as a typo and the latter one should be, "if the error is nil".
That has nothing to do with go, but well Here it is: version: 3 services: nginx: image: 'nginx' mem_limit: 300m
&gt; Generics are only really useful for if the language uses inheritance, which Go simply doesn't have. Go uses composition instead By the way, Go's composition is quite a bit closer to inheritance than in other non-inheritance languages. It's definitely more than just typical composition. See [this blog](https://hackthology.com/object-oriented-inheritance-in-go.html) for details. Go's embedding is pretty complex and has its own warts (especially when multiple types are embedded and/or embeded by interface).
Are you still using it? I liked the idea of Polymer, but never really used it in any real project.
oh I thought it might be go specific just like in Java/Elasticsearch we have a special env var for setting memory limits
Well, elasticsearch does this because java runs a virtual machine (JVM), and the JVM has a fixed (but configurable) maximum memory allocation (just like actual VMs)
Because there is no such aspect as go is as scalable as any other language.
Barely. I use it at work. Need to upgrade to v2 (or LitElement, or whatever they call it now). It's just a support system, and I've been dragging my feet. At home I switched to VueJS when they removed all the fun parts (like full JS expressions in templates and bidi value sync by default). VueJS with Webpack gives me the option to write modular code, and without the ever changing details of Polymer.
could use ulimit
Yeah I'm getting a bit tired by those. I expect to learn something new or a little more advanced than an hello world, a beginner tag or something would be useful
[removed]
[removed]
Great read. It has been annoying me for a while now that I keep injecting a logger into all my services. I will definitely have a look at refactoring some of my code based on thee suggestions
I sure hope it will become the norm. If you need polyglot builds (which can happen very fast, for instance when using protobuf), it's the best build system I know of. It just works. For instance, a gRPC server done with Go that deploy on kubernetes, Bazel can make that a breeze, and fast: - https://github.com/bazelbuild/rules_go/blob/master/proto/core.rst#go_proto_library - https://github.com/bazelbuild/rules_go - https://github.com/bazelbuild/rules_docker#go_image - https://github.com/bazelbuild/rules_k8s It can be built and deployed in a single `bazel run` command. Be aware though, it's very humbling. It takes a while to tame but once you get it, it delivers 100x imho. To the point that I don't see myself using anything other. My advice is don't learn it by porting an existing project, you'll suffer. Try it on a new one, then you'll feel much more comfortable.
I agree with most of your above advice if I am not writing a micro-service. Most micro-services are small and all they do is CRUD on a database with some caching abilities. If I am developing a project which looks more like an engine then using packages makes much more sense. The entire purpose of micro-services is to avoid binary coupling. We hardly share code between micro-services. If there is any common code then I would prefer writing a library and expose it to other projects. &amp;#x200B; Having packages makes project design complicated for soft/loose entities. A new developer always wonder should I add a functionality in package1 or package2? Any wrong decision by a developer will make the complete project design very difficult to maintain. Sometimes developers need to write an endpoint which retrieves multiple entities, do the transformation on them and send the response back, such cases always break the package boundaries. &amp;#x200B; This project is not aiming to be a sample project for all kind of requirements. This project aims to be used only for micro-services which primarily performs CRUD on databases. &amp;#x200B; I think one must prefer simplicity over language rules/conventions if it reduces the overall complexity of the project.
Cool, I use a similar design but call it repository instead of service and service instead of provider.
remove the `default` case for a start. the way you've written it it's always executed when no other case matches, and that leads to the loop being executed until a chan becomes available. select is there so you _don't_ have to do that. it blocks until a case matches (i.e. a chan becomes readable).
the `break` in the `default` case breaks the select, not the `for` loop. Use a label like so to break outer control structures: Outer: for { select { default: break Outer } } however, this probably won't be the full solution, as you might have a timing issue (both chans can't be read but the producer isn't done yet). Instead, you can use the `data, ok := &lt;- ch` version of the chan read, keep that state per chan and if both are closed, exit the loop.
As long as it is just json. https://blog.gopheracademy.com/advent-2016/advanced-encoding-decoding/ It might get a little complicated. If it is dynamic xml then you have to use a map of custom types. Which is a rough collection but I haven't seen a better resource. However! Don't use interfaces as OOP. Like a God type of interfaces. It'll get ugly when you have to keep lugging it around. Interfaces are only used for when you have to decouple a service, not as a giant inheriting object.
At present you cannot; [https://github.com/golang/go/issues/16843](https://github.com/golang/go/issues/16843) tracks adding something like that to the runtime, but a concrete solution hasn't landed yet. You'd still have to make sure that your live allocations stay under that limit, but it would help with freed but not yet reclaimed memory.
Yea I remember migrating a massive project from Angular 1 -&gt; 1.5 -&gt; 1.6 (going to 2) and that was just the worst thing. VueJS is awesome - I like it a lot, like what Angular should have been.
TBF, he/she was kinda asking if the Go runtime has something like that.
Does that mean it's okay to defer close files when the file was opened but no write was performed?
&gt; I am sure you will enjoy using this project. After reading such bold claim, I'm sure to not look at the project.
olebedev/config, not so many dependences as Viper has
Revel + postgresql DB (go-pg)
Does Revel support authentication/authorization out of the box?
IMHO it means: if err != nil { return defaultValues1, ..., defaultValueN, err }
I'm not a fan of this approach because I like adding logging, tracing, or instrumentation to some of my private methods sometimes. Decorating a service only let's me use the exported ones.
Are you talking about user authentiction ? Thats whats the postgresql db is for :) But if you are talking about ssl then yes revel supports that.
I ran into a similar issue a few weeks ago using bignum to categorize rooted binary trees. It wound up being simple enough to take the difference of two bignums and checking the sign to order them. Thanks for the post.
What exactly are you looking for? Authentication can mean a lot. Do you mean like user and password storage?
Keycloak is a good self managed user authentication service.
You've misunderstood the concept of coupling behavior in a monolith to a multi-binary project in golang. this pattern with multi binary is in fact very useful for microservices world due to the fact that, microservices are broken down parts of a same but a large problem. So usually they share a common language or a common domain ( ex. You might have a microservice that manages user logins and registrations and a service that provides profile management APIs. Many (if not most) of the things in these two services are usually common (the entity that describes the user or the store that persists user info etc.). A multi binary project would be a perfect fit for this in my opinion.. I understand what you're trying to say here. I've seen this happen too. But I've also seen that even with the pattern you have suggested, usually packages like models or services usually become dumping ground for random things (because these "developers" couldn't give a moment to think about where to put them).. this usually ends up costing higher than what you're estimating in the long run. (I've seen projects rewritten in a year just because of this reason).. in my opinion, code quality remains good only if the developers working on it understand the domain well (as they should). Domain driven packages approach helps with this.. also, with your approach, when someone looks at the project it is not possible to establish a mental model of what the project is trying to do. Also, a models package might depend on let's say a SQL driver. And services is going to depend on models. Problem here is that go has to compile models also Everytime you need to test or build services package which for larger projects increases build time. (It is usual in Go go have editor setup to run build, test, format and ling on every save). Absolutely agreed with simplicity. I'm the last person to add unnecessary complexity to things. And that's the point of the conventions I'm suggesting.. when you're building a small project, your domain remains very small and hence less packages (it is even common to have single main package at the root of the repo). But with the approach you're suggesting, every project no matter how small or large, models, daos, cmds, services etc. must be used.
You've misunderstood the concept of coupling behavior in a monolith to a multi-binary project in golang. this pattern with multi binary is in fact very useful for microservices world due to the fact that, microservices are broken down parts of a same but a large problem. So usually they share a common language or a common domain ( ex. You might have a microservice that manages user logins and registrations and a service that provides profile management APIs. Many (if not most) of the things in these two services are usually common (the entity that describes the user or the store that persists user info etc.). A multi binary project would be a perfect fit for this in my opinion.. I understand what you're trying to say here. I've seen this happen too. But I've also seen that even with the pattern you have suggested, usually packages like models or services usually become dumping ground for random things (because these "developers" couldn't give a moment to think about where to put them).. this usually ends up costing higher than what you're estimating in the long run. (I've seen projects rewritten in a year just because of this reason).. in my opinion, code quality remains good only if the developers working on it understand the domain well (as they should). Domain driven packages approach helps with this.. also, with your approach, when someone looks at the project it is not possible to establish a mental model of what the project is trying to do. Also, a models package might depend on let's say a SQL driver. And services is going to depend on models. Problem here is that go has to compile models also Everytime you need to test or build services package which for larger projects increases build time. (It is usual in Go go have editor setup to run build, test, format and ling on every save). Absolutely agreed with simplicity. I'm the last person to add unnecessary complexity to things. And that's the point of the conventions I'm suggesting.. when you're building a small project, your domain remains very small and hence less packages (it is even common to have single main package at the root of the repo). But with the approach you're suggesting, every project no matter how small or large, models, daos, cmds, services etc. must be used.
You've misunderstood the concept of coupling behavior in a monolith to a multi-binary project in golang. this pattern with multi binary is in fact very useful for microservices world due to the fact that, microservices are broken down parts of a same but a large problem. So usually they share a common language or a common domain ( ex. You might have a microservice that manages user logins and registrations and a service that provides profile management APIs. Many (if not most) of the things in these two services are usually common (the entity that describes the user or the store that persists user info etc.). A multi binary project would be a perfect fit for this in my opinion.. I understand what you're trying to say here. I've seen this happen too. But I've also seen that even with the pattern you have suggested, usually packages like models or services usually become dumping ground for random things (because these "developers" couldn't give a moment to think about where to put them).. this usually ends up costing higher than what you're estimating in the long run. (I've seen projects rewritten in a year just because of this reason).. in my opinion, code quality remains good only if the developers working on it understand the domain well (as they should). Domain driven packages approach helps with this.. also, with your approach, when someone looks at the project it is not possible to establish a mental model of what the project is trying to do. Also, a models package might depend on let's say a SQL driver. And services is going to depend on models. Problem here is that go has to compile models also Everytime you need to test or build services package which for larger projects increases build time. (It is usual in Go go have editor setup to run build, test, format and ling on every save). Absolutely agreed with simplicity. I'm the last person to add unnecessary complexity to things. And that's the point of the conventions I'm suggesting.. when you're building a small project, your domain remains very small and hence less packages (it is even common to have single main package at the root of the repo). But with the approach you're suggesting, every project no matter how small or large, models, daos, cmds, services etc. must be used.
&gt; I probably wouldn't create a `Character` interface at all. Oh sure, but you have the same issues as I mentioned above. I'm merely pointing out that, if you intend for a type to implement an interface, you want to have some compile-time guarantee that it implements that interface. For example, let's say you have a super simple `HealthHaver` interface: type HealthHaver interface { Health() int } What if we decide later that `Health` should be a `float64` or `int64`? You want to make sure that you've updated every place where you intended to satisfy that interface. I'm not showing what we're actually doing, I'm just trying to articulate the point that it's useful to have a compile-time check to make sure you're implementing an interface. The syntax `var _ Interface = new(Type)` is gross, and I'd prefer a bit of syntax sugar instead. When I'm using exported interface, I usually don't care as much since the interface is very unlikely to change. When I'm using internal interfaces, the likelihood that the interface will change is much greater, so it's much more valuable to make sure refactors are compile-time checked.
I‚Äôm also not a fan of try, it feels like a step towards exceptions, which is one of the worst programming constructs that I know of. Code should be concise and explicit. If I have to hunt down what is happening then it‚Äôs too difficult to follow. With exceptions I don‚Äôt know what is going on. With error I know exactly what is going on.
I don't understand what you're asking? The more compile-time checks to catch accidental mistakes, the better. When I'm building a new feature or fixing a bug, I'm usually mostly testing that feature or bug. If I make a change (say, to an internal interface), I want to know what parts of the code I need to test, and getting a ton of compile errors shows me a lot of those. Once what I'm working on is working properly, I'll usually give a simple smoke test to the parts that I think were affected, run the unit-tests to make sure I didn't break anything obvious, and then submit my code for review. The more compile-time checks there are, the less likely I'll introduce new bugs.
I'm shocked it's gained so much momentum, honestly. It seems half baked at best and as the article says: it's merely a small convenience for not writing as many `if err != nil` statements.
Hi shocked it's gained so much momentum, honestly. it seems half baked at best and as the article says: it's merely a small convenience for not writing as many `if err != nil` statements., I'm dad.
&gt; The first important thing about is it that it recognizes that the location that interfaces should be defined, is by the consumer of that interface. And for an internal interface, the consumer is essentially the same thing as the implementer. When I have a lot of internal pieces that I want to work nicely together, I define interfaces. When one of those behaviors changes a little, I want to make sure all pieces work properly. I don't do this for exported interfaces, only for internal ones, though they may be used by multiple packages within my project. &gt; Requiring an explicit "implements" like statement on a type that satisfies an interface rules out the ability for someone to create an abstraction over code that they have not written or across multiple libraries. Which is why I'm explicitly stating that I want it to be optional. Sometimes I want to guarantee/advertise that a type implements a specific interface, and the current syntax for that sucks. Many times I don't. &gt; You can write some code in such a way that a nil pointer has perfectly usable set of functions Sure, but is that really useful? Usually, I see methods that either operate by value or by pointer, but few that expect nils. I'd like to see a valid use-case for a calling a method on a nil value before I accept that an interface containing a nil pointer shouldn't be considered equivalent to nil.
I mean user and password storage, but also everything related to it. So I don't need to implement authentication/authorization. Just a call with an SDK to a read-made service which returns the access/permissions of that user.
shameless copy paste of my reply above: &amp;#x200B; I mean user and password storage, but also everything related to it. So I don't need to implement authentication/authorization. Just a call with an SDK to a read-made service which returns the access/permissions of that user.
bignum = `big.Int`?
Method chaining Either/Maybe is the way of light. IF statements are so 1959.
Have you looked at Dex? https://github.com/dexidp/dex It‚Äôs great as a single solution for authentication and user management, but variable back ends (ldap, database, OpenID, Oauth2, etc)
There's no way to avoid that. There are a few options depending on how synchronous you want this to be. If you don't mind synchronizity you can queue messages but if you produce so fast that receivers don't read the messages then at some point you'll have to drop messages. If your producer outproduces your receivers then you'll always run into some problems somewhere.
Just out of curiosity, what makes exceptions so bad in your opinion? I‚Äôm not disagreeing with you, but i have trouble articulating my own reasoning for this thought to other people so i just want to hear what you think about it. I‚Äôve mostly dealt with languages that lack exceptions, but I‚Äôve used a few that did like C++ and Python. Is concision and explicitness the only reason for disliking exceptions? That said, anything would be a current improvement over what I currently say. Whenever someone asks me what‚Äôs so bad about exceptions, i just say i don‚Äôt like them because they‚Äôre ‚Äúclunky.‚Äù
Not the above poster, so I'll only speak for myself. Nothing makes exceptions particularly bad. Sometimes obfuscating the control flow actually be convenient. Generally speaking, however, my experience is that actually dealing with all exceptions adequately takes no less efforts and no less coding than checking for all errors manually. Sometimes you may be able to save a line of code by bundling different types of exceptions into one exception handler, but generally you'll have to deal with the details of what went wrong in the handler anyway and so it boils down to doing the same as handling each error directly, only that the control flow will become less obvious. In the end, nothing is won with exceptions. Exceptions are mostly just convenient for people who don't handle them. Sometimes they shouldn't be handled, and for that case Go has `panic()`.
I just deployed a small app writing events to elasticsearch. I just used http to POST events in bulk to an index.
It smells a lot like IF ERROR GOTO 90
bad bot
yes came across that but also looks abit complicated :/
We have standardized on https://github.com/stevenroose/gonfig. Simple yet still supports a config loading hierarchy (file-&gt;env-&gt;flags)
I often come across this viewpoint and I don't quite understand it. I come from a java background and try/catch is one of the things I really miss. For me try/catch doesn't obfuscate anything. Often, I have various sub methos, which contains logic which can fail. Without try/catch I can do two things: 1. Handle the error immediately, often having issues with notifying the user or display a message 2. In Go, give back the error along the chain, making me write if error!=nil too often Errors and therefore exceptions for me, are not part of the control flow. A part of the control flow is, when a controlled action doesn't succed e.g. a user has the wrong password, a exception is, when mid request the server dies. For me a exception is a state which should not occur in a normal environment. I often hear people complaining about try/catch and I can't see these problems fixed any other way or see these issues. Would you be nice enough to explain you viewpoint a little bit more and if possible, how you handle errors in subroutines in go?
Super handy! Thank you.
Try/catch blocks aren't different in terms of visual program layout &lt;-&gt; control flow matching than errors as second return argument and if err!=nil afterwards. If you want to distinguish non-normal control flow from normal one, you'd need to use a language with separate exception blocks, e.g. Xojo and VisualBasic do it that way. Try/catch increases nesting of the normal code by one level, however, so it's even worse than if err!=nil in that respect. Here's how I do it in Go: 1. If it's an exception that cannot be handled, I use panic(). 2. If it's an error I can handle, I use if err!=nil and handle it. 3. If it's an error I want to pass down, I use if err!=nil and pass it down, usually enriched with more information. The only time try/catch could really save me from writing some boilerplate is in Case 3, but only if I do not enrich the error with additional information. In Go, making errors more specific is encouraged, because it makes logs more specific and debugging easier. I guess that's the Go perspective - not that I really care how to do error handling. The only time I would care is in a language with more expressive exceptions, e.g. in CommonLisp you can do pretty much anything with exceptions, including restarting, interactive prompting, using them for general signaling, finally handlers, etc. But that's because CL is a very dynamic language anyway, such a system comes with a cost and wouldn't make sense for Go.
if you really think about it you have two types of errors 1. errors that you can handle and continue execution 2. errors that you can do nothing about the first kind of errors is not really errors they are part of the program logic for example you tried to open a file but you didn't find it so you'll create a new file, so no error here just normal program logic the second kind you really have nothing to do about it for example you tried to allocate memory but you find out there's no memory, what are you going to to? you are not the OS after all, so it's better to do nothing or close the program you see the above 2 categories is basic enough that any error you find out in the wild will be in one of the two categories, and if you give it a little thought you'll find that exceptions doesn't help you with any of the two categories, for example the first kind is better handled with if conditions since in most languages with exceptions you're advised not to use exceptions to control flow your program, and they obviously won't help you in the second category either so in the end exceptions only add complexity to the language, think of the overhead of thinking about each line in your function ... execution may not reach this line because an exception might be thrown what about memory management then, since it's not guaranteed for the function to reach its return statement you'll need Garbage collection, but remember GCs only handle one type of resources which is memory then you'll end up with some convoluted thing like C++ where you have to define Constructor, Destructor, Copy Constructor, Move Constructor, Copy Assignment Operator, Move Assignment Operator just for simple type to play nice with the langauge ...etc. i prefer a simple code, it's better for me as a human, better for my compiler since it can understand and analyze what i'm trying to do, better for my machine since it's straight forward code to execute, better for my user, the program will be better overall since i don't just throw exceptions everywhere i handle my errors properly
It's super simple! You should definitely give it a try
Pareto principle called: You're saving 0.01% of development time.
Thanks, glad to make the world a better place /s
The thing that has me convinced is that people simply don't handle errors correctly now, and I'm perfectly able to keep doing things the way I am now, it's not like if statements are being removed from the language. There have been a number of times recently where I have realized that I would probably use try and it would make the code more readable, but for me it won't be the majority.
Can you provide a real-world example how method chaining makes error handling simpler than the standard `if err := FunCall(); err!= nil{}` idiom?
Something that I don't like on both the try proposal and the check idea is that they use a function syntax which might seem confusing. I prefer a keyword, like with range
 if f() if g() if h() ... vs. optional .andThen(f) .andThen(g) .andThen(h) ... There is value in keeping the flow relatively linear, rather than nesting ever deeper in callback hell.
I still prefer what I posted here: https://www.reddit.com/r/golang/comments/bwvyhe/proposal_a_builtin_go_error_check_function_try/eq22bqa?utm_medium=android_app&amp;utm_source=share For my two cents, I don't think it's needed though.
./ indicates your current directory. Are you in the directory that has the goexec binary? If goexec is already in your PATH you can just call goexec without the ./
I don't see where you are handling errors in either case...? And that first example is easily shortened to `if f() &amp;&amp; g() &amp;&amp; h()` so I'm not sure how the second example is better
In IntelliJ just add ‚Äú.nn‚Äù to anything that returns and error or ‚Äú.reterr‚Äù and it‚Äôll automatically wrap it in an if err not nil block.
I have tried it both ways. goexec should be available when I "go get" it? There are zero instructions on the goexec github, and nothing in the go github on webassembly. &amp;#x200B; I tried also running goexec from the diretory it is in, which wouldn't make sense, it should be run from the project directory, ie $HOME/go/myProj/ where the myProj/wasm file is found.
i'd guess because it is super trivial to implement and it isn't used enough to warrant a library function? that is, if you need it, just type: ``` func min(a, b int) int { if a &lt; b { return a } return b } ```
Very neat
You never have written a lot of go code? Kind regards
Yes, I‚Äôve found go get to be the best way to manage deps, then using go mod ensure others on your team get the same deps.
Yeah.
Exceptions represent a path of flow through the code that is unrepresented by syntax, so totally invisible in terms of the potential permutations and complexity of what could happen. Beyond that, I've so often seen them handled incorrectly - an exception handler that itself throws an exception therefore totally hides the prior exception. State changes that aren't safe, resources that aren't released... In a language that uses them, you can ***never*** safely assume that any code you aren't in direct and total control of won't throw an exception, but rarely does anyone write their code like that.
I do the same and use snippets heavily to avoid all the boiler, here‚Äôs my vscode snippets, some people might find them helpful: https://github.com/tj/vscode-snippets/blob/master/go.json
The Go extension for VSCode comes with the snippet `iferr` included, as well as many other useful ones.
We are using this https://github.com/golang/dep
I‚Äôve found that I‚Äôm writing a lot left superfluous (or superfluous feeling) err checks by writing functions local to my packages for marshaling/unmarshaling and doing basic type conversion etc... mainly it‚Äôs just to provide some default error handling behavior (and return a single value). But the consequence has been that most of the time then, when I‚Äôm writing an error-check block locally somewhere, it‚Äôs a conscious decision to actually do something with it, not exactly a snippet, but kinda-sorta. DRY anyways.
&gt; it's much more valuable to make sure refactors are compile-time checked. I agree with that, but we're kind of back to my original confusion now. (Confusion, not disagreement.) How is that not already the case? I use internal interfaces too, and I change them, and last time I changed one in a large project, I was immediately presented with a list of compile errors where code attempted to use various types as that particular interface, but was no longer allowed to do so. You wrote about using this in a sort of ECS, but for you to not already have compile time checks "for free" it means that this simple HealthHaver-implementing-type entity is not only never directly cast to HealthHaver but also never it's never passed into any function that takes HealthHavers and never added to a slice or map of HealthHavers. You seem to want to enforce that it _could potentially_ be used as a HealthHaver, despite the fact that it isn't actually ever used as one right now. Are these entities defined in plugin-style separate libraries that are built and distributed separately from the ECS itself? Are things getting passed around as interface{} at some point? I'm not even trying to argue with you about your complaint being valid; I just really don't understand how you've gotten into this situation in the first place.
I created benchmarks for the adding of two byte slices, I observed that using a label instead of a loop gives you up to 60% improved performance, but only for byte slices that are 1(!) element long. The performance decreases until you reach 128elements, where loop and label are equal in execution time. At that point, the loop is consistently better in execution time than the label. I tried to write a wrapper, which executed loop or label addition based on the slices length, but it seems that the functions are not inlined at all with that approach. So I would say, using label over loop is not a generic performance optimization.
This has never bothered me.
TIL. I‚Äôve had a live snippet of ‚Äúasdf‚Äù that does this
Speaking honestly, that was the idea. But I have several a bit more advanced posts coming soon.
Thanks! Yep, but it‚Äôs not yet ready to be presented to the public.
Thanks for your comment. Will try to be more specific next time and will definitely talk about more advanced topics as well.
Whatever you think of `try`, this has to be worse
Go modules is the new (official) way to manage package dependencies https://github.com/golang/go/wiki/Modules
you actually have a few options; [https://github.com/golang/go/wiki/packagemanagementtools](https://github.com/golang/go/wiki/packagemanagementtools)
This is the first simple solution that comes to mind goes like this: Create a hash function that takes both the key and a set of nodes like this: func myHash(firstKey Node,secondKey []Node) uint64 { // use firstKey and secondKey such that you have a low collision rate } and use this hash as the key in a map like this: var myMap = map[uint64]int this will work as long as you don't have collisions.
&gt;panic() please tell me you only do that in package main.
Wow that is very innovative. I'll try and implement this. Thanks for your help
&gt; When working with Python I started trying to use things like Pipenv but I just found that they are more complex than it's worth at the end, so I stuck with requirements.txt. pip+virtualenv has some similarities to the various official and unofficial package/dependency management options. They all describe some list of requirements, can fetch was is missing, and can isolate the requirements to your project (venv vs vendoring). But even the pip requirements file can have less fidelity than the Go options. Because you "requirements" file can express ranges and minimums, most options in Go create a sum file that locks down what was really used and can be committed to the repo. I don't recall something in pip that gets committed like this so you would have to use explicit patch version tags to maintain fidelity. That being said, I had started with godep, and then progressed to glide, and then Go modules. Glide has things that were missing for me in Go modules, but ultimately what I liked was a builtin solution thag automatically knows to fetch things. As a user of the vendor directory approach, I am still waiting for the Go 1.14 feature where it will automatically use the vendor folder instead of me needing to provide a build flag.
If you worry about collisions with your hashfunction, you could also change the myMap type to map\[\[16\]byte\]int. You would use a bytes representation of the firstKey and secondKey (probably concatenate those) and use a hashfunction like md5. Pros: * This has probably fewer collisions than a manually written hash function Cons: * This probably performs worse, both because md5 is probably slower than a manual hash function and because the key is now 16 bytes instead of 8 (uint64). Untested code (assuming you Node has an int field ID, modify to your liking): import ( "fmt" "bytes" "crypto/md5" ) func myHash(firstKey Node, secondKey []Node) [16]byte { var buff bytes.Buffer buff.WriteString(fmt.Sprintf("firstKey=%d,secondKey=", firstKey.ID)) for _, item := range secondKey { buff.WriteString(fmt.Sprintf("%d,", secondKey.ID)) } return md5.Sum(buff.Bytes()) }
export PATH=$PATH:$HOME/go/bin:/usr/local/go/bin
TIL, now I need to use this
Implement a sum of all elements of an array for int8, int16, int32, int64, uint8, uint16, uint32, uint64, float32, float64. Go is unusable for basic numerical computing.
&gt; You never have written a lot of go code? Never: https://gitlab.com/users/cznic/projects
Because the "wall of texts" actually explains what generics are and what's being requested. Knowing that maps, channels and append are generics doesn't really answer what feature is being requested here. On top of that, it's incredibly ungrateful to dismiss what people have spent time composing just for you as "walls of text".
I use GoLand and you start typing: "err" it will auto-fill this in, too. Good to know VSCode has this as well.
The single `.` is entirely useless here. It is only used to establish a relative path to expand to your program in the current working directory instead of checking your `$PATH`. `../../go/bin/./goexec` is the same as `../../go/bin/goexec` When you `go get` a program, it builds and installs it to your `$GOBIN` location. If that isn't defined then it defaults to your `$GOPATH/bin` location, which for you is `$HOME/go/bin`. Since you don't have any of this added to your PATH, your command can't be found. Simple solution: Update your `$HOME/.bashrc` to include the bin location on your PATH
it's unhelpful. nobody explains it correctly in their wall. they just start showing me foreign code snippets in c++ or c# which I don't know either of those well enough to understand what they're even showing me. telling me in terms of go makes it clear.
Excellent thanks. I‚Äôll try this tomorrow morning. Next question is why didn‚Äôt Go sort all this out when I installed? Other languages I have installed have not had this problem. Ho hum.
The tooling went as far as choosing a default install path when you didn't define one. The rest, I believe, is subjective to your system. The install docs do suggest an edit that you may have overlooked: https://golang.org/doc/install#install But really, adding to your PATH variable automatically means making assumptions about your shell type and preferences. And what if you decide to configure your GOBIN? The automatic edit wouldn't reflect that. Comparing it to other language installs depends on what settings they expose to configure install paths in the first place.
So after reading saturn_vk's comment, you know what feature is being requested? Besides, not a single one of the answers you have gotten have had code snippets in C++ or C# as you state. You realize I can see all the answers you've been given, right? Either way, you complained that they were "walls of text", that is to say, lengthy. You complained that somebody put _too much effort_ into writing you an answer. You didn't complain about the complexity of those answers, even though I don't find the answers given to be complicated at all.
While you are right, you are saving worthless time that you don't have to waste now.
Yes.
&gt;You didn't complain about the complexity of those answers, even though I don't find the answers given to be complicated at all. I am complaining about the complexity. it's too much to read and none of it makes sense. they're all filled with prior associations and none bring it back to the language we're using. I know what a slice / append is. I have no clue what the terms they're using are supposed to mean.
I'd assume each function returns some object that you can call andThen, other things, and something like .end() to finish it and get the last error or nil
An array of bools is largely equivalent to a bit field, so it can be represented by an int, and manipulated via bitwise operations.
I personally don‚Äôt mind the way go deals with returning errors, I‚Äôd just like more context surrounding the errors. Other languages typically have codes and types out of the box whereas go just pretty much returns a string. I realize there are ways to work around this but it‚Äôs really hard to get a team to all march in the same direction on this.
Sure, all we really can do is assume. I asked the OP for a real world example of how chaining is a better way of error handling, and they gave us two incomplete and contrived examples, neither of which show error handling. From your description it sounds like I would like chaining less and find it less convenient. It would be like taking the five (or whatever) functions you want to call and wrapping then in a sixth function that returns the error from the first function that returns an error, or nil if none do. It seems to add a layer of complexity and obscure behavior. But maybe this works for some people
Yeah it's not great. Makes me think of Javascript promises *shudder*
Ya for real, been developing a game in Go using VSCode... Wish I knew about this a month ago when I started
It broke in my Go Modules-based projects, though. TextExpander to the rescue!
We now have GO MODULES üéâü•≥
If you number every node in the graph, then the first key can be in integer, and each set of nodes can be a sorted list of integers encoded in a string. For the encoding, you could do worse than a space-separated list of decimal integers (e.g. "1 2 3") as this has the benefit of being easy to compute and easy read during debugging. A more compact representation would be to varint encode each number (see encoding/binary), with the first number indicating how many set members follow. &amp;#x200B; In this simple approach the keys are self-contained, but they are of course as large as the sets they represent. There may be more efficient data structures for compactly representing many similar sets, such as a binary decision diagram (BDD), but it very much depends on the specific problem you are trying to solve. &amp;#x200B; &amp;#x200B; &amp;#x200B; &amp;#x200B; Anoth
Works fine for me. How can *snippets* break? They're part of the extension, not your project.
yes, but given it's so frequently used, it is included in lots of languages.
I've been using tagging like this for years, but I never used the fully-qualified name of the variable like that. Have you found it to be required? Usually I would have something like `-X Version=1.2.3`
Goland also has built-in "postfix" templates: ``` err.nil[enter] /* if err == nil { &lt;cursor&gt; } */ err.nn[enter] /* if err != nil { &lt;cursor&gt; } */ err.rr[enter] /* if err != nil { return }&lt;cursor&gt; */ ```
Here's the [link to the project](https://github.com/pilosa/pilosa) the article was talking about.
Which package has that `Version` variable? `main`?
What about sublime text?
Sorry, I meant `main.Version`, ie: https://github.com/justinfx/gofileseq/blob/master/.goreleaser.yml#L4
Yep, that's a full package path, \`main\` being somewhat special.
More tips If you want a space in the arguments BUILD_DATE = $(shell date "+%d %b %Y") ... -ldflags '-s -w -X "main.buildDate=${BUILD_DATE}"'
We use something very similar by leveraging `git describe`. Besides outputting the last reachable annotated tag, with -long you can output how many commits you're ahead of that particular tag as well as its SHA1. Also, you may specify the -dirty flag; useful to make sure you're in a clean environment before building your image.
They don‚Äôt show up when I type ‚Äúif‚Äù anymore. Maybe something else got wedged somehow.
yes thanks, you are right, i ended up doing a small reader here : https://play.golang.org/p/1AxF5JeAxWT but would still like something that is abit more smooth to use for bigger configuration files.
thanks that looks interesting !
goland's live template is good
We use [goreleaser](https://goreleaser.com/) for that.
https://github.com/golang/dep/issues/2165 &gt; Your company's name in the default "dep init" text Very surprise to see this on an official golang repository !
yep, doing exactly that also: GIT_VERSION=$(shell git describe --tags --dirty) GIT_COMMIT=$(shell git describe --always) BUILD_DATE?=$(shell date +%Y-%m-%dT%H:%M:%S%z) Also always helpful to add the real commit if anyone is ever doing some force pushing ...
Glad to help! You can use a closure to get access to multiple variables. In the example below, all the variables you wanted are nested in a new struct definition called `PlaidCtx` \-- which essentially replaces the client in the last example. Word of caution: if this is more than just a learning project, you'll want to get your access token into a concurrency safe state at some point. Tokens generally need to be refreshed and if multiple instances attempt the token at the same time then you can get into some unpleasant situations. [https://goplay.space/#plGfH6hjQAb](https://goplay.space/#plGfH6hjQAb)
Ok, thank you. I have edited the wiki with information about the path environment variable having to be set in either of the profile files, as explained in the docs for Go that you linked to. I feel this ought to have been mentioned on the WebAssembly getting started guide, as I'm sure many other people from a web background will head straight for the WebAssembly pages. So if my edit sticks, it will be there from now on. Having added `export PATH=$PATH:/usr/local/go/bin` to `/etc/profile` (not .bashrc, that did not work) and logged out and in again, goexec now works as expected. &amp;#x200B; SOLVED!
I don't like three things about exceptions: &amp;#x200B; 1. Looking at a code block, you never know which function call might raise an exception and trigger a return unlike a function returning an error. 2. Exception are like super returns, you raise it 10 level deep and it immediately magically returns to the root level unless a level in between has a handler. I like error returning functions which forces one to have some indirection. Java's \`throws\` somewhat makes this better but still it doesn't make it as explicit. 3. Exceptions allow summing up multiple function calls into one block and catch all errors which doesn't \_feel\_ right. \`try+defer\` proposal somewhat tries to do a similar thing but at least it visually annotates all points that might "raise an exception" 4. People almost always end up abusing exceptions as control flow mechanism. I did this in the pas in a python REST API library where any function no matter how deep could raise a \`BadRequest()\` exception and it would make the API layer return \`HTTP 400\`. These things look good at first but always end up being problematic in large scale software development. 5. Errors over exceptions tend to encourage explicit error handling specific to each case but technically there is no reason a good developer won't do the same with exception. Errors force everyone to do it. Some of these points are somewhat softened by Java's \`throws\` like annotations but in the end still not as well as functions simply returning errors. &amp;#x200B; If you've used ReactJS, exceptions are like contexts where as errors are like props except that errors are no where near as painful to propagate up as props are to propagate all the way down.
fixed: ... if the error is non-nil, it will return from the enclosing function, and if the error is nil, it‚Äôll return the rest of the return values. ...
Don't think there is as much momentum as you think. I think actually most of the people are opposed to this and the reason it is getting so many comments is that it was posted by a member of the Go team so people who didn't like it feel the need to voice their concerns as they fear it'll be added to the language if they don't resist. &amp;#x200B; Personally, I actually quite like this counter proposal: [https://github.com/golang/go/issues/32437#issuecomment-500093549](https://github.com/golang/go/issues/32437#issuecomment-500093549) &amp;#x200B; It keeps \`try\`, adds a simple mechanism to add handler per error and removes the need for named returns and defer.
Proposed: [https://github.com/golang/go/issues/32437#issuecomment-499994511](https://github.com/golang/go/issues/32437#issuecomment-499994511)
But often context needs to be added per error, not per function. I think this will encourage people to decorate all function calls in a function with a single decoration where as before they might have added different contextual information to different errors. In a way it makes error handling look like: &amp;#x200B; `try {` `statement1` `statement2` `statement3` `statement4` `statement5` `} except {` `handleError()` `}` &amp;#x200B; &amp;#x200B; It does however add visual annotations to the statement that might raise an error inside the above block so if only statement1, 3 and 4 can raise errors, it makes the code look like: &amp;#x200B; &amp;#x200B; `defer func() {` `handleError()` `}` &amp;#x200B; `try statement1` `statement2` `try statement3` `statement4` `try statement5` &amp;#x200B; \- The try proposal is better than exceptions in the sense that it highlights every line that can possibly trigger a return. \- It is the same as all catching exceptions in the sense that it encourages a single handler for all errors. \- It is worse than exceptions because it detaches error handling code from the place where the error occurs
For vanilla vim guys: `autocmd Filetype go iab iferr if err != nil {^M ^M}&lt;Up&gt;` of course \^M is not \^M but &lt;C-v enter&gt;
It's not so much "extra panic protection" as much as it is "alternative panic protection", right? For instance, the default recover function does not write any response to the client. An alternative recover function might write an HTTP 500, increase a metrics gauge, make some structured logging ... etc
Good point, so it is more or less an augmentation of the default recovery. What I am trying to get to, is if the HTTP server is panic-safe out of the box. I think that the extra parts should be added when needed, but I find it a bad practice to start over-protecting every single place prematurely.
That makes no sense, a global panic recovery resulting in a 500 is the most common of patterns in webapps
I think care needs to be taken when thinking about what "panic-safe" is. Yes, it won't crash the goroutine that is accepting new connections and HTTP requests, but it may leave your server in a broken state. The obvious example is (assuming defer unlock is not suitable for some reason, e.g. a loop): mu.Lock() v := callSomeFuncThatMightPanic() mu.Unlock() fmt.Fprint(w, v) You can get in a lot of trouble by leaning too much on being "panic safe".
Hello golang boys and girls! we have some golang projects and with each new project, we struggle where we can store these project binaries and having them organized by versions. Using these binaries with our deployment system (Chef) &amp;#x200B; So I created a simple daemon to get the repo data and then it clones and build the binaries. it was really cool and saved a lot of hassle until we started to integrate that daemon with github and chatting systems. You know some notifications saying a new project release got created. Automation is not bad, right! &amp;#x200B; During the last hackathon time, I started to build that thing again so it can hold all new integrations and shared it on github [https://github.com/Clivern/Rabbit](https://github.com/Clivern/Rabbit), It was a short period but i was able to finish a lot and finished the beta release, Please check it and your opinion is highly appreciated
That‚Äôs true as well.
Your tests must be the same package as they should reside in the same folder under the filename `..._test.go` and thus have the same package, because you are strongly adviced to have only one package per directory which is usually the directory name Moving tests elsewhere is bad practice.
I haven‚Äôt used Kubernetes before but I pretty much decided my next project will be hosted on a hosted Kubernetes solution like DO‚Äôs. Even for smaller projects it‚Äôs pretty affordable and it seems like the easy way to use Docker in production. Change my mind!
`iferr + \t` is a bit long for my tastes. Since snippets are scoped to a certain file there is nothing wrong with one-or-two letter prefixes. I mean, it's _your_ editor so you can use shortcuts. It's not like your naming actual code variables "e" or "ie" and people after you won't know what it stands for.
If statements can still be used in loops and whenever the error comes to you unannotated, or if you're like me and want to explain what you were doing when something failed. This proposal is not intended to replace all error handling. This paradigm will probably reverse the way that I used to do errors (include all context you know that your caller doesn't) to match more with the stdlib (include your function name and arguments in your errors), and if that is applied uniformly, there will be fewer places where you need to add additional context on a per error basis. My first point still stands though: well over 99% of errors are unannotated in the wild, and even at work where we have rigorous code reviews and a style guide, 75% are unannotated. This will remove the boilerplate for many of those and might make the authors more willing to add a little bit of mechanical context.
Digital Ocean doesn't have the equivalent of availability zones does it? Does DO lose a data center about once a year like AWS loses an AZ? Does it offer multi datacenter redundancy like hosting across multiple AWS AZs?
I'm an AWS guy, but if you're set on k8s, wouldn't GCP be a better platform?
Yes, probably! Haven‚Äôt settled on the particular platform yet. GCP is much more mature but I like Digital Ocean‚Äôs down to earth ness.
Thanks for sharing! We used a reverse approach: put a version into the main executable and call the executable from the build&amp;release script to obtain the version. (For example, release script: https://github.com/Parquery/mailgun-relayery/blob/master/release.py, main executable: https://github.com/Parquery/mailgun-relayery/blob/master/mailgun-relayery/main.go)
Searching just for just `err != nil {\n\t*return` strikes me as misleading. By omitting what is returned, you are ignoring all the potentially non-trivial contexts that has been added to the error. To really see the equivalent of throwing an exception, you should really only include the instances where the error is returned without added context. That is, `err != nil {\n\t*return err\n`
&gt; It has become a masochistic cult where veterans are trying to convince newcomers that this is actually better. Wrt "sucks): I hope your insight in coding is better than that in psychology.
[Reminds me of this..](https://twitter.com/dexhorthy/status/856639005462417409?s=21)
&gt; potentially non-trivial contexts Such as stack-trace, which are automatically added by exception-handling mechanisms of other languages? The idea is that the amount of things you can do in a single return statement (that immediately follows `err != nil` check) is quite limited. As you‚Äôve said, all you can possibly do is to attach some context to the error using `pkg/errors`, and even that is to circumvent Go‚Äôs lack of proper error handling mechanisms. The regex you propose ignores 2-values functions for instance, where idioms such as `return nil, err` etc. won‚Äôt be captured. Same goes with `return [nil, ] errors.Wrap(err, "‚Ä¶")`.
I realize if statements are still there. I'm concerned that \`try+defer\` will be so convenient that it'll make most developers ditch decorating specific errors and instead rely on a single wrapper per function. If adding per error handler was made as easy, I'd have no complains. Especially if it meant \`try\` could be used without handler and then very easily extended to add a handler without having to re-write into an \`if err != nil\` statement. &amp;#x200B; To that end, I really like this counter proposal: [https://github.com/golang/go/issues/32437#issuecomment-500093549](https://github.com/golang/go/issues/32437#issuecomment-500093549) I think it solves the main problem of having highly repetetive \`if err != nil\` cases but also doesn't make it hard to add handler per error \_when\_ needed. &amp;#x200B; &amp;#x200B; try someFunc() with handler try someFunc() else err { return fmt.Errorf("wrapper: %v", err) }
There is a trending thread called literally ‚Äú[Avoid typing hundreds of if error checks](https://reddit.com/r/golang/comments/by9tos/avoid_typing_hundreds_of_if_error_checks/)‚Äù that got 80 upvotes where people share how to avoid the problem I‚Äôve described using snippets. Now that Go 2 actually brought the problem into the light, people finally started to admit that it‚Äôs a bit of a problem.
The "aha" moment for me was that I'm trying to approach these from a standpoint of someone who thinks error handling in Go is mostly fine, and someone who sees the value in annotating errors. I am clearly not the target audience for these proposals. They aren't going to make the situation worse because the situation is already about as bad as it can be already. People who are diligent will continue to remain diligent. If you make a proposal that forces people to handle errors more verbosely, they simply won't use it. So, instead, we have a proposal that simplifies the 99% case and doesn't impact the rest, but which will come with helper functions in the stdlib that could simplify some of our errors for those of us who care, and might be simple enough to draw in some of those who considered it too onerous before. The try built-in also leaves the door open for future arguments, so we can propose handler closure params, error formatting parameters, or whatever else as we gain experience with it.
My attempt to create an opensource POC of a cloud gaming service inspired by Google Stadia. Cloud gaming is the future of gaming when all the game logic is handled on a cloud server and then streamed to the user, so no installation, no heavy device is needed. &amp;#x200B; Try the platform at. Recommend to use Google Chrome: US West (San Francisco): [http://usw.cloud.webgame2d.com](http://usw.cloud.webgame2d.com) | US East(New York): [http://use.cloud.webgame2d.com](http://use.cloud.webgame2d.com) Singapore: [http://sg.cloud.webgame2d.com](http://sg.cloud.webgame2d.com) | India (Banglore): [http://idn.cloud.webgame2d.com](http://idn.cloud.webgame2d.com) Europe (London): [http://eu.cloud.webgame2d.com](http://eu.cloud.webgame2d.com) | Europe (Frankfurt): [http://ger.cloud.webgame2d.com](http://ger.cloud.webgame2d.com) Game Instruction For the best gaming experience, please select the closest region to you. \- Video Demo: [https://www.youtube.com/watch?v=koqWB1VKflo](https://www.youtube.com/watch?v=koqWB1VKflo) (If you cannot play) &amp;#x200B; Game Instruction: &amp;#x200B; \- Arrow keys to move \- H -&gt; Show help \- C, V -&gt; Start, Select \- Z, X -&gt; A, B \- S, A -&gt; Save (Save state), Load (Load previous saved state) \- Share button/ W -&gt; your game state is stored in a link in clipboard, next time you can continue your game by loading that link. \- F -&gt; Full-screen \- Quit button/ Q -&gt; Quit the current game \*The game is designed as joystick targeting multi-platform, so you can play it on Desktop, Android (IOS is not supported yet). Our purpose is to also to bring the modern gaming experience to Retro game.
I‚Äôm not sure blowing up your stack is necessarily better. By handling the errors where they are, you‚Äôre actually encouraging stability over the run time dice roll that is a try catch.
Yes. No. No (unless you roll your own, does AWS automate that?).
Yes. When you create an auto scaling group in AWS you can specify 1 or more AZs that your load balancer can route to automatically. When you launch more than one instance it will round robin your instances across all the AZs for you. There are similar possibilities for database replicas. At work the app I build has 50 instances across 4 AZs. Our database has secondaries in two other AZs for redundancy beyond backups. AWS makes this trivial. Last year a contractor cut a line at one of AWS AZs and that datacenter lost connectivity. A year or two ago there was flooding in Australia which took out a datacenter.
Take the time and learn rke or some other solution. Then use Scaleway or hetzner
ye, it's like saying "i need to get rid of this spider" and setting the whole house on fire.
Since you never run only one instance (remember, this is a Google language), it's better to crash and reset to a known good state than to continue and potentially have silent failures, or serve inconsistent data. Go encourages you not to try to be clever about panics. &gt;What else should I be afraid of? That you require 100% uptime of this precious Go process.
If you want something that comes with sensible defaults and allows you to get started quick, I'd recommend VSCode.
You don't look at *why* exceptions were avoided, you barely look at errors in Go to understand how they can be used, you discount out of hand anyone who might have a reason for having a different opinion, and your choice of measure for "code written" really isn't great. And to quote: &gt; which is nothing but simply propagating the error up the callstck (*i.e.* return the error to the caller as soon as you encounter an error); something a compiler or a runtime would do if we were using a more modern language using the exceptions mechanism. This entirely glosses over the idea that the control flow is explicit and within the control of the author of the function. It's visible in code review, it can be seen within code coverage if you're exercising it in a test. Ignoring an error is clearly visible and can be called out by linters and IDEs. Exception handling is rarely done correctly. Even when it is, and even in the case where you don't need to supplement any information going through a function, it's still an invisible maintenance danger to any sort of state changes, resource handling and plenty of other issues. I'm happy to grant that Go makes it pretty visible just how many things can fail, and that it imposes a cost on those writing the code. I've not seen anything compelling that suggests that exceptions result in more reliable code, and plenty of personal experience that they don't.
I've long wanted something like this, but ultimately I want it to cleanly integrate with the native go build chain. As far as I can tell, this isn't currently possible, though.
I personally like the Jetbrains IDEs. And Goland especially is really good IMO. It supports modules, profiling and has really good debugging support.
I start with vscode with go extensions but language server is consuming too much ram so I end up with GoLand
Hands down: [https://www.jetbrains.com/go/](https://www.jetbrains.com/go/)
Gke is literally worth using gcp for. The rest of gcp is like childrens' toys compared to what was offers from a DevOps pov
I use JetBrains IntelliJ with the [official Go plugin][ideago] (that makes it equal to the stripped-down/lightweight IDE [Goland][]) and it works like a charm. If you ever used IntelliJ before for languages like Java you will notice no difference when it comes to features and usability. Everything works out-of-the-box like - ultra-fast auto-completion with IntelliJ's smart suggestions (frequency, code-flow aware etc.) - auto-imports and clean ups - a large amount of intentions/suggestions through code analysis that warns about possible problems like unhandled errors, `nil` values and a lot more. - full support for Go's official toolchain as well as al the community build ones, e.g. [golangci-lint][gci]. - full Go modules support including `go.mod`/`go.sum` auto-complete and syntax highlighting - fluid integration when used with other languages like YAML/JSON config files through schema validations, linting and so on. - too many to list them all‚Ä¶ If you like _to go_ with a more lightweight and free IDE I'd definitely recommend VS Code with the official [Go VS Code extension][ext] following their ["Go with VS Code" documentation][vguide]. It doesn't work as smooth as IntelliJ and won't provide that many features and great UX, but it should work even for some larger projects. [gci]: https://github.com/golangci/golangci-lint [ext]: https://marketplace.visualstudio.com/items?itemName=ms-vscode.Go [goland]: https://www.jetbrains.com/go [ideago]: https://plugins.jetbrains.com/plugin/9568-go [vguide]: https://code.visualstudio.com/docs/languages/go
`vim` + [`govim`](https://github.com/myitcv/govim) is what I use.
Seems like massive overkill (perhaps expected since this is copying Java). You could do the same with a goroutine and a time.Ticker.
Same here except that I use [vim-go](https://github.com/fatih/vim-go)
Thanks for the answers everyone.
Completely agree. It's not an issue for go app to have thousands of goroutines running. But what if you want to have centralized full control over all scheduled jobs, let's say to show status or pause/skip executions.
VSCode is my daily driver for go development. Goland is nice, but in my personal experience it sucks too much CPU and feels a bit sluggish at times (this is on Linux, YMMV on other platforms) to justify the minimal advantages it has over VSCode.
Goland of course. Used Emacs with go-mode + set of hand made niceties. Switched to GoLand is it turned to be generally better and the difference is growing (Some things are still better in Emacs though ‚Äì JetBrains are bad in themes, syntax highlighting defaults suck, their inspections albeit more powerful nowdays than community linters still lack some nice to have functionality). Tried VSCode once but it turned to be retarded even in comparison with Emacs.
Change your mind? How about this, it's cheaper to get a vps from DO than deploy an app to their smallest hosted kubernetes configuration..
Thanks. I'm been experiencing the same confusion, I'm an adequate Python programmer and have written a fair amount of scripts. Since we're switching our whole monitoring stack over to Go we decided to rewrite the checks as well. I managed to get it fully working in about 3 days just by reading the package docs and using examples.
&gt; I was immediately presented with a list of compile errors Which you'd get if you pass concrete types into functions expecting interfaces. If you have an interface type and want to pass it to another function that takes a different interface type, you do a check at runtime, so you'd only notice something amiss if you test every type that could implement a given interface. &gt; You seem to want to enforce that it could potentially be used as a HealthHaver, despite the fact that it isn't actually ever used as one right now. Precisely. I intend for a given type to implement an interface, but that interface is only ever checked at runtime, so I want a compile-time check to make sure that a give type _can_ be used as that type. &gt; Are these entities defined in plugin-style separate libraries that are built and distributed separately from the ECS itself? Yes, technically, though everything lives in the same codebase. Basically, project structure is like this (again, like an ECS): - main - core ECS loop - internal - defines common interfaces to prevent import cycles - mobs - weapons - buildings The separate packages are for convenience and organization, though all types will be used as whatever types are defined in the `internal` package. A building looks the same as a weapon to the ECS, except when something interacts with it, at which point it is type-asserted to some other interface. Perhaps buildings satisfy `type SubMap interface { Areas() []Area }` or something, but they also satisfy `HealthHaver` for a destructable world, unless it's an indestructable building of some sort. It's built this way so it _could_ be extended by a third party (say, a similar product that wants to borrow pieces), but in practice it's merely separated to reduce coupling. If I intend for a specific weapon or building to satisfy an interface, but it's only ever type-asserted to that at runtime, it's pretty easy to accidentally break compatibility with the interface.
&gt; Exception handling is rarely done correctly. Citation needed really. I‚Äôd say even in the ‚Äúincorrect‚Äù case, exceptions will be noticed (unless ignored explicitly by the programmer) whereas Go is plagued with defer statements that ignores errors returned from ‚Äúclose‚Äù functions etc. Arguing that exceptions obfuscate control flow is also absurd, given the existence of `goto` in the language.
It's quite possible that veteran programmers know that proper error handling does take a lot of code, and that code and what it does is important. Exceptions don't produce better code than if err!=nil { ... handle this error...}. IME exceptions are painful if you intend to handle errors. Wrapping every call to an exception throwing function in try/catch creates more visual noise around the call than if err!=nil does. So people get lazy ("efficient with their time") and wrap whole blocks of code in try/catch and lose the context and the ability to do anything intelligent except log and exit. &amp;#x200B; Exceptions separate the place where the error happens and the place where it is handled (or not handled). That makes reviewing error handling difficult. For example, I am reviewing a function f which might throw exception e. In order to check that e is properly handled I have to find and review every call stack which can call f, and walk the call stack finding if and where e might be handled. This is not fun, and people just don't do it. This means the error cases are not reviewed with any rigor. &amp;#x200B; IMO "professional quality" code which blows up with a stack trace at the slightest hiccup, or worse, tries to continue after any and all exceptions as if they didn't have any consequences, are both signs of code written by immature programmers. &amp;#x200B; I recall a professor describing a study which pointed out that in the enterprise software codebases they examined the majority of the code points dealt with exceptional cases and errors. That just seems to be the nature of well written code.
Legality of streaming NES games is questionable.
[removed]
I could maybe see value in something like this if it had a locking mechanism of some sort, ensuring a single execution when ran on multiple hosts, with some fault tolerance/retry logic. Guess what I‚Äôm saying is not much value to it now but plenty of directions to take it. Good start though!
[https://github.com/elazarl/goproxy](https://github.com/elazarl/goproxy) done!
You are making lots of assumptions in your first paragraph but nevertheless I‚Äôd just like to point that wrapping multiple lines of code with try-catch is not always necessarily evil since the exceptions are clearly distinguished by the type of the exception raised so the error might be well handled in the specific catch blocks. &gt; For example, I am reviewing a function f which might throw exception e. In order to check that e is properly handled I have to find and review every call stack which can call f, and walk the call stack finding if and where e might be handled. Perhaps? I mean, in C++ I am afraid that is indeed the case whereas in Java you know what exceptions a function can throw so you know which exception is handled where (in the callstack). Isn‚Äôt this a solution to the problem you‚Äôve described? &gt; IMO "professional quality" code which **blows up** with a stack trace at the **slightest hiccup**, or worse, tries to continue after **any and all** exceptions as if they didn't have **any consequences**, are both signs of code written by immature programmers. That‚Äôs a bit too dramatic of a tone isn‚Äôt it? :)
Before realizing the site was to hide traffic, I imagined a site that tried to literally hide your ass. üçëüçëüçë
Another vote for Goland. I'm running it on Linux, works perfectly. Doesn't use a crazy amount of RAM all things considered. Has a really solid feature-set. Worth paying for it IMO. VS Code is nice, but Goland as a Go development environment feels much more robust to me. I think either are perfectly fine options, and a large portion of it will come down to personal preference.
Nobody realises how bad DigitalOcean's solution is until they actually deploy an application to it. DO has several service outages throughout the year and its only plus point is it's affordability.
For such a deep topic, you've got a tremendous amount of basic things completely wrong. Your benchmarks are broken. for j := 0; j &lt; 10000; j++ { s = &amp;Small{ a: 1, } b.StopTimer(); inc(s); b.StartTimer() } This is wrong. You need to loop to `b.N` so the test system knows how many operations are being taken over the duration of the test. The way you're micromanaging the timer would only capture the time taken by `inc`, and nothing about the difference is time taken by the allocator or saved by the use of `sync.Pool`. It's also likely that the non-Pool benchmark doesn't even need to allocate any memory on each iteration because your `Small` doesn't escape the stack.
Remove the default case from the select
https://play.golang.org/p/4OsjTl2jGqQ add for loop in goroutine too
Thanks - embarrassing mistake.
It's not even questionable. It's a straightforward infringement.
You should also look into nomad from HashiCorp. Kubernetes in a lot of cases is the equivalent of killing a fly with a nuke. Just cost wise you could get away with a lower bill than k8s.
We cannot give a strong assertion when a similar thing like this didn't happen before. The project is not for commercial and most of the resource is dedicated to open source community. It doesn't totally replace real gaming experience. Actually, there is some correlation with this and "Twitch plays Pokemon". It raised some debates but in the end, things are still in a gray area. [https://en.wikipedia.org/wiki/Twitch\_Plays\_Pok%C3%A9mon](https://en.wikipedia.org/wiki/Twitch_Plays_Pok%C3%A9mon)
I like my editor to be written in Go https://github.com/zyedidia/micro
Yeah, this is kind of beyond the gray area, def against the rules
Well built, works great. Nice job
Am also new to Go but been very satisfied with VSCode i really like that editor and its a fast environment. But just downloaded Goland which i want to try out, i dont know yet but i thnik it might can help me with some of the fundemental newbie issues i keep dealing with here - if i was expert in Go i think i would be absolutely satisfied with vsCode.
This is especially good when you want to rename methods/functions/structs or package names. It's also great with debugging via delve as compared to the same feature in vscode. I am a fan of vscode myself but I think jetbrains has done a tremendous job with goland.
Is this just the medium article?
Thanks! I haven't thought about memory allocation since I was writing "C" in college!
username checks out
I loved it and I cried a lot! :‚Äô)
I'm not a lawyer, but regardless of what a jury might say I think this is definitely in danger of a Cease and Desist. I'd hate to see that happen to a cool project like this. Have you considered streaming open source ROMs from the community? That way there would be no doubt that you're in the clear.
Thanks so much. It is indeed giving me a headache right now. I think your suggestion is really good. I can make it work with some free ROM from the community to avoid this kind of situation. Let me try applying that.
Thank you :D
I'd prefer 2nd approach. Look at `json.RawMessage` type example in documentation. It can be made simpler with that I think (i.e., by removing custom marshal/unmarshal )
Means a lot mate. That example really makes things a lot more clear. The only problem I'm having now is the part about replacing the struct variables with the "real deal logic" lol. The issue is that these variables are derived from the request body of GetToken. Is there a way to access the Request.Body from the WithPlaidCtx closure? Also, as an aside, do you have any suggestions for learning more about thread / concurrency safety? This is obviously a learning project for now, but I do hope to build it to be production-ready in the coming months.
I'm planning to use another marshaller/unmarshaller (msgpack probably), so I can't really use json.RawMessage :/.
Nice job. Do you think about indi games instead of NES? This could help you with all this copiright bullshit.
The msgpack codec may have the equivalent of json.RawMessage.
Anyone notice the random commits from Linus Torvalds?
Wow ...
I will be using msgpack but from all impl I looked at, none has a RawMessage. That said, looking at Golang json.RawMessage, it seems I can easily re-implement it for msgpack
LOL. It‚Äôs not real Linux. We were trying to have some fun during the project and we ended up with that. I will fix those commits soon.
Free indie game will be a good alternative. I will definitely look at that way to get me out of this situation. One reason I integrate NES internally because I can hook the video and audio stream directly from NES. It reduces a latency a little bit more. If the game is run separately from pipeline, I need to capture screen or hook screen output, then the latency may not good anymore. However, it should be the target this project aim to and I will try to make that work.
how did you resolve this?
[Atom](https://atom.io/) is very good.
I didn't even know you could set structs' fields by relying on their order of definition. Always use the fields' names, it's both more readable and robust to change, like so: type SomeStruct struct { SomeField string } ... value := SomeStruct{SomeField: "some value"}
&gt; Such as stack-trace, which are automatically added by exception-handling mechanisms of other languages? No, I've personally found it more useful for adding things such as given parameters, current state, etc to the error. 'Cannot unmarshal JSON to type T' with a long stack trace going to the http handling is not nearly as useful thing to read from the logs as 'failed to load T with id 123: cannot unmarshal json'. I've personally found explicitly handling (and having to decide how to handle them!) most error cases to be very liberating compared to dealing with codebases that wrap everything in one huge try {} catch, or having to deal with dozens of different exceptions that one method might throw, or having to remember/guess what kind of exceptions I might get from the depths of the codebase, etc.
If this is any indication of the latency to expect on Stadia, then the only thing I'll be playing there are strategy games.
That's an odd statement. I'd be impressed if you can point me to a provider that didn't have outages throughout the year.
Thank you for feedback
My main experience with exceptions is in Python. Even taking something simple - `int(x)` which can basically act as `atoi(x)`, nothing in my IDE calls out that it might throw a `ValueError` when used with `int("foo")`. It's super convenient that it returns only a single value, which also means you can use it multiple times in a single line and have no idea which use of it caused your exception. Assuming that I don't control that, I do what pretty much any python program does - ignore that there could be a problem until it blows up, then go put some sort of guards in. Since checking that things are strings, or various other sorts of tests are generally frowned upon, I'm probably catching the ValueError and then trying to work out what to do, but passing a ValueError up my stack means nothing to anyone, and increases the ambiguity of where it could have come from if I wanted to handle it somewhere where I got that input. So now I'm maybe doing this: try: a = int(x) except e as ValueError: raise BadInputToFrobnicator(e) with a new exception type that I need to create so that I can respond more appropriately somewhere up the stack (we hope). In order to know that I'm going to be getting one of these, I need to know about the code. Except now I find out that I could also get a TypeError, and I really shouldn't try and catch everything, so now I need another except case. While I could wrap that try except around the whole function, that leaves me open to catching Type from other things, like that list index that I passed a class to. So now I have 3 lines of code (5 if we include the TypeError) to handle the same thing as: a, err := strconv.Atoi(x) if err != nil { return &amp;FrobnicatorInputError{Value:x} } So in Python, we're dealing with a type we need to know and effectively cast to, which isn't much different from Go. But while the error interface is just `Error() string`, nothing about that prevents us from doing more with our errors in our application context. Our FrobnicatorInputError can implement another interface as well, one shared by other error types, such that we don't need to know about it specifically. Maybe that's the `BadInput() (inputname string)` interface. And maybe we want the underlying error, so we wrap the original error from Atoi() using in the FrobnicatorInputError, using Go 1.13's `Unwrap() error` interface. And maybe we do want the line number, so we use another error wrapper to grab the stack trace (which is an expensive operation you don't always want), and use [`xerrrors.As`](https://xerrrors.As)`(err, &amp;badInputError)` to check if there's a error that implements BadInput() in there. So yes, Error() is just a string, but an error value is much more. And some of the standard library errors might be challenging to deal with in their variety, but have you looked at the potential cases for network errors in Python as a comparison?
I wanted to alert everyone that all modern functional languages include "monad" support. Very seldom have I ever actually written case Left(error) =&gt; ... because monadic composition always handles it for me. Just compose with flatMap or &gt;&gt;= and continue on.
"Conn Read" is blocking. Something must have been read - use n, err == conn.Read(buf) and always first check "n &gt; 0" before handling "err."
A nit I forgot about [the last time this was discussed](https://www.reddit.com/r/golang/comments/bgg4zs/dotgo_2019_dave_cheney_constant_time/elkuppg/) is that [unsafe.Sizeof](https://golang.org/pkg/unsafe/#Sizeof) actually *is* a constant expression and you can totally use it [to get the size of a uint](https://play.golang.org/p/4RYZYiERhFW). The reason to still avoid it, IMO, is that it requires importing unsafe, which you don't want to do, unless you have to.
There is no "best". The best editor for standard compliance is "ed", the standard UNIX editor.
cool !
 For those interested in using Go as a scripting langage, this dotGo talk is for you [https://www.dotconferences.com/2019/03/ignat-korchagin-go-as-a-scripting-language-in-linux](https://www.dotconferences.com/2019/03/ignat-korchagin-go-as-a-scripting-language-in-linux)
When using vendoring, it is advised to check-in the vendor folder. If it‚Äôs ignored then there is no way to track the changes between branches.
Yes thank you. But is checking for an EOF and closing the connection, the same as checking if n==0? What if the client keeps sending an empty message? Like \n
I was wondering if this was a thing, just wasn't keen on a directory full of 20MB go binaries.
The conn.Read is in an endless loop. Add a *break* instruction just after the *Println()* to exit from the *for* loop. Once the connection is closed, *conn.Read* will always return io.EOF.
Seems like a cool concept, but I tried all severs and all I am getting when I select a game for playing is "Game is not ready yet, please wait". Are the servers currently under heavy load?
Well, if you do open source your mapper, I have roughly 50 or more types to push through it! &amp;#x200B; I'm also thinking of a Python script that just generates code from what the go-swagger generated, and seeing how well this works with editing the swagger.json further. &amp;#x200B; Or, I could just implement the go-native structs on an ongoing basis, so I don't do it for everything (it's not like my Go SDK supports every single endpoint of the other side yet). Still so much to try out...
I was just playing around and went with a different solution not involving Go.
&gt; Could we change the definition of os.Stdout and friends so that they retain the observable behaviour of reading and writing, but remain immutable? It turns out, we can do this easily with constants This section completely ignores all the other `*os.File` methods that are usable and useful on `os.Std`* including: * `Seek` (works if redirected to a file) * `ReadAt` or `WriteAt` if seek-able * `WriteString` * `Close` * `Fd` * `Name` * `Stat`, in particular can be used to determine if stdio has been redirected to a pipe, file, etc * `SetDeadline`, `SetReadDeadline`, `SetWriteDeadline` * etc
I think the game failed to setup WebRTC peer to peer handshake. The reason is either you play on IPhone (where WebRTC is not supported) or your firewall is blocking some forms of peer connection. It would be ideal if you try the platform on Desktop with a public network. You can read FAQ in github for more information.
Note: be careful with your punctuation; [Go!](https://en.wikipedia.org/wiki/Go!_(programming_language)) is not [Go](https://en.wikipedia.org/wiki/Go_(programming_language)); the former is a is a 2003 agent-based programming language in the tradition of logic-based programming languages like Prolog.
nice
Got it, I tried on my iPad first. Will check desktop out too.
There are many factors that can affect smoothness of the game. Location, network condition, firewall ... I feel the latency is acceptable in ideal condition as I won contra game with it :D Google has a lot of advantage when they have an infrastructure that is more spreading and closer to you. More powerful computing resources with its existing distributed GPU system. I have high hopes on Google Stadia project.
personally my preferred is [https://liteide.org/en/](https://liteide.org/en/) ;-)
When I want to run Go like a script I use `go run`
&gt; Where are the compiled files kept? &gt; They are kept under $TMPDIR (or tmp), in a directory named after the hostname and user id executing the file. &gt; You can remove these files, but there's no reason to do this. These compiled files will be garbage collected by gorun itself after a while once they stop being used. This is done in a fast and safe way so that concurrently executing scripts will not fail to execute. Looks like it does handle it
... and do this for all read errors, not just EOF.
Nice! :)
Geez ur everywhere
I always get weary when i see 'making it easier to do &lt;task language was not designed for&gt; in &lt;language thats really good at other things&gt;'.
[removed]
[removed]
[removed]
Don't need unsafe: const sizeofPointer = 4 &lt;&lt; uint(^uintptr(0)&gt;&gt;63) const sizeofUint = 4 &lt;&lt; uint(^uint(0)&gt;&gt;63)
[removed]
[removed]
Have you read the article? Or my comment? Because frankly, it doesn't seem that way. The article claims you *can't* use unsafe (and does pretty much the same thing you're doing). I said you *can*. I didn't say you *need* to.
[removed]
Cool, I guess. How about a link to the repo rather than just the image?
It also doesn't consider that fd 0 could actually be writable (and fd 1/2 can be readable). FWIW, I think it's fine to stick with those example-methods (all of the other methods can still be implemented in terms of an FD). But another good reason to stick with the implementation of `*os.File` is interaction with the runtime for polling, non-blocking I/O and somesuch.
The repo name seems to be part of the image. https://github.com/superhawk610/bar
superhawk610/bar: Port of the progress package, written in Golang. GitHub: https://github.com/superhawk610/bar This is my first time back working with Go in a year-ish, any help or criticism would be super appreciated üêø
Yes, sorry. see my edit. I had read the article the first time it had made the internet rounds but had forgotten it included the safe constants.
I meant to post it earlier, thanks.
There is nothing inherently unsafe about Sizeof, and it is unfortunate that the only access to such functionality is through the unsafe package. This was discussed in the past with the core team, however, I can't remember if it was public or private. The gist of the conversation was that this functionality probably should be duplicated elsewhere.
Switching on exception type is not a solution. The problem is that for any common exception you don't know if that exception type could have come from a different path of code than you expected it to. You could in theory trace down every exception thrown in every code path you call in the try/catch block to be sure no other place can throw that type. But you can't predict what the next, future version of the library you're using might do. It's a pain, and a source of subtle bugs. That may be why java, as you point out, went and made the set of exception which might be thrown part of the ABI. Yet no other language I know of has repeated this, and my understanding is it is considered a mistake. The problem happens over time. Today your function only can throw E and F. Next year it has new functionality, and that new functionality also can throw G. Now if you update the function spec to indicate G can also be thrown then all the callers need to be adjusted to either handle or throw G. That gets ugly when it's a public library and you don't own the calling code. Or you ignore G. Or maybe if you can, you wrap G in an E or F. Or you simply say 'throws Exception' in the first place and never deal with this, but get no compiler exception checks. Humans eventually opt for the last option. \&gt; dramatic Here's it is with more drama, and assumptions: when you're my age and have seen and code reviewed "except:", "catch (...)" and "catch (Exception ex)" year in, year out, for decades, you might share my opinions about how exceptions are used.
You should have a look at table driven tests. Code looks okayish - did not spot anything wrong.
Thanks, will put that on my todo.
 const ( Stdin = readfd(0) Stdout = writefd(1) Stderr = writefd(2) ) will make the following line valid var randomf = Stderr + 100 which is a more serious problem than package-level variables. Lacking of formal immutable values support is really a pain in Go programming.
looks cool. wanted to use this to track how long really long tests were taking. when i ran the test in vscode, i got these errors: &amp;#x200B; `panic: strings: negative Repeat count goroutine 1 [running]: strings.Repeat(0x1165ba0, 0x1, 0xffffffffffffffff, 0x0, 0x0) /usr/local/go/src/strings/strings.go:543 +0x445 github.com/superhawk610/terminal.init.0() /Users/brocktillotson/go/src/github.com/superhawk610/terminal/terminal.go:15 +0x4e` &amp;#x200B; when i ran the test in a zsh terminal got this: &amp;#x200B; `panic: operation not supported by device` `goroutine 1 [running]:` [`github.com/superhawk610/terminal.getTerminalWidth(0x105d07d)`](https://github.com/superhawk610/terminal.getTerminalWidth(0x105d07d)) `/Users/brocktillotson/go/src/github.com/superhawk610/terminal/terminal.go:33 +0xb7` [`github.com/superhawk610/terminal.init.0()`](https://github.com/superhawk610/terminal.init.0()) `/Users/brocktillotson/go/src/github.com/superhawk610/terminal/terminal.go:14 +0x22`
This. I fail to see the point of this library. If I want to count the number of lines in a file matching "abc" I will not write a go program first, I will run `grep abc myfile | wc -l`, which takes way less time.
The "First-class Functions" misses a very important point: Go has *closures*. That's essentially the most important part of having first-class functions.
&gt; There is nothing inherently unsafe about Sizeof Again, nothing anyone has ever claimed.
Thanks for the stack traces, I‚Äôll see if I can get a fix up for those.
Yeah, the examples of piping provided in the example do not look easier than using the built-in shell pipes.
Also, do I have to get rid of my javascript and replace it with Golang in order to join the front end and back end?
&gt; How would I implement Go to my website You can write the backend processes, that do the actual work, in Go, have them expose APIs to communicate then and even write the backend parts that serve the HTML pages. Basically everything that happens on the server can be done in Go, if you like. &gt; what other tools do I need to learn to pull this off For starters: - Scaling / parallel computing / high availabilty / clustering - Video processing and encoding
If you don't know about back-end, this will be difficult. Start by learning the basics. A video streaming platform is FAAAAAR too difficult.
What would you recommend I start with? I am taking a course on Go right now? Should I do something different?
No, you will need JS.
Yeah, man. Seems like you don't know yet how to communicate the front with the back-end. Start with the classics todo apps, a chat, a forum like this Reddit üòâ
But everyone is telling me I should learn go for learning back end, what do you recommend I learn then?
Easy way to get a glimpse at go would be https://gobyexample.com as it runs in the browser and teaches you some practical stuff. The YouTube videos by francesc campoy on the justforfunc channel are a good start.
For a learning project, a small program that writes and read some data from a database and can be accessed from your HTML/JS frontend via an "API". I'd guess that'll keep you busy for a while.
And keep learning Go. Just try to make an app more easy to first understand how back-end with front-end comunication work. Learn REST APIs, learn web sockets, learn databases. Then try to make... lets see... The chat widget from Twitch. You need user accounts, rooms, messages and all of this in realtime. A chat system is something very fun to code. Go for it üëç
&gt;b.N If I iterate on b.N I will benchmark the time for one operation only... and I got very low result like 1ns so I was not able to get something accurate, thats I why went for this solution... &amp;#x200B; Small actually escapes to the heap, I ran the compiler escape analysis before running the benchmarks
i++ adds 1 to i every time. But the variable that is being printed is sum. And sum is getting i added to it every iteration of the loop. So 0+1+2+3+4+5+6+7+8+9=45. Hope this helps!
Exec() splits arguments by spaces, so it will not work with arguments which contains spaces :(
&gt; i++ adds 1 each time it loops, correct? Correct, and sum = 0+1+2+3+4+5+6+7+8+9
The value of i increments each loop. On the first loop it‚Äôs 0, so sum is 0. On the next loop i is 1, so sum is 1. On the next loop i is 2, so sum is 3. Then 3, so sum is 6, etc.
It sounds like your like-an-ECS is setup in a way that is unexpected to me. Do you have a slice of all entities, and periodically cast them to functional types in order to do something? Something like this?: for _, e := range entitiesInRange { hh, ok := e.(healthHaver) if ok { hh.TakeDamage() } } I would typically expect an ECS to have typed slices of particular components (or at worst, interface pointers for like-an-ECS, but really they should be components since that's sort of the point of an ECS), so that there are no type assertions needed. I would expect components/entities to explicitly add themselves to the appropriate systems (you do at least have multiple systems as first class entities, right?) using the appropriate interface, not simply passing themselves to the ECS as a whole and letting it figure things out.
This helps! Thank you. I was so frustrated.
Thank you!
I appreciate it! Thank you!
Exactly!
JetBrains are almost perfect, but I've had a few issues with CLion specifically. I haven't tried Goland yet, hopefully it's a little faster
What kind of issues did you have? I used to use CLion for CMake/C++ projects quite regularly (currently only for Rust projects) and in comparison to other C/C++ IDEs I used over the years I found it to be one of the most useful (since about 2017). But it definitely has its issues... most of them IMO are related to the complexity of the language and the ecosystem. Both of which more modern languages like Rust and Go try to focus on more. Due to Go addressing these issues directly in a greater extent than C++, I find Goland to be more usable than CLion for the most part. So it definitely is an IDE to consider. As for the speed part... I'm on your side. I can really understand the point on using Java for IDEs but speed and more generally resource friendliness sure is not a thing that comes with this decision.
what a constructive feedback
&gt; Do you have a slice of all entities, and periodically cast them to functional types in order to do something? Something like this? Yup, something like that. It's not really an ECS, but that seemed like the most similar comparison I could make. Basically we have a set of all of the live objects that various parts of the program use, and they check for behaviors like you've shown above. I just want to make sure that the types that _should_ provide those behaviors do so they're not accidentally broken in a refactor. So, here's a more fleshed-out example: for _, hh := range healthHavers { hh, ok := e.(healthHaver) hh.TakeDamage(target.Damage()) // some enemies can inflict damage when attacked if retaliator, ok := hh.(Retaliator); ok { target.TakeDamage(retaliator.Damage()) } } So, everything in a list has a common set of behaviors/properties, and some have additional behaviors/properties. I don't want to change damage from an `int` to a `float64` or something cause some behaviors to not be recognized. Being able to indicate to the compiler that I intend for a type to implement some interface means that I don't accidentally break compatibility with some interface by changing a function. And yes, there definitely are multiple systems. If I want to do something like an area of effect thing, I'll look up all entities in the area, filter down by some common interface, and conditionally implement some behaviors. You see this in the standard library relatively frequently, such as checking for implementing `String() string` (e.g. errors.stringer). Since these are internal-only interfaces, they could change at any time (e.g. change `int` -&gt; `float64`), and having a compile-time check is _very_ nice.
Yeah, had to write that into my `helper.Execute("ls -alh {{.}}", "/")`.
Looks like most people complaining didn't even read the article.
The best editor is emacs and this is independent of what you want to do with your editor.
I've actually largely abandoned shell scripts in favor of go programs, so I feel like I can actually explain why some of the tooling the OP provides can be useful: * It's easier to test a go program than a shell script. While the purpose of the attached library is to do things quick-and-dirty, using a testable program makes things more reliable. * System-agnostic. Sometimes I need to write an app or script that needs to run on an engineer's laptop. Shell is a nightmare combination of use cases and custom configuration. Then there is having to deal with differences between different flavors sed and grep. * Can be combined with higher level business logic without breaking into a subshell and parsing STDOUT. Personally I likely won't use this tool. Most of the shell like tooling I've used in the past have been replaced with more feature-full libraries and native processes. But I could see other members of my team which prefer to do shell scripts as a way to get into doing their tooling in Go.
Cool, good job
Thanks!
A little Friedrich Gauss solved similar problem when he was 6 (or 7, I don't remember exactly) in this way ``` 0+\ldots+9= = \frac{(0+\ldots+9) + (9+\ldots+0)}{2}=\frac{(0+9) + (1+8) + \ldots + (8+1) + (9+0)}{2} = \frac{10\cdot9}{2} = 5\cdot 9 = 45 ``` Paste this code in https://www.codecogs.com/latex/eqneditor.php to see the mathematical formula
Since one of my company's products manages secrets like passwords, I can't assist directly by making a PR or something, but I can certainly give advice. First, you'll generally have the fewest security holes if you do things the simplest way. Second, you can't decide who "holds the keys to the kingdom" without deciding who your audience is going to be. If it's a business, you probably do need what you described--a way to decrypt on the server if you are an admin user--even if you are not the owner of the secret. If that's the case, you're going to need an encryption key stored for each user that encrypts and decrypts their data with plain AES. You might encrypt all of these with a master key that the process running your application can access. Your master key should be stored somewhere you trust--this might be an environmental variable in the container running your server or it might be in the OS keyring, or it might be the private key to a certificate stored on the server. This approach IS vulnerable if your server gets hacked, but the chicken and egg problem doesn't have a magical solution. If the server can disclose a password to an admin or the end user, you simply must have a way to get to the secret master key from the server. That means you need to know how to harden everything else--use two factor when your users log in, use recaptcha, and have proper rate limiting and hardening against side channel attacks like timing attacks, etc. Keep your firewall configured narrowly and have ssh allowed only from a trusted IP. If your audience is an individual (think Keepass etc), there are common approaches available. One choice would be to have the user, once logged in, request a copy of their still-encrypted secrets. They might then do the decryption locally after the secret (a user and password from a database, for example) arrives. If they change their password, they might need to download all the secrets to decrypt with the old one and re-encrypt with the new password. You could keep the website password and encryption key different so that even data in transit will be secure during things like login. However, you'll always have additional considerations. If someone hacks your server, you'll probably be serving malicious client (web ui or desktop app) code too, which negates some of these additional protections. It is a bit of cat and mouse without a perfect solution, but this type of application still needs to exist, so if it's the most secure part of your tool set, you might be okay. Regardless of approach, I don't advise using your project for any purposes more important than fun unless you have a formal review from a security professional. As a quick note, remember to think about more than security of data at rest. You also need to think about security of data that is in transit. EDIT: When I speak of a user, it could be a human, an API that uses a token, or a service account of another application that uses Oauth2.
 Just to do some level-setting. I came to go via kubernetes, and I like the language a lot (it's my goto these days). These days I'm primarily a kubernetes cluster admin and so everything I write in service of that. My workflow is like this: If I want to interact with the shell I start in bash. If it gets a little to complicated in bash, i move to perl ( because I'm old and I know it and because that's the niche it's actually designed for.. I think python is also acceptable here ) If it gets to squirrely in perl I write it in go but it gets super painful at that point. Honestly I try to adhere very closely to the unix tooling ethos of make a thing that does 1 thing very well and allow it to be pluggable through piping. But also ... operators and controllers which tend to be more complicated than that, but I try to stay away from shell commands for all but the simplest stuff like calling into iptables.
Completely unrelated question - what is the theme of this terminal? Looks cool
I agree with /u/NicolasParada, replicating Twitch or any major website on your own is very difficult. However, everyone in the current thread completely missed the point of your question. They probably forgot how it is to start learning new programming concepts. The point is not that you will end up replicating a 1-to-1 copy of Twitch, the point is that you‚Äôll learn how to build a project, and add some features to it, and each feature will take you to a path to learn new concepts, and little by little you‚Äôll get to the point of being able to understand the complexity of these platforms. Follow this list, you‚Äôll get the knowledge you need to build this project: 1. How to submit data using a basic HTML form 2. How to process a form submission using Go 3. How to submit data using JavaScript via ‚ÄúXML HTTP Request‚Äù 4. How to process an Ajax request using Go 5. How to render a HTML page using Go 6. How to render JSON data using Go 7. How to display a video using HTML `&lt;video&gt;` tags 8. How to stream a video using Go, to render via HTML 9. How to connect Go to an SQLite database [1] 10. How to submit data and store it in the database [2] 11. How to print all the data from the database to all users 12. How to refresh the page when the database updates [3] Once you‚Äôve mastered all these concepts, you‚Äôll be able to continue working on more interesting features, like video streaming _(which is basically an improvements on step 8)_. I hope this is enough for you to start, and don‚Äôt hesitate to ask more question if you need more ideas. Building a Twitch clone sounds like a fun project. Good luck üôÇüëç --- [1] Although there are better database engines out there, SQLite is probably the simplest one to use, and the point of this project is to learn, not to build a complex system in one night, so I encourage you to try SQLite first, and move on to better things like Postgresql, MySQL, or others later when you have a good idea of how to interact with a database. [2] This requires you to understand points 1, 2, 5 ‚Äîor‚Äî 3, 4, 6. [3] At this point you‚Äôd have implemented a rudimentary chat system.
Thank you sm man!
It's the One Dark theme for KDE's Konsole running the powerlevel9k theme for oh-my-zsh :) The font is Fira Code w/ ligatures enabled.
It's about getting that functionality in your go programs, whatever they are doing, most likely something more than a shell script would be convenient for.
You are right.
Alright, I've got new versions of both `bar` and `terminal` up, let me know if that fixes the problem for you! The new version relies on a more reliable method using the `stty size` command and parsing its output instead of querying syscalls directly, so hopefully it should be more stable cross-platform. Additionally, it will now fail gracefully and log a warning to `os.Stderr` if it fails to initialize instead of panicking. Enjoy, and thanks everyone for the stars! **EDIT:** To update, just ``` go get -u github.com/superhawk610/terminal github.com/superhawk610/bar ```
It was mainly speed issues on my Mac which I don‚Äôt have with other JetBrains IDEs. Eventually I switched to Xcode which I found way faster and more reliable.
I think go would really shine as a command if the process could benefit from go routines. Otherwise I'd probably recommend bash for most things, and if you're on Windows id recommend installing git bash, or other alternative. (Not sure what that whole Windows 10 Linux shell is gonna be like)
There are open source NES games too, like Nova the Squirrel.
&gt; If it gets to squirrely in perl I write it in go but it gets super painful at that point. And this is the point where the linked library would become useful - to make shell-like operations in Go less painful. Which makes your original comment a little ironic.
This library will make it no less painful. Usually what I do at that point is start making the calls under the shell commands. Honestly though it's gotten that far exactly once.
Looks like yuh May have a typo in that example muliflat
grep -c does it in one
At least one appears to have a Raw type for bytes.
agreed Atom rocks
This was posted 5 days ago by u/mloga at [https://www.reddit.com/r/golang/comments/bx8kcw/lets\_build\_a\_sql\_parser\_in\_go/](https://www.reddit.com/r/golang/comments/bx8kcw/lets_build_a_sql_parser_in_go/) &amp;#x200B; OP has a username matching the domain in his link which seems to have copied all the text from the original link. I call shenanigans. Some kind of spam bot or karma farming going on.
Do not roll your own crypto. &amp;#x200B; &gt;1. If they break into the server containing user hash mappings, the password is encrypted and theres no key to decrpyt. hashing != encryption. Why break in if the server is just going to send the hash over the network.? &gt;2. If they break into the web server, there only exists the private key and not the password. They have the private key, they also have access to the hash / unencrypted password depending on how it is stored in memory. they also have access to passwords coming in through the network &gt;3. When the server starts the user can input the password and open the DB connection and needed only once the connection needs to be opened. 99% of users will put the password in wrong, the other 1% will have capslock on. If you had to put your password into each application that needed elevated privileges for one thing or another, you would never be able to use the computer. &amp;#x200B; Its an interesting concept, but stick with a battle tested approach. Theres a reason its the norm.
Good for you, "I only read the title" guy.
Meh, I actually did read it. I just didn't find it very useful which is why I made the tongue-in-cheek comment. If I wanted to pipe together Go code, I'd rather write small programs and pipe them together on the shell using regular pipes | as opposed to calling Pipe() and doing it all within a single program
Hey thanks man! So, as I probably mentioned in the blog, it was just a thought process that I needed to put out and gain insight. But I ended by realising that "the battle tested approach" is quite solid even though kinda flawed. I do agree about your explanations for 2 &amp; 3, but 1 -&gt; I never mentioned hashing == encryption. By "user hash" mappings I meant the hash of the user mapped to the encrypted password. I probably had to be more clear there my bad. Comment and thoughts appreciated!
Also, by "do not roll your own crypto" do you mean dont have my own crypto package? I did that because I needed some helper functions that I didnt find.
Thank you! That was a deep insight into the problem. I did found one "plus" that can support my solution thought -- " It is a bit of cat and mouse without a perfect solution, but this type of application still needs to exist, so if it's the most secure part of your tool set, you might be okay. " Since my last conclusion was, "Um this is the same as user entering password, but a bit more secure", I did learn that if this server is more secure with 2 factor auth, the security of the whole system is higher. Regardless, I am still learning and understanding from people who can teach and explain, so I appreciate your effort for this :D
I think this is normal, everyone does &gt;There is a kind of programming trap I occasionally fall into that is so damn irritating that it needs a name. -- by [**Eric Raymond**](http://esr.ibiblio.org/?author=2) [http://esr.ibiblio.org/?p=8143](http://esr.ibiblio.org/?p=8143) this think may make you feel better
Looks good.
all you had to do, is put another println(sum) after the sum was raised with the value of the variable i. I suppose that would have given you the knowledge you seek ;-)
Mind Blown, is there a second part to this blog.
Similar idea, older project, different API: [https://labix.org/pipe](https://labix.org/pipe) \- Also for using script-like/unix-like pipelines to tie Go functions and applications together. For some reason, I totally failed finding that by Google-Fu, and had to resort to - GASP! - asking real-life humans!
Sorry to shit on your conspiracy parade my guy, but we're a jobs platform with a blog section where authors of articles send in their work to be crossposted. I post the articles in relevant subs because usually the users find them interesting reads. I unfortunately did not check whether this had been posted before and that's my bad.
How did you expect it to work? (trying to understand "intuitiveness" of programming constructs)
Yes,You are correct!
Yes ,If we declare only values we have to follow order of defintion . with property and value we can follow any order.
Ohh shiny
Copy the keys into a []string slice, sort.Strings, the iterate on the key slice.
The error, and the function signature tell you exactly what the problem is: \`sort.Strings(a \[\]string)\` takes a slice of strings as an argument, but you've provided it with a map. The other thing you need to be aware of is that the order of map keys in Go is undefined, so you cannot sort the keys. These are the reasons you'll need to do as tgulacsi suggests. &amp;#x200B; If you haven't worked throught the Go [tour](https://tour.golang.org/welcome/1), you probably should at least do that.
If [govim](https://github.com/myitcv/govim) works like [vim-go](https://github.com/fatih/vim-go), then it sounds very cool. Now I will try and write below.
Well, you've got to basic options: 1, keep reading; 2, close the connection. If you choose option 2, you might want to blacklist the IP address, as well.
https://www.reddit.com/r/golang/comments/byasqb/bitmap_indexes_in_go_unbelievable_search_speed ?
Oh, it was posted already.
Seems nice, but I don‚Äôt want a message like ‚ÄûErrlog tried to debug the error, but the stack trace seems empty. If you think this is an error, please open an issue at https://...... and provide us logs to investigate.‚Äù You are basically asking my customer to provide his logs, and maybe doesn‚Äôt even know that this issue link does not belong to me. Please fix.
I liked the idea of this plugin and some features. For example, it is felt to work faster, allocates tabs and spaces at the end of the line. &amp;#x200B; I realised that it should be taken as an experiment and too much is not implemented. And so I do not recommend. I didn't find the functionality for building and running, syntax checking, testing and more.
Any plan to support Neovim?
[https://github.com/myitcv/govim/pull/186](https://github.com/myitcv/govim/pull/186) is the PR where support is being planned.
`&lt;esc&gt;:! go build` to build. Map to whatever you prefer. `&lt;esc&gt;:! go run` to run. Open the quick fix window to see syntax errors. (Not tested, I don't want that kind of distraction during coding.) `&lt;esc&gt;:! go test` to test.
The part I missed was that the value of I gets stored into sum. And have to remember it loops. I was thinking "oh I just increases and it'll be 10 eventually THEN sent to sum printing 10."
Hi - I'm the original author of govim. &amp;#x200B; Yes, govim is indeed an experiment ([https://github.com/myitcv/govim/wiki/FAQ#why-have-you-created-govim-what-iswas-wrong-with-vim-go](https://github.com/myitcv/govim/wiki/FAQ#why-have-you-created-govim-what-iswas-wrong-with-vim-go)), but it has matured considerably. Along with a number of other people, I switched entirely to using it for Go development some time ago. &amp;#x200B; govim doesn't (for now) have any functionality beyond that provided by gopls ([https://github.com/golang/go/wiki/gopls](https://github.com/golang/go/wiki/gopls)). Which is largely intentional: because if something is good enough for Vim users, it should really be added to gopls so that all editors can benefit. That said, [https://github.com/myitcv/govim/issues/273](https://github.com/myitcv/govim/issues/273) is a good example of where we might add some functionality to govim first (as an experiment if you like), functionality that might one day make it to gopls. &amp;#x200B; As I mention in the FAQ, the main reason behind writing govim (which is itself written in Go) was to make it easier for others to contribute, because everything is written in Go. That means it's easier to experiment with functionality in govim, and then easier/less friction to contribute changes "upstream" to gopls if necessary. &amp;#x200B; If there are functionality/features that you think are missing, please do raise issues.
Cool! Does this handle the gopls completion issue with defer and go func?
I look forward to it! Cheers!
You would have to find a way to tell the `xyz` handler where the HTTP server for `abc` is bound (i.e. host:port) which will probably be messy. It's probably better to abstract the code behind `abc` into two parts: one that parses parameters from the HTTP request, and another that actually implements the Elasticsearch business logic. The first part would go in the handler, and the second part you could model as an interface: type Searcher interface { Search(query string, results int) ([]Document, error) // or whatever } Then, whatever implements Searcher would be passed to both the `abc` and `xyz` handlers as a dependency. This way you avoid navigating the HTTP stack twice, too.
Another part I wasn't thinking I ever gets to 2, holding value each time. I sort of looked at I as a tick, counting internally until it counted to 10 then stopped and printed 10. Totally new to general purpose programming. It's much similar than Terraform configuration code.
And what? This is pretty much mature library.
No, this is an upstream gopls issue: [https://github.com/golang/go/issues/29313](https://github.com/golang/go/issues/29313). I think it's very unlikely we will ever "patch" things in govim for issues like this. Rather we would look to focus time/effort on fixing things in gopls (for the benefit of everyone)
Makes sense, hope the issues is resolved soon. Thank you.
Thank you very much! I forgot about it and used `&lt;esc&gt;:GoBuild` and etc in vim-go. Then I was wrong. So I will use this plugin for about a week/month and write again below.
Thanks for the reply! Maybe I understood something wrong. I used this plugin for no more than half an hour. I will still use this plugin and then write about it.
This package is developer intended, its for debugging, not crash reporting. You shouldn't distribute any program/library with debuggers inside.
I don't know the answer, but might help you to get one more easily : first try formatting your code so its more readable to us (google "Reddit code formatting" in case you don't know).
Writing your scripts in Lua and putting the heavy lifting in Go would probably be quite efficient, giving you the power of Lua's expressiveness with Go's terse robustness.
I have built a SortedMap/SortedSet package with SkipList a few months ago. Unfortunately it is non-documented and needs some effort to be completed. It works fine in a basic manner. You may want to check out tests or the code in order to discover it. You can create an issue on GitHub for further discussion. https://github.com/buraksezer/gsorted https://github.com/buraksezer/gsorted/blob/master/sortedmap_test.go#L20
Continued from [Building a Go Web API](https://rshipp.com/go-web-api) - let me know if you have any feedback!
It‚Äôs totally fine to have a separate module for 20 loc, I would create a package utils/time/time.go
the big thing that i miss so far -- and perhaps it is because i don't know how to use govim yet -- is that when i save and there are errors which prevent `go fmt` from properly formatting the code, i don't get any feedback. it quietly does nothing. is there something i'm missing?
maybe utils/timeutil would be better. it'd be a mild headache to use both time and utils/time otherwise
You can always import it as timeutil, but it‚Äôs up to you. Just don‚Äôt worry about lines of code if you need to create a module if you need to use those functions in several places.
I don't think you've quite given us enough context to know the best answer, because you haven't actually presented the problem yet. On their own, it's trivial to marshal these two types. So, what exactly is the problem? Is it that you may have a heterogeneous list of these things? Is it that you're unmarshaling them in a context where you don't know the type? etc. There's multiple possible places where mismatches between the serialization format and the data can occur.
I prefer to default my version string to something like "development version", so the version string comes out as "development version" unless the linker is used to override the version. I also recommend including the actual git hash used to build; tags can technically be changed. Hopefully you'll never be in a situation where this mattered, but if you ever are, it can be a lifesaver. I also combine this in my build steps with checks to ensure that the repo really is in that state. git status shouldn't have anything in it at build time. Otherwise it's really easy to build with uncommitted changes, and, whoops, turns out the version is basically lying about what was built.
[removed]
When you say that both endpoints are on the same server, do you mean that the same server process hosts both endpoints? In that case you should have the `xyz` business logic be separated from the REST endpoint handler. Then you can just invoke it as-is. This is a general best practice. The REST endpoint handler should do little more than serialization/deserialization and parameter validation. The actual business logic ideally should be able to operate independently.
I use a package called `internal` with some sub-folders like `util` to place such helpers. I can really recommend to take a look at the [go-standard project layout][ps] which can be seen as the state-of-the-art when it comes to Go project structures. The `internal` package should not be imported by any other lib so you can place your helper there, even if some of them are only &gt;=10LOC: That's a big win compared to writing 300+LOC when implementing the same function in various packages over and over again. [ps]: https://github.com/golang-standards/project-layout
[removed]
``` package timeutil ``` Totally OK even if it's 20 LoC.
Also see the features list at [https://github.com/myitcv/govim/wiki/govim-plugin-API](https://github.com/myitcv/govim/wiki/govim-plugin-API), which includes short screen recordings of the current features. &amp;#x200B; _But please note [https://github.com/myitcv/govim/issues/176](https://github.com/myitcv/govim/issues/176); the videos themselves could/should be improved, probably with commentary to best showcase what's supported, how it works etc_
Not self hosted but I‚Äôve had luck using AWS Cognito and Go together
https://github.com/golang/go/wiki/CodeReviewComments#package-names &gt; Avoid meaningless package names like util, common, misc, api, types, and interfaces. coupled with the Go proverb https://go-proverbs.github.io , "A little copying is better than a little dependency." Don't put them in a separate package. Follow the standard of putting them near where you use them, and if you use them in another package, copy that function in that package too.
Hello :) Another option would be using Google Chrome headless to convert your HTLM to PDF. If you're interested by such approach, you may also look at [https://github.com/thecodingmachine/gotenberg](https://github.com/thecodingmachine/gotenberg) (disclaimer: I'm the author).
Link to his twitch: https://www.twitch.tv/nickbusey
This sounds like it might be relevant although I‚Äôm sure you already read it. https://medium.com/@skdomino/taring-untaring-files-in-go-6b07cf56bc07
Yes I did. I was hoping for a project that was wrapped around these packages but that is a plan b üôÇ
Cool just checking. Let me go back to google and see if I can dig up something.
Good question, and this touches on something that is hard to get right: what is the sensible "out of the box" default for govim? I've _tried_ to make the defaults as IDE-like as possible, but always with options to turn off/make manual/etc everything for those who like things bare-bones. With format-on-save, we have goimports-like behaviour as the default, which I think is thing that most people would expect. When it comes to (syntax) errors, we're not quite in the right place, yet. https://github.com/myitcv/govim/issues/277 suggests one approach, that of showing the quickfix window when there are (syntax) errors. But I'm not convinced that the majority of people will expect this to open/close as (syntax) errors come and go. It feels wrong. What does look much more promising is https://github.com/myitcv/govim/issues/284; this uses an indicator in the left hand "gutter" (sign column) to indicate a problem on a line. But still this isn't the full story; if I have an error on a line that is not visible within the current window, I no idea there is a problem in the file. For that reason I've just opened https://github.com/myitcv/govim/issues/289. I'd be very grateful if we could continue the discussion there. Thanks for the feedback.
Alright yeah seems that everything is using the built ins. Good luck!
Yup. That‚Äôs what my google-fu told me too. Maybe this is an opportunity for a resume booster haha but thanks for the help
Why not use pandoc?
There‚Äôs always room for more resume boosters.
Why are language servers considered a good idea? I do not understand why language servers are a thing.
I cover this in [a talk I gave to VimLondon](https://www.youtube.com/watch?v=qj81tDDqzrQ) ([slides](https://talks.godoc.org/github.com/myitcv/talks/2019-04-25-govim-vim-london/main.slide#1)) There is also [Rebecca Stambler's talk](https://www.youtube.com/watch?v=5Re6BHEOT_k); Rebecca is one of the main people working on gopls, the LSP server for Go.
All feedback are very welcome and appreciated :)
Why not go with the standard lib and use https://golang.org/pkg/archive/tar/ and https://golang.org/pkg/compress/gzip/ ?
I hope they point out, that for many simple cli apps, flags package is sufficient.
A TLDW for /u/myitcv 's response: Current state of things: The team behind each editor needs to write its own support for every language it supports. With Language Servers: The team behind each editor only needs to write to the Language Server Protocol.
I wanted a package which wraps that and will take miinutes to use instead of an hr+ (since im new to go)
You probably could have already completed this with the amount of time and effort you spent looking for an easier solution.
Ive been doing other stuff :) I did some research, asked reddit, and left it for responses while I went on with my day
Chrome headless sounds like a bit of overhead for such a small task ü§®
Its also not that it takes long. I want a solution that will be maintained if anything changes which will save me time and effort in the long run (especially since it seems like go changes faster than most languages). I also wanted the ability to have features that would take me more than an hour to complete
Hey, what is your intending use? Microservice integration? e2e? BDD? Please DO NOT call e2e tests integration tests. That hurts... I am a QA Eng... just to clarify e2e are *usually* user paths that attempt to mimic user interactions. Integration tests are.... integration tests. Like testing how microservices work toghether. As a side note while most Unit testing frameworks are language dependant, Integration and e2e are not so I suggest you to look for general testing like r/QualityAssurance
Once I set up a `Makefile`, that's how I build my binaries so having a Version string is enforced through my own discipline. I work primarily on projects by myself so I have that luxury. I will eventually include the build hash and whether the build includes uncommitted changes, even if that's something I just pull out of the binary via `strings`.
&gt; Also, as an aside, do you have any suggestions for learning more about thread / concurrency safety? I'd highly recommend reading through [https://golang.org/pkg/sync/](https://golang.org/pkg/sync/) so you have a good general idea of what tools are available to you. You should read [this ebook](https://quii.gitbook.io/learn-go-with-tests/) and follow the exercises, there's a good section on concurrency in it as well. &gt; The only problem I'm having now is the part about replacing the struct variables with the "real deal logic" lol. The issue is that these variables are derived from the request body of GetToken. Is there a way to access the Request.Body from the WithPlaidCtx closure? The short answer to your question is yes. You are very close to an answer. Spend some time experimenting and playing with accessing variables from various scopes. Derping your way through a problem is one of the best ways to learn and I don't want to deny you the thrill of victory when you finally get it figured out.
For restful apis I enjoy using Postman
Very awesome, nice resource!
May you can use [maroto](https://github.com/johnfercher/maroto), it uses gofpdf behind the scenes, but is much easier to create pdfs.
You probably aren‚Äôt going to find much. The built in `archive/tar` pretty much covers it, and isn‚Äôt very difficult to use, so there‚Äôs not much need to wrap it.
&gt; Integration tests are.... integration tests. Like testing how microservices work together. integration tests may also include components within your application.
wkhtmltopdf is a nightmare. You change a small bit, and everything shifts randomly around. And on top of that IIRC it is abandoned long time ago. Just use LaTeX, if you want reliable, consistent and good looking results.
An interesting quirk of `unsafe.Sizeof` and `unsafe.Alignof` is that they are const expressions. That is, you can write `const x = unsafe.Sizeof(foo)`, or even `var x [unsafe.Sizeof(foo)]int`, and the compiler won't complain.
Totally understand that. I was at that exactly same point I think. I have some code laying around somewhere for packing tar.gz. I‚Äôll have a look later. But, while new to go, that‚Äôll be a great way to learn. I code go for some time now and even I can‚Äôt wrap my head around all the fancy things. But I try to use as much of the standard lib as possible for portability and learning reasons.
[removed]
Ah ok cool, seems as though I have the terminology mixed up there. Thanks for that
Sorry for being vague. I have a rest API with a MySQL backend. Godo looks interesting, I will definitely check it out
Still better than wkhtmltopdf üòâ
For question 1, the `After()`, `Sleep()` or `Tick()` functions from the `time` package are perhaps a good start. For question 2, what is your goal here? You can compile any number of source files into a single executable, so there is no need to put everything in one file. Just do `go build` in the directory where the `main` package resides.
Yeah that‚Äôs a great thought process. Don‚Äôt want to leave my employer with more code to maintain when I leave (if it was possible). It‚Äôs probably the js in me that‚Äôs saying ‚Äúthere‚Äôs gotta be a package for everything‚Äù
&gt;A little copying is better than a little dependency I disagree on this so-called "rule", because copying stuff doesn't make it less depend on the code you copy. It even brings the danger of 2 almost equal sources, that aren't equal. A proverb is as good as its actual meaning. (And I thing, to copy helpers isn't one of them.)
yeah :D I know that feeling, same for me in python back then. alright I used the archive from mholt in that project I could find. but I know I did it on my own somewhere else and it wasn't that hard to do. also wenn you depend on someones package you either have to clone the repo to make sure it stays compatible or keep it somewhere.. ill go for the standard lib :)
Is it support multi-language?
Thanks! Also that‚Äôs what go mod is for üòù (unless he takes down the repo)
Yes, You are right @kolaente.
&gt;if you use them in another package, copy that function in that package too. I hate copying code, because you will also copy the bugs.
I am using this for 2 years, I didn't face any issue till now.
&gt;Avoid meaningless package names like util, common, misc, api, types, and interfaces. I know, I know. Then the question: how do you extend standard packages, like time? Do you embed \`time.Time\` and use OO style, or just write pure functions with a \`time.Time\` argument?
Yes, naming is also an interesting question if you add new functionality for existing standard packages. What else could come to your mind besides reusing (and aliasing) the old package or having an \`util\` postfix?
I don‚Äôt think the proverb extends to copying the same function all over a project. That is a recipe for disaster for any function with bugs (and if your function doesn‚Äôt have bugs odds are you haven‚Äôt tested it properly) Anyway, you don‚Äôt have to use an external dependency but if you‚Äôre copying the function in several places put it in its own internal util (with a more specific name)
There are few packages which generate dynamic pdf based on HTML data. But I found some new features in wkhtmltopdf are like, it supports multi-language and also we can design the pdf by using CSS inside the HTML template.
 Thanks for your suggestion. But I found wkhtmltopdf is a light-weighted package.
Pandoc is a program as well as a library, so just doing `$ pandoc infile.html -o outfile.pdf` already gets you everything that this library is doing, and that's without any options.
Yes, but my question was is it support multi-language? Because I was facing few issues with pandoc that's why i couldn't recommend. Let me share few cases which we can not cover in pandoc. This doesn't seem to be working when converting to PDF with pandoc dokumentace.md -f markdown\_github -o dokumentace.pdf . Following error appears: ! Package inputenc Error: Keyboard character used is undefined (inputenc) in inputencoding `utf8'. See the inputenc package documentation for explanation. Type H &lt;return&gt; for immediate help. ... l.83 ... nƒõ odkazujeme pomoc√≠ symol≈Ø 1^^Le0f^^T
I mean, they finally found a genuine use case for IPFS ...
So the issue seems to be that you're not using UTF-8?
[https://golang.org/doc/devel/release.html#go1.12.minor](https://golang.org/doc/devel/release.html#go1.12.minor) &amp;#x200B; go1.12.6 (released 2019/06/11) includes fixes to the compiler, the linker, the go command, and the crypto/x509, net/http, and os packages. See the [Go 1.12.6 milestone](https://github.com/golang/go/issues?q=milestone%3AGo1.12.6) on our issue tracker for details. &amp;#x200B; &amp;#x200B; (the 1.11 release only has the x509 fix it seems)
SMTP is a hop-by-hop mechanism which in your case includes at least two servers, aliyun and gmail. You are using TLS in the connection to aliyun. But gmail probably cares about the connection from aliyun to gmail which I guess isn't using TLS.
[removed]
aliyun is not transiting to google over TLS
postman is great! Automation would be good though
Your best "resource" is to actually code. Dont fall into the illusion that you can read yourself to a higher level of skill. Practice is king in this environment
Dirty hack, don't do it. May nuke a friendly country. ``` package main /* int foo(int (*x)()) { return x(); } int bar() { return 42; } */ import "C" func main() { println(C.foo((*[0]byte)(C.bar))) } ==== jnml@e5-1650:~/tmp/x&gt; go run main.go 42 ==== jnml@e5-1650:~/tmp/x&gt; ```
Dirty hack, don't do it. May nuke a friendly country. ==== jnml@e5-1650:~/tmp/x&gt; cat main.go package main /* int foo(int (*x)()) { return x(); } int bar() { return 42; } */ import "C" func main() { println(C.foo((*[0]byte)(C.bar))) } ==== jnml@e5-1650:~/tmp/x&gt; go run main.go 42 ==== jnml@e5-1650:~/tmp/x&gt;
That means I have to replace every single `if errlog.Debug(err) {...}` with `if err != nil {...}` when creating a release? Then why use this package after all?
I think for me it was [Go in Action](https://www.manning.com/books/go-in-action), which made me to think more clearly about the possibilities for modelling with a combination of struct embedding and interfaces. Especially struct embedding is an area that I feel is not well covered in the blogosphere otherwise. Resulted in important improvements in the data model in the SciPipe library.
Wouldn't it rather be if err != nil { if myApp.debug { errlog.Debug(err) } // Handle it. } even then, i would prefer to be able to "`errlog.SetActive(myApp.debug)`" and just call `errlog.Debug(err)` instead of the if
I agree on the second part, but concerning the first part: that‚Äôs not the reason errlog.Debug returns a bool
I don't fully grasp the usefulness of this change. The signature constraint confuses me; identical signatures for two methods is in no way a guarantee that they are identical, and there's no word on precedence.
&gt; I don't fully grasp the usefulness of this change. The ReadWriteCloser is a good example. &gt; The signature constraint confuses me; identical signatures for two methods is in no way a guarantee that they are identical, and there's no word on precedence. Identical name + identical signature, and interface methods do not have an implementation.
Still no fix for Go not working in Android Q?
You‚Äôre passing ‚Äúapple‚Äù as the first argument, which is supposed to be the targetLang afaict.
When I started I think it was learning about the line of sight https://medium.com/@matryer/line-of-sight-in-code-186dd7cdea88 Now, I apply that to not only Go. I try to reduce code indentation and end up with very clean looking code :) That certainly improved my code skill.
- ‚Äûjust for func" yt channel - Rob Pike - Lexical Scanning in Go - Mitchell Hashimoto - Advanced Testing with Go Those are my favourites
It is for embedding interfaces. Take these two interfaces: type A interface { F() G() } type B interface { F() H() } Notice that they share the method `F()`. Now, suppose we want to accept types that are both `A` and `B`. A natural thing would be to create an interface like this: type AB interface { A B } This is robust when any of the interfaces `A` or `B` change. However, this isn't currently possible in Go, because embedded interfaces cannot overlap. Instead, you have to currently do this: type AB interface { F() G() H() } This proposal is to allow the embedding shown above. Hope this helps.
For development speed I think Go wins - but despite you asking not to bring it experience is still a factor there. In terms of performance I think both will be fairly similar, the JVM is incredibly well optimised and can handle running very high throughput web services. Out of the two, I would genuinely pick the one your team has most experience with. If you're thinking about building a team, Java may be easier to build a team for too because plenty of people know Java, whereas finding Go developers can sometimes be a struggle (or at least, that's been my experience so far).
development speed wise, I think go is better due to faster compile times, even with hot reloading, I remember running spring tests would take 30s - 1 minute, while go bellow 1s, performance wise I think go is at least on par and has better concurrency, but the bottleneck would be the db anyway.
Go working on Android? Can you explain?
[Go and Go-based programs don't work on Android Q](https://i.ibb.co/X5VPVd4/Screenshot-20190612-091359.png)
GO ! For sure, as your code will be somehow operated and probably put in containers in the future you want to have the process less painful as possible. Think long term.
You described the proposal. What I want to know is which F that would describe.
&gt; interface methods do not have an implementation. Of course. How silly of me.
Unlike with embedding structs, it doesn't matter in this case. `A`, `B`, and `AB` are just interfaces, so there is no concrete implementation of `F()` to choose from. Every type implementing both `A` and `B` interfaces will have only one definition of its `F()` method. And that's the definition that will be chosen. However, the signature of `F` must be the same in both embedded interfaces, because a single type cannot have two methods with the same name.
Who's writing Android apps in go?
The biggest difference is likely to be memory usage. Java gets performance by using tons of RAM. Hello World as a Jakarta EE app is at least 160MiB, whereas a Go version is less than a tenth of that. If you're planning on deploying to a cloud environment, memory costs and ease of deployment can be major reasons to pick Go.
As /u/SYS9000 said, interfaces, by definition, don't have an implementation. That's the part I flubbed on.
I think you're correct that practice is the most important resource to getting better at programming. In a past life, I was a Python dev and I learned the most through personal projects and learning from my coworkers. However, I wouldn't discount the use of books or other resources to help you learn how to write better code. Even then I found books like Effective Python to improve my Python coding and even changed how my team and I wrote our code.
So... all clear now?
Is it a regression and is there an issue for it? Those are requirements for making it into a patch version.
Don't think that's going to happen until 1.13. https://github.com/golang/go/issues/31155
Ah, thanks. I was having the same confusion reading over the proposal. This is helpful!
And that's a bummer. So many things I wanted to do on my Cellphone, but they decided to go against their own cherry-picking policy because "it's in beta".
https://play.google.com/store/apps/details?id=com.nutomic.syncthingandroid
Yes, and yes. They decided to wait for Go 1.13 because "linker changes are pretty invasive" or something no one actually cares about.
There are several stories out there containing the switch from Java to Go. Example: https://www.quora.com/What-made-you-switch-from-using-Java-to-Golang Anyway, ask the same question at r/java :)
Very good summary. &gt; The go tool has little support for binary distribution of packages and what little it has is going to be removed soon. I think it would be useful to elaborate on this point a bit. One of the first questions people ask when they try go is what is the equivalent of cpan, gems, pip packages, npm, maven central etc.
Haha. And he wont know what the right language to choose
I'm pretty sure all developers who know what a linker is don't want invasive changes for a patch to fix a regression in a beta product. Waiting two months for a normal review and release cycle isn't going to hurt anyone.
I think there are more libraries with plenty of features in java comparing to Go
I know this isn't golang related, but I wanted to ask how would you go about fixing this problem then? Is this something that's completely out of my control? Is it a matter of contacting aliyun and asking them what's going on?
&gt; `(*[0]byte)` wuh? are you casting the C func into pointer to a zero-sized array?
there'll either be a configuration setting for this in your setup with aliyun, or you need to contact them.
yes i use it at work.
Ok, would you please explain what's going on in there? Are you relying on that the address of the real function is the first thing in the wrapper? I'm not sure I'm reading this right...
[Practical Go](https://dave.cheney.net/practical-go/presentations/qcon-china.html) is very good, written by a Go developer.
Are you aware that the GPL license precludes me from using your library at work (i.e. when writing code for my $employer)? This might have been conscious decision, but if it was not, this might be something to think through. ---- In either case, your `LICENSE` file must be more complicated than it currently is as you're vendoring external packages with their full source code. They have their own licenses, and their code does not magically become covered by GPL-3.0.
Hmm, what do you suggest? May I change to MIT?
Thanks so much for the materials. I'll be reading through them over the coming weeks while I work on this project. Hahaha you're totally right as well. I've definitely learned most of what I know from derping through the code. Been playing around with it the the last few days and I do think I'm pretty damn close to the solution. I'll be sure to shoot you a link of the code once I've got it figured out.
bryan c. mills' "rethinking classical concurrency patterns" https://www.youtube.com/watch?v=5zXAHh5tJqQ
Start picking up your favorite open-source Golang library and give yourself a bit of time to investigate new things through source code. I'll bet you'll find cool things :)
I think the most important criteria should be what your team is experienced in. If the team is generally much more experienced with Java then go with it and vice-versa. Secondarily depends heavily on the nature of the project. If you could share more details about that, people might be able to give you a better answer.
Is there a reason you don't employ your own cherry-picking policy and build a version of Go where it is included? Official releases need to consider everyone, but individually you can do whatever you want.
Go compiles to ARM so can be used to write programs that work on ARM. Such programs can be used by the "Apps" under the hood. Even though the there is no Android SDK for Go, I imagine using GL, one could even write a GUI android app in Go but it wouldn't be the best decision.
If you'll ever need something more than a single parameter from the query, look at the qstring package. It can do Marshalling/Unmarshalling of URL query strings to structs.
You need to include more information. Preferably more code, and a more clear description of what's "not working" and what you expected to happen. The code you show will only create a request object. It will not actually submit that request anywhere, just create a struct in memory. It is not clear to me if that is the problem in question, or if the problem lies somewhere else.
Actually, I think I've solved it myself, the trick seems to be to declare the function as a const variable instead, such as extern const char bar_function; And then in Go taking the address of the symbol is the function pointer. I'll go through some more tests but I think this is right...
&gt; And then in Go taking the address of the symbol is the function pointer. `&amp;C.bar_function` should be `*C.char` typed AFAICT, but CGo works in mysterious ways.
Yes, but it can be converted easily using `unsafe.Pointer` ...
Go is great, despite what a lot of people think with the constant "It doesn't have &lt;feature that is completely outside the scope of what Go is trying to accomplish and other languages do already&gt;" Don't @ me about generics.
Bait? Generics are coming, so that's an acknowledged "mistake" like everybody said from the start. Better error handling and generics as already in the roadmap will make Go usuable for a lot more people.
Yeah, the need to cross-compile it. I tried to compile it from Android, but I realized *all* previous Go versions were affected, which is to be expected, and I don't have another arm64 Android device with an earlier Android version laying around. I would use someone else's 1.13 `arm64` build if someone has one, though.
I've been work in go full time for over a year. Y'all jelly?
And less usable for even more people. Macros, templates and generics cause less readable, and sometimes/often unreadable code. Thanks, but no, thanks.
I actually think you misunderstand why people want generics with a comment like that. But ok, you will not use Go when generics arrive, got it.
Maybe not an acknowledged mistake in the sense that additional language features are a subjective topic. It's just that many people want Go to have generics so the team decided to add them. Many people also didn't care for the lack of generics so it is not so much an issue of right/wrong as it is of opinion.
What's the issue with error handling? It seems pretty straight forward to me
*I am!* But my personal projects are in Go so I'm good.
There's a reason for the quotes which I didn't want to elaborate on mobile. But yes, in short, it is certainly subjective, but at the same time it's not like a feature would blindly be added by majority vote, since Go's whole appeal is the minimalist attitude and careful feature selection. The lack of generics was clearly flagged as an issue early on, and it's a meme at this point - it's a matter of resisting something quite obvious for a looong time only to finally yield with seemingly no new information on the table. It would be great to hear why the opinions changed on the core team, or if they wanted it early on but wanted to wait and see long term community opinions first.
I understand why people wants generics, but I don't see it as much of an issue. afaiu it was a design choice given the usage that Google tought of Go when created it. They just now realize they could add some features widespread in other languages allowing go to have some stuff that currently are not possible without an infamous number of type checks.
Let's see in 1-2 years how many mainstream libraries and utilities use generics. That's the only way to know if it is truly wanted in the community.
Apparently questioning the use of go for Android development is a bad thing though, around these parts
Yayyyyy
going on 6 years myself ;) Really though, I'm happy to be working in Go. Two others and I introduced it to our org and moved us away from concurrent programming in perl and python. Python's Twisted is aptly named.
[removed]
Oh wow, the mobile styling an the site. I stopped reading. The headers (in particular) and cookie pop-up was a huge turn off to proceeding and further.
Awesome for Go. There's still not alot of love for Rust despite it being the most loved language year after year for people who know it.
Generics is not a mistake. Period.
[just for func youtube channel ](https://www.youtube.com/channel/UC_BzFbxG2za3bp5NRRRXJSw)
It‚Äôs gud.
Right on! Keep on trucking :)
‚ÄúIntroducing Go‚Äù and ‚ÄúConcurrency in Go‚Äù were the two that got me off to a good start. Medium.com has had a lot of good articles as well. However, along with reading I‚Äôve converted several utilities from PHP to Go, this was the biggest help. I am almost finished with a major (and fairly involved) conversion project - lots of head scratching and refactoring. Diving in and coding will get you very far.
4 here....
Question from someone who's barely tinkered with Go. Without generics, is there a type-safe way to handle collections? Or does it follow the interpreted language style of "this is a bucket of stuff"?
Question from a go developer mainly in the Microservices space, where can I read more about some use cases that generics solves that existing constructs does not solve.
Go has some really nice patterns for error checking which are easy to enforce in code reviews and so on. It‚Äôs formatting rules are also laid out without having to go into the whole tabs vs spaces discussion with other team members coming from other languages.
I work with a rust guy and all he does is shit on go about: garbage collection and something he referred to as the ‚Äúrusty diesel rocket‚Äù which sounded like some sort of dirty sex move, but it turns out is just a set of libraries: diesel and rocket.
Likewise I‚Äôve never heard of generics but the Java girl at work blabs about them all the time.
Strongly typed containers for more complicated data structures like Red Black trees are the strongest argument that I've heard (and not something you need every day). If it wasn't useful, slice and map wouldn't be generic.
&gt; for people who know it Fewer people --&gt; less love.
Dope, thanks for this one