Have a look at Elixir and Phoenix. I've used Go for about 4 years and am learning elixir. With Go I find I can't create small functional units the same way I can in JS. I seem to have to do lots of for loops. Also type safety in go only go's so far. I find I get a log of nil exemptions from initiated data. The lack of immutability leads to hard to find errors. I believe Elixir leads to simpler to reason about code, especially in the context of a web server. Plus the concurrency support is probably better. Maybe it's just having dived into functional JS that has ruined me for Go.
Big thanks.. a map was what I was missing! - I've gotten [here so far!](https://play.golang.org/p/4ucN97nnvp)
TLDR at bottom. I started my Uni life in C. I did some games programming in C++...fast and wonderful stuff but then I tried python. Holy shit the syntax. It was like I was holding my breath all this time and suddenly just gasped. I could breathe. 99% of questions I had were on stack overflow or within a few clicks. soo good. Development became about the problem and not the language. With python I got into web development. I perhaps foolishly used web.py, which got its start in the reddit backend, and although I found it very pleasant and out of your face (but useful), it was slow as hell, and I could feel it. I know it could be sped up, but that took the complexity up to a point I was no longer comfortable. I then was about to embark on a new big project. Good opportunity to see what else is out there. I did a whole bunch of research, especially on web frameworks, and Go kept being interesting. It wasn't as fast as the hardcore stuff (C++/C/Java), but generally was way faster than python. It was a compiled language, and compiled fast (yay fast like python but also fast like C++). It had *some* community support, but also had Google Engineers behind it. It had concurrency (something I dabbled in with C++, but man what a pain that was). Python just lolled in my face when I asked it to multithread. I read what the designers had wanted for it. They were influenced by Python and C++. It's going to be somewhere in the middle...fucking perfect! That's how I took the plunge. I've spent about a month learning the basics (and forgetting it all), then trying a few different frameworks out there. So far I've been pretty disappointed by them. Iris actually looked pretty good and the guy is commiting to it *all the time*. But he's got an incredibly toxic reputation, so sad. I spent a lot of time getting Gin to work, but it doesn't do enough and I have to figure out how to make other code work with this code, when I'm still pretty nooby about Go in general. Yesterday I said enough and started again with fasthttp / fasthttprouter and kataras's go-session. I got it all working together; the page serving, static serving, basic database, authentication, sessions. I'm about 30% of the way to where I was in with my python framework. I haven't needed a huge amount of help from places like stackoverflow, because the code is relatively simple to figure out. The error messages help me figure it out 90% of the time. That's actually a huge timesaver. TL;DR; because I love C++'s speed but hate C++'s long ass way of doing everything, and I love Python's syntax but hate its slowness. Go is in the middle somewhere and does parallel as an added bonus.
Only 3x? I've found Go can start off at 20x less memory usage in certain cases.
About an year ago I started working on Fider ( https://github.com/getfider/fider ) The reasons I chose Go were: - It's simple and easy to learn - Single binary output. This is a big win! - Few runtime dependencies. My docker image is only 8MB large. - It's fast and has low memory footprint -&gt; less money spent on servers - The popularity is increasing The bad: - `html/template` is not good enough for webdev, which is why I chose React for the view components. - Generics? haha :) - Folder structure is more strict than any other languages
But‚Ä¶ why not just use Python?
&gt; * smaller ecosystem; This is something I've noticed - but you only notice it when you step outside of common tasks, and even then, only sometimes. For what Go is usually used for, there are some extremely solid library choices. &gt; * higher entry level; Go is designed to be easy to learn, and frankly, it is. It's a very consistent language, with great documentation, and a great set of introductory material to get you started. The language itself is small, and the standard library helps you get things going without having to learn about loads of other libraries too. &gt; * web-frameworks in an early-stage, rising and dying everyday; Many people don't use frameworks. I don't really care if people do, but personally I don't. If you're using Go for what it's good at in the context of the web (i.e. web services, not applications) then you'll likely find you have a better time just piecing together libraries. &gt; * weak integration with modern webdev workflow. Not sure what you actually mean by this. You expose endpoints, something else picks it up. It's a very modern approach indeed. Sure, you're not going to server-side-render your React app with Go (probably anyway), but you still have the tools that are good for that at your disposal. There are a LOT of reasons to choose to use Go, some of which I've hinted at above. It's just an all-round solid language. I went hunting for a new language to learn coming from PHP, and I wanted something with a great developer experience (fast workflow, good tooling, good editor support, etc.) and Go fit the bill bests out of every language I found. It's got a decent community, a good set of libraries, and the features of the language are a careful balance that works well to keep code simple. Another language I tried was Scala, and I did really enjoy it at first, but then got bogged down in the language complexity, and the terrible developer experience (incredibly slow compile times mainly - seriously, it's insane how slow it is). I do miss the type system from Scala sometimes, but generally the trade-off is worth it to be using a language where I can dig around in the standard library and understand how it works because the language is so clear.
Go has a similar pace of development as dynamic languages, but with the debugging and reliability benefits of static typing.
https://play.golang.org/p/B6GhzQ_JmE - I eliminated a bunch of excess code. The result is printed out. If you want a slice instead of a map at the end, you'll just need to range over it once more. You can create it efficiently with `s := make([]Containers, len(m))` and then append() each without additional allocations. Edit: here's a slice result as well: https://play.golang.org/p/St6-BOxSY6 as I'm in the mood :)
I'm repeating some others, so I'll keep it short and specific to my experience. My previous team didn't use web frameworks in Go. With a basic understanding of http, we felt any developer could use Go for web with only a little learning. That was validated through rapid hiring of green CS grads. Frameworks like Rails, ASP.net, etc are great for the opposite reason. You need to know what to do to get all the time savings, and once you know how it works, maybe it can save time. However, your knowledge of how routing works in Ruby or ASP.net isn't necessarily going to help you with another language (or even simply a different version of MVC). You might think you're an expert but never realize how many side effects a method brings to the table. Being explicit and no-frills makes it easy for experienced developers to jump in on a Go project even if they aren't Go developers. All the magic in other languages--regardless of how helpful--is a barrier to entry if you don't use it all the time and forget where the magic resides. I'm now on a team that uses only C#, but with only a couple dozen keywords in Go and explicit, bare concepts, I know that I could come back in a year and have little warm-up time. When a couple extra lines of code here and there avoids a dependency, I think most Go devs tend to avoid the dependency, keeping code explicit and easy to reason about at a glance. In a career where most of my time is spent trying to determine what is happening, I would rather that get out of the way first so that I can start writing code--even if the code is slightly more verbose by some measures.
Jokes aside, the JetBrain vim plugin is the best one I've ever used.
So, I don't think it's technically accurate to say that skylark is not turing complete. The definition of turing complete is very broad. Yes, not having recursion is kinda annoying, but you can avoid recursion and still write anything you want.
This is embeddable. i.e. you can have your Go binary run python-ish scripts (like as plugins / advanced configuration) without needing to worry about having python installed.
I just updated and my problem is fixed ... cool. Main thing I'm missing is tab completion for the commands. It makes discoverability hard. edit: This doesn't work :action CloseActiveTab 
That at least sounds like what I'm talking about. Basically I want something that, when dumped out, can be used to see the entire routing table and diagnose what's going wrong, since once you get past little sites routing tables tend to get nontrivial distressingly quickly. Or at least they do for me, because I'm almost always trying to support backwards compatibility for any number of previous versions of the web site with poor decisions made....
C++ has memory management. Maybe you meant garbage collection
Well, you'd have to have some code that ties all the bits together, they certainly don't end up automatically concatenated. But basically, yeah. Design packages to bundle things together meaningfully, don't break things up the some way for everything. I tend to be a bit package-crazy by what seems to be common standard in the Go community, because I like the way a package can be a self-contained thing that can be understood by someone by reading the godoc, so for me, I don't have a problem with a package that has two types and a function in it or something, because that means I've taken whatever that functionality is and walled it off well enough that someone should be able to understand it just by understanding those two types. I would probably even break up "users" vs. "the code that interfaces between the web and the users concept". But I'm not really advocating for that, because like I said, by community standards I'm probably a bit package crazy. I've got a personal web framework that's not even entirely done and is certainly just one dude's spare time work and it's already up to 18 packages, whereas a lot of Go frameworks are all in one package. But if you want to understand "how this framework handles cookies", you can go to the `cookie` package and it's all laid out in the godoc.
"The lack of immutability leads too hard to find errors" explain?
We used Node.js at our company and constantly had to deal with issues like: * type issues and weird conversions (especially by new programmers) * memory leaks/bloat without good tools to find them (we were on a relatively memory constrained system) * logic bugs due to complicated flow * difficulty in training new devs We switched to Go when I demonstrated a working example of our app within the time that it took to resolve one memory leak (about a week) by our team. I then had a memory leak in Go and was able to fix it in ~15 minutes and my boss was sold. Here are some nice benefits we noticed over Node.js: * easier to learn (most devs were very solid after a week or two) * low memory footprint, so we could do more with less * fantastic profiling tools (trivial to find CPU and memory hogs) * scales well * pretty good ecosystem and fantastic standard library (we have about a dozen dependencies, and we can actually vet them all; in JS, there were dozens of top level libraries and perhaps hundreds in total) * gofmt and godoc are great * strong typing (easily my biggest complaint about JS and had prevented tons of annoying bugs) * simple concurrency (channels are way better than async/await) Now, Go isn't my favorite language, but it beats the pants of anything else for most web dev tasks.
These are reasons to test Go, but they aren't reasons to use Go day by day.
Memory constraints, concurrency, and ease of deployment are the main technical reasons I can see for using Go over Java. More generally speaking, Go is in kind of an awkward place right now. It's easier to build complex systems with than C, but it lacks generics so libraries are difficult to make compared to languages like Java, PHP, Python, and Ruby. I believe that if we get a good generics implementation, then we will see a lot more content management systems migrate to it.
I'd add that one of the reasons that I think Go is getting big in the backend is that concurrency is generally more important than people think it is in that context. 20 years of developing web backends with the 1990s dynamic scripting languages, which for a lot of that time had no concurrency story, and then generally a very partial one supported only by very specific libraries, trained an entire generation in thinking in a very single threaded way, to the point that I routinely see claims that web sites simply never need concurrency. This is false. Modern websites are abundantly in need of concurrency for both performance and functionality. Once it's easy to use you'll find all sorts of uses, from things as simply as making two API calls to other backend services at once instead of making them in sequence, to things like realizing that "Hey, implementing a chat system is actually pretty easy now". Once you add it to your toolset, it's hard to go back. Node can make _some_ of those cases easy ("make two calls and get back to me when they're both done" is not too difficult), but when you start really getting into it it tends to break down, even with the latest async stuff. The other myth that I think has some effect here is that since processors stopped speeding up for free every year, performance does in fact matter, and people nowadays grossly overstate [the ability to ignore performance because everything's "IO bound"](https://news.ycombinator.com/item?id=15347869). Go is much faster than normal Node code, and can often be written even more efficiently if you try, not to mention the ability to run a program on all the CPUs is really helpful too. If you _really_ need to push performance, Go isn't necessarily the right choice, but if you'd like to "go pretty fast but not spend _that_ much developer time doing it", Go's in a fairly unique position right now on the cost/benefits chart. There are some upcoming languages like Nim or Crystal trying to take a similar position, but neither of them are anywhere near as mature as Go right now.
It's a nice construct, and use it. But don't like the two func() arguments to group.Add(). So use an interface with two methods. Making stuff conform to that is trivial given go's ability to add methods to types. Eg type ch chan os.Signal func Signal(sig ...os.Signal) group.Actor { c := make(ch, 1) signal.Notify(c, sig...) return c } func (c ch) Start() error { return Error{&lt;-c} } func (c ch) Stop(err error) { signal.Stop(c) close(c) } func Interrupt() group.Actor { return Signal(os.Interrupt) } 
&gt; smaller ecosystem; People throw this word around but never care to define exactly what it means. Go has a useful set of standard libraries that are very well documented. There are also many Go users, libraries for database interfaces and protocols etc.. I guess that "ecosystem" in this context would include things like millions of tutorials on how to do anything and libraries that supposedly offload trivial work from the programmer. I believe that those are things that node.js has because it suffers from problems that Go does not have. &gt; higher entry level; I disagree, but let's face it: it's a matter of background and opinion. I learned Go in a couple of days. Its syntax is simple (unlike Ruby), its standard libraries are simple and cruft-free (unlike Java and C++), it's statically typed and it compiles quickly. Languages I'd used extensively before were C and Python, mostly Python for web services. Python was fine, but it's slow and dynamic typing is a huge source of errors. I still get confused when I read Ruby code, and a modern JS project build system is a whole science in itself. gulp this, yarn that, npm the what now, babel, uglify, 10s of dotfiles... That imposes a high barrier of entry. &gt; web-frameworks in an early-stage, rising and dying everyday; What, specifically, do you want out of a framework that the Go standard library doesn't offer? Most modern web applications are going to have a fat javascript front-end consuming a bare API on the back-end. What you need to be able to do depends on the application, but perhaps typically, serialize data structures to JSON, interact with a database, consume some external APIs. Go is suited for this type of work out of the box. A working, concurrent web server is maybe ten lines of code. &gt; weak integration with modern webdev workflow. What is this workflow? Certainly not mine. For most projects, it's just `go build` and my application is built. For trickier situations I use a Makefile (for example if there is also a front-end build step). `make`. Done. &gt; Why people choose Go for webdev? It's fast, statically typed, garbage collected, has a great set of network libraries and as a new language it had an opportunity to learn from past sins. Its use of threads and co-routines and communicating using channels makes it easy to utilize CPU resources.
I think the guy was referring to smart ptrs and ownership and whatnot. One of the things that makes modern C++ so sick is that you can completely avoid a lot of that stuff.
Wow, that book suits my current situation. I'm a pro php dev who was looking at Node.js for a couple project APIs because of my familiarity with JS, but lurk here in /r/golang because it interests me more.
Strangely enough, I find the bytes version the most readable.
Maybe it helps if considering the original use case for type aliases: To support *gradual code repair*, as outlined [here](https://talks.golang.org/2016/refactor.article). The goal is to move a type from one package to another without breaking client code that still refers to the type in the old package. Then, after all client packages have been refactored to refer to the new package only, the alias can be removed and the old package can be retired. So the original intent was to use type aliases only temporarily during phases of refactoring. (Which IMHO does not exclude any other use that seems justifiable.) For your use case (of using a type alias permanently as a shortcut to a type in another package), I see two main consequences: * Easier to write (as you said, this saves some typing) * But maybe harder to comprehend when reading the code (as the reader loses the mental reference to the `models` package.) - - - Edited to add: In the end, using a type alias this way is almost like using a dot import. As you point out in another comment, the downside of dot imports is namespace pollution, and obviously the same applied to type aliases, too.
I moved my modest collection of web apps from Python to Go. Why? Because it was fun to implement a complete application stack myself, and Go negates most of the reasons why doing that in other languages is a bad idea.
I've switched mostly from Node to Go, but when I have to work in Node, I use it with Typescript and ts-node. It brings a bit of sanity.
I'm tempted to say that you should almost always optimize for readability first and then go profile and performance optimize nicely written working code with good tests.
malloc/free (and new/delete) divvy out little bits of memory owned by the C or C++ runtime that's ultimately managed by the kernel, sure, but there's not a 1:1 correspondence to syscalls. It's still very manual, since you have to explicitly free the resources, but the runtime does do a great deal of resource management.
Possible, it's been a while since I did some c/c++ projects, but what I see still has significant emphasis on self-handling memory.
You would not be wrong :)
This is pretty easy with Go: https://golang.org/pkg/encoding/json/#example__customMarshalJSON
Well no version is wrong, but they have some difference when it comes to cognitive load reading that code. Would be interesting to benchmark them all to see where we would end up...
noooice!!!
Yup, CLi or sidecar agent for example, easily 20X smaller. 1GB vs 50MB.
Slightly tangential, but - It irks me that there is this notion bandied about that all modern day web apps are composed of an api with a client side framework in the front (React, Angular, VueJS, etc..). In my experience it is no where near that level of ubiquity. Traditional server-side web applications using X framework/language are still very much a thing, and I would argue are still the norm. Go can certainly work well in this space, but if you come to Go expecting a framework like asp.net mvc/rails/etc... you will be disappointed. Yes, some of these exist but IMO there is no "one web framework to rule them all" with consensus by the community. My approach has been all about finding a middle ground between using the stdlib, and piecing together a set of small well-known libraries to handle things like CSRF tokens, session, etc. It's more of a roll your own approach, but is what I would strongly recommend if you are looking to build a traditional web app using Go.
[removed]
You mean modern C++ better or worse?
The spec on the repo itself calls it not turing complete. 
OK then :) I hadn't seen the language spec... that's really good to know. Though I still think that in practice it's probably not a big deal for most uses. And actually, if your code is calling out to user-created code, it probably is better to avoid allowing unbounded loops etc. 
Web-frameworks rising and dying? Maybe... because many people realize they don't need one. I came from PHP where I mainly worked with Symfony. When I switched to Go I first looked for a proper framework. I've tried so many... but every time I hit a point where the framework actually hindered development or I had to work around it to get XY to work. Nowadays I only use the standard library and packages that make my life easier, f.e. router package. I'm way more productive writing websites with Go and my code is less buggy. And yeah, performance. So far I haven't encountered an area where I was like: fuck... what am I going to do? "weak integration with modern webdev workflow" ... please provide a concrete example.
What are you missing with html/template?
That's a very gentle introduction to statistics in Go using Gonum. That will help me tons in a new endeavor of writing financial apps in Go. Thank you very much!
The names .Ref() and .Free() seem bad/confusing, why not just reuse .Add()/.Done()?
You can write a [custom handler for your subdomains](http://codepodu.com/subdomains-with-golang/), or you can use a [router who has support for domains](http://www.gorillatoolkit.org/pkg/mux) already build in.
I haven‚Äôt seen this reason yet and it‚Äôs probably the best reason to use Go: Web apps, especially back-end processes are I/O bound, meaning the performance bottleneck is usually due to waiting for data or responses from other networked endpoints. (As opposed to traditional apps that are typically either CPU or memory-bound) You have two choices when you are IO-bound, you can block execution on the current process (synchronous) or yield some of your time to other processes since you are just waiting (asynchronous). The latter is the obvious choice for a scalable web app since you can expect a lot of waiting for many concurrent users. You can absolutely do asynchronous processing in your favorite language, but you can expect a little or a LOT of complexity to accomplish that, depending on the language. Go is built asynchronous from the start with no special understanding to get there. It‚Äôs an extremely powerful use-case for features that broker/process messages across a web apps that, more and more, are being distributed and deployed across geographic boundaries. 
That would be sick in the meaning of better, yes üòÇ
He literally said "memory management (garbage collection, etc.)", so obviously that's what he meant.
Is Go popular in the same space that Rails is? I haven't seen a lot of evidence of that. The common pattern that I see is using Go to build beautiful, clean, performant APIs and then use a front-end stack like React or Elm to provide the UI. I would say Go is more of the use case of a micro-framework or micro-services and I use it because it makes it easier to write correct, high performance code.
for more, see: - https://github.com/sbinet/jdev-go-datascience-2017 - https://talks.godoc.org/github.com/sbinet/jdev-go-datascience-2017/talk.slide#1 
Go is more influenced by the Modula languages than C++. It's basically going back to C and doing OO again in a different direction, avoiding C++'s mistakes.
Well I'm going to present a different view. I'm heavily committed to Go (https://github.com/anacrolix), and tempted to return to Python or Haskell daily. Go does a few things well, goroutines, native compilation, and the URI based package namespacing. However its error handling and type system are woeful, interfaces though at first appealing, aren't sufficient, and its performance, while amazing next to Python, is nowhere near C. Of course people will disagree with that, but there's always something not optimal in Go that needs work, and all the little overheads that don't exist in C add up. Cgo is also absurdly slow. Go is like C++: it owes its success to how similar to C it is, but it is also held back by it. (Register sized ints, fixed memory layout, crappy syntax, to name a few). Both languages need to let go of C, but to do so means coming out from under its wing.
That's why [zap](https://github.com/uber-go/zap) doesn't use `sprintf`. Just another example of the standard logging system's deficiencies.
Ah, reading it now it makes so much sense, yet I was having a brain block looking at it earlier. I'm still learning so big thanks!
I don't think Go replaces Django/Rails, if you're doing a standard crud app - especially if it's server rendered - then Django/Rails are still way better. Go works best with the modern JS SPA frontend with API-only microservice backend style of web application. For those things, you could use Django/Rails but they come with a lot of unnecessary baggage for that context. 
Nice little app! FYI: if you want faster responses without polling, you can listen via the websocket api for specific tags. That tends to scale better and use less bandwidth if you are listening to large numbers of tags.
Huh. I was playing around with this, trying to get it to break (maps tend to break catastrophically if you can change the value of a key after it has been placed in a map) and once I realized this is indeed safe, I learned something about Go that I had not really processed properly: A purely value-based type that you only have access to via an interface is, I believe, immutable (give or take unsafe and/or reflect). Even if it is of a public type and thus you can can type cast it into that type, the type cast will produce a copy of the value that you can now mutate, but the original is still unchanged. [I see this has been used before](https://godoc.org/github.com/mndrix/ps), so I am not claiming this is a novel insight to anybody else, but it is new to me.
It has good concurrency primitives mainly. &gt;Most Go frameworks I've seen even can't came close to 3-years-ago-Rails or any other high-level webdev toolkit Okay but Ruby/Rails is also incredibly slow. &gt;a lot of people still are re-implementing the same things, which were written in other langs and work well. Not really. Like I said, Rails is very slow. Probably bug-free too but that doens't mean it's unworthy of replacement.
Nothing is missing, it's okay for small and static pages. Hugo is a very good example. But for complex pages with multiple conditions, loops, formatting and events, the templates becomes very hard to understand and maintain.
Like those mean anything?
&gt; VIM modes in other editors Not talking about other editors, I'm talking about the vim plugin for Gogland. You need to try it... it's quite robust. Even splits panes in the IDE when you use the VIM command for window splitting.
please send it to form.justforfunc.com thanks!
thx!!!
&gt; but it lacks generics so libraries are difficult to make compared to languages like Java, PHP, Python, and Ruby. Your choice of PHP, Python, and Ruby are interesting. Go already has 'generics' of that kind. I expect that is why Go seems to be gaining the most adoption from people coming from Python and Ruby (rather than C++ and Java), as it works just like the languages they are already familiar with.
&gt; Your choice of PHP, Python, and Ruby are interesting. Go already has 'generics' of that kind. No, it does not. The empty Go interface requires casting to use, which means it fundamentally cannot be used in the same manner.
RemindMe! 7 days "ycb issue"
I will be messaging you on [**2017-10-11 18:40:43 UTC**](http://www.wolframalpha.com/input/?i=2017-10-11 18:40:43 UTC To Local Time) to remind you of [**this link.**](https://www.reddit.com/r/golang/comments/741xeb/is_possible_to_do_conditional_unmarshalling_for/dnwo4fa) [**CLICK THIS LINK**](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[https://www.reddit.com/r/golang/comments/741xeb/is_possible_to_do_conditional_unmarshalling_for/dnwo4fa]%0A%0ARemindMe! 7 days ) to send a PM to also be reminded and to reduce spam. ^(Parent commenter can ) [^(delete this message to hide from others.)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Delete Comment&amp;message=Delete! dnwo5bu) _____ |[^(FAQs)](http://np.reddit.com/r/RemindMeBot/comments/24duzp/remindmebot_info/)|[^(Custom)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[LINK INSIDE SQUARE BRACKETS else default to FAQs]%0A%0ANOTE: Don't forget to add the time options after the command.%0A%0ARemindMe!)|[^(Your Reminders)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=List Of Reminders&amp;message=MyReminders!)|[^(Feedback)](http://np.reddit.com/message/compose/?to=RemindMeBotWrangler&amp;subject=Feedback)|[^(Code)](https://github.com/SIlver--/remindmebot-reddit)|[^(Browser Extensions)](https://np.reddit.com/r/RemindMeBot/comments/4kldad/remindmebot_extensions/) |-|-|-|-|-|-|
He said Java cost 3x more than anything, not more than go. Pretty much tracks with my experience, I'm sure you're right about how much more memory efficient go is in particular. Java is just generally terrible (at using small amounts of memory) though as well as in comparison to go.
This is true, I wouldn't recommend using more than one or two c-archives or even c-shared libraries. Sometimes you just need to get shit off the ground fast and improve later. :/
&gt; The empty Go interface requires casting to use Only when you are trying to bridge dynamic and static types. &gt; which means it fundamentally cannot be used in the same manner. I'm not sure I agree that it is fundamental. If you want to use the standard library and most packages that rely on static types it is necessary to bridge that gap, but conceivably you could avoid it.
Release Notes: https://docs.aahframework.org/v0.9/release-notes.html
Interfaces (not the empty interface) are very like duck typing in python or ruby, but with an explicit contract. I'm not sure why a CMS requires generics, or even why they'd make it easier. 
Hmm, they said "for anything", in the go sub, it seems like they're talking about compared to Go to me. But either way it does still work, there JVM does use a ton of memory. I mean, there is a reason for it I suppose, but it can make a lot of things painful...
Amazing reply, helped me understand a lot more about why it's being used in backend, also I'm honestly surprised noone has added generics properly in a fork yet
If it is simply for reducing keystrokes, why type aliases over 'dot' imports? The latter only requires two extra characters per package. From a software engineering perspective, based on your description, I find myself asking if Transaction is actually a separate concern that warrants a separate package in the first place? To pick a random example from the standard library, the `http.Client` type is controller-like and the `http.Request` type is model-like, but they live in the same package as they are of the same concern. I would suggest that if you have good reason to think of these as a separate concerns, I think it warrants letting the reader of your code explicitly see it as a separate concern. Aliasing the type makes it a local package concern, in which case, in your case, you may as well ditch the alias entirely and move the entire type into that package. In fact, your example exports the `controllers.Transaction` type, which may be unintended for consumers of your package.
"3-years-ago-Rails" isn't something that anyone should be *trying* to come close to.
Sure, but buying some more RAM to server is cheaper than buying 20x as many servers just because you decided to use Ruby
You can just change memory settings if you really want to make java cli tools. The bigger problem is boot time. Starting jar takes seconds, enough that you could *compile* Go app, run it, and it will still be faster
This. So much this. I used to develop Rails apps and anytime I wanted to find out what was going on in a specific gem I had to claw my way through 15 super class calls, or read half a dozen blog posts - most of which were opinions or glossing over the subject. Go package you installed isn't working? Hop right in and fix it. Is some cases you might have to dive into a factory or an interface abstraction, but it's easy to find the culprits when fixing bugs.
Actually, I can shed some light on that too. Go has a pretty active development cycle, where a new minor version gets released every six months or so. Maintaining a fork would be a lot of work, because the improvements being made to Go are significant. Just the performance improvements from version to version are substantial. A lot of generics features are implemented as code generation projects, which are somewhat feature proof if you would decide to use one. It obviously doesn't provide first-class generics in the language, but to be really fair, or realistic, generics are a means to an end. If people can do something with code generation, they just do it and mark the problem as solved. The problem remains, when code generation isn't practical for whatever reason. There's always a vocal part of the community that wants different forms of generics, and I for one hope that they will be considered for a future release of Go. The core team did ask for experience reports, and I hope they manage to produce an "essence" of what the general problems are that require generics to solve.
I apparently missed 1.14. Glad I can use foldmethod=syntax now! This was an even bigger update for me :)
Ref/Free were choices of expediency, but I agree. What are your thoughts on `Incr()` and `Decr()`, i.e.: increment/decrement ?
Yeah, but I can dodge both bullets with Go :)
/u/peterbourgon - How about this for closing an http server ? // Start the server in a separate goroutine func (h *HTTPInterface) Start() { go func() { err := h.server.ListenAndServe() // this always returns a non-nil error, // so just check whether normal shutdown hasn't occurred if err != http.ErrServerClosed { h.loggerError.Fatal(err) } }() } // Stop the http server gracefully func (h *HTTPInterface) Stop() { h.loggerInfo.Println("Stopping HTTP server") ctx, cancel := context.WithTimeout(context.Background(), httpGracefulShutdownTimeoutSecs*time.Second) err := h.server.Shutdown(ctx) if err != nil { h.loggerError.Println(err) } cancel() } httpi := &amp;HTTPInterface{ loggerInfo: li, loggerError: le, server: &amp;http.Server{ Handler: r, Addr: listenAddr, WriteTimeout: httpWriteTimeoutSecs * time.Second, ReadTimeout: httpReadTimeoutSecs * time.Second, } } httpi.Start() httpi.Stop()
For a language with C-like performance and a great type system, check out Rust.
X-Post referenced from [/r/rust](http://np.reddit.com/r/rust) by /u/CUViper [Red Hat adds Go, Clang/LLVM, Rust compiler toolsets; updates GCC](http://np.reddit.com/r/rust/comments/74acqo/red_hat_adds_go_clangllvm_rust_compiler_toolsets/) ***** ^^I ^^am ^^a ^^bot. ^^I ^^delete ^^my ^^negative ^^comments. ^^[Contact](https://www.reddit.com/message/compose/?to=OriginalPostSearcher) ^^| ^^[Code](https://github.com/papernotes/Reddit-OriginalPostSearcher) ^^| ^^[FAQ](https://github.com/papernotes/Reddit-OriginalPostSearcher#faq)
FWIW, we also have an opening for a Golang toolchain engineer: http://bit.ly/redhatgolang
The limitations of the Go type system are well documented. Go's twist on interfaces helps, but does not completely fill the gap. I'm frankly surprised that mentioning this is _still_ seemingly controversial. I would suggest spending more time fooling around with frameworks in the previously mentioned languages to get a better understanding of what their type systems let you do.
An easy way to understand the abilities of those languages is to look at the libraries that exist, and investigate why they don't have counterparts in Go.
I have to say, I probably didn't give it a totally fair try yet, but initial impressions are that you may be right. It's better than other VIM emulations I've tried recently. However, I'd still lump them all together and say it wasn't good enough for it to be useful for me.
This is a great talk that explains why mutable data can easily be very problematic and also what immutability does to help: https://m.youtube.com/watch?index=7&amp;list=PLuVqdWOQ-PNkImAnAzU8QJ9g28VNlP-jG&amp;v=6TKI-TK__3c
Thanks, I was looking for something like that, but I didn't find anything on https://api.stackexchange.com/ Do you know where I can find the doc for their websocket API?
Thanks for the information, good to know it's a very actively updated language
They are the same number of characters and say what they do, so +1 :). I'd still be tempted to make the API the same as WaitGroup though.
&gt; The limitations of the Go type system are well documented. Sure. Nobody is suggesting otherwise. That isn't what we are discussing though. &gt; I would suggest spending more time fooling around with frameworks in the previously mentioned languages to get a better understanding of what their type systems let you do. Just how much time are we talking here? I started fooling around with Rails the very day it was released upon the world and started a job using it professionally a few months later. I've been using it full-time for more than a decade now, from back before it was even a 1.0 to the latest version. Is this meant to be one of those *"needs 20 years of experience in &lt;insert five year old technology&gt;"* kind of thing? &gt; to get a better understanding of what their type systems let you do. I am quite familiar with their type systems and have used all of those languages extensively over the years. Perhaps you should be more specific than 'go fool around'?
I would like to add to this excellent post by drumming on the "you don't need a framework the stdlib is awesome". It surprisingly is and can get alot done but as soon as you feel the need to bolt on functionality to the stdlib I will almost guarantee no matter what it is, someone else has probably made an excellent library which does it for you so have a search first and include it. The community has gravitated more to abusing the stdlib and just including small specialised packages as they need them or as it makes sense per project. I.e unless I need dynamic routing or controlling splitting request methods I will not include gorilla mux router and just use the stdlib router. This mindset means many small specialised packages exsist that still leaves you in control of the style of implementation which I think most gophers like myself love. Don't get me wrong frameworks that are very good exsist such as buffalo and can let you pump out stuff very quickly. But I personally just use it as a learning resource to discover more awesome third party libraries, since I didn't dig the style of the frameworks opinionated implementation (So even as a resource to just take the bits you want it's great). 
We used to use the same technique to implement a copy-on-write tree in go-ethereum. It comes with non-zero overhead though.
Good idea. Looking at COBOL there is a wealth of banking and finance-related libraries that I don't see available for Java, PHP, Python, Ruby, or even Go. What is it about the language of COBOL that you believe makes it best suited to writing banking and finance-related code that isn't present in these other languages? Why would you choose COBOL if you were starting a new banking/finance application today?
&gt; Sure. Nobody is suggesting otherwise. That isn't what we are discussing though. Well it's exactly what I'm referring to. Sorry, but given your supposed experience and this statement, it's just obvious you are wasting my time. Have fun either copy, pasting, and editing every bit of code you need for operations on collections or using reflection for everything.
Here is a good write up about what I'm talking about https://blog.codeship.com/comparing-elixir-go/
This comparison doesn't make any sense and you know it. Financial institutions are stuck with COBOL for logistical reasons, not because the same problems cannot be solved with other languages more elegantly. Nice try with the straw man though.
If it makes no sense why did you reach the exact conclusion I wanted you to consider? The logistical reasons that prevent a financial institution from rewriting their financial code in another language are also present in rewriting a CMS in another language. Financial software was written in languages like COBOL simply because that is what the popular languages at the time were. The same goes for the CMSes that have stood the test of time, which were implemented in the languages that were popular at the time that kind of software was needed. Now that CMSes are widely available and adopted, what logistical justification is there to rewrite it in a newer language? Exactly. There isn't one. So why would you ever expect to see a CMS written in Go? Your argument is silly.
&gt; Two security-related issues were recently reported. &gt; To address this issue, we have just released Go 1.8.4 and Go 1.9.1. &gt; We recommend that all users update to one of these releases (if you're not sure which, choose Go 1.9.1). &gt; The issues addressed by these releases are: &gt; By nesting a git checkout inside another version control repository, it was possible for an attacker to trick the ‚Äúgo get‚Äù command into executing arbitrary code. The go command now refuses to use version control checkouts found inside other version control systems, with an exception for git submodules (git inside git). &gt; The issue is tracked as https://golang.org/issue/22125 (Go 1.8.4) and https://golang.org/issue/22131 (Go 1.9.1). Fixes are linked from the issues. &gt; Thanks to Simon Rawet for the report. &gt; In the smtp package, PlainAuth is documented as sending credentials only over authenticated, encrypted TLS connections, but it was changed in Go 1.1 to also send credentials on non-TLS connections when the remote server advertises that PLAIN authentication is supported. The change was meant to allow use of PLAIN authentication on localhost, but it has the effect of allowing a man-in-the-middle attacker to harvest credentials. PlainAuth now requires either TLS or a localhost connection before sending credentials, regardless of what the remote server claims. &gt; This issue is tracked as https://golang.org/issue/22134 (Go 1.8.4) and https://golang.org/issue/22133 (Go 1.9.1). Fixes are linked from the issues. &gt; Thanks to Stevie Johnstone for the report. &gt; Downloads are available at https://golang.org/dl for all supported platforms. &gt; Cheers, &gt; Chris Broadfoot (on behalf of the Go team)
&gt; Sorry, but given your supposed experience and this statement, it's just obvious you are wasting my time. If you don't want to discuss the points I have raised, why do you keep replying? &gt; Have fun ... using reflection for everything. Why, yes, I did say I use Ruby. And yes, I do have fun using reflection for everything in Ruby. It kind of a fundamental part of the language. Truthfully, with that aforementioned 'supposed' experience I feel like Ruby's reflection has become a negative aspect of the language, but since you seem comfortable with it that's cool.
Go is cross platform. You can also cross-compile very easily and it seems to work out of the box. Static typing is good. Native binaries with zero dependencies are good. Performance is good. Go does not lend itself to building "layers upon layers" of abstractions. This can be a minus point for a lot of people, but experience shows that too much encapsulation and information hiding leads to difficulty understanding and debugging erroneous code. Here's what a typical python development looks like: You happily follow the tutorial, coding the happy case/scenario. Then slowly things get complicated and (largely because of dynamic typing) you no longer have any idea what is what. Development slows down, and things that should take a couple hours to make now consume several days. Small bugs/issues take hours to track down and fix (again because dynamic typing). Code that is doing simple numeric computations is very slow. Deployment is complicated. Setting up development environment is complicated (virtualenv, etc). At some point you get disillusioned and say, fuck this. Go is not ideal but it's among the better alternatives. The fact that it's used by Google makes it easier to convince other team members that it's a safe bet to go with (as opposed to D for example which seems obscure, not to mention it's too complicated a language). 
&gt; Now that CMSes are widely available, what logistical justification is there to rewrite it in a newer language? Exactly. There isn't one. My organization has been working on a new CMS to replace our custom WordPress stack for numerous good reasons. Go was disqualified due to issues with language design and package management, even though we use it internally for CLI utilities.
I think that's part of it. There's also - the work-stealing scheduler reducing context switches - lack of preemption and no strong attempt at fairness reducing scheduler overhead
&gt; My organization has been working on a new CMS to replace our custom WordPress stack for numerous good reasons. And there is a bank [written in Go](https://www.infoq.com/presentations/bank-go). I'm not sure anecdotal projects are indicative of anything. &gt; Go was disqualified due to issues with language design Specifically generics, as you mentioned earlier. However, you haven't exactly made it clear how generics would suddenly make Go suitable for writing a CMS. In fact, you seemed to go out of your way to avoid that question by making your own straw man argument about looking at libraries in various languages.
We don't want to have to copy/paste copious amounts of code throughout our large system. Of course this is an issue for more than just CMSes... Go has an obvious problem with this.
Well, at least you don't have to pull your hair out to build a working map operation or a basic SQL select with "reflection" in [insert language previously mentioned].
Can you provide a concrete example? I understand the value of generics generally, but I struggle to think of how they would benefit a CMS specifically. 
I have no camera to test now, but would be nice to pair with https://github.com/mmatczuk/go-http-tunnel for acessing webcams inside offices.
SQL select, map, filter, and reduce.
ActiveRecord, which is what you are presumably referring to, is one big ball of reflection. Not sure if you have never used Ruby/Rails or don't understand what reflection is.
If you want to use ActiveRecord that's your prerogative, but you don't have to. At least you don't have to manually cast the results from every function call yourself if you go that route.
&gt; If you want to use ActiveRecord that's your prerogative, but you don't have to. You don't have to, but any library built for allowing you to execute that SQL select statement in Ruby is undoubtedly going to use reflection in some capacity. ActiveRecord takes reflection to the utmost extreme, but it is found everywhere in Ruby code. It is what makes Ruby, Ruby. &gt; At least you don't have to manually cast the results from every function call yourself if you go that route. Because adding `.(mytype)` to your dynamic variable is such a burden? The Go language has numerous faults, but the ability to easily cast a dynamic variable into a static variable is clean and elegant.
I personally never had to do code generation but I use a library that does some code generation for its setup. To me the idea just seems like a pain for contributors to deal with and if you're still prototyping that's an even bigger pain. Generics in C#/Cpp you look at the code and you see what is going on, you don't need separated tooling and commands to continue developing.
I can't argue with that, but the syntax still sux.
Those are abstract concepts, not concrete examples. Code examples of specifically where the language fell short during your discovery phase would be preferable, but a detailed description will suffice in the absence of you having that handy.
trololol
FYI this has directory traversals in it, so I might note it should never be expose publicly. However it doesn't take much effort to safely implement file system access honestly so might be worth fixing it. My post history has a few posts on the topic. 
Great post. I'd be interested in hearing more elaboration on the numpy difference. Lots of folks considering gonum will surely be comparing numpy output as is done here.
I see a lot of Rails apps out there that provide nothing more than APIs for use in a front-end stack, so I think the answer to your question is a definite yes. Rails jumped on the JSON/RESTful API bandwagon at the beginning so there is a close relationship there, and as such people use it for exactly that.
https://meta.stackexchange.com/questions/218343/how-do-the-stack-exchange-websockets-work-what-are-all-the-options-you-can-send is the unofficial reference I always land on. I usually will subscribe to `${siteID}-newnav-compact-questions-newest-tag-${tag}`, and handle messages. You should be able to figure out the format pretty easy. There's also a simple heartbeat mechanism you'll need to deal with. https://stackapps.com/questions/7364/stackwatch-glitch-app-to-send-web-push-notifications-on-new-questions is my node app that I use for real-time chrome push notifications. Maybe that can help, but it is a bit of a mess.
&gt; weak integration with modern webdev workflow. Good. https://hackernoon.com/how-it-feels-to-learn-javascript-in-2016-d3a717dd577f
See that's the problem with inheritance hierarchy trees. How much of that code is actually reusable? (I mean the actual parts of code, not the files.) If he wasn't there would you be able to get the gist of the class hierarchies at a glance? Or would you be too afraid to touch it because you don't know what is immutable at certain points? I tried to write code in JavaScript to emulate go's ability to not have inheritance hierarchies. https://goo.gl/d5XsMj But without that type system and open automatic extending interfaces, it's really not like it at all. This video explains it more. https://youtu.be/7YcLIbG1ekM?t=345s
https://tools.ietf.org/html/rfc6265#section-4.1.1 set-cookie-header = "Set-Cookie:" SP set-cookie-string set-cookie-string = cookie-pair *( ";" SP cookie-av ) cookie-pair = cookie-name "=" cookie-value cookie-name = token cookie-value = *cookie-octet / ( DQUOTE *cookie-octet DQUOTE ) cookie-octet = %x21 / %x23-2B / %x2D-3A / %x3C-5B / %x5D-7E ; US-ASCII characters excluding CTLs, ; whitespace DQUOTE, comma, semicolon, ; and backslash The usual thing to do is to base64-encode it.
Did the reporters get a bounty?
&gt; Let‚Äôs say you‚Äôre iterating a hierarchy in Go and you want to track whether a certain path of arbitrary length has been visited. The easiest way is to store all visited paths in a map. The typical thing, when it's a *hierarchy*, is to just have `seen := make(map[*node]struct{})`. In a hierarchy (tree), there are no two paths to the same node. Also, his interface usage is really close to just pointers, which seems much more sane: https://play.golang.org/p/GI1yKJH0GN
&gt; for Go v0.9 Not a minute too early.
Barry doesn't use go because if he did he would know the following about his immutable argument. "Slicing does not copy the slice's data. It creates a new slice value that points to the original array. This makes slice operations as efficient as manipulating array indices. Therefore, modifying the elements (not the slice itself) of a re-slice modifies the elements of the original slice" https://blog.golang.org/go-slices-usage-and-internals He also doesn't know much about go's concurrency and how the garbage collector utilizes them with memory. https://blog.twitch.tv/gos-march-to-low-latency-gc-a6fa96f06eb7 
Go 1.8?
https://cdn-images-1.medium.com/max/1600/1*VEn3fJQDwrAy97VpemxWVA.png I have trouble parsing this ASCII art.
I can kind of see the documentation is basically a regular language. So essentially the cookie value can only be US-ASCII characters which excludes most UTF-8 characters
&gt; letterBytes[rand.Int63() % int64(len(letterBytes))] &gt; Supposedly, this is faster And you've introduced a bias.
It's pretty much intentional, and completely reflects how confusing the C syntax is. http://c-faq.com/decl/spiral.anderson.html (Except the spiral rule isn't even accurate: https://news.ycombinator.com/item?id=12775735 -- that is, it's both overly complicated and not complicated enough.)
Ok, here is my attempt at trying not to start a holy war, but provide my experience of using GO for the last 1.5 years (best thing I have ever done) Our product comprises of a front end (reactJS), and a back end (GO), in previous positions, I had done a lot of PHP, and more recently, Node. Now, firstly I think node is awesome, and PHP was a language I just new very well from +15 years experience, so I was comfortable with it. When a new project came to light, I had to make a decision, originally I thought Node (was thinking should be PHP as my experience would of made it a safer bet), however, I thought I would "experiment" with GO.... What I found is the code base was much less error prone due to the static typing (I try and not use blank interfaces at all if I can help it) and faster development, why.... in Node, the dynamic nature does not catch static type bugs, and yes, I wrote unit tests always, but the dynamic nature still can make weird success results in JS, that only in production or weird edge cases that static typing would of caught, really annoying. I find with GO, the static nature makes the code base more reliable, and I am generally only trying to find and fight logic errors in my code. Another thing I find is even though I like its static nature, it still has some kind of dynamic feeling about it too, kind of halfway between Node and C++. The other big advantage for our product is the cross platform compiling out of the box from GO, once you get spoiled with this, Node just does not cut it. I deploy one exe, with embedded website, and deploy to a mix of Linux, OSX and Windows without a single dependency, now try and do that with either Node or PHP, as they both need runtimes installed etc. Like always, Ill finish with the simple saying of "Right tool for the right job", "Choose what your most comfortable with" and "Choose what is best for your end product requirements", because we are all different, and some people hate GO too, and thats cool too. But overall this is simply my experience, and have never looked back on the decision, and have finally said goodbye to Node and Apache/PHP for good (hopefully) Disclaimer : still use Node for fast prototyping and experimenting with ideas, but not for production use. 
I'd just stick with jQuery.
/u/gohacker wow, actually I meant framework version. It seems aligned with today's Go release version number. Is it possible to edit the post title in reddit?
I'm afraid no.
Yes. This is a problem of HTTP itself, it's all US-ASCII only and everything else needs to be encoded in base64 (or something else that only uses ASCII characters). You'll see similar problems when using SMTP/IMAP (or Email in general) and most plaintext file encodings standardized before this century.
I miss functional programming too :(
Do elaborate.
Well, in the grand scheme of things no they don't and what does really? But in the context of this website they do mean that my post has the majority of the viewers' approval. The number is also relatively large which signifies that the post was a "hit". In other words most people thought it was funny. :)
&gt; So essentially the cookie value can only be US-ASCII characters correct, basically, you want to make sure that whatever goes within the http header is ASCII, anything that might come from user input, config files and/or database, I'd encode to base64 and stay on the safe side
interesting, may want to consider adding opportunistic reload of config, or config file watcher
&gt; `models.Transaction` Models is a not a very good package name. Same goes with `controllers`. They don't tell anything about the package. Use better package names and you won't even think about aliases anymore.
The spec document talks about 'side effects on the host' which is how bazel uses Skylark. What is missing here but is available in bazel is an exec function, which in bazel is used to invoke compilers etc. So I guess Skylark go could be used to implement build tools, by implementing that exec function in Go + some file change detection code etc. Another use case could be implementing a Chef like tool. Chef the devops tool is a ruby based DSL, which is used to configure hosts. 
It's basically the idea behind `context.Context`.
Some letters will be more frequent in the generated string than the others. https://stackoverflow.com/questions/10984974/why-do-people-say-there-is-modulo-bias-when-using-a-random-number-generator
Look at how they avoid modulo bias in math/rand: https://github.com/golang/go/blob/66c03d39f3aa65ec522c41e56c569391786539a7/src/math/rand/rand.go#L123-L136
The difference is, that for pointers you have to care about which allocation the value came from: https://play.golang.org/p/piDvioxFqs Compare that with the usage of interfaces, which "just work": https://play.golang.org/p/kVYjITI1m1 The reason being, that pointers equal iff they come from the same allocation (or, maybe, if the pointees have size zero). Of course this implies, that the pointer-implementation of a linked list compares in O(1), whereas the interface-implementation of a linked list compares in O(n) (because the latter actually compares the whole list as values, the former gives a weaker sense of comparison). So you'd have to see from your use-case, what makes more sense. If you can guarantee the pointer-comparison to be identical to the value-comparison, use pointers as they're faster. Otherwise use `interface{}`.
Ah true, as long as you don't have power of two lengths against a pow2 random number source. Good to know that I skipped that caveat with base64 :)
Just for those who don't read math: max := int32((1 &lt;&lt; 31) - 1 - (1&lt;&lt;31)%uint32(n)) For the random interval between `[0,n)` (same as `[0,n-1]`), this limits the maximum value of the integer that will not produce a bias: for n=10, this is 2147483639. Lets say your source was 5 bits, to simplify: - `1 &lt;&lt; 5` would result in `32` - `- 1` would result in `31` (the actual maximum value, binary: 11111) - `32%10 = 2` - the number of biased bits - `31-2` - the maximum valid value, 29 A number between `[0,29]` using `%10` would not produce a bias. Thanks for the example!
You will not regret Go, pinky promise.
Oh jesus, the async library count for node went up since the article was written: [from 4089 to 7030](https://www.npmjs.com/search?q=async). I don't know what it would take to make that happen, but I'd be fine with pouring gasoline over that tire fire.
["Make it correct, make it clear, make it concise, make it fast. In that order."](https://twitter.com/codewisdom/status/801456038008520705?lang=en)
It's Red Hat, they don't jump versions unless really needed. There is also always a general delay before any package can make it in. As long as 1.8 gets security patches there is no need to upgrade.
Start with the sentence below there then parse.
This has to be trolling. Have you not read ANY material or watched talks about Go that's been released in its 10 years of existence? Your concerns have been raised and refuted by so many others it's really disconcerting at this point. But anyway, to answer your questions: 1. [Errors are values](https://blog.golang.org/errors-are-values) in Go so you can program them. 2. [Go is time and memory and energy and memory efficient] (https://jaxenter.com/energy-efficient-programming-languages-137264.html). That's one of the reasons so many people and companies choose it. It's leagues above other languages in the space they program with it. 3. Go is unquestionably not slow and here's [why] (https://dave.cheney.net/2014/06/07/five-things-that-make-go-fast). Finally, if you're having issues with repetitive code then that's a shortcoming of your programming style and not necessarily the language. Your abstractions may be lacking. Consider guard statements and early returns instead of "pyramid of doom"style nested statements. Go provides closures‚Äîuse them. Create interfaces and program to those (Liskov substitution principle). Hopefully that was informative and you're able to improve the Go code you have to write. Nothing sucks more than using a language you don't like at work.
As far as I know, they didn't.
Hmm. The more I think about it, the more I like being able to `Add()` more than one refcount at a time. On the other hand, caller's aren't supposed to `Wait()` on the refcounter *per se*, but rather on the `context.Context`. I think I'll do this: Incr() Decr() Add(n int) I'll push the changes this evening.
https://play.golang.org/p/snse0sObOf 1. match text between &lt;...&gt; 2. split by | 3. take second part (right of |) 4. trim length by one (getting rid of &gt;) 5. replace match with the cleaned value Should be enough as a base for whatever you're doing from here out.
Bit generalization would be to take nearest `&lt;` and `&gt;` from `|` ... case: https://play.golang.org/p/3cCTpDRWij . Anyway, thank you very much.
Easy enough fix, one character: https://play.golang.org/p/ydHwwFxOI_ (regex changes from `[^&gt;]` to `[^&lt;&gt;]`). There's probably edge cases abound...
Yep. Thanks. btw, good that it also works if there is `|` before or after the link stuff :)
Interesting. I had just assumed without examination that the context library had a `map[interface{}]interface{}` in it for implementing the `Value` method. Now that I [examine it](https://golang.org/src/context/context.go?s=15091:15151#L457) I see I'm wrong. I have to admit I already didn't love Context for its loose typing; knowing that it also does an association list lookup (in the Lisp sense of the term) for the Value method makes me even more concerned about using it. If you've got a high-performance web interface then you really don't want it to be carrying around a lot of values. (Though you could implement a thing that conforms to the Context interface that did use a map and I'm not convinced much would break. If it did it would be subtle, though.)
Go's a boring language. Want more excitement? Contribute to it ;)
I love go too üòú
You've successfully wrapped an http.Server with a type that has clean Start and Stop methods. But I'm not sure how it's germane to the topic.
The reason I've expressed the interface as two funcs, designed to be provided as inline closures, is precisely to avoid the need to define types and interfaces to wrap start/stop behavior.
Kudos Kris, to bring back this project from the dead. I mean, what can't you do with `G`? The sky is the limit!
It's a minor-minor release. They're supposed to be boring. If you're active in some language community where minor-minors are exciting, you might want to start complaining.
@skidooer and @shovelpost: I agree with separating `Transactions` into its own package as a separate concern, and when I first started writing Go about 2 years ago, that is what I would have done, but now tend toward fewer, larger packages. In Ben Johnson's blog [Structuring Applications in Go](https://medium.com/@benbjohnson/structuring-applications-in-go-3b04be4ff091), in section 4, he talks about sub-packages. Because Go does not allow cyclic dependencies, it is easy to get into trouble with package `A` depending on `B` and `B` depending on `A`. I found that I had to combine `A` and `B` into some artificial package `AB` to accommodate the inter-dependency, so I stopped making so many sub-packages. As far as using the type alias feature to pull a type into another package, I agree that it is not a great choice, and I was really only doing a "thought experiment". I also shy away from "." imports because they pollute the namespace unnecessarily.
Don't miss the [immaculate test suite](https://github.com/StabbyCutyou/generics/blob/master/g_test.go). How could you fail to trust that?
@jerf: I'm not complaining.
&gt; knowing that it also does an association list lookup (in the Lisp sense of the term) for the Value method makes me even more concerned about using it. That's *literally* the point of context :) The point of context is to give a type-safe, concurrent, dynamically scoped (that is, values written will become invisible after return) map. Using a linked list is probably one of the best ways to do it. At least any implementation I could think of regresses to the same basic properties. &gt; If you've got a high-performance web interface then you really don't want it to be carrying around a lot of values. The thing is, in practice you *don't* have that many values and that deeply nested contexts. So, in practice, it turns out to not be an actual problem (if you actually do the benchmarks). &gt; Though you could implement a thing that conforms to the Context interface that did use a map I'm not convinced this is possible and if it is, that it is more performant. Let's start with [this first try](https://play.golang.org/p/Q-R8qyeqLR). Now, this *seems* to work, but it actually [violates the contract](https://play.golang.org/p/RqNNdaaGHf). So‚Ä¶ we definitely need to do *something* linked, otherwise we don't get the immutability we want. Let's try [this](https://play.golang.org/p/_0ICGVl7q6). Definitely better, right? Now we *still* get O(1) lookup for different keys, we just stack if repeatedly writing to the *same* key. Alas, it's [still wrong](https://play.golang.org/p/_0ICGVl7q). So it seems, we really don't get around using *some* sort of linked lists - with an element per push, in the general case. Now, add concurrency safety to the mix, so you need locking (which you don't need with context as is - meaning you don't need *any* synchronization primitives, meaning you don't have any contention, or cache flushes)‚Ä¶ I don't know. If you'd know more about your keys, you might be able to do better than a linked list. But I am very skeptical. I thought quite a bit about all of this. And the more I thought about it, the more I like the design of context - it is a very elegant implementation of its concepts, probably as elegant as you can get without thread-local storage or first-level language support. And it leads to very natural and simple usage - for example, in general you don't have to free any values or anything. It's pretty nifty. [edit] I should point out, that previously I had *exactly* the same issues as you; I also was very convinced that linked lists are approximately *always* wrong and would *always* perform worse. Turns out, if you want lock-free immutable data structures that's not the case anymore.
Ahh rly? did you made any contrib to go ever?
Edit: Ignore this comment, it's all wrong; leaving only so the thread makes sense. Technically base64 also uses unsafe characters according to the standard, but I think it'll work in all browsers since so many people do it. If you're motivated you can use an encoding scheme that is still safe. It's actually pretty simple to set it up in go: [as so](https://github.com/thejerf/sphyraena/blob/master/secret/secret.go#L25). (I don't recommend anything else from that repo but you can take that as-is.)
In your talk, you were talking about whether there was a better way to shut down an http server. Hence this response. I might have misunderstood though.
I don't see the issue is with defining a type once, and reusing it multiple times. Also know to look at a Start or Stop method of a thing, rather than look for closures. I find that passing a *group to things so they can add their own actors on startup as needed is useful. So there is already interface coupling between components. var g group.Group tlsConfig := NewTLSConfig( WithTLS12(), WithSessionTicketKeyRotation(&amp;g, 32, time.Hour*10), WithKeyPair(certFile, keyFile), ) 
Great example.
Made me laugh, thanks for sharing! Are there any other projects like this?
Or you use stdlib for this and do base64.URLEncoding.EncodeToString([]byte(value)) that will produce base64 according to https://en.wikipedia.org/wiki/Base64#URL_applications
Sadly this pattern already exists in the standard library. cmd/gofmt/testdata/rewrite8.input 12:type T interface{} database/sql/driver/driver.go 26:type Value interface{} crypto/crypto.go 108:type PublicKey interface{} 111:type PrivateKey interface{} 158:type DecrypterOpts interface{} encoding/xml/xml.go 55:type Token interface{} html/template/template.go 328:type FuncMap map[string]interface{} expvar/expvar.go 228:type Func func() interface{} encoding/json/stream.go 278:type Token interface{} go/printer/testdata/comments.x 28:type SZ interface{} go/printer/testdata/declarations.golden 315:type _ interface{} 540:type EI interface{} go/printer/testdata/comments.golden 70:type SZ interface{} go/printer/testdata/declarations.input 556:type EI interface{} plugin/plugin.go 71:type Symbol interface{} runtime/mfinal_test.go 15:type Tint int // *Tint implements Tinter, interface{} reflect/all_test.go 654:type Loopy interface{} text/template/funcs.go 30:type FuncMap map[string]interface{} reflect/set_test.go 221:type Ch &lt;-chan interface{} Pattern found in 16 file(s)
Go is not a systems language (which is used to create programs that usually to control hardware), it's a general purpose language. https://en.wikipedia.org/wiki/General-purpose_programming_language
**General-purpose programming language** In computer software, a general-purpose programming language is a programming language designed to be used for writing software in a wide variety of application domains (a general-purpose language). In many ways a general-purpose language only has this status because it does not include language constructs designed to be used within a specific application domain (e.g., a page description language contains constructs intended to make it easier to write programs that control the layout of text and graphics on a page). Conversely, a domain-specific programming language is one designed to be used within a specific application domain. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/golang/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.27
Yes, I'm happy to say that I'm contributing to Go and its ecosystem to the best of my abilities as much as my time allows me to do it.
It's a reference to Brad's talk, right? :) 
This totally got me /facepalm
I too love Go.
But really this begs the question, why don't we just use interfaces for everything in go? Why am I typing anything? I guess what i'm saying is, why aren't I writing perl?
Proposal: Use Go 1.9's new alias syntax for greater compatibility. type G = interface{} The change is backwards compatible and makes G compatible with functions that expect `interface{}`.
I see Go as somewhere between static typing and dynamic typing. Most things are statically typed, but when the types get confusing, it's totally fair to just bail out and switch to dynamic typing instead. You lose a little performance (but not that much compared to a fully dynamic language), but it makes things pretty simple. Imagine for example, if Go's templates had a static type. It's possible to make a type system that would work with that. But it would be so complicated that the type system would end up being a pain to work with. (IIRC, in Rust the print macro will complain at compile time if you have an invalid format string.) The downside is that in Go as it is, you don't catch template errors until runtime. But that's not a big deal, since that's also the case for almost everything in Python/Ruby/Perl/JS, and those languages are fine day-to-day for the most part.
Cheers on a new package. Submitted issue for package structure: https://github.com/twitchyliquid64/subnet/issues/3
Go, I love you.
For some reason I thought that included illegal characters, but I seem to be incorrect. So your comment does not become unhinged from the context I'll leave my comment, but this is better. Now I really don't know what I was thinking, since it seems standard base64 encoding is valid too. Perhaps I had the wrong cookie standard.
I believe standard encoding is not safe as it may contain characters breaking parsing such as / or =.
&gt; I also was very convinced that linked lists are approximately always wrong and would always perform worse. While I wouldn't necessarily go with "always" :), the fact that I thought there was basically no such thing as an immutable/const value in Go certainly colored my understanding of this matter. The only quibble I'd make is that I'm not 100% convinced that immutability is part of the contract, rather than an implementation detail from an implementation chosen to avoid locking issues. The [context page](https://golang.org/pkg/context/) only seems to mention that contexts should be safe for multiple goroutine usage, which could be accomplished with lock, with the user-visible changes you show. (Note the compiler doesn't have any issues at all with your implementation and is totally comfortable with the idea that this is a "context".) I can't find any discussion of the visibility of changes. This is a specific instance of a general problem in Go that I'd expect the community to really start discussing in, oh, about two to four years. Many of the interfaces carry implicit semantics above and beyond both the contents of the interface declaration itself and the documentation of the interface. The example of this I hit most often is that concrete objects that implement io.Writer generally immediately write every time they are called; if you want to emit something byte-by-byte but not take a significant performance hit, it's up to you to use a bufio. On the flip side, some io.Writers like the gzip one _must_ be flushed to work properly; a meaningful debate could be had as to whether that qualifies as _really_ implementing io.Writer, if it comes with extra such constraints. By no means is this catastrophic or anything, it's just a thing I've slowly noticed more and more, and this context is another instance where the language interface definition and the "actual" or "implicit" definition differ substantially, in undocumented ways. _Further edit_: It seems to me this makes for a good case to be made that some sort of "const"ness or immutableness annotation might be called for in Go 2.0. It is, IMHO, not very Go-ic to have such a feature in the language like this, but only accessible though a very particular combination of features, and that only with very particular structs too (since maps still won't be immutable if you've got one in the struct, for instance). Honestly I'd be comfortable in some ways just to say "If you label a map as immutable it's a compiler error"; I'm not even necessarily asking for that much in the way of new features. Just a way of labeling this corner of the language in a way that is explicit and in a way that appears in the language spec somewhere where people can learn about it. I don't think I'm being too arrogant to say that I'm pretty decent in Go, and I've been doing it for a couple of years now, and it's not very Go-ic for me to be learning something like at such a late date. (I mean, after 15 years of Perl it still surprises me every few months, but I expect that of Perl. I don't expect that out of Go.)
 const encodeStd = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/" I thought so too, but + is 0x2b and / is 0x2f, and + is in the second block of the grammar (`%x23-2B`) and slash in the third (`%x2D-3A`). According to the comments in the code I made where I wrote this stuff in the first place, I got my ideas from [RFC2616's token construction](https://tools.ietf.org/html/rfc2616#section-2.2), which says if you have separators, which includes a /, you need to quote the value in the HTTP header for it to be legit. But if you quote it, which the net/http library ought to be doing for you, the standard base64 is usable. Well. I've learned some stuff today. It seems I've got some code to tweak. And in another thread I'm learning all sorts of things about the Context object I've been screwing up....
Yes, but typically you can point to the nodes or vertices themselves, and those pointers are stable.
&gt; The only quibble I'd make is that I'm not 100% convinced that immutability is part of the contract, rather than an implementation detail from an implementation chosen to avoid locking issues. Without it, you wouldn't need context at all, you could side-load the data via closures or struct-members. The specific goal of context is to pass data in a dynamically scoped fashion, which you can't emulate otherwise. I agree that the documentation doesn't mention it, but that's mainly because it's really an implementation more than an interface. It certainly is a semantic contract assumed by its users.
I‚Äôm starting to like you. 
I thought this was going to be about when it's acceptable to use super-short variable names, which are a common sight in Go code.
Yeah, I'll going to write a post for that too, however, this one is about declarations. Some people get confused when they see why short declarations don't work in some cases, as I wrote in the post.
Great! Thanks 
üôè
&gt; Without it, you wouldn't need context at all, you could side-load the data via closures or struct-members. Both of which imply significant coupling and don't work well with the way people want to use middleware. I have to disagree; the point of context is to pass it in a dynamically-scoped fashion, but beyond that, there's no magic to it. It's still basically a refined map[interface{}]interface{} with a lock-free implementation and an attached cancellation channel, and I've seen chatter on /r/golang about how people think that is also two things that don't necessarily need to be coupled together. Context's primary value isn't in its implementation, it's in its community acceptance and the increasingly large amount of community code that uses it. It's the same with `io.Reader` and friends; the value isn't in io.Reader itself, it's in the way it gets used by so many things. Plenty of languages, even perhaps _most_ modern languages, _could_ have had an `io.Reader` equivalent, indeed you can even implement one, but you won't be able to find any code that integrates directly with your new abstraction.
&gt; Both of which imply significant coupling and don't work well with the way people want to use middleware. ‚Ä¶because they are not [dynamically scoped](https://en.wikipedia.org/wiki/Scope_(computer_science)#Dynamic_scoping). &gt; In technical terms, this means that each identifier has a global stack of bindings. Introducing a local variable with name x pushes a binding onto the global x stack (which may have been empty), which is popped off when the control flow leaves the scope. If you want dynamic scoping, linked lists are the way to go. And `context` is pretty much the best implementation you can do of that without first-level language support. &gt; It's the same with `io.Reader` and friends The difference being, that you are not, in general, expected to implement your own `context.Context`, but you are expected to implement your own `io.Reader`. *That* difference is what I was referring to when saying that context defines more an implementation than an interface (of course you *can* implement your own context, but it's unlikely to be beneficial). Anyway, I'm not sure what this is even discussing anymore. :)
&gt; Anyway, I'm not sure what this is even discussing anymore. :) Musings and increased understandings. I know I tend to confuse people when I post replies that aren't necessarily "criticisms.."
I haven't come across anybody who has used Go and not loved it.
Thanksüëç
Not typically. The issue is, that a path is not a `*node`, it's a *list* of `*node`s. You need to represent that list. You can either do that as a `[]*node` (which isn't comparable), or as a linked list via pointers `struct path { n *node; next *path }`, which gives you the problem of stable pointers, or via a linked list as interfaces. There are *some* very special cases where you can use pointers. For example, if your graph is a tree, there is a 1:1 correspondence between nodes and paths to a dedicated root, which you can, e.g. store in a `map[*node][]*node`. That will then give you a 1:1 correspondence between *pairs of nodes* and paths, by going through that root and eliminating duplicates. Similarly, if you are doing a DFS and want to store all the paths you visited, there will also be such a correspondence (because you are building a tree) that you build on the fly. But in the general way, for the problem as stated by OP (i.e. "build a comparable representation of a path from a list of node-ids"), using pointers won't get you anywhere due to having different allocations. I'm fine being proven wrong though; i.e. if you actually provide code. But let's make this precise. Say, we store the graph as an adjacency list, like so: type Node struct { // Whatever a Node represents } type Graph struct { Nodes []*Node // Index in this list is the node-id. Neighbors [][]int // Neighbors[i] contains a list of node-ids of neighbors of Nodes[i] } type path struct { // Your representation here } // toPath returns a path visiting the given nodes in the given order. func toPath(g *Graph, nodes []int) path { // Your code here } Find a comparable representation of `path` is the challenge presented by OP. The interface-based solution is // A path represents a path through a graph (in reversed order). // The first element is a virtual "end" node, that is the empty path is // represented by path{}. next is either nil (if this is the last node), // or also a path. type path struct { node int next interface{} } func toPath(g *Graph, nodes []int) (p path) { // note, that this doesn't use `g`; but your solution may, to get // stable pointers to nodes by id. for _, n := range nodes { p = path{ node: n, next: p } } return p }
Great point, thanks for the article :)
interface{} is not dynamic typing. The type remains "no behavior/type" until behavior is verfied and accessed. It's common to look past this distinction, but it's a vital part of building circuitry in Go. A next appreciated step would be union types for communicating groupings of potential pathways.
Sounds like from the [README](https://github.com/StabbyCutyou/generics#on-law-8) the author fully intends on doing that. StabbyCutYou just hasn't really updated since April (other than merging a typo PR a few hours ago)
TL;DR trapping SIGABRT won't break anything, but it prevents useful debug functionality.
It's a minor release to patch security issues. The excitement is in rebuilding all your code ;)
Maybe something like this is what you're asking for? https://github.com/apiaryio/dredd Apiary (now owned by Oracle.....ugh) had some pretty cool stuff. Dredd, above, is by them and open source. You may also want to look at https://restlet.com/. Not sure if that matches what you want but they have a nice suite of API-related tools. Edit: From a design philosophy, it seems the idea is the Swagger/OpenAPI Spec doc is the source of truth and the code is written to meet the spec. People who generate the spec docs from the code are kind of doing it backwards and eliminating the ability to test properly. So, if you think your swagger doc "is likely to go out of date", you may be approaching this in not the best way. Keep the spec up-to-date first, and then code around it.
I don't know of anything like that, though that proxy looks like it's what you want. You may just need to fiddle with it a bit to get it doing what you need? &gt; It seems most of the swagger stuff is about generating server code which I dont want to do. Can you share why not? At my job I switched our go API server workflow to one that has us writing the spec first, then generating code from the spec and wiring it through. It's perfect because it _ensures that the documentation is always up-to-date_ and accurate. And we never end up with new undocumented endpoints/parameters/responses because the "easy path" is just to write/update the spec and regenerate code. Switching was admittedly a bit of work, but overall it's definitely saved us more time than anything, and my client devs are glad to always have up-to-date and correct documentation.
Hi /u/The_Sly_Marbo, Yep. That's the point I was trying to get across. Yeah, you *can* trap the signal. But damn is it useful to core dump a program that is hung for some reason you cannot fathom. Bad goroutine, bad!
Welcome ... to G. This ... is ... G. Welcome. This is G; welcome ... to G. You can do anything at G. Anything at all. The only limit is yourself. Welcome ... to G. Welcome ... to G. This is ... G. Welcome ... to G! This is G, welcome! Yes ... This ... is G. This is G! And welcome to you, who have come to G. Anything ... is possible ... at G. You can do ... anything at G. The infinite is possible at G. The unattainable is unknown at G. Welcome to G. This ... is G. Welcome to G. Welcome. This ... is ... G. Welcome ... to G! Welcome ... to G
haha yeah.
Instead of helping the Guy fix his lack of understanding, we have resorted to mocking him now on public forum? All those who think he is stupid for just hiding an empty interface need to understand that people are free to make mistakes when they start. I thought Gophers were better than ML purists and r/programming trolls who keep demeaning anything which doesn't fit their idea of perfection. Color me surprised. 
Yes, on the roadmap :)
I tried browsing your submission history, but wasn't able to immediately identify what you might have been referring to. Do you have a link? I'm curious what security concerns are present with directory traversals. Even though it's intended use is as a local development server, I believe the code should only show all child files and folders of the directory when you run `spin`. In other words, running `spin` is like saying "this is my public directory".
It's a joke. I guarantee you, it's fully intended to be tongue in cheek. 
I think your comment can be read both ways, and if it doesn't click to you that's a reference to Brad's talk it doesn't help. Next time link to https://docs.google.com/presentation/d/1JsCKdK_AvDdn8EkummMNvpo7ntqteWQfynq9hFTCkhQ/view#slide=id.g39982b998820aa42_434 to remove the uncertainty ;)
&gt; The type remains "no behavior/type" until behavior is verfied and accessed. Where I come from, that's dynamic typing. What is the distinction you're implying?
Hello, I have many security related posts in my history around file system access, the most recent was from a few days ago and is the one I was referring to- I explain how to use http.FileSystem for safe fs access. [comments](https://www.reddit.com/r/golang/comments/72sx70/things_to_know_about_http_in_go_tit_petric/) How it applies to you is [here](https://github.com/everdev/spin/blob/master/spin.go#L38) you call route, which checks if path contains dot, if so you read the file and serve to client. So a request for ../../../file would serve a file outside the cwd. I get it's meant for local dev, but relying on a configuration item from end users for security should be avoided. Let me know if you have anymore questions.
&gt; in Rust the print macro will complain at compile time if you have an invalid format string Are you serious, mate?
See https://rustbyexample.com/hello/print.html. `println!("My name is {0}, {1} {0}", "Bond");` causes the compile time error: error: invalid reference to argument `1` (there is 1 argument) --&gt; src/main.rs:31:5 | 31 | println!("My name is {0}, {1} {0}", "Bond"); | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ | = note: this error originates in a macro outside of the current crate error: aborting due to previous error error: Could not compile `playground`. 
The hard part is getting them to drink... try... the language... 
So, are you complaining about rust preventing a runtime error?
No, I think it's pretty cool. But it comes with a tradeoff, which is that Rust is pretty tricky to write. Obviously, the print macro is pretty simple to use, but in general, there's a lot to know about Rust's type system.
&gt; But it comes with a tradeoff, which is that Rust is pretty tricky to write. Obviously, the print macro is pretty simple to use, but in general, there's a lot to know about Rust's type system. It's a system's programming language. It prevents making stupid errors in exchange of your effort. It's not a webcrap language, every programming language is good to render some crappy html. Few of them will make anyone productive or "safe".
No one's saying Rust isn't good for what it's good for. I'd love to learn Rust; I just haven't had a chance to go past intro tutorials. I will disagree that "webcrap languages" aren't "productive". They're super-productive for the first 80% of a project. That's why they're popular.
&gt; No one's saying Rust isn't good for what it's good for. I understood it. My point was that it concentrates on *safety*, not on webcrap generators. &gt; I will disagree that "webcrap languages" aren't "productive". You can disagree, but people will always be more productive in sophisticated languages. This isn't even hard to prove -&gt; less code=less typing &amp; less reading; better typesystem=more compile time errors &amp; less recompilation; stronger typesystem=less UTs=less typing &amp; less reading. Plus it's easier to do refactoring in statically typed languages. &gt; They're super-productive for the first 80% of a project. In practice, the other 20% used to be the 90% - "estimations". I'm working for a huge company and we've scripts written by those who believe what you've said - but the end of the day, maintainability is what brings the money, not "easy-scripts" full with bugs which needs to be rewritten due to quality issues. &gt; That's why they're popular. Between those who have no experience with programming languages.
Yeah thinking fiddling with the proxy stuff may be the route. I've generally found most auto generated code is fairly hideous and painful to debug when something goes wrong. Then, I found when you have your API, whether or not it works is down to your wiring so you still need some more behavioural based tests to actually test the API is meant to be doing what its doing, I.e. the api could match your schema but can be doing odd things. Generally found it more pain than its worth. Do you auto generate in go? I'd be intruiged to hear what libraries you use, as much as I usually dislike I am always open to new / different approaches.
Thanks for taking the time out to review the article! Changed in-built to built-in as per your suggestion! Also moved target audience to the top, before the Strengths section. Brainstorming on how I can explain "industry best practices" to mitigate issues such as dependency management etc. Will let you know once I add it :)
Thanks for your reply :). Improving the article as per your comments and suggestions :)
oÕ≠ÃÇÃéÃâÃâÕùÃπÕâÃ£Ã≤ÕéÃ∞Ã™nÃÑÕ•ÕåÕ©ÕåÃÇeÃæÃêÕ´Õ©ÃâÕ•ÃöÕÄÃ©ÕìÃ≠Ã¶ÕçÕñ ÕÉÃåÃÅÕßÃåÕêÃéÃ°ÕôÕîÃüÃ©oÃëÃéÕóÃÅÃåÕ•ÕâÕÖÕáfÕñÕôÃªÃ¨Ã¨Õâ ÃèÃâÃßuÕ™ÃæÃÇÃΩÕâÕîÕôÕésÃïÃØÃπ,ÕäÃíÕÑÃäÕáÃ≤Ã´Ã∞Ã¨Õá ÃæÃåÃÄÕÜÃáÃµÃ†Ã£ÃòÕçÃ†ÃπOÕßÃÇÃñNÃÅÃéÃûÕàÕáÃüÃªÃ£EÃÜÃùÃôÕÖ ÃèÕ≠ÕßÃÉÕØÕ≠ÕôOÃäÕ§ÃæÕ£ÃæÃøÃâÃùÕÖÃñFÕ£ÕëÃÉÃçÃΩÃèÕßÃ∏ÃÆÃ¨ÃªÃÆÃªÃ£Õî ÃøÃΩÕëÕØÕëÃáÃåUÕ´Õ´ÕãÕåÕêÃ≥ÕôÕìÃ©Ã≥SÕ®ÃæÕëÕ≠ÃìÕäÕõÃóÃó
Thanks, will take a look at those links. Yeah kinda what I said below, generally found the autogen code annoying to work with and kinda the reverse problem, api doing odd things conforming to the schema is "OK". But yeah more tests or bed like tests couple would help. Ultimately I kinda feel the swagger isn't a spec, details messages but lacks big context. Obviously fairly new to this sort of stuff,so trying g to keep an open mind :p 
Great article, I look forward to rereading! 
When you use interface{} you pretty much always use type assertions before using the values. I'm not sure what you would call type assertions on interface types, except for dynamic typing.
Well I guess I didn't get the memo then. :)
Type assertions are a verification of and assignment as a type which may be being handled, and is incidental to the core point which is that interface{} is "no behavior/type" rather than "some behavior/type". Please consider this in Go: var a, b interface{} a, b = "hello ", "world" fmt.Println(a + b) And this in JS: var a var b a = "hello " b = "world" console.log(a+b) In essence, interface{} is more vulgar than dynamic typing, and the compiler works within that construct to generally ensure clearly defined behavior. --- Edit to add: interface{} can be quite pertinent (e.g. marshalling/unmarshalling). However, at most points of handling, a mechanism which enables the compiler to ensure that all potential cases are handled would improve communication greatly. I believe this to be sorely needed in Go. In my opinion, although it is already a common name, "union type" implies a joining of multiple types to create a super type. "disjunction" or "alternation" seem more apt for something which will likely end up passing through a switch-case. For example: type Event int const ( Left Event = iota Right Forward Back TurnedTopUp TurnedTopDown TurnedTopLeft TurnedTopRight ) type Actions disjunction { Forward Back Left Right } type Affects disjunction { TurnedTopUp TurnedTopDown TurnedTopLeft TurnedTopRight } func (s *SomeThing) handle(e Event) error { switch v := Actions(e) { case Forward: // ... case Back: // ... case default: // ... compile-time error without all cases in "Actions" being handled } return nil }
Looks cool! One thing to consider would be basing the protocol on something designed for network tunneling like Wireguard and contributing a go userspace implementation of it. You'll likely see much faster speeds and hopefully inter-operate with many other implementations of wireguard moving forward. https://www.wireguard.com/ There is even a standard UI spec for implementing userspace wireguard: https://www.wireguard.com/xplatform/ Possibly one of the reasons your seeing slow linespeeds is that TLS really isn't designed to be a network tunnel as it uses TCP. This means for many connections you'll be using TCP encapsulated in TCP which will create performance issues. Sorry if you already know all this!
It is still useful for a wide range of scripting tasks. From their talk at Gotham Go today, the primary limitations that make it "not turing complete" are that it forbids recursion, and does not have infinite loops (just for loops over finite collections). For many many practical applications, these restrictions are not a problem. You also have the option of implementing more complex behaviors in the go, and passing it into your python scripts in the environment. I'm excited to try this, both as a config language, and as a dynamic scripting component for http requests.
I find the exact opposite, the larger my packages become the more likely I want to use their functionality in a package it already depends on. Hard to see how more sub packages would result in more cyclic dependencies since you break cyclic deps with sub pkgs :p
Yes, the `interface{}` trick has value. However, if I was faced with having to do that, I'd take a hard look at redesigning my data structures. My opinion: even something as simple as joining node IDs into a `[]byte` comes off as more pleasant.
Ah yes - Sean (the author) is a friend of mine and we were at the pub last night and had a great time talking about this mock package. I decided to blog about it! He enjoyed my blog and thanked me on Twitter this morning https://twitter.com/stabbycutyou/status/915929820730740736
Yeah, I auto-generate in go. I use [go-swagger](https://github.com/go-swagger/go-swagger/). It has a couple flags on generation where it can build your "whole stack" (all the way down to the `func main()`) or you can just build the routes and wire them up. I do the latter. The tool has been spot on. I wire up the handler, and it passes in the parameters I defined, and then I pack my response into generated objects representing either success cases or errors. There's no business logic in my handlers; I take the params and call into a native go func, then take the result of that func (or error), wrap it in the appropriate response object and return that. So that layer is simple enough that I don't need to test it exhaustively; I can focus on unit/integration testing the pure-go functions (that know nothing about HTTP).
Follow up: As an example, here's what my "glue" code for one of my endpoints looks like: func UserHandler(params operations.GetV1MeParams, authedUser interface{}) middleware.Responder { if authedUser == nil { return operations.NewGetV1UserUnauthorized().WithPayload(ErrSignInRequired) } user, err := DB.LoadUser(params.UserID) if err != nil { // Intentional panic - triggering 500s on errors connecting to DB // Could also have defined a response in swagger and returned that. panic(err) } return operations.NewGetV1UserOK().WithPayload(&amp;models.User{ ID: user.ID, Name: user.Name, /* etc. */ }) } The `params`, `models` and `operations` packages are generated. The endpoint parameters are validated based on how you define them in the spec, and the router will error out early with an appropriate response if validation fails. Nothing I do here is stuff I could've avoided writing anyway (I use separate structs for the API from the internal structs as a way to ensure that any data leaving the system has been whitelisted so new fields on internal structs don't leak info through the API). Testing of business logic is done on the `DB.LoadUser` function, so it's isolated from any tweaks that get made to the swagger spec. (Obviously if user IDs change from ints to strings or whatever, coordination needs to happen, but that's true regardless of approach).
To anyone reading this thread that is not familiar with Go, its tooling does warn you about invalid format strings: https://i.imgur.com/r59Puyf.png
Glad you wrote this blog posting how you did. I still don't like atexit and wouldn't design a system that needed it, but you've explained your point nicely.
this most def gets my upvote // Package generics offers a simple, idiomatic, and elegant way to utilize the power of generics, // while adhering to the holy laws of golang. package generics // G is an interface under which all possible types apply type G interface{} google tries to avoid generics to such an extent that it not only hurts performance, but it will get uglier than (void \*)
Which thread out of curiosity?
I hope no one thinks that's a "burden"...
`defer file.Close()` seems like a far better choice for an example.
Nice idea. Wouldn't hurt to have some tests though to make it easier for new contributors to help with confidence.
&gt; In term of performance, In terms of performance, a great way to improve performance is to stop using JSON...
A good IDE usually tell them exactly why they can't do it (Gogland) and there's only 2 reasons: No new variable or used at the top level (package level) since every declaration at that level needs to begin with a keyword (ie: var). Easy to remember.
&gt; However, when the process terminates, the file http.sock will still exist because Go‚Äôs http package does not clean up after itself. The socket will also exist after the app crashes, is killed, or power fails. The program startup has to handle the socket existing anyway. The code being added here provides no value, yet adds complexity. &gt; Both of the above methods are top-down, that is the main function must both be aware of and invoke them. Yes, good. Don't program blind. Calling a function from main, putting defers inside that function, and not calling `os.Exit`/`log.Fatalf` outside of main, is all you need. Do that, instead of adding more complexity, hard-to-see behavior, and cleanups that may or may not be run.
I appreciate your feedback, but the library handles the kill event. Additionally, there‚Äôs no harm in attempting diligence. Thank you again for your comment.
Also, I saw a poster on Russ Cox‚Äôs original remarks note he prefers a crash consistent exit. I can get behind that. However, that doesn‚Äôt mean a core dump or stack trace should be presented to a user. I think a crash consistent exit should be expected, but that there is still room to want to do as much graceful exit logic as possible in idea circumstances. Again, I do appreciate your opinion. It made me stop and think about the topic a little longer. Thanks!
Yep, you're right but your point is? I've updated the post btw. But, of course I'd not include the spec but its link. Declaration = ConstDecl | TypeDecl | VarDecl . TopLevelDecl = Declaration | FunctionDecl | MethodDecl .
You don't handle SIGKILL, SIGKILL handles you.
I guess...I guess is that deep inside me I somehow doubt that there's actually a lot of people who get confused and once they catch the 2 cases where it doesn't work they learn about them pretty quickly and I felt compelled to summarize the simplicity of the rules and to say how a good development tool can help you a lot. That's probably my point? It's not like I had other motives beside talking to you.
I absolutely love it. It's like Python and C++ had a kid, or at least that's what I think. Maybe someone with a more diverse programming experience can be more accurate. I never get to use it though because work requires Java, Python, and HTML.
I should have summarized it simpler like you did, good job, thx. In the post, I wanted to show people the common use cases and why they don't work or work.
That might be the reason for *this implementation*. The reason for *the language* seems to be to limit the side effects loading a build config can have.
No, you did a good job. It's important to go in more details and show varied examples for people who are new to the language. Throwing specs/rules makes an awful blog, it will all read like nonsense to newcomers anyways.
&gt; subnet establishes a TLS connection to the server. http://sites.inka.de/bigred/devel/tcp-tcp.html
Your comment did not show to me until a short time ago. Please see [this response](https://www.reddit.com/r/golang/comments/74ffn9/i_genuinely_love_this_solution_to_generics_in_go/dnyigs6/).
Yep, I agree, that's was my goal exactly. And, now it's better!
Okay, so it's a lot like Prometheus's data storage backend (not the alerting aspects), and has two-way gateways to other metrics systems. For someone who uses only Prometheus, is the value of this purely the long-term archiving? If so, does it do anything about the *reason* why Prometheus chose not to do archiving -- how to handle data larger than one machine https://news.ycombinator.com/item?id=11610761
Hi /u/tv64738, Joking aside, it *is* possible to trap `SIGKILL`. Although I did recently write [a blog](https://akutz.wordpress.com/2017/10/02/golang-and-sigabrt/) on why you should avoid trapping `SIGABRT`.
The only definition in the code that uses space is the int. So the address of the inner struct is the address of the int and the address of the outer struct is also the address of the int.
but what if I define a struct method func (c * InnerWrapper) some_logic() { } how does the compiler know that type InnerWrapper struct { myField int } a := InnerWrapper{1} a.some_logic // is valid a.myField.some_logic // is not valid if they have the same address, the compiler must store the meta information somewhere right? 
&gt; No way to enforce initialization of some struct's field This! I understand why it was done like that (mostly because struct can contain both private and public fields) but still I would like the compiler to check if I initialized everything. 
Put me on that list. Although the compiler is great I find the language overly cumbersome and unpleasant to use compared to Ruby, Elixir, Crystal, Kotlin etc. Too much typing, too much boilerplate, too much copy and paste.
That‚Äôs a linter, not the compiler. 
Haven‚Äôt had a chance to really kick the tires on this yet, but figured folks checking this thread out might also be interested in http://www.govpn.info
Hey jcmt2 I have a web app in another language, I want to be able to support Kerberos tickets using www-authenticate: negotiate. I pass the header, however the other language has no Kerberos support so I am unable to decode/validate the ticket that it receives to 1) verify it, and 2) extract the user information (mostly username). Would it be possible with your library to write a simple client that accepts a keytab (and kerberos config) along with a base64 encoded ticket and have it return the important stuff based on the exposed APIs (without having to hack things apart). I've tried this recently with java but it's been one trial after another and I'm very much not in a happy place anymore.
Neat!
Nice! but I think its more awesome to have tests.
&gt; Go, its tooling does warn you about invalid format strings
Make a twitter bot that tweets the phase of the moon every day. If you search on godoc.org, there is a package for moon phases already, so the hard part is done. 
Make a REST api. Basically hook up a database and expose endpoints (urls) that would allow people to access what you have in the db. So like GET /users would show all the users as json. GET /users/42 would display the user data for user ID 42. Then add some security with loging in, error handling, creating and updating items, give users an association and work with sql joins, etc. Anything you build is gonna need those basics, so start with that and keep adding onto it, see where it takes you.
If I need something initialized to a non-zero value, I usually write a test.
1. https://rakyll.org/style-packages/ 2. https://medium.com/@benbjohnson/standard-package-layout-7cdbc8391fc1 3. https://peter.bourgon.org/go-best-practices-2016/#repository-structure 4. https://www.goinggo.net/2017/02/design-philosophy-on-packaging.html 5. https://forum.golangbridge.org/t/comparing-the-structure-of-web-applications/1198 Base the structure on what is valuable in your project. The more important something is the higher up and more prominent it should be in the code-base.
Maybe using a factory function would be a decent approach? Then you have the arguments to the function checked and you only need to get it right once.
How? At best you can use another process to monitor a child process, but as far as I'm aware you cannot *trap* `SIGKILL`
And here is the interview with the creator of Node.js saying how he now uses go: https://www.mappingthejourney.com/single-post/2017/08/31/episode-8-interview-with-ryan-dahl-creator-of-nodejs/ 
Makes sense. Like you said, might as well fix it. Thanks for catching that.
Nice one. Leave your Twitter here if you want so when I'm done that account will follow you
I must admit the idea is good and exactly what i asked for. My fault was that i forgot to mention i did that using gorilla mux. If you have any ideas please keep going and i got one question: do programmers really like to make interfaces for databases aka RESTapi? 
&gt; signal.Notify enables a program to respond to process signals such as SIGINT, SIGKILL You *can't* catch SIGKILL. It's uncatchable.
Reading Go code is damn delight. It is always tempting to put more into any language. But, glad the powers that be did not.
You‚Äôre absolutely correct. I misread the docs apparently. Thank you,
You‚Äôre absolutely correct. I misread the docs apparently. Thank you,
I love Go as well. :)
Tricky in this case would be if the error could not be identified at compile time and was left undiscovered until the line was run. I'm not sure why you think that it's a trade off, because it is an error that is *definitely* a mistake that you are going to need to fix. There are other aspects of Rust that may be annoying, mostly pertaining to its borrow checker. It's more work convincing the compiler that your code is correct, even if you could blurt out the correct code in C in a heartbeat. But checking format strings definitely isn't that annoyance.
So what would you recommend to use between browser and server?
The compiler checks whether `a.myField` is a valid access, not the runtime. Now, it's true the compiler does store the type information _somewhere_ in the binary so `reflect` can access fields by names. But in your scenario, the compiler is doing the checking. I'm not sure about the rest of your post. You should read up on the rules of accessing fields and now types implement interfaces.
What does 'render your dev environment' mean?
Cool. You should write a post on how you made it :)
Given the skylark hashtable is implemented with linked lists, linear probing and grows are full copies (iterate over every entry and re-insert into new table), I'd imagine the performance isn't fantastic compared to python's C implementation, or Go's map implementation for that matter. Obviously for it's use case, configuration, it's perfectly adequate. The implementation of the hashtable hints to me that skylark is not performance oriented in any real sense, and as stated 'Skylark is a dialect of Python intended for use as a *configuration* language.', so I'd bet money it doesn't hold a candle to CPython or pypy in straight up performance. Pure conjecture on my part. Still, benchmarks would be interesting! 
Thanks, I'll take a look!
Aye, immediately thought about wireguard... You could consider to use that encryiption (and routing) scheme, and help that specific project going forward. We're doing Wireguard for __all__ intra-site comms. It's REALLY great. 
Thats a great help thanks and looks interesting. We're writing a few new services, so may try to get peoples buy in to try something like this on one and see how it goes. Thanks!
Note, I am not reading into your use case, this is for using WS in general. But it sounds like you could benefit from [centrifugo](https://github.com/centrifugal/centrifugo), aside from that you could either use gorilla/websocket or gobwas/ws for your own implementation. You have to keep in mind that socket.io adds a lot of overhead, [here](https://hashrocket.com/blog/posts/websocket-shootout) you can see a benchmark of different solutions, keep in mind that one uses x's ws library, which is deprecated and suggests using gorilla one, gobwas/ws is more efficient solution. Also it doesn't show socket.io there.
Might be a design issue? 15kb seems really big for a message. For most apps it's probably best to only send messages that describe how to modify the state on the server or client, not big chunks of state itself. Something like `move playerID x y` (serialised) would be a good small message. Just a few bytes. Also check out MessagePack: http://msgpack.org/index.html That said, I've had good results with https://github.com/olahol/melody and raw websockets in the browser. They're well supported these days, so there's little need for socket.io. I also used the go's concurrent map for state on the server, but I've only needed one instance.
https://github.com/gchaincl/swagger-proxy is still a work in progress but it does the job
That's right, a struct in the memory is just it's field. So where's the type info? In fact, when not talking about interfaces, there is no need to store any metadata anywhere. All the type info is checked by the compiler - the compiler knows what struct it is (bc/ code) and translates field accesses to correct address acceses. Now, the only place where we need to know the type during runtime is with interfaces. So, when assigning a value to an interface, compiler also stores the type in the interface value. Note, that this type doesn't have to be present in the runtime prior to storing in the interface. Compiler knows that you are assigning an int to interface{} and thus generates instructions to store the correct type.
Precious info, Thanks! Centrifugo looks awesome as it wouldn't require me to rewrite my entire server in a different language. But since, in that case, it would rely on a Nodejs server, I wonder if it wouldn't just hold me back in my quest of trying to use all available cores. C++ is looking very good as a server! I almost started drooling in awe when I saw the charts and how much more performant it can be than Node.js. It's just daunting that it's also equally more demanding code-wise than using Node.js, and it doesn't help that coding in C++ is in general like walking on eggs because of all the potential memory leakage. I will be giving a shot to Gorilla/websocket and C++/Websocket++ whenever I summon enough courage to start rewriting the back end. Thanks a lot, btw!
I've done a lot of stuff in Bash, and a little bit here and there in python. However, Go was the first language that I learned to the point of actually being able to use it professionally.
Wow, so you didn't have any previous experience with this kind of syntax? How did you learn Go? Any resources you would like to point me to?
C, Java, Ruby, PHP, JavaScript
With experience in these languages, did you find learning Go easy? Approx how many days it took you to start using Go efficiently? Also, since you have experience with a good number of other languages, how would you compare Go with these languages?
I just went through the golang tour, and started writing. Importantly though, I have been using other tools written in golang, and I quickly figured out that I can read their code on github, and import their packages and use them. This is what made it so easy to learn.
Great. I use VS Code and love how you can see the code of any library function/variable just by right click -&gt; go to definition. Thanx for sharing your experience mate :) Also, you use Go in your daily job?
Yes I do, but not as much as I would like. I'm hoping to switch soon to something that requires it a bit more.
Okay, best of luck for that man üëçüèª
Cheers.
Only sending diffs is a great idea actually! In fact, the client only sends a few things like the position of the mouse, whether the mouse is clicked or not and information about the size of the screen/browser (for ratio purposes, so that instead of sending the whole universe, the server only sends what will fit on the client's screen). Therefore, the players are created and updated on the server side entirely. I like the idea of sending only diffs to the client too. But that would imply updating every player on the client side (which I fear can worsen the experience for some users according to how many players there are to be updated). But I think it's definitely a route worth exploring. MessagePack and melody sound very interesting! I'll look more deeply into them, thanks!
Python 2.7/3.5 and javascript (frontend and backend).
Bash, Perl, Python, C#, Javascript
JavaScript on backend using Node? How's your experience with Go compared to Node and Python for backend? Also, how did you learn Go? Any resources you would like to point me to?
That's some diverse skill stack :D How's your experience with Go compared to other languages? Also, are you using Go in your job? Actually, I am curious to find what kind of things people are doing with Go in real world.
C++ just forces you to catch and release memory. Shockingly enough, once you‚Äôve built the algorithms and gotten things set up, you will generally know exactly when you need memory and when you don‚Äôt, so it‚Äôs pretty easy to new and delete or malloc and free at really good times. C++11 has also introduced quite a few things to simplify memory management like shared and unique pointers. Go is a much nicer place to be for concurrency though. C++ makes you do a lot of work to safely talk amongst concurrent tasks.
I moved to Go from NodeJS for writing backend web code and I also use it for CLI utilities as well ([Cobra](https://github.com/spf13/cobra) is awesome). I write all my server side web code in Go now, it's infinitely nicer than the clusterfuck that is Node's single thread async model. I write my client side web code in VueJS. And yes, I use Go at work and at home.
Basic, 6802 asm, Pascal, Scheme, C, Java, Ruby, bash, perl, Haskell. Those are ones I've either used professionally, or in major projects. Oh, and Databus on Datapoint computers, my first intern job. I've done toy programs in a dozen others, but these are the ones I could, at one time, claim proficiency in.
Great. I am also starting to like Go + Vue setup for web apps. Played with Node for a while and didn't really like it; tried Go and instantly fell in love with it :) Thanks for sharing your experience mate :)
I have less number of years of experience than the number of languages you know :D It would be great to know your experience of Go lang compared to other languages. Also, what you currently use Go for?
I do not consider me using Go efficiently. I am using only for my personal projects and there's no other person using it around me to we share knowledge. I still feel not knowing if I am doing it in the right/best way, but the go vet / lint help a lot. The "functional" oriented programming from javascript helped. The Ruby/C/Java helped by being close related, OOP. And it was easy and fun to learn by practicing.
I get it, kind of similar situation here. No one in my circle is using Go. BTW feel free to share your personal projects here or in DM, I am interested to look at it :) I recently made a little webapp myself to download Tweets as Wallpaper and PDF using Go: http://tweeload.com. I agree, its fun to learn that way.
 &gt; JavaScript on backend using Node? Yes, I learned it for my work to build API's since most of the project was written with it. However after 2 years of sleepless nights, because the API's were crashing all the time, I got quite bored and wanted to learn Go for fun so I have started rewriting all the micro-services from nodejs to Go. Within 2 weeks, my colleagues complained that our backend it was not crashing as usual, the response time dropped from 3 seconds to &lt; 100ms on rush hours (20K req/sec) and I was able to use only 3 servers instead of 20. The reason why I stuck to Go is that a typed language avoids bad surprises at the runtime. Easier to ship, nodejs in China is just a pain in the ass while I just had to ship binaries to my servers when I switched to Go. I have only used Python for web project and simple scripting. If I need to ship a project fast, I will use python. If I need to ship something a bit more data intensive, I will use Go. Nodejs is just a toy for me and just looking at javascript makes me sick (I am definitely a javascript hater but It's my personal opinion) Golang, like any programming language I wanted to learn, I think about a project I have already done before and start to rewrite it with the new language. I spend a lot of time switching from my code and google so I don't have any particular link to give you. Except [Go by examples](https://gobyexample.com/) 
Wow! That's some well-detailed feedback. Thanks a lot for sharing this. Really surprised by the performance difference you got by switching to Go. Plus, less crashing too - that's fantastic! Currently, I am also switching back and forth between Google and VS Code :D 
Each prog. language has it's own use case. I work on many projects related to big data and data processing so Go is the perfect tool for it.
Oh, DropzoneJS. They always produce the great music.
C,Python
In order of when I learned them: C++, C# 4.x, XAML (for UI building in WPF), Java, Python 3.x, bit of MIPS, HTML, CSS (but I suck at it), tiny bit of Javascript (bit of Node.js but more frontend than backend), enough SQL to get around, tiny bit of Bash, PHP. After Go I think I'll learn Kotlin. Also French and English. ‚òú(Ôæü„ÉÆÔæü‚òú) (‚òûÔæü„ÉÆÔæü)‚òû I found the language itself to be pretty straightforward to learn. The first step was being able to read the language and the only thing that was preventing me to do it at first was the short variable declaration ``:=`` which I had no clue what it was for, followed by discarding function return: ``_``. Once I knew these symbols the rest followed. I started using go to make a simple sudoku solver, then an API. For the API I was using a framework that was doing most of the work so I only really coded the DB layer. I wasn't really using what the language proper so my learning stalled until a few months ago where I coded a new project. Took my a few days to be comfortable with struct and other concepts like how to pass data to Handlers without globals. Truly, and I keep saying it, the hardest concept to grasp was moving from a mostly OOP experience to a procedural language. My experience with Go has been very good so far. It's fast and easy to develop something (especially web services), the tooling is awesome. Imo the doc is simple and a lot more readable compared to C#, Java, and Python. However, I deeply hate everyone who breaks the tooling in such a way that their program won't build with ``go get`` or if they use any Makefile (I'm on windows, life isn't easy). While I don't have much experience with Node.js so take this with a grain of salt, it's really easy to write spaghetti unreadable, multi nested level mess that actually won't run correctly because it has a runtime error somewhere. I still find Node.js w/ js incredibly interesting and I'd love to get more experience with it. Go encourage readability and it will just yell at me on compile time (unless I make some mistake with how I access pointers).
Yes, this blog conveys how we can improve the performance of normal APIs.
Great. How did you learn Go? 
Wowi that's one amazing journey, isn't it? Btw I am also planning for Kotlin after Go. :) What are you using Go for right now?
I've mentored a couple new college grads in Go as their first professional language, but they had CS degrees and whatever that entails (basic C# and Java in these cases, I think). Personally, I used C#, Python, JavaScript, VBA, VBScript, VB6, SQL, and some pretty simple bash, batch, and PowerShell. Since learning Go I've also moved from using JavaScript to TypeScript. My previous position was migrating from Python and C# with .Net Framework to Go and C# via .Net Core (except where the scientific libraries were best in Python). Now I'm in a position where I'm all C# but still hobby in Go with TypeScript (by way of Angular).
Wow, you have so much of experience under your belt sir! Hatsoff! Thanks for sharing your experience, means a lot :)
I'm running a public readonly API (I plan to get rid of my framework and rewrite with gRPC for fun), a Discord bot (it doesn't do much but it was fun), a CLI client to help maintain and update the API mentionned above. It can parse json to update the database, backing up the database, etc. I wrote it to automate things and reduce the time spent doing the work manually. There's still room for improvement.
I've done tons of python, C, C++, perl, java, php and javascript. Plus a bunch of ada, haskell, ocaml and various lisps. Plus a few other languages I've played with. I still do lots of C++, python and javascript, but I tend to use go whenever I can.
I like the phases of the moon idea. You could make that restful and be able to add/remove accounts it will tweet to through an api. As far as enjoying it? Obviously in the real world clients have much larger expectations than just being able to log in. Things can get pretty complex and requested features can get very challenging. Just because the data is exposed on the web via an api doesn't mean the business logic for each endpoint is super simple. So yeah, I definitely enjoy it because the api aspect accounts for maybe 1% of the work, the rest is the same type of problem solving and challenges that all programmers like.
6502 68000 C Java Python and Go Firstly i used Go to write specif program where i needed concurrency and speed. But finally i also use Go for stupid crud web app for readability in the long term. I'm too old to play with magic of Python !
Many sites might have minified assets in production but want to use uncompressed CSS/JS while developing. Instead of using a build script to manually create a production copy of your site, Spin let's you write production code and replaces strings/files on the fly to make your development mode work.
https://www.reddit.com/r/golang/comments/747siz/linked_lists_as_map_keys_a_weird_go_trick/
Until now... just it: - https://github.com/gumieri/huexe - https://github.com/gumieri/act
JavaScript, Ruby, Node.js, Python, and also knew C and C++ from college.
In descending order of expertise I used the following professionally before learning Go: Python, C/C++, Java, C#, Scala I sorta view Go as the bastard child of Python and C. It has become my preferred language for all of my side projects.
NodeJS / Javascript. I got fed up with the language and the dependencies and found Go, never looked back.
C#, C, C++, Python, VB.Net (shudder), Java, bash. Post learning Go, mostly JS/TS and C# sometimes. Wish I could code more Go.
C/C++, Java, php, JavaScript, C#, visual basic 6, Ruby, and a few others. I started using go in 2015 and I got heavy into go in the last few months. I just do programming as a hobby. It's a really good language and I highly recommend it for anyone wanting to get until programming or anytime needing to get away from dependency hell. That's not to say it doesn't come with it's own isms or that it is perfect though. 
If you need a full fledged browser (for js): https://github.com/knq/chromedp is also written in Go and has only Chrome as a dependency (can run headless in Docker)
Kool. Do you use Go at your job?
It seems programmers looove Go! üòÇ
It doesn't store the information in the binary. It knows which function to call with which address.
Yes, I also feel the same way. Go has goods of both the sides. Also, would love to look at your side projects, if its ok with you. Till the date, I have made only one app with go - http://tweeload.com. One more is under construction. :)
Oh, great. What do you use Go in?
Had a look at them. Good going man. Best of luck :)
Wow great. What do you use Go for?
Languages that I used most often before Go: C++, ruby, php, python, and Objective-C.
And now switched completely to Go? If I may ask, what do you use Go for?
Dabbled in C++. Used PHP, Python, FE/BE Javascript day-in-day-out. For 2018, mulling moving over 100% to Go and FE Javascript (vuejs).
100% Go + Js! Nice. I assume you develop backend for web in Go? Any reason to not go with Node crowd?
I started in C++. Learned C and Java for my first job. Then lots of bash and python. Then Perl, JavaScript, and ruby (specifically Ruby on Rails). Then RJuby, closure, scala, and LISP. Now Lots of Bash because of Docker. And some golang when I can. Early in my career I was all about the languages. Then I cared about the style (tabs vs spaces, directory layout, etc...). Then I was about the patterns (Gang of 4, book). Now I am all about the solving real problems (I don‚Äôt care what the language is, only that what is tested is what is deployed (i.e. no dynamic dependencies) That is why I am starting to uses Go more and more. It removes style, layout, and dependency arguments and focuses on writing the code that solves the problem. All languages more or less read the same when you understand the syntax, because in the end the programmer is trying to solve a problem. So if you understand the problem set then the code will make sense regardless of language. Java, python, ruby, and other exception based languages consider data to be first class and error to be second class. Most of the code will have the happy path as the only path. Errors will either be over or under handled, but if the programmer has skill the then extra unit tests will be created to account for this. C and it‚Äôs brethren treat errors as first class and data as second class. This leads to handling all but the most obscure errors as the path of flow making it hard to see the happy path (which is why exception languages were created). Again extra tests will be added to ensure the data is correct. Go treats errors, and data as first class. So you will see error handling in the main flow. But you don‚Äôt have to handle every specific case, unless that is important to your code. So in this way it is the best of both worlds. A small number of unit tests will exist to test a smattering of errors and data cases, but it is usually enough. 
Python and Bash
I haven‚Äôt switched completely to Go, but I have pretty much switched out what I would normally do in ruby, python, or php with Go. So I mainly use it for back end web services or for making a ‚Äúone off program‚Äù to run like a script. I mostly use Go for my personal projects though, I have only used it at work as a ‚Äúone off program‚Äù for one of the projects I was on.
All of my BE code for intensive operations is already in Go and faster than Node code as well! The PHP web dev will be looked at being ported over to Go Web next year. My opinion is that Go is much faster, uses less memory, less CPU, better typing, is multicore out of the box. Compiles into a binary for easier deployment. I never liked the dependency trees with Node. I like a tight codebase and knowing exactly what everything is doing. Hence why so few services are actually running with Node. What's stopping me from being 100% Go, is that there's no 100% working chromedp and webrtc with Go is also lagging. Can't wait until these two are resolved. I know some devs like to build stuff in a weekend and say it's production ready. You can't do that, when you are running a multi-million dollar operation that is mission critical. 
Wow those are some useful insights! Thanks for sharing mate :)
You use Go at job or Python?
idk, I've probably been really good at ~20+ languages. Not all at once though, I've almost completely forgot important knowledge for writing production code of languages I've been programming in daily for several years. Go looks like an ok first language to me, the documentation is maybe a tad too targeted towards people who already know a lot of programming related concepts. Python might be a better starting language but if you know JavaScript Go is probably a good second language to dig in to. The choice depends on what you know and what you want to achieve. 
Absolutely agree with you about the elegance of error handling in Go compared to other languages. Also, the focus on problem instead of unnecessary points make Go the language of Makers. Thanks a lot for sharing your thoughts mate :)
In order: Basic, Lisp, C, Python, Scala, Go, JavaScript Once you get past a few languages, they are pretty easy to pick up and you begin looking more at the trade-offs made in the design. I use Go a lot, but it's not always the best tool for the job. Knowing when and why to pick a different language for a particular project is important. But often, simplicity and readability trumps exact fit over the long term. That's why Go is often a good default choice. 
If I may ask, in what kind of situation you would prefer JavaScript over Go?
Perl, self educated :)
thank you, for you too üòä
order learned - several assemblers, C, C++, matlab, Forth, Python, Erlang, Lisp, Go, Lua, html/JavaScript/PHP, Nim, Rust, and native Kotlin. Currently using, modern C++, Python, and Lua at work. C++ on embedded hardware, Python for scripting/tools, and an embedded LuaVM (excellent C FFI) on hardware for R&amp;D work. Using the LuaVM on both an RTOS and embedded Linux has been a great experience. Our hardware is typically many months ahead of our system level software and by wrapping some low level code and exposing it to a LuaVM it allows us to easily exercise and test the hardware with Lua scripts (i.e. download scripts remotely via SSH and run, so no need to compile new binaries or re-compile and flash new images, etc...). Ongoing personal projects, some Go, Forth on several small embedded systems and recently Kotlin native. I've experimented with Nim and Rust for several SDR (software defined radio) projects as well. Lots of asm and C, and some Erlang, at work back in the mid to late 90's. html/JavaScript/PHP for some server (work and home) stuff. One of the absolute worst experiences for me has been, by far, doing OOP in matlab, but I've also worked with what I thought was horrible code in every language I listed. I still/currently enjoy coding in Forth, modern C++, and Kotlin. I started working with Go back in 2010 and began using it at work in 2011 for performance sensitive test equipment automation (GPIB/VISA) when Python was just too slow, several coworkers picked it up as well and it grew a bit from there. I still use Go on several home/work projects and I guess I view Go as a workhorse language (same view for Python) and it's definitely a great tool to add to one's belt. edit s/ones/one's/
Python, PHP, js/html/css Honestly I really like go because its hard to write bad code in it. And you can just build and ship binaries. I still love Python and always will but go is awesome because of those two points.
Python and Bash on the job. Learning Go in my free time at home. Most of the stuff I work on involves AWS.
This was written mostly because I found the "api" for running skylark scripts to be fairly inscrutable, and kind of cumbersome. You don't need skyhook to run skylark scripts from your go code, but it can get you from 0-60 faster than using skylark alone, and adds some niceties on top of the raw skylark library.
Pascal, C, Perl, ASP, Java, PHP, JS, Scala, Python, and now Go. Feels like coming home :) 
R, JavaScript, Node.js, Python. Small amounts of PHP, Haskell, C/C++
Perhaps you are mixing up compiling and running ? By analyzing the source code, the compiler knows the type of a and a.myField, and it can therefore fail to compile a.myField.some_logic() as that is invalid. Once you have written a correct program, there doesn't need to be a check for this at runtime. 
Your normal web stuff HTML, JavaScript, PHP then more scripting languages like Bash, Python, Perl and VBS then slightly more hardcore with Haxe, AS3, C# and Java. I am currently using Go as an alternative to C# and Java for multiplatform Support and my latest little project is using an Echo backend with a VueJS frontend.
Sometimes. I've written a couple projects for internal production use. 1k - 5k lines. Not big, but super fun. Also used the reverse proxy for dev'ing and built some utilities. 
C#, JavaScript, PHP, Python, Ruby (in order of professional use). I'm trying to replace small web services that I used either Ruby or Node with ones made in Go. So far so good.
When did google decide to make a small Python-like language?
R, IDL, Python, Java, C#, VB.NET
As a general idea, I doubt that if scaling an app in an ecosystem you are familiar with is problematic, you'll have better luck in a new and unknown one, be it Go or something else. Also the answer to this problem lies within testing, not asking randoms on the internet which have no idea about your application.
Languages that I have used: Common Lisp, Scheme, Prolog, Haskell, x86 ASM Languages that I have used in non-trivial projects: Fortran, Yorick, IDL Languages that I could still write something useful in: C, C++, Java, Python, Bash, Perl, Ruby, JavaScript, Rust (this one's complicated I toyed with go at launch but didn't use it in earnest until recently).
Auth protocols tend to expect you to retain some form of token to ask for info. I'm guessing you could just get data you need, hold it in a structure or a volitile keystore like redid for reference while the user is using your service. Permanent service data would need to be stored and pulled local to your service typically based on a unique ID. When I looked up gothic, I got a ton of teenage angst, so I can only speculate based off what I know about oauth systems. If you could link me to the gothic API I could take a look for you. 
Skylark is the main language of the Bazel build system. That said, I'm wondering why the reimplementation in Go.
[removed]
PHP, JS, Lua and C#
Haha, nice, I'm starting to wonder if we work at the same place.
Haskell (professionally), plus VHDL, a bit of Python, a bit of Vimscript, and a good deal of Rust.
Fixed: https://github.com/everdev/spin/blob/master/spin.go#L61
And after that, what's the next step?
Forth, Logo, Basic, 6502 asm, Z80 asm, C, Pascal, x86 asm, REXX, Smalltalk, Perl, SQL, some C++, TCL, shell, Java, Common Lisp, Scheme, Javascript, Python, Lua, Prolog, Clojure, D, Ruby, a little Erlang. I'm currently learning Elixir. I'm probably missing one or two and left out a dozen DSL's and other weird stuff. At this point I write pseudo-code in comments and then figure out the language I'm supposed to be working in :)
For front end. There are other options that transpile to JS like GopherJS or ScalaJS. But with Typescript, I find JS not too bad for front end. I wouldn't consider it for the backend because I think there are a lot better options available, like Go. 
Presumably so they could write similar configurations for their go code. 
I mean, I'm not sure that semaphores, mutexes, and mmap/malloc is "a lot of work", but making nice abstractions around it is a pain
system admin stuff (analysing logs, generating web content), web and microservice stuff, and for developing AI prototypes. Go is good for web and microservices for obvious reasons, but I also like it for admin stuff as it is so easy to deploy and rather fast, and for AI prototyping as it hits that sweet spot between C++ and python : somewhat fast, somewhat productive.
Coming late to the party, but here's my list :) Visual Basic, C#, C, C++, Pascal, Python, Java, Haskell
both Atom and Visual Studio Code are good. Visual Studio Code is a bit faster.
Visual Studio Code. Not an IDE, but afaik the best for Go dev, once you install the go helpers.
I am a big fan of VSCode for Golang development, it's fast and feature rich. You will get autocomplete, go to definition, refactoring, automatic formatting and import optimization, test coverage viewer, and of course debugger.
Basic, C, ARexx, Java, Ruby, Javascript, Python. Along with some Bash, a bit of scheme, something called Draco, even a (tiny) bit of Assembly code (6502, HC11). 
The Go Team recently added this page to the documentation website: https://golang.org/doc/editors.html as a comparison of the popular editors for Go. There are many other things each of them can do so try them out and use whatever makes you the most productive.
Perl (long time ago), C, JavaScript, Java and Python. 
Oh thanks for that, just getting started in Go and at times the resources are wonderfully overwhelming...shoulda looked there first!
Cool, feel free to ping me if you have any issues / need any guidance for Gogland / Webstorm + Go plugin or open an issue here: https://youtrack.jetbrains.com/issues/Go ;)
How do you grab text from a specific div?
I used Emacs mostly, now turned to Gogland, even though my Emacs setup is nearly as powerful as Gogland: 1. Autocompletion: Gogland is better than gocode, but it is not night and day difference (Gogland can autocomplete for non-imported packages). 2. Code navigation: nearly the same 3. Refactoring: Gogland leads a bit ‚Äì on receiver renaming it suggests to rename all receivers and it can change package names. Nor go-rename, nor go-doctor can do this. Extraction is on about the same level (godoctor behind it for Emacs) 4. Project navigation ‚Äì Gogland leads. 5. Linting ‚Äì Emacs which directly uses golinter is much better. I miss warnings for uncommented public names in Gogland. 6. Go toolset integration. By default Gogland is better, but Emacs with my setup is more potent. 7. Debug. Slight lead for Gogland here for overall experience, although not by much. All in all, I cannot say there's huge difference between them for Go coding. But I found myself using Gogland one day.
I've been using Bazel &amp; Gazelle lately, and I'd love for Go to unify its build system around Bazel tbh
With the [nexus](https://github.com/gammazero/nexus) WAMP client, a client instance provides a [Done()](https://godoc.org/github.com/gammazero/nexus/client#Client.Done) method that returns a channel that signals when the client is no longer connected to a router. This will signal your application when the router has gone dead. See [example](https://github.com/gammazero/nexus/wiki/Client-Library#wait-for-the-shutdown-while-handling-events)
Thanks for the overview. A couple of things to note: &gt; Linting ‚Äì Emacs which directly uses golinter is much better. I miss warnings for uncommented public names in Gogland. This has been fixed in EAP 15, see: https://blog.jetbrains.com/go/2017/09/28/gogland-eap-15-inspections-intentions-performance-intellij-2017-3-and-more/ And more things are on their way. &gt; Go toolset integration. By default Gogland is better, but Emacs with my setup is more potent. This is something that's also being worked on, if you have any specific thing that you'd like to see, drop a note either to me or here https://youtrack.jetbrains.com/issues/Go Have fun coding.
* _(11 years ago)_ **PHP**: Tiny bit, started out investigating a pre-built site for a private server me and a friend were running for some MMO. * _(10 years ago)_ **HTML, CSS**: Got into this after working on that, and at high school they encouraged it. * _(7 years ago)_ **JavaScript**: Years later, in-between my first and second years of university. * _(7 years ago)_ **More PHP**: Same time as the above. Continued on with PHP for a long time then mainly until I left university. I worked for a year at a PHP-based e-commerce place and learnt a ridiculous amount there. On my placement I started to understand the role of automation more by using tools like Vagrant, and scripting. It's also when I picked up Linux instead of Windows... * _(3 years ago)_ **More JavaScript and PHP**: Started working professionally at a digital agency. Worked on a very wide range of projects. Including some in other languages too like **Java**. Did hybrid mobile apps, CMS builds, bespoke PHP builds with frameworks like Symfony. A big focus on mine was on DevOps and automation. I really led the drive here with tools like Docker (and even though I left recently, they've got a LOT of my images in use there now...). I joined the agency at mid-level, skipping junior at this point. My placement really set me up well for it. * _(1.5 years ago)_ **Go**: Finally, some Go! I actually tried it out and didn't like it! A friend who worked at that same agency (who was on placement, very smart guy - he'll do amazingly in his future). It was good in many areas, but I didn't like a few things, and I was on the hunt for a new "perfect" language to learn... * _(1.5 years ago)_ **Scala**: About a year and a half into working at that agency I heard about functional programming. Decided to check it out, and took a look at Scala. I really liked it, but it's just woefully unproductive. Learning it is difficult, but doable, but the actual developer experience is terrible. Compilation is super slow. The type system is amazing, and maybe I'd enjoy something like Haskell or Elixir, but I haven't had the time to focus on that yet - as I have been spending more of it getting more up-to-speed with Go! Around this time I was promoted from a mid-level developer to senior developer at the agency I worked at. * _(1 years ago)_ **Go**: I kept hearing more good things about Go from that friend who used it, so I thought I'd better give it another shot. After not enjoying Scala really, I finally understand many of the things that made Go amazing, and felt so much more productive. Since then I've used Go almost exclusively for personal projects (throwing in some Node.js and Kotlin for good measure). I don't touch PHP much any more at all. This week has been my first week as lead developer at a company that is now primarily using Go - and I'm loving it so far. So, Go is not my first programming language by any means, and I have missed off a lot of other things I've learnt along the way (some Java, Kotlin, Node.js, Bash, tiny bits of Python, bla bla bla - once you've got some programming experience it's quite easily transferable). It was trivial to pick up Go and get started with it, honestly - but there are still a lot of things you have to learn, and while you can get started easily, it will take a long time to master any language. Go has it's nuances, but it actually behaves like you'd expect in many circumstances which is great compared to something like PHP... IMO, Go is a great language to learn. It will feel quite different to JS I expect. If you were to work with C and Python it might feel a bit more familiar. 
Python, PHP, Javascript, C I've had 3+ years of experience writing code as full time job in each Python and PHP. I was hired as a full time Golang developer based on my prior experience (with employer knowing I don't know Go) and I've had code running in production within 2 weeks of starting - go is REALLY easy to pick up.
C, C++, Python, Java, Perl, JavaScript
I've tried a few over the years. The ones I'm happy using, at the moment, are: VS Code, vim-go, Gogland. Of those 3, I now prefer Gogland. It has the occasional crash, but the integrated debugging environment is excellent. I held off on trying it for a long time because I was happy with VS Code, but I'm glad I finally did check it out. I'll be using it the most going forward.
[removed]
I too like VS Code. I do anticipate trying Gogland when it has an official release because Jetbrains is fantastic even if not entirely my style / preference.
Bazel is indeed pretty nice. It's too cumbersome for just Go projects though, I love that you can always do go build without having to install anything. Perhaps Bazel will use dep's lock file and translate it to Bazelspeak? I actually find dependency management in Bazel to be tedious and obnoxious.
that is great, thanks for sharing, i wrote about this a bit ago https://www.critiqus.com/post/multi-stage-docker-builds/
&gt; It has the occasional crash That's not good, can you please open an issue here: https://youtrack.jetbrains.com/issues/Go with the logs attached? You can find them via Help | Show logs in... and zip up the directory that opens up. Thank you.
C, C++ , Scheme, Assembly and Rust. In order of high to low proficiency.
No, I mean full time on the fly linter which will immediately mark "bad" parts. Your inspections don't cover full golint functionality, that's it. &gt; This is something that's also being worked on, if you have any &gt; specific thing that you'd like to see, drop a note either to me or &gt; here https://youtrack.jetbrains.com/issues/Go 1. Gogland binds `go generate` to the specific file and even to the specific `//go:generate ...` line while it will actually run any generation command within a package. This doesn't make a sense. There should be a way to know if package has any `//go:generate` at all and an ability to run generation for the package. 2. Integrate `go install`. Bound to `main` packages. You see, this is really hard to even to understand how to clearly implement this for the Gogland. And is fairly trivial in Emacs: `go-generate` just runs `go generate` for the package I am currently in and `go-install` installs a package which is in the current directory.
try that, after installing gazelle: ``` $ gazelle -experimental_flat -go_prefix github.com/my/project -external vendored ``` It will generate single `BUILD` file with everything. Then you can just `bazel build` with it. 
Gothic needs to to have a store for the state token used in OAuth2, this could be a cookie store (store everything in the cookie, encrypted), or use a session store (store everything on the server, usually persistent using a database or files, but could be in memory as well) which stored the session ID in a cookie on the client. Both are susceptible to CSRF though. Basically you can pass a `gorilla` `sessions.Store`, use that for gothic and then afterwards use it yourself. Personally I used `goth` itself, the underlying library, as it is more versatile. Look at this for an example: https://github.com/markbates/goth/blob/master/examples/main.go You don't have to store the session ID yourself. After login you can set some data so you know the user is logged in. Storing the user ID in the session is a good example.
I don't work much in browserland. I assume there's a javascript library for e.g. msgpack, which gives you data model practically identical with json. There also seem to be javascript libraries for protobuf.
"elegant", ugh.
Go-lang or go home... ammi right?
The build files with gazelle are not too bad, they're auto generated after all. I'm more referring to the WORKSPACE file with the need to manually declare all dependencies, including transitive ones. Does this handle that as well?
Youre never too old for magic. Xou only neef imagination
I've been using Gogland almost exclusively for a few months now. Before this I used Vim with Vim-go mostly and for a few weeks Visual Studio Code to try it out. Gogland is pretty close to where I would want a Go IDE to be at this point. Vim-go is also nice if you enjoy the general Vim workflow. Visual Studio Code makes for a "lightweight" Gogland alternative, depending on what you want from an editor / IDE it might be sufficient.
6800 machine code, various assemblers, VAX/VMS DCL, GWBasic, Python, C, CORAL66/250 and Monk.
You don't have to if you use vendoring. Gazelle will find them.
I've been trying out Goglands for a week or so as well. It's very feature rich but I too have found it a bit buggy, laggy, and has crashed twice. I run it on an internal network so I have not been able to submit the report. I'm hoping they make it a bit faster to run through its file sync and highlight routine every time you change and save code or open new files. Seems like I wait for at least 10 seconds on large projects. I had to up the VM ram to at least 2gb as well because it kept running out of memory, as well as running out of inotify handles 
Thank you for feedback! &gt; No, I mean full time on the fly linter which will immediately mark "bad" parts. Your inspections don't cover full golint functionality, that's it. This is because ` golint ` does not work on in-memory files like the IDE does so the inspections have to be ported. That's why I said that there's more to come there. &gt; Gogland binds go generate to the specific file and even to the specific //go:generate ... line while it will actually run any generation command within a package. This doesn't make a sense. There should be a way to know if package has any //go:generate at all and an ability to run generation for the package. I've filled this issue: https://youtrack.jetbrains.com/issue/GO-4581 to allow running of ` go generate ` for the package of the current file. &gt; Integrate go install. Bound to main packages. Unfortunately this is not something very straightforward to solve in a manner which will not surprise users. For example: How should this work in case there are two files with two ` func main() ` in the same directory? Or what if there are two or more ` package main ` in the same project? What should the IDE do in those cases? &gt; You see, this is really hard to even to understand how to clearly implement this for the Gogland. And is fairly trivial in Emacs: [...] and go-install installs a package which is in the current directory. If you want to use those tools, you can create custom tools via Settings | Tools | External Tools , see: https://www.jetbrains.com/help/go/external-tools.html , which allow you to add any tools you want to the IDE and even bind them to shortcuts / have them run before any Run Configuration starts. Hope it helps.
What is ‚Äújust ridiculous‚Äù about running multiple Node processes in a cluster? Separate your state to Redis or another DB, then cluster your app. At scale you‚Äôll have to do this regardless of the language you use: eventually your Go (or C++ or whatever) variant will require more resources than a single machine can provide as well. Other than that, as others have mentioned, sending just diffs will help. Switching to a faster language like Go will help temporarily. Eventually you‚Äôll have to solve clustering anyway. 
Alas, I regret to tell you that this is redundant to what is already in the standard library, albeit in a combination you may not quite have expected. `exec.Cmd` already offers you os.Stdout, Stderr, and Stdin via setting io.Writers and io.Readers, as you already know, and you can use an [io.Pipe to invert the flow control between the reader and writer](https://golang.org/pkg/io/#Pipe) if you want, as so: package main import ( "fmt" "io" "os/exec" ) func main() { cmd := exec.Command("cat") stdinReader, stdinWriter := io.Pipe() stdoutReader, stdoutWriter := io.Pipe() cmd.Stdin = stdinReader cmd.Stdout = stdoutWriter cmd.Start() stdinWriter.Write([]byte("hello world\n")) b := make([]byte, len("hello world\n")) io.ReadFull(stdoutReader, b) fmt.Println("Received: " + string(b)) } Now, there is room for a library that builds on that and then perhaps offers other functionality, but be sure to check out what the standard library already offers. For instance, if you're looking for "give me the next line", you can already wrap stdout with a bufio.Reader and use [ReadLine](http://127.0.0.1:9000/pkg/bufio/#Reader.ReadLine). But you can go beyond that and write something like an [expect library](https://www.lifewire.com/linus-unix-command-expect-2201096). Though if that sounds cool and you just want to use one, [there are definitely some available](https://godoc.org/github.com/coreos/gexpect). I mention this stuff because it's important as a Go programmer to know how to snap all the pieces together in the standard library related to readers and writers. It doesn't necessarily have everything you need, but it's got a lot of good stuff.
I'm sorry you are having problems, I'll ping the devs to also have a look at this but without the logs / https://intellij-support.jetbrains.com/hc/en-us/articles/207241235-Reporting-performance-problems it's next to impossible to figure out what causes the issues and fix them. Are you using the latest release, EAP 15 (173.2696.28)? Can you provide some steps to try and reproduce this? You've mentioned a VM, should I run any particular VirtualBox + Linux version + Gogland + some open-source projects in it to reproduce this? Do you have the files mounted from the host OS? Maybe the VM has issues with file system making it slow for the IDE to use? Do the slow sync issues this happen if you run the IDE on your computer and sync the sources in the VM using the Remote Host plugin? You can have a look at this short video I've created on how to do this: https://youtu.be/D_04aG9eH1U Is the project open-sourced by any chance / can you at least provide the list of open-source packages it depends on so that I can try and recreate it? Thank you.
&gt; Gogland is pretty close to where I would want a Go IDE to be at this point. What could it do better?
Look up jobs, look at what they are looking for, fill the gaps in your knowledge. Then, get a job, I guess.
I use Intellj but It stuck during debugging. Any of you faced the similar issue ? 
It could happen for a number of reasons. If you go to Settings | Plugins, what version of the Go plugin do you have? And what version of Go are you using? Which OS? Is the project reproducible by me? You can also open an issue here: https://youtrack.jetbrains.com/issues/Go and I'll be happy to help out as well. Thank you.
When I say VM I meant the Java Virtual Machine that Gogland uses. It's a setting in the Help menu to increase the heap size available to Gogland. So I am using it on a high end workstation with code mounted on NFS. That could be the cause of high usage of inotify handles and slow scanning. But it's how we work in our company to have our project data available to all workstations. I think you could pick any large project, like say Kubernetes, and just load it from and NFS mount. It requires a lot of ram and adjustments to the max inotify handles. And the sync and highlight is pretty slow. 
I read the name of this project as Gob Encode (Go native encoding format) 
You need to include all the files when running or building go run ./... or go run *.go
i wonder why they always need to describe their software as "elegant". sure golang is "simple" but elegant? meh.
C, C++, C#, Java, BASIC, Prolog, Turing, JavaScript, LISP... Primarily C++.
here is gothic source code: https://github.com/markbates/goth/blob/master/gothic/gothic.go here is gothic example: https://github.com/markbates/goth/blob/master/gothic/gothic.go
What do you use bazel and gazelle to do, exactly? 
Visual Studio Code.
Just checking out Bazel with toy go projects. I am also trying to reimplement gomobile bind using skylark and bazel to learn it. However, the go story is a bit complex, especially compared to go build. That said, Bazel is super powerful and I am still learning.
Is there any difference in cookie store and session store? I thought they are the same. The example you provided is also using gothic. I believe you are trying to tell me to save user ID of users logged in with the session ID gothic created in the cookie store. That is reasonable. I will give it a try. Thanks edit: I just modified my code and it works just fine. However, since gothic called session.Save() already and so after I called session.Save() to save my own variable, there will be 2 set-cookie headers in response header. It would be great if it can also be solved.
C, C++, BASIC, Ruby, Java These are the ones that I had strong understanding of. I have done other languages here and there. Learning Go as your first programming language is not bad. It's quite forgiving compared to C, but can teach you pointers as well. Although, previous knowledge of C was what helped me tremendously when learning Go. Everything just clicked.
I was initially using Atom, but it developed a bug in Windows that constantly crashes it. Tried everything to fix it So now I'm using VSCode and I love it. 
+1 to VS Code
True that! I'm dumb if I think I'm running away from scaling by going to Go. My problem is that I need to use all the cores, use them harmoniously to run one version of the app per server, and have them distribute the task of communicating with the clients without blocking anything. With Node, clustering will make me run one version of the game on each child process, which I don't want because it doesn't get me out of anything: if when using one core, the app starts failing at 200 users, using 4 cores with one version of the app on each would mean 4 times more players are allowed, but not the 800 are interacting together; you still have approximately that same limit of 200 players per game, although there are 800 on the server. From my understanding, using Redis wouldn't have helped either. Please, correct me if I'm wrong, but I got the sense that Redis allows you to store the sessions and connections so that when one cluster emits, the message can be emitted from all the other clusters too, to their respective clients. The problem with that is that my scenario requires to have one cluster running the game logic, and the other clusters taking care of getting messages from client sockets, transmitting the inputs to the game logic to perform any necessary operations, and retrieving outputs from the game-logic core, tailored to each client, and sending these out. This, so that the heavy emissions would not rest on one core but the load would be shared. Now if I understand the principles of Redis well enough, it is not really made to transfer data from cluster to cluster as if it was just copy-pasting data from a folder to another on the same machine, but rather ensures a consistency in the messages that are emitted. Also, the idea of simply emitting from the game-logic core to the dispatcher cores (and let them emit to their respective clients) would make the CPU fail at even less than the 200 users benchmark. This because the game-logic core would first be dispatching the total amount of data every 30ms, but this time to 3 other cores (which is approximately 3 times the size of a normal emit message). And just to clarify, the reason I am not running independent versions of the game on each cluster is that the game features some randomness (objects placed here and there, CPUs deciding to take a certain action and therefore ending up at location [x,y] in state z). So having different versions running would be fine as far as seeing the other human players and their actions, but the randomly generated behaviors wouldn't be consistent.
The idea behind clustered apps is you store ALL state in the database. Redis works well for this because it‚Äôs very fast. Although generally you‚Äôd have a two stage storage system, where you have Redis for temporary state and another slower but more classical DB for more permanent state. Essentially the idea is, you have your state (the actions CPUs take, the random numbers, the position and actions of your players) and put it all in your database (like Redis). Then, each server process is in charge of updating its clients with that state, and processing updates from clients into the global state. Each clustered server process doesn‚Äôt actually store any state itself. It just shuttles it between the database and its clients. You‚Äôre correct that you don‚Äôt have 100% efficiency: this approach won‚Äôt scale you to 800, probably a bit less. That‚Äôs why you can‚Äôt just stop at clustering, you still need to do other changes such as diffing. I was only addressing the point that clustering is still what you‚Äôll need to do regardless of server language, unless you‚Äôre confident you‚Äôll never need to scale past a single server. If you are confident you‚Äôll never scale a game instance to run on more than one server, you could switch to Go or some other language and avoid the issue I suppose. 
I love that the test suite is actually super legit
If all files are in the same directory, and they're all in package main, no imports are needed.
I think I see your point! I didn't consider Redis as a sort of database but just as storing the sockets (which is utterly false looks like). I haven't had much chance messing around with it and seeing for myself how well it works because I'm using express 4 and the documentation doesn't really cover its use with Redis. When I figured out how to make it work it ended up only using 1 of 4 working child processes. Many people have posted this same issue on blogs but no one seems to come up with a suitable answer. I'm posting the issues myself right now on stackoverflow. If Redis will act as a DB and can store temporary states, it will certainly not scale to the exact factor of cores due to the fact that it'll be using a DB, but it will be significantly better than using one core. Rewriting my server in go isn't much of a hassle as it is tedious, I have the feeling that it wouldn't be too hard. But at the same time if I can save some time and get a few less players than 800, it'd be something. This is provided that a working solution can be found for the cluster worker issue I talked about above. If think you're right, scaling will keep its value. I'm not too sure I'll need to scale across multiple different servers, but I never know what may befall me. Thanks for the insightful import!
Alas, 'JSON' is just there.
Simpler than C++ and Java because of a much smaller language specification. And, depending on your point of view, also simpler than dynamic languages as Go lacks all the ‚Äûmagic‚Äú that many dynamic languages come with.
What is "Type-aware autocompletion"? VS Code is definitely not type-unaware.
Me to. If it's possible to change the name to go-bencode, I think that would be good.
it doesn't work when I do `go run main.go` it complain about the routerfunction that is defined in `routes.go`.
The only thing I can think is that it means the autocomplete box is not sorted to prefer values that are the appropriate type for the current context (method argument, etc) in the way some Java editors do.
Here is my old go bencoding library inspired by std lib: https://github.com/tumdum/bencoding
Use `go build` or `go run *.go`. run and build have very different behaviors, run is for running a set of go-files, whereas build is for building a package.
Go is definitely simple. Go absolutely has an excellent stdlib. Go is very easy to read. Go is brilliantly designed for its intended use case. Go is definitely **not** *beautiful*.
Beauty is in the eye of the beholder. üòâ
&gt; For example: How should this work in case there are two files with two func main() in the same directory? The same way `go install` works: $ go install # two_mains ./main2.go:5:6: main redeclared in this block previous declaration at ./main1.go:5:6 Either the project is in fact broken or the dev meant to do sth like `go run`. The definition of what `go install` should do is not ambiguous. &gt; Or what if there are two or more package main in the same project? Tell the user what to do. 
Had a luck to stumble on LiteIDE first thing, and never felt need to search for alternatives. It is fast, productive and not bloated which I hate. It is open source and works on huge number of platforms. https://github.com/visualfc/liteide 
Agree on VSCode. Ctrl+Click on a method/function is the best thing ever and usally just comes on IDE's, here it works with a plugin. Even support for an integrated terminal is awesome, on Windows you can even run WSL in it.
&gt; Go is definitely not beautiful. I think it is. Simplicity and clarity is beautiful.
I think there is some beauty in the simplicity but agreed it‚Äôs not a beautiful language 
Yes, the session store stores a session ID in a cookie and uses this to retrieve the data on the server. Any data stored is never send to the client. With a cookie store all data is stored in the cookie, encrypted to prevent the client from altering it. It's easy to start with the cookie store but you can easily switch later on to another store. There are a lot of implementations for the gorilla store. Personally I prefer the data to stay on the server. `goth` is the main library and `gothic` is build on top of that. The example is for goth, not gothic. Goth will set a cookie when retrieving the auth URL, but you will set a cookie when the auth is complete, namely when you get response from the auth token exchange. This is at two different moments that a cookie is set, not at the same time.
Yes I know they are set at two different time. I guess I just have to remove the duplicate set-cookie header manually.
Autocomplete isn't as snappy as I'd like it to be.
Pascal, C, Standard ML, OCAML, Java, C#, Python. The last 4 professionally. 
[removed]
I use cloud9 ide https://c9.io The support is good enough but the real benefit is it being online. 
I love how it sorta forces you not to be too witty with your code and saving the next guy a headache.
Why not do it without too many packages. Obviously use cors but try it without others. Put in a js search bar. Allow multiple requests on the same page. Have the page take in any api. Make multiple tables and try to make an api from them. Write a code generation cli tool for APIs. Make a darn fine logger for APIs. Allow restful requests all on the same page that can run at the same time. ... Anything
Wow, thats a cool IDE, man I had no idea when I started this thread how much it would turn into a buffet...lots to choose from...how do you feel cloud9 does in terms of compiling, does the online factor in to performance at all? (Just off the cuff it seems that your internet connection might add a bit of latency, but I have no idea) Cloning your entire environment is appealing though...
LiteIDE has no support for multiple cursor editing and other small things you expect to work out of the box when coming from other editors like Atom or VSCode. Despite this it's one of the best go-centric IDE's out there.
No problem, happy to help! 
Umm it's nice in that you get a container and terminal. But they say explicitly they will not serve your app in a production environment. I think because they may not have the team and hardware. But it's perfect for building stuff at work or school or at home. I use a chrome book and just open it up and code. No waiting for load times, updates, errors, initialization, other processes, or anything! Just pull the top up and code. The only downside is cloud 9 sometimes has maintenance. But the benefit is for interviews when you need to show them your program code/working example and it makes sure it's using the same environment. I actually write in cloud 9 and pull GitHub and then clone to digital ocean online terminal and that's it. It's also cool to share projects and it has code blame and you can actually code at the same time and see their cursor. So yeah that's pretty much what I use and do so I don't ever wait or worry about devices. Also cloud 9 has go installed by default in each container. So no setup required. Only thing that kinda is goofy is the whole database server ports and dealing with cors with it. Which can be a pain but it comes with phpmyadmin installed with a database. But the ports thing kinda gets weird with any container environment and leads to bugs. https://community.c9.io/t/setting-up-phpmyadmin/1723 https://docs.google.com/document/d/1Zb9GCWPKeEJ4Dyn2TkT-O3wJ8AFc-IMxZzTugNCjr-8/edit?usp=drivesdk For those who are worried about security, idk use a locked pc, stored in a locked room, with a program that rewrites and deletes your data as you write I guess. Cause you are using chrome right now anyways....
Ok that makes sense, and might fit with me needing a "mobile" environment to code while I wait around etc...I mainly code on a Mac but mornings I'm logged onto my Windows machine...
I've seen DB agnostic code used before and you can certainly do it with an interface as you suggested. In my experience though, it's rare to change databases during a project. Some people also use an interface so they can mock the DB during testing. If you don't like mocking, then another option is to have your models return a prepared SQL statement. In your unit tests, you can test if the right statement was prepared. In your integration tests, you can test the handler and the execution of the statement.
Define beauty. For me the clear syntax, the simplicity, and the predictability create a very beautiful picture of a programming tool.
I just edited my comment for some resources and well the port issues that arise for any container environment that'll make you frustrated. https://docs.c9.io/docs/multiple-ports https://dinosaurscode.xyz/go/2016/06/19/golang-mysql-authentication/ https://github.com/GoesToEleven/golang-web-dev/blob/master/021_third-party-serveMux/01_julienschimdt/main.go
Strengths d), Go is portable in that it's really really easy to cross-compile. Machine code is the least portable code. Am I completely off-base here?
&gt; it's rare to change databases during a project. I've really come to enjoy using an in-memory (usually simple data structures, not a formal database) storage adapter during development. Quick to setup and allows other parties to try out the application on their machines without a long list of requirements, which is quite useful in a business environment. As an added bonus, that same adapter allows tests to run without any dependencies or purpose-built mocks since it conforms to the interface just like a real database would. Then, you can build the storage adapter for the actual database. I find it nice to be able to test this specific package against a real database dependency without other tests requiring the same. I agree that it is rare to, say, switch from Postgres to Oracle, but I don't think it should be rare to use different storage adapters during a project. It really improves the development experience.
Atom with the go-plus plugin is pretty good.
I always find these types of statements perplexing. What evidence is this based on? As a user of Go, I find the lack of generics as one of the language's greatest flaws. I hate the idea that I have to either give up compile time validation (interface{}) or lean on macro style "solutions". I could offer up a sweeping generalization of my own. People who dismiss the need for generics in Go do not understand the value of compile time vs runtime type checking and/or have never experienced an more advanced type system like the one found in Haskell or Rust, which can provide all the convenience of Go's "interface{}" but with compile time safety guarantees and runtime speedups. I could offer up that generalization, but I wont; because I really can only speak for my experiences, and maybe those of my colleagues, who seem to agree with me. But I really don't understand the pushback against generics. Perhaps the folks who are so against generics have only experienced c++ templates? Go is a neat, compact language, but it could be a safer, arguably faster, more expressive language, with the introduction of generics IMHO. I would personally like to see some sort of Algebraic Data Type support (variant discussion above) coupled with compile type interface validation (sans interface{} ) and (too much to hope for) pattern matching. 
I was thinking that it's possible that different models may be stored in different database, say a user model may be stored in postgresql, or job model may be stored in mongodb etc. 
Guess it depends what your defintion of 'being portable' is and what exactly you need to be portable I like go because it's as easy as setting your GOOS and GOARCH to something different and you can immediately build a native linux binary from windows while this *is* more work than just a python script that will run anywhere *where python is installed*, once you have that native binary (which, with go, is easy) it can run anywhere without installing anything first, which I think is a huge advantage (mostly because I like writing little programs for friends and having them install some runtime/VM for my chosen language would be annoying vs running a native binary)
For me (windows/vscode), autocomplete seems to be pretty snappy? https://i.imgur.com/l0aXYJv.gifv 
Thanks for pointing this out! Updated the post. 
What I mean is that I don't get autocomplete when I expect to. It hangs searching, then it just shows `PANIC` as the only option in the dropdown, for functions defined in the same package. I have to resort to Ctrl+hover to see the method signature.
Oh that's weird, I don't think I've ever had that, the worst thing for me is on startup theres a good few seconds before it kicks in but otherwise tends to be pretty smooth for me
&gt; The only thing I can think is that it means the autocomplete box is not sorted to prefer values that are the appropriate type for the current context (method argument, etc) in the way some Java editors do. It's actually the opposite. It's narrowing down the completion scope so that you only can get suggestions for what's appropriate based on the type of the parameter / value / etc used. Maybe I'm ignorant to how VS Code works, but here's what that feature means: - Gogland: https://i.imgur.com/eDGtXS5.png - VS Code: https://i.imgur.com/sTwcCzJ.png If there's a way to obtain the same results in VS Code as in Gogland? In Gogland there are two completion modes, the normal one (invoked automatically when typing or manually via Ctrl+Space) or the "Smart type" one which is invoked via (Ctrl+Shift+Space). This "type-aware" is basically how the feature is named in all JetBrains IDEs, "Smart type" completion. Furthermore, Gogland can "predict" what is likely to be typed by the user based on further analysis it performs. Hope it helps.
I write Go every day at work. We use Go + gRPC to build out our services.
I concur...
Node is single threaded, so you're only using a single core of that server - go has no such problem, but it will not solve your issue, because the bottleneck is elsewhere: 15KB message, to 300 users, every 30ms (or 33 times per second) is 15KB * 300 * 33 = 145MB/s. 145MB/s is 1.13Gbit/s - you can't send that much using gigabit network connection, which sounds super excessive for such a low number of users.. to put it into perspective: a single user that stayed online for 30 days would get over a terabyte of data. Counter Strike: Global Offensive uses a maximum packet size of 1200 bytes, with most packets being smaller and with default settings has per player bandwidth cap at 80KB/s - about 1/6 of your average, while having updates happen twice as often (64 tics/s). You will need to start using state diffs and there is no way around it. Most likely for continuous changes (like movement) you will have to make movement itself a state: - player n state change 1: started moving at angle x, with speed y - player n state change 2: empty (figure out how to skip?) - player n state change 3: changed movement angle to x2 - ....
That makes more sense. The impression I got was that the machine code was what makes it portable, rather than the intention that the machine code allows for a lack of separate program to run it.
I find the same thing. Cyclic dependencies are really hard to avoid with any kind of relational data.
Good article. There seems to be a need for an editing pass - as an example "Error in build in interfaces that describles types that can be treated as an error values." has a couple issues. 
checkout mage if you want something better than makefiles, but easier to understand than bazel: https://magefile.org
Author here: Thanks for pointing out. I was trying to lead this article to perfection, but small typos can always arise. I must pay greater attention to details like this.
No problem. The gophers slack channel would surely have folks that would offer suggestions on this or future posts. Thanks for your contribution!
You mean " Important interfaces that every Go developer ~~should~~ **knows**"
Thank you for screenshots. This is the reason I can't use anything but a good IDE ;)
it should be "built-in" or "built in". Minor nit but it is a detail. Another point to note: wrapping errors is nicely addressed by github.com/pkg/errors.
The 2016 Go Survey results: My preferred code editor: (ordered choice, up to 2) 1,359 (25, 13%) Vim 814 (14, 9%) VSCode 676 (10, 9%) Atom 687 (13, 6%) IntelliJ 655 (10, 8%) Sublime Text 305 (6, 2%) Emacs 137 (2, 2%) Visual Studio 153 (3, 2%) LiteIDE 99 (1, 2%) Eclipse 37 (1, 1%) Acme 238 (4, 3%) Other 425 (12%) No response https://blog.golang.org/survey2016-results
You're welcome. On hearing more about your requirements, I would say you should definitely invest in a redesign. As far as I can see, you have two major options - keep state on each client, and make it 'eventually consistent', or keep the state on the server, and make it fast (go will help here). But in either case, you should be sending very small messages only. If you're sending state back and forth, something is wrong.
Excellent technical comment about the ephemeral vs more long-lasting data storage requirement. So many apps run into this sooner or later, and it's a very important skill to figure out which data should be stored where.
Yes. No.
Thanks :)
If you're thinking about pulling out the length as a variable for efficiency's sake, benchmark it first: var ( iters = 10000 k int l = make([]int, iters) ) func BenchmarkLoopLen(b *testing.B) { for i := 0; i &lt; b.N; i++ { for j := 0; j &lt; len(l); j++ { k = (k + 2) % 9 } } } func BenchmarkLoopStored(b *testing.B) { for i := 0; i &lt; b.N; i++ { for j := 0; j &lt; iters; j++ { k = (k + 2) % 9 } } } BenchmarkLoopLen-8 30000 50569 ns/op BenchmarkLoopStored-8 30000 51602 ns/op (these results fluctuate by around 1000 ns/op)
Wut 
What language(s) would you consider to be beautiful?
whenever you loop without a **for...range**, simply cache it in a var, you'll probably do something like `cnt := len(x); fmt.Printf("iteration %v/%v", i+1, cnt)`
hello, what do we have here? love these, thanks!
Does syntactic sugar equal beauty?
I'd accept that or whatever language can do anything in the least possible amount of code. 
You can set an isClosed value for the iterating system. On loop, check if closed. If so, break out of loop
Generally, using len is faster than storing the value. The compiler optimizes the former better
Does this support Windows?
TIL. https://github.com/golang/go/issues/22131 &gt; Essentially I'm thinking to actually use the vulnerability to supply the notice. While a noble intention, you're still running code on other people's computers without their permission. Do you live somewhere where that's legal? And are you sure you won't get extradited to a country where it isn't?
how would you do it? can you add a simple example? maybe I didn't explain my problem well
Technically yes it is evaluated often. You can probably look at the assembly output to confirm. Realistically, no it's probably not worth worrying about. `len(x)` is stored at the head of the slice so it is already a pretty fast reference. More details here: https://blog.golang.org/go-slices-usage-and-internals
OK I was curious enough to dogfood my own suggestion. Pretty neat stuff the SSA compiler backend is doing behind the scenes here: len.go: package main func main() { x := make([]int, 42) for i := 0; i &lt; len(x); i++ { x[i] = i } } `go tool compile -S -S len.go` "".main STEXT size=124 args=0x0 locals=0x158 0x0000 00000 (len.go:3) TEXT "".main(SB), $344-0 0x0000 00000 (len.go:3) MOVQ (TLS), CX 0x0009 00009 (len.go:3) LEAQ -216(SP), AX 0x0011 00017 (len.go:3) CMPQ AX, 16(CX) 0x0015 00021 (len.go:3) JLS 117 0x0017 00023 (len.go:3) SUBQ $344, SP 0x001e 00030 (len.go:3) MOVQ BP, 336(SP) &lt;-- this is exactly the space needed, it's an array not a slice! 0x0026 00038 (len.go:3) LEAQ 336(SP), BP 0x002e 00046 (len.go:3) FUNCDATA $0, gclocals¬∑33cdeccccebe80329f1fdbee7f5874cb(SB) 0x002e 00046 (len.go:3) FUNCDATA $1, gclocals¬∑33cdeccccebe80329f1fdbee7f5874cb(SB) 0x002e 00046 (len.go:4) LEAQ ""..autotmp_4(SP), DI 0x0032 00050 (len.go:4) XORPS X0, X0 0x0035 00053 (len.go:4) ADDQ $-48, DI 0x0039 00057 (len.go:4) DUFFZERO $201 0x004c 00076 (len.go:4) MOVL $0, AX 0x004e 00078 (len.go:5) JMP 95 0x0050 00080 (len.go:5) MOVQ AX, CX 0x0053 00083 (len.go:6) SHLQ $3, AX 0x0057 00087 (len.go:6) MOVQ CX, ""..autotmp_4(SP)(AX*1) 0x005b 00091 (len.go:5) LEAQ 1(CX), AX 0x005f 00095 (len.go:5) CMPQ AX, $42 &lt;-- SSA knows it wasn't modified, len hardcoded! 0x0063 00099 (len.go:5) JLT 80 0x0065 00101 (len.go:8) MOVQ 336(SP), BP 0x006d 00109 (len.go:8) ADDQ $344, SP ... len2.go: package main func main() { x := make([]int, 42) for i := 0; i &lt; len(x); i++ { x = append(x, i) } } `go tool compile -S -S len2.go` "".main STEXT size=225 args=0x0 locals=0x1a8 0x0000 00000 (len2.go:3) TEXT "".main(SB), $424-0 0x0000 00000 (len2.go:3) MOVQ (TLS), CX 0x0009 00009 (len2.go:3) LEAQ -296(SP), AX 0x0011 00017 (len2.go:3) CMPQ AX, 16(CX) 0x0015 00021 (len2.go:3) JLS 215 0x001b 00027 (len2.go:3) SUBQ $424, SP 0x0022 00034 (len2.go:3) MOVQ BP, 416(SP) &lt;-- extra space here for slice overhead 0x002a 00042 (len2.go:3) LEAQ 416(SP), BP 0x0032 00050 (len2.go:3) FUNCDATA $0, gclocals¬∑33cdeccccebe80329f1fdbee7f5874cb(SB) 0x0032 00050 (len2.go:3) FUNCDATA $1, gclocals¬∑33cdeccccebe80329f1fdbee7f5874cb(SB) 0x0032 00050 (len2.go:4) LEAQ ""..autotmp_4+80(SP), DI 0x0037 00055 (len2.go:4) XORPS X0, X0 0x003a 00058 (len2.go:4) ADDQ $-48, DI 0x003e 00062 (len2.go:4) DUFFZERO $201 0x0051 00081 (len2.go:4) MOVL $0, AX 0x0053 00083 (len2.go:4) MOVL $42, CX 0x0058 00088 (len2.go:4) MOVQ CX, DX 0x005b 00091 (len2.go:4) LEAQ ""..autotmp_4+80(SP), BX 0x0060 00096 (len2.go:5) JMP 108 0x0062 00098 (len2.go:6) MOVQ AX, (BX)(DX*8) 0x0066 00102 (len2.go:5) INCQ AX 0x0069 00105 (len2.go:5) MOVQ SI, DX 0x006c 00108 (len2.go:5) CMPQ AX, DX 0x006f 00111 (len2.go:5) JGE 199 0x0071 00113 (len2.go:6) LEAQ 1(DX), SI 0x0075 00117 (len2.go:6) CMPQ SI, CX 0x0078 00120 (len2.go:6) JLE 98 0x007a 00122 (len2.go:6) MOVQ AX, "".i+72(SP) 0x007f 00127 (len2.go:6) MOVQ DX, "".x.len+64(SP) &lt;-- reading/comparing to slice.len every time 0x0084 00132 (len2.go:6) LEAQ type.int(SB), AX 0x008b 00139 (len2.go:6) MOVQ AX, (SP) 0x008f 00143 (len2.go:6) MOVQ BX, 8(SP) 0x0094 00148 (len2.go:6) MOVQ DX, 16(SP) 0x0099 00153 (len2.go:6) MOVQ CX, 24(SP) 0x009e 00158 (len2.go:6) MOVQ SI, 32(SP) 0x00a3 00163 (len2.go:6) PCDATA $0, $0 0x00a3 00163 (len2.go:6) CALL runtime.growslice(SB) 0x00a8 00168 (len2.go:6) MOVQ 40(SP), BX 0x00ad 00173 (len2.go:6) MOVQ 48(SP), AX 0x00b2 00178 (len2.go:6) MOVQ 56(SP), CX 0x00b7 00183 (len2.go:6) LEAQ 1(AX), SI 0x00bb 00187 (len2.go:6) MOVQ "".i+72(SP), AX 0x00c0 00192 (len2.go:6) MOVQ "".x.len+64(SP), DX 0x00c5 00197 (len2.go:6) JMP 98 0x00c7 00199 (len2.go:8) MOVQ 416(SP), BP 0x00cf 00207 (len2.go:8) ADDQ $424, SP 0x00d6 00214 (len2.go:8) RET 
Although I wouldn't underestimate the will of law enforcement agencies, I also would be surprised if any entity actually went to the trouble of extradition for this. The bigger concern, IMO, would be casually traveling to a country where you're wanted and may not even know it (like happened recently at DEFCON).
This looks amazing.
Can you show an example of how you would write your function that is doing the operations without considering cancellation?
https://golang.org/pkg/context/
[removed]
Very important posting. Needs a slight grammar and language check but otherwise nice post!
before clicking on the link, i can already tell it's from cznic, his Go projects on github are amazing.
Probably because they mostly post outside r/golang. As for me, the more I've used Go, the more I hate it.
This was the first big (not only Golang) project I contributed to! It's awesome.
This is a little bit like what Drone doing: https://github.com/drone/drone
What's the use case for embedding C in Go? To avoid cgo? 
"Beauty" is far too overloaded to mean anything. Perhaps more accurately it's not as aesthetically pleasing as other language's syntax?
Go binary is portable between the same operating system. Python script is portable between any environments with access to the correct runtime and installed libraries. Go is portable across operating systems in that the cross compilation is friction-less. 'Portability' depends on your requirements. 
I use VS code too
Ok, that makes sense. My background is C++ and I haven't used JetBrains software yet. You could say that Gogland is more type-aware. But VS Code is not type-unaware because otherwise this wouldn't work: something().[autocomplete members of return type of something]. There are actual type-unaware autocompletes, for example the last time I checked a base install of Vim comes with a simple identifier or word autocomplete when you press ctrl+n.
https://youtu.be/f6kdp27TYZs
&gt;[**Google I/O 2012 - Go Concurrency Patterns [51:27]**](http://youtu.be/f6kdp27TYZs) &gt;&gt;Rob Pike &gt; [*^Google ^Developers*](https://www.youtube.com/channel/UC_x5XG1OV2P6uZZ5FSM9Ttw) ^in ^Science ^&amp; ^Technology &gt;*^406,394 ^views ^since ^Jul ^2012* [^bot ^info](/r/youtubefactsbot/wiki/index)
Lots of typos, needs proofreading. E.g. in the code often you had `contens` and `contains` referring to the same thing. 
This is a really good book on the subject. [Concurrency in Go](http://shop.oreilly.com/product/0636920046189.do)
[removed]
[removed]
Yeah, actions always bring reactions. The fact you are "censored" as you claim is just the result of your awful behavior within this community. You are the only one to blame here and you learned it the hard way.
I started working with Go a couple of days back, so I'm far from being an expert but I use a lot of RubyMine and IDEA at work so I got Gogland right away and so far I'm very happy with it. It has some if not most of the features that you'd expect from a Jetbrains IDE and they also work pretty well. Especially the intregrated UI for debugging is extremely helpful, in my opinion. But I'll still give vim-go a try as well, as vim is something I wanted to check out for quite some time now, anyways. But jeah, Gogland is definitely worth trying out. And it's still completely free.
It's just a how-to documentatiom, but in a slightly different form it was used, for example, in the [sqlite driver before translating all of the C to Go](https://github.com/cznic/sqlite/blob/1a3b0a731a9d2b66fb058caef95c004634b17307/sqlite.go#L150) By introducing "standardized" binary formats of the executable and object files, the same technology is just now a bit more generally accessible for anyone else.
I think its a good idea, IIRC similar to here: https://medium.com/@benbjohnson/standard-package-layout-7cdbc8391fc1 But its more typing, and I hate typing..
To put it in a different perspective: Assuming `x` is a local vaiable, `len(x)` is just reading of an address at fixed offset in the stack frame. Accessing the cached value in another local variable is again just reading of an address at fixed offset in the stack frame, so no savings are to be expected. (Ignoring that the compiler can cache some values in registers, then the superfluos variable can actually hurt performance.)
https://talks.golang.org/2013/advconc.slide
Rather than do a massive for loop, consider using sync waitgroups, which you can read about here: http://goinbigdata.com/golang-wait-for-all-goroutines-to-finish/
Thanks, I will implement a better solution. But do you have any idea about why for {} breaks https?
Haven't a clue, but see if the waitgroup think fixes it!
I'm sure it will, because using select {} fixes it! I'm just so confused as to why select {} vs for {} affects the behaviour on a different thread, and wondering if this is some kind of bug in the implementation of net/http.
You can read here how to block forever in Go: http://blog.sgmansfield.com/2016/06/how-to-block-forever-in-go/ As for breaking the https, that's not possible. Fix your code, not pseudo-problem you cannot reproduce because of bugs.
It's still illegal, but it has been done before. https://en.wikipedia.org/wiki/Anti-worm
**Anti-worm** Anti-worm (sometimes helpful worm), has multiple meanings in the field of computer security. It can be a piece of software designed to protect against computer worms, combining the features of anti-virus software and a personal firewall. It can also refer to a worm designed to do something that its author feels is helpful, though not necessarily with the permission of the executing computer's owner. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/golang/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.27
What do you mean pseudo-problem that I can't reproduce? I've even reduced it to a minimal example which works reliably every time. Running the code with for {} doesn't work, but select {} does, for https. Both work for http. This is super weird. Also, I've already been on that page - it sheds no light on this. for {} is listed as one of the (not recommended) ways to wait forever, and yet there is no mention of side effects on other threads trying to use https.
The answer is in that article. The for loop keeps spinning, monopolizing the core you started it on, and doesn't let the other goroutine schedule. The select construct tells the goroutine to yield the processor indefinitely, so the other goroutine schedules.
Look, using for {} to stall the main thread *works for HTTP requests on the second thread*, but mysteriously stops working for HTTPS. Changing to select {} on the main thread fixes this. I've done my research, but I don't think anyone has addressed this exact issue here. I get that for {} is busy-waiting and select {} yields.
First of all, you don't need to give ; at end of each line. Use `go fmt` and `go vet` to automatically lint your code to match with conventions. Now coming to your issue, I tried your code. The `for {}` doesn't work for both http and https versions. And the `select {}` works for both http and https. The reason is because the `for {}` doesn't allow for pre-emption as there are no yield points in a blank infinite loop. Hence, your other goroutine doesn't get a chance to run. Whereas a `select {}` waits for some event to occur and always yields while this wait is happening. In these cases, using a waitgroup is ideal as somebody has already mentioned.
Thank you for actually trying my code, you're the first one who actually addressed the http/https issue. It's not working on your machine? I literally just tested it again and it works for me with http! The goroutine code runs perfectly. It **only** stops working with https, as in, every statement before the http.Get works perfectly and that line of code blocks forever if it's https. To be clear, you changed the URL to a plain http website (one that actually works on http, and doesn't redirect to https) and it didn't work?
&gt; EDIT: The reason it is working in your case for http and not for https is pure luck. It's not. Here is a much better example, where I've used a channel to make sure the goroutine gets started properly (which it does every time, by the way) before proceeding with the experiment. I've also included my website which works on http, and you can just comment out to switch between them. It's definitely not the scheduler. func main() { c := make(chan int); go func(c chan int) { fmt.Println("The goroutine is definitely running."); c &lt;- 0; _, err := http.Get("https://en.wikipedia.org/wiki/Main_Page"); //_, err := http.Get("http://kieranvs.com/"); if err != nil { log.Fatal(err) } fmt.Println("Request done."); }(c); //Wait to make sure the goroutine got scheduled properly and is running. _ = &lt;- c; //Wait forever for {}; }
Neither "http" nor "https" works for me on go1.9.1 darwin/amd64 on a macbook pro. I have two things to say about this: 1. . What you are doing is all sorts of wrong. "for {}" means "burn 100% CPU on a single core doing absolutely nothing". Even for techniques that don't do this ("select {}"?), I still can't find a good reason to ever block forever. In this case, the problem is that you have an unnecessary goroutine. Of course, in some cases, you might end up with goroutines that need to wait for each others completion, but a Waitgroup is the way to go then. 2. Despite you not wanting to do what you are doing, I do believe that you might have encountered a bug in the runtime. What we see appears to be the runtime being out of machine threads to schedule goroutines on (you're consuming one permanently with the for loop), and while there are limits to how many machine threads will run Go code at any given time, you should be able to burn one and still execute a HTTP request. Try installing go1.8 or go1.7 and see if it worked there. Open an issue on the go github issue tracker, and post you test code.
If you ever construct a loop like this to keep your app running, use the time package to sleep within your for {} loop (eg. time.Sleep(time.Millisecond * 4)).
The for loop monopolize a single machine thread. The smallest Macbooks have physical hyperthreaded cores, so he should have at *least* 4 machine threads to schedule goroutines on (unless he tampers with GOMAXPROCS). Assuming the http client doesn't busy-loop on non-yielding code, he should be able to have 3 "for {}"'s running, and still issue a http request. It's still a terrible idea to use "for {}". Why would one *ever* want to "block forever", after the applications usefulness has expired?
1. Yeah, I guess there is no real reason to. Instead of firing off a load of goroutines and then waiting forever, I could just remove the word "go" from the last goroutine invocation, and have that run on the main thread instead. However, this is what I did, and then I came across this discrepancy between what I understand and what's happening - so I just want to understand. This isn't production code, this is nothing but a learning exercise. 2. It's not that the goroutine doesn't get a thread to run on. The goroutine works. I can do whatever I want there. I can do http requests. I just can't do https requests. There's clearly a bug in some piece of code that is running on my machine and not on yours... Did you run my code verbatim? Did you try a true http website, not a website that redirects http requests to https? If you insert a print statement before the http request, you can see that the goroutine is alive and working.
I wrote this as a result of my frustration in trying to set up existing mailing list software like mailman or majordomo. They felt bloated and overcomplicated. I wanted something simple to set up that provided mailing lists that users could subscribe/unsubscribe from and query, but I couldn't find anything that scratched the itch. So I wrote this to do that for me, and figured I'd share it with the world.
I wrote a quick test program to see how many goroutines I could have running for {} at the same time, and still spawn new ones, and you're right, I can have the main thread and 3 more before it breaks. Why is this? I am under the impression that the OS scheduler can swap out system threads on a time-share basis whenever it wants, without the thread yielding. I mean, just dump all the CPU registers into memory, put in the other thread's register values and off you go! Is this a limitation with the Go runtime?
I initially ran your code raw, and then modified the example a bit to experiment (is the gourtine even running, does it only happen if the for loop is in the main goroutine, does it happen if GOMAXPROCS is lifted, ...). I just removed the "s" from your URL to try HTTP, so it would appear that I probably got redirected to https. I had forgotten to consider that the default http client handles redirects automatically. Testing against a pure HTTP site lets the code run. So far, any combination of a blocked machine thread ("for {}") and a http.Get on a HTTPS or HTTP redirecting to HTTPS site resulting in a block (*not* pure HTTP), and the routine that issues the http request is always alive before the request is issued, suggesting that the runtime does indeed trip due net/http's use of crypto/tls. Lifting GOMAXPROCS did not help, suggesting that it is not just a simple machine thread starvation.... Trying on a Linux box would be interesting, but I do admit that I am a bit too lazy to do that myself right now.
Yes but it's not literally counting the objects. Its just accessing a variable that gets reset only when you alter the iterable.
I suspect A goroutine isn't getting scheduled because of the infinite for {} loop. That goroutine is probably in the package that handles the https call. Try something like: for { time.Sleep(time.Millisecond * 4) } See if that runs your code as expected. Sleeping will yield some time to the scheduler to execute all your goroutines.
A thing is exported from a package, which is a directory, not a filem if i'ts a top-level declaration, name of which starts with a capital letter (Uncode category Lu, IIRC). Where the package is located in the filesystem tree does not matter as long as its located anywhere under $PATH/src. The location however defines the import path that one must use to import the exported things. The import path is the absolute directory path with the $PATH/src prefix removed.
If you want a lightweight cross-platform HTML5 UI - you may have a look at https://github.com/zserge/webview The library creates a full-window webview and provides a way to make Javascript bindings to connect UI with the core logic of your app. It's very small and lightweight, unlike Electron (binaries are ~5-10MB and consume very little of RAM).
In Go, you never interact with *threads*. You make goroutines, or "green threads"/"stackless threads" as they're often called in other languages, which are then internally scheduled by the runtime on one or more "machine threads". To manage this, the Go runtime implements its own scheduler. This scheduler is *not* preemptive, but cooperative, only yielding the machine threads at certain calls which enters the runtime (I/O, locks, ...). Some of these calls might create additional machine threads to service your request, but only GOMAXPROCS (defaults to logical CPU count) threads will execute *your* goroutines at any given time. Any code that doesn't enter the runtime to yield the machine thread will block the machine thread forever (although that machine thread is preempted to execute other OS processes). This might seem complicated, silly and even limiting compared to normal, preemptive OS threads. However, it's a trick done to make goroutines a cheap resource which can be spawned in the hundreds of thousands. OS threads are (relatively) expensive to create (enter the kernel, create a process/thread with a few MB of stack, exit kernel) and run (preemptive multitasking incurs expensive context switches, which take time and renders caches useless‚Äîthe fewer the better), whereas goroutines are almost free (more goroutines does not mean more context switches interfering with work, and they have tiny dynamic stacks). If you want to learn more, then the Go model is effectively called "M:N threading" (M application-level tasks for N kernel-level threads, where M&gt;N), or "hybrid threading". The common OS model is called "1:1 threading" (1 application-level task for 1 kernel-level thread). Another alternative is "N:1 threading" (N application-level tasks for 1 kernel-level threads). There can be some slight confusion of terminology here: Some would refer to the goroutine as the "thread", while calling the OS thread a "scheduling entity" or something along those lines.
Umm .. the goroutine gets started properly because you are waiting on the channel in the main function. :) And then it does the same thing all over again. I tried your examples. Yes, the normal http site works and the https site does not work. But its luck again. Because I tried with "http://youtube.com" and it does not work. You might want to try that and see what results you get.
Did you look into ESP solutions such as SendGrid? Disclaimer: I work there.
I've been debugging this issue for two solid days, it's a little annoying for you to look at it for two seconds and tell me it's luck. "http://youtube.com" is a https request because it automatically redirects to https://youtube.com. The goroutine gets started properly every time, in every variation. That has never been the issue! This is my entire point - even when the goroutine gets started properly, you still see this behaviour, so it's not the scheduling.
Thank you, that makes so much sense! Still no closer to understanding why http works but https breaks though. I think I'll have to submit a bug report on the issue tracker.
It looks obvious to me. Let's stop and think for a moment on what is happening. The program start a goroutine, it then continue and block inside an infinite loop. The infinite loop basically doesn't give any rest to the system. While in the infinite loop, I believe the http.Get request will be fired and returned at some point. What am certain off, is that the infinite loop doesn't give any window of opportunity for the goroutine to use your system I/O to print "Request done.". &gt;if you add a print statement before the http.Get request, you'll see that the goroutine gets scheduled and runs perfectly with for {} or with select {} The nature of asynchronous code is that this behavior isn't guaranteed. It's not guaranteed that a print on line #2.5 will execute before entering the for{
Self hosting the email was important to me. I didn't have any interest in a SAAS solution. Also this is very much meant for discussing forum mailing lists, it's not for email marketing or similar.
So basically [mvdan/sh](https://github.com/mvdan/sh)?
Hi, thanks for taking the time to look into my issue. I have done extensive testing, and on my machine (which allows the go runtime to have more than one OS thread and more than one hardware CPU core), starting a goroutine and then entering an infinite loop on the main thread does not block the goroutine from doing whatever it wants. Prints, general computation, http requests all work perfectly. The **only** time it stops working is with a https request. &gt; What am certain of, is that the infinite loop doesn't give any window of opportunity for the goroutine to use your system I/O to print "Request done.". It works just fine on my machine, maybe because it's got more hardware cores or something. The goroutine can do whatever computation or IO it wants, except a https request. The effects you're describing where a for {} completely blocks the other goroutines happens at exactly four such threads - that's the number of logical hardware cores that are present on this machine. The only logical conclusion I can come to is that the goruntime assigns goroutines to OS threads in such a way that the main go thread is on some OS thread #0, and the http.Get implementation contains a bug which means that it only works for https requests if it can get assigned to OS thread #0, or in some way requires the main thread to yield. By the way, in all my extensive testing, the results have been 100% the same each invocation - the nondeterminism of goroutine scheduling seems to have little to no impact on this issue with http vs https.
Is there a demo website somewhere?
Man, if you don't see what you're doing wrong here, I don't think I should be the one correcting you, but here's a short opinion: Your account/site name is irrelevant for Go, affiliate links are useful only for high ticket items and "best [tech name] books of [year]" just won't work to fix that. Most importantly - you don't have any added value.
While it's interesting to look into the compiler to see why it gets scheduled that way on your machine, the core of the problem is in your code. It would be faster to fix it (waitgroup or use a ``select{}``) than verify whether or not there is in fact a bug in some low level code of Go. http, https, http redirect all perform different operations, and different number of operations. It's entirely possible that for your hardware it is more likely to yield at a certain time for https and less likely for http when querying a specific website by factoring content-length, and the time for the request to come back to you. Better not go down the rabbit hole.
As others have pointed out, for{} never yields control back to the CPU for scheduling other activity. You can leverage runtime.Gosched() (https://golang.org/pkg/runtime/#Gosched) to yield control back to the processor. That said, there are much better ways to block that don't hog the CPU. Probably the best is just using select {}.
You could use `git checkout` in the package's directory and check out a particular commit (in this case, the most recent commit of the branch). Then run `go build` inside the directory (or `go install` if a binary is required too).
So basically not at all
You're both right. Anonymous function in main has enough time to start (easy to check with printing "Start request" at the beginning), but http.Get itself launches more gouroutines. Getting the https request is a bit more complicated then http, and takes more time. Forever loop, as already commented, doesn't allow preemption so scheduler is never executed and http.Get is stuck trying to launch new goroutines. I think this can be properly shown by using golang execution tracer tool - it's perfect for such cases. But also, you can have indirect proofs: - add delay before running for{}: time.Sleep(500 * time.Millisecond) for {} - add runtime.Gosched (https://golang.org/pkg/runtime/#Gosched) to yield scheduler: for { runtime.Gosched() }
Use (dep)[https://github.com/golang/dep]
Hey, I can reproduce your exact issue and it does seem to have to do with scheduling as the following program works with https: func main() { go func() { _, err := http.Get("https://en.wikipedia.org/wiki/Main_Page") if err != nil { log.Fatal(err) } fmt.Println("Request done.") }() for { runtime.Gosched() } } Without the runtime.Gosched() call, I don't get the "Request done." message. I'm not sure why exactly, definitely deserve an issue on the Go github repo.
There is no web based email archive built-in. That's what tools like [hypermail](https://en.wikipedia.org/wiki/Hypermail) are for. Admins can set up a bcc to a maildir that hypermail can rebuild from, or they could use another tool they prefer instead. As the README explains, users can retrieve a list of available mailing lists from the server by emailing it. Want them listed on your website? Put a list there too, you know your platform better than I will. Want a subscribe button? That's just a `mailto:` link. There's really no need for a mailing list manager to have a web-platform built in. It's an easy thing to integrate externally. As for breaking it up into multiple files, it easily could be. It's only ~650 lines though so being one file is a non-issue. There's far more meaningful ways to improve software than inventing new taxonomies.
**Hypermail** Hypermail is a free program for creating email archives, in the form of cross-referenced HTML documents. It takes a file in Unix mbox format and generates an HTML archive, complete with an index and various sorting options. It is commonly used for creating mailing list archives, but it can archive any collection of emails. Originally written in 1994 by Tom Gruber using Common Lisp, it was rewritten in C by Kevin Hughes for its initial public release in 1994. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/golang/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.27
Hmm, actually using tracer is complicated in this case as in order to write trace into the file we need to run `trace.Stop()` in own goroutine, which is also cannot be executed due to for{}. Here is a screenshot of the trace output for my example above with runtime.Gosched() called: https://imgur.com/a/s5MaO You may note many small interruptions in Proc3 (which runs main goroutine in my case) - that's what allows another goroutines to execute.
Testing on windows on my machine with his own website because he said it doesn't do https redirect automatically. It will complete the request and print for both http and https (In the case of https it will fatal because his website doesn't have a valid https certificate). If I limit GOMAXPROCS to 1, it will never yield, it will never print anything for both http and https. GOMAXPROCS to 2 will print. This is the behavior that I'm expecting. ``for{}`` will not yield. The only reason it prints on my machine when I don't limit GOMAXPROCS most be due to pure luck, the goroutine probably execute before entering the loop. IF GOMAXPROCS is set to 1 and I replace the ``for`` with a ``select``, it will complete the request and print. This is also the behavior that I'm expecting since ``select`` will yield.
To see a vastly different doc page, compare the OP with https://golang.org/pkg/syscall/?GOOS=windows&amp;GOARCH=amd64
I am on docker and `import` imports the dependencies outside of the docker folder context. so can't checkout by going into that directory.
it's not a funny post, it's a sad post :(
Nice!
&gt; smtp_password = "*******" What a weird default password.
The future is here :D https://spatialos.improbable.io/games/grpc-web-moving-past-restjson-towards-type-safe-web-apis
Older than reddit: http://www.bash.org/?244321
That joke is far older than reddit :) http://www.bash.org/?244321
Kudos to /u/disniper for jumping in with all the info. I've been using the Go plugin and now Gogland since their early days, and the amount of progress has been remarkable; I find it already to be the best dev setup for me. I've recommended it to lots of other devs, even though still in EAP. Quick question: I have a Go project that has an embedded SQLite DB via Cgo. Last time I looked into it (quite some time ago) the Gogland debugger barfed in this situation, so I ended making a separate build that excluded SQLite. Has this been fixed, or can it be fixed? Or is this an underlying issue with delve? One more quick question: Have you guys decided to stick with "Gogland" as the brand? It really really does not sounds good in English to my ear, almost like some crazy europeans with their own language came up with it... (speaking as a european from a small country with its own odd language)
If the channel doesn't send the event, provide an empty `default:` case and the select statement will not block.
Why do you only want one copy of the client at any given time? Can you put some example code on the Go playground?
2W: log. ruiner.
I was looking into mailing list software before and wanted something like this. Thanks for making it real!
But syscall is deprecated, so you really shouldn‚Äôt use it anyway. 
Still hungry after reading the blog post. For instance interface upgrade concept is not mentioned at all. While writing about io.Reader - an io.ReaderAt interface could be mentioned and its use e.g. in io.Copy. The same with http.ResponseWriter and http.Flusher.
You can keep arguing with everybody about why it breaks, eventually you will find the answer. However, stop doing a for {} loop as everyone here has told you it‚Äôs bad practice and burns cpu unnecessarily. If you ask for help and argue with everyone about it, it just makes you look bad. Plus you have burned through two days of your employers money for something that is well documented. Tl;dr: use a select, stop wasting time and money.
hope you will have fun using this!
care to explain, what is this?
Is that new? I've been wanting this for 5 years. 
I don't know, but git blame should tell you who to thank. I tried this out on a hunch and it worked.
If you are outputting to a log either through a pipe or something this would fill your log up very quickly. 
I am talking about exporting to a c library which is why I put FFI in the title. Please see my edit
well, this is meant to work with ansi terminals not log files `os.Stdout` is what you should log to.
Firstly, I‚Äôm not doing this for work so I‚Äôm not wasting anyone‚Äôs money. I‚Äôm trying to understand what‚Äôs going on, so while changing it to select makes my code work, it doesn‚Äôt really achieve the real goal here of getting to the bottom of why http requests work in the goroutine and https requests fail. Contrary to being well documented, I believe I may be the first person to ever write about this on the internet... It‚Äôs completely my fault that most of the responders to this post didn‚Äôt respond about http vs https. See, while I thought I had created a minimal example and carefully written about everything you need to know to replicate the bug, I left out one crucial thing: redirects. It‚Äôs not enough to change https to http in my example code and see the problem first hand, you have to change it to a completely different website that won‚Äôt redirect you, like Wikipedia or YouTube would. Most people probably thought okay, let‚Äôs try it... nah, what an idiot, neither works, it‚Äôs obviously the for loop and hence I got all those replies. Your tldr basically amounts to ignore it and don‚Äôt be curious. I had already discovered that select made the code work when I posted this question. The question isn‚Äôt about how to make the code work. It‚Äôs about why http works but https doesn‚Äôt. Some responders did start talking about that, and I think the general consensus is that the implementation in net/http is a bit dodgy. On a machine with two or more hardware cores, it is supposed to be okay to hog one system thread with a loop and use the other one to do a https request. I‚Äôm really sorry you think I‚Äôve been rude. :( I‚Äôm just a frustrated student trying to get to the bottom of this, this is the first time I‚Äôve really encountered a bug in the standard library/implementation of a language, and most of the community here seemed more keen to lecture me on the busy-waiting of for loops rather than discuss the question. 
os.stdout can get piped to other files. you might want to detect if stdout isn't a terminal is what the parent poster is saying.
I think "Goglide" would be a better and less cumbersome name...
Oh! I see your point now. I was more interested on the spinners, never thought much about everything else. Maybe someone else will need that then PR's are always welcome.
[removed]
I'm not sure if that's the case, because even doing for { time.Sleep(1 * time.Nanosecond) } fixes it for me.
There should definitely be a UI element for this to aid in discovery.
Hmm, that means that it works entirely as intended on Windows (for for-loop of course consuming a machine thread, so everything works with GOMAXPROCS &gt; 1). This suggests that we're dealing with a platform-specific issue, eliminating basically everything in net/http and crypto/tls. GOMAXPROCS default to 8 on my Mac, but I tried upping it to 16 to no avail, which suggest that the issue is *not* machine thread starvation.
Please do. A report too much is better than one too little. If you wouldn't mind, please add the info from the other comments as well‚ÄîKraigius, for example, points out that it seems to work on Windows.
Don't worry about those responses. You asked a reasonable question and some people are dodging it and telling you to give up on understanding the underlying issue. Very poor advice imo. What you are doing is the best way to learn. Keep at it!
&gt; Kudos to /u/disniper for jumping in with all the info. [...] Thank you! And happy to hear you like it. &gt; Quick question: I have a Go project that has an embedded SQLite DB via Cgo. Last time I looked into it (quite some time ago) the Gogland debugger barfed in this situation, so I ended making a separate build that excluded SQLite. Has this been fixed, or can it be fixed? Or is this an underlying issue with delve? Can you please open / ping me in the relevant issue on the tracker? Try the latest version + Go 1.9.1 and hopefully things should be better now (due to a lot of improvements both in Delve but more important in Go itself). &gt; Have you guys decided to stick with "Gogland" as the brand? You can suggest / vote for the existing suggestions here: https://youtrack.jetbrains.com/issue/GO-3054
Missed opportunity to call it naked mole ret
Ohh..this is interesting.
The code is mostly consumed by team members. Also, in regards to legal stuff, I don't really care. If I landed in court over something so frivolous, I'd be spanking the plaintiff with paper work for decades. Legally speaking, it can probably be accounted for in licensure clauses. Working on a shared codebase I'd personally rather annoy them with notices than have them unknowningly be exploitable. I'm just trying to assess how people feel about it really. The idea isn't too modify or do anything really. Just notify the user "bro, your shits insecure, see CVE-2027-####"
I'm pretty sure it's been there for a while. It's also not unique to package syscall.
The same feature works for reading x/sys documentation.
I avoid naked returns as well, but this might be crossing the line into function body shaming. ^^^^Please ^^^^don't ^^^^hate ^^^^me ^^^^for ^^^^having ^^^^a ^^^^little ^^^^pun.
In this scenario, nothing gets modified. The end user is left to do their own updating. No changes get made, no legal issues should arise either. While one might try to argue arbitrarily executing code in itself is illegal, it isn't going to be doing anything the user should expect except locking their console during `go get` to force them into confirming "okay" if the vulnerability check code is ran with the -d flag. 
&gt; another request with a different username and password If your client contains username and password, wouldn't it be correct to create a new client? Ie. a standard `func NewClient(o ...Option) (*Client, error)` function users can use to get a new client. If you need a "singleton", the caller can store it in an exported package variable, if passing it is too much of a hazzle.
A general resource on Go concurrency : https://github.com/golang/go/wiki/LearnConcurrency
This is unlikely to parse the string like your shell would. Just hand the string to the shell, instead: `exec.Command(["/bin/sh", "-c", yourstringhere])`
Go routines only context switch on channel sends and between functions. An empty for loop will take 100% of your CPU and run without any context switching. The delay that someone else said "fixes it" is a function call to allow a context switch and also free's the CPU from spinning as fast as it can. TL;DR; empty for loops are always bad
If someone came up with a similarly easy to handle Usenet solution, would News become more popular again?
[removed]
I think the same discussion format is still popular - it's just shifting platform along with trends. Kids at school/university for instance use WhatsApp/Facebook groups to discuss classes and organise recreational events. Being able to reach a wide, yet specific group of people to share a common question or ask a question is very powerful. That's exactly what reddit is - with a voting system for self-moderation. Every community has its own discussion platform, chosen by collective preference and the network effect. I don't expect mailing lists or usenet to make a resurgence, but they'll certainly continue to be used in some corners of the internet for the foreseeable future.
So, it looks like everyone has told you that the for loop is taking all available cpu on the main core, however no one seems to have mentioned that block cypher's such as those used in tls don't always support parallel operations. I'm guessing that the tls library only uses the main thread for block cyphers.
Or gonaked
Thanks for your thoughts on this. Sometimes I wish all those web forums would also offer NNTP for existing clients like Thunderbird, mutt, etc.
https://youtu.be/e2QVjmN5IF4
[gonekkid](https://www.youtube.com/watch?v=qkx85TIm_OY)
This sort of thing is the first thing I wrote in go.. https://github.com/JustinAzoff/http_flood/ It does arbitrary size and time based downloads and uploads and has the client/server in the same binary as well as a flash bashed client ( which I guess at this point is kinda pointless ).
It sounds like what they really want is a semaphore to limit concurrency but it‚Äôs not being done the way it should. 
...I‚Äôve made a grave mistakeüò´
You should write an article on the topic. You have some interesting insights I'm sure.
If you're using Gogland for IntelliJ you need to specify the run configuration to package . I had the same problem until I changed it. 
[removed]
How about `sync.Once`?
Thanks to the community contribution the code now only writes to terminals in case you are worried about piping and stuff.
https://github.com/golang/go/issues/21291
Yes, I think you can detect if you're being piped or not, and choose good behavior accordingly. I don't know how to do that off hand though...
wow nice, thanks for letting me know this. it would really be really good reference for me.
you'd have to go into more detail about what packages/frameworks you're using. One way to do it could be to use tag on struct fields with some reflection.
I've red his blog before and it didn't make sense to me until sometime :) I had to write lots of code and refactor multiple times to finally make sense of it.
[removed]
Ok. The main packages I'm using "gorilla/mux" and "strconv". So basically I have a Route struct which fetches Ip, Id, Time etc. (currently only works with postman injection). And I would like it to return an error if the Ip field is omitted empty. I'm thinking something like this: if { Ip == nil (panic "Ip field required)}.
the quickest way is to instead of a `panic` call, use [http.Error](https://golang.org/pkg/net/http/#Error) and return a 400 response with your error message.
Time remaining or a generic progress bar would be nicer to have.
i use visual studio code. I try any new gogland release but it is has the following problems: * it is resource intensive, 1GB for a simple console application? * It takes a lot of time to get all the source code indexed, again for a simple console application? * It will cost a lot of money (like the others do) and will almost be the same as the free stuff if not worse. on the plus side the rename works better than in visual studio code... I stay with Visual Studio Code for now and hope gogland will address all the above in order to be of interest to me.
Good idea, I will add that to things nice to have. However feel free to add it if you have time, PR's are always welcome.
https://www.reddit.com/r/learngolang
gotour
I hate when server push and other related technologies are call realtime.
Hey, you are missing letter "p" in http.ResponseWriter description. &gt; Interface ResponseWriter can be mocked using httptest.Res**p**onseRecorder struct [ doc ] which is an implementation of it. That way it is very easy to test HTTP servers in Golang.
Here's a challenge, write one yourself in less than 150 lines of Go using only the standard library. In less than an hour if you want the extra challenge.
I feel like there's some overlap with what you want and https://github.com/isiton/isiton - you're going to need a `go run` for now, because I didn't go into providing a build yet. If you need it, lmk and I'll produce a binary for the releases page.
Not every problem needs a DIY solve.
 exec.Command("/bin/sh", "-c", yourstringhere) is fine if you're running on Unix. Also, using shellexec you have access to all the fields of https://godoc.org/os/exec#Cmd, including Process and ProcessState.
You can take a look at my blog, https://scene-si.org - also for your use case, if you're an absolute beginner in go, I recommend people to go over https://gobyexample.com/
Agreed. In this case I said it's a challenge. The OP, or anyone else, could see how they'd do it or not. And what would you like to do better? Spend an hour writing a custom solution or spend an hour googling a solution, figuring out how to use it, configuring it, testing it and then deploying it?
"use my library" was not my point (neither do I very much care), but I feel like I amended my answer fully to explain further. I could also point you to the [Not invented here](https://en.wikipedia.org/wiki/Not_invented_here) wiki page, that would further explain with what's wrong with trying to develop every trivial thing in house. Not that I would feel to say the same to your exact comment if the OP was asking to develop said alternative. You're absolutely correct about it being an easy challenge, but he wasn't asking for that.
**Not invented here** Not invented here (NIH) is a stance adopted by social, corporate, or institutional cultures that avoid using or buying already existing products, research, standards, or knowledge because of their external origins and costs, such as royalties. The reasons for not wanting to use the work of others are varied, but some can include a desire to support a local economy instead of paying royalties to a foreign license-holder, fear of patent infringement, lack of understanding of the foreign work, an unwillingness to acknowledge or value the work of others, jealousy, or forming part of a wider turf war. As a social phenomenon, this philosophy can manifest as an unwillingness to adopt an idea or product because it originates from another culture, a form of tribalism. The term is normally used in a pejorative sense. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/golang/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.27
Singletons are an anti pattern. You're most likely looking at creating a session, and then using the session ID to hold the user details between browser pageloads. The difference between PHP (session_start(), etc.) is that a singleton there only lives on the one/single request, you will start with a blank pageload for every request. Go is a long running application server, meaning that the singletons you create would persist between pageloads. If you don't want them to persist - don't create them in the global namespace, but limit them in your HTTP handler. Of course, they will not be singletons anymore, which is sort of good :)
&gt; Edit: also removed the "use my lib" link If you would replied with only that response everything would have been on. Instead you chose to add a reply to my post and now you've deleted your link which was actually solving OP's problem. Except for Prometheus, to the best of my knowledge, none of the things you've mentioned actually answer the question. Such a shame.
I don't know if you should get familiar with more software or if I should explain what individual software here does. I'm linking individual screenshots with the functionality OP asked for: "Just need a website that pings IP's and reports the status" - [Ganglia](https://github.com/ganglia/gmetric/tree/master/ping) - [Cacti](https://docs.cacti.net/_media/usertemplate:graph:advanced_ping_alt.png) - [smokeping](https://oss.oetiker.ch/smokeping/doc/reading_detail.png) - [Munin](http://munin.harvie.cz/harvie.cz/server.harvie.cz/ping_loss-month.png) - [Netdata](https://github.com/firehol/netdata/wiki/fping-Plugin) - [prometheus](https://labs.ripe.net/Members/daniel_czerwonk/screen-shot-2017-06-07-at-18-49-23.png/@@images/image/large) - [ELK (elasticsearch logstash kibana)](https://bearstech.com/societe/blog/high-available-mqtt-service/kibana.png) - [nagios](https://www.ibm.com/developerworks/library/l-ganglia-nagios-2/figure1.jpg) I guess just by inspecting those, you might see that pretty much every suggestion answers the question. With Prometheus I'd also advise [grafana](https://grafana.com/). As for my lib, I'm pretty sure that it's doing less and worse than the above suggestions. In light of "hey you're doing this a bit self servingly, aren't you?" criticism, I'll gladly keep it deleted to keep that notion at rest.
Packages in go are singletons, that's not an anti-pattern, it's just design decisions made to achieve some specific result.
Hello! I am an author of the [gobwas/ws](https://github.com/gobwas/ws). If you want to have a total control over resource consumption (memory and cpu) you could read [this article](https://medium.freecodecamp.org/million-websockets-and-go-cc58418460bb) about our WebSocket server optimisations at MailRu. Note that `gobwas/ws` was written especially to have no overhead on WebSocket protocol implementation. What about your case, seems that you can prepare the message bytes at once and then just write it in sequence (or with limited amount of parallel workers) to all your users. Both of `gorilla/websocket` and `gobwas/ws` allow to "compile" the frame for multiple writes. You also could use `mailru/easygo/netpoll` lib or similar to control all of your buffers used for io operations with clients. It is low-level little bit, but helps to increase efficiency.
[removed]
In the context, the OP seems to be using a global object (or package) for state management, which most definitely is an anti-pattern in singleton use. A good read which references a bad singleton on a similar example of user data: https://krakendev.io/blog/antipatterns-singletons ; a simple rule of thumb would be, that if you need to manage per-request data, to create it in the request handler and pass it from there down to your internal APIs.
Remove state (username and password) from the client and your problem will vanquish. You can pass them into a method instead: func (c *Client) GatherData(username, password string)
Also, the second part of this code review (https://www.youtube.com/watch?v=SWKuYLqouIY&amp;t=3s) will be released in a few hours, and it will deal with the database part of the app, so that might be interesting for you!
Video linked by /u/HugoWeb: Title|Channel|Published|Duration|Likes|Total Views :----------:|:----------:|:----------:|:----------:|:----------:|:----------: [justforfunc #20: code reviewing ursho (part 1)](https://youtube.com/watch?v=SWKuYLqouIY&amp;t=3s)|JustForFunc: Programming in Go|2017-09-26|0:36:54|138+ (97%)|4,058 $quote Let's review some code! In this first part of the episode... --- [^Info](https://np.reddit.com/r/youtubot/wiki/index) ^| [^/u/HugoWeb ^can ^delete](https://np.reddit.com/message/compose/?to=_youtubot_&amp;subject=delete\%20comment&amp;message=$comment_id\%0A\%0AReason\%3A\%20\%2A\%2Aplease+help+us+improve\%2A\%2A) ^| ^v2.0.0
I think you may have missed the part about which says that it should be written in Go. But please, continue to insult me and yourself.
[pv](https://linux.die.net/man/1/pv)
Well, real-time systems is such a small part of the software development world that you can just assume that the term is used to describe something else so that you don't have to hate.
&gt;Just need a website that pings IP's and reports the status Why not just use `/bin/ping`?
Then u know my username... nooooo
Should consider nexus and Crossbar and use WAMP vs plain web sockets. Gives some nice separation, auth, pub/sub and RPC in a single standard that scales.
Yeah I did miss that part, as well as the one where I'm insulting you.
Try checkup, https://sourcegraph.github.io/checkup/
&gt; Or what if there are two or more package main in the same project? It is perfectly OK if the project has several `main`packages. I meant there should be some kind of indication for these `main` packages and there should be a way to run `go install` for them. You see, very similar to proposed `go generate`
Figured I'd post the link this time and help answer any questions you may have. Sorry for the confusion last month. Thanks to all who contributed valuable input as well as code changes!
Implement the json Unmarshaler interface, it‚Äôs something like UnmarshalJSON(b []byte) error If ip is not there just return an error You can even do verifications on it to make sure it‚Äôs within a certain range or that it‚Äôs valid syntax
If it's any consolation, the confusion last month brought caddy to my attention and I love it. Using it for a few small servers and local development now.
Cool. Ty
I like Caddy and use it for my personal website, but the licensing is seriously confusing. If you don't want to use Apache 2.0, that's fine, but don't try to trick people into paying for something that is already fully within their rights, for free. You should rename "commercial" to "basic support" and "large-scale commercial" to "extended support", because it is not within your rights to limit commercial use or the number of running instances unless you release a version where the Apache 2.0 license no longer applies and they use that version. For now it still applies, and allows commercial use and redistribution of modified source and/or binaries. The latter, of course, respecting any trademark that may also apply. This is at odds with the product page which limits commercial/internal company use for the free "personal license" and "instance limits" for the different tiers.
The absolute number 1 resource should be the tour, ahead of anything else. Then it should be followed by the official wiki tutorial. Everything else should exist lower down a list, else it could lead to confusion. If I'm going to be brutally honest though, I don't think a list like this will do much. People often ask "how can I learn Go?" yet if they were a seasoned programmer, they should have been able to hunt down the tour and get on with it. When people turn up asking to learn go, what they're really asking is "I want to know how to program, and I've heard go is good." I think in these instances, people should be pointed to places such as Code Academy's Python course to get the basics of flow control, etc, and then they can look into go.
The licensing is a bit weird. As I understand it, the two things I'd be paying for is two different support plans and the service of building a binary. A different price depending on how I use that binary. I don't know about the feedback you've received, but right off the bat it seems to me that people would be paying for support most of all, because a $25/mo fee for a binary download is expensive compared to the one-time hassle of doing it yourself. Have you considered just selling support plans and offering the option to donate? I'd seriously consider a one time donation even for my personal use.
[removed]
Thanks for your comment; some good questions here. &gt; a $25/mo fee for a binary download is expensive compared to the one-time hassle of doing it yourself. It's not the download the license fee covers, it's the continued use of the binary in a commercial setting. That companies were relying on our build infrastructure in automated settings without our knowing was a bit startling to us for one thing, and by making this a paid transaction, we can better support their use cases. &gt; Have you considered just selling support plans and offering the option to donate? Yes, we did that for a long time, and nobody bought -- and very few donated. See https://caddy.community/t/the-realities-of-being-a-foss-maintainer/2728
Interesting fact: This started as a C++ program, and I decided to make it more accessible by refactoring it into a Golang library. From C++ to Golang, I had to strip a few features, but I reduced the amount of LoC by 95% (20 000 to ~1000), made it faster and way easier to iterate on. Also, it made my CI build + tests go from 20mns to 2 minutes per run, as well as allow me to reduce the Docker image size by 50% (from 374 MB to 186 MB). I'm very happy about the result :-)
Awesome! I almost went with named returns but noticed how they interact poorly with shadowing to return the wrong error variable. Thanks for releasing a tool to discourage this pattern!
GeoJSON is just JSON following a specific format. I recommend you have a look at the following resources: - The spec: http://geojson.org/ - This website: http://geojson.io/ - This excellent library: https://github.com/paulmach/go.geojson If you have query results from your Postgres db that include a Latitude and Longitude, simply create a new GeoJSON Feature Collection, then add a point feature to it
In non-unix setting, the idea of shell snippets sort of doesn't work out, anyway.. Also, `os/exec.Command` naturally gives you access to all fields of `os/exec.Cmd`...
Looks like you are using a cygwin-like environment. Caution: sh.exe provided by cygwin esp Chocolatey packages often segfaults. The main solution is to avoid cygwin and use more reliable environments. Windows Linux Subsystem. Docker. Virtual machines. Linux on bare metal.
 In the beginning it was the hours spent coding stuff that was fun that gives you a foundation first. The "weird projects". Like mixing jquery + animatecss + greensockjs to call the animations of all three together with the css library to create a really interactive website for no good reason. It is these weird draws into the programming world that helps you build a foundation into other things and builds a thirst for more tools. In go you learn that it is all built already into the standard library. But most importantly, have fun and eventually everything you do will come back in handfuls and eye memory. I started after all that with Todd mcloeds tutorials, then I knew I had to really get the basics and I just started to try to build stuff without looking it up with gobyexample.com. Like writing embedded structs and passing data through them. Then trying out the packages. Then trying to connect a databases, templates, restful api..ect. You eventually get an eye for things and once you know the concepts, looking it up is easy. Then try to do it by memory. As long as you are hitting the keys and fulfilling your curiosity, you will learn it. https://i.pinimg.com/originals/a7/60/4a/a7604a884ddceb68697ca406d83ee58f.jpg 
Thanks for this response. The changes made last month caught me by surprise, and I'm much more pleased with the new product structure. Go Caddy!
Write the NewRuleSet function so that it returns a value.
I am writing Go tutorials at https://golangbot.com/, please check it out.
your issue is that NewRuleSet does not return a variable try this func NewRuleSet() ([]string, []string) { return []string{}, []string{} } then in your main/test function func main() { depp, conf := NewRuleSet() } in Go, like many other languages, you need to explicitly declare what a function returns.
Good luck with that. 
Personally I don't really like the Go Tour. It doesn't really explain things all that well, doesn't really have any proper exercises (and the exercises that it does have [ask you to translate some math to Go code](https://tour.golang.org/flowcontrol/8)), and is in general not a very good resource for really learning stuff, IMHO. I find that [The Go Programming Language](http://www.gopl.io/) is a much better resource for people to learn Go. Only downside is that it's not free, although $32 is very reasonable as far as professionally written programming books go and if you're serious about picking up a new skill then $32 is a bargain.
I'm using git for windows no cygwin
Is starting with a dynamically typed language really that helpful to new programmers? I sometimes wonder if it's counterproductive, as debugging dynamically typed problems is often harder than responding to a compiler error.
 type RuleSet struct { depp []string conf []string } func NewRuleSet() *RuleSet { return &amp;RuleSet{[]string{}, []string{}} } func (r *RuleSet) IsCoherent() { ... }
Yeah, that's a good point. I might have listed a bad example because there's a lot more than just naked returns going on. I'll make note to fix that. I don't think naked returns are bad if you're careful, but they're pretty easy to get bit by if you don't keep after the values of your named returns at every exit point. What exactly do you mean by "a ratio"? Thanks for the input! 
 type RuleSet struct { depp []string conf []string } func NewRuleSet() *RuleSet { return &amp;RuleSet{[]string{}, []string{}} } func (r *RuleSet) IsCoherent() { ... }
&gt;Simplicity beats verbosity. A bunch of return nil are a lot easier to understand &gt;than a bunch of return where one has to chase the latest value of the variable &gt;and make darn sure it hasn't been shadowed (intentionally or by mistake.) true dat
Debugging may be harder, but I'm not talking about people who are going to be debugging tomorrow code which they wrote today. In trying to get people in to programming, I want to reduce the barriers for entry, and python has nice features for this. Think of the following * Bool * String * Int * Float * Pointer * Generic Outside of coding communities these words have little or no meaning, yet we throw them around all the time and expect newbies to pick up these concepts all at the same time they're trying to understand variables, functions and methods. Let's remove, for now, any concept which isn't necessary for a small script, and introduce them when the user is ready for something more meaty.
I don't disagree, but watching someone learn to program lately has led me to believe maybe understanding types is just as important as understanding variables. I just have a guilty thought maybe hiding types actually makes learning to program harder.
This may actually be where go wins, because you can teach the concepts of variables and flow control without introducing types using the quick form, but you can expand on them later. The only problem is you can't introduce functions without them.
[removed]
thanks for the downvotes, haters.
Why did Mozilla fund Caddy if the goal was to turn it into a commercial product? https://blog.mozilla.org/blog/2016/06/22/mozilla-awards-385000-to-open-source-projects-as-part-of-moss-mission-partners-program/ 
Very nice. Maybe you should blog about it in some details.
Thank you :) Good idea! If I find the time to do it I'll ping you
Hi reddit, I just published a guide to use gRPC with Protobuf, in go. What do you think?
While I can't speak whether or not the donation had some conditions attached to it but if your only criteria is open source, then I have to remind you that Caddy is still open source and that a lot of open source software sells enterprise support.
By interest you mean windows support? :) I guess it's just not a big enough surface that somebody would support this feature outside of goog (which isn't really running of windows). Maybe microsoft will contribute something as they recently invest a lot to poach go core team? But I suspect they care more about kubernetes and their core services.
Here's a fun tool I created lately (thanks cespare for the awesome tetris game). I'm working right now on adding more games, and cool things to pass the time, instead of waiting for "boring" commands to finish. If you find it nice, and you wanna help, any contribution is welcome.
Go routine scheduling is cooperative. If you are in a function that does not make any explicit calls to schedule, you prevent other go routines from running. If you are seeing different behavior, its must be that only one of these code path is calling into the scheduler.
The lack of windows support is just an example of the low interest that I saw from the community about plugin feature.Just a bunch of tutorial. I think that load lib dinamically is a core feature for languages like Go.
You are decoding ID twice in a row in Load, first raw, then inside a LoadInfo.
yes, and it could be changed, but I need the ID in both functions and I didn't want to add a parameter to LoadInfo. I think Load should be changed to do an increment operation, as currently it could cause a data race where some counts are missed. I might make an episode on that and how to test it.
A C compiler in Go? Missed the opportunity to call it Go@C.
It is really misleading, because this only applies only to the pre-compiled binaries, if you compile it yourself from source it is still under the terms of the Apache license and there is no commercial limitation. There are also no paid proprietary features which is nice, companies that do that actually suck.
[You are not alone](https://talks.golang.org/2013/oscon-dl.slide)
Oh, and your container seems to still keep the development system in the container, that's why it's so big. https://medium.com/travis-on-docker/multi-stage-docker-builds-for-creating-tiny-go-images-e0e1867efe5a
Sure.
I meant access to those fields related to the command you want to run, not `/bin/sh`.
!RemindMe in 1 month
I will be messaging you on [**2017-11-09 19:15:12 UTC**](http://www.wolframalpha.com/input/?i=2017-11-09 19:15:12 UTC To Local Time) to remind you of [**this link.**](https://www.reddit.com/r/golang/comments/759enq/golang_library_to_hack_cctv_cameras/do4txcc) [**CLICK THIS LINK**](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[https://www.reddit.com/r/golang/comments/759enq/golang_library_to_hack_cctv_cameras/do4txcc]%0A%0ARemindMe! in 1 month) to send a PM to also be reminded and to reduce spam. ^(Parent commenter can ) [^(delete this message to hide from others.)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Delete Comment&amp;message=Delete! ____id____) _____ |[^(FAQs)](http://np.reddit.com/r/RemindMeBot/comments/24duzp/remindmebot_info/)|[^(Custom)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[LINK INSIDE SQUARE BRACKETS else default to FAQs]%0A%0ANOTE: Don't forget to add the time options after the command.%0A%0ARemindMe!)|[^(Your Reminders)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=List Of Reminders&amp;message=MyReminders!)|[^(Feedback)](http://np.reddit.com/message/compose/?to=RemindMeBotWrangler&amp;subject=Feedback)|[^(Code)](https://github.com/SIlver--/remindmebot-reddit)|[^(Browser Extensions)](https://np.reddit.com/r/RemindMeBot/comments/4kldad/remindmebot_extensions/) |-|-|-|-|-|-|
Very nice link, thank you! 
That's awesome, I didn't know this was possible. Will implement asap! Big thanks to you :) 
This is cool. But I noticed a lot of missing animated gifs to be added to the repo?
Your observation is correct. I was tired so I prepared just few gifs. I will eventually add the rest when I get time.
Git for Windows uses MSYS2 under the hood, which is a stripped-down version of Cygwin. [This thread](https://community.atlassian.com/t5/Git-questions/Initialise-repository-for-Git-Flow-failed-in-sourceTree-2-1-2-4/qaq-p/593891) from the Atlassian forum discusses a very similar error message, and the reason was some ‚ÄûDell Data Protection settings‚Äú (don‚Äòt ask me what that is!) that affected the files sh.exe, bash.exe, and mintty.exe.
I'll address these a bit out of order, sorry for the lengthy reply. &gt; hope gogland will address all the above in order to be of interest to me. I'm sorry you have issues with the IDE. Please report any issues you have at https://youtrack.jetbrains.com/issues/Go because otherwise it's impossible to fix them by not knowing what happens / how to reproduce this. &gt; It takes a lot of time to get all the source code indexed, again for a simple console application? The indexing happens once per version (or after you install a plugin that needs to reindex things) but you need to go thru that process only rarely. If it happens more than what I just described, please open an issue. The duration it needs is affected by three things: CPU, storage speed (SSDs are recommended) and size of your GOPATH (since in order to provide all the features it has it needs to be able to correctly identify where all definitions are, especially when it comes to Go's model of interfaces). &gt; It will cost a lot of money (like the others do) As far as I know, from the FAQ, it will cost about as much as PyCharm for example, which is $8.9/month or $89/year in the first year and it drops to $53/year in the third year. It's also free or discounted for a lot of users, see: https://www.jetbrains.com/store/?fromMenu#edition=discounts &gt; and will almost be the same as the free stuff if not worse. What could it do better? Which features are you missing? &gt; it is resource intensive, 1GB for a simple console application? &gt; on the plus side the rename works better than in visual studio code... On my computer, Windows 10 x64, latest patches, VS Code uses 485 MB and Gogland uses 543 MB of Working Set Memory, see: https://i.imgur.com/6AeYj6K.png I've used Process Explorer: https://docs.microsoft.com/en-us/sysinternals/downloads/process-explorer to get that view so that I can get a list of child processes launched by each application. The problem of correctly measuring used memory on modern operating system and applications is not easy and the builtin Task Managers can sometime hinder this a lot. The difference is that Gogland will work with the files in-memory so that it can offer all the code analysis on the fly, without having to execute any external dependency. That's why whenever you have a syntax error Gogland will show it as soon as you lift your finger off the key and VS Code needs you to save the file, wait for external tools such as go build to run and then get the error back to you (or to clear it away). It can also work on broken source-code and still provide syntax analysis whereas most of the Go tools do not like this case (think of the cases where you want to move code around). And as you say, rename (and a lot of other refactorings) are bound to be more enjoyable to use (and accurate). I'm not trying to dismiss VS Code and the many open-source tools it's using, but I hope this provides you an insight into why memory usage may be a bit higher.
Based on the description, I believe you want something similar to this: https://youtrack.jetbrains.com/issue/GO-2408 Please vote / watch for it.
&gt; I think that load lib dinamically is a core feature for languages like Go. What is the advantage of a plugin vs just restarting container behind a load balancer?
if you really care, you can use this: &gt; for l, i := len(whatever), 0; i &lt; l; i++ {
A book that should certainly be on this list is [Concurrency in Go](http://katherine.cox-buday.com/concurrency-in-go/). Also, [‚ÄûLearn to Create Web Applications using Go‚Äú](https://www.usegolang.com/) is a great book and online video course about exactly what the title says. And I don‚Äòt know if this plug is appropriate here but may I humbly ask to also consider my course [Master Go](https://appliedgo.com/p/mastergo) that I launched last Wednesday?
VSCode - free, fast, easy to extend with javascript/typescript. Used to be a WebStorm user but I don't miss it. For what I do---Go back end, React+Typescript front end---it's hard to beat. Where VSCode is weak * lack of T/JSX autocompletion - a plugin exists but it gets confused with Typescript generics * no background colors in themes to differentiate embedded scripts * no structured navigation - navigate by functions, properties * multi-project view - open go api server project with separate typescript project
This is kind of a fun idea. Better than checking my phone... Although I should probably stand up and walk around or something.
Hahahaha. Been using nginx in front of multiple go webapps at work with no issue. nginx works really well. I have never even looked at caddy cos there is no need to move what I got from where it is for any reason.
The style of discussion would be appealing to many for sure. I would much prefer it to mailing lists.
Done in https://github.com/EtixLabs/cameradar/pull/96 Docker image size is now 51MB! Thank you so much for this tip. I'll use it whenever possible now. Unfortunately here there are a few runtime dependencies (curl and nmap) so that's why the image is still 50MB, but that's already a huuuuuge improvement.
The upshot is that there isn't any way to reach out from another goroutine and unilaterally kill it. Therefore, if you want to be able to terminate a goroutine before it is "done" you are going to have to add some checks that the working goroutine uses to determine if it should stop or not. Checking a boolean flag is the simplest case, but there's a lot of ways of doing this. It just _must_ be done by the busy goroutine.
My experience with plugin start here: [go-admin-server project page](https://github.com/m4dfry/go-admin-server) It's a little project of mine. The idea is to provide a very basic server to which the user can add their pages / APIs. I planned to give a base interface for plugins, users can compile separately and link in the config file. Server must load the plugin made from user at runtime and add it to the interface. With no plugin support, windows user is forced to add some lines on main server class to include their API and use the auth-middleware. I'm a newbie of Go, an I know that this project maybe be not standard. Have you some alternative solution, to give user the opportunity to inject their code without modify the main source ??
This library plugs into [go-fuzz](https://github.com/dvyukov/go-fuzz) and constructs arbitrary calls from the `[]byte` input, using a state machine to define what calls are possible when.
While `nginx`is nice, easy, and flexible, `certbot`(to get letsencrypt certificates) is an exercise in frustration. So `caddy` has its place in the developers/devops toolbelt.
While certbot is awful and should not be the official client, there are plenty superior alternatives, like acmetool.
&gt; - no background colors in themes to differentiate embedded scripts &gt; - no structured navigation - navigate by functions, properties &gt; - multi-project view - can't open go api server project with separate typescript project All things covered really well by Gogland / Webstorm (I can't speak about the first since it's not my area of usage).
I think the drama could have been avoided if the pre-compiled binaries that imply different terms would have been available only to customers behind a login tied to payment. It seems mainly a failure in communication that exploded via Hacker News. I wish them to recover from this accident and go on to do great things.
yes I do..
but its hard for me as a newbie...A plain JSON is simple..But a GEOJSON is hard for me to construct it in a GOLANG
Use the go geojson library I linked, it does almost everything for you already. GeoJSON IS Plain JSON, you just have a sch√©ma to follow. 
Username checks out
I just wish gRPC wasn't just client-&gt;server (even with streaming, you can't call methods from server-&gt;client). Wish it was fully bi-directional with both server and client able to have methods called by the remote connection.
I am not arguing whether caddy has a place or not. I do feel comfy enough with nginx, yet have no knowledge of certbot since I have used paid certs always. Did not know that was an issue. I will now look into letsencrypt to figure out what the deal is with the available tooling for it with nginx.
&gt; without modify the main source Look at how they implemented it in the `image` package. // Formats is the list of registered formats. var formats []format // RegisterFormat registers an image format for use by Decode. // Name is the name of the format, like "jpeg" or "png". // Magic is the magic prefix that identifies the format's encoding. The magic // string can contain "?" wildcards that each match any one byte. // Decode is the function that decodes the encoded image. // DecodeConfig is the function that decodes just its configuration. func RegisterFormat(name, magic string, decode func(io.Reader) (Image, error), decodeConfig func(io.Reader) (Config, error)) { formats = append(formats, format{name, magic, decode, decodeConfig}) } Then `image/jpeg` and others register themselves in the init functions: func init() { image.RegisterFormat("jpeg", "\xff\xd8", Decode, DecodeConfig) } 
Good bot. 
Thank you HotelDon for voting on WikiTextBot. This bot wants to find the best and worst bots on Reddit. [You can view results here](https://goodbot-badbot.herokuapp.com/). *** ^^Even ^^if ^^I ^^don't ^^reply ^^to ^^your ^^comment, ^^I'm ^^still ^^listening ^^for ^^votes. ^^Check ^^the ^^webpage ^^to ^^see ^^if ^^your ^^vote ^^registered!
Is there something preventing you from using `http.Server.Shutdown`?
I agree with the general advice, try to make it work in node first. Go may not solve your issues. We used socket.io at my previous startup. Be warned that, at least with the version of socket.io we used, the room implementation was not scalable even with their redis adapter. The room roster remained in each server session not in the remote pub/sub redis server as described above. In other words, messages could not be broadcast to users in the same room, if users were connected on different servers and/or processes. I monkey patched socket.io so much that I eventually built a simpler, pub/sub-first room implementation from scratch with primus. 
You mention in your other comment the idea of allowing users to add pages / APIs to a server in the form of plugins. Recently I implemented exactly this for [mattermost/mattermost-server](https://github.com/mattermost/mattermost-server). The idea is that individuals or organizations can create powerful integrations and hook into events with low latency and drag-and-drop installation. We went with an RPC-based plugin mechanism, but we considered Go plugins and here are some of the points against them: * Go plugins can't really be constrained by an API. If you do have an API that you want them to use, it's enforced using the honor system. They can access any resource and invoke any function that your main process can (because they run within the same process). On the other hand, RPC plugins can be launched in a separate process, in a sandboxed environment if desired. * We can't do much to limit the blast radius of a Go plugin. If it deadlocks, panics, corrupts memory, etc., it'll bring down the entire application. An RPC plugin can be siloed such that the entire server isn't negatively impacted. * Go plugins only work on Linux. As you point out, they don't work on Windows, and last time I checked, they didn't work on MacOS. * Go plugins can only be used with the version of the server they were compiled for. So if you update the server, you have to recompile all of the plugins for it. * Go plugins can't be unloaded. Nor can multiple versions be loaded at the same time. If you want to update a Go plugin, you have to restart the server or add the new version as an additional plugin with different package names. * Go plugins have to be very careful about their dependencies. Loaded Go plugins cannot be allowed to import more than one version of a dependency. For example, if you have multiple plugins that import sirupsen/logrus, all of them must import exactly the same version.
Exercism.io
I'd also correct the inconsistent case of the SQL statements.
I think very few projects actually need it, many deploy production code under linux, and others have worked around it using some sort of RPC (eg https://github.com/hashicorp/go-plugin or using an MQ or through microservices)
If a company wanted to build Caddy from source for commercial use, would they have to pay any license fees for it? As far as I can tell, the answer is no, but it's kinda confusing.
About that REST gateway, is it possible to define accepted headers/header responses, constraints on the parameters, description, and field value examples? I already know that protobif 3 doesn't have the concept of required field, which is pretty unfortunate. Basically can I fully replace the full Swagger spec of a REST API to protobuf without any lost of information/regression on the documentation and API behavior? ie: https://i.imgur.com/kkz1zmL.png
The source code is Apache licensed, so no.
That was my guess. Thank you for confirming it.
You already posted your project last week. Did you made any significant change or added new features?
No problem. Feel free to read the FAQ too. :) https://caddyserver.com/products/licenses
Why do we need another Go logger? What value is there in using this one over the bajillion existing ones?
The existing one just print, but could not record log to file, and other go logging libraries are to complex. I want to make it as simple as possible. The usage is: import "github.com/vlinx-io/go-logging" logger := logging.New("info.log", "error.log") logger.Debug("it's a debug msg") logger.Info("it's an info msg") logger.Error("it's an error msg") The output: https://imgur.com/K41AaiY 
Nice. Note that you don't need to assign a sink for avoiding loop eliding. Unless your function is an intrinsic, Go is smart enough to avoid false elision during benchmarks. Also, if you are sure that your strings are always full ascii, you may want to write your own inline ToLower(). There is a CL I have sent which optimizes for the ascii case. This may be something which you may benefit from. https://go-review.googlesource.com/c/go/+/68370
[removed]
not an amazing thing to watch in a video ... but I agree :)
Sorry, but I really just don't see the value here. You mention that the other libraries are "too complex," however every logging library I am aware of is _O(1)_. If by "too complex" you mean "harder to use," then I still don't see it. Logrus, which has become the de facto logging library for production Go code, can be initialized with file logging and what-not with the same amount of code. I'm not sure how that is any more difficult to use that what you are presenting. In fact, this "simplicity" that you tout makes it virtually unusable in any production environment. Logrus is so popular because it is so _flexible_ and yet still easy to use. Where is your configuration for syslog logging? Where is your extra configuration for logging to files like format, timestamp format, etc..? You can't make blanket assumptions about an environment like this library seems to try to do. Is this _actually_ used anywhere in production? 
I like the colorized output. BTW, the reason why many logging packages only write to stdout is that in many server scenarios it is the duty of the orchestration software to collect log output from the workers‚Äò stdout streams. (Also worth noting: The standard log package does have an option for writing to a file, via SetOutput().)
That's quite neat. Is there a plan to add Moderation? 
Because it's almost never the bests option and it's only useful in very convoluted situations. I suggest you watch David Cranshaw's talk grom Gophercon on build modes. https://youtu.be/x-LhC-J2Vbk?t=2128 That should link right to the part about plugins around 35:28, but the whole talk is quite good and worth watching in its entirety.
Video linked by /u/zevdg: Title|Channel|Published|Duration|Likes|Total Views :----------:|:----------:|:----------:|:----------:|:----------:|:----------: [GopherCon 2017: David Crawshaw - Go Build Modes](https://youtu.be/x-LhC-J2Vbk?t=2128)|Gopher Academy|2017-07-24|0:44:19|33+ (100%)|2,017 $quote The Go toolchain now has a variety of build modes that let... --- [^Info](https://np.reddit.com/r/youtubot/wiki/index) ^| [^/u/zevdg ^can ^delete](https://np.reddit.com/message/compose/?to=_youtubot_&amp;subject=delete\%20comment&amp;message=$comment_id\%0A\%0AReason\%3A\%20\%2A\%2Aplease+help+us+improve\%2A\%2A) ^| ^v2.0.0
Open source and commercial are not mutually exclusive. In this case, the license has allowed commercial use and redistribution since day one. You could personally build your own binaries and use them freely and sell them yourself, or build your own binaries off your own personal branch of the source without contributing the source back to the project, of course with respect to any trademarks that may apply to Caddy. It's a very permissive license that allows both you and the original authors to build whatever business model you care for around it.
Are you French ? 
If you have a geometry field in your postGIS, it's pretty easy to output a GeoJSON with `paulmach/go.geojson` "github.com/paulmach/go.geojson" ... query := `SELECT ST_AsGeoJSON(yourField) AS geojson FROM yourTable LIMIT 10` ... geometries := []geojson.Geometry{} for rows.Next() { c := geojson.Geometry{} rows.Scan(&amp;c) geometries = append(geometries, c) } 
i'm subscribed to that channel YouTube, really great materials from campoy :) thanks buddy!
Thank you for your suggestions, before going on I will study the material you have linked to me.
Very detailed information..
What exactly is the task you're trying to achieve?
It's from one of my projects. I want it can be used in simple app, but for large server-side program, maybe fully functional log components is needed. I just want to give a lite alternative which can be used directly without too much configure. Of course, it's all according to the requirement.
It seems a bit inaccurate to say that the license fee *covers* continued use of the binary when continued use comes at no cost to you. $0 covers your cost of my continued use of the binary, and the added value of you building it for me diminishes over time when compared to the option of building it myself. If what I'd be paying for is the continued use of the download service and support, IMO the license plans should more closely reflect that. What I'd *like* to be paying for is making it possible for you to comfortably continue contributing to the project, hence suggesting donations. It is disheartening to hear that this model didn't work out, and I understand the inclination to look for better options. As a means to that end I assume it's all equivalent anyway. Please consider accepting donations in addition to the commercial plans, though. If there is a non-zero amount of people for whom the commercial plans add no value that would still consider donating for the same reasons I would, that's a non-zero amount of money.
Thanks, I'm glad you like it. btw, your comment gave my coworker cool idea. adding fitness exercises to it. https://github.com/a8m/play/issues/2
Never heard of acmetool! This looks awesome.
Not in this implementation. The first issue I can see: HTTP headers are always *string*. So Protobuf in the headers won't work. Note that the REST gateway is **before** the gRPC, and thus what you can do to headers or body is really at the mux level (https://gitlab.com/pantomath-io/demo-grpc/blob/master/server/main.go#L110). Not much room there, except changing the message serialization, and the headers-to-gRPC-context (see: https://github.com/grpc-ecosystem/grpc-gateway/wiki/How-to-customize-your-gateway). This is what's done with the *HeaderMatcher* function (called *credMatcher*), which choose what header to provide the gRPC context with. But there is no way to have a global view of all the headers, as per the doc on ServerMuxOption: This matcher will be called with each header in http.Request. If matcher returns true, that header will be passed to gRPC context. To transform the header before passing to gRPC context, matcher should return modified header. You could probably try to hack the message serialization so that you use Protobuf instead of JSON, but if you're there, why don't you connect directly to gRPC? REST gateway is really there to allow non-compatible client to access the API. Beside, the REST gateway is just a reverse proxy for the gRPC: eventually, you REST query will end up in the gRPC server, and will go thru the interceptor (https://gitlab.com/pantomath-io/demo-grpc/blob/master/server/main.go#L55). So everything (like a context metadata, which is just a HTTP header converted by the *HeaderMatcher*) that has been pushed to it can be validated.
Great video! :D Shouldn't *postgres.New()* return a concrete type rather than an interface? Since I think I saw *handler.New()* already accepts an interface? Return concrete types, accept interfaces? That's a saying right? :p
gRPC still uses HTTP/2 as a transport mechanism, and HTTP is intrinsically unidirectional. Bidirectional communication over the web, usually uses [WebSockets](https://en.wikipedia.org/wiki/WebSocket). If you're looking for a full serialization+RPC solution, that would support another transport, you might want to look into [Cap'n Proto](https://capnproto.org/). It's developed by Kenton Varda, previously Tech Lead on the Protocol Buffers project at Google. There's probably a solution using: * [Cap'n Proto RPC protocol](https://capnproto.org/rpc.html) * [Gorilla WebSockets](https://godoc.org/github.com/gorilla/websocket) * [Cap'n Proto `StreamTransport`](https://godoc.org/zombiezen.com/go/capnproto2/rpc#StreamTransport) I'm actually quite curious. If this answers your problem, I'd be glad to hear about your experience.
**WebSocket** WebSocket is a computer communications protocol, providing full-duplex communication channels over a single TCP connection. The WebSocket protocol was standardized by the IETF as RFC 6455 in 2011, and the WebSocket API in Web IDL is being standardized by the W3C. WebSocket is a different TCP protocol from HTTP. Both protocols are located at layer 7 in the OSI model and, as such, depend on TCP at layer 4. Although they are different, RFC 6455 states that WebSocket "is designed to work over HTTP ports 80 and 443 as well as to support HTTP proxies and intermediaries" thus making it compatible with HTTP protocol (HTTPS is HTTP traffic flowing through an SSL/TLS tunnel). The same RFC mentions that WebSocket reinvented "the entire [HTTP] protocol." To achieve compability, the WebSocket handshake uses the HTTP Upgrade header to change from the HTTP protocol to the WebSocket protocol. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/golang/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.27
&gt; And seems sharing a read on reddit is the most stupid thing someone could do. I promise I would not do that again; whatever. I think most people appreciate papers here. It's just that when I looked at this certain paper I felt like I was reading something that was written 10 years ago. I wouldn't underestimate this subreddit. A lot of people here are smart. If the thing you link doesn't have much value or is not very relevant, it won't get much attention.
Yeah I think you really need to look at it from a user end. If you're making something for people to use, you just need to create a few different options for people to download. All the user sees is a download link with their operating system listed next to it. They download it and it just works.
&gt; yet if they were a seasoned programmer, they should have been able to hunt down the tour and get on with it. Why would you only wanted seasoned programmers to learn Go? Additionally, it's still handy to have a readily accessible all in one resource list. Probably not *too* useful if it doesn't pop up at the top of a google search, but still having resources already listed and ranked with summaries is going to be faster than taking the time to look it up yourself even if you know what you're doing. 
[removed]
I'm doing a little open source project with a couple of friends at varying skill levels and our list of getting started resources is: &gt;#### Resource/Tutorial list #### Very good full video tutorial to Go; learn go in an hour (probably start here) https://www.youtube.com/watch?v=CF9S4QZuV30 ##### Basic encrypted transport/server tutorial https://go.unicorn.tv/articles/basic-encryption-in-golang ##### Best practices for middleware tutorial/guide (hot topic in go community/most middleware is shit because it was written without following many best practices) https://www.nicolasmerouze.com/middlewares-golang-best-practices-examples/ ##### Quick intro/"tour" of Go https://tour.golang.org/welcome/1 ##### Official beginner Go tutorial https://golang.org/doc/code.html ##### Intermediate/advanced documentation on Go efficiency/optimization https://golang.org/doc/effective_go.html ##### Overview of best industry practices. While I'm sure not everyone agrees, most of these are great ideas that we probably ought to use. https://peter.bourgon.org/go-best-practices-2016/ ##### Unit testing in Go. Yeah, we really do need to know and throughoughly cover our code in unit tests or die trying. https://blog.alexellis.io/golang-writing-unit-tests/ Sorry for the weird formatting, but it's just directly from our github readme file I have locally, and really the list is meant to be used with me around to ask questions. Might be a little biased as a general tutorial list since we're focusing on over-engineering the project a bit as resume material. 
Some Go blogs - but not necessarily focused on beginner-level go: * https://blog.golang.org - the standard one to have in your RSS list * https://dave.cheney.net - not a pure Go blog but full of insightful Go articles * https://calhoun.io - Various aspects of Go extremely well explained * https://flaviocopes.com/ - contains an array of beginner-level Go code examples (looks discontinued) * https://golangbot.com/learn-golang-series/ - a Go tutorial released as blog articles * and my own blog https://appliedgo.net - as the name says, this is about applying Go to various topics in IT.
I wouldn't recommend it, but then again I did get started with statically typed languages. I believe *most* colleges start you out that way. Honestly I find dynamically typed languages to just be hellish and unintuitive to deal with in general, but obviously not everyone feels that way.
https://golang.org/pkg/encoding/json/
How is the runtime unloaded when the DLL is unloaded?
I'm not saying that only seasoned pros should learn Go. I'm just saying that the tour is so good that a professional programmer should be able to read it and get a good handle on Go very quickly. New programmers should use it too, but I think they will have a better time if they are tought through a practical exercise which creates an application at the end of it.
I think naked returns are a huge antipattrn, regardless. Instead of seeing right at the return statement what's getting returned, I have to look at the return values of the function and then trace down to figure out where they're being set and if they've been shadowed etc. I always mark naked returns as something to change in code review.
Does this mean building native DLLs that can be loaded by Win32, .NET, etc?
Please let's be respectful of people when they post software they have shared with the community. Just because this does not fit your needs does not mean it doesn't fit anyone's needs. Obviously it fits the author's needs. Asking clarifying questions is fine but don't do it with the presumption that the author is in the wrong. I've heard on numerous occasions that people are hesitant to present their code here for fear of negative reaction, and this is why. Just be nice.
Check out https://GitHub.com/natefinch/pie for another plugin option. Plugins can be written in any language that supports RPC. As for the go plugin functionality. As others have said... The realities of restrictions on it were just too harsh for normal use. 
You might want to use build tags. Guard the files you want to exclude with `// +build test`. The word `test` can be anything. Those files will be excluded when you do `go build`. If you want to include them you have to do `go build -tags=test`. 
You might want to use build tags. Guard the files you want to exclude with `// +build test`. The word `test` can be anything. Those files will be excluded when you do `go build`. If you want to include them you have to do `go build -tags=test`. 
You might want to use build tags. Guard the files you want to exclude with `// +build test`. The word `test` can be anything. Those files will be excluded when you do `go build`. If you want to include them you have to do `go build -tags=test`. 
`*_test.go` files are not included in the binary [1](https://stackoverflow.com/questions/44685206/will-go-test-code-only-referenced-in-test-files-be-complied-into-the-binary). Furthermore, only code that is able to be reached by your main package will be compiled. So in your case, if your `testutil` package is only used by your `*_test.go` files, they will *not* be compiled. As for your third point, I don't know if I've ever seen that so not quite sure of the answer.
the Issue: https://github.com/golang/go/issues/11058
This is honestly amazing.
Cool, I'll take a look into those thanks!
I haven't seen internal packages in the wild until now, but they are used only from $GOHOME so that seems to satisfy both 2) and 3). Generally `main` isn't exportable unless you're writing a plugin for a .so build (afaik). That being said, it's common practice to have projects like this: example -- `package example` (+ tests) example/cmd/something/ -- `package main` As understood, the cmd (main package) can import `example` and `example/internal`, but it couldn't import something that's internal and vendored (ex: `github.com/user/project/internal/xxxx`). If it works. Technically relative imports should work too, [but there are outstanding issues with vendored package use](https://github.com/golang/go/issues/15478). Milage with `internal/` might vary here, but without some tests I can't be sure.
Oh that's awesome I didn't know Go optimized by only compiling reachable code. I've finally got a handle on actually coding the language but still learning all the optimizations and processes that happen when compile and running Go code.
To elaborate, this is useless unless they support shutting down the runtime cleanly, re: [ https://github.com/golang/go/issues/11100](https://github.com/golang/go/issues/11100). This references dlclose, but you'd have the same issue on Windows.
I run Windows only when forced to do so and I don't like Macs either but. . . this is huge. This is how languages flourish. It's one thing for me to say, "just use Linux or GTFO" but that's not realistic and honestly, while Linux is my preferred OS, it's never going to be a common end user platform. tl;dr bravo Go team, it's support like this which will allow more people to use and deploy Go based applications. As it stands right cross-compilation is kind of mind blowing. . . this is icing on the cake. 
Donations simply are not sustainable to pay for maintaining a large software project. I say this as someone who donated to caddy at the start, but not since. What incentive is there to keep donating? How many people do donate without heavy prompting (probably 0.00001% of a userbase)? Firstly thanks Matt for the project and all the work on it. It's a really good way to put a proxy in front of other apps or just serve some files, a great way to use lets encrypt, and a good demonstration of the power of the net/http library in go. I've used it on a few personal projects, but have found all this fuss over pricing confusing and a little offputting. I had a look here to clear up my confusion. https://caddyserver.com/download So the implication here is that personal use is free, and any sort of commercial use is forbidden without per server licenses, but presumably that's only if you download prebuilt binaries, which is odd as they are identical to open source builds. I'd be happy to build myself but it's not clear if that is officially allowed any more from that page, which I suspect is intentional. I realise this was dismissed in your link above, but I think it'd be far clearer to be simple: * Open source free to use for anyone (including companies) * Commercial with support and a few extra features costs money Of course you can't take back what has been given (hence the fuss over that header), but add a few extra features (via the great plugin system of course), which are only available in the commercial builds. For example from competitors: * NGINX Plus has exclusive production‚Äëready features on top of what's available in the open source offering, including session persistence, configuration via API, and active health checks. * Rolling restarts, mass deployment, automatically cancel deploys, better concurrency Just pick a few features from your current roadmap, work on them and start charging for them. Semantic distinctions like who built it are just inviting trouble from techies who like nothing better than splitting hairs and taking advantage of clever hacks, and for better or worse, techies are your market. Large bespoke build farms seem less a product with mass appeal and more a consulting job/service contract. But making money is hard, esp. in infrastructure projects, so best of luck with your chosen path, given the success of your open source work so far, I'm sure you'll make it work somehow. 
http://blog.ralch.com/tutorial/golang-sharing-libraries/ c-shared mode produces .h files (and soon DLLs) that can be called from every programming language supporting C's function interface, but using Go types and runtime internally, so I'm not reaaaally sure it'll mix well with other garbage collected environments like .NET.
Hi buddy - gave it a go, just left it in function main for you to play about it with and seperate it into a seperate function as you wish: https://gist.github.com/arehmandev/818b0c54f4d12db296ab21c2475e5ac0
And what about Go‚Äôs `plugin` package? I wish it will be supported on all platforms too. 
Besides the fairly universal speed benchmark like https://github.com/julienschmidt/go-http-routing-benchmark I have not seen any feature comparisons. One big difference in router type is that some routers require unique matches for a route (like `httprouter`, original `chi`). Others allow for multiple matches and utilize priority of some kind to pick the route: order of declaration or exact match is preferred over parameterized or wildcard (like `echo`). I have one Web application converted from Drupal where aliases (a fixed manually defined URL) were used for SEO purposes. Drupal first performs a lookup for an alias, translates to regular URL and only then passes that to router. I tried to do that in Go with custom middleware, custom handler, doing it in 404 handler (search alias when URL did not match any regular route). It was all ugly. Besides, it would make an extra database hit on most requests. I ended up using `echo`, loading aliases once on startup, and creating fixed routes that have highest priority. All in memory in a trie structure and routing is very fast. Before I picked `echo` I went through: - pure `net/http` - Gorilla toolkit - `gin` - `goji` I could have stayed with `gin` except it was lagging in adopting standard `context` package at the time. AFAIK, `revel` stands out by doing everything in its own way, completely non-standard, non-idiomatic. To add convenience and accommodate passing parameters from route parsing many Web frameworks did one of the following: - add an extra context parameter to all handlers - extend request type (custom request) - extend response type (custom response) "Pure" frameworks now utilize `context` to pass data around now (which is not what `context` was designed for) or provide utility methods to parse route and URL query again in the body of a handler. I am talking about the routes like `group1/group2/:id` where elements have been matched and ':id' parameter value parsed while routing and could have been immediately available to the handler except for the standard Handler and HandlerFunc having no way to pass that information in arguments. There is more, of course. Standard `net/http` does not define constants for some standard HTTP headers. Web frameworks introduce various convenience methods. All these things you can add in your own code. Frameworks also provide form binding and validation infrastructure, integrated logging, graceful shutdown, integration of template rendering (loading and caching templates), and some standard middleware: serving static content, CORS, sessions, etc. You can get those from separate 3rd party packages as well and typically frameworks just wrap 3rd party code. The bad news is you have to try a few solutions to decide what you want from a framework.
Is there any possibility of removing some of the dependencies, such as libcurl and replacing with go stdlib? Makes the package feel alittle brittle in my opinion. 
I don't typically use the built in http router.
The docs are in a completely unintuitive place (IMO), so here's a link: https://golang.org/pkg/go/build/#hdr-Build_Constraints
Gah, I should read more closely before I respond. The above won't actually help. So, for _test.go files, they're only compiled when you're running tests, so no worries there, it Just Works. For internal packages.... this is the best link I could find, which is pretty bad, IMO: https://docs.google.com/document/d/1e8kOo3r51b2BWtTs_1uADIA5djfXhPT36s6eHVRIvaU/edit The long and the short of internal packages is that nothing outside your repo can import anything in there. Also nothing outside the directory tree of the internal package can import it, even from the same repo. So like foo/bar/internal/baz - baz can be imported by anything under foo/bar (.e.g foo/bar/xyz), but not by anything outside of bar, so foo/abc would not be able to import baz. The main package that's only used to run a library... it won't get included in builds of anything that doesn't import it. However, there's no way to stop someone from downloading the code and running go build in that directory, either.... but that shouldn't matter. If you just state that it's an internal utility and not meant for public consumption... people will ignore you or not, but if it breaks, you can point to your warning as to why you're not going to fix it for them
Don't take downvotes as "this is dumb" take downvotes as "I disagree with the paper".... which I think is perfectly valid.
That's a good guess: From the bottom of the pdf: JULY/AUGUST 2008
That's the question. Would love if someone could elaborate a bit more on it.
I don't think that go-stdlib supports the RTSP protocol? In Cameradar, it's very important, as it's basically what we need for sending requests to RTSP services. The second dependency is nmap, and once again we heavily depend on it to scan networks, and it's definitely not in the scope of this project to recode nmap's features in Golang :-) If you have any idea of a quick-win to replace any one of those dependencies easily, don't hesitate to tell me about it though!
IIRC, this work was partly delayed by trying to figure out how Go's thread-local storage was going to interact with the code loading the DLL or other Go runtime instances in other DLLs. What was the resolution to this? It wasn't clear to me from the GitHub issue or the CLs that finished off the DLL support.
I've seen this, but not exactly feature comparison. Still, a decent overview. https://github.com/mingrammer/go-web-framework-stars
It was so cool to just build a little hello world networked app, cross compile it, then run one on Linux and one on my Windows VM. I'd expected way more friction, but everything just worked. I might actually get to write some Go at work with this feature.
&gt; It seems a bit inaccurate to say that the license fee covers continued use of the binary when continued use comes at no cost to you. Sorry, but this is absolutely not true. There is an increased maintenance burden associated with people using the binary for business.
Hi. In image/jpeg.Encode - you have an option - you can low er this a bit to reduce file size and stil have good quality. https://golang.org/pkg/image/jpeg/#Encode Sorry for brief reply. Just have my Phone here :)
It seems to me like rustlang fits all your criteria and it's even faster than go!
It seems to me like rustlang fits all your criteria and it's even faster than go!
It seems to me like rustlang fits all your criteria and it's even faster than go!
It seems to me like rustlang fits all your criteria and it's even faster than go!
It seems to me like rustlang fits all your criteria and it's even faster than go!
But why? Whats a use case for this? Partial/smaller deploys?
But why? Whats a use case for this? Partial/smaller deploys?
But why? Whats a use case for this? Partial/smaller deploys?
But why? Whats a use case for this? Partial/smaller deploys?
But why? Whats a use case for this? Partial/smaller deploys?
But why? Whats a use case for this? Partial/smaller deploys?
But why? Whats a use case for this? Partial/smaller deploys?
But why? Whats a use case for this? Partial/smaller deploys?
But why? Whats a use case for this? Partial/smaller deploys?
But why? Whats a use case for this? Partial/smaller deploys?
But why? Whats a use case for this? Partial/smaller deploys?
But why? Whats a use case for this? Partial/smaller deploys?
But why? Whats a use case for this? Partial/smaller deploys?
&gt; I had to strip a few features A few ?
That's not realtime. Realtime for me and what I work with is sub 40ms latency for 99 percentile of traffic, end to end. It included couple of ELBs, around 4 services in AWS and another 4 in a private cloud/environment. Multiply by 2 to get round trip time. That should be done within ~40ms with measly dual core VMs. You see where I am getting? The definition is misnomer. We need to stop using realtime unless it is declared upfront that by realtime we mean 100s of ms latency. Distributed systems are hard, very hard and making it look simple by using couple of frameworks is just unfair to people who are accessing any software. Sorry for the rant.
A tool that's pretty useful for playing with various snippets of code and showing ASM is [Godbolt](https://go.godbolt.org/) which has Go support I don't know much about more advanced, offline stuff but there seems to be some useful info with https://golang.org/doc/asm and https://golang.org/cmd/asm/, plus of course I'm sure you can find a "objdump for windows" type thing and look at it that way but I like I said don't know much about that kinda thing with Go
Modular deployment is one that I'm interested in. Without loadable DLLs, the only way to break up an app into modules is to deploy independent applications which communicate through pipes/sockets adding serialization/deserialization overhead
`go tool compile -S file.go` gives you the assembly generated by Go. Its not the actual processor assembly mind you .. there is a very thin abstraction layer. But its as close to what you get if you want to see what is the actual code generated.
I worry that without a shared runtime each module would get its own static copy of the Go runtime, each running independently (so 10 .dlls means 10 allocators and garbage collectors also running independently). I hope I'm mistaken.
IMO the greatest benefit would be security. I imagine you could write your app to allow loading external packages to handle SSL (or encryptino in general) which allows hotpatching high severity security issues (f.e. CVE's) without having to completely replace the application. That is only a temporary fix but could help a lot of people maintain LTS releases in Go more easily.
github.com/streadway/amqp ?
Basically, I removed the feature that allowed Cameradar to use cache managers. This was initially a feature because I was working on an application which required Cameradar to be able to read/write in a database continuously at runtime. This introduced a lot of complexity in the C++ application, as I used a dynamic library system to load the appropriate cache manager dynamically. Other features were environment variables support (it's being added back here https://github.com/EtixLabs/cameradar/issues/84), thumbnail generation (to generate pictures from the accessed cameras), GStreamer checks (to make sure that the RTSP streams are working properly), inaccurate detection of camera models, control over the number of threads used, and the possibility to launch each task separately (discovery, credentials attack, route attack) since there was a static cache. These features were needed by the application I developed Cameradar for, and they had no reasons to be done in Cameradar itself. Cameradar should only be discovering and accessing cameras. Now that it became a library, everyone is free to build on top of it, and for example I will now probably make a new service that uses the Cameradar library but also generates thumbnails using `ffmpeg`, and does gstreamer checks using `gst-launch`. If someone wants to build a bruteforcing software, they can basically copy-paste the example given in `/cameraccess` and replace the loading of dictionaries with their own generation of bruteforcing dictionaries. TL;DR: It has less features than my previous C++ application, but it's way easier to build whatever you want with it, including to recreate the previous features.
Well said and I did not thought so. But a bit of actual reflection on the matter might be more helpful about the "why" &amp; the "how". Yet again I'm not good with social media! :)
IMO: because it compiles so fast you don't need to add a plugin, instead of hard coding the feature.
The PNG package in the standard library uses compress/flate under the hood. The algorithm in flate has been vastly improved over the years, but the compression ratio still falls short slightly when aiming for highly compressed static content. There are several reasons: * For performance reasons, compress/flate only performs 4-byte offset matches, while the DEFLATE format actually allows for 3-byte matches. This sometimes matters for images without an alpha channel (RGB is 3-bytes). * Most PNG crushers use a specialized implementation of DEFLATE that heavily sacrifice compression speed for compression ratio (see https://en.wikipedia.org/wiki/Zopfli). This algorithm does not exist in compress/flate. * (not specific to compress/flate) Some PNG crusher are actually lossy in that they discard some details from the image that humans cannot perceive so that DEFLATE can further benefit from more matches. I can't really speak for JPEG and other lossy formats. Source: I maintain the lossless compression packages in the standard libraries.
**Zopfli** Zopfli is data compression software that encodes data into DEFLATE, gzip and zlib formats. It achieves higher compression than other DEFLATE/zlib implementations, but takes much longer to perform the compression. It was first released in February 2013 by Google as a free software programming library under the Apache License, Version 2.0. The name Z√∂pfli is the Swiss German diminutive of ‚ÄúZopf‚Äù, a unsweetened type of Hefezopf. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/golang/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.27
LISP is from 1960 and ML is (if I recall correctly) from around 1990 and State Machines are even older than that. Erlang is about 30 years old. I do not think the age of a paper in computer science could be a measure of qualification/disqualification or anything in itself. These days you hear from consultants do not use RPC for communication with outside world. Use it just internally for (as an example) your microservices architecture (which is not a bad thing by itself). And use REST for the publicly provided API. Some points from the paper (as much as I recall): * Struggling with IDLs and try to stuff anything thing inside them, * Scalability; with REST you can load balance, with RPC, well you are just calling a procedure remotely, that's not the same as scalability, * Caching? Authentication? Authorization? etc, etc, Yes; you can *implement* all of them using *RPC* (in non-standardized ways), which the same kind of reasoning if we say "you can write everything using assembly" which is absolutely correct and absolutely out of context. 
Author here: Apologies for the confusion in the ''portability' section. I've fixed the section in the article :)
That would be very improper and naive if I had thought of people as "all of them are stupid". I just think most of the time we choose the easy pass - what is familiar and known is good and there is no need to question it. I'm not saying I agree 100% percent with the paper. But in the history of software development many mistakes happened and *maybe* this is one of them.
I get the feeling you don't deal with security very much on Windows. DLL side loading is a very common attack pattern for malware and unless those DLLs are signed from a trusted source, which is not nearly as simple as it sounds, you basically have no way of trusting the DLL you're loading. Anyway, DLL support can certainly help with maintenance but it's not going to solve the security problems that dynamic linking introduces.
You can try this package if you want to experiment with lossy PNG compression: github.com/peterhellberg/lossypng For JPEG you can use the quality option in the syandard library to reduce the file size (and visual quality) Let me know if you find any (Go) native implementations of JPEG optimizers.
[removed]
no
personally I disagree with the paper. 99% of the time, what developers really should use is RPC. Because at the end of the day, when you send info to a server, you're not merely syncing state with it, most of the time you're requesting it to do something and give you data back. That's RPC. RPC fits the model that developers actually want to use. REST is fine if you don't have much logic on the server, but the minute you start putting significant logic on the server, REST stops being useful and starts being a hindrance. I've tried developing a proper REST API and it was horrible. Talk about trying to fit a square peg in a round hole. RPC is easier because you don't have to contort your application to fit the transport layer (at least, not much). With REST I was wrestling with media types and related links and all that garbage. As for caching and distributed servers, there are plenty of services that help with such things, redis, memcached, etc. 
that's a best practice and in some contexts is the good thing to do but I also think that limiting your API to the minimum information you need to expose is the best the Service interface already exists and exposing a new concrete type would not add much more
This was probably the missing bit for Windows. Iirc osx and Linux already support it in 1.9
I was thinking about curl specifically, are you doing anything exotic that cant be done with http.Client? I'd have to look into the other dependencies
sideloading malicious libaries is an issue on any platform that has a dynamic linker (LD_PRELOAD anyone?) You can do very simple signature schemes or just use GPG or only use certain trusted paths to dynamically load the DLL. Dynamic Linking may introduce some security problems but it solves some others, like any security it's tradeoffs in this particular area.
&gt; Dynamic Linking may introduce some security problems but it solves some others, like any security it's tradeoffs in this particular area. +1, that's all I was trying to say. I've seen a lot of people call Go insecure because it's using static linking by default and that by default other languages are more security because of dynamic linking (cough: Java....). It's a trade off in any case and more or less depends on the ability to do patch management+signature validation/quick releases for static binaries.
Why are files being modified in the first place? VCS should be configured to preserve line endings from the repository when cloning locally.
Thanks for your help. I've also enforced a relative path prefix of "./" in addition to removing any forms of "../" https://github.com/everdev/spin/blob/master/config.go#L39:L41 If you still feel there are attack vectors, please feel free to let me know.
I would like to know more about pros/cons of gRPC too. Personally I use NATS for distributed/decoupled systems. It's far cleaner and simpler and one can use it with every programming language. It's a message broker, so, not RPC exactly. And it does the service discovery and load balancing for me - it's possible to have different instances of a service listening for the same topic on different machines. Apart from not being an standard, I've seen no drawbacks using it in production.
Let me know if it sounds better now? https://hackernoon.com/the-beauty-of-go-98057e3f0a7d
Article Author here. Haha. Really funny discussion. I can't explain how I find it it beautiful :). I'm able to express programming logic in concise and clear syntax using Go. This, in addition with other things described in the article make it seem beautiful to me :)
Article Author here. Haha. Really funny discussion. I can't explain how I find it it beautiful :). I'm able to express programming logic in concise and clear syntax using Go. This, in addition with other things described in the article make it seem beautiful to me :)
Apparently [gofmt is supposed to remove CRs and canonicalize on LF](https://forum.golangbridge.org/t/gofmt-canonicalizes-line-endings/3615/3), which would mean the real problem is the source repo not having had gofmt run on it.
Indeed. I use a cloud platform where the best option is to log to stdout and stderr, so I have my own trivial log package which adds log levels and maps the appropriate levels to the appropriate streams. It doesn't have any of the configuration options of logrus because I don't need any of them. It doesn't colorize output because the platform handles that.
I reccoment looking at twitchtv's retool. Its like glide but for dependencies. Also beware that the goswagger binary can generate code for a different version than the library it uses. Thats why retool and vendoring your source are super importabt for a stable experience
Ask Sam Boyer and the Dep team. He already said my Git settings shouldn‚Äôt be the culprit. And those files were only ever there in the first place thanks to Dep.
Hmm, makes me wonder if it‚Äôs another member of my team committing deps w bad crlf settings for Git. I‚Äôd like to think my coworkers would notice if their commit included dozens of unintended files.
Very possibly, but the example also shows non-Go files.
Presumably that's Git doing that, then.
Yeah, but the Dep peeps say my Git settings shouldn‚Äôt be the culprit. It‚Äôs weird.
git on windows often defaults to a global setting that allows you to checkout with CRLF and checking with LR. If a tool that uses git's global settings that includes this it may change the files on checkout (checkout will be in a new location / repo for the cache). It will then show the files as different, unless the dep hasher normalizes line endings.
No one involved in these projects are committing on Windows I‚Äôd wager, but you never know.
&gt; loading aliases once on startup What does happen if I create a new blog entry with an alias? Do I need to restart the router then?
So we may have a chance to see plugin land on Windows in 1.10? Or is merge window closed?
Merge window runs till end of November but someone has to do the work for it...
Just use caddyman https://github.com/Incubaid/caddyman
I don't see any reason why there would be a problem. It's no different from interfacing C and Lua or C and JavaScript. You just have to handle your references correctly.
On stripping EXIF, it's highly unlikely to be a significant amount of data. Files which do have a lot of EXIF data are probably straight out of camera and aren't what you are putting up to begin with. Also, stripping out EXIF data for no reason might not be what you want at all points. Not that I know much about the rather arbitrary goal you are trying to reach here, if you want to crush files you probably want to call out to the CLI for that. I wrote some binding for PNGquant or whatever it's called a few years back to call it as a library and it was very inconvenient. I don't think the code still exists at this point. image/jpeg and image/png are probably good enough.
https://play.golang.org/p/06les9YDNg
How about "being able to write Windows dlls in Go"?
Message brokers are SPOFs. They‚Äôre no substitute for peer-to-peer communication.
Yes, there are still attack vectors.
It was for legacy routes. You can add dynamically routes in `echo` now while it's running. An alternative would be graceful restart.
Just ignore it and return all fields. Bandwidth is incredibly cheap and plentiful.
As a Go newbie, isn't Go on version 1.9 already..?
OK, but in some cases the data could be quite large for certain apps. Regardless, is it technically possible to query for user-defined fields safely?
Thanks, I'll take a look at you CL!
Sounds like you could use GraphQL: https://outcrawl.com/graphql-server-go-google-app-engine/
First criticism, it's not a script.
You could use transformations. If you were to create an array of "fillable" fields that are safe to return it wouldn't matter what was queried since you are essentially sanitizing the query. You could query for all fields or be more specific without worrying about injection attacks.
Noted, thanks
In those cases, make the larger data available elsewhere. There's NOTHING that says the fields in your response must correspond to the fields in the DB tables... Is it technically possible? Sure!
I would use a flat file structure: https://blog.golang.org/organizing-go-code Most other languages tend to use folder to separate functionality, but Go uses them in a more robust way to define reusable code. https://golang.org/doc/code.html is also a good place to learn Small functions are good, but this one doesn't really add value: https://github.com/dlopes7/appdynamics-license-monitor/blob/master/license_monitor.go#L134:L140 and can be combined with `processLicenseModules` https://github.com/dlopes7/appdynamics-license-monitor/blob/master/license_monitor.go#L73 `processLink` uses some deep if/else logic and some fmt.Printf statements. In go, it's typically better to return values back to `func main()` like: ```go func main() { output, err := myFunc(1) if err != nil { panic(err) } fmt.Println(output) } func myFunc(i int) (string, error) { if i &lt; 0 { return "", errors.New("i must be &gt;= 0") } return "i is &gt;= 0", nil } ``` This way, your functions are more easily unit testable and you have a simpler API in your app. `myFunc` can do lots more work, like your functions do, but I know I can toss it an `int` and get back either a `string` or an `error`. It keeps your apps more predictable and helps you refactor down the road.
It's a program.
I've looked at it, but the packages for Go looks pretty new and without much documentation: https://github.com/neelance/graphql-go
This is amazing feedback, thanks for taking the time! 
If you really need to, have a set of "allowed" columns, and parse the user-provided text into an interpolated list. Here's some terrible unchecked code, but you get the idea: allowed:=map[string]struct{}{ "title": {}, "body": {}, "author": {}, } cleaned := []string{"id"} for _, field := range args["fields[articles]"] { if _, ok := allowed[field]; ok { cleaned = append(cleaned, field) } } query := "SELECT "+strings.Join(cleaned, ", ")+" FROM articles"
Bandwidth may be cheap but depending on the volume and number of fields returned this suggestion could cause performance and overhead issues. It's fine if you only need five fields but it was never stated how many fields could potentially be returned.
I'm not sure I follow. In essence, I want users to be able to request `title`, `body` or `author` (or any combination of) from the `articles` table. I know I can `SELECT *` and then only return what they asked for, but I'm wondering if there's a safe way to construct the exact query the want programmatically.
This is similar to my response. You could also change out the allowed columns for "protected" or "hidden" columns that should be ignored.
Yes, this approach could work, thanks!
See /u/dinkumator's answer for an example similar to what I was talking about. The idea is that you define what fields are available and let that be what you use to programmatically build your query. The user could ask for `title`, `body`, `author`, and `DROP TABLE articles` but only get back the title, body, and author assuming they were in your list of allowed columns/fields. You could also do the inverse and say they can query for anything except for values in a list of protected or hidden columns/fields. I'm not at my computer at the moment or I'd give you an example. If that still doesn't make sense I try to come back with an example sometime tomorrow.
I wouldn't recommend the blacklist/"inverse" approach since you'd still have to sanitize the inputs pretty extensively.
Thank you very much for this!
There's actually not much additional sanitation needed if you set up the lists so that they map the fields/columns to a the same field/column or even a custom name. If you set up your map so that title has the value of title you know that the only field going into the query is title. Essentially what I'm talking about are associative arrays where you use the value as the query parameter. This approach also allows you to make some ugly columns easier to expose on your API if they have really long or prefixed column names.
Makes sense, thanks!
I thought plugin was broken and disabled on Mac
!redditsilver