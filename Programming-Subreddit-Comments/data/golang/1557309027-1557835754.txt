What an absolutely interesting conversation... And both of them are so humble and don't have any airs... The last bit where Ken asks them to keep their hands up so he can get a pic (•‿•)
You're welcome man :) Good job on the project. Looks interesting
Out of interest, what makes the way Go handles concurrency better? &amp;#x200B; You named the technical difference but not the reason its better. &amp;#x200B; What I gathered is there are few side cases (which can always be handled "properly") in which using multiple node processes may result in response delays. However, the way node handles concurrency you get much less initial delay for each request than you do with Go. So how is Go's implementation "better"?
The common way to do this is to use Python: :%!python -mjson.tool Does `gojson` offer any additional benefits? Python should already be installed on most Unix/macOS machines.
Shameless plug, I recently posted [here](https://www.reddit.com/r/golang/comments/bgcsey/setting_up_vim_as_a_go_ide/) my personal way of working with pure Vim and vim-go (which is what the OP also uses under the hood as far as I can see) and also contains some more info and a nice cheatsheet. Btw vim-go now supports the native LSP (gopls) since the latest release, which is pretty neat.
Shameless plug, I recently posted [here](https://www.reddit.com/r/golang/comments/bgcsey/setting_up_vim_as_a_go_ide/) my personal way of working with pure Vim and vim-go (which is what the OP also uses under the hood as far as I can see) and also contains some more info and a nice cheatsheet. Btw vim-go now supports the native LSP (gopls) since the latest release, which is pretty neat.
`%!jq .`
`set formatprg=jq` and the just `gq`... Why humanity love to over complicate things?
or this
note：what I post including runner and repl is not the feature of vim-go. so why shameless??!
Looks nice.
Very well put. To the OP, as usually, I highly recommend reading [this classic essay](http://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/) which deals exactly with the "concurrency and I/O integrated in the runtime vs it bolted on as a library" dichotomy.
im a junior and make more than that
Personally I've always preferred to stop tests on the first failure because subsequent failures often seem to be caused by the first failure and can be misleading (eg, something was returned nil, the nil-assert fails, but later asserts would also fail because they assert things that rely on the value not being nil). Is this a problem you encounter with your approach?
Note that this is 2\^10, where `1&lt;&lt;9` is 2\^9
It can be used to query inside the json also &amp;#x200B; It \`gojson\` is similar to \`jq\` with less features for now. I am writing \`gojson\` as a side project adding more features (a subset of jq) .
Yes. But I think checking for -1 is just as convenient as checking an error and in some cases you know that the value must exist, so why add rigamarole? FWIW see https://godoc.org/strings#Index
Can someone explain his shirt?
`gojson` is similar to `jq` with less features for now. I am writing \`gojson\` as a side project adding more features (a subset of jq). &amp;#x200B; Rich syntax of jq seemed a little too complex for some common scenarios, wanted to create a tool with a subset of features that `jq` provides but more intuitive apis
Go is better in every way except one: it's not JavaScript (if that's an important criterion for you). It's faster, it's typed, it's aot compiled, it's statically linked, it can use more than one core, and it doesn't require a maze of callbacks for concurrency.
https://www.welcometothejungle.co/fr/articles/languages-software-go-elixir explains in a nice way, why Go was invented.
I guess that is right. It just feels not 'go like' because it reminds me of c return codes
This was a great help, thank you for showing the community how to build an application with Go and Vue.js using Wails. It's my favourite framework for building desktop apps using Go &amp; Web Technologies.
&gt; In an age where a typical messaging application might eat up to a couple of GBs, this app was sitting there minding its business, rocking a 20MB?!? footprint. 20MB? Even if following a very naive logic, this is close to fitting 20 of these apps together, for the cost of running one Spring Boot app! Go does have an advantage for apps that receive very low/no traffic, but with actual traffic, Go will start using a commensurate amount of RAM. The JVM will allocate more memory on startup, but that doesn't mean that it's going to use more memory than Go when it has traffic. Go certainly has advantages, but believing that it uses 1/25th the memory in real-world scenarios just isn't right. Also, if one is going to compare a minimalist Go program to Java, why not compare it to Javalin or Jooby? Heck, use Javalin with Graal and you'd probably get similar results to Go for what was measured (https://javalin.io/2018/09/27/javalin-graalvm-example.html). If you're comparing Go, reaching for Spring basically means deciding in advance what you wanted the conclusion of the article to be. Go can have some memory advantages, but they're a lot smaller than naive comparisons. For example, Java uses reference types while Go will allow one to avoid a certain amount of reference overhead. Likewise, Java typically uses a copying GC which makes the trade-off of using additional RAM to get additional CPU performance. Go makes the opposite trade-off with its GC. Likewise, if you're looking to use cloud functions, even a couple second startup time wouldn't be good. The JVM will have slower startup time (a few seconds on good Java applications and terrible for Spring). The JVM will use more memory on startup, but that disadvantage usually goes away with traffic. Go is a good language, but if you're looking to memory usage without traffic or comparing it to Spring's startup times, you're not doing a real comparison. You're justifying a choice you wanted to make. Again, Go is quite a good language choice, but the article really goes into non-comparisons.
As often as I've heard this repeated there's a pretty big gap between writing working code and really knowing the idioms, tooling, libraries, pitfalls, etc. I love learning new languages, but it's a thing of beauty when it becomes so second nature it drops away and becomes transparent to solving the actual problem. Realistically few of us are going to achieve that level of mastery in more the a handful of languages. Also, a lot of languages overlap. What's the web API language of choice? ... or text parsing? Even if you have a well defined, niche problem, like NLP, there are usually good toolkits or bindings for multiple languages--especially the mainstream corporate ones.
Great resource, I also found this guide useful [https://www.golang-book.com/books/intro/3](https://www.golang-book.com/books/intro/3) However, your article has it very clearly outlined thanks!
I meant that *my* post was a shameless plug since it came from my own blog. I didn't mean to sound hostile or anything, sorry man, your post was cool!
Agreed, and the author states this as well: &gt; As people say in stock trading, “always do your own research”. I don’t want to convince you to switch and use Go full-time, because I haven’t convinced myself yet. As with everything else, programming languages are just tools, and there will always be a different tool which is better for the particular circumstances.
That's not surprising: https://www.techempower.com/benchmarks/#section=data-r17&amp;hw=ph&amp;test=json&amp;l=zijocf-1 In that context, my comment implies a few thousand *extra* requests per second for the cost of changing a library. Your marginal cost for CDN caching is likely to be super low, and unless you're dealing with a massive volume of requests the difference in machine count for scaling out horizontally may not add up to too much. $0.02: choosing an http library in Go for speed before you know that's your problem is a premature micro-optimzation.
To be honest I thought it was a fair comparison in this case since the article was not "really" about Go vs Spring. Despite the comparisons mentioned in the post, it was more about why the author would *potentially* consider using Go over his Java + Spring tooling. He just happened to do the comparison against Spring, and not Javalin, Jooby, etc, because he uses Spring a lot or used to (he didn't make mention of any other framework that I'm aware of).
&gt; Go does have an advantage for apps that receive very low/no traffic, but with actual traffic, Go will start using a commensurate amount of RAM. The JVM will allocate more memory on startup, but that doesn't mean that it's going to use more memory than Go when it has traffic. This doesn't reflect my experience. Generally, the Java systems I've worked on or monitored under load have required more memory than similar Go systems. However, it has been several years since I've done much work with Java. Others have reported [measurements](https://twitter.com/rahul_606/status/1067427671376748544/photo/1) of the same phenomenon.
Not when using table driven tests, for the same reasons Cheney mentions. Other test cases it depends on what was being tested and what failed. If I'm checking several attributes of a struct in a row, I can keep going and get a better view of the failure.
It is disappointing that Gorgonia never seems to get included in articles/videos along these lines
\+1 vim-go is pretty much the way to go!
Unless it's a [PHP hammer](https://blog.codinghorror.com/the-php-singularity/).
It looks much more readable to me! I’m going to have to try this out.
Thanks! One of the things I always found that developers new to Go (and programming) struggle with is what integer type to choose. Other than telling them to use `int` there was never an explanation. I hope I shed a little light on that. Although I feel like it could be an article on it's own. Maybe I'll add that to the list of articles I want to write.
Yes, that's basically what the server is, very simple API into S3. It's not quite just SET/GET but yes.... I'm looking to keep adding convenience features (perhaps a qr code to share your send address...). Let me know if there is anything you would want to see....
IIRC, the go standard library has a few "return -1 if no result exists". Things like the `strings.Index` family.
The Standards layout is a must read for me [https://github.com/golang-standards/project-layout](https://github.com/golang-standards/project-layout). It is not API specific but I build apis this way
Golang is slowly becoming huge . fascinating .
I used to be a big fan of go and hated Java (and I thought the jvm) until I switched to kotlin. It's type system is a bit stronger than go and has more expressivity which are two big boons. I think immutability and a certain amount of functional flavor is really important. Finally there is the spring ecosystem. If you are liberally using resilience4j for fault tolerance, chaos monkey integrations, grpc and rest servers, and liquibase for DB migrations I just don't see why you'd switch to go. Until there is a real story for those tools (esp fault tolerance ) that doesn't require a few hundred lines of setup (we use all of these for each microservice) then I'll stick to kotlin and use rust when Im allowed :).
Without doing the research (am on mobile right now) i would guess those are api's from the very early stages of go, where it was more c/c++ influenced
Nevermind, I found it: https://www.bell-labs.com/usr/dmr/www/odd.html
Here is a small&amp;Basic - Login&amp;Register&amp;MongoDB api i have on my backend. [https://pastebin.com/pnCKTzHy](https://pastebin.com/pnCKTzHy)
my favorite feature of pytest, by far
I didn't, until I noticed event fields are encoded in and parsed from the same string; that's just wrong, period :)
In place of those custom check functions I'll often accumulate a bunch of testify assert.Comparison functions type Comparison func() (success bool) Used like: require.Condition(t, equalWithoutCustomFields(expected, actual, field1, field2))
Fair point, I wasn't actually thinking of table-driven tests when I asked, in a table-driven test it's definitely not a problem. I guess I tend to compare whole structs rather than fields in a struct as separate asserts.
the setting looks so similar to electron. wishing for `react` support
do you possibly have a test func that you could show us?
There is a good list here already for why Go is hands down just better in many ways, but directly to your question: for a simple crud app where Node can handle all the connections you anticipate having, Node is fine too. A crud app with little processing load and a moderate number of connections is probably roughly equal in almost any language. Besides my personal preference for Go, I do think one remaining difference is the ability of the Go compiler to catch lots of errors simply through its type system and the human to make fewer errors due to simple, clear syntax. You can still have that in other languages. I've seen very comprehensive testing in Python teams, and I've seen Typescript written beautifully to express types in a way that eliminates potential for many types of bugs. People often say that the best language is the one you're best at writing as a team. That's usually true. "Slow" languages with loose types and / or high syntax complexity are still fast enough for companies with a lot of throughput when the correct architectural decisions are made. A large shoe company isn't going to fail because they for some reason started a new project in Perl. I've seen a lot of companies (including two that employed me) make the choice to use Go for high throughput applications despite being companies with almost all C# developers. We were pleased with the choice, but it was the business departments that really made or broke the products.
I recently went through a similar journey. I even put my thoughts together on a blog as well. Thank you for your time and research, its great that we are all coming to a similar conclusion about Go. Welcome to the community! I'm a Java Dev that is now a Gopher. You didn't mention the big gorilla is that Java is now owned by Oracle and the Oracle JVM and features must be paid for with an enterprise license. The Java community is split, and Go is a natural direction to move in. I feel that Go is very expressive, it has a lot of the best parts of Python. Primarily slices and ranges. I very much enjoy the Pythonic way, and Idiomatic Go and the Go Proverbs are music to my ears. In addition, I love that concurrency is a first class citizen with go-routines and channels. It is very easy to focus on the single threaded solution and then use those constructs to make it multi-threaded. Multi-thread packages via the shared memory model is one of Java' strengths and Go has similar strengths there. Back to Java, it feels really nice to be able to write less and do more without a loss of readability in Go. And the smaller project repos and less 3rd party build tools are great too. Java is verbose (with a purpose for readability) but it does get really redundant and even error prone at times. My research also showed that Go was more performant with CPU time. I didn't test memory utilization and GC enough, but I also found it better for my use cases. Save us a lot of container space on production clusters. Smaller docker images that required less CPU/Memory to operate. We'd love to hear more about your use cases. As you mentioned, pick the great tool for the job. Welcome!
seems about right. i do it slighty different but at its core its the same
[removed]
check out https://github.com/spf16/droplets - I randomly found it and it seemed good enough to strip out and start with something
This article was super helpful to me when I was getting started: [https://medium.com/statuscode/how-i-write-go-http-services-after-seven-years-37c208122831](https://medium.com/statuscode/how-i-write-go-http-services-after-seven-years-37c208122831)
[removed]
[removed]
[removed]
Although a bit more "heavyweight" in terms of the boilerplate to start going, I really like using gRPC + HTTP based services defined using protocol buffers. I say 'heavyweight' because I spent 15-20 minutes of 45 in a pair programming interview this week writing a lot of boilerplate before even touching the code question. However, although you won't be able to fire up a service as fast as someone else, I like how this makes the API more clearly defined and extensible. https://medium.com/@amsokol.com/tutorial-how-to-develop-go-grpc-microservice-with-http-rest-endpoint-middleware-kubernetes-daebb36a97e9 Here's an example of a tutorial using such. There's a few parts I dislike here and there, namely the way he imports his own code, but I really like using a similar method to his.
This is a bit outdated in the world of Go Modules. It's also assuming a large repo with lots of packages and commands, and there are typically much simpler ways to structure a repo if that's not the case, particularly if you want people to import your packages.
For restful http://thenewstack.io/make-a-restful-json-api-go/ https://tutorialedge.net/creating-simple-restful-json-api-with-go https://stevenwhite.com/building-a-rest-service-with-golang-2/ - much better resource http://blog.narenarya.in/build-rest-api-go-mysql.html https://hackernoon.com/build-restful-api-in-go-and-mongodb-5e7f2ec4be94 http://blog.questionable.services/article/custom-handlers-avoiding-globals/ https://medium.com/statuscode/how-i-write-go-http-services-after-seven-years-37c208122831 https://dev.to/geosoft1/versioning-your-api-in-go-1g4h?utm_campaign=Golang%20Ninjas%20Newsletter&amp;utm_medium=email&amp;utm_source=Revue%20newsletter
Golang Restful Starter kit with dependency injection and clean architecture: https://github.com/ribice/gorsk
Does this setup work with the windows binary version gvim? You only used it in the WSL, for your benchmarks.
Its probably because its used to create Google products and services rather than being a product which is marketed and sold like .Net so is more low key. I've been using GO for a few years and in my opinion it only seems to be gaining in popularity.
.Net is free however
I think it's because Go is still very impressionable. If it becomes attractive to certain people they will be able to greatly influence its design and direction. So encourage / enable only the people that don't value anything beyond simple language design for its own sake.
But they sell Visual Studio subscriptions which is heavily tied to the success of .Net. Google don't sell anything similar as far as I know for Go.
You're welcome. As a side note, this is a similar problem to processing DTMF (Dual-tone multi-frequency) signals as produced by telephones. This is an example of using some of the packages I linked above (go-dsp and portaudio) to perform DTMF detection. https://github.com/simonswine/golang-dtmf
Maybe, but you'd think they would like more and more people using their language if there is such an occasion to do so.
&gt; there's a pretty big gap between writing working code and really knowing the idioms, tooling, libraries, pitfalls, etc. This. Programming languages are no different to natural languages in this respect (but *far* easier to learn). It takes some real work to be "fluent" in a language, to express things in a way natural to that language rather than twist it to fit idioms from another language you're more familiar with. Google's early Python API libraries, for example, were basically Java using Python "words". They worked, but it was appalling *Python* code.
Google and the GO team, especially Rob are very adamant GO != Google and that the GO teams work on GO and just happen to be paid by Google. I heard him correcting people on multiple occasions by saying that GO is an open-source language where the majority of contribution these days comes from outside of Google. On this note, Flutter is open-source, however, Google promote it whenever they have a chance. It could be because GO is much more mature than Flutter is at this stage.
I kind of think of Go as created from within Google to solve specific issues, rather than being something produced by Google. So Google as a company probably doesn't really care about it that much.
I tend to embed Assertions in my own assertion type and add methods to it - extending require. by things specific to the piece I’m testing - similar result to yours but tad more abstracted away.
Flutter is also a proxy for Android, and Google wants more Android devs.
I'll form an opinion when and if the compiler is available.
Visual Studio Community Edition is free and works good for most projects and there is also VS Code which is also free. In my opinion being successful with .NET isn't tied to any subscription and I think MS has made a lot of progress decoupling .NET from any IDE. Hell, I have created some simple things using Vim and the dotnet CLI which is my preferred environment when working in Go
Fairly certain this is vaporware - some tough questions were asked in the subreddit to which there were floundering answers, if any. That subreddit is now gone.
Why would you pay for a cert in 2019?
I wrote a template for writing web API's including dependancy injection, sessions, and many more! You can find it here: https://github.com/bruno-chavez/go-web-template Sorry for the shameless plug!
Go is selling itself really. It's checking more boxes for people than just about any language I've seen. Production apps don't crash because errors are handled. Libraries don't have bugs because the authors wrote them _out of valuable experience_. Build times are fast enough they don't really matter for small apps. Performance is close enough to C++/Java for most things. Concurrency is easy. The language is simple. Backwards compatibility guarantees, and on it goes...
I didn't know that term and tend to agree as I know it now.
Check this sample that I've create: https://github.com/cyruzin/go-repository
If you have time, I would write a proto file. Depending on use case https://github.com/grpc-ecosystem/grpc-gateway may be great for your needs. Your database to honor DIP and clean should be less treated like a database and more as an interface that can be satisfied with a package that implements a database. Hopefully this gives you breadcrumbs to figure the rest out.
Yes. Good choice.
I just came across this a couple of days ago: https://github.com/deepmap/oapi-codegen
Go is really inconsistent in how strings.Replace may take -1 as an argument for replacing all instances, while strings.Split will split all, but SplitN must be used for a specific number. There is no ReplaceN. I wish -1 was not used as a magic value anywhere in Go.
What do you mean? Alpine *is* an entire operating system.
One of the areas where go really shines is for systems tools and utilities. You compile to a single binary with all its dependencies wrapped in. You don't need to worry about what version of which frameworks you have installed and configured correctly in an environment for the binary to run. A very very different experience to what you would have with python or ruby or signing something like Java or node. As in demand as system stuff is it's just not considered that sexy and there are fewer people seen to be interested in doing it then frontend stuff or even backend stuff.
Disk space and bandwidth are cheap. Time is the most valuable commodity. Small images are faster to use than large images, IMHO, and are likely more secure as they present a smaller surface area.
well -- we're splitting hairs here i think. i guess one could argue that better written software requires little maintenance? sure, if requirements change then even the best software will require maintenance. but this wasn't the case with fasthttp. the example i pointed out was a case of poorly written code AND bad maintenance. i concede that maybe i didn't express myself well.
my point is: friends don't let friends use fasthttp. most people do not have a legitimate use case for it -- not one that over rides the drawbacks to using it.
In my repos I have one example for command line app. It's a video file converter based on ffmpeg (https://github.com/soldatov-s/go-ffmpeg/blob/master/ffmpeg.go). May be it some help you.
&gt; Absolutely no mention about Go, I/O 2019? Absolutely no mention about Go(i think). Go is not a Google product and never was. It's just happen to be developed by Google developers. &amp;#x200B; &gt; Google isnt confident in Go becoming a big one in the industry It's already big. Just look at the products using Go. Everywhere you look, everybody using Go on the backend. &amp;#x200B; &gt; Golang really that performant of a language? Yes it is. It's very performant and very efficient in terms of RAM. There's no shame in comparing it with .Net. The latter is also very performant but lacks in terms of GC and memory usage. But that's benchmarks, in practice Go is often faster than Java/C# and, in general, much more lightweight and efficient. Java, for example, is often accompanied by some heavy enterprise grade web framework that uses tons of CPU and RAM for no good reason. Something you don't need with Go. Go was never supposed to compete against C or C++ in term of performance, that's not possible given how much extra stuff Go has to do (memory safety, GC, runtime). But it gets pretty close and performance is a small price to pay for what you get with Go.
I think there is a very basic difference it how different people relate to programming languages that is apparent in comments like your and the parent. The core of the difference seem to be whether you view a programming language as a medium or a tool. The idea of a tool carries with it the connotation of simplicity and variety. Think tool box with hammer, screwdrivers, etc. Where a medium relates a deeper, longer term relationship with something. Artistic and communication mediums being the rule here. I am strongly of the medium school of thought, but see the tool metaphor often enough to see that other people don't relate to these things in the same way that I do. I've argued against the tool metaphor often in the past, but I'm coming around to the idea that these are really different personality types or something.
Porn stars getting destroyedhttp://0fz9.yatv3cuz.org/fam4sc2m/
[removed]
&gt; Windows Well there’s your problem... Jokes aside, share your code for starters.
I use [gorilla mux](https://www.google.com/url?sa=t&amp;source=web&amp;rct=j&amp;url=https://github.com/gorilla/mux&amp;ved=2ahUKEwjt_rn554ziAhUNKK0KHYGzA74QFjAAegQIAhAB&amp;usg=AOvVaw10NUv4LL-jwok0Pd5tJ0NK) because I find it's routing to be much simpler to wire up, but Go's built in http package can be used for doing api routing and such.
 You can offend me when it comes to Windows. I am stopping at W7 where I still have control over the system. Actually, could this instruction be deleting every file in the directory? I thought it would only delete the filename. err := os.Remove(path.Join(cfg.Files.Pooldir, filename))
seriously?
This is my opinion (GoRESTAPI)[https://github.com/snowzach/gorestapi] It uses chi for a router, viper for config, cobra for CLI stuff and zap for logging. Here's the GRPC alternative (GoGRPCAPI)[https://github.com/snowzach/gorestapi] It supports REST and GRPC over the same port.
Golang 2 features will come with golang 2 xd. Not golang 1. Generics and error handling are features that will be live in version 2. Few time to come :)
I'm using this pattern a lot in this repository: https://github.com/jensneuse/graphql-go-tools/blob/master/pkg/lexer/lexer_test.go
I'm currently writing an SDK as a learning exercise and have spent a good chunk of time trying different approaches. In the end I found that the implementation used by the moby project newbie friendly and very flexible, so that's what my client code is based on
Did a self signed myself, the graphql client and chrome didn't like it...
My first rest api in Go [https://github.com/steffen25/golang.zone](https://github.com/steffen25/golang.zone) Frontend is open source as well and the site is live if you want to take a look. Feedback is welcome.
Je connaissais pas ! Merci
LetsEncrypt.org https://godoc.org/golang.org/x/crypto/acme/autocert
I searched “golang image diff” online [1] and found this [2][3]. [1] https://www.google.com/search?q=golang+image+diff [2] https://github.com/murooka/go-diff-image [3] https://github.com/x1ddos/imgdiff
You can try https://gokit.io
That is, thanks for helping me.
I wrote this a while back https://link.medium.com/nibBOyk9wW
The xerrors package is going to be part of 1.13
&gt; 1 author has pushed 2 commits Hmmm.
You might also be interested in [cloud.google.com/go/httpreplay](https://cloud.google.com/go/httpreplay).
I like this more, table tests without subtests give hard to debug failures with no line counts.
I was having a bit of a frustrating day yesterday and I fear that bled over into this conversation a bit more then I realized at the time. I do apologize, my intention was much more curiosity about your perspective and opinion of the situation then any intention to split hairs about a definition. I do think we are both on the same page about it for the most part.
Absolutely!
Sure...: func prefixMatcher(needle string, haystack []string) assert.Comparison { return func() (success bool) { for _, entry := range haystack { if strings.HasPrefix(entry, needle) { success = true return } } return }
That's because I generally suck at marketing these things. Life gets in the way sometimes
Oh, good to know! Thank you!
Oh, good to know! Thank you!
Thank you!
Thank you. I appreciate the feedback. Truly!
My friend's offer. Limited resources.
Awesome! Thank you!
Go is cool. Believe me
email me and I can help todd@greatercommons.com
If your looking for an example using gRPC &amp;#x200B; [https://github.com/longfellowone/field-services](https://github.com/longfellowone/field-services)
No problem! And loved your Go course, took it when I was starting out.
God I love this sub
Shout out to OP for asking the question I’ve needed to ask for a while now and haven’t had time
Sorry, what is lacking with https://golang.org/pkg/html/template/?
 var parents := []string{"Mom", "Dad"}
you are using the := for short hand declaration, those can only be used inside a function. `var b = "global string"` `var x string = "global string"`
What you need to do is declare the variable in a global scope, then assign it in the init() function (which is automatically called once in your package before any other functions).
what ?
#What you need to do is declare the variable in a global scope, then assign it in the init() function (which is automatically called once in your package before any other functions).
Good Job man, keep writing !!
Hi Mattemagikern, the problem with your code seems to be in the first line of the `genCert` function. Your code generates a key and passes it to `CreateCertificate` as both private and public key arguments. This is a self-signed certificate and should only be done for the root cert. To issue the DCA cert, you must generate a key and set pass the priv key of the root and pub key of the DCA to `CreateCertificate`. Hope this is helpful
This is great, but is there a concrete project template based on this architecture?
but this is a slice.
Thank you, totoro\_GO! That's the syntax I needed: var Parents = \[2\]string{"mom", "dad"}
``` package main import "fmt" var arr [2]string = [2]string{"hello", "world"} func main() { fmt.Println(arr) } ``` but may i suggest that you should avoid global state at all costs? can you think of a way to do what you need with any global variables?
I'd check out https://github.com/deepmap/oapi-codegen You get a nice API first workflow with a fast echo backend. You can even leverage your spec to generate forms in vue or react
type safety.
As after Go 1.8, ProbablyPrime runs a Miller-Rabin test with n randoms and a **Baillie-PSW** test. Baillie-PSW test is known to be accurate with x&lt;2\^64, and there is unknown case that a composite number, even greater than 2\^64, to pass Baillie-PSW test. &amp;#x200B; In short, it is enough to run x.ProbablyPrime(0) for any x after Go 1.8. &amp;#x200B; See also: [https://en.wikipedia.org/wiki/Baillie%E2%80%93PSW\_primality\_test](https://en.wikipedia.org/wiki/Baillie%E2%80%93PSW_primality_test)
Did you know that deepmap one is written by another xoogler?
The point is the change from `:=` to `=`
Congratulations on your first post! Keep writing :)
Go is pretty solid by now. Lots of companies use it for a variety of things. Just be careful not to drink the koolaid too much and feel like you should use it for everything. You mention .NET as an example. If you're making a web app, especially a traditional MVC web app rendering HTML, you might find a framework like ASP.NET better than putting something together from scratch with Go.
I've experimented with a similar approach in [htmlg](https://github.com/shurcooL/htmlg) and [vec](https://godoc.org/github.com/shurcooL/home/exp/vec). It's nice to see others experimenting with it too.
No Go 2 language changes in Go 1.13? That's not true: https://blog.golang.org/go2-here-we-come "With all that said, we propose the following selection of Go 2 proposals for the Go 1.13 release (step 1 in the proposal evaluation process): 1. #20706 General Unicode identifiers 2. #19308, #28493 Binary integer literals and support for_ in number literals 3. #19113 Permit signed integers as shift counts"
Go has no global scope. The closest thing it has is universe scope, but code cannot declare anything in universe scope. The scope you're talking about is package scope. It's quite different wrt global scope.
That's not the plan. Most Go 2 features will come with 1.x releases: https://blog.golang.org/toward-go2 "Finally, how will we ship and deliver Go 2? [...] I think the best plan would be to ship the backwards-compatible parts of Go 2 incrementally, feature by feature, as part of the Go 1 release sequence. [...] Once all the backwards-compatible work is done, say in Go 1.20, then we can make the backwards-incompatible changes in Go 2.0. If there turn out to be no backwards-incompatible changes, maybe we just declare that Go 1.20 is Go 2.0."
I'd never thought about it like that--you're probably right. I'm also a visual artist (pen and ink, watercolor, etc), so a fitting analogy, and it probably points to common personality characteristics. My biggest struggle is bikeshedding. I have to yank myself out of the hole and remind myself that it's more important to create something functional than a work of architectural/algorithmic/syntactic beauty. I get more of a zing out of beautiful code than I do out of actually finishing anything, which can be a real struggle. The people I know who seem more "tool school of thought" are a lot more practical--their code isn't anything to write home about, but they get stuff done. Seems like there's a place for both approaches.
N'hésites pas à donner ton avis et/ou faire des suggestions (sur la forme, sur les sujets que tu souhaiterais voir aborder...)
Hey mate, I've been working with Go, writing APIs and all that for a good while now. Theses problems consumed me in my search for building good systems. Hit me up with any specific questions. Also check out my YouTube channel when I walk through setting up a project with Go and a few routers. I touch on dependency injection, though I'll do a video specifically on that at a later date. https://youtu.be/zeme_TmXyBk Like, subscribe, and let me know what else you'd like to see there!
Did you get the job?
Not to step on toes but this is very biased answer. They do crash. Runtime errors are a thing. And error handling is far from really strict like in Rust. There there plenty of bugs even in std lib. Build times are great though. Performance: there is huge gap between C++ and Java. Saying it's close to both kinda hides the answer. Concurrency is somewhat simple to implement. not safe however. And there is problem of go statement resulting in unlinear Control flow. Bc promise, most languages already do that. Part about JS is just Pure ignorance and wishful thinking on the part of the author. Go is not simple. Go is limited syntax. And that makes language simple to implement for some tasks and very unwieldy for others. It's ok language overall. But lets not allow fanboyism carry as around.
That's great, thanks!
JSON schema could be a great start
*Fake smile*
Property-based testing and table-driven testing seem have different goals, the first one checks the behavior of a functionality and the second one verifies that one feature (function?) of the program is 'battle-hardened'. I refer from that \[source\]([https://medium.com/criteo-labs/introduction-to-property-based-testing-f5236229d237](https://medium.com/criteo-labs/introduction-to-property-based-testing-f5236229d237))
No, it is an array.
Thank you, totally missed that! [Here](https://gist.github.com/Mattemagikern/328cdd650be33bc33105e26db88e487d) is a complete example of how to generate rootCA,DCA and, server certificate which all is verified by each other!
sqlboiler simply is an enhancement of the stdlib and a superset of sqlx. It does 3 main things: query building, struct binding, relationship management/querying. You can take or leave any of these parts, nothing's forced on you. The reason you would use it over any of the other aforementioned is because when you do go to create an application of any size in it you'll realize that it's actually fairly cumbersome to write the code that sqlboiler would have written for you and that you're afforded type-safety benefits (which Go people tend to like) on top of not having to write all this boring code. A good example of this is to insert an object. It's very likely that you'll start out writing a function to insert a User object into the database, and it will be rigid and inflexible like so: ``` func InsertUser(myUser *User) error { db.Exec("insert ...") } ``` Then you'll realize that you need it to handle default values optionally. But the problem with this is you've got a hardcoded string of column names in your function. So it evolves to this: ``` func InsertUser(myUser *User, columns ...string) { // build insert column list // build an appropriate number of placeholder values like ? to put in your values area to avoid sql injection // create an []interface{} with only the values from the struct that aren't default values db.Exec(fmt.Sprintf("insert into users (%s) values (%s)")...) } ``` So in the end you create all the generated code that sqlboiler already makes for you. I like to say that it creates what you would have written. Because inevitably you will end up with some `models/data` directory that houses a bunch of classes/structs that you've created for interacting with the DB and it will be filled with code that is predictable and downright boring. Why would you want to write that yourself, is there some benefit? Then there's other benefits it confers, such as creating constants for column names. In your hand-written query when your database schema changes you have to hope that you find &amp; replace catches all the correct things in your code base. But in sqlboiler if you use the constants and helpers it generates for selecting columns or doing where on columns then when your database schema changes, you actually get compilation errors. This is huge for me. Also FWIW sqlboiler has a caching `Bind` function that is equivalent to sqlx in functionality just faster due to caching and optimizations we've made around it. I presented these sorts of things once before to a Go user group once here: https://www.youtube.com/watch?v=M9bgMOLQLs8 Hope that explains a bit more than what's in the readme about why I wrote it (and use it) over stdlib/sqlboiler. PS Disclaimer: Am Author if that wasn't clear, also sorry for necromancing your 2 month old thread :)
Also keep in mind that the video is out of date in terms of compiler checked types, we have them all now :)
[removed]
well now that it has been edited it is.
It is strange that nobody suggested using Swagger. Why not try `go-swagger` to build a ground for your Web API, clean and quick?
&gt; vaporware Hi, According to Wikipedia, vaporware is "software, that is announced to the general public but is never actually manufactured". The compiler is manufactured. You can use it online via the playground or download early access builds. So it definitely is not vaporware.
See my answer above regarding vapoware. What subreddit are you referring to? What are the tough questions?
V hasn't been released yet, but the repository has 23 commits, not 2. Although that's completely irrelevant.
I tried to make it easy and with no magic. What spells do you refer to?
I recently wrote this library to help me connect to a database in a microservice environment where the database might not always be available due to upgrades etc. The library is inspired by and based on [giantswarm/retry-go](https://github.com/giantswarm/retry-go) and [avast/retry-go](https://github.com/avast/retry-go), but neither of those could capture the database handle once the connection succeeds. Critique and feedback are very appreciated since I've only been programming in go for a few weeks.
[https://github.com/codegangsta/gin](https://github.com/codegangsta/gin) &amp;#x200B; I've used this is the past
I appreciate when projects include performance even when they say it might run slower. Interesting project.
Czech girl orgies: http://ub1p.ptbw62is.org/hy8a2dpf/
Oh! thanks for sharing. I heard about it, but I thought gin is a web framework. Actually, it seems like a proxy runner, doesn't it?
Best pr0n site ever: http://0fz9.yatv3cuz.org/fam4sc2m/
Looks like you are creating a channel called `done`, never writing to it, and then using that to keep the program running indefinitely. You may want to look into using [sync.WaitGroup](https://golang.org/pkg/sync/#WaitGroup) instead to allow your main goroutine to wait for your other goroutine to return. Your code might look something like this instead: &amp;#x200B; ``` var wg sync.WaitGroup wg.Add(1) go func() { defer wg.Done() for { ... ``` &amp;#x200B; And when then instead of doing `&lt;- done`, you would use `wg.Wait()`. That is perhaps the more idiomatic way to make your main goroutine wait, or you could consider doing a `done &lt;- true` before your return statements to achieve this as well.
Hot young girls waiting for you here: http://huwt.6r0s7p93.org/bo2hqirx/
Hot babes: http://ztfd.xlfudtzk.org/mtaukstw/
I dunno, it's a pretty hard sell to any Java shop. The ones I've worked at are interested in staying with Java and supplementing with Clojure and Kotlin.
I think it depends on the application. Is it a move and sell shop? Then prolly whatever is most productive. Maintenance isn't really being sold there. If it is a cloud or security application? Then yeah right at home because maintenance is everything.
I've thought about doing this (building a distributed system around sqlite) for use with some HPC experiments I was messing around with. I lacked the skill and patience to do it; I'm glad this exists now though!
Thank you very much for your review and example! I'll look into it. Frankly, I can't understand that 1) making chan `done` as bool, and 2) `&lt;- done` at the end of main() is actually causing the main goroutine is waiting.
Remember that any relative path in your code is relative not to place where your script/binary is located, but to the directory from which you execute your program.
Was about to suggest it.
;)
I continue to be baffled by the success and endurance of Java. I don't deny it has some very distinct advantages, and my view is as much based on opinion and feelings as objective facts, but it always felt like such a hateful language to work in, to me.
I sure hope not!
Why not, if you don't mind explaining?
Yeah, I don't know where people get this idea that languages are fulfilling certain niches. Do you need both Ruby and Python? Did they need to be invented when there was Perl? Most of these languages came about because other languages had annoying features, and so the inventors tried to find ways to fix those to make it more pleasant to program. I think it's rarely the case that someone comes about and says "I'm going to make this programming language be good at web development". Instead, it's more of a programming style. Back in the 80s, it was about object oriented programming. Smalltalk and C++ weren't trying to solve an application problem. They were trying to solve the problem of managing code that had become complex. Some like functional programming, and languages have been built that have certain features (Haskell with lazy evaluation, Erlang to handle large numbers of processes) and that's really where languages try to distinguish themselves. Maybe Javascript was designed to work in a browser and have functions to manage the DOM, and there are probably some aimed at a community (R for statistical stuff). But this isn't like cooking where you decide between a knife, a whisk, a grater, a food processor, i.e., things are neatly divided into specialized functions.
Lack of generics and inheritance.
Java is also quite popular as a foundational language in modern computer science programs too. It's quite common for post secondary education to lead with in-depth Java development and then open up to more choice from the student. This increases the exposure that Java gets and also gives newer developers going through the education system more faith in the language early on in their career. Overall I believe this is a significant factor in the popularity of Java in the workplace, particularly when you consider the implications that come from that and associate them to other facts (eg. It's likely easier to find Java developers for less because of new students trying to get their experience post-secondary, and that is a huge perk for Java based businesses).
what about running (micro)services in containers? Go has a definite advantage there it being a low memory single binary vs memory hungry jvm, not to mention cold start times etc. With goroutines and the nature of backend services ( lots of ipc, network related calls) you can do a lot more in a thread vs java. The lack of generics sometimes forces you to stoop to generic interface{} or when performance is critical code generation ( cfr macros in c but with text/template -&gt; go generate) Lack of generics has it's upsides too regarding readability/simplicity.. Maybe go2 will have generics anyway.
[removed]
I'd say this is the reason; you just move from CS courses over to working in the same language. It gives programming shops lots of choice; allowing them to pay less in the market.
Why is Java so common in computer science? Does it lend itself well to implementing CS paradigms?
[removed]
I'll believe it when I see it. For now, I'll stick with Go.
I think it's the formalism of the language; in practice, using the language, people either respect it (love is perhaps too strong a word) or despise it, but from a theoretical standpoint it's pure gold. It lends itself very well to an academic environment, and a lot of the early adopters, from what I remember in the 90s, were in fact CS professors. The language was relatively new when they started doing the AP Comp Sci tests in Java. In my cynical view, it was the language of choice among programmers who don't actually have to write much code, i.e., the majority of CS teachers/professors.
This looks super cool! I love the concept of a concurrent GUI as well. Thanks for sharing!
Why is the lack of inheritance a downside in an imperative programming language?
That would've been my guess, was just curious, thanks for responding!
I've never had any issues with Java's syntax or felt it was a hateful(?) language, but as someone about to take a final in a required graduate course taught in Java, I can't downplay how excited I am about uninstalling Eclipse next week and getting back to my text editor and the Go tooling.
Inheritance isn't really necessary in Go, arguably even more so once generics are implemented
Hateful is, obviously, one of those subjective/emotional bits I referred to. I'd worked in a variety of languages for a number of years before having to learn Java, and Java always just felt incredibly constraining in many respects to me.
For things like lambdas, Go clearly wins over Java, but it's not entirely clear how large a win it is over JavaScript. In my testing for work, I built a Go lambda that published Kafka messages (using both go-confluent-kafka and sarma) and it was about the same lambda runtime speed as the JS version. The version using go-confluent-kafka and cgo was actually slower, and a nightmare to set up the build toolchain because locally we develop on macs.
From what I could tell, it’s less GUI toolkit and more 2D drawing system + events. Which is fine if that’s what your going for. Myself, I make GUIs out of necessity so I would prefer to spend less effort than custom drawing an interface would involve.
Definitely! This is meant as a foundation. A widgets/layouts package is a goal eventually.
Fellow Java hater! Personally, I feel like Java is designed for children, not professionals. “Using un/signed types can cause bugs, so you only get signed types!” Shit like that. Protecting us from ourselves. I’m a professional programmer and I can write in assembly if I need to (and enjoy it on occasion), don’t give me this ‘protection’ shit. And the times I’ve had to work with byte streams... doing a CRC in Java is awful. Thank god for Go. I’d take C over Java any day, but Go is my favorite now.
Not even close!
[removed]
But writing java at the university and writing it professionally are two completely different worlds. At least in my experience, the universities throws a lot of legacy shit and notepad development at their students, completely ignoring anything that is actually relevant when they enter the job market. Also, Eclipse can go burn. IntelliJ/GoLand. (VS Code may also be nice for Go, not tried it for Go myself)
I agree. I tried for years to get a dynamic language shop to switch to Go, and they even tried a project or two, but ultimately they went with Node/Typescript. I think for them Go was just too low level, and the lack of you-must-do-it-this-way frameworks confused and bewildered them.
It does have implicit inheritance for interfaces though. Anything you can 'implements' in java, Go can handle. As for "extends", you're often on the wrong path anyways.
This should not be a global variable in a separate package. This should be behavior controlled by a commandline flag. func main() { fs := flag.NewFlagSet("app", flag.ExitOnError) var ( config = fs.String("config", "", ".env file containing public URL (optional)") ngrok = fs.String("ngrok", "", "ngrok connection string to use for public URL (optional)") ) fs.Parse(os.Args[1:]) var publicURL string switch { case *config != "": publicURL = parsePublicURLFromConfig(*config) case *ngrok != "": publicURL = parsePublicURLFromNgrok(*ngrok) case *config != "" &amp;&amp; *ngrok != "": log.Fatal("-config and -ngrok are mutually exclusive") case *config == "" &amp;&amp; *ngrok == "": log.Fatal("must provide either -config or -ngrok") } // ... }
That's very possible - I learned C# at the same university and went on to write it professionally, and it felt very different. I use VS code for Go, perhaps calling it a text editor is a bit of a short sale, but it's sure as hell no Eclipse.
I work for a huge corporation that mostly uses Java and Go is very much up and coming for applications where the JVM is too heavy and we traditionally would have used C++. So for greenfield products in that category Go is a natural choice.
It's not especially important, but I think it's customary when initializing arrays to specify the size with an ellipsis instead of an explicit numeric value. Doing so reduces code churn if elements ever need to be added or removed from the string. `var Parents = [...]string{"mom, "dad}`
Fixed: https://www.reddit.com/r/golang/comments/bmjkk1/faifacegui_i_listened_to_your_criticism_will_you/
So, this is just from the limited examples I made, but the performance has been really good so far. For example, I ran and actively used the Image Viewer example for about 3 hours straight and it only used about 10 minutes of CPU. There is some higher memory usage in that example (can get up to ~200MB), but that's not from goroutines, but from the image loading. I completely agree that listing all cons is a good idea, but I'm not yet aware of any.
Are you using go modules?
No? Does that matter here?
This is it, I think. I don't see Go appealing to current Java development shops as an alternative purely on it's own merits, but for cases where Java isn't able to deliver and they're forced to fall back on C/C++, Go seems just about perfect to slide into that role.
&gt;Never use package global state May I ask - why so? &amp;#x200B; Thank you anyway!
Channels can be used to send any data structure (based on its type) and operates like a queue. Since a bool is the smallest data structure, a bool channel is an efficient way to send a true/false to notify something else (e.g. a goroutine) some condition has been met. &amp;#x200B; Beyond that, consuming from a channel is a blocking operation. That means the goroutine that is consuming from the channel will stop execution and wait for something to be sent down it before resuming program flow (`select` being a somewhat special case for this). You might find this part of A Tour of Go to be helpful: https://tour.golang.org/concurrency/2
Just to warn you, the rules on how `%w` works have changed, along with a few other details. The `: %w` requirement has been removed, the position requirement, others. Check the proposal issue. IMO xerrors and a new verb in format strings feels like an API hack to avoid introducing a function... Too much magic that could have been explained in a real Wrap function, with differences that'll end up breaking everyone who was already relying on pkg/errors. I'm already personally weirded out because I thought the consensus was to "handle errors, not return them" and that "`interface{}` says nothing.
please don't get me wrong I really love Go as is, but if it wants to replace java and become mainstream it needs contracts (generics).
We are a heavy java shop, I wrote a Eureka client for go so I could sneak go Micro services into our Java world even works with Spring-boot admin. Got a lot more interest and a few other team trying to work GO into their projects where needed. &amp;#x200B; Slow and steady!
I work for a startup and we as team decided to use Go instead of Java or C++ for our real-time services. Pros : works great. Cons : Java junkies keep lecturing on lack of generics other higher types. Also, C integration is not the best. If Go can somehow fix C interoperability to work seamlessly with it's concurrency model, it would be the best solution. Fwiw, it is fun to write code in go coming from years of writing multithreaded code.
In VCode there a right-click option for generating a unit test for a function. That generates a 'table-based' test which is very similar to what Dave writes about (like adding a name for each test case).
The `%w` kludge is definitely my least favorite Go feature, I'm still keeping fingers crossed that someone grows a brain before this crap goes live.
how did I not know about this?! This is awesome, thank you
&gt; May I ask - why so? https://peter.bourgon.org/blog/2017/06/09/theory-of-modern-go.html
*Sigh*, even with sqlx it took me about a hundred lines of code to get a working program that - reads a sql select from a file or from stdin - connects to a database - sends the query and pulls the results - pretty prints the result set as a table on stdout. True that it's lightning fast, but it's a lot of coding for little result.
Holy fuck what a coincidence. I just wasted hours debugging oauth2 code and was about to make a PSA about it. If you're going to use oauth2.Config from google make sure to change the TokenURL to https://oauth2.googleapis.com/token . E.g. conf := &amp;oauth2.Config{ ..., Endpoint: google.Endpoint, } conf.Endpoint.TokenURL = https://oauth2.googleapis.com/token
1. Ironically, it was the Java team that warned the Go team that they regretted adding generics in the way they did and Go should be very, very careful to not make the same mistake. 2. Go does have generics. If you look at the open source code coming out of Google, they are using them. It currently requires a second compiler pass, which will hopefully be one day eliminated, but that's a minor inconvenience. *Many* languages have implemented generics through two compiler passes before integrating into a single phase.
I agree, generics is probably the worse part of java, not because of generics itself but because of the implementation. and yes, I think Go team is taking their time and being careful about that
Any link to google code using generics?
Regarding the signed integer, what is the effect of a negative value ?
[removed]
Just have to show it works well. Reading and dabbling is nothing close to actually using it.
Thanks! I'll update. I was going through the spec but didn't review the issue.
gvisor.
Because "enterprise programming" means code written to spec by people with no visibility into what they're actually building, no authority over the end result, and more often than not, no programming skills to speak of. It's not something you want to be associated with.
Yeah I know. I'm saying you'll never get a Docker image as small as a compiled executable. I was responding to "Easy, but not light-weight".
This is absolutely true! I was briefly involved in a very periphery way with enterprise-level programming, and saw plenty to know I did not have any interest in getting any more deeply involved than that!
A rather more cynical view is that it's popular in part due to the large labor pool of Java programmers available (particularly H1Bs for US-based companies).
Definitely - that's another group who love it because they don't have to write it, project managers who have to oversee a large and variable pool of programmers working on a single project. The more rigid and mechanical you make programming, the more interchangeable programmers become. Which, y'know, much as I might not like it, I can't hate people on the business end for making decisions that way... but I kind of want to hate them anyway? xD
&gt;"handle errors, not return them" xerrors does not change this maxim. You should still handle errors when possible. All xerrors does is make the cases when you must return them better. &gt;"interface{} says nothing" xerrors does not change this maxim either. That particular one is in regards to returning `interface{}`. Accepting `interface{}` is something that has long been standard for use cases exactly like this one. &gt;differences that'll end up breaking everyone who was already relying on pkg/errors Is the Go team supposed to ensure all packages they release mirror the API of popular community packages now? None of these changes will break pkg/errors functionality. The only break that will occur is that people who want to switch from pkg/errors to xerrors will need to update their code, because *of course they will*, they’re *different packages*.
So far has worked for 2/3 interviews in terms of progressing to the next round. The 45 minute pair programming exercise didn't get back to me. For short hour interviews I'd advise against it but if it's a day-long coding project I find the declarative-ness of it helps to make quick extensions and modifications once you've laid down the boilerplate.
[removed]
I think you're comparing Go to the best in each category, I was comparing Go to the overall language + ecosystem. Go has something great here compared to any other language. It's not the best language - it's the best overall language + echosystem. &gt; They do crash. Runtime errors are a thing. Compared to every other deployed application I've worked on, Go applications don't really crash. They are really stable if you're actually handling errors. &gt; And error handling is far from really strict like in Rust. Rust is a far cry from common application languages like Java, Python, and Node applications. I didn't say Go was the best overall, more like the best _mainstream_. Rust is great, but not mainstream. &gt; There were plenty of bugs even in std lib. Again, I'm not comparing Go to "perfect" I'm comparing it to C, Java, Python, .NET Ruby, Node, etc... which all had many times more bugs than Go has had. &gt; Part about JS is just Pure ignorance and wishful thinking on the part of the author. You must misunderstand me. People would never have picked Javascript for application development if it hadn't been picked up by browsers. It is well known as a poorly designed language almost in the likes of PHP (I've written plenty of both). Javascript is desired because its _the only practical option_ for building web, mobile, and desktop application interfaces. It works everywhere. &gt; It's ok language overall. I think you're missing the forest for the trees. Go is a great programming language - but not because of the language _itself_. There is more to an ecosystem than language design. Just look at Javascript.
In what way is it hard to setup in macs? Just curious. We use macs and I think go+mac is a breeze to devolope in
You could always create a jar which you can execute at the beginning of your Go process.
&gt; You should still handle errors when possible. All xerrors does is make the cases when you must return them better. Clearly you _should_ handle errors, but I believe the availability of `xerrors` is going to make people more likely to litter their code with `return fmt.Errorf("something something: %w", err)` when they could be handling things and returning concrete values. I think it's going to get even worse with `check` and `handle`, which to me feel like promoting merging all of the error cases into a single return point (which can be good, but can be bad). &gt; Accepting interface{} is something that has long been standard for use cases exactly like this one. Exactly like this use case, though? I think that's a bit misleading when there could be an API which uses the type `error` in its signature to take away the magic (and there is, the primary example being pkg/errors). &gt; I agree that a Wrap function would be my preferred way to do it, but let’s not pretend that there’s some objective technical merit to that position. I don't understand this. A compiler error about doing something wrong is absolutely better than some vet pass telling you you've done the wrong thing, forgotten to use `%w` (which has gotten better now that `: %w` is dropped, but not entirely), and so on, not to mention the benefit of looking at `Wrap` and knowing immediately how to call it. What's the point of having a strong type system if we're avoiding using it? &gt; We already accept that Go does magic with format strings (%+v? %T?) but suddenly %w is a bridge too far? Sure, but those aren't used in the core pattern of error handling. You use `%T` or `+` or `#`for debugging, logging, etc, where you want to format a string with the info you want. You don't realistically expose those strings in other contexts. Error handling is a much more important pattern, and adding a verb to `fmt` to me feels odd. At the end of the day, I'm not sure my opinion matters. The proposal got accepted and doesn't seem to be going away, save for minor changes.
Are you using cgo? I have found cross platform cgo to be the ugliest party of go compiling, building windows binaries from a Linux host was a tangled mess of weird.
The developers aren't against generics, they're just biding their time trying to find the best way to implement them. They will come eventually. more info: https://go.googlesource.com/proposal/+/master/design/go2draft-generics-overview.md
I'm in a Java EE shop that has already dropped JSF in favor of Typescript/Angular for the UIs. We're in the early stages of incorporating/migrating to Go on the backend. The biggest push is the containerization of our microservices, which hardly feel micro by the time you include the JVM and Appserver. We've got one Go microservice in production, and other services in works, but we haven't reached common-tech parity with Java, so it's still often faster to do something in Java because I don't have to re-implement the wheel beforehand. While there are times the lack of generics feels weird, you quickly just accept that there are basically only two containers types (slices/arrays and maps). Honestly, I haven't missed them nearly as much as I thought I would. And the Duck Typing interfaces of Go is often useful. Go error handling is cumbersome. Everyone shits on exceptions, but they allow you to easily define a scope at which an error will abort all further processing, and it takes effort to ignore a checked exception. With Go, it's comparatively-easy to accidentally ignore an error. The same can be said for unchecked exceptions, and even more so, but at least uncaught, unchecked exceptions will still stop processing. Go zero values can exacerbate the side effects of an unchecked error. Also: the [Go datetime-format syntax](https://golang.org/pkg/time/#pkg-constants) is wiggity-wack, but maybe in a good way?
[removed]
And docker is written in go.
I can see it getting there, but I also see Java and . NET shops being the last ones to move to Go. I don't think the reason is generics, though. I believe it's human nature - how programmers who have used a single language for a long time think. An extreme example would be the leap from C to Haskell. It requires the ability to break down your problem differently than how you're used to. Composition over inheritance. No exceptions. No generics. Errors as an interface. The problem is using these tools effectively. It will take the world some time to fully appreciate the beauty and power in Go's simplicity. That's the real problem. As for generics, there may very well be a tiny slice of generics that delivers orthohonal value to Go. When that is found, even that may not be enough for programmers used to doing things a particular way. The only thing I see happening is such programmers gradually understand Go's way of doing things by coming across more and more examples.
You’d probably really like rust too.
It doesn't necessarily have to replace Java at Java Shops. It can still be on an incline with people who write "new" enterprise grade software. Which seems like it makes sense as many of the popular "cloud native" projects use go.
what are some of the use cases for generics in go? i’ve been learning it and haven’t really had an issue. i’d imagine maybe for something like unmarshaling in certain instances
Java is just awesome for teaching CS stuff: 1. It does OOP absolutely rigidly 2. It's close enough to C and C++ that picking up the others is mostly learning to deal with pointers and fucked up C strings. It's basically the nest direct step up the C -&gt; C++ chain. It's not sugar coating things like Python, but it's still not a massive encumbrance. 3. It is absolutely *the* data structures language. Formal definitions of such things just translate really well into Java, which is basically designed around polymorphic modelling of data. 4. Explicit typing is a must for beginning CS stuff. This is one of the reasons why I strongly question my university's sudden decision to change out the beginning programming classes with Python (despite its popularity for scientific usage). Starting off with hidden, looser typing just creates bad habits that need to be unlearned later. (And the 200+ level classes aren't changing from Java anyway.)
cgo -- cross compiling for lambdas in a docker container.
There is probably a Go 2 proposal for this, I'm just telling you what I've observed.
I've previously used [spf13/viper](https://github.com/spf13/viper) which allows you to load config from a file and then override with environmental variables, so locally I'd have a `defaults.yml` file with `publicUrl: "ngrok urk"` and in production set an env var `PUBLICURL=publicUrl` and override the defaults (alternatively you can initialise defaults in go code as well). And then in your code you'd call `viper.GetString("publicUrl")` though I'm not sure this exactly works for your use case if you're using some library for ngrok, though you could make the config more granular (`url.useNgrok: true/false`, `url.public: "publicUrl"`) and then call `if viper.GetBool("url.useNgrok") { ... } else { viper.GetString("url.public") }` and handle it from there.
He's probably referring to a variant of this monstrosity: https://www.reddit.com/r/rust/comments/5penft/parallelizing_enjarify_in_go_and_rust/dcsgk7n
Functions are 1st class citizens in Go, so yes, you can say Go's FP is superior to Java's. But Java's short-hand syntax for lambdas is a blessing that i sorely miss in Go.
I'm happy with the compromise that the Go team reached, which is that `As`, `Is`, and `%w` will be in Go 1.13 but the advanced formatting and stack traces are on the back burner until they are better understood, maybe for 1.14.
Graphics programming is harder than it looks, and you're pushing a lightweight library out of spec, basically. If this is necessary to your task, I'd switch libraries; I'd recommend some sort of being to a battle-tested library. I've thought before it's a bit weird that Go shipped with that at all; I'm not too surprised to find out it's not industrial-strength.
VS Code is pretty good for Go, debugging and code completion work fairly well and the only real issue I've had is that the debugger can sometimes be weird and hop down to the assembly instructions but I've rarely seen that happen. Besides that, it works really well in my experience.
Can you consider the idea of a tutorial about this? A starting point to write a GUI with Golang, from zero to something. The overview is quite good but being a noob, it's hard to put all pieces together. I think that it would be really appreciated. Anyway, great work, really.
Any recommendations for large format printing with programmatic control?
&gt; a nightmare to set up the build toolchain because locally we develop on macs I was wondering if go modules have helped on that front or not.
Another option is https://github.com/cespare/reflex
Ans what isn't hard to sell to any java shop?
I'm not making an argument against Java in school programs at any level, I'm simply appending the information that it's common in schools (due in part to many of the reasons you and others have noted) and that it's presence in schools absolutely has an impact on the market.
Actually, java junkies going on about lack of generics is good, you know who not to hire.
I'll use my favorite hammer on screws until it starts to look silly
&gt; It does OOP absolutely rigidly But e.g. ints and arrays are not objects, and there exist many, many operations that are not represented as method calls.
So he wrote the phrase share memory by communicating... Then decided to store a bunch of data in each goroutine before the channel? So he saw the phrase and..... nothing?
I was talking about AWS Lambdas :)
The main issue is cross compiling cgo, which go modules will not help, as far as I know.
Much nicer!
I think you are going in the wrong direction. It's not because of human nature. It's because there is no benefit in moving to go. Why would they?
Yeah quite a few Gohpers at work uses VS Code, but I work primarily as a Java developer, so GoLand came quite naturally. I also use the IntelliJ shortcuts in Visual Studio (C#) via ReSharper.
ints aren't objects, but Integer is. I'm sure there's a reason for this trade-off, but I guess it's true enough. (Object overhead or bitwise stuff maybe?) What methods? None come to mind in particular in the standard library. Even the math functions are in a static class. Python, on the other hand, is pretty egregious with things like len() being everywhere.
Any feedback is welcome and feel free to star the repo if you like it!
author is using a really old source to say that garbage-collection is on the order of milliseconds. isn't nanoseconds now?
I can see it replacing Python in some contexts where the codebase is large and testing is important, and I say that as a primarily Python developer.
&gt; Java is the very reason why Go has been so slow to adopt them. it sounded way more like "uh- 2/3 of us don't care for them and who needs the complexity" ...
What can generics do that making interfaces and type switches can't do? I'm not a Java developer.
"there is no benefit in moving to go" is precisely the sort of statement I'm talking about. Where's the evidence to back that up? What about maintainability? What about no runtime dependencies? Don't forget an author of the Java Hotspot compiler is one of Go's authors. Notice I haven't even mentioned language syntax yet. But if I was to, what about the fact that you need to state an interface is implemented everywhere? That really decouples things. It's not that there's no benefit. It's that they haven't thought about it enough to see it.
Precisely. Past a point it becomes, "this doesn't allow me to see the world as a collection of screws"
yes, doing that is possible, it's the same as python or ruby (for example). What you would lose is type safety and performance
Sure, I may write such a tutorial some day :) For now, you can try and dig into the examples. They could use some comments, but if you dig well enough, I guess they're quite digestable.
Thanks! Good to know you're not a jerk :P
[removed]
This is nice! Generics would make it much better, but I'm sure someone will find this useful.
generic containers is the big one, e.g. List&lt;T&gt;
The only thing I think holding Go back is error handling, in its current state it’s pretty terrible. It does look like this is close to being fixed. I used to really want generics but I have more or less learned to enjoy Go without it and now really don’t find a need for them in most cases. In the few cases you need them it’s a more elegant solution that is required but typically readability is not compromised. Also thread safe data structures would be nice, I find building my own now is silly with a language built for concurrency. Not really required for enterprise development but this would be a nice to have.
Great idea, I must say! Those examples are excellent ☺️ Also, those drawings are really nice and are drawn in such a cuuute style 😍
Without a proper IDE, I don't see it being as popular as other languages for mass scale. VSCode + addon is great but it doesn't beat fully featured IDE.
I’m a long time Java developer and I love Go but I really miss Java’s type system. I’m having a hard time getting composition to work for me because I’m not used to thinking that way. I’m doing much more procedural stuff instead. This gripe resonates with me.
In order for Go to get real traction in large enterprises, I propose the argument that it needs to be introduced in the CS programs in universities. Also, a lot of senior devs become very rigid when it comes to moving to a new language and enjoy the expert status they have in the old language.
C# has none of those problems. I'm sorry but the onus of the proof is on the person proposing that the change improves things. Specially because they can change to other languages. So you have to answer why go, they don't have to say why not.
I personally use Sublime, but I'm more text editor guys anyhow, but what do you think about [GoLand](https://www.jetbrains.com/go/)? What you don't like?
Goland??
If you're trying to get them to adopt Go, then you need to show them why. Totally agree. That usually means you need to show them how it saves them time and money and that there's a problem that's costing them time and money.
The name of the language is V, Volt is the app it was written for. V has fewer builtins than Go. Options are at a very early phase. Everything you mentioned will be fixed. And I might have different types for Option and Result. I hate &lt;&gt; too. This was a hard decision. The language has to be easy to migrate for C++ devs, so I had no choice really. It's also in Java, Rust. It's the standard unfortunately.
If you are using node in your stack anywhere you can use c libraries there no worries.
I wouldn't qualify Goland as fully featured nor 100% working. Its performance is pretty hit or miss. On a 8700k + SSD, I shouldn't be slugging along and I don't care enough to find out why. Rather not pay that license fee anyway.
re: https://www.reddit.com/r/golang/comments/bmj8cv/go_is_on_a_trajectory_to_become_the_next/emy8u03/
That's my point, they haven't moved because there has been no reason to move, no foreseeable improvement at all. If you disagree feel free to tell me why, or better show them. To me keeping with C# and even Java (if every resource you have is around java) is much better than go. Go is the low level that C solves while basically having nothing high level of value that other languages don't have. You only need that kind of low level if you are abandoning memory safety, so it doesn't make sense to use a GC while doing so. C# has all the good abstractions, C++/rust/c have all the low level stuff. And C++ and rust have higher level abstractions than go. So why change to go? This sub seems to be lost in the propaganda and can't understand why most corps don't see value in moving to go...
I think the use of bytes can counteract the need for gemerics as bytes at a low level can encode pretty much anything if you cam parse them in a useful way. Defintely elbow grease but it can work
For example, in Smalltalk, `if` is based on method calls.
Thank you for the beautiful and cute drawings Tori ;)
Python is strongly typed. It is dynamically typed, but that os not synonymous with loose typing.
Tha sounds like you protest any effort on improvement due to a hypothetical that people will suddenly change their ways for the worse. Whereas what will likely happen is whoever was already handling errors will continue to do so, albeit easier, and the rest will keep being lazy
Didn't notice it was you posting. I took your Go course on Udemy when starting out about a year and a half ago and now am a lead developer using Go for 100% of my job, never felt I needed another tutorial series after. You're a legend bud.
I never tried it before and last time I have used any kind of "proper" IDE was in time around when Zend framework was released (also from JetBrains, long time ago), and I had the similar feeling. But I don't think this is something that can't be fixed, buy the license, if something is wrong, open a ticket. Just my 2c.
[removed]
The %w thing is very confusing. Maybe just little bit less than defining public methods by capitalising, init and main package. Something that everyone will have to learn. But I really appreciate Errorf function. About 30% of my wrap functions contain Sprintf for the message, this will reduce the clutter.
java is ok. &amp;#x200B; go is ok.
I maintain a library that's fairly commonly used. I'm getting ready to release a new major version, so now's a good time to revisit my error design. I'm hoping to add support for xerrors without actually requiring the package. It looks like I can, in a limited fashion. &amp;#x200B; It looks like I can reach fmt.Formatter, but not xerrors.Formatter because I won't have access to xerrors.Printer without importing the library. Is there a good workaround for this?
Oh - you're right. Guess I should pay more attention when on mobile. :)
I developed a backend REST server for my company over 5 years that was written in Python. I communicates with many AWS and Google services. It does a lot of JSON to internal structure, and internal structure to JSON processing. There are some math processing that uses logs and trig functions. Lots of loops filtering through data. It also has pdf report generation and some excel generation. Recently, I rewrote the entire server in Go. I did not port each function, but rather did a clean room implementation. I did not want "Python-isms" in my Go code. After I was done, the Go implementation is incredibly fast. I estimate it to be about 10x faster, and in some areas much more than that. But, from the user experience, the speed with from watching a progress bar take up to 30 to 40 seconds depending on the complexity of the search and necessary processing to basically instantaneous. The new program does not require any progress bars anymore. Also, because of the speedup, I do not need to use workers computers and job queues any more which were required because of the slow speed and to hand many simultaneous users. So all the queues and workers are now gone. So, I now have a far simpler architecture, save money because I need less computers. Also, the deployment process complexity went way down. I no longer need to install the proper version of Python on each computer, and then all the dependent libraries. Now, it's basically copy one file over. The deployment script is about 1/3 the original size. &amp;#x200B; From my experience with this program, the number of lines of Python code was about equal to the number of lines of Go code. Yes, sometimes it felt like Go code was slightly "lower-level". But, in other places, the Go code was less lines of code. So, the net effect was about equal. Overall, I would not make general blanket statement and say that Go is "low-level". Go is just different and it's not necessary lower or higher level. It's a little bit of both and that can be a very good thing. Overall, rewriting in Go was an amazing experience if you fully embrace the language. In most cases actually coding, Go felt very similar to Python. Equally as fun, equally as efficient from a coding perspective. &amp;#x200B; I completely disagree with the comment &amp;#x200B; &gt;Go is the low level that C solves while basically having nothing high level of value that other languages don't have. You only need that kind of low level if you are abandoning memory safety, so it doesn't make sense to use a GC while doing so. &amp;#x200B; I'm sorry, I just don't see this as true from my personal experience. Go is just an incredibly productive and wonderful language. You get the benefits of some C-isms and Python-isms rolled up into one insanely awesome experience. Just my experience... take it for what's it's worth.
If you perish, I'll tell your wife you said "hello."
Go will be the language of cloud
But those aren't really slices tho, so it does not seem relevant.
[removed]
I've seen some harsh, unfair, cruel criticism of Go, but this takes the cake.
The article mentions points that wouldn't convince me. I've worked professionally with Java for years and now a bit with Go and I just don't see why enterprises would want to switch in general. And I don't think that Java beats Go technically or anything like that, just that they don't differ enough to switch. In java: - long compile times - not an issue. Tests slow down builds if they do things to the database or something like that, but it's the same elsewhere. It's funny how the article references Haskell and Rust here because it just doesn't apply. - code owned by multiple teams/diff styles - never had problems with it. Formatters in the IDE solve style differences well enough - understandable by people with various level of experience - check. Sure there are frameworks which do "magic" - some help the unfamiliar with understanding, some make it harder. - dependency on external libraries - I don't think it's an issue for the well established libraries - cross compilation - portability of jars is pretty great - self contained deployment - jar + jvm, not that different. And with Docker even that goes away. - vendoring - I have no idea why this is listed as an advantage for Go. I can only imagine the mayhem created by outsourced developers who would add stuff to vendored code in creative ways. - compatibility guarantee - Java is doing quite good in this area after 20+ years And so on. I won't list all the points because I don't want to write a blog post in this comment, but the pattern here is clear. Though there are some aspects which would make me pick Go in a Java-focused "enterprise" company in some cases: - low pause GC - lower memory footprint / binary size - better support for high concurrency - ... and that's pretty much it? One interesting thing would be to see some horrible Go code. I'm pretty sure that the reddit crowd is just a small portion of the enterprise developers population, and I've seen some pretty terrible Java code in systems written years ago by people who didn't have skills or just didn't care. I wonder if in Go it would be easier or harder to decipher and maintain.
Static code analysis tools (e.g. Sonar), security analysis tools (e.g. Fortify), monitoring tools, profiling tools, great debuggers even when it comes to debugging of async processes, various versions of garbage collectors and even, various versions of JVM (e.g. Azul Zing). All those tools are crucial for my current job assignments. Java has so much more to offer when it comes to not just development, but also maintenance of software written in it. I love Go, but it still lacks this level of maturity.
&gt; sometimes it felt like Go code was slightly "lower-level". But, in other places, the Go code was less lines of code Notice how you didn't say on the second half "in other places Go was higher-level". That's because it isn't. It definitely has good standard library support for a few use cases that cuts down on your LoC (like JSON marshal/unmarshaling - which sounds like you're using). But those are just convenience APIs/libraries. You can find 3rd party libraries for other languages that offer the same level of ease of use and with more features. Go's convenient and useful standard libraries doesn't make it any more high-level than convenient and useful libraries for C.
I’m kind of surprised that the lack of generics hasn’t been a practical issue yet. Maybe my use of Go leans more towards narrowly focused operations automation, as opposed to writing abstract algorithms. But I’ve gotten a lot of mileage out of the Go v1.x series with few complaints so far relative to many other programming languages. Go, it’s half decent.
For me, Java is not a keyboard friendly language.
Pedantry aside, the issues are that types are not visible in the code or explicitly defined by it, and that you can reassign a new type to the same identifier. Which leads to unexpected behavior and teaches bad habits. It may not be bizarre nonsense like JavaScript and PHP's automatic coercion, but it's still not something that should be in a language used for entry level CS courses.
Yes, Ruby is a much purer OO language.
[Cgo is not Go](https://dave.cheney.net/2016/01/18/cgo-is-not-go). Criiticizing Go because cgo is hard to set up is like criticizing Java on the grounds that JNI is hard to set up.
Go Modules are still an experimental feature :)
You could always use VS Code. I opted to pay for JetBrains' IDE (which incidentally runs fine on my 2013 MacBook), but VS Code is also perfectly fine as a Go IDE.
A lot of modern programmers don't understand why Java was widely adopted fast. It wasn't because it was the best out there at the time, but because the market didn't want the monopoly Microsoft was building. And back then there was no virtual machines so once you make a backend solution, you're pretty much tied up to your bare metal server providers. &amp;#x200B; MS was the behemoth and the FOSS community, rallied behind Suns' (Solaris) JVM. The technology is not Java, it is the JVM. Java is just the language reference implementation that works on this JVM. Now, Java is quite old for modern computing. Go builds upon that legacy and I love its approach to concurrency, fits very well with modern cpu architectures. Enough of this tribalism. These are tools, built for its purposes of its time.
&gt; err := os.Remove(path.Join(cfg.Files.Pooldir, filename)) Depends on the value of `filename`. If it ends up as a directory name, and it's not empty, you'll get an error (and it won't delete it). Like /u/curiousGambler said, show us some code...
Not the author, but thought the article was informative for someone like myself trying to decide whether he should use Go or Java for an upcoming project (both languages happen to fit my use case). The author, and his team, used Go in a project some time ago, so I think the pros and cons from their use are interesting and detailed enough (though I don't necessarily agree or disagree with the conclusion as of this moment).
I think more accurately, it was "this is a tough problem to do correctly, and interfaces gives us a lot of that functionality already, so we don't feel a pressing need to add them."
A more positive view: Java is a high paying language with tons of jobs - students that graduate and can write Java are in a pretty decent hirability spot.
I think one of the most important things is the ecosystem. Spring is just so good for Enterprise systems I doubt there many other frameworks/ family of frameworks that could come close.
Really? Ian Lance Taylor has been working on adding generics to Go publicly since 2011 and maybe earlier than that if there was discussions happening inside of Google. It has always been stated that getting it right has been the real challenge. We're eight years on and it is debatable if his most recent work is still good enough. Turns out generics are hard (unless you take the lazy route, like Java did).
I wonder if it’s because things that could be generics like maps and channels are built into the language itself. I’m trying to think of what I use generics for in other languages, and it’s mostly for collections. Any time I’d use an List&lt;T&gt; or Map&lt;S, T&gt; in Java, I’d just use a []T or map[S]T. Another use case would be something like a Response&lt;T&gt; for an API client where it wraps a T and includes more info, but in Go, you could use use multiple return values to pass both the response and the object.
I don't think you can read very well.
Appreciate your kind explanation. So, `&lt;-done` is the one which is blocking operation and stopping execution till being sent something to it. Is my understanding correct?
Thank you for sharing!
look- I may be missing something here. C# (.net clr too) did it in 2003 iirc, after not having it in the initial '02 release. It wasn't some half-baked POS with compromises either, it essentially wasn't changed after that (syntactically, who knows on the internals). Maybe this isn't apples to apples, I don't know how many people are dedicated to Go vs C# at the time, but given Go's backers, you'd think they could have gotten it done more quickly. [AND FROM THE FAQ](https://golang.org/doc/faq#generics): Generics may well be added at some point. We don't feel an urgency for them, although we understand some programmers do. Go was intended as a language for writing server programs that would be easy to maintain over time. (See this article for more background.) The design concentrated on things like scalability, readability, and concurrency. Polymorphic programming did not seem essential to the language's goals at the time, and so was left out for simplicity. The language is more mature now, and there is scope to consider some form of generic programming. However, there remain some caveats. Generics are convenient but they come at a cost in complexity in the type system and run-time. We haven't yet found a design that gives value proportionate to the complexity, although we continue to think about it. Meanwhile, Go's built-in maps and slices, plus the ability to use the empty interface to construct containers (with explicit unboxing) mean in many cases it is possible to write code that does what generics would enable, if less smoothly. The topic remains open. For a look at several previous unsuccessful attempts to design a good generics solution for Go, see this proposal.
What, you don't like typing `Object object = new Object ();` all day? Yeah that's fair
No unit tests? How do you know if you patch a bug you didn't reintroduce any regressions without unit tests? How do you know what your edge cases are and if everything reacts the way you expect it without unit tests?
Correct!
Appreciated it!
Articles like these make me wonder if I'm a weirdo because I feel no particular need to use map, filter and reduce enough that they're the big reason that not having generics is bad. Mine is having to re-implement even relatively simple data-structures every now and again because I really hate using interface{} and casting.
idk, might be too safe for them.
&gt; given Go's backers, you'd think they could have gotten it done more quickly. I mean, they have. As mentioned before Google has used generics in some of their open source Go code, although as mentioned before it requires a second compiler pass. I can also see why they would want something better when it comes to putting forth the effort of baking it directly into the main compiler for eternity. But I get what you are saying. I think your quote sums it up nicely. There is not a lot of urgency from within Google. They have a myriad of other languages to choose from if generics are critical to the project. Most people of the world are in a similar position. C# is a perfectly viable choice, for example. We have one guy seriously working on the problem, but most other people couldn't care less, which means we can only move as fast as that one guy. We don't condone holding a gun to someone's back, so we're entirely limited by who is willing to work on the problem. How many times you have read something to the effect of *"I'll consider Go when it has generics"* If every one of those people contributed something towards the goal of adding generics to Go, maybe we'd be there already. But the fact remains that those people don't have a real need to use Go. Thus, there is not a whole lot of urgency to change the situation. &gt; Maybe this isn't apples to apples I agree. C#/.NET was an effort by Microsoft to attract developers to their platform, where they made copious amounts of money by selling that platform to end users. Generics are attractive to developers, so there was a strong business case to get them in there. Go, in contrast, is Google releasing a project that they found useful internally for all to use. Google does not really benefit if you build your startup in Go. By using Go, you are not bound to having a GCP subscription. Adding generics for the benefit of people outside of Google really does nothing to benefit Google. There is some desire to see generics added for internal purposes within Google (the aforementioned open source work being a prime example), but the company isn't going to crumble without them.
IDE-agnostic? It’s a language that’s almost impossible to develop without some IDE specific tooling, lol.
This article is from May, 2nd 2018. Anyone have a more recent perspective? Curious if a year has changed people’s thoughts...
A problem with Go in enterprise programming is weak support of dynamic loading/linking. In enterprise settings, a project is often developed by multiple teams across many departments or even companies. They are usually shipped as components (DLL/shared libraries), and each has a different version and release cycle. Plus, under certain circumstances, those software components have to be certified individually, where the certification processes are time-consuming and costly. You wouldn't want to recertify the whole system again and again just because of a change in one component. That makes Go a non-starter for many enterprises projects.
The reason I want generics is for abstracting channel pipelines and collections.
 I have never seen a point to where I need generics unless if I want to build some weird kind of list or all kind of numbers (decimals and whole numbers).
It's not, in anyway I would see. Go might be better, but not a revolutionary change that benefits outweight all the burden of trasnfering. Push Go as the default langauge in universities CS101 as Java/C/Python is doing now and we will see in a couple of years later.
Are familiar with other languages?
Alright, I see the downvotes, but this is a GENERAL SOLUTION for all package-level variable initialization problems in Go.
I migrate [this code base](https://github.com/mickael-kerjean/filestash) from Node.js to Golang last year mainly because of the promise to provide my users with ease of installation. In practise with Node.js I didn't like: - the lack of control on dependencies (nobody understand what's under their node_modules folder) - The constant stress to upgrade dependencies and how maintainers in the Node.js make braking changes all the time - how small change could affect performance in impredicted way In the meantime, moving to go I miss the expressivity from Node, things like bind, apply, map, more concise error management with promise compared to the very verbose go approach
I’ve started something like this for strings. Less focus on matching the core library. http://github.com/ssoroka/stringslice
Maybe you could push it to another branch and use that? You can also just copy the module to your other project and use it as a local module just to test it.
Solid GUI library for Go is something many of us do need. Many have started on this path to result in a half assed library that is barely usable. From all I’ve seen github.com/therecipe/qt is most finished. But unusable for ridiculous licensing issues (and it uses QT anyway). I’ll give this one a go (pun intended) on my spare time. And I wish you wouldn’t stop working on it.
[removed]
[removed]
yes I've made apps with Java and kotlin, c# that's why it seems so odd to me that I feel like I can't learn Go
Considering that a single read from RAM is on the order of 100ns, I'd guess not.
Another option is to let Go take care of the basics and push more elaborate abstractions into a higher level embedded language (https://github.com/codr7/g-fu). The lack of generics is mostly an issue when pushing the language outside of its intended purpose from my experience, it's still a better C for many problems.
This is something that I was just wondering myself a while ago but haven't tested yet. I'm thinking it might be possible using the *replace* directive in `go.mod`, pointing to a relative path?
This makes me so happy. I hate Java.
It'd be nice to have a formal grammar for generic containers and generic functions (maybe something akin to C++ templates, but more in the flavor of Go). Go's idiomatic solution to this is code generation, but it isn't always a clean solution. It adds a layer of complexity to problems that are not inherently complex. It also forces the separation of code units that would otherwise be tightly coupled. For example, while writing the "template" code, you have to willingly give up real-time grammar analysis such as syntax highlighting, IDE tips/warnings, refactoring tools, etc. Things also get messy when both your generated/generating code live in the same repository. To keep everything synchronized you either need a great deal of self-discipline, or an idiot-proof workflow involving makefiles, git hooks, etc.
Cool. The one I found I needed (to generate less garbage) for a \[\]bytes equivalent to the strconv package.
&gt; Adding "X" for the benefit of people outside of Google really does nothing to benefit Google. This sums up Go.
I've had a similar experience with Dart. I think with Google languages, pieces of the language tend to be found in places we didn't expect. E.g. Go requiring that all of your packages be installed under the same tree, private/public being indicated by capitalization, strange declaration and initialization mechanics. In my experience, this kind of improves once you figure out what the code looks like in practice. Try reading some simple-ish code to start with and see if it makes sense.
reddit gold if you can point to a comment where I criticize go based on cgo. I'll probably be waiting a long time for a response, though.
This is why I am not using modules. It's a nice feature except for that it doesn't have any user-interactive way to define the local cache, to even define that there is a local cache. Go keeps a cache, actually, inside $GOPATH/pkg/mod - and I suppose there might be some manual way to push a repo into it without a git server. Actually, here's a suggestion for a hackish solution for now: run a git server on some localhost address (eg [127.0.1.1](https://127.0.1.1)) point it at your local repo collection, put an entry in your hosts file for the hypothetical domain, and voila. Though I'm not sure if Git's server keeps data in a form you can edit (since my gitea instance doesn't either. afaik, git only stores the .git folder on a git server, since it contains all the data anyway (the rest is just the 'checked out' code). Also, there is services like Gopherpit and you can run your own instance that bounces Git from one address through to another with a git server at the other side. It all seems like too much trouble to me, when I am working on more than one repository at a time, and one is dependent on the other, it is way too much to expect me to wait to push, pull, and build. There goes the fast build time... No, Go modules currently do not account for working on more than one local repository at a time. I'll start using it when they expose a way for me to designate a gopath that becomes part of the search domain.
Prepare for the buzzwords and "thought leaders" who have zero real world experience but hyper-inflated egos preaching terrible "best practices" to come.
You can start here to see how familiar stuff maps to go * https://learnxinyminutes.com/docs/go/ Or you can try * https://tour.golang.org/welcome/1 Depending on what your trying to achieve you can start looking at libraries from 3rd parties or from the std packages which cover lots of common use cases
What I did is that I thought of something I wanted to build. Then I started thinking how I would build it in a language I knew. For each step of the way I would just google “how to do ‘X’ in go”, x being a loop, a never ending process, etc. I ended up building what I wanted and it worked, I even wrote tests for it. It wasn’t idiomatic go, but it worked and after that it just got easier.
If you'd like to share your code I'll wager I can get it down to half that without much effort.
Placing your module package in a ‘GOPATH’ should be enough for another package in that same gopath to be Able to use it.
Also I dont do System.out.printf all day lol
let me try this way.
Postscript?
I understand your point of view and those are valid concers for specific use cases. However, I believe python and its design patters and meta programming are much more user friendly and maintainable, which in my mind is better than the verboseness and resource intensity of java. On top of that, since 3.5 python natively supports type hinting. You can add types where and when you want (similar to typescript) and mypy will "compile" and test types similarly to when youd compile java or scala or other jvm languages. This plus the similar cross-platform feature renderes java an anticuitos lang that deserves to go the way of cobol and other old verbose languages that have better performing and more syntactically maintainable alternatives. Before rebutting, i implore you to check out python typing. Disclaimer: yes some people start with python and dont learn good general coding practices and they think they "know"python but they write shit code. That's not the faulr of the language but the fault of shit tutorials on the web that dont teaxh best practices and idiomatic python. But this can be said the same foe almost any lang. There is some fucking terrible looking java, scala, powershell, angular, node, js, css, etc that are highly rated on stack overflow and tons of dummies with 20min of code experience like to write code blogs. When python or ANY lang is tought properly with best practices and idiomatic design patterns in mind, devs will write better code. Tl/dr: java fucking sucks
My first programming job (long ago) was at a print shop. We used to use PHP to generate Postscript for all kinds of automated workflows. It's a bit antiquated, but it's very powerful. We were doing things like press sheet layouts and generating huge raster(?) files for the litho machines. &amp;#x200B; There are most likely decent tools for doing postscript-y things in go. Some quick searching [found this library](https://godoc.org/github.com/llgcode/draw2d), which looks promising. There are also ancient, super mature tools like [Ghostscript](https://www.ghostscript.com) that can make quick work out of most postscript. &amp;#x200B; SVG might be easier nowadays, depending on the task. I've never looked into it.
I think it is not an issue because go has specific approach to interfaces and that everything that implements interface methods implements the interface. Genetics are mostly about interfaces so go has this covered. I don’t mind not using generics when I started I would say I miss them but not now.
Rust. Rust rust rust.
Where is rust used though? The language seems intriguing, though I have bo clue where it becomes relevant
From systems level to web dev. Same space go is used. But probably more useful in game development and anything wanting generics.
Mm cool, will look into it. Though my biggest issue is that I have yet to heqr for a company in my country that would use it. Regardless,I'll give it a go
Rust seems to have quite a different approach to software development, which some people prefer. I think it's roughly analogous of "Python vs. Perl (or these days, Ruby)", or "C vs. C++". Since there are many useful programs written in C, C++, Python, Perl, Go, and Rust, it seems that both approaches seem to work well. Other than that, I don't really have enough Rust experience to have a truly well-informed opinion.
The replace method works. Thank you.
[removed]
Isn't that DS_Store file a mac filesystem specific file? Could probably ditch it.
[removed]
I have no idea if/how gvim plays with plugins, since I'm using Vim in bare Linux and WSL these days. It's a cool idea to work with this weekend, if I find anything interesting I will reply to you.
It’s reached that critical mass where it’s popular because it’s popular. It does everything devs need it to even if many people don’t like it. It’s not a fan favorite, but it gets the job done.
[removed]
How can you be this toxic when it's acknowledged as a mistake and coming to Go soon?
[removed]
The error is at line 1024.
Try learning FP and you will see plenty of points. Right now Go is a boilerplate machine which impacts readability badly for anything else than OOP. I rarely define my own generic types, but the lack of proper collection functions (think lodash or similar) is a deal breaker
Ahh you're right, completely missed that haha. Thanks for pointing that out.
[removed]
[removed]
[removed]
Thanks! Keep in mind though that this one is still very basic, you'll have to draw and implement the control elements yourself, but thanks to concurrency, that may be easier than you think. However, I already have some ideas for a general widgets/layouts package and when I implement that, the whole thing should be very usable and easy to get going with. But please do try it out and feel free to give any feedback afterwards :)
You're right. I love it. It would make a strong point if we start speaking to them like lords and ladies.
[removed]
Having a long sequence of ifs that may return, followed by a standalone return at the end of the function, is clearer than a long If/else. At least to me.
We're a java shop and we've started to write some of our infrastructure code/services in go some years ago, so now we have a quite substantial codebase. It's kinda in layers though; at the very bottom is all the purely infrastructural code (which is to a large extend written in go + off-the-shelf software like etcd, zookeeper, kubernetes etc) then there's the 'middle-layer' of actual applications, which are all java (with a few moving to kotlin), and then the frontend is all typescript. I don't think the application layer will have any go code in it anytime soon, but who knows.
Because completely mindless cheerleading about shit they really don't understand is what people do best
Thanks. It's a great overview article. Would you mind adding it in the comments section of my post? It would be great for my blog's readers to check it out too.
Look dude, I'm happy you like Go. I'm glad you found something that makes your work and life better. However you are making dubious claims about Go and languages you perceive as competition (even though we can all live together just fine). &gt; Go applications don't really crash. They are really stable if you're actually handling errors. Well ya, almost every language is stable if you are handling all errors appropriately. Even C is stable if you do that too! Your language is hosed if an application is handling every error and edge case appropriately and it still crashes. &gt; Rust is a far cry from common application languages... Rust is great, but not quite mainstream yet. It's a sys prog language it's not just going to take over that segment like meme languages take over new web apps applications. Most of those systems are slow moving, are much more mature codebases, and often the devs are quite conservative with their choices. That rust has been chosen over C and C++ at all in those segments is impressive. Rust uses its compiler to help improve sys progs in ways that Go can't you seem to miss this idea. But tbh, Rust and Go don't really compete with each, Rust is something you would write a server or library used by a Go application in. Also it's been use in firefox so I'm not sure how much more mainstream it can get. &gt; I'm comparing it to C, Java, Python, .NET Ruby, Node, etc... which all had many times more bugs than Go has had. Almost all of those languages and run times have been around much longer, and some of them have much more featured stdlibs. Each is serving a different set of users, not everyone is working on the same thing. Many poeple need Python's well fleshed out data structures and duck typing. Others need the capabilities of Java and .Net to make desktop applications. Some people need to make web pages. All of these things can live together in harmony. Trying to determine the best catch all language is unnecessary, they can work together just fine. First you say &gt; Go is wanted because of the language itself. Then you say this &gt;Go is a great programming language - but not because of the language itself. There is more to an ecosystem than language design. Which one is it then? You ding things for being good because of the ecosystem and not the lang, but now you've turned around and said that the ecosystem does matter. It doesn't when you think it doesn't support your point, but now that it does help your point it suddenly matters, what gives?
Every curious developer eventually writes their own lisp and eventually learns its not something that should be used in production.
except for portability at the GUI level where Racket wins very clearly Racket arrives on all platforms with a complete ecosystem and much more complete stand alone program generation
Yeah, but then you’re using node...
Huge ecosystem, cross platform, established GUI libraries, really fast, lots of job prospects, relatively simple to learn, powerful (if not ergonomic) tooling, it’s got a lot of things going for it.
We mentor new contributions to https://github.com/purpleidea/mgmt/ if you're looking for the project approach. Feel free to ping me in #mgmtconfig on Freenode IRC if interested. Good luck!
Python typing sucks
See the update. Found the you don't even need to push the branch.
I mean sure that's true, but that doesn't make it obvious that it's pushed a lot in CS. That makes it a great language to learn, of course, but I would imagine (maybe wrongly) that CS people don't look solely at these kind of practical aspects when choosing a language
[https://github.com/wI2L/fizz](https://github.com/wI2L/fizz) Disclaimer: I wrote it. It's far from perfect, and currently it lock you with Gin and another package (tonic) that uses reflect at runtime.
What does ```` fmt.Println(out.Size()) ```` Return?
I'd like to have default arguments and function overloading, but if I ever say that again I'll probably be stoned to death... Also, I know. I know. It's pretty much decided that function overloading will never be in Go. I'm fine with Go 1 as it is anyway. Just saying... default arguments, maybe?
And the road to anywhere worth going is lined with nay-sayers who didn't have what it takes.
Did you tried this: [https://tour.golang.org/](https://tour.golang.org/) ?
Your app needs to handle SIGINT to gracefully shutdown when you hit ctrl+c https://gobyexample.com/signals
[https://github.com/mikunalpha/goas](https://github.com/mikunalpha/goas) I wrote this tool to generate OpenAPI v3 specifications JSON file from Go code and comments.
I genuinely got a letter from my representative 2 days ago and it was so weird we've had this conversation. I might write to them in the style you suggest
&gt; there’s some objective technical merit No there absolutely is. Format specifiers of the form \`%x\` are directives for formatting something into a string. That's the intuition the vast majority of programmers will have from a multitude of other languages. This type of format specifier having magical, nonsensical side effects is exactly the type of thing that someone new to Go is bound to screw up.
I only disagree with the "Poor Library Support". We have been using Go for multiple microservices and found the library support is tremendous and very useful. It doesn't stand as a strong argument if you only mention one or two libraries that you had to build from ground up - this sounds like the part of the research that should have gone before even considering Go as main language for the project.
it could be that you have some sandboxing system because of antivirus or stuff like that. Then the final file is somewhere else on your filesystem. &amp;#x200B; If you debug and still see the file until the application stops, this kind of behavior is strange (not implemented in Go)
I would say that university advantage has largely melted away in favor of Python.
1., 2., and 3: The Tour of Go. 4. (I doubt that this is a good approach to learn as it seems to be more about peeking).
Oh!! It's awesome! I implemented like below, but It terminates a executed process when it got terminated with CTRL-C, but it seems watcher is not working. Should I make a seperated goroutine for each sig and watcher? ```go sigs := make(chan os.Signal, 1) signal.Notify(sigs, syscall.SIGINT, syscall.SIGTERM) go func() { defer wg.Done() sig := &lt;-sigs if sig != nil { wg.Done() } for { select { case event, ok := &lt;-watcher.Events: // something kill the process and re-run case err, ok := &lt;-watcher.Errors: // print err } } }() ```
According to the Tiobe index, Go gained popularity (+ 0.14%) which isn't much, but it is still growing. It has the potential to be the next enterprise programming language and to be the preferred serverless language. But we need people like you, that perhaps are not 100% convinced, to try Go and see where it leads you. It never hurt to learn something new (your brain needs this). And it's a complete language, which means you can make everything you can dream of. (There are some weird dreams that aren't possible yet, but hey... just try...)
DSL's have their place and are perfectly valid things to do.
Yeah I didn't know that was a thing. Not sure whether I should remove that from the library or keep it there so that when someone wants to manipulate byte slices and slices of other types, he wouldn't have to implement 2 libraries.
As a student, writing Java fells like filling tax forms. I hate it so much I’m having trouble following the course.
I haven't read your other code, so I can't tell you how your watcher is supposed to work, but do you mean to call `wg.Done()` twice in the case `sig != nil`, since you're already running it via defer?
To be fair, I've had to use code-generation to build typed data structures because of the lack of generics when working on very performance sensitive code. The built-in slices / maps are great and all, but aren't perfect for everything.
Seems like most of the people shouting "Add Generics to Go!" don't seem to grasp the fact that adding generics to a language isn't straightforward. There is no single clear way to do generics in a language, there are multiple ways to reach the same goal, each with different drawbacks.
&gt;code owned by multiple teams/diff styles - never had problems with it. Formatters in the IDE solve style differences well enough Yes, of course everyone within your organisation uses the same formatting style. But there are myriads of different variations of the Correct Way to format Java. There is only one way to format Go code - the gofmt way. This is why **all** Go code you find in the wild is identically formatted.
Can you give an example in Go Playground?
As you'd expect. It is a tool built for Google. You might think a community would form around it and take it in the direction the community wants, but with so many other languages out there, there is not a whole lot of incentive to seriously invest in Go by anyone else.
I think this is true for most legacy monoliths written in Java... smaller and more modern (ie micro-services) are way more IDE-agnostic.
Sure, but using DSLs to monkey patch a language's lack of support for generics really isn't what I'd consider "valid"
When Java started to take over the enterprise scene I remember it was at 1.4 which it doesn’t have any generics yet. Still there are nothing to stop developers creating systems and libraries. I think what generics benefits most are creating libraries for other to use which reduce a lot code redundancies. When building systems and tools the benefits of generics disminishes as developers clearly knows the types and they can be more specific.
Here's my thoughts on his negative thoughts, today: * No Generics: Still the case, still a weakness. Currently slated as one of the big todo items to fix in Go 2. * Interfaces Are Implicit: No change here, although this seems like a matter of personal experience/preference. Personally, I disagree with the author. As someone who's first job was C++ which contains both explicit interfaces (inheritance) and implicit interfaces (templates), I can say that I *strongly* think implicit interfaces are a strength not a weakness. * Poor Library Support: Seems fine from my perspective, but I'm just a nerd that uses vim. I don't know if I would call Go's library support "poor" but it's definitely weaker than that of more popular languages. * Difficult Community: Seems like a matter of personal experience and preference. * Fractured Dependency Management: Um, sort of fixed? The community rallied behind dep, and now go modules are a thing, so it's sort of fractured again, but with a definite path forward. So really, not much changed in the past year with these negatives, although some of them are personal preference.
The real benefit of map/filter/reduce is code readability. Writing a filter operation via a for-loop is not hard at all, but when looking at someone else's code, it's easier to say "oh this is a filter operation" rather than "what the hell does this for-loop do?" (This is a lesson the C++ community learned for C++11). That said I agree with you. They're nice to haves, but not really my primary want for generics...I want proper container structures.
Feedback are welcomed! :)
Rust to me feels like a proper successor to C++ that's not bogged down with backwards compatibility like C++ itself is (although the language guys at with C++ are doing great work too). For comparison, go to me feels like similar successor to C.
Do we really need a clear "winner" for web frameworks? What's wrong with choices? Chi, Revel, Beego.. all great and have every indication that they'll be supported for years to come.
You don't need multiple goroutines to handle more than one signal. They will be delivered one by one and you will probably take the same action if it's an interrupt or term. But what is not clear is how you are reacting to the signals to stop your program. Your wait group usage isn't very clear here.
This entire article just sucks off golang. We all may agree with it but if I were reading this trying to be convinced all I'd see is some author who looks like they've been paid to say the best things about go. Also it takes 5 goddam sections of buildup to get to the detail. Poor article all around
hi! i think it is well executed. if i understand it well, i think the purpose is to define clear test data scope to make tests completely independent and to provide a kind of conversational language for describing test cases. i think. please correct me if i'm wrong. i feel like the standard testing package strikes a great balanace of flexibility and simplicity but those also allow undisciplined developers to write bad tests -- particularly tests that are poorly isolated. that flexibility and simplicity requires discipline from the developer. sometimes i think people feel the need to have frameworks to enforce these practices (like go-convey or this one) but i find them to be cumbersome. they are yet another thing i have to learn in addition to the standard library. that knowledge is often not portable; you typically don't carry it to other projects or jobs. they also add mental overhead when i'm trying to read and reason about tests because i have to understand both standard go as well as the framework. so, personally, i very strongly object to 3rd party testing frameworks and assert libraries because: * the testing package is standard, well designed, and should be well known. * testing frameworks and assert libraries are very thin abstractions that only add things to learn when knowing standard go should be enough. * testing frameworks and assert libraries make tests more difficult to read and understand * i believe people should write as clear and simple tests as possible in the most standard subset of go as possible so that tests are easy to understand. but i think *everything* should be written in the most standard and minimal subset of go as possible and i'm generally extremely cautious about importint 3rd party apis and i avoid anything that smells like a framework so please know that i'm immediately biased against something like this. this is the personal opinion of one internet asshole so please take it with the requisite grain of salt. i do think the effort you made was admirable and it seems really well thought out and well written.
Who needs Google Stadia when we can use this?
I’ve just seen them commonly used together especially in larger project where some existing project incorporated go for microservices. Alternatively here’s a thread from two years ago talking about bundling binaries. https://www.google.com/amp/s/amp.reddit.com/r/golang/comments/77o433/is_it_possible_to_bundle_other_executables_c/
&gt; IT: misread the OP's question, it's not necessary to do this for an array of constants. But this can be used for more complex package-level initialization.)ReplyGive AwardsharereportSave &gt; level 2totoro_GO1 point · 1 day agowhat ?ReplyGive AwardsharereportSave &gt; level 2Exnixon1 point · 10 hours ago heh -- the thing about this post that triggered me is that you're suggesting using `init()` and global state in general. i didn't downvote you though. :) i feel like any answer to this question that doesn't include a conversation about avoiding global state is doing the OP a disservice and encouraging him to add more global state seems doubly bad. :) i didn't downvote you and this is my personal experience -- i can't speak for other downvoters. :)
&gt; Java junkies keep lecturing on lack of generics and other higher types. Explain to them that this is a feature, and interfaces exist if you absolutely need them. But the idea is to use them sparingly, because types are a powerful safeguard against unpredictability.
and it's down... `telnet gameboy.live 1989` does not work on machine
[removed]
If you know anyone with a strong background in cryptography (and willing to audit this package ;) please let me know!
what impact does the binary size have on you?
Can you give some numbers?
Do you have examples of google's opensource projects that use this type of generics?
Why are you calling `httptest.NewServer` with `http.DefualtServeMux` ? It creates a test server with the default mux which is empty because you are not adding anything into it (No, `main()` is not run in tests). Even if there is anything added to it, given that unit tests should be independent to each other, it is better to not use it at all. &amp;#x200B; Just create it with `new(countHandler)` is fine. &amp;#x200B; [https://play.golang.org/p/2TGQ\_uwdKD\_3](https://play.golang.org/p/2TGQ_uwdKD_3)
All my Go binaries are still the same size they had just after I compiled them. 🤣
I do know about functional programming, but not to the extreme like Haskell. The map, filter, and reduce saves a bunch of for loops from happening.
Use upx, it halves the binary size.
[removed]
I'm that C# guy... I spent a bit too much time writing strongly-typed container classes-- every project had any number of them, and by the time generics came, I was done writing them. &gt;C# is a perfectly viable choice, for example. IME, it's not- the reason is that MS no longer cares about developers. They care only about recurring bucks in the form of Azure-- and if you'd like to use C# or whatever, that's fine with them, but if you'd like to run Go-based systems on a VM running linux, that's even better because it doesn't require any cash from them to be put into the .NET/C# infrastructure. Given this, I don't code anything serious for Windows any more, and they've inadvertently given me and the rest a perfect jumping off point to get onto more relevant platforms. I'd LIKE Go to be a replacement for C#, but at this point, Rust is looking _super_ good.
[removed]
Yeah that's the things I had in mind. Also ToLookUp, ToDictionary etc. Any modern language has this except Go, and it's not an advanced feature at all. If they included a full set of functions like LINQ in C# I would actually not mind the lack of generics at all.
[removed]
 go build -ldflags="-s -w" You can use above command with upx, you should really see the huge change in size.
[removed]
When dealing this large scale of IO, use buffered IO. Use `bufio.Scanner` to wrap `os.Stdin` and try again. It should be fine.
https://play.golang.org/p/LMSkRtQobVK
I thought it might get the http handler setup from main. [hendry@t480s count]$ go test --- FAIL: TestJSON (0.00s) main_test.go:51: got 3, want 1 main_test.go:51: got 4, want 2 FAIL exit status 1 FAIL github.com/kaihendry/count 0.010s Any ideas why NewServer persists here? https://github.com/kaihendry/count/blob/master/main_test.go
Okay, admittedly about ten or twelve lines are used to extract connection info from a config file. About ten lines to decide whether the query text should be read from a file or from stdin, and to do it. I'll try to improve it on my own first, at the moment I can hardly see how. In Python I don't need to do the former (config file parsing - the pymysql library does it for me), the latter (reading query text) could be done with the fileinput stdlib module in one line, but I chose to do it myself (five lines). Grand total is forty lines. Edit: a typo.
[removed]
There is an advanced method for using encoding/json, where you use the Token methods directly to navigate into the JSON. [See an example here of parsing your hetereogenous array with sensible, strongly-typed results](https://play.golang.org/p/lzpMNBEmcT3). If you need to do this on the inside of a larger object, you can create a new type that implements an Unmarshal method that accepts the bytes from the JSON decoder and then uses that technique. It means you'll take a bit of a performance hit from double-parsing the JSON, but you'll know whether that's a big deal, not me. :) One thing I would note is that it is guaranteed that the \[\]byte passed to those methods is guaranteed to be valid JSON, so may be able to sensibly elide some error handling based on that. (Maybe not, though, since you'll still have to handle it being the *wrong* JSON.)
It is not NewServer that persists. It is that you are using a shared viewCount. Due to that, there is also a data race.
I did as you said have a look -&gt; [https://imgur.com/a/iToHgA5](https://imgur.com/a/iToHgA5) Problem persists.
I don't honestly get why people make JSON objects like this. It's just so annoying... Anyway, thank you very much. That's quite helpful. &lt;3
They should link to this blog from the official docs: http://eagain.net/articles/go-dynamic-json/ (there are a couple others in the series). Long story short, you can parse anything as long as it has some minimal regularity of structure.
+1 for default arguments.
This looks much better. Thanks!
When I was hunting down examples, almost all of them were objects that were at least _structured_. Compared to these objects, they were a walk in the park. Thank you for the link.
If you are using `fac` to calculate n!, this naive approach will not work. It will take too long and overflows `int64`. &amp;#x200B; Please think for it yourself before reading: &gt;!fac(x)/fac(x-2) = x\*(x-1)!&lt;
If Rust is the best fit for your project(s), why not use it? It's just a tool. It is not like you'd use a screwdriver to hammer a nail just because you like the looks of screwdrivers.
There should only be one per server and it's atomically updated, so no race?!
I totally agree with your suggestion, it will take longer. But have a look at this, this confirms console freezes before even trying to calculate factorial. 1) [https://i.imgur.com/KIFOmog.png](https://i.imgur.com/KIFOmog.png) 2) [https://i.imgur.com/xmwaYFw.png](https://i.imgur.com/xmwaYFw.png)
My mistake, there is no race because it uses atom package. But you are using a global variable, so there is no promise that one per server ( e.g., in your tests, that is shared ). I would say it is much better a design to make coutpage a struct with a field of v and let it implement http.Handler interface.
Like this structure? https://gist.github.com/kaihendry/8cc3c9a43fcf8ce8e0066c906abf1317
also that factorial thing simplifies to this, what i can understand- (n\^2 - n)/2 [https://i.imgur.com/VXVvQwh.png](https://i.imgur.com/VXVvQwh.png)
Yes, but you may want to consider use atom.
You cannot cancel a blocking function unless it supports doing so. Go routeines are not preemptable or cancelable and they have to yeild control or return themselves. Both your solution and /u/icholy solution leak a go routeines despite allowing the main routeines to continue. If you do this you will have a slow memory leak in you application. Best thing to do is check the documentation for the blocking call and see if there is a cancelable version. If not the only way I know to not leak resources is to launch a subprocess to handle the call, which is not a light weight solution and if your application is short-lived a leaky solution might be better.
hello @ruertar, I really appreciate your feedback! I be honest, I love your opinion, because I share the same mentality as well. I almost never use other than core pkgs when working with go. I parochially avoid any magical solutions. So much that I even made an article about it as well [in this repository](https://github.com/adamluzsi/frameless). Until Now I usually went with [testing#T.Run](https://godoc.org/testing#T.Run) when I wanted to create BDD like tests with the core testing. But most of the time, it was cumbersome, to do setup in a reproducible way, and to have the ability to split specifications easily into smaller chunks, and that was the reason for this pkg. I believe that a software engineer should be disciplined and practice restriction on the code, to keep the mental model as minimum as possible. But I found myself boilerplate common thins when I was working with [testing#T.Run](https://godoc.org/testing#T.Run) ,so I used the exactly same idiom from the testing pkg to create this, and if you check it out, it is actually under the hood still that. But I'm so happy because what you wrote shares so many of my own principles, and I'm happy that you took your time for this! If all the feedbacks will be like yours, I'm feeling already lucky by sharing this link here! : )
It might freeze at allocation. Try not use a slice but a map, and of a bool instead of a int. And are you sure that inputs has exactly n numbers in total?
Here is another way of doing it: https://play.golang.org/p/70jbKkuNcUI It uses a custom UnmarshalJSON method and type switches the results in the list and returns an error for unknown types.
you can try testify, mock and stub
I don't 100% know this is the problem, but Scanf is not meant to be used that way and it's possible it's doing something like reading the entire rest of the line and parsing it into integers each time, then throwing away all but one number's worth of that progress, turning this into an O(n\^2) problem. You should use bufio.Reader, and then use the method ReadBytes with a \`' '\` (space) to get the number, then you can parse the result with the last byte chopped off. That will read it as a true stream and you can have as many numbers on "one line" as you like.
&gt; First you say &gt; Go is wanted because of the language itself. &gt; Then you say this &gt; Go is a great programming language - but not because of the language itself. There is more to an ecosystem than language design. &gt; Which one is it then? You ding things for being good because of the ecosystem and not the lang, but now you've turned around and said that the ecosystem does matter. It doesn't when you think it doesn't support your point, but now that it does help your point it suddenly matters, what gives? Context is important here. The first time I was saying people are choosing Go over JavaScript and Python (specifically) because it's a good language (ecosystem aside). We were talking about the most desired languages from that survey. The second comment was comparing Go to all reasonably related languages as having a more boxes checked for the whole ecosystem: language design, 3rd party libraries, modules, building, tooling, etc...
Their language is dynamically typed and they didn't notice. I've actually advocated in general programming forums a few times that if you're writing a JSON UI that you check that you don't use heterogeneous arrays like this, because you'll annoy all the static language users. It's not just Go.
Well, I redact my comment, as I didn't mean it to be toxic, let me elaborate in a more adequate way. &amp;#x200B; If a developer defines a language for a single feature that it lacks and can't even come to consider or even realize the numerous problems it actually solves, they are *definitely* someone I would not hire. That is a clear symptom of the single tech syndrome. I myself have worked fulltime with Java for 5 years, but that doesn't mean I would pick Java over golang everywhere. More precisely, I would not pick Java for anything as of 2019, given that for most of its use cases I can find better suited technologies, such as C# and Kotlin. Notice how I didn't list golang as a Java alternative, since it is not, and the comparison itself is really far fetched. &amp;#x200B; Back to the original point, generics are really useful for creating flexible interfaces (even though I'd argue golang also has you covered) or for those stuck in OO. But given your code is data oriented, highly parallelized or has a distributed workload, that's where golang comes to mind. So I interpret the fact that these "advocates" like to bash on the lack of generics as a simple statement in the "I only know hammers, so screws are not a thing" sense.
https://github.com/tidwall/gjson might be a little easier to work with for something that unstructured, but the bigger question is how you want to deal with those structures in a useful way.
Function overloading can, in fact, be achieved in go using Anonymous Embedded Structs. &amp;#x200B; What is debatable, however, is the idiomatic nature of doing so. &amp;#x200B; [https://play.golang.org/p/pDa2WXYRGCB](https://play.golang.org/p/pDa2WXYRGCB)
I dont agree that is hard to work with data in golag. Looks like the author just commented on his personal experience.
About the want for explicit interfaces: ``` var _ interfaceFoo = structBar{} ``` This will fail on compile if the struct doesn't implement the interface, but the underscore will remove the value. This is the explicit check they are looking for.
More generally you can deal with something like this found inside of a larger structure by putting a `json.RawMessage` where the weird array is found, and then apply this technique to the `RawMessage`. If you go one step further by providing a type with an `UnmarshalJSON` method one level up, you can hide the whole thing from the consumer so that you can just `Decode` into your top-level type and have everything come out right.
Yeah considering this kind of weird array thing happens several levels, I'm taking the `UnmarshalJSON` route.
There are some ffmpeg wrappers, if that helps
Almost always not. There are some reasons it will, generally if there's something in the code that requires nsswitch, such as a lot of things in the net package. You can generally avoid it by setting `CGO_ENABLED=0`.
I expect to. I'd also like to see other tools I use (or might) have the functionality I'd like...
That just looks like dynamic dispatch to me.
`gomobile` does not have access to those specific APIs on such systems, to do so you have to provide an interface from the host platform (iOS/Android) and then use the interface to access the API, the interface's implementation would have to encapsulate (in the case of Android) access to the `AlarmService` and expose that to Go as the interface
[removed]
Most commonly, I've seen these two design choices: 1. using [domain-driven design](https://en.wikipedia.org/wiki/Domain-driven_design), `x` is in a domain/package, and is imported by both the client and server; and 2. a `proto` package, containing all proto definitions, also imported by both client and server.
I have committed. But it's not a big deal. I will modify it soon.
[removed]
So in both cases the packages contain `x.pb.go` in addition to `x.proto`?
[removed]
Cool, makes sense. Anyone maintaining a pure Go alternative to nsswitch?
Others say almost never. But in reality, almost everything you’re gonna build has some need for something in libc. Nsswitch is used for resolving the names of a lot of things, especially anything network related. But it doesn’t -need- to. Eg, a CLI program probably won’t need to.
It’s good practice to have generally have the server side with the actual go import. Then have the client import it directly. I have a separate protocols repo that holds all of that. Although I do sometimes regret not having the server side “own” the Proto files and the imports.
Awesome! Awesome! I am so glad to hear this. Email me so that we can stay connected - if jobs ever come up, I like having a list todd@greatercommons.com
Awesome! I am so glad to hear this!
Not sure what u mean here with "server side with the actual go import"? Server contains `x.pb.go` and client imports it?
Correct, in my projects, the generated `.pb.go` is always alongside the `.proto`. It lowers cognitive load and enhances discovery.
In a sense, the server should be considered the [single source of truth](https://en.wikipedia.org/wiki/Single_source_of_truth). The client is merely a consumer that depends on the server. That also means that it's up to the server to handle protocol versioning as it changes.
Note that `CGO_ENABLED=0` is no longer necessary for 1.10+.
[removed]
I've never heard of using protobuf to do those things. Do you have any resources I can check out to learn more?
But the main point people has about the lack of generics is that the staple of most languages (map/filter/reduce/sortby/groupby/minby/maxby/sum etc) is missing and that doing such super simple universal methods and defining simple pipelines takes up insane amounts of boilerplate which goes against the whole readbility point of go (same with the excessive error handling). Too much visual clutter. I don't see a lot of people actually complaining about generics from an oop perspective. But yeah, no point discussing it too much as it's already coming to Go.
This might help you out. https://mholt.github.io/json-to-go/
Got it, that wasn't clear to me at first.
Related issue in golang/go by Rob Pike https://github.com/golang/go/issues/26074
Are you familiar with the concept of moving the goalposts?
Even still there is interfaces which are like pseudo generics. However, it makes code messy with all the type assertions.
I've used how Google publishes their own proto files as a good guide. Also very useful to see how they do versioning. https://github.com/googleapis/googleapis Basically put the proto files in a separate repo.
With the server as a SSOT it feels as if I'm building a distributed monolith rather than a microservice architecture. It seems better to me that server and clients depend on the interface, the protobuf definition, rather than one on the other.
google repo seems very useful, thanks!
Put the protos and generated code within the repo for the primary implementation of that interface. This keeps the IDL, the generated code and they implementation in sync.
No if you are compiling statically. &amp;#x200B; If you are using a C library, very likely it will pull in libc and friends too.
grpc does more than just call the method. For example, it's also populating the context it passes to you with other information, like metadata, credentials and peer information and it's re-interpreting the error to wrap it with a status code, if necessary. If your service (or any of your dependencies) wants to use any of those, the tests won't accurately reflect what's running in production and you might either miss a bug with your tests, or have tests fail wrongly. It *can* still be a valid approach, if you really don't need to accurately map the grpc behavior. But TBH, given that the downsides are negligible (only a little bit extra test-code, that can even be de-duplicated into a function), I would choose the more robust version of actually connecting.
\x27 is correct. I think something else is going wrong.
Doesn't Go have a pure-Go resolver? I built an app that did nothing but networking and shipped it on a scratch docker image without issue... [https://weberc2.bitbucket.io/posts/golang-docker-scratch-app.html](https://weberc2.bitbucket.io/posts/golang-docker-scratch-app.html)
Question stipulates "pure Go".
That's what Google Search Console says: &gt; Unparsable structured data &gt; Bad escape sequence in string If I remote the quote, there is no error.
Yes, but you have to set CGO\_ENABLED=0 even on 1.12 otherwise it will use libc resolver.
I don't think bufio.Writer is designed to wait until the buffer is full to write through. If the underlying writer (your file in this case) can keep up, that buffer will never fill. If you specifically want to hold all the data until you hit the buffer size, you're going to need a different structure. You could probably just use a bytes.Buffer. &amp;#x200B; Also, don't forget to call Flush when you're done.
From 2016, but still relevant. https://blog.filippo.io/shrink-your-go-binaries-with-this-one-weird-trick/
&gt; I'm assuming start with unit tests for the exported functions? Heck yeah, test useful behaviour, that's what's important about your software. How you define bits of your code in respect to that, is a design challenge and takes experience to learn I talk about it a bit here [https://www.youtube.com/watch?v=Kwtit8ZEK7U](https://www.youtube.com/watch?v=Kwtit8ZEK7U) If you dont like videos, here's a wordy version [https://quii.dev/The\_Tests\_Talk](https://quii.dev/The_Tests_Talk)
Right, but the parent's claim was that glibc was almost always required, so your response is puzzling. :)
I would definitely use the former. One of the main advantages of gRPC is you can have a persistent connection, so you shouldn't be dialing up for every function call. Dial once, store your NewServiceClient somewhere, and use that to make all the gRPC calls you need.
I just built it myself. By default on Linux cgo is enabled and Go binary will be linked against libc resolver. I don't remember any other reason why Go would link against libc (maybe also plugins as that requires dlopen and stuff). Once you disable cgo the dependency will go away.
Congratulations! Writing a book is a big task, and _shipping it_ is another challenge on top.
With go you can get that by building the image from 'scratch'. That has some limitations though, but it is very much possible.
 It is already.
Ah, right. I just did an experiment, and the answer actually depends on the CGO\_ENABLED var: `$ CGO_ENABLED=1 go build httpserv.go` `$ ldd httpserv` `linux-vdso.so.1 (0x00007ffdd85de000)` `libpthread.so.0 =&gt; /lib64/libpthread.so.0 (0x00007fc513bf1000)` `libc.so.6 =&gt; /lib64/libc.so.6 (0x00007fc513a2b000)` `/lib64/ld-linux-x86-64.so.2 (0x00007fc513c3a000)` vs `$ CGO_ENABLED=0 go build httpserv.go` `$ ldd httpserv` `not a dynamic executable`
Actually, I can guess why your watcher stuff doesn't work without reading the code, and I'd guess it's the same reason you're manually calling `wg.Done()` - you've stuck an infinite loop in here after the signal is received, so the deferred `wg.Done()` call never happens, so the waitgroup never completes, and you added manual `wg.Done()` call to hack around that to allow your program to exit, however this means your `for` loop here never waits to complete. Basically, all of this logic is poorly reasoned, and you need to rethink what you're doing here, and understand how your blocking operations work together.
Use gRPC Buffcon. It lets you have the best of both worlds. It lets you get coverage reports on your tests.
https://play.golang.org/p/1KOcR1E__uE
&gt; The main issue is cross compiling cgo
Scanf should essentially never be used.
Won't really help here.
It's because for a long time, Java was the only good language whose SDK you could get for free.
``` [~]$ go version go version go1.12.5 linux/amd64 ``` Still builds dynamic executables by default for programs that engage in networking. With `CGO_ENABLED=0` static executables are built. What's funny is that sometimes the statically linked binaries are *smaller* (though not by much).
Ahhh I see. Thank you!
Correct, to expand a bit, the default value of `auto` for the `GO111MODULE` environment variable causes for go packages that are inside a `GOPATH` to be treated as regular non-module packages. So by placing a package that is a module in a GOPATH and with `GO111MODULE=auto` (or unset) will be enough for another go package inside the GOPATH (say the `main` entry point) to be able to import it from the GOPATH without opting into modules. * https://github.com/golang/go/wiki/Modules#when-do-i-get-old-behavior-vs-new-module-based-behavior In the situation that I first mentioned both packages are inside a `GOPATH` so placing her/his module package in the GOPATH should be enough, perhaps I wrongly assumed that the OP would have `GO111MODULE=auto` (or unset in his `$HOME/.bashrc`) which I should've clarified. However as OP pointed out, the solution for her/him has to use a `replace` directive, presumably because her/his `main` entry point is a package that exists outside of his `GOPATH` and that is using modules.
Agreed, lots of people say they want to write a book and never accomplish it. (I am looking at myself.) So impressive that you stuck with it and finished it. Cheers.
I'm re-learning Go so ill read this now. &amp;#x200B; Wish me luck and Bush did 911
In our case, we went the route of having an exclusive `*.proto` repo from which we then produce a Go specific `*.pb.go` repo that we manage through semantic versioning. That way the client and the server packages just define the version of the models that they want. We know that the recommendation is to include the `*.proto` files along with the consumers of the generated code and when needed to run `go generate ./...`. However in practice we found that when there are many consumers of the proto files and generated sources updating is a bit more complex and it's easier for developers to introduce on-off changes to the local proto files causing for incompatibility issues.
Go 1.12 increased the aggressiveness of function inlining over Go 1.11. I saw some of our binaries increase in size by about 10% while also getting significantly faster. Worth the trade-off. Why does size on disk matter that much to you, anyway? Disk is cheap. Throughput and latency are usually much more important.
Yes, the main issue with using go-confluent-kafka in aws lambdas was cross compiling cgo, which made the build toolchain a nightmare, and which go modules would not help. Still not sure why you think this is a criticism of go.
Congratulations! I have learned a lot from this book!
Yeah you should probably limit it with a semaphore.
For this I use a `[]interface{}` to decode inside an UnmarshalJSON method, and then process the indices into struct fields. You can also use `[]json.RawMessage` if that inner nested bit is something you have a struct to decode into.
Yes! I noticed this about the size too. I thought I was going crazy so showed a colleague, who agreed with me.
Great! You're right, thank you.
Honestly throw it to me in a PM or whatever. You might be surprised at what improvements can be made, or maybe youve already written it ideally. Hard to tell without seeing what you've written.
Congratulations! First time seeing this book. Downloaded for later reading.
[removed]
[removed]
[removed]
Congratulations!
Aren't you fun
If your service is calling it's own rpc functions, how do you do that then?
If your service is calling it's own rpc functions, how do you do that then?
If your service is calling it's own rpc functions, how do you do that then?
By calling them. If `Foo` is called by grpc, the passed context contains everything needed. So if `Foo` calls `Bar` using that context, everything's fine.
In this case, I don't need to create a ServiceClient?
For context, I couldn't find a tool to set up custom import paths *without* having to run a backend, so I wrote this quickly to generate the necessary files for hosting on gh-pages. There's an outline of how to use it in the README, and I personally use it for `go.bobheadxi.dev` imports! (https://github.com/bobheadxi/go)
So for host resolving, disabling CGO means the program will go directly to dns, bypassing the host os's NSS layer? It will read /etc/resolv.conf, though?
Please give a short introduction to you package in the post :-)
Congratulations, appreciate your efforts!
Wow. 514 pages of goodness. Thank you!
Can't edit the description, so I will just post it here: **Go asynchronous function simple utilities, for managing execution of closure, callbacks**
Awesome! Thanks for spending your time on this. Someday I want to read the free version of this so I'll be making PRs to help with editing. I already started. More corrections and edits to come. This is how I'll be paying for it :P. Congrats!
Hm, I see. Spawning a new subprocess is a no go-in this case. I think I'll have to consider the "timeout thread" hack and handle the call in native thread. In the initial solution I posted, despite `cancel` function (with `return` statement) is called when context is cancelled, that would still leak the goroutine in case of hanging `NtQueryObject` call?
Awesome , I'll check it out
You would use a separate repo, as the protofiles will be the Interface between your applications. Then you could either generate the server and client stubs in some way using a CI job on in your api module and then use the generated (possibly versioned) artifacts in your service a, service B repositories. Downside is a bit, that you make it harder on yourself to „explore“ a good api Interface using service a directly, as you always go through the decoupled artifact dependency from your api repo. To have best of both worlds you can: - keep your api repo - possibly for future use add a CI job, which generates stubs for different languages solely from this api repo( e.g. a Java server jar library, which you publish to a maven repository. Other java applications could just get the jar from maven and just include the gRPC runtime [but not generator] as their dependencies) - add the api repo as a submodule to service a. This way you can try out / design new Api definitions with service A directly and get a feeling of a nice API. Then you can commit to the api submodule, and possibly ship a small integration test with it
&gt; cancel := func() {return} &gt; ... &gt; cancel() Does nothing. The return is for that function not the containing function. So the call to cancel simply enters a new function and returns imminently. In-essence it is a nop (and quite likely optimized away). If you put some prints in and delay the return you can see it does not stop the go routine: https://play.golang.org/p/0a4G1bdwQxg
Sure, if you'd care to take a look: [dbSelect-go](https://gitlab.com/rj.budzynski/dbSelect-go).
Got it. Thanks for explaining!
Just read through your code, nice work. One thing though: It is ok to access individual slice items concurrently without sync. Which means, in \`All()\` , it might be better use sync.WaitGroup and set the result in the goroutines instead of having a channel to re-map the result.
That's correct.
Don't know if this will be the next enterprise programming, I mean, it could be as most of the enterprise is now moving to the cloud and Go shines on the cloud. From my perspective working with c# for the last 18 years. Last year I was told I had to wrap up the project I was maintaining for 2 years. It's an extension project for SAP ERP. It was originally written in [vb.net](https://vb.net) (never understood why) and I moved it c# 1st month and improved allot of inefficiencies in the code. There where processes that their execution time was lowered from 10 minutes to less than 30 seconds for example. Back to my new project, I was assigned a cloud based singe web application project that had to synchronize with the ERP. I was given the green light to choose whatever development platform I wanted to use for this project. After extensive research I decided for the front end to use DartAngular as later on I would also add a native Flutter app once I get the first phase done1. Now that Flutter is also going to be compatible with Web Applications and Desktop applications by the end of the year most probably I'm going to get rid of the DartAngular and move everything to just Flutter. (Most of the logic code is in another separate project so I can re use most of my code anyway). For the back end I decided to try Go, sounded simple enough and had all the pieces I needed out of the box. For the Sync service I'm using .net c#, the ERP is for MSSQL and it's a COM Object, not very friendly to use with Go and much easier to use with .net. I already finished the front end, back end and now I'm working on the sync service. And I have to admit after working for a couple of months with Go, I love .net, I love c#, it's a very robust language but now I'm suffering writing it. I got used to the simplicity of Go because (and wait for it) it does not have Generics and Abstractions. When you have Generics and Abstractions which I'm definitely using in the sync service you have to put allot of thought to do it the right way from the start because it will be a permanent part of your project. The fact that go does not have this makes the development easier. Yes, you could en up writing more code in Go for the same functions but you do it faster as you don't have to plan so much ahead to be sure you'll be compatible with whatever you want to expand in the future. TLDR; I love c# and .net but after working with Go I appreciate its simplicity allot.
thanks for the hint, I quickly updated my little package. I am not sure if I even need select to check if context is done. does it make sense to have it there ? I case the context was canceled earlier from before when the method was called ?
I would say neither the for loop, nor the context in the All() is needed.
Why would you call it's own methods via grpc? I'd would cleanly separate service business logic from representation (grpc) and call business logic methods directly without grpc being involved at all.
[removed]
Any arguments why it is useless that comes to your mind ? The only one in favour of keeping it I can see is that when the context would get canceled before all of coroutines get spawned
This is likely handled at the database level or some other transaction service between the ATM and the database holding your bank account. Check out [database transactions](https://en.m.wikipedia.org/wiki/Database_transaction)
Cf https://npf.io/2016/10/vanity-imports-with-hugo/
Yes, I get that. It could be Database or Application. But I am wondering what happens when the request is at the EXACT same time? How does the scheduler know what to consider first?
Because there does not really seem to be a case where context is cancelled in All() ?
If both withdraws were valid, the bank could process the transactions in parallel and then merge them after they have been committed. However, the professor seems to have the case in mind when $100 can only be taken out of the account once, for example because their is a limit of $100 per day. In any case the transactions have to serialized from a logical point of view, since parallel write operations and parallel write + read operations could give totally wrong results otherwise. In order to ensure consistency, at some point when a transaction locks the database it must ensure that only one request is performed and the other one is queued for later. This in turn requires an atomic operation at the bank's computer at the beginning of the transaction. These are often supported by hardware, e.g. Go provides access to such operations in "sync/atomic". Often, the operating system/programming environment also provides some means to guarantee them, because it also schedules parallel processes. In Go, you would usually lock the database in a function that is guarded by a Mutex. Other requests are stopped and queued as pending. The database then locks the file, performs the account balance check, authorizes the withdrawal, and commits the transaction. The Mutex itself is only needed for the initial locking and queueing of pending requests, which must be an atomic operation. There are also lock-free ways of keeping parallel database transactions consistent (by later merging them, as indicated above), but I doubt these are used in banking. Accounting systems are often very old, e.g. written and maintained in Cobol.
Any good resources on how to do this? New to this
being very simple: two requests finally will be processed by one code execution thread, so one will be first and another second anyway
Just move the `Getenv` call elsewhere and have your function the the value it retrieves as an argument instead.
I see. Thanks for the detailed and thoughtful response. It seems there are a series of things that need to happen: Application (go "sync/atomic" / Mutex) AND Database AND Operating system AND Hardware. The probability of a data race condition will be very rare.
How is that determined? What comes first, second, etc.. if the transaction was executed at the EXACT same time?
So are you saying something like this?
This is still retrieving environment variables directly.
Then I don't think I'm understanding... How can I call it indirectly? The GetEnv() function gets loaded when the package does, and therefore the env variables loaded then, before my test can set them. So I can't retrieve the env variables inside any exported function. Is it possible to explain by modifying my code?
Databases are awesome locking tools 😉. Here what you are looking for is a "Repeatable Read" (or serializable) transaction isolation level. And database would ensure that the two transactions are happening in a way as if one happening after the other. Of course, the isolation levels have a performance cost and it is possible to use lower isolation level (Repeatable Read) with some tricks to achieve the same behavior. But any how, it is what you are looking for. And needles to say, a relational database make your transaction management comprehensive as compared to common NoSQL databases.
It depends. If your config class is specifically and singly responsible for reading environment variables, and is not performing additional business logic (which appears to be the case), personally I'd say testing it in isolation is wasted effort. If its responsibility is not reading environment variables, then it shouldn't be reading environment variables. If it needs an app name, that should be a parameter to its constructor function. Its GetEnv method should not exist. Though I'm not sure what you mean by "the GetEnv function gets loaded when the package does" - functions aren't "loaded" at all, and it doesn't get executed until it is called, so there should be no issue modifying the environment or anything else before the function runs.
I didn't closely looked into it, assuming it might be another great library. **But was that to confuse programmers?**
what
What
well, what i did wrong this time? [https://i.imgur.com/MJ3XJDS.png](https://i.imgur.com/MJ3XJDS.png) to what i can understand Stdin buffer needs to be flushed? also check this out, i finally found what was wrong with Scanf [https://i.imgur.com/QA1ltOL.png](https://i.imgur.com/QA1ltOL.png) [https://i.imgur.com/6jPNQja.png](https://i.imgur.com/6jPNQja.png)
Sorry, I was incorrect in what I said. Yes functions aren't executed until called. However, I'm using an init() function for my package which calls an exported function that uses an environment variable. Hence my issue. The init function is executed (from my understanding) when the package is imported. It's fine for when it's a dependency. But I cannot figure out a good way to test it without manually setting the env variable. Setting the environment variable in the test file is too late as the package checks before its set.
This is a good reason not to use init functions except for things like registering functionality (eg SQL drivers or HTTP handlers). Init functions make testing next to impossible, they make programs harder to understand and troubleshoot, and are generally unnecessary.
So your thoughts are to just the user initialize it themselves on their end with the exported functions?
Practice. Practice. Practice. And more practice. There also a lot of resources online. You can do a web search or read the sidebar. Here's something to get you started: https://github.com/golang/go/wiki/Learn
\&gt; How is that determined? What comes first, second, etc.. if the transaction was executed at the EXACT same time? Because the bank's computer won't execute the entire transactions at the exact same time. At some point, both transactions will attempt to lock the shared resource \[e.g. through a mutex\] before moving forward. Only one transaction can acquire the mutex. &amp;#x200B; Put another way, imagine two people want to walk through a doorway that only fits one person. Imagine both people reach the doorway at the exact same time. They are going to figure out some solution \[e.g. likely random\] :) &amp;#x200B; [https://en.wikipedia.org/wiki/Test-and-set](https://en.wikipedia.org/wiki/Test-and-set)
Aye Aye Captain !
Yes, that's how things normally work.
Thanks, sorry for so many questions.
How many routers actually use regular expressions though? I thought most are built on httprouter or some other sort of radix tree
Some more experimentation :- 1) [https://i.imgur.com/wyiiHy2.png](https://i.imgur.com/wyiiHy2.png) 2) [https://i.imgur.com/5Cruo6h.png](https://i.imgur.com/5Cruo6h.png) If you look closely in the second link image input ends at '3310', which is not last character in Stdin. Here you go -&gt; [https://i.imgur.com/WbwwSnq.png](https://i.imgur.com/WbwwSnq.png) am i making sense? i'm totally new to golang although not new to programming. in python3 using input() was enough it read all of the values in buffer at once. also i tried this with c and having the same problem and flushing stdin is not helping, i'm missing out something for sure. c code -&gt; [https://i.imgur.com/EYsFyPd.png](https://i.imgur.com/EYsFyPd.png)
Nothing is truly concurrent, it's an illusion computers generate by context switching very quickly. Even if the ultimate deciding factor ends up being random chance, one of the packets containing one of the requests will go down the network interface of of the machine performing the lock before the other does. Ultimately there is a process somewhere making the locking decision and it will always see the requests coming in sequentially.
What does this do?
Wouldn't `foo(arg1, arg2, arg3)` evaluate before `go(...)` is invoked?
[removed]
Interesting read-up. Essentially this is working out another way to achieve the same end goal. I don't know why `chr` when it was obviously `channel_read` or `chs` versus `channel_set` or `channel_write` It's not as readable as go, it's library is not as feature-filled or well documented as go, but it's always nice for good ideas to permeate.
[removed]
[what](https://i.imgur.com/EYzlRVB.png)
 I'm guessing `go(...)` is a macro that wraps the foo call with some junk for use as a coroutine.
That'd make sense. I haven't touched C/C++ since college, so I forgot that macros were a thing. Thanks!
No, because `go(...)` is a macro, so the arguments in parenthesis are not evaluated until after a new thread has been spun up.
I need to dig into the coroutine code
I could be wrong!
exec.Command(sliceOfStrings...)?
`exec.Command(name, your_slice...)` For more details see: [https://golang.org/ref/spec#Passing\_arguments\_to\_...\_parameters](https://golang.org/ref/spec#Passing_arguments_to_..._parameters)
Args := []string{“one”,”two”} cmd = exec.Command(“ls”, args...)
I tried that but the compiler complains that I should have (String, []String...) Instead of (String, ...String) :/
I tried that but the compiler complains that I should have (String, []String...) Instead of (String, ...String)
Rather than just giving you the answer like everyone else.. Look into 'variadic arguments' - https://golang.org/ref/spec#Passing_arguments_to_..._parameters
Thank you. I appreciate that
Thank you all, I've found the error. I've used the "mySlice..." but I had top many arguments before that slice.
Thanks for sharing. I kept the approach mostly the same: https://gist.github.com/dallbee/408af93e548b275574bb91336da532e6 select.go has the nicer formatting, compact.go is for line number comparison. By my count, a reduction of 32 lines.
I wonder how many people think they have a URL route for /whatever.ext and actually the . is a regex any character matcher. I know I’ve written that multiple times.
[https://stackoverflow.com/questions/42779856/read-large-amount-of-data-from-standard-input](https://stackoverflow.com/questions/42779856/read-large-amount-of-data-from-standard-input) this seems similar
How are you passing the []string? If it’s a variable then applying the ... suffix should expand it into the variable argument type. args := []string{“hello”, “world”} exec.Command(“echo”, args...)
Yeah, I've found the problem, sorry for not saying it here. I used (string, string, string, []string...) instead of (string, []string...). Apparently the first does not work.
Not if it's done the right way, no. There is always a chance that your code is buggy, of course, but apart from that data races like the one you described can be prevented on common hardware and operating systems. You can prevent them in Go, for example.
What would name, data, and print format be on a car? Consider restructuring your code or change what you're testing. The car type and its fields are all private so I'd consider those "implementation details" – not part of your module API. If they should be public, try to think about what a car's print format would represent and whether it belongs on a car
[removed]
Thank you very much for taking the trouble. Just three quick notes, before I can dive deeper: - the `panicError()` definition in a.go is a little mangled - your `loadConfig()` is quite elegant, unfortunately the field names in `mysql.Config` don't quite match the keys used in mysql's own config files, and I tried to stick to those &amp;mdash; it's highly annoying when stuff fails for a stupid reason, like that you wrote `passwd` in a config file instead of `password`, or *vice-versa*. - the character count of your code is actually higher than mine ;) Oh and trimming the query isn't really needed, but it costs nothing.
- whoops. Made that mistake editing the Gist. Updated, but you can probably guess what was intended. - That is annoying! You can actually fix the naming inconsistencies by embedding mysql.Config in your own config struct and overriding the fields you want with struct tags. Or providing your own mapping function to the ini loader. - heh. So it is. Your code was already mostly fine. I see a lot of new go programmers end up with massive amounts of code duplication because Go's abstraction abilities are atypical, but that wasn't the case here. The only substantive improvement I made was reducing how much work was having to be done on each row.
Yep, the type switch construct was what I missed and what does make a real improvement. Thanks again.
Nice. We should join forces on [Gorgonia](https://gorgonia.org/gorgonia). let's build an awesome Go deep learning env
[removed]
Yeah, here is the snippet that actually does that. ` . . . #define go(fn) mill_go_(fn) . . . #define mill_go_(fn) \ do {\ void *mill_sp;\ mill_ctx ctx = mill_getctx_();\ if(!mill_setjmp_(ctx)) {\ mill_sp = mill_prologue_(MILL_HERE_);\ int mill_anchor[mill_unoptimisable1_];\ mill_unoptimisable2_ = &amp;mill_anchor;\ char mill_filler[(char*)&amp;mill_anchor - (char*)(mill_sp)];\ mill_unoptimisable2_ = &amp;mill_filler;\ fn;\ mill_epilogue_();\ }\ } while(0) `
Why do the send and receive operators require types
Re: character count. I just looked at the file sizes in bytes. a.go is largest, compact.go is smallest, my dbSelect.go is in between. Not that it matters a lot; character count is merely a proxy measure for cognitive load, and certainly not a perfect one. Indentation is by tabs everywhere; I use VSC which applies gofmt on every save, and your files are d/l'ed raw from github, I don't see any conversion to spaces there. Also, unless I apply `fmt.Sprintf()` on field values before passing them to termtables (or otherwise explicitly set them to strings), they get printed as `[54 56 50]` and so on, ie. as byte arrays.
&gt; I don't know why chr when it was obviously channel_read or chs versus channel_set or channel_write Welcome to C naming conventions, mthfkr.
oh that's neat! there's actually something here that actually doesn't work with Twist right now - `go get` on a subdirectory, will be adding this soon! https://github.com/bobheadxi/twist/issues/3
Ah, yeah, wasn't sure what data types you were working with. Termtables is calling `fmt.Sprintf("%v")`
Depends on how you have structured your services: we have one repo for all our public facing RPC just like googleapis but for our inner microservices each service has it own GitHub repo and we store the proto and generated files next to the service. With Go Modules (didn't even need Go Modules, just import the right path) it's very easy to import the generated Go clients. If you need to generate clients in other languages, then you may want a single repo for all so you can have consistent tooling to generate.
Well I don't really have a huge choice of column data types in mysql. Numbers (varieties of int and float), strings, datetimes, and that's essentially it. It seems that except for datetimes, which I explicitly asked to be parsed, I'm getting all field values as byte arrays when using `SliceScan()`. Not nice at all.
Your example includes a nested struct with basic type fields. I think the behaviour you're trying to exhibit only happen with pointer types. So you can try with a pointer, a map, a slice, a channel ...
Is this what you're after? https://play.golang.org/p/28S152-uqkg
Okay, here's something that stumps me. To try to better understand these type issues, I changed the code somewhat, and now it doesn't compile because of [this line](https://gitlab.com/rj.budzynski/dbSelect-go/blob/testing/dbSelect.go#L78) (or rather the line that follows it). So a type switch case is not as good as a type assertion?
struct is not a pointer ?
[removed]
[removed]
[removed]
[removed]
[removed]
[removed]
[removed]
Just do \`fmt.Sprintf("%s", v)\` on the interface{} catch instead of trying to catch the byte slice. Sorry for the terseness, I'm on mobile now.
no a struct is not a pointer. you could have a pointer to a struct but a struct in itself is not pointer. that new example because you're replacing the slice with a new slice when you do append. try using a simple slice of ints and modifying the first element of the slice instead
Ok, I see now. Like this : https://play.golang.org/p/EElTtoc_Kdl Thanks for the pointers ;)
[removed]
[removed]
[removed]
[removed]
It doesn't aim to replace a framework. This piece of code with no pretension fills a need I had while making my own homemade APIs. Hence sharing :)
It is stopping Go from being used in places which use C extensively. &amp;#x200B; Existing code doesn't get rewritten in one night, it takes various stages and inter operability between C and Go may help to ease this transfer process.
https://tour.golang.org
Please, check your code whether you Flush() the buffer before it is filled up. Btw, you may need to use Flush() only once, after final Write() but that depends on an implementation. A buffer is being flushed automatically during filling it with data. When data being written is too big to fit the buffer size they're written directly to the Writer. If a series of sequential writes fill the buffer up, next write to it causes automatic flushing. Hope, this helps you better understand how the writer buffer works and find the error.
If you don't need to transform the data in between, just use `io.Copy`. Use json unmarshaling only if you need to do something with that data in between.
Time complexity of the matcher function looks dicey with a candidate length in outer loop and then inner loop.
Thanks for taking the time to review ! &amp;#x200B; I agree, this func needs refactory. Tho, the inner loop has the same exit condition than the outer loop. No out of index error can happen.
Method 2 does a decode and then encode, but it seems like a waste of CPU time for nothing. io.Copy should be fine.
On line 68 it says `// I can actually see it in the address bar!`, but you're checking `req.FormValue()` instead of `req.URL.Query()` (or wherever else in the address URL it is) would be my guess?
Hi, well from the screenshot it looks like you are getting an access denied error? Did you follow the link in the error message to register the application? &amp;#x200B; You also need to make sure that the mp3 format is allowed, as in the code it looks like its asking for a "raw" audio file. You could also add a few "debug" prints around the for statement in the end that is looping the results to make sure its actually returning some data. &amp;#x200B; Hope this helps :)
Go blueprints is a strange pick.
Got to save on the vowels. They are very expensive in C.
Probably due to how the select macro expands and needs to cast the receiving value (pointer) into something typed.
The equal signs are probably supposed to be colons, assuming orm.Projects is a struct.
Missing comma at the end of the line
Clean Code, Head First Design, Soft-Skills, Cracking the Coding Interview and Seven Langs in seven weeks are all great books. I love go but, I'm not sure why it's a pick on this list! There's also about 20 other better Go book out there... Oh well!
Thanks for picking that up! That fixed the error there, but I had the same error message further [down](https://prnt.sc/nnf6kp). I thought that it would have been a similar problem but, it seems to be different with two [seperate](https://prnt.sc/nnf6tt) error messages. Changing this to a = gives a different [message](https://prntscr.com/nnf79k). I'm still learning both the language and the codebase itself, so thanks for your help :)
Probably `utils.Atoi` returns two values. (the value you asked for, and an optional error value if the conversion didn't worked as expected). You should check the function signature where it is defined, and if it returns two values, you should save both values on auxiliary variables: `id, err := utils.Atoi(r.ProjectNumber)` Generally after that you check if the `err` value is nil or not, and act according to that. &amp;#x200B; Finally you can assign to the struct the variable `id` as the ID value.
Have you done the Go tour? Probably worth introducing yourself to the language fundamentals.
To be fair most of the variables I come across in go have descriptive names such as “e” and “s”
I did a while ago, but defs worth doing again thanks!
Thanks for the tip, it looks like Atoi is just a simple string to int [converter](https://prnt.sc/nnfeok). It seems that it only returns the converted string, but does the error checking before returning the result. From my understanding the function is essentially doing what you said, so shouldn't it still work? Alternatively, I tried the error handling in the function as you [suggested](https://prntscr.com/nnfiek) and got the same error message. I'm doing some reading up in Go now as I feel like it will be something silly and trivial that I missed, but your help is greatly appreciated!
 x := new(myStruct) *x = myStruct { field: value, } is not valid go syntax. change it to x := new(myStruct) *x = myStruct{ field: value, }
 x := new(myStruct) *x = myStruct { field: value, } is not valid go syntax. change it to x := new(myStruct) *x = myStruct{ field: value, }
That fixed the basic problem hahaha. I'm getting a few [export](https://prnt.sc/nnfmqm) errors now but, at least it aint a red line. Good spot thank you :)
Any specific recommendations for Go books? Looking to add some to my read list :)
Do you need to put a comma after the 0 for clientid? Just curious
I just want to add to the other answers and address your questions about "exact" coincidence of timing. It is certainly theoretically possible for multiple processors or physical cores to execute the same instruction during the same clock tick, but this is precisely why processors have hardware instructions for atomics, and it is aided by the fact that memory accesses must be executed serially and communicate with processors one at a time. The easiest instruction to understand is "compare and swap." Basically, you tell the processor "Go to this location in memory, compare it to 0 (meaning unlocked), and if it matches, change it to 1 (meaning locked)." Whichever processor the memory controller talks to next will be the one to execute this, and the next one will find that the "compare" part fails and will know that it has to wait.
Thank you for your suggestion. Actually, my intention was the main goroutine is waiting for an event from watcher and also is waiting for a signal from `signal.Notify` to exit an app gracefully at the same time. I've implemented my intentions with 2 separated goroutines at the end. I'm still not quite clear with my codes. Is it idiomatic to achieve my intentions? ```go func main() { var wg sync.WaitGroup wg.Add(1) watcher, err := fsnotify.NewWatcher() if err != nil { log.Fatal(err) } defer watcher.Close() sigs := make(chan os.Signal, 1) signal.Notify(sigs, syscall.SIGINT, syscall.SIGTERM) // this is waiting for a sig to exit an app go func() { &lt;-sigs fmt.Println(`Go Watcher terminated.`) wg.Done() }() // this is waiting for an event from watcher go func() { for { select { case event, ok := &lt;-watcher.Events: // do something in case of event case err, ok := &lt;-watcher.Errors: // handing err } } }() wg.Wait() p.Kill() // run some codes during exiting an app gracefully ``` https://github.com/mattdamon108/gw/blob/ae19923320e1651df3fa87468e004950f07d2361/main.go#L16
https://tour.golang.org
Thank you for your comment. I've implemented 2 separated goroutine for each signal from signal.Notify and event from watcher. Is it idiomatic for my intention? https://github.com/mattdamon108/gw/blob/ae19923320e1651df3fa87468e004950f07d2361/main.go#L16
[removed]
 [https://github.com/dariubs/GoBooks](https://github.com/dariubs/GoBooks)
I really enjoyed A Philosophy of Software Design. It presented a nice argument against dogmatic application of things like DRY, and only ever having short functions.
I actually just finished the first two chapters of 7 in 7, and I'm really enjoying it. However as a python programmer I really wish I had a better understanding of OOP vs. prototype. DSL in Io was pretty neat but didn't seem like a killer feature, I wish I there was just a bit more on their differences.
Oooh thanks for the tip. Since all you asking was already explain in the link I tough it would be redundant to put into the post again. I'll definitely keep in mind the next time I'll do a similar post!:)
Tview is excellent :)
https://gobyexample.com/structs Change the = to :
Hm, most of the variables *I* come across in Go are named "err". In a distant second place, "ctx".
Really cool. I wish there was more documentation about how to integrate libmill into other existing C systems -- like how do the coroutines affect the interoperability with other libraries. Also, the documentation/website should list other projects that use libmill so we can use them for reference.
This looks like it should mostly work, though it won't wait for you to read any pending events/errors from the watcher, and the sigs goroutine and waitgroup are currently redundant, since you're only blocking on the sigs read with your waitgroup (you could just block the main goroutine on reading from sigs as it currently stands). Fixing it so that you close and exhaust the watcher gracefully would require further restructuring, probably reading the Error and Events chans in separate goroutines using `range` (adding to your waitgroup first), or returning in the case of an empty read (`!ok`). Then you would close the watcher when you receive a signal, and allowing your channels to drain before you signal the waitgroup that you're done working.
Actually not. There was only one meetup with Golang creators not more, zero talks
Thank you for looking at my embarrassingly long sample. Adding a line like: `fmt.Fprintf(os.Stdout, "&amp;code: %v\n", r.URL.Query().Get("code")` Produces the same results, which is an empty string. (My thought in using FormValue() was that I was getting the form values from the eBay signin, which is probably misguided. r.URL.Query() makes more sense precisely because I see the damn token right there on the address bar.
Yeah, I did!
You mf haters. Why this downvote? [https://github.com/docker](https://github.com/docker) just go and read the sourcecode. It is written in Go.
Yes, that's why I made sure to point out it's the staple of other languages. It's basically on par with for loops in usage (in functional languages there's not even a regular for loop, since it's replaced by these functions). Most other features are syntactic sugar and of limited value and the appeal of Go is largely KISS. But not having those makes data heavy logic 8-10 times as long which is not worth the trade off and goes against readbility and simplicity which is the point of the Go approach. It's not even something worth arguing as it's coming to Go, so if you argue against with "it's not the go way" it shows that you don't really know how to evaluate these things and in 1 year you will argue for it because by then it IS the Go way.
No one said it was.
This could also be expressed as ``` x := &amp;myStruct { field: value, } ```
Very cool! This is based on inotify? It might be worth mentioning some limitations, namely needing a Linux kernel and not having support for NFS (common on research clusters). See https://en.wikipedia.org/wiki/Inotify. Good job!
Waiting for the signals in a goroutine and then closing a done channel or a waitgroup is a common pattern if your code needs to do other blocking operation that don't end until the signal arrives. However in your particular code, the goroutine isn't doing anything different than if you just register the signals at the very end and block on reading the channel in the main. You don't really even need the WaitGroup with goroutine here.
req.FormValue() only works if the data was POSTed as a application/x-www-form-urlencoded. Perhaps, you need to look for JSON instead. So parse the req.Body instead: &amp;#x200B; bodyBytes, err := ioutil.ReadAll(req.Body) bodyString := string(bodyBytes) println(bodyString) var oauthCode map[string]interface{} err = json.Unmarshal(bodyBytes, &amp;oauthCode) println(oauthCode["code"].(string))
Thank you! It’s based on https://github.com/fsnotify/fsnotify that has adapters to inotify for Linux, kqueue for macOS and ReadDirectoryChangesW for Windows. Thank you for mentioning NFS, I’ll research this topic.
No, I wasn't saying it is, just in the context of people writing their own language.
Nice library but if we use it we will lose all the "fun" part! :P
What is the output that you expect? What is the actual output?
Kinda cool. One thing I would suggest is to decouple it from running commands. You’re already decoupling the config from the importable library functions, which is a good thing, but perhaps you could use a high level function instead of always running a command. Then use a configure, high level pattern for configuring with a command. Eg, you’re new watcher could be: type RunFunc func(string) func NewWatcher(name string, paths []string, runfunc RunFunc) ... .... something happens: runfunc(path) This pattern would make it possible to run any generic function based on the file path. So instead of assuming external code, one could monitor and do things directly within Go. Using a high level closure wrapper, you could easily add advanced functionality as well.
[https://tour.golang.org](https://tour.golang.org) (official) [https://gobyexample.com](https://gobyexample.com) (quick resource with examples. Really well presented in my opinion) [https://golangbot.com](https://golangbot.com/) (Found this blog while googling. This guy writes really well) [https://www.youtube.com/watch?v=C8LgvuEBraI&amp;t=313s](https://www.youtube.com/watch?v=C8LgvuEBraI&amp;t=313s) (super quick 12 min intro Go. I really liked this one) [https://www.youtube.com/watch?v=t9nqY8IzICM&amp;list=PLVEltXlEeWglOJ42pCxf22YVyxkzan3Xg](https://www.youtube.com/watch?v=t9nqY8IzICM&amp;list=PLVEltXlEeWglOJ42pCxf22YVyxkzan3Xg) (I liked this playlist on youtube) [https://www.youtube.com/watch?v=oppb7qE3Uao&amp;list=PLmxT2pVYo5LDMV0epL4z4CUbxvIw6umg\_](https://www.youtube.com/watch?v=oppb7qE3Uao&amp;list=PLmxT2pVYo5LDMV0epL4z4CUbxvIw6umg_) (another playlist on youtube I liked) &amp;#x200B; Not affiliated with any of them. Just some good resources.
It was `errors.Wrap(err, fmt.Sprintf("text +a bit more #s", object))`
These are not errors. I'm guessing this is the linter or something. I would not worry about it.
https://golangbot.com/learn-golang-series/
I really like this resource. Not a book. But something that's been a good resource for me to https://yourbasic.org/golang/.
Very nice. Does it watch recursively? Also, you could replace the done chan in the main function with `select { }`. Not sure if that's bad form, but that's what I do to wait forever.
If you'd some instructor based training, take a look at Go on udemy.com. I purchased both of Todd Mcleod courses and found them informative. For the price of the courses I think it's well worth the introduction.
Vanilla C doesn't have type inference like Go, so the macro expansion probably needs knowledge of the type for it to be initialized. GCC has some type inference extensions, but I'm assuming libmill aims to be more portable and hence can't use unportable extensions.
How about this? https://github.com/mattdamon108/gw/blob/master/main_test.go I've removed goroutine and just use for loop with select/case. But still I have some questions. 1) Which one is more idiomatic and better way? only for-loop with select/case vs. using it inside goroutine 2) in case of waiting for an event from the watcher, I think using `continue` is more readable, but `break MAIN` is working same. Why `break MAIN` in that case is not skipping a for loop?
https://github.com/mattdamon108/gw/blob/master/main_test.go I've removed goroutine and just use for loop with select/case. But still I have some questions. 1) Which one is more idiomatic and better way? only for-loop with select/case vs. using it inside goroutine 2) in case of waiting for an event from the watcher, I think using continue is more readable, but break MAIN is working same. Why break MAIN in that case is not skipping a for loop? Can I ask same to you?
Yes, it watch recursively. I plan to add flag in config to control this behavior. And thank you, `select { }` looks like little bit simple than mine.
&gt;Go offers no solution for a syscall that hangs (that's outside the scope of Go). How would this be outside the scope of Go? Doesn't Go style itself as a full systems programming language? In other words, wouldn't it be like saying that something is outside of the scope of C?
[removed]
[removed]
[removed]
Google cloud platform is talked about at google next conference. Go is used mostly on google cloud platform at google. A bit more it’s talked about at google next conference.
[removed]
You can make a struct with a method where the zero value will do the crypto thing, but the unit tests can override the private members for the test. You can even export a function that simply invokes that method on an object so the public interface has no mechanism for breaking the security but your unit tests have access. The standard library does that in several places, i believe.
I, uh, what?
Sounds similar to https://github.com/facebook/watchman
Way cool. I recently put out a (hopefully) useful Go project as well and feel like I just learned a lot looking at this. Keep it up!
I thought it's send and receive.
I seriously believe there's a potential for Go to become next enterprise programming. And what stopped it being it for now is not lack of Generics and not lack OO but the lack of (or immature?) proper module and dependency system. The transition from java to Go will not be immediate. Don't expect any enterprise to stop their Java and just move to Go just for the language constructs. But there's a huge disruption in the enterprises regarding their business models. Almost every industry is impacted with this disruption. All the green field applications will go Go native. Rise of Go in the devops framework adoption is just the start. Applications are becoming devops native. Distributed tracing, Service meshes, rest-alternative communication like GRPC are forcing the developers to leave the monstrous frameworks (read Spring, Akka) and just focus on business logic. Now there's a demand for the code to be concise, readable, do exactly what it is needed to (execute the business logic). And Go, no doubt, is suited for that.
Yep! But I need an app, that produces no output (just something like few green dots) when everything is OK 🙃
That’s a lot thank you so much @all
To be honest I'd accept those rather odd names despite the distance traveled all being internal
They have different effects. In this latest example your event loop now knows to break the loop when it receives an interrupt (although you are ignoring handling the term signal now; it should just break without checking the signal type). It's just as idiomatic to use a goroutine to watch for the signals and then to stop your event watcher so that the loop exits. I would say that if your event watcher can be stopped that way, that it would mean your loop would not need to know about the signals. It would just be a form of cancellation. Up to you really. The thing is, if you were making the event loop some kind of library function, you wouldn't want it to know about signal handling anyways. So having it stop when the event channels close is probably cleaner for that.
What is the "fun" part?
I don’t know exactly but it just works for me on my mac. I’ll google it tomorrow for more details 😉
It is a question that could equally apply to POSIX systems though, and Go does have the sycall/os packages which seem relevant. I think it is very much within the scope of the language to ask "how can I handle a blocking syscall that hangs indefinitely?"
Thank you so much!
Thanks, I'm not aware of ever encountering this. I started with MFC in visual studio 5, later 6 and it's never been something I've been aware of. https://github.com/sustrik/libmill/commits/master?after=2dd13ae8a1e4c9b5b89670f813a185dd51c43a66+1049 suggests they started this many moons after my 90's adventures with microsoft C (which I'm sorta pleased to be away from). Perhaps nearly 20 years is enough to get over the past? We used to have sizeof_t at different sizes, I don't see many using that as an excuse to hold on to 32, 16 or 8-bit
short for consonant eh ;-) whats that all aboot
We are discussing the usefulness of feature that's coming to Go this year? What are you smoking?
https://github.com/golang/go/wiki/Learn
It may not be a query parameter and instead is a #token=... Try to parse it manually. Grab your URL, remove the prefix, then print the rest out
Amazing work! Original author of go-dicom here — I’m really happy to see this project thrive like this and I’m glad to see it being forked since I don’t have time to maintain it and I don’t work in the medical software business :)
[removed]
[removed]
[removed]
`math.Abs` is your friend.
Unfortunately it's not that simple, using math.Abs will still give me the wrong number, just it's positive counterpart. `result := math.Mod(x, mod)` `if result &lt; 0 {` `result += mod}` It's simple, but annoying when you do it 20+ times, not to mention the times I forgot... I really don't understand why the default behaviour is the way it is
Thanks for your work on go-dicom. DICOM is a beast and your work was enough to parse pixel data. Wound up doing most of the other work with pydicom or DCMTK. I'm also not in medical software... But I got curious.
I think this is pretty common for the mod operator behaviour. At least Java behaves same. Which languages are different?
I've never actually used the negative return value, but I've found myself constantly trying to account for it 😂. I know you probably know this already, but if you want to implement yourself, you can just use this formula ``` mod = a - a / b ^ 2 ``` where `a / b = quotient` In Go, this could be ``` func Mod(a int, b int) int { return a - a / b * b } ```
It is, but the alternative is also quite popular. I know Python and GLSL use floored division for modulo.
Oh wait nevermind. I should've tested that before I answered, that formula has the same problem. A formula that does work would be `(a + b) % b` (the normal mod operator) I implemented that [here](https://github.com/Spaceface16518/Snake/blob/89ea28c147f3aeb289bceb7a7d59f42736296db2/src/snake/arith.rs#L9) (in Rust) Another implemenation I say added an extra mod in there (`(a % b + b) % b`) but I don't know how necessary that is. Again, sorry about that.
Awesome! If you get something to work, could you let me know? If you also want any help, I can offer that too! I made a monitor using fsnotify (a la Python) a few years ago and was really disappointed when it didn't work on our cluster. This would be super useful for HPC tools.
I just tried it, but it produces the same result as the % operator; `func Mod(x, divisor int) int {` `return x - x/divisor*divisor` `}` `--- FAIL: TestMod (0.00s)` `/home/stewi/go/src/things/math_test.go:21: Mod(-1, 4) = -1; wanted 3` `/home/stewi/go/src/things/math_test.go:21: Mod(-1, -4) = -1; wanted 3` `/home/stewi/go/src/things/math_test.go:21: Mod(-2, 5) = -2; wanted 3` `FAIL` &amp;#x200B; `func Mod(x, divisor int) int {` `if divisor &lt; 0 {` `divisor = -divisor` `}` `modulo := x - x/divisor*divisor` `if modulo &lt; 0 {` `return modulo + divisor` `}` `return modulo` `}` works though
Very nice!I added ignorePrefixes flags for my project and create a PR. I’ d love to your feedback. [https://github.com/Enapiuz/multiwatch/pull/1](https://github.com/Enapiuz/multiwatch/pull/1)
Your if-statement method seems to be just as fast as [my way](https://www.reddit.com/r/golang/comments/bnvik4/modulo_in_golang/en9n0l8?utm_source=share&amp;utm_medium=web2x) (yours takes 0.30 ns/op, mine 0.29 ns/op on my machine) so you can use whichever one you want. The way I see it, the only advantage of mine would be the minuscule difference in assembly instructions, which wouldn't make much of a difference in the final binary size. That said, I do like using the mathematical way because it feels a lot cleaner. All in all, it doesn't really matter which one you chose, but I'm still partial the formula. Good luck on whatever you're trying to do though!
For starters, you can't use shared state without any kind of synchronization. In your second version `numAActual` and `numBActual` either has to be protected by a mutex or incremented with atomic operations. Second, you're not capturing any variables here. You're passing them as arguments. First version will not even work as it just passes two integers by value, the code is not doing anything.
In Go functions actually create [lexical closures](https://en.wikipedia.org/wiki/Closure_(computer_programming\)), but here it's not the issue: you're simply sharing a reference to the same region in memory in the second example, and the first example shouldn't be doing anything useful because variables are passed by value in Go. If you want to do concurrent work on the same region in memory, use locks, or else redesign the program to use channels. I'm not saying that to make you go away and make you feel like an idiot, but normally this is covered in any introduction to go.
If you’re not transforming the data how does your server add value?
have you seen select statements yet?
/u/angry_unicorn thank you! Your foundational work was essential and an incredible feat to get dicom parsing working (it's quite a spec). I'm excited to keep building on it and adding these additional features! Would welcome any advice, comments, or contributions :)
Ah yeah, that's really obvious now that you say it. I'm not sure why I didn't see what I was doing wrong, I'm usually okay with things like this. Thanks for your help! I appreciate it!
Yeah I realize what I was doing now that you say that. Sorry about that. Thanks, though! It's appreciated!
 Thank you for your comment!
&gt; it's quite a spec You can say that again. Sorry for my laziness, but without reading your code: do you do anything about Module validation? I've always found that to be the biggest challenge: keeping track of the behemoth, nearly-identical-but-subtly-different layouts of tags. That and supporting ISO-2022 encodings.
WOOO! Now it will be easier to 3d print my brain!
That there should be better optimizations done by runtime for Cgo inter operability. &amp;#x200B; I wish it was faster but I understand that there shall always be some penalty, I guess I will wait for new improvements.
wow Go is picking up. hope we also build a Python (pip) like community
[removed]
The cryptorand reader is an immutable dependency of the function - in that you should never use any other reader. I wouldn't inject it at all, just have it as a permanent dependency. &amp;#x200B; if you inject it, you also run the (vanishingly small, but present) risk that your function works fine with whatever test reader you inject, but fails when you use the cryptorand reader you want to use in production. &amp;#x200B; Is there any reason why you don't want to test using the cryptorand reader?
Does that ever actually complete? looks like you just bounce out to the top of the loop again, not sure how that's supposed to work. What I had in mind was something like the below - assuming that fsnotify closes both the error and event channels on `Close()` (I haven't read the docs to confirm), closing the watcher on signal will allow the `range` operations to complete, in turn triggering the `wg.Done()` calls, and the application will block on the `wg.Wait()` call until pending events/errors are processed: func TestExampleCode(t *testing.T) { var wg sync.WaitGroup wg.Add(2) watcher, err := fsnotify.NewWatcher() if err != nil { t.Error(err) } defer watcher.Close() err = watcher.Add(".") if err != nil { t.Error(err) } sigs := make(chan os.Signal) signal.Notify(sigs, syscall.SIGINT, syscall.SIGTERM) go func() { &lt;-sigs cerr := watcher.Close() if cerr != nil { t.Error(err) } }() go func() { for event := range watcher.Events { ... } wg.Done() }() go func() { for werr := range watcher.Errors { ... } wg.Done() }() wg.Wait() } This is untested, off the top of my head, and I don't really have time to keep workshopping this with you - you might need to do some more research or experimentation to work out how to coordinate concurrent code.
Thank you for your kind comments and your time!
Someone said they have yet to see an example of where generics could be useful and I pointed them towards how it's used within FP. It's not so black and white/binary that you are either full OOP or FP, and in practice there's a mix. The sum or min function is what I typically see mentioned in relation to Go. From your quote it falls within the expressivity part.
Ah ha. Right now the parser parses out generic \`Element\`s, that include tag, value representation, and the value. It would be nice to package the content of an element into a native Golang struct that better represents the specific tag though. To that end, I built another project while I was at Gradient Health that may be of interest: [https://github.com/gradienthealth/dicom-protos](https://github.com/gradienthealth/dicom-protos) it generates protocol buffer representations for every tag in the DICOM spec! &amp;#x200B; At some point I'd like to potentially use the above to autogenerate Golang structs that the parser can hydrate :).
actualy, the formula '''(a + b) % b''' wil give you negative outcome, if ''' a + b &lt; 0 ''' the later formula, which can be transcribed as '''((a % b) + b) % b''' will always give you positive result see https://play.golang.org/p/AyiOQnKaQti
Not really. I will dig deeper into them. Can you help me with my predicament?
I think this is faster is ` func Mod(x, d int) int { if d &lt; 0 { d = -d } x = x % d if x &lt; 0 { return x + d } return x } ` See: https://play.golang.org/p/fuPpd9IgDda
https://tour.golang.org/concurrency/5 it makes sharing stuff between two goroutines really easy
If you look into the spec https://golang.org/ref/spec#Arithmetic_operators it this operator is named 'remainder'. This is because most hardware has a specific instruction for it. If you need modulus use something like this: func mod(a, b int) int { m := a % b if a &lt; 0 &amp;&amp; b &lt; 0 { m -= b } if a &lt; 0 &amp;&amp; b &gt; 0 { m += b } return m }
Good job! I just scanned your code quickly, here some remarks on stuff I find troublesome: - You should not log in such a package: If the user of your package does not want the extra log output in addition to the returned errors she cannot turn this logging of. (If you really want to log: provide a simple interface and let user inject their logger into your package.) - Don't do glue code in your package: E.g. Take a io.Reader, not a string and let the user warp her string in a strings.NewReader. Don't work on files, let again the user handle the file and work on an io.Reader. Even do not take a URL but let the user make the HTTP request. Maybe the user is not okay with the default timeouts or the default proxy settings in which case she cannot use her own http.Client. WIth this approach you can get rid of stuff like safeClose which is not safe at all and the user can decide on how to handle this type of errors. - Don't use channels. It is the same reasoning as with the glue code above: If I want to parse a robots.txt concurently I as the user of your package will write 5 lines of glue code to start parsing in a new goroutine. Your API does not help here at all, it just makes non-concurrent use of your package more complicated. This will also get rid of the IMHO a bit strange ProtocolResult.
Wow, such awesome 🐶 It’s first PR with code to my repo 🔥 I’ll review it later today, thank you!
&gt;Gorgonia You don't need marketing, a good product sells its self however all you need - Better Documentation - Better Tutorials - A lot of real-life examples (This is actually the main selling point) Currently what you have is too high level and only a few people will appreciate it.
FWIW, if you are actually running into this problem in the future, [this FAQ answer might help](https://golang.org/doc/faq#closures_and_goroutines) :)
As the result is random, I cannot test the encrypt function deterministically and would need to test the encrypt and decrypt functions together (which I do as well). Plus I cannot simulate an error from the io.ReadFull function (i. e. EOF), leaving some code untested. I would be happy to know if these concerns are silly though!
So, I don't like this either, to be clear. But I think it can be actually justified. IMO it is a very good idea to have `x == (x / a) * a + x%a` for integer arithmetic, that is, have true euclidean division. And IMO it is a very good idea to have `x/a == -(-x/a)` - that is, rounding towards zero for integer arithmetic is a good and unconfusing choice. And yes, it is also a very good idea to have `0 &lt;= x%a &amp;&amp; x%a &lt; a`. Unfortunately, you can't have all three of these very good ideas. You either have to round towards negative infinity, or you have to give up true euclidean division or you have to give up a clear range for remainders. There is no *correct* decision here - you have to die at least one death. It turns out Go chose to go along with the decision of most hardware designers, which I find very defensible :) Arguably, the world would be better if we could collectively accept rounding towards negative infinity, but oh well.
Addendum: Interestingly, python chose to have two operators for division - `/` for rational numbers and `//` for integer-division. `//` actually divides towards negative infinity. I think that's a decent way to side-step the confusion. Arguably, it works better in a untyped language though. `/` has different input and output types, which isn't ideal. And to be precise, it would need high-precision rationals as a type. It's possible to do, but it does require some extra complexity to spec out. There are probably interesting ways to solve this in a more powerful type-system though 🤔
I would not make `Article` know about `ArticleRepo` or `AuthorRepo`. That looks like an unnecessary complication. `Article` and `Author` might reasonably be DTOs or maybe they have domain logic but they should not know how to save themselves, draw themselves, convert themselves to xml, yaml, json, protobuf, etc. (I'd be slightly flexible around field attributes to _enable_ the serialization, but no more than that) If a web handler (for example) needs to find an `Author` then the handler has a dependency on the `AuthorRepo`, not on the `Author`
 p := reflect.New(reflect.TypeOf(v)) p.Elem().Set(reflect.ValueOf(v)) return p.Interface()
In this case you are missing things in your model as @nearly_adam mentioned. As a starter, there's some "higher-level concept" that encompasses these articles. For now, let's call it a "blog" (it might be CMS, just "Articles" or whichever seems more appropriate). package blog import ( "your.project/article" "your.project/author" ) type Articles interface { Draft(...) error Publish(...) error Get(id article.ID) (*article.Full, error) List() ([]*article.Short, error) } type Authors interface { Register() Get(id author.ID) (*author.Full, error) List() ([]*author.Short, error) } type Blog struct { articles Articles authors Authors } func (blog *Blog) Draft(...) error {} func (blog *Blog) Publish(...) error {} func (blog *Blog) Update(...) error {}
are you perhaps looking for reflect.(Value).Addr()? [https://golang.org/pkg/reflect/#Value.Addr](https://golang.org/pkg/reflect/#Value.Addr)
I think you're talk about anemic domain mode? Article not know how to save themselves and just know when to save, because ArticleRepo is a interface, i use interface to isolate entities and repositories.
I know that anemic domain mode style, ArticleService -&gt; ArticleRepo -&gt; ArticleModel. I'm wondering how to implement rich domain model in golang
I've used this one since I dunno when, long ago. From memory, might even be right. &amp;#x200B; \`\`\` func Mod(x, d int) int { rem := x % d if rem &lt; 0 { rem += d } return rem } \`\`\`
Articles might know how to serialize themselves to an arbitrary io.Writer, but they shouldn't have any knowledge about the repo they get saved to.
not silly, as long as you have some action you can take once you detect that those are errors... I'm not sure what would cause an error from the io.ReadFull function, but if one happened, would you do anything about it (apart from throwing the error back to the caller)? If so, test away... if not... what's the point?
Addr doesn't work in this case. To be honest, I have no idea where it does actually work. Supposedly, with elements in slices or struct fields or something.
Thanks, that's what I was missing. The 'Elem' method is the key
Nice- that’s useful
Looks good. My only critique is that an interface name should describe what it does, e.g. `RobotsExcluder` or something to that effect.
😀I spent hours in frustration, stuck trying to get CGO and cross compilation to work. GoReleaser is a good tool and hopefully helps people with that extra requirement without getting stuck like I did.
&gt; Who uses the negative return values in the real world? who passes negative arguments to `math.Mod` in the real world?
Anyone dealing with coordinates. Negative values are common, and modulo is the desired behaviour in this case, not negatives.
It depends on the caller. The error is indeed very unlikely to happen, but it must be there for a reason. The caller could try again or continue without encrypting for example. But there is still the random result in the unit test so I cannot test the function alone.
Kotlin or Groovy are much easier sells to a Java shop....
&gt;understandable by people with various level of experience - check. Sure there are frameworks which do "magic" - some help the unfamiliar with understanding, some make it harder I was with you until this one. Java code from long developed big codebases is impossible to read by a beginner. There are custom annotations and introspection tricks that make the code work **exactly** like magic.
Great! I'll read it! .. thanks for sharing.
[removed]
Positive modulo function, with less comparations ;) ``` // Positive modulo, returns non negative solution to x % d func pmod(x, d int) int { x = x % d if x &gt;= 0 { return x } if b &lt; 0 { return x - b } return x + b } ```
Thanks, I'd be really interested to hear what you think and if its useful for you, or how this could be improved. 😄
this fails (produces negative outcome) if `x &lt; 0 &amp;&amp; d &lt; 0`
Thank you for the feedback, I think a lot of what you said makes a lot of sense. I especially like the idea of not accepting a channel and letting the user of the package worry about concurrency as they could just wrap my function with their own concurrent function. I just have some follow up questions. &gt; Don't work on files, let again the user handle the file and work on an io.Reader and &gt; Even do not take a URL but let the user make the HTTP request. `NewFromFile` and `NewFromURL` is really just meant to be a convenience for the user so they don't have to worry about file handling and HTTP requests. Are you recommending not to do this type of convenience for the user? Do you think it would be instead okay to accept an http.Client as well as a URL so that I could respect their timeouts etc...? I push to keep methods like this for a couple of reasons 1. The spec itself has some opinions on where the robots.txt file should exist and it says it should exist at the root of the domain. The `NewFromURL` method enforces that we only check the root level for the robots.txt file even if they entered a nested url like https://www.dumpsters.com/test/robots.txt. It also has some opinions on how to handle HTTP response status codes which I would like to handle for the user. Do you think maybe a `NewFromResponse` method would be better and it could take an http.Response?
It does a little more work than checking whether or not a Robot is being excluded from a page or not. It also returns things like the crawl delay and links to the sitemaps. Do you think a name like `RobotProtocol` or just `Protocol` makes sense? Especially since it's already being used in a package named `robotstxt` so the usage would be `robotstxt.Protocol`.
Yes, I would be interested :-)
From what I remember, ResponseRecorder is a very expensive wrapping structure. Often used to easily tie response codes to certain clients (Request IDs) so you can spot issues or attacks.
I am using CGO and GoReleaser. Everything works well except I can't cross-compile for Windows. I have to build my Win10 version on Windows and then manually upload the .exe to my Github release page. Would your solution work for me? If you have time, see the section called "Windows compilation" in my README.md file. https://github.com/jftuga/timeshift/ Thanks.
My apologies, I assumed without looking at things that we were using the [image](https://golang.org/pkg/image/) library. I think logically I just assumed that we wouldn't be talking about a random third-party library, because I mean, why wouldn't that have weird bugs in it? Whoops.
yes, a little, not very i think, actually we opened it in the test environment or when we need to spot issues. Is there any cheaper way? If so, please let me know.
Nothing's wrong. That's how \[\]byte is written by fmt.Print. Trying wrapping a string() around the \[\]byte type and you'll get what you expect. Don't forget about the fact that ReadBytes will leave the delimiter on the end, too, and I think strconv.Atoi will be offended by that.
To be concrete /u/liguangsheng, one of the things Go makes very easy is composing types together, and I've had a lot of good experiences making sure I separate things properly. You can have an `Article` type that has no reference to any repository or anything like that. You can easily have a `Repository` type that knows how to store articles (or possibly, more generically, store things in general). Then it's really cheap and easy to have a type ArticleRepository { Article Repository } that just composes the two things together when you need them. Any method on an "ArticleRepository" that only references an Article or a Repository should be moved to be a method on the relevant object. Any function that takes an "ArticleRepository" but never references the Repository should be rewritten to take an Article, etc. If you want to be a bit lazy, you can define type ArticleThing interface { Article() Article } and then add as a method to Article func (a Article) Article() Article { return a } which by method embedding means that anything that embeds an Article can be passed to anything that takes an ArticleThing. Though I'd say at least try to stick to the concrete types for a bit to see how it plays out; this approach is locally convenient, but it starts to get pretty magical if used pervasively.
Large interfaces are not idiomatic. Interfaces in Go tend to be focused around a single action, see io.Reader. Interfaces may not be appropriate here, especially if there is no need to interact with other structs that do the same thing. I'd advise just returning a pointer to a struct.
A simple function that takes the response code and request object (and/or context) can log the value while setting the response code without needing to actually use ResponseRecorder. Recording response size is a bit harder and requires counting each `.Write()` worth of bytes.
Introduce a service layer and expose the db operations in an interface. &amp;#x200B; Article (Model) ArticleRepo(Interface) ArticleRepoImpl (mysql implementation) ArticleService (Inject ArticleRepo).
That looks more like function overriding. Overloading is when you have the same function name with different arguments. eg: func Greet(int) and func Greet(string)
This is relevant: [https://github.com/golang/go/issues/6853](https://github.com/golang/go/issues/6853)
You know what, you're totally right. I misread the original comment. :-/
This is an interesting design question to think about. I have to say I think the architecture you are trying to describe does sound a little confusing. I'm trying to hold the shape of it in my head to try and see the benefit but I'm not sure I can quite see it. I'm not hugely familiar with this concept of an "anaemic domain model" but it feels a little like the worst thing about it is the name. Perhaps another way of thinking about it would be something like "a clean separation of concerns between database persistence and business logic"; whereas a "rich domain model" as I think you're describing might be pejoratively called "lasagna code" which wikipedia tells me is: &gt;"code whose layers are so complicated and intertwined that making a change in one layer would necessitate changes in all other layers" Perhaps you are conflating two things - there is business or application core logic which perhaps should live in your Article or Author types (making them non-anaemic), but it feels to me that is different from code which is all about persisting or reading state for those objects from some data store.
$0.02, lots of the same feedback as /u/drvd: * I expect \`NewFromURL\` to return an object based on the name * \`NewFromUrl\` does not appear to be a convenience function, as it uses un-exported functionality that the consumer would have to recreate (url transformation) * You want to be able to override and control the http client to set things like metrics, circuit breakers, timeouts, proxies and whatever other application specific setup you might need. * New should really just use an io.Reader as mentioned, so that you can pass in whatever. You shouldn't have to read the whole thing then convert to string, just to convert to bytes and wrap with a reader again. * You could probably follow the recommendation of returning structs and accepting interfaces. I don't see that much value in the interface you provide since the best place for an interface is with the consumer of an API. * You might want to return a robotsTxt pointer, in case you ever wanted to modify it * If you're going to log in a package, you should accept a logger. Even better to accept a logger per call.
I definitely agree that interfaces are generally focused on a single action. I guess I was going with [this](https://golang.org/doc/effective_go.html#generality), which says &gt; If a type exists only to implement an interface and will never have exported methods beyond that interface, there is no need to export the type itself. Exporting just the interface makes it clear the value has no interesting behavior beyond what is described in the interface. It also avoids the need to repeat the documentation on every instance of a common method. What do you think of this?
Thank you! I definitely like the advice of accepting an io.Reader instead of a string in the `New` method. It does make a lot of sense to make `NewFromURL` and `NewFromFile` return the interface and remove the channels from those methods. A couple of follow up questions if you don't mind &gt; You might want to return a robotsTxt pointer, in case you ever wanted to modify it Is this a common practice to preemptively make things pointers? Could you point to some article or documentation? I think it does make sense, since you don't want to have to break your package and bump up a major semver version if you did later want to make it a pointer. &gt; You could probably follow the recommendation of returning structs and accepting interfaces. I don't see that much value in the interface you provide since the best place for an interface is with the consumer of an API. I posted above responding to /u/BOSS_OF_THE_INTERNET that some of the Go docs says to just return the interface if the struct doesn't do anything extra, that can be found [here](https://golang.org/doc/effective_go.html#generality). What do you think of this? &gt; `NewFromUrl` does not appear to be a convenience function, as it uses un-exported functionality that the consumer would have to recreate (url transformation) I guess I don't understand this comment, if I'm saving the user from doing things themselves then isn't this a convenience to them? Again thank you for taking the time to look through this!
There's no point having an interface with just one implementation.
You are not wrong. It does give me the flexibility to change the implementation later on though without making a breaking semver change though if I chose to reimplement the interface another way. What do you think?
YAGNI
&gt; Yagni only applies to capabilities built into the software to support a presumptive feature, it does not apply to effort to make the software easier to modify &gt; If you do something for a future need that doesn't actually increase the complexity of the software, then there's no reason to invoke yagni. from [Martin Fowler's website](https://martinfowler.com/bliki/Yagni.html) I don't know really, I'm not sure if 1 interface is increased complexity. If it is then I would want to know of an example of a change that doesn't increase complexity but is also considered "future planning". I do think the interface applies very much to the first point though, since if I just return the struct and then later decide I want to implement it differently then I'm almost guaranteed to have to bump up a major semver version. I'll have to give this some more thought as I'm not totally sold one way or another, thank you for your input!
Hey /r/golang &amp;#x200B; If you are new to WebRTC it is a really amazing technology, and lots of powerful things can be built with it. It isn't just a technology for conferencing, you can build powerful P2P software that works on all platforms (including your browser!) &amp;#x200B; You can see it in use in places like [IPFS](https://github.com/libp2p/go-libp2p-webrtc-direct) so come check out the [examples](https://github.com/pion/webrtc/tree/master/examples) and build something cool. &amp;#x200B; We also would love to chat! You can find us on [Slack](https://pion.ly/slack), while this channel was started for Pion there is a lot of interesting general WebRTC conversation going on. \---- I am excited to announce that v2.0.\* has officially landed and stabilized! Multiple large production users have migrated to it and we fixed all the bugs we found along the way. This was a really big release, you can see the full release notes [here](https://pion.ly/knowledge-base/release-notes/webrtc-v2.0.0/) here are some exciting parts though. * Unified Plan and Plan-B support * QUIC Support * WebAssembly Support * ICE Regular Nomination (better support for NATs) * Massive SCTP performance and reliability improvements * API Cleanup to better match the WebRTC Spec We are also starting work on v2.1.\* which so far will include the following. If you have a feature that you think is important we would love to hear! * TURN Support * User configurable JitterBuffer * Re-negotiation (allow multiple Offer/Answer)
Nice, even included a [streaming-to-disk example](https://github.com/pion/webrtc/blob/master/examples/save-to-disk).
@William Kennedy, thanks for your awesome articles. &amp;#x200B; Can someone please explain why the strings.ToLower() functions (Listing 12, line 119) are allocating on the heap and not the stack? It seems this is being called and used only locally inside a function. But, the author says, "The calls to strings.ToLower are creating allocations since they create new strings which will need to allocate on the heap." Any help understanding this better would be appreciated.
I loved these https://gobyexample.com/ https://quii.gitbook.io/learn-go-with-tests/
If you look internally at the [implementation of ToLower](https://golang.org/src/strings/strings.go?s=14318:14347#L574) it has to create a new string builder and then append characters to it, then return the resulting string. That means ToLower needs to return a thing that has a pointer to a dynamically sized buffer, so it must be heap allocated. If ToLower were just mutating the input string then it may be possible to avoid any heap allocations.
@barfoob, thanks... makes sense.
@barfoob, just be clear. Here is a function foo(). a contains a string that is allocated on the stack, correct? From what I understand what you are saying, b contains a string that is allocated on the heap, correct? func foo() { a := "FOO" b := strings.ToLower(a) fmt.Println(a, b) }
You say that .. Years ago I worked for a medical company that made 3D-rendering of DICOM data. I'd almost forgotten everything I learned, but then I moved to Finland and got my brain-scanned as part of some medical diagnosis. &amp;#x200B; At the time I was getting scanned I was talking to the person responsible, and she said "Oh, if you like you can buy a CD-ROM of your data .. it belongs to you, after all". I paid my €25 and received a CD-ROM in the mail, a few weeks later. I now possess a reasonable awareness of DICOM, and a set of data referring to my own brain. (Or at least the blood vessels within my own brain.) &amp;#x200B; Funny how things turn out!
 func Reconnect() (*gorm.DB, error) { var tempdb *gorm.DB var err error err = retry.Do(func() error { tempdb, err = connectDB(connectionString) return err }, retry.Attempts(8), retry.Delay(3*time.Second), retry.LastErrorOnly(true), ) return tempdb, err }
It should do, although I would suggest giving it a test. It includes libraries from [mingw-w64](https://mingw-w64.org/doku.php) including 64bit support, which is different from [tdm64-gcc](http://tdm-gcc.tdragon.net/) from what I can see though it should be compatible. The configuration of .goreleaser.yml is slightly differnt see [this example](https://github.com/mailchain/mailchain/blob/37722c30df485d477945dabc562036e369ea69e4/.goreleaser.yml) and note the env settings. ``` env: - CGO_ENABLED=1 - CC=x86_64-w64-mingw32-gcc - CXX=x86_64-w64-mingw32-g++ ``` Please give it a try and if it doesn't I can add tdm64-gcc the library to the docker file.
Simple, Strongly Typed, Performant, with an experienced community of developers building big, distributed systems. Not a scripting language.
It's the sum of the parts; the creators took a lot of old, good ideas and made a new, reasonably orthogonal language.
&gt; If [assembly] is good enough for Google, it should be good enough for me. Well, just because large companies do something, doesn't mean it's the best process for individuals. Behind in your comment is the real answer: Go has good features and ideas that not only work for solo developers - but also large companies. Those are the points that should be spelled out here for people pitching Go to their company.
Cross compile (eg build linux binary from macOS) very small artefact, I like node where node_modules is like 50-100mbyte, fast start up time in aws lambda, strongly typed, reasonably large community support. Standard lib that comes with many things like http, network, unit tests, imagine building without npm with nodejs, golang that’s normal. Great memory handlers, yes you can still build a code with mem leak but you can actually profile it, try that with ruby(puma!) or node. It is not script language but you can run like one too!
Easy to learn, easy to read other people's code. Native, static executables. Fast compile times. Low latency GC. Easy to fire up 'threads'. Data race detection tool useful for finding mistakes. Any type can be a value or reference type. (vs Java where there is only reference types, or C# where you have to decide ahead of time what the type is class/struct) &amp;#x200B; Reasons \*not\* to use Go: Low throughput GC, compiler not as great at optimizing as some others, lack of language features sometimes increases verbosity, slow interop with other languages. No manual control of stack vs heap allocation.
Strip denugging info
Glad you found it helpful :) &amp;#x200B; If examples of anything else would be useful would love to add them also!
I don't think that your string `a` is necessarily allocated on the stack. The Go spec makes no mention of "stack" or "heap," so it appears to be an implementation detail. I'm not very familiar with the intrinsics of the Go compiler, but if this were C, then `a` would be found in a read-only data area rather than the stack or heap, since it is known at compile-time. And if you wanted to mutate it, you would typically memcpy it to an allocated chunk of memory on the heap.
Advantages in my opinion are mainly focused around organisations of people: \- Quick to learn: Easier to put non-Go devs on Go projects, easier to hire any variant of dev and have them learn Go on the job (provided the people are willing, given its a relatively small amount of effort to learn I expect that would help). Coming from say C you won't hit much in the way of profoundly new or difficult concepts that will slow down the learning process. \- Simple, verbose style: Less of a barrier to contributing to a new codebase, makes shuffling people between projects less wasteful As to the advantages for an individual, I'm going to say that depends on your personality and experiences. Some hate it, some love it. Any specific attribute of Go - simplicity, performance, etc - is done better by something else - but the mix of trade offs Go wraps together - that's the personal taste bit.
Your robotsTxt object is a fairly complex object with methods. The moment you get much beyond a small POD object, I tend to prefer pointers because if you forget that you're copying the object every time you pass it around you could end up with some strange behaviour. This gets even worse if you ever need a mutex on it. Making it a pointer after a certain point simply avoids some gotchas. &amp;#x200B; Your link makes good points, but I still avoid it. One reason is that it's premature generality, and isn't really improving any usability of your package yet. Generally speaking, your robots.txt is just a data-structure representing that information, and there's very little coupling needed to the function that creates it. Making it an exported structure would allow others to write new ways of populating it if they wanted, or ways of building and saving it etc. &amp;#x200B; With NewFromUrl, I'd suggest a \`UrlToRobotsUrl\` function that you expose. At that point, NewFromUrl is actually a convenience, but at the moment the functionality in \`UrlToRobotsUrl\` is effectively hidden inside of \`NewFromUrl\`.
My interpretation of that passage is that it applies to interfaces that already exist for other reasons (generally multiple non-test implementations). You seem to have mis-interpreted it as a recommendation to create an interface solely for this purpose. I assure you, the general rule of thumb is accepting interfaces and returning concrete structs. If this passage was intended to suggest that you should create and return interfaces instead of structs, it would have just said so.
Honestly, I'd like to see someone flesh out a simple broadcasting demo where a single client's webrtc stream is converted to an HLS feed delivered over a CDN. Sure, you could use a flash client or custom desktop software to record a stream to https://github.com/arut/nginx-rtmp-module, - but WebRTC from any laptop or phone would be pretty handy. If I only had more time I might look at adding a record feature to https://github.com/strukturag/spreed-webrtc
Because its a better enough C for some problems (https://github.com/codr7/g-fu/tree/master/v1) where garbage collection, concurrency and a solid standard library are worth more than total control.
That would be amazing! &amp;#x200B; If you are interested I would love to work on building that together, if you released it as Open Source people would go crazy for that. I don't know HTTP streaming that much (HLS vs DASH) but if you got an MVP together and put it on HN/reddit you would really see it take off :)
It doesn't get in my way when I'm trying to code.
if you're trying to tag users on reddit, write it as /u/Belred1 instead of using an "@" sign. They'll get a message that their name was mentioned in the comment.
- The typing is strong enough for code completion. - Less magic than Ruby. When I want to know how an identifier works, I know where in the docs to look it up. - Go generates self-contained binaries so I can deploy without dealing with dependencies on the computer that’s actually running the program.
What a super awesome book. I'm buying this to support your work. Kudos brah.
What does low throughput GC means?
garbage collection algorithms can be tuned to keep pause times shorter (latency) at the expense of total garbage that can be collected over then long term. (throughput) so all else being equal, a web site done in go may have lower worst case response times since the gc never pauses for very long, but be able to handle less requests per hour. how that math works out depends on lots of things, and all else is never equal. but low latency gc can be nice in many scenarios.
Real native static binaries that don't even need C lib and can even run on bare metal! Go is compiled with Go, no OpenSSL or any C lib needed, everything is clean and pure. Python, for example, looks clean and pretty, but under the hood is chaos and it links to many C libs.
It’s a lot of what I love about Python, with a focus on high performance and really accessible, easy to grok tools for concurrency.
CPU performance Goroutines Low latency GC Ease of deployment Memory usage
Brad Fitzpatrick said it best. It gets you 80% there, with 20% of the overhead complexity.
In alternative to Go, V language looks promising with fast compilation speed and could offer smaller file size than compiled app in Go even after binary stripped, perhaps less memory too. The author even claims there is no Garbage Collection in V.
As I understand it, Go strings are immutable so it has to be reallocated.
C's power and Python's ease of use.
If I look at grpc dashboard, it seems that may not be the case, unless I misinterpreted the graph. Do you mean in general this is true? Go's GC is a non compacting generational GC. What I did notice from perf dashboard on grpc is that Go was at times better than Java for throughput but there is a CPU penalty. Is that considered bad in general? What are the tradeoffs taken by common GC implementations.
Why did I not think of that? :/ It doesn't even require typecasting. Thanks for enlightening me!
Thanks for taking the time to look into this. I really appreciate it.
Easy to learn and read a code, and fast compile time, easy to use a concurrency logic.
Actually, I found better tools such as `gin`, `reflex` since I started to build this tool. But, I kept building for my study and personal use for myself. I'd like to share it if anyone might need to use in case of building a backend API. Hopefully, I may have a code review or bug reports in my codes, that would be much grateful. And also, it might be a little contribution in open source ecosystem.
I do not need Google when I write Go code.
 [https://github.com/globalsign/mgo](https://github.com/globalsign/mgo) [https://github.com/mongodb/mongo-go-driver](https://github.com/mongodb/mongo-go-driver)
\- You can read the entire spec in an afternoon. \- Features are added slowly and with care \- Idioms are pervasive and lead to very maintainable code \- Bare metal performance when you need it
This is definitely still very rough around the edges, so any feedback would be much appreciated! It's heavily inspired by \[deno.land's continuous benchmarks\](https://deno.land/benchmarks.html). The \`gobenchdata\` CLI basically exists to parse output from \`go test -bench\` from a pipe and manage JSON records of past runs, and the \[GitHub Action\](https://github.com/marketplace/actions/gobenchdata-to-gh-pages) helps automate benchmark runs and updates to \`gh-pages\`. You can then use \`gobenchdata-web\` to quickly generate a simple, customizable web app that will chart past benchmark runs! Some examples: \* https://gobenchdata.bobheadxi.dev/ \* https://zapx.bobheadxi.dev/
Naturally compatible with Docker.
Super Graph is an instant GraphQL API service. It converts your GraphQL query into a single efficient SQL one. This new feature allows you to also query remote REST APIs and combine the result into the JSON generated from the SQL query. For example if you want to fetch users and the stripe payment related to them in a single call you can do that now.
I mean technically you do...
Yet Go is the one of the few languages that you *do* need Google for.
As a non-professional developer (more SRE/Sysadmin) my reasoning is rather pragmatic. We use a lot of stuff that is already written in Go (Docker, Kubernetes, Prometheus, etc...) so to be able to fully participate in the ecosystem it surely doesn’t hurt to learn Go and write automation and API stuff in Go just to gain experience.
Because it is the first programming language designed with maintainability in mind. And we all know maintaining code is 90% of the work.
Sensibility.
Yeah but testing "return nil, err" is kinda pointless. I know it's a code path, and not testing it will reduce your coverage from 100%, but I'd trust the compiler to pick up any problems with this.
Concurrent, open source, vibrant community, easy to start, powerful.
I think that is referring to a case where I have interface Foo and some struct Bar that implements Foo. The point is that it's fine to make Bar --&gt; bar and not export it to avoid having to document all of bar. My point is more along the lines of: why have an interface at all? In general, accept interfaces and return structs. There are times when you want to avoid that, but it's generally good practice. Let's say you add a String() method. Now your struct automagically implements the Stringer interface, but you'll have embed Stringer in the interface you are currently returning to use it, whereas if you return the struct, the caller gets Stringer for free.
&gt;it's quite a spec yeaaap \*bangs head\* \*bangs head\*
How does this compare to grailbio go-dicom?
Quite easy to learn, faster than languages we've used before, backup from a large company and yet open source. will be the next enterprise programming language and evolving always into the best of breeds
Memory is managed at compilation time, it free a variable when there is no use for it
All strings are allocated on the heap since they are dynamic. The FOO string is hardcoded in the compiled binary so it's neither on the stack or the heap.
it’s cheaper but also a little bit cumbersome i think. Sometimes we just want to see what happened underlying without the man-madefactors.
"How did you say those brackets out loud"
because moonies
I don't think the comparison is fare. You're comparing two cases - with allocations and without allocations. Everytime `byReference` is called a new instance is allocated. If you want to compare passing by value or by reference then do something like this instead func use(s *S) { if s.a &gt; 1 { panic("123") } } func BenchmarkMemoryStack(b *testing.B) { var s S = byCopy() for i := 0; i &lt; b.N; i++ { use(&amp;s) } b.StopTimer() _ = fmt.Sprintf("%v", s.a) } func BenchmarkMemoryHeap(b *testing.B) { var s *S = byReference() for i := 0; i &lt; b.N; i++ { use(s) } b.StopTimer() _ = fmt.Sprintf("%v", s.a) } Now passing by reference will be faster by a slight amount. But it's not that simple. These kind of benchmarks are often misleading. For modern CPUs cache locality is VERY important for achieving high performance. That means that often it's much faster to copy something or to use, for example, arrays instead of linked lists even when common sense tells you the opposite. More references means more cache misses which are very expensive. But modern CPUs are also very complex and you can't reason about things like this without concrete data. In some cases CPU will cache everything properly or predict access patterns. In others cache misses will destroy the performance. You have to benchmark actual code.
I frequently have to work with clients C# code where someone has gone to town with the abstraction (even for simple things like reading a file into a DB). To the point where you try and follow the code for ages but at no point can you find any code that actually does anything. It was then I decided that Inheritance can actually be a bad thing when in the wrong hands. I personally find the lack of inheritance in Go a big plus because the code is much easier to follow with less "magic" that can creep in with some other languages. I'm finding that Javascript is the latest where people try and be overly clever with functional programming and try and boil down a thousand different things into one statement. Very clever I'm sure but just isn't as readable for someone a year on as breaking it down into logical steps.
&gt; In general term, the sole purpose of the Service function would be to return a list of ip-addresses and ports for the specific service that the client will look for. then do that?
Great syntax, tooling and community. Im still in school but I wish I would have had my intro to programming class in Go rather than C++.
What?
https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html This is how it is done in Rust
When I say "examples", I of course mean in the language we're talking about. When I say "that makes no sense", I mean that your post implied the language has compile-time memory checks but still uses a garbage collector for some reason. That's what I wanted examples of.
Well, your post said "what?" When I replied. anyway, there is no garbage collector in V but it is said in the documentation that the user is expected to manage the memory for the moment and will be fixed soon
Because for the kind of work I do, it's the least-badly fit tool for the job.
JS has feelings too :/
Each app gets its own set of databasesh/caches/queues etc. If you want security and safety don't share things
I'd suggest type RunFunc func(ctx context.Context, arg string) (error) If only because the context lets you temporally or manually kill it, and the error signals the higher layers if it "worked" or not.
agreed, I'll get on it.
- It combines C-like performance with the simplicity of a scripting language. - Building/deployment is easier than pretty much anything else. - The standard library is fantastic. Comprehensive and without the nasty, crufty '90s APIs you see in the Python stdlib, for example. - The support for concurrency/parallelism is absolutely first-rate. It combines the best of async (more concurrency than you can shake a stick at) with the best of threading (actual parallelism).
&gt; It’s a lot of what I love about Python At this point in time, I'd say Go fits the [Zen of Python](https://www.python.org/dev/peps/pep-0020/#the-zen-of-python) better than Python itself does…
Check [https://gokit.io/](https://gokit.io/)
&gt; To the point where you try and follow the code for ages but at no point can you find any code that actually does anything. I can't C# to save my life, but I had to read through Sonarr's source to generate an RSS feed it would understand. The abstraction is absolutely ridiculous. For every line of code that actually did something, there were 20+ lines of wrapper nonsense. After finding an entry point, I had to drill down through 4 or 5 levels of abstraction until I found the code that was actually doing stuff. &gt; I'm finding that Javascript is the latest where people try and be overly clever with functional programming and try and boil down a thousand different things into one statement. This, too. It's like SLOC are a limited resource or something. If you're writing 5 lines of code that take 20 minutes to understand instead of 20 lines that take 5 minutes to grok, you're an arsehole. I sincerely hope I never have to touch your code. I am a very big fan of languages like Go and Python that deliberately make it difficult to write code like that.
I used Revel for my first Go project, which had a lot baked in and was easy to pick up. Now I'm using [https://github.com/go-chi/chi](https://github.com/go-chi/chi), and for what I'm doing (web APIs), I can't imagine using anything else.
Thanks! It's very cool!
Yes: Hyperledger Fabric. No: Rust exists.
go chi also, because is the most minimalist one I found, I tried gin and other, but felt bloated.
it looks very conceptual, like what we find in java world. Worth looking at, because I tend to think it should help maintainability.
&gt;Revel -&gt; [https://revel.github.io/tutorial/index.html](https://revel.github.io/tutorial/index.html) Both looks easy to understand. Chi is definetely close to Slim/PHP. Thanks.
It's perfectly okay to have the convenience functions, but you should also provide a functions that read from an io.Reader. That way, your package will be way more useful, because it will allow parsing the files from all kinds of sources with easy. Good job, though :)