I just wanted to chime in, and say thank you for both of your perspectives and your respectful debate. I've played with Erlang quite a bit and have found an appreciation for it. That said, I'm writing my thesis in Go and having a blast.
Good point, thanks - I'll try that out; might make the code significantly shorter actually.
Tigertonic is nice, sure, but as it says right at the top of the README: *"If HTML is your game, this will hurt a little."* Go's standard library is fantastic, but it's also intentionally minimalistic: it does what it needs to do to suit the "obvious cases", and acts as a great foundation for anything more complex. Using it to say "well the standard library doesn't do it this way, so you shouldn't" isn't a genuine reason to not do it (provided it's clean and well documented).
You might already be aware of this, but there is a small trick that will bring the annoyance down to 2 + n, rather than 3n functions. The sort package gives a concrete example: http://tip.golang.org/pkg/sort/#example__sortWrapper
Try https://github.com/mattn/twty it's pretty small twitter client. 
&gt; The answer is not to use reflection but to define interfaces that expose what you need instead I think this probably needs to be more strongly emphasised in the community generally. I think dynamic languages have somewhat spoilt/untaught people to think about their interfaces and implementations separately, and it's kind of refreshing to go back to how I started out initially (in the Java days).
Yes, it requires an external lib to work. Apple doesn't offer access to the "sandboxed" API otherwise. But from a Go package perspective it makes no difference.
The snarky words were Francesc Campoy's tweet linking to his repo :/
Would it be possible to use the API directly from the Go program using cgo and objc_msgSend()?
I was excited to watch this, however the audio and video quality (inability to read the slides) made me turn it off and look elsewhere for information on profiling Go. I know cloudfare has made a lot of slides on Go available publicly, I hope these can be found as well.
Isn't the easiest slice declaration just: var foo []int ? I mean, if you're not planning to allocate anything right away.
You can add any arbitrary arguments in your function signature and Martini will either populate it or panic if it cant. Easy right? :)
Cortesi! He's the guy who did the awesome [spatial sorting visualizations](http://sortvis.org/).
I have been helping my dad with his customer database. He needed a way to export invoice data to send to his vendors. It uses Access. So when I saw mdb I immediately thought it was for reading those kinds of files. Cheers!
Very cool! Can I add extra services that martini will inject?
Yup! Check out the project readme for more info 
I see now, that's awesome. Thanks!
Update 11/26/2013 - 9:13pm The package has been updated such that there is no longer any external dependancies. The terminal-notifier bundle which handles posting notifications to OSX is now EMBEDDED into the Go source files.
The link is broken: http://owenou.com/2013/11/27/writing-build-tasks-in-go-with-gotask.html
Weird, I missed these as well. Thanks for linking them.
&gt;Once “go background” is working well, a possible extension would be to add -watch flag to “go test,” “go install,” and “go run,” which would repeat the command each time a prerequisite file was modified. For example, running “go test -watch” in a terminal window would automatically show compile errors or test output each time a source file was saved. Sounds useful.
Most of the community hangs in the Plan9 mailing list. I wrote a post about plumbing, you can read it [here](http://www.mostlymaths.net/2013/04/just-as-mario-using-plan9-plumber.html) (heavy Mac OS focus, but should work anywhere). I also detailed some ways to extend acme with scripts (using the 9p file system, i.e. the way Plan9 does it, but with Plan9Ports) you can find it [here](http://www.mostlymaths.net/2013/03/extensibility-programming-acme-text-editor.html). Just this morning I asked the mod community in reddit to hand me /r/acme which is currently without moderators, or content. If I get it I'll try to get it to be the hub of acme content (I have tons of links with more plumbing, tips and tricks and Edit scriptlets)
In the other document: &gt; The linker is one of the slowest parts of building and running a typical Go program. And here: &gt; After the linker, one of the slowest parts of building a Go program is looking at the sources to see what needs to be recompiled. The go command should take advantage of OS-level file system notifications to speed incremental builds. I guess the Go devs have managed to avoid writing C++ code for so long that the "slow" Go build speeds are starting to annoy them?
What is a Linker? anyone got a wiki page for a noob?
http://en.wikipedia.org/wiki/Linker_(computing)
Someone went to last night's meetup eh?
That actually saves me a shit ton of time. 
Thanks for this! It made me rethink the way I was structuring my webapp. It also seems like the website went down... Could someone link me to the example's source repo?
currently site doesn't work :/
Yeah, first world problems of developers :) It's so freaking fast it's funny that people refer to it as slow.
Where is the compiler itself? http://atom-symbol.rhcloud.com/p/tul gives 404. 
If the site is down, you can read more about martini [here](https://github.com/codegangsta/martini). It looks pretty cool I have to say.
ld.gold? no? Thats exactly the problem it solves... Ian the author of gccgo wrote ld.gold too.
I know you're kidding, but this is a **serious** problem. Imagine this sequence of events: * I auto-run `go install` when I save a file * Compile errors are highlighted in the source * I have to wait to see if there was an issue It only takes 500ms, but I notice this. every time I have to *endure* this wait I get a little annoyed. I start to lose momentum, because this annoyance is distracting. Before long I'm on Reddit trying to relieve the pressure. And then it's go-home-time, or movie-time. Almost the whole day wasted.
Site is back up, sorry about that, it was nighttime here.
I think that using something like Google Cloud Endpoints is the right way to build REST interfaces. It saves everyone the hassle of having to then write all of the boiler plate code to figure out the types, unmarshal them and handle errors. See https://github.com/rwl/endpoints/
/p/tul has been updated with a notice that explains the situation a bit.
[Go 1.2 Release Notes](http://golang.org/doc/go1.2) I'm already looking forward to 1.3 though, the changes to the toolset sound promising.
From /u/rsc on /r/programming: &gt; Actually, it has not been released yet. We've tagged what we believe will be Go 1.2. There are still two days for that to change. :-)
This looks really similar to martini; maybe you guys can join forces? http://martini.codegangsta.io/
could you clarify what you mean by "implement gorm"? It doesn't look there's any magic involved in using the two in the same app. They cover different areas.
&gt; man, new golang web frameworks are a dime a dozen these days I guess web frameworks are the Go equivalent of "hello, world", followed by assertion-based testing frameworks and dependency managers.
That code review is hilarious.
Some/many of Google's projects require a "LGTM" from a committer/project member before committing to the master branch is allowed. So it's cute--but not as much as it seems :)
good stuff.. One annoyance is the HUGE banner at the top..
Awesome talk, thanks!
This would seem like a reasonable complaint if the banner stayed in position no matter where you scrolled, but this banner disappears as you scroll down. edit: it is gratuitously big
I have been actually thinking of a "cloud compiler" for quite some time. It would do much of the same thing. (There is also no reason for it to be aware on how many computers the whole thing actually runs.)
Have you tried working in a tmpfs?
A lot of bugs are fixed with the help of go-nuts mailing list. Any recommendations and fixes are welcome. 
Yeah, I had mostly the same response... why the hell would you expect that to work. 
&gt; I could not believe that the Go language designers, who are otherwise very meticulous and reliable, had overlooked something like Content-Type: application/json handling. Well, unless handling of "application/json" is [part of the official RFCs](http://www.ietf.org/rfc/rfc2388.txt) for HTTP (and a requirement for a standards-compliant HTTP server implementation), the Go language designers (or rather, the standard library authors) should not be under any pressure to handle this, just like they don't automatically de-serialize "text/xml" or return [an image](http://golang.org/pkg/image/#Image) if someone posts a valid image file. If "application/json" posts are in any HTTP RFCs, then AngularJS is being a bitch for not using standardized Content-Types and backend servers have no obligation to handle non-standard Content-Types, even the ones that make sense (like application/json).
Nice. Yeah, this is essentially the solution I came to.
Gave a shot at removing the mutex. The only thing that doesn't work is that the reported capacity isn't 0 when closed. https://github.com/icholy/pool/blob/master/pool.go
Something like this? package main import "os/exec" func main() { cmd := exec.Command("bash", "-c", "echo this is a command that bash will execute") out, err := cmd.Output() if err == nil { println(string(out)) } else { println(err.String()) } }
I think so. Thank you.
as you just need to call a program you can skip bash package main import "os/exec" func main() { cmd := exec.Command("echo", "one arg","the other arg") out, err := cmd.Output() if err == nil { println(string(out)) } else { println(err.String()) } } 
It is cool. But can you explain if all connections are used, will create a new, instead of waiting until one get free? It is correct?
A few questions: * What license do you plan on using? * Have you done any performance comparison with [github.com/lib/pq](http://github.com/lib/pq)? * Do you have any plan to implement a COPY helper (i.e. something similar to psycopg2's copy_from/copy_to)?
Is this a fork of github.com/lib/pq or compatible with it?
Thank you.
We're gonna fix banner :) 
- Same license as Go uses. Added it to the repo. - Yes, prepared statements are ~20% faster. "Plain" queries are 3 times faster, because lib/pq uses prepared statements when you have parameters in the query. Benchmarks: https://github.com/vmihailenco/pg/blob/master/main_test.go#L574 , relevant results: https://gist.github.com/vmihailenco/0e16f61ee5e2b512c163 - No, I don't have such plans but I will look at that helpers.
No, this is not a fork and client is not compatible with lib/pq. Actually github.com/vmihailenco/pg is not a driver for database/sql at all. 
yes, that's correct.
I looked at database/sql and lib/pq more than a year ago, but AFAIR lib/pq is forced to use prepared statements for queries like db.Query("SELECT * FROM users WHERE id = $1", id) to get info about data types. Prepared statements are 3x slower than plain queries. So you either have to use fmt.Sprintf where possible or have slow queries. This client also has built-in support for mapping Postgresql response to Go struct, which makes a lot more sense than Scan interface (at least for me). Also Loader interface allows to write custom loaders like pg.Ints: http://godoc.org/github.com/vmihailenco/pg#example-Ints Thankfully to the Factory interface connection pooling is simplified a lot and users should not care about closing Rows at all. 
Have you thought about automatic mapping of the hstore to a Go struct? I would like to use PG as a classic key/value store and not worry about table migrations.
Yes it will not wait, however I'll plan to implement an option that it will disable factory and wait until the pool is ready.
For the language itself I'd say yes. But the place where Go's standard library shines is backend programming, network, crypto, encodings and stuff - which is usually not the most interesting application domain to first-time programmers. Of course they will probably start with command-line programs, where Go offers a low barrier, but to keep them entertained visual output and interaction is often a good idea. That's why many beginners learn JavaScript+HTML nowadays and why I started with BASIC and Turbo Pascal ("uses Graph;") back in the day. The ["intro to images"](http://www.pheelicks.com/2013/10/intro-to-images-in-go-part-1/) series goes in the right direction. Maybe packages similar to [Microsoft Small Basic's](http://smallbasic.com) very [simplistic APIs](http://smallbasic.com/doc.aspx) and a mini IDE mainly consisting of a code window and a run button would be of help in teaching Go to beginners and kids. 
I think there is a strong point for Go that wasn't even mentioned in the article. Go is a programming language that allows the student to use only the concepts he has learned so far. Consider a simple Hello-world program: package main import "fmt" func main() { fmt.Println("Hello world") } This program contains 1. a package declaration. Each file has to contain one, easy to teach. 2. an import directive. A simple concept that can be teached upfront. 3. a function with body. This might be considered boilerplate but is easy to explain. (A function is a container for code). 4. a statement with a function call from another module. The semantic of "fmt." is easily understood because of the import statement further above Now, an equal Java program would look like this: public class Hello { public static void main(String[] argv) { System.out.println("Hello world"); } } It contains far more things: 1. A class. Explaining what this is requires basic coding skills. Usually teached as "this is boilerplate, please ignore". 2. A public modifier. dito 3. A function decorated "public static" with arguments. More boilerplate that might confuse the student. 4. A call to System.out.println. The semantic of System.out is more difficult to gasp than in the Go example because the Go example contains an import statement that introduces the notion of getting an indentifier from somewhere. IMHO, the Go example is much easier to comprehend as there are no constructs you cannot explain to an absolute beginner. This continues when you dwelve into the language further. You don't have to force students to blindly use certain constructs before they are introduced: 1. Students can learn about variables with examples that declare them with :=. Types don't have to be used until introduced. In the Java example, types and declarations with them have to be used in the simplest examples as boilerplate. 2. Students don't have to understand arrays till they are introduced. The same holds for channels, interfaces and all other language features. 3. Interfaces such as io.Writer can be introduced through specific implementations such as os.File long before the notion of interfaces is introduced. Once they are introduced, students can use the previously learned interface in an abstract way. 4. Syntax can be introduced once necessary. There aren't any constructs that have to be used in order to do simpler things. Java on the other hand requires the usage of exceptions with the associated syntax for comparably simple tasks such as IO. Teaching exceptions before object orientation is difficult, but IO is something integral that might be thought much earlier. Another thing were Go shines is the API. The libraries shipped with Go are easy to use and to understand and do not require complicated setups to use. This compared with the fact that Go doesn't require a particulary complicated setup and is portable makes Go a really neat language to teach programming.
I see your package main import "fmt" func main() { fmt.Println("Hello world") } and raise you a package main func main() { println("Hello world") } How's that for a simple "Hello, world"? I think that formatted output can wait. &gt; Teaching exceptions before object orientation is difficult Exceptions have nothing to do with object orientation. Of course, Java mixed them up, as it did with everything else. *That* is why Java is a lousy teaching language - people walk away thinking that things belong together that actually have nothing to do with each other at all.
Great job to all those past and present in Go's continued improvement!
These are very reasonable points, but I note that many of them are not really unique to Go. Specifically, most (all?) of them are also true of Scala, which also has a nice and standard REPL (yes, there are similar go efforts, but I think it's nice to have something this basic as part of the "official" version). Anyway, I am definitely encouraged that there are now several plausible and well-designed languages that are both used in the real world and *aren't* Java or C++. :-)
I cloned your repository and it couldn't build because it can't find lilpinger/tools and lilpinger/config. Shouldn't you use the full path in your import (e.g. github.com/ARolek/lilpinger/config)? Are you separating these two packages for namespacing?
I love Go, but I can't recommend any language as a *first* language unless it has an interactive toplevel (sometimes called a REPL, or miscalled "interpreter"), like Python and Lisp do. Learning programming relies heavily on experimentation, and an interactive toplevel means you can experiment much, much faster. It also means you don't have to also learn an editor and other tools at the same time. As a first language *for kids*, there also should probably be easily accessible graphics primitives. 
It may be worthwhile to consider http://picturingprograms.com/.
Neat! I actually wrote something similar not too long ago with just time.Tick that runs when I log in to my desktop. Also, nice to see that TinyFactory is using Go. :)
Can someone explain the third argument in slices? How it works and where it might be useful?
Pretend that you really have no idea how to program, that you've never programmed before, and look at those lines again. --- &gt; package main What is this? What is a package? What is main? &gt; import "fmt" What is an import? What is "fmt"? Why is it in quotes here? What makes this different from that package thing up there? &gt; func main() { &gt; fmt.Println("Hello world") &gt; } What is func? Why is "main" there? Is this the same "main" as the main we saw with the package thing up above? I see "fmt". Why isn't it in quotes here? Why are there parentheses after the "main"? Why curly brackets? Why is "Println" uppercased? --- I'm trying to impress upon you the possibility that you may have an "unconscious bias". It would not be due to any deliberate fault, mind you: you're probably a very good programmer. Too good: as such, you've got to realize that that your expertise may blind or make you less sympathetic to the problems that beginners run into. There are a _lot_ of things going on in that program above. Getting back into a beginner perspective is hard. It's active research to figure out how to help beginners. The fact that everyone here is talking about how syntactically lightweight programs are in Go vs Java is missing an important point: beginners make mistakes! What happens when they do? Does the programming environment help? For example, error messages alone are a serious consideration: http://cs.brown.edu/~sk/Publications/Papers/Published/mfk-measur-effect-error-msg-novice-sigcse/ I'm not saying that Go wouldn't necessarily be a good beginner language, but neither is it obvious that it would be one.
The most obvious example is to prevent other routines from overwriting data they don't "own". For example, let's say I have a slice of length and capacity 20, and I pass that subslice [:10] to a function which does an append(). That append will notice that there is extra capacity and overwrite elements in 11..20 if it needs to. By using the third argument, you can force a capacity of 10 on the subslice so that any append() will cause a reallocation instead of overwriting data past the end of the subslice that was passed in. edit: playground link: http://play.golang.org/p/jzRfAEfSQD
1. The whole point here is, if it's empty you have to call factory, otherwise if it's closed you have to prevent that someone reads from that channel. That's why I'm trying to say. look at point 2. We have to protect it somehow. 2. It's not, you can receive from close'd channels. See example: http://play.golang.org/p/B5duoy69Hm . That means if you don't protect the channel, Close() and Get() will both drain it and therefore Close() should be protected.
No doubts that lib/pq and database/sql developers are aware about such behaviour: https://github.com/lib/pq/blob/master/conn.go#L487 . And you will have to spend a lot of energy to change current state of the things (besides that database/sql has good reasons to hide type information). But I simply don't have enough interest in it. 
I thought about that. The problem is that it is hard to write decent and meaningful hstore support without actually using this feature. So I doubt that client will have full hstore support until there is real interest in it (i.e. patches are welcome :). 
Very nice. Mapping into structs is extremely useful, and I might have been more likely to use postgres had this driver existed many weekends ago!
And now it's called interface{}. That's not generics.
Very cool, thanks. I actually have your plumbing post bookmarked from when I stumbled on it a few weeks back :-) &gt; Just this morning I asked the mod community in reddit to hand me /r/acme Subscribed, just in case you end up with it.
Channels are thread safe, you can safely have multiple goroutines receiving on the same channel without any issue. You don't have to 'protect' them. I don't see what the big deal is with Get() being able to still get a net.Con out before Close() is finished. The client still has to Put it back. The only difference is your Pool is 'closed' once Close() acquires the lock, my Pool is 'closed' once the channel has been drained. Maybe I'm missing something, but I can't imagine a use case where one would be superior to the other. 
It should be replaced with https://code.google.com/p/go-wiki/wiki/Projects which is under active review and maintenance.
The 70ies called. They want their magic numbers back.
It would be awesome if supported some kind of branch coverage.
&gt; Current implementations provide several built-in functions useful during bootstrapping. Well, we *are* bootstrapping students through these examples, aren't we? ;-)
It's been very handy (I've been using the beta for a while since I was extremely confident that 1.2 would officially come out before I deployed, which was correct). I just wish there was a way to label that I don't want a particular bit of code covered; I'd love to add coverage tests to my CI, but without that I really can't. (I'm not talking about insisting on 100% coverage for all modules, which isn't that great an idea. But I do strive for 100% on "foundational" modules, and I _would_ like a warning when somebody violates that. So I'd be picking a set of modules to assert that I have 100% coverage on in my CI system.... except that breaks too often to be useful now.) Also, before someone asks, one reason I have sub 100% coverage is this pattern: something, err := CallThatIDontKnowHowToMakeFailInTests() if err != nil { panic("With a nicer contextual error message") } I've learned not to let the coverage system tell me to remove the panic with the nicer error message, as every once in a while that sort of thing really saves your bacon. But I don't necessarily know how to make the test cover it in any reasonable way.
Given the backward compatibility guarantee, they wouldn't be able to move the constants out of `os` without breaking things. I suppose they could duplicate them in `io` and then encourage people to switch from the `os` ones to the `io` ones.
Yes, that was my thought exactly.
Not sure how I missed that... fascinating stuff.
There is a TON of Java stuff out there for someone that wants to start programming. That is one HUGE advantage. Not to mention, most colleges have classes if they want to go the "formal" route.
The same holds for C and Fortran. I personally wouldn't recommend either for learning programming. 
Yeah, the go bits are not maintained any more. The other bits, however, are. 
Well, teaching students things they are supposed to stop using later on proved to be ineffective as students dislike stopping to do certain things. This is the reason why Pascal (let's try to make an easy language as a teaching tool which intentionally misses certain concepts to be easier) grew into the abomination called Delphi: Because people weren't willing to switch languages. It's better for the future people who have to maintain these mistakes to teach students proper things in the beginning.
I started programming about a year ago and tried to get into it several times before. The reason I suddenly sticked with it and had an easy time grasping it was that Python has very little boilerplate and usually everything that is needed for the first few examples can easily be explained. I looked into a lot of different java and c++ beginner books. I can honestly say most of these start with "accept it for now we will explain it later". "later" meant sometimes several chapters later, while in most python beginner books I read it was part of the next chapter or even in the same chapter just a bit later. ;) Also the "later" explainations sometimes depended on details of earlier chapters, so you had to reread parts of earlier chapters a lot of times to understand the current chapter. In the end "func", "package" and "import" are much easier to grasp and explain then some concepts of OOP that isn't really needed for the task. If something isn't needed for the task that you try to solve or is being solved, you will wonder why to use it to begin with. Personally I think you shouldn't start learning programming with a programming language but that is another story. :)
Like [this](http://code.google.com/p/go/issues/detail?id=6873&amp;thanks=6873&amp;ts=1386019017)?
The constant names are not idiomatic, otherwise it looks good.
You are getting hung up on the OP's hyperbole. It is odd that there are no constants for Seeker defined in the io package.
Sadly, for practical purposes, SCTP makes no sense because basically any NAT won't know what to do with it. That being said, having an SCTP implementation that could be switched to when the network allows it would be pretty cool, but it's beyond what I need. I'd be happy to take a pull request for it though.
Wasn't Uriel the maintainer of all cat-v.org content? Who's maintaining it now?
It's in good hands. 
Not sure why we have to have a language description in less than 50 pages, or what that really means. (I mean, I can probably do the BNF of most of these languages in much less than that; does that count?) Anyway, [this is the specification for Go](http://golang.org/ref/spec). I don't know how many pages it is. And [this is the specification for Scala](http://www.scala-lang.org/docu/files/ScalaReference.pdf). Seems to be 138 pages for the language itself. My sense is that the spec for Scala is somewhat chattier, which is neither here nor there. In both cases, we are safely below the limits of (say) Common Lisp, The Language, although that might not be the bar one should set. :-)
Actually, I need it exactly for targeting a "normal consumer". muxado is the foundation for the next version of [ngrok](https://github.com/inconshreveable.com/ngrok) that I'm building. I think Go's tool-chain and easy deployment will make it a very popular language for building developer tools that are run outside the datacenter.
Actually, I need it exactly for targeting a "normal consumer". muxado is the foundation for the next version of [ngrok](https://github.com/inconshreveable.com/ngrok) that I'm building. I think Go's tool-chain and easy deployment will make it a very popular language for building developer tools that are run outside the datacenter.
And these days...neither would I. But being as old as I am, C and Fortran were two of the first four languages I learned. Java is an odd case. On the one hand, there is lots of tutorial material out there. Also, there are many, many tools and libraries. And literally tens of thousands of person-years have gone into optimizing compiling technology for the JVM. And yet...many students of Java programmers, some of whom who have spent years learning the thing and are hardly stupid, don't seem to be especially good programmers. Now, that might be because the language is holding them back in some way, but it is at least as likely that a good part of this is that there are just waaaay more Java programmers out there than programmers who know other languages (at least these days), and most people trying to do most complicated things are, um, not very good at doing them. I don't know of any experiments that have been done where you randomize beginning programmers to different languages and find out how they turn out in the end, but I suspect that the effect sizes would be pretty small compared to what most language zealots would expect.
Damn, it seems really interesting. Is there anyone with a skill in Japanese translation?!
I find that a lot of the file operations are spread out across `os`, `io`, `bufio`, etc. Seems like it could be bundled a bit better.
Nice! I haven't had the chance to write much Go for work-related purposes, but have been writing a lot of personal tools and side projects with it lately. Really brings the fun back into programming for me. I write a lot of PHP at work and it kills me. 
Yorp. Went both ways. Updated using Homebrew on my Mac and manually on one of my Digital Ocean instances. Very pleased so far!
Wouldn't it be a more practical skill to learn how to do web development using html/css/JavaScript? There are far more resources available to learn from, plus you'll learn basic cs principles along the way that can be applied to more complex languages.
Frankly, most web-based services are simple enough to write without having an in-depth knowledge of CS. For the most part, it's CRUD - Create/Read/Update/Delete. By that, I mean you need to understand the data you are trying to work with. You don't need a degree to guess that a `User` record should contain an Id, Username, Email, and Password (obviously, you may not name it this way, just an example). That being said, he said you don't need to worry about "a database". I'm not entirely sure what you are building, so take my comment with a grain of salt. Most web apps are entirely database driven (read: CRUD), so you will probably need to understand how to model the data you're working with into a [usable schema](https://en.wikipedia.org/wiki/Database_design)...and in doing so, picking a database that is suitable to you. In my experience, MySQL and Postgres are the most common. I usually use raw net/http, but I'm fond of [Revel](https://github.com/robfig/revel). There's also a "book" available on building web apps with go ([here](https://github.com/Unknwon/build-web-application-with-golang_EN/blob/master/eBook/preface.md)). I just pulled it up with a quick search, so I can't vouch for how decent the material is, but with a cursory glance it looks like it covers the basics of any web-based application in Go. Hope some of that is helpful. You are more than welcome to provide additional information about your project so that we can be of better help.
Somebody else is doing the frontend integration and since the web service will be applied to my field he'll need help with that!
Thanks and sure! He just said to not worry about the database too much for now. The project is extracting historical data from the government's new open data on locations. The upbringing of local franchises, family owned businesses, social actions, etc. It's a sociology / cultural study to reorganize our university's surrounding history and our influence. There are third party APIs that have specific information that the government doesn't have, so it's like a huge scraping project that'll expose a new simpler API for the front end people.
I'll take the unmaintained pages off.
I use ArchLinux as well and I could barely wait to upgrade to go1.2 but I wasn't expecting anything to break because I know how the go designers and the community feel about that. Whatever supported OS you're using, any linux distro, mac, windows or freebsd, the process should be painless. One thing I noticed though, is that the (re)compiled binary is slightly bigger in size now. Not a problem, just mentioning.
And we (VividCortex) REALLY appreciate your hard work. Thank you. If you weren't so damn far away I'd ship you some of these chocolates -- right up the street from me, best chocolate in the world: http://www.gearhartschocolates.com/
Well, it's a minor release of a language/compiler/runtime. i.e. infrastructure software. The best way to make sure it won't get used for a long long time would be to break backwards compatibility all over the place - so the didn't do that :-) 
They also shouldn't be in ALL_CAPS. My fault. Sorry. Will fix in Go 2. 
I like this pattern. I've also seen it used in JavaScript libraries where a global object with the same name as the library is provided to be used by default -- but you can also instantiate a new object to customize.
Thank you for an authoritive answer. Is there a public list of planned changes for Go 2?
I've never been keen on managing settings via environment variables, seems like you're just transferring responsibility from a config file that can be tracked in scm to some way to initialize the environment variables that can't be as easily tracked.
At least some of the Go team work out of NYC which isn't _too_ far from Charlottesville...
Is this library safe to use concurrently from multiple goroutines? That's one of the main benefits of the database/sql design.
Thanks for this, I'll be following your curriculum, myself.
Are there any CS people at your university that you could get some help from? suggestions from strangers on the Internet are fine add far add it goes but someone you can get to give you help in person is extremely useful when you're staying out
We don't have the best CS department. The HoD told me they have no familiarity with Go and that their classes are in C++. A CS student overheard the conversation and told me this was the best community. The HoD proceeded to tell me that if I wanted to sit down for the next semester that I can because they are too busy with finals and kids going in their office hours. I went on looking for a language and came across this one that's close to C++ and my friend said perfect figure it out.
In a medium sized code base at work we had a single test fail after upgrading to 1.2. And that test was just hacking around 1.1's overly picky csv parser which as fixed in 1.2! We just removed the hack in the test, built new binaries, and ...upgrade complete.
Don't forget the official resources: * [Go Tour](http://tour.golang.org/) * [How to write Go code](http://golang.org/doc/code.html) (mostly on packaging / environment) * [Effective Go](http://golang.org/doc/effective_go.html) Of course, they might not be better than a book for a complete beginner (the tour seems to be suited for those who have already programmed in other languages), but those are invaluable resources nevertheless.
Why no panics? I use panics in place of asserts. They communicate "you're not using the API correctly, and you should not be recovering from this".
Environment variables as application settings are really useful in projects that are otherwise completely open source but utilize paid services like AWS for S3 or SES.
I'll not fall for your lies... *evil*duck. But no, I like fallthrough mechanisms myself. If flag is found, use flag value. If config file is found, use value from config file. If nothing else, use sensible defaults where applicable. I suppose you could throw "environment variables" in there somewhere.
Please forgive the carry-over from my experience in other languages, which certainly did influence my work on GoConvey. I'm not sold on the single-starting-character convention so prevalent in go code. :)
I should also mention that I don't always use 'self'. There are times when there is a better name that isn't even related to the class name, like 'parent' and 'child': https://github.com/smartystreets/goconvey/blob/master/execution/scope.go
Good point. I like 'game" WAY more than 'g', which a lot of coders (including the core devs) tend to use, which requires double-takes and mental mappings for whoever might read the code later. As an aside, I contest that "self" and "this" are indeed reflections of identity. In fact, they make it easier to know that the variable was not passed in from outside but rather that it is the receiver itself. (yes, I realize that I'm going against standard convention but it's something I feel very strongly about.)
&gt; which requires double-takes and mental mappings for whoever might read the code later Not if your methods are short. Pointless repetition of long names in every line of a method can detract from the structure of your code.
I'm very thankful you guys work hard on Go. If there's any way I can give support, just tell me.
While it may be convenient, it isn't a best practice. It creates a singleton (and singletons are globals), thus resulting in surprising behavior, bugs, and reduced testability when unrelated components all mutate that shared state. 
One step closer to a pretty interesting possibility, a Meteor-like web framework utilising JS translation to provide the client-side access to core business logic natively and without round trips to the server.
I like the idea, but ultimately these designs struggle handling the queueing problem. For example, if one consumer of frames get backed up, everyone waits. Martin Sustrik (ZeroMQ and nanomsg) has written about this in a very clear manner.
This is something I went back and forth on for a while when starting with Go. Ended up just going with the prescribed convention. Now I don't even think about it.
Nice read. It's always nice to learn about real-world experiences with Go -- positive or negative.
That is a nice feature, not as good as TCP flow control however, but better than nothing. 
I think this is really cool. Revel uses code gen to do dependency injection, and other than a compile-time overhead, it seems to work well.
This looks like a truly powerful package, if it does all it says it does and with as much ease as is apparent on this page then I think there is a a lot of potential use for this. This could add to the base for a lot of go programmers toolsets.
Good explanation! It's a good data structure to know and have in the back pocket. I built a Skiplist in Go as well...https://github.com/reducedb/skiplist
Agreed, I've used one in my projects in the past, although it was from [here](http://github.com/glenn-brown/skiplist).
It kin'of serves multiple purpose for me. It let me refer a single source for dependency management, along with knowledge of any specific tags required to be applied at any particular package. Easier to get all dependencies at a single go_get_pkg. Since I use separate Go Envs per project (cleaner to play around with alpha changes), the package install happens a lot. PLANS: I'll add in-between caching layer for packages, so can happen offline as well. I've seen one issue in it lately on tag-specific package... will fix it as soon get time to debug. May be there are better ways already as a part of golang for these, I'd love to improve on my usage if there are.
I think you should be passing back error values. Throwing panics unnecessarily decreases program stability. An error due to unexpected misuse of a package causes one function to fail. A missed panic causes the whole program to crash. I may be wrong about that though. I think what he means by no panics is that packages should never throw panics like you'd use exceptions in other languages. Exceptions aren't exceptional in most cases, and failure should be treated as common occurrence.
i feel the title is misleading. it is "a code generator to generate underscore-like functions for certain types". a workaround for not having generic type in go 
Might want to edit the picture in the article that has a password up on the whiteboard.
Yes, methods with short scopes make a lot of things easier. So are you saying that "game" and "self" are long names? When brevity and simplicity are discussed, getting a simple design along with short methods are way more important goals than super short names (removing random characters within a word - "fmt" or chopping to the first character - "g" for "game" - are just silly practices and aren't worth the characters saved when typing). Our brains process complete words really well. Having gone on this little rant though I'm realizing that this mini holy war isn't really contributing to the topic of this page and our respective approaches are probably equally effective because of our respective experience. Changing a habit is difficult. I should probably just conform to the convention. :)
Awesome, this is one datastructure that I have yet to learn the details of and what better language than in Go.
It does not decrease program stability. It increases it by enforcing that the API be used correctly. You want to make it as difficult as possible to get away with doing the wrong thing. Fail-fast principle. 
&gt; But, considering that Go functions are first class, these can easily be implemented. ...over and over for every type you want to use them with. In case of map and reduce, for every pair of types.
This is so cool! It's little things like this that make me love Go and the Go community.
What's interesting about Go's approach is that it provides you the template language that everybody already thinks and acts like they have, but they don't. I'd say "woe betide he who learns in Go and tries to transition to another language", but it's already the case that most developers spray security vulnerabilities every which way when developing on the web, so I'm not sure there'd actually be a visible change to the current status quo.
Hey, Have you ever dealt with web development in other languages (Python, Ruby, PHP)?. As some interfaces / frameworks from those languages have the concept of middleware too, that might help for you to grasp it. Anyway, since I'm lazy, I'll cite my own [blog post](http://justinas.org/writing-http-middleware-in-go/): &gt; In the context of web development, "middleware" usually stands for "a part of an application that wraps the original application, adding additional functionality". [StripPrefix](http://golang.org/pkg/net/http/#StripPrefix) is an example of middleware. Upon a request, it strips the given path prefix and only then does it pass the request to your *real* application. Usually, middleware either pre-processes or post-processes your request / response (could do both). This graph from [Django documentation](https://docs.djangoproject.com/en/dev/topics/http/middleware/#hooks-and-application-order) explains it well. A request goes in through all the middleware, it's then processed by your view function ("handler" in Go) and then goes back to the user, while again passing through all the middleware. Though any middleware could, of course, choose to do nothing to process the request or response.
 r := make(&lt;-chan bool) w := make(chan&lt;- []os.FileInfo) What's the point of making a read/write-only channel? Shouldn't read/write-only just be specified in a function's arguments/when calling that function?
Integrating goimports with go-mode in Emacs: (setq gofmt-command "goimports")
This looks fantastic. Now I just have to find or make up a reason to use it. :)
As the OP is talking about web dev, it's fair to say that "middleware" explicitly means "HTTP middleware" in this case. /u/sjustinas answer covers it pretty well. His [nosurf](https://github.com/justinas/nosurf) package is a good example of idiomatic Go HTTP middleware. 
I'm not really sure how I feel about it. While I agree that every framework inventing its own middleware is not ideal, I can't help but [think of this comic](http://xkcd.com/927/). Though this package supports the standard `http.Handler[Func]`-s, it still happens to be incompatible with existing `net/http` based middleware (`http.StripPrefix`, `gorilla`, `nosurf`, etc.), as it gives no reference to the original handler on construction (only "Next" at the runtime). Yes, `net/http` can at times be annoying and crufty for writing middleware, but then again, the only differences seem to be: * A need for specific interface (`Handler[Func]`). * The responsibility to call the original handler yourself. * The convenience of `Compose(H1, H2, H3)` over `H1(H2(H3)))`. The last point is adressed by [go-stackbuilder](https://github.com/mattn/go-stackbuilder). As for others, I don't think it's worth rewriting the existing `net/http` based middleware just so you can omit a few lines of code once in a while.
[Image](http://imgs.xkcd.com/comics/standards.png) **Title:** Standards **Title-text:** Fortunately, the charging one has been solved now that we've all standardized on mini-USB. Or is it micro-USB? Shit. [Comic Explanation](http://www.explainxkcd.com/wiki/index.php?title=927#Explanation) **Stats:** This comic has been referenced 133 time(s), representing 2.66% of referenced xkcds. --- ^[Questions/Problems](http://www.reddit.com/r/xkcd_transcriber/) ^| ^[Website](http://xkcdref.info/statistics/)
Thanks for the reference to the comic :) You are correct in saying that Compose is essentially a convenience as it only really adapts the handler to func(http.ResponseWriter, *http.Request, http.HandlerFunc) and chains the handlers together. In my opinion those middleware handlers were designed without a predefined middleware signature in mind. But still, it's quite trivial to create an adapter (even the implementation thereof). The 'adapter pattern' shouldn't vary for middleware handlers such as http.StripPrefix, nosurf etc. **Example http.StripPrefix adapter:** import "net/http" func StripPrefix(prefix string) func(http.ResponseWriter, *http.Request, http.HandlerFunc) { return func(w http.ResponseWriter, r *http.Request, next http.HandlerFunc) { http.StripPrefix(prefix, next).ServeHTTP(w, r) } } I found that for gorilla/context it could simplified a lot by using middleware to enforce the lifetime scope. gorilla/mux can be inserted in a chain without any modification as it's a http.Handler. gorilla/sessions currently depend on gorilla/context which would be a no go if you used go-middleware/context instead. The only real middleware I know of that gorilla 'supports' is gorilla/mux that essentially clears gorilla/context if it's set (similar to Compose(mux.NewRouter(), ClearContext()) - but for go-middleware, the request context is cleared automatically when the middleware function exits and thus don't require a cleanup filter. I hope that brings some clarity - thanks for taking interest and have a good day :) PS. I'll add the adapter pattern to go-middleware/examples
just do a display-none on his avatar-link class with your inspector. And you will be fine.
Thanks for the help :) "middleware" it's become clear
Out of morbid curiosity, what's a good use case for something like this?
Wow. Awesome, gonna use it for my IRC bot.
Latest commit 5 months ago? Is it abandoned or just extremely stable?
Lots of programs can profit from extensibility via an embedded scripting language (JS, Lua, Guile, Python, Tcl ...): Text editors, window managers, network simulators, image manipulation programs, games, ...
&gt; When writing high performing network servers it’s useful to delegate some of the expensive work to other threads – but threads are difficult to reason about and to manage well. Go handles this using goroutines and other native language constructs that mean we never need to worry about such things. I think the Go community needs to watch out for this claim; it's not true. When it really comes down to it, Go is threaded as much as anything else. Goroutines do not provide memory isolation, and it does not mean you can just forget about concurrency issues. What Go has is a _culture_ of isolation, and a standard library that extensively uses it. You need to worry about it _less_; perhaps even _much less_, but not _never_, the way you can say with a straight face that you never need to worry about accidental sharing in (pure) Erlang.
I can't hear anything :S
You're right. It's not super precise but I'd say it's largely true when you follow conventions and idioms. 
&gt; "never need to worry" is a severe overstatement. Yes, it is. However, what I _said_ was &gt;&gt; never need to worry about ___accidental sharing___ in (pure) Erlang. This is true. You will not accidentally share state between Erlang processes. (People occasionally claim otherwise that Mnesia, ETS, or DETS "share state", but they're wrong; each of those are in a container process, or in the case of Mnesia, have full transaction support.)
actually it is really interesting if you think about it as a build step it would be nice if it could be easily integrated in go build 
Hi. OP here. Good to know. It looks good, but I think it should not be used unless you really know what you're doing
Being able to shoot yourself in the foot with garbage collection and strong type checking. What else could we ask for!?
This is extremely useful for lock-free data structures - both to guard against ABA, and for "helping" algorithms where a pointer and flag both need to be updated in one atomic operation.
Ah yes, another usecase. :D
Hey, thanks for the comments! %b doesn't have leading 0s, which is why I wrote gogogadget - it uses fmt.Sprintf("%b") in it :). There are several more interesting inspection tools that is in my private gogogadget repo, which I'll eventually put on the public ones. Github gists - didn't know that. Everything else: I totally agree. I am using something that looks like your code (mine keeps the in-place swap when untagging) as of yesterday in some parts of my project (after I discovered that pointer tagging was faster than traditional type switching). Haven't run into problems yet. Then again, I deal a lot in unsafe space, so, there's that.
A long time ago there was a hoax in assembler with making your hard drive arms spin so fast they'll burn it. But it was just a hoax. Let's wait for an import pyro, pyro.DestroySystem()
You can use `fmt.Printf("%0.32b", 71)` for zero padding.
TIL. Thank you
Sorry for the disappointment :( – I'll make sure to blog about any advancement when it happens.
Can't wait to see the video xD
Actually nvm, the slides and github were good enough. Thanks!
Out of curiosity, what technology compiles/renders these kinds of web-viewable slides? I see them all the time for programming-related talks. Is it some kind of html5 standard? A google-specific thing?
It's an open source program that we wrote at the Go team. The code is available here: http://code.google.com/p/go.talks You can also use http://talks.godoc.org so you can serve talks directly from github like: The talk https://github.com/campoy/todo/blob/master/talk/talk.slide Can be served on http://go-talks.appspot.com/github.com/campoy/todo/talk/talk.slide
That's what it's based on, but gophers use the [present](https://code.google.com/p/go/source/browse?repo=talks#hg%2Fpresent) tool. [godoc page](http://godoc.org/code.google.com/p/go.tools/present)
Tagged pointers like this feature in some language interpreters to save space on numeric types. I may actually use techniques similar to this at some point in the near future to do just that.
actually I think tagged floats will save even more space. You can store up to 31 bit integers in a tagged NaN
The interesting part is that they already have the infrastructure to run go in native client. 
Agree! I think this wasn't highlighted enough in the article, but having NaCl available will be a huge boost for native Go app deployment
whoaa!! I never knew you could do filesystem &amp; network stuff.
I think the select at line 106 needs a default case, otherwise on the first error, the loop will block until the channel is closed.
Is it just me, or do all of these libraries seem not-that-much-better than the standard Go libraries. All it seems to do is just obscure what's going on under the hood. I feel like a lot of people are just coming up with clever ways of doing the things that Go does by default, and not really extending anything palpably.
I was initially really excited for this, but it isn't going to have Chrome support (at least initially). I was really hoping to be able to write an app for my chromebook in go :(
If anyone from AZ is going I'm also planning on going...
Why "nutrition"? That doesn't seem to convey anything about what this package is doing.
Fantastically comprehensive document. Easy to see why Russ Cox heads system aspects of Go.
This. Just recently I've been considering, how awesome it would be to write both front-end and back-end in Go, and today I discover, that in about 6-7 months it will be possible!
I love the name :) It's like to feed apps with some config
I hope the "at least initially" part is just that, I would love to be able to develop apps for ChromeOS in Go. Sure I could bite the bullet and learn dart or javascript but where is the fun in that.
Actually you know you are correct. I originally had a default statement but took it out for some reason. Will add it back.
I'm not sure how much these communities overlap, but I figured I would post this here if anyone is interested. I also have a library I wrote prior that went through the RTMP(s) protocol, but I haven't open sourced it because it is essentially obsolete now. If anyone is interested in that source as well, let me know. If there is enough interest I can put what I currently have up.
I think it would be a cool adventure, but I'll be out of the country in April.
THANKS! Was about 1/2 through doing my own, saved me some work!
Will do
The router is open source: https://github.com/alphagov/router 
Well, you'll know another programming language, and in the case of Javascript you'll learn to understand better why you love all the other programming languages so much.
Well between the two I would probably be more interested in learning Dart. I have tried to learn javascript years ago and realized it was not for me. I do understand the language and developer tools built into web browsers have come a long way since then, so it may be worth giving it another shot. I would still want to see where Google goes though once they get Go working under Native Client.
We've not specifically tested the router for DDOS handling (beyond the general performance/load/soak testing described in the post) because there are several other layers in our stack that should handle it. I believe one of the team has run it on a Raspberry Pi (mainly to do some testing for https://github.com/alphagov/router/issues/66) so it should work fine there if that's how you want to use it.
In the past, this project was maintained [and abandoned] by the NaCl team, right? Is this going to now be maintained by the Go team?
This sounds interesting. With the planned implementation of ILP32, it shouldn't be very complicated to support the x32 ABI under Linux which is exciting in its own regard. Go could be the first programming language apart from C to support x32.
It seems to be a lot like with Python web frameworks a few years ago: Everyone wrote their own, it nothing else, they did it to learn the language. Go makes writing these types of web service frameworks pretty easy, so that's what people are starting out with. I would love if someone wrote a Django like templating package or improved the Go html/template package, but that seem to much harder to do. Take a look at Armin Ronachers talk: [Dismantling Jinja](http://www.youtube.com/watch?v=-NPuhYWzi-c). I know it's Python, but makes it pretty clear to me that creating a fast and powerful templating language is pretty hard. 
Thanks for the contribution! I was also about to write my own LoL API client. Just a suggestion, when building the URLs, you may want to do something like this: http://play.golang.org/p/kIsh0DXmCS Should be more robust, and doesn't require you building URLs yourself or converting from numbers to strings.
what were you going to do with the RTMP library?
I built it to pull data from the riot servers before the official API came out. It was ready to use internally, probably 85% from a state I would have released it to the public at. Assuming the official API has all of the kinks worked out, the RTMP version really only has the benefit of not requiring an API key (just a league of legends account), or if someone wanted to build a replacement client in Go to replace the AIR client. I suppose now, unless someone else had something they wanted to use it for, it is essentially just sample code for a portfolio. I will probably put it up on github someday. If there is a demand for it earlier I could try and upload it in it's current state. Not really a production ready library at the moment though. I am also not sure how much of it is useful for an alternative. I forked an amf library and added some support for references and AMF3 arrays. My fork can be found at https://github.com/TrevorSStone/goamf The rest of it I think is pretty League of Legends specific changes. EDIT: The rtmp library is released at https://github.com/TrevorSStone/golol
Please explain
I'm sure someone will come along and explain pointers in a much more accurate way, but the way I explain them to myself is that pointers are just that: pointers to actual objects. Let's say I have a database client, `db` which is the type `sql.DB`. Now, I have a few functions that I want to be able to access the original client as opposed to creating a new DB client for each function. Thus, I use `func DoSometing(db *sql.DB) {}` as the function signature, which allows me to give the function `DoSomething` a pointer to my existing database client. However, if I had `func DoSometingElse(db sql.DB) {}`, this function expects a full-and-proper sql.DB type, which it then creates space for in memory and allocates the values from the sql.DB client I passed into the function, in essence creating two of the exact same DB clients in memory.
You can send pointers to different functions without the need to copy the actual data, which saves buttloads of memory. Example in Python: my_dict = {1:2, 3:4} some_func(my_dict) In Python, this saves space because Python "sends the pointer for you", so to speak - it looks like you send a copy of the dictionary, but Python just sends the pointer to the dictionary's address. That's what it means when people say that lists and dictionaries are reference types in Python. In older languages you have to use the pointers directly. This is how you send a copy of a dictionary: a_func(dict(my_dict)) Of course, this wastes a lot of memory and may not be needed. Go does have some of that niceness too, dictionaries and slices at least are "sorta" reference types in Go ([source](http://blog.golang.org/go-maps-in-action)), where not the dictionary itself is sent but a small datastructure which itself has pointers to the data. To quote: m = make(map[string]int) The make function allocates and initializes a hash map data structure and returns a map value that points to it. But you might still have to use pointers manually to make sure you copy as little data around as possible. Edit: Also, pointers let you make clever datastructures that you can't directly do this way in Python, for example, you can have a linked list of Persons my using pointers, like this: type Person struct { name string nextPerson *Person } then you can do first_person := Person{} second_person := Person{} first_person.nextPerson = &amp;second_person Voila, now you can treat persons as a linked list.You can expand this example to have double linked lists (just have a previousPerson), branches (have several "next"s), trees etc. There's also heaps of algorithms that use walking pointers to achiever faster speeds. Have a look at the[ binary search algorithm](http://www.csit.parkland.edu/~mbrandyberry/CS1Java/Lessons/Lesson27/BinarySearch.htm), for example. Or, you can simply make a deque, a list that allows you to add or remove elements of a list from the start or the end at O(1) cost, all you need is two pointers, one that points at the start and one that points to the end of a list. Then, if you remove the element at the end, you just shift the pointer one to the left, if you remove an element at the start, move the pointer one to the right.
1) Suppose I have a variable that is several gigabytes, and I want to pass it to a function. Without a pointer, I would need to copy that object to a new object, thereby consuming more resources. 2) If you perform lots of operations on a variable, it is a faster operation to copy the pointer data around in RAM rather than the entire object. This is not true for all variable types, such as an int. 3) If you want to perform an action on a variable by passing it to a function, and want that original variable's value to change, you either need to pass a pointer so the original has the operation performed on it by reference, or you need to replace the original with the value returned by the called func. This can be slow, resource intensive, visually confusing, etc.
In Python every object is being referenced like a pointer by default. As a Python programmer you should be puzzled about non-pointer values, not about pointers.
No, the NaCl team never wrote or maintained the Go NaCl backend.
Interesting. So, if I were to say, have the following program: package main import ( "fmt" ) func identity(x int) int { return x } func main() { y := 5 fmt.Println(identity(y)) } Is Go allocating an additional 32 bits when identity gets called this way? And it wouldn't do the add'l allocation if I were passing it a pointer instead? 
I definitely started out being confused by both :) I actually didn't realize that Python was essentially passing pointers around for me, but it makes sense from what other people in this thread are saying.
And I believe the author is in fact puzzled quite a bit. Python hides a lot of stuff from you. This is good, until you need to understand what's beneath it. While a couple of people have gone into detail about what a pointer is, let me highlight this phrase from the question: &gt; What I don't understand is why one would use pointers instead of simply _using the object itself_. Emphasis mine. The phrase "using the object itself", in the way the author is using it, probably doesn't correspond to anything in the computer. A CPU can not "use an object"; in fact there's no such thing as an object to a CPU. It can only use the numbers in its registers, or load things from memory, or save things to memory. The only two ways to pass something to a function is either to pass the values directly in a register, or to pass a memory address in a register (or set of registers). As YEPHENAS points out, Python pretty much always does the latter for you, so you don't even tell. Go gives you the ability to either do a by-value copy or pass the pointer, depending on which you choose. A by-value copy will still, at the CPU level, possibly produce new memory allocation, a copy, and the passing in of an address. However, for smaller (in RAM) values, such as simple integers, it may simply copy it in via a register. To really understand what's going on, venantius, you need to spend some time down at the assembler/CPU level. Not necessarily enough to "program in assembler", but enough to understand what the CPU actually does (which, for all their apparent complexity, is really shockingly little...). Then it'll all make sense, though you may need to spend a bit of time on Python internals. (Go internals, like C, will be much simpler; the only "crazy" thing Go has is really the garbage collector. Python is _full_ of magic. This, by the way, is not a criticism. It's what makes Python Python. It's just not "free".)
Yeah, I think that's the crux of what I'm asking (why pass a pointer instead of passing the values) -- and it sounds like the answer is to avoid the program creating a copy. So, then, some follow-on questions. If I have an object X, and a function Y, and I pass X to the function (==pass the values of X to the function, not a pointer to X?), does that mean that if I modify what I've passed to the function within the function that the original object will remain unchanged? By contrast, if I were to pass the pointer in and modify it in the function, my original object X would be modified?
yes, you're getting it
Sweet, I've been looking for something like this for a while. Been loving this golang advent thing!
Yes. You can see so in this [snippet](http://play.golang.org/p/MjYEe9ijOy) on the go playground.
Thanks for the correction, I did remember incorrectly. According to [this email](https://groups.google.com/d/msg/native-client-discuss/Ym9L_KS5WgM/D6vfNyrNfvAJ), Russ Cox had something working before, but did not follow up when NaCl changed their ABI.
Conceptually speaking, pointers exist so you can reuse an object instead of allocating a new one. In Python, function calls effectively always use pointers, because they send the original object out to the function. In Go, function calls always copy the thing used to make the call. So, if you use the object, it gets copied, but if you use a pointer, the pointer is copied, but the original is let be. The one tricky wrinkle of pointer is Go's "slices" (which are what Python calls a list). Effectively, a slice is a struct like type slice struct { *backingArray startingElement length capacity } As a result, when you pass a slice to a function, you get access to the original backing array but only copies of the length and capacity. If you mutate elements in a slice, the caller sees the changes, but if you append to a slice, the caller won't see it. Try playing with [these concrete examples](http://play.golang.org/p/YnDOR-STAL) and see if it doesn't make things more clear to you.
I just saw the talk at SFDC and I am happy to see this out in the wild now.
I am no expert so please correct me if I am wrong. Pointer enable 'call be reference' opposed to 'call by value'. In call by reference, since you are passed an address of the variable you can then change it and the change will be seen in the parameters used to call the function also you save memory by not making a copy of the variable. In call by value, the function is handed a copy of the variables and the change is not reflected. [Sample](http://play.golang.org/p/VqFhxWJ2h1)
There are a number of valid explinations here, not all of them explains everything though. I'll do my best. A program can store memory in two places. The stack, and the heap. You can think of the stack as an array with a fixed size, instantiated when the program starts. This memory area has (as mentioned) a fixed size, and if you allocate more memory on the stack than there is room, the program will crash. This is known as a stack overflow. In Go, they have bent the rules a little bit, giving you flexible stack space. There is still a limit though. Every Goroutine get's 250Mb on 32-bit and 1Gb on 64-bit I believe (not 100% certain). In other programming environments, it's normal that the stack space is in the ballpark of 2-8Mb per thread. In any case, all local variables an function arguments (as well as temporary values) are stored on the stack. If you want to store larger objects, or alot of objects that together results in more allocated space than what is available in the stack, you have to use the Heap. While the stack can be thought of as a fixed-size array (not entirely accurate, as each variable doesn't necessarily have the same size, but close enough) the heap is a memory pool, where you ask for a piece of the pie, and if the OS grants your wish, you are given an address to a memory area of the asked for size. Since the stack is an array, you don't actually need to know the address of the memory/variables you wish to use, only an index. For heap you always need to know the address. In summary, accessing something from stack is faster than heap (as you don't have to retrieve values by reference) but the stack is also limited in size. So the heap has to be used for any large objects. In addition, whenever you call a new function, the arguments to said functions are copied on the stack. Remember this, stack values are always copied. Either you copy the actual value of something, or you copy an address (usually represented as a int32 or int64). This explains why Python, Java and other languages copy datastructures by reference, and stuff like bool, ints, floats by value. Copying an int is as efficient as copying the address to the int (itself represented by an int), but accessing said int is faster (becouse it's on the stack). Datastructures tend to be larger than an int, and therefore is more expensive to copy. Another point to note is that you don't require garbage collection for the stack. So allocating stuff entirely in the stack can save time spent in garbage collection. Note that you can entirely allocate an object on the stack in a top-level function, and then pass that object by reference to other functions (avoiding the penalty of copying a large object). As long as those functions don't hold on to that reference somehow, Go won't promote the object to the stack, and you can avoid garbage collection for that item. So in essence, you would use a pointer when: 1. You want to save stack space 2. Want to avoid unessary copying 3. Want to mutate the variable You would use a value (instead of a pointer) when: 1. You don't want the function to mutate the value 2. You are sure you won't blow the stack 3. The value is equal in size, or smaller than an address (int32 or int64), and you don't care or want mutation.
I guess that makes sense, since you can't preprend to a slice.
Thanks for the comments, I appreciate you looking at the code. I went for the global/singleton approach because what I understood from the riot TOS is that each application will have only one API key. I may have misunderstood, and if there are examples showing otherwise I will instantly change it to a struct model. I do know that using two league accounts to get two developer API keys is against the TOS, so that is why I wrote it the way I did. I suppose it is an interesting question whether or not the code should be written to help enforce proper API usage, or written to allow a little more freedom. 1. For the GetXXX method names, I am curious how you would name them. I understand that getters and setters aren't very idiomatic, but I thought that becasuse these are making remote calls that the naming was appropriate. Do you think changing, for example GetSummonerByID to just SummonerByID is preferable? 2. I agree and actually would have probably changed some of the value names had I remembered this feature. I only remembered when I was almost done with the first iteration and I saw that the ChampionStat Count value was actually just sent as 'c' in the json. That was when I remembered tagging the values. I will probably go back through and do it for all values just to be thorough. For now though it is my understanding that it should have no ill effects at the moment. 3. Good call about using the Decoder. I forgot that existed. If I keep the global/singleton type model, would you recommend keeping the json.Decoder a global variable, or would the memory benefits be negligible? 4. Both yours and /u/nickpresta 's suggestions are indeed better. This is once again something I noticed half way though writing the code, and figured I would just keep as is and change in a later iteration. The current version is definitely not as maintainable as it could be, and is something I plan to revisit soon. Thanks again and I hope the library can be of some use to you!
Thanks for looking at the code. I made a post to /u/surmair that mentioned your suggestion. Your suggestion is the more correct way to do it, and I realized it about half way through the library, but what I had was working, and I figured I would just revise it in a later iteration. I appreciate you looking into the code, and I hope the library will be of some use to you!
You are right, it is against the TOS, that doesn't mean I don't want do it anyways ;) But seriously: Let's assume I want to launch a service and I want people to provide their own API key so I don't have to use mine to avoid running into rate limiting problems. I know that I could register an official app with Riot, but Falcon Pro (a Twitter Client for Android) had similar problems and now offers users to enter their own Twitter App's data to circumvent vendor locking. It's just the flexible approach. It's not your responsibility to enforce TOS. It's also good code design to not have side effects. This is my 2cents tho, it's totally up to you which way you wanna go :) As for the Getter/Setter issue: Take a look around in the standard lib. Setters are fine, Getters usually at least omit the "get". So I'd exepct something like `riotApi.Champions()` instead of `GetChampionList()`. That's why I called it a very minor nitpick ;) 
So I built this for myself because I need to run multiple TLS applications on the same port of a server. They all need to run over port 443 to have the best possibility of running on port-filtered networks. They're not HTTPS connections, so nginx won't do. I can't really afford to buy a new server for each application/version. Adding additional IPs is an option, but requires complete server restarts. stunnel is an excellent alternative, but as far as I can tell, won't let me multiplex traffic without terminating it. So I ended up building slt. Hope someone else finds it useful!
As damn_redditors said, it's easier to just send the address than the entire object. Imagine asking someone if they want to come over your house and instead of giving them your address, you grab a huge crane, tear your house out of the ground, and drive it down the road to their place.
True. Just wanted to be sure something hadn't gone over my head. Always learning :) thanks.
Writing program is essentially to build logic within memory space under the hood. Object is a representation of a memory block. Pointer can be imagined as directories accessing those memory blocks. Reference is like a nickname of pointer in the sense that both point to a memory address. Modern languages often abstract this knowledge because it is not easy to handle allocation and deallocation of memory.
The program has undefined behaviour.
Nice! I had plans on writing one of these myself (https://groups.google.com/forum/#!topic/golang-nuts/bt-onu7RiKQ). I think I'll fork it and implement the hot config portion here soon!
Objects in Python have headers (a few bytes of data preceding the actual value on the heap identifying the type of the value), and if they're aggregates (which is the case for all user-defined "struct-like" objects written in pure Python), these subcomponents of aggregate objects have to be allocated separately with their own headers. You can't refer to anything else in Python than to a beginning of an object (the header) in memory. This is the same principle that, e.g., Smalltalk has been using since time immemorial (with a few exceptions such as LSB-tagged SmallIntegers, for performance reasons and to save memory). OTOH, in Go, *any* value is simply "a piece of memory somewhere" (just like in C!), and you can get a pointer to it (just like in C!). The problem is, a pointer to a raw block of data is unusable as an object - you can't tell the type (interpretation) of the raw block of bytes you're pointing to! The only way you know that the number pointing to a block of data is of a specific type is because the compiler tracks the types at compile time and generates the correct machine code if you're doing a type-specific operation such as fetching a field of a struct etc. But this doesn't work for objects (passed into a function that operates on their dynamic type), since objects, by definition, are supposed to "know their own types" - that's why they have headers in other languages. No "ordinary" value in Go has a header as such, though. But Go has a special type to overcome that - an interface. Since (non-interface) values don't have headers, in order for object-like references to them (interfaces) to work, the type is carried by the interface itself. Think of a Go pointer as of a *single* C-like pointer saying *"this is an address of a beginning of a block of memory, and the size and interpretation of the block ("the type") is implicit in the (static) pointer type"*, whereas a Go interface value are *two* C-like pointers saying *"this first pointer is an address of a beginning of a block of memory, and this second pointer points to data telling you the size and interpretation of the block pointed to by the first pointer"*. This mechanism gives you 1) the ability to use C-like raw blocks of memory as objects, 2) the ability to refer to "inlined" sub-components of blocks of memory as sub-objects without wasting memory on headers, both of which give you 3) easier interoperability with C. Besides that, it also gives you 4) no need to use "wrappers" for primitives like Java does it if you need them as objects, and 5) both "value" and "reference" types in a similar sense as .NET does it, *without* having to implement two kinds of types in the language and the runtime - the implementation of these two notions is "unified" and you decide how you want to use your types. This was my greatest point of confusion before I realized how this worked. Having come to Go from Smalltalk/Lisp-like languages, I was constantly asking "but where are the headers, if you have late binding for methods?". That was my big "Aha!" moment, because the language spec didn't bother to explicitly point this out (or at least I didn't notice that, perhaps they've changed it or I was just blind). The one problem with this is that it complicates garbage collection, and I'm not sure how I'd go about doing an incremental generational GC like the ones that Lisp and Java tend to use these days. However, this is somewhat compensated for by not having to do finely granulated allocations all the time, since you can simply allocate a bunch of stuff at once and carve it into pieces by using "inner" pointers (pointers pointing inside the atomically allocated blocks), and by being able to do stack allocations by default (escapes are impossible unless you explicitly pass a pointer). To summarize: all non-pointer, non-interface values in Go are blocks of memory (like in C), a pointer is a special single-machine-word value pointing to a *statically* typed value, and an interface is a special two-machine-words value pointing to a *dynamically* typed value. And you can have a pointer and an interface pointing to the same place without things getting jumbled up. Anyone more knowledgeable is welcome to correct me on anything. :-)
I'd gladly accept a patch for hot-config reloading
You'd probably want to add a quit channel, so the other go routines don't become memory leaks.
Your answer does exactly what he's asked for, but do you think its possible to improve it further? If he retrieves it from cache and returns it, he's going to be hitting the disk anyway, potentially slowing other reads and writes. Would a different approach bring better results?
The point is to leverage concurrency by not having to wait for all queries to come back. You only wait long enough for the fastest query to return.
Other goroutines won't become memory leaks. Channels are garbage collected and once the variable is out of scope the channel and all it's content would be garbage collected
If you check the documentation, you'll see that for actually outputing a % you need %%. Any other letter following a % will be consumed as a format and in this case a invalid one. The string you're getting %!R(int=5)%d(MISSING) means that R has the int 5 bound to it but it is not a valid format and %d's value is missing. Not sure what to say but that's just the way the fmt's pkg *printf family of function works.
This seems like a fairly common problem in all server contexts. Could you explain to a neophyte how this is solved in other languages and frameworks?
If the channel was unbuffered, then there would be a leak because the other goroutines would be blocked on the send. However, all the goroutines have exited so the channel should be garbage collected as normal.
ty for your response! i guess i have to write a scanner to detect and add another "%".
what? that would mean you are using dynamic format strings those are a bad idea in most languages as they can be abused and exploited in various ways, I am sure go is not an exception there either although there was probably more attention paid to such issues this time
I didn't notice the buffer. 
Use `%%` see http://play.golang.org/p/Anzh0_tz6S
It isn't, because it's a problem on the remote end. You often can't unquery something, or unsend a packet, or tell something to stop, and even if you can, sometimes it's still a bad idea; violently quitting a shell pipeline is not always a good idea if it's going to write something, for instance. It doesn't matter what you hack together on the client side if the remote end can't cleanly cancel.
If you've got some confidence about the timings (and I do mean _some_, you need more than none but you don't need total confidence), you may be able to squeeze out a win on average by trying the faster things first and giving them a certain amount of time to respond before trying the things you think will be slower. Your worst case time will go up but you may see a net reduction in resource consumption (as you'll go from still hitting the database on every hit to only hitting it sometimes, and that's usually relatively expensive). This is a risky move, though, because it will also destabilize the system, in the physics sense of "destabilize" rather than the programmers sense of "make more crashy". If the system comes under load and misses its initial cache hit because of that, it may choose to hit the database for the query, increasing load on the system, and causing the _next_ query to be that much more likely to also miss its deadline, further increasing the load. Hitting the cache and waiting for its response, hit or miss, may be slower on average but shouldn't have a surprising non-linear explosion under load. Which is not to say there's never a time to do the time-bound thing; just be _aware_ that it may have bizarre load characteristics. You may not care if your load is very unlikely to ever be variable enough to matter; a B2B app may have a very predictable load, whereas a consumer app may be very spiky depending on how the publicity goes. Only you know/can guess.
Note to the person who downvoted this post: Please could you provide a reason for your downvote? I don't mind you downvoting my post, but at least provide a decent explanation as to why, rather than just mindlessly slamming that arrow, which is helping no one :/
At first i thought that you would like to have new kind of TCP/IP stack, where applications negotiate their ports during each connection, but probably what you really meant is that you have multiple domains and one server, and you would like to map each domain to different application handler on the same server automatically.I see it might be useful in development, when you want to quickly setup environments for multiple applications. Take a look at [pow](http://pow.cx/) - it's made for Rails-based apps, however you can look at the concept, and see if there is something simillar for PHP. In production this approach is useless, because: * Usually there is only one, max two applications running on the same server. Each application needs only one listening port, and adding the automation here would be an overkill * Managing multiple open ports would have security implications - remember, each open port is a risk, which should be considered when we do production systems * In a complex system, there might multiple services talking with each other, and well defined and stable ports are very much welcomed If you have multiple servers in production, you usually use some kind of software to manage them all at once - google Puppet, Chef, or Ansible. probably you could use them on development as well - in a matter of just writing some proper script for that. 
Yeah, multiple domains and a single server is my setup. It's mainly for a handful of little projects I'm working on that I would like to host on the same box. pow looks interesting, but I'm not sure it quite fits my needs. I see what you mean about production applications tend to run on their own servers, which would explain why I've not found anything like this from Googling. I guess it's kind of a niche case. Is there any alternative way of achieving the same effect? I mean, instead of using TCP ports to listen on and proxy, is there another way to pass the requests and data back and forth from the apps to Nginx?
That's what I've been doing essentially at the moment. However, that manually assigns it's own hard-coded ports, and I would have to manually assign these again in Nginx, which is a process I'm trying to avoid.
The code on this article is horribly formatted. It's almost illegible.
I'm not sure how direct you want it, but it's trivial to make linked lists. class Person: def __init__(self): self.name = "" self.nextPerson = None first_person = Person() second_person = Person() first_person.nextPerson = second_person
Reddit has an upvote/downvote system where posts get a random, small amount of up/downvotes to (kind of) "salt" the system. Good/interesting/relevant posts raise with votes anyway (like yours) and bad go down faster.
nginx can pass requests to upstream unix socket listener.
You could use unix socket, which essentialy is a special file on filesystem, which acts as a channel of communication between two applications. It's common to set up php-fpm this way. It will work only if the nginx and the application are on the same machine (which seems to be your case), but has one big advantage over using TCP/IP stack, because it's faster (it doesn't have to go through whole stack encapsulation). Still, you have to define this file path in application configuration (it's listener duty to create such file, and in this case the application is the listener), and you have to place that path in nginx configuration. The semi-automatic thing you could do here is to make the names of those files to look like domain.name.sock (.sock extension is the standard way to name unix socket files). Then you could get the host variable in nginx, and create the proxy URL using these schema. Then you would have do the same on the application part, if you have some source of naming for each of those application.
One way you could handle this if you're feeling ambitious is to do most of the routing in your own proxy service, which you could certainly write in Go. The proxy would: * bind to a configured port, to which web app processes can connect, to register themselves as handlers for particular domains. * bind to another configured port, to which Nginx is forwarding requests for many different domains. * route HTTP requests from Nginx to the registered web app processes. ["net/http/httputil"](http://golang.org/pkg/net/http/httputil/) would be useful here.
Would using text/template be better here? Dynamic format strings are almost always Wrong™.
Pongo?
I should have clarified further, this was more of the approach I was looking for. Of course, I could just spin off goroutines and let them go, but it does seem wasteful.
that is actually a really good point. ill give it a try, ty!
Thank you! I have been looking for something like this for gosublime!
I do this when working with python and UWSGI. Instead of uwsgi_pass, he should use proxy_pass. http { ... upstream mywebapp { server unix://&lt;path to socket&gt;; } server { listen 80; server_name "domain.tld"; ... location / { proxy_pass mywebapp; } } }
Oh... well now I look silly lol. Thanks for the explanation :)
github.com/youtube/vitess/go/czgip it a faster drop-in replacement for the slower gzip package.
There's a simpler solution... http://play.golang.org/p/fQ9ymRrMFg
I recently tried to link some cpp code into a Go project to push the rewrite of that code a little. After some research I found [this](http://stackoverflow.com/questions/1713214/how-to-use-c-in-go) approach. You basically cut down the API you want to use to C declarations so that cgo can link against them.. For larger code this can get out of hand quite fast. The only alternative I found (until now) is the recent support for Go in [SWIG](http://www.swig.org/Doc2.0/Go.html) which kind of automates this for you a little bit (maybe I got the docs wrong, I didn't try it yet.) If I'm not mistaken this approach enables the use of library functions from any language/build process just by defining the arguments and return types in go code, thus you can ship/use libraries for your target which are (pre-)build outside of the go build process. From what I've read,cross-compiling code using cgo also doesn't work too well. This approach would help there, too. 
Thank you. The answer to that question from linked site: &gt; There’s no immediate plan. Go does ship with a Go program parser written in Go, so the first piece is already done, and there’s an experimental type checker in the works, but those are mainly for writing program analysis tools. I think that Go would be a great language to write a compiler in, but there’s no immediate plan. The current compiler, written in C, works well. &gt; I’ve worked on bootstrapped languages in the past, and I found that bootstrapping is not necessarily a good fit for languages that are changing frequently. It reminded me of climbing a cliff and screwing hooks into the cliff once in a while to catch you if you fall. Once or twice I got into situations where I had identified a bug in the compiler, but then trying to write the code to fix the bug tickled the bug, so it couldn’t be compiled. And then you have to think hard about how to write the fix in a way that avoids the bug, or else go back through your version control history to find a way to replay history without introducing the bug. It’s not fun. &gt; The fact that Go wasn’t written in itself also made it much easier to make significant language changes. Before the initial release we went through a handful of wholesale syntax upheavals, and I’m glad we didn’t have to worry about how we were going to rebootstrap the compiler or ensure some kind of backwards compatibility during those changes. &gt; Finally, I hope you’ve read Ken Thompson’s Turing Award lecture, Reflections on Trusting Trust. When we were planning the initial open source release, we liked to joke that no one in their right mind would accept a bootstrapped compiler binary written by Ken. The *edit:answer to the question* I pulled out of this context ~~from that is answered in the start of~~ as given in the document explaining the compiler plans: &gt; Writing the compiler in C had some important advantages over using Go at the start of the project, most prominent among them the fact that, at first, Go did not exist and so could not be used to write a compiler, and the fact that, once Go did exist, it often changed in significant, backwards-incompatible ways. Using C instead of Go avoided both the initial and ongoing bootstrapping problems. Today, however, Go does exist, and its definition is stable as of Go 1, so the problems of bootstrapping are greatly reduced.
Wouldn't that mean writing half a C compiler in Go as well?
Plan 9 is still being developed? It's cool they are trying to get rid of all C code for good.
&gt; When we were planning the initial open source release, we liked to joke that no one in their right mind would accept a bootstrapped compiler binary written by Ken. This sentence made my day. 
&gt; a compiler bug that prevented the fixing of said compiler bug Huh. I guess that means it's easy to accidentally implement some language features in a [metacircular](http://en.wikipedia.org/wiki/Metacircular) way.
[Plan 9 from User Space](http://swtch.com/plan9port/) [9atom](http://9atom.org/) [9front](https://code.google.com/p/plan9front/) 
The translator itself could be in c instead of go.
Great post, but I'm confused where the .ddl and .so files live. Do they site next to the compiled binary? Or can you include in the final binary somehow.
Why not make a Go-&gt;C translator in Go+C instead, then Go could take advantage of the quickness and portability of C, without people having to deal with C. Or if you were a man of pure evil, Go to C++.
`FirstDayMonday` should not be a global variable. Global variables like that are thread unsafe. The two functions that use it (`BeginningOfWeek` and by calling that, `EndOfWeek`) should either take it as a parameter, or they should use a hard-coded default (possibly overrideable on a per-`Now` object basis) and a second function for each should be offered that allows you to set it. You might want to allow arbitrary days; [there's a lot of variance on "week starts"](http://www-01.ibm.com/software/globalization/guidelines/c11.html), and once you're allowing three different choices you might as well just throw your hands up and allow arbitrary.
Is that a reference to the trusting compilers paper?
True, but why would you want to do that?
To his Turing Award lecture, yes. It was about a compiler that had a special backdoor: When it compiled a clean version of its own source code that had no backdoor, it would insert the backdoor in the new compiler's output binary anyway. Thus the backdoor could continue to propagate and remain on your system, even if you only ever compiled trusted source code, provided that you started with a tainted compiler binary. Obviously, other trojan horse functionality could be embedded in the backdoor as well. Thompson himself used it for debugging purposes. So the joke is that of all the people in the world to accept a compiler binary from, Thompson is the most suspect. The fact that you don't really have a choice among different compilers makes it even better.
They have... http://beego.me/docs/intro/
Yes... it says it in the previous sentence.
Go is in the same performance league as C - and in many cases, has the right architecture to outperform it (it's a matter of compiler's maturity). Moreover, it would be quite difficult to implement some features without resorting to assembly, which kinda defeats the point of generating C.
&gt; scripting languages are utility languages, not a core language as most treat it. Expressiveness is the key. Short feedback cycle is the key. If your application code is not the bottleneck, it makes perfect sense to use any toolset that produces correct, concise, maintainable code - quickly. This is the case with 95% of webapp programming; buffer-overflow-free text processing or getting those two remote API requests executing in parallel with the database query is far more important than using typed tuples instead of hash tables, or optimising your for-loop to be branch-predictor friendly instead of passing an anonymous function to `map` - when your result set is 30 rows. Machine time is cheap, programmer time isn't, I think we've agreed on this some 25 years ago, when Perl arrived. So good luck with C/C++ when you've got two months from discovery phase to delivery. This is how projects look like where I work, and while usually I have freedom to choose any tech I like, I'm simply not taking risks with what is clearly not a tool fit for the job. I like Go a lot but I'm still using it only for internal, non-critical stuff. &gt; targets an audience of people who are too stupid to ever program well. So you're writing your word count programs in WEB? :)
FirstDayMonday setting is not encourage to use, but use Monday, Sunday, EndOfSunday.Once it is used, this value should never be changed. But you are right, I regret this already, but haven't change it because of compatibility. Not sure I am right or not ;(
I recommend changing it. If someone's using that flag, it's a very sneaky problem that they could blow a lot of time on. If they aren't using that flag, well, it doesn't hurt them. :) In a more strongly-typed language, you only need to worry a lot about compatibility problems that sneak up on you at run time. This is an immediate compile-time fail, when they try to access `FirstDayMonday` and it's not there. Those are a much less big deal; the combination of the fairly-obvious compile error and a release note is fine.
RTMPing -- that sounds interesting.
Beego is awesome.
That was one of the most enjoyable tutorial videos I've watched in a long time. 
The point of writing the compiler in Go is to have the compiler written in an elegant, readable language. But if large portions of it are auto-generated by a translator tool, it will be none of those things.
For anyone who (like me) couldn't initially find the content on this page: http://traffic.libsyn.com/dickwall/The_Java_Posse_431_-_Brad_Fitzpatrick_on_Go.mp3 
A `&lt;-chan` can only be received from. You can't send on it. [Remove the `&lt;-` from the printReceive in this playground posting](http://play.golang.org/p/IeVKJBqDKy) and you'll see the difference. This is useful to guarantee that the function in question won't sneakily send on the channel you pass in. See also the functions in the [time package](http://golang.org/pkg/time/) that pass back receive-only channels to the user.
He had a good chapter in [Coders at Work](http://www.codersatwork.com/brad-fitzpatrick.html)
Agreed, it's an abstraction sort of thing to help prevent misusing the API. In addition it would prevent one from closing the returned value (since receive-only channels cannot be closed) and ensures that the one who created the channel is the only one who can close it. On the other end of the spectrum, returning a chan&lt;-string prevents you from receiving from it. This is useful because you could have multiple things writing to the same channel, and if one of them receives from the channel a value could get lost. It just lets the compiler double check for misuse of API, and has actually caught me accidentally breaking my own API a few times. Therefore I deem it pretty useful to always return recv-/send-only channels when appropriate.
Unfortunate choice of name, it clashes with the (very interesting) project from agl: https://pond.imperialviolet.org/
In many cases, sure. In many other cases, it can be. Please don't point to the alioth shootout, it's representative of little and sets rules about what you may do - see disqualified entry I submitted that was on par with C in binary trees, for example - http://benchmarksgame.alioth.debian.org/u32q/program.php?test=binarytrees&amp;lang=go&amp;id=6 * Note here - this wasn't my idea, it was further editing upon an earlier submission. It's all in how you write the code. Idiomatic Go is not typically as 'fast' as idiomatic C in many cases, but it doesn't need to be. If it does, write it in C or manage your own memory in Go.
I'd really love to see more of this.
Real men use command line tools 
&gt; The high performance with JSON serialization summons a possible theory: Perhaps Go is being performance-tuned for the same set of workloads most directly associated with frameworks like Node.js. What does this even mean? The original microbenchmarks are of dubious enough usefulness, derivative articles like this are pure linkbait garbage.
The web
Its been a long time since I've created (or really used) a GUI that wasn't created with HTML to be honest. In all honesty, what kind of apps require native widgets these days anyway?
I'm trying something quite drastic and just doing my own UI from scratch using OpenGL. The advantages are that it'll run exactly the same on OS X/Linux/Windows (edit: in browsers via WebGL also), and I'm not artificially limited by anyone in what widgets can be created. The disadvantages are everything else hehe. See some screenshots: https://dl.dropboxusercontent.com/u/8554242/dmitri/projects/Conception/images/Go/Live-gofmt-with-rewrite-rule.png https://dl.dropboxusercontent.com/u/8554242/dmitri/projects/Conception/images/Go/Basic-Widgets.png It's largely a work in progress, and basically an interim solution until I figure out what kind of UI I want and better alternatives become available.
Doesn't Light Table do something like that for its UI?
I'm not an artist. But I can find a zillion who can make me an HTML/CSS interface that looks amazing. Then its 2 or 3 lines of jquery to plug different actions into different rest calls on my Go backend. And now I have something that can run in any browser, as a native app (same way iTunes and Steam are really just browser widgets accessing an HTML app), runs on an iPhone or Android etc, can run as a local app or run transparently over the network with with multiple users. That's a pretty straight line (at least for me), super flexible, and super cross platform. My only real complaint there that I have to write some logic in JavaScript. But with projects like NaCl and ASM.js the time where I can wire up the front end in any language I want is very near. [ edit ] But please tell me if its stockholm syndrome. I honestly haven't used native widgets since a GTK+ project I did in 2004. (it was terrible)
As much as I like go, my response would be to ask "Why is it a requirement to use Go for this?". At the moment, Go is brilliant for servers and for web applications. It's great on the command line. However it's a long way from being ready for any sort of release level desktop application. Any such work is still strictly experimental and likely to be loaded with bugs, pitfalls, and problems to which nobody currently knows the answer. Not to say that you couldn't work to help solve those problems, but what you're doing there isn't developing a desktop application, it's developing the tools and knowledge to create a desktop application.
In my work, I mostly do web applications, but I sometime make desktop app as a hobby. I love Qt, a lot, I started learning it when I'm a student, it has changed so much since (more Qt tool makes your work different), but I hate C++, I don't want to do many extra things just to get it run. So, I ended up using PyQt/Pyside and *mostly* happy with it. Then I know Go, it fits my work as a web/server tool, it won't throwing my variables around without knowing what it is like Python, it is compiled language with many similar to C++. If it can make my life outside work easier, I'd be happy. As a general purpose language, a GUI toolkit is a must. I don't think some language which works reliable in server application will have bug in desktop application, if there's any bug, it's in the GUI toolkit, not the language. 
I love this idea. This is brilliant. It is a ton of upfront work, but it is the "right answer" and actually insanely portable anywhere any flavor of GL will run. I work at a Go shop, and we have kicked around this exact idea as our dream setup. A fully featured OpenGL based UI is basically a dream. 
Also, it is niemeyer... so I have super high hopes. He "gets shit done" -- mgo, pipe, go-check, goyaml -- those are just his packages I use every single day. 
I've been waiting on any SDL2 wrap to become stable, but after months none did so I'm using SDL2 directly. Quite easy writing your own UI in Go and SDL2, and then it'll be identical on all platforms.
Awesome!
For quite some time now, I've wanted to reverse the the file system usage: these days, most compilers use the file system to fetch source files and deposit object files and binaries. I thought that with all the Plan 9 heritage, the Go toolchain, once it's in pure Go, could easily become a file server (9P?). You save a source file (onto the mounted VFS). The toolchain process actually saves the file to some permanent storage (in a Venti-like/Git-like fashion), and the change trickles down all the way to the binaries even before you say "build it". (Most of the time, "build it" would just check that it had, in fact, already been built! ;-)) It also works in a cloud setup: if the builds or tests are slow, add a few machines. If a machine burns out, the redundancy/replication kicks in automatically. And even if you don't have a dedicated build farm (a small company?), the connected desktop machines could still share the resources, because not everyone is compiling at the same time (and they could also serve as each other's automated backups as well). And based on profiling data from the test runs and performance runs, perhaps you could run a continuous optimizer like some Oberon variants experimentally had some time ago, with some expensive optimizations being delayed - and added to the mix when they're done, with a bit of luck, when you're deploying. (In fact, especially for small companies, automating many of these things would probably be a huge win. Just look at all the people who don't use version control, who don't have regular backups etc. "I don't want to care, just do the right thing" simply seems like a pervasive theme in Go, so it sounds like a logical follow-up to that. Make things work automagically. I really don't want to care.) Of course, it would be even better with the editor being a more integrated part of it, but this would be nice to start with. ;-)
Have you seen the [VPRI research](http://vpri.org/html/writings.php)? Perhaps stealing some of their ideas regarding the UI architecture would prove fortuitous for a Go-based UI effort, what with Go's focus on composition and concurrency.
I have no opinion, except that I am delighted that I am not the only one converging my world view between Rob Pike and Niklaus Wirth.
better ide..
Is it really necessary? Actual *efficient* N-dimensional computations, the way I see it, would require deferring the computation to the last possible moment, while constructing a tree of the operations demanded by the program, then either generating native code on the fly or offloading it to some specialized hardware (OpenCL, for example). None of these scenarios would actually require Go to have language-level multidimensional arrays. Also, working with multidimensional arrays using indexing and indices efficiently would require a vectorizing compiler, while a higher-level interface could work in an APL-like fashion and generate vector operations from the higher-level operators. Perhaps it's a little bit of an overkill, but you said "science", which implies really big datasets to me. :-)
@earthboundkid, GoConvey already does automatic testing as soon as you save, complete with desktop notifications. Merry Christmas?
An official, blessed package manager with a repository like CPAN or PyPI or npm or [...], instead of combinations of `go get` and things like `kr/godep`. I understand the appeal of working from `master`, but maintaining dependencies in a big project is a challenge. `kr/godep` is the best solution right now but I think the Go community can do better.
Real Generics! Generics have put Rust over the edge for me as my experimentation language of choice.
Package/library management for reproducible builds without third party tools or forking all required libs into my project.
What does this do?
It's definitely a portable solution, but there is one potential problem holding it back. You have to take great care to optimize it to render lazily, and if possible, request the less powerful graphics card to be used (in the case of Intel + dedicated gfx card environments). Otherwise, the battery life and fan noise will make it feel like you're playing a 3D game rather than using a simple desktop GUI app. I know Blender, the 3D modeling app used to render its UI in OpenGL and it worked fairly well as far as I know.
If Rust ever drops the semicolons, Go's sunk! ;-)
What about godep leaves you unsatisfied?
An IDE with code completion and debugger. I knows about the existing ones but they are not that Good.
So every developer should write their own tool in their own workspace because thus isn't addressed in core? I'm not saying it isn't possible to overcome. I am saying it's a bad decision from the core team to not have this solved. And what I want for Christmas is to have it solved as part of the core library go command line interface.
Rust looks like a bloody mess to be, but I must say that I secretly wish Go's performance was as good as Rust's. *&lt;sigh&gt;*
Generics, and looser assignability on function types. I forget what it's called, but the ability to make `compress/gzip.NewWriter` assignable to a variable of type `func(io.Writer) io.WriteCloser` would be nice.
I started hacking on this for funsies at one point, and then realized due to the number of un-exported helper functions, I would basically have to fork stdlib's "net" :/
Versioning
oh, I see thanks.
See the [web benchmarks](http://www.techempower.com/benchmarks/#section=data-r8&amp;hw=i7&amp;test=json) and think about that [this commit](https://code.google.com/p/go/source/detail?r=28a4d13557a99de31746a59fd0d07ddcfeed351b) wasn't included.
Full SOAP support either via official or third party. 
I don't know how do you render text, but RTL is a common pitfall when you implement from scratch.
better/mature gui toolkit
[sockjs for go](https://github.com/igm/sockjs-go/) is in development, at least!
Will have to keep track of that. 
Slight on topic question for you, what are you using Ada for in your stack? 
I was reading the matrix discussion on the mailing-list, but for some reason I wasn't able to come up with your solution... although at University, I already did something [similar for python](https://github.com/shelajev/ut.parallel_computing_2010_project)... but the offloading was to the MPI instead... Basically, we had Distributed Programming course and had to implement PageRank using Python+MPI, obviously the straight-forward calling and communicating with MPI got confusing. So I made a special "Processor" that dispatched commands and communication orders to "Nodes" and they calculated the BiCG in parallel... it was fun :). I think you should suggest that approach to https://groups.google.com/forum/#!forum/gonum-dev, it might get some attraction. At least, I think it's a brilliant idea.
Thanks for the detailed write up, that was a very interesting read!
We are using Ada on the custom made Tablet devices. It's responsible for gathering data from the sensors, displaying a user interface for the pro and uploading the data to the central servers.
It has always seemed insane to me to store your Gmail password in plain text on your server. That's certainly asking for trouble (even if it's an app-specific password). Something like Mandrill (via https://github.com/mattbaird/gochimp) or Amazon SES (http://aws.amazon.com/ses/) are free/cost cents for low volumes and the API is just as simple as net/smtp. var message gochimp.Message = gochimp.Message{ Subject: "This is a subject", FromEmail: "you@domain.com", FromName: "Big Dave", Text: "Hello there", } message.AddRecipients(gochimp.Recipient{Email: form.EmailAddress, Name: form.Name}) response, err := mandrill.MessageSend(message, true) // send it async if err != nil { // log error or return it if not async }
Wouldn't that benchmark show encode performance, not decode?
Hi egonelbre, thanks for your reply, but as casualsuperman notes, I was talking about decoding, not encoding. The benchmark you linked to concerns encoding. Encoding and decoding are different despite sharing many letters. 
What exactly is the problem?
Mostly that i'm a noob. i'm very experienced with rails, and deployment is a breeze using capistrano or even straight to engineyard or heroku. Go? nothing. i'm not sure what approach i should take, monit or upstart. what are the best tools for the job. and google doesn't seem to offer much examples. Biggest problem, and i'm sure many techies will relate with me - i'm so stressed at this point i can't even think. If there's any chance you could walk me through the setup and deployment script it will save my ass and job. :(
Deploying Go applications can be as simple as copying the executable to the server and running it. Does your use case require a full blown deployment system?
If your deadline is tomorrow, just compile for your target platform and upload the binary to the server. Than use OS init system to start the service for you (use systemd or upstart). Done.
i wish it would be that simple it's running across over 20 instances for scaling
Considering the launch date, doing it manually once shouldn't be too horrible idea. I agree it's probably not optimal long term solution in larger systems though.
Get the job done today by uploading 600MB (30 minutes?? probably a lot less) and manually starting each one. Get it done *today*! Tomorrow you can take your sweet time looking for automation tools..
Deploy it manually today, wait until you're not stressed, then act. I don't know the technologies you've referenced as being familiar with, but if they're worth anything at all, they ought to be able to be convinced to take a compiled binary and run it. It is literally the simplest possible deployment there is. Today, though, BASH is your friend: $&gt; INSTANCES="192.168.1.1 192.168.1.2 192.168.9.88" $&gt; for i in $INSTANCES; do ( scp source.exe $i:/final/destination &amp;&amp; ssh $i "restart command" if $!; then echo $i failed; fi &amp; ); done Or something like that; not 100% sure where the &amp; goes, which parallelizes the whole thing; if you're content with serial deployment remove it. Save your INSTANCES variable in a file somewhere or something so you don't have to recreate it over and over. Regardless, I hope that's enough automation to drop the stress level down to something manageable; deploying a new binary at the last minute is no longer a lot of human work, just a lot of computer work, which is where the work belongs.
What are the known syntax warts?
this sounds like a plan. jerf it seems you have a grasp on go and experiecnce. is there any chance for a chat call? my username is yariv.m
This. There's doing it right and then there's not doing it at all.
I use systemd: https://github.com/badgerodon/deployer/blob/master/scripts.go If you're using ubuntu here's an example upstart script: https://github.com/badgerodon/deployer/blob/ddc2087c0f1038d26b797cb8ae4cc87605010b8e/main.go I'd get your binary onto the server, install one of these init scripts, then make an EC2 image and clone.
lol why?
I have no idea whether you require that scale but keep in mind that Go might be able to handle in one or two instances what your ruby app would require 20 instances. Disregard if you really need 20 instances :)
Check out Salt: http://docs.saltstack.com/ http://docs.saltstack.com/topics/tutorials/walkthrough.html 
This looks great! Nice to see some progress being made on the GUI front.
As it happens I just released my [[]byte pool implementation on Github](https://github.com/thejerf/gomempool) a few days ago. You can probably get a win in parse/parse.go:getRawPages line 67 if instead of appending to an emptied byte buffer you get one out of the pool instead, by size that you know on line 67, and if you can work out where you "return" the []bytes (which I assume you probably do). You're definitely working the GC by creating a lot of extremely varied sizes of []byte only to throw them away forever mere milliseconds later. You can do even better if whatever that is is already loaded into memory as a []byte and you can simply slice and directly pass to the XML parser, but I don't know if that's what you have at that point. Given the size of the corpus in question, I'm assuming not. I see you aren't using concurrency now, but if you choose to in the future you might want to run this through the race detector. I don't think the IDGenerator is thread safe. Also, you should be able to tell `NewIDGenerator` the final size of the `map[string]int64` in the make call; I'm not sure how big a win that is, but it's cheap to try. It's definitely weird to me that `GetID` is nearly as expensive as `getLinks`; the latter ought to be much more expensive.
Do what they said, set the system to run the program on startup. Then go to AWS, right click on the instance, and click create image. Now go to launch instance, set all the right options, choose the image you just made (it takes some time to actually make the image btw), and have it start up 20 of them. Voila. This won't scale up/down automatically with need, but will buy you time to properly figure that out, while also saving you from manual setup. Another thing is that your app needs to figure out how to configure itself. Also if you figure out a good solution, tell me, cause I'm doing the same thing right now...
[GoSublime](https://github.com/DisposaBoy/GoSublime) works very well for me. But I am holding out for an [official IDEA plugin](http://youtrack.jetbrains.com/issue/IDEABKL-5938).
This seems relevant: http://blog.labix.org/2013/12/23/qml-components-with-go-and-opengl
This is very interesting for me, in the the context of my post [here](http://www.reddit.com/r/golang/comments/1tdd7v/what_is_golangs_solution_for_modern_crossplatform/ce6xkl9). 
I don't know who really is but when he says along the línes that he "started to worry about what language his hypotetical children would use blah blah" he sounds to me like insufferable know it all kind of person, ugh! I much prefer to hear Rob Pike talk about Go, way better overall guy.
&gt; someone who is prepared to commit to writing level 2 and 3 blas routines in asm would be certainly welcomed. That would be great. When I was playing around with both, go.matrix was about three times slower than biogo, and I think it was because of the different blas package used (combined with my particular use case)
Using mmap (gommap) should help with the syscalls: you only need to set it up once, instead of doing many reads. Also, check out the [Pool](http://tip.golang.org/pkg/sync/#Pool) on tip which should help reducing garbage generation.
Upload to S3 your go binary. Install s3cmd on each server— or build an AMI. execute Capistrano script to download binary from S3. Run the whole thing with supervisord. Enjoy Christmas. 
I'm launching a large golang deployment on AWS in a couple weeks, and spent the last week or so load testing. For deployment, I've been really happy with fabric/cuisine (in python). For me, it's world's better than capistrano, but I'm a python guy. Just simple and easy to use. Given your launch is so soon, I think by far the simplest thing to do is to make one server manually, create an image, then clone it and put it behind a load balancer. Keep in mind, it depends on your architecture, but go(lang) may not be your weak point--there are generally many points of failure. My go servers were crashing under load and I finally fixed it by switching to a better router (gocraft) which didn't open extra sockets. It's hard to get everything right without testing. You may want to look into hiring a consultant for launch day, because it's likely things will go wrong. Start with a friend who knows AWS, and also pay for AWS business support. There are fancy 3rd party companies that AWS may recommend to you, too. Good luck! 
I can't find them right now - but typically Rust's performance is very comparable with C, while Go usually can't even beat Java, performance-wise. EDIT: one example: http://togototo.wordpress.com/2013/07/23/benchmarking-level-generation-go-rust-haskell-and-d/
Ahhh, all my favorite gophers except Dave Cheney are giving talks! I have to go!
It would be nice if these were recorded and uploaded to YouTube. I'd watch mostly all of them xD
I'm going to try to get my company to pay for the trip, but if not, i'd gladly pay for webcasts/videos. Any chance of that?
This is really cool. It's very nice to a complete go app that is not web based. What has your experience been with the lack of version pinning in Go and the GC? Get an unlucky GC pause and you could crash.
The comment does not show up because there's a blank line between the comment and the package statement. http://godoc.org/github.com/njern/gonexmo
Thanks - fixed it right away!
This is nice. But, I really do not care about 0.01s vs 0.13s. What I do care about is not having to deal with installing Ruby tools and their endless mess of dependencies. That for me is the single strongest argument to do this in Go. One binary. Done.
That's what goprotobuf does, it uses pointers and the nil value means uninitialized. It is simple enough for many situations but it is not my favorite solution, I'd rather have variant types like in Haskell, but for an imperative language pointers, special values or OOP seems the only way to handle this. 
Why does being imperative preclude variant types/algebraic data types?
after all, everyone on reddit knows haskell is the best imperative language, if not the only actual imperative language in existence
Rust is certainly imperative, and it has a Option type. 
It would be fantastic if they replaced javascript in QML with go! The javascript is definitely the biggest weakness in Qt 5. Shouldn't be that hard right...? /s
Codesearch looks great, but I don't see what I'd use it for. Any use case?
You can get something quite like [sum types in Go](http://www.jerf.org/iri/post/2917) using interfaces, but that won't help much in this case because all variables of an interface type will also themselves be able to be nil, thus making them useless to avoid nil.
This is my first blog post as well as my first post about Go. I would love any feedback. 
Nice to see more SMS services getting Go libraries, good work :)
I think it's extremely cool, I just wish I could think of a use case for it. Maybe alerting, but then emails are more flexible and expressive. :(
This is a big deal. Android apps written in pure Go? Yes please.
Go on ARM isn't anything new (I've been using my ARM chromebook to write and compile Go code while I'm traveling for several months now), it's just that there didn't used to be a tarball anywhere and you had to compile it yourself. What's keeping us from writing Android apps in Go is the fact that Go compiles to machine code (for the particular platform that you're working with) while Android apps need to be bytecode that the Dalvik VM can interpret on whatever platforms it runs on. As far as I've seen, Google officially has no interest in making Go work with Android.
Also, it's part of the 1.3 roadmap to make it part of Go's stdlib.
Well, it's more that the NDK would need to be available from Go, which would require writing a ton of wrapper library functions. 
This is interesting, but it's a far cry from writing Android apps in pure Go, unless you want to write a game or something and use nothing but the native input/drawing/etc. APIs. If you actually want to build a typical android app and use all the associated standard libraries, what you can do with Go (or any other native language) is very limited and it'll have to be called from a Java app.
This looks great. One addition that would make this much more useful would be placeholders. For example, say I wanted to translate "We're sorry, but $username$ is already taken" -- this sort of translation requires that the i18n system support placeholders and replacement patterns. I think Drupal does a pretty great job at this sort of thing. It's PHP, but provides a good example. https://api.drupal.org/api/drupal/includes%21bootstrap.inc/function/t/7
Thanks! Although I don't think that placeholders are necessary since you can just use format strings: fmt.Printf(i.T("We're sorry, but '%s' is already taken"), username) This is the approach [gettext uses](https://en.wikipedia.org/wiki/Gettext#Programming) and it seems to work well.
Ah right, that makes sense! Thanks.
At a glance it's not clear how to handle plurals (as in ngettext, where there are mutiple strings to choose from depending on number).
I'm not super familiar with Go, so maybe this is a "thing" in the Go world...but I would recommend changing the name. It's going to be impossible to search for, not to mention I would imagine a lot of people use i as a single letter variable. I understand you're going for "simple" but there are so many other names you could've used that are much more descriptive and still give a simple feel rather than "i". My gripes about the name of the project extend to the source code as well: Why single letter variables? Why is "ts" a DefaultStorage? Other than that, I think it looks good and would probably give it a try if I needed some internationalization :).
Although to do this right, you need to use the positional specifiers added in Go 1.2 when you have more than one substitution: "foo %[1]s bar %[2]s" because in another language they could be reordered: "arb %[2]s oof %[1]s"
Short variable names, especially for method receivers, is idiomatic. However, I have to wonder why it's "ts" as well. I'd expect "s" or "ds". Maybe "ts" stands for TranslationStorage, but then that obviously doesn't make sense because there's neither such a type nor such an interface. As for the package name, I agree. As it is currently, pretty much everyone will have to rename the package when importing it.
My reasoning behind the short name was so that it would be easy to internationalise a package by simply replacing all “naked” string literals to the modified, so ``outputFunc("foo")`` would easily become ``outputFunc(i.T("foo"))`` with not much space taken away. I didn't really think of name conflicts, since as you said anyone can give any package another name, or do the “dot import” (which would give the developer a pleasure to use the beautifully short form of ``T("foo")``; as well as a headache with ``Storage`` and ``Source``…). But the use of “i” in a for-clause really escaped my sight. Maybe I will change the name once I will find the package mature enough to be called stable and get a 1.0 version. Maybe I'll rename it “ee”, so that the pronunciation bit could be removed :) &gt;My gripes about the name of the project extend to the source code as well: Why single letter variables? Why is "ts" a DefaultStorage? ~~Oh my dog, someone is actually looking at my code. Wat do?~~ /u/dominikh is mostly right. Short names (with moderation) are idiomatic in Go, and in it's early days the package's ``Storage`` and ``Source`` types were ``TranslationStorage`` and ``TranslationSource`` respectively. But then I decided that I don't need names that long and shortened them. But the short variable names remained. I do need to work on the uniformity of them throughout the package to make it easier to read.
You don't need to do: if err != nil { // handle it } else { // handle success case } Just do: if err != nil { // handle error } // handle success case
Was the written for an older version of go? Running `go build` on 1.2 had a bunch of errors that needed to be fixed.
No using go 1.2 on linux here. But I did not tested it on any other platform
Also 1.2 on linux... Seems like my changing things to use relative paths for imports for playing around with it locally caused the problems.
I would replace your entire OAuth bit with https://code.google.com/p/goauth2/ -- it handles creating a client for you that is authenticated, and allows you to specify a cache file for your token. I would then also use go-github (https://github.com/google/go-github/blob/2ab27f559fda344eca289bff137efd0241c8da71/github/gists.go#L160) to create (and possibly edit/delete) your gists. Your library can then just focus on being a command line wrapper that provides a way to interface with go-github/goauth2.
Thank you!
Thanks! Personally I use it for monitoring and alerting, and for two-factor authentication. If you find something cool to do with it, please let me know! 
Yes, but where's the fun in that? :-)
I guess you're right :-) Still, integrating well tested third party libraries into a tool that provides convenience is still pretty fun. Or maybe I'm just weird.
those two flows are only identical when error handling results in leaving the scope (e.g. return from a method), which not always must be a case
It is traditional to use very short identifiers in localization. I would suggest a period-import is appropriate here, so you just get `T("string")`. The module containing that should export as little else as possible, to facilitate that usage. Of course your library doesn't control that, but I would freely use it in the examples. Then make your package name something descriptive, because you expect it to only be topped in the import list, once. Best of both worlds.
In *this particular codebase* it was.
Hah, I also have a program called [gost](https://github.com/cespare/gost). (It's not for gists, though.)
It simply depends on the goal of the author. Are you trying to make something useful, that doesn't already exist, to make people's lives better and allow them to do something they couldn't before? Are you trying to make a library that is meant to offer that and be used by people for this specific need? In that case, he should absolutely refactor it to write as little code as possible while getting the job done. It seems that go-github and goauth2 exist to do most of that work. Or is he trying to learn the language and get better at it, so that he can do something new that hasn't been solved already in the future? In that case, it's completely normal to just rewrite something that exists for the sake of learning and so on.
One idea is to use a meaningful name and demonstrating the import rename for the short form. Import I "package.name/International"
As you can guess, learning and having fun is the primary goal. Excellent gist clients already exists, like [defunkt's](https://github.com/defunkt/gist). My goal was to mess with the language and get my hands dirty, but if one day it gets too popular, I'll consider integrating well testes third parties libraries
Oh c***, don't mind if I keep the name?
Not at all.
That sounds like a good plan, and you seem to do doing well with the language so far! +1
do it for the community, please change one or the other name!
I'd say reading the standard library helped me the most to understand the basic patterns and best cases.
Gahh, this makes me want a 3D sound library in Go even more.
Also, https://github.com/nf/deadleaves : "Command deadleaves finds and prints the import paths of unused Go packages."
I saw that and thought it was a little weird as well. What's the point of that? It makes the code far less readable.
He didn't want to think of appropriate names https://github.com/bradfitz/goimports/pull/26#issuecomment-30389623
That's actually not bad reasoning. They're small enough projects to where it doesn't matter all that much I guess.
Thanks, dmikalova! Forgot to include a link.
For anyone considering the localhost server + browser solution, this is the best option I've found: [golang-nw](https://github.com/lonnc/golang-nw) It uses node-webkit to create a webkit window and open a localhost port for communicating between your go binary and the webkit window. In your go app, you implement an http api. For your GUI, you use html/js. **Pros** * Webkit is the GUI * Node-webkit has prebuilts for linux 32/64, win32 and osx32 * A .nw spec file can be distributed for those who must build node-webkit themselves * Does not interfere with cross-compilation * Reusable as a remote web interface **Cons** * Not completely native * Node.js involved (although you won't need to deal with it)
Luckily, self-posts can be edited ;).
If I can import `so` into my package locally (via a dot import), then I'm mega +1 on that. I don't like having to qualify `c.So` for all my assertions.
Author here, please ask away if you have any questions. Thanks.
I would have needed some for X-mas.
Give a late present, say he "got lost burrowing here - should have taken left at Albuquerque".
I'm actually about to implement an API server in Go, and while net/http allowed me to do the prototype quickly, now I need some utilities it doesn't have an I really need. Routing is not one of them though: 1. Input validation and automatic casting. e.g. I want lat,lon parameters to be parsed as float and fail the request automatically if they are invalid. 2. JSONP wrapper to responses 3. Automatic error handling, including PANICs in request handlers without crashing the entire server. 4. auto documentation of the API. A nice bonus would be API key rate limiting and such. all these are not very hard to do but net/http doesn't have them and it doesn't make sense I'll have to write them myself. So yes, net/http is not enough beyond very simple serving and static files.
Or [make your own](http://oylenshpeegul.wordpress.com/2013/10/16/all-yarn-gopher/)!
You may want to consider making it easier to support generation of these templates from within code; this would make a useful addition to a website framework, which would draw from its internal data structures and write this stuff out directly, without passing through .json files for no good reason. It doesn't look like you've _blocked_ this, but it could be easier. I'd suggest an API where you can create an Alpaca object, call a series of "Add" calls adding a new call, and finally render it out. Also, the types on alpaca.Data don't help. There's an awful lot of `map[string]interface{}` flying around; is there really no narrower type that can be applied? It makes it hard for me to follow the code, because I don't understand what's in those structures.
It was sitting in a buffered channel. 
The first suggestion looks interesting. I will think about it. Regarding the alpaca.Data, I wanted to postpone defining the data structure since I am pretty sure there will be a lot of changes soon to accomodate many things. That's why I am using `map[string]interface{}`.
New. Make. Special operators. 
Very interested in this, great work. While I realize that the protocol is language agnostic, how about calling the syncthing utility 'GoSync' ;)
Finally! I've been wanting one of these over since I started using Go. Ordered and now waiting.
$35 shipping to Canada from the Google Store is absurd. :-(
$126 for international shipping :-( 
The funny thing is that my experience with go has been largely similar to the author's in that there is nothing to get overly excited about and everything just works. Once you get the hang of a few weird things like the directory layouts and the packages, you can focus on writing fun, clean code. On the whole, I'm enjoying my stint with go, coming from a year and a half of python.
O_o
what the hell??? How is that justified?
Why not just contribute to [Camlistore](http://camlistore.org/) instead?
&gt; Not a lot of synatic sugar and features to get super excited about (I would love to see pattern matching Real talk: Pattern matching just means, "Function that starts with a switch statement," in hype-speak. :-P
This is very neat!
We need it in the europe store!
Thanks ! 
[HyperLogLog](http://algo.inria.fr/flajolet/Publications/FlFuGaMe07.pdf) improves on LogLog by 64% in terms of memory consumption. Moreover [HyperLogLog++] (http://static.googleusercontent.com/external_content/untrusted_dlcp/research.google.com/en/us/pubs/archive/40671.pdf) improves on HyperLogLog even further by reducing it's memory consumption and improving the accuracy for certain cardinalities. There are existing implementations in almost all languages. At my company we have a Go implementation of a persistent realtime HyperLogLog on top of LevelDB. The implementation does 100s of millions of operations each day. I hope to get that implementation open sourced soon. Finally [stream-lib] (https://github.com/addthis/stream-lib) has a Java implementation of [HyperLogLog] (https://github.com/addthis/stream-lib/blob/master/src/main/java/com/clearspring/analytics/stream/cardinality/HyperLogLog.java) and another of [HyperLogLog++] (https://github.com/addthis/stream-lib/blob/master/src/main/java/com/clearspring/analytics/stream/cardinality/HyperLogLogPlus.java)
thanks ! I didn't know about Hyperloglog or HyperLogLog++. 
What's the advantage of this vs goamz ([here](https://launchpad.net/goamz) and [here](https://github.com/mitchellh/goamz))? Also, AWS best practices are to use roles and have the machine authenticate for you if you are making a request from an app that's located on an EC2 instance. Does this support that?
Goamz performs lots of functions related to some Amazon Web Services. Go-Aws-Auth is lightweight and only for signing requests, but it supports nearly every Amazon web service. As for getting temporary credentials based on IAM role within an EC2 instance, it's not yet supported, but pull requests would be welcome until we have that need internally at work.
A big advantage indeed! Which is why I linked to the fork by Mitchellh as well on Github.
Great point.
Anyone want to do a comparison to using Sublime Text?
Personally I'm also excited for [Go Lime](https://github.com/limetext/lime), I hope I can start contributing to it in the future.
Looks nice -- very small and simple. Thanks!
I use Sublime for the main reason that it isn't trying to be an IDE. It has a nice directory view (project) and with a simple build setting I go all of my go commands without having to have a terminal open (though I usually do anyway.) I like to work this way because one of the driving factors behind go is they wanted a language that didn't need a powerful IDE to enjoy writting it. Beyond that this plugin doesn't seem to give much of anything useful right now, though that is sure to change with future releases.
What does it do better than godoc.org?
At first glance it does the basics of what GoDoc does, but also provides: * Test/Build pass/fail * Code coverage (with HTML presentation) * Doc coverage * Golint concerns * Some form of [Cyclomatic Complexity](http://en.wikipedia.org/wiki/Cyclomatic_complexity) All together on one page. Seems pretty neat.
*First paragraph from linked [Wikipedia article](http://en.wikipedia.org/wiki/Cyclomatic_complexity):* --- **Cyclomatic complexity** (or **conditional complexity**) is a software metric (measurement). It was developed by Thomas J. McCabe, Sr. in 1976 and is used to indicate the complexity of a program. It directly measures the number of linearly independent paths through a program's source code. The concept, although not the method, is somewhat similar to that of general text complexity measured by the Flesch-Kincaid Readability Test. --- ^[(?)](http://www.reddit.com/r/autowikibot/wiki/index) ^| ^[(CC)](http://creativecommons.org/licenses/by-sa/3.0/) ^| *^I ^will ^automatically ^delete ^my ^comment ^if ^score ^is ^-1 ^or ^less.*
Attach should take an io.Reader not a string. A string is inflexible as it requires you to attach on-disk files.
I'm glad you're reusing net/mail rather than re-rolling it yourself.
Cool idea, besides it does not work. I gave it a shot with github.com/gorilla/rpc, what happened afterwards it went into infinite loop trying to import github.com/gorilla/undefined...
How does this handle conflicts? Edit: "Currently whichever file has the newest modification time "wins". The correct behavior in the face of conflicts is open for discussion."
Thank you for noticing this!! Makes my day, actually. I told myself that I would try to make it a priority to reuse existing ("proven") modules as much as possible to both help with stability, consistently, and readability. Almost every example or other library I found trying to implement email would do things like roll all the MIME stuff themselves (Go has a MIME package), or refuse to reuse net/mail for things like parsing email addresses, etc. Though, in the specific case of using net/mail, I actually received an email saying that this didn't allow for special (unicode) characters in the display name of the email address. I may have to look into ways around this if it turns out to be an issue with net/mail. Thanks for the feedback!
Yes, Ditto.
IMHO the IntelliJ plugin does a better job at code suggestions and it is easier to browse function and struct definitions (hold down Ctrl and click). This update has major improvements when it comes to handling GOPATH and GOROOT.
Intro here: http://ahmetalpbalkan.github.io/go-linq/ I appreciate your feedback!
Could you please expand on this a bit more? I'm still fairly new to Go, so I'm trying to see how I could keep as simple as possible, but allow flexibility. As it stands, a user does not have to open the file before sending it to attach. By requesting only the file path, I handle all the issues of opening and reading the file contents, etc. It sounds to me (*I could be wrong*) that by requesting an io.Reader, I would be removing this, and making an extra step for the user (but gaining some flexibility to support any io.Reader). Also, this would affect generating the Content-Type header of the MIMEtype. Currently, I use the file extension given to determine the appropriate content-type. Any suggestions as to how to best handle this with a generic io.Reader? Thanks again for the feedback - the goal is to always make the best possible package.
This is my first full-fledged project in Go, and I'd especially like feedback on writing idiomatic Go, if anything seems amiss in my code. If you have any thoughts you'd like to share, please feel free to PM me or post a comment. Your thoughts are much appreciated!
I'd maybe do both? As /u/AeroNotix says, being able to attach an io.Reader means, for instance, that one can pass in something that's reading from a gzip.Writer, which itself is Reading from a tar.Writer, which itself is Reading from a socket, etc. etc. On the other hand, as you say, the convenience of you handling the (undoubtedly most common) case of disk-file + MIME type is great - so maybe rename "Attach" to "AttachFile", which opens the file and susses the mimetype, then calls "Attach(io.Reader, ContentType, AttachmentName) or something.
This is awesome! Time for me to host a tracker!
Thank you! It performs well in our testing, but I do wonder how well it scales once it reaches a large number of peers. I'm certain there are ways to improve it.
Why'd you delete this and repost it? Also, more on topic: how do you fake generics? Is it just a `interface{}`? In which case, doesn't there need to be explicit casting at some point?
This sounds like it may be the best option. I personally *really* like how easy it is to currently attach a file - just pass in the filename. But, I also want to provide flexibility so I may just create AttachFile, and repurpose Attach to accept an io.Reader as suggested, allowing the user to pass in the ContentType. I'll work on this a bit tomorrow - thanks everyone for the feedback!
Hey! I've added some golint checks and made the package `go get`-able as well as `go build`-able: https://github.com/mdlayher/goat/pull/9
This is fantastic advice - exactly was I was hoping for when making this package. Thanks!!!
Thanks, and merged!
Why are you using a make file?
Some implementations of probabilistic data structures, including hyperloglog: https://github.com/dustin/go-probably
Sounds interesting. Someone let me know when it's up again, because right now it appears to be fried. (No sarcasm or snark; I'm a programmer, I get the whole "unanticipated problems after release" thing.)
So it's not a "magical hack"?
&gt; Is there a better way? Yes, use the standard Go build tools and don't rely on Makefiles. If it's *really* necessary to save keystrokes, set a bash alias. Idiomatic Go projects never use Makefiles when dealing with pure Go - it's an antipattern because, if it feels necessary, that's amost always a sign that the project isn't correctly structured to begin with. One of the design goals of Go was simplicity around the build toolchain, and eliminating reliance on Makefiles is part of that. *EDIT* Just saw you merged my pull request - thanks!
I've updated the package accordingly - let me know what you think! Thanks again for the feedback.
I've updated the package accordingly - let me know what you think! Thanks again for the feedback.
Uh, context? I'm not sure if you're asking some sort of legit question or trying for some sort of sarcasm I'm not getting? (prf\_q doesn't seem to be claiming any magic...?)
Visit the intro page (linked in another comment: http://ahmetalpbalkan.github.io/go-linq/). &gt; Bring your type &gt; &gt;There are no generics in Go, but go-linq's magical hacks let you use your types with no trouble.
&gt; If it's really necessary to save keystrokes, set a bash alias. I don't understand the objection to makefiles. Is it really better to have a team have to share and update bash aliases than to have a Makefile hold the same rules?
I have the following aliases in my .bash_aliases: alias gb="go build" alias gr="go run main.go" I have a very low tolerance for typing.
If anyone figures out how to run a project using the new plugin, please suggest. http://stackoverflow.com/questions/20918041/using-intellij-golang-plugin-how-to-run-entire-golang-project-instead-of-a-sing
The error handling here is terrifying. Running errcheck on it gives me 47 ignored error return values and a lot of the actual error checking just logs the error and then blindly continues. All the database Save() methods, ignores any errors from the database and just returns true. 
Nice one - just the ticket.
The idea though is that the build and install procedures are supposed to by consistent across the whole ecosystem by using the built-in tool chain. Using makefiles creates fragmentation in the ecosystem.
Thanks. But doesn't limiting on x-forwarded-for invite trouble with things like office networks and ISP proxies? 
I think I am bad at choosing title. toki is just a tokenizer that uses regexp; not a "regexp tokenizer". the reason that I created this is because I am writing a css3 parser, and the gorilla/css/scanner is outdated(based on 2003 revision). the actual css scanner that uses toki is [here](https://github.com/taylorchu/css3-beautifier/blob/master/css/scanner.go). only tested on bootstrap.min.css (which has about 100000 tokens).
X-Forwarded-For is the "remote IP". Remote ISP proxies aren't usually a problem as these are typically transparent (carrier NAT will be, though). Office networks can be, but 10 req/s can be tweaked. Ultimately however, I don't know of another "simple" way to rate-limit remote connections. If you rate limit by IP + a combination of anything else (e.g. User Agent) then you're potentially allowing the remote end to spoof the details and bypass your rate limiting. I'd be curious to know how someone like GitHub rate limits their login forms.
The real problem with doing this is the semantic difference between a generator and a goroutines. A generator computes values on demand, a goroutines computes values before you ask for them. A closure is a far better generator.
Interesting. How would you do Euler #2 with a closure?
I'm just going to show how to create the Fib sequence from a closure, which is the relevant bit to your question, I'm out of time locally: http://play.golang.org/p/Ct5j9N-sVd Note there's no globals anywhere there; each invocation of `fibs` will return an independent generator.
I disagree. Makefiles have always been there to automate various non-trivial tasks. Using Makefiles that call the go tool as part of more complex build targets is totally legitimate. Also, muscle memory.
I disagree. If the channel is unbuffered (the default, and in many cases the preferred behavior) computation of the goroutine sending values will halt until the runtime detects that there is a receiver waiting on the channel. Comparing closures to generators to goroutines is a false dichotomy - in Python, except for the built in generators, generators often (always?) are implemented as closures, and goroutines are similarly very often implemented as closures. In Go, you want to use a goroutine + channel for generators in any case where concurrency is important. Go, as you know, contains lots of facilities to make concurrent processing and lightweight IPC a first-class and fast option. The overhead of channel signalling is not much more than the overhead for calling a continuation in a closure. (Did you ever notice that computer scientists seem to be obsessed with the letter 'c'?). Doing so even lets you do things you can't actually do in Python (at least not easily) like having multiple generators running at once, concurrently, with the output all being gathered in the order it was produced. Channels running in goroutines is a perfect idiom for 'generators'. In fact, I wrote a golang library called 'Proto' to do stream operations on nested generators for just such a reason. [Here's that library](https://github.com/eblume/proto). In one project I created tens of thousands of these streams and the laptop I was running it on didn't choke one bit, outside of needing about 100MB of memory for callstacks.
The issue is with timing and ordering. A generator creates the value when you request it, the goroutine creates the value immediately after the previous receive. If the value relies on timing or ordering then it will be incorrect. Eg. A timestamp generator would be completely wrong if implemented as a goroutine.
Many thanks.
I don't see ordering as being an issue unless the specific time of execution effects the order of elements produced, which I see as an implementation detail that doesn't detract from the usefulness of using channels as generators in the slightest. Similarly, I can only imagine timing issues being something that matters outside of constant-time operations (in which case concurrency is automatically ruled out anyway, unless using a very strict constant-time scheduler... the sort used in military hardware) or in the specific case of a timestamp generator. As far as timestamp generators go, golang has time.Timer which returns a channel that generates Time objects. However, that function ultimately calls a C runtime library. I can't tell if it's a system call or just a library written in C. See [runtimeTimer](http://golang.org/src/pkg/time/sleep.go?m=text) in the `time.sleep` module. But in any case, you will notice that the standard library uses a channel to generate the Time values (even if under the hood it's got some other stuff happening). Edit: Since tone can be lost on the internet some times, please know that I'm not trying to be belligerent or mean or something. I just happen to be very fond of using channels as generators (I prefer the term 'stream', personally) in Go and so it's something I know a bit about. Your first post said "**A closure is a far better generator.**" and I'm just trying to point out that I think the assertion is unfounded. No offense intended or taken. :)
Not exactly - with a zero-buffer channel, the producer will begin each iteration the moment the previous iteration's result is retrieved from the channel. In this snippet, "goroutine continued" is always printed before "waiting for two": http://play.golang.org/p/J7a5CMwOxR
Yup, I believe I pointed that out.
It seems to require an ending slash, e.g github.com/gorilla/rpc/ should work fine.
Is this month mimimi generics month? Edit: Oh, it's from August 2013.
I don't want to be mean, but why all the examples that try to prove Go is bad are actually lame? His type-switch snippet for built-ins can be easily reduced to: switch v := reflect.Typeof(x).Elem(); v.Kind() { case reflect.Int32, reflect.Int64: ... case reflect.Float32, reflect.Float64: ... On the other hand, are abs(), min() or max() really the only problems that system programmers are trying to solve?
No, but they're short, easily understood snippets that show the problem. Even your improvement of the code is still a lot worse than the if x &lt; 0: return -x return x equivalent that many languages will let you do.
What about: var i = int(math.Abs(float64(x))) (ok I know, it's lame :D, but I'd rather see abs(), min() and max() as builtin functions rather advocate for generics using them as an argument)
I really like the sort package. I used it in much the same way as you did to sort things based on time here https://github.com/arzh/godo/blob/master/item.go (important bits are lines 85-108 and 181-196) Now it's based on time right now, but I plan on putting in one to sort alphanumerically based on Item.Note. With this structure I would just have to add one function (two if I wanted to expose it as a method of Items) Now your example is much simpler than mine, which I'm guessing is why you don't understand why it is written that way but when you get to sorting more complex data structures it is quite nice. I will agree with you though that Time should have been included with all the built in types into the sort package, you might suggest it to go-nuts and see what people think. 
What about -9223372036854775807 the abs of which according to that (at least on the copy of Go I have here) is 2147483647 (or -9223372036854775808 if you cast to int64 instead). I get what you're saying, and yes they probably should be builtins, but they aren't and it's frustrating to fix without large amounts of boilerplate and casting all over the place. Let alone doing anything even slightly more complex.
&gt; you I don't think that the person who wrote this article a couple of months ago and the person who posted it here are the same.
Just discovered this plugin today. It's wonderful! No bs go-to definition under cursor.
&gt; I wanted to like Go a lot. I wanted a fast, compiled replacement for stuff I write in C right now. But Go is not that language. Shame. I would argue that Go is exactly that language: a language that is a decent compromise between C and higher-level languages. The type system hasn't really gotten in the way (actually, my one quibble has been that `int` (`uint`) may be `int32` or `int64` (resp. `uint32` `uint32`)) because I don't have need of type polymorphism. I don't miss generics either. Extensibility is a nice language feature (it is one of the reasons I do a lot of work in Lisp) but is not a deal breaker in a systems language, IMHO. You can argue that C++ is the language OP wants: it's extensible (launching off from his example, CLOS : Common Lisp :: STL : C++). It has generics. Its type system is polymorphic. But compare the readability of C++ to Go. 
Sure but I am also not responding to OP, I'm responding to the author.
I suspect another way to write Abs would be as a method on a user defined type, eg. Int(-8).Abs() which is somewhat reminiscent of Ruby's -8.abs. It still requires manual specialization, but these "boxed" types can be passed around either directly or via an interface. Whether the conversion and/or dynamic dispatch overhead are worthwhile is another question. 
I suppose that's the point of the article. If I want type safe and generic map() and filter() functions, they need to be added to the runtime as builtins. And the same for anything like that. It goes without saying that these builtins are harder to change down the road than your own library. Several small language additions over time may interact in strange and peculiar ways. Or alternatively, years pass before being able to express something the way you'd like. Martin Odersky has a talk on type systems up on InfoQ. He mentions some of the pros (and cons) of Go's approach before deep diving into simplifications planned for Scala's type system (while maintaining it's expressive power). That said, I'm still a big fan of Go, as I prefer the particular set of trade offs it makes for the kind of work I do. 
I never really done Haskell, so that might be the reason I don't understand his example. In the Go abs function it's pretty clear what happens when you parse it a string, you get nil, but what happens in the Haskell case? Do I get nil (or what ever is the Haskell equivalent) or do I get a runtime error?
I wonder if the whine about the lack of generics will ever die down.
Then wouldn't it be more appropriate to post underneath the article instead of here?
Not if I wanted the discussion to be here and not on an old blog post
Haskell has a thing very like Go interfaces called Typeclasses. One of the big differences is that the typeclass can declare a class as one of the incoming parameters, and then use that "same" type as an outgoing parameter [1]. In Go terms, it's as if you can write this: type Num interface { func add (value SOMETYPE) SOMETYPE } Where "SOMETYPE" is actually a variable "type" itself, not a type with that name, and then implement it as: type myint32 int32 func (l myint32) Neg (r myint32) myint32 { return l + r } type myint64 int64 func (l myint64) Neg (r myint64) myint64 { return l + r } and then use it: func test () { var a32, b32 myint32 var a64, b64 myint64 fmt.Printf("%T %T", a32.Add(b32), a64.Add(b64)) } and have everything typecheck out, with the final Printf yielding "myint32 myint64". Thus, abs :: Num a =&gt; a -&gt; a abs a = if a &lt; 0 then -a else a Translates to: "The abs function takes something that implements Num called 'a', and is then a function that takes in a value of that type and returns a value of that type." That could be a 32-bit Int, in which case you get a 32-bit Int back, or an arbitrary-sized Integer, or anything. In fact you can't get "null" or anything like "null" out of that function in Haskell. (At least not without contriving a fake example, and it still wouldn't be a "null pointer".) You can't pass anything in that doesn't implement Num; the compiler won't let you, just as Go won't let you pass a value to a function expecting an interface that doesn't implement that interface. I haven't spent enough time on it to be sure, and I'm not sure this would work, but I've been tossing around the idea of trying to figure out how to make this Go-ic enough to work in Go, too. I haven't had the time to really sit down and hammer through the problem to see if it can be made to work. It certainly doesn't just come right over, I'm not yet convinced there's nothing that can be done, though. (Also, incidentally, that code is buggy. "&lt;", less than, is not part of the Num interface. For that you need "Ord", which is Orderable. In the actual [Num interface that ships with Haskell](http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#g:7), "abs" is actually one of the elements of the typeclass itself. This example doesn't actually compile.) [1]: Haskell experts, yes, I am well aware there's more than that; I'm simplifying for the local context.
Job well done. What's up with v 1.0 release?
As the language becomes more popular, probably not.
This is the third article I've read today on why Go's type system sucks. The previous one I've read was far more rough, but in this context it just seems like "go bashing day" to me.
I love Go. I really do. I've written a lot of it. I'm falling head over heels in love with Rust though, and these things ring true in my heart. edit: I know it's early days for Rust, I'm not trolling though.
&gt; We are in an age where a language tends to be judged by the number of features bolted onto it and where language simplicity and elegance is secondary. That applies to the C++ crowd more than anyone else, in my opinion.
I think the problem illustrated is on the design end, not with the language itself. What is the purpose of a type-generic `abs()`, and what benefit does one gain from using it vs normal typed `abs()` functions for each type, and does that really offset the increase in code ambiguity, especially for less trivial examples?
I don't really see code design issues (perhaps as a resistance to coding for the language you're using) as a reasonable critique of a language. The bulk of it can essentially be summed up as "this example of parametric polymorphism that can be trivially implemented in Haskell is why I won't use Go for things I currently use C for" which strikes me as a rather awkward comparison.
&gt; the part that bothers me most about Go is the immature ecosystem, not any specific feature or lack thereof. You have too many unmaintained, immature or buggy open source libraries for just about any use case, but there are too few who are good, mature and maintained This right here is reason I don't use Go for more things myself. Hopefully as Go ages this will get better. 
&gt; You can argue that C++ is the language OP wants I'd argue that the language OP wants is Vala - generics, nice syntactic sugar for closures and proper classes. It compiles to C so it's quite close to being the ultimate "better C while keeping it simple".
There are two types of languages. Ones that everyone complains about, and the ones nobody uses.
Thanks! It was my first vimscript plugin. Let me know if you have any questions. You can also file bugs on github. (I know there are some open "It doesn't work" issues, but I think those are user error... I just haven't gotten around to closing them..)
&gt; vs normal typed abs() functions for each type Go doesn't allow overloading, so you'd have to do `Float32abs()`, `Float64abs()`, `Int32abs()`, etc.
Very nice work. It's great to have an alternative implementation of Go.
Re: the BigNum problem: If you're using big enough numbers or matrices, wouldn't you need the ability to reuse objects through mutation, and wouldn't that necessitate something like `a.Add(b)`?
I'd like it if Go supported a syntax like type T generic type Summer interface { Sum(...T) T } func Sum(ns ...T) { var total T for n := range ns { total += n } return total } Etc. 
Haskell is a beautiful language, and I strongly recommend taking a closer look into it. Even if you don't end up writing anything significant with it, it'll be worth it.
&gt; "I don't really see code design issues (perhaps as a resistance to coding for the language you're using) as a reasonable critique of a language." In my most serious, but somewhat astonished, voice, "are you serious!?" The design choices, or lack thereof, determine the amount of suckage developers will ultimately have to deal with if a piece of software goes mainstream. And, as unfortunate as it is, when not rescued in time, some software can suffer permanent and irreversible damage from the very developers that gave it life; the spawn then wreaks havoc on the community at-large for decades when the sycophant armies lure in the naive. 
Same here, but from pragmatic perspective, Rust is not a viable option: - Its not even 1.0 yet - It has very small community - It has literally no library support - It has almost no traction (in terms of marketing/hype) Therefore, I don't see it as something I'd want to bet my future on. I wish it luck, but for now, I feel safer investing in Go. For now, Rust is my Plan B.
Software development is intractable, I'd be more concerned if there was little or no criticism. 
I've been using it for over 4 months, it works well and is useful. Thanks!
I think you missed my point. What I'm saying is a poor choice of program design (as in the examples given to illustrate why the author doesn't use Go) that would not be considered idiomatic code for a given language does not constitute a valid critique of said language. One couldn't reasonably argue that JavaScript, for example, is a broken language because you cannot apply C++ specific techniques to it. That wouldn't make any sense there, and it equally doesn't make sense here.
Garbage collection.
Still, it seemed a bit overwhelming for one day, and there was a discussion in go-nuts as well. Someone suggested on the mailing list to dedicate an entire new mailing list to generics discussions.
The number of libraries are growing at a nice pace, and Rust can easily fill gaps in its ecosystem with C libraries thanks to its stellar ffi. The community, whilst small, is growing, IRC usage is steadily climbing, as is the activity on the mailing list, and the number of contributors constantly on the rise. It's certainly exciting times. It is not 1.0 yet, but it definitely is shaping up well. Come and have a chat on the IRC, we are very friendly. All this said, Rust and Go are targeted at different things – the Rust community doesn't see any battle between them at least.
Haskell doesn't have a concept of nil, eliminating a large swath of runtime errors. If you do want something like a nillable type, you can wrap the type in `Maybe`, but you wouldn't be able to pass that to the abs function without unwrapping it first otherwise you'd get a compile time error. - http://en.wikipedia.org/wiki/Option_type - http://hackage.haskell.org/package/base-4.2.0.1/docs/Data-Maybe.html - http://www.standardml.org/Basis/option.html - http://static.rust-lang.org/doc/master/std/option/index.html 
*First paragraph from linked Wikipedia article about [Option type](http://en.wikipedia.org/wiki/Option_type) :* --- &gt;In programming languages (especially functional programming languages) and type theory, an **option type** or **maybe type** is a polymorphic type that represents encapsulation of an optional value; e.g. it is used as the return type of functions which may or may not return a meaningful value when they're applied. It consists of either an empty constructor (called None or Nothing), or a constructor encapsulating the original data type A (written Just A or Some A). --- [^about](http://www.reddit.com/r/autowikibot/wiki/index) ^| ^&amp;#10003; *^(autodeletes if comment score -1 or less.)* ^&amp;#10003; *^(/u/bjzaba can reply with '+remove' to trigger deletion.)*
Roger that! My mistake. But at the same time one should expect those mistakes when advancing new ideas. 
His efforts don't get enough attention.
People criticize Go for gofmt? Gofmt is literally the single best part of Go. I miss it every time I'm working in other languages. (Most aftermarket code formatters are weak at best compared to gofmt, though Eclipse ain't too bad.)
AES is defined with a block size of 16 bytes. You need an encryption mode like CBC ( http://golang.org/pkg/crypto/cipher/#NewCBCEncrypter ) in order to encrypt large blocks of data. If you're not familiar with crypto, you're probably better off using something like http://godoc.org/code.google.com/p/go.crypto/nacl , github.com/dgryski/keyczar or https://github.com/gokyle/cryptobox that handle all of the details for you. If you need compatibility with an existing system, then you'll need more details about exactly what their system looks like.
Pretty normal... AES - like most encryption algorithms - works with a fixed block size, AES using blocks of 128bits - which equals to the 16 bytes you see there. You need to use some block cypher method, CBC being the most popular, for which I think methods are available in the crypto/cipher package, but I never used it. [edit] Looking at http://golang.org/pkg/crypto/cipher/ - it supports multiple block cypher methods, including CBC.
I noticed in your main(), you were ignoring errors from the encrypt and decrypt steps. Your decrypt call appears to be returning: err= Invalid padding length You might want to look into that.
I have been using Revel in a few projects, and I love it. Recently, I've tried out all of the many other players in the Go web framework arena. But I keep coming back to Revel. I'm looking forward to trying out v0.8.
I'm using CBCEncrypter and CBCDecrypter - check the source code please. Also note that I'm getting only the first three blocks of 16 bytes corrupted, as per my sibling comment.
Your implementation of "derive_key" modifies "salt" in "append(salt, derivedKey...)". Fixing this (e.g. two calls to hash.Write instead of one) fixes your code.
Fascinating. The salt slice remained the same, and the keys appeared to be the same in the output, but since the underlying array changed, the BlockMode.Cryptblocks implementation did not work as expected. Thanks so much, this did indeed fix it!
Nice! Finally a usable frontend to oracle! I hope GoSublime will pick it up, too.
Style nit: Go constants aren't spelled SALT_LENGTH. You want saltLength (if private) or SaltLength (if public). 
Style nit: ErrBadPadding, not BadPadding. Error variables star with "Err" or "err"
Anyone know where currentValue on the Apply() function is from and why it takes in a ctx but isn't used?
For the 99.99% of people (including me) who have never heard of STOMP: Simple (or Streaming) Text Oriented Message Protocol (STOMP), formerly known as TTMP, is a simple text-based protocol, designed for working with message-oriented middleware. It provides an interoperable wire format that allows STOMP clients to talk with any message broker supporting the protocol. It is thus language-agnostic, meaning a broker developed for one language or platform can receive communications from client software developed in another language. http://en.wikipedia.org/wiki/Streaming_Text_Oriented_Messaging_Protocol
I had no issues getting it working.
Look at using https://github.com/cryptobox/gocryptobox — which will save you a lot of hassle. Alternatively, take a read through the AES section of ["Practical Cryptography With Go"](https://leanpub.com/gocrypto)
A good idea, though it is more robust and arguably safer to just fork a repo onto your own github and then reference that. This has the added benefit of letting you import from a different side, vcs, etc. You can later upgrade your own version (or patch it) safely. Doesn't really take any more effort.
And it's particularly useful for replacing AMQP when working with RabbitMQ.
We need something other than /, though. httptools is a directory and / should still mean "navigate down the directory to find". If I had to make a concrete suggestion I'd go #, but there's a lot of good choices. (For gopin it makes sense, by its nature it is a bit of a hack, no criticism intended. But if it's going in core we need a different character.)
Clever!
Great idea! It's funny, I've been working on something almost entirely the same, after implementing [gobndl](https://github.com/beefsack/gobndl) and feeling like a sort of package proxy was a better idea. My project stagnated though and didn't hit the same level of completeness. Best of luck with yours!
Gotcha. I guess I had just tunnel vision on my phone early this morning! Thanks!
I agree fully. Maybe just have it as a second string? import ( "github.com/surma/httptools" "ef4a90a9c9a90152e154fa8ba46cc8858f3476ec" )
I really like tools like this seeing as it doesn't require anything special to work, it just works. I'm wondering if such a tool could be built around this concept for doing a git pull against a data-structure that is generic. Something like: import "github.com/deckarep/stack&lt;int&gt;" "ef4a90a9c9a90152e154fa8ba46cc8858f3476ec" Then in github the stack datastructure can be designed and tested against a single type but the type can be swapped out dynamically on an import during the GoPin proxy phase. I know i'm overly simplifying the idea...but it *could* work right?
&gt; fork a repo onto your own github and then reference that. How does that work with transitive dependencies? Let's say I use `foo` and `bar`. `foo` uses `baz` and forks a copy into its repo. `bar` also uses `baz` and forks its own copy. Then, when I try to use both `foo` and `bar` in one app, will I end up with a collision, or two separate copies of `baz` in my app?
You're saying that he should solve the problem in an idiomatic Go fashion, if I read that correctly. "The response of the Go community is “Abs is a 2 line function, just do it inline or per type” to which I respond: I want to define a generic algorithm, or datastructure, or really anything reasonably complex!" And he explains the issues with the Interface solution. Basically, the idiomatic Go is poor programming for languages with parametric polymorphism. That is to say, it could be solved in the same manner as Go does, but it would be the worse approach. &gt; why I won't use Go for things I currently use C for" which strikes me as a rather awkward comparison. Agreed, he did not demonstrate that C could do better. I suppose he doesn't want to learn a new language if there isn't going to be any gain in doing so.
I think not having shared libraries has been a reason for some.
Two copies, I reckon. Go stores reps by path name to URL. So you'll get two paths with similar content
Because the file should live in the root of your project's git directory.
That prime sieve code is for demonstration of goroutines only. It creates a new goroutine and channel for every prime number. Hardly the most efficient implementation. See the following blog on this. http://blog.onideas.ws/eratosthenes.go
There are two use cases to think about. The first is the standard "we are building something and use libraries" -- in that case, I think pulling dependencies off the internet is downright insane, idiotic, and just ill thought out. What if the github profile is deleted (read: this happened, see Atom), broken in non-backward compatible way, you need to make changes you don't want to share, etc. The other use case is I am building a library I want to share with others, and it depends on libraries... which depend on libraries... which depend on libraries. Here is where you can't just say "vendor it" and "test it" and be done. This is where versioning tools start to make some sense, but Go is not designed around having non-compatible versions of libraries living together. 
Brad Fitzpatrick's `goimports` tool will fail on some imports from gopin. Namely, those with a hash that happens to begin with a number. It ignores all folders that begin with a number. See this line: https://code.google.com/p/go/source/browse/imports/fix.go?repo=tools#225 If this is important to you, please submit a bug report.
FWIW, I made a PR for it earlier (see https://github.com/bradfitz/goimports/pull/26), but my rationale wasn't accepted.
In Python, pip uses the format, `github.com/foo/bar@tag` format. For Go, I'd probably like to see something like: import "github.com/surma/httptools" //@ef4a90a9c9a90152e154fa8ba46cc8858f3476ec 
Make a "template file" with T as the generic type then run `gofmt -r "T -&gt; int"` over the file: $ more ./main.templatego package main import "fmt" func main() { var v T fmt.Printf("Value: %#v\n", v) } $ gofmt -r "T -&gt; int" ./main.templatego &gt; ./main.go $ go run ./main.go Value: 0 $ gofmt -r "T -&gt; string" ./main.templatego &gt; ./main.go $ go run ./main.go Value: "" 
Thank you for leaving Go, for everyone's sake.
This is similar to automatically using jar-jar-binks in the Java world.
Great job axw! It's a coincidence that I just tinkered with llvm-go 2-3 days ago cause I need it for my project and it didn't work since I have go 1.2 installed. I noticed your plan for the ssa rewrite of your project and looking forward to see it take shape, I tried compiling the ssa version but it didn't work either. I couldn't believe the announcement just got out today that it's good for use already! Great!
I agree that coming from Python I quickly missed sets, but Python did not have sets builtin from the start. One can draft a solution for a simple case in minutes - the whole generics thing is another league, though. From my experience: I wrote a bunch of simple (non-concurrent) command line tools, which - in my specific case - outperform their Python and Java conterparts by a factor of 4 - and are outperformed by their C "equivalents" by a factor of 4, also. So it's there in between, with a readable syntax, fewer lines of code than Java, nice tools like "go fmt" and a growing ecosystem - so what's not to like? On the other hand, I love Python for my data crunching tasks, and libraries like numpy, scikit-learn, pandas, nltk etc. are not built in months, but years - I cannot except this kind of maturity from a language that is just a few years old. Also, cython makes it really easy to write fast modules, so Go will need to mature to get on such a level - if it would want to - I can see me using Go beside Python and Java. The few quibbles so far: * the builtin command line argument parser (flag) is a bit bare, would prefer something more --posix --style * import commenting/uncommenting - (this has upsides, too, it encourages you to think a bit slower and clearer, I suppose) * the docs could use more examples 
If you want something like --arguments, you can use something like https://github.com/voxelbrain/goptions.
Note this is from 6 months ago
Thanks for the tip, looks promising.
Why not just use a [set library](https://github.com/deckarep/golang-set)?
Very cool! I haven't had a chance to dig into gofmt at all. Thanks for sharing this.
It seems like the author missed the point of Go - a nice systems programming language. I assumed from my introductory experience and reading of Go that it wasn't meant for heavy computation tasks. Java or one of the functional languages would definitely be a better solution here.
&gt; more --posix --style The flag package allows both -foo and --foo
Generics solve one problem: Parametrisation. A common instance of this are containers. If you have a container you want to parametrise it over the type you put into it. Of course you could simply use interfaces but this makes it difficult to assert at compile time that the type of what you put inside is always the type you expect. Plus, you have to use tons of conversions. Personally I think you shouldn't stop at plain generics and go for fully-fledged Hindley-Milner type-inference with fully parametricable types. Perhaps I've done too much Haskell.
I dunno, I guess I continue being confused a bit here. For one, a container (say, array) must already be instantiated in Go with a given type, so that's not really it. I guess the thing becomes that you might want an array (container) with a bunch of different "types" in it, and then be able to strongly say which is which. Most of the time, that sounds like bad practice to me, unless, like you said, they're similar enough that they can share an interface. So then the next concern is that you end up needing to do conversions or assert what type it "really is". I don't really get that, since it seems to me like if you have 3 types that all match an interface, and are passed into the same container or function, then they should be handled the same way (i.e. call interface functions). That is, we refer to the Duck Typing golden rule of "if it quacks like a duck, throw it into a pond". If they're being handled differently, you should have separate functions. But there seem to be so many people that complain about this feature, that I must be missing something.
He is referring to custom containers. Arrays/Slices are ok but what if you want a linked list or a queue? Currently there is no way to have a generic type-safe container. Or even a function, that can operate on all different types of int for example. That said, Generics are awesome but it also has many drawbacks and adds a lot of complexity, which is the reason it's not in the language yet. 
I'm just reposting a comment I made on the post for the OP but thought might contribute to other people as well: &gt;This is not meant to be a bad comment or anything but I think you still haven't learned the Go way of doing things. For example, I used to complain about the lack of generics and some other things but after a while I realized that I was trying to program in Go the same way I'd in OO languages. &gt; &gt; Go is not OO, and it has other tools that when leveraged properly can pretty much provide the same things in a more decoupled way. Think "Composition Over Inheritance". &gt; &gt;That said, it did took a while to start getting things right. I hope you give Go a second change but with more time. Don't try to use it in a big professional project. Do some smaller side projects which you'll have time to rethink and play around with it. &gt; &gt;Also, keep in mind that Java is much much older than Go. None of the authors said Go won't have generics or that it's perfect the way it is. What they say though is that before adding something like this to the language, the design needs to be solid, it needs to fit the language nicely without adding much overhead. The standard lib is extensive (not as Java) but at the same time the open source ecosystem is still growing, but you can already find Set and BitSet implementations. It's super easier to roll your own as well, if you have the time. &gt; &gt;In terms of performance that did come as a surprise. Were you using Go 1.2? The compiler still does not optimize nearly as much as Java's JIT can, yet. But also bear in mind that Go's philosophy is different than Java. In Go, you have way more control over memory layout, allocations, etc., so that you can have more control over performance. That means if you neglect those things (like one would in Java), the language will not try to do optimizations around it but on the other hand, one should be able to squeeze more performance out of it by profiling, which would not be harder in the Java world since you don't have much control over those things as in Go. &gt; &gt;Anyway, don't take this post wrong. Just trying to share my learnings. &gt; &gt;Cheers
Java can be faster, but it's a lot more work. With Go you can do it the C(fast) way or the Go(slow) way, and generally it's best to mix both styles.
That's far from correct. Go is very fast, faster than Java in a lot of tasks, and it can and is used for computationally heavy tasks. Either directly or by wrapping C code. 
How would you return a Set&lt;Value&gt; in the ValueSet() function on a Map&lt;Key, Value&gt;? The Set and Map interfaces would need to be in different packages and the Map package would need to somehow parameterize its import statement.
Yes Go is certainly spoiled in this regard, official tooling and then both GCCGo and llgo as alternates.
I'm curious - would you use Go for implementations of statistical methods? I think that Python (pandas, numpy, scipy) and R (plyr, standard library) are far more powerful when it comes to matrix manipulation and have method implementations that are proven to work.... I'd be wary of rolling my own stats in Go.
The point is, if you use a container for interface{}, you have a lot of unneeded casts and you can't prove statically that the container contains a certain type which makes it easier for errors to slip in.
The normal standard is for `--foo --bar` to be the verbose way and `-fb` to be the short way to write the same thing. Because it only uses one dash, Go effectively force you to only ever have verbose flags, not groups of short flags. NBD, but non-standard these days.
No operator overloading, and it requires types… I don't see Go ever becoming popular with the kind of people who like Mathematica. It's a bit faster, but ISTM that Python/R for convenience and C/Fortran for speed will be hard to displace.
I like node.js, but it's not without its issues. Yes perhaps, all the libs in the npm are designed to be async but it's still all too easy to bring a node.js server down. All it takes is for a developer to do some CPU bound work. Plus node.js has the callback hell despite all the attempts to abstract it away in a future, or promise...or no wait...is it called a deferred these days? The closest thing to Go that I've seen is either stackless python or gevent. They have similar ideas to Go but Go has it all built into the language from the ground up and additionally Go is capable of muxing goroutines onto real OS threads giving you some serious multi-core power all while still allowing you to write synchronous code. A truly amazing tool. One more thing: all the whining about generics kind of irks me. If people had their way with the language we'd end up with Go++. I appreciate the small simple approach to the language. And if I needed all those features that bad I'd simply go use a language that has all of that built in. Go is beautiful and clean people, lets not dirty it up.
My interpretation is that his primary criticism was about the lack of generics, which led him to maintain multiple implementations of similar things and ultimately led him to rewrite it all in Java because of the overhead in maintaining the different-but-similar things and backporting features between those different implementations.
Fun little experiment, and a cool idea, to design Javascript functions in a Go paradigm... but I don't think I'd ever use it in a real project. Why is the Javascript prototype pattern broken? Until I can be convinced of that, I have a hard time seeing this as really useful. (Contrarily, I think prototypes are very powerful when you know how to use them.)
+1 for your Go++ remarks. Generics/templating would be really nice, but that is something that took me forever to learn about C++ and it still bites me quite often. I have never picked up a language so fast as I have Go. (I already feel more competent in Go than I do Python which I've dabbled in for a couple years now, and I'm only about 7 months into Go!)
I hope to see Go used heavily in academic settings. It's a fairly simple language to learn and I think it's an excellent way to study computer science and programming. Not that we shouldn't still use C/C++ or other languages in school settings, too. Those still have their place. Our local CS program is evolving, and apparently concurrency and parallelism are a big deal nowadays (in case you haven't heard, people want to use all their cores for all their chores). I think Go is a great clean, refined way to teach and implement those features. Is Go perfect? Nah. Is it feature-complete? Nope. But as I said in a reply on this page, I have never taken up a language and felt competent with it so quickly as I have Go. There's huge value in that.
I've wrote a Set data structure based on maps, take a look and see if it fits your needs: https://github.com/fatih/set :)
No. 
Teacher here, I almost used it for "Creative Programming"... but the setup was too painful on Windows... for example to get to a state usable for class and get Audio working: 1. install Go, 2. install git, 3. install hg, 5. install liteide, 6. install gcc (for cgo) 7. install necessary packages... Basically the setup for Windows should be easier... one big package that installs go, git, hg, bzr, liteide, gcc, goimports, gocode... then it would be nicer for learning... So, for now, I went with Javascript + LightTable and it seems to work.
I went to see the thesis displays last year because I saw one was for Go. The paper was for porting Go (runtime and all) to [seL4](http://ssrg.nicta.com.au/projects/seL4/).
&gt; Java can be faster, but it's a lot more work. I'd think that if you're forced to write an implementation of something because of something missing in Go, performance shouldn't be a problem because it's you as the code user who's in control of it.
&gt; and are outperformed by their C "equivalents" by a factor of 4, also Sounds almost like a case for a performance bug report for the current compiler! ;-)
&gt; Generics solve one problem: Parametrisation. Generics solve a lot more than that, but few languages have anything beyond simple parametric polymorphism, which probably isn't enough for the Go guys (too little value for too much change to both the spec and the code).
&gt; you have a lot of unneeded casts That's what profiling should decide ;-), and also on modern CPUs, I guess a lot of the logic can be executed speculatively. &gt; and you can't prove statically that the container contains a certain type A Sufficiently Smart Compiler could, at least in *some* cases (mostly having to do with dynamic extent data, I guess). Whether the cases are useful, well, I'm not sure about that. I guess the memory costs are a bigger issue in the end. Arrays/slices of interfaces have serious space overhead compared to the information they effectively contain in many cases, especially if the code is oligomorphic (the array/slice contains values of just a small number of distinct types).
&gt; I assumed from my introductory experience and reading of Go that it wasn't meant for heavy computation tasks. It ought to be perfectly possible to process "heavy computation tasks" in Go. It's not a problem of the language.
Touché. I've never tried Go in Windows. I ditched Windows development about 3 years ago for that very reason. Seems like a good fit for the class, though—developers have to be creative to program on Windows, no? ;)
If we routinely wrote: type generic interface{} at the top of every source file, would that silence the critics?
&gt; I like node.js, but it's not without its issues. Yes perhaps, all the libs in the npm are designed to be async but it's still all too easy to bring a node.js server down. All it takes is for a developer to do some CPU bound work. Plus node.js has the callback hell despite all the attempts to abstract it away in a future, or promise...or no wait...is it called a deferred these days? In defense of node, despite javascript's obvious quirks, it's quite feasible to write small and quick prototypes for non critical systems. You get a lot of performance with very little effort. And promises are really easy to grasp. But everyone can fuck up any codebase :-) We've chosen node over go a couple of times when we just wanted a quick prototype.
People mostly know this. The problem is that this has no type-safety, and is also very inconvenient to use. Neither of those are trivial problems; making the wrong thing easier than the right thing is a dangerous thing for a language to do, because in practice, people don't choose between the "right" or the "wrong" thing; they pick between the "easy" thing or the "hard" thing, and guess which one usually wins? A language should strive to make the "easy" thing the "right" thing as often as possible.
It would help to put a runnable version of your problem on the [Go playground](http://play.golang.org/). Since you can't open a file there, reduce it to the core problem. Are you sure you didn't sneak a `*` into the type signature of the restart method when you put this code in? Your problem would be completely explained if you had `func (e Entry) restart()` as the type signature.
The problem seemed to be more amenable to a dynamic language. It seems particularly suited to something like Clojure or NumPy. Go's original focus was to replace clunky services written in C++, but since it because a big hit with the scripting crowd, people seem to think that it's basically a compiled version of dynamic languages and it's not.
:D... Yeah, I would also use linux... :P but, it's a high school, so can't expect them to learn linux + ... all the coding as well... it's just easier to deal with Windows. I.e. get something about programming rather than learning a new OS.
This is a response to the "Handling generics in go" post. I removed all sanity checks to make the code as simple as possible.
Inheritance in OO is actually broken. If you extend a class and override a method, you may break a lot of stuff accidentally, and never notice if test coverage is not high enough. Embedding in Go solves the problem. Go mirrors the struct content and methods until they're overridden. And it keeps the original struct isolated, which secures that overridden methods will work as exactly expected if they're called by other methods.
Simpler, more idiomatic, less loops, less allocations, understandable: strs := []string{"this", "is", "a", "test"} m := make(map[string]int) for _, s := range strs { s = "prefix-" + strings.ToUpper(s) fmt.Printf("tap: %s\n", s) if len(s) &gt;= 9 { m[s] = len(s) } } fmt.Println(m) 
Thanks captain obvious.
Why not just make a base install and then deploy that to all your computers? Seems easy that way, and if someone fucks up a computer you now have a clean system to restore from.
added a few more functions &amp; wrapped it up in a package https://github.com/icholy/higher
It is obvious to us, but I've recently seen a couple of people trying to reenact idioms and paradigms of other languages like LINQ/FP in Go. And then they get hysterical over the absence of generics.
The only time I get hysterical is when I see people saying that generics should never be added to Go.
If Pike is on the fence about it, it's because of the performance/implementation problems/implications, not because he questions the merits of generics. I'd say there is an overwhelming public demand for them (look how often it gets brought up and how many other languages have them). At the same time there's also a group of idiots smugly saying that "you don't need generics" as if they know something everyone else doesn't. It's like some people think that hating on generics will make you seem cool/hip in the Go community. I really don't understand where this started but it's pants on head retarded and needs to stop.
Shameless but relevant plug: I implemented an irc server in go a few months ago. http://www.github.com/eXeC64/Rosella
The pinnacle of building web apps today in my opinion! Swap Go for Rust in the next year and I'll be in developer heaven.
In case you still want to see it, the video has been added to my blog post :-)
&gt; opinion! &gt; Swap Go for Rust in the next year and I'll be in developer heaven. Rust is significantly lower-level than Go however: I'm not sure what you'll gain from it over Go when speaking HTTP. Go vs. Python/Ruby nets you speed for very little extra boilerplate, but Rust is (from what I've seen) a fair bit more verbose.
I agree. Mostly it has more to do with the code for my application logic. Or a strongly typed ORM. Or dealing with HTTP headers that are well-typed etc. You're right though, Go has an extremely *great* net and net/http library. That's the bulk of Golang that I write today actually, and it's a constant conversation in my head choosing to do my next server-like project in rust or Go because of those concerns. That, and I am self-aware enough to accept that some of this is flavor-of-the-week syndrome in that Rust is my current pet project language. Still have my little Gophers on my desk though of course.
Currently the whole thing was setup in a rush... due to some miscommunication I thought there was 2 weeks of time instead of 1 week. So the decision, what to use, had to be made in ~2days (me doing other things, because there was time). Although I managed to make a package for [audio output](https://github.com/loov/audio) for windows... getting portaudio to compile would be too difficult, but I still forgot that linking to dll-s requires gcc. And that base system still wouldn't help students, they would need to be able to setup the whole thing on their own computers. I considered creating a bundled installer like Rails does, but I decided not to, since that would be too much a hassle at that time-frame.
Also forgot to mention... I wrote my thesis ([pdf](https://github.com/egonelbre/spexs-thesis/raw/master/Thesis.pdf), [repo](https://github.com/egonelbre/spexs)) in Go. Really good language, but not ready for high-performance stuff. I.e. too much going on in the runtime and you start to get a lot of cache misses. But from the coding clarity, it's better than any other language I know.
&gt; If Pike is on the fence about it, it's because of the performance/implementation problems/implications, not because he questions the merits of generics. I think the thing he questions the most is the benefit/problems the current known generics implementations have. Obviously there is a need for generic structures, otherwise there wouldn't be a map/chan/slice in the language. An implementation that is simple, performant and easy to understand is a difficult problem... i.e. if there will be a Go generics implementation, it will differ from current generics implementations. &gt; At the same time there's also a group of idiots smugly saying that "you don't need generics" as if they know something everyone else doesn't. I find those people stupid as well :). My position on it is that you can quite easily manage without generics; for most of the code you just don't need them and in many of the needed places it can be generated.
Just two comments on the code style: 1. It is standard style to spell abbreviations in either all caps or all lower case. The type should be called IRCClient. 2. You don't need the NewIrcClient method, as it just returns a zero value of your struct. Instead, you can just initialize it as client := irc.IrcClient{} 3. You could even call the type "Client", as the package name is already irc. Then, you would instantiate it as client := irc.Client{} 
&gt; Projects like the JVM invest a lot of time and effort in improving their garbage collectors to battle the high amount of garbage they need to deal with. Go, on the other hand, generally takes the approach of avoiding garbage in the first place, requiring a less sophisticated garbage collector by giving control back to the programmer. I've seen statement like this more often, but I'm wondering what if anything is different about Go as a language that would allow it to avoid creating garbage where Java can't?
Thanks all for feedback, will try to implement all your suggestions.
Hi, I'm interested. I'm from Argentina (just as a comment, my grandparents were from Poland). Here is my profile in linkedin: http://ar.linkedin.com/in/carlosfsalguero/ Regards
Heya guys! This is the foundational library that will power ngrok v2 as well as some other tunneling projects I'm working on. The core API that go-tunnel gives you is equivalent to net.Listen. Except instead of listening for connection on a port on your local machine, it lets you listen for connections *made to a remote machine*. This is extremely powerful because it allows you to open ports and receive HTTP requests as if your program were running on a public server even when it's actually running on your laptop or any other machine behind a NAT. I'm providing a default service which powers the top-level APIs ListenTCP() and ListenHTTP() but the code in the go-tunnel/server lets you run your own custom one. For fun, here's the magic you can just copy into your code editor to start an HTTP server on a *public URL*: package main import ( "net/http" "io" "fmt" "github.com/inconshreveable/go-tunnel" ) func main() { http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) { fmt.Printf("Serving hello world page!\n") io.WriteString(w, "Hello world!\n") }) tun, err := tunnel.ListenHTTP() if err != nil { panic(err) } fmt.Printf("Serving at: %v\n", tun.Addr()) err = http.Serve(tun, nil) if err != nil { panic(err) } }
He's probably on the fence about how to implement them. People will freak out if it does the C++ thing of making separate copies of stuff for each type. People will freak out if it does Java-style type erasure. Inevitably some Haskell or ML snob will bring up Hindley-Milner, and that's pretty much the equivalent of bringing up Hitler where the argument is lost right there because it can only be a flame war from that point out.
Who needs them anyway, am I right? ;)
Go has structs and limited stack allocation, which permit less heap pressure. On the other hand, Go has internal pointers (you can take the address of a field of a struct) which make garbage collection harder. 
If you want to learn Go, why don't you just hire frontend dev and do backend yourself?
I have about 1/3 of the website ready (front and back). I want just someone to help me with it to ensure that it will be finished. It is also more fun to work with someone else. 
Thanks for the reply. I will contact you. Do you know any Polish (it doesn't matter for the project I'm just curious)? 
The tooling is built in to the standard distribution that allows you to track down all allocations. Being able to specify pass by value vs pass by reference can also help to eliminate heap allocations if you would defeat the escape analysis (at the cost of paying for the copy).
If memory is really tight in Go, you can create a buffer of []T at some maximum size that you'll need, then just never allocate new T instances, but only reuse slots of your buffer as they become available. It's basically manual memory management, but only for one type, instead of manually managing everything, like you do in C, etc.
Doesn't this require rewriting imports from packages in the same repository to your fork URL? Edit: Clarification: Repository A contains package B and C. If A is now forked to location D, and B was importing C at A/C, it now has to be changed to import from D/C.
Great to see gogtk3 under active development.
No, but if you dont, it could mean that deps of deps break eventually. That is a legit problem, and in production, I would probably like to solve it. Unsure if any of the current solutions do that either though...
Could you address my clarification?
That's just my deps-of-deps answer with a bit more crazy. The answer continues to be: it'll work, but old deps get used (unless the repo you forked has relative import paths). I.e. if anywhere in the code you forked, it says to import from github.com/whatever, it'll do that, and work. However, that obviously wont get snapshotted, since it is an external dependency. So, again, my method works , but not for indirect dependencies. Indirect ones will still get imported and built, but not version-snapshotted.
screen shot?
I'm really excited for the [QML project](https://github.com/niemeyer/qml) to mature.
[Here ya `go`](http://imgur.com/0EhkU9a).
Love it. Looks neat.
Excellent work! Thanks for open-sourcing this tool.
I use em in a private project just fine.
Thanks, I'll check them out again, since they remove this problem entirely.
Though, I should explain. You can import by filesystem path, so I just put the packages together and import relative to GOPATH by file path. Not super elegant if you intend others to use your libs, but works well for private stuff. Idk if there is a better solution.
Thanks :)
*Bad* name choice. Why risk scaring people away with some silly name?
Nice effort but honestly, ToDo apps that do not sync to a centralized location (e.g. web service) are totally pointless. I want my tasks at least on my PC and my phone. For example when having a shopping list: I might create it on the PC but at the super market I want it on my phone. And even if this was just for learning Go you could have made it a web application with a GTK frontend just as easily. The logic is the same, there's just another communication layer in between.
&gt; REST = HTTP + JSON WTH? And he doesn't explain it any better in the talk either. When you can't or don't want to explain REST in your talk then don't do it or don't use the term "REST" at all, just say JSON web service instead.
The problem extends beyond the name (https://github.com/remogatto/gorgasm/blob/master/doc.go#L20)
Take 2 steps back. This is an example of how to write a GUI using Go. There are unit tests and even has mocks/automated testing. This is awesome. Would I use this for my TODO lists? Probably not. Would I take a look at the code to see how stuff was implemented? You bet. OP: Good job and Thanks.
and as effing metal as a name that sounds like "gore-gasm" might be, that isn't going to save it.
True.
Yes. Change the name. It is early so no one will hurt.
And it's also a B movie [monster](http://en.wikipedia.org/wiki/Gorgo_%28film%29)!
My first (not totally trivial) program in Go. You can try it out if you have a few million CPU cycles to waste: It produces beautiful pictures, and helps warm-up the planet. See some [example renderings](https://github.com/npat-efault/mandel/wiki/Example-Renderings). Comments and suggestions welcome. You can also check out the code: I tried to comment it thoroughly and stay true to Go idioms. Enjoy!
Short answer: There are reasons. Longer: I wanted to have a self-contained binary, with no external support files (e.g. javascript files, css files, etc). Just a 'mandel' binary and nothing else. For this to be possible I have to generate a go source file that, effectively, embeds these external support files in the binary. This cannot be done with a simple "go get". If this wasn't my requirement (a single executable binary file and nothing else) then "go get" would do it---but it is, so it doesn't.
Yes, it's possible... But I don't think it's worth the trouble. And if the user installs with go get, then he simply gets a binary in "$GOPATH"/bin which still requires the presence of the source-dir in order to run (correctly). And if he wants to install it somewhere else (or simply remove the source) then he has to copy all data files (manually), or I have to give him an "install" script, which will not be go-get run-able... and so on. Both approaches have their advantages and drawbacks... It's mostly a matter of preference. 
Great name, cool project. Keep up the good work.
So does anyone have anything to say about this package that isn't about the name? 
Honestly, I would invest some time into reading through and critiquing it, but I cant see it going anywhere solely because of the name it has, so I wont waste my time.
In my humble opinion I think yours is a prejudice.
This may be polymorphism, but it isn't "generics" as popuparly understood. Generics usually includes some assumption of compile time type safety.
Nope, not worth even looking at until the name is changed.
I would love for go to be a mainstream tool for app development, and i'm sure that your package is a step in the right direction. The problem is, being named as it is, nobody is going to take it seriously enough to devote their time to developing for/with it.
I think you're wrong. Lady developers will likely not appreciate the reference, and I'm not sure I could mention to anyone on the business side of my company that we're built on "Gorgasm".
My friend, you have a lot to learn. Be careful about calling someone's point of view a "prejudice." People have their own opinions for their own reasons, and often good ones. If you want to encourage dialog and conversation&amp;mdash;which as an open source author you certainly do&amp;mdash;you'll go farther if you listen to those opinions instead of disparaging them. As you've seen here, the name of this package turns a lot of people off. People won't work with it who would otherwise, just because of the name. Here's the tough part: There is nothing you can do about this. You can disagree with people, you can argue that they are prejudiced, but it won't change a thing. In fact it will just make it worse. So listen to the feedback you've gotten about this name and change it to something fun and inoffensive, like [bothering's great idea](http://www.reddit.com/r/golang/comments/1v0ys5/gorgasm_a_framework_for_writing_native_android/ceo9pcu), Gorgonzola. Who doesn't love a good Gorgonzola? :-) Then sincerely thank people for their feedback and keep listening, and you'll earn a great deal of respect. I will check out your framework in any case, since I use Android and I like Go. As others pointed out, if the name offends me, I can just fork it. &amp;nbsp; (Above revised from the original, with thanks to [born-under-punches](http://www.reddit.com/r/golang/comments/1v0ys5/gorgasm_a_framework_for_writing_native_android/ceoft6i) for commenting on it.) &amp;nbsp; &amp;nbsp; &amp;nbsp; Now let me tell you how I learned this lesson. I may have been about your age at the time. It was in the 1970's and I was working on the PDP-10 linker at Tymshare. As with many object linkers, there were various bits of unused space in the executable output file that the linker created, because some things had to be aligned on particular boundaries. The linker didn't clear out this unused space, so it contained whatever garbage was in memory when the output file was put together. My manager thought we should zero out all this unused space. There are good reasons to do that: consistency from one run to another, a more professional appearance for anyone who inspects the executable files, and who knows what kinds of potential security issues. The linker was a nasty complicated piece of spaghetti assembler code. I found all the places where it left memory uninitialized and fixed them to zero it out. There were a lot of places like that in this tricky code. It was not a fun project. When the linker finished running, it printed a message something like this: 141037 words used 2014 words free That second number was the free space I've been talking about. I was getting a bit annoyed when I finished this work, and I updated the message to let people know that the free memory was now properly zeroed out: 141037 words used 2014 words free, and it's pretty fucking clean My boss was a cool dude, so I knew he wouldn't have a problem with this. Unfortunately, he wasn't the first one to see the message. My boss's boss gave a demo to an important customer, and the *customer* was the first one to see the message. This was not a good thing. As you can imagine, it led to a fairly uncomfortable conversation. Lucky for me, I realized that this was a pretty stupid message to put in the linker, and I'd already removed it. So I didn't get fired. But I can't say it was the most shining day of my career. &amp;nbsp; &amp;nbsp; &amp;nbsp; Update: I just remembered a time when I got away with it, working on that same linker and the related assembler. I suppose I'll be shooting my whole little morality tale in the foot with this, but it was too much fun not to share. The assembler had an `EXTERN` directive to declare an external symbol reference that would be satisfied from another object file, just like assemblers and linkers have today. We wanted to add a "weak external" feature. With a normal external reference, it's a link-time error if the symbol is not defined by any object file. But a missing *weak* external would not be an error. It would just leave the symbol defined as 0, so its presence or absence could be checked at runtime. I needed a name for the new weak external directive in the assembler. The obvious choices like `WEXTERN` and `WEAKEXT` seemed boring. But then I realized we could call them Secondary Externals instead of Weak Externals, so the directive name was obvious: SEXTERN And this time, nobody complained! It was the '70s, after all.
Names are important. Everyone has biases and that is ok. You need to realize that naming a package orgasm, then pre pending a g onto it, is a big signal that tells everyone 'hey this is not a serious project, it's just something I threw together. Have a gorgasm!'
Thanks for this.
Just admit it, the project name is not only unprofessional, it makes people cringe hard. Exactly the same reason why the testacular test runner for JavaScript got renamed to karma. If you're really out of inspiration, just use one of the project names that GitHub suggests on https://github.com/new.
Are you implying that women will have more of an issue with this name then men? If so, why?
This comment has been linked to in 2 subreddits (at the time of comment generation): * /r/bestof: [/u/stratoscope explains why gorgasm is the bad name for a software project.](/r/bestof/comments/1v2tfz/ustratoscope_explains_why_gorgasm_is_the_bad_name/) * /r/bestof: [/u/stratoscope explains why naming a programming library "gorgasm" is a bad idea.](/r/bestof/comments/1v2ug7/ustratoscope_explains_why_naming_a_programming/) * /r/golang: [stratoscope comments on Gorgasm: a framework for writing native Android applications in Go](/r/golang/comments/1v2zk7/stratoscope_comments_on_gorgasm_a_framework_for/) * /r/golang: [stratoscope gives advice on the name of a Go package](/r/golang/comments/1v32cy/stratoscope_gives_advice_on_the_name_of_a_go/) ---- This comment was posted by a bot, see /r/Meta_Bot for more info.
I think women are more likely to have an issue with it, yes. Personal, anecdotal experience tells me so. I could be wrong. Either way, the name should go.
And to be clear: I don't know what this package does or if it the best tool for it but I do know that my boss would be pretty pissed if I had to tell a client that the package that we used for their software that we just installed in a middle school is called gorgasm. 
What's the panic? 
I like how the top of the thread is asking for comment on the software regardless of the name. And it's just more people bitching about the name.
Wow I messed up that title! Here's the output: % go test -bench Fmt :( testing: warning: no tests to run PASS BenchmarkFmt fatal error: all goroutines are asleep - deadlock! goroutine 1 [chan receive]: testing.(*B).run(0xc21004b0f0, 0x3, 0x7f18c57c6d80, 0x1, 0x1, ...) /usr/lib/go/src/pkg/testing/benchmark.go:171 +0x4b testing.RunBenchmarks(0x558930, 0x649800, 0x2, 0x2) /usr/lib/go/src/pkg/testing/benchmark.go:303 +0x549 testing.Main(0x558930, 0x6513a0, 0x0, 0x0, 0x649800, ...) /usr/lib/go/src/pkg/testing/testing.go:411 +0x1b5 main.main() github.com/me/package/_test/_testmain.go:49 +0x9c goroutine 3 [chan receive]: testing.(*B).run(0xc21004bf00, 0x0, 0xc21004af60, 0x7f18c5961618, 0x40a00f, ...) /usr/lib/go/src/pkg/testing/benchmark.go:171 +0x4b testing.Benchmark(0x5588b8, 0x651ca0, 0x41843c, 0x659a6c, 0x1, ...) /usr/lib/go/src/pkg/testing/benchmark.go:355 +0x93 github.com/me/package.BenchmarkFmt(0xc21004b0f0) /home/me/projects/go/src/github.com/me/package/scrypt_test.go:81 +0x2f testing.(*B).runN(0xc21004b0f0, 0x1) /usr/lib/go/src/pkg/testing/benchmark.go:119 +0x88 testing.(*B).launch(0xc21004b0f0) /usr/lib/go/src/pkg/testing/benchmark.go:190 +0x75 created by testing.(*B).run /usr/lib/go/src/pkg/testing/benchmark.go:170 +0x2e goroutine 4 [semacquire]: sync.runtime_Semacquire(0x659ab4) /usr/lib/go/src/pkg/runtime/sema.goc:199 +0x30 sync.(*Mutex).Lock(0x659ab0) /usr/lib/go/src/pkg/sync/mutex.go:66 +0xd6 testing.(*B).runN(0xc21004bf00, 0x1) /usr/lib/go/src/pkg/testing/benchmark.go:111 +0x2a testing.(*B).launch(0xc21004bf00) /usr/lib/go/src/pkg/testing/benchmark.go:190 +0x75 created by testing.(*B).run /usr/lib/go/src/pkg/testing/benchmark.go:170 +0x2e exit status 2 FAIL github.com/me/package 0.004s
I can't reddit tonight... I replied [here](http://www.reddit.com/r/golang/comments/1v30ez/how_to_use/ceo8e6y)
They go away once five of them [finished ones] accumulate.
If one wants to change the name... I suggest "Gorgonzola"
Your advice is sound, and your story interesting, but the 54 upvotes you got (which I suspect is around twice the amount the highest upvoted comment in any other topic posted here ever got), the 24 downvotes remogatto's comment has, and the fact that the top five comments all say the exact same thing ("OMG, BAD NAME! SUCH JUVENILE!") leaves a bitter aftertaste of vote brigading in my mouth. No, that's not accusing you, just feeling a bit disgusted with what seems like the larger community patting itself on the back.
You can fork and rename the project you know. Or is "forking" suddenly too juvenile a word too?
I was also surprised by all the upvotes, but I must admit I am grateful for them - and for the Reddit Gold - thanks, anonymous benefactor! But I think it must have more to do with the comment being linked in the subreddits mentioned in Meta_Bot's sibling comment. Maybe people just liked the story and thought it relevant? I do have to disagree with one thing: &gt; the fact that the top five comments all say the exact same thing ("OMG, BAD NAME! SUCH JUVENILE!") I think you're really mischaracterizing those comments. They seemed like thoughtful and mature comments to me, not some doge meme silliness. OP would do well to listen to those comments, regardless of the voting. Thanks for sharing your thoughts in any case - I do appreciate hearing other points of view.
If an program/idea/anything has an enormous, obvious, and painfully stupid problem staring you right in the face people are going to talk about that. Not sure why that's hard to understand.
Also you can specify an Absable interface if you need that.
Hehe, just a label. What OS do you use? It's probably not Prolapsetech Windows, it's Microsoft Windows. P.S I'm not 100% sure that's not a real company b/c I sure as heck am not googling that. 
You are aware this is a perfect example of the overblown response I was talking about?
One sec, my Projaculation Laptop is low on batteries. Let me grab my Asspad so I can continue reading how these names are somehow worse than GORE GASM (as it would be pronounced out loud &gt;_&gt;)
That's the entire point. Names like this are juvenile and should be made fun of. Glad you finally caught on! One last thing, I am still interested in how my names are overblown compared to GORE GASM. I don't think anything could top that. 
Sure, when it's ready.
&gt; Names like this are juvenile Yes. &gt; should be made fun of. No. The fact that you don't even have the basic decency to understand this says loads about who you are as a person.
I love how a pedantic lecture on humility qualifies for "best of" on reddit. Edit: But what I love even more is when my comment pointing that out (this one), gets down voted even after the guy who I criticized thanks me for the criticism and we have a nice, friendly exchange. May your bestof be forever mediocre and your jimmies be forever rustled, reddit.
i think i share his prejudice. honestly, the name made me think it was Go for teledildonics or something. when i read it was for android, i thought the name gratuitously sexualized and the cleverness of it dissolved, i lost interest almost immediately. 
Always happy to learn better if you want to point me at things and/or school me here! Certainly my knowledge of the internals isn't super solid, as evidenced in the talk. That said, quite possibly the problem is the age-old issue of "when standing in front of people attempting to explain things, one does stupid things with words". I feel like the length/capacity stuff was definitely a case of that; I know I was using the wrong word for half the talk (think I corrected it once, then probably flip-flopped between the two and made a hash of it). Misrepresenting the multiplexing -- yeah, probably. I left out the entire subject of syscall threads and elided many of the details, but also, the scheduler has changed every revision and I haven't kept up with it super well. GOMAXPROCS -- I think that this is the number of threads the runtime will use to execute goroutines? Am I misunderstanding? Thanks for the feedback!
Dude just change the name, it's clear that even with such a small sample size on reddit that you will struggle immensely just because of it. Why handicap yourself?
Everyone is laughing over a silly name and you're insulting people and complaining. Maybe time to reevaluate your priorities?
GOMAXPROCS is the number of threads that may execute at the same time, the default being 1, which means concurrency but no parallelism. How many actual threads you have isn't directly controllable, that's part of the multiplexing and indeed affected by things such as syscalls and cgo. The other problem was that the slides said that Go multiplexes goroutines across processes, not threads, which makes quite the difference. The major length/capacity issue I noticed was when you demonstrated io.Reader.Read, where you said that make([]byte, 4096) has a capacity of 4096 but a length of 0. That you further threw away the byte count return value and didn't reslice before echoing makes that a bit problematic, because it looked like Read was responsible for setting the length, while it's not. Don't get me wrong, overall I liked the talk (and it's better than I could do), but that sort of audience tends to suck up all the subtle mistakes.
Thanks for your comment. I actually appreciate it. You're right, the first part of my comment *was* a pedantic lecture, and melodramatic too. That's what I get for writing late at night. I groaned when I re-read what I wrote after seeing your reply, and replaced it with something that is hopefully more kind and less pedantic. :-) To give context to your comment, here is what I originally wrote: &gt; First, don't call your opinion humble when it isn't. Humility is kind. Humility listens to others. Humility does not accuse people of prejudice or other undesirable traits. &gt; &gt; Of course you're entitled to any opinion you want, just don't call it something it is not. &gt; &gt; Second, the name of this package *will* turn people off, whether you like it or not. It will turn a *lot* of people off. &gt; &gt; And here's the tough part: There is nothing you can do about this. You can accuse people of being prejudiced until you're blue in the face, and it won't change a thing. In fact it will just make it worse. &gt; &gt; Or, you can listen to the feedback you've gotten about this name, change it to some interesting but inoffensive name, sincerely thank people for their feedback, and earn a great deal of respect by doing so. &gt; &gt; Your call. 
If you dig through the sources of skynet (github.com/skynetservices/skynet) there's an implementation of BSON rpc that uses Go's RPC libs with a custom BSON encoder. I'm using this from Ruby very successfully. The ruby client is here: https://github.com/skynetservices/ruby_skynet
I might not be an unbiased judge, but that seems like a pretty good way to handle criticism.
there is [msgpack RPC](http://godoc.org/github.com/ugorji/go/codec) codec also
Hehe, sextern. I commonly work with a utility known as Source Extractor, aka SExtractor. My coworkers think I have weird habits.
The best kind of critic is the one who shows a writer (or musician, programmer, etc.) where they've gone wrong, in a way that helps them improve. Thanks again. (And sorry you got so many downvotes for what turned out to be a very helpful comment.)
You must be new to reddit if you aren't used to the vote brigading. It happens and there's nothing that can be done about it.
&gt; I’ll give you a hint, which is that there’s nothing wrong with the language. It is at this point that defenders go too far. If there is nothing wrong with the language, then you are not allowed to celebrate the awesome new features of Go 2.0, because clearly, they are not necessary. Go 1.0 has "nothing wrong" to improve on, right? Heck, why did anyone even release a 1.1 and 1.2? The problems may be _overblown_, but Go is not perfect, today. It never will be; no such beast can exist. It can only be better or worse for a particular task than something else, and Go's got plenty of "better" it can crow about. Stick to the facts, don't go crazy; you don't have to.
Nice name. Ignore moralfags.
If he didn't, a fair chunk of Go's defenders do, and did last week. Don't overreach in the rhetoric; it is _not_ appealing advocacy. "Go is still an appealing solution to lots of problems, despite various issues" is a defensible and appealing position ("and hey, let's talk about which problems those are and why Go is a better choice"); "Go is perfect and anyone who thinks otherwise Just Doesn't Get Go" is neither defensible, nor appealing ("and so you should just shut up" is what people hear). And yes, the latter was on display last week. I saw them.
&gt; **Everyone is laughing over a silly name** and **you're** insulting people and complaining. I was unaware that I was calling anyone names, unless we count your staggering ability for cognitive dissonance.
Sure you can, you can stand up to the bullshit and not care about the downvotes.
Which changes nothing.
Most of the complaining about Go can be essentially summed up with "I can't write language X style code in Go therefore Go is bad." Now that I think about it, most criticism of any programming language seems to fall into that category. Real, in-depth criticism and analysis of a language is difficult, it's much easier to focus on shallow superficial differences. 
The same human meat thinking process finds conflicts equally in religion systems.... As in Dev languages All things. Same brain
&gt; Go 1.0 has "nothing wrong" to improve on, right? Heck, why did anyone even release a 1.1 and 1.2? This is asinine in the worst way. The author doesn't say that Go is perfect. You have successfully nitpicked on something that is completely irrelevant to the author's central point.
I think you made the point. It is ridiculous to claim that a language has no flaws and to assert that one doesn't would require clarification. Until then, I am left to assume he meant, there is nothing inherently wrong akin to other popular languages. Obviously Go has it's goals and niche and won't work everywhere.
No, but he strongly hinted that anyone complaining about go's feature set was an idiot for even thinking about using go. &gt; This is utter horse shit. This is like finding a new alloy of steel and then building a bridge out of it to see if its any good. If Go doesn’t have generics, and you know you need generics, why the fuck did you bother with Go? The fact is, you don't know what feature you want/need/miss in a language until it has bitten you so hard that it makes you want to scream out in pain. I currently use java all day long, there are several missing features that I would love in the language that currently don't exist. It isn't because Java is a terrible language, just that it doesn't have every feature I would like for my problem. That said, go gets so many complaints and articles because it is hip and new. Everyone knows Java has type erasures, nobody writes long winded articles about it to reddit just because it is a known sore spot. Go doesn't have the luxury of being as old as java, so we see these articles with more regularity. On top of that, it is growing in popularity, so you can expect more "It doesn't support feature X? This is a travesty!" Just wade it out. Eventually the language will live or die, and the hard parts will largely be ignored by people determined to use the language. The main good thing that comes out of lots of complaints is that it gets the language authors a little more aware of the issues that people really care about.
I pretty sure one of the articles author is pointing to is this one: http://oneofmanyworlds.blogspot.com/2014/01/another-go-at-go-failed.html
Paul Graham has an excellent essay ("Beating The Averages") where he points out this tendency of programmers to criticize other languages for lacking the features they are accustomed to. http://www.paulgraham.com/avg.html
&gt; "I can't write language X style code in ~~Go~~ Y therefore ~~Go~~ Y is bad." Pretty typical among novices. And many of these "programmers" are novices after decades of "programming". As a matter of fact, it extends well beyond programming onto many other technical fields.
The biggest problem I have with Go is the same one I have with Rust. Or even C++ , etc. I do not know what kind of applications I need to write in it that cannot be done in Python. My problems are not large enough that optimization of that sort is needed yet. And so, I find myself liking Google, liking Go, liking the design of the language.. and completely unable to find a problem that it needs to solve. 
Jules dares you to say Generics one more time. https://twitter.com/genghisjahn/status/422594450263506946/photo/1
"Nothing wrong" and "nothing to improve" are worlds apart.
IMO, a fair amount of it depends upon the way you think and the workflows you use. I use Python a lot, but my brain still prefers static typing. I'm a hell of a lot better at debugging statically typed code than dynamically typed.
&gt; I'm curious if you would put complaints about generic type erasure in Java in the "novice complaints" bin. I think the problem hasn't been stated very clearly: the problem isn't with the tool but with the operator's understanding of his trade, in most cases. A master of the trade, any trade, will find a way to accomplish a task, and to do so he'll pick the right tool. (It seems like it came out to be a bit preachy, that wasn't my intention. I guess perhaps after years of dealing with the same shit day in and day out certain things to sound preachy, eh?)
"Well, it's called Gorgonzola...but it doesn't stink..." 
Yeah. I remember someone saying "There's absolutely nothing wrong in walking to work every morning even though you could improve the process by riding a bike" once as a resposen to similar argument.
Here's mine. 16 line function that parses an ini file into a map. func parseConfig(path string) map[string]string { file, err := ioutil.ReadFile(path) if err != nil { log.Panic("CONFIG ERROR - " + err.Error()) return map[string]string{} } lines := strings.Split(string(file), "\n") newConfig := map[string]string{} for _, line := range lines { fields := strings.Fields(line) if(len(fields) &gt; 1) { newConfig[fields[0]] = strings.Join(fields[1:], " ") } } return newConfig }
Asinine means ass. 
&gt; The fact that you don't even have the basic decency to understand this says loads about who you are as a person. that's not an insult? I wonder why you're so bent out of shape over this. Did your parents name you Philletio instead of Phil? 
Where can I get that t-shirt?
Perhaps so, but I also do a lot of end user/gui work.. so Go is not in my solution set for that reason as well. Like I said, I don't see myself writing a lot of lower level code
Actually, unless you need &gt;100K goroutines, `Executors.newCachedThreadPool()`, and `BlockingQueue` are pretty much equivalent. The only thing which is a bit problematic to implement is `select`, but it's definitely possible.
And I can see the logic behind that. But my problems are still not "Go Scale." I can see the advantage of the giant binary containing everything, and the speed increases, but I don't have a thousand systems that need the same functionality (without worrying about dependencies) or a million lines of code that take 50 minutes to compile.
We are excited to finally launch this. Expect weekly episodes in the range of 3 to 5 minutes. Our goal is to pump out extremely high quality. Nate and I have very high standards for how screencasts should be produced. If anyone has suggestions on topics to cover please let us know in this thread :)
Heh, now you ruined it for me ;)
[Image](http://imgs.xkcd.com/comics/photos.png) **Title:** Photos **Title-text:** I hate when people take photos of their meal instead of eating it, because there's nothing I love more than the sound of other people chewing. [Comic Explanation](http://www.explainxkcd.com/wiki/index.php?title=1314#Explanation) **Stats:** This comic has been referenced 24 time(s), representing 0.27% of referenced xkcds. --- ^[Questions/Problems](http://www.reddit.com/r/xkcd_transcriber/) ^| ^[Website](http://xkcdref.info/statistics/)
Thanks both for your candor and for renaming your library. I didn't find the original name sexist or offensive, but I did think it was a bit juvenile and inappropriately lewd.
I really liked the screencast you did for martini. Sometimes I watch it just to watch it (maybe it's the music, I'm not sure).
Way to go on renaming it. However, I think your comment at the end is non-applicable and pretentious. Why? Because the name of a software package is one of its intrinsic qualities. This is especially true in Go, where you import specific packages rather than just a general namespace. If the name of the project has negative value, then the project itself has less intrinsic value than it otherwise would. 
Another thing: You really should add info about `godeb` to the page for the installation screencast. Here's a link in case you are not familiar with it: http://blog.labix.org/2013/06/15/in-flight-deb-packages-of-go
This is the problem. Go is not suitable to replace C or C++ and anyone who says it can doesn't seem to understand what "lower level" means. If anything Rust has higher chance of replacing C++. As long as it can gain enough popularity. So therefore Go competes against higher level languages such as Python or Java. I think it doesn't have much to offer against Python except speed at the cost of being more verbose. I think it has a potential to compete with Java. Assuming it can convince Java developers that it provides a benefit. 
Best tool for the job. Rails allowed us to ship it quicker. Also, this http://joelhooks.com/blog/2013/09/15/why-i-built-an-angularjs-training-site-on-rails/
&gt; http://blog.labix.org/2013/06/15/in-flight-deb-packages-of-go Thanks, I will add it to the shownotes 
I love that music. It is so soothing. Count on more screencasts about martini coming from GopherCasts. Maybe the music will make it in there too ;)
Given the hatred he received, I'm surprised he didn't rename it to Gofuckyourself. (Yes, I know some of it was good advise too).
Well, that is a problem. That said, though, Google has never positioned Go as anything but "an open source programming language that makes it easy to build simple, reliable, and efficient software." So I don't know where I've seen it as a systems language.. other than on blogs and the like defending it when positioning it against C++ 
Rob Pike was claiming in his blog that that was the goal of the language was to replace C and C++.
Totally appreciate the name change. This looks really cool.
Not if it keeps making 2Megabyte Hello Worlds and can't compile itself :D 
&gt; Go is general purpose computing language; you should be able to approach any task in it. *Any* task? You sure about that? Just because a language is general-purpose doesn't magically make it applicable to every need. Python is general-purpose yet you don't see me writing operating systems with it. And yes, pedants, in theory you could, but you get my point.
I couldn't use `bufio.NewScanner`. Tried [this code](http://kch42.de/cg/af16c31d) for the FizzBuzz problem and got this output: # command-line-arguments ./source.go:40: undefined: bufio.NewScanner WTF? EDIT: And why didn't I use a `switch ... case` block instead of this ugly `if ... else if` chain? I don't know...
Ha~ maybe not *you*, but... http://python-os.info/en/ ;) 
bufio.Scanner was added either in 1.1 or 1.2. I forget which. They are likely running an older version of Go.
&gt;Go is not suitable to replace C or C++ I have always seen Go primarily as a replacement for Java, python, PHP et al... and C/C++ for a limited subset of tasks. For instance, somebody wrote a simple clone of nginx using go's standard libs and ended up with comparable performance to the original.
Nasty or not, it looks [fairly similar to go](https://github.com/elazarl/go-java/blob/master/src/main/java/org/golang/example/PrimeSieve.java). In fact I used this pattern regardless of Go, so solve concurrency Java problems. The only thing that is a bit different is the `Runnable`, but this is mitigated by using a good IDE like intellij. It would fold the boilerplate for you, so you can read and write it just like you read Go.
Some more info for OP why he should reconsider the name: There are three problems with it: 1. The pornographic meaning, which will piss of tons of people. 2. The violence meaning (gore-gasm), which will piss of those that are chill with seeing tits at work (i.e. europeans) but don't like intestines hanging out of the people showing the tits (like in this first-page google hit for "gorgasm" http://riddickart.com/news/wp-content/uploads/2010/10/gorgasm.jpg ). 3. Its a name already taken by some metal band, which will dominate all search results for your project. I tried to search reddit for "Gorgasm" to find this thread again. Top result was this: http://imgur.com/a/NvUTi , linked from /r/wtf. If you try a google search, you get a full page of metal bands and gore/porn images. That alone will mean that it is NEVER going to be used in any kind of teaching / educational environement, too.
Ah, I see. I thought it was there since 1.0
for nerds orgasm is not sexist.... is BUTTHURT %) 
The point is not parsing a ini into a dictionary but adding ini parsing configuration support for free to your existing programs which are already configurable via command line flags.
The footer is not valid Go though :) &gt; var dotGO = []awesome{ Speakers, Venue, Workshops, Partners, FAQ, Tickets, Code of Conduct, Contact } &gt; var credits = { "design": Maurice Svay, "golang": Google } &gt; var dotConferences = []conf{ dotJS, dotScale, dotRB, dotGO }
&gt;This is the problem. Go is not suitable to replace C or C++ and anyone who says it can doesn't seem to understand what "lower level" means. If I could get the hours in my life that I've spent debugging memory corruption, race conditions and dead locks in what *should* have been simple concurrent code, written by a self-professed "expert" in C++, I would be really happy. C/C++ are stuck in a concurrent programming model that was already antiquated in the mid 90's; Python, at least CPython, is an even bigger joke - it refuses to even acknowledge that concurrent/parallel programming is a "thing", last time I looked at it - "just spawn more interpreters!" No. We are getting CPU's with more and more cores. 4-core machines will be the norm in another 2 years. Concurrent and parallel programming is extremely difficult, if not impossible to get right with manual memory management and low-level synchronization primitives. That's where Go shines and that's why it's a winner, in my book. It's a modern C, with most of the cruft gone, with a slight (but ever-decreasing) performance hit. What's seriously not to like about that? 
I think you example with the select makes an assumption that something has already sent a value down the channel and is waiting to be read before you enter the loop. If a channel is still waiting for a value to receive, it will call the default before getting the value.
A friend emailed me this article saying, "Really?" Answer: No. Also, there are data races in the example code, like: for i := range channels { go func() { channels[i] &lt;- value }() } Where each goroutine will probably be using the same i, and by the time it runs, each goroutine will have the same value of i. Or the program will crash. The Go race detector would've caught that. 
I think people can conflate sexuality and sexual references with sexism. Sometimes, this can be an appropriate correlation. In this case, I think that the old name perpetuates the "boys club" mentality in parts of our community which *does* tend to alienate women, it invites off-hand comments and jokes which *would* inevitably cross the line, and would have inevitably led to real embarrassment for *real people*; I know a lot of women who would dread the obligation to talk about their experience with "Gorgasm" in front of a bunch of men (say, in a work environment). Due to demographics, I think such emotional distress would disproportionately affect women. Despite this, I said I don't think that the name itself was sexist, and I'm certain there was no such intent behind it.
Can you elaborate more on your answer of no? Why, for example, is the deferred code in a loop not a problem?
The first part was fine. (i.e. know that defer is func-scoped, not block-scoped)
Be careful with this. Just like bradfitz's comment, this code also has a race condition. It should also have go func(i int){ ... }(i) That way the index variable is locally scoped and not changed as the for loop continues.
The code go func() { ch &lt;- v } is equivalent to ch := make(chan bool, 1) ch &lt;- v not to select { case ch &lt;- v: default: } which would abandon sending the value altogether if `ch` blocks.
true
&gt; **If you have to type implements in all the spots that an interface is satisfied**, that &gt; also means you have to include the “header” of the place where that interface &gt; is defined… once again, many more includes which would slow down the builds. Java reference in the context of Rob's quote looks awkward. 
&gt; Go is not suitable to replace C or C++ and anyone who says it can doesn't seem to understand what "lower level" means.
It is not equivalent to either of those. Also that "correct way to do that" probably does not fix the bug in the way the author intends to although it might work correctly in his use case. If `ch &lt;- v`would block, it doesn't send it asynchronously but instead doesn't send anything at all to the channel.
Little nitpick: I frequently see people pass the WaitGroup into functions as a parameter. While there is technically nothing wrong with this, I wonder if it is the cleanest approach. The calls to `wg.Done()` are important to make the synchronisation work, but the called function likely has nothing to do with synchronisation. It is just there to perform some arbitrary task and should probably not have any notion of the WaitGroup use. As such, I prefer to retain control over when and where this happens, close to the definition of the WaitGroup itself, by wrapping the function call in a closure in which the `wg.Done()` call is placed. Like [this simplified version](http://play.golang.org/p/LTeAA0KbQS) of the code in the article. The function `f` now doesn't need to know anything about synchronisation. This arguably makes for a cleaner API.
If you're having someone that waits on sending value to an unbuffered channel, it's similar to having a buffered channel with a value waiting in the buffer. In both cases the receiver will immediately receive the value you sent.
Indeed, there is that.
The example should import "net/http" not import "http"
Thanks for this improvement 
Maybe he wanted but was [too late](http://gofy.cat-v.org)... :)
I'm still of the opinion that I (and my work) don't really need a Go-specific solution to package management. I had initially tried to use git submodules, but that hasn't worked out so well in practice. We're going to be trying out [git subtrees](http://blogs.atlassian.com/2013/05/alternatives-to-git-submodule-git-subtree/) for the next project. In my testing so far, it is looking pretty good, and most of the developers in a project (who aren't concerned about pushing changes back to upstream) don't need to know or do anything different than regular git. 
What were the problems you encountered with submodules?
&gt; Makefiles have always been there to automate various non-trivial tasks. Yes, but compiling pure Go source code, fetching dependencies, and installation of Go binaries *are* trivial tasks.
Looks good.
We 'vendor' every library anyway, and we'll use hg-git to pull in those Mercurial ones.
The Atlassian blog post links to three different articles on the downsides of git submodules which can explain the situation better than I can. But briefly, it is just more brittle and cumbersome in everyday use. More commands to run every time a submodule is updated, and if a developer forgets to do that, it is a problem. It is also way easier to revert a submodule back to an older version inadverntently. I, as the guy who is normally worried about pushing changes back upstream, need to pay more attention and do a little more work, but that's OK. For day-to-day development (for me and everyone else on the team) git subtrees are straightforward to use. So far. I reserve the right to change my mind in a few months. :-)
Ah, so more the general issues with git submodules than specifically using them for managing dependencies.
Also git-remote-bzr :)
Yes. With either, and with the practice of vendoring your dependencies, you have 100% repeatable builds, which is one of the most important things in this discussion. As a bonus, it works across different programming languages too. It is not all a golang world... I might have to learn Rust soon too.
&gt; the practice of vendoring your dependencies On that topic, I hope that _any_ Go solution for packaging supports this as a first-class use case. It's a good idea, _period_, for any operation that needs to be reliable. At work, we don't even use CPAN, except to extract tarballs and put them in a local repo, because you just don't know what's going to happen. I'd rather see a tool that maintains my vendor repo and then makes that easy to use than a fantastic tool for managing dependencies that fails if my network link or GitHub goes down, or if someone force-pushes at an inopportune time.
Oh dear god no.
http://youtu.be/umDr0mPuyQc
For the future reference of others, I rehoisted my local copies of code to live at the top level (i.e., lib/src/library instead of lib/src/github.com/user/library), on the theory I didn't really want the implementation details of where the library lived to go into the code base. I've come to regret that. I still don't like having the literal phrase "github.com" appear in my code, as it tends to imply the wrong things about where the library is coming with, but the alternative is worse. Plus as I'm releasing libraries that use each other on github, and then using them in my own code, I have to give them the same names in both places or it doesn't work very well.
Why would I want to do that if there are goroutines? Since you can easily catch panics, there seems to be no reason to spawn other processes.
Good question. This is definitely not meant to compete with Go's concurrency and definitely not meant to stop you from using goroutines. The current implementation is bound to a single machine, so basically no real benefit (well I don't know how goroutines behave on heavy CPU usage). But since all IPC is hidden, I see some potential. It'd be fun if you could distribute the tasks over several machines in the future.
How would differ from GoCircuit(http://www.gocircuit.org/)?
A process is an OS level service requester for the CPU. Imagine you have 100 processes running in your machine, then your app will have only 1% chance of being serviced(1/100). Even though your app can run million goroutines, the CPU scheduler precludes your app with the probability of just 1%. Now imagine you have 2 processes. Now you have 2% chance of being serviced instead of 1%. Both processes can run any number of goroutines.
For one, go circuit depends on third party software. Secondly, it runs on multiple machines as against spawn that is meant for single machine.
Or you could just increase the nice value of your process if you think its gonna help that much...
 export GOMAXPROCS=2
That variable is used to put restrictions on maximum number OS threads to run. If your process crashes, OS takes care of it without disturbing other processes. You can do that with goroutines as well. Just put recover function in every goroutine defer. But all this is only possible when your process is served during CPU scheduling. Because there may be many other applications running. With extra process you now have more chances to be served from CPU. Golang RPC does that only. It creates extra process. And that's how Google chrome works. It has single process for every tab and extension. You can see it in the Task Manager.
I am not familiar with that. But I am sure there are many ways to deal with processes.
That's exactly what we do too. It seemed easier than changing the references. Our public stuff is under src/github.com/our_github_name and our private stuff is under src/our_domain.com.
I will check it out. Thanks.
I'm not a web developer - what is the big deal here requiring a separate library?
What's the alternative to using a package? Copy / paste? 
How about https://github.com/bradfitz/camlistore / http://camlistore.org/ . Created by Brad Fitzpatrick who works for Google on Go, but is developed by a team. It looks fairly large.
Here's a smallish one that generates the GoByExample.com website: https://github.com/mmcgrana/gobyexample
A project that I am working on: https://github.com/wikiocracy/cryptoballot It's still a work in progress, but it provides a fairly simple example of a RESTful webapp written purely in Go.
I've been using Hugo to build my website http://hugo.spf13.com. It's a complete (web) application. 
It does, this is just a nice idiomatic abstraction (IMO).
I have a couple small ones: * https://github.com/thraxil/houston -- just draws some graphite graphs of my servers/apps based on a toml config file * https://github.com/thraxil/augend -- riak backed fact database * https://github.com/thraxil/rhabdom -- riak backed super simple video blog * https://github.com/thraxil/intweet -- twitter to atom gateway. (ie, it makes my twitter contacts feed available over atom so i can read it with my feed reader instead of a regular twitter client) Sorry most of those aren't terribly well documented. I mostly write them for my own needs. My more significant Go web app is Reticulum: http://thraxil.github.io/reticulum/ It's sort of a distributed image serving/thumbnailing application. A bit hard to explain, but Go has proven to be a very solid choice for implementing it.
&gt; but I did think it was a bit juvenile Ageist! &gt; and inappropriately lewd Only in some societies.
https://github.com/jmoiron/monet is a good reference (full blog backing onto Mongo). I'll be open-sourcing my own web-app soon: Go backing onto RethinkDB with heavy use of the Gorilla toolkit (mux, schema, feeds) + email (gochimp) + user auth (bcrypt hashes). Ping me if you have any specific questions though and I can share some code. 
Sounds really interesting. Can't wait to see it!
awesome project!
I wrote this project to help the British Library tag their million photos. Backend is written in Go, frontend is written in AngularJS. * [WorkMachine](http://workmachine.us) ([source](https://github.com/abhiyerra/workmachine))
Excellent. I believe that for security purposes, one should really never interact directly with the URL arguments, but should always be marshalling out concrete instances like this. People get in trouble when they try to take shortcuts and directly manipulate form parameters. Given the impoverished nature of URL encoding, one thing you may want to give people that xml and json do not is an opportunity to run a post-processing step; if my data type implements some interface, run a PostMarshaling() method call on it or something, which can also return an error. Sketching what I mean: type PostMarshal interface { PostMarshal() error } // in your code: pm, isPM := marshalledValue.(PostMarshal) if isPM { err := pm.PostMarshal() if err != nil { return err } } For instance, I have an ancient widget here that represents an IPv4 address via 4 numbers in 4 form elements. I could implement: type MyIPv4 struct { RawOctets *struct { Octet1 byte Octet2 byte Octet3 byte Octet4 byte } IP *net.IPAddress } func (m *MyIPv4) PostMarshal () error { var err error m.IP, err = net.ResolveIPAddr("ip4", fmt.Sprintf("%d.%d.%d.%d", m.rawOctets.Octet1, ...)) if err != nil { return nil } m.RawOctets = nil } Then you can get even more sophisticated encodings and decodes. A PreMarshal step may also be a necessary addition, though that sort of calls for a slightly different interface (it ought to be able to return an interface{}; for instance, in this case I may want to return just that embedded struct). I'd also suggest adding another optional "namespaced" call, that allows you to marshal/unmarshal to or from a chunk of the URL parameters named by a "name." prefix, so that for any given marshaling you may still have an arbitrary number of them on the page. Right now, as written, it appears to me it would be a challenge to have 2 of any item you've defined this way on a single page. (Again, we go back to the impoverished nature of URL parameters...) That is, this would give me the ability to put on the page an "interface1.Octet1", "interface1.Octet2", etc, and also an "interface2.Octet1", "interface2.Octet2", and then I could use this new function to `d.DecodeNS(&amp;someIPv4Instance, "interface1")`.
I share your hope, i'd like to use this opportunity to improve my golang, but I'm really busy these days so don't count on me lol...
One of the major features of lobste.rs is the filter system so that no one can complain about a certain link type (they can just add it to their filter). I'm disappointed that Chris didn't get that :/
I found that Chris guy's attitude presumptuous and arrogant. The rest of his Twitter feed is more of the same babbling. Disregard.
Security is indeed an important reason to avoid manually parsing, encoding and decoding data via URLs; as you suggest, it is very easy to miss a level of escaping, for instance, and create a vulnerability. I'm confused about PostMarshal; is that step not already possible using [custom marshaling](https://github.com/ajg/form/#custom-marshaling), which is already supported? The idea of namespaces is appealing; though I wonder if the same can be achieved already using an enclosing `struct`. For example: type Interfaces struct { Interface1 RawOctets `form:"interface1"` Interface2 RawOctets `form:"interface2"` } Where, e.g.: type RawOctets struct { Octet1 byte Octet2 byte Octet3 byte Octet4 byte } Conveniently, `form` lets you nest structs (and any other composite type) arbitrarily, which can serve as a namespacing mechanism. Anyway, thanks for the feedback.
For whatever reason, Go seems to be the single biggest magnet for PL snobs.
There are two kinds of programming languages: those people always bitch about and those nobody uses. (attributed to Bjarne Stroustrup; one of his more perceptive sayings.)
Wish I could go to this, anyone know if this is being recorded?
&gt; Go 1.0 has "nothing wrong" to improve on, right? Heck, why did anyone even release a 1.1 and 1.2? because why not? 
&gt; Go is general purpose computing language; you should be able to approach any task in it. cars are general purpose vehicles but I bet you don't use them to carry 2 tons of steel 
http://twitter.com/GopherCon/status/425453599389659136
You're offering a meaningless arbitrary comparison as a counter example. Let's stick to the original problem domain, shall we? That'll save us a pile of stupid and pointless chatter neither of us care about. Here's the issue: Given an arbitrary new programming problem, how do I evaluate if I should attempt to solve it in go or not? Well, let's examine the problem; It's a problem we assume we're going to solve with *some* kind of programming... Can the solution be implemented in go? Well, go is turning complete, it has the ability to interact with c libraries. Technically, there's **no reason why our new problem shouldn't be solved in go**. Period. End of argument. Any problem that can be solved by a general programming language, can be solved using go. This is not even in dispute. Your assertion that go is somehow like a car, and simply 'cannot take some loads' is *categorically untrue*. Now we add another dimension to the problem: Does my problem fit into the domain of problems that go was 'designed to solve' or 'go easily solves' or that 'go is useful for solving'. Is that question even meaningful? ...but the problem is, how can I tell? Before I start solving the problem, *by definition* I *don't know what the solution is*. So, I have to start solving the problem, realize that it is a problem suitable for go, and then swap to solving it in go? Or start it in go and then realize that it's not suitable for solving in go, and swap to something else (as in the example of the guy and his generics). Which do I pick? Are you seriously suggesting people shouldn't even *try* solving *any* problems in go? ...because that's what you're basically suggesting. You might argue that you can get a 'feel' for the 'sort' of problem something is, and then by talking to people and listening to their experiences solving similar 'sorts of problems' decide if the language (in this case go) is suitable. *That's* a valid argument; it's a bad argument, because new comers to a problem domain probably don't have the ability to get a 'feel' for a problem, but you could argue a technical expert would have those skills. You could totally make that argument if you wanted. ...but I maintain it's more valuable to the community to try and fail, and then let other people know about the sorts of things that are not suitable, so maybe they won't do the same thing. 
Congratulations for being a Haskell fan (me too) and not totally disregarding Go for not having generics. You win at sane priorities.
&gt; Given an arbitrary new programming problem, how do I evaluate if I should attempt to solve it in go or not? in the same way you evaluate every other problem in your life. should I buy this laptop or not? should I go to this supermarket or to another one? was this restaurant good enough to come back? is it really that hard? and BTW, javascript is a general purpose language too, but you don't write device drivers with it. And a lot of people are writing a lot of software with it, even if it has some very big issues as a language... I can't really see your point, is Haskell good for everything? &gt; Or start it in go and then realize that it's not suitable for solving in go Wrong question. The right one is: is Go the right language for me to complete this task? I used to solve much of my programming problems with Pascal and C++, before installing my first linux distribution and learning how to program in BASH... Really, I couldn't know before trying. To answer your questions: are you writing a GUI or a window manager or some fancy application with a sophisticated UI? don't choose Go. Are you writing a packet manager, a compiler, code that interacts with C libraries, services in general, give Go a try, it sits in between C/C++ and Python. Every time you thought of using Python, when not writing web applications, you could try Go. Wanna hack a quick web app and have fun writing it? try Rails (not because of Ruby, because of Rails). For example: Rust is a promising language, but I'm quite sure I won't pick it up to write web apps or for frontend development.
“Go is not meant to innovate programming theory. It’s meant to innovate programming practice.” — Samuel Tesla
I really don't get what the big deal is. Use go. Encourage people to use go. If people don't like go, listen to their feedback instead of writing blog posts about how they are idiots. It's not rocket science, it's just common courtesy. If go isn't suitable for something you're doing, don't use go...but dont *criticise other people* for trying to use go for things *you* don't think it's suitable for. That goes for OP too. That's why I wrote what I wrote. &gt; should I buy this laptop or not? Stop bringing up irrelevant nonsense. &gt; are you writing a GUI or a window manager or some fancy application with a sophisticated UI? don't choose Go. Why not? There are plenty of people doing this, and doing so highlights the limitations of go so it can be improved. Some of them have done a pretty decent job despite it. I'm a big fan of the SDL go bindings. Anyway, what the OP *actually said* is: &gt; This is utter horse shit. This is like finding a new alloy of steel and then building a bridge out of it to see &gt; if its any good. If Go doesn’t have generics, and you know you need generics, why the fuck did you &gt; bother with Go? These details are widely, exhaustively documented; they are not surprises. No, it's nothing like a steel bridge. These irrelevant metaphors are stupid and ridiculous. The details are widely, exhaustively *contested* by people *who claim go doesn't need generics*. It was utterly *unsurprising* to find someone trying to walk down the path of using go for data processing. It's sad that he gave up and failed, rather than working around it, but good for him. He solved his problem. It's sad that people in go community responded like *this* instead of more thoughtfully.
Nice. I've been using lib/pq and while it works, the use of $1 vs. ? along with zero documentation make it less than ideal :/
the 'conn' should not be a global, but part of the Bot type, this way you can handle more than one connection at the same time with many Bot instances. func (bot Bot) sendMessage(channel, message string){ bot.conn.Cmd("PRIVMSG %s :%s\r\n", channel, message) } 
This is not a bookmark.
Yeah, I admit it is quite a minor complaint and I understand the $1 is the standard PG placeholder, but the Go db/sql driver documentation uses "?" as the placeholder everywhere, implying that "?" is the standard placeholder for all Go drivers. Regarding documentation, I was really only referring to the README on GitHub. It contains no examples and no documentation at all. The godocs are indeed excellent!
You can also use named parameters with [sqlx](http://github.com/jmoiron/sqlx), or use '?' with sqlx.DB.Rebind() to produce $1, $2, $3, ....
Nice! I was not aware of this package.
&gt; Use go. Encourage people to use go. If people don't like go, listen to their feedback instead of writing blog posts about how they are idiots. It's not rocket science, it's just common courtesy. who said they are idiots? he just said that most people are "judging a fish by its ability to climb a tree" &gt; Why not? There are plenty of people doing this because there are still no good GUI libraries out there... and BTW, there are people writing software in brainfuck too, it doesn't mean I will advice you to go down the same road. I will certainly write a game in Go, not a desktop app. I wouldn't build a desktop app in PHP either, even if GTK bindings have been around for years now. I consider *"it can be done"* and *"it should be done"* two very different things. &gt; No, it's nothing like a steel bridge. These irrelevant metaphors are stupid and ridiculous. can you come up with something better? Go doesn't have generics, everybody knows, so if you **really** need generics, why use Go? isn't it plain simply stupid? But most of all, today is the tenth birthday of Scala, one of the most praised languages out there, and after all these years, the language is plagued by tons of problems (at least from what I read) but very few of those critiques started contributing to improve it, they just whine on the interwebz. Haskell is almost 15 years old, and still have a long road ahead before even taking off as a serious language in industry. Can we just give Go a little more time, since it has been around for only 4 years? Does it sound reasonable to you or not? Go strength is that one person can know all about it in few weeks. I mean, **really all about it**. That, IMHO, is already good enough. TL;DR: use yellow hat sometimes, not the black hat the whole time
"Larger than the size of a single pointer" is not the cut-off point at which passing pointers is more efficient than passing values. Pointer dereference isn't free, and copying small multi-word values isn't that expensive, either. Considering it's an IRC bot, one should check what makes more sense semantically, not what's faster (or not) by a few nanoseconds in an artificial benchmark.
For a pointer, you need to load the pointer from memory, and then you need to load whatever is at the address the pointer points to. That's already two loads instead of one. Then, pointers ruin locality of data, which means a struct of 5 pointers might be a worse idea than a struct of 5 values that are each bigger than a pointer (numbers made up). Third, with pointers, your data will usually end up on the heap instead of the stack and thus cause more work for the GC. There's no hard and fast rule when a pointer is more efficient than a value – that's something for you to benchmark for your specific application – but saying "the value is bigger than a pointer, so a pointer is a better idea" is wrong, even for an estimation. Even very high traffic IRC channels require laughingly little resources to parse and process. Odds are that your actual handlers – the things doing work on messages – are going to be more expensive. I've run some bots written in Ruby, using regular expressions in multiple steps of the parsing and dispatch process in some of the highest traffic channels without problems ;) – I'd definitely be more concerned with accidentally modifying data that shouldn't be modified and would thus pass values instead of pointers when possible (and required – I haven't looked into this particular program at all, this is generic advice.)
The idea was to both save it and also show some respect to the OP, but who would have thought it could be worth so many downvotes!
&gt; can you come up with something better? Yes. If you're talking about programming language, compare to other things in the same domain. ie. programming languages. &gt; who said they are idiots? ... &gt;Go doesn't have generics, everybody knows, so if you really need generics, why use Go? isn't it plain simply stupid? Sooo... being told you're doing something stupid != being told you're an idiot in your view? Well. Whatever floats your boat~
Nested and anonymous structs are my favorite new tricks. :)
You're welcome. I kind of just hacked it together this morning as I was faced with porting that entire JSON sample manually into Go. Instead of spending 10-15 minutes typing it up myself, I spent an hour writing a script to do it for me in &lt; 1s instead.
Seems decently produced and recorded.
In both Die and Timeout, you should give the channels you create a buffer. In neither case does the timeout nor the issuing of a kill signal actually stop the provided function from running. When they eventually finish, their calling goroutines will block on `ch &lt;- true`. This will cause your program to leak goroutines. (Or in the case of Timeout, the timeout goroutine can block indefinitely if the fn finishes in time) By adding a buffer, the channel send operation won't block; the goroutine can finish, and garbage collection can take care of the channel.
This looks like a library written by someone who hasn't taken their time to understand properly "time" package nor Go idioms. Some of these functions aren't probably needed or aren't encountered often enough in practice. http://play.golang.org/p/93oa7QxwQY And, generally write synchronous functions and, if necessary, the caller can always make them async with "go".
&gt; Yes. If you're talking about programming language, compare to other things in the same domain. ie. programming languages. are you familiar with the concept of metaphor? and I did compare Go with other languages, no answer from you, cause you probably don't know what you're talking about. &gt; isn't it plain simply stupid? do you know what **it** means? &gt; being told you're doing something stupid != being told you're an idiot in your view? no, not only in my view, but semantically in general. At least in Italian if you do something stupid, doesn't mean you are stupid. If I say "this is stupid" is different from "you're stupid" And stupid and idiot have also two slightly different meanings. Maybe you missed that class in school or you don't have an internet connection to check on a dictionary. You have no real arguments against Go, you're just trying to win a fight. I think we're done here, are we? 
I like these. The fact that the lessons are clearly prepared in advance makes them lean and easier to follow.
Alternatively, there's a CLI utility: https://github.com/ChimeraCoder/gojson
Came here to say the same thing. The docs on Timeout() and Killable() (nee Die) are very misleading: the functions will absolutely run, assuming the program lives long enough. In the Timeout() example, if the program survives for an hour, it will print "Hello World." (And the goroutine will leak and the channel will block, as you said.) I suspect most of these were tested in the context of a simple main() function which calls the code snippets and not a larger program. All goroutines do die when main() exits, but there is no other mechanism for killing a goroutine, which the docs imply is possible with Timeout and Killable.
#####&amp;#009; ######&amp;#009; ####&amp;#009; *Here's a bit from linked Wikipedia article about* [***Ad hominem***](http://en.wikipedia.org/wiki/Ad%20hominem) : --- &gt;An **ad hominem** (Latin for "to the man" or "to the person"), short for **argumentum ad hominem**, is a general category of fallacies in which a claim or argument is rejected on the basis of some irrelevant fact about the author of or the person presenting the claim or argument. Fallacious Ad hominem reasoning is normally categorized as an informal fallacy, more precisely as a genetic fallacy, a subcategory of fallacies of irrelevance. Ad hominem reasoning is not always fallacious, for example, when it relates to the credibility of statements of fact. --- [^(about)](http://www.reddit.com/r/autowikibot/wiki/index) ^| *^(/u/shadowmint can reply with 'delete'. Will also delete if comment's score is -1 or less.)* ^| ^(**Summon**: wikibot, what is something?) ^| [^(flag for glitch)](http://www.reddit.com/message/compose?to=/r/autowikibot&amp;subject=bot%20glitch&amp;message=%0Acontext:http://www.reddit.com/r/golang/comments/1v4udy/hes_sick_of_newbies_whining_about_golang_spot_on/cevz4ab)
I'm not trying to fight here. You're welcome to respond to this however you like, and I won't write back. ...but here are just a couple of points that may be worth thinking about: &gt; I consider "it can be done" and "it should be done" two very different things. Sure, but that's *their* decision, not yours. If you criticize someone else for making a decision *you dont agree with*, you're in the wrong. &gt;But most of all, today is the tenth birthday of Scala, one of the most praised languages out there, and after all these years, the language is plagued by tons of problems (at least from what I read) but very few of those critiques started contributing to improve it, they just whine on the interwebz. I disagree. Feedback generates change. It's insulting to the Scala developers to suggest they've simply been ignoring the feedback on their language for 10 years, and that none of it has been meaningful. &gt; I wouldn't build a desktop app in PHP either, even if GTK bindings have been around for years now. Fair enough; I wouldn't either. I don't particular like php. If I had to build a desktop app, I might try Scala though. I have no idea if it's appropriate, but *I think* sometimes the best way find out if a language is suitable for a task is to try to use it. Maybe you fail. ...but that's ok. You've learnt something, and you've tried something new. Maybe that's better than just always using the same tools to solve the same task? I think it is. 
Personally I don't see the point in calling it a "document" instead of a JSON object. Makes my skin crawl a bit. I can't say I'm thrilled about un-marshaling into `map[string]interface{}` either. The author says it's not scalable to write structs for every odd piece of JSON, and I definitely agree with him, however I've yet to use Go to consume random blobs of JSON rather than something more consistent and uniformly structured. I come from a PHP, JavaScript, and Python background and it feels exceedingly tedious to write structs for all your JSON and to un-marshal into those structs rather than un-marshaling into more generic data structures (were they to exist), but after discussing it with some other Go developers I'm convinced that tedious is better than hack-y. However that doesn't detract from `jpath` being pretty handy.
Anyone have? doc := DynamicDecode(bytes) val, notfound, wrongtype := doc.Query( ".something.something" ).ToUint64() I ended up writing a scripting system to process json. From what I'm reading most go people like structs. Maybe I'll just write it.
&gt; If you criticize someone else for making a decision you dont agree with, you're in the wrong. well... if someone criticize a tool for not doing what he wants to do with the wrong tool, who's wrong? I'm not a Go fan, I'm just using it where I used C or Perl, and I think it's much better for day to day use. And I'm also ok with discussion in general about strength and weaknesses of the tools we use everyday for our job. Go has a lot of weak points, I agree, but not the ones everyone is talking about. Really, in the past six months every single critique on Go has been about lack of generics, not being revolutionary, haskell|erlang|python|scala|rust is better for what **I** do and curly brackets. If they said "it's slow", "it doesn't work the way they said it should", "it's ugly" I could understand. But really, the specs are there, can we please stop complaining over and over again about things we already know? I got the impression that most of them are bashing the bike because it doesn't have four wheels. &gt; Feedback generates change. this is not feedback at all. these are people pressing the "don't like button" because facebook doesn't have one. Feedback is when you propose a feature and that feature fits perfectly with the way the tool was created. And BTW, I'm quite sure Google won't change its language just because some random guy on the interbuzz doesn't like it. &gt; to suggest they've simply been ignoring the feedback on their language for 10 years I never said that! I'm just saying that Scala has grown big and complex probably because everybody wanted something different. It ended up being like C++, it does almost everything, but nobody can really understand it fully. I don't know one single programmer that uses every feature of C++. Yes, more freedom, but what's the hidden cost? I agree, trying something new and doing something challenging, is the best way to learn, but if you (you -&gt; generic internet man) give up because the tool doesn't work the way **you** want and not because it doesn't work the way it is **supposed** to work, maybe you didn't want to learn in the first place. 
http://gopheracademy.com/jobs is a good place to post these, but I'm sure they're welcome here too. Good luck.
Go is strictly typed, so there is no 'object' in the same sense as JavaScript objects, PHP arrays, or Python dictionaries. In order to parse JSON in Go you have to explicitly define what each key is -- yes, every single key in your JSON. This can be exceedingly tedious, and if your JSON is random then you're going to have a very bad time. The proposed solution by the author is halfway between the two -- you define a query (the `jpath` within the User struct) that's parsed by the library and the library will search through the JSON for keys that match the query, and it will fill your constructed structs with the queried data.
Typed? No custom objects? How does go then consume data from other systems? 
Given this JSON: [{ "username": "John" }, { "username": "Jane" }, { "username": "Jack" }] Would be this Go: type User struct { Username string } type Users []User users := Users{} data = FetchJson() // returns []byte of the JSON mentioned above err = json.Unmarshal(data, &amp;users) And the `users` variable be as you expect it.
Yay I work for a competitor and use Go.
Also agree on the trail period. My situation sounds exactly like yours. I ended up getting the job, but the next three people we did trial periods with didn't. So it ended up seeming like a big waste of time, at least from my perspective 
Cross-posting my comment from the blog (which seems to use white-on-white for comment text and may have eaten the comment altogether): &gt; &gt; Go did not provide a direct way to read a status code from the HTTP response interface, only write it. &gt; &gt; This is misleading, because you're talking about the http.ResponseWriter interface, whereas net/http uses http.Response to represent a response. Don't call a ResponseWriter a Response. &gt; &gt; It is true that you cannot get much information *out* of a ResponseWriter (as might be expected from the name). However, the typical way of doing the thing you're trying to do is to wrap the ResponseWriter you pass through. Then you can catch all the calls that the are made, recording any information you want, before passing them through to the underlying ResponseWriter. &gt; &gt; Here's a demo: http://play.golang.org/p/6AwEeb7YuY &gt; &gt; You'll find this pattern in a lot of http utility libraries. This approach may also be faster than your reflection trick, and it's certainly more idiomatic than hacking into private fields.
&gt; there are dictionary-ish objects in Go. They're just less efficient. I hope you don't mind elaborating—less efficient than what?
When you use `map[string] interface{}`, you're essentially doing Python/Ruby/whatever in Go. Expect to get similar performance.
I use a tool I made [gostatus](https://github.com/shurcooL/gostatus#examples) that lists Go packages with dirty working trees, in need of updates, etc. Other than that, Sublime Text with GoSublime that runs `goimports` on save.
Where did you have this printed, looks like it actually came out nice. 
I made it on [Zazzle](http://zazzle.com), it was a bit pricy but I'm impressed with how it came out, they definitely don't seem to skimp on quality.
What's goimports?