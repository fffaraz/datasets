The *Bridge type events began with RailsBridge. You can read all about the "why" (or in this case, the "why not") at http://www.railsbridge.org/about
I agree on your points regarding separation of concerns, but I still like to have data models accessible by both the app and data layers so that you can write a method in `data` like: func InsertUser(db *sql.DB, user *models.User) error { ... } and then be able to call that from `app`: err := data.InsertUser(db, &amp;models.User{...}) That way it's still database-agnostic, but you still have well-defined structures that can be operated on everywhere.
A more common approach would be to actually just return a pointer to a MemoryCache object from the NewMemoryCache() function in the first place: https://play.golang.org/p/rIe3y0viqx
Your post didn't include examples of `app` calling `data`, so I was unsure if you advocated an approach like the one I mentioned, or preferring to operate on less-structured data.
Can you explain a bit more? Example?
You may be able to use a wrapper struct *instead of* an interface: type Impl struct { KeyIn func(string) (bool, error) KeysIn func([]string) ([]bool, error) } type Checker struct { Impl } func (c Checker) KeysIn(keys []string) ([]bool, error) { if c.Impl.KeysIn == nil { result := []bool{} for _, k := range keys { v, err := c.KeyIn(k) if err != nil { return nil, err } result = append(result, v) } return result, nil } return c.Impl.KeysIn(keys) } The main issue with the above API is that a client could fail to define one of the methods, and it would be a runtime error (no static checks). You could do better by having `Impl` itself embed an interface value supporting the core operations.
Confusing headline. "Namespaces in Go" for me would mean either packages or something like this ("modules") type MyNamespace struct{} func (MyNamespace) NotAGlobalFunc() { } func main() { (MyNamespace{}).NotAGlobalFunc() } So a better headline would be IMHO: "Using Linux Namespaces in Go"
Just discovered this as I was tired of re-writing lisps in Go. Shame this doesn't get more love
I liked "Go in Action", had enjoyed it during summer vacation and found it as a good addition to the original "Go Programming language". 
Author needs to get it added to awesome-go repo
Why not have both versions, check the length of the slice, and use the double-loops version for small n, and the map version for large n?
I was pretty burnt out yesterday, but regex. I'd allow the user to write some regex for matching with the caveat (docstring) that one should take care that they do not match unexpected output. That along with with exact matching and partial matching should be suitable.
This library https://godoc.org/github.com/jjeffery/stomp seems to let you set subscribe option headers: https://godoc.org/github.com/jjeffery/stomp#Conn.Subscribe See example 2 - looking at the spec, I'm guessing these selectors are server specific? http://stomp.github.io/stomp-specification-1.1.html#SUBSCRIBE
Ooh, fancy! 
There are already a bunch of ORMs that have all of these features plus more. Why would I use this?
Yes!!! I've been waiting for this!!!
Announcement here: https://www.reddit.com/r/golang/comments/5ihs99/announcing_gogland_brand_new_go_ide_from_jetbrains/
"Go... *gland*"? That a rather... uh, biological sounding name. 
1. Do the plug-in developers cease to work on the plug-in and instead work on the JetBrains Go IDE? 2. Is Gogland a fantasy name? I read it as Go gland, which I find odd.
Cool, I put in a request to try it out.
It's only a project codename, not a product name, but it is a bit odd to English speakers. The FAQ points out that it's an island off Finland and sounds a little like Kotlin.
Yes, exactly.
IntelliG
ah! and if you're into the "Grammar of Graphics", you could also have a look at: http://github.com/aclements/go-gg
See here the full list of differences: https://www.jetbrains.com/help/go/1.0/faq.html#d3e52
&gt; built-in formatter equal to gofmt What was wrong with gofmt that it needed a replacement?
I occasionally use err2, but yeah, I try to stay away from numbers in variable names where possible. That being said, I think it's trivial enough in this example that either way is fine.
This is so exciting!! The JetBrains IDE's make the barrier to entry for starting to work with a new language super low, especially if you're already familiar with the others. I really hope I get a chance to try an early build!
I thought gofmt is a service with an API, you put code in, it gives formatted code out, done. I'm in no way versed with the internals of Jetbrains but every editor (Eclipse, VSCode) I used just included gofmt this way?
Just finished this and wanted to try and get clarification on something real quick. I'm reading the request body up to a certain length using an `io.LimitReader`, and then using an `ioutil.NopCloser` to reset the body, as shown [in this code](https://github.com/beeker1121/imup/blob/master/imup.go#L142-L155). Are there any issues with doing it this way? Will the root handler be able to process the body still, without any issues? Thanks! Edit: Just fixed this thanks to the Gopher slack channel - the request body Close method should be called before resetting it a NopCloser. Also refactored checks so errors pass through. **Awesomeness edit**: Optimized thanks to vcabbage on GitHub from the Gopher Slack, request body is now no longer read into memory for valid files, and automatically handles the max file size check within the file read!
I'll reply in more detail in a couple of hours.
If this new IDE will let me run AND debug my go code in MacOS inside the IDE, I will be a rabid user of this IDE. Right now, I am trying to use Visual Studio Code to run and debug my code inside VSC on MacOS, and it's giving me all kinds of problems. Delve is really, really buggy on MacOS.
There won't be, apparently.
I love JetBrains' IDEs and their VS extensions, but yeah... that name is not so English friendly... 
I expect they'd want to keep internal edition state like folds and selection, which is probably easy (or at least possible) if they use the Platform's built-in formatting tools but bordering on impossible if they have to pass raw text to an external tool, plus they'd have to reprocess it for coloration &amp; linting &amp; al. Also as an other commenter notes, the built-in formatter can be automatically applied to codegen or templates, or to only a subset of the edition buffer.
For getting early build.
Curious to hear the reasoning. As far as I know the "go" package and subpackages in std would give you the more fine-grained control over formatting etc, without needing to write a whole parser or anything...
1.8 in general is unfortunate to the point I won't be upgrading.
Go is a real language now!
In general, I would say that it's preferable to post a link to a readme, like at https://github.com/b3log/wide rather than posting a large gif directly to r/golang. It also makes it easier for people to get to your project, since right now the link only goes to the gif, rather than the repo itself. In order to get to the repo, you have to copy and paste the text of the link, which is rather cumbersome.
That being said, it's a very cool project and I love the idea of a more IDE-style interface to the playground. The pasteable iframe for blog posts is downright amazing, IMO.
Really great comments, especially about the matching. I'm a much bigger fan of your version. I refactored the error handling a bit; I've read that article before and I personally didn't think that it was redundant enough to use that pattern. I changed it to this, which is a little bit more succinct: https://github.com/alistanis/silentinstall/blob/master/silent/cmd.go#L123 I don't use named parameters enough and I think that both the method you refactored and the new method there benefit from it. I am a little confused by what you mean about embedding the Stdinpipe() to the struct and removing the need for goroutines - when I'm reading from Stdout/Stderr I don't know when input is going to end until EOF, so I need to be able to read/read/write asynchronously. Maybe I'm just really missing something? Either way - thanks a ton for your contribution and for going over the code. I'd be happy to add your reddit name or any other name to the README as a contributor, or you can feel free to pull request and I'll approve it.
&gt; If this new IDE will let me run AND debug my go code in MacOS inside the IDE, I will be a rabid user of this IDE. You can already do that, today, with the IDEA Go plugin.
This is not an appropriate comment for this forum.
Intelligo sounds like a disease... what about G-UNITelli ?
I would also like to purchase one. If there is an online store that sells them would love to know.
I love JetBrains products, but I do a lot of my Python work in VS Code right now despite my paid PyCharm subscription. For me the choice is usually about my mood. VS Code competes more directly with Atom and Sublime Text. JetBrains products usually feel heavier and slower, but the GIT tooling, refactoring, and configuration GUIs are pretty rich. When Project Rider is released for C# et al, I anticipate it will compete with Visual Studio, not Visual Studio Code. Go, on the other hand, doesn't really have a rich feature filled option. The difference might not be large enough for me, but if I wanted a GUI to configure Docker stuff, it might already be worth it.
I'm the author of godb. I'm happy to see a mention here, thanks :) The projet title has changed to "A Go query builder and struct mapper", as it's not a full featured ORM. I have to be honest. This project is the result of some learning work, I use it, but I don't pretend to make a tool better than others at this point. But perhaps it could be useful for somebody else.
Simply to find bug I made but didn't found yet (joke). Seriously, nothing. You could find an interesting feature, like the use, or not. As I explained in other reply, the project was a laboratory to improve my go skills. I tried to make something clean (there is room for improvement), something I could use on real data, something useful at least for me. The code is open source, free, nothing more. 
&gt; I would have thought it would be easier to use the stdlib Go parser to implement all of those things, though? […] using an existing library to do all the heavy lifting just seems logical to me. 1. Parsing is far from "all the heavy lifting", especially for Jetbrains (russian developers apparently say that Jetbrains cooks parsers for breakfast), I'm sure they've got extensive tooling to facilitate that. 2. And Go was written specifically to be fast and easy to parse, understand that Jetbrains has their own Swift, PHP, SQL or C++ parsers (in fact IIRC they've got two of that one, as the ReSharper C++ and the CLion teams independently implemented theirs). 3. Furthermore the Go parser is written in Go, requiring JNI bindings to CGO bindings to Go, that's a fair amount of complexity for what it is. 4. Finally Jetbrains IDEs need lots of deep contextual knowledge of the code for syntactic and flow analysis, code rewriting (refactoring), code generation, and things which just don't make sense in the language parser like *language injection* where a Go string is parsed and analysed as SQL. This is all infrastructure which already exists, having been built in the platform over 15 years or so, it "just" needs a parser fitting in. Thus writing their own parsers is the most natural course of action, it lets the new system fit right in the platform's ecosystem, and allows them to benefit from improvements to the core platform without a mismatch between an external parser and their own tool. Plus it gives them freedom of movement, they're not beholden to an external group, though they're paying that in playing catch-up when the language changes.
This is super important, I've been using Go this week for a uni project (needed an excuse to learn it anyway!) And trying to learn a language without an IDE is pretty tricky. I think this will encourage the uptake of Go a bit more, as it bridges over the learning gap
I just wanted to add, it's weird that the other solutions here - including the ones being upvoted - all failed to actually answer the question and are all instead suggesting other things. Safely asserting one interface as another is a way of "testing" a type to see if it has methods. This allows you to have a superclass "check" the child, proxying methods if the child has the method, but providing its own implementation if the child does not. It's a powerful feature and I feel either the others have not understood your question or do not understand type assertions.
I think /u/masklinn had a very good explanation above. There's also another reason. Cursor jumping is irritating when having an external program format the source as the IDE can't reuse the position in the file correctly anymore. Moreover, the formatting is done on the fly which means that you rarely will need to format anyway. Finally, the Platform already offers the tools needed to handle the formatting so it makes sense to use it.
nice! thanks
I don't think there's any "hope" here. They're no longer making newer IDEs free. If there was to be a community edition, it would be on the FAQ.
I'd recommend looking up the issue here: https://youtrack.jetbrains.com/issues?q=hidpi and if you can't find it open an issue, they are very quick to reply to these.
Representation is not the only issue. I would disagree that we're overrepresented given the disproportionately high unemployment rates and lower education rates, but let's say it is proportionate for the sake of argument. I have had potential employers tell me that my presence would be a distraction to others purely because I'm trans. I've had HR tell me that coworkers have a "right to know" that I'm trans and out me to potential hires- and tell me that I should get out of tech if I don't like people making crude jokes about my genitals and calling me a tranny. Representation is immaterial if the rights of trans people to a workplace that isn't hostile are ignored. Representation can definitely help those things change- people having a trans coworker can help them realize the issues we face- but it's not a fix. It's one aspect/symptom of a larger problem that needs to be approached from many angles. GoBridge is one such angle.
I think the public types and functions of the standard library should have been frozen at 1.5 to forestall certain combinations of GOARCH/GOOS and alternative compilers becoming de facto second class citizens, the context package should have stayed in golang/x, quotedprintable belongs in encoding, not in mime, the plugin package should be incubated in golang/x, and the deprecation policy is being applied superfluously and in ways that are contrary to the compatibility guidelines. Packages like syscall and syslog should have demonstrated how careful you have to be with the standard library and since 1.5 it's been polluted with irreversible bikesheds, partial implementations, pointless deprecations and bad ideas and more of the same is slated for 1.8.
Gonad it is, then.
Great, thank you! This works: mqSelector = `category='books' AND attr='title'` sub, err := conn.Subscribe("/queue/SomeQueue", stomp.AckClient, stomp.SubscribeOpt.Header("selector", mqSelector)) 
Test debugging, hallelujah! 
 type KeysFunc func(keys []string) ([]bool, error) func (kf KeysFunc) KeysInDb(keys []string) ([]bool, error) { return kf(keys) } func (kf KeysFunc) KeyInDb(key string) (bool, error) { result, err := kf.KeysInDb([]string{key}) if err != nil { return false, err } return result[0], nil } but as noted elsewhere consider providing default implementations as functions or provide a wrapper to return struct{I1,I2} with a default and provided implementation.
I said we need *a* central repository and refined versions of npm/Cargo/Mix tools. I didn't say we needed the npm foundation to come and do it for us. The dream would be for Google to fund the central repository and have it managed by some Go committee members, I guess.
why not call it just goland
It's the name of an island https://en.wikipedia.org/wiki/Gogland near the https://en.wikipedia.org/wiki/Kotlin_Island which is near St. Petersburg where a big dev center for Jetbrains is located. It's a pun / codename for it, they are happy to get suggestions for the final name.
Since Clojure is trying to emulate Go with `core.async`, this can go gloriously meta pretty soon :)
&gt; After long discussion it was decided that the typical use of maps did not require safe access from multiple goroutines, and in those cases where it did, the map was probably part of some larger data structure or computation that was already synchronized.
&gt; GOPATH of over 7 GB of Go sources only I always wondered what go get github.com/... would do.
As I understand its based on Webstorm, similar to PHP, Pythong IDEs. Was just planning to buy Webstorm since my Intellij license is about to expire. Wondering if they would provide some upgrade option or you'll just need to by new license.
When they do that, can they publish a spec about what exactly gofmt does? It irks me that there's no written spec for it.
I'll pass the question along. We've asked the Go devs a long while ago about a formal spec and the answer was that the spec is in the implementation and that's enough.
It would make more sense to forbid shadowing altogether. There are enough letters in an alphabet to come up with new names for nested scopes. While single character names are fine within a function or block (one usually can see entire function on the screen to trace variable origin), file, package, and universe scoped variables should have descriptive names. Voila, no likely name clashes and no need for shadowing. Obviously, it's too late for Go 1.x. But there is a reason `go vet` reports shadowing - it is more harmful than beneficial.
Nice Work - my only comments would be to reload the config once in a while and also change the UI to a client side pull of an API call to avoid reloading the entire page every X seconds!
Echoing u/natefinch 's sentiments. Very sorry to hear that this actually happens, and that you have to deal with it :( 
Yes! Nice I'm excited for this
Been using the Go generator beta in prod for months now, it does indeed work nicely, at least for my medium-complexity grammar.
&gt; I think the public types and functions of the standard library should have been frozen at 1.5 to forestall certain combinations of GOARCH/GOOS and alternative compilers becoming de facto second class citizens Do you have any examples that show the second citizenship problem? I think it is only natural that certain GOARCH/GOOS combinations will have some bugs since there are fewer people that know them well and use them but I don't think Go treats any combination as a second class citizen per se. &gt; the context package should have stayed in golang/x Why? It is a proven best practice and it is incredibly convenient to have it supported by the standard library. &gt; quotedprintable belongs in encoding, not in mime I don't know about that at all. You might be right. &gt; the plugin package should be incubated in golang/x To be honest I wouldn't mind if they took some more time to polish plugins before they moved them to the standard library. But as far as I am concerned, having them in the standard library is important. &gt; the deprecation policy is being applied superfluously and in ways that are contrary to the compatibility guidelines Any examples of that? &gt; Packages like syscall and syslog should have demonstrated how careful you have to be with the standard library and since 1.5 it's been polluted with irreversible bikesheds, partial implementations, pointless deprecations and bad ideas and more of the same is slated for 1.8. Again, any examples?
Exciting news!
I went hunting for this too; it's not been made easy to find. And I still can't tell what has changed between beta1 and beta2 :-(
So, closed source, then?
Can I use delve debugger on tests?
Hi there, I commend you on your efforts here. I can tell you put a good bit of work into this so I figured since no one has commented I will tell you why that may be the case. I'm a fairly experienced programmer myself and I can usually make sense of what something is, or at least what it wants to be. But after looking at your readme and rowing a couple github files I backed out with no idea what this library was. At first I thought maybe it does reflection or uses the Go/{ast,parser,token},etc family for static code analysis so it immediately sparked my interest. But I don't think that's what it is, it seems to run some kind of service.. so I looked and still am unsure :) I would adjust the readme a little and show exactly what it does, print the actual code to use, them the output data and why the output is useful. Might help ya get some more people to show interest. Oh and run Go test with -race, I see a few places that could race depending on access patterns. Good job on your code coverage, hype factor and general effort on this though, happy coding, take care.
Yes, the and all the new features will be closed source. But given that there's a lot of effort put into it, I'm happy with that. 
It's a codename, they are looking for the final one. It's also an island.
There's also a new way to install if you want to just try it out, without replacing your current stable install. https://godoc.org/golang.org/x/build/version/go1.8beta2 Follow instructions there and then use go1.8beta2 instead of using the normal go command to try it out. 
Such a waste for the open source world. At least if it ends up being good and helps make companies adopt Go easier, that will be a nice indirect contribution.
Sorry all, I couldn't see that. I will update that gist with @dcapes 's awesome feedback.
Fatih is doing an amazing job with vim-go, I'm glad to hear you are happy with it. Please make sure he knows that as well. 
Oh, great, thanks :). We even talked about these stuff in a ticket on gentleman repository. I am looking forward to gentleman v2. I think it is great idea. Also, I would really appreciate your feedback on GWC and cliware. Is there anything you would change? And how does it align with your plans for gentleman v2? It would be awesome if we could agree on same plugin format, so that same plugins can be used on both projects for better code reuse and to allow third party developers to write plugin with wider audience. I am willing to talk about design of cliware (or whatever we agree on) to achieve this. Would you be interested in something like that?
Some more info on typical use cases, alternative packages and benefits of this particular package would be nice.
io.Pipe is especially useful when you need to pipe something that is too large to load in memory. Eg if you want to do an HTTP post with a file that is too large to load in memory. I think that is how I first learned about them.
I find https://github.com/gordonklaus/ineffassign (part of gometalinter now) to be more effective in finding places where shadowing causes a problem. The shadowing reports from `go vet` have too many false-positives. Yes technically it's shadowing, but it's not a bug.
Catalan/Spanish, too
Atom also does not offer the amount of info, refactorings etc. typical JetBrains IDEs do.
Looking at [introduction](https://github.com/chyeh/pubip#introduction) section more robust I guess.
The only use case I had for maps so far was a dictionary with lookup/insert/delete = everything has to be synchronized = mutex.lock() everywhere.
On the latest GNOME, if you up the font-scaling in `gnome-tweak-tool`, I find the IntelliJ products fine on a 4k screen.
First of all, thanks for the comment. Now, it's exactly like /u/Morgahl said, you can see it this way "your Google analytics but for any data", Google analytics (GA) "only" does web analysis. Imagine you have a []User that you fetched from your db and you want to know more about your user base; now, you can't give GA a []User, if you want some statistics you'd have to write all the code yourself, what the pkg does is exactly what you'd normally write but in just 1 line of code. And yes, i need to add more info to the README such as a better explanation of what the pkg does and the outputs (if you go to the examples/sub-folders, the .go files have the outputs) . Thanks for giving me your opinion :) and thanks /u/Morgahl for clarifying the doubt.
What new tool
Try rename data to Data with capital d to make it public
Thank you! I guess it makes sense that if you made an attribute private, you wouldn't want it potentially being sent out the door. Duh.
I'm not going to get into the details of pricing and licensing as I don't have any knowledge of them. But based on the FAQ, if they price this in the same range as PyCharm et al smaller IDEs I think it will make the IDE quite approachable as a price paid per month (around ~€20 / month~ (that is companies), €9 / month right now). If you spend all your time developing Go apps, I think it's a reasonable price. They are spending all their time to develop a product, fix all the bugs, add features and so on. If you don't like paying JetBrains, I suggest trying to donate to people like Dominik Honnef https://www.patreon.com/dominikh who are doing a lot of work in the open-source community to give developers tools like go-statickcheck or go-mode.el. Aside from VSCode and I maybe Atom, I don't think any other editor out there for which the developers are paid to work on and the only tool that I can think of as being paid for is guru.
I think full IDEs are great. I have tried using go a couple of times with Eclipse and it didn't work as smoothly as I hoped. Perhaps this will be a bit better. I look forward to trying out go a little bit more when I can get hold of this.
Some of that can be done in Go when plugin support arrives in 1.8.
Part of the point of moderation is to remind people to keep the conversation on track about mostly technical topics. It doesn't do anyone any good to rehash the same complaints over and over, especially when it's completely unrelated to the original post. It was certainly fair game when the font was first announced... but at some point it just becomes noise. Note that Damian didn't delete the comment. It's not even strictly a "warning" per se. It's just a suggestion that we try not to beat a dead horse.
Have you already read The Go Programming Language book? If not, I'd recommend starting there. It's written by Alan Donovan (who is one of the core Go team members) and Brian Kernighan (whose name speaks for itself) and is really high quality and comprehensive. http://www.gopl.io/
Agree on Donovan/Kernighan book; If you want to immerse yourself as a beginner, then these might also be helpful: https://tour.golang.org http://www.golangbootcamp.com/ 
Without losing cursor position and folding?
The highlight seems to be the plugin package has been enhanced by removing support for darwin.
And in the grand tradition established by that package, nobody gave any thought to requiring a build constraint so go fix has turned into go screwup.
You're just not quite angry enough for opensource
I don't understand. 
The Go Programming Language. It is a really good book, short as can be while at the same time having great practice programs and great explanation of the language. It is a very worthy successor to K&amp;R.
yeah, I'm open to collaborate with you. Let's move the discussion to gentleman repository: https://github.com/h2non/gentleman/issues/19 PS: I'm a bit lazy today, but there is some other stuff I'd like to add there. Feel free to comment whatever you want with your proposals too. That should be a pure design discussion.
Couldn't find a fix for https://github.com/golang/go/issues/18190 , so it was removed to avoid shipping broken code.
What black magic is this?
This is really fun! Thanks for sharing. How did you find using GopherJS? Any big hurdles or problems with performance in writing a game like this?
FYI there are native Go alternatives to Guard.
Cool. I am new at Go and appreciate the 'brisk pace' because I know C well. I tripped over the map example because it doesn't work like that: var x map[string]int x["Hello"] = 1 While reading your page, I thought all of the code should copy+paste&amp;work, and an explanation that make() has to be used would be nice :) Also the part where you talk about multiple return types uses the example func calculate(a, b int) (sum, prod int) { As far as I can tell, that's just one return type :) Thanks!
...
There's a freeware version: https://www.hex-rays.com/products/ida/support/download_freeware.shtml (dunno if it is usable for Go)
I wasn't sure if plugins can be loaded into a running process. If so, that would be nice.
What are more commonly used/loved ones? I just turned to Guard because I know it like the back of my hand.
Left and right only is really, really confusing. You should make the controls use all 4 directions. Also, it's possible for food to be generated underneath the snake. That caused some confusion. Other than that, pretty cool! Snake was my first game I ever wrote as a kid. Brings back memories.
To my knowledge no other Disque client offers a channel-based solution, which hinders my ability to use common channel patterns for flow control. This is actually why I wrote it, I would have rather find something that solved the problem for me, but sometimes you just gotta write code. ¯\_(ツ)_/¯ [EDIT] Don't downvote a perfectly valid question folks!
I don't know much about the technical details of node and it's event loop but I am pretty sure it is still single threaded. And that you have to code in a non blocking way and use promises. Go's scheduler let's you write code that blocks, since goroutines can be swapped out and multiplexed onto os threads. Also goroutines are extremely cheap to spawn (like a function stack). 
The problem being that there doesn't seem to be a community edition in the works, meaning developers looking to get in to Go who are coming from other JetBrains products will have to pay just to *try* Go. In the end, this looks like it will be more useful for developers whose companies are switching to a Go-based stack, or for ones that are already working in Go.
This is cool, good job. I always like Go generate tools and I use TDD(ish) for everything and sometimes make small mock structs on the fly for just call counts. In order for this to be a safe and reliable tool since its used for unit testing and many people run -race for their apps, I would make this library generate a struct a safe for use by multiple Goroutines. A couple patterns I follow for this when I just want call counts, is an int64 with Atomic.addint or a "type Call struct" that embeds mutex and gives helpers to reset or increment. For more complicated mock control, I usually have a factory that returns two parts, the mock structure and a control mechanism that I can check for results, block execution etc, I.e. // NewServerMock() (*serveMockCtrl, *serverMock) { ctrl, mock := NewServerMock() // run a test t.Run("TestOne", ... if ctrl.ServeCalls &lt; i { ... // next test t.Run("... ctrl.Reset() // reuse or further mutate existing state in subtext
From the sounds of it the problem appears to be display. You could use d3js or polycharts to display charts and graphs. You could also stream the data with websockets if you wanted to have live updates. 1.8 also has http2 push support.
&gt; then R with Shiny to build dashboards Shiny? As in exp/shiny?
Wow. Unreal. Read my first post. Simply stunning.
Are you looking for [something like Hugo](https://gohugo.io/)?
Thank you all for your responses!
Unfortunately this reddit post linked to the download page instead of the release announcement on golang-announce or golang-nuts: https://groups.google.com/forum/#!topic/golang-announce/LvfYP-Wk1s0
Did you file a bug?
FWIW, I don't really consider using channels in APIs idiomatic. There are a few stdlib packages that do it, but mostly the adage is "offer synchronous APIs and let your callers wrap it in an asynchronous one if they need to". The reason is, that there are a bunch of subtleties involved in how channels work (e.g. are they buffered? Do they need to be consumed? What happens when they are closed?) and calling a synchronous API and sending the things on a channel are only a very small handful of lines of obvious code.
Use a theme that works without javascript.
Nice article!
&gt; "offer synchronous APIs and let your callers wrap it in an asynchronous one if they need to" Well, the client does that: the channel implementation is nothing but that handful of lines of code on top of the synchronous API (which is also exposed and documented). Nothing wrong with offering a convenient ready-made solution though, I know I'd rather have that common use case solved and tested in the library itself. 
Nice!
Can this be used as a lib? 
This is really nice. I wonder if you could plug it into Google Photos? Do they have an api where you can get a reasonable thumbnail that you can process?
Thumbs up for Hugo, I use it for appliedgo.net and love it. However, the OP seems to have different goals: &gt; Which is, to put it bluntly, because I need a tangible, useful project to stick on my resume.
What the problem do u solve? I didn't see any advantages of the lib. 
Uh that's nice. I have a similar program from 2001 called Azujelos that makes the same (http://www.chip.de/downloads/QaPa-Azulejos_13010397.html). I really need to check your source code, I always wanted to do something like this since I was young ... 
That's pretty much on point, just happens that you don't want to agree with it.
&gt; meaning developers looking to get in to Go who are coming from other JetBrains products will have to pay just to try Go That's incorrect. There will be a plugin for IntelliJ IDEA Ultimate and other paid IDEs according to a statement on the release announcement. Moreover, the IntelliJ Toolbox users will automatically get the new IDE without having to do anything for it. Both will happen when the IDE will go in public EAP during 2017. So people that already use other JetBrains products are well taken care of by JetBrains. &gt; In the end, this looks like it will be more useful for developers whose companies are switching to a Go-based stack, or for ones that are already working in Go. Actually it will be very useful for beginners as well. All other products are free for students and teachers, are free for open-source project maintainers and are discounted for graduates and startups. While I don't know what will happen when the IDE goes 1.0, there's strong evidence to support that it will continue in the same line, which will make it very attractive to a lot of people. Finally developers that really want to use this, will probably be able to pay the €9 / month subscription fee, which if you think about it, it's the cost of two coffees. And with the IDE having a trial, I'm sure people will try it and figure out for themselves if they like what they see or not.
Eclipse + Goclipse plugin gets stuff done :).
Here's an example with descriptions and code. https://dinosaurscode.xyz/go/2016/07/08/golang-and-reddit-api-tutorial/
 cheers for the link. ill figure it out im sure.i guess thats part of the fun.
You should apply gofmt on that.. It will make it perfectly symmetrical, and give it smooth edges.
Please, don't use relative imports. package gosaic/cmd: unrecognized import path "gosaic/cmd" (import path does not begin with hostname) package gosaic/controller: unrecognized import path "gosaic/controller" (import path does not begin with hostname) package gosaic/environment: unrecognized import path "gosaic/environment" (import path does not begin with hostname) It is not go-gettable! Using of makefile is not idiomatic!
&gt; appliedgo.net At least, there's no sidebar which eats half the width of the browser window (if you happen to use a tiling wm and your browser takes half of the screen).
I don't even remember anymore. I tried to get it running twice but there was a lot of configuration to be done and then it did not work fully anyway. Comparing that to for example the python plugin where it works with very little trouble. 
can you post your query builder?
Thanks for the link, done!
Several of the examples near the end could be simplified by using http.Handler instead of a HandleFunc. The Build method, for example, is totally unnecessary. Just use ServeHTTP. 
Yeah, but you have to rely on libraries like gofmt. Atom doesn't actually do any building, testing, or running. It's just a text editor. 
You might want to take a look at [Grafana](http://grafana.org/) it does all this already and support a lot of common datasources out of the box or its reasonably trivial to write an endpoint as a [simple JSON datasource](https://grafana.net/plugins/grafana-simple-json-datasource/installation) for it. And it's open source and written in go - https://github.com/grafana/grafana
Couldn't this potentially worsen latency because the files might be cached by the browser?
I fail to understand how this relates to a DSL, what was achieved is a good OOP approach to solve you domain problem. No specific language was created, the SL in DSL
Yes, that's correct, Gogland uses the only debugger known to work with Go, delve. 
There are still a lot of bugs in delve, hang, go to wrong line while step out, can not print local variables.... 
Sadly those can't be fixed without people contributing to delve
Do you still use js for UI state and UI navigation ? Seems the only workable option. But I would rather do as little as possible in js ;-) So just checking this with your experience.
&gt; a lot of configuration to be done Huuu? * Install Goclipse (~5 mouse clicks). * Go into the settings / Go / Tools and download+install all things (gofmt, oracle etc) with one click automatically * Done
Yes, slightly. The client wouldn't see any delay though, as the cached results are displayed immediately. However, the server does additional work that isn't necessary. This could be fixed when this becomes a standard: https://lists.w3.org/Archives/Public/ietf-http-wg/2016JanMar/0024.html
Install the Sourcegraph extension for Chrome for similar functionality on GitHub
I think it's just a weird Rubyism. They call writing compact code "writing a DSL" for some reason. The article mentions that it's not creating a true language at one point, so it isn't a genuine misunderstanding by the author, just a weird way of referring to things. 
I think calling it bullshit is pretty harsh. A DSL in Go looks different than it does in Ruby.or Python. I have definitely seen many people call this kind of assembly of methods and functions a Domain Specific Language, for example when talking about the various Go testing frameworks. 
Please share this advice with your colleagues.
We a using postgres, mysql, mongo. But our code is still maintainable across 30 backend developers. We use standard drivers and some wrapper around sqlx.
It would be possible to move most of your state management to Go, I tend to keep application state in Go, and on have my UI widget state in JS. I will also say that because you are running through the JSX and Babel compilers, you have full JS ES6 syntax available which takes most of the pain out of JS. As far as Navigation, I don't tend to use the built in Navigation controls in React Native, rather opting for Navigation just being result of application state change. A bit of advice for React Components, use very few ES6 class style stateful components and instead use pure functional components and you will have a much better experience.
I agree with the other poster however, this isn't an abuse of syntax. I have tried unsuccessfully in the past to express this type of programming to people before.
Wow so helpful.
cool, yea sqlx is a great library too, I've made contributions to it myself to simplify JOIN queries, but in the end settled on upper for the extra conveniences. Such as.. query building, types for conditional expressions and also a bit of code organization help with an interface enhancer pkg I wrote github.com/upper/bond. Bond still needs some docs, but it creates a simple Store interface for more of a model-like feel for tables (optional, and varies in taste). 
Quick look on eBay gives me this: http://m.ebay.com/itm/Ir-Gopher-Raro-KIDROBOT-Renee-Frances-Arte-de-juguete-de-vinilo-Google-me-PROJECT-s-Mascota-/201526576534?_ul=AR Hope that helps. Might be some on Craigslist.
Technically speaking, we can't copy pasta with MIT license, can we?
Good point I change the license to Unlicense, public domain.
Awesome, thanks!
http://i1.kym-cdn.com/photos/images/facebook/000/210/119/9b3.png
Memory is cheap
Turns out that this IDE is actually pretty fast and uses a lot less memory than others in the family. As for who needs it? Judging by the reception it had I would venture to guess that many more programmers that you think. IDEs actually provide a wealth of functionality and one thing that you'll not find in other editors are all the refactoring options. Most importantly it will help new programmers have an easier time to start and learn Go. So who needs it? The Go ecosystem, current and future, needs it.
They only announced it Thursday so it's not quite about a week yet. As for if you'll hear from them, it might be that they are overwhelmed with requests or they are trying to make sure they get a good sample of users, based on the questions they are asking. Have patience.
A lot of people think they need it because that's how they've been used to in the past or with other languages. I argue that a Go dev doesn't need it in reality, but if the dev feels this way, then by all means.
If it compiles it should be in the "Projectname\bin" folder.
Just after Oracle bought Sun, in 2011 they started bundling payment-required components (e.g. JavaSE Advanced) in their supposedly "free" (as in beer) JavaSE download. Only this year did they start hunting down people using those extra components, with some businesses owing $1 million or more to Oracle. Would you really bet on Java in 2017? 
I can be open and most probably I will take a look at it. But I've tried Intellij IDEs in the past and haven't been compelled to use one, unless maybe for java. I didn't say IDEs are all bad, but while I can see how they can help someone be more productive in certain aspects, I also find them quite limiting in other aspects and feel they slow me down. Not necessarily in performance but in UI and interaction. I'm doing 99% of my work using just the keyboard, not only when coding (in which case is 100%) but in my interaction with the system (Linux, no DE, just Tiling Window Manager). An IDE makes me take my hand from the keyboard and put it on the mouse, which is a sin :). My flow is ninja level and I can't settle for anything less. So although curious to try Gogland, I don't think it will be on my liking.
I hadn't seen this comment yet so i responded to your other. I got the damn thing to compile at last but it did not accept me using a normal project and go from there and put stuff in relative paths. The installation did really not work as easy as you said. I know this because I tried it from scratch, uninstalling go, changing the godir to an other disk and setting all variables there etc, cleaning out anything old to make sure nothing causes trouble and it still did not work by just installing it, making a go project, adding a source file to that and compiling it. That results in no binary file and that is how at least I think it should work after an installation of an eclipse plugin. You must have some other stuff set up if it works that easy or you put the project in the only accepted path.
As long as you put the license notice at the top of the file, should be good 
I hadn't installed Go or Eclipse/Goclipse on my notebook under Windows yet (only on my Fedora partition), it was a fresh install. What I noticed is that you seem to put your projects under your Gopath - that's not where your stuff should be. The Gopath is for stuff you download via "go get". Projects must be created via the Eclipse interface, you normally have a default "workspace" folder that is set upon the first start where your project folders then are created.
You have your GOROOT - the place where you installed Go. You have GOPATH - the place where your stuff is placed from "go get" and which you have to include as a Path variable under Windows. &gt; with GOPATH: D:\KOD\GO;D:\kod\go\go_neon\firsttry - that's your problem, you are trying to use a project in your GOPATH directory, don't do that. You have your Eclipse workspace - the place where your Go projects are created, Eclipse asks you on startup for a folder for the Workspace directory. If all 3 are set you can just create a new Go project via * File * New * Project * Go/Go Project * Enter Projectname * Finish Then create a folder under the "src" folder and create your "main.go" file into it via "right click/new/go file". Then enter your go code, press the big green arrow (after creating a Run configuration for Go) and it gets compiled and placed into your project bin folder. Screenshot from my new installation a few minutes ago with Eclipse project on the left side, Go environment variables on the right top and my Workspace directory with the compiled binary from Eclipse on the bottom. I just used the default workspace Eclipse suggests me. * http://imgur.com/a/mJYBQ And then you can go under "Windows / Preferences / Go / Tools" and one click install gocode, guru and godef (and don't forget to activate "Format automatically on editor save" at the bottom).
Will check it out later. On mobile now and I hate trying to look at code on my phone.
The right tool is the one that gives you the greatest productivity, be it IntelliJ, vim, or writing code on slips of paper. Only in limited cases are the resources on your dev machine not sufficient for development, and in those cases you use a different tool/method/machine to get the job done.
Judging by the other comments in this thread it doesn't look like that sadly. 
Not the template itself, I meant resulting projects.
i dont think using 2 libraries and a basic makefile is super opinionated, but thats ok, you have the option to keep doing whatever your want, even roll your own. if you don't need anything mkdir should be more than enough to start a project.
Yeah that's cool, this is an app rather than a lib :) Funny they have the same name!
The scoping is one that I have mixed feelings towards, and I generally feel unexported types are easier to maintain and lead to easier to understand code, but I'm not opposed to them in some situations. I only got a chance to glance at the code (busy weekends as the holidays get closer) but I think the second point you are referencing is the fact that my example parses `{"born_at": null}` as if the null were really a 0 while yours will error since null isn't a valid value. Is that correct?
Here's the gist so far: https://gist.github.com/carlmjohnson/855c31109df51d42bc2fca7da7cab23c I wasn't able to simplify as much as I wanted because the side-effect of doing everything as methods is that the composition process would have to be repeated over and over if you just added a ServeHTTP method to everything. I think if I rewrote it some more to use functions instead of structs/methods I could fold the composition cost into it more elegantly, but at the cost of looking less like a declarative struct at the end.
Thank you for using Ebiten!
&gt; What I noticed is that you seem to put your projects under your Gopath - that's not where your stuff should be. I give up.
&gt; but in my interaction with the system (Linux, no DE, just Tiling Window Manager) That's interesting. I've heard quite a few people using a similar setup. I've tried using a Tiling manager but I had problems with certain programs especially the browser. Could you share your setup? I will give it a try next weekend.
None of those permit permissionless copy pasta, which is really what I want. Normally I release all my stuff under mit not because I care if it will be copied but to make developers life easier dealing with corporate red tape since its usually pre-approved. Unlicensed was one of the preselected github choices so it looked okay. Not really sure what to do here, never researched or thought much about it. You suggest just using MIT and annotating my intent that someone may use it without giving me credit? I guess what I want is kind of contradciting, to have copyright for the corporotate world but not impede the solo weekend project with having to copy a license file or credit. I want to be public domain without red flags for company use (including my own). 
Care to elaborate? If you mean revoking the previous license, I didn't think I needed to create a dual license because the new one was more permissive.
Dual license!
Probably out of good will but also probably a very bad idea from a security perspective. 
Here's [the context](https://groups.google.com/d/topic/golang-nuts/TJa4V3y_QRQ/discussion) for this package to spring into existence.
I was gonna argue with you, then I looked at the code. Yeah, it would be entirely too easy to commit a change there with a message like "updated from mozilla root", and insert any malicious root you like. The os disto cert bundles presumably would have more integrity checks done and so forth, but I am also thinking it would not be hard to make a docker image with compromised certs and get people to use that as well. I wonder if it would feel more secure if it actually downloaded the source file from mozilla at runtime, checked the sums/signatures or whatever, and built the client from that? But how do you establish a trusted connection to mozilla without the roots to begin with?
Hard to incubate compiler/linker changes without changing the comiler/linker though.
I think the runtime download is probably safer than embedding it. The problem is if you have stuff like Wosign being distrusted. Since the certs are baked in, all old versions will trust Wosign, no matter if you update the os-certs and feel safe about it. The oscerts are usually a good idea, if you don't have those, you need to pin the mozilla ca and only establish a connection to it for the initial update, distrusting everything else. The problem is that nowadays it's very hard to securely bootstrap a root ca set without having to rely on a subset of root ca's.
&gt; // Append out OXR App ID to URL, :-( Just curious, why the sad face?
I really like this version of the proposal, especially since it's limited to types only.
Thanks, I'll check it out when I get home.
@shovelpost: Good question! I'd just prefer to be able to pass AppID's/Tokens via an HTTP header.
Projects should be under GOPATH iif they are to be go gettable. Please stop teaching people the wrong thing! The IDE should be able to work with that, not force users not to do it due to obscure reasons!
You can use the recursive or normal parsers (`ParseAll` and `Parse` at the moment). If you don't pass the directory where the resources live it won't do recursive parsing. I'm in the middle of a refactor that will show this distinction more clearly. There is no magic going on though ;-)
Ugly arrow syntax?
&gt; Secret wont be sent in the request. cheers sairamk. i appreciate the help.
You're right that if you have a function that matches the signature of a `HostFilter`, you don't need a special declaration for most uses of the type- for example to pass it into a function that expects a `HostFilter`. Here's the kicker, though: if you declare methods of the `HostFilter` type you can't use them with `IsDotOrg` as the receiver without fancy footwork. [This playground](https://play.golang.org/p/KiD_PSbsTG) uses my "unsavory" declarations, [this playground](https://play.golang.org/p/T9BQVlC35V) uses a normal function declaration for `IsDotOrg` and another example `HostFilter`, `HasGo`. Both declare a method of the `HostFilter` type and attempt to invoke it with `IsDotOrg` as receiver. The first compiles and returns the value expected, the second doesn't compile. There are a lot of DSL-y and otherwise handy uses for function types that don't involve declaring methods on them and don't require this kind of stuff, but if your API involves functions that have methods (odd, I know) you may end up using some dubious techniques. 
Eclipse uses workspaces and you have to create your projects through the IDE. That's how Eclipse worked for 5-8 years. I never had problems with Eclipse, just use the Workspace directory (it asks upon startup where to put them) and it works. And I don't see any reason to put my workspace in the same path as GOPATH, GOPATH is for "go gettable" where IDEs look for "import xyz" stuff first but I would never put my workspace folder in there.
HOLY SHIT
Monkeypatching is intrinsically a runtime operation. If the compiler is doing it, it isn't monkeypatching. It is the runtime nature of monkeypatching that is the core problem. It is also possible to have compile time magic, where the compiler does something there is no way to track back. This isn't that either. This is so easy to track back it'll almost certainly appear in the godoc. That's not magic.
Yes, but why?
I just tested the Eclipse workspace (C:\KOD\Go\src\workspace) in the same directory as the GOPATH (C:\KOD\Go) and it worked without any problems.
Thank you very much for sharing. I am gonna try i3wm soon. Personally, I love to work with the keyboard so I find that vim fits my programming needs very well. I had tried a TWM at some point and I thought it was fine but I kept having problems with the browser. I can't remember which one I had used though. Hopefully things will be smoother with i3wm. Unfortunately, I do not know much about Arch Linux. I've been hearing a lot of hype but I find that I am a little past the point of experimentation with distros. Nowadays I want things to just work and I especially appreciate sane defaults. I remember one day installing Arch for fun though. It was certainly a cool experience that brought me back to my university days. I also remember using the Vimium extension which I liked quite a lot. Though as I recall, I had trouble with certain tasks which always made me reaching for the mouse again and again. Maybe I needed some more discipline. I am also a person that likes simplicity and minimalism. After doing some experimentation with tmux I realized that the simplest, alternative thing to do is opening a few tabs on my terminal which I can do with zero configuration on a freshly installed system. And as much as I love using the keyboard, for certain tasks you just cannot beat the mouse. So nowadays when I develop, I keep switching between two modes. 1) Keyboard mode aka writing Go on vim 2) Mouse mode aka using the browser. Nevertheless, the main reason for not trying the TWM more is that my second screen broke down and I am stuck with just 1 screen which is kinda small too. I might be wrong but I find that a TWM is more or less pointless without a large screen. So I am planning to buy a big monitor for Xmas and thus I am definitely going to go back and experiment with a TWM. Hopefully this time I can stay mostly on just keyboard mode which is what I love. :) Thanks again for sharing!
https://talks.golang.org/2016/refactor.article
I have a low IQ, but to me it kind of sounds like this enables you to re-write a small portion of a package that your program depends on, import it, and refer to a type exposed by it under an alias, so that you can still use the old package too without conflicts. Then, over time, you can move more and more code to the new package. It seems like it would make testing new code in production easier/safer (as opposed to re-writing the whole package and dropping it in all at once). I could be completely wrong though because I have a low IQ. 
&gt; But if Mozilla were to announce that installing any post-50.0 version of Firefox required a working installation of a pre-50.0 version they'd just get laughed at. Joke's on you. https://groups.google.com/d/msg/mozilla.dev.platform/Gzwh1IbxvHE/tWkIMQWACQAJ &gt; What software engineering advantages does it bring with On a more serious note, this question and probably much more can be answered by this talk: https://www.youtube.com/watch?v=cF1zJYkBW4A
So it's just a GVM thing then? Fair enough, my mistake.
Thanks for the video link. 
Thanks for the answer and advice. Am very new to Go, evidently: but impressed with it so far. I went with GVM on the basis that Googling questions about the best way of setting up Go seemed to indicate that 1. it was easy to do and worked well and 2. it offered a good way of managing different versions of the language on the same machine, should the need to do so arise. I've had a load of problems resulting from needing to run different Python versions on the same machine in the past and wanted to nip such concerns in the bud with Go, if possible.
The GVM README is correct in saying that you need another copy of Go in order to **compile** Go 1.5+. But the majority of people are probably better off just downloading pre-compiled binaries.
You don't need to use Arch Linux, that's just a preference. You can use whichever Linux distribution you feel most comfortable with. There are a few more extensions like vimium for chrome and firefox, vimium being one of the simplest ones but does what you need without much configuration and customization, except maybe for changing a few keys here and there depending on your preference. And is also fast. I'd say just in the browser, 95% of the time I don't need to use the mouse. There are cases though when you have to put your hand on the mouse for a brief period of time due to vimium's limitations or better said chrome's api limitations that prevent vimium from doing more. &gt; After doing some experimentation with tmux I realized that the simplest, alternative thing to do is opening a few tabs on my terminal which I can do with zero configuration on a freshly installed system. And as much as I love using the keyboard, for certain tasks you just cannot beat the mouse. I slightly disagree with you, although it's not a matter of right or wrong. I use tmux as well and I'm pretty happy with it, but it offers a bit more than a simple terminal window. But putting this aside, consider the following. Using i3 and urxvt as the terminal of choice. Urxvt is also very configurable and offers more than the standard terminal that comes with your DE. On TWMs a urxvt window is generally opened simply by pressing alt+enter. You open one and then another one and they are next to each other. Then you need another one and before you open another one you decide if you want it left or right to either one of the two on the screen, or underneath either one of the two. Then you open another one and you decide the same thing and so on, but at some point your screen can become pretty crowded with windows left and right and their size is also shrinking, unless you set them to floating mode which you can. Ignoring the fact that we have workspaces and we can switch between them and open more windows positioned in any layout on each workspace, you now decide that some windows will become master windows and will host some other windows in a tabbed layout that you can switch between using only your keyboard. Some windows may be tabbed others stacked, you can move them around from one master to another put them in any order etc. So now you only have let's say two urxvt terminal windows with each one having other urxvt terminal windows tabbed or stacked. Any of its child windows can have other windows tabbed or stacked, or just split windows for that matter. The combination is limitless. Now coming back to tmux, tmux allows you to have many shells open as you most probably know and also split the terminal windows inside tmux, vertically and horizontally. Tmux also allows you to manage clipboard just with the keyboard (if you're not doing that already with urxvt), also save sessions and layouts and many other things. It doesn't depend on your graphical environment, so you can work with it through ssh or with X11 completely shutdown and you can attach or reattach to the session from whatever terminal graphically or non-graphically. Offers sharing sessions between multiple users etc, and these are just some superficial stuff at the top of my head right now. For a linux sysadmin / devops / ninja it's indispensable just as "screen" was years ago for sysadmins before tmux was written. &gt; Nevertheless, the main reason for not trying the TWM more is that my second screen broke down and I am stuck with just 1 screen which is kinda small too. I might be wrong but I find that a TWM is more or less pointless without a large screen. That's where the stacked and tabbed features come in. They let you organize your windows nicely and save up space while also being able to access them quickly, especially true when using rofi with "-show window" which lists all your windows and let's you search through them by typing and select them with vim-like bindings if you so like (rofi is good stuff and is also very popular on TWMs). I've used i3 in the past on a 15.4 inch laptop display without any problems. Believe me when I say, 98% of the time (as a whole) I only use the keyboard without needing the mouse. Even in some of the cases you mentioned.
I went with GVM because it seemed to offer an easy way of both updating the version on the computer and of running multiple versions of Go on the same machine, should that be necessary. Would you recommend just installing multiple binary versions instead?
Coming from a python background, if there is something that makes me mad about the golang community, is the absolute lack of interest for documentation. Guys, documentation matters. A lot. This project doesnt even have a readme. I know some people say "well, the code should be self documenting" or "the tests are the docs". That is bullshit. This project, in which Im sure the creator (not sure if op) has put tons of hours for his own shake, is not going to get adopted by as many people as it could if the creator had written at least a decent README with use cases and requirements (even if the requirements are none). You might say "well, im not a native english speaker, is not fair". First of all, neither am I. Second of all, you can either ask someone to add a README, or just use google translate and put a not so nice yet readable documentation README. It will still be far more helpful than me having to dig through your code just to figure out if this project is for me.
Actually I'd recommend to just stick to the latest version. You won't run into problems as a beginner. Corporate projects may have restrictions to a specific version but you sould be fine with any 1.x.y as Go 1 has a [compatibility promise](https://golang.org/doc/go1compat) 
Today this is legal: type ( Int int Float float32 ) I'm not sure how that would work with `=`. I guess the same way.
Go's facilities for documentation are second to none. Avoiding libraries without docs seems to be a common practice amongst Gophers. The sentiment of your post is valid, but the truth of it is amiss.
I use pycharm on bigger projects because the code completion and refactoring tools are really useful. . For small projects and general fiddling, I just use vim. 
I agree code completion and refactoring are very useful. I have those in vim as well. My gvim configuration offers me most of what an IDE offers.
Thanks, I will watch later today
I do agree that Python has some of the best docs due to maturity, but I believe for the age of the language, Go is actually decent. Tooling makes it easy to create docs, and the format tools helps with understandable code. Sometimes Go devs are bad at stopping once they've provided minimal comments for godoc, and that's bad, but many projects have fantastic readme docs on par with Python sphinx docs and the like. In this case, the lack of Readme.md content drew me to comment as well. The code is simple enough to understand, and I'm always happy to make pull requests to help people with README grammar if authors struggle with the English or something. :)
I dont think this has nothing to do with maturity. I think ( and this is a personal opinion), that python community is very welcoming to newcomers (maybe because python is an easy languaje to pick up as a first languaje). On the other side, golang is not as easy as python (its still pretty easy for me, but its not my first languaje), and the fact that projects like this (with no documentation) are accepted by the community only makes things worse. For example, when you say "The code is simple enough to understand" , how do you know this repo is not the first one I am reading after doing a golang tutorial? On the other side, if people like you are helping others with their documentation, maybe things will change for the better :)
If it sits in a container (stated goal), the only way the container gets updated is by updating the container -- regardless of whether the CA certs sit in a file, or inside the binary.
It wasn't an implementation bug, it was due to some unintended complexities introduced by the larger scope of aliases under the previous proposal.
Actually, that might get you into legal trouble if you distribute CAs into countries that enforce the inclusion of compromised CAs.
I think his point was how the syntax will be incorporated into grouped type statements (if at all).
&gt; With the Go 1.8 release Uhh 1.7.4 is still the actual release. /edit looks like a very well written article after I finished it.
But Unlicense is the public domain license no? How is that terrible?
I've never heard of Urxvt. I was just using the default Ubuntu terminal, creating 3-4 tabs and alternating between them with alt-1 to alt-4 like say #1 for vim, #2 for starting and closing my server / program, #3 for git and running other commands and #4 for misc stuff. That pretty much covers all my needs when it comes to writing code and commands plus I can handle those 3-4 tabs with just the keyboard. I've tried using Gvim once but as I couldn't find a way to run a terminal through it, I didn't see the advantage of using that vs vim in a terminal or vs a popular editor like atom, sublime or vscode. That said, I'd also love to be able to run graphical programs, especially a browser and possibly a video player with just the keyboard so that makes a TWM very, very appealing to me. &gt; Tmux also allows you to manage clipboard just with the keyboard I didn't know that. I hadn't had a good use case to use sessions (plain terminal history is usually sufficient for me) but clipboard with just the keyboard does sound very appealing. So I might give Tmux another try. Thank you very much for the detailed explanation. That's a big help. I've still got much to learn I guess. I am definitely gonna start with i3wm + vimium and work my way to revisiting tmux and possibly consider urxvt as a replacement for the default terminal.
Yes, I'm wonder if this will be legal: type ( bite = uint8 roon = int32 ) I think so, based on the doc.
urxvt (unicode rxvt) is a popular choice amongs TWM users, because it's lightweight and scriptable / customizable. It also features a daemon mode (urxvtd) to which clients (urxvtc) connect to and open faster. I just used it as an example but it doesn't have to be urxvt, what I wrote applies to any terminal window or window of any kind. i3wm has a feature called scratchpad, this feature allows you to hide any window (or more windows if you want to) and make them appear instantly seemingly out of nowhere when you press the key combo for scratchpad. This window can be any window or a terminal window. I find it very useful because I always have a urxvt window of a fixed size in the scratchpad and in this terminal window I have a tmux attached to a tmux session with many tmux windows in it and every time I need to do something system related, configurations etc I press the key combination and it instantly appears on top of everything else and then again disappears as needed. In the tmux session within this urxvt window, If I press ctrl+a and s it shows me a list of active session that I can switch to, to have access to the tmux windows that are within that session. Each session may have one or more terminal windows with tmux attached to it and each window can be of course split into multiple windows hor / ver. What you're doing with tabs, switching between them with alt+1 alt+2 etc can be done with tmux as well + other benefits. If I press ctrl+a and w I see a list of tmux windows within that session that I can navigate up and down with j, k as you would do in vim, before selection a window to switch to. If the number of windows &gt; 9 you can still select whichever you want fast because besides names they also contain numbers from 0 to 9 and then what's above is marked with letters, so when you want to switch to any tmux window you press only one key. Or if you already know the window because you have it in sight (meaning you see them tabbed underneath, sort of) you can press ctrl+a and &lt;number&gt; and ctrl+a and a to toggle between them. Note: ctrl+a is not the default for tmux. Tmux in a sense is like a TWM but for the terminal, you can have tabbed windows and split windows ver / hor. I wanted to give you an idea, though it's only a vague one. Tmux also supports plugins that extend its functionality. Check out [tmux-plugins](https://github.com/tmux-plugins) if you're curious. If you're a vimer there's definitely a big advantage over using either one of Atom, Sublime or VSCode. Those have plugins that implement a small portion of vim's functionality and not all are as well written not to mention they as code editors are not as snappy, whereas when you use gvim you enjoy the complete power of vim in a graphical way which has its benefits. Terminals have some limitations that impose on vim, those limitations don't exist with gvim and it also feels smoother. You can have an entire IDE like functionality at your fingertips and by that I mean just by using your keyboard as you would expect. It too is in a sense like a tiling window manager, in that you use tabs, and each tab has or can have more than one window split hor / ver, but there are also the buffers that you can open in any way, new tab, horizontally or vertically, quick access to any of these functionality and more. Of course this is vim 101 nothing special, but it's like a continuum. There are many vim plugins that extend it to make you happy and add functionality that you didn't think of or didn't know you needed until you tried it and saw the possibilities and productivity it brings. If you're happy using vim in the terminal you shouldn't switch. Otherwise you should try it with an open mind and see what it can do for you and why it would be more enjoyable to use. I would have to write really long messages to be able to send that message across.
You can't have cake and eat cake. What he is writing is common knowledge about garbage collectors, you can't have low latency without costs in either higher memory usage or cost in CPU time. He gives example of person that wrote on go google groups which i also saw some time ago. That person clearly states that last change cost was 20% more CPU usage. 
As a stop-gap, in a performant language, I'm happy to pay. Numbers, in a long-winded article such as the op, are desirable for common knowledge to become more common.
Further then; Putting aside the entire purpose of the post, please demonstrate what remains that is "demonstrably wrong".
Just click the links to research papers he is providing and you will read about generational garbage collectors with numbers.
It is. But they obviously experimented with the beta release which is available for some time: https://golang.org/dl/#unstable
This is good timing. I've been benchmarking Prometheus, and have discovered memory usage notably above what's expected due to GC. In the small setup I currently have monitoring ~4.8k machines it's producing ~100MB/s of garbage. Due to the GC running every minute or so, that's 5-6GB added on to the RSS. A generational or reference counting GC would be useful in this case, as most of our data hangs around for less than a second.
The last change mentioned in the article with the 20% cost is actually not intended, and is from a prior Go 1.8 alpha build. We'll see what it actually is once 1.8 is released I suppose. From the golang-dev thread on the 20% increase: &gt;Those STW times look great, but that's much more CPU than I would have expected. Could you file an issue, preferably with more details on where you're seeing the increase and before/after profiles if you can, and cc me (GitHub: aclements)? Thanks! 
I am not doubting his common knowledge. But it seems more of an opinion piece when one looks at benchmark numbers of Go vs Java: http://benchmarksgame.alioth.debian.org/u64q/go.html 8 out 10 programs are faster than Java and use less memory and 2 which are slower also use much less memory than Java. So some of his points about Go GC using 100% more memory may be strictly technically correct but Go still fare better than Java in terms of memory. Regarding compaction again he is making theoretical comment. Here is what Go committer Ian Taylor has to say: https://groups.google.com/d/msg/golang-nuts/Ahk-HunIqgs/1sOi8t5iCQAJ In short Go does not have memory fragmentation issue like Java. Here are C# vs Go numbers which he thinks probably be same: http://benchmarksgame.alioth.debian.org/u64q/compare.php?lang=go&amp;lang2=csharpcore Here again Go is using quite less memory than C# or faster in case similar memory usage. Of course one can claim all these benchmark useless but I would expect of them to show better benchmarks.
I have a little expertise to speak on this--not as an embedded systems engineer myself, but as a cohort of some embedded systems engineers that sometimes consult me. Until a year or so ago, I didn't know anyone who heard of these sorts of devices using garbage collected languages. However, regulations are about proving response times (latency), not strictly about implementation details. Today there are actually some controls systems using garbage collected languages--and I don't mean as an interface to communicate with a separate RTOS. I don't personally know of a Go example unfortunately, but then a lot of these things are held fairly secret.
"There were tests lately"? [Citation needed]
It's so exciting to see Go growing and maturing to the point that the days of needing nginx or Apache as a proxy are not necessary. 
How is it Go's problem if Java/C# are lacking in some features? If Java GC is really performing better than Go I would love to see that. But at least in this article author made conjectures of memory usage/fragmentation which do not seem true from the links I mentioned. Go's shortcoming in isolation make less impactful narrative as author does not give equivalent Java options. Here is what author claims about superior G1 GC which is supposed to be state of the art and one size fit all: &gt; ... G1 scales very well. There are reports of people using it with terabyte sized heaps. And here is a user struggling with G1 with 10GB of heap: https://groups.google.com/forum/#!topic/mechanical-sympathy/HzcRI2eAqqU 
To be honest, some HFT firms are doing the simple trick of disabling GC for a trading day. Works quite well for them. Still if it's really fast HFT you are looking for - nothing beats C++. 
I agree. The main trick I heard for using Java is put like 100s of GB heap during day and simply restart application by end of trading
I've taken a slight detour to implement a tangle program: https://github.com/driusan/lmt ... now, back to implementing enough of the shell that I can rename it to "gosh" as promised in another comment..
I feel you. I came from rails and everything was convention over configuration. Totally different approaches. Both have their benefits. 
There's no such thing as a "public domain license".
A scripting language needs a REPL, which needs to be able to accept and execute statements on a line-by-line basis. 
Hopefully after articles like these, the defaults will become the safe options.
Yeah but the closest thing we have is Unlicense and WTFLicense.
I would argue that Perl fails this particular test. You can launch it in debug mode, bit that's a pretty poor UI for REPL.
The above is pretty strange definition, especially since Perl predates many other languages. Go is great, but it depends on a job at hand. As always, use the right tool for the job.
Is that your goal tho? Imagine you have some guy working on a technology and this is pulled in as dependency. Next thing he knows, he's getting arrested. Was the government right in doing this? Probably not. Is the dev of the dependency at fault for this? Debatable. Was this preventable? Yes.
https://cr.yp.to/publicdomain.html
I don't think it is necessary to set CipherSuites or CurvePreferences. P256 is already by default the preferred curve https://golang.org/src/crypto/tls/common.go#L542 And the default cipher suites https://golang.org/src/crypto/tls/cipher_suites.go#L75 looks fine as long as tls.Config.PreferServerCipherSuites is set.
This, plus the option to run go tools in a container or a VM, if the need for using an old version of Go ever arises.
Ah ok. thanks
Do tell. What went wrong?
&gt; Isn't refactoring already solved by tools like gorename etc.? I know I'm missing something obvious but... Yeah you do: https://talks.golang.org/2016/refactor.article
As others have answered your main question I want to leave something here for potential GVM users, because I think it is the easiest way to manage Go versions at the moment. You also can install a binary version with GVM. This should work with &gt; gvm install go1.7.4 --binary don't forget to set the version you are using with &gt; gvm use go1.7.4 --default Have fun with Go :) 
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/golang] [Gophers BLASTED for their shitty unconfigurable GC; complete denial by several people in the thread](https://np.reddit.com/r/golang/comments/5jcoo2/gophers_blasted_for_their_shitty_unconfigurable/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
I have heard many times how using an IDE can impede learning. I'm not contesting that- I'm just curious- but I just don't see how. Could you give an example of that? 
I think for beginners IDEs are a lot more beneficial than throwing people into a Notepad like editor and saying to them: ok, now learn.
It IS the good option for the majority of use cases. You want those settings when behind a reverse proxy. If you're thinking there will suddenly be more people using bare Go as opposed to Nginx / Apache / Caddy, then you're fooling yourself. Perhaps if this becomes common there could be a fast configuration for production facing sites, but I doubt it since this isn't actually more complicated than the configuration of an entire Nginx and / or Apache server now.
You have real-time garbage collected systems older than me? I do doubt that.
Very exotic solution to say the least. I have never encountered errors from this way of doing it so I guess it's fine.
He's a newbie, and used to languages that make everything more difficult. A lot of people make the same assumptions coming into the language. 
I think there is some truth to what you say. You do however still have a thermal budget to work with and making really big boxes exhausts this quickly. All of these solutions of throwing more hardware at the problem have a cost in physical infrastructure, it's also more expensive to scale out from a software design perspective. I agree there will not be many companies that have to move to Go or a faster language than Go to alleviate these costs but it can become a big effect in the future.
Please be polite. Assuming people don't know what they're talking about is not a good way to encourage communication.
We're not talking about memory usage for a given program. That would be a different benchmark, relevant in a comparison of languages, but irrelevant in a comparison of GCs. We're talking about GC overhead: average actual heap usage *as a fraction of the size of the working set*. If Go programs use less memory in general for the same task that's great for them, but it's not a measure of the GC.
Hence all the Rails applications still running around. Such performance!
Of course it's "gojira". Of course it is.
Yes, but Linux distros and most phones allow you to install your own CAs and update the existing CA list, which is why I'm arguing that a baked in CA list with no option to extend or upgrade is a very very bad idea.
&gt; It’s a very efficient compiled language written in assembly ... Go is written in assembly? I know there are places where assembly is used, but by and large Go is written in Go.
We are trying to make this subreddit better. If you think someone's post is inappropriate, please use the report button. We have a limited number of mods, and the report button helps us find controversial posts. I agree that mackstann's statement seems baseless, given that geodel effectively only made a single statement, which is clearly true - that the author did not provide benchmarks (whether or not this is important is another matter).
How is total usage of memory irrelevant? If Java process uses 10 times memory for same amount of work than Go, It is very relevant for hardware provisioning. As someone who would recommend hardware configuration for my applications it is for whole process not GC and application separately. 
Because this isn't a Go vs. Java discussion and there's no reason for it to be one. Does Java use more memory? Great. I'm not using Java and I don't care how much memory it uses. What I do care about is that my Go programs, which I *am* running and maintaining, have the potential to use 40% *less* memory than today, with a different GC that offers a different set of tradeoffs.
Can you provide a link? Please.
That's awesome. But does it apply / will it always apply to things like 3rd party frameworks? E.g. to work with the Django web Framework version 1.9+ you need to have either Python 2.7+ (if using Python 2.x) or 3.4+ (if using Python 3.x), and there are also a load of Python related software packages that still aren't updated to work with Python 3.x: which is obviously a hassle. So, with Python most of the version annoyances come not from working with core Python but from using it with third-party software. Do you happen to know how has Go gotten around that problem?
Except there is still the problem of setuid and privilege separation. Still need nginx for that or tweaking capabilities.
Neutral? Hardly. It contains a number of selected CAs that are deemed to be *trustworthy* for some reason. A CA root set cannot by definition be neutral, otherwise it would contain untrustworthy CAs. &gt;packaging CAs then none are available in the environment That still doesn't answer why we can't have an update mechanism &gt;the environments CAs are known to be out of date Update them. Y'know. &gt;the environment is known to have compromised CAs. At which point you cannot trust to have downloaded non-compromised CA sets to begin with. You need trust to bootstrap the root CA set. &gt;once you take onto yourself to package CAs it's up to you to keep them up to date, complete and meet any legal requirements - just like everyone else distributing CAs. That doesn't liberate you from having to update them.
There is no Go 2.x yet and might never be, so currently you are good to go (no pun intended). Before thinking anymore about version incompatibilities, read about Donald Knuth's "premature optimization is the root of all evil" or the YAGNI principle
Also here is Go GC expert and committer RLH's comment on that article: "It is not true that without compaction fragmentation is inevitable. Well known allocators such as Hoard, Intel’s Scalable Malloc, TCMalloc, Boehm/Weiser GC, and the Go allocator all use segregated size allocation to avoid fragmentation. Go avoids “pause distribution” using a variety of techniques including pacing over-eager goroutines by asking them to do GC work to pay for their allocations. Abnormal “pause distributions” for whatever reason would be considered a bug in Go. Injecting preemption checks into loops is a tradeoff that Go currently makes in favor of performance over latency. Recent releases of Go have brought latencies down to the point (&lt; 100 usec target) where this is now an issue. And yes, it is all about tradeoffs." https://medium.com/@rlh_21830/it-is-not-true-that-without-compaction-fragmentation-is-inevitable-e622227d111e#.q1ujwogvd
Found the solution: vars := map[string] interface {} { "Title":"Test", "Body":template.HTML("Hello &lt;b&gt;World&lt;/b&gt;"), } If we make the thing as not string but template.HTML, then we are good to go. http://play.golang.org/p/Uw8l3M7Qvg
It's a compiler builtin. Just like + works on ints, floats, and strings.
&gt; I'm not sure if it matters It matters because in the first case there is a data-race on `i` (written by loop, read by the go-routine holding the lock). There is no such thing as a benign data-race, the first code is just wrong.
gb++, love that tool. Allowing me to build a project in any path, with my source separate from top-level documentation. I sure hope both of those concepts make it to the new tool.
[removed]
&gt; If you think this is crazy, just check how append() is implemented. You know what they say: If it looks crazy but it works, it ain't crazy.
Uh, no, the switches have nothing to do with Go's type system. It wouldn't even be possible to do that, because there's an infinite number of possible types (in the case of append). Go's compiler, *at compile time*, looks at the type of the first argument and essentially does a special-case of generics, for only this function and a couple other builtin things.
[removed]
&gt; I think for beginners IDEs are a lot more beneficial than throwing people into a Notepad like editor and saying to them: ok, now learn. I couldn't disagree more. An IDE for a beginner is essentially like putting the average person in front of an airplane console that has a hundred switches and buttons and ask them to fly it.
&gt; It is however no different than for example virtual envs used in Python Not being worse than Phytons virtual env is a low goal ...
You could consider using a `struct` instead of a `map[string]interface{}`.
So I tried a few package managers for go, some seem a little lacking even among the popular ones, but with glide I found one I'm perfectly happy with. The biggest problem which I can think of is that most go projects don't tag their repository with semantic versions in a discoverable manner. For me trying to compensate for people not getting gopath by offering supporting solutions is false. I think it would be better to teach the concept by making a transparent and sensible default setup where gopath=$HOME. 
&gt; I think it would be better to teach the concept by making a transparent and sensible default setup where gopath=$HOME. I also like gopath=$HOME. I think 1.8 will bring as default gopath=$HOME/go so that's a very good step.
Cargo. Not even kidding, Cargo is incredible and exactly how it should be done.
Why can't we just use a common project/workspace structure and implicitly define the GOPATH as the path you're executing your toolchain from (assuming it meets the criteria)? E.g.: Assuming there is a top level `src` folder, go will assume you want the current folder to be the GOPATH (if none is set). Otherwise, if you explicitly define GOPATH, then that's your GOPATH. I've been using `direnv` to manage my project based GOPATHs (because I need to work on multiple Go projects at the same time) to basically achieve the same result.
Oh for sure. We're vendoring everything, even dependencies on libs we're building, just to minimize the problem. We also use `go install` instead of `go get` to build in CI, so that nothing gets downloaded that wasn't in the vendor directory. I'm excited to hear about the work being done on a builtin tool to manage deps, though. It means progress continues to be made. Amusingly enough, once I began to understand `go get`, I started using `go get -d` to clone things to the right place. I've even unabashedly started using it to clone non-go repositories into a well-structured work area.... for better or worse.
Not first attempt. Rust community tried developing package manager before designing the current one.
Also, for every problem I had with GOPATH, I ended up writing tools that resolve those problems for me. Instead of disliking something, I augmented it with tooling. I realize most people don't know and don't use tools like [`gostatus`](https://github.com/shurcooL/gostatus) or [Go Package Store](https://github.com/shurcooL/Go-Package-Store) daily like I do, so my perception of GOPATH workspaces is probably very different.
I was thinking more about this, and it would be feasible to not store any state in JS and write your app with only pure JSX functional components and a few helpers. I believe it actually might be pretty clean. I would be glad to prototype something with you if you are interested.
elements in maps are randomized
&gt; I realize most people don't know and don't use tools like gostatus or Go Package Store daily like I do, so my perception of GOPATH workspaces is probably very different. Wow! Those two tools look amazing! I am very surprised that we never hear about them in blogs and stuff. Functionality like this could even be useful as part of the standard Go tooling. Have you tried contributing?
I wish release announcements didn't assume everyone knows what the project is. This is a plugin to add Go support for the Atom editor.
How does cargo solve problems like dependency hell? Do Rust projects look like RoR or Node.js projects aka hundreds of dependencies hidden under the rug? I know almost nothing about Rust so I am genuinely curious.
builtins are essentially AST transforms, not functions.
&gt; "The iteration order over maps is not specified and is not guaranteed to be the same from one iteration to the next." This is a property of how hash maps work. The go implementation additionally adds more randomness to help discover potential bugs in code that mistakenly assume deterministic order.
Randomizing hash table iteration order is a best practice across all programming languages; it prevents code relying on things not guaranteed, and goes hand-in-hand with preventing denial of service attacks. http://events.ccc.de/congress/2011/Fahrplan/events/4680.en.html
For me that highlights the exact issues with the GOPATH environment - without augmentation it is difficult to manage efficiently. As an example simply consider just how many versioning systems alongside with tooling in general that has been released for Go, it is symptomatic of underlying issues.
There are features in newer releases (like context being moved to core in 1.7) that frameworks/libraries use that would prevent you from using them with an older Go version, but with the backward compatibility promise, you just run the latest version and everything is fine. Where you can end up running into problems is with 3rd party packages. Things are generally okay because there's not a ton of libraries depending on libraries everywhere like in the JS world, but you'll occasionally run into a package that does a breaking change.
I wasn't aware it was randomized per run. It surprised me.
Coming from a C/C++ mindset - GOPATH is better than awkward makefile syntax and letting the compiler know the paths to all the object files. The go tool eschews that crap by imposing a layout for projects and package imports which I'm frankly happy about.
It's actually really cool. Other languages just say "Don't rely on the order, it may change"... Go just goes ahead and always makes it change. Documentation through execution is a great last-resort!
[removed]
We? Since you're an admin (tagged you in RES) does that mean reddit using Go now?
Map iteration is undefined!
I believe people are interpreting you to mean that Go's "+" operator is a switch statement. That's false. [Operators](https://golang.org/ref/spec#Operators) and [switch statements](https://golang.org/ref/spec#Switch_statements) are disjoint concepts in the Go language. If you mean the Go compiler's source code uses switch statements in its implementation of append and "+", then sure, I guess. But switch statements are so pervasive in the Go compiler, you could argue everything is a switch statement, so it becomes a meaningless claim.
Both are around for about same time. Rust prioritized on some stuff Go on something else. 
I agree, gb is well done. I hope Dave doesn't drop it. I hate GOPATH and feel we should have per project dependency management instead of using go get.
Except that it is nowhere near as good as virtualenv since there is no official tooling to support it, no best practices to follow, and it forces you to have all your code in the same directory structure as all the crud you're importing. Finally, it doesn't help much with strange dependencies of dependencies, which has been 'solved' in python with .wheel files with nothing similar in Go. I agree that virtualenv is not the best solution out there, but at least it is supported and works properly. The fact that GOPATH doesn't even get close to the same utility as virtualenv says it all, really. 
Thanks! &gt; I am very surprised that we never hear about them in blogs and stuff. I did blog about it, e.g., see https://blog.gopheracademy.com/updating-your-go-packages-with-go-package-store/, but the problem is unless you repeat it, most people won't know. I'm not good at marketing. About `gostatus`, I think it's a very useful tool, but it doesn't belong as part of `go` tool. It's primarily helpful when you don't rely on vendoring. Otherwise `git status` tells you everything you need to know (and your vendoring tool).
What are you taking about? Do you not remember everyone's JavaScript builds breaking because a quadratic character prepending package went away? A centralized repository doesn't prevent things going away or changing. You can't remove your responsibility for dependencies, only spread it around.
E.g. See https://software.intel.com/en-us/blogs/2013/01/06/benign-data-races-what-could-possibly-go-wrong
FWIW, Python had had, intentionally, random ordering until 3.6. There's a lot of good discussion in /r/python on the topic.
Accurately identifying a truly benign race is difficult and requires a detailed understanding of the memory model for the system. Such races are possible in go, but proving them is not worth the cost of the synchronization.
You meant to post to PCJ ?
I had this exact same error when I was connecting to a ssl port without ssl. 
No one disputes that there are tradeoffs, we just don't know what those tradeoffs look like without some quantification. For all I know, we're trading 1% of performance for a 100X improvement in pause times. The strength of the author's argument seems to depend on some characterization of this tradeoff.
I have found the fix: http://stackoverflow.com/questions/41250665/go-https-client-issue-remote-error-tls-handshake-failure 
To be honest, even if your language has a package manager you should still be vendoring everything. I'm not sure pushing dependency management into language specific tooling was ever a good idea. I'm even more sure that, these days, where most new projects are duo language out of the box (i.e. javascript, and &lt;some-lang&gt;), that it is a poor fit.
So, something like Presto?
I would definitely be interested in seeing that. That said, I think there's still a place for non-SQL distributed MapReduce, so I really hope that development on Glow continues as well.
I should have been more clear. poetic_waffle makes a good point, but I think there's a wide range of approaches to teaching using an editor/IDE. If a student is expected to learn the intricacies of every function of an IDE, that's one end of that range, and I think it's safe to say that that's not conducive to learning. On the other end is dropping a student in with notepad, as you said, but that's also not conducive to learning. A better phrasing is that I wonder whether we're striking the right balance in education within that range. I had a pretty rough experience as a math student with no prior programming experience being tossed into C++ with an IDE and having to configure it, for example, to build a project- when I had no idea how the build system worked. I didn't figure it out til a couple years later when I revisited it on my own time. I've had friends who were instructed to use a text editor and the default Python REPL while learning, and they were frustrated with the experience. It seems to me that Go, at least, is pretty beginner-friendly all around. I most often see it recommended to use something like Sublime, VS Code, Atom, etc along with a gocode plugin for autocompletion and such. I think that's a pretty good place to start, but it's obviously dependent on the individual, their background, and varies quite a bit from language to language.
Just like how [while is spelled 'for'](https://tour.golang.org/flowcontrol/3) in Go, package management is spelled 'git'.
So it is written, so it is done: dsh is now renamed to gosh. (Not much opportunity for plugins yet, though.)
This was my final project for my comparative programming class. If you note any errors, misconceptions I may have had, or just have any general feedback, I would appreciate your thoughts! Also am open to take pull requests if you have any suggestions: https://github.com/jakerockland/go-vs-swift
It would be good to see any examples at README.
[removed]
npm is no longer allowing unpublishing, they've learned their lesson. A repository SHOULD prevent things from disappearing, otherwise we could jusrlt use git.
&gt; is GOPATH a good idea..? No. It relies on two basic assumptions: - You will only ever need one version of a dependency for all your projects. - You will only don't care what version that is in any of your projects. Both of these assumptions have proved categorically false, and that's why we have vendored dependencies. &gt; I like to think of my GOPATH as a huge monolithic project ...Which is fine, if you only ever work on one project. Unfortunately, when you work on multiple projects, that workspace idea breaks down quickly; you end up using the dreaded `export GOPATH=`pwd`` and then there's just no point to it at all. The real question is: Does GOPATH exist for a meaningful technical reason at this point, given vendored dependencies? What is it about GOPATH you actually like? For me, it's like the global pip with python; it can sometimes be vaguely convenient to have a `pip install -g pandas`; you can just open a python file and import the package and off you go. No requirements.txt, no virtualenv, just quickly up and running. ...but for any *serious* work, that's a absolutely stupid idea, because 10-to-1 you'll git clone your code on another machine and it won't work, and good damn luck trying to figure out what package versions you need to get going again. :( The GOPATH is magic that doesn't work. If go has magic, I want it to be magic that works. (You could argue that GOPATH would still be meaningful if the vendor'd deps went into the GOPATH semantically tagged instead of a vendor folder, and it was like a cache of all the versions of all the deps you might want, which would actually be pretty useful; eg. no downloading the world every time you need your dependencies ala glide... but... that didn't happen. :P)
i remember when npm [told everyone to favor local packages over global packages](https://nodejs.org/en/blog/npm/npm-1-0-global-vs-local-installation/), it was a game-changer (at least for me). * there is not 1 version of a package which every other package depends on, that is just not the case for the majority of all packages * once every dependency is tightly coupled to the thing you want to build, building that thing will be much easier (reproducability++) npm is not perfect, but local packages are a _huge_ win (nowadays the flattened node_modules directory makes things a lot better too). another _great_ example for a good implementation of a package-manager/system that promotes and encourages local packages is cargo (rust). it is such a pleasant developer-experience to work with cargo, please try it out if you haven't yet!
If the first iteration of such a great package is in pure Go and the second isn't then I think Go might have a real problem. Sad to read this.
Yeah, he actually does a Go a very poor showing in that regard. Slices and channels iterate in Go very cleanly; it's one of the selling points. Channels: for element := range ch { fmt.println(element) } Slices: for _, element := range slice { fmt.println(element) } Go is also different from Swift in purpose; I mean, Go really is trying to be a general purpose networking service language. Swift is trying to be a better Objective-C and native language for OSX-es and Linux desktop apps. 
Thanks! One point I see is now missing in my explanation: when the first working C compiler--written in some assembly language--was ready to rock, to make it self-bootstrapping, the devs had to re-write it in C. With Go, the same thing happened: up until, and including Go 1.4, the Go runtime and the build tooling were written in C. By 1.5, they were re-written in Go--almost mechanically, as the devs themselves freely admitted, and hence Go became self-bootstrapping by being able to compile itself from scratch, and that obviously required a working Go compiler available to do that work. In Go versions past 1.5 the runtime and tooling were incrementally optimized, including gradual implementation of the new Go AST parser which uses SSA (see Wikipedia) to generate optimized input for whatever layer which generates the assembly for the target platform. Hence the idea to re-write Go in Go was not just to show-off (Go devs are mostly grey-bearded wizards, they don't need to show-off since long ago :P) but to allow for easier programming and hence bootsing productivity when improving the Go runtime and tooling.
What you describe is the lack of package version management and dependency control. It's not GOPATH.
wat
Which Antivirus?
Your assertion that Go requires the import of "fmt" for a hello world is incorrect. package main func main() { println("hello, world") } 
"Throughout Apple's history, many of its frameworks have been built around the Object Oriented Programming paradigm. " I don't think you'll find anything OO from Apple between 1976 and 1983.
I agree with you, but conditionally- vim is great, so long as you're already familiar with it. I don't think it's a good idea to have someone learning basic editing functionality alongside a language and the way of thinking about code. Some people pick it up quickly, and that may be fine for them, but I'd be hesitant to recommend it to someone without a good indication that it would come naturally to them. That said, this conversation has helped me put into words something I feel is pretty basic but I wasn't able to articulate. I think that in many cases, whether a program is a text editor or an IDE heavily depends on its configuration, and that it's less a binary classification than the way people talk about it. Vim is a good example. Out of the box, sure, it's pretty plainly a text editor. But start adding plugins, and it can easily rival many programs typically dubbed IDEs. It's up to the individual to tune it to their liking. And now I'm thinking that the idea of describing particular programs as a text editor or IDE is not the best way to go about things. Whether a particular feature is provided or not is less important than whether the programmer utilizes it. If I use PyCharm but never touch anything other than code completion, the functionality I'm using is pretty close to that offered by, say, iPython. An IDE certainly can be a crutch, but it's not inherently so. It provides more flexibility but it's up to the user whether that's something they want to take advantage of. All in all this is a pretty minor issue I feel, but it's been interesting fleshing this out. Thanks!
For SailfishOS (Jolla phone) we have some applications build with go QML bindings: Resize (shrink pictures), miniLock (encrypt attachments with miniLock / NaCL crypto), Ivy (Rob Pikes APL-like calculator), Dewpoint calculator (calculates dewpoints based on temperature and humidity). 
I know almost nothing about swift, so these are the points I would like to see: * Garbage collection/Memory management * Error handling * Cross compiling support * Package management
whats trace.exe? Edit: If you got it from official site then result is a false-positive. /u/PaluMacil thanks for explaining.
Scalability is a vocal group at various Google offices. They sing "regular" songs and have a few Google / tech-specific parodies. This is one. For others, see their YouTube channel: https://www.youtube.com/user/ScaleAbility
A bit of searching finds: https://www.reddit.com/r/sysadmin/comments/3h0o7u/were_reddits_ops_team_aua/cu3f88n/
That's what GOPATH is. It's a poor mans dependency management solution that doesn't work very well. I'm not even talking philosophically, *technically*, that's what it is; it's a path resolution solution for 3rd party packages.
Yeah gccgo is part of GCC, gc is standalone. First time I saw somebody make that mistake, gccgo does not seem that popular.
I think the end of section 6 does Go a disservice in the "yes and no" summary. Everyone can be assumed to know what OOP means, but are less likely to understand that Go solves things in a different fashion. Packages, interfaces and composition are surprisingly powerful concepts, and provide ways to make interchangeable parts that can be built into structures then chained together - instead of "is a/implements a" it's more "can be used to do ..." &amp;nbsp; I'm still getting my head around it to be honest.
He mentions it in the article: There is a builtin `println` function, but that prints to `stderr` instead `stdout`. Also there is no guarantee for that function stay in the language, so you probably shouldn't use them: https://golang.org/ref/spec#Bootstrapping
Go map iteration is not-deterministic as a measure to prevent DDOS attacks via crafted input sequences, causing excessive number of collisions.
It's in the tools of a Go install: https://blog.golang.org/http-tracing **Introduction** In Go 1.7 we introduced HTTP tracing, a facility to gather fine-grained information throughout the lifecycle of an HTTP client request. Support for HTTP tracing is provided by the net/http/httptrace package. The collected information can be used for debugging latency issues, service monitoring, writing adaptive systems, and more. **HTTP events** The httptrace package provides a number of hooks to gather information during an HTTP round trip about a variety of events. These events include: * Connection creation * Connection reuse * DNS lookups * Writing the request to the wire * Reading the response **Tracing events** You can enable HTTP tracing by putting an *httptrace.ClientTrace containing hook functions into a request's context.Context. Various http.RoundTripper implementations report the internal events by looking for context's *httptrace.ClientTrace and calling the relevant hook functions. The tracing is scoped to the request's context and users should put a *httptrace.ClientTrace to the request context before they start a request.
There is also a method by which AV can identify development tools. I'm not certain if it's via lists of valid SHAs or something else, but certainly it would be nice to see that corrected. That said, it doesn't affect any of my AV software.
&gt; AVG, AegisLab, AhnLab-V3, Jiangmin, Kaspersky, McAfee, McAfee-GW-Edition, Microsoft, and Rising Uninstall all and use Defender.
That's the only one I have installed. The OP linked to Virus Total which shows a list of results from many sources. This list is a minority of AV software.
&gt; That's the only one I have installed. I thought I was the only one so I mostly said it as a joke but good to know.
And the original MacOS (1983-2001) wasn't OOP either. It was a plain Pascal API.
Is there a reason why the goenv aproach isn't being considered?
That you can do a thing in a different way doesn't make the thing less useful. 
If you want a good example of a project that utilizes code-gen well (due to the lack of generics) take a look at SQLBoiler.
&gt; identifying a truly benign race This phrase is nonsense, that's the point. There is no such thing. Either there is a data race (completely undefined behaviour) or you've followed the spec and synchronized all memory access. The code only means what the language spec says it means and showing/identifying that a specific compiler on specific hardware happens to have produced code that does the right/wrong thing in a case where the language doesn't specify the behaviour is irrelevant.
Remember though that you can do most of the workarounds listed... with generics. Which equally doesn't make THEM less useful.
GB is a fine solution, it just requires a little foreknowledge, since it makes the code not go-gettable, which is regrettable (look, I rhyme, some of the time).
The example I consider is a concurrent read and write of a bool that starts as false, is changed to true once, and remains so forever. The the trick is to make sure the instruction that changes its value cannot be reordered with other instructions. You can do this with function boundaries. If you don't consider this a race, then I guess that's fine.
I just released today the first version of [piladb](https://www.piladb.org), and its daemon, `pilad`, is a JSON REST API fully implemented with `net/url` (plus `gorilla/mux for routing`): https://github.com/fern4lvarez/piladb/tree/master/pilad
Yeah, to be honest that feels like a lazy qualifier. The problem I have is while he does say that, he doesn't really go into the strengths of Go. Instead of saying that, he could have shown that, which is why I brought it up. I feel he spends a great deal of time doing a lot of rote stuff like examine native types ( not strict typing ), class-like structures and what for loops look like. In the last two, he does misrepresent Go. He barely goes into concurrency with "go", and doesn't even touch channels, probably one of Go's biggest strengths ( the power of a generic enumerator and a control flow object combined! ) Granted this is a final for a college course, and our expectations should thus be calibrated, but I was disappointed that didn't pop out to someone studying CS. Maybe he had a professor that was obsessed with native types.
To this day, having written some major programs in Go that are now in production, I have never **needed** generics. In fact, the cost of a different approach has never been enough to warrant new syntax and a higher barrier to entry. I think the main problem is that people don't fully grok interfaces. Yes, there is boilerplate, but an aversion to boilerplate has no place in Go. Boilerplate is some of the easiest, safest code to write, and removes all doubt about how something is happening. You always have the exact code that is being executed where no code is created at compile-time. Even with go:generate, the code is available for browsing before compiling. Duck-typed interfaces are an incredibly powerful tool, and adding a few methods onto your types (or creating wrapper types) is so much simpler than generics. Generics also have a large cost that people overlook. Adding syntax is not free, it increases the barrier to entry. As is, Go's power comes from it's ability to scale, where absolutely new coders can contribute useful, contained, tested, and straight-forward code. I have given junior non-Go developers a test suite and they have written implementations to satisfy it, and because of the limitations of Go, that code has actually been clear and easy to audit. Personally I hope Go never gets generics. What Go needs is a bit more syntactic sugar to reduce boilerplate... For example, if the primitives in Go had methods that could be relied upon, your own types could be integrated into external libraries without any boilerplate. There's so much room for improvement of Go's current abstraction tools that adding a new one, such as generics, is jumping the gun... I say let's see where our current tools get us, and when there's no blood left in that stone, re-evaluate the need for a new abstraction tool and see if generics are still the answer. One last note- the stdlib needs a re-factor, massively so. Many stdlib packages don't take full advantage of the abstractions and flexibility that Go can provide, and it trickles down into third-party libs, too. Take the "sql" package, there's so much more abstraction it could provide that it simply doesn't right now. If it provided a Scan interface that you could satisfy on your types, then the boilerplate for pulling complex, nested types from a database could be drastically reduced. On top of that, if it provided reflect-based wrappers (a concept that is woefully not seen in the mainstream) that could implement those types, meaning the boilerplate required for good database bindings completely fades away. I truly believe these improvements will come in due time, and in a bit more time when I have a few more things running in production, I'll start pushing more towards a deeper understanding of Go's features and how they can all play together nicely.
https://github.com/benbjohnson/wtf is what you're looking for. It has a long blog series too.
Ah, OK, fair :)
[`net/http.ServeMux`](https://golang.org/pkg/net/http/#ServeMux) is very very limited. In most of the cases it is necessary to try 3rd party routers.
`os` is still an import, so why would you use it instead of importing `fmt`?
the project has been updated and almost everything is optional on creation now. its a lot more customizable.
Agree. Hard choice to make given no generics, dynamic remote code execution. On the other end, Gleam can work easily with 3rd party programs, almost no memory issues compared to Java, much simpler code.
if you are just starting, I'd strongly prefer choosing pressly/chi nowadays. https://github.com/pressly/chi Light, idiomatic and strongly stdlib-compatible. It uses 1.7 context.
I believe reflect-based wrappers are a very expensive operation- I remember reading that a single reflect lookup costs as much as a mem cache miss.
Well explained. Thank you. 
I agree, although it completely depends on the circumstances. I would love to see generics in go one day but in some circumstances they aren't needed at all. Code generation makes me a but uncomfortable.
I wrote a small [web server](https://algernon.roboticoverlords.org) in Go with support for Lua, templates, several database backends and auto-reloading webpages in the browser upon save (using the `-a` flag). If anything is unclear, I would be happy to update the documentation.
Related, https://github.com/golang/go/issues/17373
How is code-gen by an external tool better than code-gen by the compiler? One of the main reasons/trade-offs given for the lack of generics (the template form of them) is that it would increase the compile time. Spending that time outside of the compiler in a code-gen tool just to have a fictitious low compile time seems not a solution to me. While I agree that SOME copy and paste is better than extra abstractions, GO at the moment is at a level where it requires A LOT of copy and paste. 
(4) instead of locks and syncs you could use atomic for access, but you need to be pretty careful to not make mistakes! 
Have you tried IntelliJ with golang plugin?
For learning authentication &amp; redirecting to login: https://play.golang.org/p/mov3sLp9Ic 
This one. Helped me a lot! 
As predictions go, "Go will never get generics" seems more likely to come true than most.
&gt; However, due to its lack of inheritance, attempting to emulate the above Swift example in Go is not straightforward It's just as straightforward in Go as in Swift. https://play.golang.org/p/tcJNhLy7dy
Didn't consider the tradeoff between `os` and `fmt`, good point! Though I think I will leave the `fmt` example as it is more readable and this paper was meant to just be a simple introduction to the two languages. 😅
It's possible, though I think Go is much more suited to play that role. There are a lot of people working on server-side Swift, though I don't think its at a level that is production stable yet. I'm honestly not knowledgeable enough on the details though to have a strong opinion on that.
Thank you! I'm definitely excited in seeing how concurrency is integrated as a language feature in the next couple years. Wasn't aware that GCD was fully compatible with Linux now, I will have to update this paper soon. 😅 It got a bit more attention than I expected here on Reddit so there are a lot of little things to tweak that people have pointed out.
Didn't mean to do a disservice to Go. Will update to show the more elegant for-loops with Go! I'm much more familiar with Swift as a language that I use on a regular basis, so most of my references for Go snippets here were based on simple examples from things like "A Tour Of Go". Definitely are a lot of improvements I can make though and are a lot of interesting areas of the two languages that I did not get to cover (memory management, error handling, etc.), but this was just one of the things I had to get done this semester while trying to juggle working full time haha. 😅
So, it's not that the asm function is slower per se, it's that pure Go can be inline and avoid being the function call. Somewhat misleading article. Obviously, moving more of the code to the asm function ends up being faster than Go; it's not that asm itself would be slow. I guess it's also worth stating explicitly, it's just a missing optimization, not a fundamental overhead like with CGo.
Nice! I was looking for a simpler grammar since the supported features would be limited at the beginning. But it is good to know this! btw: With Lua, the UDF would be much much easier to develop and deploy. No jar files to upload and no server restart.
No, the official go compiler is not included in gcc (gccgo). go compiler = compiler (frontend, backend) written in go. gccgo = gcc compiler frontend for go written in c++. They are separate projects, with gccgo trailing the official go compiler, as to why gccgo exists, as I recall it's mainly due to the wide range of hardware platforms which gcc supports. Performance-wise they differ, gcc has a very strong optimizing backend, but gccgo also lacks important features like escape analysis which I assume is what has led to the official go compiler performing better in the majority of the benchmarks I've done.
&gt; Or maybe I should just fuck off and use something else, yeah, maybe I should do that... Please, please do. We can all do without your toxic attitude.
[removed]
How do I integrate this into SSL?
Neovim &gt; VIM &gt; VSCode &gt; Atom &gt; Sublime Worth noting, though, that VIM and Neovim still don't have Delve support plugins, to my knowledge :(
Looks good to me, I would suggest using 'GNU compiler collection' or 'GNU toolchain' rather than 'GNU toolkit' .
this looks nice! A while back I was fiddling with intrinsic functions (that guy whose name I can't remember but is similar to "Klaus") has a very similar, yet more in depth, library. It was a shame assembly couldn't be inlined. (or, in the case of this issue, intrinsicified.)
yessir. thanks, I don't know why I forgot his name for a moment!
Looks like I haven't fully done this justice, will look into updating things soon to more accurately reflect OOP in Go--thank you for this!
How does generics imply custom operators? Java is a rather obvious example of generics and has **zero** support for operator overloading. It also supported interfaces as its sole method of generics in Java 1-4 but even they added generics, because its just necessary to preserve type information for many use cases (e.g. data structures).
To clarify a bit - generics do not imply operator overloading. The easiest example would be map keys and values, and custom map implementations. You could use interfaces here, but problem of getting concrete type is still there. From performance standpoint - interfaces are pointers inside so you are getting runtime polymorphism with all benefits and disadvantages. The biggest disadvantage for me is that you get a lot more of cache misses. That could be fine in case of polymorphic collection, but in case of monomorphic one you are essentially paying for nothing. But - the subject of type systems is hard. Implementing meta type system is hard. Learning one is hard. This topic has been discussed several times before, and Go team had responded that they do want generics, but don't know how to implement them properly without loosing much of what makes Go - Go. 
&gt; To this day, having written some major programs in Go that are now in production, I have never needed generics Thank you for illustrating the blub paradox so beautifully.
&gt; which is why by default reflection should be hidden within a wrapper. How does this help a runtime reflection call?
&gt; blub paradox Not quite. I've needed, and used, generics in other languages and appreciate their strengths.
I hadn't yet heard of a port planned for AIX or z/OS, both platforms I looked in to since I have to deal with them at work. I am aware of the s390x port but that is only for the Linux port to my knowledge. I don't see much development happening for AIX in general.
Oh man, hah, please don't take my criticism too personally. I understand being super busy. Please keep in mind that that was part of what I meant when I said "our expectations should be calibrated". A lot of people I know in school have to work full time these days. That said, totally check out channels more in depth if you can, they were really powerful for me once I discovered everything you could do with just one very flexible native type.
The issue here is that Go is intentionally not OOP heavy. It's OOP-like. While we can clearly define the sharing of behavior through composition, which replaces implementation inheritance through sub-classing, the freedom granted by having interfaces implicitly implemented allows us to also create types that are not bound to class hierarchies and related issues. Interfaces/interface implementation should be most of our focus when reasoning about designs. Please consider https://play.golang.org/p/hdEO_DWygr (I hope I stated/coded this all correctly.)
Hard to say without seeing the client code. Are you fully reading the response body? Are you sure you are always closing the connection? Are you re-using the http client? 
I wrote one of these once. Tried benchmarking once, because I intended to use it as a sort of brute forcer. The best solution by far was using the naive code to generate massive lookup tables. After the initial bootstrap time, it could run ridiculous numbers of encryptions per minute. I couldn't find a good way to store and load the ~2GB lookup tables though. Edit: I guess I overestimated: Just for 5 rotors in all possible orders and positions (not accounting for the ring setting) it is 5x5x5x26x26x26x26 bytes of lookup, or ~57 Megabytes.
I have updated my post with a simplified code example. The error checking location is exactly where I put it on my actual code.
If you posted your code I could give a very concise answer, but as it stands I think I'm missing something, or you are. If you are able to know that legitimate work is being done and if an error occurred in the work.. then that is the place to initiate a retry. I think you may be trying to centralize book keeping in the dispatcher, which I completely understand. As a good programmer you feel in the dispatcher that natural pattern to try the work, and only release ownership if it succeeded. But Go provides you a bit nicer of mechanisms to let **"go"** of that work and trust you will be notified later when it is complete. So, that said, forget about context, in your dispatcher pass the task to the worker and a second channel for failures. Have your dispatcher in it's current dispatch goroutine have another select to pull and handle failures. Now your workers can run as long as they need to, and if they don't need retried you can trust you won't receive them. Or again, maybe I am way off, hard to know exactly without being in the weeds with ya. Have fun!
&gt; Suggesting code generation with templates as a solution for the lack of generics? Not as a solution, but merely as one of several possible alternatives that might fit a particular problem.
&gt; or use code generation and give up sanity. How does `go gen` affect mental health? So far I would have considered code generation as causing a bit more work (and planning) but not more than that.
&gt; it was trivial to extract them. Can you show how to extract them?
It's all good as long as it's working well, but when there's a bug in generated code it has a tendency to be *much* more difficult to pin down. I'm generally okay with out-and-out code *generation*, for example serializer/deserializer generators and that sort of thing, where they generate uniform code and are unlikely to have bugs once they're mature. I've used a bit of that in Go, and some of my favorite tools in other languages do tons of that kind of codegen, and I don't regret it. But the kind of code generator that takes your code and modifies it, or takes some kind of input that's so complicated that you might as well call it code, and translates it, those ones operate at a level of subtlety that's often more trouble than it's worth. Basically, I would lose a lot of faith my ability to understand what my code was doing if I used a `go gen`-based genericizer.
Most people keep describing gopath as a pain in the ass while in their heads they assume that without it, they would magically be able to build their applications as they wish and however they wish. At the same time they forget all the good stuff that gopath brings aka being able to build with zero configuration. Yes that's right, zero.
&gt; Something like this, maybe? (wip) Awesome idea. The syntax and semantics of `merge` (and I guess also of the other builtins that are still in "planned" state) appears to match Go's own "generic" functions -- that is, builtins like `append`, `len`, `cap`, `copy`, `delete` etc. The [Go Generics Discussions Document](https://docs.google.com/document/d/1vrAy9gMpMoS3uaVphB32uVXX4pi-HnNjkMEgyAHX4N4/edit#) lists compile time function evaluation as a possible technique, and so far there are no cons listed. I wonder if the Go team would be open to the idea of adding further builtins to the language besides the established ones.
Absolutely valid point - my fault of not thinking of it. If a code generators produces code that is hard to debug then it might indeed cause more harm than good. I'd argue that code generators should generate code that either allows to clearly map an error in the generated code to the corresponding place in the original code that was fed into the generator, or contains additional functionality to facilitate debugging (like e.g. a system that would allow to generate error message with references to the original code). But this might be easier said than done.
&gt; On the other end, Gleam can work easily with 3rd party programs, almost no memory issues compared to Java, much simpler code. Yeah and all the good stuff about Go thrown out of the window.
Small proof of what I am talking about: https://www.reddit.com/r/golang/comments/5iv2er/create_your_own_image_mosaics_with_go/dbgs8vy/?context=10000 https://www.reddit.com/r/golang/comments/5iv2er/create_your_own_image_mosaics_with_go/dbgse3r/?context=10000
&gt; I do not understand "all the good stuff about Go thrown out of the window". I haven't looked at the code but from what I understand you are using cgo no?
I think I stumbled upon gabs, it definitely looked like it would do the job. I ended up figuring it all out by trial and error, however, so I didn't use it. I'm definitely going to look into using an actual database in the future, but this was just a little fun project mainly intended to get me more familiar with Go, and working from a JSON file in whatever my directory is seemed simple enough to get going.
I don't know why it would be os.Args tripping up on certain words. It just contains the args passed when the process was executed. It is probably your shell command. What kind of command are you running? They may never have made it to the actual Go process. 
do you quote do when you run your program, so it looks like `./myApp do` or `./myApp 'do'`? And which shell are you using - bash?
Not sure if it is the first attempt, but maven is pretty good. Yes, XML is not ideal, but when it comes to project layout, dependency management and reproducible builds I found it to be a great tool. It caches the builds in `~/.m2/repository/&lt;dependency&gt;/&lt;version&gt;` which is nice too - it means 2 projects using the same version of the same dependency don't have to download and store the same thing twice.
&gt; Should I always protect these mutations with explicit locks Yes. &gt; Does Go at least protect against corruption, in the case of bit-level write races? No. This is where at least some go-implementations (gc in particular) [lose their memory-safety guarantees](https://research.swtch.com/gorace). Always use locks.
Maven is not first party. I feel implication here was Go team didn't do enough in this area. Whereas they felt community at large will come up with solution, which they did.
You can use `\n` to insert a line break: `line1\nline2` Do you need to shell out to bash? What about opening in append mode: filename := "/etc/hosts" fileInfo, err := os.Stat(filename) ... handle err handler, err := os.OpenFile(filename, os.O_APPEND|os.O_WRONLY, fileInfo.Mode()) ... handle err defer handler.Close() f.WriteString(text) 
"unspecified ordering" is not the same as non-deterministic. "Deterministic" means producing the same output from the same input. Or, as I like to say, producing the same bug from the same input. For example, the C++ `unordered_map`s are deterministic[1], yet order of iteration is not specified, it's just the same across runs, which is a huge advantage with regard to reproducibility of of bugs. [1] unless you instantiate with a randomized hash function
&gt; Even with resources with a few values in the path, it was trivial to extract them. Any example? Speaking as a noob.
This has absolutely nothing to do with os.Args as os.Args just transports the arguments from program invocation to your code and does not do anything beside that, especially not look at the arguments provided. Stop looking where nothing is hiding and focus on what you do wrong invoking your program, especially when invoking through a shell which might do tons of stuff to what you type (and see in the terminal) before handing it down to your code.
Google hired an intern to work on inlining improvements for Go, so hopefully we see this appear in Go1.9
The hello world program is from his B tutorial (section "7. External Variables"): https://www.bell-labs.com/usr/dmr/www/btut.html
Could you develop the following statement: "integrations in cross-platform developer toolkits" "Swift will also be deﬁned by its versatility as a powerful modern compiled language, with many potential applications outside of the Apple ecosystem from server side applications to integrations in cross-platform developer toolkits " 
An article from almost two years ago that starts out by admitting the author hadn't looked at Go in a while is a pretty old article in tech. Of note, half the article is a quote from someone else about lack of scientific tooling, though gonum was getting off the ground around then. The other half is about generics. Regardless of what you think about them, it's a very well tread topic.
`▸ git log --reverse` commit 7d7c6a97f815e9279d08cfaea7d5efb5e90695a8 Author: Brian Kernighan &lt;bwk&gt; Date: Tue Jul 18 19:05:45 1972 -0500 hello, world R=ken DELTA=7 (7 added, 0 deleted, 0 changed) commit 0bb0b61d6a85b2a1a33dcbc418089656f2754d32 Author: Brian Kernighan &lt;bwk&gt; Date: Sun Jan 20 01:02:03 1974 -0400 convert to C R=dmr DELTA=6 (0 added, 3 deleted, 3 changed) commit 0744ac969119db8a0ad3253951d375eb77cfce9e Author: Brian Kernighan &lt;research!bwk&gt; Date: Fri Apr 1 02:02:04 1988 -0500 convert to Draft-Proposed ANSI C R=dmr DELTA=5 (2 added, 0 deleted, 3 changed) commit d82b11e4a46307f1f1415024f33263e819c222b8 Author: Brian Kernighan &lt;bwk@research.att.com&gt; Date: Fri Apr 1 02:03:04 1988 -0500 last-minute fix: convert to ANSI C R=dmr DELTA=3 (2 added, 0 deleted, 1 changed) commit 18c5b488a3b2e218c0e0cf2a7d4820d9da93a554 Author: Robert Griesemer &lt;gri@golang.org&gt; Date: Sun Mar 2 20:47:34 2008 -0800 Go spec starting point. SVN=111041 
I'd also suggest adding "Never start a goroutine without knowing what it will do if it panics." The default of terminating your program is what it is for a good reason, but it's often not what you want. I also don't suggest blindly adding a defer to catch all panics... you need to think.
See: https://blog.gitea.io/2016/12/welcome-to-gitea/ It appears gitea is the open sores bureaucratic bastardization of gogs, so you are likely to see more activity, that is until interest is lost. And whether you consider the opinion of many to be better than the opinion of one to be a good thing or not. It's too early to tell right now but gitea could go either way. They are still at feature parity and I have not had any issues what so ever with gogs so that's where I'm staying.
It's humbling to know that it will be another forty years before I'm as experienced as one of the creators of my favorite language, furthered by the fact I'll spend the entire time being half as good. Well, half is probably untrue, but let's not let me die thinking I'm a total idiot please.
It's not a speed play, it primarily reduces goroutines and garbage.
Does that mean you expect version 1.0.0 is going to be ready in a matter of days? Sounds like that will be worth waiting for, and worth a try...
My general rule when writing Go code is "try to make panics impossible". Stick to type safety and it's not too hard. 
If you post the source to a simple program (say, one that prints the args) and a script that runs it to reproduce, I'm sure we can figure out what the issue is. It's almost certainly an issue with how you're invoking the program, rather than an issue with the program itself.
Gitea 1.0 makes a new infrastructure, like glide -&gt; govendor, all codes golint PASS, lgtm, truely single binary and etc. Also it contains many many bugs and vulnerabilities fixes. The most important is it builds a 14 people's community via https://github.com/go-gitea/gitea/blob/master/CONTRIBUTING.md.
Go right now is where Python was at maybe 6 or 7 years ago. With more development, it will get to where the libraries are on par. Maybe a slightly different direction. Just as Python took a bit of a different turn and not being a R clone. The type checking and easy concurrency are the big sells. Not the case with Python or R.
Gitea is showing lots of activity lately and Gogs hasn't seen a commit I'm aware of. Personally, I will be supporting Gitea over Gogs.
The sync package has at least one panic for people misusing WaitGroups. However it is well-documented. https://golang.org/src/sync/waitgroup.go?s=1857:1892#L42 I have no problem with this. If a WaitGroup count goes negative you have a bug.
Pure Go. No cgo at all. cgo is yucky and I do not want to learn it myself. 
Thanks!
That `Everyday Hassles in Go`article it mentions has some pretty crappy go examples. Such as copying an array just to add 1 to every value, what the hell?
Agree, probably just put conn.Close() at the end of the handling go routine. No need for defer.
reiterating my previous point: you then have to check every pointer method receiver for nilness, and gophers seem to have decided that is an antipattern
...and terminating with a stack trace is almost always the right answer
IMO panics are never acceptable as a control flow mechanism. Go lacks exceptions for good reason. Return errors.
With os package, it wouldn't prompt for password and can't update /etc/hosts file. Only way that it was successful was through bash...
If your library is not meant to be used with nil receivers, then doing so is a bug and it can panic. If it is meant to be used that way, you should definitely check for those cases where appropriate.
I don't think /u/DeedleFake is suggesting it as control flow - in this case it's pointing out a bug in the code using the library and bringing down the program.
A goroutine saved is a goroutine earned.
How is it a bastardization? It's exactly how open source should work, a bunch of commiters weren't happy with how the owner went missing for long stretches of time and didn't give anyone access to the repo to continue the development in his absence. So they forked it.
If you like watching as much as reading: there are some youtube channels with nice talks, like https://www.youtube.com/channel/UC9ZNrGdT2aAdrNbX78lbNlQ and https://www.youtube.com/user/dotconferences/search?query=dotgo
Most successful OSS has a BDFL.
It will stop when I hit control-C. Job done.
Have you had to operate a gitlab instance before? 
Well, it's not a git thing, it's just a convention for text content. Gerrit, but maybe other review tools too.
I can count the number of times I've needed to do that with zero hands.
I have lately introduced a minor issue but we are nearby a release.
I'm using zsh, and actually I just narrowed it down to what I think is the culprit: when the args contain "=&gt;". And no, nothing is quoted when running ./myApp fun args go here =&gt; stuff stuff. I get this error when =&gt; is at the end of the arguments: zsh: parse error near `\n' If =&gt; is anywhere in the middle, such as ./myProgram word word =&gt; more words, it simply exits without a message. Any ideas? =&gt; doesn't seem to be an alias for anything, so it's sort of weird. Not sure if it's worth copying the function that is causing this, it's extremely simple and just printing out the full os.Args slice so I can see what's going on. Quick edit: even just echoing "=&gt;" in my shell causes the same error, so I'm quite sure this is independent of my program.
A BDFL is worth nothing if there is no community around and it's more anecdotal evidence than actual evidence Most projects require some sort of community to work; see OpenOffice.
I responded to another person in the thread, but I believe I found the source of the problem and I don't think it has anything to do with my program. It appears that when a fat arrow ("=&gt;") is present in the arguments to the program, zshell doesn't like it. Even if I just run echo =&gt;, I get: zsh: parse error near `\n' Another quick edit: it's actually just '&gt;', not the arrow. 
Zsh also interprets other characters as special, such as a question mark (?) when the arg might be a url with a query string. You have to enclose those args in quotes to prevent the shell from interpreting them
I don't think you and /u/earthboundkid are disagreeing, here.
Got it, in fact I just realized it's not the fat arrow, it's specifically '&gt;'. Would there be any other possible solution? As what I'm trying to do involves running my program with the arrow to signify something special about the text that follows. Perhaps I just need to choose a different symbol, because I don't want to have to type ./myProgram add thing "=&gt;" here's the special text 
Correct. Every function which starts with Must* can only be used during program initialization. So your library is allowed to panic only then. All other panics and you go straight to hell ;-)
ctrl-Z is much better tbh. Just ctrl-Z everything and at best never close your terminal either.
`\n` worked. Never thought about using that. Thanks for your help!
Failing fast is arguably still the best action for bugs like this. A panic in a program like this is a bug, and you can't guess all the possible ways it could happen and cope with them all. If you do try you can end up with a process with bad state which could screw you even worse. Best to just let it die with appropriate logging and alerting, and let the system service restart the application.
I hope gitea the best but is there any real need for a fork? Unknwon has done a fantastic job with Gogs and has put a lot of time and effort into the project. Why fork from the main project? 
That is what I mean too. Unspecified can be deterministic or not because it is unspecified. I agree deterministic is better for reproducibility, but randomness is better for bug discovery.
When I had to write software for tracking eye movements I had to write that many times.
You could refactor everything into your own packages (could take quite a lot of time to get something general purpose), but if you care about making your second web app process faster then it could be worth considering a decent framework? I've done several medium-ish things in AppEngine and it deals with a lot of your stated things (authentication, data store etc) for you.
You're right. But 2 month ago we said that we won't stop developing gitea no matter what. It seems like Unknwon is back, but we will continue anyway. He might be gone any day again.
Is Unknwon refusing to add project members? Is there a link to a conversation where this has been discussed? 
The standard JSON package uses panics internally.
You can use a type checker with Python if you really want to.
It's hard to say that when a project's only been around for a few months. Gog's been in the works since Feb 9, 2014, almost three years. [I could say the something like that about Lunny Xiao, a gitea member](https://i.imgur.com/fIcTEVo.png) who contributed a lot at the beginning of Gogs, but then was silent for over a year. 
Yes, he refused. I'm not sure about a link. Might have beed on gitter. Maybe someone else knows. Please read: https://blog.gitea.io/2016/12/welcome-to-gitea/
Sure. Below I do some slicing with specific lengths, but I could just as easily have done a split on the "/". Note, this is from a side project I'm working on, and not from my place of employment; but the concept is similar. func games(w http.ResponseWriter, request *http.Request) { gamerId := request.URL.Path[len("/"):strings.Index(request.URL.Path, "/game/")] gameId := request.URL.Path[strings.Index(request.URL.Path, "/game/")+6:] token := authentication.Authenticate(request.Header.Get("Authorization")) if request.Method != "OPTIONS" &amp;&amp; token.Claims["gamer"].(string) != gamerId { w.WriteHeader(http.StatusForbidden) return } switch request.Method { case "OPTIONS": w.Header().Add("Access-Control-Allow-Methods", "PUT,DELETE") w.Header().Add("Access-Control-Allow-Headers", "Content-Type,Accept,Authorization") w.WriteHeader(http.StatusOK) case "DELETE": deleteGame(w, request, gamerId, gameId) case "PUT": addGame(w, request, gamerId, gameId) default: http.Error(w, "Method Not Allowed", 405) } }
Sure, take a look at my reply above.
How so? Use that for static regular expressions, don't use it for ones created at runtime.
I agree. If OP means how would you go about developing a new, separate web application that reuses the existing logic and components/pieces of the current app, then you're 100% right. Creating the structure for your application that makes sense and is easily reusable, testable, etc just comes with experience and fine tuning of ideas that come from building apps in Go (and reading articles and what not). This just takes time. If OP means though how would you actually structure it, there's a few ways. For instance in my current web app, all of the backend logic is built into services. These services are each their own package and could easily be used to make a web app, CLI app, or whatever. There's not many articles on this method afaik, but this is where the basic idea comes from https://medium.com/@benbjohnson/structuring-applications-in-go-3b04be4ff091#.hgjql7k9f
I would prefer having a handle to goroutines since it seems knowing how your goroutines will stop is more complex. Go is a language that prides itself on simplicity, but from my perspective Go choose the more complex option for little to no benefit here. It was mentioned elsewhere that you should also know your goroutines will not panic. I wholeheartedly agree but contend that avoiding panics in Go is made harder than it needs to be. Go's concurrency model is simpler in the beginning but it doesn't scale in terms of complexity due in large part to not being able to ensure goroutines are disposed of properly.
&gt; The standard Go compress/zlib algorithm can't be used to extract packfiles, because it's greedy on the underlying io.Reader `io.LimitReader`?
&gt; Any non interactive batch operations benefit from increased throughput and aren't sensitive to latency. &gt; For example, nobody cares whether your compiler undergoes pauses as long as it gets the job done. Well this area is already covered since Go is written in Go. Anything else?
Whoosh...
xs[i]++
&gt; simple helper func called `die` In a nod to Perl's "...or die" idiom I guess?
Yes, it's easy and smooth
Nice. Thanks for this info. I will try it today.
Designing good reusable packages is difficult. To get to a reusable package I would write 3 applications by copy and pasting as necessary... then afterwards find the commonality and design packages for them. You can make this easier, if you separate your application based on value you will end up in a good place. (Think of a project structure where you can delete a feature by deleting a single folder and one line from elsewhere.)
Its nice, but if the project isn't intended to go to any of github etc, and will live on local system, it won't look neat. 
Does anyone know, at this time, what the differences are between Gogs and Gitea? Questions like: Is it a drop-in replacement?; Has one have more features? Security?
If you use channels and don't keep the pointer to the data structure, meaning that only one goroutine at a time will have the pointer to it, you won't have any race conditions. Share memory by communicating (go proverb) 
What do you think is going to be the future of Go in another 6 or 7 years?
premature modularization is the root of all evil maintaining a bad abstraction is a thousand times more expensive than maintaining copy pasting YAGNI
You guys should all band together and join forces.
Because Vim looks for GOROOT when I run `:GoDoc`, and I honestly don't remember why I set GOBIN originally, it was either from a guide I was following when I first started learning Go, or because I got an error telling me $GOBIN was not set, so I set it. 
I setup a git-notify mail for that repo and check it regularly. IIRC it's a huge load of bug and security fixes, linting the project, adding some minor features, updating some dependencies, etc. Personally, it looks most like cleaning up the entire project before adding anything big to it, which I like.
I've gotten into the habit of MIT licensing code I write for personal projects (such as the above), because it's the closest license that I know of to public domain (with a warranty disclaimer to cover your ass). Anyone's free to take my code for their own implementation (or contribute to it.. in fact, I should probably make a CONTRIBUTING.md explaining the code layout to make that easier.)
Yes. :-)
Same. Thank you for your reply! I will be making the switch to Gitea.
github.com/artyom/smartcrop does the same as package referred to here, but does not need opencv.
Beside that even the entire used infrastructure is published. As we are 3 admins and two additional people with full merge rights we don't have the bottleneck that Gogs got.
Even if one or two of us are gone, we got 3 owners with access to the entire infrastructure, so IMHO we can say that this can't happen to gitea.
I think this is probably the best approach I've seen so far for error checking a streaming read. I'm still on the fence about doing a streaming approach at all though. In my particular case, it really seems easier and cleaner to make all of the functions pure by just passing around a byte array instead of a Reader. 
Right, the initial version is mostly cleanup and bug fixing. Additionally we got some api changes to get in a direction of api compliance with github. The next version 1.1.0 will get some new features like protected branches or OAuth2 consumer.
&gt; I'm going to try wrapping the stream in a bufio.Reader and see if that helps. bufio.Reader won't work, probably. But you can write your own simple wrapper struct and use it. Something like that: type reader struct { io.Reader buf [1]byte } func (r *reader) ReadByte() (byte, error) { _, err := io.ReadFull(r.Reader, r.buf[:]) return r.buf[0], err } 
Because as far as I have read, they like to think that work on Go started with C's root, they have changed 6-7 version control systems etc and now, in 2010 they released Go as FOSS. Thus the commit from 1972, it was a logical thing and sense of humour!
Cool, how about a delete function to delete the whole structure again ? (Usefull for test)
What ever is the easiest to reason about and maintain long term. I'm not advocating against routers, just disputing how "limited" the stdlib is.
yet elsewhere in this thread, people are upvoting suggestions to check for nil pointer receivers....so once and for all, does the community want these checks or not?
I'd try removing both. Recent versions of Go and vim-go don't require either and if your manual setting should ever differ to what `go env` automatically determines you'll have issues/confusion (e.g. right now if you ever wanted/needed to change `GOPATH` you'd have to remember to also manually change `GOBIN`).
&gt; insane variety of different behaviors apparently randomly slammed into the same commands That's why I use mercurial for everything and hg-git to access stuff on github. Unlike git, the `hg` sub-commands+options are sane and it's absolutely not worth learning/remembering both. (I even have a small tweak so that `go get` will use `hg clone git+…` instead of `git clone …`.)
Have you considered defining a Go struct which looks like that object and implementing the BinaryUnmarshaler interface? https://golang.org/pkg/encoding/
Do you think that Go could work for the enterprise like Java or Google could let Go be the language for android instead of Java?
Doesn't Apache 2 have better protection against patent lawsuits?
Maybe optionally. Personally, I find Rust's errors incredibly obtuse, especially when they point to the wrong part of the code, which they did pretty often back when I tried it.
I'd like to see non-nillable pointer types. It feels weird and arbitrary that since I'm pointing to something that I have to check for nil all over the place. 
https://blog.gitea.io/2016/12/welcome-to-gitea/
This should have gone away in the last few months. Which version did you see those in?
looks cool but i am going to stick to gogs for the time being....i totally get why they forked...but gogs is still getting fresh commits and moving forward at a good clip, and personally i am more focused on the project's velocity and not its governance gogs is awesome and i love being able to run it locally with ease...the setup is trivial for someone who has no concurrency/multiuser concerns (i.e. my own laptop)
That looks like a formalization of reading the entire file in as a byte array and then transforming it. The more I work on this, the more I think that's the typical Go way of doing something like this. 
personally, i'd like to see more debug information provided in the base error type by default (like stacktrace, line numbers, files, etc.) rather than just a special stringer interface
Go has stream encoder/decoders that operate on things like this. That being said, it's more complicated to stream decode this and a single file is likely not so huge that loading into memory isn't convenient. 
Very nice!
They should do away with the half-assed `syscall` package, remove the various design oversights and throw out those functions they replaced with better versions. Of course, all of this should happen in Go 2 as to not break compatibility. It would also be nice if the semantics of functions were explained in a more detailed manner in the standard library. Right now it's not possible to accurately build a Go implementation just based on the documentation, which is an absolute requirement for a system that wants to be more than a single implementation.
I agree with FUZxxl. This does look to be really awkward compared to non-nillable types. 
1. more thought put into interfaces in the standard lib, not just concrete APIs. looking at most of the standard lib, you would not know interfaces were important in Go 2. make `go tool vet` and `golint` unnecessary. if people are really going to be dogmatic about their ideas of idiomatic Go, just make them compile errors so we can avoid all the superfluous PRs and "bug" reports 3. something like `Maybe` as a major addition to the standard lib. we have *some* generic constructs...why not one more? it's worth has been proven elsewhere when implemented appropriately
I'd like to see a fast (non channel based) C# style yield return construct.
Not sure. My area is in data analytics and data engineering. 
I want to see one smoking out of a bong
I'd like to see something like a way to pass types as parameters and, ideally, use these types against functions etc. at compile time and such. I don't know what to call it. Some common general inclusive term probably?
Classy
Algebraic data types would be stellar.
I think it'd be really nice if it could/should support WebAssembly as a target. :P
- full generics - algebraic data types - declared interface impls - implement interfaces for types in other packages - interfaces and methods for primitive types - custom operators - full type inference - simplified var declarations - debugger - range/index/etc work with user types - exceptions - equality for slices, maps, and functions - cleaner godoc presentation that doesn't just look like pure code - use upper- vs. lower-case for types/variables instead of exported/unexported - repl - type aliases and re-exporting - dependent types for arrays and custom types like vectors - useful zero map values for key/value insertion and zero slice values for indexing - remove special pass-by-reference semantics for slices and maps - use something other than * for pointers to avoid conflict with multiplication - naked returns are useless - disambiguate recover() results (panic(nil) and panic(myaccidentalnilvar) look like no panic happened to recover()) - go tool support for managing deps so many more too
SQL package really needs a way to bind a row to an structures rather than having to do each field manually.
A proper extensible attribute syntax. Struct tags are OK, I guess, but I hate how certain comments like `//go:generate`, `//export`, and `// #cgo` are treated as compiler directives and all use a different syntax. Also, I think `export` should just be a language keyword, now that the shared library build type is supported. That way I can export functions like this: export func DoSomething() { }
* equality for slices, maps, and functions Would slices and maps be compared by value, or reference (I.e., would two slices with the same contents compare equal, or do they actually have to point to the same underlying array in the same place)? As for functions, I'm actually glad that Go doesn't allow them to be compared. The best you can do is reference equality; but with closures it becomes unclear whether two functions are equal: func f(n int) func() int { return func() { return n } } // Surely, f(4) != f(5), but how do we know?
[Go already has that, really](https://play.golang.org/p/zJhJPnKStR). Dereferencing a nil is not instantly an error, because pointers in Go aren't just pointers, they're semantically a (type, pointer) pair, so you can still get to the method through the type even if the pointer is nil. Which is sometimes useful; I have several types for which "nil" is perfectly valid and meaningful. It's exceptional enough of a case that I always document said legality in the godoc and carefully explain what it does, because it seems a non-trivial number of people think nil is always invalid, and the remaining people who know it's valid probably (generally correctly) assume that a pointer can't be nil if you don't say it can. However, it can also mean that when you have a nil that shouldn't be nil, the error message can end up _even farther_ away from the real problem, because you can end up passing through even more method calls before something finally crashes out rather than crashing earlier on an illegal dereference. I'd still like to make non-nillable types.
&gt; full generics Why? What's wrong with interfaces as they are today?
You basically want a different language.
&gt; Personally, I'd like to see more informative compiler errors. Go's compiler errors are one of the best I've seen in my life. If you have any doubt about that, try working with C, C++ and Java. Even today a missing semicolon error can make me scratch my head for a few seconds. Rust's compiler errors might be better than Go's but it is probably because it is such a complex language that without detailed compiler errors you wouldn't survive writing it. That said, if Go can improve the compiler errors even more I obviously wouldn't mind. Which makes me wonder, is it against the Go compatibility promise?
&gt; make go tool vet and golint unnecessary. if people are really going to be dogmatic about their ideas of idiomatic Go, just make them compile errors so we can avoid all the superfluous PRs and "bug" reports If you do not like your code getting better by the community then simply mention in your README that you do not accept PRs or at least that you do not care about writing idiomatic Go code (nothing wrong with that). Do not take away tooling that helps everyone else.
Gccgo and gopherjs both implement the specs are able to use much of the standard library as is. Gccgo in particular was helpful in finding places where the spec and the gc compiler disagreed. 
Const is tricky. You might be interested in Russ's evaluation of the proposal for read-only slices https://docs.google.com/document/d/1-NzIYu0qnnsshMBpMPmuO21qd8unlimHgKjRD9qwp2A/mobilebasic
Is this a serious comment?
&gt; The compiler errors are getting better in 1.8 and 1.9. That was one of the reasons for moving away from the yacc-based parser to a hand-rolled one. Dope!
Underrated.
I guess the problem is that you had a different question in mind than the one I answered.
&gt; I guess the problem is that you had a different question in mind than the one I answered. Indeed. Do you have an answer for my question though? :P If not it is ok. It just means that the Go designers are doing it right.
I would love to see an easy way to replace all the 'if err != nil { return err }' blocks sprinkled everywhere. It is so common that I long for the ability to create macros like in C++.
This was a huge pain in my ass when writing my Mustache parser. 
I LOVE these! I really like the rock climbing and statue of liberty (big NYC fan) ones. Great job!
True, MergeSlicesWithoutDuplicates would be a better example.
wow neat and i wish the original std package had those features
you misread. i am not opposed to these tools, i am saying that if we all agree that that the changes suggested by these tools always constitutes valid advice, then just turn their advice into compiler errors so we can stop having silly discussions about what is/isn't idiomatic code. you code will either be valid by these tools or it won't compile. yeah, there are some corner cases, but most of `golint` is actually stuff that could be easily enforced by the compiler 
Support package version. Vendor is a hack. 
Only thing I'd really like is lambda expression syntactical sugar. If I want to do some functional-style iterations, it's kind of awkward currently. myMap.Filter(func (v MyType, k string) MyMapType { /* do something */ }) as opposed to: myMap.Filter(|v, k| =&gt; /* do something */) I would figure the type signature of `filter` would let you know what `v` and `k` are and what the lambda should return, so it's not breaking type-safety. I just think it would make Go a little more fun to write. The `for` loops get a little tedious after a while, but that might just be my preference. EDIT: Eh, the more I think about it, I'm not sure Go is cut from the right cloth to do stuff like this. I'm hard-pressed to think of how to truly make this useful without generics. Oh well, `for` loops it is.
&gt; helper libs Ah! Ive made this mistake myself. Because the language won't let you do what you want to do yet cleanly//elegantly/without repeating yourself, you made a helper lib, and used generics to code gen your way around the problem. But what you really wanted was the language to support what you were trying to do in the first place in a more clean way. I bet you I could come up with a better way to represent your solution by enhancing the language and NOT adding support for generics, which is exactly the Go way. Adding generics introduces a largely intractable problem without resorting to very messy code gen, and there are cleaner ways of expressing code reuse that are idiomatic Go, just not yet supported in the language. Push for those clean, elegant, idiomatic language solutions, not messy ones that cause more problems than they are worth.
I don't disagree but this is tricky. There are already many complains about unused imports. Imagine if the compiler started complaining about missing comments or something like that. On the other hand, things that actually matter like shadowing would be very useful. Unfortunately those cases always have false positives so I don't think it can be done reliably.
&gt; my equality comparator What is your equality comparator?
And gopherjs, and llgo. While the first is incomplete by design and the latter seems outdated, it still means more than two teams are testing the spec for its limitations.
Iterables. I'd be happy even if it was implemented by convention. currently convention is for n.Next() { current := n.Value() } if this is the settled convention, it would be nice to support this with the range keyword for _, current := range n { // do }
While some of the language features mentioned here would be nice, a working debugger would be a more practical start: dlv just doesn't work on OSX 10.12, which was released 3 months ago.
Dependency management.
Would you mind extending your comment? I have no clue what you are referring to, why would you want to replace the error checks? And why don't you just use an editor that supports (and understands) go? That way you can easily refactor. And if all else fails there are snippets. The whole thing is for me errr&lt;tab&gt; (error return) or errh&lt;tab&gt; (error handle)
Tell me how you would enhance the language (without generics) to properly handle something like a channel. Go ahead, I'll wait
Be aware that generics and interfaces aren't the same thing: generics are parameterized types; interfaces are assertions that methods (in Go's case) exist for a type. There are useful things that can't be expressed without generics. For example, Go arithmetic and comparison operators require the operands are the exact same type. That's useful. How can you do that for your own function? You can't, because that's generics. How about a function that can operate on any slice? Append can do it, but it doesn't have a function type expressible in the language, because that's generics. For that reason, append arguably isn't even a function; it's merely a primitive baked into the language like arithmetic or channel operations. Take a look at the builtin package in the standard library; practically everything in there is an example of things in the Go language that can't be expressed by its type system because it's too limited to describe them. I'll talk about algebraic types as well since I'm talking about things in Go that its type system can't describe. How do you make a number type from scratch? That is, a new, unique type with multiple, unique values that aren't defined in terms of, or built on top of, some other type? The answer is you can't. There is no way to express the "int" type in the Go type system, because it's an algebraic type. So it's baked into the language itself. We're given int out of the box because there's no way to express it ourselves. Basically, Go's type system is incapable of describing some of its own basic concepts and constructs without generics and algebraic types. Picture the values in a language as a hand. The type system is the glove. Without generics and algebraic types, it's a bulky, thick, course, hot knitted mitten that keeps the four fingers stuck together. It's awkward to use the fingers, and everything feels distant and muffled through the glove. All you can really do is pinch things with your thumb and mash things with your fist. It's not a good fit, and so it hampers what the hand can do. With generics and algebraic types, it's a light, slim, comfortable, dexterous leather glove that snugly fits every finger and feels light as a feather; you don't even really notice it's there, and the hand can do anything it normally can do. Some people like dynamically typed languages because they feel less burdensome than statically typed languages. They like that you can just write code and not fight the type system. They don't realize that static type systems aren't inherently bad; they were just using shitty ones. Static type systems can express anything that can be done in dynamic type systems. In many cases, the types can be inferred without explicit type annotations, so you get the best of both worlds. There is zero SEMANTIC reason for a language to not have full generics and algebraic types. There CAN be valid implementation reasons, which is what the Go Team is partly stuck on now. Personally, I don't get what the performance hang up is about just boxing generic values; they get boxed anyway when I stick them in an empty interface; but I'm not up to speed on all that, so I dunno, but I've never seen that point addressed. Hope that made sense!
Well, it is verbose yes, but then again similar constructs look like try: conquer_the_earth() except AllHellBrakesLoose as e: recover(e) not really less verbose, just different. The only thing is that you can let it bubble up without doing anything. But I don't think a caller 2 or 3 levels up cares about an index error or knows why that happened
Do you think there's place in the library for smth like https://play.golang.org/p/76ivuvbSpt ?
&gt; Non-copyable types (mutex). Not the same, but... go vet (-copylocks) warns about copying types that have a `Lock` method. [1](https://github.com/golang/go/issues/8005#issuecomment-190753527)
Why do you think I'm looking for a language like Go? I've clearly already found it and learned it... Then you say: Well, no, I actually meant that Go won't ever change to do that stuff. Then I say: Isn't the premise of the question that Go can change?
I might be missing something but when I recover I want a stack trace by default. If I can't control what panics then I have no way to ensure a stack trace is included in the panic func.
Don't get me wrong- it's a very good tool. I assume other languages provide their own.
Which is good.
&gt; Dereferencing a nil is not instantly an error, because pointers in Go aren't just pointers, they're semantically a (type, pointer) pair, so you can still get to the method through the type even if the pointer is nil. Actually, no dereference happens when you call a method on an a pointer receiver. After all, the method call is just an ordinary function call with special syntax. Since the object's type is known at compile time, no vtable is looked up either. The only cases where a method call dereferences the receiver are: * when you call a method with a value receiver on a pointer to that value. * when you call a method on an interface, the interface (not the object within) must be dereferenced for the virtual function call * when the method you called (or one of the functions called by it) dereferences the receiver.
Is idiomatic Go always the best possible implementation? Or could there be a change to the way Go was made that would have been better?
I definitely vote for including UTF-8 into learning material right from the start. There are a couple of things that beginners might stumble over if they don't know about Unicode and the way Go handles it. For example: `for i=0; i &lt; len(str); i++` (byte-oriented) versus `for i, v := range str` (rune-oriented). Or `char := str[i]` where `i` might happen to be the index of one byte within a 3-bytes UTF-8 character. The student would see garbage in `char` and would have no idea why. 
&gt; The definition of `rune` actually covers UTF-8. No, rune represents Unicode code points, which have nothing to do with UTF-8.
The best solution is adding a ZIP file to your binary and use a section reader to present it is to the ZIP package. If you want you can add a vfs on top of it. See here: https://www.ueber.net/who/mjl/blog/p/assets-in-go-binaries/
I second that. 
But there are others here who might write tooling to make some of these possible, even if they're not "official".
Unicode code points have *something* to do with UTF-8...
Bill Kennedy's goinggo blog... Excellent stuff on there 
Sometime in January, they said. 
I'm on mobile so I can't link to the documentation , but you can configure the vim-go plugin to open everything in a quickfix window. 
Better import cycle error messages (they're entirely useless atm) including culprit line numbers, more information in FileInfo without having to rely on syscall (keep the API consistent across all devices, let Go work out what's what in the back, I don't want to have to use something like this: https://github.com/djherbis/times)
Some stuff. Honestly, I don't know, but I'm going by the words of its authors: https://github.com/gopherjs/gopherjs
I am aware of third-party solutions, but this is still an ugly hack in my opinion. Why should it be so hard to support resource files by the toolchain?
Currently working on the UI. Should be ready by the official cloud release. So far the Constructor has been used only by back office staff ( it was not provided to businesses ). Therefore we have not paid much attention on the UI. It was important to do the job. Now we are working to make it as intuitive as possible. 
I dislike the way the structs are popuated by sqlx, up to the point that I forked it, check out the readme: https://github.com/boreq/sqlx Does anyone know if there is a different way to do what I want to do in sqlx?
* Debugger * IDE * Standard Package Management * Grouping for functions added to Structures. The last suggestion: I really don't understand why I can't do something like: type x struct { Count int *x func Increment() { x.Count++ } } 
dlv seems to be working on 10.12 as of a week or two ago, built from head. I've not used it heavily, but it's working fine from within the VS Code integration. 
I would love to see interfaces more embraced by the spec for undefined or unsupported operators that don't lead down the rabbit hole of abuse too deeply. I.E: t "+" | "-" | "*" //- T.Add(T) T tcpy := *t // T.Copy(T) could be abused badly but illustrates point This would allow nicer slice appends in my opinion, specially when your merging multiple into one. []T + T[] // T.Append() use today's append by default As well as maybe some private ones, I personally hate how I feel the need to use New() or make structs private and return interface wrapped when all I need to do is make a chan or map. Would be nice to have: var t T // t.init() T - always non nil for pointer T and never fails It would only fail in cases that allocations fail and would have panic anyways. They could all be abused though and I could end up regretting dealing with such features later. I try to remind myself that I like the language because I'm never spending hours hunting down total WTFs from language internals being mucked with like can happen with python.
I created an account just to upvote this. The day the GOPATH will be dead will be a good day.
And that is dear kids why you should write your comments in english
Do you have any background in C or C++? Because coming from those languages Go is a breeze with pointers. I don't really see any problems with pointers safety in Go if you write idiomatic Go code. In C you can't write programs without pointers because everywhere in std you have pointers and you mostly operate on raw memory so you need pointers everywhere, in Go you can write code almost without any pointers. Implications of having Rust like safe pointers would mean changing whole language which would mean breaking a lot of code. Train for that already left, I don't see possibility for that to change, to have compile time checking without major language changes.
Only because you don't have genetics. Maybe types work really well 
Yes, I do, but once in couple of months maybe, when I use some new library. But cost of changing the whole language to cover that is not adequate to how often it occurs.
Then don't use C, don't use Go and even don't use javascript. You know what cycles are ? Does JS protect you from that? It does not, you can get memory leaks in javascript, you can get in Go etc. In practice developers can write unsafe code in every language, because even Rust will not protect you 100% from writing fully correct code and there is a cost you pay for safety. Go was built as successor to C, not JS. And comparing it to C it's a lot safer. Your point is invalid, because if it would then just write idiomatic assembler, yes? No. You have different levels of safety in every language. Writing idiomatic code in Go is a lot safer than in C. There is a balance always between safety, performance and productivity. Choose language that fits your need and acceptable "safety level". Go is safe enough for me, if it's not for you then choose a language that is. I can guarantee you that Go will not be safer in this matter in future because that was decided in language design many years ago. It was decided that for certain group of people this level of safety will be enough and acceptable and it is. 
It's in the [syscall documentation](https://golang.org/pkg/syscall/): &gt; NOTE: This package is locked down. Code outside the standard Go repository should be migrated to use the corresponding package in the golang.org/x/sys repository. That is also where updates required by new systems or versions should be applied. See https://golang.org/s/go1.4-syscall for more information.
&gt;Choose language that fits your need. Agreed completely. &gt; In practice developers can write unsafe code in every language, because even Rust will not protect you 100% from writing fully correct code. [...] And comparing it to C it's a lot safer. Also agreed, but that does not really matter -- we can't be 100% safe, but that does not mean there is no value in trying to be safe. Thats actually the value Go adds that got a lot of us to switch to it in the first place, even though it is not 100% safe. I guess I'm just not understanding what your objection to trying to have less nil pointer dereferences is. If you're right that its impossible to do without breaking a lot of code, then sure, shelf it for the next major release that will already break things. If not..maybe someone with the skills can start working on it now. In either case it seems like a perfectly valid answer to the OPs question of what they'd like to see improved in Go. &gt;Your points is invalid I'm glad you checked first otherwise your brain might have crashed when you tried to follow them. 
Then the iterating goroutine would panic when sending on a closed channel.
Depends on the design of the sender, iirc if you put a done channel, that's closed by Close(), on a select then you can signal to the sender that it should stop. Edit: example: https://play.golang.org/p/YrT5B9vaEE
For `Maybe`, use a pointer. nil means `Nothing` and non-nil means `Just`.
I can see where you're coming from with maps, but how is an empty slice more useful than a `nil` one? All operations are the same on them as far as I know (`len`, `cap`, `range`, `append`, `copy` all still work, and subslicing and indexing panic on both).
For most of my structs, everything is in one file. Even in Java or C++. Never did much Python. And most modern code editors can make the indention levels more or less obvious. Language specific editors can do even better. In Go, I've become used to the kinda floating nature of the methods. Do sometimes long for inheritance, but I've gotten used to go now. I might like some kind of compile time templates so I can define standard methods that can be applied to structs without having to cut and paste code. Not quite inheritance, but something like it. Not sure what the down votes are for, BTW. Unless it is bad to answer questions? I'm pretty sure I have written more Go code than the average Go developer... Not like I'm dissing the language.
It fills them out in order, yeah. Which I think is perfect for this use case since there is indeed no way to find out what the full name of the column is. The attributes are access with the full name `p.Post.ID`.
&gt; Personally, I don't get what the performance hang up is about just boxing generic values; they get boxed anyway when I stick them in an empty interface; but I'm not up to speed on all that, so I dunno, but I've never seen that point addressed. Although I can't speak for the Go team, I think part of this is that implementations of generics that don't do code generation typically box *all* values (at least by default) even when you're not using them with generic functions or values. For example, Java and ML and Haskell have boxed types by default (Java's primitives are not boxed, but you can't do generics with them without boxing). As a more concrete example, if I have something like type struct [T] Pair { First T Second T } Then with an unknown T, your pair object has to live behind some sort of indirection; it has unknown size so it can't live in a register or (easily) on the stack. Accessing its fields requires doing arithmetic on the size of T; you could imagine larger examples where the address of a field depended on several generic parameters. By comparison, once you've wrapped up an interface object, you're just dynamically calling functions; which as long as your branches predict reasonably accurate is only slightly slower than a regular function call.
guess im not using the orm then. lol
Thanks. I guess I wrote a lot of my syscall code before that lockdown occurred.
A maybe is basically a more shitty pointer type with more boilerplate and less elegance.
Exactly my point. Why introduce another state of it behaves exactly the same way. Also it creates more ambiguity in the rare cases you need a pointer to a slice. 
&gt; query the current number of values in the value buffer of the channel by calling len(ch), where len is a builtin function. Could someone provide an example of this? I didn't think this worked and I can't come up with a test case that shows it works.
I've been a qt developer for a number of years now, although I have only had a very quick play with the new go Qt bindings. But I would say that, we know Qt makes nice UIs and we know from the documentation that the Go Qt bindings are fairly complete. So that being said, I would wager it should be just as possible to create nice UIs from the Go bindings as it would be from C++ or python 
Here is an optimized and runnable example using cap() instead of a magic number: https://play.golang.org/p/wq4_VdaYjA c := make(chan struct{}, 10) for len(c) &lt; cap(c) { c &lt;- struct{}{} fmt.Println(len(c)) } 
I did see ListenAndServeTLS, but that doesn't seem to use Secure?
Can you link to this middleware? I'm not quite sure what you mean by "middleware" here. Why would you need middleware to use HTTPS?
True, sorry. Basically was wondering how to specify a certificate to use for HTTPS. In the README, I saw the Secure options, but it doesn't seem to specify where I actually specify which certificate it uses for HTTPS. I'm also completely new at this, so yeah... Sorry. 
https://github.com/unrolled/secure
Ok. I was being stupid and did the allocations in goroutine and only did a time.Sleep(1) to let them run... ie. not enough time. I always have to remind myself that it is not in seconds (like unix sleep command).
Thanks for your reply. I was actually aware of the GitHub preview mode but did not connect the dots. As a follow-up question, do you know how I can provide that custom media type when using go-github? **Edit:** As far as I can see, the media type is set by go-github: https://github.com/google/go-github/blob/a77ccc9a588d217ea8c8b069620a3a070ed201c3/github/repos.go#L176
Ah, never mind. I got it working. The API indeed sets the media type by default; `Repository.License` is however still `nil` if GitHub's API cannot find a license for it. The following code works: repos, _, err := client.Repositories.List(user, opt) if err != nil { log.Fatal(err) } for _, repo := range repos { name := repo.Name var license string if repo.License != nil { license = *repo.License.Name } else { license = "N/A" } fmt.Printf("Repository %q by %q has license: %q\n", *name, user, license) } 
I don't remember, but it's been a little while. If it was fixed in the last few months then it's probably been fixed since I ran into it.
Don't the values received from a channel in a range statement depend on user code? Couldn't that be expensive? What's the difference between a channel and a custom set type (for example) that implements a standard iterator interface in terms of understanding what is happening? I don't see the need for properties either, but getters and setters have the same mystery to them in that anything could be happening under the hood. Most of the things I listed would actually simplify Go while making it more powerful. The spec would be *shorter*. Operators being just normal functions/methods. Special operator and function generics being normal type features. All that explicit error checking and returning and panic stuff being combined into a single exception mechanism. Generalized iteration and Go statements (e.g. range) and expressions (e.g. indexing) that operate on interfaces. Consistent built-in type operator syntax ([]int and foo[], ^int and foo^). The Go Team is currently working on a way to alias exported types (like to alias golang.org/x/net/context.Context with context.Context) like can already be done with constants and variables (IIUC).
I'm pretty noob so I'm not sure if it is working. I have it set to redirect to HTTPS so it ensures to use HTTPS but I can't see where it sets the certificate (I'd like to use a self-signed certificate) that is used for HTTPS so I'm not even sure it's doing HTTPS properly. Chrome also gives me an error when trying to access the HTTPS endpoint. Yes, I realize I'm pretty noob at this so what I'm writing may seem completely ridiculous :P
Also string literals in Golang are UTF-8. 
Fair enough; I was sloppy.
How is the type system lying to you? Pointers can point to nil. That's documented so there is no lie, only a misunderstanding on your part.
If I tell you there's a car in your garage, but when you look inside there's no car, you're probably gonna say I lied to you. If I have a function that accepts a Widget, that is a contract. But the type system will let me pass in something other than a widget.
Gil Tene, one of leading expert on GC, seems to agree on Go's GC choices as compared to original article.
Why is B's perf unacceptable? It's equivalent to what we do ourselves with empty interfaces: type Pair struct { Left, Right interface{} } type Pair struct(T) { Left, Right T } Same perf and type-safe. If you want the best perf, then don't use generics. If you use generics, you opt into the perf cost of the boxing.
Thanks for correcting me. I had meant to say `strings` cover UTF-8. rune - https://golang.org/pkg/builtin/#rune https://golang.org/pkg/unicode/utf8/
If your writing it for any reason other than a learning experience, I wouldn't try to invent a new way to pass a program input. I would design this the proper way and use command line args as you are above for add thing, and instead of the syntax after just send the special text to stdin. Then the endless edge cases and wtfs are all mitigated. 
[Less is more.](https://commandcenter.blogspot.gr/2012/06/less-is-exponentially-more.html)
If you are looking to write GUI with bindings then I think the story is already quite good in Go. The problem with that, is that you are essentially introducing C in your project with all the good (and bad) stuff it brings and you say goodbye to some good stuff that Go brings like easy cross compilation. Unfortunately right now this seems to be our only option (excluding web UI) as any attempts for a pure Go cross platform GUI library have either been [abandoned](https://github.com/google/gxui) or are just [too immature](https://github.com/golang/exp/tree/master/shiny) for real development.
Thanks! This seems to be working fine. Can you tell me the reason why you added &lt;silent&gt; in front?
&gt; you can configure the vim-go plugin to open everything in a quickfix window. Thanks for the reply. I'd rather not do that. I am pretty sure there is a very good reason some commands choose what they choose. I am going with this command for now as it seems to be solving the problem: &gt; nnoremap &lt;silent&gt; &lt;leader&gt;a :cclose&lt;CR&gt;:lclose&lt;CR&gt;
&gt; there are plugins for this. I try to use as less plugins as possible but I would probably use something like that if this command didn't solve the problem: &gt; nnoremap &lt;silent&gt; &lt;leader&gt;a :cclose&lt;CR&gt;:lclose&lt;CR&gt; Thanks for the reply.
Ya that's what I also understand to be true. Thought it was abandoned long ago. Don't think I have ever even seen any Java Qt code. Python and C++ Qt are still going strong. I'm hoping to use Go in a Qt project soon 
Well I use haproxy/nginx for lots of reasons independently of language/framework capability. For me infrastructure is a different problem to solve versus programming. It's simply a matter of separation of concerns. I use haproxy to do SSL termination, to load balance, to do no-downtime deployments (turn off half of the pool, deploy, turn back on, repeat on the other half of the pool). I always start any projects with 2 webservers in production with automated deployments for this reason. Maybe because I have all my Ansible environment setup for all my projects that I don't bother anymore to serve static files, configure to run on port 80, load balance in useland, etc. For me it's not related to programming at all and surely not because Go can or can't do it. 
For some reason VSCode eats up a lot of battery while I use Go
yeah. i was thinking the same thing tbh. is the general consensus that the framework is shit? do you have much experience with it. 
While I thank you for this, for writing big apps is this not just extra unnecessary work? 
how about send/receive N values to/from a channel in one time?
I believe crux of the matter is, should we look at application performance as a whole or purely GC performance. I think it should be about application perf. If that's the case Go is not that far at least compared to Java. Because from benchmarks available Go looks quite competitive in both throughput and memory usage. And as Ian Taylor mentioned in mailing list that Go concerned only on latency at cost of throughput is hyperbole. However, many have argued about just GC perf in which case Go might need quite a bit. My problem with article in sense it mentioned a lot general GC theory but Go specifics were a lot of guesswork.
&gt; is the general consensus that the framework is shit? do you have much experience with it. I have zero experience with Beego but I have tons of experience with frameworks from other languages (specifically Spring for Java, Ruby on Rails and some Python/Django). I've heard that the Beego framework is good but personally I am trying to stay away from such solutions. I'd rather spend my time learning how to do something, than learning how to do something with a certain framework. The difference is that the knowledge you get in the first case is general and once you acquire that you can apply it in mostly any language and tooling. Meanwhile in the second case (while you still learn of course) it is much more specific. In fact if you've learnt to work with a certain framework and then suddenly it goes away or you even try to do things in a new language that doesn't have such a framework, your productivity might go down the drain. This can also happen when you have been spoiled by the ability of your framework to get things done for you while you have no idea how things actually work. For me this is the biggest trap of frameworks. While they might seem incredibly convenient at the start they might backstab you later down the road. When the time comes to implement something that is not supported by your framework or just find where something goes wrong, if you do not understand how things work and only know how to work with that framework then you are gonna have a bad time. I'd suggest you start as simple as possible (just the standard library) and add small external libraries later when you actually discover that you need them. Of course you know better the requirements of your project. If you are working on a tight deadline then frameworks like Beego might be the exact thing you need. Obviously I cannot speak about the general consensus. If Beego fits your requirements then you should use it. From my perspective and what I perceive as the Go philosophy, it's better to keep things simple.
Meanwhile, Java experts at Google are afraid to touch concurrency (with Java).
Do you know if Go would be able to target to the enterprise? Java and C# seem quite in that area. On the other hand if Go does not have a good framework I cannot see how big corporations are going to accept Go as a language for their web apps. What are your views on that?
Qt-Jambi? I tried it a while ago, but it kept crashing. It's very unstable
All gitea contributors are former Gogs contributors. We tried it multiple times to talk to unknwon but in the end we had to do the fork for a real development progress 
Sure, along with an explicit request for a counter opinion. This is a discussion forum, not a PR board.
Fair enough. The way I see it, any official support from other companies is a big win for the language. Some years ago, wherever you read documentation, you usually saw examples for the most popular languages like Java, Ruby, Python etc. You were lucky if you saw a Go example let alone an official library. Go seems to slowly be taking its position among the "popular" languages and libraries like this one are a good indication of that. If you do not like it, do not use it but at least realize the importance of its existence. 
It might be a great library! It might even be better than the ones created by third party developers. I won't claim an opinion on that as I haven't tried them either. I'm still hoping someone throws in that counter opinion.
But nil does not point to a widget, so it is not a "pointer to a widget". Right now the type system allows me to have a type that is "either a pointer to a widget, or nil" which is limiting compared to a type system that lets me have a type that says "definitely a pointer to a widget". The point of statically typed languages is to provide guarantees at compile time, so while you may say you're fine without this particular guarantee I'm saying the more guarantees the better. 
....but I like Gin...
I can't for the life of me figure out how more APIs generating Go clients could be cast as a bad thing.
i have the same opinion check the code [here](https://github.com/heliorosa/webscaffold/tree/master/db)
Who said it was a bad thing? That would indeed be silly. I agree with you 100%.
I am not so sure. If you need it, you always got Haskell
Yo dude, chill ✌️ 🎄
And also the creators of Go :-)
I'm all for tooling IF there is a chance that it will be accepted into core language. Otherwise it does more harm than good by fragmenting the community. Look what being ignorant about dependency management did.
Tumblr is the most developer ecosystem friendly social network around. You should support them on that basis alone.
I'm quite sure, and Haskell is not "Go with sum types", so it's not useful for my purposes.
I see
&gt; I'm all for tooling IF there is a chance that it will be accepted into core language. Otherwise it does more harm than good by fragmenting the community. Finally someone that gets it!
I don't get it. Why? (The latest commit message says it was changing the comments to English.. was something broken before that?)
Have a look at: https://github.com/golang/go/wiki/GoUsers Now, I am not claiming that all those companies are using Go to write web apps but even if it is just 10% of them, I believe it's still a pretty good number.
&gt; I can't for the life of me figure out who would use this "As of January 2016, the website had 555 million monthly visitors." "395 employees" "Alexa rank: 40 (December 2016)" If, for your life as you say, you couldn't figure out why people would use this, I imagine you'd be in quite an inescapable predicament.
http://importgolang.com/newsletter/ if you are into newsletters.
Lots of people eat McDonalds too, that doesn't make it good. But the question is specifically about the purpose of using their API for automation, outside of corporate messaging purposes. So far nobody has come up with anything.
&gt; Can you explain what you mean specifically for Go? That article is specifically about Go (though it also mentions C++) and explains "less is more" much better than I ever could. &gt; If that were actually true in all cases, we would be writing programs in Turing machines. Not for all cases but it is true for Go. &gt; I doubt you think nothing new should ever be added to Go 1.7... That is true. I want nothing new to be added to Go 1.X. I want the Go compatibility promise instead. I simply want what Go has been doing all this time. Every new release brings zero (or close to zero) language changes while steadily improving performance. I want Go to keep being opinionated, simple, readable, maintainable and especially [resist the pressure](https://www.reddit.com/r/golang/comments/5j57m6/golang_pros_and_cons_altabel_groups_blog/dbmamaz/).
&gt; So far nobody has come up with anything. Probably because it is as if you are asking "what can I do with an API?". If you want to get data without an API then you have to resort to webcrawling which is just horrible. And of course without an API you cannot easily submit data either, so there's that too. &gt; outside of corporate messaging This is as if you are asking, "If I exclude social messaging, what can I use a social messaging webside for?" `¯\_(ツ)_/¯`
Thanks for sharing this. A few notes, though I'm no expert either: I like Bolt but maybe it's overkill here. Something editable like JSON or even CSV might be more suited. Similarly, you could keep the rules in memory in a simple `map[string]string` where key=extension and value=group. For easy editing, you could store it like this (example JSON): { "Music": [ "mp3", "wav" ], "Archive": [ "7z", "tar" ] } It looks like you're creating the database in the current directory. I'd prefer a user specific file, like `$HOME/.gorganizer.json`. See [os/user.User](https://golang.org/pkg/os/user/#User) and its `HomeDir`. Edit: I'd like to add a feature request :) A flag to preview the outcome without actually moving files.
&gt; Do yourself a favor and write the front end in HTML, CSS and Javascript and write the API that services the front-end in Go. I totally agree with that. &gt; If by web apps you're talking about server-side dynamic generation of HTML, you're barking up the wrong tree IMHO. Not really. I find `template/html` extremely powerful and the fact that it is part of the standard library makes it even better. Just try to write a web app that serves HTML in Java by using just the standard library. I dare you.
I'm not sure if you're looking for code review or just advertising, but if you wanted some light feedback: 1. You shouldn't include the bin directory. You only have the binary for your own architecture there, and `go get` automatically compiles things and puts them in $GOBIN for users. 2. Similarly, you can just put the code in the main repo. Go build uses the name of the directory with package main for the binary name. Putting it in a directory named src will make the binary name become "src"
By file extension? Ever heard of the magic number?
no, just in (i think?) chinese which for english-mostly subreddit is hard to understand
Challenge accepted.
&gt; I'm not sure if you're looking for code review or just advertising Your feedback/code review is appropriate. Advertising a file organizer in /r/golang wouldn't make much sense, right?
Isn't this the first step? Firdt you create static html generation at server side, later, you add the API.
No, I'm not.
What do you think about other web frameworks? While I understand writing web app without framework as explained in the tutorial, I do realize that at the end of day you either use a framework or write your own. What are the specific benefits of Gin?
Excellent stuff indeed. Thank you!
I'm in agreement to an extent (though for different reasons). I've heard some horror stories about the engineering practices at that place, don't expect a castle build of sand to last. Official library or not, how well the API itself works, if it remains backwards compatible or if it's even stable.... I've seen their name come up more than once from different recruiter emails and every time I chuckle a little and reply with a "No thanks". Check out their Glassdoor profile, lots of frustrated software engineers at that place.
It can go in steps but in reality it is a choice. Do you want a web app that renders HTML server side or do you want a web app that consists of an API and a frontend that consumes that API? You can also do both at the same time but then you end up with a huge mess. I've been there and I do not recommend it. Using an API from the very start to get your data and display them in your UI is the way to go in my opinion. Also called dogfooding. Unless of course you are building a small web app where you are planning to never have an API for it. In that case going just server side is fine.
&gt; Challenge accepted. Yeah and remember. Just the standard library. Zero dependencies. No fancy 3rd party template engines like Thymelyf or Rythm. No ants, no mavens. I am looking forward to hear how much "fun" you had doing it. Go ahead, I'll be waiting. 
This is a great update! Upgraded seamlessly from 0.17 to 0.18.
If upgrading from 0.17 to 0.18 broke something for you, now is the time to speak up. A 0.18.1 bugfix release is planned in the coming week. Report your issues here: https://discuss.gohugo.io/t/hugo-0-18-1-a-bug-fix-release/4908
I believe that for the enterprise, big corporations need a standard, a framework, a way of doing things. Java/C# fits very well here. So that´s why I feel Go might not fit in the enterprise world. Comments are welcome.
[removed]
taking a look at this, it seems to be a command-only lib? move forward, back, turn, etc... could you provide some examples of how to read inputs from different sensors? also, the encoders? i see there is a bus imported in the example. is this how one would read input from the sensors?
Thank you for the feedback! I will change the database to a json file and implementing this preview feature, nice suggestions. 
Thank you! Is hard to find Go articles about good practices in code, i am trying by best! I will change the database to a json file, thank you for the suggestion!
I didn`t know about this, i will remove the bin directory and move the code! Thank you for the feedback!
I never heard about magic numbers, just googled that and this is amazing! I will learn about and add as feature to Gorganizer! Thank you for your feedback!
It doesn't run recursively, so if it is downloaded as a folder it won't be moved, and if it is a compressed file it will moved entirely 
`Nothing` is a value, not a reference, so this is not good advice
&gt; I believe that for the enterprise, big corporations need a standard, a framework, a way of doing things. https://github.com/go-kit/kit
Suppresses non-error messages and doesn't add them to the message history. See `:help silent` for more info.
To quote the offspring: Future is now
Can you give me an example of a scenario in which I might use Gorganizer?
Not the author, nor have I used it yet, but an somewhat obvious scenario for me would be to organize files in your browser download directory ?
Exactly i use this to organize my downloads folder.
ive already built a rest api without the framework. thought learning the framework would speed up the development process. I hasn't. iam more into handcrafting my own decoupled systems :) 
I like boosting the global internet retardation. ;)
I've just added a flag to specify the output file, so you can save the resulting meme wherever you want. meme -i brace-yourselves -t "brace yourselves|the memes are coming" -o ~/Documents/Memes/MyMeme.png
My idea of organizing the browser download directory is deleting everything.
There is a content type sniffer built into net/http. Take a look and see if that could be reused as a file classifier.
I'm curious which exercises you're worried about. Maybe it's a good PR for the test suites. A lot of them are ASCII focused, but they also have strict vocabulary or outputs (99 bottles clones for example). Hamming distance is an interesting example since it genomes have a structured vocabulary; a sequence explicitly won't have non-ascii code points. After a quick glance, Bob (one of the text based exercises that isn't implicitly English focused) tests for umlauts. 
&gt;The input for these examples requires ASCII and therefore the solutions can legitimately index the strings using byte offsets. As the old saying goes, "Just because you _can_ doesn't mean you _should_." Particularly when teaching.
&gt; but I would love to see your config file for formatting the bash command prompt. No worries, I'm using [ZSH](https://github.com/robbyrussell/oh-my-zsh) with [bira](https://github.com/robbyrussell/oh-my-zsh/wiki/themes#bira) theme
&gt; req.Header.Set("statuskey", "auth_key_redacted") Probably issue 4800: https://github.com/golang/go/issues/4800 Try Go 1.8 beta 2.
If you want to take your dummy api server testing model further, have a look at hoverfly: https://github.com/SpectoLabs/hoverfly It allows you to record the traffic against a real api, then tweak it to create test cases. It's useful for testing things like delays, weird error codes etc. 
Ideally you'd use a C parser to parse the header in your generator. The pointlander/peg library has a C grammar, and you could probably use it to get the functionality you want: https://github.com/pointlander/peg/tree/master/grammars/c
No idea how extensible is is, but `bindgen` from the Rust ecosystem is wonderful. It generates complete API bindings to C libraries from a header file and includes `#define` -&gt; constant conversions. You might see if retargeting it to Go is as easy as adding some new templates. Been a while since I've done any FFI with Go, but I imagine it would be a useful tool. Edit: link to the repo: https://github.com/Yamakaky/rust-bindgen
Thank you /u/driusan i made all your corrections, it looks a lot cleaner now!
i changed user data to a ini file, thanks /u/bear1728 
i can create this option on Gorganizer hahaha
Ive lost the link. But this github is the posters implementation of a dropbox blog about password storage from a week ago.
Yes the source link is in the bottom of the GitHub 
Is there a way to list currently available memes?
This looks very much like [Avro](https://avro.apache.org/docs/current/), which I've always liked as a nice middle ground between "here's all your field names, 20 billion times" JSON and "hope you like codegen and inscruitable binary" protobuf/thrift.
You can debug this easily in Python using `requests`. `requests` preserves headers and also sets appropriates cookies based on the headers returned by the previous request, but Go won't do any of that. &gt;&gt;&gt; import requests &gt;&gt;&gt; r = requests.get('https://ourapp.com/status', headers={&lt;your headers&gt;}) &gt;&gt;&gt; print r.url # print final URL &gt;&gt;&gt; print r.request.headers &gt;&gt;&gt; for h in r.history: print h.request.headers If some sort of redirection is happening(based on the Location header returned by the above URL) then the above program will print `https://ourapp.com/status/`. You can also check the complete redirection history using `r.history`. In Go you can do something similar by defining your own [`CheckRedirect`](https://golang.org/pkg/net/http/#Client) function and printing the headers being sent with each redirect.
I had written such a script in Python, a long time ago. Thanks for sharing :-)
Check out https://github.com/evmar/gocairo for some code that follows this strategy, using a golang c parser.
It seems to work if you do `c.Path = "/"`, but according to the docs this is optional, so I have no idea why you have to do this... Is Go setting Path automatically to your subpath and not / for your cookie perhaps? I'm not sure. 
&gt; I tried posting to the IRC channel but it was a dead. Try https://invite.slack.golangbridge.org/. &gt; If you're too lazy to try it, the error returned is "named cookie not present". You need to configure (http.Client).Jar field before issuing requests (e.g. to the result of cookiejar.New()), the default http client does not pass cookies around. 
He's passing them around through his browser, he doesn't need an additional cookie jar.
When writing web apps, I usually implement the API in Go which accepts JSON and manually validates the fields server side. The forms only exist on the client side and any additional validation happens using HTML and Javascript.
`meme -help`
This is definitely not a bad idea, I'll probably hook this into my project. However, I recommend to put this under a license, atm this is basically proprietary code I can't use. :( I think it would also be neat if the library offered an Argon2-variant for a more modern variant parallel to the bcrypt-variant, but the library should be a good template and easily implementable over it.
That's exactly why Go isn't simple nor easy. Also can't see how these "rules" are easier to deal with than mutexes. Apparently took some time until someone came up with this list.
Generating Go constants from C enums and #defines could be probably done using [github.com/cznic/cc](https://github.com/cznic/cc).
+1 for gorilla/schema
I'm just learning Golang. Is Go the wrong language for web development (probably), or is the philosophy around Go wrong for web development? In Java, you'd pick from a myriad of frameworks. Each provides some form of binding. This is handy, but none solve a full trip worth of validation. 
[removed]
Thanks! I'll poke around.
You can write leaner apps (in terms of stack depth and memory usage) on jvm. But most of popular libraries are heavy. 
Thanks for the feedback, License MIT added, I'm planning to add support for Argon2 
&gt; A waste of time time to read Why?
Thanks a lot!
If I am understanding your question, the following should playground example might answer it. https://play.golang.org/p/GETLz1LgU8
the idiomatic way would be to do something like func MakeThing() (thing, error) { t := thing{} if condition { return t, errors.New("this is an error") } return t, nil }
You can't expect a meticulous comparison when the author doesn't even bother to write "I" as a capital i.
&gt; And for all of them, why not just "mixer.Unmix()"? mixer.Unmix() (no args) likely does not hold the required dependencies, at least not obviously. This emphasizes the nature of the question for me. It's not as general of a question as I first took it to be; It seems to be about how OO the API should be, if at all. In that line of thinking another possibility is to call mixed.Unmix() ... My current thought is that any answer to this question, as it is now, would be assuming too much about the rest of the package (it's intent, scope, etc.). Flesh it out and use it. See what's comfortable as it comes to light.
I think you are 100% correct. In any event, setting path to / makes it work just fine. Even from other subpaths like localhost/apple with a different handler func the cookie still shows. Thanks a bunch.
Oh, you're right.. I misread that as the same variable name passed multiple times. If anything, it should be mixed.Unmix()... Side note: this is why you should try and make your variable names vary by more than 1 character..
[Command-Line written in Go, GitHub](https://github.com/search?utf8=✓&amp;q=command+line+written+in+go)
Not an excellent read as others point out. As a Golang and Scala developer (and Python, but that's another story), I don't usually compare one against the other, since I use them for different use cases (although, they share the strong typed area of what I don't use Python for, yikes). A point for Scala, its type system is awesome, and nowhere can Go beat that (and it does not aim to, anyway). If you don't need that level of type power and need good concurrency, Go is a much, much better choice. 
That's neat. I like that the strategy of using ``` type ProcessPayloadFunc func(payload interface{}, header Header) ``` as opposed to the approach go-github takes here. I might look into using this package in the future. 
Any reason for not using existing software? Like https://github.com/adnanh/webhook ?
That's certainly an option. I found it more flexible to process the payload on my own and interact with other systems from within the same daemon. In some other scenario I might've opted for a general solution. In the end, the hard part is not accepting a webhook and decoding some JSON, but deciding what to do with the data afterwards. 
This is a case of comparing apples to oranges. You can't compare a byte-code interpreted language that runs on a VM to a binary executable. This is on top of the fact that Java, Scala, Go - each have their own use cases and places where they shine.
I've often found the opposite to be true. Simple solutions tend to be very fast and robust, but finding a simple solution takes time.
Excellent point. This idea that a programmer should only use a single language is ludicrous. It's like a carpenter saying he's never going to use a Phillips head screw driver. Languages are a tool. Use what's right for the job. I certainly love Go, but Scala has its place. So does C, Java, Perl, and so on. 
Idk. E.g. in parsing, fast solutions are far from simple. Try a simple problem like string matching: is string `a` a substring of `b`? The naive solution, readable as it may be, has an O(|a|·|b|) complexity, but it can be done in O(|b|). That solution is however not simple. If you get to more complex problems, the efficient solutions become rather math heavy.
Nice, but you might as well filter by language, rather than relying on project having "written in Go" in description. https://github.com/search?l=Go&amp;q=command+line&amp;ref=searchresults&amp;type=Repositories&amp;utf8=%E2%9C%93
https://github.com/simeji/jid
That's a legit analogy too. Point is that a comparison between clay and granite to declare one the best sculpting medium period would be silly. You've got to consider the intended usage. Same with programming languages. Imagine someone writing a comparison between COBOL and JavaScript, and then concluding that COBOL is a bad language, because it doesn't give you access to the DOM. 
&gt; What does a package author do if he wants to improve his project in a way that breaks backward compatibility? Create a new repo? * You can use: http://labix.org/gopkg.in * You create a new repo. * You just don't. Stability is much more important. Being able to compile my programs with every new Go version (and not only they just work, they get faster too) is pure bliss. And all thanks to the Go 1 compatibility promise. Usually this is also the case for go packages but obviously not every developer out there can be trusted. Still, having this culture of not introducing breaking changes is very good. &gt; If it's a few sentences to describe vendoring your dependencies, would you mind explaining that? You simply copy all the .go files of a dependency package under the `vendor` folder of your project. Then you can simply import them in your code and Go will find them as if you had gotten them with `go get`. This way you can ensure that the dependency will never break your code since you keep a local copy of it in the `vendor` folder. There are many tools that make that procedure easier but you can always do it yourself manually. The tool I usually use is [gvt](https://github.com/FiloSottile/gvt). The vendor committee is working on making an official tool.
I've made some modifications to the bluele/gforms project and had some of my own changes rolled in. It does make a couple of unusual decisions in form building idiomatically, but it's not completely wrong either. As far as capturing how either django-forms or wtforms does it, it seems to have missed the mark somewhat, or at least isn't thorough in the approach. In part this is a limitation of Go itself (metaclasses what now?), but in part I think the library just hasn't had enough development on it. I've already got a [fork](https://github.com/gavbaa/gforms/tree/using) with some new field types and additional validation support for form-wide validators, and am considering breaking it off into a new project to take another stab at the overall data structures, improve access to validation and so on, the same challenges you're struggling with.
Fair enough, the js target is much more feature complete and seems to be usable, while the native target is not particularly stable/complete. Some of what I was saying was just because I find the effort interesting.
Totally valid. I also think those efforts are interesting. 
&gt; https://golang.org/pkg/regexp/#Regexp.FindStringSubmatch &gt; A return value of nil indicates no match. And you don't check for nil [here](https://gist.github.com/j0holo/d3ab4c33cd33305acd20e99f24d04029#file-ufwlogreader-go-L65).
What is it you like about the Scala type system? I'm curious for your perspective as Go and Python are the languages I've worked the most with. 
See the list on the cobra library README https://github.com/spf13/cobra/blob/master/README.md
thanks a lot i will :)
thanks for your time
There are many times when you have a choice in Go; do you throw safety to the wind, or do you write weird or overly verbose / repetitive code to try achieve some kind of safety. With Scala, you rarely have to make that compromise, you can express a lot of things extremely safely, in a way that allows the compiler to do far more work for you (I mean, you can tell... it does take a long time to compile Scala code). Honestly, this has to be one of the things I dislike about Go the most, and that was after having come from Scala. I just loved being able to write a bunch of code for ages in my IDE without running it, and having no red lines under any code, and being pretty damn confident it would run and work.
Doh, I compared it as a string not as a string array. Just tested it in the go playground. Will test it tommorow in my program, thanks anyway.
&gt; and use an already well equipped .js frontend framework to handle forms. What do you mean by that? Any frontend validation needs to be backed by backend validation too. This requires implementing and maintaining the logic twice.
I was already using IntelliJ with the Go plugin, and am eagerly awaiting a stable release of Gogland. I had a feeling it was in the works. They are seriously awesome IDEs.
It's true that these are a bunch of micro benchmarks, but I haven't seen any production environment benchmarks between Go and Java, so I have to go with what data I have. In other words, I've yet to see anything indicating Java has an overall upper hand on Go in performance, I think they are very much in the same ballpark (same goes for C#).
Have you seen [Bluejay](https://github.com/blue-jay/blueprint)?
well simple ≠ trivial, some of those simple solutions take complex thought to achieve, which in itself takes effort to get to and understand if you need to maintain it
Shameless self promotion: [http-spec](http://github.com/tmornini/http-spec)
Bunch of hot air. I love Scala, I'm learning Go to pad my resume and dab in it, however can't replace the benefits of the type system. Love love love Scala! Hate Java. It's verbose it's ugly, and Spring is bloated, never learned it. Akka + Scala = happily written code that makes me productive and makes me money! As an engineer nothing beats that. 
Do you have evidence of this? I'm going to write a chunk of micro services, then a few gateways and then a web front end on that. I thought that Golang might be a good thing since I'll need 7 micro services. The JVMs would take up about 350 MB standing still. Golang should weigh in at 35 MB total (random guess).
I usually find myself doing this: func MakeThing() (*thing, error) { t := &amp;thing{} if condition { return nil, errors.New("this is an error") } return t, nil } When is it appropriate to use each case?
I love the anecdote from https://probablydance.com/2016/11/07/lessons-learned-from-shenzhen-io/ By searching for the super fast solution he found the simple/elegant. Of course it takes a few iterations to get a new perspective on a problem, which we cant afford in most day job code.
Wow TIL. Google should change the name anyway, Go is inconvenient to even search on the web lol
Good catch. Luckily, cropping an image to zero width or height is rarely desired. (That's why the bug may have slipped through. Alas, the repository seems to have issues disabled.)
Sure you can. They are equal enough to be substitutions of eachother, and therefore very comparable.
I'm reading a Reddit link to a Twitter post of a Hacker News comment. Is this the future of journalism?
I could have linked directly to the Hacker news comment but I thought I'd attribute the twitter comment.
Agreed, but users are unpredictable. BTW I wasn't trying to criticize your code - I was mostly curious because I know fuck all about image manipulation.
It's way more expressive than Go's structs (which I like a lot for its simplicity). Type inference with implicits makes for some compile time magic. You can fake subtyping in Go with interfaces, but it gets unwieldy if you have something moderately complicated, Scala can get as unwieldy as it needs too while keeping readability and ease without a hitch. Case classes and pattern matching also make for some niceties in readability that Go loses on. Either/Option types beat `if err != nil` any time (even if they are more or less the same, syntactic sugar is cool from time to time). A downside, compile times are horrible (specially compared to Go, and more if you use a lot of automatic type inference or long implicit chains) and sbt as a build tool is a little bit unwieldy (I call it Scala Burns my Trousers, usually).
I've certainly observed a huge difference in the friendliness level of this sub versus other language subs, like /r/rust and /r/python. There's a lot more dismissal, unconstructive criticism, and unexplained down-voting here than elsewhere.
This should be voted to top. Question is most basic one, good reading of manual should solve it along with a lot of other things new Go users could get stuck with. There is no replacement for learning from docs in correct order. Knowledge is layered, if you lack good foundations then process will be slow and frustrating and final products will be bad. 
Wow, Community Code of Conduct must have saved the day once again! Oh wait... May it be, may it be, the problem is not the lack of moderation, but the general attitude towards any sort of constructive criticism? My favourite "40 years of computer science is impractical; academia knows shit" trick never gets old!
My goal is to have a friendlier community. The CoC is one way to explain to people what a baseline for "friendliness" and "politeness" might look like. In some cases having the CoC isn't helping. But it's a big leap to say "People are jerks *because* there's a CoC so we should get rid of it." This isn't the first time I've seen the Go community accused of having an attitude problem. I do belive it is something we should fix. If you have any concrete suggestions, let's talk about them.
any sort of constructive criticism? i don't think so. sarcasm isn't necessary in order to make a constructive argument. its one thing to come off as a "progressive" thinker, another to come off as an ass. mutual respect should not be taken for granted.
Which one do we submit to /r/programming? 
If you're into Linux ricing I wrote [dfm](https://github.com/chasinglogic/dfm)
There's also a huge difference in friendliness between this sub and other Go language communities(slack for example). This subbreddit needs a lot of work, and I don't envy the new mods, even though they're some of the more exemplary members of the community. 
I'm amazed you say everything you post has you feeling like you're about to violate the CoC. Can you point to which sections in particular? Do you feel others are similarly restricted or is it specific to your communication style?
Yeah. I can just say that we're aware and working to make it better! Please help us out by being the change you wish to see in the world :) As well as being liberal with reports.
&gt; And if people can react with "Awesome" or "great article" then I should also be able to say something that's negative in a succinct format such as that w/o having to argument it. We're actively trying to improve the tone of this subreddit. So, please don't. Thanks :) 
So we are going to have to post only positive comments but shut up and down vote otherwise? If you want to improve it then make the rules equal for all, not just for those that don't fit a certain blueprint. I'll probably start using aliases from now on, thanks for the heads-up.
Criticism is great! Just do it constructively, kindly, and substantiate your opinions. Simple stuff 👍
Thanks for your advices. My question was more how do you do than how should i do. And definitely not if Go is the right lang for that ! I know that Go is not the right tool for this part but this part is not difficult is just boring. But i think even by hand we need some useful helpers and I see that most of you are doing the same, grab one helper here and there. So I'll continue this way also. I like tools like sqlx for example, it doesn't go in your way and keep you near the metal. But I understand that for html form there is so much possibilities that it's quite impossible to be simple and handle the case for everybody.
Thank you for taking the time to explain this. :)
Whoa! Awesome! What editor do you use?
I think simplicity is very difficult to "sell" but easy to "attack". We've seen the same problem with unix from where came the term RTFM, isn't it ? 
ranger clone: https://github.com/gokcehan/lf
This is neat. Why is there no .go extension listed for file extensions of Go, while C has .c, .h, .o? Is that a mistake?
we're on our way to a better community now that /u/dgryski is moderating here...but that won't change the dismissive and condescending tone of the core group, which I now accept will never change also agree with others here that a CoC was mostly unwanted and universally ineffective anyway...just another tool for the core team to elevate themselves above the hoi polloi
if anything, the CoC debacle exposed many in the community plainly. I now want nothing to do with Cheney and Gerrand for example, and frankly wish they would just move on
Indeed! My introduction to Linux was so off-putting that I found the only way to get answers was to say things like "Windows is so much better than linux because of X". The responses were usually along the lines of "STFU NOOB LINUX DOES THAT HERE'S HOW", which was rather rude, but often got me actual information. Fighting fire with fire, sigh....
That's really slick. But it's pretty shameful that a huge site like Medium can't even get a simple form to be accessible.
you can tune jvm memory (Xmx, and gc options). There are many web servers that run with less than 35MB ram. Search for android and raspberry pi targeted servers. If memory allocation during idle period is an issue, use php or cgi. I'm not saying you should run your microservices in jvm. Just use golang, or node.js. Whatever your team is comfortable with. (don't use node.js seriously)
Great initiative. Thanks
CockroachDB, etcd and dgraph as well.
I'm curious what you mean by "exposed plainly".
How does having a code of conduct elevate the core team from the hoi polloi? 
Excellent reference. Thank you. 
[removed]
Thank you very much for all kindly responding to me.
code of conduct rule #1: always act with mutual respect what else is needed?
You can't for certain say something is allocated on the stack or heap in go. If a function returns a pointer to either of these // memory allocated on stack: var i int // allocated on stack; type inferred from literal: j := 3 It wont be on the stack. 
you are doing a good job but honestly maybe we should stop talking about community in these posts and just let it happen (or not)
I agree, that part is incorrect, or at least misleading. Stack vs heap is pretty much an implementation detail in Go, and you don't generally need to care in most cases.
https://github.com/boltdb/bolt 
This seems like a consequence of Go's principles stance on simplicity. Other communities are more eager to experiment with new features, and consequently need to say "no" less often. Still, I agree that Go needs to do more to be positive and respectful; I think we can do this without affirming every ill-conceived suggestion. For frequent feature requests, it would be helpful to politely explain that said feature has been debated thoroughly, but not implemented for various reasons before linking them to the doc that explains in more detail.
Given that I don't know what exactly your library does, my guess would be that (2) should be your choice.
While this was my tweet, I did not post it to this subreddit nor was I the first to shift discussion towards CoCs. What should the the job of the moderators be in your opinion if not to guide discussions and set the tone for the rest of the members. If you advocate a completely hands-off approach, why even bother having mods at all?
Regarding the issue of the server stop not working on Windows, you should be able to check `os.platform() == 'win32'` and if true, use `spawn("taskkill", ["/pid", startCmd.pid, '/f', '/t']);` to kill the server process. I haven't checked this as I'm not on a machine with node installed at the moment, but I think it should work. If you like, I can test it and send a PR if you don't have access to a Windows machine. EDIT: [I've created a PR](https://github.com/akmittal/hugofy-vscode/pull/1) . Seems to work on Windows 10, but you may want to double check functionality on other platfortms in case I've accidentally broken something with a typo!
&gt; // cannot be stored in numeric or string variable: &gt; nil And bool and struct too. &gt; include "math" in sqrt for go 
That is crazy if you don't mind me asking have you always been blind or did you learn to program before you went blind?
We've built a highly distributed, highly available database suited for writing a ton of data and reading all of that data at least once. It's entirely written in Go and is going to be open sourced though isn't 100% complete yet. So yes, Go is quite capable of building databases.
You'd be surprised at how much of the industry ignores accessibility. In fact, I'd say the gaming industry is actually the leader in this area... which is saying a lot...
What are better orms that your recommend? Sqlx? I'm tired of fighting gorm. 
&gt; If you advocate a completely hands-off approach, why even bother having mods at all? In a word: spam, spam, spam, spam, spam, spam, and spam.
Well, it's still in alpha, really, but we just moved our [reign-based system](https://github.com/thejerf/reign) to production at work. I haven't done my cleanup, test coverage, and documentation pass yet, though. But it's basically Erlang-style clustering for Go.
https://twitter.com/dgryski/status/794457923040714752
File a PR against the gopheracademy-web project. Instructions are in the Readme linked from the spreadsheet. 
Thanks. The github link: https://github.com/gopheracademy/gopheracademy-web
Thanks for PR I will check.
If Rust can get C level performance with `ASLR/PIE` turned on, why does golang need it off? (I don't know what `ASLR/PIE` is, this is probably a naive question!).
There's nothing you shall fix — moreover, I'm afraid there's nothing you CAN fix. Go language community is a cult and has all signs of a cult (worshipping, opposing critical thinking, doubt and dissent are discouraged, the leadership dictates, sometimes in great detail, how members should think, act, and feel). You shouldn't be surprised to see the community being treated like a cult and definitely must be expecting Go community members using aggressive defense mechanisms against people who "doesn't understand it" or use "dated patterns". You can't do a thing. Maybe you could somehow transform the community, but you must understand that it's very hard to rescue someone from a cult, especially from a Google-powered cult with leaders such as Rob Pike. Regards good ol' morale, I fail to see how CoC can be even remotely helpful, especially on Reddit, where we have a thing called [reddiquette](https://www.reddit.com/wiki/reddiquette). I guess we should focus on technical discussions and figuring out how Go could be a better thing rather than witch-hunting people for thought crimes.
Have a look at [gam](https://github.com/AsynkronIT/gam), which is an Actor Model implementation in Go. Work on clustering is in progress, and it already supports remote actors. Another goal, given it uses protocol buffers for message serialization, is cross-platform actors.
Is there a reason string formatting for Go wasn't included, while the C counterpart was?
&gt; I like to avoid returning nil when possible because it removes one extra check or one extra error that can be introduced. In practice we have to check for the error anyways so the check cannot be avoided. I still cannot figure out when to use what though. Most popular Go code I see on github returns pointers. I suppose they have a good reason for doing it but it is not obvious to me.
Interesting question, over half the time on my box is spend in GC related activities (goofing around with GOGC=off more than halves the time). But, it does seem like a solid naive implementation. I wonder what could be changed to lessen the GC pressure a bit. 
It also cant show pictures offline.
Except the stupid case of no error but still return nil :(. And yes, I have seen that before. And the reason they return pointers is because the structs probably have methods that mutate them so you want a pointer. 
&gt; Except the stupid case of no error but still return nil :(. That is tricky yes but if you are the one writing the code, you should never allow that case. &gt; And the reason they return pointers is because the structs probably have methods that mutate them so you want a pointer. Are you sure about that? I don't think there is any relation. My best guess is that they return a pointer to allow for the same object to be reused.
&gt; $ git clone https://github.com/onerciller/go-chat $ go get github.com/gorilla/websocket $ cd /go-chat $ go run main.go Are you sure a simple `go get github.com/onerciller/go-chat` is not enough?
Wait, what? How are you able to use a PC if you're blind? I'm sorry if it's a somewhat unrelated question and no offense meant, I'm just extremely curious. I have thought about what I would do if I were blind, since basically 90% of my interests are tied to PC.
From what I know, there is a special terminal that outputs Braille and there is also Text-to-Speech for most things. Atleast, that was state-of-the-art when I last heard about it.
I personally prefer using a code generator, xo in this case. When I add new tables, I run the generator again. I keep changes in seperate files so that I don't have to worry about the generator overwriting things. It allows me to quickly generate 90% of the code and write the 10% of custom code than I need. ORMs tend to give you a shortcut for the 90% and make the 10% very very hard while Generators make you the 90% and allow you to write the 10% using standard library code.
I have always been blind. That has made things much simpler. I have shared my [autobiography][] and [the tools I use][] on my blog. I'm really glad you are curious about this! :-) [autobiography]: https://www.parhamdoustdar.com/2016/03/27/autobiography-blind-programmer/ [the tools I use]: https://www.parhamdoustdar.com/2016/04/03/tools-of-blind-programmer/
Yes. When you are presented with a badly-written code in any language, it sucks. Perl is just more permissive in allowing you to do whatever you want. Maybe that's why I love Go. There are less ways to do awful things. It's not impossible it's just harder.
No offense taken. So, you can use the computer without sight. In fact, I've written about [the tools I use][]. I think reading that should give you a pretty clear idea. Of course, if you have more questions, I'd love to answer them. [the tools I use]: https://www.parhamdoustdar.com/2016/04/03/tools-of-blind-programmer/
Thank you so much dear. I will review it detailed as soon as possible. I say again that all pull request is welcome. :)
Changelog has a Go-oriented podcast called Go Time. IMO it's pretty good. https://changelog.com/gotime
The Alioth shootout is Lies, Damn Lies, and Statistics material. The results are — generally speaking — non-deterministic (e.g., suboptimal runtime settings on JVM that lead to non-repeatability) or specious (e.g., measuring the performance of Go, Ruby, or JVM callouts to native C libraries). I wish folks would quit citing them and formally label them harmful; they lack methodological rigor.
I'm not 100% sure right now, but try `go get -u ./...` in `$GOPATH/src`, after `rm -r $GOPATH/bin`.
I have this in my shell config (zsh), so upon go upgrade or simply when I got a new computer, I just run the function: function update_go_tools() { packages=" github.com/ajstarks/svgo/benchviz github.com/axw/gocov/gocov github.com/cespare/prettybench github.com/dougm/goflymake github.com/golang/lint/golint github.com/josharian/impl github.com/kisielk/errcheck github.com/kisielk/godepgraph github.com/nsf/gocode github.com/tools/godep github.com/rogpeppe/godef golang.org/x/tools/cmd/... " echo $packages | while read pkg; do echo "$pkg" go get -u $pkg done }
Note that the reverse is also true; `new(int)` will be on the stack if it doesn't escape. E.g. https://play.golang.org/p/WinyxmBSOl
Mainflux is intended for industrial cloud solutions, but it can be run on Raspberry Pi. Currently Mainflux Core service (https://github.com/mainflux/mainflux-core) can be run with only MongoDB as a dependence, but I guess even this can be changed to in-memory persistence for use-cases where no multi-user, HTTP-only and single binary solutions are needed. But yes - use-case of multi-user multi-tenant multi-protocol Industrial IoT cloud imposes some complexity and best approach was to break it into micro-services.
huh. I didn't know that. Thanks!
I've run into something like this when in a project that uses C bindings. For some reason, guru can't handle packages that import "C". [There's an issue for this](https://github.com/golang/go/issues/15710), but no milestone assigned since guru is an "experimental" package....
You could use a [Bash array](http://stackoverflow.com/questions/8880603/loop-through-array-of-strings-in-bash-script) instead of a string to save from echoing and trimming new lines. 
If you'd have Go binaries in $PATH but no sources locally - you could use gobin to update all of them. go get github.com/rjeczalik/bin/cmd/gobin gobin # lists Go binaries gobin -u # updates them Disclaimer: I'm the author of the tool.
&gt; Please use tags in your html page if you want search engines to index your info. What do you mean? Sorry, I have some silly automated jekyll site that I basically do not touch, as I have 0 understanding of HTML/ JS.
Oh, I did not understood your comment as a negative criticism, on the contrary. I think every comment here is beneficial, as it discusses more deeply the problematic. IoT interoperability is hard to obtain, and today practically impossible as there is no prevailing standards. There are efforts from many bodies, we'll see who will win. Mainflux is actually a very low layer middleware, that just enables a secure connections over different networking protocols, makes a bridge between them for IoT messaging and does device management. It is not ment to make Philips Hue talk to Belkin WeMo. And it is not really oriented towards end users - it is more intended for producers and IoT system designers - in this case Philips or Belkin, or Samsung, or any startup that makes connected objects. In every IoT system that you need this block that does connection enablement - an IoT server that your firmware embedded in the device will target, connect to and send messages to. On the northbound side application connect to this middleware block and can consume data that came from devices. In this sense Mainflux is somewhat similar to Amazon AWS IoT or AT&amp;T M2X. For your simple home-automation use-case I guess NodeRed or FloGo (http://www.flogo.io/) can be interesting. Or Python based HomeAssistant (https://home-assistant.io/) which has a lot of extension to interconnect these existing devices.
This is a good post, but the author should give credit to Rob Pike and Dave Cheney for making this pattern popular. https://commandcenter.blogspot.com/2014/01/self-referential-functions-and-design.html https://dave.cheney.net/2014/10/17/functional-options-for-friendly-apis 
Is there any symlinking going on? I had to give up on them because vim-go's tools don't work well with them.
Maybe how to add a column to a table? Or how to add a new table?
The check env then fallback is perfectly fine with me, though I prefer failure over fallbacks like that.. at least when my env is setup properly things work. Thanks for looking into it!
If you want asynchronous execution spread across nodes use queues.
 cd $GOPATH go install ... This will not re-download, but it will recompile what was previously downloaded.
Take a look at this, its weird: https://youtu.be/zM5qkW1aO98 Note: The recording tool didn't capture rightclick and autocomplete windows. I can see the const "hello" listed in the autocomplete window.
Ok, I think this needs to be solved by the guys from JetBrains. Can you please open an issue here: https://youtrack.jetbrains.com/issues/Go and add this movie + some more details such as OS, which font do you use and anything else that might be useful? It's definitely a strange one. Thanks a lot!
That was it... Changed the Editor &gt; Colors &amp; Fonts &gt; Scheme from "Dracula" to "Dracula - dlsniper". Don't know what's the difference between those two but the first one is always buggy for me
I've been using it quite a bit in the past week. Despite the fact that it's still in the early access program I'm really impressed- it's quite polished and I've encountered fewer issues with it than some other ides either tailor made for go or with go plugins. My biggest issue at the moment is getting used to manually triggering a code reformat- it doesn't seem possible at least at the moment to have their own reformatter run automatically on save like I'm used to with gofmt. But they're doing pretty well if that's the biggest issue their pre-release software has!
Oh, that's strange, the color scheme should inherit from Darcula. And yes, that's me :D
I think best way to debug is to call `guru` from terminal or change the command to `godef` (See the vim-go docs for more info). Also `guru` right now doesn't allow to use `guru` on packages/files that are outside `GOPATH`. However I think there was an open issue and Alan wanted to tackle it. If you still have that problem feel free to open an issue on vim-go tracker with a reproducible case and I'll take a look :)
This sounds obvious (and ubiquitous), can you be more concrete?
I'm on the phone so I can't look it up, but there also an implementation of the HTML5 parser, which is really the definitive answer to that problem now. Beautiful soup is a great library, but predates the HTML5 algorithm by many years, and is therefore it's own quirky thing, whereas the HTML5 parser should actually be consistent with other such parsers.
Watch this: https://www.youtube.com/watch?v=2r_KMzXB74w&amp;index=20&amp;list=PL2ntRZ1ySWBdliXelGAItjzTMxy2WQh0P
Is `github.com/gorilla/mux`initialization an example of the builder pattern? r := mux.NewRouter() r.Handle("/api/v1/users", createUserHandler).Methods("POST").Name("create_user_handler") 
Official go documentation is good, as is "effective go". Read "effective go" frequently, it has some subtly important points that become more clear the more code you write. Read the godocs for the standard library. Use go vet.
Libsodium is perfect for you: https://jedisct1.gitbooks.io/libsodium/content/ The short version is that developers should almost never be using functions like AES/RSA/SHA256 directly. You should use a higher-level function that smarter people have written. Whilst libsodium is for C, the documentation is excellent, and the specific functions are found in Go. For example, for Public Key Authentication, libsodium uses crypto_box_keypair. These functions are available with slightly different names in https://godoc.org/golang.org/x/crypto/nacl/box, or you can use a libsodium wrapper from https://github.com/GoKillers/libsodium-go 
How does this compare to https://github.com/mattes/migrate (which I've used happily for a while) ?
BS can use several different parsers. Pretty sure there are a couple of html5 options in there. 
**size of code base:** pgmigrate: 451 LoC migrate: 2440 LoC **dependencies:** pgmigrate: none migrate: github.com/fatih/color github.com/go-sql-driver/mysql github.com/gocql/gocql github.com/gocql/gocql/internal/lru github.com/gocql/gocql/internal/murmur github.com/gocql/gocql/internal/streams github.com/golang/snappy github.com/hailocab/go-hostpool github.com/herenow/go-crate github.com/lib/pq github.com/mattn/go-colorable github.com/mattn/go-isatty github.com/mattn/go-sqlite3 golang.org/x/net golang.org/x/net/context gopkg.in/inf.v0 **other** * migrate does not allow you to set the schema for your migrations table. This means it will probably end up in your public schema (depending on your search_path). pgmigrate allows to configure the schema, und uses its own schema for its table by default. * migrate does not allow you to set the name of your migrations table. pgmigrate lets you do it. * migrate uses 1 transaction per migration. This means if you're trying to migrate from version 1 to 3, it's possible you'll end up at version 2 if version 3 has an error. pgmigrate uses 1 transaction for all migrations, so if you're migrating from version 1 to 3, you'll either end up at 3 or stay at 1, nothing in between. * migrate does not verify that your migration files have not been modified. pgmigrate does. * migrate provides better error messages in case of migration failures (column and line number). pgmigrate doesn't do this yet. * migrate provides a powerful CLI tool. pgmigrate doesn't and I have no plans for adding one myself. IMO migrate is definitely a good library, especially if you have to maintain projects using multiple databases. But if all you care about is postgres, pgmigrate might be worth considering.
Nice! But how does `gobin` determine the right source if there are multiple possible projects with the same name in `$GOPATH/src`? Like, e.g., `github.com/author1/mycmd` and `bitbucket.org/author2/mycmd`.
That's a good idea, with a small caveat. If there are multiple projects in `$GOPATH/src` that install a binary with the same name, the last one that `go get` processes will win. (And this might not be the one you want.)
Ah, that's the trick! Didn't know that Go binaries include source import paths.
Meta tags should help with search engine queries. But other than that, Google, Yahoo and Bing are perfectly capable of indexing Go and Rust if word programming (or language, or library) had occurred in the text. 
I wrote a similar tool in Go, which requires something to call it (in my case, bash)... The benefits are: it doesn't go inside dot folders, it doesn't consider the vendor folder either and the search is "organized", meaning it will traverse the directory tree going deeper every time, which is a problem with some solutions out there, since they prefer to have a faster solution but it will always lead you to an inner folder in a structure where a subfolder has the same name as the parent. https://github.com/patrickdappollonio/find-project
Thanks, glad to hear this! As a small word of warning - Mainflux is still young project. It is usable, but not all parts are stabilized yet (there is ongoing work on security schemes, for example). Using it will probably demand some effort, but is intended for IoT system developers and integrator anyway, and there are community channels over which you can ask for help. I think however that it is already a good staring base for building more complex IoT soultions and that at the present state it becomes manageable (although not ideal yet).
Nice! This morning I got fed up (and finally decided to do something about it) and just whipped this up in a few minutes.
NaCl or Libsodium. Chacha20 and Ed25519 are almost foolproof crypto if you don't do anything obviously idiotic. I severely recommend to learn atleast a bit about crypto and the common pitfalls.
I'm not sure if this tool would work correctly. Gopaths can contain several folders seperated by `:` which as this script looks would cause some havok.
+1 for the Go Tour. In addition, the official [Go blog](https://blog.golang.org) has tidbits that explain concepts and idiomatic use. If you're looking to make a web application: * [Writing Web Applications](https://golang.org/doc/articles/wiki/) (Go official wiki) * [Go Web Programming](https://www.manning.com/books/go-web-programming) (Manning Books) rakyll's blog, [go bits](http://golang.rakyll.org/), is a more advanced resource.
:) glad to know I wasn't the only one to realize this ...maybe great minds think alike... and it turns out to be just as, if not more, performant.
I am interested OP. Let me know how do I begin
Is that common though? I don't think I've ever seen multiple paths in GOPATH.
so what? it's still not correct.
Another popular one: https://github.com/cockroachdb/cockroach
I just create a symlink to my go github user directory. So cd ~/dev/go takes me to gopath/SRC/github.com/username where all my projects are. Handy
Nice, I always forgot about this one. &gt; If a non-empty directory name from CDPATH is used, or if - is the first argument, and the directory change is successful, the absolute pathname of the new working directory is written to the standard output. So, to avoid the printed-pathname on directly descended directories, one would have to set this instead: export CDPATH=:$HOME:$GOROOT/src:$GOPATH/src:$GOPATH/src/golang.org:$GOPATH/github.com: (removed the initial ".")
I use multiple GOPATHs, yes. There are a few others and it should be considered a bug and fixed eventually as multiple GOPATHs are part of the specification. Not implementing the specification would be a shame and leaves out potential users.
May I ask why? What is the use case here? Why is it preferable to the alternatives? 
If you are using zsh and oh-my-zsh, you can get the same behaviour with: setopt auto_cd cdpath=($GOROOT/src $GOPATH/src/golang.org $GOPATH/src/github.com $GOPATH/src/bitbucket.org)
Cool, thanks. 
You're ranging over the indices not the values. Use the two-valued form of the range.
I try to vendor things, however, not all libraries I download are using vendoring and not all of my projects use vendoring either. Plus it keeps the duplication among projects low.
&gt; not all libraries I download are using vendoring True, that's why I use [gvt](https://github.com/FiloSottile/gvt), a *very* minimal vendoring tool. You run it on your project root, like this: $ gvt fetch github.com/vendor/package and it downloads both that package *and* it's dependencies, recursively into `vendor/` and deduplicates them. That way, you get to keep a clean `$GOPATH` and you can use everything that's go-getable, even if they don't vendor their deps.
I personally use `govendor`, it's much more versatile than most other vendoring tools. But as said, I don't vendor everything, for quick development it's IMO better to put things into the gopath, setting up vendoring for a 5 minute project is not worth it tbh. Plus some of the libraries bring along some binaries I need to use, like gvt, so they don't go into my projectpath either.
FYI: https cert error on mobile (android). 
&gt; [I]'m looking to add encryption to a project [I]'m working on and i know little to nothing about encryption. Don't expect it to be secure and more importantly don't make any claims that it is secure. Encryption solutions fail not because of the underlying math (e.g. AES) but because of implementation flaws. If you are not a cryptographer the chances of using a low-level package like [`crypto/cipher`](https://golang.org/pkg/crypto/cipher) correctly without adding any implementation flaws is almost non-existent. [E.g. a semi-recent essay by Bruce Schneier: [Cryptography Is Harder Than It Looks](https://www.schneier.com/essays/archives/2016/03/cryptography_is_hard.html)]