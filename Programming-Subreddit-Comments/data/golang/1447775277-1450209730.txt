A good example of this is calling Lock on a sync.Mutex that's embedded in the copied receiver. It causes a race condition if you use any pointer value in the receiver that's supposed to be protected by that mutex.
Looks slick. Great job on the README btw. The demos really put the icing on the cake
Not forced on you... Yet. Revisit this in 5 years.
The fuck is a pointer?
Quite insulting, and I haven't done php in 10 years. I also have a CS degree and have programmed in many languages. The answer telling me what most gophers do was perfect and assumed I'm ignorant about the go programming community, not programming in general. 
Perfect rebuttal, thank you! 
Did you solve your problem? If not here is a workaround (maybe). Unmarshal your json into a struct with strings. Run through the string list and convert each into int. if s, err := strconv.ParseInt(v32, 10, 0); err == nil { fmt.Println(s) //or something else } While v32 is your string, 10 the base, 0 the bit size for int. Documentation for this [here](https://golang.org/pkg/strconv/#example_ParseInt) save in new struct and you are good to go for now. 
Don't sweat this asshat's responses. He pretends that he is some great programmer, but has never answered one question with an actual response. Just look at his history. It's full of insults and zero substance. He just needs to make himself feel better about his inferior abilities.
Wrong and wrong.
[Image](http://imgs.xkcd.com/comics/workflow.png) **Title:** Workflow **Title-text:** There are probably children out there holding down spacebar to stay warm in the winter! YOUR UPDATE MURDERS CHILDREN. [Comic Explanation](http://www.explainxkcd.com/wiki/index.php/1172#Explanation) **Stats:** This comic has been referenced 535 times, representing 0.6043% of referenced xkcds. --- ^[xkcd.com](http://www.xkcd.com) ^| ^[xkcd sub](http://www.reddit.com/r/xkcd/) ^| ^[Problems/Bugs?](http://www.reddit.com/r/xkcd_transcriber/) ^| ^[Statistics](http://xkcdref.info/statistics/) ^| ^[Stop Replying](http://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=ignore%20me&amp;message=ignore%20me) ^| ^[Delete](http://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=delete&amp;message=delete%20t1_cx3i6xo)
That is a shared library I wrote. I think the cursor cannot move beyond the window size.
hmmm. You're probably right, and given that, I bet you updates would cause the screen to flash or look strange briefly. 
+1 for xhandler -1 that xhandler abbreviates Context with C https://github.com/rs/xhandler/blob/master/xhandler.go#L21 ;-) I don't use gorilla/context because of the underlying global map. Stick to context.Context 
Yeah. Made that a todo :)
The global map scared me too. I didn't read all of gorilla.context's code, but it seems to me we'd want a safety goroutine to expire stale contexts from the global map, just in-case one didn't get cleared for some reason. I'll check out xhandler. Thanks
&gt; If you don't want to get broken at all by API additions, I'd recommend pinning to a minor version, or if it's very critical, to the patch version. Any API change should be at least a minor version bump, but even bug fixes (patches) can break downstream code that rely on the bug. (xkcd) You misunderstood what I meant. There is no "minor version" in go, to a very good approximation (i.e. adding a global identifier is the *only* minor version change you can do to an API and even that is only allowed by explicitly excluding dot-imports from compatibility guarantees). That's the basis of 80% of my criticism of semantic versioning for go.
&gt; Why fetch the reverse dependencies from godoc.org instead of extracting the dependencies directly from the source? Because it's about reverse dependencies, not dependencies. This is about your changes breaking other peoples code, not the other way around.
Yeah it seems as if he might be running the wrong code? Check your GOPATH. Also how are you running this? go run?
Yep, moving it out of your GOPATH means it probably cannot find fmt.
I will when the libraries get more mature :).
Alright thank you, finished crawling the baldur-garten.de site and no problems so far, I hope it was the global variable.
Also, you realize that this: for thread, _ := range threads { href := scrape.Attr(thread, "href") fmt.Println(href) } Is going to return the INDEX of the range in "thread", not the "thread" itself.
Agreed, you owe us no explanation; your questions are spot on.
Thanks for bringing Sciter into awareness - this seems like *the* right way to do non-native GUIs if they are to be done!
Cool. Thanks for correcting that. I was mistaken.
Except I'm using CJK text, which is all multi-byte Unicode, for which pretending everything is ASCII is not a useful option.
As someone who had a lot of criticism for the original proposal, I'd like to say well done. It seems that you really have listened to feedback and this version is much improved over the original.
I totally agree. I was critical of portions of the original document (and told Andrew via email), and he clearly took everyone's feedback to make a better document. I'm pleasantly surprised, and I kind of feel bad for my cynicism now.
I love sustrik's coding style.
&gt; Here are some links to previous discussions and articles that discuss the topic. Please beef up the FAQ a lot. What is there currently is nowhere near enough to pacify "an abrasive newcomer". Perhaps even include a place where such discussion *should* be directed.
Yeah that's a great suggestion. We have been working on improving the wiki, and need to direct visitors to the FAQ there.
Thanks for the link! I love these sorts of screencasts (especially on Macs for some reason). 
I think it would be a bit disingenuous not to mention that this is a possibility, even if only in extreme circumstances. I did go out of my way to mention that it's an avenue of last resort: &gt; Note that the goal of the Code of Conduct and the Working Group is to resolve conflicts in the most harmonious way possible. We hope that in most cases issues may be resolved through polite discussion and mutual agreement. Bannings and other forceful measures are to be employed only as a last resort.
I agree. Benches well, and the API is super simple for what I need (and I need it to be sinatra-esque)
I posted some thoughts that might be useful [link] . I think a hard enforcement policy is important but only after you have a robust CoC. Already you have revisions and additions. You will likely have more as things progress. [link]: http://atomi.github.io/2015/11/17/youre-not-welcome-here/
The Unicode handling in Python 2 is also really bad. Ruby 1.9+ was the first language I used that had really, really good text handling. Matz is Japanese, and in Japan, they use about a half dozen different encodings for different things because they don't like Han unification in Unicode. In Ruby, every string is text, but the string has an encoding attribute attached. You can convert to and from encodings very easily for any string. s = "A" =&gt; "A" s.encoding =&gt; #&lt;Encoding:UTF-8&gt; s.encode!("UTF-32BE") =&gt; "A" s.encoding =&gt; #&lt;Encoding:UTF-32BE&gt; Encoding.list.size =&gt; 100 There is always a concept of an external encoding and an internal encoding as well. It's easy to use, but very fine-grained and controllable. Python 3 converts strings to Unicode internally, unless they are specifically read as byte strings. IMO, this is the absolute easiest way to handle the matter, because it doesn't have to be managed much at all by the programmer. Go seems to use more of a Python 2 approach, but piecemeal. I still don't know if I'm using the right functions. For example, if string.Replace can act safely on Unicode strings... I know Rob and Ken invented UTF-8, and that's awesome, but the string handling seems to be done from the ASCII C perspective of chars = bytes, whereas the rest of the world seems to consider strings to be text composed of characters (what Go would consider "runes").
Agreed. I like that the "outside" clause has been removed. And several other well done changes. 
As someone who was supportive about the original idea, but really skeptical about the original implementation, I can definitely say that right now it looks much better and much more mature, which is more important. Alto, I would really like to have "non public" clause - that the any kind of public shaming\or trying to gather a "mob" by A for breaking any of these rules by B, will be violation of this CoC (penalties included). If A has a problem with B, and it requires involvement of CoC group - the B should also be protected from "public outrage".
And, how does it perform?
The issue will be nevertheless discussed and at least noted. That's good, because issues should be targeted and resolved. But at the same time I would like to hear what happens, for example - when someone contact CoC group about violation (this can happen, people make mistakes), but at the same time they also start a "twitter war" or something like that. **Do not**, doesn't explain what will happen if **you will.** Or at least, what steps CoC group will take... Thing is - that *opal case* feeling is still there. It destroyed a lot of nerves and spent too much of people's energy, which could be used in much more productive way.
I've done this so many times.... 
FLOSS Weekly interview with the author: https://twit.tv/shows/floss-weekly/episodes/358
You're welcome. I'm 7 screencasts in and glad that the format is working. If you have other topics you'd like covered, open an issue at https://github.com/arschles/go-in-5-minutes/issues
No problem! Any idea why especially on macs?
I still don't consider any of these an argument for semantic versioning. But I agree that I am tired of a discussion that goes in circles.
The 2nd sentence is PHP. "A new platform (dynamic web pages) being homesteaded by, primarly, amateur and hobbyist developers".
Okay. Why bother? Also, &gt; causes all errors to be indistinguishable at the type level Huh? I can make testing type assertions to handle certain types of errors. For example: if closeMsg, isClose := err.(*websocket.CloseError); isClose { closeReason = *closeMsg } else { closeReason = websocket.CloseError{ Code: websocket.CloseInternalServerErr, Text: err.Error(), } } Also, I declare all my custom errors as exported `var ErrFoo = errors.New("....")` for easy external checking.
I'm having a hard time seeing this one... Version isn't reliant on anything, calling this should have no effect on compute. Compute sets the result before closing the channel. The main function waits on the channel before reading the result. Result cannot change after the channel has been closed. I'm still learning - am I making an incorrect assumption somewhere here?
Not sure if you came across this yet, but there is an existing binding for picosat https://github.com/wkschwartz/pigosat I made a few contributions and have some still pending merge requests. I'm not really experienced with the inner workings of SAT solvers, but I have consumed this API for an application already. Do you have any examples of using your API?
Why wouldn't you have chclose and chfree or chdestroy?
Yep, so?
This actually makes sense. If the Go compiler can determine the type of a struct or struct pointer, it has enough information to find the correct function to call. There's no need for a valid pointer to accomplish this - it's all done at compile time. I suppose the real WTF here is that Go does not perform an implicit nil pointer check for such calls, but I for one (coming from a C programming background) wouldn't expect it to do this since it wouldn't be very performant. Contrast this to more OOP-style languages where things grind to a halt with a null object pointer. This is because the runtime needs a valid pointer to access the vtable for the type; the mechanism that makes inheritance possible. In Go, this exists too. But since we're not using interfaces in the provided code, it never has to go into runtime dispatch of function calls. TL;DR: If you re-write the playground sample to use interfaces, you'll find the behavior much more familiar.
I found it interesting and wanted to share it in case somebody didn't know already.
He has.
&gt; An abrasive newcomer, a pithy response Does anybody reach out to B because of his rude message?
I saw chdone which closes, and chclose which free/destroys.
And what's the problem?
You can call methods on nil pointers, except when it's a nil interface. It works when it's a nil wrapped into an interface though.
There is no reason why it should not work, especially since the specification describes that obj.fun(foo, bar) where `obj` is not an interface type behaves like fun(obj, foo, bar) except that you cannot use the latter syntax.
I can't even imagine how coroutines work in the OS and CPU levels. For those who feel the same [this small section on coroutine implementations in C](https://en.wikipedia.org/wiki/Coroutine#Implementations_for_C) might give some hints on how to start researching about it.
Oh wow, didn't know about that one.
&gt; In particular, respect differences of opinion. So, [will Rob Pike finally "take a week off" from the mailing list?](https://groups.google.com/forum/#!msg/golang-nuts/hJHCAaiL0so/kG3BHV6QFfIJ) ;)
Ah, I might use that in the future. For this I gave up fighting the server about what it thinks are ints or strings and just stored it as a string. Doesn't seem to be causing any major problems so I'll probably leave it there. Just seemed like my inner programmer wanted all numeric fields to be ints :)
[A better CoC.](http://i.imgur.com/u0r6olA.jpg)
Nice. Now if someone could just put together a really good Vim plugin, I might switch. Code has a number of things I like, but I've been a little spoiled by Vim.
While this is a pretty cool idea, it looks like it's limited to channel and network i/o since you have to use it's network routines (where I guess all the scheduling is performed). While this can be nice for new projects, it's won't be easy to integrate this in existing projects - if possible at all.
I think /u/DeedleFake means that Code doesn' t have vim keybindings.
I was invited to the MS campus a couple of weeks back to get feedback on how MS can do better with open source. Members of the VS.Code team were there. They were specifically interested in how they can support node.js, Go better. I swore off MS a long time ago but times are a changing.
Full Go support seem provided via external plugin: https://marketplace.visualstudio.com/items/lukehoban.Go
Yeah, I shared the wrong link. Go extension is https://github.com/Microsoft/vscode-go
That's where the CoC shall be enforced. This could also mean that if you violate the CoC outside of "the Go spaces", you'll get banned on the Go spaces. The CoC proposal says "The Code of Conduct applies generally. If you participate [...], you are expected to observe the Code of Conduct". This sound kinda vague and can easily be interpreted as "you are expected to observe the CoC everywhere".
I also wrote one a long time: https://bitbucket.org/brtzsnr/gasca/src. This was based on my master thesis in which I developed a cluster distributed java sat solver.
Oops. Turns out it's just chan. https://github.com/tylertreat/chan 
Well, for what its worth, C#/.Net is light years ahead of where it was a decade ago. I started C# over a decade ago. Since then I've worked extensively with just about everything. MySql, Postgre, RavenDB, Mongo, CouchDB, h2, Go, TypeScript, Java and a whole host of Java technologies, Node, PHP, Python, and I have to say C# is light years ahead of where it was a decade ago and where Java is today. Node has it's strengths, I actually love it, but after doing a big Node project, I switched to Asp.Net MVC for our current project and holy shit I love it. It is such a breeze compared to a lot of other technologies. MS Sql is pretty damn solid as well. Now Postgre is a fucking rock. Used it for years and never had one single database issue. Seriously. No locking, no database corruption, nothing. While MS Sql is a rock 95% of the time, it does have locking issues but they are solveable if you know how. I would absolutely use Postgre again but the C# drivers and datatypes can be a pain. Anyways, point is, give C# another go. It's awesome.
There is no race. The compiler complains because main is reading from a shared struct that the goroutine is writing to. But there is no data race. If you think there is a data race, give me one way the results would come out different because of the race condition.
They all look nice and awesome and beautiful and so on ... BUT what when you write a framework which creates complex SQL queries and a 3rd party developer should have the chance to modify these queries easily (withour type assertions of some interfaces) via events/observer or callback or whatever? Which of the these ORMs is then easy to use (fast and less memory ;-) )?
Great job! Its actually very usable! Is it possible to launch commands like go run or go test from VS Code?
nope
Well explained!
Being light weight is among the reasons I use vim. I never understand why people need vim bindings in heavy duty IDEs such as VS or eclipse. 
Every company wants you to use their other products also. Google/Go is no different. And what do you mean it's too difficult to overwrite the default configuration? It's actually extremely easy. Adding Filters or Libraries or bindings or Owin extensions is trivial. And Asp.Net VNext makes it even easier.
Since all interface types in Go are open, and `error` is an interface type, you can't get exhaustivity checking. Therefore, you can't design your types in a way that guide and guarantee proper handling of invariants. I really don't see the argument for Go's `error` compared to actual sum types.
Backstory, I believe. https://www.reddit.com/r/golang/comments/3rtdsb/gophercon_publicly_discriminated_white_men/
Because (for example) I've been using vim for 20 years (no joke!) and retraining that much muscle memory is hard.
Here's what I mean with default configuration... If you wanted to write some middleware that checked all requests coming in and filtered the ajax ones from the regular posts, there was some property you had to check that just didn't work. It was literally broken. I believe MVC 5 addressed this issue, though I'm not certain, but what I had to do with MVC 4 was override some auth core class (I can't remember its name now) and throw in some unnecessary spaghetti code. There was no middleware chain to set up like everyone else did things. For years, they had HTML helpers and did everything possible to force you into using Entity Framework (their ORM). Another thing that bothered me was when they started using JSON.net to marshall all JSON responses. It was buggy when dealing with dates and that caused some headaches. Those are just some examples. The frustration and stopping points in trying to change how MVC worked out of the box made it a frustrating framework to use. This contrasts highly with what I experienced with NancyFx. NancyFX lets you write your own simple middleware and doesn't expect you to write code how Microsoft intended. To be fair, Microsoft did add something called Web API, which looks more like Go's standard library, but I like the structure that NancyFx gives better. I am now on the second project with NancyFx and have managed to get a prototype ready in three days. I would still prefer to do everything in Go, but I'm slowly convincing this Microsoft shop and that takes time. Microsoft does things differently (or at least they did). They want you to use their product for free. They create a very easy path towards getting started. I find this the exact opposite from what Go gives you. Instead of getting full control like you do in Go, you use their GUI based tooling to start a default project. Now that Microsoft has you using their tools, they'll create a tiered pricing system that adjusts for what they predict your income to be based on how you are using it. This is how they made their money. SQL server had a great price until you needed to use it in scale. Then, you could expect to pay hundreds of thousands of dollars. Try avoiding SQL server and you'll find yourself rewriting several interfaces that prove themselves to be cumbersome. Now, they are gearing everything towards Azure so the more they get on their infrastructure, the more revenue. I suspect that Visual Studio Code will eventually have a button that says "Run on Azure". 
For one, Andrew has three more years of experience to draw on. Also, with a clearer CoC, he could evaluate Rob's comment in *that* context. I also believe that Andrew is sincere enough that he *would* call out Rob for being a jerk on the list. Maybe not in public. Maybe earlier in the thread somebody *else* would have called out Rob as being inflammatory and not constructive. I can't change the past; I can't predict the future. But I do know that I want to be in a community where the standard of civility is higher than the general level on reddit. That thread got derailed by Rob's comments. They didn't add to the technical discussion at hand. Maybe with a CoC Rob wouldn't have phrased his opinion that way in the first place.
seconded... VS Code is much more snappy that Atom.
Java is the only language I use on a semi-regular basis that I can't edit using Vim without going nuts...
'Learn Golang with over 20 hours of video lessons....launching soon' And that is actually *all* the available info ? Seriously !? 'Trust' is probably not a familiar word... 
It doesn't look that the rationale section is a part CoC, so while things stated there has some historical value, they are non-binding. Basically the CoC just doesn't help with the issue.
Yeah. Woops. For some reason I didn't see that line when I first looked.. I could have sworn it wasn't there when I first looked!
Not at all. It feels like Sublime in terms of snappiness. I've managed to crash Sublime but not VSCode for some weird and/or intense tests I did. It's dark magic good.
From a quick look, the example looks concurrent. The "go" keyword runs the following function concurrently in a goroutine. https://golang.org/doc/effective_go.html#goroutines This link might be helpful as well: https://www.golang-book.com/books/intro/10
The race occurs when we call version() which causes a copy of the RPC struct [since its not a pointer method] while its being modified by the compute() method running in another goroutine. Once character fix: https://play.golang.org/p/2wvWJAzVJ0
Should be doable. Docs are here: https://code.visualstudio.com/docs/customization/keybindings
TL;DR $ git clone https://github.com/golang/go $ cd go/src $ ./make.bash The output binary resides in go/bin 
I'm only 45 pages into a book on Go. WHAT DOES IT MEAN
I discovered this recently and was charmed yet confused: it's kind of a type-closure, I guess? It was certainly useful for my needs.
maybe not 'decent' yet, but delve has some promise.
Incidentally this is quite similar to https://www.reddit.com/r/golang/comments/3t9nlo/wednesday_pop_quiz_spot_the_race/
Very interesting, thank you. In general, I'm very eager to see how people are combining Python and Go.
Any word about pricing?
The go race detector indicates Data Race, according to the doc. because: "A data race occurs when two goroutines access the same variable concurrently and at least one of the accesses is a write". You are questioning the design of the go race detector and its outputs (false positives ?). See article here: https://golang.org/doc/articles/race_detector.html. This is a question for his designer. And he only could answer it. How would you prove yourself (automatically) there is no possibility to corrupt the shared state (here the object RPC, the struct and its method) in this example with 2 goroutines, main and rpc.compute()?
I get why the compiler does what it does. I'm just saying, in this case there is no *real* race condition (despite the fact that a read and a write is occurring on a shared data structure). This code will never have two different outcomes however the timing of different elements lines up. On the other hand, if the question is "will the go compiler detect a race condition" - the answer is yes.
Updated: http://pastebin.com/ii7qg0q9
I'm sorry but nothing about Go ties you into using Google's other products. Microsoft is changing rapidly but I'm another one of those that sought to stay away from it because of the lock-in to other products. Now don't get me wrong there's nothing wrong with any company trying to create an ecosystem of products that only work with each other for profit. There's also nothing wrong with avoiding such ecosystems.
This looks good. I like that it's not anything "revolutionary"; it's pretty easy to understand for anyone with a decent understanding of the standard HTTP library, and it offers a clean, convenient API for declaring the HTTP surface as well as some nice routing options. Usually I'm annoyed by web frameworks (their "convenience" rarely justifies the cost of groking their API), but (at first glance) this seems like something I might legitimately use.
Not sure if I agree with that. The Go compiler chooses to raise a flag by this criterion because it has the *potential* for a race condition. Here is another definition of race condition (from [Wikipedia](https://en.wikipedia.org/wiki/Race_condition)). "A race condition or race hazard is the behavior of an electronic, software or other system where the output is dependent on the sequence or timing of other uncontrollable events." I don't consider a race condition to exist if there isn't a real race condition by above definition. EDIT: It seems like there is a distinction between a [race condition and a data race](http://blog.regehr.org/archives/490). I'll have to concede your point.
You know - I had another thought. compute() takes a pointer, while version() takes a value. Which means a call to version() gets passed a copy of the rpc struct. The two calls aren't even operating on the same object. Why is the compiler complaining then? 
Figured it out. 1st Issue: ListenAndServe() was within the handler function which it should not have been. 2nd Issue: Was checking for err != nil when should have been checking if err == nil. Thanks for everyone who helped much appreciated!!
&gt; The CoC prohibits racial/gender discrimination. Since when is trying to even out the representation of underrepresented groups a form of discrimination?
Thank you. Having `Start()` as idempotent is a great idea. I was also thinking about having a blocking `Listen()` and introduce an interrupt channel to `Start()` and a `Stop()` function to send that message.
This implementation relies on Xorg, specifically the `XRRSetCrtcGamma` function from xrandr.
More complete TL;DR curl -sSL https://storage.googleapis.com/golang/go1.4.3.darwin-amd64.tar.gz | tar -C $HOME -zxf - mv $HOME/{go,go1.4} git clone --depth 1 git@github.com:golang/go $HOME/go1.5 cd $HOME/go1.5/src ./make.bash ln -s $HOME/go{1.5,} echo export GOROOT=\$HOME/go PATH=\$HOME/go/bin:\$PATH &gt;&gt; ~/.bash_profile . ~/.bash_profile If you would want to have multiple go compilers it's as easy as instaling them in $HOME/goX and just changing the $HOME/go symlink.
Also, that's literally the same thing bufio already does. So‚Ä¶ yes, you're right :)
I'm really not sure what you're asking. You go through a lot of trouble to construct your `buf` and then you never use it in your example code. If you want special behavior linked to the ReadWriter (i.e: written data is available to the reader, or data should be copied from the reader to the writer), what kind of behavior are you asking for? `bytes.Buffer` already fulfills the `io.ReadWriter` interface, and writes to it can later be read. `io.Pipe()` can be used to construct the reverse. that is, to send all data from a Reader to a Writer. If you're not asking for them to implement any particular behavior (just one reader and one writer), just package them up in a struct as /u/lstokeworth suggests.
It looks like it was this: http://i.imgur.com/SL7UeZj.jpg They posted just the eggplant emoji on a discussion entitled "inclusivity," it's pretty obvious that they were trolling. There's not really any alternate interpretation to even give them the benefit of the doubt there - it wasn't on a discussion about, say, favorite foods.
&gt; Now the Coc applies generally. If you participate in or contribute to the Go ecosystem in any way. Fuck this bullshit. Great point, actually. We removed the other wording about enforcement outside Go spaces, but we didn't update that sentence. I've just changed it to: &gt; If you participate in or contribute to the Go ecosystem in any way, you are encouraged to follow the Code of Conduct while doing so. I hope that makes it more clear. I just want to point out that you are really just assuming the worst, and that I don't agree with your characterization here: &gt; Of course no one really believes this is ever going to be applied in a fair way: if I criticize a feminist it's going to be my fault for being offensive with "microaggressions", if I get annoyed by someone making a snide remark about "white dudes" it's my fault for being "fragile" and actually, I'm the offensive one. If you're criticizing the *person* in a Go space then you are off topic. If you are talking about "white dudes" you are also off topic. I can imagine that there might be particular threads (such as this one) or meetings where such topics are appropriate, but in general they are not.
*(Copied from another comment of mine elsewhere in this discussion. Replying because you made the same point.)* Great point, actually. We removed the other wording about enforcement outside Go spaces, but we didn't update that sentence. I've just changed it to: &gt; If you participate in or contribute to the Go ecosystem in any way, you are encouraged to follow the Code of Conduct while doing so. I hope that makes it more clear.
Hah yes it looks like they do 
Yep, looks good!
Yeah, it's been there since the start, and they increased the pointer usage to extend to the configuration structs a bit ago too. I'm pretty sure this is to help distinguish between an empty field and a non-existent one, since the AWS APIs are largely JSON.
Yeah, I expect it will be different. Although note that the usual proposal process isn't democratic either. The discussions are already happening here and on golang-nuts. There's no need to rehash it again on the issue tracker.
How about Unicode progress bars? ____üêå
&gt; I just need helloKey's address, and I think helloKey will have default value 0?
&gt; For years, they had HTML helpers and did everything possible to force you into using Entity Framework (their ORM). WTF! I use MVC since 1 and I never used Entity Framework and never felt compelled to use it. In what way are they forcing you to use Entity Framework? &gt; I suspect that Visual Studio Code will eventually have a button that says "Run on Azure". What is the problem of it? Do you think that the integration with Git is a bad thing because the other dvcs were neglected?
Technically, that is possible. However, you are discarding the assertion success/failure bool. Please see this play for clarification in code: http://play.golang.org/p/RJDvA2Ek4s, and the documentation here: https://golang.org/doc/effective_go.html#interface_conversions. The net/context documentation gives an example of how to code this (https://github.com/golang/net/blob/master/context/context.go#L93-L138).
Depending on the problem you might also use a `range` loop, they iterate over UTF-8 strings a rune at a time.
you're right it would have a zero value. My bad! But why the address? You're just using an integer as a key in a map of values.
Ah, interesting. I missed that. I expect nil will always be returned unless the same pointer is used in both functions. Edit - Oops, nevermind. It's a global, so it will work despite being odd.
Are you trying to emulate Node.js streams in Go?
&gt; So when you use forms auth on MVC 5, you write your own user provider code? Yes. We don't use forms auth as provided. We have our own IPrincipal and Auth/Account Controller.
At least they got rid of *map! Apparently there are tons of conflicting rules about nil / omitted / empty values across the various AWS APIs so this is the best they can do.
A pointer to a variable is fine for the key. What do you think will go wrong? A panic in the second function isn't possible unless some code in this same function misbehaves or they export the key.
If you're merely trying to balance out the overrepresentation and underrepresentation of specific groups, such as based on gender, nobody is being discriminated against. Representation merely gets closer to the real sizes of all groups. Trying to call that discrimination or a distasteful bias is just intellectually dishonest. The status quo is biased towards men in tech conferences, trying to even that out is simply not discriminating against men, because the status quo is an overrepresentation of men in the first place. If we want equal rights for everyone, we need to take care of equal representation in all walks of life. Hence why there is no discrimination involved, nothing to see here, just move on.
we do tend to use it a lot though, so it's good to have it mentioned :).
should be enough.
Good read. So essentially an optimization from the compiler in passing the RPC value might involve overwriting the RPC in main for example?
I understand. It's example code. I just want to know whether I can use a global address as a key.
Instead of `go build -a` (or gb), you could also use Go 1.5, which fixed this issue, as well as related issues. Go 1.5 stores a build ID, which is a hash made up of the file names and tags used to compile a package. If a file is removed, or different tags are used for compilation, the installed object file won't be used. Using `go build -a` should not be required for correctness anymore.
See https://go-review.googlesource.com/9154 and https://go-review.googlesource.com/10760 for the implementation. And to clarify, tags aren't stored explicitly in the build ID, but indirectly via the list of files.
&gt; I contribute to a couple of high profile go projects and this makes me want to drop everything and walk away Goodbye! ‡≤¢_‡≤¢
Ah, I must have missed that. A more up-to-date roadmap (at least for 1.6) is https://docs.google.com/document/d/1kBx98ulj5V5M9Zdeamy7v6ofZXX3yPziAf0V27A64Mo/edit?usp=docslist_api But I agree future directions are absent from that plan.
This is kind-of expected though. An interface is a perfect wrapper, it wraps all possible values of the type it wraps. This of course includes `nil`.
i did
&gt; Furthermore, this is something that the core Go contributors feel that we need to continue to run the project well. And their names are‚Ä¶
If you're not familiar, it's common internet shorthand for a penis.
Even without being written in Go, this looks really neat. I may switch to it for a little while and see how it goes.
But we can just use `go install ./...` instead of `go build`. go install will raise a `cannot find package` error
You know about `runtime.GOARCH`, right?
I'd like to read about your experience! After a fresh FreeBSD install on my main dev laptop I'm not really ready to start experimenting with this kind of thing just yet. ;)
I'm not arguing against it. I didn't feel the need to defend it either. It's not what people with a lot of backgrounds expect, but it keeps the language more consistent internally. I don't think it needs defending.
It may be possible, I tend not to think about what exactly might go wrong because even that is undefined (or may change). Programming is all about exposing "contracts" of this form, and its only by following them that we can guarantee correctness.
I noticed that as well. I wonder if one inspired the other or if this was an interesting coincidence. 
Why didnt you call it Gosh!
Probably because it's [taken](https://github.com/mkouhei/gosh). I'm still waiting for a git clone named 'got', though.
This is about the Go project repos. 
&gt; go install cmd THIS SAVED ME SO MUCH TIME Jesus christ you're a godsend!
The set of Go programs is infinite enumerable. So we only need time and a computer with infinite memory.
Rob Pike's presentation at gopherfest earlier this week was pretty amazing
Looks interesting. At the moment I'm using gorm, kind of unhappy with it. Tried sqlstruct with own extensions, but your lib seems promising. Sadly, will be able to try it only at some distant point in future.
I ended up writing a wrapper that takes sane non-pointer arguments. It's tedious but makes using the SDK bearable, since now whenever I want to, eg, start an instance I don't have to go look up the RunInstancesInput and RunInstancesOutput definitions every time.
Can we sidebar this?
got a video link?
No specific names so it's impossible to call out a lie. I see.
The proverb is about dependency, not abstraction. (Nevertheless, DRY is a dangerously overrated principle, often leading to over-abstraction and clever code.)
In a week or two 
There should be infrastructure for it already written in the package that handles play.golang.org. You can run that page as a local server too so it should come with the go itself.
For god's sake, this, so much. I can not tell you how much these "dog is an animal that has 4 legs"-type class examples have delayed my learning; it more or less single-handedly put me off Java altogether. Especially when taken in the context of text-book learning where a whole Uni class is often put on assignments that are COMPLETELY disconnected from reality in a way that somehow manages to be both insulting to the intellect and unhelpful in terms of understanding what you're doing. Ahh, had that on my chest for while longer than necessary ;)
I've been using this for the last 2 months for a multiplayer server. Works very nicely, but importing is still a little broken :/
My issue with DRY is that people will refactor *accidental* duplication instead of only *essential* duplication, and then when only one of those needs updating they'll add a boolean parameter to the function signature and an if test in the body. Lather rinse repeat. It's hard to convince them that these two things which *were* the same are now different and should be split up. 
Forking is not *directly* happening but basically, a shell constantly makes subshells and executes commands in them, while doing complex things with signal masks and file descriptors. Implementing that without forking is going to be tricky.
You know, not all projects should announce the language they are written in... Specially in Java, where people go out of their way to include a J somewhere, but also pyThis and tool.js are boring.
no idea what is it
Hey just a tip from my personal preference, Instead of using these convoluted ugly byte strings like: `w.Write([]byte("[{\"success\":{\"/lights/" + p.ByName("lightId") + "/state/on\":" + strconv.FormatBool(state) + "}}]"))` You should make a struct with your response, and then just marshal it and send that instead, e.g.: resp, err := json.Marshal(dataToSend) // handle err w.Write(resp) I personally find it adds better readability and adds easier refactoring in the future if you choose to add or remove data from your response. 
Agreed. Early on it was intended more as a warning. "This is a brand new shell written in a brand new language". It doesn't seem as necessary now.
Some small changes were required to support job control: https://go-review.googlesource.com/#/c/5130/ , other than that Go's combined fork/exec has been sufficient. Oh attempts to avoid launching subprocesses and prefers to launch goroutines when possible.
I agree. In most cases. but this is a fairly complicated struct whos top level is an array. That being said I should probably just not be lazy.
Probably your best bet :)
:)
I think you might have missed the point on the last one. I'd say it's about the Go's design decision of executables being statically linked by default. In this case, copying is actually good, because it cuts down complexity.
You misunderstand. Oh is a Unix shell not a POSIX shell. So, saying "it doesn't work correctly with regards to subshells and job controls" is nonsensical. There are many POSIX and POSIX-compatible shells. I didn't think it made sense to create yet another in Go. Instead, oh is trying to improve the programming language features of the Unix shell while still being convenient and familiar when used interactively. Job control is one of those features that doesn't make as much sense in the presence of nearly ubiquitous graphical desktop environments and tools like byobu/screen/tmux/... Oh's job control features are deliberately minimal.
https://talks.golang.org/2012/splash.article#TOC_7. "Through the design of the standard library, great effort was spent on controlling dependencies. It can be better to copy a little code than to pull in a big library for one function. (A test in the system build complains if new core dependencies arise.) Dependency hygiene trumps code reuse. One example of this in practice is that the (low-level) net package has its own integer-to-decimal conversion routine to avoid depending on the bigger and dependency-heavy formatted I/O package. Another is that the string conversion package strconv has a private implementation of the definition of 'printable' characters rather than pull in the large Unicode character class tables; that strconv honors the Unicode standard is verified by the package's tests." Blake Mizerany's great talk "Three fallacies of dependencies" goes in a similar direction: https://www.youtube.com/watch?v=yi5A3cK1LNA Especially at the end: https://www.youtube.com/watch?v=yi5A3cK1LNA&amp;t=18m38s
I would look into the pub sub design pattern. This could work well with the microservices that gkx mentioned.
Sounds similar to the actor pattern, actors receive messages and send more messages but are unaware of the other actors. Actors can manage other actors( become supervisors) and be managed by a supervisor. Erlang issues this pattern by default immsmc. You could achieve that with golang channels and goroutines quite easily. In a larger sense this then becomes micro services when different applications are involved and talking to one another via a common interface.
I'm very new as well, only a week in really, but one of the best tips I've learned is to use `goimports` and `go vet`, the first of which formats (like `go fmt`) your code and orders your imports, removing unused ones and adding missing ones, while the latter will point out common mistakes and more. Having the tools to automatically "conventionize" your code is very helpful indeed (coming from Ruby, btw) 
Great tips. I agree, `go fmt` and `go vet` have been huge time-savers (not to mention the strict compiler). I no longer have to think about how to format code or handle OS-specific edge cases (also coming from a Ruby/PHP background).
I'd also check out https://github.com/alecthomas/gometalinter
Back in the day, we used to call it "programming". Nowadays I guess people have to assign names to things for some reason.
There are some good names already offered for what you are describing, but I'll also offer the term, "dependency injection," because of the way you described a central package stitching otherwise oblivious/agnostic components together.
No, it's about copying code, which is often the better approach when the amount of code is small. Rob's talk (I was there) gave the example of a small text conversion (IIRC) utility function. The function existed already in a library. BUT, importing the lib would import a bunch of unneeded code. The function itself was &lt;10 LOC. So they just copied over that code. But, then they were clever and **did import** the library for their unit tests, where they enforced that the original code and the new code were in sync. That said, importing into tests is a clever approach but your tests better be great in that case or you risk getting out of sync. "A little copying is better than a little dependency" is great advice to not over-stress about a few lines copied here and there. Don't bring in large dependencies for a small utility, and don't immediately refactor your code because you're going to re-write a bit of code and you think you'll use it "in a bunch more places." You probably won't, so save the refactor for later.
I'll add a proverb: &gt; *Beware of shadows* I don't like shadowing. I've only ever been bitten by it, when I accidentally shadow a variable (usually inside a loop) and then in my debugging the code all runs correctly but the final result is wrong because I was writing to a shadowed variable. Honestly, shadowing runs counter to one of its main goals: to be a very **safe** language, where developer flexibility is slightly curtailed in order to eliminate subtle and dumb errors. * It randomizes maps during iteration * Has no ternary ("elvis") operator -- x ? y : z * Forces you to do *something* with error values. * Strong typing (no automatic/implicit type conversion) ... and we allow shadowed vars??
Hugo-to-wordpress exporter? .. you have a typo there. I was surprised at no comparison to Jekyll.
How does .NET tie itself to Azure or Visual Studio? You can just use any other .NET host if you want to and you can just use any other IDE that you wish without it impacting your application in any way. Just because Microsoft developed the superior tools/services in these scenarios doesn't make it tied to that in any way.
Probably cause it's an article about Wordpress to Hugo. Ya' think?
Just for the record for others this is like a todo list kind of task manager, not a process manager Cool app though!
So are giving your variables names like thing1, thing2, thing3, etc.?
Have been using this with Postgis, simple feature support only. Hope it's useful to someone.
No need to [repost](https://www.reddit.com/r/golang/comments/3swqpm/a_simplistic_golang_webapp_to_manage_personal/) the same link repeatedly.
Sounds like a job for `bufio.Scanner`, though there's that whole reader/writer impedance mismatch.
You're off topic. We're not talking about variables or their names.
To be honest nobody commented on the earlier post, so had to repost, see two people commented on it. There is some merit to repost it after all
Thanks for the great advice. I've seen the flag packages defined both within and outside of the `main()` function, and I gravitated towards inside to discourage me from attempting to pull in the flags elsewhere instead of handling them correctly in `main()`. I see that most people define it outside, so I'll probably just move it out to be consistent. You're correct, when a valid config can't be found, it essentially just shells out the passed command and exits. This is so that the `git commit` alias can be used in projects that aren't set up with a `.githound` file. I had it returning an error in the beginning, but decided to just ignore it. I should probably remove it now. The `wg.Wait()` is inside of a goroutine as specified [in this golang blog post](https://blog.golang.org/pipelines). I'm just now getting the hang of goroutines, but I was running into race conditions when it was outside of the goroutine. You're right though, I should probably pass the `WaitGroup` directly into the function. For `hound.Sniff()`, I _completely_ agree. Now that I have a better grasp on channels, I want to go in and refactor that function to just send messages to a couple channels and handle all the output that way inside of `main()`, like you said. **Edit:** I went through and refactored a lot of the code today. I actually went ahead and got rid of the `WaitGroup` because it was beginning to become too hard to test. I just went with an old fashioned `done` channel, which works quite well. Again, thanks for the help!
congratulations to vim team
You mean like this? https://github.com/lunixbochs/vtclean/blob/master/vtclean/vtclean.go#L11 Calling scanner.Text() is wrong as a writer because it blocks until a line is ready.
I find that running goimports on save instead of just gofmt causes vim to hang on large files. Has this been fixed recently?
Give them female names. And use IDE with good refactoring so you can rename them easily once you are fed up &amp; realize your mistake.
It's a problem of goimports, not vim. So if you use gofmt your problem is solved. I'm not sure what vim can do here when the underlying tool is slow on large codebases. I've made it a little faster by writing it directly to the source, but you'll have to use and decide it yourself if it's fast or not for your use cases.
I agree with opinion, however will add the following. It doesn't matter how you name your variables within functions, yes, there is a polite way to do it, for example use "i" for iterator variables in loops and "n" or "num" for number of things. But in general I prefer simple short names, often one letter. If you're having a hard time reading variables within a function, the problem is not with variable names, it's the function. It's an old fact that average human cannot process more than 7 things at the same time. If you have more than that, think about creating abstractions or breaking up the function into multiple pieces (in that order). However, as a reminder, abstractions always have complexity cost, prefer simplest possible abstractions. If you can group some of your variables into structure and think about it as a single element, that's the best way to do it. If that doesn't help, maybe you can break a function into multiple functions, this abstraction is harder to read and understand, but still rather simple. And only after than you can try hardcore OOP path with interfaces and encapsulation and methods and what not. Data design first, then function flow and only after that heavy OOP drugs. And a very good and old link is Rob Pike's article: http://doc.cat-v.org/bell_labs/pikestyle
It would be nice if vim-go had separate commands for gofmt and goimports. Currently, if you change the value of the `g:go_fmt_command` variable to "goimports" and goimports hangs, you have to change it back to "gofmt" after you kill goimports to format the code with gofmt.
https://github.com/golang/go/wiki/CodeReviewComments#variable-names is the best, short resource that I have found.
Output: Value: "Example" [^source](http://ideone.com/ndQpas) ^| [^info](http://www.reddit.com/r/CompileBot/wiki) ^| [^git](https://github.com/renfredxh/compilebot) ^| [^report](http://www.reddit.com/message/compose?to=compilebot&amp;subject=Report%20Abuse&amp;message=--report%20https%3A//www.reddit.com/r/golang/comments/3ta437/til_you_can_call_functions_on_nil_pointers/cx4m8st%20Include%20your%20reason%20for%20reporting%20here.) 
Could probably use some fuzz testing.
You're late...
My pleasure. Apparently...for some reason... others aren't as thankful. Dunno why I have downvotes.
I'm interested in a clean solution to this problem as well. I don't know why it was designed that way, but it's annoying and goes against the strictness we see everywhere else in go.
No.
Ehhh, don't worry about it mate. Every time there is a system which let's you express your feelings towards others in an anonymous way and vent your general existence problems, or just be a dick, there will certainly be people who will exploit it. They just probably did not agree with you, or found your writing not pleasing them to 100%. Or they have a problem with Hugo, so every post that includes Hugo is a -1 because f*ck you and everything near you. And of course they usually don't have a good reason for it, or are just lazy to formulate it and write it down because that would mean that they would have to initiate a conversation and read more. And their time is precious so Gods forbid that they actually spend even more time on something they don't like. Sooooo... Ignore it mate. :) It's good stuff. :)
Well put. Let me try to expand a bit :). The [language spec](https://golang.org/ref/spec#Declarations_and_scope) answers the question in a fairly technical way. &gt; The scope of an identifier denoting a constant, type, variable, or function (but not method) declared at top level (outside any function) is the package block. In other words, when you say "type foo struct {}" then "foo" is defined everywhere in the package, including earlier in the same file and in other files.
Well it has. Checkout the docs please. There is :GoImports which only calls goimports :)
you should open issue in Go's github repo and propose your solution... i would like to see parsestrict in time package...
This is kind of automatic "forward declaration" feature.
Thanks! That was helpful. Appreciate the spec reference.
Indeed it could - at the moment, I have a very narrow use case in that I'm only reading TWKB from postgres (i.e. all internal) but not writing it back (i.e. no external input of TWKB, only from internal server). I am going to harden it up over the next few weeks along with the EWKB parser I'm putting up. But, you are right, it could do with more randomised testing (as well as some more specific testing too). 
Have you tried specifying a location ? https://www.godoc.org/time#ParseInLocation
I'm actively looking for ports to other OSs/architectures! I'd be happy to collaborate on ports.
Lint you application: http://go-lint.appspot.com/github.com/mcansahin/tarak.go
Sorry for the unclear title :-( Seems not possible to edit it...
[multipass](http://static.guim.co.uk/sys-images/Money/Pix/pictures/2013/11/14/1384434812854/Milla-Jovovich-with-her-M-008.jpg)
Would anyone have any quick guides on setting up. I want to make a quick rest json api using this server.
This is a HTTP server, not router, so comparing is not really possible unless you mean comparing fasthttp+httprouter vs. net/http+httprouter?
Wow, importing the library in tests to test that the copied code is identical is brilliant.
No there is not. If everyone thought that way reddit would be filled with duplicate posts. Don't do this.
It's been a while, but if my memory serves me correctly, you may need to set the -orighost to match the external host/ip that the browser is using to access your presentation. I had to do this within my dockerized go present tool. (https://hub.docker.com/r/mkboudreau/go-present)
&gt; 586-mingw32msvc-gcc On Ubuntu it's in `mingw32`. 
I agree with this. Many times when people make their own domains for go pkg importing, it ends up dying or they change the name or something similar. Just use github.
Thanks
[removed]
Thanks for the instructions. Seems straightforward enough that I might actually convince myself to do it :)
Would it make just as much sense to have getBuffer.key be []byte and use "NewGetBuffer()" which sets the key field as the result of "make([]byte, 0, 1024)"? If this does make sense, it also has the advantage of being more easily configured ("make([]byte, 0, bufferedKeySize)").
I'm not entirely sure I understand your question, but I will try to answer it anyway. It would make sense to use a byte slice for readability, but the article is about optimizing garbage collection. In that sense, it would be a bad idea to use make([]byte, 0, ...) because that would be an additional allocation. One allocation for the struct and one for the underlying array of the make'd slice. Also, I'm pretty sure you can use a named constant, say "bufferedKeySize", for the sizes of an array as such: &gt; var arr [bufferedKeySize]byte I hope that helps. Let me know if I need to clarify something in my post. 
Asked too soon: http://dave.cheney.net/resources-for-new-go-programmers Sorry!
Ditto. Just got it, and I can't put it down.
+1. It is so good.
Thanks for that. Regarding the subtlety of resetting: Is `s = s[:0]` an incorrect approach?
Thank you also.
A premise of this article seems to be that Go allows more fine grained control of memory layout than Java. The proposed approach then uses an allocation pool which I'm having trouble relating to memory layout without actual address space comparisons. Why is this preferable to an object pool in Java and how does it achieve a preferable memory layout?
What's confusing you? That looks right. Slices are pointers under the hood. Modifications in the function reflect outside. 
A slice is a composition of a pointer, a length and a cap. All of that make the slice header. As go is pass by value, when you pass a slice to a function the slice header is copied. Remark that the pointer to the underlying array remain unmodified. So, when you pass the slice header to the function, a copy is made. Then you change the underlying array, changing it for both and modify the length of the slice header copy in the function. But as you return in the main program, the original slice header remains unchanged, thus its length (and cap) are still the same.
sync.Pool is cleared before garbage collection, so it never retains unnecessary memory.
This can absolutely be confusing when you first come to it. There's some good examples here https://github.com/golang/go/wiki/SliceTricks for achieving what you need.
Again, primarily used with Postgis. Enjoy!
And now reddit goes even further off topic but your post only displays the moron quality of this site altogether. To explain it to you, possibly, this topic is not about programming languages or variables, which is my point, but I'm sure you still won't be able to figure that out.
My whole point has to do with this obsession with what something is called and containing oneself within it rather than just writing the code. I see this so often on reddit, and other amateur boards, and nowhere else. What kicked it in was my interview with a potential client who spewed the alphabet at me questioning what methods and tools we used as if he knew what he was talking about. It was all a paper tiger and I saw right through it. Just like I see right through a lot of programmers who need labels on things instead of just getting to the work they should know.
I've seen people with Microsoft's Code team say it's a high priority.
Except programming doesn't occur in a vacuum or bubble where you're writing code only for yourself and never interacting with others. Having a shared vocabulary for referring to programming paradigms and principles makes it easier to communicate with other developers and to teach new ones. Your posts seem to have a pattern of ad hominem attacks and straw men that make you look childish, despite your claimed experience and veteran status in the industry. Your point about annoying clients who just spew buzzword vomit to sound impressive is valid, but it also has nothing to do with the current discussion.
Author here, AMA.
Very cool! Does the paper at the end of your readme describe what you've implemented? Is there any sort of short description of how it works?
Cool. It would be more useful to me if I was able to set a verb/path combination to respond with a specific payload.
Cool! What did you use for training data? Do you have any numbers for how well your system performs? Perhaps even in hostile text with bad capitalization?
This seems like the repository pattern, however I end with code like: type ProjectRepository interface { Store(project *Project) FindById(id string) *Project FindByName(name string) *Project Update(proj *Project) Delete(id string) } would you mind sharing a go generate example?
Neither does your last paragraph. I find it funny when people, here, say "Your point ... is valid" and then go on to say what a bad guy I am for saying so. But this is reddit, where nothing is logical, rarely correct, and usually posted by those under 18, which makes it easy to go off on most.
What do you mean by JSON API? Do you intent to follow [jsonapi.org](http://jsonapi.org)?
want to comment on the app?
If you're looking for a short screencast series, allow me to throw in a shameless plug for mine: http://www.goin5minutes.com
I highly recommend reading over your Readme. Typos everywhere doesn't make for a very convincing argument to try your library. That being said, there are some other good services that do this sort of thing, such as [Pretender](https://github.com/pretenderjs/pretender). Might be some good ideas for you there.
https://www.google.com/work/search/products/gss.html#pricing_content
Very cool! One quirk I noticed is that quoted sentences/dialogue don't get parsed as expected (or consistent with the semantics): &gt; "Hi, how's it going?" asked shazow. The wind was noisy as qudat responded, "pretty okay." Becomes - "Hi, how's it going?" - asked shazow. - The wind was noisy as qudat responded, "pretty okay." By the way, I really like that you have a live demo up. Thanks for doing that.
Style 2 throws out many of the benefits of using an IDL in the first place.
Everyone is saying that disabling CBC will have big implications because of incompatibility. Does anyone have any source that lists all (or many at least) devices/OS:es that will break? Or is it practically everything? 
In this particular case, my intuition for the logic is... When a sentence ends with a quote: - If (quoted sentence doesn't end with sentence-ending punctuation) it's a continuation. - Else if (next sentence starts with lowercase) it's a continuation. [*] - Else it's the end of the sentence. [*] This part is probably most fragile, not sure how well it would scale to other languages. Another scenario that would be nice to handle is: &gt; "I wrote up an algorithm" shazow said apprehensively, "no clue if it's helpful, though."
Does that show up anywhere in the web UI? Or is it API only? 
I personally like this much better than the traditional way to do date formatting. Without looking, what is the difference between 'yyyy' and 'YYYY' in java? Twitter used the wrong one and it [brought down their API a year ago](https://news.ycombinator.com/item?id=8810157).
"oh my god, something is not as I expect it. five questionmarks. quick call the whaaaaambulance!" (has the CoC been accepted here yet? i'm fully acknowledging that i'm breaking it :)
Ha. Calm down I was just over zealous in my curiosity. 
That's what I get for skimming. Thanks!
I'm about halfway through it and highly recommend it.
Really neat design!
Coincidentally exactly what I need for a project I'm in the middle of. Can't wait to try it out. 
try disabling it and going on https://www.ssllabs.com/ssltest/ (I have no idea whether or not it breaks lots of compatibility, just pointing this out)
I would like to give it a try, some comments: * For me, even more important than performance is reliability. So even if it is 10 times faster than net/http, it cannot possibly be as polished and well tested. I see this won't happen if nobody starts using it... * What about http2 support which will come with go 1.6 basically for free for all users of net/http? * That repository could use an /examples/ directory demonstrating basic usage This is an ambitious project, good luck going forward!
This looks really cool -- good job! Since I noticed this: https://github.com/neurosnap/sentences/blob/master/storage.go#L6 In Go, sets are usually represented as `map[T]struct{}` (or somewhat less commonly `map[T]bool`). `struct{}` actually takes up zero bytes, compared to `int` which is typically 4 or 8. Here's a simple implementation: https://play.golang.org/p/TmVXF0f9od
&gt; "Gentlemen," he said, "Ivan Ilych has died!" It'd probably have to be able to match this structure: `sentence noun verb sentence` That'd also catch stuff like &gt;"So that's what it is!" he suddenly exclaimed aloud. "What joy!"
You could try using the AJAX API, although I think it's being deprecated but am not sure. And while it still works, I wouldn't rely on it for anything serious. The URL you need to use is: ``` https://ajax.googleapis.com/ajax/services/search/web?v=1.0&amp;rsz=&lt;results&gt;&amp;start=&lt;offset&gt;&amp;q=&lt;query&gt; ``` Where `&lt;results&gt;` would be the amount of results you want returned (limited to max 8, if I remember correctly) and `&lt;offset&gt;` would be the offset of the search. And `&lt;query&gt;` would be your search query, eg. golang. So assume you want 16 results, you would need to set the `&lt;results&gt;` to 8 and then make two requests, one where `offset` is set to 0, and another one where it's set to 8. So an example query of the first 16 results of "golang" would like like: 1. `https://ajax.googleapis.com/ajax/services/search/web?v=1.0&amp;rsz=8&amp;start=0&amp;q=golang` 2. `https://ajax.googleapis.com/ajax/services/search/web?v=1.0&amp;rsz=8&amp;start=8&amp;q=golang`
Thanks for the input! If you'd like to submit a PR for it I'd be happy to accept those changes -- so you can get credit for the contribution. If not I'll make the change no problem.
If you use syscall you're pretty much throwing portability away anyway, so it's not too different from interfacing with C.
of course, I just think it's easier using this than using cgo. 
Did the `make install` actually complete without errors? If so, it probably put `dlv` in `/usr/local/bin`. Check if it's there. If it is, you probably messed up your `$PATH`; make sure your `.bash_profile` (or similar, depending on your shell) has something like: export PATH=$PATH:/usr/local/bin Then start a new shell. 
Your signed dlv is ready to use in /Users/jordanjuel/Projects/Go/bin. Add that directory to your PATH and it will work.
Thank you! 
Another approach is a self-recompiling binary that can install plugins. I prototyped it here: https://github.com/shazow/go-selfcompile The implementation is still fragile and needs work but the core idea is functional.
vim-go is love, thank you for all the work! I've been running into a small problem with it recently though - do you know how to stop folds from closing on save?
One of the creators, not all of the creators.
Fantastic! Keep up the great work
I just wish they'd put them in some kind of order. How are you supposed to remember that month comes before day and second comes before year?
It was an unfortunate accident that is too late to change now. It matches the ANSI C ordering, FWIW.
There's no "sync/mutex" package (it's package "sync", which has a type called "Mutex").
Ah yes thank-you, poor choice of wording--corrected.
Just wanted to share my latest Go project. I was inspired after watching [Andrew and Brad pair on tips.golang.org](https://www.youtube.com/watch?v=1rZ-JorHJEY). I work at a company that deals with a lot of pull requests. I thought it would be nice to have something that rebases them for me.
I would try this with an ODBC driver, yes.
Nice write-up, thanks! Translated it for russian-speaking gophers: http://habrahabr.ru/post/271789/
I'd guess syntax highlighting helps more when you're used to the particular colors rather than getting random ones thrown at you for a test
Fantastic, thanks for doing that for the Russian Go community.
Two questions: a) What is the authentication model, i.e. does it react to *every* comment (and if so, where does it push, because that seems kind of insane) and b) Could it also do a squash? :) I'm annoyed by the fact that github pull requests create merge-commits and merge the entire history of a PR into the master branch (which could easily span tens of completely broken commits now in your history) and would like something lightweight that just squashes every PR into a single commit and commits that instead :)
I will add a short time later.
Yeah, that is a trivial (in both number and complexity) study, but their aren't many good ones. Obviously lots of industry luminaries soldier on without syntax highlighting (Linus using Micro Emacs, Pike using Acme just to name the first two that come to mind). I have been experimenting with turning off syntax highlighting (mostly, comments and editor features still highlighted or faded) and even built a vim theme for it (https://github.com/robertmeta/nofrils). Interestingly, once I got over the initial (painful) few days -- I have found code easier to read and understand. The best way to describe it is the difference between reading with subvocalization and without. Turning off syntax highlighting for me turns off the "subvocalization" of code (too much focus on individual keywords, too little on overall flow and structure). 
This tool is pretty great! Good job!
I worked on a project years ago with Sybase. IIRC Microsoft SQL server was originally based on Sybase and still uses the same wire protocol (TDS - tabular data stream or something?) they inherited from Sybase. So you could try a MS SQL driver, not sure if it is similar enough that it would still work but it's what I used to do years ago.
yes
I turned off syntax highlighting shortly after I started working on Go 6 years ago. Today I find syntax highlighting distracting when I read other people's screens. I do sometimes turn on syntax highlighting when editing a particularly complex piece of HTML or JavaScript, though. It definitely helps when the code is irregularly formatted. I suspect‚Äîfor me personally‚Äîgofmt makes syntax highlighting redundant.
&gt;`|&amp;` tells bash to redirect stderr to stdout, it's an alias for `2&gt;&amp;1 |` Didn't know that. This'll come in handy elsewhere on the commandline, e.g. when I need to grep something on both stderr and stdout. Anything to cut down on amount of characters typed is a win in my book. Well, almost anything -- if it was all gobbeltygook just to reduce keystroke count, the commandline wouldn't be the amazing place to be sitting on that it is. Oh and also, the panicparse tool which was the subject of the post seems nice too. I haven't done much in Go yet but I can see it being helpful just from the GIF in the README.
Well -- for me I found the greatest gains in unfamiliar code. It forces me to read the code more linearly and that seems to improve comprehension. 
Interesting. I'll have to look at it. 
While you're right, that C++ and Java rate expectedly higher, I was surprised to see Dart up there. Also, when you look at the 'multiple query' test, golang seems to be lower than I would have expected.
the funny thing is dave cheney sits on the Code of Conduct Working Group.
Also https://github.com/TechEmpower/FrameworkBenchmarks/issues/1469
What graphics library did you use? SDL?
on zsh use ````&amp;&gt;```` to direct both stderr and stdout.
I would not even use golang for this. This is a program that will run only in windows, so naturally i would use something with a more tight integration with the windows ecosystem like .net! Don't get me wrong i like golang very much but we should use the best language for the task. This is my personal opinion, don't hang me!
Http Server == Yes, but requests (HttpClient) to HTTPS are buggy.
Thanks for replying - good to know so as not to waste time! Cheers 
That's true and I agree. However, I have seen too many times plain JSON config files in Go projects. I consider this a lost battle. Probably because the stdlib has JSON but not TOML or YAML.
What was your reference to implement the API using a MVC pattern?
I guess using this means you can't deploy a single binary anymore, right? Any chance of adding a `go generate` step to have the queries embedded?
Thanks for the very nice write up, very pragmatic and nice tips. When using mutex or channel. I always afraid of deadlock - very hard to test and debug. I know avoiding deadlock is a big topic, can you maybe share some idea or point us with some links? Thanks. Btw, how do you like writing technical stuff in medium.com? E.g., does it offer good formatting syntax like code blocks? Does it have a good community around programming? Helin
Similar to Ansible, but easier to use. I like it.
No problem :) Cheers
There wasn't really a good reference I could find on how to structure an API within a web app coded in Golang. This API implementation is pretty much my own idea of what I think would work well, keeping everything as modular as possible and separated out. You define incoming and outgoing JSON data using structs in Golang, so you're essentially creating models for that data. The models shouldn't be handling interactions with and modifications to the data, so that's left up to the controllers. Each API endpoint then has its own controller. The view is always the same as we're just outputting JSON, so it can be handled directly in each controller.
So. You've implimented callbacks?
These are not entirely callbacks. Well, signals-slots are opposite to callbacks, the whole idea is to makes things more transparent. It's just an attempt to implement the concept from Qt in Go. As you can see, it doesn't really look promising though.
Software engineers are pretty snarky and dismissive, don't take it personally. Code reviews are often humbling. This doesn't seem too full featured, but I'm not convinced this is anything new. The next step would be to implement different types of events, and optimize the way you emit the events. Looking at the code now, it won't scale if you have a ton of listeners. If the project motivates you to write code, continue to do it.
The name re-use bothers me a bit. Sup was an email client (which may have since died, I'm not sure): http://supmua.org/
Haters gonna hate, but I have a suggestion: add support for filtering out trailing commas as well. Basically you need to scan for things like (pseudo regexp): `,\s*}` and `,\s*]`. And remove the comma.
Yes you can! Use https://github.com/jteeuwen/go-bindata
All of this :)
[removed]
Don't put that demo in an animation. I want it as text I can scroll through, in both directions, at my own speed, and cut and paste extracts to others if I want to publicise it. The animation is a gimmick, and this isn't a good use for it. The project looks interesting, but I abandoned finding out more about it due to the animation and lack of time to work around it. Sorry if that sounds harsh, but I thought the feedback might be useful in case others are doing the same.
it's so hight it's cool
This is the framework Gogs uses, but isn't this based on dependency injection just like Martini, which is considered to be a bit of an anti-pattern in Go? and why the author of Martini created Negroni.
sure it [is](http://go-macaron.com/docs/intro/core_concepts#service-injection) -- this is the definition of dependency injection.
Gonna wind up like python and have a dozen web frameworks that all do things slightly different and nobody agrees on anything so nothing ends up working properly.
I was about to complain about 'oh no not another go web framework'. I've recently test drove a handful of them and ultimately fell back to using a 'router' and traditional std-lib handler functions and middleware. However this framework seems to bring all the _basics_ you ultimately need for any non-trivial 'web app' (such as templates, sessions, CSRF etc.) AND it appears to have some good example based documentation. (http://go-macaron.com/docs/intro/core_concepts#return-values looks interesting to me, I hope this can also done when using the template rendering?! I prefer my functions to return _something_ :)) Sure you can hook all this stuff together yourself, but it always feels a bit disjointed to me and distracts from the problem I'm actually trying to solve. And I'd rather not wire it all together unless I _have_ to. I'm wondering if the 'Sinatra' of Go web frameworks has finally arrived? I will certainly be investigating!
Can you elaborate on this? How does Flask, Django or say, Tornado not work properly?
If you're in callbacks you're probably doing something wrong. 
While it might seem to bee more work to read in the content of json files (a simple require vs defining a struct with the same structure and marshaling into it) you are gaining run time safely, which is nice. 
How to program.
I recommend starting here https://gobyexample.com/ run through all the examples, you should have a pretty good grasp after that. There are many other advanced concepts, but not necessary in getting started with Go.
Indeed, unless you're writing a synchronous iterator and don't want to use a Scanner pattern (like [filepath.Walk](https://golang.org/pkg/path/filepath/#Walk)).
I'm using https://github.com/BurntSushi/xgb to avoid any C dependencies. I'm developing a lot of game libraries in pure Golang but they are still immature. When I'm done I'll write a bit about them :)
Wow, sounds great. I wish you best. I'll have to keep an eye on you ;)
You're not wrong, what I am trying to express is as a new Go programmer I found it confusing when I saw functions like this: func foo(args interface{}) { } It was even more perplexing at first to read that Go does a type conversion on the parameters passed into a function that takes an empty interface. This article probably does a better job of expressing what I'm trying to say. http://jordanorelli.com/post/32665860244/how-to-use-interfaces-in-go
And yes it' snot special: just confusing when you start out as the OP is.
It's no time waste if you ask me (I never read the book though), but I don't think knowing different ways of solving a problem ever hurt a programmer. But as mentioned above, Go is slightly different than Ruby :)
1) Look at the question and you'll see why I said that. I should have also replied, "Learn how to use Google" 2) The golang coc is for golang, not reddit, but it's generally silly anyway and doesn't even apply to this.
looks like it's converting from Jade to html.
No. That's Emmet.
We don't need more web frameworks. EDIT: Downvote instead of disagreeing, as is tradition. The documentation is littered with grammatical errors and typos. It's great people are making things with Go but there are already plenty of (completely unnecessary) web frameworks in Go, and the last thing we need is another, especially one that's poor quality and has bad documentation.
There are plenty of formats and languages that Go supports. That doesn't mean that the Go subreddit is the correct place to post content about them.
Yea, I think you're right. Or, if not Spring particularly, they still think of DI "containers"... _shudders_


I mean that more often than not you pick one framework and make your stuff only to find out later you need it to do something it doesn't do well but the others can, then you need to jump through a ton of hoops to get what you actually need.
&gt; For me, even more important than performance is reliability. So even if it is 10 times faster than net/http, it cannot possibly be as polished and well tested. I see this won't happen if nobody starts using it... I believe fasthttp will find many users, which will help polishing and testing it :) &gt; What about http2 support which will come with go 1.6 basically for free for all users of net/http? Http2 support is planned in the future. See the [FAQ](https://github.com/valyala/fasthttp#faq) for details. &gt; That repository could use an /examples/ directory demonstrating basic usage This is in [TODO](https://github.com/valyala/fasthttp/blob/master/TODO).
`/r/golang` is [specifically identified](https://golang.org/conduct#tmp_2) in the code of conduct: &gt; **Where does the Code of Conduct apply?** &gt; &gt; Explicit enforcement of the Code of Conduct applies to the official forums operated by the Go project (‚ÄúGo spaces‚Äù): &gt; &gt; * The official [GitHub projects](https://github.com/golang/) and [code reviews](https://go-review.googlesource.com/). &gt; * The [golang-nuts](https://groups.google.com/group/golang-nuts) and [golang-dev](https://groups.google.com/group/golang-dev) mailing lists. &gt; * The #go-nuts IRC channel on Freenode. &gt; * The /r/golang subreddit. Additionally, the subreddit's sidebar asks posters to follow the code of conduct in its very first sentence.
Those hoops are actually called "Software development".
Already answered. See the answer above :)
What about noticing commented out code? gofmt doesn't make sure /* isn't used anywhere high above and you missed the */
At least Fatih uses syntax highlighting.
Go has no proper dependency management, nor a proper build tool. `go get` just checkouts master. `go build` only builds .go files. No pre-build step, no post-build step. No tasks. If you generate something in a pre-build step, you have to check artifacts into your source code repository. ([This is the official recommend way](https://blog.golang.org/generate)) Because `go get` won't do anything besides `git clone`. There are some popular tools for dependencies, e.g. Godeps. But I didn't see anything for tasks. Maybe you should keep using Grunt or another Node task runner.
Hi, OP here - I don't feel like logging back over to Linux for my password manager: I use the following languages: - C++ - C# - Java - Ruby - Python - Lua - JavaScript I do actually already know how to program and I have been doing it for 4 years :-) I just wanted a list of gotchas because there's a lot of documentation that I'm going through at the moment and documentation doesn't *always* show you common mistakes. A good example of this is when you learn to write asynchronous APIs (in any language): you should always make sure the method is **always** asynchronous or **always** synchronous, and never both. I also find it laughable you don't think JavaScript isn't programming. Pray tell why? Golang might have more complexity but complexity doesn't necessarily indicate programming skill otherwise we would all be coding in Assembly.
Oh - is that like expressing an anonymous type for a parameter? We do that in TypeScript/Flow (typed extensions to JavaScript). function f(foo: { bar: string; baz: Date; qux: number }) { } var foo = { bar: 'hurr', baz: new Date(), qux: 0 }; f(foo); // Works just fine f({}); // Compiler error because {} does not match type { bar: string, baz: Date, qux: number } I really do like how Golang is structurally typed (rather than nominally), that has always felt like a better way to do things.
[Learn how to use Google](https://www.google.com/search?q=golang+gotcha&amp;oq=golang+gotcha&amp;aqs=chrome..69i57j69i65j69i64.2167j0j7&amp;sourceid=chrome&amp;es_sm=122&amp;ie=UTF-8) &gt; I also find it laughable you don't think JavaScript isn't programming. Where did I say that?! Or are you a typical redditor and make things up? 
Wait a minute. Google and golang run, operate and manage /r/golang?! What a disappointment! While I generally find /r/golang one of the rare steps above any other thing on reddit, I'm shocked Google would step so low as to endorse any subreddit! I mean, it's like building an opera house amongst a bunch of crack houses! 
Me calls a spade a spade.
So now you're saying you only asked the question to be sociable? What a waste of time.
Yes, Go and TypeScript are very similar in that regard.
At one point there wasn't much out there for .Net PaaS. None of the common players were doing it. So what other service were you going to use? There was no other major IDE for writing .Net besides Visual Studio so what other IDE were you going to use? Microsoft didn't develop the superior tools/services. They developed just about the only tools and services. If it makes you feel better you can call it everybody else's fault for not supporting .Net if they indeed had the chance. The effect was still the same. You were tied to MS. Of course I guess you read right past where I talked about things changing now.
The naming convention comes from Martini and Negroni, e.g. martini.Classic()
i can confirm with my devops person but I'm pretty sure we put our go http process behind nginx for https stuff simply due to performance in the implementation, we found the go version slow. ymmv.
Wow, one of the nicer talks I've watched recently. Quite enjoyed this one. Kudos.
from what i recall it was mainly about not overwhelming our redis database(s) immediately after a garbage collection pause cased a bunch of requests to stack up. we didnt try having workers read jobs from a channel, we just process the request in the http handler goroutine (with a nested goroutine/timeout selector), unless theres too much at once in which case we return 204s. i think the number we came up with was somewhat arbitrary and based on observed performance and when things started to look ugly right after GC pauses.
And who runs the Go project?
`make`?
No reason. Fix deployed. Thanks for your feedback!
Dave's blog posts are always quality. I learn something new every time.
NewDb assigns a bunch of variables using in-line functions that are called in place. There's no good reason for this. Also, your usage example gives away the fact that you use flags for some things and environment variables for others.
This is actually the only framework that has some up to date documentation. Sure, there are some typos but, they actually made an effort. This is worth an upvote. Plus, it's not exactly new, it's been there for a long time, longer than frameworks like gin and echo. It's just never been announced here.
Stackful goroutines are very expensive comparing to stackless generators and async/await from ES6/ES7 or TypeScript.
fragmenta.eu maybe ? Its a CMS like, for example, Drupal. Never tried it but sounds good. "Fragmenta sites somewhere between Rails (a web app framework), and Wordpress (blogging software) - it combines the quick start and simple UI of Wordpress with the flexibility of a framework like rails, which lets you build your own backend to suit your users." 
`copy(m.matrix, spiV3)` only copies the outside slice, the inside ones are still the same. You need to copy the inner slices one by one: dup.matrix = make([][]int, 0, len(m.matrix)) for _, in := range m.matrix { out := make([]int, len(in)) copy(out, in) dup.matrix = append(dup.matrix, out) }
Really, you "started using Go for pretty much everything I built" without being aware that there are no generics ? Please. Vendoring solves the problem of dependencies, better than the rest in my opinion. Any example about the boilerplate ? No sub-packaging is not even true. Where did you get this idea ? Did you look at some Go code from the standard library or a big project ? 
Thank you for the help, you made me realize I'm in so over my head :-)
There is a proposal to add ["strided" (multidimensional) slices](https://github.com/golang/go/issues/13253) that would fix this problem.
I wrote this for myself but I thought it might be useful for someone else too.
Completely agree. The first Go web framework that I know I am going to use. It's middlewares take care of many pain points e.g. sessions, contexts, caching, user auth.
&gt; Really, you "started using Go for pretty much everything I built" without being aware that there are no generics ? Please. They didn't say they weren't aware of it, they just said that it's a disadvantage. You can totally use a language for a while *despite* being unhappy about something and still cite it as something bad when you stop using it. &gt; Vendoring solves the problem of dependencies, better than the rest in my opinion. Vendoring solves some problems (mostly reproducible builds and stability) but dependency-conflicts isn't one of them. Because the real problem are diamond dependency conflicts and with vendoring you end up with multiple versions of the same package, which is bad. &gt; No sub-packaging is not even true. Yes, it is. `net/http` isn't a subpackage of `net`, it's a separate package that just has `net` as a prefix, but there is no special relationship between the two (given, internal packages and vendoring muddy the water a bit here, but it's still not really "sub"packaging, for example `net/http` can't access unexported identifiers of `net`). However, what I think the author referred to is the fact, that you have to reference identifiers in a package purely by package name (instead of a full namespace-like path). This would also be true, but a weird thing to complain about‚Ä¶
Why does GC performance depend on pointers?
I'll give you a simplified explanation. Sorry if it's too basic. A GC must not free memory location the program could still use in the future. It can't know in general that a piece of memory won't be used -- but it can know that pieces of memory that cannot be accessed through dereferencing pointers and indexing slices or maps. The difference between pointers, slices and maps is not very important. Under the hood slices and maps are implemented using pointers. The GC knows about all occupied memory locations; some of them are accessible. There's a set of obviously accessible locations in memory called GC roots. The GC traces where it can get from each accessible location. To avoid infinite loops, we mark each location that we've already visited as accessible. Once there's no new place to visit we can free all locations we haven't visited while tracing. The more pointers we have the more work the GC will have tracing. When looking at a pointer the GC has to spend time to discover whether the memory on the other end is under it's control. That's why creating Go pointers causes the GC to take more time. Keep in mind, for most applications the speed gains aren't worth the mental toll of manually managing memory.
Regarding this question: &gt;Safe Performance &gt;by snadrus &gt; Reimplementing the Gnu+Linux toolchain in GoLang could provide safety that decades of eyes on C could not (thinking about the recent BASH bugs &amp; OpenSSL overruns). Even a small portion would add security to Android. Performance is close &amp; 1.5's library loading should keep executables light. Is there interest in rebuilding Linux's base userland? Shameless plug for [this project](https://github.com/EricLagergren/go-coreutils).
This is a fantastic entry-level introduction, thank you! Where does `sync.Pool` fall into all of this (if at all)? I understand `sync.Pool.New` method returns a `interface{}`, which is essentially a means of passing a pointer (interfaces are just wrappers around pointers, right?). Am I to infer that `sync.Pool` can somewhat optimize things by reducing (de)allocation, hence limiting the number of structures the GC has to traverse?
Glad I could help. Keep in mind, this is the general idea. The story behind the current GC in Go is more complex and I sure as hell don't know most of the technicalities. AFAIK using `sync.Pool` doesn't affect the tracing times much. The GC doesn't just collect garbage - it manages memory. Remember how I said that the GC knows about all occupied memory locations? When the program needs some space it's the GC that tells it what space to use. When the GC does this it has to remember this space is now occupied, and that takes some work. A `sync.Pool` sits between the programmer and the GC. The pool can provide values, and they can be given back to it once they are no longer needed. If you need to use the pool you should to give the values back to it. When they are given back it can then decide whether to keep references to them or not. If it doesn't have any references it has to call the function from it's `New` field to get one. If it has some references internally it can just return and forget one. Since this doesn't involve asking the GC for some memory it's supposed to be quicker. Note, this is my understanding and I feel less confident about the details than in the previous comment. And yes, interface values contain pointers under the hood.
Just to clarify, does this mean that it's not considered bad practice to have an unexported struct with exported fields for the sake of decoding incoming JSON? EDIT: The reason I ask is that I can't find any examples of this in the go docs. It works, but I've been unable to confirm if it's considered good practice or not. 
Haven't tested it so no guarantees, but I assume something like the following: type Article struct { Title string `bson:"title" json:"title"` Body string `bson:"body" json:"body"` Categories []*Category `bson:"categories" json:"categories"` } cat := &amp;Category{} change := mgo.Change{ Update: bson.M{"$push": bson.M{"categories": cat}}, } c := session.DB(database).C(collection) _, err := c.Find(bson.M{"title": "cats in hats et al"}).Apply(change, nil) if err := nil { panic("not enough cats in hats") }
You refer to "running .go files". I assume that means you are trying to do something like "go run &lt;file.go&gt;"? Have you tried simply building your binary, and then running that? There really shouldn't be anything for you to set in your environment, other than your GOPATH. 
Are you including every dependant file as an argument? E.g. go run main.go routes.go handlers.go or on *nix with no test files and all package files in the same folder: go run *.go
&gt;l Go 1.4 &gt; &gt;Go 1.5 has a regression bug in cgo, due to which DGraph is dependent on Go1.4. So download and install Go 1.4.3. Can you explain this or point to somewhere where I can read about it?
It does sound interesting. It is still in large discussion. I need to dig in deeper to understand everything what's been proposed. :) But thanks for the link!!
Quick background; this is a project we've been baking internally. Anything glaring stand out? Anything we could improve? The team is pretty new to golang so there are probably some major "you-shouldnt-be-doing-this" items, would love to have some external eyes take a peek.
Do you have an antivirus installed? Avast maybe? If so try disabling the DeepScan feature in Avast and see if that fixes the problem. I had this problem a while back with Avast and would stop any Go program from running.
Awesome! Exactly what I was trying to do. Thank you so much for this. What I was mostly having trouble with finding is how to map a string to a regex, but it looks like `map[string]*regexp.Regexp` is what I was struggling to figure out. I didn't realize golang was pass-by-value like C (from what I can see in the FAQ), so I see why they're returning a `*regexp.Regexp`. I didn't expect to see pointer notation in a garbage collected language. I thought they'd all be references.
I think I just recently read a similar discussion like that on golang-nuts that ended with avast being the culprit 
Hi. This is a quick overrun of your code... Here is some feedback. :) if value_reflected.IsValid() { if c.IsJson { // This could be put together into one line with &amp;&amp; if value_reflected.CanAddr() { if field_type.Elem() == value_reflected.Type() { //175 // Can be normalized 224-269 can be either normalized, or thrown out and simplified. It's too big, and full of duplication 318 =&gt; Don't need the return nil in else. just say return nil otherwise without the else. 323 =&gt; ConcatWith. Insted of the for cycle, use append(total, cc.Columns...) ... -&gt; for variadic function call passing in the elements together, like this: var total []string total = append(total, cc.Columns...) total = append(total, other.Columns...) *Hint: If you have many else-if's, use a switch instead. Is more readable. *Hint2: Run the whole thing through fmt &amp; lint. *Hint3: Many of your if's could be simplified and make more readable with pulling them together into one line assigment like: new_conn, err := db_alias.OpenNew() if err != nil { return nil, err } else { db_alias.Connection = new_conn } Instead do the idiomatic Go way: if new_conn, err := db_alias.OpenNew(); err != nil { return nil, err } else { db_alias.Connection = new_conn } *Hint4: There is a lot of duplication going on, and your utility methods seem over-engineered. Your JSON Serialize seems very unnecessary for example. *Hint5: You can put the locking mutex into the struct making the struct essentially concurrent proof. *Hint6: ... 
When will you fix your default 404 page, and your Category menu? :)
as soon as someone tells us they're broken :) I'll look at it today. thanks for the heads-up!
Glad to hear you're enjoying Go. One little correction, however: &gt; Go includes `float` and `int` types as well There used to be a `float` type, but it was removed before Go 1 due to non-explicit bitsizes with floats potentially causing more problems than with ints. The only float types are `float32` and `float64`. ^(Well, and the `math/big` package's types.)
I enjoyed reading about your experience. I also found "compare the mass of things to the average bee" to be very amusing. I hope you can continue having fun with Go.
That's because async/await and stackless generators are nothing more than state machines around functions after transpilation. They're going to be pretty fast. We haven't seen how they will perform in native browsers yet, could be better - or worse. Not really fair to use them in an example right now. The only thing supported in super modern browsers are generators.
thanks so much for the review; it is very helpful. pushed some updates. for 224-269: did you mean that the `columnCollection` generally is redundant? i would tend to agree that it's pretty heavy for what it is doing, but makes reasoning about those operations pretty straightforward. For hint5; ideally you want the metadata shared across connections so it's necessary to have the mutex not on the connections themselves but as shared/static state. 
what it does??
Do you guys realize that the main purpose of `cat` was file concatenation? :) http://harmful.cat-v.org/cat-v/
Great to see another project in this space. May I ask, where do you see pain points in [Cayley](https://github.com/google/cayley), which is another knowledge-graph inspired graph database written in Go?
Well you always can use a transpiler, e.g. TypeScript. Or Babel. (Although IIRC Node doesn't support .map files, so stacktraces aren't quite useful unless you fix line numbers in them.)
 alias ccat="highlight -O ansi"
Think about why io.Reader is used in most cases, and not just because it's idiomatic. The json package for example, does not need to read the entire byte slice in to memory in order to parse it. It utilizes a tokenizer. This means that io.Reader is acting like a pointer to the original slice of bytes, preventing unnecessary memory usage. text/template however, needs an entire copy of the byte slice in order to do it's parsing. If it were to provide io.Reader in the API, it would have to essentially do an io.ReadAll() before continuing almost guaranteeing extra work / memory utilization (origBytes-&gt;io.Reader-&gt;copyBytes-&gt;Parse rather than origBytes-&gt;Parse)
I'm guessing because text could be in utf8, and be 2 bytes per character. Making it a string means that the parser does not have to deal with the conversion.
True, but what if you are reading from a network resource? Or a compressed file, or any number of other readers? I can't believe the ParseFile does anything different than read from a reader internally, but I have not looked at the source though. 
I haven‚Äôt looked too deep into Cayley, but based on my understanding, it‚Äôs sort of like a graph layer on top of an existing database. It supports multiple of them. You can use a distributed database below it, for Cayley to support distribution. This means Cayley itself doesn‚Äôt need to tackle data distribution, snapshots, machine failures etc., and can rely on the database for these features. But also means, Cayley query performance would be bound by how data gets divided by underlying database, and affected by the number of intermediate/final results. For DGraph, low latency for query execution is the prime goal. In a distributed system, this largely equates to minimizing the number of network calls. For graph processing systems, doing that is really hard. If data distribution across machines is done in a standard key based sharding way, a single graph query could end up hitting a lot, if not all the machines, when the intermediate/final result set gets large. DGraph tackles this problem by dividing up the triple data (subject S, predicate P, object O) in a way so as to colocate all the (S, O) for P on the same machine (possibly further sharding it if P is too big). Furthermore, it stores the data in sorted lists (O1 ‚Ä¶ Oi), to allow for really cheap list intersections (think of queries like [movies starring X and Y]). This allows keeping the total number of network calls required to process a query, linear to the complexity of the query, not the number of results. In addition, all the entities (S, O) are converted to uint64 numbers because they are a lot more efficient to work on (CPU wise) and pass around (network wise). DGraph is aimed at squeezing great performance, so one could use this system in production, directly for user facing queries. It‚Äôs built with a very different design and ideology than Cayley. Btw, do have a look at the product roadmap to get a better understanding of where DGraph is headed: https://github.com/dgraph-io/dgraph/issues/1
Stable version of Go 1.5.2 hasn't released yet. But, I'll give it a shot when it comes out.
Come on, the video is just 20 minutes long and really clear to follow. I would recommend to watch it, it's really worth it. 
Can you try from tip, or the release-branch.go15 branch?
Pretty easy to watch at 1.5 or 2x as well.
Easily one of the YouTube player's best features. There are so many talks on YouTube, and the ability to speed them up a little makes really long ones much easier to get through on a tight schedule.
We are getting into semantics, but "parallelism" to me does not necessarily mean "GOMAXPROCS &gt; 1". Literally, when you say, "I am doing a few things in parallel". There's only one of you, right? If you have multiple threads, microthreads, goroutines, processes, then we have parallel tasks. Adding a few channels, you have extra imposition of dependency among the tasks, and thus concurrency.
"Parallelism is a whole beast of its own that is much harder to do correctly than concurrency in my opinion." Perhaps our definitions of parallelism and concurrency are different, but parallelism to me roughly means "concurrent or simultaneous execution of independent tasks". When you execute a bunch of goroutines that do not communicate and do not depend on each other (i.e. no channels involved) you are running tasks in parallel.
I go with Rob Pike's definition &gt; In programming, concurrency is the composition of independently executing processes, while parallelism is the simultaneous execution of (possibly related) computations. Concurrency is about dealing with lots of things at once. Parallelism is about doing lots of things at once. [source](http://blog.golang.org/concurrency-is-not-parallelism) It is the *simultaneous* aspect of parallelism that makes it harder to deal with in my opinion. Threads running on multiple cores (not to mention multiple connected machines) aren't going to just yield and place nice with each other without you making it happen
Concurrency doesn't even have to be threaded, concurrency can be achieved on a single thread via asynchronous execution. Parallelism requires that, because it's execution of multiple tasks at once.
Might be beneficial to checkout jwt.io. They have 3 JWT packages written in Go, and at least one covers most of JOSE.
hey you can make the change it's cool. (sorry I somehow missed your reply!)
&gt; Concurrency is necessary for parallelism, but it can exist without parallelism Parallelism can exist without concurrency as well: if you execute two things in parallel, but they do not have to synchronize, then you have parallelism without concurrency.
I've been watching it and migrated a couple of my projects from Gin to Echo: they are very similar but Echo allowed me to simplify routing because it supports static and parameter branches in the routing tree from the same parent node. Echo is minimalistic enough that you can mix it with other libraries and add your own. Nice alternative when you need a bit more than net/http and have considered adding Gorilla Toolkit mux or something else. 
Rob is bending the truth saying that other languages "converge by borrowing features from each other" and that Go somehow stays out of it. Go has been built on features borrowed from other languages, there is no shame in that. It's still evolving even being on 1.x. Consider internal packages, special comments for code generation, and some other small adjustments. True, there were no significant changes in the language. We'll see what happens at Go 2.x. I say, adding a good safe macro support will immediately close the "need for generics" and will improve code generation capabilities. Now, let's talk C# a bit. The latest added "features" actually make C# code simpler and easier to read and hiding complexity - something that Rob praises in Go. So, adding features could be very beneficial for a language. Overall, a good talk about simplicity/complexity if you think of Go as one of representative languages, not a shining beacon.
Started as a little internal event at Develer, GoLab has grown up as a not so little conference (100+ attendees) in less than one month. Ready for the next edition?
&gt; Consider internal packages, special comments for code generation These are not part of the language, they are interpreted by the build tool ("go" command).
If you really want to have those funcitons it's easy - http://play.golang.org/p/XgaVMx4Wnh and http://play.golang.org/p/YFJBQYQizq
Yeah, because writing data[Min(data)] and requiring the slice to implement the 'Lenner' interface even though all slices already have a length is so much more readable than data.Min() or min(data). Thanks. I notice you also didn't show an example for mapkeys because that one actually has to be generic to work. To write a Min function that doesn't look like it was made by a retarded baby, you need either generics or macros or language support, and Go has none of those. Pretending that you can write such a thing is wrong. This is a place where Go does make code less readable; you don't have to devalue his point with an example that totally doesn't address it.
Yeah, C++ templates are terrible. Any feature can be implemented terribly and no one's advocating for terribly implemented macros or generics. Lisp-like macros are great and usable. Rust or D's generics would be nice. C++ templates are a strawman, as are any Java features you might bring up compared to Go.
Oh come on. It was just an example.
Non blog-spam link: http://talks.golang.org/2015/simplicity-is-complicated.slide#1
&gt; Say there are two people, they have a stack of reports, and they have to count the number of times the reports contain the word "bagel". &gt; Don't communicate by sharing memory, share memory by communicating. &gt; If they're both looking at the reports, counting the number of "bagel" occurrences, they need a way to bring their totals together. &gt; If they communicated by sharing memory, one way they could do that is have one sheet between the two of them, whenever one of them finishes counting one report, they grab the sheet of paper, add the number of "bagel"s in that report to the current talley, then put the paper back between them. They're "communicating" the number of bagels they've counted so far by "sharing" the piece of "memory" that has the total. It's just a matter of semantics. You can also say that those two people are sharing the piece of memory by communicating when which one can go ahead, grab the paper and update the tally. This is what makes it confusing, at least to me and it seems to some others too. The thing about this is that "sharing memory" and "communication" are two different things. Sometimes, you need to share memory. For example, if you have processes updating a map, you will need a mutex to control access. This is why Go has mutexes. Mutexes are needed when you need to share memory. If you need to share memory, you can't naturally "communicate" your way out of it. If Go designers think that you should always use channels, then throw away the mutexes. But they don't. I think channels are extremely useful and are a natural solution in many situations, but mutexes are also important when you have to share resources. 
This is something that bothers my about Javascript. I really like Javascript as a prototype language. But, people keep trying to shove OO shit into it. As a consequence the OO style of programming in javascript is faster than the prototype method. Which makes me sad. I glad Go has resisted the pressure from "bloggers" to implement the "bloggers" favorite language's language feature. Go probably still needs some Generic-like functionality, but other than that I pretty happy with it's current feature set. If you want strict OO or purely functional language features, just use another language.
&gt; The latest added "features" actually make C# code simpler and easier to read and hiding complexity - something that Rob praises in Go. So, adding features could be very beneficial for a language. The problem is that the old features still remain even though there are new ways to do the things they were trying to achieve. This is still added complexity even though the new features are simpler. Rob might argue that C# would have to remove the old, redundant features to truly make the language simpler. I think that's his point when he's talking about features as basis vectors. At least, that's what I got from his talk.
The problem with data.Min() is that slices don't have methods. Okay, fine, let's change the spec to allow methods on slices. Great, so we want to add Min() as a method on the slice. However, slices can be used for any type T, while Min only makes sense for a subset of types. So should it be that built-in numeric slices have Min(), while slices of other types can't? My class Foo has a method Less(Foo) bool. Should []Foo also have a Min method on it? What about the type type BigFoo struct { Foo } should []BigFoo also have a Min method? The point is not that the issues aren't solvable, the point is that there is significant complexity in establishing rules to follow. It is no longer easy to know all of the methods of a particular type. There are common classes where it's useful. The gonum floats package, for example, has Min and MinIdx that work on []float64. When I need a min of a float64, I just say v := floats.Min(s) Is it generic? No. Works great though. 
I've thought before that readability, while an important concern, is often overplayed -- big time. *Comprehensibility is more important to readability*, and people have merely identified readability as a factor to comprehension. But readability is not the totality of comprehension. Readability often means that I'm looking at some local area of code and timing how long it takes for me to grok some module, function, or snippet of code within the limits of whatever can fit on the screen. Rob Pike criticizes map and reduce and other functional idioms as not machine simple, and will therefore be more inefficient than an imperative solution. And although Rob Pike doesn't argue this, I would argue on his behalf that functional code has a reputation for less readability. But I would argue that functional idioms permit tasteful tradeoffs between machine simplicity and system comprehensibility. I would also further argue that the gains made to system comprehensibility permits a human to optimize for multicore distributed contexts, to such effect size as to offset losses to machine simplicity and local readability. The reason is because when a system becomes big enough, I'm willing to pay the cost of the more difficult to read functional idioms (readability), as well as machine simplicity, insofar as I receive the gain of being able to discuss how many discrete orthogonal components I need to know before I can get a sense of the whole system, and also that I can more easily model my program in a multicore distributed context.
The proper solution here is to use go generate http://clipperhouse.github.io/gen/ ``` // +gen slice:"Min" type Price float64 ```
The keyword is not "borrowing," but "converge." As you also agree, Go keeps its philosophy and personality. His point is that while borrowing, some other languages don't.
I think Rob is overstating the simplicity of Go implementations. Definitely easy to write C-looking procedural spaghetti code with concurrency included. The language itself is not a strong guard against the complexity inherent to writing in programming styles. Example: here's the core logic of the server side of a working state machine for a dice rolling game implemented procedurally and concurrently: http://pastebin.com/FQACpUSZ As far as I can tell this is the best way to implement simple game logic (baked into the procedural structure) when it needs to run for many concurrent games efficiently. [**Edit**] The game is playable, but has not been tested with more than one match at once, and your USERNAME AND PASSWORD ARE SENT **UNENCRYPTED**: http://mclnds.com:8080 and it might stay crashed if the reboot script doesn't work. And I don't think Firefox works. If you want some music to go along with it: https://soundcloud.com/pciet
Umm, Javascript is actually more OO than any other "OO" languages, those languages are actually Class oriented languages. Javascript is just OO. Things like Classes in JS are just syntax sugar, its still prototypical.
Apps are more of a side thing for me. I primarily work with OpenStack. I may yet make the attempt with Golang. Interesting, I've been flown out to all of the Gophercons since it's inception and one of the groups I met at this past Gophercon created games successfully using Go. The names escape me, but I'll double check my files, might be of interest to you. Edit: Unless of course you happen to be one of those people I met!
Yeah, I've been thinking about it, and a few small things would go a long way. For example, if you could copy mismatched slice types besides `[]byte`/`string`. Keys in particular are a pain to have to convert by hand instead of doing something Go-ish, like keys := make([]keytype, len(myMap)) copy(keys, myMap) sort.Sort(keys) In general, I think `copy` should do all the grunt work of converting one type to another for you where there's a sensible way to do it. A standard iterator protocol would be nice because you end up having to reinvent the wheel. In my mind, generics and operator overloading have the same problem: if you could **force** people to use them for their intended use case (data containers and numeric types, respectively) they'd be great, but instead people use them for weirdo things like operator overloading bit shift to mean stream concatenation. So then if we can't trust people to be responsible, the language core needs to do more things for us.
Sure.
That's a bit disingenuous though - `go generate` is part of the standard platform
And thus add a bunch of non-standard stuff to the language that tooling will break on.
There's some info on it here https://github.com/golang/go/wiki/Mobile https://github.com/golang/mobile but haven't attempted it my self yet.
Ah. I've never had the pleasure of attending a Gophercon. If you happen to remember the name of that game, I'd really love to about it.
copy() has the same performance characteristics of "min" and is already a built-in. I understand the general feeling of hiding non constant operations, but I don't think a min function on a slice can trick anybody into thinking that maybe it's being done in O(1).
The performance figures are good but I care more about long term code maintenance and reliability than speed for the libraries/frameworks that I consider. Are there anyone using this in production and intend to maintain for long ? Or is it just a hobby project ?
I'm sure it's slightly more than never, but it's very rare that I need the keys from a map in a slice, but i don't need to iterate those keys. Not making the language larger for those use cases is a great thing about go.
Uhm, Horror.... 'nil' should I have had written... the Force of the past inhabited me.. :(( C fut une autre histoire... I correct it. The Horror... apocalyptic... your remark, if correctly I interpret it..
Make a feature request if you want that.
how would you say it compares to Gin ? I am considering starting new projects with it instead of Gin. API use case.
I get a 503 error...
Very similar for basic purposes. However, Gin appears to have a bit more in middleware variety, form binding, validation, and template rendering integration. That is my perception, I have not used much of these. The issue I had with Gin is I needed to handle URLs like /static/*, /profile, /login, /admin, /:city The last one could not coexist with the rest in Gin but works perfectly well in Echo. There are workarounds for Gin but I really did not like either of them.
Probably web the server is written in Go and he is busy debugging it. 
My book is very close to a beginner level book. But I am making an assumption that the reader is familiar with some programming concepts. In my book, I recommend to spend few days with [MIT Scratch](https://scratch.mit.edu/). I am avoiding comparisons with other languages including Python, which I used for 12+ years. Edit: grammar - add missing _with_
I ran out of file descriptors because I forgot to raise the ulimit!
Ehh, you posted the original github link I provided and you posted the video version. Not exactly the same, not here to witch hunt anyways.
Agreed, I'll edit my post, didn't mean to offend you.
I think there is enough books about Go the language, but we need books about the standard library and packages x of the team. But please, not a book with half pages to repeat the tuto or to sell Go !
Not when you gotta sync to multiple versions of the client side. Specified numbers mean less maintenance here I think.
You mean like this? https://tip.golang.org/debug/vars - check the expvar package.
You should send in a change! https://golang.org/doc/contribute.html
Yes, some of the standard library is in serious need of better documentation.
Go 1.5.2 closed issues: https://github.com/golang/go/issues?q=milestone%3AGo1.5.2
You would think, but people seem to have a lot of trouble getting things like `copy` and `append` and `close` right. If `keys` existed, it might not be that hard to get wrong, but I imagine almost every usage of it would be wrong and unnecessary. Nonetheless, it's not hard to write maps.Keys(m, keys interface{}) today.
An iOS port of [SyncThing](https://syncthing.net/) would be sweet. It's [MPL](https://github.com/syncthing/syncthing/blob/master/LICENSE)ed, though, so I don't know what kind of license issues you might have. I _thought_ it was GPLed, though, so they've probably retained copyright assignment for everything.
You need to send this data elsewhere?
I looked, really nice, 
Try to upgrade binary with script. But now I have to hard coded the version number or pass it as an argument. Is it possible to get the latest stable release automatically? Something like a link "go_stable_latest.tar.gz" point to what ever it should be?
You might be able to glean that info using the GitHub API. https://developer.github.com/v3/repos/releases/#get-the-latest-release
a simple: uri := "https://example.com" hc := &amp;http.Client{} // transport with skipverify doesn't work either req, err = http.NewRequest(method, uri, strings.NewReader(form.Encode())) response, err := hc.Do(req) // handshake error contents, err := ioutil.ReadAll(response.Body) It works if I do this: mTLSConfig := &amp;tls.Config{ CipherSuites: []uint16{ tls.TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA, }, } mTLSConfig.PreferServerCipherSuites = true mTLSConfig.MinVersion = tls.VersionTLS10 mTLSConfig.MaxVersion = tls.VersionTLS10 tr := &amp;http.Transport{ TLSClientConfig: mTLSConfig, } hc := &amp;http.Client{Transport: tr} So basically I checked what cipher the website supports and put that cipher manually in the transport. 
I ran your example on my machine (ubuntu 14.04) and had no problems, could it be an issue with your system? Here's a screenshot of the output: http://i.imgur.com/a3aJhDM.png Edit: This is go 1.5.1 linux/amd64
By default go uses all ciphers so I am not really sure what is wrong, try reinstalling go.
The white-on-white code examples are cute.
Some websites work because they use standard ciphers. But I had a problem with "https://api.copernica.com" and mailgun also gives problems.
I think a book teaching programming for kids using Go would be really useful, especially if it's Creative Commons so it can be easily translated to other languages to help battle digital illiteracy.
&gt; https://api.copernica.com Fwiw, both those work for me as well.
it's great.
Since author is exploring Go, using 'Go' instead of all 3 forms (Go, Golang, golang) to refer the language is much appreciated. 
You should look into elastic beanstalk. It is a sort of batteries-included easy mode for aws stuff. Go and docker is pretty easy to get running.
The string concatenation of mixed types with `+` won't work either.
Lost but not forgotten 
why isnt it scientific?
Is fasthttp using sendfile()? Does nginx not have sendfile() turned on? Pretty impressive numbers on both if they are accurate.
I think the inheritence confusion is because developers of traditional OO languages try to catch (pun intended) a new language using the vocabulary they already know as it covers functionality and operations they understand. Much of my own learning experience with Go was to unlearn.
I see what you mean. Even after about two years with the language I still occasionally refer to unexported identifiers as "private".
In your benchmark, were you running the client on the same box as the server? If so, you may have been probing differences in thread affinity more than the differences between the servers. Look into something like [Bees With Machine Guns](https://github.com/newsapps/beeswithmachineguns) to do a more real-world test.
Nothing to do with go. Clearly referral spam.
There's quite a lot of little things going on that are keeping your code from compiling. It's pretty clear what you're trying to do, but it looks like you're trying to do it the same way you did it in [whatever language you used before]. I'd recommend starting with a Go tutorial, and working from there. You might like to try [A Tour of Go](https://tour.golang.org/welcome/1) to learn the basics of the environment in an interactive format (where you can test changes to your code, then run them, and see what it does or if it works).
Here's a set of changes that seems to work on my end. https://play.golang.org/p/lJcvOThkNV Note: This particular code won't run "properly" on the go playground, as the code executes in an environment where trying to read from `os.Stdin` always gives you an End-of-file. I added some simple error handling to illustrate this.
You need to start thinking in the target language and its library. For example, if the symbol you want to skip is going to be single rune/character, read string from input, slice/get the first rune, and then pass that rune as a delimiter to ReadString in the subsequent loop. In that loop check for returned err and stop looping when it is io.EOF. Alternatively, start using Scanner instead. There are examples for Scanner in the documentation for the bufio package.
[Caddy is a web server](https://caddyserver.com/docs/faq), fyi.
I see a lot of Java developers say "inherit by composition". When they use inherit in that manner I assume they are talking about things like code re-use, rather than actual OOP. I realise it's not technically correct, but the meaning is understood within the Java community. Technically they should say "use composition instead of inheritance".
This is a very cool project. However from a system administration standpoint having reading from stdin (without even checking if stdin is a tty) as a possible behavior isn't acceptable, and from the same standpoint the choice to treat ~ as the default to cache configurations is somewhat astonishing, while that's fine convention for things like linux containers it's very bad to assume home is a writable and reasonable place to cache or store persistent data. To contend in the same space as nginx and apache all development needs to proceed keeping in mind packaging guidelines for major linux distros and unixlikes, including their notions of hier(7) and init and how services are to be configured. It might be better to provide the letsencrypt support as a separate commandline utility that parses caddyfiles.
Thanks for your feedback. From the [docs](https://caddyserver.com/docs/cli), you should use the -agree and -email flags in automated environments and, with a non-empty email, this will bypass reading from stdin, guaranteed. The behavior of using $HOME to store the certs is documented, so you can change $HOME if running in constrained environments. If you want to use a separate utility, there's [lego](https://github.com/xenolf/lego).
https://gist.githubusercontent.com/jpillora/dcabf16e99d087eae6e0/raw/install-go.sh (Note, in addition to installing latest Go, this script also sets the default GOPATH in your .bash_profile so you might need to edit it match your needs)
Ah, I didn't know about ECS Task Definition, I'll look into it. Thanks!
Yeah, my web application will have additional files so I figured Docker was a good way to keep everything together.
In Go, `nil` is a valid value. Yes, dereferencing it causes a runtime error, but so does dividing by zero. Had `Bar` been a pointer method rather than a field, it could have potentially executed without any error. As a result, a heuristic to prevent dereferencing nil could never be exhaustive in Go. That means that which cases would potentially be caught and which wouldn't would become implementation dependent, since different heuristics might be used. This is generally bad, since it makes what constitutes a legal program somewhat arbitrary and hard for a user to predict, not to mention potentially non-portable. As a result, this kind of analysis is better suited to tools like go vet. Go only does this type of analysis in the most limited situations, such as dividing by a literal zero. Swift catches this case because `nil` isn't a valid value unless you're using an explicitly optional type, and then you have to unwrap the optional in order to access the contained value. This requires a more complex type system. It's also incompatible with Go's simpler initialization strategy, which is that every type has a zero value which it can be initialized to by default without calling any user code. Swift requires more complex initialization tracking, since there's no value that can be chosen as a default. If you use implicitly optional types in Swift, you get the same behaviour as in Go.
I think that will grab the source code and compile it and it would need to install a lot of dependence packages. But anyway I will give it a go. 
It sounded like you already knew how to get the binary given the version number, so I figured the API would be enough to figure out the latest version number. Maybe I misunderstood.
Looks right to me. Why would you have a pointer and not use it? Use Unit Tests to catch these easy assertions before committing a change. Your code is incorrect.
Objects are devalued in Go, memory and instructions are clearly split and composed with interfaces and structs, with package APIs taking the role of organizing code, instead of big classes or class hierarchies.
Is there any book like cookbook for go?
Excellent article.
The struct isn't nil, the pointer is.
Why Memcached over Redis?
What the heck are you on about?
It's not a big deal, just let it go.
I'm sorry you took my comment that way. At the same time, I don't see what Rust has to do with the question. And the last comment was not aimed at you but more of a general feeling of mine (which I should not have expressed perhaps). To keep short, escape analysis is not sufficient here. What you want is data flow analysis. You are not only looking at lifetimes but also values and how they change throughout the program. (as I explained to the OP) 
Curious to know what sorts of issues Options in Rust have. Do they fail to prevent the use of null pointers or do they create other even larger problems?
Awesome summary. Lately, I found that using sync.WaitGroup instead of the empty struct increases the readabilty of the code. 
Yes you can...But App Engine is more expensive. Iron.io is a bit closer to Lambda, but that too is also more expensive than Lambda. Google also has a really cool service called Apps Script. I only wish it worked with Go.
Indeed. Redis' single thread can sometimes be useful and sometimes be a hindrance. 
You need to read some documentation man.
Does it still discriminate against white male participants?
About 1/3 of the presentations at GopherCon 2015 were rather shallow in their technical depth. There was only one presentation on distributed programming in GO (gokit), none on messaging patterns, and none on horizontal scaling of go applications. However the organizers spoke highly about a need for diversity in the Go community. While I do strongly support diversity, it should not be used to sacrifice technical depth at a technical conference. After the conference was over some friends and I discovered several rejected talks which provided the technical depth so many of us desired. This year I will be waiting for the list of talks to be published before I burn vacation days and a few hundred dollars. 
I think Twitter‚Äôs Senior VP Of Engineering said it best. ‚ÄúDiversity Is Important, But We Won‚Äôt Lower The Bar‚Äù. As a business owner who employees people and more importantly want's to keep the [right] and [qualified] people employed. Companies should be first and foremost employing the right people based on specific merits that will push the company forward, regardless of their background. I echo /r/coding_4_fun. I would love to see really technically inclined presentations. Not really fluff pieces by non-white males because they want to hit a diversity target.
&gt; This year I will be waiting for the list of talks to be published before I burn vacation days and a few hundred dollars. Ditto. I was somewhat disappointed with this year's conference. A couple presenters were completely unprepared (e.g. "sorry, I put these slides together last night"), there was redundancy between some of the talks (e.g. 2 or 3 covered Go's evolution/roots), and there seemed to be lots of technical problems (e.g. presenter laptops not connecting to the big screens) that could have been shaken out during a dry run.
I'm using Vim with vim-go and alot of other plugins (neocomplete, syntastic....)
Thanks for the tip :)!
That presentation was horrible. Another speaker just quit halfway because "that's all the slides I have". Good job on the diversity!
I wonder how this compares in features to https://github.com/xenolf/lego
In general, don't program language $X as if it was language $Y. Don't program Haskell like it's C. Don't program Python like it's Java. Don't program Go like it's Lisp. The point of each language is the design trade-offs it makes. If you don't internalize those trade-offs, and adjust your style to them, you will be missing the sweet spot of whatever $X happens to be this time around. For Go, the trade-offs are very, very consciously chosen, and a critical part of the reason for the whole language to exist.
Because meaningful stack traces are considered more important: https://groups.google.com/d/msg/golang-nuts/nOS2FEiIAaM/miAg83qEn-AJ
Not an expert here, but I think it is mostly an ideological choice instead of a technical one. Go developers like to stress that Go is not a functional programming language although it has closures. So I guess they are not very keen on endorsing recursion either. And when you are not inclined towards solving problems recursively, the advantage of tail call elimination becomes somewhat limited.
Well then I think that this submission violates the infamous code of conduct.
Please note that `func F(b *bytes.Buffer)` and `func F(r io.Reader)` are only loosely compatible. Changing a function signature in *any* way is a breaking change because of interfaces, or things as simple as `var f func(b *bytes.Buffer)`
That's right: https://github.com/motemen/gompatible/issues/2
The link seems missing...
Is this what you are trying to do? http://play.golang.org/p/UksdO9ThQQ Slices are a little bit like "flexible" arrays. In you code, you gave a string to a function that wants a slice of strings, i.e. multiple strings. I assumed you wanted to print the first character (rune in Go) that the predicate applies to. When ranging over a slice, you get two values: the first is the index in the slice and the second is the element at that index. When ranging over a string, you get the position of the character in the string as first value and the character (rune) as the second. When ranging over a map, the first value is the key, and the second is the value associated to the key in the map. Let me know if you have any more questions, or if what I wrote is not what you were trying to do. By the way, a more idiomatic way to implement your program in Go would be to pass a function to the findFirst[Rune] function which it would use to check the predicate, like here: http://play.golang.org/p/R3gEEd4AV_
Aha, ok. Didn't know about the infinite stack part. Then it is even more interesting that tail calls are not eliminated since the infinite stack is clearly a step towards that direction. Thanks for the information.
anybody could give example? i have no idea what it means
A trampoline is a function that "bounces" a function to the top of a call stack in a loop. [Here's an example recursive factorial function](http://play.golang.org/p/rAIgzGqAOM). In the example `Factorial` is a trampoline that acts as the tail call eliminator for `fac`. In the example, the trampoline is pretty much pointless because the recursion is also pretty much pointless (recursion really only makes sense for problems with trees, not arrays), but supposing you had a couple of different functions that needed to be able to call each other recursively (e.g. for a state machine), you could do it like this.
So I was talking to my wife about this. She is "from groups traditionally underrepresented at technology conferences". She offered to submit my proposal as her own. Then, if selected, she would introduce me as the actual presenter at the conference. She is awesome like that.
I'd love to know what you guys would like to hear at GopherCon. It'd be interesting to see a deep-dive on the compiler, garbage collector, or scheduler, but I don't think many people would be able to apply it to their day jobs. Go as a language isn't that complicated. There's channels and goroutines to talk about, but we all know about the pipelines blog post about them. Do you find it interesting to hear how others are using Go, along with lessons learned along the way? Thats what I tried doing last year. I've been doing some different stuff with big data and horizontally-scaling services at my current gig this past year, and think some would find it interesting. I'd go into some stuff we learned along the way - CGO, Go's behavior with forking/exec, and some strategies for high availability, profiling operations in production, and how we're able to do it with Go. Thoughts?
√áa ne devrait pas √™tre ¬´ j'aime les gaufres ¬ª ?
How does this look? https://play.golang.org/p/aUdCKy25L5
Use go-debug https://github.com/mailgun/godebug
Sounds good. You should propose a talk!
I'm not an author, just submitter. Funny enough, I was _building_ the same thing. :) And yes, I wanted it for the service too. Also it can be integrated with existing services like gopkg.in. And it can be used to check SemVer semantics.
 func icoHandler(w http.ResponseWriter, r *http.Request) { http.ServeFile(w, r, "img/favicon.ico") } or func pngHandler(w http.ResponseWriter, r *http.Request) { vars := mux.Vars(r) if !strings.HasSuffix(vars["item"], ".png") { http.Error(w, "Wrong File Extension", http.StatusNotFound) return } file, err = ioutil.ReadFile("img/" + vars["item"]) if err != nil { http.Error(w, err.Error(), http.StatusNotFound) return } w.Header().Set("Content-type", "image/png") w.Write(file) } PROTIP: use something like https://github.com/diegobernardes/ttlcache for a cache so you don't read from the disk every time you want to serve the image. EDIT: added .png checking, completed functions
awesome! ping me via email, maybe we can work together on it?
Maybe?http://play.golang.org/p/pEArDVhgAu
Please fix the README, it says `dlsniper/intellij-idea`, where it is `dlsniper/docker-intellij` instead.
Thanks for the explanation! There is [very little](https://www.google.com/search?q=golang+method+expressions) on Google about this feature, so I guess it isn't that common.
Oups. Fixed. Thank you!
Question for gophers, since we're on the subject: I have a struct Foo that contains a RWMutex. There's several goroutines accessing Foo. My policy is that each method Foo.Bar() performs its own RLock() or Lock() as appropriate. That is, Foo's mutex is only ever locked by Foo methods, and not by external methods. Now there's this problem: There are places where I need to perform several real-only operations on Foo: foo.Bar1() // read-only foo.Bar2() // read-only foo.Bar3() // read-only I don't want foo to be written to between calls. So then this motivates locking the mutex outside of foo: foo.Mutex.RLock() foo.Bar1() foo.Bar2() foo.Bar3() foo.Mutex.RUnlock() If I coded it this way, I'd have a reentract RLock() call, which is a no-no and has been shown to potentially deadlock. But I remove the RLock() calls from inside each Bar(), then the responsibility for locks would always shift to the **calling** function, which is also bad. What's the solution? 
Technically, what you need to do is to defer the unlock, which is guaranteed to unlock it on return. foo.Mutex.RLock() defer foo.Mutex.RUnlock() foo.Bar1() foo.Bar2() foo.Bar3() But knowing nothing about your application, it looks to me like you should rethink a bit your APIs, that access pattern doesn't look very healthy.
This was true until [the commit](https://github.com/valyala/fasthttp/commit/778f4a10542e87e51624db8b5072d1629314d2ae), which enables sendfile for large files. Now fasthttp works faster than nginx on both small and large files.
Thank you for the clarification.
`become` seems pointless to me though, because there's already a clean way of reusing stack frame: `for`-loops. As I see it, recursive calls are either 1. a simple recursion 2. a tree transversal or 3. something more complicated (e.g. an a ‚Üí b ‚Üí a recursion cycle). In case 1, use a `for`-loop. In case 2, you can't use TCE because you need the stack. In case 3, you can't use `become` without some complicated machinery to keep track of things.
Your interface is too fine grained. If you need to lock across multiple operations, you need to refactor to a more coarse grained interface. i.e: foo.PerformBar1AndBar2AndBar3() or foo.Perform(func(f) { f.Bar1(); f.Bar2(); f.Bar3(); }) That said, if a coarse-grained interface doesn't feel appropriate you probably have a deeper structural problem in your software that needs to be addressed. In my experience this is a strong indication that the locking really should be the responsibility of an outside observer, not internal to the object.
Most uses of maps don't span multiple goroutines, so the memory and CPU overhead on every operation would be burned for nothing. When maps are used across goroutines, it's not enough to just keep then from becoming corrupt, you also need to decide what is correct interaction. E.g., what would it mean to `m[k] += 1` in that map?
Agreed on `defer`. See my reply to /u/bmurphy1976 regarding the API. In some cases, combining methods into a coarser-grained API makes sense. But there's still cases where even a fine-grained operation (like serialization) might require exposing lock-responsibility to caller.
It's a good thing all applications are as simple as the hello world benchmark in that they don't need a database connection and they don't talk to any other services. Otherwise this article would be in danger of being irrelevant. /sarcasm Go has many advantages. It's a succinct language. It's easy to get started with. It's great to get shit done. This being the case, I don't understand why people keep talking about 'speed'. In most cases, the time that database connections and service calls take dwarfs the time taken to execute code which is why these 'hello world' benchmarks are not only worthless but also (unintentionally or otherwise) misleading. **Edit 1:** Also, having just one keyword for looping is not a trade-off but a feature - and a damn good one at that **Edit 2:** (in response to /u/knightress_oxhide below) Nobody here is saying that speed doesn't matter. All I'm saying is that if you're going to evangelize a language or state why you use it over language X - without any context - then using performance as the reason just doesn't hold water. Otherwise the whole world would be programming in C (or maybe even assembly language). Moreover, neither Ruby nor Python (the subject languages of the article) profess to being blazing fast. So if you're going to say another language is better than these, then the language needs to be better at what these languages do best. And this would then be a valid reason for stating why one would use language X over language Y. If you're not going to do this then don't compare languages. It's perfectly fine to say 'I use language X because it is fast'. But when you say 'I use language X over language Y because language X is fast' then you're being disingenuous, either unintentionally or otherwise - especially towards new programmers/devs.
/u/rsc just mailed out https://go-review.googlesource.com/17501 to make the Go runtime blow up earlier and more aggressively if it detects misuse. That should root out bugs earlier and reduce the number of false bug reports people file against Go. 
True, however, I have found that Go is faster and better for managing said connections and deserializing/serializing data transferred on them.
I always find it amazing that there's such a lack of best-practice info on this. It's not limited to golang -- the same problem exists in C++, etc. There is "The Little Book of Semaphores" PDF, which is a lot of fun, but it focuses on translating abstract consumer-producer scenarios into non-deadlocked code. It doesn't cover best practices on how to, e.g., lock a tree, or how to best handle ownership. I agree with your two points. I'll add that another way to think of it is as a continuum of complexity vs efficiency. On one end, you can have a single global RW lock, and simply remember to lock it at every top level call. It's ok to accidentally use Lock() instead of RLock() here -- you just have to not RLock() when you need a Lock(). On the other end of the spectrum, obviously, each object has a lock. You have to be a lot more careful, but the code is technically more performant. You can easily mess up even the global-lock implementation, by forgetting to Lock().
Totally agree with everything you said. And that leads to immutable data structures, actors, CSP, STM, and just about every other method should be tried first before resorting to locks. 
Performance is literally one of the last things that any modern development team looks at when choosing a technology to use. Servers are cheaper than people, so it is much more important to have a language people can write faster than one which is even twice as fast. Fortunately Go tends to do both acceptably well. Though I can't say I agree with the `for` loop thing. If the goal is to write readable code, then which reads better: `for x &gt; 10` or `while x &gt; 10`. Even if `for` and `while` were aliased to mean the exact same thing and programmers could use the one which reads better in their app, I feel that would be an improvement to the language. 
If you are working for an employer and clock in and out after 8 hours, sure. Go eat your dinner and don't forget your vegetables too! However, there are some who either work for start ups, for themselves or maybe they are doing a hackathon for themselves to get funding? Whatever the case may be, 16 hours a day is nothing when you have a target to hit!
Yeah, the author is right. This is sad. :(
That bulleted list is why people use the language, there's no shame in that. However, I agree with you, the "best" doesn't exist outside of one's own preferences. Python can do the job just fine and most people would hardly know the difference.
Quick, someone build an open-source Go library that publishes Go blogs with these bullet points.
I believe we should be happy that our community grows and that people enjoy using the language. Besides we probably got a similar impression about Go when we started back then. Why criticize the people that start now?
ah, nice so we'll finally have a sort of `ConcurrentModificationException` :P but really, this should definitely be helpful, especially for newcomers/learners or to help catch stupid mistakes before they create official issue noise. PS: It was funny to see a private runtime function called [`throw()`](https://github.com/golang/go/blob/go1.5.2/src/runtime/panic.go#L519-L529). I actually cringed a tiny bit. Ha.
But how do you know what to search for if you have no idea what it's called? The spec is good for understanding the behaviour of something you're already aware of, but it feels pretty opaque beyond that. 
I'm glad you made this comment. I work for a startup... my startup in which I am the sole developer. I work no more than 8 hours a day. I am able to get amazing things done in record time by following one rule... I don't overwork. I don't measure my success by one nights achievement. I measure my success weekly. Not only do I produce better code than I did when I worked 15 hour days, I am a more efficient programmer. Your brain cannot function for 16 hours straight. Unless the business is burning down, there is no excuse. Working in a startup does not mean that you are selling your life away for the acute possibility of wealth. If your conditions are not appropriate, you are being played for a sucker. Long coding stints create the kind of maintenance bugs that cause what I term bug loops. The kind of bad practices that end up dragging you back into long nights. Programmers are one of the few professions that can generate enormous wealth with few people. That fact has been exploited by employers and investors. You can still make it by refusing to be exploited. I would even argue that you increase your odds of success by leaving a little fuel in the tank for yourself. 
Yes, that's fine. It's the same as any variable in Go: any number of goroutines can be reading a variable concurrently, but if there's a goroutine writing, nobody else can be either reading or writing. 
Ludum Dare is this week.
&gt;Good article, but I didn't like how it glossed over JS being significantly faster than Python/Ruby in many cases. It was left out of the performance benchmark altogether. Agreed it would be nice to see how they benchmark these! That said, you can't really just compare node to Python (and ruby, I'm guessing, but I'm more familiar with Python). You'd need to compare it to an async framework (aio.web, twisted, tornado, etc.). Most times they run benchies against flask or django using the standard gunicorn workers (similar to how rails works iirc). Each request is a process, not an evented loop in the latter. 
https://33.media.tumblr.com/123e96b4d3019a8b697ca596c07569b0/tumblr_nw52vgYiIN1rz6w0do1_500.gif
If you don't understand why people keep talking about it, perhaps you need to research more. As they say, if it stinks every where you go, perhaps its you who needs to wipe your butt. You say its "perfectly fine", but you don't act like it.
Because it wasn't directed at you. It wasn't even directed at the OP or the person who wrote the article. It was directed at this trend in general.
&gt; It's development environment isn't quite mature yet to do large-scale multiple Go projects development For a language used at Google... I think what the blog show is that even a language made for large entreprise can be used very quickly for very small project. That's all and it's very important because it means you can try it without loosing lot of time. Then you decide if you whant to continue or not. I had the same feeling with Python. 
Yeah, but it's a revelation for each of them. Nothing wrong with sharing your personal experience! 
Interesting attempt at a ruby style DSL in Go.
I think so too, after researching more, using a directory called "testdata/" seems to be the best way. Seems that's how the go devs also go about testing with local files. Running go help packages also gives further information, including this piece here... &gt; Directory and file names that begin with "." or "_" are ignored by the go tool, as are directories named "testdata" Thanks!
Yes. What's so strange?
It's not "open source" it's free software and the point is to allow others to inspect the code, or to fork it. In future I'll start accepting patches, but right now I'd like to "shape" the engine myself.
NTRU forces GPL, which is a nogo.
I don't have an answer, and fortunately you seem to have found one. I just wanted to let you know that this was an excellent question, and actually helped me with a problem I've been having. (Basically the same one you were having, only with pictures.) Thanks, OP, for being awesome. 
No worries, don't forget to check out the other comments in this thread. Using an ```io.reader``` also seems like a useful way of approaching this problem.
I see a lot of this, and it makes me sad. It seems the functional programming community and the Go community simply can't get along. They inherently are at odds with each other. :/
Not saying the language sucks, it's the managing *multiple* projects. I don't work at Google, but I am guessing their workflow includes sharing/open-source code across all departments, but that's not how everyone works. When you want to start distributing closed-source Go packages, you are screwed. Go needs its own *official* package manager. [The fact that there are so many open source package manager for Go](https://github.com/golang/go/wiki/PackageManagementTools) says something about the product maturity. Again, I am using Go, and I like it, and that's why I am here. But you can just feel that this language needs a couple more iterations to feel complete.
&gt; No SSH Keys &gt; Our robust Distelli agent handles everything. Is that a selling point? I'd be hard pressed to think of something that was *less* annoying than copying my SSH keys and pasting them into a web application.
Why is the style of the &lt;code&gt; tags red on red on this blog? They are not more important than the rest of the text.
The animation is only as quick as the speed it runs at. I can learn more elsewhere; there's no shortage of things to learn. I did ignore it, but thought feedback to the author might be beneficial. I expect others ignored it without feedback.
What do you think about possibly adding it as a tab to gotools.org? For example, similar to imports tab, http://gotools.org/github.com/motemen/gompatible?tab=imports. The whole point of gotools.org was to offer other tools with with URLs just like godoc.org. (Note, its internal code is very messy right now because it came from a prototype, but it's also extremely short and would take just a few full-time days to re-organize it to be clean.)
Being that `modTime` is being set on execution, wouldn't the mod time always return the current time, thus the client always will request a new file?
Am I understanding this correctly? are they manually trying to do vendoring with this third_party directory? If so, then I do the same thing with Go 1.5 the vendor experiment setting and glide. Why not ditch goimports for glide then?
No, modTime is set when the app loads. Typically the app will run for a long time (like weeks). Of course you can use some other logic for setting this value.
You have the opportunity to take the md5 value of your concatenated file and produce an etag out of it. You would get more accurate and potentially longer lived caching out of the deal.
Simply put: concurrent performance. memcached handles large numbers of concurrent users at the same time better than Redis. We have had memcached in production for several years and it has worked well the entire time, handling very large numbers of concurrent connections / requests. We tend toward key-value storage use cases so the model is good for us. Source: I'm the author of Rend
Sounds like a good idea. I'll have to get the details on how to get the md5 value.
I happen to use direnv with it. Makes configuring the environment seamless.
I think this is your strongest option. Unless your production code HAS to touch the FS. On a side note, normally you want to keep your `package main` thin, and therefore have functionality that you want to unit test in sub packages.
I just now saw the need for a code "feature explainer". Like you put in some code and it tells you what features of the language the code is using, perhaps sorted by how common the feature is, then links to relevant docs for each feature.
NOOOOOO! Ugh, please god, no. :)
If you use a fake server, does that imply an integration test? I thought an integration test is when you test the integration between two components. So like if you have a Client -&gt; Server, the integration test would be testing the "-&gt;". If you have Client -&gt; FakeServer, then you really have a end to end test for the Client, right?
Hi. I am familiar with Otto. Yes, they aim to do that but Otto is far from complete or even being competent. Also, Otto is application focused rather than being environment specific. With Otto you can setup a project with a configured infrastructure and add in dependencies automatically. Like, this, what I did, if it would be Docker specific, I could setup a Go infrastructure make it of type='go' and do a project called docker-develop or something like that. But here, with Vagrant, I was aiming for a general infrastructure for any kind of project. Otto is nice, if you want automatic dependancy handling for A project, but I think it still lacks parts of which Vagrant provides, which is an easy way to configure a general environment which could be of any kind. It's written in Go so that's a good approach. Hashicorp got good with Go over the years. I'm sure they will get there eventually, but for now, Otto is beta, whatever they say. :-)
That's a great idea, but sounds very hard to implement, especially if the code you pasted relies on components outside the standard library. Is there anything like that for *any* language out there?
I don't believe there is, but it would only work well for language constructs, not external code. It's not too hard to do, in theory. Take whatever parses the code into an AST, then describe each of the features in that AST. It's the same as compiling/running the code, but just keeping track of the constructs used. Might be worth trying it out with Python or something and could be very helpful.
Not if you protect them with a RWMutex
Not really, no. [dl.google.com has been written in Go for a while now.](https://talks.golang.org/2013/oscon-dl.slide) 
I added an Otto example for you how you would go ahead and try to set this up using Otto. But it's pretty insane at the moment. I would say, give a year at least to try and catch up with today's needs and maybe they will get into a point where otto is useful. Because it relies on magic, and something they call "industry best practices" I fear that it will never really take off. For example, even getting it to NOT use ubuntu precise was a b*tch. Hope this answers your question. :) Cheers!
The GoUsers page lists a number of other known uses at Google: https://github.com/golang/go/wiki/GoUsers
Honestly your blatant disregard for standards makes me avoid the package. I respect your opinion but why bother having any standards of we say it's unimportant? This is fine for pet projects you just run internally places but doesn't fly in my opinion when releasing open source projects for the community. Depends on your goals but your disregard means I'll be staying far away from this. 
Ok, ok I'll remove the restriction. But just to be clear. You can improve the program. Just fork it and share the changes. It is free software.
True, though they said they tried go 1.5 vendor experiment in the article, but goimports didn't support it yet. That was basically my reason for suggesting to dump goimports for glide, I also thought glide was the recommended tool now, though I can't remember where I read that.
Just implement the net.Listener interface to do pooling... I think that's what other people do... But if you want to respond to the client in http protocol then you just implement that in your handlers but that means accepting a connection which you want to pool... Either way I don't see the need of the net/http implementing that Not really an answer to why as you asked
The need comes from a simple fact - the cost of goroutine creation.
I'm agree that Go needs better tools for this. It's also a good things when the core team prefer to wait than to jump in the wrong direction. Compare to Python, after 25 years we just begin to see a start of a solution to deploy projects. It doesn't means that Python was not mature for large-scale multiple projects since years. We already can manage multiple projects in Go, it's just not so easy and universal as it can be.
So you try to tell me that having spawned 300k+ goroutines seems legit? I mean spawned by HTTP server, not business logic workers.
&gt; Do the goroutine creation time is so small that it can be skipped? This is the goal, where goroutines are NOT threads but a finer lighter construct meant to simplify real world concurrent programming (like just starting a goroutine instead of managing a pool). The official golang blog covers a ton, as does the official documentation. e.g.: https://blog.golang.org/pipelines
Watch the official videos and read the official documentation before jumping into blogs, you absolutely can get all of the important Golang specifics here: http://blog.golang.org/concurrency-is-not-parallelism
The point of an RWMutex is to lock out everything on a write but allow unlimited reading callers, as reading does not change the underlying data. You must know the characteristics of Bar1/Bar2/Bar3 (do they only read?) to really make any decision here. Foobar examples are almost always terrible as the specific solution absolutely depends on what you are doing specifically. There are many styles to writing concurrent code and many ways to refactor.
Don't use `math.Min`. Use this instead: func min(a, b int) int { if a &lt; b { return a } return b } This gives you: `body[:min(len(body), 17)]` EDIT: Just curious, why the downvote(s)?
Unfortunately C call overhead is show stopper for using Go with OpenGL (unless you do some insane hacking and move all logic to C which nullifies advantages of Go).
Well that was why I was using math.Min
On the surface the simplest solution would be to move your Bar[1-3] logic into foo.bar[1-3]Unsafe() functions that don't do the locking. Have the foo.Bar[1-3]() functions lock, call the unsafe version and unlock. Your second example would get the lock and then use the three unsafe methods. If you do this, then unit test in tight loops and use the race detector liberally. It's easy to accidentally make a small mistake that skips a step this way.
Yeah, it seems like that should exist. On the other hand, it's hardly more work to write that than it is to do the import and use it. :/
Yeah, this drives me *crazy*. I understand the lack of generics, some things are hard and there are tradeoffs. But the lack of min/max funcs for all the numeric types (and time.Duration, don't forget that one!!) is infuriating. I wrote my own. It wasn't so bad, but it was time I could have spent doing something else.
Incidentally, math.Min is more complex than the trivial implementation you can have with integers since it has to deal with +/- Inf, +/- 0, and NaN. The casting is actually less efficient because of this, but insignificantly so.
I liked [Go By Example](https://gobyexample.com/).
Nope. Named array types support all the same operations as unnamed array types. There's very limited situations where a named type can't be used where the underlying type might be. The only examples I can think of are that named pointer types don't have methods, and of course any two named non-interface types won't be assignment compatible regardless of their underlying types. Also, most binary operators (bit shifts aside) are between values of the same type.
Converting between types with the same underlying type is trivial, since nothing has to be done to the value. Some conversions involve allocation, such as between byte slices and strings, or from a non-pointer type to an interface. Converting between strings and rune slices also involves encoding/decoding utf-8.
Conversions are generally not *that* efficient. I only use them when I need to
Its possible to write the business logic of a mobile app in Go and then ship it on with only the UI written with native APIs. An example of this is Ivy - [App Store](https://itunes.apple.com/us/app/ivy-big-number-calculator/id1012116478) and [Play Store](https://play.google.com/store/apps/details?id=org.golang.ivy). Its a little cumbersome to pull off right now, but I think it will get easier with Go 1.6 and beyond. You can find a bunch of cool Go projects at this page - [awesome-go](https://github.com/avelino/awesome-go). My favourites are * [Bolt](https://github.com/boltdb/bolt) - an embedded key-value store, inspired by LMDB. * [A bittorrent client](https://github.com/anacrolix/torrent) * [Docker](https://github.com/docker/docker) and [Kubernetes](https://github.com/kubernetes/kubernetes), used for managing containers. * [etcd](https://github.com/coreos/etcd) - A highly-available key value store for shared configuration * And as mentioned by someone else, [hugo](https://github.com/spf13/hugo), used for creating static sites.
See https://golang.org/doc/effective_go.html#pointers_vs_values The gist is that Go will convert from a pointer to a value to call a method with a value receiver. It will also covert the other way if the value is addressable.
https://golang.org/ref/spec#Calls A method call x.m() is valid if the method set of (the type of) x contains m and the argument list can be assigned to the parameter list of m. If x is addressable and &amp;x's method set contains m, x.m() is shorthand for(&amp;x).m()
Hi, I've created a tool for extracting dependency relation from software. You can use this tool for extracting #include dependency relation from a software written in C, import dependency relation from a software written in Go, target dependency from Makefile or module dependency from Haskell softwares. Hope it help you to investigate the code structure of your projects.
Sure but, assuming it's a `[18]byte`, if you want to use the full width of `c.Key` you'll need to use `c.Key[0:18]` as the copy destination (or `c.Key[:]` which is a more convenient way to slice a whole array).
Try out http://exercism.io/. It has a ton of very nice problems which you can work on. And per review is always a plus for your code.
While [worker pool used in fasthttp](https://github.com/valyala/fasthttp/blob/master/workerpool.go) gives measurable performance gain comparing to creating a goroutine per request, it may be completely eliminated in the future if golang runtime is optimized properly, i.e. if it will keep per-cpu stack of stopped goroutines (metadata + stack) for subsequent reuse. I don't know how golang runtime manages stopped goroutines at the moment, but it looks like there is a room for further optimizations.
It's Inconsolata, monospace. btw, you can right click the text and click "inspect element" to find details like these. Edit: The code on the homepage uses Menlo, monospace while that on the tour site uses Inconsolata, monospace.
Sadly, you can't write competitive OpenGL games (calling C functions has significant overhead). If there was a way to use Go with C without overhead (even in thread/goroutine "simplified" mode) this would be near perfect language.
I get why they need cgo for RockDB but for snappy and lz4 there are definitely pure Go versions and even if they differ it shouldn't be too hard to port. https://github.com/bkaradzic/go-lz4 https://github.com/golang/snappy
https://xkcd.com/1053/
I love this area, I just wish more sql migration projects compared themselves to [liquibase](http://www.liquibase.org/)
note that thread affinity is relatively easy to setup: lock a goroutine to a thread, delegate all calls to that goroutine by sending commands over a channel. e.g. (for ptrace) https://github.com/golang/debug/blob/master/ogle/program/server/ptrace.go#L15 
FYI: the code samples in K&amp;D (printed edition) are, as far as I can tell, Consolas. Very similar to Inconsolata (Used on the tour page), but not open source. I think it's owned by Microsoft. From the copyright notice of the book: "Typeset by the authors in Minion Pro, Lato and Consolas, using Go, groff, ghostscript, and a host of other open-source Unix tools. Figures were created in Google Drawings."
Although I still use Logrus myself, [Our way to Go by dailymotion](http://engineering.dailymotion.com/our-way-to-go/) and [Let‚Äôs talk about logging by Dave Cheney](http://dave.cheney.net/2015/11/05/lets-talk-about-logging) really pushed me away from leveled logs.
that's a fair point, but we actually have those as dependencies of RocksDB, so the Go implementations don't help us much there.
&gt; I understand the lack of generics Well, that makes one of us!
This is very cool. Thanks!
Somehow this is the first time I'd heard of Ivy... very cool.
Besides [awesome-go](https://github.com/avelino/awesome-go), this is another way to get an idea of interesting projects being built with Go: https://github.com/trending?l=go&amp;since=monthly Also, if you like listening to podcasts, TheChangelog is a great podcast where developers of cool open source projects are interviewed and discuss what they're up to. Here are the episodes that are about Go projects: https://changelog.com/tagged/go/
smells like somebody made it their lives work to disparage go, if it also had articles contradicting or explaining why something is the way it is, it might come off less insane
https://dzone.com/articles/i-don%E2%80%99t-much-get-go &gt; Personally I think code without punctuation (semicolons) looks like English grammar without punctuations (no period) &gt; You end up with what look like run-on sentences &gt; Of course they‚Äôre not run-on sentences, they‚Äôre just lazily written ones with poor grammar &gt; wat next, lolcode? omg
author of [Azul3D](http://azul3d.org/) here, I've actually [benchmarked this extensively](https://github.com/slimsag/cgo-batching) in the past. It's _not actually as bad as you would think_, and people are still writing OpenGL apps in Go and they do run OK. But as the number of GL calls go up, so does the overhead (obviously). You won't be making the next GTA in Go, but the less intensive 70% or so of games on Steam today you most likely can without many issues :)
Yes, 120-180 ns per call is result in my benchmarks too. Go is OK for graphic bound games with smaller world / number of nodes (you could make Quake with it without a problem) but for large world with lot of object in it just won't work. Overhead is a real shame because Go is perfect garbage collected language for 3d games. Its matrix/vector calculations are near close to C in speed (from 1x to 1.2x), and its GC is one of the best (if not best) right now, pauses with Go 1.5 are really insignificant. But all that is worthless when simple calling of OpenGL kills all that performance.
This is awesome. Now I just need someone to build a widget for Reddit Enhancement Suite so that I never have to see these articles in my feed. Any takers?
Lol, that's funny. (why would anyone want to collect that? O_o) Haters gonna hate.
I don't like a lot of things of Go but I would never write about them, I just use it whenever I need it and role with it :) 
Why do we need this if we can just search for go in /r/programming?
My only concerns: * Designed, Maintained, Owned by Google Inc. * Hosted on github.com * Governed by law of the United States of America Everything else can be done by you or the standard library. I am a USA citizen and buy into the west coast technology culture. [**Edit**] If the golang team or a Google lawyer wrote documentation explaining the implications of each of these then I'd be happy.
I use LiteIDE every day and I love it. The refactoring support is also excelent, at least for my needs.
Kudos!
I have plenty of gripes with Go, but almost none of them are on the list. This sounds more like a list of features: * error handling * no semicolons at line endings * has pointers * no asserts * opinionated (i.e., sane defaults) * is compiled * no `this` * `nil` * no immutables (because the `const` keyword in C++ is so straightforward?) * no pattern matching * project layout is bad (i.e., project layout is sane) * stupid syntax (i.e., sane syntax) * method access modifiers or misinformation: * only interops with C * no OOP
Just for some fun stuff.
The [Ian Byrd's article](http://byrd.im/go-is-poor/) is quite reasonable among all of them.
The code for Ivy is available [HERE](https://go.googlesource.com/mobile/+/master/example/ivy/)
I know. Wait till they discover Ruby, Python, LISP, or Haskell...
A conversion is different from a cast because it will create a *copy*. C-style casts are like "hey, trust me on this, this type is just like that other type" and Go conversions literally create a copy of the value you're converting from - so they're usually "cheap" but not necessary "free" like casts. 
Has anyone done any benchmarking around some worthwhile game code to get a real world idea of the impact? I've been toying with OpenGL development in Go but haven't come anywhere close to anything complex enough to judge the bottleneck. I was mainly aiming to learn OpenGL and how engines work under the hood and considered moving to an established engine to work on games. But I like Go so much I'd like to stay and build out my own purpose built engine.
Are you a https://www.reddit.com/user/tucnak/ 's alt?
Stuck in 70's
LiteIDE is great!
Similar thread https://www.reddit.com/r/golang/comments/3w42nq/the_cost_and_complexity_of_cgo/
[Here's another list](https://github.com/golang/go/issues).
yeah, i started with atom, but quickly switched to LiteIDE which for me works great. haven't tried intellij yet
It would be a very short document.
&gt; the worst compiler toolchain ever What. the. heck.
&gt; "Why is every line an if statement?" If you deduct error handling, Go shouldn't have more if statements than other languages. Although some of the generics-workarounds (type assertions, etc) may introduce if statements that wouldn't be in languages with more conventional generic programming mechanisms.
Just interested, what were the places where you needed to write generic code? There are lots of ways of implementing generics and they make different tradeoffs. Which one is the right one? Which one makes the right trade-offs for Go?
That's in the 'features' category. In other words, I consider not requiring semicolons to be a feature, not a gripe.
Most recently I needed to write an index that would fetch data from N JSON APIs, transform it, and stick the output into a SQL database. Each API had a different structure, and the transforms and SQL representations were all different, but the considerable overall pipeline code was the same (the difference was only the types of data that were passed around). Similarly, there was a server application that had N HTTP APIs that mapped neatly to particular SQL queries; again, the only difference was the structure of the data that was coming out of the SQL database, the transform operations, and the final JSON representation. Ultimately, I decided the cost of maintaining multiple type-safe copies of the high-level index and server pipelines was too great, and I elected to use `interface{}` as the data type, and do my transforms against that. The code is less readable and there are a few places where I need to use reflection. It wasn't impossible, but it ended up taking a LOT more time and producing much less-readable code than the generic alternative. &gt; There are lots of ways of implementing generics and they make different tradeoffs. Which one is the right one? Which one makes the right trade-offs for Go? To be clear, my argument isn't anything like, "Generics are easy and the Go authors are stupid for not implementing them!"; it's simply, "Generics are useful and I wish Go had them." That said, it seems to me that the best option would be templates. The only "tradeoff" I'm aware of is code-bloat, but that's really a non-issue when you're telling people to go *manually* write a OrderedMap implementation for every combination of types you plan to instantiate (the alternative to code bloat would be to write a single implementation that deals in `interface{}`s and create type-safe wrapper APIs around it for every combination of types you'd like to use--this also falls under the purview of templates). Basically, templates seem like they're just automating everything we do today, by hand.
* no immutables (because the const keyword in C++ is so straightforward?) * no pattern matching In what world is a language better without these? You cherry-pick const in C++ as a strawman. Immutable bindings/fields in Scala, Ocaml, even Java are easy to understand and definitely useful. Also how is no pattern matching a feature? What's so wrong about it that having it in your language makes it worse? * `nil` Why is a nil value that inhabits every non-value type (with no way to opt-out) a feature?
Because it is quite successful compared to languages of same age. (Rust, Scala, and whole bunch of other JVM languages). 
I had to do something similar recently. The pipeline was the same, but extraction from the JSON/XML differed depending on the source. To do this I defined an interface, and then created specialised structs per source which implemented the interface. I also have a "factory" style method that return the appropriate struct for a given data source. The code is quite clear. Generics were something I initially missed when I started Go. When writing Go, I switch to thinking in interfaces and composition and I end up with code that is in my opinion very clear :)
sure, *you* want it. then someone elsr wants "just that one thing". and then someone else writes a blog post about why missing x y and z makes it a horrible language
I don't think it's healthy to be obsessed over criticism and/or critics of your favourite language. People have different opinions on programming languages all the time, popular or not, and will continue to do so as long as more than 1 programming language exists. Just chill.
&gt; The only "tradeoff" I'm aware of is code-bloat. This is true if generics are unboxed under the hood as opposed to boxed. If generics are boxed, there's a very serious performance and memory cost to using them (depending on what you work on: this is a deal-breaker for my numerical work, but doesn't really matter for my game design projects). This isn't my area of expertise at all (maybe someone can step in and explain this better), so I can't tell you why you would choose boxed generics over unboxed generics. But there's definitely some fairly compelling arguments for using them as your implementation since most modern programming languages use boxed generics (with some of the primitive types unboxed either by default or under certain access patterns). C++ is the only exception I can think of. I also seem to remember reading once that interfaces have some sort of very non-trivial interaction with generics, but I can't back that claim up.
*most*? I think that's a bit of a big step. There's an awful lot of C++ I've had to deal with where Go would work fine.
SameSame
https://github.com/golang/glog
That's why I said "templates" and not "generics". Templates are what you would refer to as unboxed (I think; I'm not much of a Java guy these days). Pretend you are tired of writing StringLinkedList and IntLinkedList and MyTypeLinkedList; templates allow you to write the template LinkedList&lt;T&gt; and it will generate the StringLinkedList that you would have written whenever you use LinkedList&lt;string&gt;. As far as I know, it's not more magical than that. Someone else in this thread was talking about covariance and contravariance pertaining to interfaces and template interactions. I'm not sure what these terms mean specifically, but Go's not the first language to tackle these problems. I mean, this whole argument has been hashed out over and over and over and I'm not aware of a substantive technical limitation (like I said, there are languages out there that prove out the concept!).
note that io.Reader is an interface. There are many implementations which do different things. If it is a network request like you are using, then you can use the same buffer over and over again: buf := make([]byte,128*1024) for{ conn.Read(buf) } This loads straight from the os memory into your buffer. There is no additional allocation.
A++
Can you show the code before/after interface (for both cases)? (The reason I'm asking, is that I'm updating [SGoG](https://docs.google.com/document/d/1vrAy9gMpMoS3uaVphB32uVXX4pi-HnNjkMEgyAHX4N4/edit#), whenever I see good real-world examples or new approaches suggested).
That's also my mental model for how templates work, and based off of that, they seem like the obvious choice. But my point was that when most PL designers sit down and hash out how they want to handle this type of thing, they decide that they don't want their language to have templates and they do want their language to have boxed generics (e.g. OCaml, Haskell, C# before they got a JIT which took care of it, etc.). So, there has to be some sort of non-trivial drawback to their inclusion which causes this to happen as often as it does. It's not obvious to me that integrating Go-like interfaces with generics is a solved problem for two reasons: 1. Go-like interfaces are not exactly common (although obviously many programming languages have some sort of structure called "interface"). The only other language that I can think of which has structures that work in the same way is OCaml (but, obviously, I'm not familiar with every programming language, so there are probably others). 2. It's not clear what tradeoffs had to be made under the hood in these languages in order to include both generics and Go-like interfaces in these languages. Ocaml has them both, but Ocaml also has a much more complicated type system, lives in a different programming paradigm, has boxed generics, has a slower compiler, usually generates slower code, etc. (Now, one argument you'll _never_ hear me make is that interfaces somehow make generics obsolete or that generics aren't that useful or any of the other things people on this subreddit sometimes say. Go's lack of generics is often very frustrating.)
Most of the issues criticized by the different authors are seen as advantages of Go. It's good that everyone can choose the language they like most (and I feel sorry if you can't).
&gt; Adding them would probably double the size of the language specification. Not necessarily. You would probably be able to fit some generics approaches on a single page. (e.g. package templates) Generics can be invariant; which seems to fit much better with Go.
&gt; If generics are boxed, there's a very serious performance and memory cost to using them (depending on what you work on: this is a deal-breaker for my numerical work, but doesn't really matter for my game design projects). Boxing vs non-boxed, depends also on the size of the element being boxed. The larger the boxed element, the less effect the boxing has on the overall speed. &gt; I also seem to remember reading once that interfaces have some sort of very non-trivial interaction with generics, but I can't back that claim up. It depends, which generics you mean. Some have, some don't. But mostly, yes contravariance, covariance vs. invariance; is one of them.
The project layout / the enforced structure upon you + generics is the only thing I really miss but after you've been working with it for a while you find it's "ok" other than that I love Go ;-).
Sure, no-problem... and I understand. Also, when making the simplified version, make sure it has a real-world value. Don't trivialize the problem, but try to show the full complexity of the domain. I try to make the examples as close to real-world as possible... but, even now I'm not happy with all of the examples.
But it's a copy. You could avoid the copy with a ReaderFrom
got an example?
I'm not sure off the top of my head how to do it in that direction. io.Copy automatically does it in the other direction from a file to a TCP connection. io.Copy to ioutil.Discard would be the first thing I'd try for this type of problem, though.
even that allocates an 8k buffer (at least it is a pooled buffer): https://golang.org/src/io/ioutil/ioutil.go#L147
https://github.com/ivpusic/golog
And honestly, it's one of the best features of Go.
Make a pull request then. Devs arent exactly opposed to adding it, just no-one bothered to do it yet
He is talking about Go's assembly and linker stuff and it's indeed quite dreadful.
Same here. It is the best IDE I have ever used and adds a lot to easiness of using Go. Best balance of speed, features and simplicity.
I agree with you, I think it would be a subtle problem between the theory and the practice. Currently I have not decided how this should handle this kind of problem, but the looseness should be noted explicitly.
Yeah, sadly thats true, I noticed it a few hours later when I downloaded the release.
[It sort of has them](http://blog.jonathanoliver.com/golang-has-generics/)
Here are a few: http://geekmonkey.org/2012/09/comparison-of-ides-for-google-go/
I intend to as soon as I acquire the time and expertise. But that's unlikely in the foreseeable future. ;)
It seems to me that main developers just not use it in a way that would require heavy use of generics and that is why none of them bothered to implement it
"Better C" was the reason I've started using it, I needed something low-level(ish) but without the burden of learning hundreds of C traps and memory management, and ease of deployment is just a bonus. It seems like they plan to sort out GC and clean up code first before implementing anything else, and sub-10ms GC on 200G+ heaps looks [promising](http://www.infoq.com/presentations/go-gc-performance) ( 24:38 and 26:33 ) 
&gt; It sort of has them That's not generics, it's interface polymorphism. The author is confused. For example, you can't use interface polymorphism to implement LinkedList&lt;T&gt; or OrderedMap&lt;K, V&gt;. Today the best you can do is implement them on `interface{}` and type-assert it back to the type you intended. This is slow and error prone, and it produces hard-to-read code.
Maybe go needs a preprocessor? Then you could do something like this: #define TYPE Int import "containers" Bjarne Stroustrup used a similar approach in his prototype "C with Classes" language. In other words, Go's facilities for writing generic code has caught up with the level of C++ in 1989.
Cheers. Someone in this thread though I was your puppet :D
Does it support Linux and/or BSD in addition to Win?
That "Let's talk about logging by Dave Cheney" link seems broken. In hopes of helping others access this info, here is a working link: http://dave.cheney.net/2015/11/05/lets-talk-about-logging
Okay, if you want.
Much appreciated! Building Go from source on my Beaglebone Black is a bit too much. The prebuilt arm7 binaries are an excellent solution and I hope the Go team will eventually provide them officially.
Do we know how much it costs yet?
Thanks for the writeup. Makes sense.
To reject it purely on where it's hosted, is surely an oversight
Google once let their domain registration lapse, one cannot then conclude that Google sucks
forgetting to re-register something, vs willfully replacing something that is not yours with a similar thing that infects computers with bloatware. That is an odd comparison.
LiteIDE, to date, has been malware free
I would love to experiment with taking a command buffer approach to C interop. The last rendering backend I did actually "rendered" commands into an API agnostic command buffer and then submitted the entire batch to the actual renderer backends. Taking a similar approach, one could do the command generation on the Go side and then pay the cost of crossing the language barrier once instead of each call.
X28 is now included in a portable package for all interested Windows users: https://github.com/josephspurrier/golang-portable-windows/releases/tag/1.5.2-r.2
We implemented something similar to this about two years ago for our startups main product. Like you, we figured channels makes for a nice way to implement it in go, but unlike you, we opted to have the library return a interface{} which the user was to type-cast to a channel of the needed type. The library knew what type through reflection of a "example", or by simply passing in a reflection.Type. Both sender and reciever had to agree on the type which made any errors detectable early in testing since all modules started and got their ends during startup. We did this because we had long-running modules expecting data-streams and did not want to do typecasts every loop. Since things did not turn out too well for us (lack of customers, since we had a pretty niche B2B idea) we are looking into open-sourcing it shortly. We called our Briee (Like Brie the cheese and ee for event emitter. We liked cheese.)
Blogspam. I think Caddy is great, but you could at least have some content besides 11 lines of configuration. The sole reason for the move? &gt; I have no reason to move from Nginx to Caddy, except the feature of setup HTTPS easily with Caddy. I tried, it works, then no reason to go back. What? This post isn't even Go related. You don't even mention the damn server is _written_ in Go. I get it, we've got some neat tools coming up written with it..but this belongs in /r/webdev, not /r/golang.
The Gemfile is slowly being reinvented. It's scary. 
I was really hoping to see how you handle mapping over functions that could error. For example, if you wanted to implement `cat` by mapping `ioutil.ReadFile` to a list of filepaths.
I'm no PHP programmer, but Go's standard library templating as well as the ecosystem surrounding web development is great. It's trivial to use and concurrent by default so making something that scales extremely well is as easy as it gets. You can definitely make do with Go's standard library alone or you can pick and choose what you want from frameworks. I for one tend to use Go's templating from the standard library, the Gin HTTP framework (a very lightweight wrapper around net/http+the very fast httprouter mux) and contrib/sessions from gin to store per-session data.
People who care about dependency management?
If Go "paused and looked at what every _other_ languages were doing", then a lot of the things we like about Go wouldn't be in Go.
Yes, but memory bandwidth should *far* exceed network bandwidth (e.g. 4+GB/sec vs ~100MBps for a saturated Gbps network), so it shouldn't matter. You can avoid any heap allocation using an array: var buf [128*1024]byte for { if _, err := conn.Read(buf[:]); err != nil { break } }
Yes, I tried something similar, instead of eg. 100 x glMultMatrix I would store 100 matrix data in buffer and call C function once that would go trough buffer and do the job. This avoids C overhead, but loading buffer adds overhead too. I didn't do comprehensive tests as I doubt it would work satisfactory with heavy load.
&gt; I wonder if there is a chance the Go compiler will get tail recursion optimization In discussion about this from just a few days ago https://www.reddit.com/r/golang/comments/3vndco/why_no_tail_call_elimination/ the top comment links to a discussion from a few years ago with real answers. In any case, if there's something you don't know, ask about it; You don't need to resort to such ludicrous statements like &gt; or if that would be viewed as encouraging different programming styles and therefore harmful.
&gt; I also do not like how the PHP-FIG (again just my personal opinion) seem to be affecting the PHP community on a global scale with their PSRs and their rantings about how everyone are free to choose their recommendations, yet at the same time members work tirelessly in an effort to get everyone to adopt their so-called "modern approach". You are going to _hate_ Go if standards and strong conventions bother you.
You are right that Go shouldn't be trying to grab the features of other languages. This happens to be about solving feature gaps in toolchains (rather than in the language itself) that don't have sufficient solutions today.
ouch, thanks! (I noticed I didn't have Dave's blog in my feed system while pasting the links together.. X11 pastafail)
Standards and strong conventions doesn't bother me, not one bit, rather on the contrary. It's only the way the PHP-FIG works that bothers me.
I had not heard of php-fig before so i did some research. Their website shows they have 6 accepted standards of which 1 is deprecated and replaced with a newer version, though still accepted. Browsing them I discover that the majority of their content seem to be already enforced by Go (in some manner), either in the language syntax, by the standard automated tools (e.g. gofmt) or by angry yells from the peanut gallery.
PHP-FIG is not an official standard organization in any way.
I know.
Why is this not a valid complaint? Shouldn't we talk about it instead of just ignoring it with the excuse that people on progit and HN generally like to complain about Go anyway.
[removed]
Wow, this post doesn't show in the new section anymore. Has it been hidden/removed by mods? Isn't this a valid issue that we should discuss?
I think dep management for a language where you have to constantly ship all of your deps isnt necessarily the right model for a language that produces statically linked binaries. Instead of adopting all the same old tools that enable the same old mistakes, we should develop a new mindset about libraries, both in terms of developing and adopting them.
It should be noted that FIG stands for *Framework Interoperability Group* and the rationale is to standardize development practices between all major PHP frameworks. Their standards are enforced for contributions to core framework code only rather than to the general community. That said, most companies use it in the same way as PEP8 is used -- for readability of code. Since there is a lot more visual noise (curly braces, semi-colons, etc) then the rules must be more stringent.
Impressive. The 1.5 GC timings were a huge drop from what we had with 1.4. The Go team is doing amazing work here. GC timings are usually a tradeoff of course, but I think this must be getting towards the territory of GC not being an impact for the majority of applications. Yes, GC will always matter so extremely time sensitive apps, but for me and the apps I'm working on, life is good :)
Go is great for web development, but if you prefer the old style "PHP as a template language" model, Go won't solve you problems (although it has a great template library which can fill that niche, allowing for a clean separation between HTML rendering and more typical backend things).
What process would be a new mindset that meets the following general requirements? * Audit-able dependencies to check if a security release has come out. * Handling changes to the public API for a package and making sure the right version is being used in your application. * Knowing enough about dependencies to solve for complex situations. For example, your application has a dependency that has a dependency which you also include but the versions are different. * Reproducible builds If you look at other languages whether they are static or dynamically typed and interpreted or compiled the same patterns emerge because we have the same problems to solve. If you have a proposal on another way to solve these problems that's easier and meets everyones needs we'd love to hear them. I for one want a simpler setup. The solutions only get as complicated as the needs.
I've been wanting to switch from PHP to something more sane. What made you choose Go over other alternatives like Python? Some of the things listed in "Things we have loved" are also checked off with other languages, so I assume there's more behind the decision. I've got a bit of background in Python so I'm relatively comfortable with it and systems like CherryPy seem alright so far. I haven't really taken the time to learn Go yet since it seems a bit daunting -- but maybe that's just me not giving it time to sink in. So, why Go in particular?
Yep.
I don't see why is this racist rubbish still allowed here.
Among many reasons: - Go was the least "stack changing" in our minds. Go had the ability to provide its own http server built into the language. So we didn't need to learn how to tweak and set up something like Tornado, or Tomcat, etc. - The Go syntax is closer to that of PHP than something like Ruby or Python. Remember we had some lifelong set in their ways PHP developers on the team that we wanted to alienate as little as possible. We were looking for a fast time to market language. - Simplicity: Python is pretty close to being simple. But you still have to worry about things like pip being installed and working properly (and all of your projects packages) and the whole debacle between Python 2.x and Python 3.x. With Go we can send a binary to the server that just works with no dependencies. It will be interesting to see if we have similar issues when Go 2 comes out. - We felt that Go handled large code bases at a core level. It felt that you couldn't easily get that same level of project and dependency management in Python without introducing massive frameworks like Django. - EDIT: Another massive reason is the fact Go is written in Go. If I want to see how an io writer is implemented I can pull up the source code or the test that supports it. I can't do that for PHP or Python (or most any other language). I find myself reading core libs all the time for ideas on good habits and just how to do things in general. Disclaimer: I haven't truly given Python the college try. These are only opinions we gathered and not a jab at Python. 
Talking about it is an absolute timewaste. It can't be changed now, so it *doesn't matter* if it's the right choice or not (it might matter to any one person but talking about it won't change that). We can talk about it when go 2 is on the horizon, but up until then it's just one of the "oh well, it's how it is, get used to it or don't", things. :)
Can anyone please make a dependency managment tool that knows how to work with git repositories via ssh? Or perhaps there is one and I don't know about it?
Yeah, Go is great. OpenResty on the other hand has kinda PHP style focus on a web. A lot of PHP devs seem to be moving to Go and OpenResty (or both). I don't like this over engineered "lets make PHP a Java clone" either, and do everything OOP.
From this talk: https://www.reddit.com/r/golang/comments/3wcozk/go_gc_prioritizing_low_latency_and_simplicity/
I have switched from PHP to Go about 1.5 years ago ([my website](http://www.outfitadviser.eu)). To my surprise all the functionality i need was readily available either through the standard libraries or by quick Google searches. Also the average load time of my website is like 150 ms for Google crawlers compared to seconds for an analytical tool written in PHP that also runs on the same server. I love the static type system, that it most likely works if it compiles, the built-in templating system and that it compiles into one binary. Just set up a reverse proxy in Apache and you can run multiple services side-by-side. I don't love that there's so many PHP-made plugins and stuff, so you really have to write most things on your own.
Agreed. It was pain for me working with external api's. 
This is clich√©, but, generics.
Glide can. In the *glide.yaml* file specify the *repo* and optionally the *vcs* attribute. [Here is an example](https://github.com/Masterminds/glide/blob/591b53cb09369f35c512454ea5ab72815e830387/glide.yaml#L6).
More like nanosecond in some cases... 
Luckily there are a lot of [options](https://en.wikipedia.org/wiki/Post-quantum_cryptography) besides NTRU, and some are free of patents.
Are the trade offs between 1.5 and 1.6 listed anywhere?
This conference is a little strange to me anyways. I went in 2015, and felt like it was a non-stop sells pitch to use Go. Then when I would walk around and meet people, everyone was just asking if I wanted a job. I think I would prefer more technical deep dives and talks that are bringing ideas to the table.
Can you post an actual example on how to use this?
[**@jmoiron**](https://twitter.com/jmoiron/) &gt; [2015-09-25 17:33 UTC](https://twitter.com/jmoiron/status/647463976679407616) &gt; greenkeeper.io shows how different the philosophy is towards dependencies in the \#JavaScript community vs the \#Golang community ---- ^This ^message ^was ^created ^by ^a ^bot [^[Contact ^creator]](http://np.reddit.com/message/compose/?to=jasie3k&amp;amp;subject=TweetsInCommentsBot)[^[Source ^code]](https://github.com/janpetryk/reddit-bot) 
I don't think it's well intentioned.
Nope, that is not supported yet. I hacked this this morning. So it lacks many features. 
You seriously think that **32 lines of code** need separate library, githup repo and reddit topic?
&gt; is Go a language I can use to create another programming language &gt; Has anyone used Go to create other programming languages? Not "other" languages *per se* but Go is itself implemented in Go[1] and, obviously, Go is a programming language (;&gt;) so, yeah, Go can be used to implement programming languages at least as featureful as Go. [1] https://go-review.googlesource.com/#/c/5652/
So you wait until goroutines inputting data on their chans into a single consumer chan all call .TurnOff(): func (l *LightsOff) TurnOff() { if atomic.AddInt32(&amp;l.count, -1) == 0 { l.callback() } } Then the user of the library provided callback closing of the single consumer chan. So this library has a specific use case: fan-in closing with bounded input data and a known number of input goroutines. A LightsOff object effectively flags when a crash on write is no longer possible / all data has been input, by having a known number of goroutines stating they are done with TurnOff() calls. Specifically, this cannot be used when the input goroutines are dynamically added or their data is unbounded (where they stick around indefinitely). LightsOff must known how many input goroutines there are at creation time. I roughly solved a specific dynamic fan-in producer/consumer closing problem I had with a cancellation pipeline (https://blog.golang.org/pipelines) - once the single consumer knows its time to close it drops a "cancel" message at the start of the producer pipeline, the producer of producers closes, each producer closes, any data in flight is consumed, then the consumer sees all is done ahead of it and finally closes.
&gt; It's only the way the PHP-FIG works that bothers me. For example?
Na, you didn't need to put it in a gist. This is pretty reasonable to me, and is `go get`able
How do tools like bundler, npm, pip, and others lead to a culture that undervalues the cost of dependencies? Which costs? How are they undervalued? For example, tools like [David](https://david-dm.org) help you see the state of dependencies for open source projects using npm. Are you using something that depends on a version of something with a security vulnerability? You can visualize that which is important for project developers and consumers. Greenkeeper, which was in your link, is a tool to try and automate keeping dependencies up to date. That's great and I fully support that. Greenkeeper requires a *package.json* file to handle the updates. The other tools I've seen need version ranges and tools (similar to Glide) to provide the underpinnings. It would be great to have a bot that could read the version ranges in a *glide.yaml* file, see new versions are out, and do a pull request with an updated *glide.lock* file. Then you could keep up to date with API versioning and have the latest versions that support that. Why do cultures that adopt semver and overuse small deps undervalue API stability? Can you give examples? With your comments on dependency handling in general it's not so much about gilde, a management tool, but rather the use of dependencies at all. Vendoring is a storage mechanism. If you vendor dependencies you can loose version info and the ability to easily track security releases. That's a problem that's easily to fall in. Note, with glide you can use semver, lock versions, and vendor deps. It supports detecting and updating your vendored deps. I agree about the automation of updating dependencies. But, even the tool your reference uses npm to do that. The other tools I've seen work with composer, maven, etc. Without the tooling what will the automation be built on?
Yeah, I think PHP is getting more and more bloated.
you could make a new cryptocurrency
I'm not sure I follow. Is it a then lie to say GCC is in C because it relies on a C compiler to be bootstrapped? Or that the Roslyn C# compiler is not written in C#?
Be aware that the link you refer to was written in 2014. Things may have changed since then.
I don't like that. Every library is a dependency. I don't like introducing dependencies into my programs.
Standard logger and https://github.com/natefinch/lumberjack/tree/v2.0 for rotation, when I need rotation.
Thanks, I'll give it a try.
Only if you're calling `gocd` without arguments. My main use for this is for going to a package directly from anywhere on the file system without having to type out the full import path. I suppose you could mimick gocd's basic functionality with something like this: gocd() { CDPATH=$GOPATH/src cd &amp;&amp; cd "$1" } But then you wouldn't have the package find ability. One could argue you could probably do that in bash as well but I figured I was working with Go already so why not
Agreed. The people who are annoyed by the if statements don't quite realize that exception-languages don't have that because they just sweep the problems under the rug.
Generics aren't an OOP feature. Lots of OOP languages have them, but they're not part of OO.
Sure. I don't know what monads are; do you think you could point me to an example of an error monad, preferably in Go?
Interesting, I've done something similar, [godir](https://github.com/death/godir2).
Sorry, I took your "what else is missing" as a more general question.
Disagree if you like, but they hardly seem like emotional reasons to me.
CDPATH already works this way, it's not for zero-argument cd: [travis@mars ~]$ export CDPATH=$GOPATH/src [travis@mars ~]$ cd / [travis@mars /]$ cd github.com/lib/pq /home/travis/gocode/src/github.com/lib/pq [travis@mars ~/gocode/src/github.com/lib/pq]$ EDIT: this is bash, not sure about other shells.
&gt; forgot about a package being included in import and it's not required [goimports](https://godoc.org/golang.org/x/tools/cmd/goimports) solves that problem once and for all.
I have more interesting tasks. I did one, though (day 4). Didn't submit it.
Don't judge other people by your own limitations. I've seen a group of coders knock out things that would make you faint over the course of just a few weeks working full-pelt for the chance of a massive multi-million dollar investment. But alas, I get it. You aren't a rockstar. Not everyone can be! eh?
I'm not sure if you misunderstood my analogy or if I'm misunderstanding your response, but by "exceptions sweep problems under the rug", I meant that exceptions are hidden until someone explicitly goes looking for them (via a try/catch higher in the callstack). This is in opposition to returned errors which must be dealt with explicitly at every level, which means ignoring the error is almost an explicit action (although Java incorporates exceptions into the method signature, and failing to handle them is a compiler error, which is pretty cool).
I [started](https://github.com/nii236/advent-of-code-go) but didn't stick with it.
&gt; tools like gem, npm, and pip lead to a culture that undervalues the cost of dependencies; tooling has made declaring and fetching them easy but have not helped responsible maintenance and tracking updates (which is the actual hard part) Sure but the alternative that is pushed by go (vendoring) is an order of magnitude worse than that. Instead of "set lib version to `&gt; 2.0`" and lock it, then remove lock when you want to upgrade (and dotest-&gt;fix-&gt;repeat dance) , you got a bunch of dirs with collection of libs to manually upgrade it. And tool that tracks updates could be pretty easily integrated into that. Just make a tool that: * extracts semver numbers from glide. * does a bisect of upstream versions based on test suite to find on which one your code breaks * upgrade and repeat for rest of deps * generates report of upgrade and applies it if it was successful (no broken upgrades) That way at least "bugfix" updates would be trivial to do without breakage (provided you got good test suite), just let it run overnight
Mutating (or passing) a slice doesn't create a copy. It's all still referencing the same underlying array so this would be your own fault. The bug exists in the first inner loop of permute. I think this is what you're looking for: https://play.golang.org/p/pP9HkqWaMn
The problem is on line 22. The `append` will overwrite the original slice. To stop this, change line 20 to `pre := values[:x:x]`, which prevents `append` from being able to modify `pre` by explicitly setting `pre`'s capacity.
I didn't think to put my solutions online. I'll do so after the end :)
I should hope it has a similar style to K&amp;R; K's one of the guys writing it! :)
Biggest issue I see is that the Writer doesn't implement io.Writer. Ditto for reader.
I just meant that it is possible to successfully, correctly, and maintainably implement traditional try/catch exception blocks. These are just computers tools us humans wire together. I do agree with all of your points and would much rather be presented with local handling over digging for out of order blocks of code. But no code is right for every use.
This is my first library for Go. I am hoping by throwing it into the larger Go community I might net some useful feedback about Go best practices or just how I could improve on this piece of software. I have mixed feelings about some of the design, but by and large I'm happy with how things came out and I believe that it came out this well mostly as a result of the elegance of the Go language. Thumbs up to the Go developers.
Subtype polymorphism, late-bound `this`.
I can't think of a way to beat linear time for a single call, and the constants seem like they'd be trivially optimized as well, so I'm not really sure what's going on there. It seems like if you're calling it a lot on the same string you could benefit from some precomputation though. Just compute the totals at each index, and then subtract when you want the count between.
1.py: def test(): 'abcdefghijklmnopqrstuvwxyz'.count('no') if __name__ == '__main__': import timeit seconds = timeit.timeit("test()", setup="from __main__ import test", number=20000000) sec_per_op = seconds / 20000000. ns_per_op = 10**9 * sec_per_op print(ns_per_op, "ns/op") --- $ python 1.py 650.573050976 ns/op $ python3 1.py 307.5997867010301 ns/op --- 1_test.go: package main import ( "strings" "testing" ) func Benchmark(b *testing.B) { for i := 0; i &lt; b.N; i++ { strings.Count("abcdefghijklmnopqrstuvwxyz", "no") } } --- $ go test -bench=. testing: warning: no tests to run PASS Benchmark-4 20000000 78.6 ns/op --- Questions? 
it's a nice library. do you have some benchmarks or a handle on how fast it is, compared to, say, straight `encoding/binary` or `encoding/gob` ? also, do you envision integration with `go generate` to automatically generate reflect-less (un)marshalling methods for types ?
&gt; do you have some benchmarks or a handle on how fast it is, compared to, say, straight encoding/binary or encoding/gob ? No, not yet. I should probably do that, but I am aware that it is going to be pretty slow compared to encoding/binary for now. &gt; also, do you envision integration with go generate to automatically generate reflect-less (un)marshalling methods for types ? Yes, in fact, this is one of my overall goals for the project. I haven't actually gotten anything done in that direction, though, mainly because I am still pondering about how to handle certain things. But my intent is to support it by generating Pack/Unpack/SizeOf methods for types so that it can work transparently with the same API.
In which way? Do you expect the gofile.Writer.Write to take an io.Writer as an argument, or would you want to see gofile.Writer.Write actually be an io.Writer? Because if is the latter, how would one specify where needs to be written to?
That doesn't make a difference due to how UTF-8 is designed.
It's not particularly hard. I [solved](http://codegolf.stackexchange.com/a/45426/134) a similar problem a while ago (where I wanted to count the number of unique substrings for each length instead of getting them). A fast solution is this: 1. [suffix-sort](https://en.wikipedia.org/wiki/Suffix_array) the array in O(n) or O(n log n) and compute an [LCP array](https://en.wikipedia.org/wiki/LCP_array) at the same time. 2. Observe the differences between each adjacent entry in the suffix sorted array, use the LCP array to cut down the time to find this difference. See the linked post on how to get unique substrings from that. Due to the properties of UTF-8, you can pretend that the input uses a single-byte encoding. Then throw out all substrings you found that don't begin or end in a full UTF-8 sequence.
Just curious: When the code did not work you really thought "This probably is a compiler error handling slices and I am the first to notice that that slice code is buggy in the Go compiler." The chance that such a prominent feature of the language in complete normal usage is broken is practically zero. 
If you are seriously asking this question you will not be able to implement your own language without some heavy reading before starting coding. Really. 
Well, if you read that patent file: &gt; Google hereby grants to You a perpetual, worldwide, non-exclusive, &gt; no-charge, royalty-free, irrevocable (except as stated in this section) &gt; patent license to make, have made, use, offer to sell, sell, import, &gt; transfer and otherwise run, modify and propagate the contents of this &gt; implementation of Go, [...]
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/php] [Switching from PHP to Go : golang](https://np.reddit.com/r/PHP/comments/3wn6b9/switching_from_php_to_go_golang/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
Very Cute! I'm not part of that rockstar group. I'm part of the group that part funded them. Also your point of view is very wrong. I'm rolling in money by funding various start ups and having my own group of devs. They don't work 16 hour days, nor do they work fast pace either. Not for a normal working environment! I know you "millienals" don't like to work. It's ok Precious! You'll never have the wealth of the baby-boomers!
This is not functional programming. The generated code uses for loops and no magic. As for your comment regarding the new slice, your absolutely correct. A simple for loop with everything in there would take less time. This reduction in 'efficiency' is probably acceptable in the author's use case. 
You are right in that these are functional programming concepts. However, this doesn't make the code above 'functional programming'. There are no immutable data structures or pure functions which, imo, are part of the core of functional programming. If just having first class functional was enough to qualify a language as functional, then Go would partly be a functional language on account of functions being first class in it. There would probably be world peace before there's a universally accepted definition of functional programming :). 
&gt; In which way? Do you expect the gofile.Writer.Write to take an io.Writer as an argument, I'm guessing you mean a reader, but that wouldn't be very nice to use. &gt; or would you want to see gofile.Writer.Write actually be an io.Writer? That's what I meants. &gt; Because if is the latter, how would one specify where needs to be written to? Your interface is missing a file handle type.
The second part is what concerned me: &gt; If you or your agent or exclusive licensee institute or order or agree to the institution of patent litigation against any entity (including a cross-claim or counterclaim in a lawsuit) alleging that this implementation of Go or any code incorporated within this implementation of Go constitutes direct or contributory patent infringement, or inducement of patent infringement, then any patent rights granted to you under this License for this implementation of Go shall terminate as of the date such litigation is filed. I mean, that sounds fine, but here Google *is* stating a way to take away your license to a Go implementation. As I am not a lawyer I am not aware of all the ways this wording can be used or the history of these words, but perhaps there is a back-door built in here? That is my concern. Of course I can just fork the code and ignore Google. But I like what Google is doing, want to keep them upstream of what I do with Go, and want to absolutely stay above board.
I don't think so, I find information easier to find on reddit. These conversations are easier to read and will stick around as long as a mod doesn't delete this thread.
From the FAQ: &gt; **Why are (1) hardware or (2) Free or Open Source Software combined with special purpose hardware excepted from coverage under the OPN Pledge?** &gt; The focus of the OPN Pledge is Free or Open Source Software given the growing ubiquity and importance of OSS to innovation. While some open source projects around hardware have been initiated, their industry impact remains uncertain. Thus, Google has elected for now not to have the OPN apply to hardware as such. &gt; Most OSS is designed to be hardware platform agnostic and to execute on a broad range of general purpose computing devices. Special-purpose hardware, such as microprocessors or servers that incorporate unique functionality in the form of deeply embedded firmware, tend to be proprietary to their developers. For purposes of Our Pledge, we wished to support truly Free or Open Source Software, and not address edge cases where there might be questions regarding whether the use of such software is truly free or open. In any event, recognizing that customized applications of Free or Open Source Software are typically permitted for end users, we have broadly included within coverage of the Pledge Internal-Only Use of Open Source Software combined with special purpose hardware. This works for my case, I think Google is doing a great thing with this pledge and their actual weight behind it (e.g. Go being permissive open source). Thanks for the pointer /u/TheMerovius.
More of the core team read the mailing list. Only a few routinely read reddit.
I agree with your point on FP I'm still not sure if i'd prefer using this lib to a simple for loop tho. I'm just not sure the added complexity justifies the (tiny, imo) added convenience. But the code does look very nice. You might be interested in this: https://github.com/robpike/filter
Really wish I would have thought more about method names before stabilizing the API :( As it stands, I think I'll need to move that over to v2. But it's definitely good feedback. I still need to think about `restruct.Sizer` while I'm at it.
You might want to check out [Afero](https://github.com/spf13/afero) as well.
I will probably get downvoted for this opinion because this is /r/golang but it sounds like the issue with PHP is that your devs don't know how to use PHP, and Go is more idiot-proof. Here's why I think that. &gt; The deployment strategy: one binary and occasionally a folder of templates vs having to push thousands of PHP files to a server (we have some Laravel apps) You manually push the entire app, including vendor folder, from a dev box to the production server? You wouldn't have this pain with PHP if you used git and composer. &gt; The development strategy: almost all of our devs are OSX users, almost all of our servers are Linux. When we were with PHP just getting a local version running for a dev was a pain. OSX ships with PHP installed already but it's always an old version and when you introduce frameworks like Laravel suddenly every dev needs to compile mcrypt into their system (side note our devs have a strange aversion to Vagrant. They must like pain). Go on the other hand just works. There are no additional modules that need to be compiled, you don't need PDO drivers and MySQL drivers, and mcrypt and iconv, etc. So they were manually compiling PHP and its extensions, instead of using Homebrew? They must really like pain. Getting Homebrew set up takes 1 line of copy and pasting, and installing PHP and its extensions with Homebrew takes 5 minutes at most. It even supports PHP 7. &gt; Performance: due to the compilation aspect even bad Go code outperforms great PHP code. PHP 7 is getting close to the performance but again you have to write good PHP code. This is fair, but performance isn't a significant factor in most web apps--at least not until you get to the point of hundreds of visitors per second. Even PHP 5.6 (with opcache enabled) is faster than other popular web languages like Ruby and Python by 10-20% in most benchmarks. &gt; The type system: having a statically typed language has forced our devs to become better planners. In PHP they could easily say "I don't know. This function might return an object, or an array, but for now we'll return a Boolean." This easily introduces bugs into production code because they forgot to check an in_array because they thought they were dealing with an object. PHP 7 also introduces optional static typing, which you could begin implementing in your internal apps now, and most open-source libraries will probably start to implement within a few years (once PHP 5.6 support dies). (Also, as you mention later in your post, having a weak type system can be a benefit in some ways as well.) &gt; Some of our PHP projects had absolutely no tests of any kind and we would often learn of and debug bugs in production. Go on the other hand which does analysis on compilation notifies us of errors and let's us resolve before pushing to production. Our bugs are now more true bugs than developer oversight. It's not really PHP's fault if your applications had no tests. There are linters for PHP as well which will catch the same kinds of mistakes that Go's compiler will catch, but having a compiler (or a linter) does not free you from writing tests. Even a good developer can write perfectly syntactically valid code that compiles but doesn't run properly because of a bug, even something as small as typing the wrong number or a `1` instead of an `i` (actually something I've done before that took about a half hour to debug). Now I don't want to make it sound like Go is a bad language or anything. I don't have enough experience with it to make that judgment. But Reddit has this hivemind mentality that PHP is terrible, so I dislike it when people blame PHP for things that really, aren't PHP's fault.
Thanks for the condescending response, I didn't really think it was a bug with how slices are implemented.
s/bugs/features/g with golang slices. slices return pointers to the original data in new arrays, so i ran into some weird edge cases while iterating over a slice and taking subsections of it.
While his tone is definitely condescending his point is still one to consider in the future. Remember your title "Bug with slices or my own fault?" This would definitely lead one to believe (myself included) that you were chalking it up to a bug more than assuming you might have made a mistake. In the future it might make more clear your thoughts and intentions if you just asked what you might have done wrong. Again, I don't agree with the condescending comment but I do think you might not be fully aware how you worded your post. **edit**: used the wrong word
I think you might be interested in https://github.com/ksimka/go-is-not-good
[bytes.Count](https://golang.org/pkg/bytes/#Count) doesn't count bytes, it counts instances of a pattern within the byte slice. ASCII and Unicode are accepted in a byte slice, so the result wouldn't change.
You're modifying "text" in the inside loop, but your code never reads text except at the beginning of the function. Did you mean to modify "runes" instead?
I wasn't being flippant, by the way. Regardless, Go, Python, Node all will work as simple HTTP servers. The benefits of Go are really purely subjective. It's a compiled language with a strong core, a sane dependency management system and lower abstractions. Plus, GC. Without modifying the packets on the wire (which isn't easily done with any type of sys call, see the middler link), you're really just using the supported proxy settings for whatever platform you want to target. If you do want to modify another processes memory, then you'll basically need to figure out which osx process corresponds to the IP stack, find out where in the memory it buffers network packets and then use GDB or vmread/vmwrite to modify it. Try these references: https://books.google.com/books?id=KjX57QfgwZkC, http://stackoverflow.com/questions/10668/reading-other-process-memory-in-os-x 
meh, I've got java on my system, python is relatively less evil than that.
Not awful points. To "rebuttal" your points- We did/do use Composer. Still our PHP applications lay in the hundreds of files range just from our codebase. We do use Homebrew, and it has made lives much easier. But it's still the fact PHP needs those modules in the first place. Sure it's an install once and you're good. Not to mention communicating new modules back to ops so they could install it on the servers... But compared to Go which has no additional needed modules. We do happen to sit in the hundreds of requests a second range so performance is a factor when introducing new tech. Also we switched a little over a year ago. This was before PHP 7 spec was solidified. Had we known then that PHP 7 was going to be such a massive overhaul maybe it would have gotten more pull in decision making. All your points aren't bad. Just (opinion talking) Go was so simple in comparison. 
"Error monad" means you have a way to compose functions that could produce errors. Given: func A(T)(U, error) { ... } func B(U)(V, error) { ... } func C(V)(W, error) { ... } You should be able to compose them: compose(C, compose(B, A)) or compose(compose(C, B), A) which should produce the same result. This gives you a function `func(T)(W, error)` which will either return the result of calling `C` with the output of calling `B` with the output of calling `A`, or else an error if any of those calls results in an error. There should also be a function for each of `T`, `U`, `V` and `W`, etc... with a signature like `func(T)(T, error)` which just returns the value passed to it without producing an error. If we call these functions `Identity_T`, `Identity_U`, etc..., then: compose(Identity_U, A) should be the same as compose(A, Identity_T) which should just be the same as `A`. --- Usually, the way you would do this is by encapsulating the `(T, error)` return signatures with types like `Result_T`. Then you can implement a method called `FlatMap`: func (rt Result_T) FlatMap(f func(T) Result_U) Result_U { if rt.error != nil { return Result_U{error: rt.error} } return f(rt.value) } // for contrast func (rt Result_T) Map(f func(T) U) Result_U { if rt.error != nil { return Result_U{error: rt.error} } return Result_U{value: f(rt.value)} } Basically, `FlatMap` is like `Map`, except that it "flattens" the result. `Map` would produce a `Result_Result_U` if the function passed to it returned `Result_U` like the one passed to `FlatMap` does. `FlatMap` flattens that, and what you get out at the end is just a `Result_U`. Then, `compose(B, A)` would just be: func compose(B func(U) Result_V, A func(T) Result_U) func(T) Result_V { return func(value T) Result_V { return A(value).FlatMap(B) } }
&gt; Go had the ability to provide its own http server built into the language. So we didn't need to learn how to tweak and set up something like Tornado, or Tomcat, etc. Python actually has its own web server built in as well. That being said Tornado is a favourite of mine - it's all user-land code too. &gt;The Go syntax is closer to that of PHP than something like Ruby or Python. Remember we had some lifelong set in their ways PHP developers on the team that we wanted to alienate as little as possible. Senior developers ought to be able to look beyond syntax. It's the semantics of the language where adaption may be slow and I feel Go differs from PHP in this regard much more. &gt;Simplicity: Python is pretty close to being simple. But you still have to worry about things like pip being installed and working properly (and all of your projects packages) and the whole debacle between Python 2.x and Python 3.x. This is probably one of the most painful aspects of Python from my perspective. Virtualenv goes a long way to resolving a lot of this but it's still a pain in the ass. &gt;We felt that Go handled large code bases at a core level. It felt that you couldn't easily get that same level of project and dependency management in Python without introducing massive frameworks like Django. I would definitely agree that Python doesn't scale particularly well. &gt;Another massive reason is the fact Go is written in Go. If I want to see how an io writer is implemented I can pull up the source code or the test that supports it. I can't do that for PHP or Python (or most any other language) Honestly in my top ten list of reasons why I love PyPy. Most of Python's standard library is already written in Python. With PyPy this is true to a greater degree and the rest is written in a Python variant (RPython). 
Ah ok, makes sense.
Something that helped me: After the first few days I switched from using a func main() to making them as unit tests. One case with the sample data and then another case for the actual problem.
Due to HSTS and certificate stapling and the like it'll be pretty much impossible to use HTTPS with something like this (and, hopefully soon, pretty much all web traffic will be HTTPS). This isn't really solvable, unless you do the interception at the endpoint of the connection, i.e. in the browser.
&gt; here Google is stating a way to take away your license to a Go implementation. Yes, I think "we won't sue you unless you sue us first" are very fair terms (and are very standard when granting such licenses). &gt; As I am not a lawyer I repeat that you should probably ask one, if you are that concerned :) reddit isn't a lawyer either and no lawyer would be allowed to give you advice on this for free on the internet on the basis of what you said so far.
You should ask your question only once: https://www.reddit.com/r/golang/comments/3wpi6w/is_it_possible_to_monitor_and_redirect_http/
I feel your pain :)
Hi I couldnt find the original post , thought it had been lost
&gt; Additional note: Slicing a string is the same as converting to a rune slice and slicing that. This is incorrect; maybe you're thinking about converting a string to a byte slice. See https://golang.org/ref/spec#Conversions_to_and_from_a_string_type Given `s := "a„ÅØb"; r := []rune(s)`, `len(s) = 5`, `len(r) = 3` and `s[:2]` yields a string with broken utf-8 data.
Go should improve its' positions in round 12 because fasthttp [has been merged](https://github.com/TechEmpower/FrameworkBenchmarks/issues/1765) :)
Very cool, my [framework](https://github.com/guregu/kami) was written mostly because the lack of context support in Goji, it uses significant chunks of Goji code. The new Goji doesn't seem to have einhorn support and stuff though, are they moving those to a separate package?
Great, I was thinking of trying gin but my first priority is goji now.
It's an article about childish articles. Having used almost all of those languages in production, it was funny and spot-on :)
the fact there exist such an article about childish articles makes it even more childish. Why do we even care? Do we want people who don't want to be gophers anyway? In my opinion its their problem if they miss such a great, once in a lifetime, opportunity.
Your butthurt is amusing. It almost seems like you are mad that people are allowed to have different opinions about Go.
Newcomers to the language see those articles and frequently take them seriously. An article like this is a good, fun way to respond to the points commonly brought up in them.
The cult mentality going on in these comments is astounding.
&gt; Are you perhaps implying that they shouldn't do so? I'm going to quote you: &gt;the fact there exist such an article about childish articles If you don't like articles poking fun at something, be consistent. &gt;Do you consider animated cat pictures a proper way to respond to the criticism of Go? Because they are also fun and carry the same amount of useful information as the article in question? Did you see animated cat pictures in this article? And would you go as far as to claim memes of that sort are a rare occurrence in the programming world? This article tackles various points with a short take on them. If you don't like it, suit yourself; some people do.
I suppose it may depend on the type of analytics you are looking to perform. I personally have very little experience with Python, so I don't know if Python is better than Go with such tasks. I know for a fact that Python is very popular for machine learning. I will say, however, that I have found it very useful in writing API servers and have personally used the language for my machine learning projects at school. I even wrote an application that interacts with Eve Online's API in Go. So I think you should give it a shot. But, again, I'm biased and have never used Python ;)
I think its poking fun at the ridiculous tone a lot of the Go critiques take in their blog posts. I'm not sure if you've seen this, https://github.com/ksimka/go-is-not-good Its surprising to see people write huge critiques of things which are superfluous to them. Its not like most of the bloggers have to use Go. If its so bad, surely others will feel the same way as you and use a different language. Why not focus your time on something that matters to you, critique that and attempt to make that better. Most of the points the blog posts make are the strengths of Go. Its odd its almost as if they want Go to just be another language. I think having a high level of pointless negativity about a subject can serve to dampen peoples legitimate critiques of things. I mean of Rob Pike goes out and constantly reads a critiques of his language that are nasty, militant, and focuses on turning Go into X programming language, eventually he's just not going to, right? If someone says, damn I like Go, heres why to show that I understand the language, but I have this issue with it. That the type of critique which can help the community. I for one enjoyed the childish nature of this blog post and it got a self absorbed chuckle out of me.
Just come to the front at one of our meetings during the altar call, and you too can learn our chants, and wear our secret go underwear, and get a url to special blessed go playground where all your questions (expressed in go) are answered!
The main advantages of golang and python are that they are both very easy to test. You should just give it a try on a prototype. It's difficult to help somebody to choose because it depends a lot of the taste of each dev. I just needed some hours to choose, loving the simplicity immediately (some may not like it and prefer a catalog of features). After that, it doesn't mean that it'll be easy ! But if you like the language you will not count the learning curve. Both languages are also very easy to use together, calling each other by http or socket for example. After years of Python, the main advantage i see with go are the speed (but not so often needed in my projects) but maybe most, the static typing and the absence of magic and good tools that will help me in refactoring. The python 2 to 3 is the last straw. *i'm not english speaker, please correct my english in private if you can !*
true :) my post was ironic.
why you don't do something productive instead of complain about go :)
Great ! I was looking for something like this last week and wondered why it did not yet exist. Made a note as possible future project. Thank you for solving ! 
I think most of those articles are written with quite a serious tone. The OP is the only one grasping at straws with maniacal laughter.
Yeah, I came from Ruby too and love Go. Not to shit on Ruby, but I do feel like Go is a huge step up.
So you actually prefer to ignore the questions raised in the articles and resort to personal attacks? This is starting to look like blatant fanboyism.
My bad with the quote. I'm not silencing you, not sure where you're getting thtat from. I'm giving my opinion. You may not, but some people like this article and yes I find it fitting as a response to the "criticism" Go has received.
There is: https://godoc.org/golang.org/x/tools/cmd/goimports
Both are very fast to write. Python is more commonly used for these kind of projects and (personally) Python is easier to use for different types of data. Both are easy to learn, but Go is a bit harder to master. Go is lower Level than Python, this can be good and bad. But Go is (MUCH) faster Personally I would use both, but it sounds like you don't know either... So I would say Learn/Use Python initially. Once you have your core functionality built... Build it again in Go... Then you will see the strengths of both and you can move forward with one or the other or both. I usually build simple to medium projects in mutiple langs so I can figure out what are the strengths and weaknesses of those langs. Langs are just tools in a tool box, and while you can hammer in a nail with a screwdriver I would musch rather use a hammer. Pont being.. One lang does not fit all and on many projects I will use Go, python, node, and what ever else to get the job done. and on a final note: make the code modular. Both langs you mentioned make it very easy to do so. 
Go rants per year could use some more input data A graph with that few data is really pointless
Now I want go underwear.
I'm not sure. I know the github README states that they're still working on this new version. Perhaps they will port those features over, or make them pluggable. Their mailing list is likely the best place to ask @ https://groups.google.com/forum/#!forum/gojiberries 
Serious Question: How is /u/BoTuLoX silencing you? They are not a mod of this sub-reddit, and have no special powers to stop you expressing an opinion. The fact that I'm replying to you should demonstrate you haven't been silenced. Accusations such as "silencing me" are also counterproductive. Agreement to disagree, and polite discussion are how we should be progressing here. Not unfounded accusations of censorship. Back on topic (sort of), if you're seriously offended by humorous criticism of PL design, you shouldn't watch [this video](https://www.destroyallsoftware.com/talks/wat). If you don't like Go, don't use it. I don't like PHP or Java. I'm still forced to use them occasionally, but I don't write comments on their respective community fora telling others they should hate them as well.
To be fair he did bring up the issues - error handling, generics, no OOP. Fact is, there have been many articles rebutting these claims and I'm not sure OP would have achieved anything my posting yet another one. Which is the point he's trying to make, all of these articles repeat the same thing over and over and he wants to help them make their posts unique.
In large codebases, there ends up being a common problem where after a large refactor you accidentally have too many imports. Go has the compiler just tell you when this has happened. The reason why it is an error is because Rob Pike doesn't believe in warnings. While I don't know if I completely agree with him, his approach does end up making things much more simple and prevents the "wall of warnings" problem with C where you start just not paying attention to potentially large problems that the C compiler warned you about, but you ignored. Considering how tools to trivially rewrite the source code are common in Go, the unused imports thing doesn't end up being a problem. Someone else pointed it out, but this exists: https://godoc.org/golang.org/x/tools/cmd/goimports I have it hooked up so every time I save it runs this command on the source file.
Nice! All the echoed and sometimes not even understood rants from the major camps combined into one article showing how silly they can sound. Rather than Haskell there should have been a whole functional group and it should have come first though the rants there sound similar to the D rant.
Use Delve for debugging Go apps: https://github.com/derekparker/delve (integrated within IntelliJ IDEA since a couple of months ago..)
Their tone may be serious but the arguments they make are still childish. You can chant "no generics" for years while people increasingly use the language just fine with no generics. At some point it becomes butt hurt whinning from people that just don't want to like the language and don't want others to like it either.
A group of people using a language showing agreement that there are rants aimed at the language from cult like groups using other languages is cult mentality? 
So you actually prefer to ignore the points raised in this article? Go is seeing some pretty good adoption with no generics, no exceptions etc. When do we admit that maybe its the design of the language as it is that's driving this adoption? And when you boil it down to this somebody always says no its Google driving adoption just like this article points out. And if these features are so necessary why hasn't anyone forked the language and added them. I mean if there are all these folks that want Go with these features they could do that instead of letting a few write these whiny articles over and over.
I imagine you could easily and precisely accomplish this by using the [go list](https://golang.org/cmd/go/#hdr-List_packages) command, combined with [go oracle &lt;callees | callers&gt;](https://golang.org/s/oracle-user-manual) on the command line.
Awesome, I love goji - thanks!
Here's a simple script to rewrite /r/soccer to /r/nfl -- let me know if you have any questions: # This file is called 'rewrite_req.py' # GUI (ncurses) version: mitmproxy -s rewrite_req.py -p 8080 # Non-visual version: mitmdump -s rewrite_req.py -p 8080 import os import re def request(context, flow): # Need to debug? Run this file with mitmdump instead of mitmproxy and use the line below to drop to a debugger # import pdb; pdb.set_trace() # 'http://reddit.com/r/soccer' request_url = flow.request.get_url() soccer_regex = r'soccer' if re.search(soccer_regex, request_url): # replace /r/soccer with /r/nfl new_request_url = re.sub(soccer_regex, 'nfl', request_url) flow.request.set_url(new_request_url) 
I like what Go is doing and I really tried to give it a chance, but the syntax is too weird for me. I can't think of what went trough their minds when they decided that you can only import "things" that start with uppercase from another module. Things like this make no sense to me.
Very cool. Looking at it now.
And in Visual Studio Code's Go plugin.
https://golang.org/pkg/crypto/md5/#example_Sum Contents of file, sum, bam.
This was great! Have all the upvotes!
&gt; A group of people using a language &gt; cult like groups using other languages Ah, so *they* are cult like, but not this place. Makes sense.
Yes. /r/golang is the only PL-specific subreddit I subscribe to that seems to have made a habit of front-paging any criticism of the language so that it can receive its two minutes hate. Now we can't even bother with original blog posts and are instead circling the wagons on a post about a post about criticisms of the language. Even the Lisp people come off as less bitter these days.
Ugh, you're right. I was too focused on the pattern interaction and forgot the utf-8 catch. 
I would say that it depends on the analytics and the relative importance of the analytics side and the server side. Python has so many libraries for analytics it'll be easier to get started on that side. We are trying to fix this situation with gonum. If you're interested in helping us out, come check out the gonum-dev mailing list.
Setup your editor to automatically run `goimports` (and `gofmt`) on save. I've been using the IntelliJ plugin these days, and it automatically *adds* imports too. If I use `fmt.Printf` for example, it'll add `fmt` to the imports.
&gt; Things like this make no sense to me Identifiers starting with lower case are private, identifiers starting with upper case are public. Once you grasp it it's quite simple. HTH
I wonder what your use case is. I have a goroutine that is interested in listening to a particular event happening in another goroutine, and also able to timeout in case such events never happen. If Go officially supports `WaitWithTimeout()` on `sync.Cond`, this wouldn't have been needed.
They have a few Go repositories on https://github.com/uber and https://github.com/uber-common
yep totally agree, and it's nice to know exactly where and why a full copy happens because that can be pretty expensive.
Well I think that inheritance is not an antipattern and I have a more traditional stance on OOP criteria. I told you what you wanted to know: why people think that Go is not an OOP language.
That's fine; I wasn't arguing, just speculating/learning out loud. :) if inheritance is fundamental to OOP, then I'm not an OOP fan (although every OOP language I know supports composition and interface inheritance and many OOP communities have some sort of "prefer composition..." Mantra). If it's not fundamental to OOP, then Go is an OOP language and I love OOP. :p
How weird is it that the Go community, more than any other programming language, seems to be spending a huge amount of time defending itself from people saying the language is terrible?
I don't think its all that weird when you notice that a lot of the complaints originate from users of languages that aren't seeing much adoption. The article is a little unfair in that respect. I don't see many complaints from Java or C# devs. They are happy to continue using what they are using without complaining about something they don't intend to use. C and C++ devs seem to say they need the memory management they are used to and simply say it doesn't fit their needs. But if you hang around these articles and comments bashing it for a while you'll start seeing Haskell, Erlang and a couple others pop up and they then drag Rust into it. Looking around the Rust community they don't seem to have an issue with Go. Like the others its just not for them and they don't seem to waste time bashing it.
&gt; Don't get so caught up in trying to point out a lack of introspection that you can't see a spade and call it by name. Wow... Just, wow. OK.
I used PHP for many years and found the language to be ok. Its almost the same problem with folks that need a paint by numbers programming system bashing it because it lets them get themselves into trouble. And to be fair PHP was adopted mainly by folks doing side projects and seeped into usage in companies via all the projects that were built with it. Go on the other hand is being adopted directly by companies and put into production at what seems to be a far faster rate than PHP projects found their way into companies. But if not adoption then what else are you going to judge a language by? The number of people that don't do anything more with it than a trivial example to write a blog article complaining about it?
One of my biggest complains of Go is the lack of functional programming idioms, as well as Rob Pike's argument against them. Rob Pike argues that functional idioms are less readable. Perhaps they are. But I think programmers place way too much emphasis on readability, which is a local concern to some function, module, or snippet of code, and not enough concern for system comprehensibility. I want to know what minimal set of atoms are required for me to gain total system comprehension. Sometimes, if it means paying the cost of local readability, I would pay a bit for total system comprehensibility.
How?
Up next: &gt; The number of complaints about articles complaining about the number of complaints against Go is increasing at an exponential pace.
Rather than trying to hack the Count method, you could just put a map/reduce setup together and spread the heavy work across more cores: func getels(text string, minlen int, maxlen int, threshold int) (saved map[string]int) { saved = make(map[string]int) runes := []rune(text) text_len := len(runes) done := make(chan *map[string]int) for w := maxlen; w &gt;= minlen; w-- { //Map go func(width int) { var count int var e string tmp := make(map[string]int) for left_i := 0; left_i+width &lt; text_len-1; left_i++ { e = string(runes[left_i : left_i+width]) if _, ok := tmp[e]; ok { continue } count = strings.Count(text, e) if count &gt;= threshold { tmp[e] = count } } done &lt;- &amp;tmp }(w) } for w := maxlen; w &gt;= minlen; w-- { //Reduce for k, v := range *(&lt;-done) { saved[k] += v } } close(done) for k, v := range saved { //Filter overlaps t := []rune(k) for i := minlen; i &lt; len(t)-1; i++ { for j := 0; j+i &lt;= len(t)-1; j++ { if tv, ok := saved[string(t[j:j+i])]; ok { if v &gt;= tv { delete(saved, string(t[j:j+i])) } else { saved[string(t[j:j+i])] -= v } } } } } for k, v := range saved { //Filter below thresholds if v &lt; threshold { delete(saved, k) } } return saved } 
What exactly are you criticising? &gt;We started writing some things in Go, so that's been some of the high-performance systems where initially we might write something in Node. Some of those are currently being rewritten in Go in particular places where it makes sense, just to get a little bit more optimization from the system. They clearly mention that they are rewriting components from Node to Go that need optimization.... That's a pretty clear promotion of the language. So what are you really mad about?
The original posts have been addressed over and over again and more keep coming while people that actually use the language don't seem to see these as major issues. That's the whole point of this article. Its rather telling that you can make a guide on how to complain. It says to me that people are just hopping on a bandwagon more than anything. 
Well that's what it is. Forest for the trees? Or maybe I should have phrased it "trying to find a lack of introspection". The point is that people often come into discussions on the internet trying to take some neutral high ground and miss the obvious. 
I've got my editor to run goreturns (which calls goimports/gofmt). https://github.com/sqs/goreturns
Code readability is a huge consideration when it comes to maintenance of a codebase in an organization. In my experience it's easier to pass code between devs or bring new people on to a project when they don't have to worry about clever functional constructs. There's less time spent learning about the abstractions and the functionality of the code is usually readily apparent.
blockchain, proof of something (usually work), block reward, transaction system, consensus rules, p2p network.
The biggest difference I see is that zgok doesn't transform the data to be included as (compressed) strings, but put the file(s) in a zip and appends it at the end of the executable. At runtime, it then calculates the difference between the reported executable size with the real size to find the position of the zipped data.
And that how we got [brainfuck](https://en.wikipedia.org/wiki/Brainfuck). People are lazy. I would've preferred pub/priv if we're so eager to type less so that we're not forced into certain naming convention. This yields all kind of weird names. I see you guys don't agree and downvote just because someone has a different opinion. If you guys like it that's great. I'm just highlighting one reason why others don't.
Yep, my results on: https://github.com/la0rg/adventofcode Up to day 7. Hope I'll finish them all :)
Did you see https://github.com/GeertJohan/go.rice? It seamlessly lets you switch between files on file system ("live"), embedded (as jteeuwen/go-bindata does) and appended (zip appending to the file). Why do you manually fix/calculate the offset to the zip start? This is already provided by zip itself.
Did it work with windows and osx webdav client implementations? Every time I try to make use of webdav, osx and windows where a pain to satisfy the parts of the protocos each use (and the changes between the different os versions).
Is something that I though a couple of times. chan(struct{}) and chan(bool) is something that semantically doesn't add any value and is hard to understand to newcomers. One thing I love about go is simplicity because the increase of readability. A code like stopChan &lt;- struct{}{} is, IMHO less readeable than. wg.Done() This have a, sometimes, consequence in the api that it is being expose, and if the use case is clear to be a select over different channels, then select { case &lt;-stopChan: .... } Is clear more superior than: over := make(chan(struct{})) func(){ wg.Wait() close(over) } select { case &lt;-over: ... } What do you think?
&gt; made a habit of front-paging any criticism of the language I think it feels that way because there aren't many posts here. The https://www.reddit.com/r/golang/new/ queue is not far from https://www.reddit.com/r/golang/hot/
How does the case of the first letter of a method or field yield a weird name? And I think you've been downvoted because the community has grown tired of years of nitpicky complaints. While you and others may genuinely dislike the conventions and lack of features the people that use it do so because of those conventions and minimalism. So it gets tiresome seeing people that don't use the language trying to change it. Why not just say its not for me and move on to the next thing. I've tried to like Rust and do like some ideas but I don't think it's for me right now. If somebody were to ask why I'd tell them but I don't feel the need to keep telling the community I don't like the things that obviously make the language appealing to them. I don't know if its because Google is involved or if it hurt some feelings by gaining popularity while throwing away some folks favorite features but the negativity has grown old.
Well, Go itself isn't getting any more sophisticated, so...
I don't see how functional idioms (you mean filter-map-reduce?) will help in understanding the whole system. I don't see any language that allows one to express system architecture and don't really get your criticism.
Yes 
First doesnt mean best
I'm the content curator at Outlearn.
http://stackoverflow.com/questions/11268943/golang-is-it-possible-to-capture-a-ctrlc-signal-and-run-a-cleanup-function-in
The section you're looking for in the specification is the section on shift, under Operators: &gt; The right operand in a shift expression must have unsigned integer type or be an untyped constant that can be converted to unsigned integer type. If the left operand of a non-constant shift expression is an untyped constant, it is first converted to the type it would assume if the shift expression were replaced by its left operand alone. 
Sorry, I copy pasted directly. It doesn't matter if I use shift operator or not. I've updated the post. To anyone confused about the parent, my post previously said: byte(344&gt;&gt;(0*8)) but v := 344 byte(v &gt;&gt; (0*8)) 
If you see here: https://play.golang.org/p/L5Zqnwh6O5 It becomes a bit more obvious. `const b1` and the `344` literal are (untyped) constants, so the compiler knows their values before hand. Since in both cases you're essentially calling `byte(344)`, the compiler can see that `344 &gt; ^byte(0)` and provides the "constant over flows ..." error. Note that this error happens on the lines where you call the conversion (i.e., 16 and 19) because the compiler inserts the literal values of the untyped constants and evaluates the expression as far as it can. `b2` and `b3` are inferred type variables, so their type is going to be the smallest integer that can hold the literal value. Because they're variables (not constants) the value may be changed at any time, so even though the compiler knows the values are initialized to 344, it cannot 100% determine that the future `byte(b2)` or `byte(b3)` conversion will cause an overflow. `b4` and `b5` are different because they're typed. That means the compiler can determine (at compile time) that the initialized value is too large for its type, thus causing an overflow. (It's why they overflow at line 11 and 13 not line 25 and 26.)