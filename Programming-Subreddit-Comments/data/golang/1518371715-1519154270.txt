You could spin this up pretty quickly using something like [Marked](https://github.com/chjj/marked). 
Ah, makes sense.
I don't agree with their comparison, C is much more comparable to Rust
Here‚Äôs a web app that uses Google Sheets to track changes on other webpages: https://github.com/baltimore-sun-data/track-changes
Hi there, just to provide a different option, at NASA we're always *always* looking for talented software engineers. We tend to be pretty language agnostic, and give our engineers ample time to work on passion projects that are relevant to their field. I am primarily data analysis focused and used to work on mostly c/Java aerospace simulations, but was given plenty of time to work on a project in data analysis using python. If you're interested, usajobs.gov is where to look for openings. Coming out of college I'd recommend looking for gs-11 or gs-12 jobs as those would best fit someone with an undergrad degree looking for a first job. There's also NOAA, the DoD, etc. though I can't speak for language agnosticism or their worklife balance. At NASA work life balance is heavily shifted toward life in order to compensate for the slightly lower salary.
the word gapping in your blog is unbearable
Offer constructive criticism and ways the author can improve rather than just being a dick.
Good point for the first remark, I've changed the behavior. For the rest you're right as well, it is not managed. Yet I don't see how it could.
You just linked to a line that isn't a fork.
Then why not do it with reflection? I mean: the library is not for production use as it is basically just a interface{} type with a few extra methods. And you wouldn't declare all your methods with return type interface{}, would you. Also you could do it without reflection by knowing the internal structure of an interface and exploring that by using unsafe.Pointer to check the interfaces value. Reflection would be obviously safer but less fun. 
&gt; I'll start doing that I guess. It will add a lot of bloat and muddies my merge requests to the point where code reviews will become really painful. Update them in their own commits. &gt; A central repo can also make code signing restrictions stronger. You could do this today -- buy SuperSecureSignedCode.com and set it up as the place for no joke hosting of go code... make it have no user renames, super-secure cryptographic whatever you want, heck use the blockchain! Right now, you have the power to do that and in the market people can choose to you use, once it is centralized that power is gone. &gt; ... can be solved faster ... Of course centralized repositories can do stuff more quickly, at a cost. Dictatorships can make decisions faster as well, at a cost. &gt; 1.0.1 to 1.0.2 is a simple change, A follows semver, it won't break anything. Even in a central repo, people lose access to accounts and bad actors can upload a new 1.0.2 -- at least right now you can create SuperSecureSignedRepo.com and if I am a fan of your management style I can use it and then people who use my code can trust in me and my chosen code hosting solution. &gt; I'll most likely stop updating dependencies unless I really need a feature. Package hijacking is a problem on every major repository system, regardless of centralized or not. On NPM developers have talked about having THOUSANDS of hijacked packages under their control, to be leveraged later or for pay. Pulling down code en-masse is an act of faith at the end of the day. &gt; I would rather have one service provider whose dedicated job is to ensure this doesn't happen fail and fail big enough for me to know that something really bad happened That isn't how it works -- at any time on major package servers some % of packages have been hijacked, this isn't a system wide hack... this is hacking the accounts with permission to upload the next version of a package.
Yeah, it's very hard to read
&gt; So does go fmt, or dep, but it became necessary. go fmt and dep both have INSANTLY popular alternatives. They don't suffer the network effects problem. Many people, myself include use goimports instead of gofmt and use glide or other tool instead of dep. 
Any such library would need to be type-unsafe, use reflection or code generation to work. It's also not considered very Go-like: see https://github.com/robpike/filter for an implementation of map / filter and note the author says that it shouldn't be used because for loops are preferred in Go.
Work is being done to speed up gonum - to use AVX and other SIMD related stuff. You should also try Gonum with IntelMKL. It's a pretty good speed On the GPU end, there is my package cu which is due for a version bump, which will see significant speed improvements. 
Ahh good catch! I'll keep that in mind for the next part of this tutorial! Much obliged for pointing that out!
&gt; Generics do not solve the problem of having or not having a type-registry. They also don't solve the errors you get if you want to decode a type but do not have the type information handy. I already agreed with you on those points... &gt; Not a problem the blog post actually talks about, from what I can tell. Also not a problem that needs solving here, from what I can tell. The blogpost deals with a type registry and converting types to one another, including versioning. If that's not relationships between types I don't know what is... &gt; I strongly disagree. Well, until either of us brings up any sort of a solution either featuring generics (and/or other type system feaures) or not, this is conjectural. &gt; "if you squint, you can kinda see how generics could be used here" Some of the functions beg to be type-parametrized. No squinting required. &gt; the author (or you) would actually take any sort of parameterized types and would actually try to describe en detail, how they would solve the problems brought up in the blog post In the last comment I tried providing a simple example of how I think associated types and generics would be useful. I don't think an equivalent can be expressed satisfactorily in Go. I really don't know what you're trying to accomplish here. Yes, the blogpost doesn't describe how generics would solve the problem; in fact, the blogpost doesn't actually describe _the problem itself_ very well in the first place and so I don't think it can really suggest a solution whether it involves generics or not. It really isn't a very good blogpost. But to me that's beside the point, because looking at the Kubernetes codebase it seems fairly obvious to me that they would benefit from some sort of a type system upgrade. Like I said, to me the ability to be able to express (more) relationships between types seems to be the important bit more important than generics, although from my experience generics go well together with that and are kind of natural complement. But of course what _exactly_ the upgrade should be is very much an open question. That's my takeaway from the Kubernetes report and I don't think your complaints about the blogpost, while mostly valid, really change anything about that. 
Not quite, the requirement of a VM and giving up control of memory towards a garbage collector makes Go unsuitable to a lot of low-level C apps, drivers are a prime example.
&gt; On the GPU end, there is my package cu which is due for a version bump, which will see significant speed improvements. care to share?
So again it comes to the same thing that go is missing generics and it is a big debatable topics
Nope, Rob Pike refuses to recognize the usefulness of this feature, so the Go community is hostile towards it. https://github.com/robpike/filter
I'd say it is also comes down to the [philosophy of the language](https://www.youtube.com/watch?v=PAAkCSZUG1c&amp;t=14m35s).
I've made some changes again using reflection (still fun though). Yet, for a struct, I don't like checking if it is zeroed or not. An user might initialize it to the zero value on purpose, I don't wait the Of() to fail for that in my opinion.
How the thing works: In "main" you can call or text your friends just as skype or icq. when you are in the app, you need to put informations in your profile about (age, gender, location, first language, second language, knowledge of). "notifications" is where you receive notifications ! it's a message. "people" is the list of all that are online Lets say have a question about nebuchadnezzar. You go to "people", use the filter and select "knowledge of history" after applying the filter, you find 32 000 matching people out of 500 000 online. you send a notification to them, they will receive the notification and will reply to you, also by notification or by instant message or by calling, from the 32 000 , there will be like 15 that know the subject very well. last step: call them and enjoy your instant answer !
Update #1: I tested the minimal example from https://pocketgophers.com/serving-https/ which should work. I still getting this issue again: `acme/autocert: unable to authorize "DOMAIN NAME";` `tried ["tls-sni-02" "tls-sni-01" "http-01"]` Perhaps, one of the last commits to https://github.com/golang/crypto/acme/autocert were buggy?! I don't know...
So basically [Helpouts](https://techcrunch.com/2013/11/04/google-launches-helpouts-paid-video-chats-with-experts-to-address-whatever-is-bothering-you-right-now/) 2? [Spoiler alert](https://techcrunch.com/2015/02/13/google-pulls-its-helpouts-mobile-applications-from-the-app-stores/).
Update #2: Something strange is ongoing. I used this minimal example: ```` package main import ( "crypto/tls" "fmt" "log" "net/http" "golang.org/x/crypto/acme/autocert" ) func main() { log.Println("Runs...") mux := http.NewServeMux() mux.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) { fmt.Fprintf(w, "Hello, TLS user! Your config: %+v", r.TLS) }) m := &amp;autocert.Manager{ Cache: autocert.DirCache("certs"), Prompt: autocert.AcceptTOS, HostPolicy: autocert.HostWhitelist("DOMAIN NAME), } go http.ListenAndServe(":http", m.HTTPHandler(nil)) s := &amp;http.Server{ Addr: ":https", TLSConfig: &amp;tls.Config{GetCertificate: m.GetCertificate}, Handler: mux, } log.Fatal(s.ListenAndServeTLS("", "")) } ```` I run it without Docker and it works üò≥ Ok, I analyze this effect even further...
&gt; Well, until either of us brings up any sort of a solution either featuring generics (and/or other type system feaures) or not, this is conjectural. It is impossible to prove a negative. Which is why I asked the author to provide at least evidence for a positive. And FTR, there *is* a solution without generics. It's implemented. &gt; In the last comment I tried providing a simple example of how I think associated types and generics would be useful. The problems you are talking about, however *are not the ones talked about in the post*. It is uncontentious that there are problems generics solve, but my criticism is exactly about the problems they *don't* solve, even though said post claims they do. &gt; I really don't know what you're trying to accomplish here. Really, just trying to get anyone to explain how generics are supposed to solve any of the problems of the blog post. And if not that, then at least to get them to stop linking to it as an argument for their usefulness, because it's a pretty bad argument. &gt; in fact, the blogpost doesn't actually describe the problem itself very well in the first place Why in god's name are we having this argument then? I'd like to point out that that's [all I said from the very beginning](https://www.reddit.com/r/golang/comments/7wi1kb/what_happened_to_go_2/du10tz9/). Like, this whole thread is a) someone linking to a shitty post making broad, nonsensical claims about problems generics would solve, b) me pointing out that these claims are nonsensical and c) you starting a thread about how I got it all wrong and am misunderstanding the points the post is trying to make. Sorry, but yes, that is not amusing, such a waste of time, just to arrive at utter agreement. &gt; That's my takeaway from the Kubernetes report and I don't think your complaints about the blogpost, while mostly valid, really change anything about that. That's fine. I wasn't trying to change anyone's mind about generics at all. I was simply pointing out that the blog post does not make any sense. 
This is a post spammed all over Reddit by a throw away account. 
Not true. what the hell are you saying ?! This is a good idea to be shared. there is nothing wrong in sharing. Have you at least looked at the thing, I'm sure you haven't.
Just stop. It wasn't funny the first time you posted this exact message on another sub. You're misguided and don't read rules at best, and a troll at worst. 
[removed]
[removed]
No worries! :)
&gt; Update them in their own commits I'm not sure what your workflow is, we review PRs. It's not possible to separate code commits to dep commits unless you are super careful and commit all dependency updates before making any code changes. I'm starting to think you're trying to argue as your projected self, Robert. &gt; You could do this today Case in point: we have 0 alternatives today. Prefer having one that exists and solves the problem than 100 that no one uses. Or worse, have the same security risks, distributed all over, and not even have source code hosted there. &gt; at any time on major package servers some % of packages have been hijacked That's disheartening if true. Let us fix that, not use it as an excuse to sit on our hands and get shot one after the other.
Yep, that's a valid option too. I'm still 50/50 on adopting it. That's what I used to do when writing C and C++, but with Go it feels kind of weird having both a dependency manager *and* vendoring.
If you look at dep as more of a solver for the tree and vendoring as simply the solution to get it into your version control makes more sense. Even with centralized version control, you still have to solve dependency versions. 
Just looking for some information man, how to get basic devices to connect and ping each other. How to set code running and listening, more than a problem I find myself trapped by my own ignorance, but I guess that is how we all start...
&gt; both have popular alternatives So could your central package hosting server. Today, there is no major package hosting server. &gt; use goimports instead of gofmt Unless you have some other tool by a confusingly similar name, you're not making any sense. If, and I highly doubt it is the case, you're talking of some other goimports, you understand that alternatives can exist, even when the official tool has been around forever.
Yep, that makes sense. Dep does a nice job of flattening the dependency tree, which was a major issue I had with Glide and the dependency hell that is gRPC. All in all, I'm not unhappy with my current setup, I just wish there was a way to keep your project outside of the GOPATH (which seems to be an ongoing discussion regarding the go tool.)
&gt; I'm not sure what your workflow is, we review PRs. It's not possible to separate code commits to dep commits unless you are super careful and commit all dependency updates before making any code changes. I don't know about super careful, I mean... a policy of "separate PR for dependency updates" is fairly simple, and fairly sane. I would challenge you to track the amount of breakage in your project that comes from dependency updates -- even on "stable" APIs -- you might be surprised how often doing a casual update to your dependencies just signed your team up for more work. Dependency updates are non-trivial, in many projects they are the MAJORITY of the code changes by both LOC and severity, in some projects they represent the majority of the build-breakage -- and they should not be treated casually. Doing a dependency update should be in its own PR, it should be reviewed, and someone should be responsible for when that breaks the build... doubly so if that person just broke OTHER peoples code in the process of that update. Another benefit of having it in its own PR is that if it does contain breaking changes that require code updates, it is all together in that PR... "Updated foo from 1.3 to 2.0, updated $X, $Y, and $Z to use new API". &gt; Case in point: we have 0 alternatives today. Alternatives to Github? Seems like we have LOTS of alternatives. Most of my vendor directories are littered with other servers. &gt; at any time on major package servers some % of packages have been hijacked &gt;&gt; That's disheartening if true. &gt;&gt; Let us fix that, not use it as an excuse to sit on our hands and get shot one after the other. It is not fixable. Because it is end-user security. Until people stop reusing passwords, getting their personal boxes exploited, etc -- this will always be the case. Centralized or not, it doesn't matter, packages will be hijacked. So I think centralized or not makes zero difference in regards to this. 
&gt; both have popular alternatives &gt;&gt; So could your central package hosting server. That would be decentralized package management (no blessed / official server)... which is what we have now?
Solvers are really, really hard. Arguably impossibly hard, so we just do our best.
&gt; you understand that alternatives can exist, even when the official tool has been around forever. Which is why I mentioned BOTH network effects and official blessings as being things that apply specifically to central repositories and not like gofmt or glide. 
https://github.com/gorgonia.org/cu
thanks, this throws 404 for me, is this the correct github url? I can access the gorgonia.org/cu that redirects me to godoc
You're thinking of this the wrong way. There is no "IOS" interaction server. Every interaction between a client and server is over some kind of network interaction. What that interaction looks like is completely up to you. If you want it to be restful, build a restful endpoint. If you want it to be TCP, build a TCP server. If you want it to be UDP, do that. The sky is the limit. You already have an option which you've dismissed; an HTTP response function. Expand on that and have n number of them to handle all the functionality you need/want. Boom; server for any client. There is lots of other things you'll need to think about like authentication and authorization (2 different things), security, etc. All of this lives in the realm of architecture, and you're not going to find a single all encompassing tutorial on it, you'll need to search out each topic when you get to it. Good luck! It's a fun journey if you're up for it. 
it's just https://github.com/gorgonia/cu
It should be difficult or unnecessary to do so. Yet, from your own example, yarn exists.
ok, probably an issue on my end, thanks!
fixed
excellent, works now, what did you do?
I fucked up the link
nah the original link had an extra ".org" :-)
I saw it, but didn't cross my mind to remove it, all good, thanks!
Going to sleep, but does the Docker image give the app's service account enough access to save the certs retrieved from autocert?
Cheers!
http://golangtutorials.blogspot.com/2011/06/methods-on-structs.html
I actually hate these kinds of tests. I feel like it's a mountain of text thrown at me in a single test function. It really makes it harder for me to pick out what the tests are supposed to be testing. I much prefer, smaller digestable tests that straight up tell me a clearly defined uses case. I find that I often have a top-level test function that is just TestMethod() with nested t.Run("sentence describing use case/expectation", testForUsecase). Then I write testForUsecase () below, and there I can add data tables if necessary. Either way, I can quickly scan the top-level TestMethod and get a very readable understanding of what a package does and how it's supposed to work. 
Perfect, thank you :)
(s *statusSync) called receiver. 
Cockroach wants money for full features. No thanks. Liberal Postgres is for me. :)
Which features besides parallel backup and restore?
The nice part about this test style is that it needs no external dependencies. The verbose coding style might not be everyone's favorite though.
Nice list. I came across something where I couldn't make the zero value useful. For example a library to prints financial values with numbers up to two decimals. The default should be that it has two decimals, but the zero value means zero decimals. This has proven to be a bit of a surprise for some users, how would you go about addressing this?
What a shame! Jack Nicholson is my all-time favorite.
Sounds cool! Might want to reconsider the name, though. There's already a popular package named Jobber: https://dshearer.github.io/jobber/ Plus, it's not clear how "lambda functions for micro-requests" results in a name like Jobber.
[removed]
Could you elaborate? Are the gaps too small? Are the gaps too big?
Yeah, I'm porting the PHP version of my snail simulation to Go, as a project to learn Go. 
&gt; how to get basic devices to connect and ping each other If you're on the Internet, you've already achieved this. &gt; I find myself trapped by my own ignorance It seems that you're rushing to solve a problem you don't fully understand. There are a lot of pieces you have to get right to get a client talking to a backend, and if you don't have the tools to debug each of the pieces, you'll be dead in the water. Perhaps you might start by studying a bit of computer networking (TCP and its modern variants), and review a few existing server frameworks, even if they don't directly address the problem you want to solve. You might stand to learn by looking at other examples. 
I completely agree with you regarding the values: simple, readable, no dependencies. The idea here is reducing the cognitive overhead by reusing the pattern. Once you get used to it, your eyes will only see the cases. Actually, my code editor highlights the string literals in a way that even at the first read, I would inevitably focus on the test case names. That's probably the reason why I had a different impression about the readability of this pattern.
Why is Jack Nicholson in that list? 3 times looks like a saucerful carrier to me. As for code - I think you overuse blank lines üòÉ. On more serious note - don't panic, use errors instead. Check for csvLine len - you don't want out of bounds panics.
Keep in mind that methods aren't limited to structs as the above URL suggests. A broader introduction is available in the Go tour: https://tour.golang.org/methods/1
Why Go-lang tag - check point 5
Thanks for your approach. I tested it by granting the program `root` access. But it still does not work.
I throw the map of input/output into the subtests. I find it to be the best of both worlds
&gt; I recommend describing your current experience with Go and where it falls short. Then we can park it forever. :thumbsup:
&gt; is based on a fundamental misunderstanding by the author. I don't think he misunderstands anything. This is the same response from any anti-generic fanboi that thinks developers are not smart enough to understand generics aren't necessary. I think it's the other way around. ;)
This! Experience reports are bullshit and just a way to make it look like you're engaged but ultimately not going to do anything about it. You only have to take a look at the golang generic issue on github to see that it is needed.
Yes, we'll not have any of that type-safe reusable code around here.
&gt; This is the same response from any anti-generic fanboi that thinks developers are not smart enough to understand generics aren't necessary. I'm not an "anti-generic fanboi" and indeed, in the comment itself (and many times before and since) I explicitly acknowledge their usefulness. This kind of "you are with us or against us" side-picking mentality is destructive for productive discourse.
So you're against us then?
https://www.urbandictionary.com/define.php?term=patches%20are%20welcome
 &gt; https://www.urbandictionary.com/define.php?term=patches%20are%20welcome https://github.com/golang/go/issues/15292 /u/kalekold I think your trolling skills are parked as well. Not only you haven't bothered to read that issue, to understand the complexities behind it, and failed to notice four different previous attempts at implementing it, but you also failed to read and correctly reply to the message I've sent about you being the one that opened those issues as well as patches for other issues you've personally fixed. Of course, since it seems that the logic and reading skills are parked as well, I can't expect much. Then again, you're just embarrassing yourself so... there's that :) Come back when you can sustain a real conversation. 
You stole my earlier comment! And my code style!
&gt; I don't want this language to become riddled with clever shortcuts and magic conveniences You are describing a language very far removed from Java. Java is one of the langs with the least amount of "magic conveniences" and "shortcuts" out there. 
Change the origin. Let the library always add 2 to the number of decimals. If you want zero, then you use -2, which clearly means: two less than the default number of places. &lt;/humor&gt; More seriously: do not export the implementation, provide a public set of methods, including a constructor which initializes the structure as required.
There is nothing specific to Go here. If you can write out some basic JSON via HTTP with Go then that's the Go part done. From there, you'll need to create a client library that can consume the Go service _in your mobile app_. That means using some code to make a HTTP request, then having something decode the JSON response and do something with it. That's the most basic thing you can get set off with, but it doesn't sound to me like you're struggling with the Go part. It doesn't matter what language the server is written in really.
Seems like you've had a rough welcome here so far! Thanks for writing and article. These are all great things, and it's good to still acknowledge them. Sure, there are articles that say these things already, but this might also help steer more people towards Go (for better or for worse ;)) Keep it up!
interesting. Do you know of an open source project that tests like this so I can learn?
It's not a strange request, you probably do it everyday when you untar an archive containing symlinks.
Thanks, I ended up finding this too. Seems to be the only thing that works. There's nothing built directly into the standard libraries. :(
He got a rough start because a cancerous sub decided to spend their time mocking and downvoting this post. See: https://www.reddit.com/r/programmingcirclejerk/comments/7wzttj/go_is_remarkably_simple_it_also_gets_rid_of/
i was wondering a bit about testing this morning. is it common to use a mocking library in go? or should i just create interfaces pass them as params and use a "test" implementation that i roll myself? Thanks
While the "humorous" suggestion isn't necessarily exactly what I would do, the principle holds. For private members, you are entitled to view them however you like. If you are using a byte to hold the number of decimals (for concreteness), you've got 256 values that you are technically welcome to map to whatever you like. You can then provide yourself a private method to determine the "real" number of decimals, which unless you do something weird, will be inlined, and may not even have the negative performance you might expect with the way modern processors work. It's one of the reasons to hold things private; you can do things with them that you can't do with public members. I'd also point out that eventually you can end up backed against a wall. Sometimes you need a type to be publicly available, and sometimes it's going to have private members that need to be initialized like channels or something, and the only way to handle it is to document a function as the only valid way to create an object. Stdlib has this in a number of places. I find pointer types to be particularly prone to this; you need the type public to be able to call the methods externally, which may be the entire point, but a nil pointer is frequently just invalid, and it's more sane to just error out than to try to construct some surprising thing for all the methods to do.
Sorry. I added some clarity to mention that I also added winners. Thank you for the pointers. üëç
https://grisha.org/blog/2017/04/27/simplistic-go-web-app/ This is a good frame (but not a framework) for a single page app. 
How does this product optimize around the 10+ millisecond latency that API Gateway introduces? Are we specifically targeting IAM-authenticated SDK code invocations? 
I've been meaning to look into GraphQL! I'll take a look and see what I can do! Thanks for the request!
Can you connect to the port 80 web server from the outside while running under Docker?
Not yet unfortunately. NYC is the place to be though :)
We moved from glide to dep. I thought glide was solid but yeah it looks like most are switching to dep. It's good for the community to rally behind one solution. I just wish dep had a flag not to read source code to figure out my deps. I'd rather tell it these are the exact deps I need, just install them.
It's all a matter of taste but that's what I do. If it is so complicated to mock a dependency that it feels like a burden, perhaps that's a problem in your design. As always, listen to your tests. Your interfaces should generally be small and focused which means it should be easy to mock them out
Found the issue üôÑ It was a wrong configured DNS: IPv6 + Docker + Let's Encrypt is not a good combination these days. Let's Encrypt prefers IPv6 and Docker does not handle IPv6 by default. Wrote an article: https://tsommer.org/article001 Thanks everyone for the help.
Yep, true. Never really thought of that. 
A common saying among sysadmins: "It's always DNS" :)
Thanks. No argue here. I struggled to find a name that describes this and ended up find a name just by searching different wods. If you can suggest any I can rename the package
Latency of API call which invokes the functions won't affect the processing time. We invoke lambda functions but not to process individual jobs. Lambda functions __connect back__ to the grpc server and stay alive to server many requests. Each job becomes a grpc call to one of lambda functions with latency of a grpc call . Hopefully sub millisecond if lambda is in the same network as the code. 
Nice writiup. One thing I would change is to give a more concrete example in the `Use self referential interfaces` section. It's really hard for me to follow what you are trying to convey there, since `Foo`, `A`, and `doer` make it hard to follow what you are trying to say. Maybe include an example that uses a network connection like you mentioned in the paragraph before. 
Are C++ developers willing to learn Go good candidates?
&gt; The nice part about this test style is that it needs no external dependencies. I'm genuinely curious why having no external dependencies is necessarily a good thing
/u/campoy Happy cake day!
Link me the proposals and your participation. I am curious to see your way of error handling.
Sorry but this is spam.
when you are in the app, you need to put informations in your profile about (age, gender, location, first language, second language, knowledge of). "notifications" is where you receive notifications ! it's a message. "people" is the list of all that are online Lets say have a question about nebuchadnezzar. You go to "people", use the filter and select "knowledge of history" after applying the filter, you find 32 000 matching people out of 500 000 online. you send a notification to 100 of them, they will receive the notification and will reply to you, also by notification or by instant message or by calling. From the 100 people , there will be like: 60 don't know nebuchadnezzar. 10 know nebuchadnezzar somehow. 10 know him well. 10 know nebuchadnezzar quite well. 10 know nebuchadnezzar very well. last step: call them and enjoy your instant answer ! 
Sooo...... Stack Overflow?
&gt; I was simply pointing out that the blog post does not make any sense. I understand where you're comming from. I wouldn't go this far though. Seems to me like it was written by someone in a hurry who ran into problems with a poorly implemented type registry. The takeaway from the blogpost is an "assemble yourself" type of thing, but the way I see it there still is a value to it. For example, I wouldn't even know about those issues with type registry at all if it weren't for this admitedly poorly written report... Obviously it doesn't suffice as an evidence for integrating generics (or other type system features) into Go, but I can see it being a sort of a baseline to be improved upon... 
I didn't fully understand that either so I [made a playground](https://play.golang.org/p/PcMJHgEdrnu) to help.
OP - this sub is for posting projects and questions about Go the programming language. If you build this in Go and want to share your source code then by all means go ahead, but just posting an idea is going to get an awful response because it isn't relevant. Even if you want to build it in Go, it still isn't relevant until you have source code or questions specifically about Go to share. It sounds like you are young and eager to build something, so I don't want to discourage that attitude, but I want you to understand why you are receiving a poor reception here. Even if you had an idea for the best new app in the world, ideas for apps just isn't what this sub is for.
Not sure why I bothered with a genuine response before checking the users post history. They appear to be spamming this to tons of subs.
Experience. I find calling unexported methods as an indicator, that something is not entirely ok with your package API, since you can't write a self-contained test that depend only on your package's API. I find data-driven tests more manageable in the long run than behaviour-driven ones. Secondly, a lot of projects tend to use things like testify or other test checkers. Those checkers give away type safety by accepting interface{} as input arguments. This is not that rare, that one refactors return types of unexperted methods. Combined with use of before-mentioned checkers this introduces a new class of errors during runtime execution of tests. While I cannot force everyone to drop the use of test checkers, this can be easily mitigated by export_test.go trick explained in my original comment. I know that there are exceptions and saying something is ok or not ok is not entirely possible. I was just bitten too many times by the issues I describe, sometimes that badly that I dropped the idea of refactoring a package. And I left it to rot.
"understandable" is a function of the person who's trying to understand. If a widely-known and widely-used language feature is not "understandable" then the answer may lie within. Many programmers do not find threads or pointers to be "understandable" either.
No, Go does not have method overloading. A type can only ever have one method with a given name.
Sure! 
From OP: &gt;fmt.Sprintf("%x") with a named int type may cause a stack overflow. Is that expected? The helpful response they received: &gt;Yes it is. Use `return fmt.Sprintf("%x", int(t))` to avoid the infinite recursion. lol
You don't need a temp file, you can just use a buffio Reader as your io.Reader
I couldn't find mergeTwo anywhere. I went ahead and compared merge using `WaitGroup` with `atomic` and saw that [`WaitGroup` is just as fast](https://gist.github.com/Xeoncross/3e0328137019b14373ee26701a23ed81). 
wow I've been here for 5 years!
&gt; The topology doesn't need to be advanced visually just something to show connections between 2 seperate hosts or network devices. You'll get a table of connections between hosts if you run your pcap through Wireshark.
It's way cleaner and it works, thanks !! I wonder if there are other testing approaches
I appreciate the comment, but the reason I posted this here and not in another subreddit was because I'm looking specifically for something in Go.
Excellent. The more Go support there is in Azure, the more Python stuff I can deprecate.
I wish the post was a little more technical, but I'll definitely look into Squirrel. Can anybody give a good explanation of what makes Gorilla better than the http mux
&gt; what makes Gorilla better than the http mux It's one of many third-party muxes. It makes it easy to route based on regular expression matches and to capture parts of the route. That makes it nice for some sorts of "pretty url" sites. It's also fairly easy to use. It's not blindingly fast, nor a perfect match to some sorts of URL tree. Like most everything there's not a _best_ solution, just one that's well-suited to what you're doing.
As somebody who is just getting into go, how do you go about this?
You should be able to write your own tool using [gopacket](https://godoc.org/github.com/google/gopacket)? It has a subpackage [pcap](https://godoc.org/github.com/google/gopacket/pcap) that can read packets from the wire, or from a pcap file.
Right now i'm worried more about library code (code that I don't have direct control over). I understand the convention in go is that if a function returns 2 values val and err, if err is non-nil then val is nil and vice versa. But given that this is just a convention, I worry that some library i'm using will violate this convention. Some function from some library might return nil for both the err and the value, i'll try to do something with the value and my whole program crashes. Even if I trust myself and my team to always do the right thing, I get very nervous when I have to trust something else. I also don't even trust myself 100%. I'm scared that one day at 3am i'll be running on very little sleep, i'll accidentally make a change that returns a nil value and a nil error from some function, and i'll introduce the same problem I described in the previous paragraph.
Good to see this but it's a bit thin. And these docs aren't anything new anyway. What would be really nice if the web apps with golang finally worked well. Last time we tried it, it was a miserable experience. 
Exporting symbols for tests using thin wrappers even if tests can access these symbols directly? Hmmm
I'm probably gonna get down votes for saying this, but it's pretty sad people now a days are able to be oblivious to the lower level technical details andc call themselves programmer/software engineer. I agree fully with the idea that you should pick apart frameworks just for the sake of knowing how it did it's magic, just shocked by the realization that this isn't a requirement anymore...
https://github.com/golang/go/blob/master/LICENSE It's nothing like the React license. It's very straightforward.
[removed]
This is how i think of the various disciplines: Computer science - development of fundamental theory Engineering - Direct application of theory Developing - Application of applications of theory. So most "software engineering" is really just "developing" (which is fine!), and within this there's obviously a range of skill levels. This isn't anything official it's just how I break it down personally.
IANAL and as expected I don't really understand this despite how straightforward it is. Who are the "Go Authors"? Also if they're employed / owned by Google what kind of barrier is obtaining written permission?
&gt; Can anybody give a good explanation of what makes Gorilla better than the http mux Gorilla supports regex pattern matching. If you have many complex routes with deep nesting such as: `/companies/{companyID}/departments/{departmentID}/employees/{empID}` then Gorilla mux is probably worth the investment as it will allow you to easily extract the IDs and such. Meanwhile a large number of APIs are much simpler and avoid deep nesting. So if the majority of your routes look like this `/books/{id}` then you can most likely avoid depending on Gorilla as you can get the key by simply slicing the URL route.
I think he's more concerned for https://github.com/golang/go/blob/master/PATENTS But it seems more like the Apache license (you lose Patent rights _only on what you sue_)
you've sold me on giving Go a shot. is it similar to js? similar to C (I know a little baby amount of C)?
1 - a function to handle errors is fine, so long as you are handling the error up to your standards. in the case of this program, I think it's fine. 2 - log.Fatal will kill your program and display the error. its not particularly graceful, but useful in development. in a binary version it might make more sense to print the error or log it to a file (nicely formatted / human readable), and then return to the input section of the code. since its a command-line tool and probably for personal use, log.Fatal is all good. 3 - a template would be nice and would make the code more compact. plus, it would be simple to build a comfy front end in html or to use in emails / SMS if you wanted to do alerting on drastic price changes . Addl. Notes - not in love with your switch. to me it is clearer to separate your declaration of ```info_level``` onto its own line. the comment above the decoder is wasteful, what does it say that json.NewDecoder does not? 
If you are predominantly deploying/building for MS then C#. If you want cross platform code that you can build on any platform for all platforms, is fun to learn/use, and can be used for microservices (among other things), Go would be my choice. I am having a hard time convincing my fellow colleagues/bosses to switch to Go from Java for back end code and api microservices. But all my own stuff is going to be built in Go.
These are the Go authors: https://golang.org/AUTHORS. These are the Go contributors: https://golang.org/CONTRIBUTORS.
&gt; if tests can access these symbols directly? Tests can't access them directly, because your tests should be in a different scope than your package (e.g. `package mypackage_test`). Lot's of downvotes and no argument made - I see that only argument from authority is taken seriously here, without a second thought. https://github.com/golang/go/blob/master/src/strings/export_test.go https://github.com/golang/go/blob/master/src/bufio/export_test.go https://github.com/golang/go/blob/master/src/bytes/export_test.go https://github.com/golang/go/blob/master/src/sort/export_test.go https://github.com/golang/go/blob/master/src/strconv/export_test.go ... 
No. But you could make the signature ```receive(w writer, r reader)``` and then call it like so ```receive(nil, nil)```.
I also set - GRPC_TRACE=all - GRPC_VERBOSITY=DEBUG still nothing, do I need to pass it somehow to a graph server ?
I am glad that you are going to give it a try! In terms of syntax, I would say Go is rather unique, but it shares some resemblance with C. If you are comfortable with pointer and function pointers in C/C++, then you should find Go empowers you a lot of utilities that Java/C# have deprived of you, meanwhile you don't have to have to do memory allocation as Go has its garbage collection. Your Java/C# background may not be helpful when you write software in Go. It took me a few months to recognize that I didn't write Go programs in the way that Ken Thompson wants me to. Once you understand the designer's vision of Go, you should find writing Go programs is really a joy.
It's kinda of what CS is heading to, to be honest, and it's typically against the direction of the education of other sciences. Berkeley's undergrad EE/CS courses emphasize on one thing only: abstraction. The less you need to deal with low-level things, the better/more robust your program/system will be. It's true if you ONLY build high-level stuff, like what @jame_is_an_ok_guy mentioned, but it does not bring you any insight on how things actually work at the bare metal level. Physics and Chemistry education goes the totally opposite way: you were given a simple picture of how the universe works. As you advance, you learned deeper and deeper, and all the way to the quantum level. Computer Science/Software engineering goes the opposite direction: you were taught basic assembly and operating systems at the undergraduate level courses, then as you advance, you interact more and more with APIs instead of electrons. Other sciences make us more sophisticated while CS/SE is making us more naive. ¬Ø\_(„ÉÑ)_/¬Ø
You dropped this \ *** ^^To ^^prevent ^^any ^^more ^^lost ^^limbs ^^throughout ^^Reddit, ^^correctly ^^escape ^^the ^^arms ^^and ^^shoulders ^^by ^^typing ^^the ^^shrug ^^as ^^`¬Ø\\\_(„ÉÑ)_/¬Ø`
Ya. Done. Thanks.
Good bot
Thank you a1454a for voting on LimbRetrieval-Bot. This bot wants to find the best and worst bots on Reddit. [You can view results here](https://goodbot-badbot.herokuapp.com/). *** ^^Even ^^if ^^I ^^don't ^^reply ^^to ^^your ^^comment, ^^I'm ^^still ^^listening ^^for ^^votes. ^^Check ^^the ^^webpage ^^to ^^see ^^if ^^your ^^vote ^^registered!
But.... But.... What happen if you need to build high performance stuff? Just unleash the raw power of the cloud and let AWS bill sky rocket?
This. It's called idiomatic Go. You can use Go like other languages you are already familiar with but that isn't the best way to go about things. When you have that "a-ha moment"and start using go as it's intended, it's the beginning of a joyful journey. Some of the guys in Medium have great articles on Go. Reading about the use of Clean Architecture and interface abstraction in Go was a defining moment for me.
We pulled our use of ReactJs because of that license, which Facebook recently changed because of all the slack they got for it. However, as was made aware to me by an Apple employee using React, you dont get the license revoked, it resorts to a different license.. I forget the details, but it wasnt like you couldnt use ReactJS suddenly and your app had to be yanked.. it just meant your license was changed... which I think had something to do with avoiding being able to sue any affiliates of Facebook. It was kind of perplexing why they opted for that license. Even with it, plenty of big name companies still used the library. 
Right, but CS is not like other sciences. It does not try to explain natural phenomena but finds newer and newer ways of applying a really powerful, but still man made framework of boolean logic. It's practically a branch of mathematics, which is thought the same way as you described. First you learn the numbers and basic operations, and and later you go to more and more abstract levels, when you don't even deal directly with numbers anymore. 
It is not necessarily a good thing *in itself*, but there is no point in adding dependencies unnecessarily, when the language, its toolchain, or its standard library already provide what you need.
I'll look into the edges on mobile, thanks
Thanks for the kind words, these are quire rare on the interwebs :)
Heh, I did not notice that 
I AM NOT A LAWYER There is a major difference between Go's patent grant and Facebooks: The latter expires if you sue Facebook *for any reason*, whereas the former expires if you sue them *because Go infringes your patents*. I.e. in Go's case, if you never sue Google for making Go, they can't ever sue you for using it. In Facebooks case, if you ever sue them for any reason (even if it's because of antitrust issues or workplace harassment because you decide to work for them at some point in the future), they might sue you for using their software. *Big* difference.
And what is the idiomatic way? Is this book enough to understand? http://www.gopl.io/
Just be careful about this classification since not everyone might see it that way. For me "Engineer" is mostly a legal term about the membership in specific organisations, since that is the law in Germany. Others have called my position "Software Engineer", but I will always call it "Software Developer" since I still have the German laws in mind even if they do not apply.
&gt; There was an argument to be made that any suit against Facebook for patent infringement of any sort would result in your license to use React being revoked. No, that argument cannot be made because it's simply not true. You could lose the *Patent Grant* but that's all. &gt; Facebook ended up relaxing the license, and we all lived happily ever after. What actually happened was that you lost any guarantees. It now means that Facebook has no legal wording in-place to protect *you* from themselves. 
Very welcome! 
www.ZetPDF.com library is pretty good
Just a heads up, other routers do support all of these things, and are a lot faster. The Gorilla toolkit is great, but is not very well optimised (relatively speaking that is, you probably won't actually notice a difference in normal use). If you did care about performance a lot, and wanted an actively maintained, fast, feature-rich router, then I'd take a look at something like [chi](https://github.com/go-chi/chi). I've been using it recently and it supports some really nice things: * Middleware built in (quite Express style, with a `.Use` method), makes it very clean to add middleware to your router. * Routing with parameters, that you can extract in handlers. * Optionally restricted by regular expressions. * Sub-routers, making it easy to split up routing configuration in large applications. * Doesn't deviate from the standard `http.Handler` and `http.HandlerFunc` interfaces.
It's not much like JS at all aside from the common syntax for a few things like loops and if statements (and even then... slightly different). The programming style is very different to both JS and C#. Go is not a functional language, nor is a prototypical language, nor is it an object-oriented language. It's much closer to C in all of those respects than anything else you've mentioned in my opinion, but it's still high-level enough that it's not painful (actually it's the opposite). I think Go was originally designed to be sort of a bridge between Python and C (in terms of how it feels to use the language). It's very lightweight, code is simple and readable, you've got strong typing, lightweight binaries that start quick, etc. If you're going to start with Go, don't forget everything you know. There are still some common themes. Dependency injection is still a good idea for example. Just read through the material that is provided on the Go website, e.g. the language spec, effective Go, so on. If you're curious about idiomatic Go, look around in the standard library - it's very, _very_ readable. So are other projects too, take some big projects like Kubernetes and go for a dive inside them.
I think this is something you probably just have to discover as it's not easy to distil it down. It's the sum of many different parts, but at some point it'll all start to click for you. You might have a phase where you battle against cyclic imports, but then when you get passed that you'll probably have learned a lot about how to write good, idiomatic Go code, with sensible use of interfaces, etc.
&gt; a lot of utilities that Java/C# have deprived of you Such as?
[removed]
[removed]
&gt; Tests can't access them directly, because your tests should be in a different scope than your package (e.g. package mypackage_test). Honestly, where does this come from? Where is this approach used? (next you are gonna tell us we should use XML files and DI and golang port of Spring to configure and orchestrate tests and everything? please don't :) ) Sure you can do this, but who does? From what I see everyone has tests in the same package. Some examples with tests: - golang: https://github.com/golang/net/tree/master/html - golang: https://github.com/golang/go/tree/master/src/encoding/xml - docker (also tests unexported functions): https://github.com/docker/docker-ce/blob/master/components/engine/api/server/httputils/httputils_test.go - kubernetes: https://github.com/kubernetes/kubernetes/tree/master/cmd/kubeadm/app/util These are all massive and well-known projects, and they generally do it **not** the way you describe. It's not about aurhority, it's about "idiomatic use" so that everyone working on golang projects do it in broadly the same way with minimum friction. With the way you are proposing -- that would raise questions, and it does not seem to be idiomatic as far as practice is concerned. 
Would the below link be a good jumping off point? I have a good amount experience doing web dev but only with frameworks. I would love to understand the nuts and bolts of it more. https://golang.org/doc/articles/wiki/
Java does not have the notion of passing in or out primitive data as a reference, which can be surprisingly useful, and one thing I miss when I work with Java. Java also does not have (yet) value types. It (finally) got lambdas, so now you can write free functions, yet you still must enclose them in classes. And while the last problem is mostly To be fair C# has both `ref`s and structs, so it doesn't apply there that much. Also - the fact that objects have the same representation in memory, as they have in code, helps when you work with os\platform specific code and specifically assembly. P.S. Hey cmov and pcj bandwagon.
I asked because I work with C# day to day, so that was interesting to me. I'll add that C# also has lambdas and value types. I don't know any Java.
Yep. This way one can specify timeouts like: * `10 * time.Second` * `2 * time.Minute`
why would you ever need to write anything that doesn't use the web?
yeah... I am (since a few months...) in the middle of dropping the dependency against `bitbucket.org/zombiezen/gopdf/pdf` and use instead `github.com/jung-kurt/gofpdf`. partly because `gopdf` isn't maintained (IIRC) and also because `jung-kurt/gofpdf` handles transparency. being on github is a nice secondary benefit :)
[removed]
we do have a few examples: - https://godoc.org/gonum.org/v1/gonum/mat#pkg-examples - https://godoc.org/gonum.org/v1/gonum/stat#pkg-examples - https://godoc.org/gonum.org/v1/gonum/stat/distuv#pkg-examples - https://godoc.org/gonum.org/v1/gonum/floats#pkg-examples - https://godoc.org/gonum.org/v1/gonum/diff/fd#pkg-examples - https://godoc.org/gonum.org/v1/gonum/integrate/quad#pkg-examples - https://godoc.org/gonum.org/v1/gonum/optimize#pkg-examples what are the ones you feel are lacking? don't hesitate to file issues against https://github.com/gonum/gonum/issues/new :)
This comment deserves upvotes rather than downvotes.
I keep wanting to see simple implementations like this, but for Proof of Stake. Plain blockchains and PoW are surprisingly simple, but I've got no clue how PoS works :s
Be careful with this. There are a few potential problems with this approach too: * You drop the ability to return errors from the broadcast if it fails for a given member. Broadcast already doesn't return an error, so maybe you don't care? But then why log it? Logging errors is usually less visible than returning them. * The messages are no longer guaranteed to be sent in order. In fact, different clients may receive them in different orders. For example: room.Broadcast("msg1") room.Broadcast("msg2") might be received as "msg1" then "msg1" on client 1 but "msg2" then "msg1" on client 3 (especially if client 2 is slow).
FYI, you might have some naming confusion with [Heimdal](http://www.h5l.org/) in Google.
You mean like traceroute?
**in their readmes** That's the first exposure any potential user gets
**in their readmes** That's the first exposure any potential user gets
I agree. I'm training a few new developers at work, and it's appalling to me that they're not interested in digging into things and will abandon a library of it has a bug or an apparent limitation. I enjoy digging into things and contributing back, and so did many of my previous, more seasoned developers, but I completely forgot that some people just don't care unless they *have* to do it. I'm not sure if it's a trend or just a part of being a junior developer, but it's completely foreign to me. As a teenager, I decompiled Java examples to figure out how they worked. As a college student, I dug into the HTTP library for node.js to understand how async works in C and ended up using its HTTP library for a web project I had to do for coursework in C. Aa a junior developer, I dug into the standard library of Go and D to see if I could make improvements (they were rejected, but I still use my fork of one lib because I prefer it). I ended up convincing my boss to switch to Go from node.js because it was a better fit for our problems. I'm coming to find that my company busy have been lucky with early hires because our latest hires don't seem to have this drive. It's not a bad thing, I just thought most software engineers were very interested in the tools that use. Hopefully this isn't a larger trend.
So, yesterday's announcement was related to the Go SDK, to build apps that interact with Azure services and with the Azure management plane. For Web Apps, the situation hasn't changed. We currently have 3 variants of Web Apps: on Windows, on Linux and "for Containers" (based on Linux). Sounds like you were trying to use the Windows version, which doesn't support Go, and there's no plan to add that. Today, you can use Go in Web Apps via a custom container: https://docs.microsoft.com/en-us/azure/app-service/containers/quickstart-custom-docker-image (hint: creating a custom container for Go is very easy... if you don't know where to start, VSCode can help, with the "Add dockerfile" command: https://code.visualstudio.com/docs/languages/dockerfile#_docker-commands ). This works, and we have customers doing this already. On the Web Apps on Linux side, which would allow git-based deployments, support for Go is currently on the roadmap.
K8s works. Custom containers on Web Apps for Containers would work too (at least for single container apps)
Thanks
What a toxic thread. A few people at least are being nice to the maintainer, but geez! It's like people forget that open source usually involves a human on the other side.
well, godoc is really great to document things. examples are good documentation. we could have a bigger button `HERE ARE OUR EXAMPLES`. I thought your point was that we didn't have enough examples in some (all?) packages. Having said that, I think we'd better invest into a tool that can extract our `godoc` examples into a Jupyter notebook setup (or a Gonum-enabled Go playground).
check this one https://github.com/golang/go/issues/21161
we're rolling out Linux-based Go support for Web Apps now, the container image is already described here: https://github.com/azure-app-service/go would love to help with your issues if you'd like to help test. email me - joshgav[@]microsoft[.]com. same for others reading this, feel free to reach out.
People that pull from master and complain...
Oh yes, this was indeed on Windows and we did this on purpose. We did try running on Linux in containers (when it was still in preview). And everything kinda worked, **except**, there is/was no feature parity between Windows-based and Linux/Container-based. In particular, we couldn't solve the problem of "where are the access logs" when running on Linux/Container variant. The Windows version on the other hand does have this readily accessible, plus access logs can go to blob storage (which is what we wanted). In fact, Windows-based Web Apps did exactly what we wanted in pretty much every regard (even if performance wasn't great in general it was still acceptable for our use case). I'm sure there were other "feature parity" issues similart to the above, don't quite remember well, it's been a while now. Hence we did try going on Windows -- there **were** blogs and things around which said "here is you can now deploy golang things to run on Windows Web Apps, just like node and PHP". We might give it a go again with Linux/Containers, maybe situation with feature parity improved and we can get what we need. 
Thanks for the info. Can you send me an email? I‚Äôd like you to chat with a colleague of mine. I‚Äôll DM you my email address!
It also involves someone who hasn‚Äôt been active on github since Jan 3rd. My bet is he‚Äôs not in a position to get on the internet - jail, coma, dead, etc. 
I recently pushed a similar API change on an old and otherwise unchanged library. It's sad to see so much negativity in the thread because chances are the author spent a long time considering these changes and their impacts, and they have every right to make adjustments to their library. Use vendoring people, for both yours and the authors' sanity.
+1 on vendoring. Pin a specific version that works and upgrade on your time table.
From the comments in this case it looks like go.uuid wasn't set up to be vendored with version numbering, though?
Equivalent to `python -m SimpleHTTPServer`.
It's going to create a new OS thread if the underlying OS doesn't support async.
The repo has version tags, and even without you can still pin to a commit hash. The problem with url based versioning systems like gopkg.in is that if you already started off with people pulling directly from github.com then even if you adopt it you are still going to break builds when you push to master, and you have no way of knowing how big that group is until they are shouting at you.
A byte slice is a `[]byte`.
What error are you referring to?
I can make sure at least all slices whose underlying type is `[]byte` can also be called byte slices.
The last line reports: `cannot use bs (type BS) as type []byte in argument to runtime.slicebytetostring` 
No, `string([]byte(bs))` doesn't work, it reports `cannot convert bs (type BS) to type []byte`.
&gt; Information we need to see &gt; StackOverflow ... Could you explain why you need to see a StackOverflow account?
Reimplement GNU Parallel in Go to get rid of the Perl dependency.
Well it's not as you code but I think code is for coding and documentation is for documenting. Godoc makes use of commenting as part of it's implemention. https://www.ardanlabs.com/blog/2013/06/documenting-go-code-with-godoc.html 
Agreed, but I can see how there might be a whooole lot of Go developers who just "go get" their dependencies in a build script. To be completely foolproof, projects really should have a "development" branch where new works goes and master should always point to the last release version.
Oh! Sorry, I failed to follow the types all the way through. The problem here is that Go has neither contravariance nor covariance, so it only does a handful of limited conversions. It won't convert []X into []Y for any X or Y. You get the same thing in interfaces; if someone writes an interface that has `io.Writer` in an incoming argument, you can't write a method that conforms to the interface by taking an `interface{}`. Even though it may seem "obvious" that all possible uses of the interface would involve `io.Writer` and that obvious can be turned into a `interface{}`, Go won't do that conversion. There's a lot of non-obvious subtleties around those issues that you can find a lot of discussion of if you Google contravariance and covariance. It isn't 100% clear to me that Go couldn't avoid them because a lot of those discussions will be around how they can interact very surprisingly with subclassing, which Go doesn't have. But in the meantime, Go doesn't have it, at all, and it does at least keep things simple.
Just because you *can* doesn't mean you *should*. Sure, they can't *sue* the author, but if you know that people are relying on your open source library at the very least it's a faux pas to break your API without notifying people of the impact. Particularly when it's simple enough to just [version your repo properly](https://semver.org/) and avoid creating a headache for everyone else.
It‚Äôs been seven days and your post has been edited so not sure what you said but something was inaccurate or unclear for me to link that document. Regardless linking the document I told you to read doesn‚Äôt explain why you said using Go could cause a bad time on systems that don‚Äôt support AIO time (we are in a language comparative context, so you are relatively speaking about tradeoffs against another language). Every language has to create threads to support concurrent synchronous system calls, so what is your point?
I don't know of anything that does exactly what you are looking for. I haven't used it myself buy GOA https://github.com/goadesign/goa apparently has a DSL that you design that generates a swagger spec for you, as well as some code generation. That is the closest I know of.
Holy flying fuck!! You are a lifesaver, thank you so much!!! I‚Äôll look into those resources and go from there I am just learning how to do servers and set up protocols so everything is very new to me but now that I know more specific things to look I‚Äôll finally have some direction to follow.
Is the whole program one 10k LOC perl file?
You can accomplish this via the fairly new *type alias* syntax. https://play.golang.org/p/0Cx56aZ6Aec ```go package main import ( "fmt" ) func main() { type B = byte type BS []B str := "hello" bs := BS(str) // why is this ok, str = string(bs) // but isn't this? fmt.Println(str) } ```
Do you consider C++ developers willing to learn go?
FWIW, []apiv1.LoadBalancerIngress isn't an array, [it's a slice](https://blog.golang.org/go-slices-usage-and-internals).
I think that trend came from Go devs saying "do not brake the API" some people think they can go get everything and expect it to work for ever.
&gt; Coder is a fast growing startup I worked at a fast growing startup once. Grew faster than it could produce revenue. Was a bloody six months of slashing and burning while trying to secure more funding. Eventually we sold the company for pennies. I worked at a fast growing public corp. once. Grew faster than the org knew how to scale, and deep silos developed in the company. Two years into that growth, there was a lot of brain drain and the company ended up going private. (Hint to OP: growth isn't a virtue in itself. You have to balance growth with something else...)
&gt; A recent work example via GitHub or a portfolio Yeah, and this? I've only worked on proprietary software. How the hell do I develop a portfolio?
Go doesn't support AIX[0][1]. Word on the street is that they picked Rust over Go to use internally. [0] https://docs.chef.io/platforms.html [1] https://github.com/golang/go/wiki/MinimumRequirements 
Hey mate, maybe not as low level as you'd like - but I've been playing around with Go Lambdas - they're real easy to get started with. It'd be nice to start a community of Go-Lambda contributions! 
&gt; in absence of best practices by the library dev Such as tags for a dependency management software. Learn to read.
Pretty much, which is why I'd love a Go replacement.
Is there a reason to do that beyond that it's written in Perl?
I don't agree with your original point, that because the license says there's no warranty that you can't raise an issue and have a conversation with the author about preventing future breakages.
I didn't say that either. But looking at the whole thread.. these people didn't just say "please do this and that", they expected it from the beginning and were then mad that their expectations were not fulfilled. This view about free software is clearly wrong.
Thanks for the write up!
Awesome info thanks!
Hi all! I didn't find any support for the SB Queue in Azure SDK for Go, so decided to create the library. I welcome your feedback and feature requests!
Why would you want chef rewritten in Go?
Not to be a buzzkill, but: why? As I understand the purpose of Optional, it is to tell the caller of your func/method "hey! check that I actually returned a valid value, before you do anything with it" In go, there's already a (type safe) solution for this: return a second boolean value indicating success. func MyGloriousFunc(blah1, blah2 Blah) (thing *Thing, ok bool) { ... } 
Oh thanks for the info. I came across slices in Rust but haven't got my head around them yet. I'll go and read the docs.
I was very fortunate that I landed in adtech industry for 2 years, where I actually get to experience unpredictable massive spike of traffic all the time. In those situations, everything is a bottleneck, the common belief of web devs that nodejs is fast completely falls apart, it's like playing a game of whack-a-mole where you fix one thing and three other things breaks, you just keep digging to lower and lower level until things are optimized enough to create a good enough positive cash flow for the business and not take a life time to do it.
Hi, Unfortunately we are only taking developers who have experience in go
It's Perl, so it is a ~340 KB one-liner.
Hehe. Scroll down to the end of the readme and there's a link for my fork of Dave Chaney's `godoc2md`, with a number of fixes. I use this to read the code docs and spit out the Markdown file. The `Makefile` I have in that repo is mostly to insert the links at the top of the README.md after it is generated. Like for the 100% code coverage, godoc, and other links. :) 
Write a simple window manager. Ideally completely standalone and not having any dependencies on any existing WM's.
I just looked at the summary and thought 'Well that doesnt sound too hard'. Then i open the tutorial to see some more features and see 'saving to an sql base'... What the actual fuck 
Why in the world is the API written in not only PHP, but Symfony? Symfony has a great codebase, but you pay for it in high memory and CPU usage.
API part is just an example, it could be ruby on rails it would be the same thing. It's represent pontentialy a legacy part. The important thing here is architecture. For client part the best way is an example with javascript maybe with react.
Found an old version I guess.
I'm pretty new to go. Is pinning the same as the dep tool?
I think you are right, people should be using go dep. But, they aren't I imagine. It'll take time, I think.
I like it, nice work
I work in embedded (think Raspberry Pi, not Arduino) and we started with node.js (not my choice), but we ran into all sorts of performance problems (mostly with the GC, but there were plenty of others), and it got to the point where rewriting was the better option. As such, I also got intimately familiar with node.js internals as well as Go internals. Too many people seem to just throw hardware at their problems instead of actually fixing the underlying problems. It's annoying...
what are you expecting the code that's using Foo to do if the condition wasn't met? you're going to have to declare the variable before the if statement, and then just do a standard assignment (**not** `:=`) inside the if statement. there isn't a whole lot of choice here.
That's more complicated than it sounds, but if you want to learn the basics of writing a window manager in Go the my [dewm](https://github.com/driusan/dewm/) wm is written using a literate programming style with Go as the underlying coding language and is intended to be educational. (You can also start with wingo or taowm if you prefer to just read source code. Either way, BurntSushi's x protocol bindings written in Go are invaluable.)
Well the question was about Gorilla vs ServeMux so I replied specifically for that. I don't doubt that chi is better than Gorilla but for me the question is usually about having an extra dependency or not.
There's probably at least 50 of those on github already, if you want one. I've even got one myself, though at least I present it as "an interesting sample project".
There are a lot of angles to consider with a change like this. First, its the developer's project. They can do whatever they want with it. They promised no warranty, per the MIT license. No matter what else, _always_ keep that in mind. Is the developer responsible or irresponsible in doing this? Hard to say. I'm going to take the devil's advocate side. First, where did this breaking change happen? If it happens silently in the logic of some function/method, changing its behavior without that change surfacing in an API signature somewhere, then I think anyone would agree that the change is irresponsible. But, the change was in an API signature. Go is statically compiled. When this change happened, your applications did not "break" per se; your compilations and CI broke. Though unideal, that's far better than a silent change. The original [proposal that the change was necessary](https://github.com/satori/go.uuid/issues/18) was filed over **two years ago**. If you aren't in some capacity following the conversations and issues around your direct dependencies, you are acting irresponsibly. If you missed a two year old conversation about a breaking change, you are acting irresponsibly. Fixing the update requires just a few additional characters, and a new helper function is provided to help migrate. Very responsible. Finally, if you were surprised when this update started causing compiles to fail, you are acting irresponsibly. You were pulling from master. Take this as a lesson and use version pinning. I believe every Go developer should always follow the following guidelines when working with dependencies. If you fail to follow any of them, I immediately consider you irresponsible, and your opinion as to the actions of a dependency maintainer is moot. - Never pull master. Always pin against a version. - Always make an effort to follow upcoming changes in a dependency, checking new issues by the author at least every couple months. If you follow these and your build still breaks by surprise, then its more likely that it was the dependency author's fault and they acted irresponsibly. 
In most cases you can think of curly braces as "define a separate scope, here." Information can't be accessed by enclosing scopes, but in many cases can go the other way. Example: https://play.golang.org/p/B9eEPyveK0h
Indeed, and that's a good view to have. I just thought I'd chime in about chi because I've only recently really looked into routers other than the gorilla ones, so I thought I'd spread the word a bit more.
Nodejs in embedded.... Gosh... Sound like fun
I write code with this general logic quite often. if cond { foo = Thing() } else { foo = OtherThing() } The easiest way to accomplish this similarly in Go is to define the variable before the branches var foo Bar if cond { ... It works and is a good pattern. The other thing you can do, which might be cleaner depending on your specific logic, is to use an anonymous function: foo := func() Bar { if cond { return Thing() } else { return OtherThing() } }() And depending on the size of each branch you may want to break that out into its own separate function.
&gt; use an anonymous function: Especially if you need to populate the value from an external source. I use this pattern often: err := func(*s SomeType) error { c := NewClient(dbconn) defer c.Close() s, err := c.Get() return err }
Since this SDK is lacking of integration with Service Bus Queue I created my own version: https://github.com/g-rad/go-azurequeue
Yup. Apparently the garbage collector doesn't work well on memory-constrained, 32-bit devices. which is a bit surprising since V8 is used in Chrome an Android, but perhaps tabs don't live long enough to get high memory usage. And yeah, fortunately I was able to switch us from node.js to Go, and it's been a *lot* nicer. Instead of having crashes a couple times a day due to memory leaks, we now go weeks between crashes, if at all.
OP, add support of AIX to the Go compiler.
Yeah, I really don't understand why it's so bad. They pour millions, perhaps billions, into v8, yet it still sucks on GC. But whatever, I don't do node.js anymore, so I don't have to care as much.
I'm very glad that this merge finally happen. Library code shouldn't panic but return an error. Pretty hilarious the amount of people who doesn't use a dependency manager tool that is pinned on a specific commit/tag. I support satori.
https://i.imgur.com/DTMITWw.png I was not in jail in September. Sometimes the motivation just changes.
Been there, done that :) https://github.com/BurntSushi/wingo
Thanks mate I‚Äôll definitely have a go at this, sounds very interesting to me
They picked Rust for Chef Habitat because Adam Jacob doesn't like code readability. ha
Because Ruby is dirt slow.
Cool!
&gt; Pretty hilarious the amount of people who doesn't use a dependency manager tool that is pinned on a specific commit/tag. Shrug. `vendor/` only arrived in Go 1.5 and there was otherwise no usable tooling or mentions in official documentation when it came to managing dependency versions in your GOPATH. I don't think we should be terribly surprised at the state of affairs today.
https://github.com/shurcooL/home/commit/83baea195d15c13d39b2fff6b7427fcc7ef6ad9c.
&gt; Why I'm getting down voted Because most people still believe just go get and vendoring are enough. I've faced issues on similar lines from package managers and the community here alike. I've seen people get down voted just because they said dep didn't work for them. Even if someone is clearly mistaken, we need to help them by telling them what it is, not doenvote to hell. Let alone comments like yours. 
and we laughed at leftpad‚Ä¶
While you're advice is definitely sound, it does go against the general view in the Go community of stable HEAD for dependencies. That idea is baked into `go get` in that it always pulls HEAD, you don't have the option to pin a version. A third party tool is required.
It's just a regular HTTP client under the hood so same rules apply (e.g. yes, it's safe for concurrent use).
Great. Thanks. 
While the mentioned mgmt is cool, it‚Äôs also pretty experimental, and didn‚Äôt support many things last time i checked. And one of the powers of chef is that it actually uses Ruby code as DSL. Implementing that in Go would be pretty absurd :-)
Not too terribly surprised that it's a mess to be fair. However, the sense of entitlement that the complainers have about something that is ultimately their own fault... now that is funny.
I wasn't aware of this functionality and I can see the use cases, but yes, the UNIX philosophy of simple, self-contained tools (like xargs) does not encourage that.
Perhaps I just don't get something but why not just say: if cond { v := someFunc() // use v here } // don't use v here Unless v was already defined somewhere else and just might need to be updated: func (o obj) getValue(a int) int { if o.needsUpdate() { a = o.updatedInt() } return o.doSomething(a) } Or you're doing something like what 014a said where in an else branch, you want to set the value to something else. Is there some other situation?
Do you think a "simpleHTTPSserver" is similarly unimpressive? I've been using something like that but hadn't really thought about putting it on GitHub.
Thanks for the thoughtful reply! Messages for this particular app aren‚Äôt required to be in order, they are mostly orthogonal but this helps me think about potential cases where that may be untrue so I‚Äôll chew on that. I like the queue idea too. We make use of the sockjs-go package to manage those sends and I believe there is a time out at play for slow/dead clients. So far memory not an issue. Broadcast is one of the few places we logged instead of returned the error, mostly because the caller didn‚Äôt have anything meaningful it could do with the information and clearly, at that point, we couldn‚Äôt talk to the client about it. But we didn‚Äôt want to loose the details that a failure was occurring.
At this point I think even Go parsing the Chef cookbooks implemented in Ruby would be faster than the typical chef client which is also based in Ruby. It's painfully slow and definitely doesn't take advantage of modern multi-core processors. 
Are there any other popular tools written in Perl? I would also like to work on porting it to Go.
Yeah, looking at the actual change it's mind-boggling that people mind this. The new behavior is a big improvement. So you didn't vendor your dependencies and have to (mechanically?) change a few lines.. Geez, big deal. 
"only in Go 1.5"... That was 2.5 years ago. :-) Even with the standard library compatibility guarantees that's a long time in Go ...
Looks like this project got way out of its scope. But you are right a clone of the core functionality in go would be pretty cool :) 
If gccgo and gc disagree on the legality of this program, that should be considered a bug and be reported. I'm not sure what the correct reading of the spec is, though. The [convertability rules](https://golang.org/ref/spec#Conversions) contain two special cases that are relevant &gt; * x is an integer or a slice of bytes or runes and T is a string type. &gt; * x is a string and T is a slice of bytes or runes. So either both conversions should be possible (if BS is "a slice of bytes") or neither (if BS isn't "a slice of bytes"). The other rules, I think, don't apply. I would recommend filing a bug.
It‚Äôs complex to use but what I like over GNU xargs is the progress meter and ETA functionality.
Use a `var` and document that it is not to be changed. Yes, that's the best way. Alternatively, you might consider returning the struct from a function, guaranteeing, that they always return the same value. But it does imply a lot of `()` whenever you use them for no real benefit, IMO.
&gt; I have a pair struct and want to give a name for possible field values of the pair. I cannot understand what you mean. Are you talking about something like this? type AudioOutput int const ( Mute AudioOutput = iota Mono Stereo ) 
It seems that windows support is almost perfect from the next release. https://github.com/c-bata/go-prompt/pull/38
Don't do this. All config management systems have the same fatal flaw: The code in your config system does not uniquely specify a box state. For example, if you say "install apache", then delete that line from Chef, apache will be installed on some boxes (the existing ones), but not on others (any new boxes you boot up). Problems like this can bite you months or years down the road. (I've been bitten by a dozen variants. One time I changed something that (indirectly) removed an nginx config file. Weeks later, we deleted the DNS entry that was in that config file. A few days later, a simple nginx restart failed -- because that stray file was still referencing that DNS name. Arrrg!) Plus not every chef change can be fixed by "rolling back" to the previous Chef commit. (Don't get me wrong, Chef is better than nothing. But it's going to bite you eventually.) There is a simple way to fix this: Always start fresh. But if you are going to do that, then Chef is overkill. The old unix tools (adduser, apt-get install, echo 'addme' &gt; config_file) work just fine if you don't need to make them idempotent. You can replace Chef with a Dockerfile, and it will be much more readable, and in less danger of breaking.
&gt; because a lot of those discussions will be around how they can interact very surprisingly with subclassing, which Go doesn't have. Covariance and Contravariance only make sense in the context of subtyping, because they describe how a subtype-arrow behaves under a given functor. Say A‚â§B (i.e. A is a subtype of B). Then in some languages `a -&gt; A` ‚â§ `a -&gt; B` (as you can use any A as a B, any function that returns an A can be treated as returning a B). OTOH, `B -&gt; a` ‚â§ `A -&gt; a` - if someone wants to put an A into the function, you can just as well treat it as a B. So, `a -&gt; A` is covariant for any A (it preserves subtype-direction), whereas `A -&gt; a` is contravariant (it inverses subtype direction). And Go *does* have (de-facto) subtyping, but only in a limited sense, by using interfaces. But it does only have invariant type constructors, if you will (so even if T1‚â§T2, []T1 is not a subtype of []T2, nor the other way around. (disclaimer: I can kind of use the fancy words, but it's not like I actually know a lot about type theory ^^) --- I don't think, however, that covariance or contravariance really are the issue here - because `type B byte` introduces a new type `B`, distinct to any other type, without any actual subtype-relationship between `B` and `byte`.
That would be great. The problem is that Docker is pulling `dep` at every build, so it never uses cached layers for subsequent steps. Do you know a simple way to make it cache the ADD layer?
Try multi stage builds, the first stage would be the dep install and then the second stage would be the binary. I may be missing something, but I believe I did something similar for one of my pipelines.
[removed]
The problem is that chef cookbooks require the implementation of a full Ruby stack, since there is pretty much no limitation on what anyone can use. I know I did some pretty nifty stuff in those... Sure you could write simple straight-forward parsing and re-implementing the basic resources hard-coded in Go, but the reality is that every single resource out-there is implemented in Ruby, both third party and internal-ones, and there are a lot of them. I am far from a Ruby fan for multiple reasons, but the more recent runtime versions have seen some respectable performance improvements, which are already written in C++ afaik. There is not a single indication that a re-implementation in Go would be faster than that. Ruby's - and Chef's - slowness is due to it's flexibility and complexity.
You are missing the certs from the scratch container, in case those are needed. As for having `-a` used, that's a terrible cache buster to use. You should also consider saving the GOOATH/pkg from the container to the host by mounting it onto the host as that would speed things up during the actual build more than anything else. Otherwise the current container negates all the benefits Go has in terms of compilation speed 
If you use plugins, you would need CGO_ENABLED=1. To do that, I use an alpine container with glibc, which is still pretty small at around 8MB.
&gt; You are missing the certs from the scratch container, in case those are needed. Good point. If you need to connect to an HTTPS server, some more work is required. As for the compilation speedups: this is an image designed for shipping to the production environment. Reproducibility is a much stronger requirement than compilation speed: this is why I purposely avoid any caching. On top of that, you don't necessarily have the `pkg` folder or even Go installed on the CI machine.
Right: Go plugins require the dynamic linker. An Alpine image with libc is for sure a good solution!
You sure ADD does not cache? i think it should cache based on content but not totally sure. Otherwise i would use RUN to install dep somehow
Also the timezone information probably should be copied into the resulting image together with the certs.
Chi[1] has a markdown &amp; JSON doc generation tool. There's an example of it in use at https://github.com/go-chi/chi/blob/4c5a584b324b74af3e9cfeaf6265d14ae2fdfc99/_examples/rest/main.go 1. https://github.com/go-chi/chi
FYI, it seems registration is required to download the eBook.
I don‚Äôt know about ADD, but it certainly caches my RUN go get dep commands. 
&gt; Note: The first encountered ADD instruction will invalidate the cache for all following instructions from the Dockerfile if the contents of &lt;src&gt; have changed. This includes invalidating the cache for RUN instructions. See the Dockerfile Best Practices guide for more information. From the docs. Sounds like it should cache as long as dep is byte identical. 
An alternative option to consider, assuming you have permission for the devices you're discovering would be to use SNMP. Using pcap will only get you so far as it's going to be limited to the network segment you're on. It all depends on your use case.
Alpine uses [musl](https://www.musl-libc.org), not glibc, as the libc, unless you specifically take some extra steps to install glibc.
Yes, Robert has filed it.
yes, but ...
Use direnv to automate your go path: http://tammersaleh.com/posts/manage-your-gopath-with-direnv/ Use the example from his post that uses 'layout go' inside .envrc
bugmenot.com has several logins and the top one has a bunch of books already associated that you can grab.
I use dep with vscode and haven't had issues. Here's the only related config I have, my bash profile (I didn't have to do anything in vscode config): # go export GOPATH=$HOME/code export GOBIN=$GOPATH/bin export PATH=$PATH:$GOBIN 
You can use caching and still ship to production reproducible builds. But even if you disagree with caching GOPATH/pkg, I just don't see an advantage to recompiling the standard library.
IMHO you won't be happy with Go if you want to mimic Python in that regard :(
Explicitly copy Gopkg.lock first, then run dep, then copy everything else. That way the part up to and including dep is unchanged so it can be reused from cache.
Why is it mind-boggling that people mind this when applications that used to build now do not build? It's human nature to mind when you've had extra work forced upon you by someone else's decision, especially when you were not expecting it. And since the issue it solves was happening never or almost never for many, many users, how is it a "big improvement"? If the average project broke their API like this once a year like this, I'd probably spend 10% of my time fixing the fallout (whether in my code or in 3rd party stuff that's also been broken) There are much better ways out there of handling this kind of thing without forcing your users to do extra work. 
Thanks for the honest response. I have mainly been interested in Go for doing some command line tools and eventually some desktop GUI programs. I just know that there are some decent Go web frameworks such as Revel and Gin. Go has strong typing support. I could definitely see a framework able to do self inspection of its router and required parameters/arguments to produce an api reference. 
Thanks, this looks pretty solid. It's a different approach, but not a bad one.
Just curious what your plan was for desktop gui programs? Support for desktop gui seems like it is mainly binding to some other gui library, nothing native to go. Not saying that python is any better since I used python for a desktop gui app once and decided it just wasnt the best way to do it.
&gt; Good point. If you need to connect to an HTTPS server, some more work is required. All that should need to be done is add a line to your final stage to copy in ca-certificates.crt from the first stage: COPY --from=0 /etc/ssl/certs/ca-certificates.crt /etc/ssl/certs/ca-certificates.crt Now your application in the final image has access to the requisite certificates.
Correct
This is an album of neat images from my twitch stream where I have been teaching programming via small game projects in Go. Our current project is using a genetic algorithm to evolve pictures. Pictures are drawn by traversing an abstract syntax tree which represents an equation in terms of X and Y. We use goroutines to render the population of trees in parallel for speed. You start with a population of random ASTs, and the user can select any number of them to 'survive' to the next generation. A new population is created by mixing and matching subtrees from the surviving trees around, plus some random mutation of tree nodes. Repeat the process until you have an image you like! Next episode we will be outputting the trees in a lisp-syntax text form, and writing a lexer and parser to load them back in. I'll be using Rob Pike's talk about lexing in go as a basis: https://www.youtube.com/watch?v=HxaD_trXwRE At some point in the future when we get to OpenGL we may revisit, and output the trees as shader code, to make this super fast. Which, is remarkably easy to do! 
You can try https://www.codingame.com/training, it's good site for learn programming language.
I have been doing a twitch stream that does just this, I assume no prior knowledge, and we use all free, cross platform toos. See gameswithgo.org past episodes are all up on youtube 
uh, well, it looks like it does. I'm still confused why it's caching now that I'm using docker-compose, and not before when I was `docker build .`-ing.
The first couple are interesting but then the rest are just silly "gotchas", IMO. ---- TIL about `go vet -shadow`, though. Definitely keeping that one in my back pocket.
@wwader I was wrong! `ADD` is actually caching in some circumstances. I am changing the Dockerfile right away! Thank you.
You are right, it's caching in most circumstances. Fixing right now! Thanks.
I'd like a FLAC metadata library, with a command line client.
I have no problems, but then again I follow Go's recommended directory structure and don't have multiple GOPATH entries.
I just realized today that `interface{}` is the type of `interface{}`. So while you might leave off the brackets with other types, interface needs them. append([]string{"A"}, others...) append([]interface{}{"A"}, others...)
This is pretty useful. This might be a dumb question, but... How does one go about defining environment variables in a Docker container?
When a dependency is deleted, copy the code out of your vendor folder and (assuming it's properly licensed to do this) create a new fork, then tell dep to fetch the dependency from your fork's URL in Gopkg.toml. Or if someone else brings the dead repo back to life, use their URL as the override.
Open the preferences and verify that "go.gopath" is either set to `null` or does not exist in neither of User Settings, Workspace Settings (if available) nor Folder Settings (if available). If this entry is set to a path, VSCode will use this one instead of the system GOPATH.
Thanks for those series, I‚Äôm enjoying it a lot as I learn how to use sdl2 with Go. Also, gotta love those Lisp parenthesis.
[removed]
I see two problems here 1. `selectedChar = Cartman`*copies* the value of `Cartman` to `selectedChar`. 2. The ordering of `init` execution may mask this behaviour depending on the order they are run. With `go run main.go characters.go` the `init` from main.go runs first. With `go run characters.go main.go` and `go build` (which you should be using) the one from characters.go runs first. One fix is to have `selectedChar` be a `*Char` instead of `Char`. This lets the global character object (e.g., `Cartman`) be the single source of truth for that character and `selectedChar` point to the currently selected character.
Thank you for uploading the streams to youtube. It's impossible for me to watch it live due to timezone so you got yourself a sub. I also found [An Introduction to Programming in Go](https://www.golang-book.com/books/intro) but I don't know if its good or already outdated.
That looks like a good resource, Go information can't be too outdated, the language has been relatively stable. 
shadowing has bit me before! 
This is a really neat way to tackle the API versioning problem. I'm not writing any Go professionally but I would be very interested to see how it works in a big production project.
Thanks I will look into this
Thanks for clarifying it for me. Just watched [EP. 02]https://www.youtube.com/watch?v=R9LPV44RLv4) and I learned more in that hour or so than from all the other resources I tried before. You are very clear and concise in your explanations and that for a non native English speaker its a major benefit. Also I really enjoyed watching the logic behind doing the stuff in one way as opposed to the other. Thank you very much to get me excited about learning the language and not being able to sleep now :)
I will definitely look into this thank you
Video linked by /u/Biofobico: Title|Channel|Published|Duration|Likes|Total Views :----------:|:----------:|:----------:|:----------:|:----------:|:----------: [Games With Go EP 02 - Variables, Loops, Conditions](https://youtube.com/watch?v=R9LPV44RLv4)|Jack Mott|2018-01-05|0:59:57|10+ (100%)|182 $quote I introduce variables, loops, and conditionals. We do our... --- [^Info](https://np.reddit.com/r/youtubot/wiki/index) ^| [^/u/Biofobico ^can ^delete](https://np.reddit.com/message/compose/?to=_youtubot_&amp;subject=delete\%20comment&amp;message=$comment_id\%0A\%0AReason\%3A\%20\%2A\%2Aplease+help+us+improve\%2A\%2A) ^| ^v2.0.0
Thanks! I'm curious as well üòÉ. It would definitely be a delicate process to switch from an existing solution to this, however if snapshots were taking prior, that could provide some confidence.
It is a best practice in software development to have a rigorously defined API and then coding to that specification, not the other way around. If you don't like swagger, then you might prefer protobufs and gRPC. 
Forgot to mention binary begins with 0b
Cool. This would make for an interesting protobuf plugin where you just diff the protos* (as you can easily just introduce new fields, keep track of renamed fields through the identifying number, and leverage deprecated=true) ‚Äî and then just generate most of this stuff. (*This obv makes most sense if you use the proto as ground truth for everything, even for json based requests, that is.)
It's a very hacky solution. Thanks for it though. I haven't checked in my vendor directory yet. 1.5 mil lines it adds to my project. Those many lines to maintain, take through upgrades, vet on every update. If I can avoid it, I would like to.
Thank you!
btw there are examples in there to get started (list all products, create payment url CLI and web server, online store web server) hehe, also a telegram notification bot powered by selly webhooks that you can deploy on heroku! [Work In Progress](https://github.com/aerth/selly-notify-bot)
ENV var=value
I guess it's a tradeoff in ops vs code overhead? My interest in a code-first approach is it prevents possibility of drift, especially if changes/improvements are made to an API that are independent of versioning. I'm interesting in hearing more though! How do you direct requests / inspect versions? And how would it work if there were multiple instances per version?
Is there a specific reason why you didn't talk about versioning using header metadata? Headers and media types exist for the client and server to be able to know things about each other without mucking up the body and paths. The HTTP protocol gives you really awesome tools for solving these problems.
The drift concern makes sense though it's never come up for me personally, I've done it all sorts of ways, but at my current job we use a pair of gateways (one internal, one public). These gateways route to different versions using the version in the Accept Header. Infrastructure behind these gateways varies, but these days we're mostly containerized so each API version does in fact have multiple hosts on which it runs. These are load balanced as any other set of hosts. This whole scheme can get pretty complex at work, since it's a large enterprise, but even in my personal work, I can't imagine a time when I would prefer the nasty, conditional code overhead to the infrastructure overhead of two stacks. Of course, your lib makes the code better, and I also stress automated, easily maintained infrastructure etc so two stacks is no big deal besides perhaps the cash (but scaling with traffic alleviates that since traffic is split across versions then). Perhaps in a position where the infrastructure was a huge pain, your lib would make the code a more attractive choice for version management. It just happens it's not the experience I've had. 
Well, that seems obvious. Derp. Thanks!
I can see how this may be useful for versioning response data structures, but how does this help when versioning domain logic?
I was indeed referring to that.
We concluded we could still use it without much risk. But ya, it was a pain. Programming is easy compared to legal jargon.
This shows how little I understood any of it. We had lawyers review it, and we were good to go. My understanding was from reading forms of a bunch of people trying to interpret it on GitHub üòÄ
Does Chef need to be particularly performant? It's for doing high-level automated sysadmin tasks, not finding prime numbers with millions of digits.
Yes, when running app installs or using test kitchen something like installing R or python might take several hours for a single iteration due to the sequential nature of the run with package installation. From a Devops perspective this is incredibly painful. If I'm installing hundreds of independent packages from source then why not do some in parallel? If you're just using it for basic configuration management then you certainly don't need it to be terribly quick.
I think that the examples you cited have more to do with a poor implementation than ruby being slow. There is nothing in ruby preventing the Chef guys from forking processes to do work in parallel. While I am not terribly familiar with Chef I have used things like Ansible, Puppet, and Salt. There are things you can do in those tools to help speed things up but they are always going to be a bit slower than pure shell scripting.
I agree chef is poorly implemented ruby... That said ruby itself is very slow. Try doing anything at all from Windows in Ruby. I avoid Windows like the plaque but should you need ruby it takes forever to load anything. 
Many languages have binary literals with 0b notation, but not Go. There is a proposal however. https://github.com/golang/go/issues/19308
https://github.com/go-chef/chef
You can actually get the updated version of that course on greatercommons for free, Todd Mcleod is a pretty great instructor, I'm using that course to learn programming for the first time myself!
"Array won't change" and "String won't change" are pretty unrelated. And "Array won't change" is a pretty misleading title for any value type. Waiting to see "Int won't change". I thought most people nowadays accepted that nothing bad happens to them if a picture of them is burned... 
Adding this to my commit hook, I got bit by this yesterday.
I love Golang for command line/text tools! And there are lots of libraries like https://github.com/rivo/tview for playing. 
I've signed up on greatercommons but it asks me to pay $20.00 and I can't find where I can get the updated version for free. I have no doubts that Todd is a good instructor, but the Udemy's course format isn't what I expected.
Thanks a lot! It solved my issue.
[removed]
[removed]
Your DefaultUserAgent is invalid. net/http had similar issue: https://github.com/golang/go/issues/9792
What I've seen is all for bindings as well. GUIs I'm thinking of would be add-ons to command line utilities, geared towards controlling local hardware or amateur radio communications. I want them to be relatively lean, and I'm planning to avoid the browser shell/electron route. The one that I was most interested in is [ui]/[libui], but the development of that is (understandably) slow. It still might be worth experimenting with because it looks like it would be pretty clean and lightweight. Otherwise, the top contenders are Qt and [Nuklear]( https://github.com/vurtun/nuklear). Qt seems like the best choice, though it does have some licensing restrictions around distribution that complicates things. [ui]: https://github.com/andlabs/ui [libui]: https://github.com/andlabs/libui
Thank you, sir!
The [package](https://github.com/sjkaliski/pinned) itself let's you use either the query params or the request header to determine version. I didn't include that in the post for brevity.
I don't understand this question. Can you give a little bit more details on what you are trying to achieve?
I love goland from jetbrains. But I have heard good things about visual studio code
&gt; Am I just setting the bar too high? If you cannot find anything then yes you are. Remember, go is still a new language - rapidly growing in popularity but still new. There are quite a lot of developers wanting to code in it and not many positions for it. Most companies that are coding in go will likely also have things written in other languages as well. It is only the newest of startups that will be almost pure go. That said a lot of companies are moving towards it so you might have better luck finding a job for a company that uses other languages but that might be open to moving to go - or at the very least allowing you do to start some new projects in go. Looking for companies that are already use multiple languages might help. You can always get a job working with another language for now while continuing to look for that dream job you want but dream jobs that meet all of your goals will be hard.
Maybe [this](https://play.golang.org/p/Wvpx8Pt7ld6) answers your question (if I had to guess), but note that there's a reason the unsafe package is called unsafe.
I don't think it's unreasonable, and I think it will be a growing list. Have you seen this list? Many of these places use Go: https://github.com/remoteintech/remote-jobs
Also I recommend subscribing to Golang Weekly and checking out their Jobs section each week. You can also just browse the archives: https://golangweekly.com/
Same here, I use Goland after for a long time using the Go plugin for PHPStorm, but they eventually removed the plugin and made it into an own product....
That totally makes sense. The only thing is that I think I'd rather wait for something that really fits rather than to work on something I don't truly enjoy. Knowing myself I don't think I would do a good job if I'm not into it unfortunately. Very good advice though, thank you :)
Depends where you live. Sure, in SF.
I'm in Europe. It's true that it would most likely be easier in the US.
Didn't know it existed, going to check that asap! Thanks! :)
Of course, that's why your server should have sane defaults for how it responds to clients that don't specify what version of the API it wants to use.
vim or emacs :P
Gotcha, your article made it seem like your proof-of-concept was path-based.
A lot of companies give reasonable freedom to work with multiple languages. Some allow you to transfer to a team which is using this or that language. In my experience, language is less important than the company culture. If you're writing Go in a toxic environment, you're probably not going to be enjoying yourself.
Fixed the issue the blog had with safari, so the "word gapping" should be gone.
Fixed the issue the blog had with safari, so the "word gapping" should be gone.
Best in which dimension? If availability of gruber-darker color schema is more important to you than price the answer might be different. Just use emacs like everybody else (who doesn't use vim).
I use Atom but what ever your use to is fine.
What is emacs 
If you use vim, install the vim-go extension. Auto formats, build and run from normal mode, plus so many awesome features for go.
Well, I simply believe that Go is a tool that I enjoy working with, there's no shame in having a favorite tool is there? :) When I said I was looking exclusively for Go jobs, I don't mean that I won't touch any other language. I just really like how Go allows me to focus on what matters and not on maintaining a build toolchain, struggling with deployments because of compilers, etc.
&gt; rather than to work on something I don't truly enjoy. Welcome to life as an employee. It is rare to get your ideal job what you really want is to aim for a job that puts you in a better position then you currently are. If you can afford to wait for this then great, but it can take some time with a high bar set.
&gt; Good dev don't really care about tech x,y,z. That couldn't be more wrong. Good developers are going to want to choose the best tool for the job, which will vary depending on what it is you are trying to accomplish. Some programming languages (e.g. PHP) are bad choices all the time.
Updated! Thanks for catching that.
It seems suboptimal to put this into a `map[int]int`, instead of a sorted slice of `[]struct{start, end int }` (or a binary search tree or something). The map makes inserts of intervals O(1), but every *other* operation O(n). Presumably, inserts will happen a lot less often than, say, membership-checks.
It's a religion based on modifier keys, but that's not important right now.
What kind of IDE features are you looking for? Many editors have so many language specific features integrated that the lines are pretty blurred. Goland is the only true IDE I‚Äôm familiar with, but I get everything I need through Neovim with Go plugins myself. 
Restricting a search to 1 language + remote + exciting is going to be hard yes, no matter what the 1 language is. I would advise against the 1 language search. You may find go really exciting now but one day you will realize language isn't really that big of a deal! Better to work on an exciting *thing* or for good money/environment than a particular language. 
Why do people feel that this sort of pedantry about what is an IDE and what is not is an important thing to talk about? With a sufficiently featured language plugin, VsCode/Atom become IDE in every practical sense of the word. This isn't meaningful to argue about.
Come to SV, there are a bunch here
I was able to get a (full time, remote) job in Go in 5 weeks of applying for almost exclusively remote Go jobs (after 4 weeks, I started applying for remote jobs in other languages). I may be an outlier, I don't know your experience / education. I used the #gophers slack and whoishiring.io to filter for jobs, if that helps you.
I think you misinterpret what I was saying or I didn't communicated it properly, yes they're going to use the best tool for the job opposed to I want to code in x,y,z because it's fancy.
I actually had the opposite use case when I wrote the library. My usage pattern was to read the set out of a database, insert/delete new intervals, and then iterate over the entire set. So I optimized for the Insert/Delete operations instead of the Contains/Overlaps.
Agreed. So to be clear.. did the change to the license Facebook made in the last few weeks or so get rid of that concern? Or is there still some jargon in the new license that indicates you would lose your license to use ReactJS if there was any litigation?
Eh, that's what I use anyways.
Yeah but they don't feel powerful and I have editing those json files in VsCode 
Standard constructor? Go has no constructors, just methods that can return objects constructed by the method you showed. You normally prefer to wrap that syntax in a method as it is a little nicer to look at and you cna add validation or change the default values that are return.
If you work at a larger company, you shouldn't have to worry about build toolchain or compilers, no matter what language you use. Somebody else will have already solved that for you.
Yeah this was pretty clear to me. I understand the use case of pointers like: n := 3 p := &amp;n However we cannot write something like: n := &amp;3 because this just doesn't make sense at a memory level, and I understand that. The problem with structs is that you can actually call: s1 := &amp;MyStruct{1,2} s2 := &amp;MyStruct{3,4} fmt.Println(s1, s2) this is perfectly legal, and you can edit those two MyStruct instances values independently. This is what's not really clear to me 
I've used jetbrains in the past. Watching the feature tour, it looks like much of the feature scope is the same as Atom (IDE) with plugins like goplus installed.
I'm not sure if you're being sarcastic or not, but if not: You haven't really made a case for why PHP is any good and should be considered for serious endeavors over other, more capable languages in the same sphere. It is widely understood to be a poorly designed mess of a language. That mirrors my own experience with it. But don't take my word for it - see the well-known blog post "PHP: a fractal of bad design": https://eev.ee/blog/2012/04/09/php-a-fractal-of-bad-design/ If I also told you that brainfuck or whitespace was an awful language that should not be used for serious projects under any circumstances, would you also reply that only a Sith deals in absolutes?
Thanks for replying. Can I ask which web framework you're using for Rust? Is it Rocket?
Yup.
Most people use VS Code.
So does Go have constructors or it doesn't have them. You confused me with your first reply
Yeah but why should I edit a file when I can go into the GUI and change it 
Hey - here at WorksHub we're thinking about setting up a 'GolangWorks' platform in the coming months as we've found the Go community super vibrant and buoyant! It would be great to know whether this is something that would be pretty well-received...? You can get an idea of how it could look here - [WorksHub](https://www.works-hub.com/?utm_source=reddit&amp;utm_campaign=Walkies&amp;utm_content=Gen%20FP) 
That was a serious answer. Emacs is an operating system that lacks a decent programming editor
`&amp;MyStruct{}` isn't a constructor, because it doesn't cause any kind of initialization code to run. It's a struct literal, just like `17` is an integer literal and `"cheesecake"` is a string literal. If you want a constructor, the usual Go style is to create a `func NewMyStruct() *MyStruct {}` method.
Oh, I'm someone else, not the person you were talking with. I was just making a funny. I agree that PHP has a lot of bad design decisions. I haven't worked much with it, and for that I'm glad. But PHP is good for some things, e.g. beginners who just want "HTML + a bit of logic." I probably won't recommend that somebody use PHP. But I, like the parent, take issue with the assertion that PHP is *always* a bad choice.
Rather than shelling out to `git`, you might want to take a look at the excellent https://github.com/src-d/go-git library. Every commit and file can be analysed in memory this way. It may be much much faster. 
Depends on where in the US. If your city doesn't have a big tech scene, you may be trapped doing .Net or having to work remotely.
Agreed, This isn't a golang issue just a SQL issue. Ether JOIN or UNION the tables together if the result set needs to be a single result set. If you are querying multiple tables and expecting multiple result sets then you need to issue those independent of each other. Finally, if you want to get multiple result sets at the same time that is a situation for a goroutine to be used.
Very similar idea to what Stripe is doing https://stripe.com/blog/api-versioning Looking forward to seeing it being used in a larger project. Sounds very useful. üëçüèº
This was the inspiration (linked in post) :)
May I introduced you to the wonderful world of relational algebra. https://en.wikipedia.org/wiki/Relational_algebra
Exact same thing for me, I used Slack and got a full-time remote job in four weeks. Going to local Go meet-ups might prove valuable too, and the recent Who's Hiring posts here on Reddit can be useful too.
&gt; But I, like the parent, take issue with the assertion that PHP is always a bad choice. Please argument this. Why ?
Same thing for struct: `append([]struct{}{}, others...)`
Berlin has a bunch of Go companies. Who is hiring on HN and golangjobs are your friends.
We are based in EU, we love GO, we build Traefik ;) https://containo.us/jobs/developer
What exactly do you find concerning about that? All of the vulnerabilities in that list are fixed, it would seem to me.
Is it something to be concerned about, when merely installing the Go toolchain? Not in the slightest. Most of the CVEs in that list (I didn't look through every single one of them) are for older versions of Go. Additionally, the ones I looked at are for various parts of the standard library; simply installing the Go toolchain won't make the underlying system any more-vulnerable, since those standard library packages will get linked into the resulting executable. If, hypothetically, you were to install a version of the Go toolchain that some of these CVEs pertain to, well...let's just say I don't know why you would necessarily want to install an older version of Go. If you have a distinct reason to, I'd like to hear it.
What is GL? Good Luck? Graphics Library?
Reports indicate this was done in preparation of Google porting the Chrome codebase to Go.
gotcha thnks
like: &gt; The net/http package's Request.ParseMultipartForm method starts writing to temporary files once the request body size surpasses the given "maxMemory" limit. It was possible for an attacker to generate a multipart request crafted such that the server ran out of file descriptors. not sure who have written this CVE, but basically it's useless. the http standard library of go is low level. If it would not have the maxMemory limit somebody could use all the memory... the only way to prevent that would mean to kill the request before the ParseMultipartForm if a certain amount of bytes is reeached. But that should probably not be handled inside ParseMultipartForm directly...
https://4.bp.blogspot.com/-3PZhBqkbF6U/UExreutG4cI/AAAAAAAACu4/iIiTVLroxNA/s1600/patrick-bateman-upvote.jpg
I use Rocket for one project, Iron for another. I've been looking into gotham recently though since it looks like a better Iron with async I/O. Async in Rust is changing, so I'm holding off doing a major update until things settle down a bit.
couldnt agree more
That‚Äôs what I thought. My conclusion right now is to just a different client if a different token is to be used in concurrent situations. I am thinking it will not add too much overhead with this method. 
That's probably also a totally feasible option üëç
Obviously, join tables when you need to. However, sometime it does make sense to return multiple tables in a single query. Use: https://godoc.org/database/sql#Rows.NextResultSet to do so. Here is a package that can buffer multiple result sets that you can use directly or use as an example: https://godoc.org/bitbucket.org/kardianos/table To those suggesting multiple queries for multiple result sets, sometimes they are interrelated with many temporary tables calculated to return them all. Sometimes it is the best way. Slow down on your criticism. 
[https://github.com/weaveworks/scope](https://github.com/weaveworks/scope) is a product, written in Go, that does what you want on live systems.
 import "game/player"
In LoadConfiguration() on line 58 you aren't checking the error. Change that to `err = decoder.Decode(&amp;config)` to see what the problem is. There is quite some unidiomatic code, but this should be a start.
could is be that StatusCode in SendSMS is not in the 200-300 range? try log the resp value etc
I searched for a pure Go job in Europe and found one. We are hiring by the way: [Smallpdf Careers](https://smallpdf.com/careers)
I'm sure that SendSMS is returning something. Take a look at what it gives you back. 
^/s
You can try Prometheus for monitoring API calls and Logrus for logging. Logrus can be used as well with another library to send the logs to Logstash or to format correctly logs so that Logstash can aggregate them rightly or if you don't need that then just simple logging into a file. You can easily integrate Prometheus with router you are using. If you want to know status of your services etc. you should use Consul for that. https://github.com/hashicorp/consul/tree/master/api https://www.consul.io/api/agent.html https://github.com ‚Ä∫ sirupsen ‚Ä∫ logrus https://github.com/zsais/go-gin-prometheus 
+1 for prometheus!
Moving from C++ to Go won't in and of itself help with memory. On the contrary.
I'm pretty sure it's a small dig about Chrome taking a lot of memory.
Add grafana to pull data from Prometheus and youve got a winner!
is this how fake news happens? 
... and take a lesson for the future: never silently ignore an error. At a minimum it should be logged to debug. There‚Äôs a reason why static analyzers flag this anti-pattern. 
Yup, GCs are a lot of things, memory light is not one of them.
&gt; I will never understand why so much hate against PHP... Have you ever read https://eev.ee/blog/2012/04/09/php-a-fractal-of-bad-design/ or https://blog.codinghorror.com/the-php-singularity/? &gt; When was last time when you have used PHP seriously so that you can say it's always the wrong tool? When was the last time you used any language that had an equality operator that you are actively supposed to avoid using because it provides broken comparison? PHP 7 documentation still has a big warning box on [the strpos documentation page](http://php.net/manual/en/function.strpos.php) telling you that you need to be extra careful to use `===`. &gt; It doesn't even make sense. What exactly does not make sense about calling something like it is? You'd probably think it stupid for someone to drive a nail with a rock when they have a perfectly good hammer, right? &gt; Are you one of those who used PHP 10 years ago and think it hasn't changed since then? I am one of those people (aka "competent developers") who knows that the single most glaring flaw in PHP is its loose typing. And guess what? PHP 7 is still loosely typed: 0 == "" // this is true How about the fact that the standard library is garbage? We still have functions like [ldap_connect](http://php.net/manual/en/function.ldap-connect.php) which, despite its name, also clearly has a note on its documentation that it _doesn't actually connect to anything_. So please enlighten me - what has changed exactly? Because as far as I have seen, it is still littered with problems. Also, I have to say I'm surprised to be hearing this sort of disagreement in the Go subreddit since it is actually a well designed language.
Just looking in /usr/bin on an ubuntu 16.04 box finds 129, that does over count for the actual perl executables and helpers, but it gives you easy targets to start porting/replacing (also the debconf stuff that I did not know was in perl): packer17:/usr/bin$ file * | grep -i perl | wc -l 129 packer17:/usr/bin$ file * | grep -i perl | head aspell-import: a /usr/bin/perl script, ASCII text executable bogoupgrade-bdb: a /usr/bin/perl -w script, ASCII text executable c2ph: a /usr/bin/perl script, ASCII text executable calc_tickadj: a /usr/bin/perl -w script, ASCII text executable ckbcomp: a /usr/bin/perl script, UTF-8 Unicode text executable corelist: a /usr/bin/perl script, ASCII text executable cpan: a /usr/bin/perl script, ASCII text executable cpan5.22-x86_64-linux-gnu: a /usr/bin/perl5.22-x86_64-linux-gnu script, ASCII text executable crc32: a /usr/bin/perl script, ASCII text executable c_rehash: a /usr/bin/perl script, ASCII text executable 
You have a clear upgrade path from that 1GB VPS
just what I needed :)
I know this is not your question, but if you ever want to learn quick sytax in one one-hour video, check derek banas' videos. It is very easy to watch even if you are not very experienced. I think. https://www.youtube.com/user/derekbanas
Sure, it may not be the best choice. But you can't say it's always a terrible choice. Whenever you find yourself making "always" or "never" statements that contradict what other people believe, it's usually because you have less understanding than others, not more.
Great question. The focus at first was purely in the "contract" between server - client. The side effect behavior is not addressed. However, functionality, the version is available, and can be passed through context. Specific example in mind?
For what? Storing porn in heap?
Load times are *such* a boner-killer.
My wife won't find it there :) 
This patch does a lot more than increase the total memory limit. I don't know enough about browsers to know if some if these changes might be useful to land before porting huge amounts of code. It's becoming more and more clear that I likely missed the joke, though I still don't think it's out of the question for a significant portion of Chrome to be rewritten with memory in mind, especially for Chrome OS and mobile Chrome.
Third data point, but I was found from my GitHub repos (among other things, IIRC).
Ah! it looks good now I didn't realize it was a safari only thing
Isn't process per tab a thing to stop one tab killing the whole browser process though? 
Yes! Forgot to mention that. 
https://github.com/go-gitea/gitea
I appreciate the readme says "Screenshots" and then shows a text block. Good job!
Chrome's process model is there's one browser process (with complete filesystem/network/etc permissions) and multiple renderer processes (with sandboxing to limit them to IPC with the browser process). Separating the browser and renderer processes is for security, but (at least today) having multiple renderer processes is just a performance/reliability feature. There's no extra sandboxing between renderer processes. However, eventually the Site Isolation project should address this: https://www.chromium.org/Home/chromium-security/site-isolation
Aren't renderer processes more secure by virtue of being in different processes alone? I was under the impression that this separation in itself is to mitigate the risk of code execution in one process reading other tabs' memory. And that should be provided by the OS without specific sandboxing capabilities.
(For context, I was on Chrome's security team for a couple years working specifically on sandboxing and process isolation.) &gt; Aren't renderer processes more secure by virtue of being in different processes alone? Sure, splitting renderers across multiple processes means they're slightly protected from each other, but there's nothing valuable in a renderer process. The valuable content (e.g., cookies) are stored in the browser process, and because of cross-origin iframes, the browser process can't know whether a renderer process is acting legitimately or maliciously if it accesses random cookies. In typical Chrome exploits, an attacker gets arbitrary code execution in a renderer process (usually through a V8 bug), and then sends malicious IPCs to the browser process (or another process with relatively elevated privilege, like the GPU process). There's rarely any point to using a renderer process to attack another renderer process, because it doesn't grant any extra capabilities to you as an attacker. &gt; And that should be provided by the OS without specific sandboxing capabilities. Sandboxing is necessary because otherwise processes can use debugger functionality like `ptrace` to read and manipulate each others' memory.
Vertical scaling all the way up to the moon.
Nice, now I only need 496GB more RAM to make use of this
Ahh I was under the impression that a single renderer would be on a single origin. That must've been some really interesting work!
Regarding the "reconfigure" proposal: - I don't understand the connection with OpenCL; in particular, Tasks don't mention OpenCL at all; - I find both the Tasks and Expected Results muddy/unclear/handwavy. No idea what the mentor really wants from me, if I were to try to participate (which I'm not BTW, not a student already for some time). In other words, I'd find it impossible to measure my progress against the proposal's goal (esp. given that the goal is not even clear to me). That said, I'm not sure if such stuff is required for GSoC.
I haven't "coded" (ok, scripted, but it's the same... right??) since.. a decade ago? lol Started watching this dudes tutorials earlier. idk if it's quite what you're looking for but he does a pretty good job of walking you through all the different syntaxes. Everything is letter for letter "type what I type &gt; here's what it basically means &gt; this is what *should* happen &gt; here's what broke". Anyway, just signed up to share the love, the tuts have been a great intro to Go for me. Thanks u/sentdex! https://youtu.be/G3PvTWRIhZA
CNCF is also accepted as an organization. Kubernetes, Prometheus and other projects have proposal ideas listed.
neither did I, and it was not an issue on the latest safari version when I tested it :D
This is a test code that I wrote using the glot library. The problem is that even though the png file does get created I get a completely empty file with no image in it. Some information on how I installed glot (in order) : 1) go get github.com/Arafatk/glot 2) then install gnuplot from https://sourceforge.net/projects/gnuplot/?source=typ_redirect 3) then I changed the PATH in ADVANCED SYSTEM SETTINGS -&gt; ENVIRONMENT VARIABLES -&gt; in SYSTEM VARIABLES -&gt; I typed in this path C:\Program Files\gnuplot\bin because the code wouldnt compile without a correct path How do I solve this? import ("github.com/Arafatk/glot") func main() { dimensions := 3 persist := false debug := false plot,_ := glot.NewPlot(dimensions,persist,debug) plot.AddPointGroup("Latitude","lines",[]int32{1,2,3,4,5}) plot.AddPointGroup("Longitude","lines",[]int32{10,11,12,15,8}) plot.AddPointGroup("Slope", "lines", []int32{1,3,18,11,2}) plot.SetXLabel("Latitude") plot.SetYLabel("Longitude") plot.SetZLabel("Slope") plot.SavePlot("test.png") plot.Close() } 
From what I've watched, his videos seem "perfect" for programmers and not so much for beginner like myself. Thank you for sharing it. 
indeed: - Xapian: - https://trac.xapian.org/wiki/GSoCProjectIdeas#Project:ImplementBindingsforGo - Amahi (no particular proposal with obvious Go-related tasks) - CNCF: - https://github.com/cncf/soc - https://github.com/grpc/grpc/blob/master/summerofcode/ideas.md - Kubernetes, Prometheus, CoreDNS and gRPC (sadly, no Go proposals that I could see) - Elastic: - https://github.com/elastic/gsoc#ideas - Matrix.org: - https://github.com/matrix-org/GSoC/blob/master/IDEAS.md - https://github.com/matrix-org/GSoC/blob/master/IDEAS.md#contribute-to-dendrite - Honeynet: - https://honeynet.org/gsoc2018/ideas - https://honeynet.org/gsoc2018/ideas#honeytrap-iot - https://honeynet.org/gsoc2018/ideas#honeytrap-core
Thank you for sharing the link. Already bookmarked it after seeing the intro video because I'm mostly interested in web dev.
My website counter api is saved!
a few pointers: - https://github.com/glycerine/zygomys - https://github.com/mattn/anko (used by buffalo) - https://github.com/go-interpreter/wagon (not used much (yet?))
[removed]
you can serve a lot of APIs now
A lot of people have explained the semantics of constructor but I don't think you got an answer as to why you would sometimes want a struct, and sometimes a pointer to a struct. Being able to control how you use memory is one of the most important things you can do to control the performance of programs on modern hardware, and choosing when you want a pointer and when you don't is part of that. For example if you have an array of MyStructs, wher MyStruct contains an X and a Y, it would look like this in memory: [X,Y,X,Y,X,Y,X,Y] The Xs and Ys would all be contiguous in your computers memory, which if you needed to often iterate over them and change them, would lets this be done very quickly. Conversely, if you had an array of pointers to mystructs, the array would contain just pointers, and each pointer would point to a relatively random position in your computers memory. This means your CPU's caches will not as easily be leverage to grab those mystructs from ram quickly, and iterating over an array and reading or writing those mystructs would be much much slower. It is a good experiment to try for yourself. In Java for instance, where you have no choice, the array would always be pointers to your classes, and performance suffers when you have to do that. Another time when you might want a pointer is if your struct has many fields, passing the struct to functions means making a copy of all of those fields, which can get expensive. When passing a pointer to a struct you pass only 1 word to the function. Lastly you might chose one or the other for the semantics of how your code should operate. If you pass a struct to a function, and that function modifies the struct, it is modifying a copy, not the original struct you passed it. Sometimes that is desired. Other times you might want it to be working with the original. In that case you need to pass a pointer. As others have explained the struct initializer is the same in either case, The &amp; is applied to it like any other variable, to get an address of the struct. Hope that helps! 
Grafana uses Go https://github.com/grafana/grafana
Thank you really! This was a really good and clear explanation. Having never worked with pointers on a serious level, I was struggling to grasp these kinds of low level differences. I'll definitely try the array of struct thing! Thanks :D
I've honestly not had a tab that's crashed stop my whole browser in years with Chrome. I can always switch tab, and it always pops up and asks me if I want to kill if the misbehaving tab if it happens. I honestly don't think you could write a browser in Go efficiently enough. The GC would end up being too painful for it I think, despite how fast Go is, and how fast the GC is. There's a good chance a Go-based Chrome would use more RAM than the C++ based implementation too, and if they can optimise Go to be more efficient than the current C++ implementation, it just means they could make an even more efficient C++ implementation. If safety is a concern, Rust genuinely would be a better option, because it would be able to very quick because it's much lower level than Go. I think Go feels a lot more low level than it really is.
Just wrote this! Hope you like it! If there's any patterns that you'd like to see added, or any sections you'd like to see built upon, let me know!
Most promising, thx! Let's not forget your own that I just happened upon: https://github.com/sbinet/go-eval ;)
That was fun! Props to who came up with the challenge 
yep. AST-evaluation based. (but I just happened to have salvaged it from the pre-Go-1 era. it used to live under the `exp/eval` package, and was written by @aclement, IIRC) https://neugram.io is another interpreter (AST-eval based as well.)
Large GC pauses.
What are the highlights of the 1.10 release?
Is this an self-contained application ? or a library that I use in order to create an application? 
Can you even come up with a realistic scenario where choosing PHP for any sort of new project makes sense? Because I can't. Your "HTML plus a bit of code" example did not do it for me, because you can do that with a ton of other languages that are better designed. &gt; Whenever you find yourself making "always" or "never" statements that contradict what other people believe, it's usually because you have less understanding than others, not more. This makes me think you have never used PHP or you do not understand the ramifications of a broken type system. Did you read the article that I linked previously? It does a fine job explaining why it's a poor choice. In fact, I was just putzing around with a PHP online code sandbox just to see how much stupidity there still was. I was confused by literally the first thing I tried to do (echo a falsy value) which is illustrated in the example below: &lt;?php echo(true); // This produces 1 echo(false); // This doesn't produce anything, that's not confusing at all! /s Any developer worth their salt would be very concerned about such basic functionality acting in such a confusing way.
https://tip.golang.org/doc/go1.10
for me: - https://tip.golang.org/doc/go1.10#build - https://tip.golang.org/doc/go1.10#test this (build+test artefacts caching) is the game changer, speeding even more the run-edit-compile cycle. having `go vet` being run as part of the build has also caught a few interesting bugs. The `plugin` package has also gained some support for darwin.
&gt; large amount of JavaScript
For anyone running math operations heavily - I made math.Exp run 2.3ns faster :P https://github.com/golang/go/commit/d2f317218bf563121e80b36bb06a8ba46d040a20 
This is not entirely correct. A goroutine doesn't mean a new thread, there's a difference between concurrency and parallelism. Quoting [golang docs](https://golang.org/doc/effective_go.html#concurrency), &gt; They're called goroutines because the existing terms‚Äîthreads, coroutines, processes, and so on‚Äîconvey inaccurate connotations. &gt; A goroutine has a simple model: it is a function executing concurrently with other goroutines in the same address space. It is lightweight, costing little more than the allocation of stack space. And the stacks start small, so they are cheap, and grow by allocating (and freeing) heap storage as required. &gt; &gt; Goroutines are multiplexed onto multiple OS threads so if one should block, such as while waiting for I/O, others continue to run. &gt; Their design hides many of the complexities of thread creation and management. 
Good article, thanks for sharing! Very helpful in understanding Go concurrency for someone with web development background, like me. 
Sure bro. A developer who knows PHP needs to make a new site. Done.
Love the smell of deploying on a Friday
You can also see the frontend [here](pigmice.ga) and the source at https://github.com/pigmice2733/scouting-frontend
Not asking for an ETA, but are there any updates on Go 2.0 since it was announced?
&gt; The Fields, FieldsFunc, Split, and SplitAfter functions have always returned subslices of their inputs. Go 1.10 changes each returned subslice to have capacity equal to its length, so that appending to one cannot overwrite adjacent data in the original input. Nice, this has always caught people by surprise.
&gt; The go test command now caches test results This is big for us - some of our projects have large test suites. Very excited to see what improvements come of it.
Incoming brew update and upgrade, wohooo
Every release has someone gifting gold :thinking: But seriously, excited to play with 1.10 this weekend :) 
Is there any easy way to update on Windows or do I just install again?
&gt; Recently I found a client that needed to convert a list of txt files into csv - and he wanted the solution to be written in Go In what cartoon universe does this "client" exist? Sounds real zany.
We saw improvements from 14 minutes Travis times go to 6 minutes with the release candidate. 
I've been eagerly waiting for this! Way back in September I wanted to write a package built on the `flag` package, but it was missing some functionality I needed. I [submitted an issue](https://github.com/golang/go/issues/21888), the proposal was accepted, and someone implemented the feature! Now I can post my project publicly. Really neat to see the open-source process in action. :)
[removed]
Can only comments get gold?
I found him on a freelancing website. It wasn't a big buck, but took me about an hour in total so it was worth it.
yeah - a major release on a Friday takes big brass balls but I guess it's also a testament to the solid design, testing and release processes the Go devs follow
Sweet. Keep up the awesome work guys. 
You make the unfounded assumption that knowing PHP will make your development efforts more efficient over the course of development than using something actually sane. I guess we'll have to agree to disagree since you're not interested in addressing my points.
it is more self-contained application ofc there are things you have to implement based on what you actually need it to do
Man, you hate admitting you're wrong.
You know what this mean, people? Friday afternoon prod deployment!!! /s
THANK ROB FOR BETTER AVX SUPPORT
Why are all these random comments gilded? 1.10 must be exciting the hell out of someone.
[removed]
Some anonymous person does this with every "new go version" post. :D
Why everyone has got gold?
Good point, I know I'll be tinkering with it over the weekend 
I've never seen a gilded post with only downvotes lol
not everyone
&gt; Happy Friday, happy weekend! Today the Go team is happy to announce the release of Go 1.10. You can get it from the download page ü§îü§î &gt; Happy Friday, happy weekend! Today the Go team is happy to announce the release of Go 1.10. You can **go** get it from the download pag üôÇ
I really wish all of that could get combined with `context`, somehow. It'd be really cool for arbitrary io.Reader/Writer/Copy stuff to be cancelled if possible, but those interfaces are absolutely going to have to remain the same. For now, at least for File, I'm sure you could do `context.Deadline()` and then call those new functions like stuff in `net` does. Hopefully, context finds its way into the core language somehow...
Cant wait for weekend!
Damn. I just updated to Go 1.9.4
I hear Reddit regrets dumping Common Lisp and is now looking at migrating to Go. 
For Windows just install again. It'll ask if you want to just install or also remove the old version.
I want to try.üòÅüòÅüòÅ
Awesome, this is great news!
&gt; Edit: what's causing this gilding madness? For some reason this is common in Go release announcements. Dunno why or who's doing it either.
/r/negativewithgold
I created a working example of how to retrieve results with a join for you: https://github.com/pdk/godbex There are actually many (many) ways to deal with this, but this example uses only the standard library. You can create a struct type that matches the results you expect from your query. If you're going to do an outer join, rather than inner, you'll need to make sure all the types of the outer join columns are nullable, and handle them appropriately. Hope this helps.
wow someone's got a lot of gold to throw around
Yay, math.Round
How long should I wait before using this in production? I'm assuming there will be some minor patches in the first few weeks(?) Or was all this hashed out during release candidates?
Clearly sometime likes making Reddit rich :p
I love how easy it is to install Go! $ go version go version go1.9 linux/amd64 $ sha256sum go1.10.linux-amd64.tar.gz b5a64335f1490277b585832d1f6c7f8c6c11206cba5cd3f771dcb87b98ad1a33 go1.10.linux-amd64.tar.gz $ sudo mv /usr/local/go /usr/local/go1.9 $ sudo tar -C /usr/local -xf go1.10.linux-amd64.tar.gz $ go version go version go1.10 linux/amd64 
go test caching yessss
From what I've seen it's mostly a collection of generics-weenies whining.
Maybe
There is support for external lib, so whatever you have there compiled and prepared can work. Too much work to support and include even assembler instruction, not to mention OpenCL, so probably that will not happen. Only C code.
The benefits of static compilation! 
&gt; I chose to use the term "multithreading" in the title because, It would be like calling structs classes because they can have methods. It is fundamentally wrong and the fact that Go spec does not use these words is important. Go routines aren't threads.
It looks like your racing examples are leaking the unsuccessful goroutines. You could increase the channel size to fix that.
wow! first gold ever!
Sure, why not („Å•ÔΩ°‚óï‚Äø‚Äø‚óïÔΩ°)„Å• ƒ°ÃµÃñÃ£ÕÇÃåÃéÃáÃÉÃÄÕäÃàÕÇÃäÃΩÃÅ∆°Ã∑Ã°Ã®Ã°Ã®Ã¢Ã®Ã°ÃõÕñÕâÕìÕéÃ±ÕïÃüÃüÕáÃ±ÃùÃ™ÕöÃ´Ã≥ÃØÃùÕñÃ©ÕéÃôÃØÃñÃ≥Ã∫ÕñÃπÃùÃüÃπÃüÃÆÃùÃπÕàÃóÃüÃ∞ÃûÃ§ÃØÕçÃ™ÃûÃ©ÃØÃ≠Ã†Ã´ÃúÃ≠Ã†ÃÆÃ™ÃûÃûÃ∫Ã©Ã±ÃúÕöÃªÕìÕáÃ±Ã†Ã±Ã†ÃôÕéÃùÕöÃ≥ÃÑÃìÃíÃìÕÇÕõÃçÃîÃàÃÅÃÇÃìÃÉÕõÃæÕãÃäÃÜÃîÃíÃΩÃÖÃèÕíÃÅÕÇÃàÃÅÃÄÃÉÃîÕõÃçÕåÃøÕõÕãÃÅÃÑÃáÃéÕÇÃÅÃêÃêÃëÃìÕãÕõÃëÃÄÃêÕåÃêÃÑÕåÃäÃâÃÄÃêÕåÃãÃÅÃèÃåÃèÃíÃæÃêÕäÕåÃìÕÇÃΩÃæÃÉÃÜÃÉÃïÃöÃöÃöÕòÕúÕùÕùÕùÕùÕùÕùÕùÕùÕùÕùÕùÕùlÃµÃ®ÃßÃ¢ÃßÃßÃ°ÃõÃõÃõÃóÕìÕâÃ±ÃñÃØÃ≠ÃòÃ™ÃªÃòÃ¶Ã†Ã±ÃòÕïÃûÃºÃ£ÃùÃòÃúÃ¨ÃûÕâÃ´ÕìÃúÃ¶ÃñÃ§ÕáÃ´Ã¨Ã¨ÃúÃôÃúÃùÕâÕÇÃøÕÇÃàÃÅÕõÃÄÕóÕõÃèÃÑÃåÃΩÃìÃçÕåÃÇÃêÃíÃΩÕíÃèÃÅÕåÃàÃÅÃÜÃìÕêÃàÃÇÃÖÃåÃìÃéÕóÃáÕÇÃçÕãÃêÃøÃéÕÇÃéÃÜÃîÃìÃâÕãÃÜÃãÃîÃîÕíÕóÃêÕóÃæÕÜÃΩÃãÃÅÕÇÃÅÃÅÃíÕõÃîÃÑÃÅÕõÃàÕåÃÅÃãÃìÃÖÃëÕãÃâÃéÕäÃàÃîÃÅÃÄÕêÃçÃÉÃøÃêÃáÃøÕóÃøÃÜÃÅÃãÃÅÃèÕëÃëÃΩÃãÃïÕòÕòÃöÕòÃöÃöÃöÃöÃïÕúÕùÕ†ÕùÕùÕ†Õ†Õù·∏ëÃ∑Ã¢ÃßÃ°Ã°Ã®ÃõÕàÃØÃ≥Ã§Ã∞ÕñÃ¶Ã≤Ã¨Ã•ÕïÃüÃºÕáÃúÃ´ÃùÃ¨ÕéÃØÃ©ÃπÃûÃ∞Ã∫ÕôÃ§Ã≥ÃôÃÆÕâÃ≤ÃºÕàÕîÃùÃªÃ∞ÃºÃ™ÕâÃùÕôÕïÃÆÕáÕïÃ§Ã•ÕñÃÆÕöÕéÃùÃóÕéÕïÃìÃΩÕëÃäÃÑÃìÃÄÃåÕäÃÜÃÅÕÜÕíÕõÃÇÃîÃΩÕÜÃàÃÅÃÑÕíÕãÃÑÕäÕíÃàÃÅÃíÃÉÃìÃìÃøÃçÃëÃàÃÅÕêÃìÃëÃøÕõÃÇÃçÃîÃáÕóÃïÃöÕùÕùÕùÕùÕùÕùÕùÕÖ
Besides stretch-backports, what's the recommended way of using newer Go on Debian?
Download the zip binaries, put them into /usr/local/go (or wherever else you want), add that location/bin to your PATH, add $HOME/go/bin to PATH (assuming that $HOME/go is where your GOPATH is), and enjoy Go.
It's showering gold.
but it is a good comment.
What is it with all the gold jerk circle going on?
Super excited to see how the new caching and build times work out
If it is asynchronous it returns a channel that sends the value it it is complete. This is short just in the example. How would you do that? If you would copy data to multiple buffers you can do it all at the same time and than check the errors. var errChans []chan error for _, data := range datas { errChans = append(errChans, buf.CopyFloat32(data)) } for _, errCh := range errChans { if err := &lt;- errCh; err != nil { log.Fatalln(err) } }
If you want to have efficiency, you must have a low-level approach to the GPU. But if you want conveniency of usage you must sometimes give up on efficiency. I'll just try to build an high-level abstraction on devices, buffers and kernels. So the platforms, contexts and command queues are all wrapped up in the *Device* struct. *Buffer* is also wrapping the command queue and events. The *Copy* functions spin up a goroutine that waits on the event to complete the write and then sends the error value (or *nil*) trough the channel. Also the *Kernel* is a function that calls the appropriate *cl_kernel*. Calling the kernel is just enqueuing the task to the command queue, so it is also asyc and that also creates a goroutine that waits for the kernel to complete. It's just a little library, and not everything is covered. But I wanted already to show it :) Now i'm working on creating a buffer from *image.Image*.
thanks :)
Is there much benefit to using strings.Builder over bytes.Buffer? They seem functionality equivalent and pretty much the same under the hood unless I'm missing something.
Thank you Go Team! Especially Ian Lance Taylor (the creator of gccgo and one of the top-contributors to Go). Your work improving the interface between Go and C is really important! The new CGo features in 1.10 is also a good step forward. Eventually, Go won't feel so much like programming in a bubble.
What better options there were instead of regex?
Take that, Javascript devs!
Nice, I will be testing some windows dll creation over the weekend.
The difference is - `bytes.Buffer.String` allocate a completely new object, where Builder does not. Those you can decrease allocation count, used memory and GC pressure. 
`grep` that is indexed for a whole subdir but with fuzzy logic and faster than https://stackoverflow.com/questions/7734596/grep-but-indexable
As a small exercise try implementing saving output of `xargs -P` to an SQL-base. Make sure stdout and stderr of the different jobs do not mix.
Do it now? we've been canarying the RCs for a week with no issues.
how can I use it? I get an error: &gt; ../github.com/microo8/blackcl/blackcl.go:80:12: could not determine kind of name for C.clCreateCommandQueueWithProperties
Excited by the test updates, although mine are usually very unit test driven and minimal IO wise, it's the kind of philosophy I love about go. Make good practice a part of the language release and update cycle to make it easy to implement good testing and choice standards.
Alternative [interval](https://github.com/cznic/interval) package.
Huh, this library only works on Go 1.10+?
Thanks guys, great work! Been waiting for ‚ÄòDisallowUnknownFields‚Äô in JSON decoding for a while :)
Somewhere an orange president is getting excited
[Related issue](https://github.com/golang/go/issues/21888). Basically - it uses name of the flag set to construct command hierarchy. 
Im also glad it made it in, nice job man!
A precise technical lexicon is vital for proper communication, "easier" maybe, but speaking about technology in precise terms must take precedence.
I like that your api seems pretty simple to use, that is a good start! 
Glad to see I‚Äôm not the only one that releases on Fridays! :D
[removed]
But that also means you won't receive any (security) updates without manual intervention...
You run your codes test-suite with the new release, you build your code with it your CI process, you deploy to staging, you monitor it, you hammer it, then you promote to production once you're happy it performs well. Once you've deployed your new binaries to production you rely upon your performance/metrics/monitoring to catch problems. Right? You don't just randomly build a binary on a developers laptop, `scp` it to a host, and restart the service. 
Hi guys, I love Go!!!
Go team sharing the love
Hi Dazzford, The title may be slightly ambiguous so apologies, this is a tutorial that shows how you can build a RESTful API that utilizes and ORM to communicate with a database. Hopefully this clears things up!
Where does Travis cache the results?
Kudos to the whole Go team!!! I'm soon starting working on my side project's microservice, powered by Go and Gin! Exciting times =)
If, before explaining how to boil a pot of tea, someone first had to learn about atomic particles and how electricity functions, we wouldn't learn much of anything
What editor is that
Visual Studio Code! definitely worth a look if you havent seen it!
Looks great!
Like the go install update. Makes my CI installs of dep more streamlined. Yay!
You know what I spend way more time doing than typing error handling code? Figuring out the processes and structures needed to accomplish my goals. Everything is a trade-off.
I used to agree with you, when I first started writing Go, but over time, I've come to see the brilliance of the way this is done. Here's a good post about why [error handling in Go is elegant](https://davidnix.io/post/error-handling-in-go/). The thing I like about it the most is that it makes it clear exactly what went wrong. In your first example, unless `A()`, `B(x)` and `C(x)` return different exceptions, it's not immediately clear which one threw an exception. In Go, I'm not only given the opportunity but _encouraged_ to handle each error as its own. I can handle each error specifically. I know it's repetitive, and I know it looks clunky, and I know that in a well written program like 2/3rds of your code is basically checking for errors, but trust me... in the long run, that's a good thing. I hear you, though. Keep working through it. :) 
Of course.
Cool, thanks :)
I like errors as values over exception handling semantics but I think they're much better when encoded into the type system with something like result/either, which go's type system can't support unfortunately. Also much better when you can use map to operate over error types (which go also can't really do). Basically: the value based approach to error handling is good but go really needs to offer some better tools for dealing with it. 
Don't worry, you'll get used to it. It's fine.
Take a look at https://github.com/hashicorp/go-multierror/ it‚Äôs a battle tested solution
It's targetted at beginner to intermediate go programmers. Let me know if you need any additional support, happy to provide it!
Do you have any good videos or resources to learn go 
That's great news! There were sensible performance improvements in 1.10rc versions, I'm glad to be able to use it for production code.
It doesn't in-between builds (at least not by default, but that might be possible to make work. However, if you test multiple packages then those packages their dependencies are only compiled once. This should be possible with previous go versions if you use the correct compile options as well, but I couldn't get it to work with coverage enabled. Now it just works automatically, which I really like. 
I wouldn't call either variation 'brilliant'. It's just two different things, neither of them very interesting. It is what it is, and the go variation is slightly more boring (which is a good thing imo!).
Given a desired concurrency of N -- assuming N remains static through the lift of the process -- your setup sounds fine... Make a chan for submitting processes... launch one goroutine to listen on that channel which loops N times filling a []chan then waits on the process submission channel. loop over each chan in the []chan and submit a copy or a pointer of/to the original value. You could easily wrap this into a struct with a rwmutex and the ability to resize the []chan with a stop the world event in varying ranges of complexity as necessary for the safety of your programming (a long running process probably wants very precise cleanup... whereas a cli tool which is invoked for one task and then exists can *probably* not worry about cleaning up orphaned goroutines and leave it for the exiting of the process...)
You're right, but your error managing code is pretty poor. Your code should actually look more like f, err := os.Open(filename) if err != nil { return fmt.Errorf("can't open %v: %v", filename, err) } bytes, err := ioutil.ReadAll(f) if err != nil { return fmt.Errorf("can't load %v's content: %v", filename, err) } nb, err := strconv.Atoi(string(bytes)) if err != nil { log.Printf("warning: can't convert value %q from file %v: %v, using default value instead", string(bytes), filename, err) nb = defaultValue } // do stuff return nil } Each error is different and is dealt with differently. Some make the whole function fail, others force you to do things differently. Now how do you write *that* with your `try/catch` mechanism? Try it, and you won't find it any less noisy or distracting.
I'll just leave [this](https://www.youtube.com/watch?v=1B71SL6Y0kA) here.
For the beginners, there's some nice improvements to the debugging experience](https://golang.org/doc/diagnostics.html).
You‚Äôre the only top level comment not guilded ‚Äî are you behind all this?
Thanks I'll clean it or
 what is the price of a gold?
Prior to Python, Reddit was in Common Lisp. 
The general preferences are for values over pointers. Direct field access over accessor methods. Structs over interfaces. Obviously use whatever method is so necessary for the task at hand. 
There are ways around it. This is a good read: https://mijailovic.net/2017/05/09/error-handling-patterns-in-go/, and there are other blog posts about, but I can't find them right now.
This argument is often repeated. But apparently there are cases where a single return value is silently discarded. Isn't that dangerous?
Go style is different and it's hard to see its benefits at first. The downsides are immediately visible. As you use Go more, it often happens that the benefits of the approach start to grow on you. I highly recommend this post https://medium.com/@shazow/code-boilerplate-is-it-always-bad-934827efcfc7 on the topic. You might not agree right away, but it's something to be mindful about.
by one of the many ways your question can be interpreted, i'd say: yes
I'd imagine that there are linters which will do this.
Very enjoyable talk, couldn't help but think to myself "wait a minute am I getting a monad tutorial here" Not sure if I'd ever write code in that style though, your types will probably get incredibly complicated and you'll need to test that you handle the errors appropriately between each method call as you're effectively introducing temporal coupling with a "global" error var in your type. Very entertaining talk though and did make me think a bit 
Reading up on it now, I can see why it could be considered as such. Specifically looking at https://news.ycombinator.com/item?id=12479370 You don't happen to have any other resources I can look at for personal reading?
Small nit really, but the first example you wrote is probably something to be avoided if you have a buffer since it allocates probably 13-15 times. The second one that uses append should probably be avoided too because it's less usable than calls to the buffer methods directly. Here is how I would write your post using bytes.Buffer, the below should only allocate exactly twice. var buf bytes.Buffer for i, p := range []int{2, 3, 5, 7, 11, 13} { buf.WriteString(strconv.Itoa(i + 1)) buf.WriteByte(':') buf.WriteString(strconv.Itoa(p)) buf.WriteString(", ") } buf.Truncate(buf.Len() - 2) One benefit to bytes.Buffer over strings.Builder is for repeated calls with different inputs you can produce a string with a single allocation. For example if you changed the above to Reset an existing bytes.Buffer you can amortize to 1 allocation per call, the cost to produce a backing for the string.
what do you recommend currently?
You already have to maintain, upgrade and vet your dependencies. The only change is if you have a reproducible build or not. 
Blockchain, blockchain, blockchain. Add some ML and AI layers for all your big data in docker containers.
The example doesn't really explain it properly. You can preallocate bytes.Buffer as well (https://golang.org/pkg/bytes/#NewBuffer), e.g.: b := bytes.NewBuffer(make([]byte, 0, 32)) But it's true that every time you call b.String() a new string is allocated and populated from the contents of the internal []byte buffer. New Builder type uses unsafe trickery to overcome this problem, see source code: https://golang.org/src/strings/builder.go However, it will still allocate new chunks of memory just like bytes.Buffer does when you're appending stuff. The main purpose of this new type is to avoid last (and the most expensive) allocation and copy when you use bytes.Buffer just for the sake of building a string. Especially important for large strings (multiple megabytes). Most people won't notice any difference.
I'm not 100% sure what you are asking, but maybe this example will help: https://play.golang.org/p/_l7_zpWd-Sz
I'm not 100% sure what you are asking, but maybe this example will help: https://play.golang.org/p/_l7_zpWd-Sz
I like it, I did something similar a while back since every single of my programs uses a hierarchical/subcommand based interface but I didn't expand on it since the functionality that it provides is enough for me. I think the way they both work is similar, as far as I can see. https://github.com/boreq/guinea/
The code is a work in progress and I understand that cryptocurrency can be a polarizing topic at times. So with that being said, I would like to ask that we keep the focus of discussions on the code itself as much as possible. &amp;nbsp; We encourage you to follow the code as it evolves on GitHub. We welcome thoughtful and constructive discussion about this project as it grows.
[removed]
yes and no you can do `b := (a)` but its just a pointer to the same array. or : b: = make([]byte, len(a)) copy(b,a) // or a,b i forget...!? 
Thanks for your dedication and love you bring to this subreddit!
Those are slices
Lol, rpmbuild still needed though... I never had issues with it, what problems have you experienced?
You mean Go 1.11?
Yes, you just run "go tool asm filename.s" and it'll output filename.o. But note that "go build" automatically assembles things with the .s extension, so you can just define the prototypes in Go and write all your real code in assembly if you wanted.
Yeah but does that object file have the go runtime do you know? 
Admit it, you said it for the gold ;) - kidding thanks, it's a pleasure posting and reading here.
As someone that uses GORM a lot for DB queries in Go, thank you so much! This looks awesome.
The go runtime comes from the linking step (if you're doing things manually, when you explicitly call `go link`, otherwise `go build` is effectively a wrapper around `go tool compile`, `go tool asm`, `go tool pack`, and `go tool link`). The object file won't have the runtime, it'll just have the code from the .s file. Are you trying to make sure you *do* or that you *don't* have the Go runtime linked? If you have a file with a `.s` extension in a package main and define your asm prototypes in Go, it'll be linked by `go build`. If you're trying to avoid linking it, the best I've been able to do is [this](https://github.com/driusan/noruntime) since `go tool link` doesn't have any "don't link the runtime" flag.
Oh what's it called 
I want to make sure it doesn't have it. So I could use it just like nasm or gas
The timing on this is awesome! I currently use fpm for building rpms and was going to re-work some build processes to use multi-stage docker builds.. but nfpm would make everything simpler. With a multi stage build I could at least have a go image for building and an fpm image for packaging, but with nfpm I wouldn't need any of that.
The above link is the closest I've been able to get to that. The object files generated by Go aren't ELF object files, so they need to be linked with `go tool link` and can't be directly used by your system linker which doesn't know anything about the Go object format. `go tool link` always links runtime, and the link is a fake runtime that tries to strip out as much as it can while still compiling a valid executable.
Ah! this makes it even better. I remember looking at goreleaser for building rpms, but the fact that you still needed fpm meant that it didn't really make anything easier for me.. if this means goreleaser can natively build rpms now that's perfect.
Ah damn ok that makes sense. Thanks
Arrays are values so assignment statement creates a new array with copied contents. As for slices - you could just do that: var b []byte b = append(b, a...) It will actually be more efficient, since runtime does have to initialize new slice with zero's.
Who use GOM here in production? Tell us about your experience with it.
Well for one thing, it's a joke to expect Go, a GCed langauge with limited control over memory layouts, to beat highly optimized C++ when it comes to memory usage.
Not true, arrays are not reference items. This is true for SLICES, not arrays
Hi, the first thing I can suggest after looking at this code is to run Go lint and fix every single issue. Next remove all dead and commented code. I also see lots of potential for race conditions scattered about (i.e. global pkg) but I don‚Äôt see any benchmarks with RunParallel or other hints that testing is done with -race yet. Investing here early on to expose any big design flaws that will require large refactoring may be well worth it. That will clean things up a lot making the code a bit more welcoming for serious review. Good luck with your project.
What version of OpenCL you have on your system?
That's a great Go rule and I want to have an idiomatic Go API, but if you want a non-blocking call, you must return something from what you can know, that the action was completed. Like some promise or event or something. I didn't want to introduce a new struct to the API. KISS :)
I use a checkError function with the first argument being the error, the second argument an int on the severity (fatal, log, etc) and it works great. I love Go‚Äôs error handling ‚Äî it‚Äôs simple and concise 
Have a look at https://github.com/skydive-project/skydive Mentioned in the last Go Time podcast (https://changelog.com/gotime/66)
Thank you on behalf of the team for taking the time to review this and provide your input. It's still a work in progress between 3 developers that is pre-alpha and changes several times a day on their end which may explain a lot of the comments and bits of dead code that are being actively worked on. Proper golong workflow will be followed and observed. Some of the comments/code are still there to keep them aware of particular issues and components in the code. They have responded to let me know that this will definitely be cleaned up to make the code more welcoming for review. &amp;nbsp; All of your suggestions have been noted by the development team and will be kept in mind moving forward. Thank you again from the Dero team, we honestly appreciate you and the time you took to do this.
Check [OWASP](https://www.owasp.org/index.php/OWASP_Secure_Headers_Project#tab=Headers) too.
Yeah, somebody made an issue about making `io.Reader` type Reader interface{ Read(ctx context.Context, p []byte) (n int, err error) } in Go 2, but that got nixed because it'd be terribly annoying and a bit overkill for most reads. They mentioned making `context` a thing that's integrated with the language, but nothing concrete.
Mind telling me what application you were using to send the http requests?
The test caching is the big one for us in CI!
This prompted me to look at goreleaser. Awesome! I just set up my gofileseq project to release its two binaries with it. 
If you need some headers for your own in-house tooling or something, I'd opt for a prefixed version of the returned headers. As the X- prefix has been adopted in production software, I would suggest to avoid this prefix if you can, and using some sort of acronym for your project. For example, if you were developing the `ProductHunt` website, outputting headers like `PH-Debug-...` and `PH-Timestamp`, `PH-Request-ID` and so on would create a generic grouping rule that indentifies your custom headers.
The worst part is the `Itoa` calls in this example. Using strconv.AppendInt with a small scratch buffer should be a lot better on allocations.
I wonder how useful `strict-transport-security` is for a non-public site/app (particularly if you're not going to submit to HSTS, which itself seems ill-conceived).
That's not quite right. In the first example, the first writing goroutine succeeds as you say. The second one, however, is blocked waiting to send, as unbuffered channels are entirely synchronous - sends only succeed and unblock when there is a waiting receiver *for that send*. Here's an example that shows that the "losers" never complete: https://play.golang.org/p/zIMgBlagCqs You can deal with it in several ways, some of which you mention. The most general is to have a pair of channels, one to write success to and one to indicate that the requestor is satisfied. Using that the providers can select on both channels, writing to success and reading from done, and the requestor can close done once it is satisfied. This way you can avoid needing to know the magic number. Here is the fixed code: https://play.golang.org/p/C0UEJOSX0_9 By the way, make sure that you do use a second channel. If you use only one, you can't close it without panic'ing the remaining writers. Example: https://play.golang.org/p/Zn-UjSmhdPN I understand that this is a tutorial. However, understanding the blocking nature of channels is very vital to their correct use. As a suggestion, it might be worth just a short follow-up in a second article that builds on that one to address how to handle this issue.
The original example was specifically about the cases where error handling is the same (even though errors are different). If all you are doing is log the underlying error, there is no need for all this. Also, why not use the default value in other cases? that's confusing (the code may also fail to close the open file, not sure). Now, if you need to go to that level of details, you have the whole language to help you (functions, etc.) to keep the complexity under control. You can even write error codes in a language with exceptions. I don't really understand the point of this example.
Can you elaborate more on what distinction you're drawing between what you're considering an anti-pattern and what you're calling a "networking API gateway"? 
You should look into service meshes like envoy stand control planes like istio. A sidecar topology provides the decoupling of the data plane and business logic without a single point of failure like the API gateway
It is not if designed correctly &gt; 1. Multiple deployments will be required now to deploy a single feature - a change in the real service + a change to the gateway which approaches it Why? The API gateway should not require a change if you change a backend service, its routing logic should be configurable and ideally based on automatic service discovery. A new version of your backend service gets deployed, then it just routes traffic to the new instances and away from the old ones. If you need to do a deploy to both the gateway and your backend server regularly you have failed to separate the concerns of each service. &gt; 2. The gateway is a single point of failure No it's not, each service should not be a single instance or VM - it should be a cluster of instances that can autoscale as demand meets and in the case of failure of one instance another can be brought in to replace it. &gt; 3. The gateway is actually a smart pipe which knows a lot of things about many services And? Is this a problem? It is not the only, or best pattern but I would not consider it an anti-pattern. Like any pattern, it has its strengths and weaknesses and can be implemented badly.
Hmm, so you're sorta like all the best parts of xmr, eng and eth? How does your tx/s and gas price compare to those other ones?
Yes. Networking API gateway is a generic hardware/service that does HTTP layer enrichment (SSL termination, routing). It never does custom logic and orchestration. AWS API gateway &amp; nginx are an example for networking gateway
I've had a good experience with it. With any ORM I think you find that it's not perfect enough to only use its calls and never make raw queries, but GORM is really nice for that since I could make a raw query using gorm.Raw() and follow that with one of the built-in commands. Most of the time though, I'm making the smallest effort possible and letting my struct tags take care of all the effort; which is how it should be. I query using where, update, delete, etc, so I barely have to think about my queries most of the time which is great. 
Deployments - if the products microservice GET: /products now requires additional param then the gateway will need to be adjusted as well Single point of failure - what if the *service is down and not the container/machine? e.g. someone had deployed a bad version to api gateway and it's not not functioning, now the *entire system is down Smart pipe - is simply against the core idea of microservice, splitting our brain across many components and not *centralizing 
No idea, depends on you! 
PRs change and become more complicated. Robert, you and I, we've been through exactly this before.
&gt; Deployments - if the products microservice GET: /products now requires additional param then the gateway will need to be adjusted as well Why? the gateway should forward everything through that it does not directly have to deal with (ie it might strip auth info or add user info). Then the backend can deal with it however it wants and the gateway does not need to change. The gateway should only deal with what it needs to and forward everything else on to the backend - if it is decoding the params on ever request it may as well deal with the request. This is an example where you have not separated the concerns of each service - the gateway only needs to know how to auth and forward requests not how to decode them. &gt; Single point of failure - what if the *service is down and not the container/machine? e.g. someone had deployed a bad version to api gateway and it's not not functioning, now the *entire system is down This is what unit testing, a ci pipeline are there to reduce. Then you have canary deployments where you only update some of the containers to see if they work before rolling it out to everything. And you should have the ability to roll back quickly in the event that everything does screw up. &gt; Smart pipe - is simply against the core idea of microservice, splitting our brain across many components and not *centralizing It is not against the idea of microservices where each service deals with one thing - the gateway deals with traffic ingestion and routing. Just because it talks to a lot more servers than everything else does not make it a monolith service. --- An API gateway does not, in my opinion, violate any of the rules of microservices. You also do not have to only use micro-services for everything, sometimes the best solutions to problems involve using ideas from multiple different patterns. I would say trying to use microservers for absolutely everything is an anti-pattern. Something it is great at while others it is less great at, you should understand the problems it is trying to solve and why. It is also a fuzzy team, what exactly makes a service a micro service? You could create a service to deal with each different parameter in an HTTP request, but that would be stupid. Really it is just a blurry scaly from monoliths to the tiniest of microservices with no real hard line as to when something goes from being a monolith to a normal service to a microservice. So is an API gateway a microservice? I think so, but maybe it is not - does it matter? It solves a problem and if it works for you then use it, if not then don't. It is definitely not inherently an anti-pattern.
Go wins against Java in all except these 3 benchmarks. Great to see Go narrowing the gap with every release.
&gt; AWS API gateway &amp; nginx are an example for networking gateway nginx can serve as an API gateway. And AWS API gateway is for sure (hehe) an API gateway. 
Hi there, great post. We wrote a small container to support hot-reloading for development https://github.com/dkfbasel/hot-reload.
Hi everyone, We recently deployed our new api gateway which takes the form of a graphql server. This is awesome for the frontend developers, as it is super easy to select the data you need from the backend. In addition the api is very easy to documents. The graphql server will perform some authentication steps and then fetch all required data from different micro services via grpc. All microservices are deployed in separate docker containers with an envoyproxy sidecar. To make it easy to orchestrate the whole thing, we wrote a small utility called Kolumbus https://github.com/dkfbasel/kolumbus that will watch all docker container and automatically create load balanced service clusters based on specific docker labels (very similar to Traefik). Additionally, for development, it is also possible to use an envoyproxy instance embedded in the kolumbus container to create a proxy with a vpn-tunnel to a remote cluster. With this setup, you can setup a remote testing cluster were all microservices are running and simply work on one service locally that will automatically connect to the remote services. Therefore it is no longer necessary to start all downstream microservices on your local machine for development. If the api-gateway is not a single point of failure as we can also run multiple instances of it, if required. 
How is Java able to be so fast with binary trees?
Okay so I guess the main takeaway is that you shouldn't compare this with Java but just compare the two versions of Go against each other.
I'd say you can still compare it. The way it is written now is how 99% of folks would solve it without premature optimizations. The Java GC/Allocator has a ton of maturity. It is still "better" (because it depends on what you value) but the key is the gap being closed. You also need to account for overall memory usage and such as well. Golang is already very very light but at the expense of a few benchmarks. It is also relatively young so seeing this progress is great.
Yeah, would be my first impulse too.. b := [2 + 20 + 1 + 20]byte{' ', ','} s := b[2:2] for i, p := range []int{2, 3, 5, 7, 11, 13} { s = strconv.AppendInt(s, int64(i)+1, 10) s = append(s, ':') s = strconv.AppendInt(s, int64(p), 10) buf.Write(s) s = b[:2] }
About as useful as SSL itself if the server is local only (useless). I'm not sure how useful that is if it's not attended to be used from a web browser but it certainly doesn't hurt to have it. If the domain/app is reachable from the internet, SSL + HSTS is simple to set up and it will make a good exercise. If you never submit the domain to the [HSTS preload list](https://hstspreload.org/) (this one is for Chrome) then only the very first request to your domain by the web browser is more vulnerable. Subsequent requests will be aware of your HSTS policy. Basically, the preload list is backed in the browser itself and makes it aware of the policy before making that first request to your domain.
Yeah, I've looked at memory usage differences and the lead Go has there is pretty astounding.
I wish they would just bail on the RE2 garbage already. For all the talk of Go being a language for getting work done instead of an academic experiment in language design, they went with an academic experiment in regular expression engine design that both supports less functionality *and* has horrible performance, all in the name of preventing hypothetical issues no one was complaining about in the first place.
That score is using cgo PCRE, not re2.
&gt; but trust me... Why? That linked article is very disingenuous - exceptions are vastly superior approach, but you can't describe it as such in 3 lines of code... "look, try{} catch{} looks more complicated than "if (err)...". No, it doesn't. Once you write code of any decent complexity, with components interacting in various ways, you'd realise that you can establish a rule that, say, propagates errors to the caller and you catch and deal with exceptions there. Meanwhile you can write layers of underlying code without checking for errors even once. You can do it because you're safe knowing that compiler will deal with all the clean up code that needs executing should exception happen. It's doable, and it's elegant, and it's type safe (in case of C++). 
Then why not use both engines just like the sort algorithm(quick sort by default and heap sort or other algorithm for the worst case) implemented in most lanuages std library?
The whole point of that rule of thumb was to not desire a "non-blocking call". Let the caller manage concurrency.
This post teaches to build a fast application with GO. Source - https://www.laitkor.com/services/golang-development-services
If you really wanted to avoid allocations for larger integers you don't need the additional complexity you have here, just use the buffers backing. You keep the flexible buffer API, allocation amortization if reusing, avoid the error prone slice manipulation and maintain readability. var buf bytes.Buffer for i, p := range []int{2, 3, 5, 7, 11, 13} { b := buf.Bytes()[buf.Len():] b = strconv.AppendInt(b, int64(i+1), 10) b = append(b, ':') b = strconv.AppendInt(b, int64(p), 10) buf.Write(b) buf.WriteString(", ") } buf.Truncate(buf.Len() - 2) return buf.String()
Nice. I'd love it if go fmt automatically did that. Minus one thing to bike shed about
What you have described, to me, is not a *gateway* it is a *monolithic application* with a fractured tree of dependent services - and yes I consider that an anti-pattern. It just combines all of the horrors of managing microservers with all of the horrors of monolithic applications. But you should call it what it is - a *monolithic application*. A gateway should be just that - a gateway into your infrastructure. It should not have business logic inside it and as soon as it does it is no longer a gateway, its an application. To me, a *dumb* gateway is one that forwards requests to a preconfigured set of backends, maybe deal with load balancing and backend failures - such as nginx, haproxy in their simplest forms. *Smart* gateways can also handle authentication and dynamic routing of requests, dropping requests, routing requests between different versions of backend but never business logic. 
If you're already familiar with programming and you're looking to build a deeper understanding if CS principles, then it should be fine. You should be able to treat solutions in other code bases like psudeocode and translate them easily to Go. You need Python, Java, or C# (or C++ if you're a sadist). If you're taking your first steps, then no. You need the largest most helpful community for that sort of things where first languages are common and the community is sympathetic. You will only get frustrated and angry at people who don't know how or don't want to deal with people asking rudimentary questions. You will no doubt need specific code examples to understand what you're trying to do and you won't find that in a relatively small community in a language where the vast majority are already very well experienced in others.
Yep, I already know how to code. I've coded some applications with Python (mostly for DS/ML related topics) but I want to learn about the foundations of Algorithms and Data Structures since I do not have educational background in this important topic. I thought that I could take advantage and learn two things at the same time: The core concepts of Algos &amp; DS + new programming language that seems very interesting. Thank you very much for your answer.
I think he's basically asking what the convention is for using a struct method `foo.Bar()` versus a standalone function `Bar(foo)`...
I my opinion if your purpose to learn algorithms and data structures then programming language not important this may be Go, Rust, Python or classic C or Pascal. Algorithms and DS better to learn in classic languages as C and Pascal, but Go is similar to C and so it may be good variant for you.
Awesome, also useful for non-Go projects. Thank you!
The Go GC is already far ahead on latency
Not to mention you can run tests across multiple platforms/distros with docker. https://github.com/adamdecaf/cert-manage/blob/master/linux_test.go
io.Writer API is smaller, so more flexible, by definition. If buf is a bytes.Buffer get the same allocation amortisation. Think the latter two are subjective. 
Totally agreed.
If you want to add a constraint that you need to copy to an io.Writer I would just say use a buffer in front of it. I see no advantages to your approach for reasons stated in prior post.
That's actually exactly what I was looking for.
Catastrophic backtracking is only an issue for me if I have reason to distrust the source of the regular expressions. I write regular expressions on a regular basis and the backtracking issue has only been an issue once that I can remember. 
This is on purpose.
Something not mentioned in the post is multi-stage builds where you compile the binary in stage one, then copy the binary into stage 2 and discard the rest to create a much slimmer container. https://docs.docker.com/develop/develop-images/multistage-build/#use-multi-stage-builds
Both redux and complement took a very small performance hit - I wonder why?
Ohh man, I hope Java will die soon. One can only dream.
Wow, incredible answer. That is actually a point. One of the greatest advantage of Python is its simplicity but at the 'cost' of hidding the complexity or how it really works inside. I started to learn A&amp;DS with Python 2 days ago and that was my concern. The base data structures for implementing other data structures are lists and, as you have commented, they hide some internal complexity that you may miss (for example popping the last element of a list in Python is O(1) but popping the first element is O(n) just because the built-in implementation of python lists works like that) I am happy to know that Go does not hide the complexity and therefore you actually learn the topics correctly. I will start doing the implementations in Go. Thank you for your answer! 
probably because this article is pretty old, before multistage was available. Article is from September 2016
Wait what? gofmt does that already. (echo; curl -s https://play.golang.org/p/HmnNoBf0p1z.go; echo)|gofmt 
comparing a language with bytecode on a vm to a statically compiled one seems meaningless to me. Go should be compared to similar languages with a GC like, I don't know, D?
Java is fine...
actually an api gateway is not an anti-pattern, but what you describe is a anti-pattern. but it's solved by something like https://github.com/zalando/tailor
Yeah, their generic stuff is still subpar (tacked on instead of developing Java with it in mind) but since Java 8 I can't complain, especially JavaFX is quite nice.
&gt; While it's silly to assume the programmer is the enemy I wouldn't say that. Distrust the programmer is something I can get fully behind, Rust does it with the borrow checker and it works great. People do mistakes, errors happen. Assuming that a human is 100% perfect all the time is wrong. If a machine can help with it I'm all in.
nice, let me know if you find any issues =D
nice, hope it works out well! \(and let me know if it don't hehe\)
&gt; Go got 15-20% faster in benchmark game with 1.10 Are you sure about your figures? Most tests remained the same except these three: | Benchmark Name | Go 1.9 Time | Go 1.9 Memory | Go 1.10 time | Go1.10 memory | |--------------------|-------------|---------------|--------------|---------------| | reverse-complement | 0.54sec | 132,404 | 0.63sec | 89,120 | | k-nucleotide | 14.98sec | 147,704 | 12.72sec | 148,012 | | binary-trees | 34.42sec | 268,188 | 28.80sec | 434,632 | Only *k-nucleotide* really sped up. *reverse-complement* became a bit slower (by 15%) but reduced its memory consumption. *binary-trees* became 20% percent faster at the cost of 60% increase of memory consumption. So, *reverse-complement* and *binary-tress* changes are rather the consequence of different memory allocation and GC setup than a improved optimization.
[removed]
To explain what's going on in benchmarks that Java wins. - k-nucleotide - Java solution seems crazily micro-optimized, in particular it doesn't use language specified map implementation but a special external implementation designed to be fast. Go on the other hand has a rather straightforward implementation. A better code on Go's side could make Go faster in benchmarks. - regex-redux - regex engine in Go is a joke in terms of performance, this pretty much only tests the performance of regex engine, it doesn't even matter how fast the language is otherwise, as PHP used to win in this benchmark (like seriously). - binary-trees - this is test of parallel allocation speed, it's really low in Go, also Java really has fastest allocation speeds - faster implementations just use [region-based memory allocation](https://en.wikipedia.org/wiki/Region-based_memory_management), because they really don't stand a chance against Java using regular allocation provided by a programming language
[removed]
&gt; You can do it because you're safe knowing that compiler will deal with all the clean up code that needs executing should exception happen. In C++? As long you use RAII and don't have any side effects - I'd hardly say it's totally safe. Certainly not from a junior engineer who doesn't know or understand your standards and conventions. Exceptions have a lot of problems too - firstly, they're a totally invisible pathway through your code that you constantly need to think about. You can't see where an exception might be expected, because there's no syntax for it. Error returns that are ignored are easily checked for, and you can also easily see what the code flow would be for them. Now, RAII is fantastic, and I wish that it existed in Go, but it's also a bit of a crutch that you have to remember to use and combine with things like scopeguard, which has probably gotten a lot better with lambdas. However, you've got defer in Go, and that's pretty good (and fairly equivalent to scopegoard). I actually think that defer is better than try/except/finally (just thinking about the Python implementation here) because the defer code happens before a return (visible or otherwise), unlike finally which can happen after a return statement (which breaks a general rule that you only need to know about code up to a certain point to see what's going to happen). And if I'm honest, having worked on a large code-base of Python, people just don't bother thinking about the index/key errors, or other exceptions a large amount of the time. Sometimes, if you're lucky, it gets caught in unit tests, or very shortly after it starts turning up in Sentry. "Out of sight is out of mind" totally applies to exceptions. Exceptions have some nice supporting systems in some languages, but to ignore their downsides is sort of ... disingenuous? 
Aren't there UTF-16 routines you can call? 
Calling C from Go is indeed very slow. Turning off the memory checks might help a bit but there's still a lot of instructions there. Calling Go from C is fast though. 
Everything you say is correct. However, why is it that **omitting** a feature such as backtracing has such a huge performance cost? And if the horrible RE2 performance is unrelated to the lack of backtracing, then why does everybody bring up backtracing when the performance discussion come up? I'm not an expert here, but I think the missing features are red herrings. There's no obvious reason why eliminating some functionality should make the engineer inherently slow. Rather, I believe nobody has bothered to optimize the engine, that complaints about how horrible the performance is are justified, and that it is common for defenders to distract from this by making arguments about eliminating features for safety.
As far as I know, it's not easy to find out if a particular regex suffers from catastrophic backtracking without entering the catastrophic backtracking. At that point, it's too late.
The Go regex implementation compiles and then simulates an NFA instead of doing backtracking. It's a completely different algorithm.
Part of me thinks BMG should have with/without warmup numbers but another part of me doesn't understand why we have JITs so *shrug* Yes I'm aware of all the standard reasons people say JITs are useful, no need to reiterate. 
It's actually hotspot, not the JIT (although the first couldn't exist without the second). Maybe you'd prefer PGO for languages that don't run in a VM - definitely underrated in the gcc / llvm world.
\&gt; The gateway is actually a smart pipe which knows a lot of things about many services The client may as well know a lot of things about many services.
Please [provide your measurements](https://benchmarksgame.alioth.debian.org/sometimes-people-just-make-up-stuff.html#jvm-startup-time) and explain how you made the timings. 
But only a shallow copy i.e. that doesn't work with nested arrays.
Hotspot is technically the name of the JVM released by Oracle, but it refers to the JVM's ability to do PGO on the fly. When Java code is faster than C/C++ code (yes, it sometimes happens!) it's usually the JVM's on-the-fly PGO that's allowing this to happen. To simplify, the JVM always starts in a much slower interpreted mode. This interpreted mode runs instrumented code that records all kinds of performance characteristics of the running code. The JVM then uses this information to make guesses that a compiler couldn't make about how it can further optimize running code. It then re-compiles the program code on-the-fly (or Just In Time) with these new performance optimizations. PGO for llvm / gcc is essentially the same thing, but it currently needs to be done manually by the user as an additional step since there's no VM sitting between the program code and the machine code than can do this for you. Some additional bits about this: https://wiki.openjdk.java.net/display/HotSpot/PerformanceTechniques http://cliffc.org/blog/2018/02/03/under-the-hood-of-the-jvm/ 
Beware, in several cases it's just the default JVM allocation and does not reflect what the differences will be like when the app actually needs to use memory. 
I'm not sure why you're not just completely deferring that to `ssh`. The user can specify to your tool/API what username to use or configure it in `~/.ssh/config`. It shouldn't matter to you. If a username is specified, generate the command line with it. If not, don't.
Without looking at the regex, I don't know if that's why they used cgo. It might have been that the benchmark required backtracking.
You should write a bit more about what it is in the readme. 
I get what you‚Äôre saying and I am letting the ssh agent actually handle the signing logic on behalf of my program. But the Go API requires a username and I have to populate with something. This is what starts the rabbit-hole to my question. Keep in mind I also allow this username to be overridden by a flag ‚Äîuser. But I don‚Äôt want to have them require providing this every time.
Good idea. Currently it spits out the docks if you run the program without any args but that would definitely be better.
Not quite curl -s https://play.golang.org/p/01khLxyyTYR.go|gofmt he's talking about after { and before }
I concur.
A showstopper crash bug was just fixed, so if you‚Äôve tried it over the last few years, it might be time to try again. I am not the author and haven‚Äôt contributed except to open issues, but I am quite pleased with the library for small tasks because the library takes only about 9MB for a ‚Äúhello world‚Äù application whereas wxGo is an order of magnitude higher and QT is larger still. [UI from Andlabs](https://github.com/andlabs/ui) is based off of his C-based [libui](https://github.com/andlabs/libui) (which powers UI libraries in a number of other languages as well) and lacks the huge widget set of wxWidgets in the form of Go library [wxGo](https://github.com/dontpanic92/wxGo). My fingers are crossed for a data grid widget later in 2018, and the author has announced an intent to move to semver. My understanding is that the README will be cleaned up at that time. It‚Äôs a little messy at the moment, but if you look at the wiki, examples, and godoc, you‚Äôll be able to figure it out. Overall, there are some bumps in the road when you use a less mainstream library, and the author had a long pause as he waited for copyright clearance after a new job, but he has just made some important bug fixes, and I‚Äôm excited to see the project continue. The author isn‚Äôt extremely punctual on pull requests and issues, but he‚Äôs a hard worker tackling a task that I appreciate very much.
You might be interested in [Tr√¶fik](https://traefik.io). It has tools for routing requests, load balancing, auth management, etc etc etc. You'll be able to define what sort of requests get routed where and it'll let you scale things out a little more effectively. I do agree with the other posters here. Your "API gateway" shouldn't really look at anything in the requests it's passing through. Requests to different APIs/endpoints can be organized by subdomains, for example. Traefik could blind passthrough all requests to "user.yourdomain.com" to the User microservice, all requests to "auth.yourdomain.com" go to the Auth microservice, etc. As you're learning, tightly coupling your load balancing/routing to your "backend" APIs becomes very problematic. Take advantage of existing tech and tools ( host based route forwarding which is something even simple nginx configs can do ).
Dang, that was an even better catch than I thought! That seems entirely counter-intuitive since I'm coming from the world of stream-processing where it's been more of a "fire and forget" system. Thanks for pointing it out! I have updated the tutorial and placed the buffered channel section closer towards the beginning so that it can be used to prevent goroutine leakage throughout the article. Seems like it's definitely worth a follow-up in the future! I'll figure out how to
As someone who interviews a decent amount, learning in go but interviewing in python would have be how I would have done it if I could go back in time (unfortunately go didn't really exist then though). My background is in physics, but I work as a software engineer, so I never formally learned any of this stuff. I learned it all in python self taught and I can 100% say I missed a lot of the intricacies that aren't apparent on the surface due to python. Big O is always a "well it depends" situation with python. I'll always always always interview in python because it's much faster to prototype (for me personally), and thus easier for technical interviews, but languages like go and c don't hide everything behind the magic of lists like python does. Which becomes a crutch to many of us python every day users. Personally I've been rewriting a lot of my work from python to go just because go has taken my liking voraciously since I started using it.
Sorry wrong title, I meant Go sped up in 2 of the benchmark.
[removed]
Ah ok, that makes more sense.
Related question. Anyone used the book "Data structures and algorithms in Go" by Jain? Would you recommend it?
The command `ssh -G host-name` prints the ssh configuration after Host evaluation. You can parse its output and get useful information such as `user`, `hostname`, `port`, `identity file` ...
A rewrite in a language that isn't an abomination unto the lord that c++ is, is indeed very welcome. This should make it easier to hack on. I'd heard about this in various places and was awaiting the completion of the port in eager anticipation. With that said, you've ruined everything with the license. It appears to be incompatible with using the codebase to create your own coin, which is the first thing someone wanting to experiment with your implementation is going to want to do. It's definitely incompatible with the GPL. You're also not claiming that the code is a cleanroom rewrite, therefore it is doubtful that you are actually entitled to impose a license over the entire codebase if it is incompatible with one or more of the original licenses from which the port is derived. I'm hoping that this is some sort of oversight and you opt to use the BSD license you use for deroproject/dero or even GPL, otherwise I'd be bitterly disappointed.
Hello u/testmeharder Thank you for expressing a potential interest in Dero. Would you be willing to clarify for me what you mean by a "cleanroom rewrite" if you wouldn't mind?
How can you typo something like that? 
Don‚Äôt wanna bring a flame-war here but Have you checked if java benchmarks are running in cold (right after startup) or jitted? You‚Äôll find a huge difference in numbers. 
Seems interesting. I'd like to see a more complex example.
Isn't it a `sed` one-liner?
It might be possible with a complex term yeah, but I think using go's ast ist more safe: https://github.com/Eun/goremovelines/blob/master/_tests/func_inner_string_func/input.go.txt
The code size to logo size ratio is like 0.25. And, well, the chief problem is that if I would like to write a *script-like* throw-away code (that's the sole case where you want to "fail fast no matter where and why"), I'd take Python. Go is for writing infrastructure code which must be robust.
I'm writing simple web services in go. And if something goes wrong I want to knew it (send errors to rollbar). Having recovery and panic allow to simplify code and not to forgot some errors (laziness: `val, _ :=`, forgot return, etc). Yes, logo is main part :)
I usually work with different languages, Java, C++ but also Common Lisp. A very simple approach that mimics yours is possible to do with exceptions. (defun parse (string) (or (ignore-errors (parse-turtle-syntax string)) (ignore-errors (parse-functional-syntax string)) (ignore-errors (parse-xml-syntax string)) (error "Cannot parse ontology: ~S" ~A))) IGNORE-ERRORS catches errors and returns NIL (the error being caught is returned as a secondary value, but we don't care about them). The OR expression returns the first non-NIL value. Here we error when no parser succeeds. Note that using bare errors with message strings is not great (we don't want the callers to compare strings, as in Go). I would instead do: (error 'cannot-parse :source string) ... which creates an instance of this class of errors: (define-condition cannot-parse () ((source :initarg :source)) (:report (lambda (condition stream) (with-slots (source) condition (format stream "cannot parse ~s in any known format." source))))) The above defines an error named "cannot-parse" which has one slot named source, and for which we define a "report" function that describes the error (e.g. in the debugger). To shorten things a little, I wrote a "define-condition*" macro. The above can thus be defined with: (define-condition* cannot-parse () (source) "Cannot parse ~S in any known format." source) Then, you can call the parse function with files: (defun parse-file (file) (with-open-file (stream file) (parse (read-all stream)))) (defun read-all (stream) (let ((buffer (make-string (file-length stream)))) (read-sequence buffer stream) buffer)) The above might signal errors but there is no way I can predict the set of all errors that could possibly exist. A developer might define a custom STREAM, which errors in novel ways, after my code is shipped. If I want to be robust and enable forward-compatibility, I can catch any error and wrap it under a single "ontology-parse-error" object; I can catch all errors, but there is no way to *handle* them all at this level. However, reading files as strings before trying to parse them is not great. The above abstraction is hiding too much: the actual format might require different ways of opening a source: decompress an archive, open in binary or character mode, fetch from a network stream... A better approach here would be to use multiple dispatch and let the format decides how to open a given source. The following defines a generic function which first dispatches on the format, then on the source. (defgeneric parse-semantic-triples (source format) (:documentation "Read triples from `SOURCE' according to `FORMAT'.") (:argument-precedence-order format source)) Generic functions admit methods that specialize the behavior. Here, the default method when reading a pathname is to open it, and recurse with the open stream. (defmethod parse-semantic-triples ((source pathname) format) "Default method for pathnames: open file and delegate to stream." (with-open-file (stream source) (parse-semantic-triples stream format))) Likewise, let's define a default method for streams which slurps everything and parse from a string. That is the same behavior as previously, which is useful in some cases. Unlike the previous version, here the behavior can be overidden. (defmethod parse-semantic-triples ((source stream) format) "Default method for input streams: read all and parse resulting string." (parse-semantic-triples (read-all source) format)) If you want to warn the user when the result is empty, first define a custom class of warning: (define-condition* suspiciously-empty (warning) (source) "an empty ontology was found in ~S." source) With dynamic dispatch, there might be multiple methods applicable to an object, based on the class hierarchy and how methods are combined. Inside a method, `(call-next-method)` calls the next applicable method (a bit like "super"). Here below, I define an "around" method for "parse-semantic-triples". (defmethod parse-semantic-triples :around (source format) (let ((triples (handler-bind ((suspicious-empty #'muffle-warning)) (call-next-method)))) (when (zerop (length triples)) (warn 'suspiciously-empty :source source)) triples)) Here, we call that primary method with "call-next-method" and check the size of its result. The call to the primary method is done in a context where we "muffle" (ignore) warnings of type suspiciously-empty, simply because we might want to recurse. That allows to warn at the highest level of recursion, where source is the one given by the user (e.g. source is first a file, then we recurse with a stream, then a string ... we only want to show one warning for the file). Finally, we can have a format named :guess where we try all known formats. As before, define a new error type for when guessing fails: (define-condition* guess-failed () (source errors) "Cannot guess format of source ~S.~ ~%Parse errors for each format:~&amp;~{~%~{~S~% ~A~}~%~}" source errors) We should have a way to register known formats. Here we simply have a list of formats to try. A developer can locally rebind that special variable or add new formats to it. (defparameter *known-formats* '(:turtle :functional :xml)) Then, define a method for the ":guess" format (defmethod parse-semantic-triples (source (_ (eql :guess))) (loop with formats = (remove :guess *known-formats*) ; just in case (*) for format in formats for (result error) = (multiple-value-list (ignore-errors (parse-semantic-triples source format))) when error collect (list format error) into errors until result finally (if result (return (values result errors)) (error 'guess-failed :source source :errors errors)))) At (*), there is call to "remove" to avoid infinite recursion in case someone clever puts ":guess" in the list. Note that "remove" is purely functional, the original list is not modified. The rest is a simple loop: test each format, collect errors, stop with first non-NIL result. Errors are accumulated in another list, along with the format being tested. In case no format works, an error is signaled. Otherwise, the value is returned, and all the collected errors so far are returned too, as a secondary value (that might be useful). &gt; Yes, but except in very specific cases, this is not enough. All errors are not equal, some are fatal to the whole program, some make the whole function fail, for others you will try several times before failing, for some you will just log the problem and use a default value, etc. And that's why I prefer a richer set of primitives for errors than error codes. When you are trying to do things properly, the code becomes complex. Error values can get the job done, just like a goto can be used for any kind of loops. But I really think exceptions allow to untangle things more easily. Let's parse from a uri: (defvar *timeout* 2 "The default timeout") (define-condition* bad-status () (status headers) "Got status ~D, wanted 200. Headers: ~S" status headers) (defmethod parse-semantic-triples ((uri puri:uri) format) (multiple-value-bind (body status-code headers) (drakma:http-request (puri:uri "http://www.example.com") :connection-timeout *timeout*) (unless (= status-code 200) (error 'bad-status :status status-code :headers headers)) (parse-semantic-triples body format))) The above part is the "happy" path. Let's handle some network errors: (defvar *max-retries* 3 "How many times we retry") (defun handle-503 (bad-status-error) "Handle 503 with Retry-After header" (with-slots (status headers) bad-status-error (when (= status 503) (let ((retry-after (cdr (assoc :retry-after headers)))) (when retry-after (sleep (parse-integer retry-after)) (invoke-restart 'retry)))))) (defun handle-timeout (timeout-error) (incf *timeout* *timeout*) (invoke-restart 'retry)) (defmethod parse-semantic-triples :around ((uri puri:uri) format) (let ((retries *max-retries*) (*timeout* *timeout*)) ;; rebind (handler-bind ((usocket:timeout-error #'handle-timeout) (bad-status #'handle-503)) (loop (restart-case (if (plusp (decf retries)) (return (call-next-method)) (error "No more retries")) (retry () "NOP, which means we simply return to the loop")))))) Error handling is disconnected from business logic. 
The problem with this approach is that when a panic happens *all bets are off.* I mean, if the code obj.Field = 42 crashes because `obj` is a nil pointer to an object whose field you intended to update, this signals a fatal logic bug in the code. By abusing panics to emulate exceptions in "more mainstream" languages, you're mixing real exceptional cases with simple casual errors, thus creating a mess. IMO, "I'm writing simple web services" is not an excuse: you'll (supposedly) will eventually be writing production code at your $dayjob, and by that time you'll need to unlearn this skill. So it's better to do that sooner than later ;-)
FUD. This test is not replicable, the "full table" doesn't explain computer specification, used JVM, execution detail (no warm-up at all?) I am really interested to see comparison with C or Rust.
On a more serious note, this is not how you do error handling in Go. Read these first: * https://blog.golang.org/error-handling-and-go * https://blog.golang.org/errors-are-values
&gt; The API is promised to never break existing projects using this library. I don't see version 1.0.0 anywhere.
For quick little projects you could also use [BoltDB](https://github.com/boltdb/bolt). The dream is to someday have an SQLite equivalent written in pure Go but for now this is the best we got.
Emacs is whatever you want it to be.
This is such bad language design. Youre not meant to panic for the majority of errors, but rather handle them gracefully. And no, using recover isnt what i mean. Theres a lot of hidden performance hits in panic recover, from defer to unwinding the stack. I almost find it hard to believe that this library is a serious one. 
Let's agree to disagree. We have code reviews in place to not allow code like that you're advocating for into production anyway so good luck with that ;-)
Reverse-complement hit is significant ~18%. Redilux is negligible. Even we run benchmark twice on same system we may see this kind of difference.
&gt; 1500 lookups/sec So you add a cache for your dns look ups and it gives you 1500 lookups/sec. Does it anything have to do with Go?
Thank you so much dude 
While not a complete course and not covering too many algorithms yet, I have a few resources for learning a&amp;ds in Go here: https://www.calhoun.io/lets-learn-algorithms Feedback is welcome, as I was experimenting with various formats for the lessons and they vary a bit.
Is there a reason why you posted a second link to the same article hosted on a different website? Why not create a post pointing to the custom domain if that's where you want people going? What you did makes your post come across as spammy before anyone even reads the article to honestly evaluate it.
Hello I'm newbie on this matter, do you have any sources where i can understand what is nfpm, npm, rpm??? Thank you in advance
Indeed =))) But you forgot tests, and awesome logo!
Still a work in progress but it should help you: https://www.calhoun.io/guide-to-go/
&gt; Although Go is more C like but I find it better to compare it to Java because both are garbage collected languages Java has a GC and a VM, it is better compare the JVM to Mono, Node.JS, Zend Engine and so on... Instead both Go and Rust are compiled and have a memory managed mechanism. If Rust is too better then feel free to compare Go and Swift.
I read this before. But still believe what in most cases panic - it's correct approach. I prefer to write less code (less places to make error), fail fast, and yes ‚Äì be able to see stack traces along side with error message (https://github.com/pkg/errors). Point me there're I'm wrong? Let's leave aside the authorities in the dispute. Just explain what's wrong with my approach? (and yes, I'm missing generics in go)
Laziness is controversial argument. And programers are lazy. If something can be done by computer it should be. "handling them properly", so I thing guys at AWS really lazy: * https://github.com/aws/aws-sdk-go/blob/33ba3859ae4a8204a009f78f17d9c29dfb934c5f/aws/session/session.go#L272 * https://github.com/aws/aws-sdk-go/blob/f9f8469082b0d56f45aa6317a13fffd7bc985584/private/model/cli/gen-api/main.go#L215 * https://github.com/aws/aws-sdk-go/blob/b2dc98bb584e48b0f5f39c93110633173c5da43c/vendor/github.com/jmespath/go-jmespath/api.go#L27 * https://github.com/aws/aws-sdk-go/blob/793c7bad9fd33bf3cf2095f32f8024bf47f3cd0a/private/model/api/load.go#L34 * https://github.com/aws/aws-sdk-go/blob/b2dc98bb584e48b0f5f39c93110633173c5da43c/awstesting/integration/integration.go#L34 * Much more: https://github.com/aws/aws-sdk-go/search?utf8=%E2%9C%93&amp;q=panic&amp;type=Code
I have encountered this issue even if I have gcc &amp; mingw version 5.1.0 https://github.com/andlabs/ui/issues/147 so this is kind of a show stopper on windows 10..
&gt; Indeed =))) But you forgot tests, and awesome logo! Ok // ‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïó // ‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïê‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù ‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïë ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïë ‚ñà‚ñà‚ïî‚ïù // ‚ñà‚ñà‚ïî‚ñà‚ñà‚ñà‚ñà‚ïî‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïë ‚ñà‚ñà‚ïë ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïë ‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù // ‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë ‚ñà‚ñà‚ïë‚ïö‚ïê‚ïê‚ïê‚ïê‚ñà‚ñà‚ïë ‚ñà‚ñà‚ïë ‚ñà‚ñà‚ïë ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù ‚ñà‚ñà‚ïë ‚ñà‚ñà‚ïî‚ïê‚ñà‚ñà‚ïó // ‚ñà‚ñà‚ïë ‚ïö‚ïê‚ïù ‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë ‚ñà‚ñà‚ïë ‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë ‚ñà‚ñà‚ïó // ‚ïö‚ïê‚ïù ‚ïö‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïù ‚ïö‚ïê‚ïù‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïù ‚ïö‚ïê‚ïù func TestCheck(t *testing.T) { defer func() { if r := recover(); r != nil { t.Error("Check doesn't working somehow.") } }() var err error Check(err) } func TestMust(t *testing.T) { defer func() { if r := recover(); r != nil { t.Error("Must doesn't working somehow.") } }() fn := func(val int) (int, error) { return val, nil } if Must(fn(2)).(int) != 2 { t.Error("Must doesn't pass through same value") } }
If there is some function you want to associate with a value and not explicitly pass that along with it, use methods. If you want a type to satisfy an interface which contains one or more methods in order to generalize some behavior across multiple types, obviously use methods. The rest is a matter of taste and semantics. For example I prefer things like `func add(a, b T) T` over `func (a T) add(b T) T` if it's a simple commutative operation where there is no single clear "self" to operate on.
How to handle gracefully err on opening file for example to logging? In average go program 80% of errors types just escalated to top to be added to error log. Why don't delegate this to panic/recover? 
See it as an opportunity to learn new things, then!
I'm feel just the opposite. After years of jumping around large code blocks of try/catch, Go's approach reminds me of procedural programming days and is quite refreshing. Object oriented languages brought a lot of power to developers but try/catch was not one of them in my opinion. Try/catch in my opinion made error handling and reading code that much worse. Multiple try/catch is worse. Or the empty try/catch speaks for itself. Go handles all of these conditions inline, directly after the function. Handling the errors directly after the function itself tells you a lot about the possible error conditions. Used in combination with the "defer" keyword, I think you have a better pattern than try/catch.
```// This helper is intended to be used in variable initialization to load the // Session and configuration at startup. Such as:``` AT STARTUP, as mentioned by someone else here. Regarding the majority of other cases, they are almost always ok times to panic. The way youre talking is as if one should *always* panic on any error at any stage, which is completely non-idiomatic and quite frankly, idiotic. There are many cases where one should do something else in the case of an error, an alternate route etc etc. Panics should be reserved for exceptional cases, and errors are not exceptional
The average Go program doesnt escalate errors to the top to be logged. They are most often logged at the site of error. Youre overusing panic, and its not the way things are done in Go. Panics are for extremely exceptional cases
Would be great to see something like Plex written in Go. Not that it uses a native UI but I can benefit from UI like things (tray icon etc).
I would check out [x/sync/errgroup](https://godoc.org/golang.org/x/sync/errgroup) to see a good example solution of the problem you‚Äôre solving here. The things that make errgroup better are: - valid zero value means you can put a errgroup on stack with var g errgroup - handles error propagation via sync.Once - optional WithContext coordinates cancelation for all goroutines if a task fails. - does not allocate for calls to Go or zero value usage Criticism for your library: - requires a call to New, for a ctx value that probably already exists in the scope the functions are defined in. - WaitGroup is a pointer for no reason - Require allocations for each goroutine created to signal when they are finished, but in practice people don‚Äôt need per goroutine exit notification. - capturing signals is in general something that should be avoided, even if it was I don‚Äôt think a channel make and call to os.Signal is really worth existing as a function anywhere. So I would start with adding value on top of the core things errgroup does, because error propagation is crucial for writing real world Go programs. 
&gt; MinGW-w64 it only worked with MinGW-w64 ... Does not work with TDM or MinGW 
- nfpm: this tool - npm: node package manager. javascript stuff - rpm: package manager on several operating systems
Okay. It could be coincidence that I've always been able to compile it without issue. I certainly need to change my path frequently on Windows. :(
Agreed. After a new libui version is merged in to UI, I am going to make some documentation pull requests.
I'm guessing Plex would need something like wxGo. I only use UI for simple command launchers and I'm not sure it would have what Plex needs.
Okay, use MustCheck only for startup stuff. &gt; But what if the error is unrecoverable? 
Thank you very much, it's more clear 
That's stating the obvious since it's the only license in the git tree. Why has it been chosen? Is it going to change? What exactly is meant by 'commercial' use?
How sound/complete is errcheck?
&gt; Okay, use MustCheck only for startup stuff. Then you need to update your documentation and Readme. 
You can just use [gometalinter](https://github.com/alecthomas/gometalinter) (it includes errcheck).
For some projects it would be useful, but it actually wouldn't have worked for the one I was working on yesterday. I needed to be able to open the database from multiple processes at the same time, and Bolt explicitly stated that you can't do that. I also stumbled across one called [ql](https://github.com/cznic/ql), but the documentation want clear about things like multi-process access and, more importantly, it has an optional CGo component that's on by default and requires manual build-tag fiddling to turn off, so I passed on it. I wonder if someone should tell the author that there's an automatic `cgo` build-tag...
Why would anyone include this as a library instead of DIY? I‚Äôve written OrDie funcs many times (and actually moved away from them but never-mind that), and I never felt the need to have someone else write it for me. Remember ‚ÄúA little copying is better than a little dependency.‚Äù
What are you, or do you plan on using this for? Or is it more for learning purposes? Either way, pretty cool!
I was asking if it being written in Go has anything to do with the 1500 lookups/sec. 
That hasn't been decided, right? But it would be good if it was 1.11
&gt; In C++? As long you use RAII and don't have any side effects - I'd hardly say it's totally safe. Certainly not from a junior engineer who doesn't know or understand your standards and conventions. Compiler-generated unwinding doesn't mean "fool proof". You should certainly not let your interns commit shit before a thorough code review in _any_ language, let alone C++. But that's beside the point. My point was simple - no one who has any relevant experience on large code bases will not go around saying how calling "if (err...)" millions of times, scattered all over your source code, is an "elegant" way of error handling. Jeebus, we've done this for 40 years in plain C and no sane person wants to go back to that! Trivial source code and examples are all fine and good looking, but that shit doesn't scale in the real world. Now, exceptions are not a silver bullet, and C++ and its use of exceptions certainly leaves a *lot* to be desired, ever since they were bolted on and then ignored by programmers was a long time. But these days, when compilers generate code that is just as performant with exceptions enabled, and when we're finally standardising their usage, there is no reason not to use them. If you have a good reason not to use them, then you'll already know all about them. (And another problem with discussions of this type is that you never know who sits on the other side of the arguments like "if(err) is elegant" and "Go's simplicity is its strength"... most of them sound like kids who've done a couple of years of Python or something similar and are now talking about things they really know nothing about. Dogs on the Internet, or a joke like that).
Just go to link and evaluate it as u want 
Good catch, but JVM warm-up requires some time.
It's just my view, but 12 years on a very large python codebase that used exceptions a lot, and I'm very happy to be working with explicit syntax for when something will leave a function, and not having to check for a finally statement below a return. I won't call it elegant, but I do find it easier to reason about and maintain than invisible paths through the code. 
Thanks for sharing all this info. 1. Did you create a specific rich-order-info service for that scenario or all system calls ran through the UI service? 2. Order is probably already familiar with user &amp; product, why not just expose order.getRichReport (as REST API of course) which will take care to interact and aggregate from the services it already know? 
It is not generally slower. You can make NFA simulation (or DFA construction) be much faster than backtracking at the cost of some preprocessing (this is exactly what the `lex` tool does when generating parsers). However, I believe the Go implementation is just not very optimized. The important advantage why you want NFA simulation (or DFA construction) instead of backtracking is that these algorithms do not suffer from catastrophic performance loss as backtracking does when presented with certain regular expressions. This is an extremely desirable property when the regular expression might come from untrusted sources, such as user input.
I've often used Go to improve speed in legacy API's where the existing PHP/Python/Node backend was not fast enough. In almost all of these cases I've had to really carefully design the database and I/O calls which almost never seems like it's a good fit for an ORM. For example, I might have a single, complex, multi-table query that only touches the specific columns needed. In these cases I've had trouble finding a benefit to the ORM abstraction over simply using SQL. So few of my RDBMS CRUD needs are as simply as mutating a single object (`Fetch(Foo).Modify(Foo).Update(Foo)`). Now if this was redis or mongodb it would make more sense. Can anyone provide insight into this process?
&gt; Ok so indeed postgres is a much better choice. What is the pure Go driver that you mentioned by the way? [pq](https://www.github.com/lib/pq).
Oh cool, that's the driver I have always been using. üëç
So because you're using redis instead of BoltDB or an internal map of some sort I assume you expect multiple fastresolv instances to be spun up? 
Thanks ;-)
In that case, look into creating a new [zapcore.WriteSyncer](https://godoc.org/go.uber.org/zap/zapcore#WriteSyncer) that supports GrayLog. Depending on which Graylog library you're using, you might need to write your own abstraction type to abide by an io.Writer, but once you have that it should be pretty straightfoward; create the WriteSyncer, use it to create a new zapcore.Core with an appropriate message encoder (likely just JSON), then pass that to zap.New.
thanks for your job. I'm not satisfied with autocomplete and good static analysis support for php for vim/emacs so your project may be a good entry point for me to write my own lsp server for php in golang.
try-catch is counter intuitive in most languages. For example, in Javascript if any of those are async functions, the try-catch doesn't work as most devs expect and silently swallows errors.
[removed]
I am not sure, but I think your first example application will optimize itself to a no-op without the `-defer` option. It is calling a leaf function that does nothing with the result of two constants, so it will very likely be inlined and then removed completely. I tried actually looking on godbolt (see https://godbolt.org/g/MsP9rh) but I am having trouble following the generated asm. Can anyone confirm or deny? Interested results, regardless. Nice write-up!
It really depends on what you want to do. If you're familiar with other languages, pointers behave similarly to reference types. That is, pointers REFERENCE the originally defined type. If you define Foo and pass it to a function as a value, the foo you have defined won't be changed. If you define Foo and pass it to a function as a reference to Foo, the original Foo will be manipulated. Pointers don't copy. They reference. Here's a demo - https://play.golang.org/p/CqC0us11KGW So if you need to manipulate a slice of Foo, you'd pass a pointer to your slice as an argument of your function. If you need to do something with your slice of Foos but don't want to manipulate the original slice, you'd pass the slice itself to an argument to your function. One of them is a copy of the values. One of them is a reference to the original slice. (Note: Go doesn't REALLY have reference types, so that's not technically a "correct" term, but I find it easier navigate by mapping them that way mentally)
Returning a slice of either type doesn't copy the underlying data. A slice type only consists of the slice length, capacity, and a pointer to the underlying array. 
The size in memory of the return value or arguments is the same for all slices, because they only contain pointer to data, length and capacity. For the rest it depends on the use case. If an index can be nil or do you store already created data that you have a pointer to, go for the pointer version. If not I usually go for the non pointer one. One exception there is if I have a lot of functions that take *Foo. In that case I often use a slice of pointers. 
Thanks. The idea was less to write our own than to use an existing one. Does anybody have experience with and _existing_ integration? 
github.com/oklog/run works similarly, with a more general and smaller API.
Always the first one! Except when the second is better. 
This is not accurate -- the slice is always the same size, as a slice is just a reference to a backing array with a size and a capacity. If it were an array, rather than a slice, a [10]*Foo is smaller than a [10]Foo if Foo is a structure larger than a printer.
Only the backing array is smaller; the slice is the same size. You also don't generally need to take a reference to elements of the slice, the compiler will typically handle it transparently as slice indices are addressable. In other words, you can call pointer methods on elements of a value slice.
Why so many down votes?
The simple heuristic is that if the constructor of the type returns a *Foo and the methods have pointer receivers, use a []*Foo, and if the constructor of the type returns a Foo and the methods have value receivers, use a []Foo. This same heuristic applies to variables of a type as well. The former should be the default if you have no reason to do otherwise, in the same way that functions returning structs should by default return pointers to those structs, and methods on structs should default to pointer methods. Value types can be useful but they can cause confusion when they get copied if they contain reference fields, and so they should generally be considered an optimization to be supported by perf analysis first.
true, true. I think its good entry point because parser code is not complicated too much at this point of time. I'll give a try and dig into your library. see what i can do and how can i help. 
I don't have time to dig into this right now, but serving 1500/sec sounds _really_ slow. You may want to do some profiling and figure out where the time is going.
&gt; the range keyword, howver, it makes a copy of each element in the slice resulting in the behavior you describe (changes are local to the function only, unless of course the value is a pointer then the end result is the same). https://play.golang.org/p/fN6MNKJCDwG I just changed your for loop to a range loop, expecting that values would be changed locally only. Was not the case.
Instead of using the time command, you should use [benchmarks](https://dave.cheney.net/2013/06/30/how-to-write-benchmarks-in-go) from the testing package
So this makes C++ calls via FFI? How are you making sure that you are mangling the names right per C++ compiler that compiled the Qt libs?
Good clarification! If you use the index to access the value when using the range, the result is the same as using using a for loop. It's when you operate on the value instead of the index that this happens.
It actually seems to be using CGO to call this library: https://github.com/kitech/qt.inline, which is essentially your good ole' C wrapper on top of a C++ library. That means name mangling is not an issue when calling the library from Go.
I can't imagine it would be more than a dozen lines to write your own. For example, with [this library](https://github.com/Graylog2/go-gelf) it looks like they already export io.Writer compatible interfaces, so its as simple as replacing the log.SetOutput(io.MultiWriter(os.Stderr, gelfWriter)) line with the similar zapcore.Core line. With [this one](https://github.com/robertkowalski/graylog-golang), they don't, but you'd just have to wrap what they give you in a new struct that does have a `Write` and `Sync` method, where the `Sync` method likely does nothing since the writes already appear to be synchronous. 
you are reinventing errgroup arleady in this library :)
I pretty much always vote for []Foo for readability. Tracing pointers is fun and all, but I prefer debugging to be as painless as possible.
Ah, I see now, thanks! I have been wanting to find a well-supported C wrapper for Qt for use in other langs. Hopefully it works well.
As a rule of thumb I always go for * as function arguments/return types for structs because of performance reasons. I benchmarked all possible cases, * is by far fastest as there is least mem copying.
Same. You can convert code to use pointers later if perf is the issues.
&gt; yes, it sometimes happens! Urban legend. It is never the case with good enough programming: C/C++ code beats code in Java by the factor of 2-3 when it comes to CPU intensive tasks.
Please just do ```go newFoo := changeFoo(foo) // or manipulate directly if it is very simple: foo.Name = "asdf" ```
Right. There are few instances where slice of structs makes sense. For instance, I am parsing RTCP message where header contains count of SSRC blocks. I can allocate a slice of fixed size structs to capture the data. Just one allocation. Very efficient for networking. For SDP media I go with a slice of pointers to media structs: they are of different sizes, the total number is not known until I parse the content, and it's not real-time data.
I'm not sure if this is a serious response. I gave a very contrived example to show, in a simple way, the difference between pointers and values. Manipulating the value directly would not help to serve that example.
Do you expect a web browser to connect to the server? If not, they why did you base this on websocket? If so, what's the security model? 
I always return a slice of pointers, rarely do I end up not mutating an element 
This is not clear. as slice is also a `pointer` to underlying array. you still can modify each element in the function. Same for return value. 
I setup a project using nfpm via goreleaser and it seemed to work great. The only issue that I ran into was that the default goreleaser file was missing some of the fields under nfpm, and it breaks if `description` is missing. Once I added description, license, homepage, maintainer it worked ok.
I'm really not sure what your point is here.
[removed]
The OP stated that copying a slice of structs costs more than copying a slice of pointers when returning a slice from a function, which is false.
In Go 2, they should get rid of the useless linked list and add a deque instead. 
No doubt, but that's besides the point. The output will be the same.
My personal use case is mixed and WebSockets are a good common denominator without much overhead. It performs well for streaming data from multiple sources and distributing/mapping/filtering them using POSIX-style pipes instead of having to build network code into your data applications. I wouldn't expose a node directly to the internet, so the assumption for security is that you put a reverse proxy between the node and the internet if you want to serve it to browsers. Otherwise there is no auth and the WebSocket server has both "/in" and "/out" paths which probably isn't what you want.
The reason I asked is that there seems to be little reason to use WebSockets in the application. If you don't need to use it for communication with a browser, then direct use of TCP may be simpler and will be more efficient. 
&gt; You‚Äôre copying the values again in the print statement though It would be the same if I passed pointers to those values. The copy is irrelevant. &gt; and not the values from the slice, but the original values that were copied to fill the slice. Of course. That's the point... &gt; Try printing the slice instead, or the slice elements (fooValues[0] etc) We don't care about the values in the slice; we care about the original values. Of course modifying the slice will modify the slice; that's uninteresting. We want to know the difference between a slice of values and a slice of pointers!
I think then maybe you missed the point of the comment you responded too. Regardless of returning a slice of pointers or a slice of values, the underlying array can be modified directly (value array) or indirectly (pointers to values on the heap). So the point of that comment holds and you have not disproven it, only made an example of how not to write said function. 
WebSockets don't add that much overhead over TCP, every modern language has a client implementation, the WebSocket protocol handles some of the lower-level message buffering, and it works in browsers (which can be useful for local applications even if you don't proxy it through to the internet).
[removed]
I don't think /u/weberc2 is trying to disprove anything, rather he's interested in modifying the original slice. He's not saying you're wrong. He has agreed with you, in fact. Could you show me a code example of what you're try explain? I'm not doing a great job of understanding what you're saying.
It is generally considered an anti-pattern to place a `defer` in a loop for the reasons you discovered. As a more efficient alternative, you should use a single `defer` that enumerates the list of resources and performs any cleanup. Add any resources to be cleaned up in the loop to this data structure. See https://play.golang.org/p/Gs_f_TLOiWu
Not necessarily, especially if the backing array fits into a few cache lines; these are the sorts of things that can become optimizations down the line but don't make much sense to spend a lot of development time on until it becomes a problem :)
No, I don't know what unixpath and sendrequest are, because there are too many search results without more context. Unix sockets are their own things that are unrelated to TCP or UDP, which have their own special abilities. I know Go supports them because I used them just last week.
I meant like can you make an api request through unix sockets like socketpath/api/getitem
I didn't miss the point :) Even though you can modify a slice of values, you may not modify the original data from which the slice was made, unlike a slice of pointers. In my example, I showed that foo1, foo2, and foo3 were preserved. I think perhaps you're basing your assumption (if indeed you're making an assumption; it's very unclear) on the idea that the slice is the source of truth for the data, but the slice could well only point to a copy of the data.
Your one loop version allocates more. 
Errgroup was mentioned by top comment 8 hours prior to yours. `errgroup` and `runner` offer a different feature set. I'm sure going to use `errgroup` in the future, but also `runner`, depending on whether or not I need exit notification per goroutine. Removing `New` is not an option because of my API compatibility promise, and even tho the library was only a few hours old and its very unlikely anybody would already be affected by it, a promise is a promise. `New` is deprecated as of v1.1.0, released 11 hours ago.
The second loop should be over countRecord (which should be called recordCount). 
I see a few things: * remove parenthesis in the conditional in the first loop * change `isAppend[v] == false` to `!isAppend[v]` Other than that, it looks fine. Oh yeah, and as others have said, run `gofmt.`
https://play.golang.org/p/xwNS9PR2Kj-
It shouldn't be too hard to write a quick start guide for delve.
So how would you benchmark defer without putting it in a loop.
The init cmd could probably be improved... thanks for the feedback!
Thanks everyone for the comment, yeah, it was a hackerrank online code testing, so I didn't run go fmt. 
Yes the other for loop optimizes out the `inc` function call, so that it just increments the counter 10e6 times. Check line 33 https://godbolt.org/g/mqmQ5H
Right. It also depends on the size (N) of the data at hand. Most values of N benefit from using a normal slice. As N gets huge, depending on the operations you reference, it's totally possible that using a linked list would perform better. Benchmark, and benchmark the use cases you're trying to address. If you have a collection of a million widgets, then benchmark your operations on a collection of that size.
Every Go code is beautiful, don't let anyone tell you otherwise
I've used https://github.com/moovweb/gvm Nothing fancy. 
Navigate to https://golang.org/ref/spec and select `Print`, then select `Save as PDF`. Just tried in Chrome, the result looks quite good.
I have only played around with python a bit and read a few chapters here and there in a few books, so I might be wrong about how virtualenv works. From my understanding, virtualenv allows you to isolate dependencies and use different versions of python. In terms of Go: - If you use the `vendor` folder in each of your project to store your dependencies, then the dependencies will be isolated from each other. - Go is really fanatical when it comes to backwards compatibility, so, as long as you're using Go 1.x, your code should compile fine in general. In addition, only the last 2 versions of Go are supported and there is a minor release (1.x) every 6 months, so it's pretty easy to upgrade. - I tend to use docker containers if I need to test a new version of Go or try to replicate or test something in an older version. I made a very simple tool for myself to spin up a container, attach any service containers, copy the code into the Go container and execute a command (run tests, etc). I've seen a few other open-source projects posted here that will also do this for your. I haven't had the need to use gvm myself, but it seems to be a well-built project that should suit your needs really well if you need to run multiple versions of Go on your machine.
Thanks for the suggestion. The outcome does hurt my ex-scientific editor's heart a little. :(
It sounds like your projects are more dependencies than, uh, anything else. You might need to rethink how many dependencies you use. Also -- vendor your code?
I don't work at Google, but my perspective is similar: https://opensource.google.com/docs/thirdparty/licenses/#restricted (and my personal experience with making software under the MIT or Apache Software License has been positive in terms of getting contributions, people using the software, rewards for myself, etc).
It is good to remind people of [classic tricks](https://blog.golang.org/error-handling-and-go#TOC_3.).
I came from python too and was also missing virtualenv. Which is why I created virtualgo: https://github.com/GetStream/vg It's a small wrapper around dep (the pip of Go): https://github.com/golang/dep . At the core it only sets some environment variables and moves some files around. What makes it much nicer to use then virtualenv though is that it has auto activation on cd. It's also recommended in the dep docs if you need some of its features, such as pinning executables. 
But when is the second one better?
You can do HTTP APIs over Unix Sockets, not sure anything others. They are certainly possible, but never tried myself.
I wouldn't.
I use the default GOPATH for testing and set a new GOPATH for each isolated project.
I think the answer from the comments on the top-post are far more enlightening. It just makes sense *semantically*. Values in Go are always copied. When you call `Foo(b)`, you don't expect `b` to be modified, when you call `Foo(&amp;b)`, you expect that it might. If what OP asks would be possible, that distinction would break down. IMO the source of the confusion here is (again) the syntactic sugar Go decided to add, that you can call a method with pointer-receiver on an addressable variable, without first dereferencing it. This is what makes people think "if I can call `b.Read`, then why can't I say `io.ReadFull(b)`?". So really, IMO the question should rather be "why can we call pointer-methods on non-pointer values" - and the answer is "because it is really convenient and not *that* surprising behavior in practice". But it does lead to some confusion.
It is indeed sexy! https://github.com/tombowditch/telly/blob/master/Dockerfile
Why would you want this? Save some trees
You can definitely modify the original data in the slice. A slice can be seen as a value type that essentially holds a length, a capacity, and a pointer to the first element. Crucially, that pointer is a pointer regardless of what your slice is of (even value types). This means any number of copies of the slice will refer to the exact same sequence of elements, until you perform an operation that requires a new underlying array to be created (eg. resize). When /u/marksteve4 said, "you still can modify each element in the function" he is correct. You can see that here: https://play.golang.org/p/lQPSthZtsuH Your response link didn't have any explanation, but I took it to be a counterpoint, which it isn't. Keep in mind that value types are stored with the variable on the stack, and every unique variable will have its own storage (assignment copies that storage). Because the slice value contains a pointer, that pointer is copied and stays the same (so the underlying array is reused, not copied), while assigning single values of a value type (the struct in this case) to a variable will copy that struct, which means the other variables won't be affected when you modify the new variable.
You don't need it. I'd recommend working through the content in this page - https://golang.org/doc/code.html - then developing in that style for a while before you look to diverge from the recommendations. That way you'll understand the intentions of the language designers better and have a clearer idea of what you like and what you need to tweak.
It always baffles me, that people find `return MyError{code, "whatever"}` so much better than `http.Error(res, code, "whatever")` - in particular, given that the latter is *so* much more flexible (you could also use your own function to render an error page like you want, for example). I have to admit, that returning an `http.Handler` is a clever twist on the idea, but I don't think it's a particularly good idea. For example: Their `WithStatus` is not usable in combination with their `JSON` (if the latter weren't broken and would actually set the Content-Type header). So, they add a bunch of subtlety to the API for the benefit of writing, e.g. // Helpers func Error(w http.ResponseWriter, err error, code int) { w.Header().Set("Content-Type", "text/plain") w.WriteHeader(code) fmt.Fprintln(w, err.Error()) } func JSON(w http.ResponseWriter, v interface{}) { w.Header().Set("Content-Type", "application/json") json.NewEncoder(w).Encode(v) } func Text(w http.ResponseWriter, s string) { w.Header().Set("Content-Type", "text/plain") fmt.Fprintln(w, s) } // Usage func GetThing(w http.ResponseWriter, r *http.Request) { thing, err := storage.Get("thing") if err != nil { Error(w, err, 500) return } JSON(w, thing) } func DeleteThing(w http.ResponseWriter, r *http.Request) { if err := storage.Delete("thing"); err != nil { Error(w, err, 400) return } Text(w, "deleted thing") } func HandleThing(w http.ResponseWriter, r *http.Request) { switch r.Method { case http.MethodGet: GetThing(w, r) case http.MethodDelete: DeleteThing(w, r) default: http.Error(w, "not found", 404) } } http.Handle("/thing", http.HandlerFunc(HandleThing)) Which isn't a significantly different amount of code in the end‚Ä¶ I think there are some changes you could do to the http server package to make some things more convenient. For example, being able to set the status code of a `ResponseWriter` without having to write out the header directly might be neat. Or *maybe* being able to panic from a helper to omit the extra return statements (though I'm not sure I like obscuring the control flow). But I just don't get how it's more convenient to put the needed info into a return value instead of calling a method on a parameter - in the end, both are *exactly* the same amount of code.
 &gt; in the end, both are exactly the same amount of code. They are more or less the same yes. But the latter requires an extra line for `return` and it is easy to forget it. 
It is my first Open Source project and I am open to contributions. There are many issues that I need help: * Documentation * Usage examples * PhpDocComment parser * Errors handling and syntax error tolerant parsing * Namespace resolving
You might want to try virtualgo in that case. It automates switching GOPATH based on the directory you cd to. 
Yes, but if you need to manipulate a *slice* you need to pass a pointer to the slice. If you only need to manipulate the underlying array or some values its elements are pointing at you obviously don't need a pointer to a slice. So /u/HankDanger isn't wrong, however I think passing slices by value makes sense 99% of the time.
Use `Foo` if you need to return a copy of a value. Use `[]Foo` if you want to return a slice of `Foo`. Use `[]*Foo` if you want to return a slice of pointers to `Foo`.
Using it within a function inside the loop seems more realistic.
yes. I wrote a tiny server like this recently. https://github.com/syphoxy/wego/blob/master/cmd/wego-server/server.go
Just a wild guess: Scanner.Scan() scans for "newline-delimited lines of text". The aria2 output may be doing something else?
I believe it would help if the handler for the API response was also running concurrently. The example sounds like the 3rd party API is being handled in the main loop. If you check out how HTTP servers work, you will realize the main loop only receives requests and launches concurrent functions.
You could try using [pandoc](https://pandoc.org/) to convert the HTML file to a LaTeX'ish PDF using your favorite document class. 
I think it is a clever hack, but I usually write another function that does "the thing" and return the body and/or an error, and then use it inside the handler, so the handler has only one \`http.Error\` call. Bonus points because I can test "the thing" without a http test server or anything else.
Did you read to the end?
Yeah why?
The post's main takeaway is the HandlerFunc that returns an http.Handler. The go blog link you posted has no mention of this.
Hi there :) If your request handler is an http handler, then already every handler is in a separate goroutine. So, you need not spawn a separate goroutine for that. Unless of course, you want to return immediately to the user. But, if they are not, then yes, for the 2nd request, a new goroutine will be spawned. Both goroutines will run concurrently and will be handled according to how the code is written. Does that help ?
Say, there is no parallelism, i.e. we use a single actual *thread*. You can still have what you want, as long as you have support from the runtime and do the right thing when things "block". So, let's take your example and apply it to javascript, for illustration: * You get a request R1 * You do some processing and decide that you need to send a request R2 to a different backend to serve R1 * You call `http.request`, passing it all the request parameters of R2 and a `function(res)`, let's call it `f`. This causes the runtime to send out the request and store `f` in some internal data structure for when the response arrives. * You then return from your function, back into the runtime * The runtime then receives other requests R3, R4, R5,‚Ä¶ and calls your handlers, which does other things. * At some point, the response to R2 arrives (let's call it R2'). As soon as the runtime gets to do its thing again, it will look up what request that response is to (R2) and what function you passed it when creating it (`f`). It then calls that function with the response, allowing you to handle it. Now, this is how JS handles the issue of writing concurrent, non-blocking code: When you want to block until a certain event happens, the runtime gives you a function that tells it "call $thing, once $event happens" and you then return back to the runtime. Go does it differently: In Go, you also get cooperation from the runtime, but instead the function it gives to you can be described as "park my current context and stack somewhere and wake me up again, once $event happens". So * You get a request R1 * You decide that you need to send a request R2 * You call `http.Get`, passing it the request parameters. *This then* calls into the runtime to tell it to suspend execution until the response arrives. * The runtime parks your execution context and picks up a different one * This then receives requests R3, R4, R5‚Ä¶ * At some point, the response to R2 arrives. The runtime, once whatever is executing right now is getting parked, will look up the context of the function that sent R2 and unpark it So, both things happen very similarly, except that in JS, the runtime stores a mapping "events -&gt; function" and you have to return/unwind your stack to hand control back to the runtime. Whereas in Go, the runtime stores a mapping "events -&gt; execution context" and the runtime parks and unparks you automatically. Both, in a way, are examples of [continuations](https://en.wikipedia.org/wiki/Continuation), in JS you construct a continuation explicitly, in Go the runtime implicitly creates it for you when you want to block. So, in this way, your example illustrates concurrency: The JS code is *not* concurrent, because JS prescribes that conceptually only one thread can run at a time - so you have to return, to signal that you are done with your processing. In Go, the code *is* concurrent, because each handler can pretend that it runs at the same time (i.e. concurrently) with other handlers and just write for linear execution. Parallelism is largely orthogonal to that. Parallelism is the notion that there are multiple physical runtime threads running at the same time, each doing the thing I described above. This is perfectly possible to do in JS, but you'd need to somehow figure out how to prevent data races, as the language doesn't have any way for you to lock objects or synchronize threads. In Go, we provide synchronization primitives in the language (in the form of channels) and stdlib (in the sync package) and expect the user to prevent data races themselves. Concurrency is a property of *Code* - whether or not your code is written as if it is running at the same time as other code and can pass control back-and-forth between the two. Parallelism is a property of *Execution* - whether or not independent execution contexts of your code actually run in parallel.
**Continuation** In computer science and computer programming, a continuation is an abstract representation of the control state of a computer program. A continuation reifies the program control state, i.e. the continuation is a data structure that represents the computational process at a given point in the process's execution; the created data structure can be accessed by the programming language, instead of being hidden in the runtime environment. Continuations are useful for encoding other control mechanisms in programming languages such as exceptions, generators, coroutines, and so on. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/golang/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
The other thing that leaps to mind is that the program may be emitting on standard error. A lot of programs aren't too clear on the distinction.
No you can't?
They're not being used in either function.
Benchmark. People have done it, and I have read the results. You will be surprised at the crossover point. But you may not believe it until you try it yourself. I am not unaware of the issues... I am _more_ aware of the issues.
&gt; So /u/HankDanger isn't wrong Not being wrong is about the best we can do when it comes to programming, haha.
Yes, they are. `w` is used in both - `r` isn't used in either, you are correct, but that's mainly because the code you posted is toy-code. Presumably, they would parse out an ID or something from the request. And either way: Your code doesn't use it either, so this hardly qualifies as a "difference".
I meant you can remove both parameters from the original code. 
&gt; When using net/http, handling errors is kinda annoying. This is how the article starts so the error handling is the initiation point for the discussion. Personally I find this part more important because error handling is one of the hardest things to get right in a program while http.Handler chaining [has](http://www.alexedwards.net/blog/making-and-using-middleware) [already](https://www.nicolasmerouze.com/middlewares-golang-best-practices-examples/) [been](https://medium.com/@matryer/the-http-handler-wrapper-technique-in-golang-updated-bc7fbcffa702) [beaten](https://medium.com/@matryer/writing-middleware-in-golang-and-how-go-makes-it-so-much-fun-4375c1246e81) [to](https://cryptic.io/go-http/) [death](https://husobee.github.io/golang/http/middleware/2015/12/22/simple-middleware.html) and should be common knowledge by now. &gt; The go blog link you posted has no mention of this. Chaining of http.handlers is very common technique showcased in the standard library and this [Go article](https://golang.org/doc/articles/wiki/#tmp_12). As I said, your article is very good because it reminds people how to use the standard library and could prevent a dependency or two. I believe that we need more articles like yours and less "Let's use FOTM-library to build a golang API!" 
It's not. But since we're being pedantic about contrived example code, I thought I'd point it out.
You might be being "pedantic about contrived example code", I was trying to point out genuine issues I perceive about what you are suggesting. But yeah, whatevs.
&gt; But, if they are not, then yes, for the 2nd request, a new goroutine will be spawned. Both goroutines will run concurrently and will be handled according to how the code is written. so how exactly they will be running in my example? the first goroutine is waiting for a response from 3rd party service. At the same time 2nd goroutine created with another request to the same 3rd party request. So will 2nd one start doing smth only when 1st one finished (received a reply from the service) OR 2nd one can start doing its stuff while 1st one is waiting for a reply?
No, you're being dismissive and trying to disguise it as inquiry and positive criticism.
https://github.com/qbecker/goprocess This little package does what you‚Äôre asking for. 
You can take a look on my goenv project (project/directory manager, with golang and python support, combination of ideas from projects: direnv, gvm, pyenv): https://github.com/mieczkowski/goenv It supports: installation of golang versions (latest or specified), handling GOPATH env var, and as addition: possibility to create python virtualenv for project (maybe in the future: some additional features and languages ;-) ). Example usage: goenv create my_project --golang (to enter: goenv use my_project) [my_project] goenv init git@github.com:some/repo.git (or shortly: some/repo - it will complete github address to clone) It will download sources and set default directory to this project. Alternative: [my_project] goenv set --directory=src/some/project and 'goenv use my_project' will go to this directory by default. It is in beta version, so testing and suggestions are welcome ;-) Also documentation is missing, but 'goenv help' will explain installation and usage. I will add documentation soon.
If I'm understanding correctly your process tree is **ytdl-web -&gt; youtube-dl -&gt; aria2** - If so start by making your code simply be this: cmd := exec.Command(command, flags...) cmd.Stdout = os.Stdout cmd.Stderr = os.Stderr If that works, you can replace the os.Stdout with a os.Pipe() and give the writer to the cmd.Stdout and read from it however you like, it's thread safe. Finally change exec.Command to exec.CommandContext so you don't have to select or scan, this simplifies things to: func RunCommand(ctx context.Context, w io.WriteCloser, command string, flags ...string) error { defer w.Close() // this will unblock the reader cmd := exec.CommandContext(ctx, command, flags...) cmd.Stdout = w cmd.Stderr = os.Stderr return cmd.Run() } r, w := io.Pipe() defer r.Close() go func() { // you can use a scanner on R here, send to a chan or print, doesn't matter. } () err := RunCommandCh(ctx, w, flags...) // handle err If at some point it doesn't work make sure that when you run the youtube-dl command directly it works to rule out youtube-dl doing any buffering.
Value Receiver: `func (f Foo) fn(){}` Pointer Receiver: `func(f *Foo) fn(){}`.
Documentation added ;-) 
The key words here are **operation** and **task**. Thank you, for reading and fully understanding the comment. I just wish I had more time and energy to commit to bickering with the less fortunate - they might learn something.
Be less arrogant, watch the video.
Some more reading on the subject - https://justinas.org/writing-http-middleware-in-go/ - https://hackernoon.com/simple-http-middleware-with-go-79a4ad62889b - https://medium.com/@matryer/writing-middleware-in-golang-and-how-go-makes-it-so-much-fun-4375c1246e81 - https://medium.com/@matryer/the-http-handler-wrapper-technique-in-golang-updated-bc7fbcffa702 - https://stackoverflow.com/questions/6365535/http-handlehandler-or-handlerfunc - https://www.nicolasmerouze.com/middlewares-golang-best-practices-examples/ - http://www.alexedwards.net/blog/making-and-using-middleware - https://gist.github.com/nilium/f2ec7dcd54accd23532e82b04f1df7de - https://github.com/rsc/tiddly/ - https://www.reddit.com/r/golang/comments/6fl86p/wrapping_httpresponsewriter_for_middleware/ - https://www.jtolds.com/2017/01/writing-advanced-web-applications-with-go/ - https://github.com/mholt/caddy/blob/master/caddyhttp/httpserver/middleware.go - http://www.akshaydeo.com/blog/2017/12/23/How-did-I-improve-latency-by-700-percent-using-syncPool/ - https://golang.org/pkg/sync/#example_Pool - https://github.com/go-chi/chi/blob/master/_examples/rest/main.go - https://blog.golang.org/error-handling-and-go#TOC_3. - https://www.reddit.com/r/golang/comments/7yt1w2/experiments_with_httphandler/ - https://cryptic.io/go-http/ - https://gist.github.com/husobee/fd23681261a39699ee37 - https://www.reddit.com/r/golang/comments/7umarx/http_input_validation/ - https://gist.github.com/Xeoncross/fe8910ec0eb236bc077844976832e6f0#file-input_validation-md
&gt; You can definitely modify the original data in the slice. You can't, as illustrated by my playground link. If you only have a slice of copies of the original data, you can't modify the original data through that slice. You would either need the original data to live in the slice or you would need a slice of pointers to the original data. &gt; A slice can be seen as a value type that essentially holds a length, a capacity, and a pointer to the first element. Crucially, that pointer is a pointer regardless of what your slice is of (even value types). This means any number of copies of the slice will refer to the exact same sequence of elements, until you perform an operation that requires a new underlying array to be created (eg. resize). Yeah, absolutely. And to be clear, this is consistent with all of my posts. I'm actually confused about why you're sharing it... &gt; Keep in mind that value types are stored with the variable on the stack, and every unique variable will have its own storage (assignment copies that storage). Because the slice value contains a pointer, that pointer is copied and stays the same (so the underlying array is reused, not copied), while assigning single values of a value type (the struct in this case) to a variable will copy that struct, which means the other variables won't be affected when you modify the new variable. Yep, I'm well aware of all of this. :) In fact, my example wouldn't work if this weren't true!
Cool! It's really a shame you can't be as productive on this library anymore. I hope it won't fall into oblivion like other Go libs do when main creator "leaves" the project. This seems to have gathered a nice fan base that also see it being a great library, so hopefully it will still grow.
Here is a list of threads in other subreddits about the same content: |Title|Subreddit|Author|Time|Karma| |---|---|---|---|---| |[justforfunc #29: dependency injection in a code review](https://www.reddit.com/r/programming/comments/7yxdbv/justforfunc_29_dependency_injection_in_a_code/)|/r/programming|/u/campoy|2018-02-21 00:51:10|1| ---- I am a bot [FAQ](https://www.reddit.com/r/DuplicatesBot/wiki/index)-[Code](https://github.com/PokestarFan/DuplicateBot)-[Bugs](https://www.reddit.com/r/DuplicatesBot/comments/6ypgmx/bugs_and_problems/)-[Suggestions](https://www.reddit.com/r/DuplicatesBot/comments/6ypg85/suggestion_for_duplicatesbot/)-[Block user (op only)](https://www.reddit.com/message/compose/?to=DuplicatesBotBlocker&amp;subject=remove%20user&amp;message=campoy)-[Block from subreddit (mods only)](https://www.reddit.com/message/compose/?to=DuplicatesBotBlocker&amp;subject=remove%20subreddit&amp;message=golang) Now you can remove the comment by replying delete! (op only) 
Some interesting Go-fu there! :) However by going under the covers with unsafe pointers, you've gotten around a potential type safety issue by compromising pointer semantics. After an assignment to i, *p does not point to i anymore: https://play.golang.org/p/JYfoaq4rBPz
I'm shocked it took this long for a post like this.
This is fantastic, while I'm thankful for the efforts of dep developers I'll admit I'm glad it will not be the official tool for various reasons that aren't important anymore. Small note, you have a dead link in your [tour]( https://research.swtch.com/vgo-tour), it's relative to your domain and seems to be https://github.com/golang/vgo/issues but that gives me a 404 /u/rsc - is it private?
It's not the standard middleware chaining pattern. I have not seen this pattern described before.
dep*
I am so happy Go is moving towards a more module based workflow. This will solve a huge category of real problems I have working with publicly forked Go code. I know many of us have argued for project/module based workflows for a while and told we were wrong. I think `gb` had something in the FAQ about a philosophical difference. The linked article was a great history summary, but I wish there was more insight into why project based workflows were rejected in the past, but are now part of vgo. Google frequently talks about getting more non Google Go developers. I get the sense the dep team has a lot of core knowledge in this area. Could they have been drafted to take a lead on vgo? The decision to remove the lock file is interesting. I'm unsure how this will work in practice: I think there are a lot of side benefits a lock file has that solve tricky corner cases.
The link is fixed but will take a while to get through the caches. Please use the main issue tracker and use an "x/vgo:" prefix in the issue title. That text about a separate issue tracker is outdated. Thanks. 
Well yeah, obviously :) But FTR, `p` never pointed at `i` - it pointed at the value *enclosed* in `i`. And yes, it won't continue to point at the value enclosed in `i`, because it's a different value. I originally understood the question to ask exactly about that. It would totally possible to use, e.g. a `bytes.Buffer` value in an interface as an `io.Writer`. The actual value would live on the heap and that value would be modified by the calls to `Write`. However, they wouldn't be reflected in the variable you pass in, which I later realized OP intended. Which is why I added to my original answer to explain why what OP *actually* intended doesn't work - because it would require references, which Go lacks (intentionally). I like this question, because to really understand it, you have to be aware of the distinction between a variable, a value and a storage location.
Excellent video! I have been surprised at times how a number of people in the Go community seem to be resistant to DI. I think it's because people seem to associate it with things like Spring sadly. To me it's a fundamental technique for basically any PL and your video would be suitable for people who dont even write Go! 
Doesn't using the minimum suitable version fix this problem, at least in theory? No module should ever be updated automatically, unless some other change to dependencies requires it, so the dependency versions are essentially locked in until you make such a change.
it's been clear to me for a while that dep was not going to be "it", and while opinions will differ, i think it's the right call. this is a much-delayed step, but it almost surely marks the end of the churn. cheer up!
Glad to see this! I'm still digesting the details, but to comment on https://research.swtch.com/cargo-newest.html Cargo does not use the latest version. Saying toml = "0.4.1" is the same as saying toml = "^0.4.1" NOT saying toml = "=0.4.1" which is what rsc would guess. This decision was made because `^` is the most reasonable default; over-use of `=` destroy's Cargo's ability to help you upgrade, given that you basically asked it to not think about it at all. Further, it would significantly bloat binaries, as this would mean many more duplicate versions of packages in your project. Basically, idiomatic use of `=` is only in very specific situations. We could have required that you always specify some operator, but we also like reasonable defaults. Writing `^` everywhere is just more typing. The transitive dependency issue isn't any different, really: that's due to said packages also not using `=`.
Sure - but I mean, what happens if a library's upstream is sketchy, or if someone replaces the git repository to serve bad code. If I'm simply locking a git tag, there's no way to know if the code is the same. This is why the post talks about proxies, so an organization can control exactly what source code is being served. Something that people tend to do as well is lock with git commits, which serve as checksums of the repository's contents at that tag. My point is that, from the point of view of someone who develops side projects, being able to use commits would be much easier than having to set up a proxy.
Hey Steve, I've got moderate experience with Rust(several projects, thousands of lines) and this is new to me. I think it's a great idea for all the reasons you outlined, but maybe it isn't adequately communicated? I think a point should be made on pages like https://doc.rust-lang.org/cargo/guide/dependencies.html to call this out in a very clear and hard to miss way since it's a divergence from most other popular package managers.
[Reposting from HN] Hi. As I said in that page, I do know that cargo is working as designed, and that "0.4.1" is the same as "^0.4.1". My point is maybe a little more subtle, that cargo takes the newest allowed under the constraints, so given "^0.4.1", it has a choice between 0.4.1, 0.4.2, 0.4.3, 0.4.4, and 0.4.5, and it takes the last. When you're adding a new direct dependency, taking the latest is almost certainly right. But when you're pulling in a new transitive dependency, I think taking the last is problematic: it seems much safer to me to take the one closest to what the author of that code tested with. I'll elaborate more on this in a post tomorrow. For what it's worth, I think I do understand what cargo is doing, and why, and I completely respect that approach. I just think this other approach might have some different properties worth exploring. As I've been working on this I've been using cargo as the gold standard, really. If the end of this all is that people say Go's package management is as nice as cargo, then I will be very very happy. A long way to go yet for sure.
[Reposting from HN too, haha &lt;3] To be clear, I don't think you don't understand it; I'm afraid that the way that you've worded it means that others won't understand it. I also very much don't think you should cargo cult! As munificient said above, this is a Hard Problem, and there are a lot of options. In some senses, I'm glad you're not just copying things, as well, that's how we all learn. 