I find myself going back to A Tour of Go often for stuff like type assertions. Really concise examples with good explanations, what more do you need haha
I'm gonna ask a few dumb questions, think of me as a [rubber duck](https://en.wikipedia.org/wiki/Rubber_duck_debugging): 1. The sysops/go-check.git and bgolway/go-check.git are exactly the same? `diff -rq /Users/bgolway/go/src/github.company.co/sysops/go-check.git /Users/bgolway/go/src/github.company.co/bgolway/go-check.git` 2. Does `main.go` at sysops/go-check.git import github.company.co/sysops/go-check.git/check-megacli/lib? 3. What happens if you `cd /Users/bgolway/go/src/github.company.co/sysops/go-check.gitcheck-megacli/lib &amp;&amp; go vet`? 4. What's the output of `echo $GO111MODULE`
Is this true? I hope not, I thought they still considering how to implement it
I realize I'm not the most prolific or advanced Go developer but I still don't understand the big deal with generics when interfaces work so well. It's annoying to occasionally rewrite functions to accept different primitives but for the most part it's not a big deal
What does `go.mod` in chaincode-common look like? Because you have the `replace github.com/user/chaincode-common =&gt; ../chaincode-common` line in chaincode's `go.mod`, it might work if you use imports like `ccerrors "github.com/user/chaincode-common/chaincodeerrors"` https://groups.google.com/forum/#!msg/golang-nuts/1nYoAMFZVVM/eppaRW2rCAAJ
It was actually a missing } in my conditional statement, which the linter indirectly notified me of, probably because I had a lot of nested curly braces for conditionals and and for loop. I had already fixed it, but over-wrote it some how, so it needed to be fixed again. Thanks for the attempted help though.
This might mean that goroutine stacks could be allocated more efficiently. Goroutines are supposed to be reused so repeated stack growth like this doesn't happen. After a while, if the system is working, there should be a pool of goroutines with appropriately sized stacks, so this issue won't show up.
`setCityAblaze`
[removed]
[removed]
[removed]
[removed]
[removed]
[removed]
[removed]
I'm quite comfortable with slices. A slice of an interface might get you all you need. You might occasionally need a loop instead of a filter method like you'd see in Typescript or many other languages, but it doesn't bother me.
Interfaces. But you have to write wrappers to bring your own types.
So you have to write "Collection objects" that match the collection interface?
Equals operator is broken?
Has anyone (other than Brad Fitzpatrick and people who liked his recent tweet) spotted the Easter egg in the go1.11.11 release yet?
A = 1 B = A A = 2 Is a compile error.. unless you explicitly mark A with a ‚Äòmut‚Äô declaration when you init the variable. Variables in Rust are implicitly immutable.
Ooh you're talking about the assignment operator, I thought u meant `==`. If you put a let before the assignment you can shadow variables without declaring anything as mut and it probably optimizes to the same code in this example.
Duh! `RTFM`... `go list -m -u all`
He explained the reason why, I don‚Äôt see how that is broken...
That's not broken, it's intentional. Variables in Rust are immutable by default.
Something tells me that 'lost his shit' meant he carried on politely conversing about his preferred coding language.
As others have said, just building things is often the best way to learn. If you don‚Äôt have anything you are looking to build right away maybe try https://gophercises.com/. The exercises do a good job explaining things that you will encounter in most applications.
It is absolutely impossible to write non-trivial Go programs without using "generics", or "parametric polymorphism". Slices, maps, channels, the `append` built-in - all have parametric polymorphism baked-in by the compiler. When people say they don't "need generics" in Go I always get really, really confused. What's wrong with the special-cased types that have been in the language since day 1? Is the fact that you can have map[string]int` and `map[int]string` being distinct types with all the benefits arising from that them somehow confusing, or unreadable? Would you rally prefer it if both were instead `map[interface{}]interface{}` with you having to do type conversions manually and crashing at run-time?
Ok,thank you.
That's his bad attitude ,I like both rust and go
Yeah, that's really easy. I'm giving you another one that's easy to understand. `go get $(go list -f '{{if not (or .Main .Indirect)}}{{.Path}}{{end}}' -m all)` Take a guess at what it does.
It‚Äôs friendly banter.. I totally see why some people have a boner for Rust.. my boner is for Go, I just think it‚Äôs more readable / elegantly designed.. and the standard library is out of this world.
Once you understand it, it groks. It‚Äôs broken because that‚Äôs what pushes my coworkers button.. I say x, he does y. I like how deterministic my workplace can be.
You can say that for every level of abstraction.
I agree in standard library , but iterators and syntax part got my heart in rust , maybe just iterators , if I need something really really fast and it uses just math algos I'll take rust , for networking and web programming it's golang all the way
Go lacks a few features but I still really love it due to visual aspect of the code, the way code looks makes consuming it easier. Also it is easy to keep code in 120 columns in contrast to Java where it is tedious task and makes you break into way too many lines in single file.
I've been wanting a more detailed explanation to what you are mentioning here. What can generics do that interfaces cannot? what are the trade offs?
That's not broken, that's a feature
If he couldn't clearly explain that what you said makes 0 sense, he isn't a rust developer. That's like page 2 of The Book.
They are
Yes, no one said that - the LACK of them is.
I'm genuinely curious about how Rust's concurrency story is better than Go's? The only dimension I can imagine this being true is safety.
Unfortunately, it seems the app cannot be used in a cloud environment such as Google AppEngine. The reason for that is that you cannot provide your own http.Client - it's hardcoded to \`client := &amp;http.Client{}\` in the code in a lot of places.
I was not so smart but had the confidence to comment apparently üòÄ
Make me a reusable data structure
Since Go is strictly typed language, currently for each argument type you have to implement different interfaces. For example consider below code snapshot: // Returns the keys from a map func Keys(m map[K]V) []K // Merges multiple channels into a single channel func Merge(chans ...&lt;-chan T) &lt;-chan T In some way it could be similar to Java Generics or C++ Templates however Go will only use generics (draft proposal for Go 2) in special way so as to fit in Go design: * Go wants to add a way to "abstract away needless type detail", such as the Keys and Merge functions in the previous section. * They do NOT want to target things such as special implementations, like their example of having a general Vector&lt;T&gt; and a special case of Vector&lt;bool&gt; which has bit-packing. * They do NOT want turing-complete templates (like C++) or type erasure (like Java), or weird cases that reveal how the generics system works internally. The generics implementation should fit smoothly into the language (looking at Java again with generic array types...). * Generic type information should be accessible in both the compile-time AND run-time.
&gt; ...by simply looking at the signature of functions which is how checked exception works in Java. Of course Java also has the thing called RuntimeException that is not part of the function signature but the overall design of exceptions is explicit. The thing that java does wrong is making throwing exception so taxing that people avoid using it to the extend they should (having a custom exception for every path of the outcome). Again this is a flaw of Java not checked exception as a concept.
When I talk about Go, I introduce it as a language from the 22nd century.
[https://learning.oreilly.com/videos/ultimate-go-programming/9780135261651](https://learning.oreilly.com/videos/ultimate-go-programming/9780135261651) Video tutorial by William Kennedy, well-known co-author of Go-In-Action series. As Go-In-Action is little outdated one (2015) this one aligns with more recent Go version.
I don‚Äôt know man, everything worked fine when we were using dep.
Amazing
lol you are full of shit my man
Apart from readability and avoiding copy-pasting I have one other reason to prefer generics before interfaces - All `interface{}` parameters of functions are automatically boxed. You are paying a heap allocation every time you call a function with an `interface{}` parameter even if the value is `bool`, which gets us back to copy-pasting for different types.
Well safety is pretty big in concurrency. I never used Go, never even looked into it but Rust also has stuff like parallel iterators with Rayon for example
[removed]
`\n` is not an empty message, it's a message containing 2 bytes
I think Keybase is the largest app using gomobile.
What's it use for the interface?
It's just used for the backend that's shared across all platforms, the frontends are either Electron on desktop or React Native on Android / iOS
IMO, you shouldn't clutter the usage output by repeating the usage as-is for each alias but instead only use it as-is for the first one and make the others say something like `"alias for -" + names[0]`. Also, since such a change would treat the first name special and since it probably doesn't make sense to give zero names I'd change the signature to something like: `func Bool(value bool, usage string, name string, aliases ...string) *bool`. (Or perhaps leave `name` as the first argument so the signature differs from `flag.Bool` only with the extra arguments). Also, I don't think a command should have multiple aliases for the same thing (unless it's for compatibility). Simple short options (like -c and -r short for -config, -recursive) is probably fine but both -r and -R is just polluting the space of single letter options for no reason. (I realise that was just an example but I'm suggesting the real world use case is to occasionally have just a single alias). Personally, for any tool I was writing instead of adding yet another dependency if I wanted to this I'd just do something like: config := flag.String("config", "/etc/myconfig", "location of config file") verbose := flag.Bool("verbose", false, "enable verbose output") flag.StringVar(config, "c", *config, "alias for -config") flag.BoolVar(verbose, "v", *verbose, "alias for -verbose") (I actually have done just this for things like -v).
What if I don‚Äôt want to return the plain error, but wrap it (as I literally always do)?
With generics you can declare "function f takes 2 arguments a and b. a and b can be any type, but they must be the same type". For instance: function f (a, b T) Where T is not a real type, but a generic one. So, `function foo1 (a, b int)` is the same type as `f`, and so is `function foo2(a, b string)`. But `function foo3(a int, b string)` is not. You cannot do that with interfaces. For instance, if you want to make a `set` type, youmight want to describe sets of a given type. A set of ints, for instance, or a set of strings. But you don't want the user of your type to be able to add a string to your set of ints. Another advantage, depending on how you implement them: they can be way more memory and cpu-time efficient. If your set is known to only contain ints, the compiler knows that each element of your set is only the size of an int. With interfaces, it has to stores a pointer to the actual value, and a pointer to the type of the pointed value. So your interface-based set of ints is less type-safe, and 3 times bigger in memory, than strictly required. Tradeoffs? It makes the language more complex, and, depending on the way you implement them, can bloat the generated code or dramatically slow down the compilation process. When they are abused by clever programmers, they can make the code so abstract it becomes unreadable to the non-initiated.
That's not equality, that's assignment. And you have the same behavior in go: const ( a = 1 b = a a = 2 ) is a compile error. The only difference is that symbols are constants by default in rust.
I love Go, but another day had to code a quick 10 liner in javascript, and its amazing how much you can do in a page of code in that environment. So the point is: I'm never happy.
Well you got the most upvotes hehe :p
Shows the average redditor doesnt it
The generics discussions are always a complete joke because half the people don't even know what they are. But I was actually not sure if you were talking about the lack of them or not either, so maybe there's some misunderstandings in this chain
Agreed with the usage, it's something I'll look into at some point, but for now I just wanted something simple. The usage I have was for comparability (learning project, rm). I disagree with the duplicate code over pulling a very small dependency. That's kinda the whole point of libraries.
Developer Here! I want to know if this project is worth to continue. As there is no decent alternative to Python-Scrapy on scraping world.
I am certainly criticising that it doesnt have it or deem it necessary. In the beginning I understand their effort of simplicity. But lack of generics blocked me from doing so many good stuff in the past years
Is this project fully completed?
I've been looking for something like this - cheers for making ti! Added your first issue. Things you may want to add to your README: * Why is this better than the competition? * Flesh out your example more so that it's a real world one users can play with
No, I just started It, I posted here to see if its worth to continue developing.
I want to make this best suitable for bigger scraping projects. For example, reusing middlewares, hot-plug data exporting functions, distributed scraping, simple cloud deployment commands etc..
Maybe have a look at [Colly?](http://go-colly.org/)
Maybe have a look at [Colly?](http://go-colly.org/)
Yes, Its pretty good for simple scraping projects. But I want to handle much more sophisticated scraping projects. And colly didn't work for me.
An example that's close to home are streaming libraries like Apache Beam or FlumeJava. There, you have a "PCollection", which is a bit like a channel, but represents a stage in a map/reduce calculation. In FlumeJava, you write things like PTable&lt;string, DataType1&gt; to indicate you've read a key-value table with given types. Then you can apply maps. For short examples, it's fine not to have types: ``` data := readTable(path) transformed := data.apply(TransformData1ToData2()) ``` but as this gets longer (in my experience), it gets hard to keep track of what they key/value types are in the tables, without some annotations to help the reader. In pseudo-go, for long types, it would be a big help to be able to say ``` var data PTable&lt;string, Data1&gt; = readTable(path) var transformed PTable&lt;string, Data1&gt; = data.apply(TransformData1ToData2()) ``` It's hard to given short examples that really illustrate why this is a big win, because in short examples, you can keep all the types in your head. But if you do a lot of complicated things, having the types annotated is a big help.
&gt; I disagree with the duplicate code over pulling a very small dependency. That's kinda the whole point of libraries. Sure, if it's a useful abstraction, complicated, difficult to get correct, etc, etc. But here it's only a single simple obvious line per alias (of which I think there should only be a small number per program) versus a dependency that readers/writers of the code may need to go lookup to verify they understand what is happening. A trivial amount of very clear simple "duplication" (I wouldn't even call this case that) is better than adding complexity.
I'm definitely curious. I've kind of specialised in building ETL CLIs over the past few years, and I'm getting pretty sick of starting from scratch every time I switch jobs. Just from the snippets in your readme, I really like what I'm seeing. Great work!
Please tell us what are these sophisticated scraping features that your project support, that colly doesn't?
Right now, Automatic data exporting to CSV and JSON only. I've been developing this project for 1 week. I'll add new features in time.
lol no generics
Anyway continue for your own learning. That is the "biggest" step. BUT PLEASE, cut the crappy buzzwords out (e.g blazing, cutting edge), they're driving most of the people insane, especially me.
Read good golang codebases. Learn everything you don‚Äôt understand and then try to use what you just learned in your own projects.
Just start a project. I myself want to make a backend for a game wich will communicate with others backends for discord bot or web server through zeromq. A lot to learn actually.
Write and read more code.
That‚Äôs a fair point. How would you like to see this functionality implemented?
Do you have benchmark results for the 'blazing fast' claim?
The examples are actually racy. If you run it with the race detector, it'll complain. So‚Ä¶ don't do this :) The stdlib example notably uses `atomic`, to make the accesses race-free. You should really just use [sync.Once](https://golang.org/pkg/sync/#Once), that's what it's for and it does the correct and performant thing under the hood already.
finally, something i can use these coins for. it's been 84 years.
Sorry, you're right. I changed Github description. But I can't change title in reddit.
Right now, no. But I'll add it
What would be the benefits of your project vs, let's say ferret (https://github.com/MontFerret/ferret)?
can you point to which example race detector complains about? I actually ran the example with go's race detector and it doesn't seem to complain.
What I find to be the hardest part of writing code to be is figuring out what you want your program to do. Once that's in place, the code flows freely. Once you have something you to accomplish, write tests that would prove the functionality. Not all at once, but in bits and pieces, writing the dev code immediately after a small test. That way you also learn how to write testable code
&gt; What can generics do that interfaces cannot? Be type checked at compile-time, and be more performant in certain cases. First let's talk about compile-time checks - Consider the below: ints := make([]int, 10) ints[0] = 10 ints[1] = "foo" go will rightfully complain that you can't do that at compile time: cannot use "foo" (type string) as type int in assignment It can do this because the go compiler understands that the type `[]int` can only contain `int` values, and a string is not such a value. Not only that, though, but go can also understand `[]float32` and other types - even types that you just defined! type Foo struct { x int } func main() { foos := make([]Foo, 10) foos[0] = "foo" } the compiler will tell you that it can't compile this because `"foo"` is a string, not an instance of the `Foo` struct. The compiler understands *at compile time*, and can therefore give you a compile error. It's impossible for you to write your own data types that can work the way that slices do because slices in go are generic. The go compiler does 'understand' generics, and it uses them internally to let you indicate that you want a slice that is specifically for `int` or `Foo` values or whatever, and the compiler can therefore give type errors if you attempt to use the wrong type. You can use `interface{}` to create your own data type which will accept values of different kinds of types, sure: type MyType struct { valueX interface{} valueY interface{} } But using that example code: What if the way `MyType` is supposed to work requires that the type of `valueX` and `valueY` are the same type? The only way to handle that in go would be to require that people create instances of `MyType` using some constructor function you write, and in that constructor function you'd assert the types of `valueX` and `valueY` are identical. ... but this is not the same as what you get from slices - slices will have a type-failure at compile-time, go outright refuses to compile an error of that kind on a slice. In a theoretical go-with-generics you could write something like: type MyType (t type) struct { valueX t valueY t } instance := MyType(int) // create an instance of MyType where `t` is `int` MyType.x = "foo" and that would cause a compile-time error because in this theoretical go you're telling the compiler "this instance of `MyType` is specialized to the `int` type", and the compiler can see that both of the fields of `MyType` must match the type given when the instance of `MyType` was created As for performance: You should be aware that `interface{}` is not 'free', all usage of it has a cost at run-time. When go is dealing with a variable that has the `int` type the compiler can emit very optimal machine code without checking anything - since the compiler knows exactly what an `int` looks like in the memory and what CPU instruction can work with it most efficiently and correctly it can just do it. If a function accepts an `interface{}` type, though, the compiler only knows that the value it's working with will, at the machine-level, be a bit of data with a pointer somewhere else in memory (where the actual value behind the `interface{}` is) and information about the type of the value that's behind that pointer. When the compiler is emitting machine code for a function that takes an `interface{}` and does some type assertions the the machine code needs to essentially work with the metadata in the `interface{}` to ask "what type are you?" and check it against your type assertions, then it has to follow the pointer to another part of the memory of the program to actually read the value behind that `interface{}` Let's use an example with the theoretical go-with generics again: func addValues{t type}(valueX t, valueY t) t { return valueX + valueY } a := addValues{int}(10, 20) b := addValues{float32}(10.0, 20.0) In this case the compiler knows that the first time we want to add two `int` values and return another `int`, and the second time it knows we want to add two `float32` values and return another `float32`. Since the compiler knows how to type-check and make sure that when we ask it to add two `int` values it'll only actually compile if we pass in `int` values it can write machine code for that function that's extremely simple - it'll just be the machine code to add two values of `int`. The `addValues` function specialized for `float32`s can't use the same machine code since adding two floats is different at the machine code level, but the compiler can just keep track of the fact that when `addValues` is specialized on `int` values it'll use one version fo the function, and for `float32` specialized calls it'll use another function. If you write this in real go (with `interface{}`) the machine code that's emitted has a lot more stuff to do when your program is running: it has to take the two `interface{}` values, check what their types are to know how to actually add them together at the machine level, it has to follow the pointer to the data elsewhere in memory for each of the values, and then it has to take those values behind the pointers and actually add them the way it knows it right for adding those two values. *TL;DR* generics can let you get better type errors and essentially asks the compiler to do the copy/pasting for different types for you instead of either having to manually specialize your functions or using the less-performant and not-compile-time-error-raising `interface{}`. The cost of the compiler doing this is that the compiler takes longer to think about things, and some people argue generics are harder to read than code that only works on concrete types, even if you have to manually copy/paste sometimes.
Rust is built around concepts like immutability and preventing incomplete data representation. If you don't understand something, try learning first instead of calling it broken. Maybe you'll learn more about Go in the process.
This is a paraphrase of Bjarne Stroustrup from his book, "The C++ Programming Language" which may be applicable to your question: * Know what you want to express * Take a look at how others did it * Practice
There's rarely a good reason to abandon a project. Writing your own web scraper sounds like a pretty fun one, too. But the standard library has CSV and JSON encoding tools that will certainly be very well tested and familiar to most Go devs. The great thing about open source is the ability to contribute to existing popular projects instead of dividing and reduplicating efforts. If your goal is to learn or even build your resume, then don't stop working on this, but I don't know if it's worth pursuing contributors.
Are you fucking retarded?
Try go-mod-outdated https://github.com/psampaz/go-mod-outdated
&gt;Edit: I am an idiot That's why you use Go.
OP (Endtest) is spamming up tech subs, every day with multiple accounts [1,](https://www.reddit.com/user/boss_scarbos) [2,](https://www.reddit.com/user/dragnea_presedinte) [3,](https://www.reddit.com/user/llupei) [4](https://www.reddit.com/user/wernerklaus), [5](https://www.reddit.com/user/jos_cu_klaus), [6](https://www.reddit.com/user/sa_vina_werner) with focused self promotion spam like this that clearly breaks [reddits self promotion rules](https://www.reddit.com/wiki/selfpromotion) See for yourself. Vote and report accordingly.
Assinging `arr` is not guarantueed to be an atomic operation. The first check (before acquiring the lock) could read a garbage not-nil value if it were to execute at the same time as the initializing thread/goroutine.
Why the hell are you promoting it as a "blazing fast" tool then?
Honestly, this feels a bit junior and more of a learning exercise. You mentioned Colly doesn't have some of the features you need like CSV/JSON. My understanding is that Colly is a framework but could work with these. If you need something not possible by the framework, I'd recommend opening a feature request to explain it, then code it. That way your features will be used by a lot of people and in turn you get to use a well maintained project. One advantage contributing to different project give you us code review. Your projects doesn't seem to use errors much (log.printf and return), and has a lot of code that someone learning would write. For example, the Do() method should be broken up in at least 2 methods. One with the semaphore acquisition and one after release. Then in the first method, use defer() instead of manually releasing it in every return statement. The "blazing fast" experience you get is a byproduct of Go; not this project's advanced performance tweaking... Don't take this the wrong way, I'm sure you learned a ton. You'd probably learn as much and with peer review/feedback when you send pull requests.
I haven't used colly in a while but if I recall correctly it seemed pretty simple to export to CSV or JSON in a scraped callback. The only problem I had with colly is that it doesn't support a real headless browser yet (or didn't when I was using it). That's fine for some scraping projects but not all.
The very first. Saving that to `race.go` and running `go run -race race.go` gives ================== WARNING: DATA RACE Read at 0x000000511090 by goroutine 6: main.getArr() /tmp/race.go:12 +0x47 Previous write at 0x000000511090 by goroutine 5: main.getArr() /tmp/race.go:22 +0x105 Goroutine 6 (running) created at: main.main() /tmp/race.go:30 +0x5a Goroutine 5 (finished) created at: main.main() /tmp/race.go:29 +0x42 ================== Found 1 data race(s) exit status 66 Using `go version go1.12.5 linux/amd64` I'd say that the other examples should be racey too, though I haven't tried them specifically.
Lol
an hour!? you ask too much.
CSVs are comma separated values( which you already know of course) and as such will return both values e.g [0][0] string(before the comma) and [0][1]string for after. You can go about it by looping through the [][]string returned value and storing the data with structs. You can check the ‚ÄúparseRecords‚Äù function in [this](https://github.com/spaceCh1mp/quizApp/blob/master/quiz.go) code.
That's a slice of string slices, here, all the rows and in each row all the fields. ss[1][2] is the third field in tge second row (index count fron zero).
Interesting. That example is from the wiki itself. I didn't think of double checking it. can you try running the examples after that?
that is why the second check exists. as /u/TheMerovius pointed out, the first example has a race. However, I believe it's because of the globally shared mutex rather than DCLP itself. This can be confirmed by running the other examples through the race detector.
I do not really want to affect your opinion on this in any way. It's just a pattern I see reasonably often: 1. Someone writes a piece of F/OSS. 1. They heard GPL is _the_ license for F/OSS. 1. So they pick it without actually putting some thought into what repercussions a particular license would have on that particular piece of software, and what will be the trade-offs with other licenses out there. As one example regarding GPL, consider that the most used Go implementation (that one dubbed `gc` and available for download from &lt;https://golang.org&gt;) produces statically-compiled executables, and the GPL has pretty clear stance on static linking‚Äîfor instance, see [this](https://softwareengineering.stackexchange.com/a/167781/303695). Another well-known property of the GPL is that while you're allowed to _privately_ combine GPL'ed code with non-GPL'ed, you cannot legally _release_ the combination‚Äîunless you somehow license this whole combination with the same (or higher) version of the GPL of the GPL'ed part of the code. And this is chiefly the reason why enterprises try to steer clear from depending on GPL-ed 3rd-party libraries in their code bases: their lawyers are aware of the fact that in some unknown circumstances in the future the code base which makes use of a GPL-ed piece of code might either require open sourcing that code or would require rewriting that code to instead depend on some other non-GPL-ed piece of code with comparable functionality. What I said _does not mean that *GPL is bad,*_ of course, just that it has a set of properties which may shine in some settings (as an example, the fact Linux was GPL-ed is beleived to have contributed to its success) and not so in another ;-) Hence I advise you to study the subject matter better.
Rust supports any style of concurrency (either directly or it's quite possible to do so in userspace), go is very strongly pushing you into the CSP style with its first class support for channels and even special syntax for cooperative mutlitasking via these channels. That's great for many use-cases, but it is less good (or outright precludes) usage in certain scenarios. Rust will support the go style CSP, if not as 'first-class'ly or as prettily, but it'll also support all sorts of other things more readily (OS thread based concurrency, single-threaded or multi-threaded event loops, interrupt-based programming for microcontrollers, no concurrency whatsover, using epoll/kqueue directly, creating full subprocesses, some combination of all the above, etc.) Go's runtime and choice of how to implement concurrency works fairly well in the places it's meant to, but you don't really have the option to escape it if you need to, or at least you can get around it but it's a hassle. I might call go's concurrency more *specialized* rather than strictly worse, though.
Mmmkay
Sorry. I removed it in github. But cant change on reddit.
Seems like there are a lot of unnecessarily negative comments here.. OP, don't waste your time listening to these. Good for you to release a useful tool and from the look of it, quite a well-designed one to boot. &amp;#x200B; This sub used to be quite supportive. Hopefully it gets back to those roots!
If there is a mistake in my blog, please inform me.
lol no generics
Check out: https://github.com/linkchecker/linkchecker I think it is the best out there
&gt; I don‚Äôt use Rust but I understand it kicks the snot out of go in performance "Kicks the snot out of" is pretty strong. I'd expect it to be 2-3x in performance in the general case. But programming languages are generally best understood on a logarithmic scale; 2-3x can be a lot in some cases, but in most cases it's going to be lost below other real time drains the code has. That why Python, at \~20-25x slower than Go for most uses, is still useful for so much. For CPU-type tasks, I wouldn't say there's anything that "kicks the snot" out of Go; it's too close to optimal for anything to kick the snot out of it. "Clearly better" for many things, sure, but you hit the performance wall before you get beyond that. There's a reason why so many fairly chunky network servers are written in Go.
"It depends", but in the general case, yes. Sorting, for instance, did eventually settle on a [fairly generic interface](https://golang.org/pkg/sort/#Interface); you implement that for your collection, and you can get a sort done on it. It's not _that_ intrusive an ask to say that if you want to run an algorithm on something, you may have to provide it an interface to work on. So that's a special case where you don't have to implement your own algorithm on the type you may be using, you can just implement the simple things the generic algorithm needs. But in the general case, your collection object will be implementing its own algorithms. The major reason I want generics in Go isn't actually because I think Go desparately needs "map" and "filter" and all the other paraphernalia to try to pretend Go is a functional language, it's because I want to be able to get some more generic data types beyond slices and maps.
First, Thank you for your kind words. I've changed the code according to your review. Yes, I could just open feature request on Colly, but I thought It'd be so slow as I've so many features in my mind to add. I want this project to be as flexible and extensible as Scrapy on Python. Pipelines, middlewares etc. But adding this kind of things would require compatibility issues on Colly. I want to use fasthttp on instead of net.http to improve performance for example. Thanks for being supportive. I'm disappointed that I didn't see support from this post.
Can you fix your blog? It's too thin to read well on the desktop, the code is sometimes left-aligned and sometimes center-aligned, the font styles and colors keep changing, etc...
Wow, that does not look good on mobile.
I agree with everyone saying here that you should go with what your team has experience in or want to support in the long run. If you know how to write performant code, you'll be able to achieve reasonable speed with both. I've never seen a Spring application handle requests extremely fast (sub 50ms). But that's not because it can't do it, but mostly because the focus of the framework (and developers using it) is somewhere else: they tend to focus on ease of use / ease of development much more. Optimizing for speed has a cost (both in time and money), so most business will look for a "good enough" sweet spot. Nonetheless, the previous place I was working at made the switch from Spring to Micronaut to shave a few milliseconds on all the reflection / runtime stuff. It's also much more lightweight. Micronault doesn't "do everything" and that's a good thing when you want to focus on performance. The place I work at right now serves hundred of thousand of requests per second in Java and the response time is between 10 and 15ms, all that inside a Java Spring application with less than 2GiB memory (the memory footprint would be maybe 80% of this on an heavily optimized C app - most of it is user data). So yeah, go with what the team knows and wants. Unless you are aiming for sub 10ms response time, Java and a framework or Go can both take you there.
Did you test it? i ran your code and the web server is running ok. Your only problem is that the log line srv.log.Println("Server is ready to handle requests at", srv.Addr) Is only gonna be printed once the web server is shutdown because ListenAndServe doesn't return until `Shutdown` is called.
aaaarff you are kidding me. I have read over this 20 times. In the working example that log line is above the ListenAndServe(). Thanks... I could have easily stared for hours on that code I guess.
That's the necessary but not sufficient condition. The missing piece is "and do it long enough", where long enough is measured in years for us, ordinary mortals.
I don't even know what should be fast about a scraper. You spend 99.99% of time waiting for network anyway.
Thanks for your support. This was my first open-source project and its 1 week old. I just wanted to see if people cares about this. From those comments I understand, people didn't like my project, but they want it. Why? Because, they commented. They could have just ignore it. I'll continue developing this. Thanks nilslice
It's great buddy, keep it up!
I don't know how much testing you've done, so you may already know this. But Valve intentionally obfuscates the timing of bomb plants in the game state API by plus or minus a few seconds to prevent stuff like this from presenting an in-game advantage. I think it *may* give you reliable timing when you yourself have planted the bomb, however it is definitely not reliable when teammates and/or enemies have planted.
I'm surprised this isn't currently possible. I would think it would fit squarely within Go's structural typing system
&gt;But Valve intentionally obfuscates the timing of bomb plants in the game state API by plus or minus a few seconds to prevent stuff like this from presenting an in-game advantage. Do you have the source for that? I mean if you have a reliable source I will delete the repo :(
Especially since there are other libraries that do similar things. I'm not 100% against hyping your project, but you should try and tell a story about why you think it's so good. Provide comparative benchmarks and the code samples you used to generate them as well as the unique technical and API decisions you've made, and their rationale.
I mean in the docs it is said "Here's a sample configuration file for stage lighting driven from a tournament observer's machine connected to team spectator" so I guess they use the same way to show these timers on tournaments.
JS rendered requests (headless browser) is now supported on Geziyor. Thanks for suggestion.
A lot of these proposals are missing an important part covered by the the original draft - the handling of errors. While the 'check' keyword is great, since it reduces the monotony of having to assign and check for errors, the handle block allows you to actually try and recover from errors. This is why I'm way more excited for the the draft proposal rather than any of these.
I don't know if it's in the documentation anywhere, but my source is that the game state integration was developed in concert with SteelSeries months before it was released as a public API, and I was one of the two developers on the SteelSeries side of the project.
Oh thank you for information ill be delete when get to pc
Sorry to ruin it for you
Create a type like this type mystruct struct { hostname string platform string hostidstring } and then do something like infoStat, err := host.Info() // handle err != nil var s mystruct err := json.Unmarshal([]byte(infoStat), &amp;s) // handle err != nil then you can use `s`. This looks like a detour to me though. Did you check `host.InfoStat` does not have any public fields or methods returning these fields directly?
Spring adds maybe 1ms to the response, without any crazy optimization. It's not that heavy. &gt; Unless you are aiming for sub 10ms response time, Java and a framework or Go can both take you there. +1
@marcofranssen -- what do you think about the following blog post? does it ring true to you? https://medium.com/@goosgoarch/gracefully-shutting-down-web-services-in-go-e8b7f068485
"Spring" is actually quite vague and I could have given more context to better explain my position. A barebone installation add minimal overhead, but it can get quite heavy (from the point of view of fast processing) depending on the number and sent of features one is using. When you add a few security filter, some processor, maybe global error handler, spring cloud with retry mechanism and such and such, it all adds up. Mind you, they might only add 500us of overhead individually, but the problem is that when you aim for high speed processing, adding 3 times 500us of processing is eating 10% of your 15ms processing time budget üòï
Of course not. But you can surely prove me wrong if I'm mistaken ;-) (Please do not forget in your proof to properly handle the "every level" thing, thanks.)
&gt; It is absolutely impossible to write non-trivial Go programs without using "generics", or "parametric polymorphism". Wow, so you have proven the equivalence of Turing complete languages being wrong? Congrats! When are you expecting to be awarded the Turing (sic!) award?
I haven't mentioned the motivation at all, so whatever. I talked solely about the consequences. Have you perhaps something to say in that regard?
These "consequences" shows some misunderstanding.
let A = 1; let B = A; let A = 2; [compiles without error](https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=eba8d9e1f059bfa8c7a24c9aa3aecdc4)
Thanks for this blog article. Out of office right now but when i get back from vacation i will implement this right away. Have you put together a grpc middleware layer for this?
I haven't considered grpc but it's near the top of my list of things to play with. I would definitely be interested in some kind of integration if possible.
Cool. Have you found that generating diagrams from your integration tests end up affecting how you design your code? I think that this could be used to helpful to discover areas in my code base where i have O(n) rpc calls, and to then allow me to better optimize.
I just hope you have a good therapist
I guess when you appeal to the absolutely bottom of the barrel that kind of makes sense.
We have used the diagrams to detect errors in retry logic in some error scenarios - we wouldn't have noticed those errors without the diagram since the tests passed. The mocking support allows you to simulate these error scenarios which is very useful. We are using the tool at a large UK online retailer so it's getting a lot of use :)
You have as much burden as of proof on this thing as I have. Also, I find your attitude extremely aggravating.
I think it's great. Keep at it!!
Yup. Your blog immediately highlights the root cause of my confusion. üëå Found the problem based on the earlier comment. Thanks for sharing though.
I come from &lt;t&gt; century and I concur.
&gt;Did you check &gt; &gt;host.InfoStat &gt; &gt; does not have any public fields or methods returning these fields directly? Exactly these fields reminded me of something I did in the past and if Im not mistaking you are using the psutil library These fields are exported so you should be able to access them directly as pointed out by notimpressed16. [https://github.com/shirou/gopsutil/blob/master/host/host.go#L13](https://github.com/shirou/gopsutil/blob/master/host/host.go#L13) This works locally [https://play.golang.org/p/kRprEOmRk0-](https://play.golang.org/p/kRprEOmRk0-)
Amazing tip!!
Depends on whether you're measuring total love or love per capita. Even the most hated language will win total love if it has enough of a lead in adoption, not a great metric imo.
Not my blog.
It's a great metric for why you don't see much total love. Winning the most love is a different story, and I agree with you.
BTW can the server (ListenAndServe) crash or stop somehow on it's own? By crash I mean, start, work for some time and then shut down. I don't know how if that is possible with net/http but here is a simulated case: [https://gist.github.com/owais/9d79156b2c394cd317519f8039e990d4#file-server-go-L50-L53](https://gist.github.com/owais/9d79156b2c394cd317519f8039e990d4#file-server-go-L50-L53) &amp;#x200B; This stops the server after 5 seconds but the graceful shutdown code does not let the program to exit and blocks indefinitely. &amp;#x200B; I think this can be re-worked to catch the interrupt and as a reaction to that issue the close signal to the server and then exit.
writing programs for real life with very specific needs. this way you cant cut corner and do something the easier way, because that would fail the gaol
ah yeah fair enough :)
Cobra without a doubt. Would link you but internet sucks, just google "cobra github golang" -- you'll like that. Its what docker and k8s and shit use for their cli I believe
We use [github.com/jroimartin/gocui](https://github.com/jroimartin/gocui) at work. It's not bad.
On the other hand, I was able to package a business service, http server, and all client side assets into a single, easily distributed executable and go+makefile made it easier than I had done that with any other language.
You also need just the right amount of repetition in the types of systems you're building to gain some long term memory. Not too much repetition or else the learning stops but enough to gain some proficiency. It's why is advisable to jump around to different projects/products throughout one's career so as not to become stale. Overspecialize and you breed in weakness.
I went through the book and while it's a good overview of semantics it failed to cover the cli tools, project organization, etc. The go wiki has a section on [the go toolchain](https://github.com/golang/go/wiki#using-the-go-toolchain) which has been helpful for me.
Unfortunately OP asked for a CLI in their title but based on description it‚Äôs a CUI package they‚Äôre looking for, which isn‚Äôt something cobra does as far as I‚Äôm aware. Cobra is sweet for CLIs tho.
&amp;#x200B; &gt; is not guarantueed to be an atomic operation. The first check (before acquiring the lock) could read a garbage not-nil value if it were to execute at the same time as the initializing thread/goroutine. &amp;#x200B; Yes, but no. What you're referring to is called a split write, which is guaranteed to not happen on most architectures for data which is up to the size of a word. &amp;#x200B; You're not going to see a "garbage not-nil value", but the memory model also doesn't promise that the other goroutine will \_ever\_ see the changed value without synchronization. In practice, a memory barrier needs to be placed with \`XCHGL\`, which atomic.StoreXXX does for you.
As pointed out by /u/TheMerovius, the examples are not correct within the languages memory model. &amp;#x200B; I recommend a \_careful\_ read of [https://golang.org/ref/mem](https://golang.org/ref/mem). Spoiler: the memory model is makes very few promises.
Yeah my bad. CUI is closer to what I‚Äôm looking for.
I've been pretty happy with [https://github.com/rivo/tview/](https://github.com/rivo/tview/) As for CLI, although I've used Cobra I prefer [https://github.com/alecthomas/kingpin](https://github.com/alecthomas/kingpin)
This is a decent enough example of how Go makes concurrency \_easy\_ (just prefix the go keyword!) but not \_safe\_ (programmers are expected and presumed to not write data races). We do get all the tools in the language and stdlib to avoid data races, but apart from that it feels on par with C's safety with respect to data races.
You Welcome
OOP is shit. Go back to the 90s, OP.
Onlarƒ± bo≈üver akƒ±yor kanka
o7
The only thing worse than a go-to is a come-from, and congrats you figured out how to implement a come-from in a language designed to be readable so that you can't know how the program got into that state! Fantastic!
Cobra. Definitely. I make CLIs for a living.
It's an arbitrary choice by the tutorial's author.
So ‚Äúup to 1Kb‚Äù, but if the client sends less it will still process the packet? Testing it seems to work even though the client only sends a small amount of data. Which makes me wonder how it knows the client is done sending.
There is no significance to the 1024 byte buffer. At the beginning of handleUDPConnection() the code blocks trying to read 1024 bytes into that buffer. The author is trying to indicate that reading from a client and responding to a client can be dine in the handleUDPConnection() function. I have to be honest that this is a pretty poor example. I would recommend reading the docs of Go‚Äôs conn package. That‚Äôs where you‚Äôll learn the most.
Yep, exactly. It can hold up to 1024 bytes, but will trim off any excess. It truncates the slice to the number of bytes read with `buffer[:n]`. I don't think this is a great tutorial for UDP applications...
This article of mine is an overview of various CUI/TUI libraries, but be aware of the publishing date. There may be newer libs available that better meet the requirements you are looking for. https://appliedgo.net/tui ProTip: In general, if you want to find a particular kind of Go package, try these options: * A Github search with `language:go` as one of the search terms (yes, most Go projects seem to reside on Github) * https://libs.garden/go (formerly golanglibs.com) * https://go.libhunt.com/ * https://godoc.org/
Isn't `buffer` actually a slice? I think `[1024]buffer` would make an array.
nice
This is an excellent article. üíØ
Have a look at this very simple Hacker News library: [https://github.com/peterhellberg/hn](https://github.com/peterhellberg/hn) \- it does it well.
Thanks!
[removed]
There's good typography, bad typography and this blog.
Still racey: ================== WARNING: DATA RACE Read at 0x00c000088008 by goroutine 6: main.(*program).Run() /home/mero/tmp/race.go:11 +0x47 Previous write at 0x00c000088008 by goroutine 5: main.(*program).Run() /home/mero/tmp/race.go:21 +0xfc Goroutine 6 (running) created at: main.main() /home/mero/tmp/race.go:27 +0x87 Goroutine 5 (finished) created at: main.main() /home/mero/tmp/race.go:26 +0x65 ================== Found 1 data race(s) exit status 66 The lines the race-detector spits out are "1st check" and the assignment. For real, this is racey and unsafe, don't do it, just use `sync.Once`, full stop :)
&gt; can you try running the examples after that? TBQH‚Ä¶ No. I don't really want to invest that time. I gave you the version of Go I use so you can check it yourself with my version.
&gt; This is a decent enough example of how Go makes concurrency easy (just prefix the go keyword!) but not safe (programmers are expected and presumed to not write data races). FWIW, if you use the *easy* way ([sync.Once](https://golang.org/pkg/sync#Once)), it's also *safe*. It's only if you try to invent these primitives yourself, that you get into trouble :)
I didn't know I was using ETL process. Its superb to know. I'll dig deeper into this process in Geziyor scraper. Thanks for your kind words.
Yes.
√áok saƒüol knk, destek olacaklarƒ±na k√∂stek oluyorlar.
Have any dotfiles anywhere? Does coc.nvim step on vim-go's toes in any way?
I'd also recommend checking out [this gotcha list](http://devs.cloudimmunity.com/gotchas-and-common-mistakes-in-go-golang/). It's a bit more extensive and in-depth
You could say the same about a web browser.
awesome
The signature should probably read `func Resize(imagePath string, constrain bool, width int, height int) (image.Image, error)`
bingo! So simple, thank you :)
I definitely didn't repost this. Sorry about the confusion.
Habe you lolled into Protocol buffers before doing this?
Sure. We use protocol buffers a lot at my company. Doesn‚Äôt fit here for a bunch of reasons. Protobufs are actually encoded in a very similar way to TLV, but require a third party dependency to parse (the proto library). In our case we must support low level clients which we can‚Äôt require such a thing of
Sure. We use protocol buffers a lot at my company. Doesn‚Äôt fit here for a bunch of reasons. Protobufs are actually encoded in a very similar way to TLV, but require a third party dependency to parse (the proto library). In our case we must support low level clients which we can‚Äôt require such a thing of
Some quick comments to whoever made this library - - DO NOT ROLL YOUR OWN CRYPTO. You are doing it wrong. IVs are not meant to be static. Salts are meant to be random, not pseudo-random. Please do not write code like this `rand.Seed(time.Now().UnixNano())` to create a random salt. It is NOT random and highly insecure. As a rule, DO NOT use `math/rand` anywhere in production code. - main.go is not the place to write example code. Please see - https://blog.golang.org/examples - Write tests. - Do not use package paths like `paytm/paytm`. Use the fully qualified path - `github.com/Mindinventory/Golang-Paytm/paytm`
Why?))
I imagine this as one hell of debugging. Also, how do you guarantee that finally is executed? Also, `Do` is not intuitive. Also, what if something panics instead of `trycatch.RaiseError` (which sounds terrible imo)? Panic accepts an interface, recover returns an interface, why can catch only handle an error? Also, there‚Äôs a ton of articles explaining why errors in go are values.
Theres [https://github.com/Jeffail/benthos](https://github.com/Jeffail/benthos), which is a stream processor specializing in more mundane stream tasks and lets you write your own plugins. It makes pretty heavy use of goroutines and channels for vertically scaling work whilst preserving transaction based resiliency. Got a video explaining some of its internals if you're interested: [https://youtu.be/NM7X4PIUQB0](https://youtu.be/NM7X4PIUQB0)
https://mholt.github.io/json-to-go/
I think this question was relevant to yours: https://www.reddit.com/r/golang/comments/bmz3y7/help_parsing_a_weird_json_structure/
I don‚Äôt get it, but ok. But I think the way protobufs encode var length optional variables is appropriate here though. For strings, use their encoding, for numbers, you could look into the (I‚Äôm not joking here) Minecraft protocol, you could use protobufs encoding or have a look into how COBOL / NATURAL handles numbers and use their encoding (they use a fixed length though, so maybe use the variable length encoding). Serializing names is not appropriate here imo, use one byte vor the value Name and/or type, then maybe a frame (as websockets do for example), eg 4 bytes indicating the length of the actual value (or variable length number encoding as in protobufs or the Minecraft protocol), depending on if it‚Äôs variable length, and use -1 as ‚Äúfield not present‚Äù. Then serialize the actual value, and because you framed the value, you know when to stop reading. This even enables you to decode attributes while streaming.
This could have all been in one page. No need to have 1 item per page to get more page views.
Your readme leaves a bit to be desired. I read the whole thing and still have no idea why I would want to use your library, or what I would want to use it for. You might consider adding more words to it to explain what problem you're trying to solve and how you're solving it.
Fair observation. Hopefully, the creator reads your comment and does something about it.
Pattern matching is very useful in many cases, and it's very common in functional programming languages such as e.g. Haskell. I can recommend having a look at it, it's really fun :) I've found it super useful for e.g. implementing compilers. It's ideal where you would normally have to use the visitor pattern in an OO programming language.
This is a really cool library, thanks for sharing! I've been thinking of doing something similar myself, but I guess I don't need to now :)
While you're not wrong, you really lost me at "absolutely impossible". It's only "absolutely impossible" to write _Java-like Go code exactly the way you would in Java_ without generics. It's a bit harder, or rather more complicated, to write non-trivial applications in Go without generics, but I also often find them to be a lot more _unintentionally readable_ than the absolute chaos some people introduce with generics in Java.
He didn't say PHP.
TLV isn't a particular protocol, it's a protocol design technique. Without knowing the context of their use, we don't really know whether or not "serializing names" is or is not "appropriate". For instance, one major thing that impacts that decision is whether or not the communication is internal to a particular system, or if it's meant to be implemented by a lot of external parties. Doing something byte-efficient with names may also make it more challenging to implement external. That's just a for-instance, not the whole set of concerns. I think the point of an article like this is to give some suggestions on how to design a protocol that has some flex to it. It may seem obvious to you, but I've seen a crapton of binary protocols over the years that were clearly written by someone who lacked the understanding of the principles discussed in this post, regardless of whether the specific details would have been appropriate.
Apache Beam now has a Go SDK (https://beam.apache.org/documentation/sdks/go/). Beam is the externalization/open source implementation of Google's internal data processing and pipeline framework, Flume (no, not that Flume). 10/10 do recommend using it over Spark, MapReduce, etc. Disclaimer: I work at Google :)
The Go core team has been publicly considering how to implement them since at least 2011. Nearly a decade later and they are *still* in the consideration phase. Like Pike alluded to in a recent talk, that consideration may go on forever if they don't come up with an acceptable proposal. Generics are not necessarily coming. As always, since the dawn of Go, Generics will only come if an acceptable proposal is found.
Awesome, thank you.
As others have mentioned, it‚Äôs a pretty poor example. With the golang network code, you allocate a slice, then it reuses the slice for efficiency. You want to be super careful because there are major gotchas with slices in Go. Eg, if you just pass that slice to something else and hold onto it, and read a second time, it will be overwritten. Also, if you append more bytes but less than the underlying array size, it overwrites in the original array, which can be super confusing. I would also note that a 1kb buffer for UDP is an extremely poor choice. You would want the buffer to be at least as big as a single packet could be, or around 1500+ bytes. Otherwise it has no choice but to chop larger packets into smaller parts. Often in UDP, individual packets have special semantics, unlike TCP that acts more like an opaque stream.
Is this still somehow related to Minio?
Since you work at Google, is CockroachDB actually similar to Google's Spanner or not quite?
I'm an old Google!Flume user myself, good stuff, but Beam's Go SDK has zero documentation for running on anything but GCP/Dataflow. I keep checking hoping someone would explain how to set it up on Spark or Flink or similar, but no dice. :(
Hmm.. if golang has enough ‚Äúgotchas‚Äù for this post to be more than karma farming then doesn‚Äôt that mean it needs to be designed better?
You *also* haven‚Äôt said why I should use pattern matching or what for.
Yes, in the sense that everything has gotchas and everything can/should be designed better.
Hey! So the newer versions of Beam have moved away from the language specific runner interfaces and into what's called the "PortableRunner" which works across all languages. Take a look at https://beam.apache.org/documentation/runners/flink/ and select "Portable (Java/Python/Go)" a bit down the page, and you should be all set. :)
It really is! There are a few key differences, in particular since Spanner (internally) has evolved quite a bit since CDB has been released, but the core concepts are more or less the same. That being said, Cloud Spanner, the version available to our customers, is fully managed and the real deal!
The struct you want to unmarahal into doesn't really matter (unless you are doing a 1:1 unmarahal). Just define a custom unmarahal method and uyou can use an intermediary struct to convert into youra
Feedback are welcome :)
I don't understand the "value":"somestring" repetition here. Why aren't the strings direct value's of the parent keys?
Not sure about built in tools. For me perf just worked out of box. &amp;#x200B; to run: perf record -g -e cycles -F 10000 ./program arg1 arg2 arg3 to see profile results: perf report -G
[removed]
[removed]
Thank you very much for good words :) I'm really happy that this library could be interested for someone! I'm going to add ANY pattern for matching DEFAULT, and show how the fibonacci sequence could be implemented.
&gt;rand.Seed(time.Now().UnixNano()) what do you suggest instead?
Wait are you saying that a hammer, door, tea kettle, shoes, etc etc etc have gotchas? Yikes.. just accept the criticism and move on, no need to attempt to generalize.. I mean it‚Äôs clearly not true that ‚Äúeverything‚Äù could be designed better in the same sense that golang could. Honestly, it‚Äôs not even true that all programming languages could be designed better and there we would actually be comparing apples to apples. Lisp is a great example of a gotcha-free language, everything there is logically consistent. (‚ÄúGotchas‚Äù being specific facts that cannot be extrapolated from context, but must be learned as an independent item, often due to logical inconsistency)
Normally profiling happens with benchmarks and `go test` or for web services people often use the `"net/http/pprof"` package. For your case I would kook at the doc on https://golang.org/pkg/runtime/pprof/ specifically the part about &gt; To add equivalent profiling support to a standalone program, add code like the following to your main function:
For those who a little lost: * sentry - [https://sentry.io/](https://sentry.io/) * logrus - [https://github.com/sirupsen/logrus](https://github.com/sirupsen/logrus)
Nice
I mean that this list does not present anything much &gt; Lisp is a great example of a gotcha-free language If you have *ever* looked up *anything* up the Lisp language then you have proved
 [Simple New File by Dimitri Tarnavski](https://marketplace.visualstudio.com/items?itemName=fayras.simple-new-file) Then with `Ctrl` + `Alt` + `N` you type `some-folder/main.go`. There are lots of similar extensions. Do the search if you want to automatically create files with the standar package thing: ``````
Go and PHP are more or less on the same level of therapy-inducing.
I am using mutexes in this type of situation because I feel like using channels means you have to set up a channel for read requests, a channel for write requests, and a goroutine that loops forever selecting between the two channels, and then you realize oh it shouldn't loop forever, there should be a third channel to tell it to shut down, and oh what if the goroutine panics for some reason, there should be a way to check if it's running and if not to restart it... and read requests should each send their own channel on which the looping goroutine should send its response so that different read requestors don't get each others' responses. Mutexes just seem simpler in this case.
There‚Äôs a project for ya. Create an application that does that and install it to your PATH.
&gt; Honestly, it‚Äôs not even true that all programming languages could be designed... Lisp is a great example of a gotcha-free language, everything there is logically consistent. Even the designers of LISP would almost certainly disagree with you. It might be more consistent than Go, but this statement is pure tunnel vision. I spoke in generalities because it's clear you're still missing the general principle.
I am not quite sure what you are trying to achieve with all the locks, but for the `Person` part of the code you could use the [testify Mock](https://godoc.org/github.com/stretchr/testify/mock) library to create a `LockMock` which would implement `sync.Locker` . We can assume the `sync` package works correctly as it is in the standard go lib and has unittests itself. So if we use the Mock to show `Lock()` is called, we can be convinced the code is working correctly. Regarding this part: func newPerson(name string) *Person { rwMu := new(sync.RWMutex) return &amp;Person{ readLocker: rwMu.RLocker(), locker: rwMu, name: name, } } please don't do this, this looks ugly, I suggest doing this. (untested code) func newPerson(name string) *Person { return &amp;Person{ locker: &amp;sync.RWMutex{}, // https://golang.org/pkg/sync/#RWMutex zero value is unlocked mutex name: name, } } and use methods `RLock` and `RUnlock` in the `Name()` function Building on my above comment, I suggest creating a new interface like this type RWLocker interface { sync.Locker RLock() RUnlock() } and make `LockMock` implement that, and use `LockMock` for unittesting.
Overall, that looks good. Regular expressions can be used to make it shorter, and the loop body could be smaller. I think you can move those special cases by prepending the comma instead of appending to each digit group. [https://play.golang.org/p/KB3K7tbqxQV](https://play.golang.org/p/KB3K7tbqxQV)
I just tried termui and I ran into a few bugs that I couldn't work around and swapped my code to gocui. While there's less "widgets" to work with, it's very functional. My only complaint at this point is the lack of an error handler function so that I can catch errors and display them instead of the main loop ending.
super ! thanks that seems perfect the extension ! about the Go snippet, how do i call that ?
I like your idea of a RWLocker interface, that does seem cleaner. The separate read and write locks were bothering me. &amp;#x200B; The "Person" stuff is an example, what I'm working on is a way to have a server with domain objects that can be read in memory quickly and then simultaneously they can be "checked out" for mutation as part of a larger logical transaction / unit of work without the read requests seeing changes that haven't been committed. Basically the reads can always go against a cache and just need a read lock, writes go to the database and don't update the cache until the whole transaction succeeds. There are not going to be very many domain objects and they will be read much more often than written, so I wanted to try making a cache system like this. I wrote a simple version with mutexes but for the main version I will try using channels as well and compare the two. I may be over-engineering this but I'm treating it as a learning experience.
Is*
yes but dont think i can write extensions in go to vscode :)
Your statements are confusing. First you state... &gt;I said you can. I didn't say you need to (in fact, I said you shouldn't). Then you state... &gt; Again, nothing anyone has ever claimed. So, if there is nothing inherently unsafe about the Sizeof function within the unsafe package then why shouldn't I use it?
No need for extensions. Simply create a file with a path of &lt;foldername&gt;/&lt;main.go, can go as deep as you'd like, e.g. a/b/c/main.go will create the 3 folders (a,b,c) and then the main.go
oh didnt know that was possible ! nice !
This is type-safe: type Collection []int This is not type-safe: type Collection []interface
then i need to create a file first (unnamed - and then save-as ) thats 2 steps to achieve it ,the extension works better
LOL. No. Dealing with PHP every day, they aren't even close.
*Be.
\*Are
um, no, just right click in the explorer and create in one movement.
Affiliate link spam.
I don't think I will read the article after reading this single sentence.
the title is more informative: *Go: How Does defer Statement Work?*
Amn't've
Come on bro he's prolly not a native speaker
This would be a good project to write in Go! You can create directories and files with the `os` package. Use the `flag` package to get arguments from a CLI.
Your loss.
I did not know that rule - I thought that was correct to use ‚Äúare‚Äù with feedback - thanks for the fix!
I wish I had a better english too ^^
Thx, yes, I did not want to make a repetition in the title in reddit and medium, that was not a good idea lol
Tunnel vision is the right word and I agree with you.
I guess I might not be the best at assessing which diarrhea makes the best salad topping.
You use ‚Äúis‚Äù when it‚Äôs singular: &gt; the kid is welcome here You use ‚Äúare‚Äù when it‚Äôs plural: &gt; the kids are welcome here It gets a little more confusing with words like ‚Äúfeedback‚Äù which are considered ‚Äúmass nouns‚Äù, that are singular but encompass a plural number of objects. Another example of a mass noun would be ‚Äúeveryone‚Äù, which would be multiple people but treated as a singular noun.
So come up with a common API for language plugins, so you only have to write language support once to have it work in any supporting editor. Why there needs to be a SERVER here is beyond my comprehension.
That's a useful thing to track! Thanks for the help!
Use `crypto/rand`.
I‚Äôve wondered this off and on for awhile. I know there are packages that work with HDFS. Still, I wish the there were a full on alternative to Hadoop technologies written in Go... but that‚Äôs because I hate Java.
Feedbacks are welcome*
[removed]
I have a bash script that I run manually to push to AWS's Elastic Container Registery. It looks likes this: LOGIN_FILE=$(mktemp) docker build -t container-id . aws ecr get-login --no-include-email &gt; ${LOGIN_FILE} sh ${LOGIN_FILE} docker tag container-name reg-id.dkr.ecr.us-west-2.amazonaws.com/container_name docker push reg-id.dkr.ecr.us-west-2.amazonaws.com/container_name rm ${LOGIN_FILE} Above, "reg-id" and "container_name" are specific to my instance. It would be simple to tie this script into a git-hook.
Literally the first sentence in the readme: At its core, Yig extend minio backend storage...
Because if possible, it makes sense to avoid importing the `unsafe` package. There are environments where your package won't work if it imports `unsafe` and it might unnecessarily confuse tooling or readers.
Looks like a scam, because the \`github.co\` domain is not belong to the \`GitHub.com\`. Seems the collect email addresses or identity thefts.
Very cool, will save a lot of time and hassle!
* Don't do \`os.Exit\` in \`waitForShutdown\`. How are you going to write a unit test for that? * Don't do \`log.Fatal\` in the go-routine. You likely don't need the stack trace, and it's verbose. Just make \`Server\` return the error, and make a simple \`if err := Server()... log.Error ... os.Exit\` in \`main()\`. * These are the same signals: \`os.Interrupt, syscall.SIGINT\` * The comment \`// Create a deadline to wait for.\` is redundant, since that's obvious from reading the next line. Say what you're using the deadline for instead. * I guess opinions differ here, but I try to get the "main flow" running in the main goroutine. So I'd run the shutdown logic in a goroutine instead. Meaning you could just do \`go waitForShutdown()\`. * For unit testing purposes, be sure to do \`signal.Stop\` at the end to clean up signal handling.
Loved the article. By far one of the most elegant way I've seen to describe Go's interfaces!
u/svilgelm You can see the same link on this twitter post, which tweeted via Github's official twitter page :) https://twitter.com/github/status/1139665072618446850
more info: [https://twitter.com/github/status/1139665072618446850](https://twitter.com/github/status/1139665072618446850)
This article is pretty good, but the title is overselling it. The content is pretty basic. Nothing about embedding interfaces or using interfaces in unittesting for example.
&gt;How are you going to write a unit test for that? There are no unittests at all. I agree with /u/tgaz, please refactor your code so it becomes testable.
Sorry, badly worded question. I was curious if this was basically a standalone service that you'd put in front of Minio, or is this a replacement/reimplementation? It looks basically like a reimplementation to me and quite a lot of sourcecode for the API layer actually comes from Minio.
Unfortunately not into node/js but yes there was potentiel for a nice little tool for go
So it's basically sxhkd with a config?
thank you, I did not know that, it is clear now :)
Can someone explain this: ‚Äò‚Äô‚Äô stringSet := map[string]struct{}{} ‚Äò‚Äô‚Äô
Another re-invention of aliases / functions / shell scripts / direnv that are so common on this sub.
I‚Äôve not yet read the article but I imagine this is for fast searching a list of strings by value, unless there is better way of doing this - I‚Äôm a bit rusty on my Go, need to get back on it
Do you mean by default sentry does not take logging into account? I've been looking at a logging solution for my stateless docker swarm.
As you‚Äôre already using Gitlab you could use their CI system and internal Docker Registry üôÇ https://docs.gitlab.com/ee/ci/ https://docs.gitlab.com/ee/ci/docker/using_docker_images.html https://docs.gitlab.com/ee/user/project/container_registry.html
&gt; you could use their ci system In Soviet Russia, their ci system could use **you**! ^(this post was made by a highly intelligent bot using the advanced yakov-smirnoff algorithm... okay, thats not a real algorithm. learn more on my profile.)
It works without X and don't need any config.
That's what I meant, it's sort of got a config built-in. Isn't xinput2 part of x though?
Tipsy-me made a version of this for fun just now: ```python #!/usr/bin/env python3 import os import subprocess import sys def main(args): if not args: # just list lines = { file: open(f'exc/{file}').readlines()[1].strip() for file in os.listdir('exc') } for file, line in lines.items(): print(f'{file}: {line}') return 0 name = args[0] path = f'exc/{name}' if not os.path.exists(path): print(f"No exc named {name}", file=sys.stderr) return 1 return subprocess.run([path]).returncode if __name__ == "__main__": if not os.path.exists('exc'): print("No exc dir", file=sys.stderr) sys.exit(1) sys.exit(main(sys.argv[1:])) ``` Put that on your path and `chmod +x` it. It looks for an `exc` subdirectory from where you are. If you call it without arguments, it lists the first line (after the shebang) of any scripts in the exc subdir. If you give it a name, it executes that script.
Xinput is only needed to enable/disable touchpad, if you're working in X.
But it still requires X to be installed, then? Running or not? I'm not very well versed in the X11 internals, that's why I'm asking.
It's not needed to install X just to make it work, it can handle keys without X. But if you have installed X, you can also install xinput to make touchpad switch key working.
I see. That's neat then!
This seems very verbose for what is ostensibly a wrapper around a handful of escape sequences, but maybe I'm missing something.
&gt; What would this be used for? As the name of the variable says, for a set. And sets are very handy in solving many real-life problems.
Hello, the goal is to be verbose yet provide easy to use functions for developers to start coloring their outputs right away. Yes, it is a wrapper around escape sequences and that is how all the terminal styling modules work, it eliminates the need for you to remember those opening and closing sequences. Currently this module supports 16bit colors but the challenge comes when we move to a 256bit color implementation keeping in mind the terminal support and it's compatibility with all the older terminals and work almost similar along all terminals. There might come a case where we need to fallback to a nearest possible 16bit color when the developer has specified only hex(256bit color) color. I'm also in a learning phase and researching constantly about the solutions and one of the things I came up with is this - https://printzero.github.io/tint/tint_expressions.html. This does seem like an inception of escape sequences but at least it more simpler than those sequences.
Awesome, thanks! This is what I was looking for in terms of newer tooling.
Hi Would you please tell which library you find better than [https://github.com/tarm/serial/](https://github.com/tarm/serial/issues/27) ?? I am having some issue with this library and trying to find a better one
And a good example of the other case is "all" -- All are welcome here.
Like others have said, you can use this pattern for a set: a data structure that stores elements but prevents duplicates. I say "can" because it's more common to use a bool for the value. I think there is a go team blog that mentions it, so using a bool is idiomatic now.
&gt; follow the best Go practices/coding convention &gt; (seems to work) You should have tests so that you can have more confidence than "it seems to work", especially as you make changes/improvements to existing code. One small thing I'd note (although it's an optimisation note and you shouldn't optimise prematurely), is that the book was released [`strings.Builder`](https://golang.org/pkg/strings/#Builder) was added. As long as you're using Go 1.10 or later it should be preferred over a `bytes.Buffer` for building a string. (Another related optimisation is to call the [`Grow`](https://golang.org/pkg/strings/#Builder.Grow) method early on if you know the approximate final size).
Yes, by default sentry doesn't take logging into account, you need to pass it errors manually: [https://docs.sentry.io/clients/go/usage/](https://docs.sentry.io/clients/go/usage/) &amp;#x200B; Thanks for PR, forgot to change the module
I don't know why you don't just use [`testing.T.Parallel`](https://golang.org/pkg/testing/#T.Parallel) and run your tests with the `-race` flag. IMO you should not care about nor test for specific implementation details such as "does this specific method acquire this specific lock" and instead care about and test for the lack of races when used concurrently.
Thank you /u/tgaz and /u/notimpresssed16 . What kind of unit tests do you mean for such a small piece of code? Also, do I need to include stress tests?
Don't do os.Exit in waitForShutdown . How are you going to write a unit test for that? &amp;#x200B; What else do you suppose I must be doing? I want the server to shut down basically. Also, if I return an error from \`go func()\` , go func() error { log.Println("Starting Server on port " + port) err := server.ListenAndServe() if err != nil { return err } }() that is an error. Doing \`\`\`go waitForShutDown\`\`\` needs me to have a (im not sure if theres a name for it, appreciated if you tell me what it is), a \`\`\`fmt.Scanf()\`\`\` to stop it from not ending instantly. Is there a way around this?
Not thay anyone asked, but there's also another way to make a set from a map and that is to use `bool` keys: set := make(map[string]bool) I personally prefer this approach, because it's easier to use: set["A"] = true // set if set["A"] { // ask delete(set, "A") // delete }
If I can plug my own project, there's https://github.com/gcla/gowid - my attempt to port urwid (python) to golang. I used it to build termshark (https://termshark.io). But it's quite new and not nearly as established as gocui and tview.
Almost there.
Interesting, however it gives you more than one way to check for existence, which goes against a fundamental desire to do things in a consistent way. ```golang type fruit struct{} fruits := make(map[string]fruit) fruits["apple"] = fruit{} if _, ok := fruits["apple"]; ok { fmt.Println("yaay") } ``` is far more universal, and the better way imho.
The problem with this approach is if "A" is not in the map then you will get a panic trying to access a value in a map that has no key. To avoid this, you have to check for existence, which is what the empty struct does, but this bool method takes up extra space.
The approach is so good exactly because this is not true :) If an element is not in the map, accessing it will return a zero value for the type. In the case of `bool` it's `false`, which is exactly what you want.
Sure, but the "extra" way is the nice `set[element]`, which evaluates to a `bool` directly (and evaluates to `false` if the element is not in the map at all). With your approach, you always need to asign, then check. Of course, it's not a big deal, just a preference.
you're introducing something that is not conventional, and not idiomatic ..., that's all.
See e.g. https://stackoverflow.com/questions/67299/is-unit-testing-worth-the-effort You mean benchmarks? This just runs at startup, so I don't see why performance would matter. But that depends on your use case.
It's not unidiomatic at all. For example, in the book 'The Go Programming Language' you find: &gt; The struct type with no fields is called the empty struct, written struct{}. It has size zero and carries no information but may be useful nonetheless. Some Go programmers use it instead of bool as the value type of a map that represents a set, to emphasize that only the keys are significant, but the space saving is marginal and the syntax more cumbersome, so we generally avoid it.
Technically, it's legal to ask for a key which has not been set in the map. However, it can lead to panic's if the value that you're asking for is a pointer, and you are subsequently trying to dereference the pointer. For instance, it's perfectly fine for me to do type fruit struct{} fruits := make(map[string]fruit) fruits["apple"] = fruit{} if _, ok := fruits["apple"]; ok { fmt.Println("yaay") } foo := fruits["banana"] fmt.Println(foo) However, if instead my map was of the form ``` fruits := make(map[string]*fruit) ``` Then I would be f***ed :)
I meant like this: https://play.golang.org/p/k7R1iiJEFDl It's still difficult to write a race-free unit test for `waitForShutDown`, but at least it doesn't kill the entire test.
I think transparency in code, and minimal indirection, is more important than whether or not it's cumbersome or not for the developer to type it out. Use some nice IDE that gives you templates that autocomplete, or just learn to type faster ;) Also, the type alias ``type fruit struct{}`` saves a pair of { } and makes it more readable.
Thanks!
please save the reader some work, and paste the file paths, and line numbers to these use cases :)
It seems untrasparent to you just because you're not used to it. I'm kinda sad it's not more widely used, since, as I pointed out it seems to be the originally intended way to make sets and is definitely preferred by the Go team.
Fair point, but as with most things, broadly speaking, there are two camps... those who want fewer features, and less bloat, and those who complain about a lack of features, and want to type less code, but ... it often results in more obscure and hard to parse code :)
Here are some (not all): go/ast/filter.go:430 go/build/build.go:720 go/build/build.go:1584 go/build/zcgo.go:7 go/printer/nodes.go:1328 go/types/lookup.go:108 go/types/methodset.go:116 go/types/resolver.go:214 I typed these out by hand, so there may be a mistake or two :D.
Just want to point out that I can find a lot of uses cases for ``grep -o -R "map\[.*\]struct{}" /usr/local/go`` ``` /usr/local/go/test/fixedbugs/issue7867.go:map[string]struct{} /usr/local/go/test/fixedbugs/issue22781.go:map[*T]struct{} /usr/local/go/test/fixedbugs/issue7996.go:map[interface{}]struct{} /usr/local/go/test/nilcheck.go:map[string]struct{} /usr/local/go/src/testing/testing.go:map[string]struct{} /usr/local/go/src/testing/testing.go:map[string]struct{} /usr/local/go/src/runtime/type.go:map[_typePair]struct{} /usr/local/go/src/runtime/type.go:map[_typePair]struct{} /usr/local/go/src/runtime/hash_test.go:map[uintptr]struct{} /usr/local/go/src/runtime/hash_test.go:map[uintptr]struct{} /usr/local/go/src/runtime/hash_test.go:map[uint16]struct{} /usr/local/go/src/runtime/map_test.go:map[int]struct{} /usr/local/go/src/context/context.go:map[canceler]struct{} /usr/local/go/src/context/context.go:map[canceler]struct{} /usr/local/go/src/context/context_test.go:map[canceler]struct{} /usr/local/go/src/cmd/trace/annotations.go:map[uint64]struct{} /usr/local/go/src/cmd/trace/annotations.go:map[uint64]struct{} /usr/local/go/src/cmd/trace/annotations.go:map[uint64]struct{} /usr/local/go/src/cmd/compile/internal/gc/reflect.go:map[*types.Type]struct{} /usr/local/go/src/cmd/compile/internal/gc/subr.go:map[typePair]struct{} /usr/local/go/src/cmd/compile/internal/gc/subr.go:map[typePair]struct{} /usr/local/go/src/cmd/compile/internal/gc/pgen.go:map[*types.Sym]struct{} /usr/local/go/src/cmd/compile/internal/gc/walk.go:map[*types.Sym]struct{} /usr/local/go/src/cmd/compile/internal/gc/syntax.go:map[*types.Sym]struct{} /usr/local/go/src/cmd/compile/internal/ssa/looprotate.go:map[ID]struct{} /usr/local/go/src/cmd/compile/internal/ssa/gen/rulegen.go:map[string]struct{} /usr/local/go/src/cmd/compile/internal/ssa/gen/rulegen.go:map[string]struct{} /usr/local/go/src/cmd/compile/internal/ssa/gen/rulegen.go:map[string]struct{} /usr/local/go/src/reflect/type.go:map[string]struct{} /usr/local/go/src/go/printer/testdata/declarations.input:map[string]struct{} /usr/local/go/src/go/printer/testdata/declarations.input:map[string]struct{} /usr/local/go/src/go/printer/testdata/declarations.golden:map[string]struct{} /usr/local/go/src/go/printer/testdata/declarations.golden:map[string]struct{} /usr/local/go/src/net/dnsclient_unix_test.go:map[string]struct{} /usr/local/go/src/net/dnsclient_unix_test.go:map[string]struct{} /usr/local/go/src/net/http/server.go:map[*net.Listener]struct{} /usr/local/go/src/net/http/server.go:map[*conn]struct{} /usr/local/go/src/net/http/server.go:map[*net.Listener]struct{} /usr/local/go/src/net/http/server.go:map[*conn]struct{} /usr/local/go/src/net/http/h2_bundle.go:map[*http2serverConn]struct{} /usr/local/go/src/net/http/h2_bundle.go:map[*http2serverConn]struct{} ```
Yes, I was talking specifically about the `go/*` packages. Also, you can find a lot of `map[T]bool` use cases in the packages you are talking about.
Thanks for the hints! I had both benchmark and test code but didn't want to bloat up the text description. But I completely forgot about play.golang; will use that the next time I post something. Cheers.
I think ``map[T]struct{}`` is more popular and more common than you think. For sure people also use the lesser ``map[T]bool``, that doesn't mean it's a good idea. Here's an example of a standard go library that uses ``map[T]struct{}`` ``` go/src/golang.org/x/tools/go/pointer/api.go:map[ssa.Value]struct{} ``` specificall lines 64 - 66 ``` 64 Queries map[ssa.Value]struct{} 65 IndirectQueries map[ssa.Value]struct{} 66 extendedQueries map[ssa.Value][]*extendedQuery ``
I think ``map[T]struct{}`` is more popular and more common than you think. For sure people also use the lesser ``map[T]bool``, that doesn't mean it's a good idea. Here's an example of a standard go library that uses ``map[T]struct{}`` ``` go/src/golang.org/x/tools/go/pointer/api.go:map[ssa.Value]struct{} ``` specificall lines 64 - 66 ``` 64 Queries map[ssa.Value]struct{} 65 IndirectQueries map[ssa.Value]struct{} 66 extendedQueries map[ssa.Value][]*extendedQuery ``
I know it's a bit of buzzword bingo, but BDD is how I approach things that change often. Test the expected external behavior rather than (and/or in conjunction with) unit tests.
Clean code concepts are fairly language independent, IMO, and I think only a portion of your content is go-specific. And I'm not sure that "clean" fully encompasses your views.
Ah that was a nice thread. But Im still not sure what kind of unit tests would go with a simple server. A test for checking whether server is up on a certain call? Like you ping and realise its up? Thats kinda what came to my mind, do tell me if you have other suggesstions. :)
Ah rightt. So testing for multi thread functionality would also be a test.
Add a [trace logger](https://github.com/olivere/elastic/wiki/Logging) to your Elastic client to see what‚Äôs actually going between your client and your server
Thanks for the feedback! I agree that clean code is not language specific. However, I don‚Äôt think that this eliminates the need for a language specific resource. Could tou elaborate on why ‚Äúclean‚Äù does not fully encompass my views? Thanks!
&gt; security stuff ??? Like bouncer at the club entrance? Or more like armed guard in the shopping mal. (Btw: The language is called "Go".)
That sounds interesting. Could you share some more details on that process if you don't mind
I don‚Äôt trust go‚Äôs crypto package, and thus, it‚Äôs security. It‚Äôs just too immature at this point. Doesn‚Äôt mean it isn‚Äôt secure, it‚Äôs just not as trusted. So for external connections, it always sits behind a balancer. Otherwise it‚Äôs fine tho.
There is nothing obscure or not idiomatic about a a map where the default zero value can be used without checking for presence. You are perfectly free to access a map without checking the second value. Usable zero values are recommended. Stop trying to tar people who disagree with you as wrong and with other views they haven't expressed.
I'd argue that it's extremely hard to do TDD without iterative development, they go hand in hand. Your tests should be helping you change the way your system behaves, not hinder it. &amp;#x200B; Typically tests start getting in the way when they are overly testing implementation detail over behaviour. A common mistake people practising TDD make is they think they have to write a new test for every new bit of code. That is \_not\_ what it prescribes, You are supposed to write a test for each new behaviour, which fits very well with iterative development. &amp;#x200B; I have written, and spoke about this and you can find details here [https://quii.dev/The\_Tests\_Talk](https://quii.dev/The_Tests_Talk) &amp;#x200B; And I also have a resource for Go and TDD [https://github.com/quii/learn-go-with-tests](https://github.com/quii/learn-go-with-tests) &amp;#x200B; Good luck
I thought this was an interesting discussion, ... points of views don't need to align, I never said people are wrong or are not allowed to use ``map[string]bool``, I simply don't like it :)
First you said it wasn't idiomatic, and were wrong. Next you implied that anyone who uses it wants to write obscure code and "want more features". Then you're on to whose way of doing it is more frequently used, and if you were to find that went the other way I suspect you'd be benchmarking next. I think you should have stopped at "huh, never saw that before. Not sure I like it, but I'm going to think about it a bit."
Great article, would love to get involved. Awesome initiative!
No, you'd be falling back to to the zero value for the type, which could be perfectly valid. If you've got pointers in a map, there's the possibility of having nil pointers, so unless you check for the item not to be a nil pointer, you're "setting a trap" for yourself. If you check for a nil pointer anyway, you don't need to check for presence.
Awesome! The best thing you can do to contribute, is to give feedback. Whether that be spelling errors, rephrasing, or if you feel something is missing from the article :) Thanks!
Test that `Server` starts a server and that it can shut it down cleanly on signal (or as close to a signal as possible, e.g. by sending a fake signal on the channel). Also test that logging is initialized as you'd expect. Those are the three things your code does, and you should ensure continue working.
Thanks!
Yes. that leads us back to my first comment. &gt;There is nothing inherently unsafe about Sizeof, and it is unfortunate that the only access to such functionality is through the unsafe package.
"Useful gotchas" is an oxymoron.
I can't figure out how this: if _, ok := set[elem]; ok { // ... } is less obscure and easier to parse than this: if set[elem] { // ... } And how this: _, ok1 := set1[elem] _, ok2 := set2[elem] if ok1 &amp;&amp; ok2 { // ... } is less obscure and easier to parse than this: if set1[elem] &amp;&amp; set2[elem] { // ... } Nevertheless, I also enjoyed this discussion and definitely am not pissed at you or anything :)
Is there a document somewhere which explains the principle behind this sort of rate limiting? I mean, I'm familiar with "leaky bucket" / "token bucket" approach, but not this "bitmap".
Hi new gopher! Since go 1.11 there is [go modules](https://blog.golang.org/using-go-modules) which is the go approach of package and version management.
&gt; You are supposed to write a test for each new behaviour That sounds a lot like what BDD is supposed to be. What's the difference between TDD and BDD, then?
Practically speaking there is very little reason to have one, unless you're writing something that explicitly needs to target multiple versions (like, running performance benchmarks after a new Go release or publishing a library that wants to be as backward compatible as possible). There is GVM.
Whereas Python and JavaScript are interpreted languages, Golang is a compiled language. This means that a program that is compiled in Golang doesn't actually need a specific version of the Golang environment installed during runtime. This means that unlike Python and JavaScript, a Golang project doesn't need any support for multiple Golang versions once it's delivered. &amp;#x200B; Golang has a [guarantee](https://golang.org/doc/go1compat) that defines that all 1.x versions are backwards compatible with all 1.x versions that came before. Because of that, there's no real advantage to having multiple versions of the Golang compiler installed - just install the latest one, and all your projects will compile and run the same as they did with any older version of the Golang compiler. The changes between Golang versions actually improve the projects compiled with each new version, due to advances in the runtime and tools - so you actually benefit from always being at the latest compiler version at all time.
From the Gorilla Mux Documentation: r := mux.NewRouter() r.HandleFunc("/specific", specificHandler) r.PathPrefix("/").Handler(catchAllHandler) This should do what you need. Define all your routes and then have this last route as your "else" since everything should start with a "/".
I dont think there is much difference in outlook tbh. I think BDD is more about collaborating more with people in your team to make black box tests. With TDD its still about \_behaviour\_ but also includes behaviours within your system. So you may build a package for managing a bank account and your TDD would drive tests to verify the "behaviour" of that package. That package would get composed with other packages to build a system (e.g) a website which you might write some BDD style tests for.
Hey! I just wanted to say thank you so so so much for taking the time and writing such a great answer. I have written down your suggestions in a book and I'll be going through them step by step. I'm currently learning Go and the basics of Bitcoin, cryptography, and networking. To be honest I don't even know where I'm going with this ‚Äî so I'm super thankful for any advice and recommendations. In closing, I want to wish you the best of luck and good health! Cheers!
Excellent! Thanks for your help and for the extra knowledge!
Thanks!
`map[string]struct{}` looks way hackier than `map[string]bool` in my eyes.
Thanks I will look into the resources you provided. And yes I suppose I fall in that category of trying to get 100% test coverage for my packages. OCD
The .Handler method seems to have a weird spec for HandlerFunc's that it takes. The other handlerfuncs I have written doesnt seem to be compatible as "they dont have a ServeHTTP method" Not sure whats wrong because the r.HandleFunc takes in the HandlerFuncs I wrote
Thank you for the help and alternative solutions; pre-pending the comma indeed sounds like a better approach!
Test coverage can give useful signals but it's harmful to try and chase coverage for the sake of it :)
I don't really know how to debug that without seeing the code, but if you just have a HandleFunc("/", catchAllHandler) as the last route added then that should work as a catch all as well. Also you can use URL parameters and regex to handle the random part of the url like this: r.HandleFunc("/articles/{id:\[0-9\]+}", ArticleHandler). Instead of \[0-9\]+ you would write something like \[0-9a-zA-Z\]+ (or whatever regex handles your random generated URLs). &amp;#x200B; I have to say that I have no idea about Gorilla Mux. I just read your post and thought that it can not be a difficult problem and with just a few moments of reading the Gorilla Mux documentation I was able to find multiple ways to solve it.
Ah so basically I need to have a http.Handler as the argument as opposed to a func(w ..,r..). Thanks for the help!
leaky/token bucket used for traffic shaping requires a predefined threshold. Here it works in blind, shrinks or expands according to response status. You can use "notify" heuristics to reduce quota exceeded responses. No documents were referred while writing it, at least I'm not aware of any.
Should be FileExtension not getFileExtension.. Go doesn‚Äôt use ‚Äúget‚Äù for function names, it‚Äôs implied.
Thanks for the input! That makes sense, I‚Äôll change it :)
Sure
As others already mentioned,a version manager is not required. If you need one, asdf (https://github.com/asdf-vm/asdf) might be worth a look, especially if you use other languages as well, because it can manage a wide range of languages
&gt; in Python and JavaScript where I used to run multiple versions for different projects using pyenv and nvm respectively I think he's talking about versioning the actual Go runtime, like being able to switch between Go 1.11, 1.12, etc.
not solving your specific problem, but just writing a test is a good way to contain a snippet you are working on. the vscode run test thing works great! my boss taught me this. tests dont actually have to be tests, and you can do a lot of your in process work on a function on snippet in the isolated environement of a go test
After re-reading the OP I can see how you could interpret the question like that. It's phrased ambiguously. When I read "pyenv" I guess I stopped reading. If the question was how to deal with different versions of Go itself, it's very easy. Get the latest version and you're good. All released go versions (this far) are backwards compatible.
I almost always use named returns - _especially since `error` is almost always one of them_. Using one of your examples. ``` func (pipe *Pipe) Save() error { if _, err := pipe.writer.Write(pipe.FlushBuffer()); err != nil { return err } return nil } ``` can be simplified to ``` func (pipe *Pipe) Save() (err error) { _, err = pipe.writer.Write(pipe.FlushBuffer()) return } ```
GVM is still a lot less of a pain on Linux than waiting for your distro to add the latest to their repositories or determining if another source is trustworthy. Now that snap packages are common, it might be a somewhat less important point, though.
I'm sure you'll say "Java" or "Rust".
In the same family as rbenv, pyenv and nodenv, there is also https://github.com/syndbg/goenv. It works well.
I thought we were trying to find the best diarrhea, so that‚Äôs going to most likely be between Go, JS, and PHP.
I have the same doubt! Right now, it is the fasted growing language and is being adopted by a number of companies around the globe. Everyone is switching to Go, the community is growing fast and I think it's time for including GDE for Go soon.
The named return does nothing there. &amp;#x200B; They should only be used for docs or with defer imo, I can't see any other good usage for them. &amp;#x200B; [https://github.com/golang/go/wiki/CodeReviewComments#named-result-parameters](https://github.com/golang/go/wiki/CodeReviewComments#named-result-parameters)
Seems like the quoted part did not need the ‚Äúif‚Äù without the named return either. It can be simplified to your code by just moving ‚Äúerr‚Äù from the named return to the return line in your code
func (pipe *Pipe) Save() error { if _, err := pipe.writer.Write(pipe.FlushBuffer()); err != nil { return err } return nil } can be simplified to func (pipe *Pipe) Save() error { _, err = pipe.writer.Write(pipe.FlushBuffer()) return err }
Thanks! Didn't know about this.
Buzzword Driven Design.
Alan Turing, Charles Babbage and Alonzo Church.
Makes sense.
Thank you!
I wasn't trying to find the best anything, I just figured you'd ignore actual diarrhea because you think it smells oh so sweet.
Bare return was a huge mistake, IMO. In anything but the simplest cases it makes it much harder to work out what's happening. Especially if variable shadowing happens, oh gosh - and it's most likely to happen with err! Imagine accidentally returning nil because you used := because you needed access to the non-err value!
Rust is much better than Go, much faster and actually had features. For perf heavy software it‚Äôs what I would use. Not a fan of Java but it‚Äôs less shit than Go. Haskell is what I use for software that isn‚Äôt overly performance sensitive.
My advice when testing external behavior is to stick to "the happy path" and not test every permutation because those e2e tests are the most fragile. Fill in your less important scenarios with integration and unit tests.
You're absolutely right. The article is oriented at newcomers confused by the basic meaning and syntax around interfaces. For this post I'm not looking to get into more nuanced uses of interfaces. How could I improve the introduction to better communicate what should be expected from the rest of the post?
Routers are just http.Handlers that happen to work by examining the Request, then invoking the desired Handler with the incoming parameters. You can do anything you want. Just grab a high-level handler, do your logic, and then call to the desired targets. There's no magic.
Where can I learn about embedding interfaces?
I would first change the title into something like "Introduction to Golang interfaces". That way readers that know the basics don't have to bother. I would remove text in the introduction like this: &gt;Go is an awesome language and *interfaces* are one of its most powerful features. They allow for decoupling pieces of code cleanly to help make components like database implementations interchangeable. They're the primary mechanism for dependency injection without requiring a DI framework. and say something like this (leaving out harder terms that are not relevant IMO): &gt;Golang is an awesome language and *interfaces* are one of its most powerful features. In this article I will talk about how their syntax and basic usage. and optionally &gt;This article is aimed at anyone having a basic understanding of golang who wants to learn more about interfaces. Disclaimer: this is my style of writing, this is not necessarily better, just how I would do it. Sidenote: I don't know if it's very important, because when I read your article the first time I scrolled down straight to the code. I suspect many others have the attention span of a goldfish and don't read the intro either.
i bet it is already being considered. we do have gophercon coming up -- i wouldn't be surprised if this wasn't announced there.
A tip about using "options" parameters for stuffing function arguments, especially if using for non-optional arguments. I suggest never passing in the options struct directly. There is no issue in the code with nil parameters that may actually be required as you refactor your code (i.e. if you add caching to your program, you might need a reference to the cache interface, and it'll be a pain to check EVERY function call to see if you included the caching interface once the API changed, especially if the variables are broken out into multiple lines). Instead, if you want to go down this route, have every Options object have a "Check" method that verifies options are correct and returns a reference to itself, panicking if options are not correct (the point is to catch these issues in tests &amp; not production, so not having to check an error on the method is cleaner). This way you can pass in `Options.Check()` and your unit tests will panic where calls are out of date. Otherwise, you are taking on significant technical debt using the options pattern for any non-optional parameters. In general, I think this is a bit of an antipattern in a statically typed language with modern code editors, as identifying what a variable in a function call is can be as simple as moving the cursor onto it and seeing the type signature for all the parameters. Whereas including in-line defined structs sometimes breaks the editor type declarations. I think the ideal is to use the pattern only for optional parameters, but if mixing required and optional, a trick like the above will be a lifesaver. Of course, make sure you have unit tests in place for any function that within it passes a checked option struct, or you will end up with panics in production.
Run this thing through a basic spellcheck. It is littered with simple spelling errors and it makes the whole thing look lazy as a result.
This [section](https://golang.org/doc/effective_go.html#embedding) of "effective go" on the official Golang website talks about it.
[removed]
Thanks for the links. Think I'll need to read up more on it.
[removed]
Why not update the old repo?
Cool, will do
Don‚Äôt think i understand?
I agree with this point... i had a section about bare returns, which i deleted, as I wasnt too happy with it... I dislike bare returns, because it feels more like a ‚Äúthis is less lines‚Äù refactor, rather than a ‚Äúthis is more readable‚Äù refactor. I value the latter.
I second this and basically everything else in Effective Go. It's only shortcoming IMO is that it's often quite terse and thus confusing as introductory material. For areas of the language where you already have your bearings it helps put things in context and shows what the language is capable of.
[removed]
Thank you so much for this feedback! This is great! I will play around with this tomorrow :) Might have follow up questions by then!
[removed]
Here is a video showing me and olivia speaking [https://www.youtube.com/watch?v=JmJZi9gmKvI](https://www.youtube.com/watch?v=JmJZi9gmKvI)
Why would you do this? This genuinely seems mental to me.
Could you talk more about it?
if this is yours, https://olivia-ai.org/ the button says "host oliva yourself" what happened to olivia? who is oliva? what have we done?
&gt;if this is yours, https://olivia-ai.org/ &gt; &gt;the button says "host oliva yourself" &gt; &gt;what happened to olivia? who is oliva? what have we done? I'm not sure to understand
[removed]
i submitted a pull request
Thanks a lot!
&lt;3 love chatbots
I hope Olivia will become better with the time!
&gt;So come up with a common API for language plugins, so you only have to write language support once to have it work in any supporting editor. That's what LSP is. &gt;Why there needs to be a SERVER here Ok. Imagine that this API is implemented without a language server. The editor can make API calls, for the purpose of code completion, tooltips when hovering, etc. Where does the editor make the API calls? We still need a target that's aware of the code that it's reporting on. You could have the editor itself provide those responses, but then we're back to exactly where we started, and they have to write their plugin for every language individually. Could we have a CLI tool that the editor would make API calls to? Well, yes. But that's exactly what the Language Server is. It's an external program (aware of the target codebase) that responds to these API calls. Is there some other way you could see this working? Alternatively, perhaps the confusion here is about the word "server" itself? We're not talking about some external host or some bloated webserver like Apache. It's just a generic name classifying the software itself, where it responds to API calls for this specialized information.
[removed]
It just generates the interface. You will need to implement it yourself or use a tool like impl which can generate a stub implementation of an interface.
Cool. Is this based on tensorflow or caffe2?
Gophercon had for few years worldwide, but still no news
Not OP, but been browsing the repo. It utilises a fork of [fxsjy/gonn](https://github.com/fxsjy/gonn) \- the neural network itself is created/trained in [training.go](https://github.com/olivia-ai/olivia/blob/master/training/training.go).
It's provided by the official tool, see https://golang.org/doc/install#extra_versions (tl;dr: `go get golang.org/dl/gox.y.z` then `gox.y.z download`)
Yeah, I've also written a short bash script for it, but I'd like to have that automated. Every change of the base image and every push to the master branch should trigger a new build, ideally. I know this is an overkill for such a simple app, but it's not only for this project. I have a few other ideas in mind which definitely require automatic builds after a push to master (and where I really don't want to trigger that manually every time I push something).
Nice work, I've just been browsing the repository and it looks clean and well organised too. One of the repositories I maintain at work is *functionally similar* \- but sadly nowhere near as "*nice*". I see you [forked the GoNN package](https://github.com/fxsjy/gonn/compare/master...olivia-ai:master) \- was there an issue with the upstream version? I haven't done anything with neural networks before, and I'm interested; so I'm just wondering whether I should avoid that package!
Unfortunately I didn't figure out (yet) how to build images (with my free GitLab account, not sure if a paid account is required for this). I can let GitLab build the binary (take a look at the gitlabci branch of the project), but the binary alone is not enough. If you know how to build a complete image and push it to GitLab's registry and could help me I'd be very happy :)
&gt;https://github.com/Pungyeon/clean-go There's a way to give constructive feedback and then there's your approach.
Naked right?
I interpreted that as meaning it seems uncommon to use Java to compile a front-end app around a compiled Go application. And that it would be interesting to hear why Java is the target for the UI instead of either doing everything in Go, or making the front end a web app that is self hosted by the Go application. In general, I don't think it matters if it is Java, JavaScript, Go, Python, etc, in terms of creating a front end. It just means your Go app needs to expose some way of receiving control, such as stdin, command line flags, json/rest api, or grpc. It might be more helpful if you explains your situation better, such as what kind of Go app you need a front end for, and whether you control the source of the Go app.
Ohh thats nice!
It is really difficult for a reader to try and figure out what finally query structure is actually produced. I recommend that you print out the actual query structure that you have generated to find where you have allowed it to produce an array value when it expected only a single object. Also, is this a bug? ``` var monitoringAnswersMatch *elastic.BoolQuery if monitoringAnswersPipeline != nil { for _, query := range monitoringAnswersPipeline { monitoringAnswersMatch = elastic.NewBoolQuery().Should(query) } finalQuery.Filter(monitoringAnswersMatch) } ``` You are only appending the last bool query in that loop.
Thanks for sharing, I wasn't aware this was an official-ish position taken by the Go team.
What about stack traces? Whoever refactors this code is going to have a nightmare for 1.13-style errors.
One thing, you can move to go modules right?
If you don't want to wait for the distro, then installing Golang is as simple as downloading a tarball and opening it, and then setting the path to have the new $GODIR/bin first. The one source of truth for all Golang versions is [https://golang.org/dl/](https://golang.org/dl/). No need to search for any other source.
What are "1.13-style errors"?
Basically, what's currently in the [`xerrors` package](https://godoc.org/golang.org/x/xerrors). The functionality will be built into `errors` and `fmt` from 1.13. By wrapping your errors, you get something close to a stack trace for free. Check out [this Reddit post](https://www.reddit.com/r/golang/comments/biexq0/go_113_xerrors/) about it.
How does it compare to M-x doctor?
I'm dealing with file-system so don't want to make a web app. I don't believe golang frontend frameworks are there yet (correct me if I'm wrong). I've worked with JavaFX before, hence asking this question. I use gRPC in my application for node-node communication. I could probably get away by writing the clients in JavaFX+Java and the servers in golang.
&gt;I don't think it matters if it is Java, JavaScript, Go, Python, etc, in terms of creating a front end This clearly contradicts your first comment, lol.
It is in process right now.
&gt;&gt;I don't think it matters if it is Java, JavaScript, Go, Python, etc, in terms of creating a front end &gt; &gt;This clearly contradicts your first comment, lol. No it doesn't. I'm commenting on the other reply by suggesting that it would be uncommon to write a backend in Go and a front-end in Java, to explain that comment. . But then I went on to say that the method by which one would communicate between the two is not necessarily a Java problem. The solution would apply to various front end language solutions.
Fair enough. I understand it's common as well and that's why I wanted an opinion. I think the problem of communicating between the frontend and backend exists nonetheless. And gRPC would be good enough if I go ahead with JavaFX anyway. But I just wanted to know if anyone's done that before. If given a personal choice, which frontend would you rather have?
It depends on your definitions of "there". There are available native gui options, and there are web based gui framework options. Even if you need to access the filesystem it could be done by delegating to the back end. But I have no idea if the back end is a remote service or a local one. Anyways it doesn't matter. You can achieve your goal with Java by using grpc.
What I'm working on is essentially a P2P based framework. So the client and server as essentially on the same host. The nodes use gRPC to exchange messages and so I think JavaFX would do the job if I use a java grpc stub. What frontend frameworks in golang would you suggest?
No I think your reason is 100% justifiable. To be clear, I have zero issues with your decision to do a Java front-end. It makes sense to use what you know. Again this was really just based on an interpretation of the other comment. Use what you know! I don't dev in Java. So I would choose Go, Python, or C++ Qt. I like Go because it's statically compiled and won't require a runtime during deployment. Python is easy but deployment has more dependencies.
Yeah, it actually really boils down to use what I know.
Oops, you from Google!
&gt;What I'm working on is essentially a P2P based framework. So the client and server as essentially on the same host. The nodes use gRPC to exchange messages and so I think JavaFX would do the job if I use a java grpc stub. &gt; &gt;What frontend frameworks in golang would you suggest? My front end experience is usually Qt so it'd biased. I've tried a couple of the Go Qt bindings. I'm not the best source to suggest other front ends but I have seen some pure Go desktop gui options. And then I have seen people talk about GopherJS+React or other web UI combos. Maybe someone else can comment more on that.
That's not an amazing one, I've not finished my work on olivia-ai/gonn. I forked this just to arrange the code because it's veryyyyy old. Look at tensorflow bindings for go or golearn if you begin! :)
I don't even have to reply you do it for me! :)
&gt;I'm not sure to understand
I think so
Is it broken?
It is possible although I would not recommend it personally. &amp;#x200B; Here's how I would do it: * Clients which want to receive messages \[receivers\] call a server method with a streaming response * Receivers identify themselves by some sort of ID (non-random UUID or anything without collision) * Clients that want to send messages to other clients (senders) call a specific method on the server with the receiver ID and the message to pass * The server has to store every receivers ID and their related stream * Upon receiving a message, the server looks up the stream and forwards the message &amp;#x200B; This would work but would have some significant issues, like: * Each sender must somehow uniquely identify the target client * The sender must be able to handle error cases (Client -x-&gt; Server -x-&gt; Client) * The architecture is not really straightforward &amp;#x200B; Depending on the specifics (e.g. does the sender get an answer, does he wait for it, does he need to know if/when the message was received) I would recommend using a protocol that was designed for message passing, like AMQP (i.e. RabbitMQ). You can also use your protobuf messages you already have. &amp;#x200B; On the other hand a *full gRPC server* in Go isn't really resource intensive so apart from the additional coding setup (and depending on your use case of course) the alternative solution wouldn't be that bad either.
I believe it's a reference to ELIZA, accessible via emacs keybinding.
Any source onto how everyone switches to Go?
Loving it, will finish the last few pages tomorrow, good job!
I've used pyqt before...and I agree that nothing comes close to qt...but at the same time, I ain't a fan of bindings from past experience. I've used JavaFX in one of my projects here - https://github.com/gravetii/wordagam. Just in case you wanna take a look.
Glad it was helpful! Also, IMO one of the biggest topics to be addressed in clean Go is architecture. Accepting interfaces and returning objects makes it really easy to properly isolate packages from each other, so achieving something like an onion architecture works out pretty well. Basically, Go's implicitly satisfied interfaces paves the way for an "inside out" architecture where you define business objects in a core package that depends on *nothing*, wire up inter-object actions in a layer that only depends on the domain layer and defines interfaces for external services, and then write your external services conforming to the interfaces defined by your actions. Then you simply have the "outermost layer" bootstrap the external services and pass them into the actions methods. It's really, really awesome as all your complex side-effect code (depending on external services) has little to nothing to do with your complex business logic, and the entire rest of your application (the actually complex parts relating to the problem domain) can be tested cleanly with stubs. It takes a bit to get used to, as it's sort of the inverse of how people typically go about architecting code, but in my experience, I'd never start another project the classic top down way instead of the inside out way.
A job like this would build the Docker image from your Dockerfile and push it into the registry of your account :) build-dockerimage: stage: build image: "docker:stable" variables: DOCKER_DRIVER: overlay2 services: - "docker:dind" script: - "docker login -u gitlab-ci-token -p $CI_BUILD_TOKEN registry.gitlab.com" - "docker build -t registry.gitlab.com/KopfKrieg/yearprogressbot/yearprogressbot:${CI_PIPELINE_ID} -f Dockerfile ." - "docker push registry.gitlab.com/zerok/gdpr-courseware/backend:${CI_PIPELINE_ID}"
Why are you still using dep instead of Go modules?
No idea, I should look at this more closely
Author dialogowƒÖ gofmt but wanta to promotor Clear code. The biggest reason by forcing same looking code, clean and readable is a decision on camel vs snake case. If author of gofmt decided camel case is the way to go we have to adopt and not dispute it. IMHO Code In go has to be camel case. I don‚Äôt liked it at start but now I don‚Äôt really care that much. You adapt and use it or you don‚Äôt write clean readable code.
There is one source for this. I have been reading alot. Uber, Tinder, Zomato and many other organisations do use Go for some of their services.
Dunno, maybe because the iteration order over maps is not guaranteed to be the same?
What advantage does the map give you here? In both cases you need to iterate over every element and no elements are added/removed so there are no real benefit to using a map. Except for readability, which I find the flatter structure of the list to be more readable but this is mostly a personal opinion.
It takes fifteen times longer to iterate through a map last I checked.
Goroutines do not suddenly panic and die without taking down the rest of your program; the panic boils up [https://play.golang.org/p/9b8ZZBhrcQP](https://play.golang.org/p/9b8ZZBhrcQP) to the main goroutine. &amp;#x200B; There are a few cases where mutexes are definitely a better design choice though; it seems like you still have a strenuous grasp of Go and concurrency, so I suggest you experiment with both. Switching between a channel approach and a mutex approach is no simple task, as the entire design of your app is quite different. Channels lend themselves well to worker models and chained operations, which can more easily race/deadlock when coded using mutexes.
slices is what gotests generates. I'm not about to write the boilerplate myself
Use whatever fit to your case, I think no reason there
[removed]
``` if a, ok := &lt;expression&gt;; ok { } ``` Is very common in golang. That's how most error handling works, for instance if b, err := json.Marshal(object); err != nil { }
Language is hard, by obscure I can simply mean the fact that the bool value is hidden unless I look at the definition of the map, while I can use the "harder to type" method regardless. I would be silly not to think that the bool approach is sexier, it is definitely sexy. But I see potential issues with it, it's hard for me to explain, but imagine code refactoring or optimization down the road, and having to get change all of your bool maps to struct{}. Another point is that struct{} saves memory. https://stackoverflow.com/a/37320521
It was pointed out in the Go Time podcast that this could be an advantage when running tests. If tests fail when running in a different order it exposes fragility in the code.
I mean they use Go but it doeant mean everyone is switching to it
If you've used nvm before, the question is unambiguous, but if not then I can see how it'd be easy to misunderstand it. OP is definitely asking using different versions of Go itself in different projects though.
Agree, but if you want to check that it would be better to pick random permutations (they are enumerable) instead of relying on side effect of compiler‚Äôs implementation of maps.
By everyone I doesn't mean literally everyone. I mean most of the companies are trying Go right now.
The key acts like a description or name for the test. This can be useful, but it's an overhead.
That is what the `Name` field does. It being inside the structure or as a key in a map makes no difference except how the code looks.
The best option is to avoid SOAP if possible. &amp;#x200B; As that's rarely the case, I don't know. Go's encoding/xml parses with namespaces great, but encodes a little bit too verbose. As not all clients made equal, I've had to hack a special replacer for deleting attributes for declared tags, for example.
This is the output I get from the query builder function for one of my request, so the structure of the query seems to be correct { "bool": { "filter": [{ "bool": { "should": { "bool": { "filter": { "bool": { "should": { "match": { "answers.a8DFB0ntZBRCrhIBmFbx.text": "Male" } } } } } } } }, { "match": { "formId": "hHhcLKh9st1vFr8nDY4a" } }, { "range": { "_updated_at": { "from": "36163", "include_lower": true, "include_upper": true, "to": null } } }, { "bool": { "should": { "bool": { "should": { "bool": { "should": { "match": { "answers.a8DFB0ntZBRCrhIBmFbx.text": "Female" } } } } } } } }, { "match": { "formId": "hHhcLKh9st1vFr8nDY4a" } }, { "range": { "_updated_at": { "from": "36163", "include_lower": true, "include_upper": true, "to": null } } }] } } &gt; You are only appending the last bool query in that loop. thanks for that, fixed it. &gt; to find where you have allowed it to produce an array value when it expected only a single object. what I can't understand is where does it expect to have a single object instead of an array.
I and my team are trying out javafx client for a go server. Is that your use case?
You're right. Ok, I also don't see much of a difference and think it's a matter of taste. Slices look simpler to me.
I set the logger and this is how the ES request is logged | ELASTICPOST /response_v2_d41d8cd98f00b204e9800998ecf8427e/_search HTTP/1.1 | Host: 172.17.0.1:9201 | User-Agent: elastic/5.0.81 (linux-amd64) | Transfer-Encoding: chunked | Accept: application/json | Content-Type: application/json | Accept-Encoding: gzip | | 7 | ["_id"] | 0
Im not sure my question was clear. Since I have random URLs that I need to route from, I cant have a track of all those random URLs. So, after the mux checks for all sensible routes like "/something" and "/somethingelse", I need all the random URLs to go to a handler since they didnt match any of them so that I can using that random URL here and route to whatever necessary.
Agreed. Relying on iteration over map for random iteration order also makes it unclear what the intent is behind that code. Unless you already know iteration over map is undefined, it just looks like any other loop. It's sloppy and not really idiomatic.
I learned from your video so if you could just keep making them and spreading them around I assure you something will come of it. Thanks Elliot nice and short video A+
&gt; is GDB my only option? Of course not. Debug prints/logs are available accross languages.
It's only implied if the function is a method of a type. For example; use f.fileExtension than f.getFileExtension. See https://golang.org/doc/effective_go.html#Getters. His getFileExtension is not a method, so IMO, the name is fine and more clear.
* You're fundamentally iterating (once) over it. No random access, so a map adds nothing. * It's shorter syntactically.
it still works if it's all in the same module project |- go.mod |-package-main | `- main.go `-package lib `- root.go or if it's in a different module, look at the [replace directive](https://github.com/golang/go/wiki/Modules#when-should-i-use-the-replace-directive)
Makefiles are notorious for having possibly the worst file format of all time (and for being really slow, but I don‚Äôt think that applies here). When dealing with c/c++ I preferred Jam (much faster, and only a fraction as error prone). I do think it highlights a gap in go, and I see solutions such as bash scripts (goodbye sanity):( I‚Äôd hate to end up with another yml mess or groovy based files (how I loathe you Jenkins and anything gradle) so hopefully it‚Äôs a good they look at when looking at the go tools (that I do generally like).
Consider writing unit tests that exercise the functionality you are building; I used to do what you describe, but when I started in with Go, I realized that unit tests can test basically everything I could test manually, but way faster and it can test everything I've written every time, instead of just what I'm working on now. Throw in some test driven development, and my hobby projects are now way more fun and productive.
I have used GDB with Go - there was a python script that can be loaded in to make pretty prints and goroutines make sense - it's distributed with golang proper. I don't know about other equivalent options, but GDB wasn't horrible.
Yes that's my use case exactly. How long are you in it?
You seem really kinda stuborn at this point. Your first reason, that the bool is somehow hidden. The type of every variable, every function, everything is hidden unless you look at the definition. I'm really not sure how that's a problem at all. The second reason you pointed out is completely invalid. If you really were to change from bool to struct{} (which I'm not sure what the reason could be), you'd just change it. Done. The compiler would show you each and every one of the usages you need to change with type errors. No problem at all. Saving memory, while it's true, it's just one byte per element. The map has a memory overhead on its own, so in majority of cases, optimizing that one byte is an premature optimization.
Know of any material that talks specifically about those separation of concerns in indiomatic go? Package layout examples to the modules themselves?
You can replace many of the bash scripts you might want with small go programs, and use `go run`.
Do the different strategies affect final binary size?
I prefer maps of name/description to test case. The name isn't part of the case. Changing it doesn't change any of the expected behaviours, so I leave it out.
Why not introduce pre-reqs? watch make ftw ;)
nah just a typo he merged the PR already
Can you elaborate me ?
What do you want to say?
Aside from that, solid presentation.
This is the text version linked in the description of the video: https://tutorialedge.net/golang/makefiles-for-go-developers/
&gt;They do NOT want to target things such as special implementations, like their example of having a general Vector&lt;T&gt;and a special case of Vector&lt;bool&gt;which has bit-packing. Not sure what you mean here. Isn't this essentially describing how slices operate under the hood? I.e. slices behave as arrays with addressable data and with some other associated metadata (length, capacity), except for when the inner type is bool.
I prefer [Magefile](https://magefile.org) for this sort of thing. It doesn't require you to have bash installed, which works nicely on Windows environments.
Hello Moduledata! (Just kidding. Thanks for the instructive article.)
There are a couple examples out there for the clean architecture (though I prefer the onion architecture. IMO Bob just rebranded that with different (and worse) naming to claim it as his own): [Example 1](https://manuel.kiessling.net/2012/09/28/applying-the-clean-architecture-to-go-applications/) [Example 2](https://medium.com/@eminetto/clean-architecture-using-golang-b63587aa5e3f) [Example 3](https://medium.com/@hatajoe/clean-architecture-in-go-4030f11ec1b1) The first example has the most detailed description. Personally I think the code in example 3 is the most illustrative, but the author's English struggles a bit.
Last year I went full tilt on a makefile for python projects. The perhaps most reusable part of it are the .PHONY help and helpverbose targets: [https://gitlab.com/mbarkhau/bootstrapit/blob/master/makefile.template#L155](https://gitlab.com/mbarkhau/bootstrapit/blob/master/makefile.template#L155)
Then implement a handler that does that. You can pretty much write in code what you just said, and it'll work. "Routers" aren't anything special. They're just a pattern of handler we tend to use a lot. You can attach a handler directly to a http.Server and call out to any handler you like. If the "routers", which are just a Handler, doesn't do what you want, then write one that does. There is no obligation that a request "must pass through a thing called a router". Here, try this to see if it helps. Write a simple http.Handler that simply echos the URL used to access it. Start a new http Server, and where the Server has the parameter for Handler, pass in your Handler you just wrote. Start the server and point your browser at it. Play with the path in the URL. If you still don't get it, make it so if the url starts with "/abc/", it calls another Handler and immediately returns. Congratulations! You just wrote a "router". It's degenerate and doesn't do much, but it's a router. Now make one that does exactly what you need.
Thank you so much for your response, this was very helpful! What I draw from this is that gRPC is probably not the most ideal way of pursuing this kind of messaging. Essentially I am looking to build a simple chat app that uses a Go backend, but want to build it myself so I don't want to use an XMPP server. I also need to encode a small amount of data along with the actual messages so I was planning on using Protobuf, and gRPC just seemed natural, but it seems as though it is not. Would a message queue be appropriate for a chat application? It seems perfect but maybe I'm not understanding the use cases of an MQ correctly. Would websockets be a better fit for this kind of application? And would I still be able to use my proto definitions?
You can do that true . But it‚Äôs non trivial for instance protobufs use varints to mark tag numbers, have their specific logic for processing length delimited, 64,32 bit for field types , support nested messages etc. When dealing with networking folk TLV is the common solution to this problem. Simple to implement , well known. I really like protobufs , in fact I‚Äôm working on a whole series of posts about them. But you‚Äôre missing the point of the article , it‚Äôs how to implement a common pattern , and where it‚Äôs applicable to use it .
I would look at using an external usb drive for storing your repos if using a Pi, the sdcard can get corrupted. while it's nice to write your own servers and feels good when it works, Gogs is a really nice git server that [works on the Pi](https://blog.meinside.dev/Gogs-on-Raspberry-Pi/) and it has a nice webui plus works with [drone.io](https://drone.io) if you want to do CICD.
I've used both. To be honest, the reason I usually end up with more slices than maps is because when I'm feeling lazy and testing a simple function I'll just use Visual Studio Code's integrated test generator and that uses slices.
As always: it depends. &amp;#x200B; As you are sending mostly text (which can be easily compressed), I would strongly recommend a protocol/transport with compression. gRPC itself supports compression but not all client/server implementations do. If you have much structured metadata, Protobuf is a good choice but I think for a simple Chat app JSON or similar encodings would suffice. &amp;#x200B; For this purpose I would not suggest AMQP because it is aimed a bit more at backend applications communication. &amp;#x200B; My personal recommendation would be to use WebSockets. It's easy to get into and has probably the best support across different platforms. Furthermore I would use JSON instead of Protobuf because of the aforementioned platform accessibility which especially with Protobuf might differ hugely from platform to platform. &amp;#x200B; Some more tips for your journey: * Encryption is most important if you want to communicate over open networks (the internet) or are looking to publish this project. (Have a look at Let's encrypt for HTTPS - there is also a good and easy Go API for it). * Think about what happens when the receiving Client is not reachable (offline, network problems, etc.). How you handle this part makes a big difference in usability. * Use a good (and secure) authentication mechanism especially if you want to store information on the server. * And as for every good project: Look for third party libs. The Go community has many really good projects that you can use easily to get you started quickly (e.g. Gorilla WebSockets if the Go native ones are a bit too bare for your taste).
Your spellcheck is a linter, use it.
So of you can plug the query into your curl request and it works fine, then maybe something is wrong with the rest of the body. Are you able to see the entire request? Does it also fail if you remove the Source()?
okay big guy .... can you help me with this stuff now ?
https://golang.org/pkg/image/color/#Color ``` RGBA() (r, g, b, a uint32) ``` The method of the Image interface returns the 4 pixel values.
Image.rgba{r, g, b, a} for a rgba literal. I just make up a map for a pallet and choose colors out of there. Just reference the map when you need a color. Better coders than me would have better suggestions.
Tell him
[removed]
&gt; Makefiles are notorious for having possibly the worst file format of all time Autoconf would like a word
Also please feel free to try [Gorgonia](https://gorgonia.org/gorgonia) - it's built for deep learning in Go.
Thanks for the response. I think it's something that would have to be offloaded to a jvm.
Thanks for suggestion. I've learned to do that lately, and it's true, unit tests in Go is really nice. Unfortunately, right now I'm working on binding to C++ libraries, and IMHO creating unit tests for cgo package is not really fun :(. That's why I'm trying to use the old way again.
Yep, this is it. Thank you very much !
Cobra? Let‚Äôs you make CLI apps fairly easily. Probably had some examples like that.
Cobra is still the best CLI package that I've used.
Great video!
That's probably fine for a lot of people. It's all preference. I have used Linux for over a decade, and for 7 years it was my primary OS, but I don't necessarily use some important commands often enough to remember the options needed to wget the tarball and untar it, so I prefer to have the gvm tool so that I don't need to Google those things each time I update stuff.
RemindMe! 7 Hours
I will be messaging you on [**2019-06-17 06:25:41 UTC**](http://www.wolframalpha.com/input/?i=2019-06-17 06:25:41 UTC To Local Time) to remind you of [**this link.**](https://www.reddit.com/r/golang/comments/c1dob6/golang_rest_api_with_mux_great_tutorial_for/erd0th6/) [**CLICK THIS LINK**](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[https://www.reddit.com/r/golang/comments/c1dob6/golang_rest_api_with_mux_great_tutorial_for/erd0th6/]%0A%0ARemindMe! 7 Hours) to send a PM to also be reminded and to reduce spam. ^(Parent commenter can ) [^(delete this message to hide from others.)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Delete Comment&amp;message=Delete! ____id____) _____ |[^(FAQs)](http://np.reddit.com/r/RemindMeBot/comments/24duzp/remindmebot_info/)|[^(Custom)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[LINK INSIDE SQUARE BRACKETS else default to FAQs]%0A%0ANOTE: Don't forget to add the time options after the command.%0A%0ARemindMe!)|[^(Your Reminders)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=List Of Reminders&amp;message=MyReminders!)|[^(Feedback)](http://np.reddit.com/message/compose/?to=RemindMeBotWrangler&amp;subject=Feedback)|[^(Code)](https://github.com/SIlver--/remindmebot-reddit)|[^(Browser Extensions)](https://np.reddit.com/r/RemindMeBot/comments/4kldad/remindmebot_extensions/) |-|-|-|-|-|-|
Right. I'm laughing right now.
If that's your form of therapy from overcoming the pain of using Go, PHP and/or JS then I totally understand and hope you feel better soon.
RemindMe! 0.2 Hours
Alpine doesn‚Äôt have bash by default either. If your script is complicated at all, don‚Äôt expect it to work on Alpine.
Okay, I'm a heavy user of the current github.com/pkg/errors currently (and was part of that thread), but wasn't sure what you meant by `1.13-style`. Personally, I haven't had any problem with named errors using `err = errors.Wrap(err, ...)` before `return`.
You can use `go mod replace` to point your app to the local code for your module instead of the remote tagged version.
I while love all these api service tutorial everyone does, but no one ever covers auth/Authz in a microserice environment with service validation. I wish someone would cover that.
You mean like using JWT auth or a third party service like auth0?
Yeah JWT auth and authorization and service verification
no, they're just different ways of telling the compiler where to look for dependencies
Nope
RemindMe! 10 hours
You might want to consider [a different name](https://packer.io/).
Being not so old to doing this, (after all the efforts i put in without this video) I came up with https://www.reddit.com/r/golang/comments/c0tpc8/basic_go_server/?utm_medium=android_app&amp;utm_source=share as an easy way to create servers.
Still in the evaluation stage. Will keep you posted on how it goes. Initial impressions are good. There seem to be no issues.
Why is nobody that writes these writing tests? One of the primary reasons to use Golang IMO is that it makes TDD very easy. All of those postman tests could have been test-pairs. Why is main.go the only file they build? Why doesn't anyone show nice features like build-time vars? (server version as an example using git commit hash) It's not using packages None of the common code (like getting an ID) was isolated to a helper method. No heap escape detection and use of a global without mutex and locking as the store...
&gt; Reference and Deference In case ii , re := &amp;r , you're are invite by your friend at his home, so that you can play together. In case iii you invite your friend but this time your friend eat your favourite cookies, or play with your toys at your home. If you write code in c then you know reference means a house address or dereference means playing area in home. Have a great day WAT?!
RemindMe! 10 hours
Or xsltproc, you don't have to call it too often.
Thought about it. Let's choose it a new name. Voting opened 8)
How about: * What works when you don't have internet and don't have a magic cache on your machine. * What continues to work when your chosen mirrors and "notaries" are stuck on a blocklist. * What continues to work when you forget to maintain your internal mirrors? * What continues to provide repeatable builds without having to explicitly dump the output of your upstream mirror * What works when globally distributed means one server in Sydney and nothing else within 150ms Just because a handful of devs lack context doesn't mean the vendor folder is no longer required.
THIS. I have modules on a private git repository.
Not sure of your skillset, experience or interests, but if you‚Äôre interested in blockchain / cryptocurrency development, we‚Äôd love more good developers to contribute to our new Synapse architecture at Phore. Almost everything we are doing for Synapse is in Go, there are some parts we are writing in Rust and JS for specific reasons, but the primary language is Go, and everything we are doing is open source. As far as quality goes, I suppose you can judge for yourself, but as one example, many core aspects of the architecture are aligned with the Ethereum 2.0 specs (but we are also doing many things differently), and the Ethereum Go team is actually using some of our code and has invited our lead developer to join standards calls related to the Go BLS signature aggregation library he wrote. The back end of our Phore Marketplace application is also written in Go, so if that interests you more, I‚Äôve got an extensive roadmap you could help with there as well. Happy to chat with you online or set up a call to discuss if you‚Äôd like to learn more.
the issue was fixed, needed to use this instead of \`Source()\` \`FetchSourceContext(elastic.NewFetchSourceContect(true). Include("\_id"))\`
In the last year I became one of the maintainers of an ~10-year old hobby open source project that's depended upon by quite a few people. It's Java, and being of that vintage uses Ant with all the dependencies checked in. While discussing with the other maintainer we agreed that our dependencies need updating (it's been quite a while), but given the longevity of the project we should probably continue to check in dependencies, They're all pretty standard stuff, but may be hard to find 10 years down the line.
I work, when developing that "sample application", with an extra instruction in my mod-file: replace YourLibName =&gt; ../YourLibName Which is just the same as a remote, but then with a kind of fork. (It isn't one, but it acts like it is a local version of your library.)
Blockchain would be too heavy for me. Thanks a lot for suggestion though.
What sucks about this is adding thousands of files to your repository that, not only are you not supposed to touch, but absolutely can't touch. The implications of committing them to the repo can easily become muddy. I can see both sides but I've had plenty of experience with well-meaning devs modifying vendor files and making it impossible to update the vendor.packsge afterwards. Call it paranoia.
Because it's hard. :) And time consuming to explain and make videos about. But mostly because it's rarely simple and hard to solve elegantly and make a video tutorial about it. I think most of these cater to beginners because there are many of those. Go is not mature like, C++ where you can dump a bunch of very high profile videos and get a lot of views and likes because the user base is old and experienced enough now to understand / need these types of tutorials. At least that's my thinking in this area. When I was looking for beginner things when I first started I found plenty. But as I grew with the language and being a coder long before coming to Go, once I started to look for more advanced things, I found less and less high quality content. I guess that's just the nature of the beast and how a language and its community evolve.
That also means you can fork [https://github.com/benthosdev/benthos-lab](https://github.com/benthosdev/benthos-lab), add your own custom plugins and then also execute those within the browser.
An exception is a come from. A panic/recover is also a come from. You have no idea how the code got to that recover, and this makes the code unreadable.
Errgh traversy media! When you get into a language you realise just how much his videos lack.
Packages shouldn't use `os.Stdin`/`os.Stdout` nor exit. They should use `io.Reader`, `io.Writer`, and return errors. Why would anyone do this instead of just making and using an idiomatic `io.Reader` or `io.Writer` wrapper (or a `transform.Transformer`](https://godoc.org/golang.org/x/text/transform#Transformer))?
Thanks for comment. The library is more utility to build quick cli tools. From quick search: [https://stackoverflow.com/questions/29721449/how-can-i-print-to-stderr-in-go-without-using-log](https://stackoverflow.com/questions/29721449/how-can-i-print-to-stderr-in-go-without-using-log) I see I get dislikes for repo name, idiomatic/clean code etc'... But the intention was to share tiny utility that can help write bash scripts. Anyway, I'll be happy to hear any thoughts and will fix things accordingly. Also if you see value in this repo and want to improve, PRs are more than welcome.
FTR, if you can fetch a git-repository with a vendor-dir, you can also fetch a module file with all its dependencies. Fundamentally, no matter what, there is a phase where you *have* internet and can download all the needed source code and if there's a phase where you have no internet, you can't download any source code. Which source code you download or are missing when you're offline is independent from whether that code is stored in a directory called "vendor" or in a directory called "module cache".
It's not the same thing in the case of a private network behind a proxy where some people have an external proxy configuration and some can only access the internal network. If the main project is an internal private repository and it uses external 3rd party dependencies, the developer without external proxy access is only able to download the internal project. One then needs to resort to an internal module cache proxy to provide those dependencies. Thus, it's not the same as a vendor folder where the project is downloaded internally in a completely ready to build state.
Most important: Use tabs not spaces. Some IDE's will render tabs but convert them into spaces under water.
With Chinese documentation. Thanks.
&gt; Thus, it's not the same as a vendor folder where the project is downloaded internally in a completely ready to build state. Except you are cheating, by declaring dependencies part of the "main project", which are somehow magically able to be copied to other machines, while module files can't. The solution, really is that simple: Whenever you would usually transfer the vendor folder, instead transfer the module cache. Done.
Thanks for the python script hint. I believe [this](https://golang.org/src/runtime/runtime-gdb.py) is what you're talking about.
Everyone underestimates the value of working without a constant internet connection. It's not until their connection goes down for a day that they realize just how fragile their systems really are. They can't build anything from scratch or stand up a new system until it comes back.
read it all, and a big thank you for all of your work. Keep this up. It will encourage people to rethink their writing, or to start with a good goal straight from the beginning.
I wonder , why such a keen report makes the discusion turn in a generics thing. To me this is an unprofessional opinion, that needs to be there of course, but not here. I use this report to show my colleagues (my pupils) that there is a future for Go, and they are in the middle of this movement. Lot's of people spend their time to give us these insights and I am grateful for it. I'm grateful too for the fact that our company wants this too and also the report shows that this isn't some flurry of misunderstanding. Go is serious stuff (and the report tells me what I already knew). :-)
ISO-8601 (Python) and RFC3339 (Golang) I believe refer to the same thing. Try this: ``` package main import ( "time" "fmt" ) func main(){ fmt.Println(time.Now().UTC().Format(time.RFC3339)) } ```
https://play.golang.org/p/8SXhlGl6_fX
Pythons stamp has microseconds at the end. time.RFC3339 has just seconds. There‚Äôs 3339Nano but that‚Äôs nanoseconds. Just look at the time source and remove 3 9‚Äôs from the nano format and you should be good. Using 9‚Äôs in the partial second also means if the stamp has no partial seconds it will truncate the 0‚Äôs. That can make it hard to parse, so you can replace the 9‚Äôs with 0‚Äôs to avoid that issue.
Yeah man, cobra with viper for configuration has been my gold standard for applications.
Sorry to pick on your post, but it seems emblematic of Go REST API tutorials. Why don't you use a transaction? Why are you using a connection from the pool for every operation? If you get any reasonable level of strain, there is a good chance that you're going to exhaust the pool. Why not capture the connection once, or better yet the transaction, and use that for the entire length of the request?
This is good advice, but I've been thinking about this with WebSockets. Since they are long lived, the approach above using a closure is probably better than a middleware level.
Why? Did you get performance issues? Transactions provide isolation from partial writes.
OS X will be losing bash soon as well.
Good to hear, I'll prolly dm you to get some more specific details.
When the explicit purpose of the package is to help you use os.Stdin, it's OK to use it. I'd still want the API to allow me to pass in the in, out, and err streams so I can test my code, but there can be a "default" call that passes them down to that call for me. &gt; Why would anyone do this With all due respect to the poster, in this particular case it doesn't strike me as all that useful. However, there are related things that could be useful. Perl has a useful operator `&lt;&gt;`, which will either read lines from STDIN if no file names were passed in, OR will open each file mentioned on the command line and read lines from them. Stuff like this is non-trivial with a lot of corner cases and could be useful, even if it doesn't come out to a lot of code. (I have an open source library that isn't necessarily a lot of code, just a few hundred lines, but is a nightmare of very particular details to get correct if you want to do it yourself.)
I think taking a look at https://github.com/src-d/go-git/issues might be interesting if you already know Git anyway. A pure Go re-implementation of Git has a lot of uses in other popular tools such as gitbase or can be used in utility scripts. I am a big fan of the project, though it took some playing around and writing up some examples while looking at existing e to figure out how to use the library. If you look at Caddy https://github.com/mholt/caddy, some of the code might be over your head, but there are a ton of plugins. Many of those are pretty simple projects and could use small PRs like adding additional providers. See the dyndns plugin as an example of a very tiny repo with lots of obvious help--from typo fixes if you're a native English speaker to adding additional DNS providers to the plugin. Do you have any familiarity with specialized areas like C or windows ui? DNS severs? SMTP servers? Excel open document formats? Parsing? ECMA standards? Machine learning or statistics?
Actually using map\[T\]bool is the way official *Effective Go* uses. &amp;#x200B; &gt; A set can be implemented as a map with value type bool. Set the map entry to true to put the value in the set, and then test it by simple indexing. &amp;#x200B; See : [https://golang.org/doc/effective\_go.html#maps](https://golang.org/doc/effective_go.html#maps), the part after timezone examples.
Fatih at it again
These Makefiles that are essentially a named task runner, since they don't Make's dependency tracking, can be written as a single top-level `case` statement in POSIX Shell. That's a very sane and appropriate use of shellscript.
[removed]
Thanks
Wow, thank you so much for the kind words &lt;3
That's nice as an "integration" test, but a very crude mechanism for testing if you want to start annotating with log messages, using a debugger, etc, because of the way it runs completely out of process. Being able to send in an io.Writer and Reader gives a lot more options. For heavy-duty testing of some sort of really big program, it can become a problem that you're starting a bash and then a copy of your program every time, too. Just the process work of starting up and shutting down can come to dominate the test execution time.
My employer is slowly but surely working towards being sure our builds are accountable, where we know where every bit of the final product is coming from, completely. One of the things I'm trying to push for to help with that is the build servers will be allowed access to the source code server, and possibly a defined list of blessed archives internally, but the final build servers won't be able to access "the internet". Vendor directories won't be "necessary" in that case because we could have an internal Go module proxy, *but* a vendor directory will have the advantage that a team using Go won't be required to wait for such a server to be set up. I'd also say there's an advantage in just being sure a new developer or changing to a new system won't render a system unbuildable because the cache is now empty and it turns out that we can't get to the version we wanted. Having a vendor directory means if I can get to the git checkout at all, I have everything I need. Anything that deviates from that opens a window where I can get some of the project but not all of it, though it's a continuum of how affected a project can be, not a binary change. I think that's the core of my opinion on the matter; it doesn't matter if you can get it to the point that the modules are 99.99% likely to be available, with vendoring I can make it effectively 100% (in that if they fail, it's some other completely fatal problem anyhow).
Thank you so much for your help. This helped me solve my problem.
Posted here only four days ago: https://old.reddit.com/r/golang/comments/c06q6i/using_goanalysis_to_write_a_custom_linter/
Git repos work over email They work over torrents They work directly peer to peer with git daemon It's one less moving piece to have to depend on I've worked with the fun of ruby gems in the middle east when the UAE randomly blocks them for a week. Countries with filters are going to hit proxy services the moment a package they don't like goes on them. then we're going to have lots of fun trying to work around that.
Everyone estimates the active hostility towards the internet in some countries.
RFC3339 is a profile of ISO 8601 (minus one weird thing where -00 offsets in RFC3339 has a different connotation than +00, but that probably won't affect you), so it is the "same" thing (the reverse is not always true of course) and should parse fine with most libraries such as the date constructor in JavaScript. Of course, that might not matter it you're comparing times for an exact match (almost always a bad thing to do--but every rule has exceptions) or have a library that says it wants 8601 but technically wants something much more specific.
* In your example how do you share the source cache between multiple build servers? * How do you manage atomic writes to it from multiple build servers? * How do you prune unused modules from this cache? If you go with a go proxy mirror to solve the first two then? * What happens when the mirror goes down? * What happens when a module in the proxy is deleted? * What about blocked access? (china for example) If you host it yourself.... * You have to maintain another software and their storage. * You have to keep backups and find a way to prune it so it doesn't grow indefinitely. * Pray that the format disk format never changes or the proxy mirror can handle some old format that you had in backup 5 years ago. Nothing of the above isn't an issue with a vendor folder. For me not having a vendor folder is a dealbreaker and those who push the use of the goproxy doesn't address the common issues like the ones i and others have trouble with it.
Pretty cool! If you're interested in a concurrent, thread-safe version, I wrote something very similar at my last job: [https://github.com/Clever/optimus](https://github.com/Clever/optimus)
&gt; Git repos work over email &gt; They work over torrents &gt; They work directly peer to peer with git daemon Zip-files work over email, they work over torrents, they work over HTTP, you can print them out and send them via snail mail, you can morse them‚Ä¶ I honestly don't understand your argument here. *Obviously* Zip-files are either simpler to transfer, or just as simple as git repositories (but definitely not strictly worse). And they obviously have fewer moving parts, than a git repository (I would know - I re-implemented most of the git-internals myself once).
&gt;The solution, really is that simple: Whenever you would usually transfer the vendor folder, instead transfer the module cache. Done. Since when was copying a module cache around with projects considered a standard workflow? Vendoring is not cheating if it's a supported function of the Go tooling that enables completely self contained builds.
[removed]
Hey, I just wanted to say thank you for expressing your opinion! Even though I disagree, I'm still really happy that you gave feedback, it's super appreciated! :)
[removed]
&gt; Since when was copying a module cache around with projects considered a standard workflow? Literally what `go get` does, so this is as standard as possible. After you fetch a project, all its transitive dependencies are in your module cache. And you can start working offline no problem.
For websockets I think it makes sense to have a ‚Äúmiddleware‚Äù-like function wrapper that wraps the handler and does the transaction support for you. Same idea.
Thank you! I always suck at finding libraries, so I appreciate the link. Seeing how other people do similar things is always a great way to improve. I like that your examples include the necessary imports- I'm not sure how I neglected to do that. I also like the mutex logic in `optimus.start`. I'll have to remember to look at that if/when I decide to make this thread safe.
As someone who's learning Go (and programming in general), I'd love to see the "right" way
I think I'll go ahead and explore using WebSockets then. I could always switch to using Protobuf if I needed to but the people I'm working with are more familiar with JSON anyway. Thank you for all of the help, I really appreciate the tips as well, they are every helpful!
‚Äúbig guy‚Äù Are you starting a bar fight or asking for programming help? smh
Thanks a lot for your suggestions, no I'm in no way expert in anything. I will look at both of them slowly, Thank you.
From what I remember, ChartJS doesn't depend on anything except loading the script. So my guess would be that your web-app can't find it. Go doesn't care what JavaScript libraries you include, it only serves the files.
ChartJS is a client side library that generates the graphs in a browser, so the backend has little to do with it other than outputting the data set to plot which maybe sent on page load or requested client side via a XHR request to the backend.
I could just notice it more now that Go is my primary language, but there seem to be quite a few others in the infosec community starting to use Go more. From a security testing point of view, I much prefer it to Python. Easy portability, cross compilation, and compile time checks are all big wins. You won't find as many projects in Go. Some Python projects make use of the REPL which can be nice for some things (e.g. Scapy). But I've been able to generally find whatever packages I need. GoPhish, Amass, and Bettercap are all pretty popular projects in Go.
_and I learned something new about Go style recommendations_
Hi Jeff, The "if this text doesn't disappear" would not clear for me. I discovered that I could get it working by cutting and pasting the input text. Once I did that, the compile and execute buttons appeared
also agrees, for Go Makefiles should not be involved at all, we can easily craft build scripts for programs using magefile or just writing plain go
That‚Äôs cool. How would you check if a string has a leading or trailing white space?
In every other language I work with this is how it is done, so I don't really understand why Go developers are so hostile to this point of view. Those languages often did have vendoring before, but once a proper package manager was released it became redundant. I agree there are cases where vendoring is still useful, but for most people it's not needed. If you already have the project building one day, it's still going to work the next day if you don't have an internet connection. If you are concerned the library owner is going to delete the repo, or your access to GitHub will be removed then by all means vendor it (though you can do it later as you have the package installed to $GOPATH). My view may be biased though. I've worked on projects that have had hundreds of megabytes of code vendored (Ruby ten years ago was notorious for this, as you would vendor compiled binaries too), so the git repo quickly ends up becoming huge.
An opportunity was missed to name it `gotee`.
You can do something like this to get the index of the whitespace `package main` &amp;#x200B; `import (` `"fmt"` `"strings"` `)` &amp;#x200B; `func main() {` `fmt.Println(strings.Index(" hello", " "))` `fmt.Println(strings.Index("hello ", " "))` `}`
there's an issue with the os.Rename part of the code (line 101 in main.go). panic: rename /tmp/sponge-612215231.tmp test.py: invalid cross-device link goroutine 1 [running]: main.CheckError(...) /home/sam/go/src/git.sr.ht/~tslocum/sponge/main.go:37 main.main() /home/sam/go/src/git.sr.ht/~tslocum/sponge/main.go:101 +0x7af What seems to be happening is, on my system, /tmp is a different file system than /, the os.Rename function doesn't seem to like crossing over the file system boundary hence the error. I was able to get this to work by having all of my files in the tmpfs and avoiding crossing the boundary.
Thanks, I'll look into this.
just trynna say i am not toxic ..
Yeah both PHP in node has it, but I still commit all the vendor code for both of them.
On Debian-based systems, `sudo apt install moreutils` for the standard sponge.
how is this different form `cat`?
No, I am not. But I do know about it because I talked with one of the core Go team members who mentioned the Go GDE process.
Interesting, thanks for letting me know. Was this on mobile by any chance?
From sponge(1) &gt;Unlike a shell redirect, sponge soaks up all its input before opening the output file. This allows constricting pipelines that read from and write to the same file.
Retried again in a new window. I think my initial report was a red herring since I waited longer and it popped up straight away once the 10mb WASM file downloaded. I'd attribute this to my shitty internet connection.
Channels can be used to create generators in Go. The official Go blog has an article on this: https://blog.golang.org/pipelines
As it mentioned in other comments channels are what are you looking for. Here‚Äôs an article describing how to replicate python yield pattern. https://bbengfort.github.io/snippets/2016/12/22/yielding-functions-for-iteration-golang.html
Writing to a file while you are still reading it can cause problems.
You can't generate useful mocks, you have to put specific behavior in them that you can test against. So, yes, commit them.
strings.HasPrefix strings.HasSuffix
&gt; packages are installed in a decentralised way I would rather call this a disadvantage in most practical scenarios as an overall reliability equals to the reliability of the weakest component. I mean I would rather rely on GitHub than on some random ‚Äúblitznote.com‚Äù (real name, real case ‚Äì this thing was down for some time and our build of pre-modules Caddy was disfunctional that time) &gt; If you are concerned the library owner is going to delete the repo proxy.golang.org solves this ‚Äî it caches forever. Using VCSes as package repositories was not particularly smart decision.
Again, this implies that the person who is getting the internal project can also get the external with "go get". What are the steps you recommend for switching to a module cache approach to allow developers without external internet access to go get the internal project and build it? If you say a module proxy, that is alot more complex than vendored dependencies. If you say to copy a module cache somewhere in the project then that is outside the automation of the Go tooling.
I usually use \`map\[T\]struct{}\` for that. \`T\` can be any type you want a set of, as long as it's valid for use as a map key, and \`struct{}\` is the empty struct, which has the nice property of not taking up any memory at all: [https://dave.cheney.net/2014/03/25/the-empty-struct](https://dave.cheney.net/2014/03/25/the-empty-struct)
There are packages like https://github.com/scylladb/go-set that provide a `Difference()` method which does what you want. The package I linked also includes a script you can use to generate the code for your own types.
Does this guarantee thread-safety though ?
Wouldn't this pose a problem for big files?
You can call \`mv\` as fallback if \`os.Rename\` fails &amp;#x200B; [https://fuchsia.googlesource.com/jiri/+/HEAD/osutil/rename.go](https://fuchsia.googlesource.com/jiri/+/HEAD/osutil/rename.go)
Unlike Python, Go prefers to not hide its complexity. At least not with the standard types. Using a map you can do a diff. https://play.golang.org/p/dFomgHKfgaa In the Python approach you listed, there are two conversions to sets and then third set as the difference, followed by a list construction. In the Go version where you are being explicit, there is the one map creation and the one slice result.
Yes. The use case is mostly the ability to rewrite / clobber files (doing in-place modifications) without corrupting them. This is rarely done on huge files.
Bettercap and Cameradar are some great hacking tools made with Go. And see [https://github.com/guardrailsio/awesome-golang-security](https://github.com/guardrailsio/awesome-golang-security)
[TechVerito](https://techverito.com)
For your requirements you should take a look at go modules: [https://github.com/golang/go/wiki/Modules](https://github.com/golang/go/wiki/Modules)
It looks like this only works if you're not in the go-path, right? (Because I relly like the concept of the go-path)
Yes, it works outside the go path. In general though, this is what is perceived as the future with 1.13 close by.
Yes, I heard of it but I've also found a way to use the mod in the gopath. Anyway thank you very much.
It only takes a few moments to write up something convenient. [https://play.golang.org/p/Sce7ZreWpAf](https://play.golang.org/p/Sce7ZreWpAf)
&gt; Instead of contributing upstream, they fork and just write nonsense The article [stripping dependency bloat in VictoriaMetrics Docker image](https://medium.com/@valyala/stripping-dependency-bloat-in-victoriametrics-docker-image-983fb5912b0d) clearly explains that [the standard Go library for metrics' exposition in Prometheus format](https://github.com/prometheus/client_golang) has complex API and many dependencies that aren't used in VictoriaMetrics and the majority of Go apps. It is impossible to contribute to the standard Go library by removing bloat because of backwards compatibility. So we decided writing slim library from scratch - (github.com/VictoriaMetrics/metrics)[https://github.com/VictoriaMetrics/metrics]. &gt; The guys here just post false claims without any data The post you refer - [measuring vertical scalability for time series databases in Google Cloud](https://medium.com/@valyala/measuring-vertical-scalability-for-time-series-databases-in-google-cloud-92550d78d8ae) - contains enough data for the claim - a single-node VictoriaMetrics may scale to 19M inserts per second and to thousands of heavy queries per second. It would be great if you, as core Thanos developer, will conduct the same benchmarks against properly tuned Thanos cluster, so we could compare results. I'm happy to update these claims if moderately sized Thanos cluster would outperform single-node VictoriaMetrics. &gt; If you care about the ecosystem &amp; the community then yo contribute to open source projects, help make them better, not fork them and claim that they are "bloated". 1) We didn't fork anything. All the VictoriaMetrics code is written from scratch. 2) We contribute back to open source community by providing alternative projects with better performance and usability. We think community wins from such a competition.
Extra allocations might occur: [https://play.golang.org/p/Fenn6NiRf3r](https://play.golang.org/p/Fenn6NiRf3r)
I find debugging gRPC requests can be a pain because debugging proxies like Fiddler/Charles don‚Äôt natively understand gRPC. So I built *grpc-dump* to try and make this easier by doing interception at the gRPC level rather than the HTTP level. Without requiring any client/server changes, *grpc-dump* transparently intercepts traffic on your machine and logs a JSON stream of all gRPC(-Web) requests that are made. This stream/dump is already useful for debugging but I‚Äôve also started adding tools like *grpc-fixture* which uses this dump and responds to future client requests with the saved server responses from the dump.
Yes, it is ok to have multiple files for one package. There are so many projects on github with such structures. So go ahead and don‚Äôt worry.
ah -- makes sense. reading is fundamental. good job.
If you interested in feedback for Go programs in general, it's worth to check out [exercism.io](https://exercism.io/tracks/go)
Thank you. I'll have a look into this.
&gt; func CheckError(err error) { &gt; if err != nil { &gt; panic(err) &gt; } &gt; } Please never ever do this. A command line utility should not dump out useless stack traces for expected errors (e.g. a destination path that is not writable, etc). If `main` wants/needs to exit it should use `log.Fatal` (probably with an initial `log.SetPrefix("sponge: "); log.SetFlags(0)`).
&gt; The post you refer - measuring vertical scalability for time series databases in Google Cloud - contains enough data for the claim No, It doesn't. You haven't run any tests against m3db, cortex or Thanos and yet you claim that your system works same way or better. &gt; It would be great if you, as core Thanos developer, will conduct the same benchmarks against properly tuned Thanos cluster, so we could compare results. I'm not interested in that and It's not about that. Just if you claim something, back it up by data. &gt; 1) We didn't fork anything. All the VictoriaMetrics code is written from scratch. 2) The metrics library is the fork of client_golang, so you did fork and didn't contribute anything to client_golang. &gt;2) We contribute back to open source community by providing alternative projects with better performance and usability. We think community wins from such a competition. Or you can contribute to client_golang and existing projects and then community wins by doing updates and not having forks everywhere :)
Just an explanation because I know what you are going to say. I'm planning SOAP server instead of REST because of the future clients of the app have their system prepared for that architecture.
Check out my Chrome devtools plugin: https://github.com/SafetyCulture/grpc-web-devtools/
Based on your question, I have this to say: Implementations of sets are an interesting interview question. Now, the reasons. First, do you know the type of your list? It is `[]T` but the question comes to the mathematical properties of `T`. Is there a partial order relation in elements of `T` ? For example, if `T` is an `int` or `string` then it is feasible to define a `sort.Sort` interface for `[]T`. If elements of `T` are unorderable, then you have a multitude of solutions already mentioned in this thread. If elements of `T` are orderable, I would like to bring up this: https://github.com/xtgo/set. The xtgo/set library is one of the finest you will get in Go. It relies on a good understanding of the problem and the data structures that define the problem. This is why I say that it is a good interview question. If your data type is orderable, then it's straightforwards: implement a `sort.Interface` for your slice, then use `xtgo/set` for a very high performance abstract data type that represents a set.
[github.com/UNO-SOFT/soap-proxy](https://github.com/UNO-SOFT/soap-proxy) may help (find body, parse &amp; generate Fault), but the real trick is that if you like gRPC, then [github.com/UNO-SOFT/soap-proxy/protoc-gen-wsdl](https://github.com/UNO-SOFT/soap-proxy/protoc-gen-wsdl) ([https://github.com/UNO-SOFT/soap-proxy/tree/master/protoc-gen-wsdl](https://github.com/UNO-SOFT/soap-proxy/tree/master/protoc-gen-wsdl)) can generate a SOAP gateway for your gRPC server. (I alse have [https://github.com/UNO-SOFT/grpcer/tree/master/protoc-gen-grpcer](https://github.com/UNO-SOFT/grpcer/tree/master/protoc-gen-grpcer) to generate a JSON-RPC gateway for your gRPC server). &amp;#x200B; Regarding your question: if you have a .proto file, protoc-gen-wsdl can generate a WSDL for it. And Protocol Buffers is a nice and easy format. And you're lucky: [https://blog.sourced.tech/post/proteus/](https://blog.sourced.tech/post/proteus/) can generate .proto from your source structs! So you can go .go -&gt; .proto -&gt; .wsdl :)
Those are all pretty much why I've picked Go. I remember when Java was easy. Came back to it 15 years later and I don't recognize anything
Go is all about simple abstractions and readable code. It's great.
Same here. I am finding open source projects, but I don't know if I should be copying they're coding methodologies.
i wonder if instead of writing a temporary file if it is feasible just to load it into memory and assume that the VM subsystem/pager would handle storing it in a file (swap file) if necessary. my point is: would it be reasonable just to simply buffer the input in memory no matter how large it is?
defer is not only for cleanups. it's quite possible you have something like this in the beginning of your function: if metric != nil { before := time.Now() defer metric.ObserveTimer(time.Since(before)) } ... If it's executed at the end of block, this won't work as expected. As for use defer in a loop, there's nothing wrong with wrapping them into an anonymous function :)
I hope Go would eventually be labeled feature complete (syntax-wise) in the future.
I don't understand your use case - can you post some example code illustrating the problem you are trying to solve?
Forgive me if this doesn't answer you question. The best way you can do this is by creating a release tarball/zip which has the precompiled binary for the target system(s) alongside an install script which will place the binary in the user's path. This way you user won't even need Go installed to run your app.
You got it! Do you know how I'd do that?
We don't autogenerate our mocks, so they are all added to our version control repo.
some notes: (a) i would try to declare variables when you need them. it isn't necessary to have that `var ( )` block at the top of your main function. a few of the variables in there should be declared with the short declaration operator (`:=`) and really all of them *could* be. (b) get rid of your CheckError() function and simply use `log.Error()`. You shouldn't be `packic()`ing for errors that you can handle. (c) i *never* check if `err == nil`. i typically don't ask if there is no error -- i always ask if there is an error. what `if err == nil` does is force you to place your happy/non-errored path in a more deeply nested scope. this really stands out to me -- i consider this an anti pattern. (d) you should consider using `defer` to handle cleaning up your temporary file. immediately after checking the error value for `ioutil.TempFile()` you should probably do something like: ``` defer func() { os.Remove(tmpFile.Name()); tmpFile.Close() }() ``` (yes, it is fine to unlink a file while it is open. the kernel still keeps the file descriptor and it doesn't go away until it is closed.) (e) i'd try to find a way to reduce the amount of duplicate code you have. there are three places where `io.CopyBuffer()` is called. instead of calling it in three places, i'd make the first half of the program's job to determine which writer to write to. then call `io.CopyBuffer()` once to that writer.
First start by contributing to multiple projects. Then you will learn a lot. Look out for small projects. If you are a beginner.
Its like a language for kids, I try to force my teams to learn and use whenever it reasonable.
Maybe you are looking for this, https://github.com/golang-standards/project-layout
Why did I not see this before. Thx
When deferred functions are executed at function return, one can use them to easily implement leaving any scope using a function/function literal. If defer would always execute at scope exit, there's no easy way how to schedule deferred execution of a function at function exit when executing the defer statement inside a nested block.
That makes no sense in a statically typed language.
Check out [https://github.com/goreleaser/goreleaser](https://github.com/goreleaser/goreleaser).
I'm sure your teams appreciate you treating them like children?
What exactly is wrong with extracting your file handling or whatever into a function, and calling that in your loop?
A love letter to Go.
In a potential hot loop it is not ideal to create and destroy a resource in every iteration. Try to factor the resource out of the loop.
This crossed my mind as well while porting. It would be possible to default to a small-ish in-memory buffer, then switch to a temporary file once that buffer is filled. Patches are welcome if anyone is interested in implementing this.
Thank you for the detailed feedback. I've updated sponge to address it.
Thanks again for reporting this. I've implemented the mv fallback.
Thanks for the feedback. I've updated sponge to address this.
Apart from channels you can use closures to implement generators.
I'm hoping that day comes sooner than later. Another thing not mentioned is that Go's simplicity encourages small programs -- unix-style 'do one thing' kind of approach. It doesn't fit all needs, but it's generally what *I* develop, not elaborate frameworks with all kinds of inheritance and huge monolithic enterprise systems (nothing wrong with those, but I don't work with those).
For those who are looking for many other performance tips as well, https://github.com/dgryski/go-perfbook
That's exactly the mindset the language was designed with though. Rob Pike himself said he wanted something that would be easy for fresh grads to learn, since they don't have the experience to "appreciate an elegant language".
Assuming you want to learn about the install script, I have to say there are a million ways you can approach this. The simplest being a simple shell script or even a bash script. Shell scripts are pretty easy to write but should you need more help ask at r/bash
Thanks!
You should improve the code with the constants from the http package: https://golang.org/pkg/net/http/#pkg-constants
good job! interested in more feedback?
thanks. is there any other way I can improve? will update the post soon.
What I don't like about these short tutorials is, that they don't show people new to go how to properly setup a project structure. At the end, everything always gets pushed into a single main.go file. But real use cases for APIs will have different project structures. Maybe do a follow-up, throw a sqlite/postgres in there, dockerize it and build an actual tiny service like a book/movie review service that has a proper project structure as well. One question maybe. What was the reason for you to choose mux over the standard http library. You don't use any features unique to mux vs std http, like middleware or route grouping.
Others have written about the reasons for defer working this way. Regarding using defer in a for loop, your approach is correct, but I'm not sure what you mean by "pass around the loop variable and the error". If it means what I think it means (passing as arguments to the body function), you don't have to do that, because anonymous functions have access to the outer scope: for _, filename := range filenames { func() { f, err := os.Open(filename) // handle err defer f.Close() // ... }() }
Try /r/GolangJobOfferings
Today, if I had to pick a language for the backend that is guaranteed to have an OS underneath it and is not performance critical, I'd pick Go. Turns out that's a really large set of real world problems. If it was performance critical, I'd pick C++. If I had to pick a language that needed to run on bare metal, I'd pick Rust if I could, C if I had to. I would still pick JS for the front end right now
I've always thought we have a low enough number of total posts and enough interest in remote Go job posts that this is a great sub to post this. I'm not looking for a job change, but as a remote midwest dev that works with a lot of remote people two and three timezones west, it's VERY easy to find developers who don't mind getting up later and working later to sync schedules with a west coast team. I have a teammate in Tennessee that wakes at 11:30AM in our timezone and he loves it. You'll also find that you can pay someone from the midwest a little bit less than west coast while still beating the salaries they will get offered from a local company. If you wanted EST scheduling, it would be another story and you'd never be able to get a dev in Seattle to stay happy longterm, but I very much encourage you to accept other timezones.
:)
`go get github.com/user/repo` (or maybe something like `go get github.com/user/repo/cmd/repo`) should do what you want, no? The standard line I use is: &gt; You can install it with `go get arp242.net/info`, which will put the binary at `~/go/bin/info`. This is enough info for most people, and people who know about GOPATH, GOBIN, and whatnot are knowledgable enough to do something else.
&gt; Each package has M abstractions. No. https://github.com/golang/go/wiki/CodeReviewComments#interfaces
Sorry if I wasn't clear what I meant. I'm not trying to pass parameters into the anonymus function, but rather extract results, and errors from it. Looking at your example (which is kinda similar to mine), in order to handle the handle the error, I pass it up up to the function containing the for loop, so to bubble out the error from the function, what I do: ``` for _, filename := range filenames { res,err:= func()(*result,error) { f, err := os.Open(filename) if err!= nil{ return nil,err } defer f.Close() // Do some processing that can also fail _, err:= io.Copy(someDest, f) if err!= nil{ return nil,err } //... return result{},nil }() //handle error received from anonymus function } ``` However this seems like a fair bit of work, so I wondered if there was a simpler way to do this.
I was more commenting on the notion of somebody forcing their team to write in their favorite language rather than giving the teams some agency and treating them like professionals. Top-down decrees on what technologies the team should use is a bad sign IMO.
This entire question is very skimpy on details, but you can perhaps use a struct tag to tell ES to not marshal the data. If you use JSON for both, you can probably just set the `ID` field to `0` in the code, and use the `omitempty` flag?
Pretty neat. Thanks! In this case users already have go properly installed, but still a nice approach. I had totally forgot this Go command.
I'm very sympathetic to that argument, and I would personally prefer if I was allowed to write in whichever language I like. But I recognize that people leave and code must be maintained, so the language and tools must be standardized across a company to a degree. I would have probably preferred my company went with Rust or Elixir instead of Go, but in the end, Go's strongest suit is how easy it is for your stock C++/Java people to learn. It's still difficult to get most of them to write idiomatic Go, so is it really that unreasonable to assume they should be given a language "for kids"?
Most of the stuff I write is aimed at Linux/BSD (and to lesser extent, macOS) users, so installing Go is usually just a matter of running a single command to fetch it from the package manager. On Windows it's a bit more work.
Gotcha. Yeah, I guess that's the only way aside from not using defer, unfortunately. I guess this doesn't come up often enough for the designers of Go to be motivated to make this easier.
I get your point, but if my technology stack was arbitrarily nerfed by management because they think a lot of us are idiots, I'm going to be finding another job immediately.
I feel you. If I‚Äôm ever in a managerial position, I think I‚Äôll err on the side of allowing people to use uncommon languages and frameworks. I think having to learn a new programming language isn‚Äôt that much harder than learning a new framework or codebase, and if someone‚Äôs incapable or unwilling, I should not have hired them in the first place.
If you write a method, then write a test for that method. I don't know about the right way ^TM, but I can share an example from a repo I wrote 10 months ago. Here is an example of a method written using a structure App which contains it's DB, which passes that (DI) to func (a *App) updateProduct(w http.ResponseWriter, r *http.Request) { vars := mux.Vars(r) id := data.ParseUUID(vars["id"]) _, getErr := repositories.GetProduct(a.DB, id.String()) if getErr != nil { rest.RespondWithError(w, http.StatusNotFound, fmt.Sprintf( "Product '%s' not found", id.String())) return } body, err := ioutil.ReadAll(r.Body) if err != nil { rest.RespondWithError(w, http.StatusBadRequest, "Unable to read request body") return } defer r.Body.Close() p, err := data.ParseProductDataJSON(body) if err != nil { rest.RespondWithError(w, http.StatusBadRequest, "Invalid request payload") return } err = repositories.UpdateProduct(a.DB, id.String(), p) if err != nil { rest.RespondWithError(w, http.StatusInternalServerError, fmt.Sprintf( "Unable to save product '%s' with data %+v", id.String(), p)) return } m, _ := repositories.GetProduct(a.DB, id.String()) rest.RespondWithJSON(w, http.StatusOK, m) } Here is a corresponding test func TestUpdateProduct(t *testing.T) { clearTable() p := data.CreateProduct("cheap trash", .99) err := repositories.CreateProduct(a.DB, p) if err != nil { t.Errorf("Unable to save initial model to database") } req, _ := http.NewRequest("GET", fmt.Sprintf("/product/%s", p.GetID()), nil) response := executeRequest(req) originalProduct, _ := data.ParseProductDataJSON(response.Body.Bytes()) payload := []byte(`{"name":"test product - updated name","price":11.22}`) req, _ = http.NewRequest( "PUT", fmt.Sprintf("/product/%s", p.GetID()), bytes.NewBuffer(payload)) response = executeRequest(req) checkResponseCode(t, http.StatusOK, response.Code) modifiedProduct, _ := data.ParseProductDataJSON(response.Body.Bytes()) if modifiedProduct.GetID() != originalProduct.GetID() { t.Errorf("Expected the id to remain the same (%v). Got %v", originalProduct.GetID(), modifiedProduct.GetID()) } if originalProduct.GetName() == modifiedProduct.GetName() { t.Errorf("Expected the name to change from '%v' to '%v'. Got '%v'", originalProduct.GetName(), modifiedProduct.GetName(), modifiedProduct.GetName()) } if originalProduct.GetPrice() == modifiedProduct.GetPrice() { t.Errorf("Expected the price to change from '%v' to '%v'. Got '%v'", originalProduct.GetPrice(), modifiedProduct.GetPrice(), modifiedProduct.GetPrice()) } } I already know that this sample I use to show someone has problems. For a start it's centre out, rather than keeping details on the periphery and deferring to a mostly logic core. I Had reasons at the time, but it at least checks some things about the implementation when testing. If I were to rewrite it I think I'd probably make each method correspond to several tests with a shared setup / teardown. Here is a rather pointless benchmark test func BenchmarkCreateRequests(b *testing.B) { request, _ := http.NewRequest("POST", "/product", strings.NewReader(`{"name":"something","price":99.99}`)) b.ResetTimer() for i := 0; i &lt; b.N; i++ { response = executeRequest(request).Result() } } Having benchmarks allows you to see (this one is pretty much e2e) how parts of your application will perform. Here is a much cleaner and simpler pure function func AddHyperMediaLinks(links *[]Link, basePath string, page, total uint64, count uint8) { if page &lt; 1 { page = 1 } pages := getPages(count, total) *links = append(*links, GetPageLink(basePath, count, 1, "first", "GET")) if page &gt; 1 { prevPg := page - 1 *links = append(*links, GetPageLink(basePath, count, prevPg, "prev", "GET")) } *links = append(*links, GetPageLink(basePath, count, page, "current", "GET")) if page &lt; pages { nextPg := page + 1 *links = append(*links, GetPageLink(basePath, count, nextPg, "next", "GET")) } *links = append(*links, GetPageLink(basePath, count, pages, "last", "GET")) } Here are several tests for it. func TestHyperMediaLinksFirstPage(t *testing.T) { links := []Link{} expected := []Link{ Link{Href: "/products?page=1&amp;count=10", Rel: "first", Type: "GET"}, Link{Href: "/products?page=1&amp;count=10", Rel: "current", Type: "GET"}, Link{Href: "/products?page=2&amp;count=10", Rel: "next", Type: "GET"}, Link{Href: "/products?page=10&amp;count=10", Rel: "last", Type: "GET"}, } AddHyperMediaLinks(&amp;links, "/products", 1, uint64(100), uint8(10)) linksLen := len(links) if linksLen != len(expected) &amp;&amp; links[0] != expected[0] &amp;&amp; links[1] != expected[1] &amp;&amp; links[2] != expected[2] &amp;&amp; links[3] != expected[3] &amp;&amp; links[linksLen-1] != expected[linksLen-1] { t.Errorf("Expected: %+v, Got: %+v", expected, links) } } func TestHyperMediaLinksNthPage(t *testing.T) { links := []Link{} expected := []Link{ Link{Href: "/products?page=1&amp;count=7", Rel: "first", Type: "GET"}, Link{Href: "/products?page=4&amp;count=7", Rel: "prev", Type: "GET"}, Link{Href: "/products?page=5&amp;count=7", Rel: "current", Type: "GET"}, Link{Href: "/products?page=6&amp;count=7", Rel: "next", Type: "GET"}, Link{Href: "/products?page=15&amp;count=7", Rel: "last", Type: "GET"}, } AddHyperMediaLinks(&amp;links, "/products", 5, uint64(100), uint8(7)) linksLen := len(links) if linksLen != len(expected) &amp;&amp; links[0] != expected[0] &amp;&amp; links[1] != expected[1] &amp;&amp; links[2] != expected[2] &amp;&amp; links[3] != expected[3] &amp;&amp; links[linksLen-1] != expected[linksLen-1] { t.Errorf("Expected: %+v, Got: %+v", expected, links) } } func TestHyperMediaLinksLastPage(t *testing.T) { links := []Link{} expected := []Link{ Link{Href: "/products?page=1&amp;count=10", Rel: "first", Type: "GET"}, Link{Href: "/products?page=99&amp;count=10", Rel: "prev", Type: "GET"}, Link{Href: "/products?page=100&amp;count=10", Rel: "current", Type: "GET"}, Link{Href: "/products?page=100&amp;count=10", Rel: "last", Type: "GET"}, } AddHyperMediaLinks(&amp;links, "/products", uint64(100), uint64(1000), uint8(10)) linksLen := len(links) if linksLen != len(expected) &amp;&amp; links[0] != expected[0] &amp;&amp; links[1] != expected[1] &amp;&amp; links[2] != expected[2] &amp;&amp; links[3] != expected[3] &amp;&amp; links[linksLen-1] != expected[linksLen-1] { t.Errorf("Expected: %+v, Got: %+v", expected, links) } } func TestHyperMediaLinksFirstAndLastPage(t *testing.T) { links := []Link{} expected := []Link{ Link{Href: "/products?page=1&amp;count=10", Rel: "first", Type: "GET"}, Link{Href: "/products?page=1&amp;count=10", Rel: "current", Type: "GET"}, Link{Href: "/products?page=1&amp;count=10", Rel: "last", Type: "GET"}, } AddHyperMediaLinks(&amp;links, "/products", uint64(1), uint64(0), uint8(10)) linksLen := len(links) if linksLen != len(expected) &amp;&amp; links[0] != expected[0] &amp;&amp; links[1] != expected[1] &amp;&amp; links[linksLen-1] != expected[linksLen-1] { t.Errorf("Expected: %+v, Got: %+v", expected, links) } } func TestHyperMediaLinksZeroPage(t *testing.T) { links := []Link{} expected := []Link{ Link{Href: "/products?page=1&amp;count=10", Rel: "first", Type: "GET"}, Link{Href: "/products?page=1&amp;count=10", Rel: "current", Type: "GET"}, Link{Href: "/products?page=1&amp;count=10", Rel: "last", Type: "GET"}, } AddHyperMediaLinks(&amp;links, "/products", uint64(0), uint64(0), uint8(10)) linksLen := len(links) if linksLen != len(expected) &amp;&amp; links[0] != expected[0] &amp;&amp; links[1] != expected[1] &amp;&amp; links[linksLen-1] != expected[linksLen-1] { t.Errorf("Expected: %+v, Got: %+v", expected, links) } } These again are not perfect, but they test several cases of a very low level component used throughout the example
I guess you're right that in that scenario you would have to run a proxy or do the copying manually. I guess I find the idea just strange, that a company would a) block HTTPS to the internet and then b) be unwilling to maintain even the simplest of HTTP servers (or NFS or whatever) on an intranet to deal with the fallout of that. I guess that's kind of the crux of the matter. ISTM that people think a Go module cache is some complicated software to run and maintain, but it can literally be as simple as a shared network drive or an HTTP server with a copy of the cache in an exported dir. If you're unwilling to run that, IMO you wouldn't firewall your workstations that restrictively.
Why would a set "hide complexity" any more than a map does?
&gt; Top-down decrees on what technologies the team should use is a bad sign IMO. You'd love where I work. No barriers anywhere, but no discipline either
Thanks for sharing. Always good to get some random performance tips. Especially when they come with benchmarks!
Not really though, it won't be the default anymore. But Bash will still be present
What I mean is that in python there are a lot of little concise operations that programmers use, like the one liner converting both containers to sets, doing a diff and converting it back to a list. It is easy to not think about what is happening under the hood with all the temporary containers and iterations. When you have to explicitly iterate and allocate your containers, you see the complexity.
Oh I totally agree and understand that the slice will need to allocate as you append. But it's not really any different that 1 of the lists you need in the python variation. At least we know that the Go implementation allocates the list in chunks to amortize the cost. I don't recall how the CPython list allocates each of those items it has to add.
Agreed. Don‚Äôt ruin a simple language with generics, please.
What value does this bring over the official documentation?
Sure. I'm still waiting for the proxy that we currently use for other languages to release their new version that includes the Go module proxy feature. But it's a step that involves multiple departments (I am not IT) and a setting that has to be made to the dev env to point at the proxy (or integrating it into the build system / script). I just really love how concise and portable a vendored project can be. A non go developer that needs to build the project can easily build it without any dev env settings. But I agree that it will become easier over time to consume the module proxy.
I read this completely at least twice, and I honestly can't tell if it takes try statements and rewrites them into current go, or if it tries to take current go and rewrite it to use try. The documentation says "tryhard considers each top-level function...", but I don't know what it's "consider"ing it *for*.
See https://www.reddit.com/r/golang/comments/c21dlz/grpcdump_a_grpcgrpcweb_debugging_proxy/ for (more) comments
strings.Join(strings.Fields(mystring), ‚Äú‚Äù)
I could have sworn he said that it‚Äôs designed for smart 20sonethings who nevertheless overestimate their own intelligence (that is, the typical Google hire).
Considering the sets and the list are constructed based on structures with a known size, they probably allocate an array of the final size immediately.
more notes (after refactor today): (a) it isn't necessary to explicitly discard return values. change stuff like: ``` _, _ = fmt.Fprintf(os.Stderr, ...) ``` to just ``` fmt.Fprintf(os.Stderr, ...) ``` (b) the defer block you have to clean up the temp file is in the right direction but not correctly implemented: ``` defer func(tmpFile *os.File) { if tmpFile == nil { return // File was closed elsewhere } tmpFileName := tmpFile.Name() _ = tmpFile.Close() _ = os.Remove(tmpFileName) }(tmpFile) ``` you do this right after you open the file. it is impossible (okay -- EXTREMELY unlikely) for `tmpFile` to be `nil`. also, `tmpFile` being `nil` doesn't indicate that the file was closed. there is also no need to pass it as a parameter to your func. just "close" around `tmpFile` like: ``` defer func() { os.Remove(tmpFile.Name(); tmpFile.Close() }() ``` also, again -- if you're concerened about maintain the validity of your `tmpFile` value after closing it, simply `os.Remove()` it *before* closing it. (c) that block that starts with: `if writeFileName != "" {`... imagine if that was a function that returned an `io.Writer`.
As a dev that worked solely with Go for ~6 years, and now the last ~year with Rust, how Rust and Go solve problems feel very different. In general I think Rust speaks to me far more than Go did _(though, I thought that about Go too)_, but really I think the bigger more objective things are: 1. The types of problems you're solving and the features you think you need to solve them with. 2. The safety needed, which arguably is simply another feature and thus ties into item #1. Which features they thought they needed I don't know. I know now that I've rewritten a project in Rust I'd argue heavily for Rust over Go for my specific project, but that of course doesn't apply to everything. I think it's a case by case basis. The other answer might simply be that they like it. I know I do. In general I use Rust for everything now. A few projects I think Rust is objectively better for, but all the rest of my projects I just use Rust because I like it more. Though, professionally I'd never choose Rust over Go strictly on that.. and I hope they wouldn't either haha.
Do you believe that Go works well in larger projects with subpar development process (e.g. lack of/poor code reviews)? I'm kind of afraid that lack of some features* will lead to projects harder to understand and maintain, at least for some teams. * - fine-grained encapsulation + immutable types with constructors
&gt; `tryhard` is a very basic tool to list and rewrite `try` candidate statements so it lists or converts blocks that could be converted into a `try()` statement. a "`try` candidate statement" is one that takes the form: ``` T1, T2, ..., error := SomeFunc() if err != nil { // do something } ``` and that could be converted into: ``` T1, T2, ... := try(SomeFunc()) ```
I always love Go for this reason. Blazingly fast, easy to read, no generics to worry about.
Great answer. I agree
&gt; The Libra Blockchain is open source with an Apache 2.0 license, and any developer can build apps that work with it using the Move coding language. The blockchain‚Äôs prototype launches its testnet today, so it‚Äôs effectively in developer beta mode until it officially launches in the first half of 2020. The Libra Association is working with HackerOne to launch a bug bounty system later this year that will pay security researchers for safely identifying flaws and glitches. In the meantime, the Libra Association is implementing the Libra Core using the Rust programming language because it‚Äôs designed to prevent security vulnerabilities, and the Move language isn‚Äôt fully ready yet. This leads me to believe they will use their own language. Rust is being used temporarily.
That's more of a /r/rust question where folks do bit of circle jerking about which project should be written in Rust or why some project author need to be convinced to rewrite stuff in Rust etc. In my experience people here write Go code (or not) and move on to other important things instead of debating why the whole world must write Go.
&gt;You can't generate useful mocks, you have to put specific behavior in them that you can test against. This is not true at all. On the contrary, mocks generated by [&gt;!mockgen!&lt;](https://github.com/golang/mock) are designed *not* to contain logic that validates particular behaviour. That logic is supposed to be part of the individual tests. But the question of whether to commit generated code is it's own topic. For what it's worth, my opinion is that the decision should be implemented consistently (commit all generated code or none at all), but the decision itself depends on the individual project and team (and probably other factors too).
&gt; The metrics library is the fork of client_golang, so you did fork and didn't contribute anything to client_golang. OK, show me common code between these libraries: - https://github.com/prometheus/client_golang - https://github.com/VictoriaMetrics/metrics
Would you be happier if golang made you manually instantiate each thread in a thread pool and feed that into the go runtime, then start that runtime first thing in `main` before using goreoutines would work? Because go as it is go hides plenty of implementation details from you for basic language functionality, and it's generally considered a feature that go lets you just `go stuff()`.
That is only in the context of constructing them directly from another container. If you consider the Go approach of not creating so many temporary intermediate containers, then you don't know how many items will need to go into the list until you have tested the membership. The same would happen in Python if you were appending to a list. What I don't know is how the allocations work in lists in cpython when you are appending. I don't know if they allocate chunks or if they allocate on every append. Or if they are a linked list.
I don't really understand your point, to be honest. I am not saying that Go should make every single implementation detail explicit to the user. I'm saying that Go tends to not hide the time and space complexity of operations that in other languages are hidden. It is just that when you look at `list(set(a) - set(b))` it can be quite easy for less experience programmers to miss the complexity that is really going on. I feel you have gone to an extreme in proposing that I would want every runtime detail to be explicit.
Check out the net/http package - set up a handler for POST data. The browser doesn't do anything with POST data other than send it to a web server
it needs to be fast and secure and they prolly are hesitant to use a competitors language for something like this
&gt; I would still pick JS for the front end right now What other option do you have?
Swift, Objective-C, and Java are common choices.
You‚Äôre looking for high level functions I believe. I haven‚Äôt used yield in python but have in Ruby. That‚Äôs just a high level function.
You‚Äôll have to start by defining what ‚Äúfunctional‚Äù means.
Go is a multi-paradigm language... Functional paradigm included.
False premise. Go is functional! To add to that, it is usually immutable data structures that people are actually referring to when they talk about reasoning about code. There is nothing about Go that prevents you from using immutable data structures, but there is nothing in the language that forces you into that paradigm.
[removed]
[removed]
&gt; The key point here is our programmers are Googlers, they‚Äôre not researchers. They‚Äôre typically, fairly young, fresh out of school, probably learned Java, maybe learned C or C++, probably learned Python. They‚Äôre not capable of understanding a brilliant language but we want to use them to build good software. So, the language that we give them has to be easy for them to understand and easy to adopt. &gt; ‚Äì Rob Pike
Go has generics. Go's maps are generic, go's channels are generic, go's slices are generic as are go's arrays. Go doesn't let you define your own generics, but the language itself is full of them.
Go is a continuation of an older system, Inferno. The Inferno/Limbo/Plan9 ecosystem was a competitor with Java (and Linux to some degree) at the time it came out. Go is explicitly designed around the notion of Communicating Sequential Processes (ie: CSP), which could not be more opposite to functional programming. CSP style encapsulates state per process, where stateful processes exchange immutable messages. It is the combination of sharing state and mutability that is the real problem, not so much just mutability itself. Instead of banishing state, you can control state sharing by having stateful programs exchange immutable messages. Go was co-evolved with Google Earth during its development, apparently written while waiting for C++ code to compile. The original inventors of C and Unix are on the Go team. It is an extremely practical language that is not motivated by a desire to play around with cool academic ideas. Functional languages create problems of their own that need to be solved. Performance (in time and especially in memory) is a hard problem in functional languages. Haskell (for example) is an invitation to creating code that can have an absurd learning curve for people coming from normal languages. Go is about getting on with getting work done. So, it's basically a 1970s language with modern tooling. Being garbage collected, having built-in concurrency, and building static binaries is a good combination for just getting work done. What you really want out of a language is compiler assistance in validating that there are few bugs. Functional programming can be a nuisance when you already have stateful code or specs that do the job with good performance.
My thoughts on this topic would be that crypto requires relatively compute intensive operations. Go is fast enough for most use cases, but Rust is faster. I think it's more interesting that it's not in C. I have no actual knowledge of the decision making, this is just a guess.
Functions are first class citizens in Go, which is the primary thing you need to write pure functional code. In my book, this makes Go a functional language. I'm guessing your question is more "why doesn't Go have &lt;feature&gt; which I have found in other functional languages"? That answer depends on the feature in question. The general answer is that Go's focused, reasonably sized standard lib and language spec are a major strength of the language, and that means that Go's maintainers have to pick and choose what goes in it carefully. Your feature may be excluded because its not universally useful enough, or because it results in there being two ways to do something. Many features have decent implementations outside of Go's standard library. If you let us know what you're looking for, we may be able to help you find it.
The updated bit about sync.Pool needing a pointer is wrong. You can‚Äôt trust some random commenter on Hacker News to know what they‚Äôre talking about. That‚Äôs what Reddit is for.
Typescript probably. Personally, I can't wait for web assembly to be widely adopted.
Generics don‚Äôt ruin a language lmao. The lack of generics is a serious flaw imo.
I personally do, as one of the lead developers on my team.
TS is a superset of JS.
Yes that's my approach. Athens GOPROXY is still a bit flaky so you still need to rely on go module cache if you're not vendoring; therefore some of the above points about shared cache etc are valid. But once Athens irons out it's kinks... The idea of rebasing on a large project with moving dependencies and a vendor directory &lt;shudder&gt;
Assuming you've created a new instance of `MyCtx` with each incoming request, then tentatively yes. There's a lot of ways you can goof up thread safety. For added safety you could make `MyCtx.Token` private, then use a getter to prevent overwrites.
&gt; no generics to worry about. Right, instead we just have to reimplement them in some adhoc way. Stop acting like this is an advantage. Just because generics are absent from the language doesn't mean the problems generics solve are.
What do you do with rust professionally?
My guess is safety. Ethereum had some problems with Go due to lack of immutability: [https://www.youtube.com/watch?v=fNUx4jHTaIc](https://www.youtube.com/watch?v=fNUx4jHTaIc)
Hey Thanks for taking the time to write down on how I can improve. Really appreciate it. My end goal is to create [https://github.com/PandaWhoCodes/udhaar.site](https://github.com/PandaWhoCodes/udhaar.site) this Flask app but using Go. So the next tutorial is on sql. Then on serving webpages using Go, then putting it all together. Is it okay if I send you a draft before posting anything ? &amp;#x200B; I do use mux.Vars(r) but I see you point, I need to do more explanation on why I am using what I'm using. Thanks again for your feedback.
That sounds like a similar, but very different, thing he said to the thing I half-remember.
Define a struct matching the json. Then you can do: "result.Key1.Key2.Key3[1]"
This doesn't work as expected anyways. All arguments to the deferred function are evaluated immediately. So this is basically a defered call to ObserveTimer(0)
For sql abstraction I can only recommend using the gorm library. It's pretty cool once you get the hang of it. And with gorms automigrate feature it will also create database and tables for you ;)
``` defer func() { metric.ObserveTimer(time.Since(before)) } () ``` you know that's not the point.
If you would return a `var mySlice []byte` to the pool using `pool.Put(mySlice)` you would require an allocation to move the slice header to the heap. So using a pointer here in the first place actually makes sense. Alternatively you can just keep the original `interface{}` value you got from `Get()` and return that. But doing so brings other other problems with it.
You can write bad code both ways, but overly broad generics tend to lead to it much faster. Hopefully the solution we end up with will meet the needs of enough people that we won't keep seeing complaining about generics not being as good as &lt;insert x language with broad generics here&gt;.
Only an insane person would select Objective-C or Java for front end code.
Would you be surprised if I told you there are plenty of devs who can't figure out "fine-grained encapsulation + immutable types with constructors"? It's better for your code to be simple and easy to follow than complicated but meeting some fantasy about easy interchangeability (and that somehow making it more.maintainable).
Wat
My guess for them not using C is that it is prone to memory leaks.
Looking at the the readme I assume this package does not lower case the keys in YAML by default correct (on a mobile so can‚Äôt test)? If so this just won a new user. I‚Äôm stuck using an old version of viper because of that.
Best way to go unless you have very specific circumstances. See the example at https://golang.org/pkg/encoding/json/#Unmarshal
Dont know so much about Rust, can it do the same as Go and generate a single binary ?
Because compile-time throwing type safety out the window and littering anything you'd use generics for with `interface{}` is clearly the better option
_usually_ if you run `go mod tidy` it will make the go.mod and go.sum file content into a more consistent state, but I think there are still a few corner cases that it's not always guaranteed.
Maybe decided by team tech-stack
The example you showed adds more lines. As suggested by other response, it is good idea to run tidy before commit. go.sum actually likes to keep information even for things that are not used (the argument is that you might stop using specific dependency then later start using it again (due to go not allowing to list unused imports), and you would expect to use the same version)
I've never used (and would never recommend using) a package as complex as gomock for this kind of thing, Go already has essentially native and completely easy-to-use mock "hooks" in the form of interfaces. But maybe you're right, maybe it's possible to generate mocks with usable (i.e. non-zero-value) returns. Even so, with very few exceptions, generated code should \_always\_ be committed to a repo. Code generation is something that authors and maintainers should do, never something that users should need to do.
For the web, maybe. But they are sane choices for mobile apps
It doesn't lowercase and break specs. One of the many reasons why we had to ditch viper.
Can you give an example where generics lead to bad code faster? I‚Äôm new to this debate and as an avid user of generics I‚Äôd like to know
I don't understand if you have 1500+ lines in one file, or in more files in the main package. (I personally don't let it grow that much before restructuring, but that's me.) I'll guess you have some functions that have a common purpose. You could put those in separate subfolders of the main project (in a package). If you have more projects with similar code, you can put common purpose files in a library.
What makes you to think that \`The metrics library is the fork of client\_golang\`?
I love the fact it has ÊúçÂä°Â≠êÂëΩ‰ª§. If I only knew what it meant. :-) If you want a bigger audience, don't write in a native language ;-) But to be serious about it, you have courage to start a new framework, which is nice. ((I couldn't make it from the project description, but then again I only know Chinese from the things I eat.)
This comment sounds like something out of /r/pcj
Paste a sample of the JSON into here: [https://mholt.github.io/json-to-go/](https://mholt.github.io/json-to-go/) Then use the struct to reference the keys directly.
I guess the OP misses (as I do) higher order functions.
Go has higher order functions.
I've not seen any tutorials as such, but for a lot of things the documentation is concise and easy to hit the ground running with. If you want to look at idiomatic code, there are plenty of good examples to peruse - the standard library is very readable and a good place to start, then there are projects like [upspin](https://github.com/upspin/upspin) too. I'd just start trying to write code. It's probably not going to where it should be at first, but your style will evolve as you learn, just as with any other language. You'd probably be writing some project you don't care about when following a tutorial, so why not just make your own project you're interested in and Google for solutions as you need to.
I've used it before on a project where mockgen mocks had already been generated, and found that it removed some the mundanity of writing mocks. That said, you end up with an awful lot of generated code (which likely has a detrimental effect on test run times), and certain little "quirks" (read: limitations) eventually popped up which meant that some mocks had to be "hand written" anyway. And I've not found myself reaching for mockgen or anything similar since I left that project a year ago - so I guess that speaks for itself. Regarding generated code: generally I would agree that it should be committed. However, past experience has taught me that this is not always the best way, and can lead to issues ensuring that the source of the generated code and the generated code itself remains "in sync". In one particular case, there was a pipeline of half a dozen steps that at the end of it produced a very large amount of generated code that was maintained by a lot of geographically disparate teams with varying knowledge of the project and Go in general. The issues that arose from generated code in this project were very real, and could have been easily solved by *not* committing it. But I agree that usually generated code should be committed, but sometimes circumstances dictate that this is definitely the wrong decision.
The python list has amortized constant time append operations just like every other standard library list in pretty much any language. It is not a linked list. It is the same in python and cpython.
It can be tempting to skip the basics and focus on the "cool stuff" only. Sure, virtually all common languages have integers, strings, loops etc. However, there are always subtle differences that can break your code if you are not aware. For example, do you know how Go's classic `for` loop differs from a `range` loop when iterating over strings? Do you know the behavior of the shortcut operator `:=` in the context of multi-assignment statements? Do you know the scoping rules? Do you know when two types are identical? Do you know when a local variable escapes to the heap? Do you know that constants can be untyped (and what the consequences are)? Do you know that Go has no type casting (but instead it has type conversions and type assertions)? These are all quite basic aspects oft he language. And yes, some of these things belong to the cool aspects in Go. So where can you draw the line between the boring stuff you strive to avoid and the idiomatic stuff you are looking for? I recommend taking at least a quick tour on Go's basic language features. I am sure you find the one or the other surprising fact. Or skim through the [Go language specification](https://golang.org/ref/spec) and keep it at hand while learning the advanced parts. The spec is actually quite readable, I used it a lot while learning Go.
`append()` **may** reallocate memory. That is why it returns the array you are appending to. Do not use the original pointer after append and you should get the expected result.
What is TCO?
If the slice is big enough, append will return a slice pointing to the same array. So `a1:=append(a,'d')` will return a slice of the same underlying array as a, if a points to an array at least 3 bytes long. the `a2:=append(a,'g')` call will repeat this process - if a points to an array long enough (as it still does, if it was long enough to append 'd' before), then it, again, adds 'g' after 'a' (which is still 'ba' - the a slice still points to the first 2 characters of the underlying array!) and returns a slice pointing to the same 3 characters as a1, but - as you observed - having modified that buffer and changed a1. If a were allocated a 2-byte underlying array when created, then both append calls would create a new array to append to, and so a1 and a2 would "bad" and "bag." I assume that depending on your build platform/environment, in some cases `a := []byte("ba")` will give you a 2-byte underlying array, while others will give it a larger buffer, most likely 4 or 8 as a minimum allocation size. This may be surprising behavior but it's not a bug in go, though obviously it could be a source of bugs in your program. Slices are basically pointers into arrays that are often only declared implicitly.
Author doesn't know the difference between a Go array and a Go slice. Author also wastes time on an utterly trivial task without adding a single piece of useful information (even for complete beginners) and mis-information (e.g. it's *never* a good idea to sort unbounded input to find the min/max).
The usage of multiple OS is supposed to be covered, according to the modules wiki: [https://github.com/golang/go/wiki/Modules#why-does-go-mod-tidy-record-indirect-and-test-dependencies-in-my-gomod](https://github.com/golang/go/wiki/Modules#why-does-go-mod-tidy-record-indirect-and-test-dependencies-in-my-gomod) "go mod tidy also ensures your current go.mod reflects the dependency requirements for all possible combinations of OS, architecture, and build tags (as described here). In contrast, other commands like go build and go test only update go.mod to provide the packages imported by the requested packages under the current GOOS, GOARCH, and build tags (which is one reason go mod tidy might add requirements that were not added by go build or similar)." &amp;#x200B; AFAIK the sum should remain consistent after running "go mod tidy", so this might be a bug related to your specific packages or something.
I have to disagrer on the abstraction part.
Yes, including statically statically w/o any dynamic reference to libc (using musl e.a.)
Your absolutely correct about the learning by doing approach, it works best for me. I find that throughout education, they tend to just cover the basics, or what's sufficient for you to pass. For my first project, I believe I developed a REST API. Having knowing nothing about the language at all, it was a great way for me to dive in head first. If I came across a problem, I'd research it, and then implement the fix. Once I came a bit more proficient, then I started to go through and refactor things and finally begin to start writing tests. Happy gophering :)
For me, the best projects are those that solve a problem that I'm having. Don't worry too much about whether or not it can use some sort of feature (like goroutines), just focus on writing good software that solves a real problem.
Go code and modules are two different things and you write literally the exact same Go code whether you build with modules or not. As usual: Take the tour and do the exercises. Skip what you are sure to know. Then read about the fine print (which you do not know) of strings, bit-operations, const and maps in the GO blog.golang.org
To add one more: Code does not work on 32bit platforms. (I think this type of blog post appear more often than let's say 3 or 10 years ago. Does anybody have an explanation why this happens? What motivates more and more people to publish such half-baked stuff?)
It's a shame because the value (to me) in min/max of a slice as an interview question is being able to discuss algorithmic complexity and other deeper concepts with a trivial problem. For instance: * *why* a sort is wasteful compared to a linear walk * What sort of approaches would be faster than a linear walk? (I assert log time) * How could you demonstrate these differences with a large sample and Go's built-in tooling? This would also be a great demonstration of the value of the simpler linear walk vs something like a log solution and seeing how big an N is needed for the log code to be significantly better. * Do you have to have separate searches for min and for max, or can you provide both? Pros/Cons for each approach? * **!!** What are the implications in Go of taking a slice as a function parameter and running a sort on it? These questions get into some Go specific things and are potentially more useful for the reader than rehashing trivial problems in a new language syntax.
gameswithgo.org can give you some ideas
C++ is heavily used at FB and other large companies; wouldn't surprise me if the team member we're already familiar with C++ that using the benifits of Rust make more sense than learning Go. There is also a chance that FB "refuse" to use Go because of the "Google" thing!?
Found on \[golang-nuts\]([https://groups.google.com/forum/#!topic/golang-nuts/onlD1GIG00g](https://groups.google.com/forum/#!topic/golang-nuts/onlD1GIG00g)) - see the full announcement there.
I see. The problem is that you're returning the three word slice header, so it needs to be copied, but it's in an interface, so it needs to be passed on the heap as well. The heap part isn't actually the big deal: everything you do with sync.Pool is on the heap, that's kind of the whole point. The problem is that you're both copying _and_ heap allocating the slice headers. Using *[]byte means the headers are still on the heap, but they don't get copied anymore.
[removed]
Only true software engineers call legacy code "dangerous" - minefields, and all. I salute you for accomplishing this mission.
because people keep asking dumb interview questions, so people make blog posts loaded with solutions.
&gt; as an interview question &amp;#x200B; It's a shame people still have 'code min/max of a slice interview questions' in 2019. For real? just sit down, discuss things, you don't need to try bait people with prepared interview questions. Their baring on actual day-to-day work is usually zero. If you asked questions from the dot points instead, you would facilitate a healthy discourse between you and the candidate that got to the crux of the matter quickly. The candidate would also learn from the situation if they didn't do well.
I agree on the point of legacy code rewrites: it is underestimated.
[removed]
[removed]
Thanks for your feedback.
Regarding the maps &amp; GC performance, a question. Using a string is a go-to, but seems quite poor for GC performance. The trade-off of hashing a string each time a map access is required, seems quite significant though?
We could just stop making JavaScript sites... Wouldn't it be glorious.
i recomend you use a secure framework with a well tested implementation rather than reinventen the wheel, when people creare their own implementations specially with regex is very unsecure, there are always ways to trick a regex... use a secure lib that does this for you that is well tested and audited.
How can I do that with a lib ?
Standard Library regex packet. Either predefine your regex with MustCompile oder use the MatchedString function. Just guessing i think the 1st option is faster.
For another release or so, then they'll remove it, like [they removed lots of other GPL software](http://meta.ath0.com/2012/02/05/apples-great-gpl-purge/).
Ok thank you, &amp;#x200B; Anyone can put an example inside my function please, for me to understand better . It would help me a lot please !!
it's extremely hard to convey why it's taking so long to migrate to Linux to the management. In a sense I totally understand their difficulties to understand that the technical debt never has been paid. One thing though, I was one of the devs there in 2001, so really I've inherited my own junior time code base, which hurts sometimes, and is funny at other time.
yes totally. Plus it's not a choice, we really "don't want" to rewrite anything at this point. Systems are running, but I tried doing a lift &amp; shift and it was another too difficult tasks. We decided to dockerized as much as possible and just try to "port" instead of rewrite some aspect.
Go doesn't really support functional programming because it lacks tail call optimization.
I think he's advising you to find a previous implementation rather than rolling your own. It's good advice if the generic implementation happens to mirror your needs and doesn't come with unwanted baggage. I suspect as well that he's recommending you zoom out a bit and work out how much of your code could be covered by someone else's libraries rather than carving your own out from scratch. &amp;#x200B; That said I'm not sure I agree that using a go regex is inherently insecure for this particular task. If you want to understand how to apply a regex anyway it's pretty clearly explained [in the fine manual](https://golang.org/pkg/regexp/). Mostly it's a case of compiling your regex with regex.Compile and then calling the MatchString method on your password.
I'd put a code example in there, maybe you can adapt that. just put the check somewhere before you update the password
Look , I put your block code inside my function, What do you think ? &amp;#x200B; Again thanks a lot for your help &amp;#x200B; func UpdatePassword(unitID string, loginID string, password string) (err error) { f := GetFederation(unitID) ldap := connections[f.Connection] hash, err := HashPassword(password, "SSHA", nil) passRegex := regexp.MustCompile(`?=^.{8,}$)(?=.\d)(?=.*[a-z])(?=.*[A-Z])(?!.*\s)[0-9a-zA-Z!@#$%^&amp;*()]*$`) if passRegex.MatchString(password) { return nil } if err != nil { msg := fmt.Sprintf("password hash generation failed for %s. Error: %s", loginID, err.Error()) return errors.New(msg) } originalPasswordHash, err := mdb.GetUserPasswordHash(loginID, f.ID) if err != nil { if err.Error() == mgo.ErrNotFound.Error() &amp;&amp; ldap != nil { var profile map[string]string profile, err = ldap.GetProfile(loginID) if err != nil { debug.Println("get Profile error ", err) return err } login := profile[config.Connections[f.ID].LoginField] loginID, originalPasswordHash, err = ldap.GetPasswordHash(login) if err != nil { return err } } else { return err } } if err = mdb.ChangeUserPassword(loginID, f.ID, hash); err != nil { debug.Println("ChangeUserPassword error ", err) return err } if ldap != nil { err = ldap.ChangePassword(loginID, password) if err != nil { info.Printf("revert password change in DB for user %s", loginID) if err = mdb.ChangeUserPassword(loginID, f.ID, originalPasswordHash); err != nil { return fmt.Errorf("cannot revert password for user %s in DB", loginID) } return fmt.Errorf("cannot change password for user %s in ldap", loginID) } } return nil }
This is awful. You should do some simple arithmetic instead of iterating through all possible months.
I've not a developer, but I am a platform engineer. I see you have a role, so I might brush up my cv for that.
We actually are, description is here [https://boards.greenhouse.io/monzo/jobs/1428110](https://boards.greenhouse.io/monzo/jobs/1428110)
You say it "keeps" changing but only show a change in one direction. Is something also removing the lines? If not, the file should stabilize where it is. If so, what command is doing that? &amp;#x200B; In general there are up to two lines in go.sum for each module: the first line of each pair in your example is the checksum of the overall file tree; the second line is the checksum of just the go.mod. If a module appears in the dependency graph but nothing from it is imported in a given build, then you end up with just the go.mod in the go.sum file - the overall file tree does not need to be downloaded or processed. (This is especially efficient with proxies that can hand back just the go.mod for a given module version.) &amp;#x200B; In this case it sounds like the package that imports one of these (perhaps something in [github.com/RichardKnop/machinery/](https://github.com/RichardKnop/machinery/)...) is either Linux-specific or macOS-specific, so that it is not being built on the other system. &amp;#x200B; "go mod tidy" should put things in a consistent, portable state, after which "go build" should not need to make any changes to go.sum. If you find that not to be true, that's a bug, in which case please file details at [golang.org/issue/new](https://golang.org/issue/new). Thanks!
Oh cool, actually just watched a video yesterday from Jake Wright about his first day at Monzo.
I didn't quite get what were the issues transitioning to dotnet core. Seems like it would be a smaller step than switching language completely. Can you elaborate? Thanks.
The for loop is a new scope and go allows for shadowed variables however you can check for shem with go vet shadow ``` go get -u golang.org/x/tools/go/analysis/passes/shadow/cmd/shadow go vet -vettool=$(which shadow) ``` Add this to your CI or editor on save and you can spot shadowing that you may not want.
Anyone can check my solution please ?
I really can't think of any working definition of functional programming that I've ever heard anyone use that would include Go.
I don‚Äôt know about an error, but everyone should have their lexer screaming about this.
And higher order functions are basically pointless because of lack of generics.
I work for Facebook and also code a lot of projects in Go. It's using the right language for the job/team/whatever Also, there here is more than technical merits of a language that dictates what you should use. I can't speak for the team who worked on Libra but I am sure they had a good reason for Rust. Never is one of those technical merits "because it's was written at Google". That is just silly. Some (little) proof that Facebook does use Go. https://github.com/facebookincubator?utf8=%E2%9C%93&amp;q=&amp;type=&amp;language=go https://github.com/golang/go/blob/master/AUTHORS#L460
Because the crazy go devs thought it was a good idea that go build updates you mod and sum files... You have to do 'go build -mod=readonly' to behave properly...
Higher order function like map, fold, or filter, which go does not have, require generics to be useful.
What definition(s) do you have on hand? I cannot think of any definition of functional programming that wouldn't include Go. However, as stated above, Go does not fit the definition of a purely functional programming language. But neither does Lisp, and I have never met anyone who doesn't consider Lisp a functional programming language.
Go is not multi paradigm, it's imperative only.
Go's support for const values is worse than C's.
p.s: This is for Windows only.
Why? If you write the same code in C or Lisp you have the same result.
you could to "if !passRegex.MatchString(password) {handle error here}" &amp;#x200B; because passRegex.MatchString(password) returns true or false, no need for error checking if you put it that way
I have this too &amp;#x200B; matched, err := regexp.MatchString(`?=^.{8,}$)(?=.\d)(?=.*[a-z])(?=.*[A-Z])(?!.*\s)[0-9a-zA-Z!@#$%^&amp;*()]*$`, password) if err != nil { debug.Println("Password error : %s ", matched, err) } What do you think ? &amp;#x200B; Thanks for your help
I did not say sort was a good idea. Just that is the it's the easiest way. You know the most brute force way.
You must understand that what you are trying to do is _wrong_. Encoding some enforced password complexity into an unreadable regexp is **wrong**. Especially as the regexp you are keen to use makes use of syntax which is **not** **supported** by Go's regexp package. Nobody sane is going to try and understand your regexp monster and transliterate into Go-regexp-syntax (if this is possible at all!). Just stop that regexp exercise and write two handful of lines of code which check that the right amount of lower/upper/number/special characters are present.
London... no way :(
Same, he recently posted a video about a day at Monzo.
you are correct sir, technically correct ! didn't think of that... i second what he says!
 Two lines of code you said ? Ok, but without regexp, how can I reinforce my password then? &amp;#x200B; I said, it's possible to have an example with my function ? Because I don't see how can I make other ?
Not quiet. It will not be copied. Go knows that the header will escape to the heap at some point in the `New` function, so it will directly allocate it there and put the pointer into the interface{} object. You can check this by compiling with `-gcflags="-m"`.
Password complexity enforcement? Make explicit checks for the complexity requirements, a regexp is not a great, maintainable way to accomplish this.
So How would you do this inside my function above
Isn‚Äôt that because of the `:=`?
Composition in Go is terrible, for one. The fact that functions are values is cute and all, but without generics, who cares really? You can't write map. You can't write fold. Forget any of the more interesting traversals. That's why I said I can't think of any definition of "functional" that working programmers actually use that would fit Go. Go and lisp could hardly be more different.
&gt; You can't write map. Sure you can. func mapint(i []int, fn func(int) int) []int { r := make([]int, len(i)) for i, v := range i { r[i] = fn(v) } return r } Generics would help with development effort, but there is nothing about functional programming that requires generics.
Do you hire contractors? Or perm role only?
I still have to check it out, but I think this is a great idea to have beginning developers work with this to gain more knowledge along their "game" :-) (Why didn't I think of this hahahah)
Preferably loud and with curse words :)
IMO Java is overly complex mostly due to the abuse of two of the JVM's features: * dynamic code loading * reflection Most of the abominations created by the java community are based off of these two features, including: * runtime DI frameworks (Spring, Guice) * runtime AOP (AspectJ) * Complex ORMs (Hibernate) * Complex web containers Without dynamic code loading and reflection, the above features are impossible to implement. In fact, for java programs that want to be compiled to native code via Graal/SubstrateVM, none of the above frameworks can really be used at the moment. Note that none of the above frameworks are intrinsic to Java the language. In fact, I believe that for the most part you can write simple Java the way people write simple GoLang. The problem IMO is the community, not the language.
Why should it give an error? Variables are block scoped. The 'x' inside the loop shadows the external 'x'.
The major issues were with code that are not present / working in .NET Core. I gave some examples in the article, but you can think of all configuration changes, the way authentication was done, the way we used Razor view generation via code (for email rendering and lots of template). We also thought it would have been a semi straight forward experience. But it was not. Maybe the current application was not following what Microsoft called best practices and that makes the migration to .NET Core X times harder than what it should be. Also we had some issues with passing XML Soap services to run on the .NET Core. In short, apart of the DLL that used System.Data.SqlClient it was all but straight forward.
I really dont get Op 4 :D some clues ? I suspect that i have to something with interfaces.
Oh, I didn't notice the link to the article. :) Now it's much clearer.
There‚Äôs no real world evidence that only using pure functions is better for distributed systems. People say that a lot, but they can‚Äôt point to real projects that show the point. Haskell is a notoriously difficult language, which if anything goes to show that pure languages make it harder to create large scale systems. Purity is fine in small doses, but used in large systems it creates performance problems that then need to be hacked around and eat up whatever the supposed benefits of purity were.
Given that Facebook has the resources, they can overlook the complexity of Rust. They also don't need their code to be easy to contribute to. So all the reasons that Go is a simple language without compile-time metaprogramming features don't apply to them. I also wouldn't make a library that's intended to be called from other languages in anything that requires a runtime.
Exactly :) Try creating a "BadCamera".
It is because of that. `:=` infers the type AND declares a new variable.
Perm only for now, but the compensation packages are competitive
You can work remote if you prefer
This snippet is naive, inefficient and not go-like. Instead, you can simply calculate months like this: ts1 := time.Date(2019, time.January, 0, 0, 0, 0, 0, time.UTC) duration := time.Since(ts1) months := duration.Hours() / 24 / 30 fmt.Println("months since", ts1, "is", months) https://play.golang.org/p/_EsKQVcTIj0
https://rpeshkov.net/blog/golang-variable-shadowing/
It's expecting to start recording on some kind of recording device... perhaps you can make your own :P (Hope that's not too much of a clue)
thank you for the answer! Good to know
Number 5 was fun :) Not sure I followed the rules.
&gt; In fact, I believe that for the most part you can write simple Java the way people write simple GoLang. The problem is the community, not the language. You CAN write Java simply, but that's not the nature of developers. They'll use all of the functionality available to them. I don't want to see Go become Java With Easy Concurrency. Generics is on the table. What's next? Polymorphism is useful... So is inheritance....
I tried it with `var =` and it still works
Sure. `x := 1` and `var x = 1` are precisely the same thing.
Because that _also_ creates a new variable.
Weird example that panics on nil.
in the exercise you have a "type Camera struct" that has a function "func (c Camera) record() string". So it implements all functions of the interface RecordingDevice. Thats why in the main function you can call "startRecording(camera)" on the camera object. You have to write another "type MyCamera struct" and implement a new record() function for that struct to solve the exercise ;)
The only rule is to have fun :)
I'm stuck on the LaserGrid. Got a hint? I haven't used go for about 2 years, this is a great refresher!
But it is a copy because every invocation of Get() will cause a new header allocation. I think we're just disagreeing about terminology.
i really enjoy the game so far :) thank you for creating such a beautiful programming experience ;) im learning go for a couple of months now and im writing go code on some small projects. such games making it fun to dive into the concepts of the language. so thanks again ;D
Just found out I can do a midwest time zone. Do you know anyone?
Nice touch using "fine".
Who ever gets hired, please implement international money transfers first (and no, Transferwise isn't the same thing). Monzo is great, but it's kinda embarassing to have a bank in 2019 that doesn't even have IBAN numbers.
Open to part-time positions with flexible working hours??
Saw that, enjoyed his video
reboot /s
My recommendation in general is to rewrite something you've written in another language. If you haven't done anything in another language, pick a problem that you understand implicitly, like sorting or math functions or downloading/uploading files. The reason I suggest this is because then you can focus on learning only Go, instead of having to learn a new domain (e.g., search, AI) AND learn a new language at the same time. For example, if you've built a tic-tac-toe game in Javascript or PHP or Python, then build the same thing in Go. You know how the business logic works, so you can focus on the syntax of Go without having to reason about how tic-tac-toe logic works.
Not according to your own job post "we're open to remote working (as long as you can spend around 20% of your time in London)."
Then the material should be a breeze. Read it.
maybe... sent this post to him now
Sure thing. \`setupLasers\` needs to have all the lasers active. But \`testGrid\` doesn't. If only there was some way to modify the struct after the \`setupLasers\` function is called. Hopefully this \_points\_ you in the right direction :)
&gt; Haskell is a notoriously difficult language What makes you think so? It's an quite simple language, much more simple than many mainstream languages, like Python. And Scala/Akka and Erlang are used for large scale systems quite a lot, as well as Haskell and OCaml.
Yeah I'm at that point, but it was all by Val not by ref for the grid lasers. I'll have a look tomorrow - it was 2am ü§£ Thank you
So like, first off, don't use a regex, they're slow and overly complicated. Why do a length check in regex when you can just do a len(pwd) in go code which is a constant time check? Just write normal go code using the strings package and it'll be way faster and more readable and maintainable. &amp;#x200B; There's zero need for a regex here.
Great! Can you please elaborate on this a bit? &gt; We care deeply about inclusive working practices and diverse teams. If you‚Äôd prefer to work part-time or as a job-share, we‚Äôll facilitate this wherever we can - whether to help you meet other commitments or to help you strike a great work-life balance. Seems pretty interesting but somewhat unclear in terms of day to day mechanics (in the 'too good to be true' realm)!
Correct, but the `LaserGrid` struct is editable :)
If written incorrectly, of course.
&gt; Free licenses for students. Pretty incredible for a company to do this with no strings attached. I mean I agree with what you're saying, but you're wrong in this instance. The educational license doesn't let you use their IDEs for commercial use.
[removed]
This gets a little broad. You might want to refresh your basic skill by redoing the Tour of Go once more.
What's the line then? `go stuff()` has a whole bunch of overhead implied in it you (As a feature) don't need to consider. Operations on a slice that might result in reallocation. A lot of begginers probably couldn't describe what it takes in terms of memory or operations to get a runtime format performed or determine if a given string is valid utf-8. Should they all be broken down in to more fundamental units that better expose their cost? If not, why are these different cases than having a set type?
&gt; but the compensation packages are competitive That's what *everyone* says ;)
One of the specific design goals of Go (much more than "building distributed systems") was to enable new developers to hit the ground running. Functional programming languages just‚Ä¶ don't seem particularly good at that. For sure not for the majority of programmers. I would also argue with the premise that FP makes "reasoning about code easier" - *some* code gets easier to understand, but for the vast majority of problems, I find that FP over-abstracts and obscures what's actually happening in the machine. Reading even a simple Haskell program takes me‚Ä¶ forever, to actually figure out how all the types fit together and how the data flows. In any case there's at least not a universal answer to this, I think it depends heavily on the person.
[removed]
I don't really understand what the headline is trying to say is the bug here. There isn't really a bug in Go, at least, this is WAI. This is, however, indeed a simple way to introduce a bug *into your own programs*.
The focus here is on the constructors. Go doesn't, for instance, have a slice constructors that would let you produce a new slice from the keys in a map, ala `[]string(aMap)`. And even if they did provide a set type in Go, they wouldn't consider it very "Go" like to allow users to write `[]string({}string(x) - {}string(y)) `
We're on it! :)
Yes
You will have to come to the office once in a while, most people seem to fly in once every couple months, but if you're so far this is really inconvenient you might be able to sort something out with the hiring team
It's ambiguous because it's dealt with on a case by case basis. If you have specific questions I can forward them to the hiring team :)
If the JSON has no particular schema, then yes, that's what you have to do. If the JSON has a schema, define some structs using JSON-to-Go as posted in this thread.
&gt; You should apply if: &gt; * you‚Äôre passionate about yaml Do you really have team members who are passionate about YAML? ;-) (And are they real humans?)
I know you guys are technically on it, but it's been quite a while since we had any updates from you on this and it's made worse by the fact that some of your competitors had this basic feature for a long time now. Anyway, not really appropriate for this thread, sorry about the distraction :)
I believe writing a scraper/crawler is a very good way to learn new languages. It touches different aspects depending upon how sophisticated you want it to be starting with very naive approach. I used the [same approach](https://github.com/pkmishra/goscraper) not sure if it is useful though.
I guess any passionate opinion counts? :D
It's got a spec so long and winding, George R R Martin is jealous
Remote as in UK/EU or world wide remote like the US?
BTW the #jobs channel in the gopher slack is pretty active too so you might want to post there
When you say &gt;we're open to remote working (as long as you can spend around 20% of your time in London) does that mean the company pays for the flight and place you stay or that comes out of your own paycheck? Sorry if it's a commonly known answer, I'm 16 and I've only ever worked locally.
What a great tool! Many thanks!
That's pretty cool, and a lot better than what Revolut had discussed with me in the past. I've just moved jobs though but I'll bear it in mind.
Has there been any changes to the recruitment process lately? I was *really* tempted to apply back in March when I saw some job postings. The tech stack looks great, whenever I've met staff in *The Flying Horse* after work they've been a great bunch, and the company itself is brilliant. Unfortunately I checked Glassdoor and saw that the process wasn't very seamless, and coming from a contracting background (so immediate availability for the right permanent job) there was no real way I could've held off on other offers that long. (I think I heard up to *6 months* from one person?)
I'm told there was a point last year where the recruitment team was really overwhelmed, but that has been sorted since,
By this definition Scala and Clojure would also not count as functional languages.
Is remote from Canada accepted !??
&gt; _I am writing an application where; given an html form, the application should: parse the values and create POST DATA from that values, like a browser. How can i achieve that?_ &gt; &gt; submitted by /u/bukens Here‚Äôs an example of an HTML form: &lt;form action="/" method="post"&gt; &lt;input type="hidden" name="csrf" value="3858f62230"&gt; &lt;label&gt;Username:&lt;/label&gt;&lt;input type="text" name="username"&gt; &lt;label&gt;Password:&lt;/label&gt;&lt;input type="password" name="password"&gt; &lt;/form&gt; Here‚Äôs how you‚Äôd handle the POST request in Go: package main import ("fmt";"net/http") func login(w http.ResponseWriter, r *http.Request) { if err := r.ParseForm(); err != nil { http.Error(w, err.Error(), http.StatusInternalServerError) return } username := r.Form.Get("username") password := r.Form.Get("password") fmt.Fprintf(w, "Username: `%s`\nPassword: `%s`\n", username, password) }
Do you guys ever higher Junior level developers? I've got some experience through a few internships and school work but I'm finishing up my masters here in December and will be looking around then.
[removed]
We sometimes do, but not now afaik
Do you accept remote applicants from Brazil?
I think the final level was goofy. The code provided doesn't have the capability of "unzipping" the files. Unzip should return a File, not a bool. I made it work, but it just didn't make sense like the others did.
The fact that you have to write a separate map function for every possible combination of types or else throw away type safety altogether using interface{} proves the point of why go should not be considered a functional language. Saying it is functional is just being pedantic at that point.