I love memes
in what way do these knobs do the same thing? these flags are dual to each other, and mutually exclusive - not identical.
&gt; while we're waiting for that information, we're also potentially populating the ecosystem with a bunch of unnecessarily tight constraints. Explicit &gt; magical. I've wasted many hours trying to figure out why do I end up with the wrong dependency version. And then some time wishing untimely and painful death unto whoever decided that equals doesn't really mean equals. &gt; i did forget to note in the post that we're not the first to do this - cargo does as well You're supposed to learn from others' mistakes, not replicate them.
Seems like the fundamental flaw is the thought that OOP is the appropriate way to approach problems. I've experienced good results by organizing around WHAT the program will do instead of the THINGS that are required to do it. OOP was originally focused on the WHAT (messaging) but seems to have morphed into a focus on THINGS (for a while now...); Alan Kay: http://lists.squeakfoundation.org/pipermail/squeak-dev/1998-October/017019.html Edit: and Go is an excellent way to learn this... :) 
&gt; Based on previous experience with this so called just prototyping approach, it never got dropped. there's plenty of things we dropped and changed, largely in response to feedback that we got. we did not accept some of the feedback you provided - especially suggestions that would have amounted to changing the entire trajectory of the project. but that's not the same as not accepting feedback in general. &gt; So you can understand my reluctance to yet another thing that we really really don't need. if i agreed with your premise, then i'd understand your reluctance. please remember that the registry work is not _solely_ for hypothetical, public registries - it's also for private ones. that's a repeated pain point brought to me by _many_ organizations. &gt; We need dep to be stable and usable. How about we have that first then prototype anything else? we consider dep [safe for production use](https://github.com/golang/dep#current-status). progress on a registry is orthogonal to work on CLI bugs and UX - literally no one who's working on one is working on the other, with the exception of me providing high-level commentary and guidance. this is open source. neither you, nor i, get to decide what people choose to work on. to the extent i am able to channel folks in particular directions, it is generally in furtherance of stability and usability. i mentioned the registry work because it's something that's emerged out of other peoples' interest, and i wanted to make sure the community is informed. 
maybe! time will tell. my view is that it's because the model we've chosen to adopt obviates the need for such knobs, while still covering such edge cases. but this is argument at the level of general metaphors - if we want to actually have this discussion, it'd be better to pick something concrete.
the issue was closed after the decision was made, as leaving it open would have given the wrong impression. i locked it because this is a _classic_ bikeshed, and continue to litigate the issue after the fact is just harmful. nothing prevents people from opening a new issue. when folks do, we explain that it's something we can revisit when toolchain transition time comes. this was mentioned multiple times in the original issue. the issue was open for 2.5 months, and people weighed in with their thoughts quite a bit. but this is one of those clear-cut decisions - and, again, bikesheds - where it's just not possible to please everyone.
for sure, all of these things are üíØüíØüíØ reasons why you wouldn't necessarily want to pull the latest. but somehow, the conversation here jumped track. the dichotomy you're suggesting no longer has to exist: ``` $ dep ensure -add github.com/foo/bar@v1.0.0 ``` now, you've specified the dependency ahead of time, and the constraint rule will be appended into `Gopkg.toml` (assuming the named project is accessible, the version exists, an overall solution can be found, etc.). after that, you start using it in your code. EDIT - i realized what people are complaining about after writing this. we can probably improve our CLI constraint parsing - it needn't be the same as how `Gopkg.toml` works.
&gt;&gt;Lol, yes I find computer science worthless because I said no one wants to have a regurgitated computer science discussion. It's too bad you don't know what to tell me, I don't program for a living and needed you to enlighten me :( The thing is your comment invited such a remark. The way I see, they only reacted in turn.
&gt; Explicit &gt; magical. i agree. it just wasn't the most important consideration in this particular case.
So you are telling me that you use a strong statically typed language like go for safely writing server side programs yet the complete loss of type safety when using empty interfaces is no concern to you? The standard library is riddled with empty interfaces. These empty interfaces are only there because the language lacks mechanisms to properly handle such situations. If the development of Go 2 focused on real issues then fixing the type system should be number 1 on the list.
underscore import does not add anything to the scope, it's only useful for side-effects of imports, ie. running init(). what you want is regular import, and use `routes` as that is what your package name is, not `Routers`.
ahh! i see what you're saying. i think i was off on a different track, sorry. i think this is actually something we can rework. while implicit carets are absolutely gonna stick around with the declarations in `Gopkg.toml`, we don't have to treat CLI args quite the same way. it's probably better not to, really. the background on the CLI arg parser is that we really didn't touch it with this refactor, so it's still back in the mindset from before, where `ensure` was supposed to do _all_ the management of the manifest. and, in the big refactor, i just didn't account for this part. it seems reasonable to me that we might tamp down the scope of that behavior so that we don't assume, or even allow, ranges to be specified via `dep ensure -add`. when people name a version on the CLI, it's absolutely silly to not get just that specific version. and we can do that. we'll still write the bare/implicit caret version to `Gopkg.toml`, for all the bigger picture reasons. but the originally-specified CLI version generally won't move in `Gopkg.lock` without a `dep ensure -update` - that's the whole way this is supposed to work. EDIT: issue created - https://github.com/golang/dep/issues/1036
Your solution brings up the issue of third party tools to solve the problems of the type system. There are many third party tools, all trying to solve the same problem. I see this only adding to the complexity of using the language. Yea, sure, the language is simple, but so simple that it creates its own problems, one of which is the use of third party tools to solve the shortcomings of the language. These tools exist outside of the core ecosystem. These tools are maintained by small communities, if not just one person. These tools also have the potential to fracture the language. That is a huge issue. I am not sure I am willing to hang my hat on a tool that may not exist for the life of a project that could span years and even decades. I've said this many times. The solution is a rewriter. However this rewriter must exist within the core ecosystem. So the question that should be asked is what does generics mean to you. What forms of generics do you use. How could your solution be implemented as a rewriter. This rewriter could be activated with a source code tag, or even a compiler flag. I also totally dismiss the notion that such mechanisms would noticeably slow compile times. Another issue is the fact that the core Go team seems insistent on such mechanisms being part of the runtime. Interfaces are the runtime solution to polymorphism. Now what is needed is a compile time solution for the same problem. You might ask why two different solutions? Because the runtime solutions put pressure on the garbage collector. It would be great if there was a solution that also help relieve some of the pressure on the gc created by such runtime solutions. I've made this comment in the past many times. Some of those working on the runtime have agreed with my assertions. gofmt is a rewriter. how is it that such a rewriter is accepted but another type of rewriter is dismissed? Empty interfaces is not a solution, it is a time bomb, waiting to fuck you up in indescribable ways. I wish I could direct you to my previous comments about the issue, but I only use burners and lost track of the countless accounts. You might asked why so many accounts? To circumvent the overly oppressive moderation of this sub.
There's a Go Font? üòÖ
cheers. that sorted me out. go has some strange quirks
It's true that Go does not approach problems in your traditional C++ way. So, you won't be learning the traditional classes and inheritance. But the important question is why do you consider not knowing OOP to be a "bad" thing. OOP is just one way of approaching problems which several programming languages leverage. But there are tradeoffs. Other languages don't use OOP completely. Consider a different question - "Will a new programmer learning C++ have a deficiency in their Functional Programming knowledge ?"
https://blog.golang.org/go-fonts
I use Mac and Linux and dep, and I have no idea what kinds of friction you are suggesting might occur?
Mac doesn't distinguish cases, so a dev checks in gopkg.toml and it works fine. Different dev checks it out on Linux and it is broken. 
I am not sure what you mean. I don't think any of the solutions needs 3rd party tools. If you are talking about code generation, the standard library tooling should be sufficient.
I find it bizarre that Go developers, of all people, are so angry about things having names in which the first letter is capitalized.
Ok, I think you should postpone replying until you fully understand the issue and the current solutions. Go generate was only added after months if not years of argument. And that took me years of insisting on such a tool. before then there was no real solution for a cross platform build tool. Finally, a light went off above Rob, and he answered the call. And that is only one of the building blocks needed for a sufficient solution. Go generate even has its problems.
Yes. Using dep and loving it. Good work.
Oh, right. Yes, if people name the file incorrectly on the Mac, the tools might not notice. However, it would be easy enough to add a check for that, as the Mac is also case-preserving. I'll put in a ticket for that, in fact.
I believe I have a pretty good grasp of the subject. See some of my [comments](https://www.reddit.com/r/golang/comments/6u9pvn/the_future_of_go/dlryspl/).
&gt; it just wasn't the most important consideration in this particular case I strongly disagree. Also to counter the Rust example: - Python Pip: `=` is invalid, `==` locks to a specific version - Javascript npm, yarn: `package: 1.0.0` locks to a specific version - PHP composer: `package: 1.0.0` locks to a specific version - Ruby Gems: locks to specific version - Java: Apache Ivy, Maven: locks to specific version - C# nuget: locks to specific version - Erlang Rebar: locks to a specific version - Swift package manager: locks to a specific version if full version is provided, if partial it's a 1.2.x equivalent 
https://np.reddit.com/r/golang/comments/6na5sy/it_came_to_them_with_a_message/
[removed]
I think it is because we want to avoid cross platform issues.
Thank you for your response, the terms protocol contracts vs implementation details helped in understanding the concept. 
Thank you, I was under the impression OOP was the be all and end all of big boy programming. 
ok, I will let you believe that....for now. However the link reveals nothing, and your posts that I have already read overtly dismiss the feature as useful and/or necessary in a modern language. I will comb your comments for generics related material. However, I may not reply, as I am pretty much over arguing about it. I'd rather put my time into a solution, now that the go team is openly asking for solutions, instead of arguing with those that dismiss its need.
It would help if you'd show what the resulting query should be, but I am assuming something like: SELECT * FROM aTable WHERE firstname=? AND lastname=? So, what about query := "SELECT * FROM aTable WHERE" params := []interface{}{} for k, v := formQueryParams { query += fmt.Sprintf("%v=?", k) // here you can quote the identifier or sanitize it params = append(params, v) // if your values are not all strings you may need to convert them to the appropriate type } res, err := db.Query(query, params...) 
I do not dismiss the need for generics. But when someone tells me that generics have no drawbacks at all or that Go has no solution for this problem today then I gotta reply to that. Generics will most likely happen in Go 2. We need good experience reports to help the Go team and make sure they get it right. &gt; I'd rather put my time into a solution, now that the go team is openly asking for solutions, instead of arguing with those that dismiss its need. It's ironic that that someone as well versed in the subject as you claim to be does not understand that the Go team is not looking for solutions but for problems. 
@manisrjain from distsys slack - so based on the post, I think they may still have one issue, which is the need to fsync() the directory after a rename operation (Jason)
No, it has been stated that they understand the need for polymorphism. However they admit they don't fully understand the problem, as generics is a catchall for all sorts of mechanisms, so they would like a more precise estimation of the problem. Not only are they asking for problems, but also solutions to the problems. I fully understand the problem, so I can identify the problem and suggest a solution at the same time. they openly welcome such work. **I'd like to add that currently there is no solution , only bandaids, that is why a real solution is desperately needed. 
Ah, thank you. That is my new language policy as well. Yes, can confirm, these limits are coming from Go, not you. Have fun!
Renames are atomic in almost all modern file systems. You need to sync the directory only if you add (or delete) files to that directory. Update: Based on `man 2 rename`: If newpath already exists, it will be atomically replaced, so that there is no point at which another process attempting to access newpath will find it missing. However, there will probably be a window in which both oldpath and newpath refer to the file being renamed. We only rename one file, i.e. MANIFEST. And in that, we ensure that the newpath exists and the oldpath is synced to disk before renaming.
I don't think it was as bad as it sounds in this comment. Was one user encountering an issue that we were in the process of fixing already: https://www.reddit.com/r/golang/comments/6b57aa/badger_a_faster_kv_store/dhm4yyk/ We have never seen data loss with Badger, ever. Also, re: fsync, with SyncWrites=true, that worked great. We only made some changes to do more explicit syncs when SyncWrites=false. Just wanted to clarify that. The reason to embark on understanding file system behavior and running ALICE was to proactively find issues (not reactively responding to bugs) -- even then we only found a couple; so Badger is rock solid by now :-).
[removed]
Thank you, It seems a lot of GO fans are Smalltalk fans and vice versa. I was not familiar with Smalltalk until my research into GO. The link to Mr. Kay's message was informative. 
I'm going to have to respectfully disagree. There are basic software principles that allow one to create safe and robust software. One of those principles is that invariants should be maintained. As it stands, by exposing Wheels, that type does not maintain its invariant... and therefore makes any code that uses it less safe and less reliable. It's weird for me to see people advocating techniques that are in direct contradiction to basic professional software principles because they don't agree with "Go's idioms"? Then change Go's idioms... don't dumb down your software.
Ick, it has serifs.
ah yes, we've looked at all those. and more, across a number of dimensions. i didn't mean to suggest that this approach is common - just that we're not the first. your objection is noted!
Yea, a font is what a language needs, not something as useless as generics. Better use code generation, yo
humans never create the files - at least, not in any expected workflow :) but yeah, i think i'd probably accept a patch which disqualifies e.g. `gopkg.toml` on a case-insensitive filesystem. fortunately, we already have logic in place to do the obnoxious work of filesystem case sensitivity detection. 
this was my big concern as well, at least until i looked in more detail, and it seemed that the real issue ends up being driven by accepting _either_ of capitalized or uncapitalized: https://github.com/golang/dep/issues/168#issuecomment-292412282 totally possible that i've missed something there; if so, i'll eat crow and we can address things when toolchain transition time comes.
Can you give some examples (code) where you need to explain the behaviour but are having a hard time to? I'm having some issues parsing your question, some actual examples might help.
&gt; Yep, that's aggressive, I withdraw the characterization with apologies‚Äîthough I observe Ruby and `Gemfile`. I also observe that this is conversation the distilled and purified essence of a bikeshed, withdraw from it completely, and encourage everyone else to do the same. https://github.com/golang/dep/issues/168#issuecomment-292147746 
Go gives you all the mechanisms necessary to write in a fully OOP style. Receivers which conceptually transform functions into methods to satisfy messaging requirements. Composition of types and the use of unexported fields and methods to satisfy the requirements for encapsulation. Messaging and encapsulation is the essence of OOP, nothing else is needed to satisfy the requirements for OOP, everything else is something else - some other paradigm.
Agreed. If you can mess with the private state of an aggregate, then you won't get the benefits of DDD. Thefn you just have an anemic object model.
THANK YOU! For your detailed reply, part of what attracted to me to GO was it's similarity to C. The brevity of GO syntax is welcome, and something about a complied language just feels better. 
[removed]
I truly appreciate the effort done with ALICE. However, as George R. R. Martin likes to say, words are wind. The fact remains that Badger still defaults to losing data: https://github.com/dgraph-io/badger/blob/748aadf6702a00085d444be0228874eb94f4d563/kv.go#L100 
I highly enjoyed the gopher face addition.
eli5 request, what is the problem with generics? [8]
Well, it looks like it's for a UI package so it's not that weird.
[removed]
It's just an identifier for zero-value. Considering that Go is strongly-typed and they want to keep the spec small, it makes sense that they keep things simple without creating any special rules.
People want Go to have it, but all proposed implementations are too ugly for the Go authors to accept.
Sans-serif fonts are probably for children.
Awesome! Let me know if you have any other questions üòÑ
[removed]
*some* people want Go to have it, many others don't. 
Is your main concern performance? You're tracking a network request so I don't think fetching for the latest time is going to impact your performance at all. If you can gather performance data that shows you're dying from making calls to get the current time, you could build a clock that ticks every 10ms or whatever to give you a "good enough" approximation of the request time. But again, benchmark with and without time. I seriously doubt you'll see a difference. 
You, an uncultured rube: I like sans-serif fonts. Me, an intellectual: You impudent child.
Is only a small test of my puerile regexp engine, against what there is, I will soon investigare in the bowels of re2 to gain more knowledge
I'm... I'm happy without genetics.
Well, I am trying to see which request that takes the longest time. If you have a service that talks to multiple different things in a single call, I need to know which one of these that's taking the longest.
Many of the people who want Go to have it don't even use Go.
How is that aggressive? Aggressive is promoting your project by calling someone else's one harmful (and then locking a GH issue so nobody can answer to your "deep" analysis). That's aggressive. What you wrote is plain stupid. And no, that's not "bikeshedding" but a legit issue. And if you were a bit more attentive you would notice a difference between `Gopkg.toml` and `Gemfile`. A little one at the end.
How would you say this compares to the alternatives, say for example, [Uber's Dig](https://github.com/uber-go/dig)?
Create a new request type that embeds an http.Request, and wrap the methods you want to time.
&gt; It's just an identifier for zero-value I think you meant non-value. Zero value is already a term and concept in Go that is t related to nil.
This library is inspired by uber's [fx](https://github.com/uber-go/fx), i have a simple try, but found it doesn't support multiple same type, so i wrote [go-di](https://github.com/cosiner/go-di). I am missing the backend dig library from fx's documentation, and this is the first time i have seen dig. So stupid. Compare to dig: * No Parameter object, Result object, In, Out, just anonymous structure is enough. * Named values: using structure field name by default or overwrite by tag like `dep:"Logger"` * Automatically gather methods as providers by OptMethods function.
[removed]
if the authors found an implementation they liked, would you still be against it? I don't understand arguing against a simple generics feature.
no god please no.gif
While all this talk may have theoretical merit, in practice, OOP means inheritance. If you interview somewhere and you say you know OOP, they're going to assume you're familiar with the Java/C++ model, which knowledge of just Go would cover only partially.
If that would convert makefile &lt;-&gt; yaml then you could have a use-case. Without it I'd probably use (and adapt) one of dozen formats, which are more widespread (travis, circle etc.).
The easiest way is to start a ssh tunnel to your remote docker daemon, make an `alias remote-docker='DOCKER_HOST=127.0.0.1:tunnelport docker'` and the rest is obvious.
üòö
`nil` is the zero value. It is unfortunate that it is the zero value for *lots* of things: slices, maps, pointers and interface. So there have not been many "decisions made around usage of nil" so there is not much to explain. What exactly are you interested in?
Good idea, thank you!
Generics are not simple.
Well, I disagree.
serif for printing, sans-serif for screen. So unless you're still using a teletype...
I'm not convinced this hierarchy is adapted for go because you will end up having a lot of package having the same name.
[citation needed]
Software systems aren't simple. We shouldn't be using simple tools to build complex systems
Simple to use, but complex to implement. I think Go should have generics, but if you think it's a quick and easy thing to implement you're mistaken.
Very helpful post! To run my smart contracts I have to set a value of 0 (Value: big.NewInt(0)) to make them work. Is their a similar example to make simple tranfer between two accounts ?
A compiler is not meant to be simple.
I agree that std should have a logging interface. I need to add my logger interface to accept loggers in my APIs. It makes DI harder.
I totally disagree! I'd argue that one of the driving principals behind Go is to keep the language as simple as possible, precisely so that complex systems are easier to build and more reliable. A similar theme is also driving the adoption of functional programming languages.
**nil** is the zero value for types A) for which a "non-value" is the only sensible zero value, and/or B) which require a non-trivial amount of initialization before they can be properly used. For example, for pointers, functions and interfaces a non-value is the obvious zero value. What should a zero but non-nil function value be? A NOP returning zero values seems sensible in some ways, but also horribly error-prone. And what should a pointer point to if not explicitly initialized? With Go's syntax and semantics a nil is the only solution that makes sense. On the other hand, channels and maps require a certain amount of allocation and initialization, and there's a clear performance benefit for not doing so implicitly. Go is, above all, a *practical* language, so this seems sensible, even if it's clearly a compromise. Slices are an interesting edge case. Automatic allocation and initialization of a zero-lenght slice wouldn't be a big deal; however, a nil slice *behaves* like an initialized zero-length slice in every way that matters, so again, nil seems like a good, practical solution. A nil slice *is* an empty slice, not a "non-value".
From a usability point of view I agree. The language should be simple to _use_ / write software in. What I meant by complex tools is the language internally, not syntax. Garbage collection and type systems for example are exceptionally complex systems to design and build, yet relatively easy / simple to use. So we are already past the point of no return in that regard. Generics are in my opinion the same, complex to build but not to use (after an initial learning curve). When I see generics in any other language that looks simple to me. In go, writing the same code over and over because we can't use generics, is just really annoying - not simple. For beginners I see the point, it took me a while before I really understood the whole concept. But leaving out such a powerful feature shouldn't be based on some interns potentially having to ask questions about how some portion of code works. Just my $0.2
To *replace C++* and *to replace C++ in one specific company* are two very different things. Go is pretty much the exact opposite of C++. And for a lot of applications, a garbage collected language can never replace C++.
&gt;As far as I understood initially Go was designed to replace C++ (at least at Google) When mentioning this, you should keep in mind, what C++ was used for at Google at the time. AFAIK, it was mostly services, *systems* of services (which is one of the reasons Go used to be called a *systems language*). In this regard, Go *did* replace C++. I don't think the Go creators ever saw Go as a replacement for C/C++ in anything low-level, although it can be done.
I am currently writing a compiler for a language supporting generics. Its a pain in the ass
Actually... that makes a lot of sense. Thanks for the reply. 
I'm one of those people! I started learning it, then learnt about ` for ... range`, then discovered I would never be able to put my own types through it, and I stopped soon after. I've been lurking here, waiting, waiting in the dark, ever since.
It's in fact an easy valid problem to report !
I stopped using Go recently, [not only because of generics](https://www.reddit.com/r/programmingcirclejerk/comments/6uehog/do_we_really_need_syncmap/dlslbxj/). We‚Äôre two, it‚Äôs far from the ‚Äúmany‚Äù claimed. I know, we‚Äôre definitely more, but he pulled that fact out of nowhere.
Big fan of George R. R. Martin's work, but sounds like a forced argument. RocksDB does the same: https://github.com/facebook/rocksdb/blob/master/include/rocksdb/options.h#L1077
Have a look at these articles from russ cox if interested in the Go regexp engine. https://swtch.com/~rsc/regexp/regexp1.html
Rust is already a better C++ replacement than anything that could be called Go 2 would ever be. This is because of a difference in goals, not "goodness" or something. Every language designer must face tradeoffs between the costs of a new feature and the benefits it will bring to the language. C++ and Go sit on opposite ends of the spectrum. Go is quite possibly the language that demands that all of its features give the most before being included in the language of the entire set of "commercially viable languages" out there; I literally can not think of any other designers that demand more from their features before putting them in. And C++ is all the way on the other end of the spectrum; C++ is probably the most complicated "commercially viable language" in existence after repeated releases of standards that introduce new features upon new features that interact with all the old features in insane ways, and even more surprising, I see no evidence that the C++ designers intend to stop anytime soon. There's no way something from the Go process could "replace" something designed by the C++ process. I mean, obviously I like Go for some purposes or I wouldn't be here. But it's never going to be like C++. I consider the C++ designers at this point as basically insane for not either freezing C++ or admitting that they really want to design a C++++. (Call it C+4.) Rust is not that crazy. They are more willing to put things in, but they use a sane standard. Still, they're a lot more willing to try things out than the Go designers, because, well, that's true of just about everybody. I don't expect that the very highest performance code is going to be in Go. If you look at performance per developer effort, Go has a _really_ sharp takeoff on the curve compared to a lot of languages (the "dynamic" language's best performance at the high effort end is below Go's "initial prototype" in a lot of cases), but part of the price it pays for that is that it does plateau out before C, C++, Rust, etc. on the high-effort end of the curve. Fixing that would pretty much inevitably require making the early part of the curve much less performant, and that would eliminate one of Go's big selling points. The early part of Go's performance-per-effort curve is unique among the "commercially viable languages" right now. (I've seen other languages that IMHO have similar curves but none of them have ever gotten Go's level of support to where I can say to my boss "Hey, I'm going to work in X" and he's not going to blink. YMMV.)
I hope Go will never have centralised registries like crates.io, rubygems and the rest of walled gardens. go tools (godoc, go get etc) along with its derivatives (e.g. go-search) are so much better and empowering than a single centralised registry. How is crates.io better than godoc.org? Why would someone prefer to hosts a copy of its library on something like crates.io and deal with the hassle (i.e. keep it in sync with the upstream, yet another user/pass etc) and on top of that handle the ownership to mozilla or whoever owns crates.io ? If you can't install VCS tools then you could submit a patch to `go get` tool so that it can support a http/ftp protocol. How is a central registry a response to the lack of VCS support? 
&gt; I don't think the Go creators ever saw Go as a replacement for C/C++ in anything low-level, although it can be done. Depend on what you call ‚Äúlow-level‚Äù. A managed, garbage collected language such as Go can be a no-go in a lot of domains. 
I see no reason the author used Iris instead of net/http directly.
Dishonesty about performance is common..
What is the use case?
I don't think regexp1.html links to 2, 3, or 4. they are all linked from here: https://swtch.com/~rsc/regexp/
what about desktop apps? The chrome, google earth, google talk, etc?
Rust lacks simplicity so I would expect a different approach from Go. I actually want Go&lt;2&gt; to replace C not C++ if that makes sense. I want to use Go on low level stuff...that's all. I don't want templates, concepts, generics and other fancy stuff from C++. I'm fine with the current Go abstractions. I'm sure that if there would be a good enough replacement for C very few would use C++ or look for a C++ replacement. 
Because the author is the author of Iris if my memory serves me right.
Oh, well that is a reason. Still, I feel like if you are comparing Go to .NET, you use what comes in the stdlib. Otherwise you are comparing a 3rd party lib in one language to a stdlib in another language, which... I don't know why, but isn't as interesting to me.
thanks to both, the articles escape my level of english and programming, I will try to translate them I'll go straight to the code, I hope to get something wildly 
Are you familiar with iris debacle? If so it shouldn't surprise you from its author.
I learned a lot from [this course](https://www.youtube.com/watch?v=sm0QQO-WZlM&amp;index=1&amp;list=PLFB9EC7B8FE963EB8)
&gt; I love quick feedback: I appreciate websites which load quickly, I prefer fluent User Interfaces which don‚Äôt lag Does anyone not? :P Seriously though, great wrote up. I agree with basically everything. I think Go is certainly not for everyone, but its features are *thoughtful*, in a way that languages that evolved over time aren't (usually). Thays not to say that other languages are bad. 
Very interesting comparison. Thanks.
It's going to be tough for Go to replace C for some of those things, because Go has a more complicated runtime than C (which, contrary to popular belief, _does_ have a runtime environment which is very much _not_ neutral, but it is still simpler than Go, plus it tends to be the "default" for almost all OSes) and the garbage collection also implies it is relatively difficult to plug things in. But if you mean "low-level" executables rather than device drivers, I do expect it will get there.
Fucking What?
I'm unfamiliar. update: oh wait! this is the project that copied source from other frameworks with attribution? I had forgotten about that. Thank you for reminding me.
This is a good article. I think Go is really good for a broad (and useful!) class of concurrent, networked applications. It's a good language for the microservices domain in particular producing small, fast binaries which are easy to containerise and deploy - and great support for creating RESTful APIs and the like. It does have some caveats, however, like it's quite painful for complex data manipulation where you're mapping between a lot of complex objects because its type system still isn't there yet.
Do you know of any languages with simple generics that would not be equivalent to a `go generate` template? Most of my experience with 'real generics' was in Scala which took the [unsound implementation from Java](http://io.livecode.ch/learn/namin/unsound) and added some [nightmarish variance rules](https://youtu.be/uiJycy6dFSQ?t=22m3s).
Tone note: I mean this seriously, because I am curious. Why would I prefer to do this: func ExampleInjector() { inj := New() err := inj.Provide( []int{1, 2, 3}, func(v []int) int { var sum int for _, n := range v { sum += n } return sum }, ) if err != nil { log.Fatal(err) } err = inj.Run() if err != nil { log.Fatal(err) } var sum int err = inj.Inject(&amp;sum) if err != nil { log.Fatal(err) } fmt.Println(sum) // Output: 6 } Vs this: func SumInts(v []int) (sum int) { for _, i := range v { sum += i } return } // and then somewhere else... SumInts([]int{1, 2, 3}) Also, to further assure that this is an honest question, I fully expect the answer to involve "At scale...". But I don't get that "at scale", as I've written some non-trivial Go programs and not hit a scale where I'd even remotely know what to do with this.
Your wish satisfied ;).
I think Go is already suitable for high-performance, real-time stuff. Garbage collector is blazingly fast, at most 100 microseconds of pausing. I'm working on a real-time audio low-latency audio library. We have MP3 audio codec, and on-the-fly audio processing, such as resampling (which is not the least expensive thing). No problems with Go so far. Actually, all of the performance problems we are facing come from C/C++ libraries, such as OpenAL (it's slow with real-time). We are incrementally switching to lower-level audio backends, such as ALSA and with that, there are no performance problems whatsoever.
&gt; I think Go is already suitable for high-performance, real-time stuff. Garbage collector is blazingly fast, at most 100 microseconds of pausing. Obviously 100 microseconds of pausing is not real-time. At least not in the low level world. I don't think you will see vendors such XMOS providing Go SDKs with "high-performance, blazingly fast" ~100 ms pauses. Right now if you are using Go for a/v stuff most will tell you're using the wrong tool for the job. Even the bindings (i.e. to ffmpeg) are quite costly if performance and resource usage is a major concern(not to mention that cgo is not Go). I found this the hard way and ended-up with os.Exec to ffmpeg cli. And yeah you can be sure that the requirements for the next ethernet driver won't include a "blazingly fast 100 ms pausing". 
ms != microsecond
&gt;Zero value is already a term and concept in Go that is t related to nil [Not related to nil?](https://golang.org/ref/spec#Predeclared_identifiers) If you go over the specs you will see that nil is always described as a value.
It doesn't really make a big difference as far as the domain problem is concerned. It's either real time or it's not. ``Blazing fast ~x pause`` it's not real time at all. Go make the case to use Go instead of C for the next video codec (i.e. AOMedia Video 1) and let me know how it goes...
I think the question is somewhat flawed. Paradigm isn't a property of a language of a language, but rather the way you think about the problem. In a sense you can write OOP-ish code in assembly... (https://medium.com/@egonelbre/paradigm-is-not-the-implementation-af4c1489c073) As for expressing OO ideas in Go... the main thing you might hit is inheritance. There's no equivalent for Go... but from experience, designs without inheritance are easier to understand and follow (at the cost of conciseness in some places)
Our MP3 decoder is pure Go and we are able to play while decoding and resampling on the fly with &lt;1/100s latency with 0 underruns. EDIT: and even simulating doppler effect... all on an 1.9GHz i3 CPU without using parallelism
microsecond and millisecond is a big big difference
100ms vs 100us, is the difference of it being usable in real-time audio and not being usable in real-time audio. Probably still not suitable for professional/high-end use, but 100us makes it usable in hobbyist scenario.
Ok then, but can you play it at zero latency?Or is there even a guarantee it will always play at 1/100s latency? I feel this discussion can't end well so I won't argue with you anymore! After all there are java a/v libraries too and it seems they work just fine for some people so good luck with your pure real-time blazing fast ~1/100s pause Go audio decoder! &gt;&gt; EDIT: and even simulating doppler effect... all on an 1.9GHz i3 CPU without using parallelism Edit: Well if you use Go "parallelism" you will get real time for sure!
You can't really do zero latency, not even with C. Btw, we can also do 1/200s, or even 1/1000s if you don't do much audio processing. (Latency depends on the buffer size, with too much processing, you need to increase buffer size to avoid glitches.) This latencies are really good, even compared to what you can do with C. OpenAL could barely do 1/20s when streaming on-the-fly. (But OpenAL is not really designed for streaming.) Btw, you can try it for yourself here: https://github.com/faiface/beep Notice: such good latencies are currently only on Linux, but we are working on other platforms.
And regarding the guarantee. If the processing doesn't keep up with the playback, underruns occur. We can detect them. Since 0 underruns occur (if you don't do anything too crazy), 1/100s latency is "basically guaranteed", I can't prove it, but it just works.
&lt;&lt; Buffer size determines the stability and responsiveness of the playback. With smaller buffer, you get more responsiveness and less latency. With bigger buffer, you get more stability and reliability. Just read the repo doc and it seems that the real-time and low latency is kind of variable... That's the issue with GC... you don't know the latency...you may test it but you never know it. So the ~1/200s, or ~1/1000s latency you advertise is actually a ballpark figure based on different factors including the Go runtime mood. Can you get a certificate such AVB / AVB TSN [0][1] with this kind of numbers? Would you sell stuff bundled with Go a/v processing? Why would I buy your a/v processor with variable latency instead of something with fixed latency? It won't even be cheaper than the C processor because Go required more expensive hardware than C. I never said that you can't do audio processing with Go. I've just said that Go is not the language to use if you want to make money out of A/V stuff(i.e. processing). Better said it's the wrong tool if you are using it for commercial applications. No sane company would put Go in a a/v box. [0] https://en.wikipedia.org/wiki/Time-Sensitive_Networking [1] https://en.wikipedia.org/wiki/Audio_Video_Bridging 
**Time-Sensitive Networking** Time-Sensitive Networking (TSN) is a set of standards under development by the Time-Sensitive Networking task group of the IEEE 802.1 working group. The TSN task group was formed at November 2012 by renaming the existing Audio / Video Bridging Task Group and continuing its work. The name changed as a result of extension of the working area of the standardization group. The standards define mechanisms for the time-sensitive transmission of data over Ethernet networks. *** **Audio Video Bridging** Audio Video Bridging (AVB) is a common name for the set of technical standards developed by the Institute of Electrical and Electronics Engineers (IEEE) Audio Video Bridging Task Group of the IEEE 802.1 standards committee. This task group was renamed to Time-Sensitive Networking Task Group in November 2012 to reflect the expanded scope of work. The charter of this organization is to "provide the specifications that will allow time-synchronized low latency streaming services through IEEE 802 networks". These consist of: IEEE 802.1BA: Audio Video Bridging (AVB) Systems; IEEE 802.1AS: Timing and Synchronization for Time-Sensitive Applications (gPTP); IEEE 802.1Qat: Stream Reservation Protocol (SRP); and IEEE 802.1Qav: Forwarding and Queuing for Time-Sensitive Streams (FQTSS). *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/golang/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.26
The claim about buffer size and stability / responsiveness is valid both in C and Go. It has nothing to do with the GC or the language. Once you set the buffer size to 1/100s and you get no underruns, you have 1/100s latency, it's a precise number. Once you get underruns, of course, this doesn't hold, but, you get underruns when you do too much processing with too low buffer size in both C and Go, it's really not the GC problem.
It just works until it stops working...I know how it works :). Good luck with your project though! I may use it as I love Go but I'm just saying it will never be able to compete with C/C++ in real time a/v processing&lt;unless Go changes/improves&gt; . It may compete with some badly written C/C++ but not with the top notch. It just can't. Without guaranteed latency it's just a guessing game and sometimes you want/need things to work perfectly without Pops, clicks, crackles, dropouts, distortion or latency between channels. I don't think you can afford that guessing game if you organise concerts or run a movie theater and to be frank I don't think you want that on a home theater either especially when you have alternatives. A Go solution is good up to the point when you need to sell it in a product and compete with the alternatives. Even C lacks some stuff to be great for a/v (see XC[1]) so you can just forget Go1.x. Can Go play some mp3 on your desktop...? maybe... but let's not argue that makes Go a good fit for real time a/v processing. [1] https://en.wikipedia.org/wiki/XC_(programming_language)
I still disagree. You flush audio data 100x per second. GC pause takes at most 1/10000s. That's at most 1/100 of the time you have to process the audio data before flushing. Now, if you actually only use 5-10% of that time and you're sleeping/waiting for interrupts for the rest (which is the usual scenario if you do decoding), it's kind of guaranteed that you'll make it. I don't know the definitions of guaranteed, but this seems quite guaranteed to me. EDIT: there are different kinds of real-time requirements. Of course, Go is not suitable for the strictest. But audio and video are not the strictest.
gmgolang = kataras
This is kind of a super-deep subthread but I wanted to sneak in one more point to further support /u/faiface's side: The GC only really applies when you have memory that needs to be collected. It's perfectly possible (and fairly easy) to write low-level code that avoids allocations and re-uses buffers which makes the GC pauses practically non-existent.
And me who thought that they initially only wanted to make it as fast as C++, not replace it.
I need to correct you again that you have no guarantee on the GC latency. You have a ballpark figure on a specific input. You can't get any time sensitivity certificate when you have no latency guarantee on the GC so let's keep Go at the hobby status for a/v for now and everybody is happy. Without latency guarantees you can't sell PRO stuff. That's a fact. Would someone buy your a/v processor with unknown latency or something like this[0] with ``network latency is an astonishing 0.625ms(fixed), even over 7 "hops"(switches)`` ? (btw this kind of stuff can stream 500 channels simultaneously). I'm warning you that even the entry-level/low grade a/v processors have fixed latency so in a/v industry fixed latency is not really a luxury item anymore, it's a must. Audio and Video are some of the most sensitive things when it comes to latency. Latency can basically ruin any multi-channel experience and so the lip sync. You can try to sell a/v solutions developed in Go but I'm warning you that they won't sell that well. Btw some time ago I've tried to develop a roku-like player with improved a/v capabilities in Go... now it's a mix of Go and os.Exec so you can be sure that I want to believe you can do a/v processing in Go but it's just not the case. [0] http://motu.com/products/avb/16a/networking.html
[removed]
&gt; As far as I understood initially Go was designed to replace C++ (at least at Google) Go was designed to replace C++ in places where C++ was only used instead of Python out of necessity. They haven't designed an all purpose C++ replacement, they designed a Python replacement good enough they don't have to write C++. If you're looking for a potential C++ replacement as a system programming language then Rust fits the bill better.
I'm not selling anything, I'm making an open source software, and it's working better than OpenAL for what I'm doing (which includes some preliminary 3D audio too), and I'm confident it will continue to work better than OpenAL. OpenAL is pretty successful.
You can write low-level code that avoids allocations and re-uses buffers but they won't make the GC pauses practically non-existent because even for these buffers you re-use you have no guarantee provided by Go compiler/language(AFAIK) that they won't be collected. Correct me if I'm wrong&lt;citation/spec required&gt;. Most likely your decoder will have multiple go routines scheduled as the go runtime pleases so your decoding routine with the perfectly reusable buffer may be paused by the runtime and you can't do anything about that. So if there is will to make Go a better fit for A/V processing we need some guarantees/real time "features" thus my request to make Go better fit for low level ops such a/v processing and driver development.
A garbage collected language cannot replace C. Go's abstractions are built around it being garbage collected. The thing you want is impossible. Now if you said you wanted a "Go-like simplistic language with manual memory management" you'd probably be onto something. But that language already exists: it's called C. 
You can have functions that receive functions and then loop over a custom type while applying the given function. This works well in practice. Look at the design of BoltDB.
The 100 microsecond benchmark is supposed to be worst case‚Äîcases where GC is longer than that are generally considered bugs. Here's the announcement: https://groups.google.com/forum/m/#!topic/golang-dev/Ab1sFeoZg_8 With minimal allocations and buffer re-use, in practice, the GC pauses are at least an order of magnitude shorter than that. Anyways, if you can't tolerate the GC and you're reusing all of your memory, then you can disable it: https://golang.org/pkg/runtime/debug/#SetGCPercent My point is that multiple people are using Go _in practice_ in low-latency scenarios and it's largely fine. I'm sure there's always room to improvement, but it doesn't help to debate this from some hypothetical not-enough-guarantees position. If you'd like to provide some code examples where Go doesn't perform well enough, we can talk about how to improve the scenario or file some bugs against Go.
Go has no language-native solution for building desktop user interfaces. There are projects out there that aim to be cross platform, but they all interface with C/++ APIs and libraries of the operating system. Though, this has been the case for many other languages. Now if you're talking in terms of performance, when using Go and these UI projects effectively, the language can work quite well. But this depends on a lot of things in your software requirements. At the end of the day, the two languages are hard to effectively compare as is the case for most other languages out there.
My point is that if you don't have any guarantee about the GC latency then you can't provide any guarantee on your program latency either. It's just like you would deploy a web service on a cloud platform with no SLA and you would try to provide a SLA to your end customer based on the usual uptime/latency. It's not about hypothetical scenarios it's just that the lack of any guarantee. Sometime around go 1.4 the GC and scheduler gave me enough troubles to loose any any confidence in its "average latency" and I don't see any reason to trust this latest version of GC more. It has better latency for sure but any guarantee on that latency? The story is same as far as I'm concerned. I would love to see a project that works with the GC disabled. Can you provide a link to any public one? Never knew that you can actually disable the GC&lt;except for debug&gt;. Can you use Go routines? I can't hardly see Go working without GC considering that at some point you need to release memory in your program. Ideally you would like to disable GC on package/lib level. 
Go 1.4 is from 2014. A lot has changed since then. It predates at least 2 major GC overhauls, and a full rewrite of the compiler from C to Go. It was no where near sub-100 microseconds back then‚Äîit was several orders of magnitudes slower, even for the average case. The new GC we're talking about was from Go 1.7. The latest version is Go 1.9. You don't need to repeat yourself, I've read your other posts and I understand your complaints. Nobody is going to give you an SLA. It's your job to make your code work within your own constraints. I suggest you give modern Go a try and run the numbers yourself for your specific scenario, if it's worth your time. If not, then don't. We're trying to tell you that we've used modern Go for similar scenarios and it worked well for us. That's not a _guarantee_. You're not going to get a guarantee. Do with that information what you will.
If it works for you then it's already a success and I wish you the best. More people working on stuff like this will definitely push Go in the right direction. If you think your project would benefit from any change/improvement to the language try to put it on Experience Report[0] as now there is a rare chance to propose language changes. [0] https://github.com/golang/go/wiki/ExperienceReports
Hi, would you mind to explain a little bit more about this data manipulation issue?
&gt; As far as I understood initially Go was designed to replace C++ [...] What lead you to this understanding? Go addresses several pain point C++ has, but I doubt anybody really thinks of Go is the language to replace X (for whatever X). Use Go where it fits, use C++ where appropriate, use FPGA where sensible, use Python if it offers benefits, etc. pp. Same for Go 2.0 (whatever that means to you).
I must say that I'm actually pretty satisfied with the language regarding performance right now. If I'll ever push it to absolute limits where it could benefit from a language change, I'll definitely do an experience report about that.
So you made yet another task runner like [go-task](https://github.com/go-task/task) and bunch others...
&gt; We're trying to tell you that we've used modern Go for similar scenarios and it worked well for us. That's not a guarantee. You're not going to get a guarantee. Do with that information what you will. That's well said and I perfectly understood it. It works for some people, no doubt but if Go 2.0 wants to become a first class candidate for real-time apps it needs to provide a bit more &lt;i.e. mechanism to achieve predictable latency/performance&gt;. That would encourage investment and most likely will attract new developers(i.e. C developers). That's why I've asked if Go still aims to replace C/C++...(seems it actually never did, at least in this domain).
I'm afraid talking about the drama that relates to why Iris is not very popular is inappropriate for this sub under it's rules. But if you are interested in a brief explanation you can DM me.
I didn't say simple to implement, I meant simple to use. Of course it's not easy to implement, compilers are extremely complicated.
Do you have any ideas how you would improve it? I have a similar opinion. I love Go, but I don't think it would work well to write or consume say the Android SDK in. I don't think it ever will or maybe even should. Oop, abstracts classes, and inheritance just work so well for such things. I would expect Go to be good at data manipulation and I think it probably should be.
GC pause is not the only characteristic to consider. 
What about a Go dialect/subset that can be isolated and works perfectly with the rest of Go code? Something better than Go to C via cgo...i.e. something like the Go 2 -&gt; Go 1 integration(that from what I hear will be seamless).
Simple/complex vs Easy/difficult Please think what the words mean before using them
It's funny you same that because I had the same thought after I posted my comment. A really excellent C interface would go a long way. 
You seem like an angry person. I hope your day goes well.
Sure but it wouldn't be that bad if Go 2.0 would address a bit more use cases and implicitly pain points of C++. cgo is not that great, you know? Neither os.Exec. It is just better than writing the whole thing in C++ but I would definitely to replace that c++ program with a pure Go package if the language would allow it. 
There are several desktop graphics projects in Go that do not use C++ APIs.
Rust can definitely replace c++ though I think the issue I have with Rust is that it looks too much like C++(complexity like). I would rather prefer a Go dialect with powerful/low level features as C. That would check all the checkboxes: simplicity, abstractions and power. Most people hate C++ for its complexity. I don't think that they will all be happy developers if C++ committee will release a barrow checker with guaranteed memory safety(a`la Rust) in the next version( C++20 ). 
&gt; I never said that you can't do audio processing with Go. I've just said that Go is not the language to use if you want to make money out of A/V stuff(i.e. processing). Better said it's the wrong tool if you are using it for commercial applications. No sane company would put Go in a a/v box. You never said what you claim to have said here. Why should we think you are being legitimate in your concerns?
What else would you consider?
Wait what? Iris is not allowed here??? I find it to be the most mantained web framework, with great support and docs. DM me..
You lost me at Iris...
Cool
Well all I said is that as it is now you can't have guaranteed latency with Go and as you might be aware real time a/v processing is about latency. That being said a language which cannot provide any mechanism to control the latency cannot be considered a good candidate for real time a/v processing. It is a no brainer. If your product features "real-time" it is supposed to also feature a fixed latency or in the worst case a guaranteed latency range. In multi-channel systems you usually deal with a lot of stuff such transcoding, dsp, switches etc...all of them add some latency. My personal opinion is that the system will not sound/play nice if is developed in a language which cannot provide predictable performance/latency. I don't think any recording studio would tolerate such stuff. I actually think the issues would be visible for consumer products too (e.g. the speakers/channels will run out of sync and chances are you will get a/v lip sync issues too or just buffering pauses&lt;whatever you prefer to trade off&gt; ) Now about legitimacy, I'm not sure I understand what you mean. Do you think Go is great for real time stuff and I just make up arguments because of some mean reasons? Do you know any way to achieve fixed/predictable latency in Go? I feel I should have better kept this question/concern for myself as it was received with repulsion. The bottom line is that you can do some a/v stuff in Go (i.e. webrtc) just like you can in JavaScript, python or any other language but you can't compete with C/C++ or dialects(i.e. XC). 
Go is garbage collected, which effectively rules it out as a low level systems language. 
You never mentioned anything about money before this post I quoted. Why are you saying you did.
Apparently, he means g word.
guacamole?
there is no such thing as guaranteed latency in any popular operating system
It's an idiom for a reason. Extra API comes with a cost. Every extra line of code you write increases the possibility that you'll introduce a bug. Everything you add to your API must also be tested. Everything in your API must be doubly maintained because you need to maintain the tests and the implementation. I'm not saying it wouldn't be a good idea to make Wheels private, I'm just saying it depends on what's going on in the code. I don't consider making the explicit choice to make my API simpler "dumbing down my software," just like I don't think it's a good idea to follow Go's idioms without questioning them for a particular use case. If it doesn't fit the use case, don't do it.
It's not OP's fault you haven't heard about null safety.
the `regexp` library achieves it's primary goal - to get people to not use regex in Go
Because the article author *IS* kataras, have a look.
Why does your engine use a different syntax from everything else? Seems unnecessary.
For non existent GC pauses, the GC system can be turned off entirely with env variable GOGC=off https://golang.org/pkg/runtime/
Go makes it relatively straightforward to release packages and command line utilities, that's why it's one of my favorite languages!
Simple doesn't mean simplistic. You're talking about APIs, so now we can safely assume you're talking about code that is meant to be **consumed by others**. It doesn't depend on what's going on in the code. You've given API consumers a direct pathway to enter an invalid state. A pathway that need not and should not exist. What use case possibly exists where you want consumers to have the direct ability to invalidate one of your invariants? EDIT: Furthermore, when the heck did making internal state public, thus killing encapsulation, become idiomatic Go? Can you point me to a source.
only supports regexp, Express other things, it requires twisting the regexp to avoit `\\` and to simplify the parser in the code
I use API to refer to what's being exposed by the package. It doesn't necessarily mean that it's public. It could be internal to the application. It absolutely does depend on what's going on in the code. It might be worth the cost to have that pathway there, if it means having an API that's easier to understand and maintain. I can't answer your last question, because that of course would depend on the problem being solved. I can say that this is basically the same thing as worrying about client code directly calling a constructor vs. using the factory to create objects. At some point, there's gonna be a situation where you can violate an invariant. It's always good to try and minimize when that can happen, but at some point the cost of doing it is not worth the benefit. That threshold depends on many things, like for example the size of the program you're writing.
No, it's allowed here, but the maintainer is not in good standing with many in the community. Edit: I am not talking about the drama here because it's not really within the rules of the Subreddit. r/golang does not exist to talk about drama and gossip, is what I'm trying to say.
(Comparatively) it is only fast with plain text, slow in the simple and regular in the rest, but it is conpetitive Its design to the user is interesting and practical, although I would prefer that the catches report their location, multiple catches and other things that would require redesign
Generic store brand guacamole 
Why are you continuing to edit this post, repeating yourself, and still not answering my question? This just reinforces that I should think you are a troll.
heh? Now I think you are not worthy of an answer. Even so whatever question you had I already answered. Why should I repeat myself one more time? 
Ok, fine, don't answer why you lied about talking about money. Suit yourself.
Do you have a reference to that notion that Go was supposed to be a better C++? I think that is actually a pretty low bar in either case.
I don't know what you are talking about. The point is that any solution developed with Go right now is subpar compared with a C solution. That's because you can't get any predictable latency in Go. You are dealing with a GC which pauses and collects as it pleases. The behaviour of the GC can change from one version to another. The money argument was there just to reinforce the fact that in order to make Go competitive in the A/V industry it requires changes so that it can compete with other languages(i.e. C/C++). If we talk about your hobby project then any language is good enough for a/v stuff.
Stop it, that's not what I'm asking you
&gt; I never said that you can't do audio processing with Go. I've just said that Go is not the language to use if you want to make money out of A/V stuff This is not true. Explain why you lied. I do not care about your opinion on whether or not it could be used for professional audio processing. I care why you lied about what you said. You never said what you claimed to have said here. You never mentioned money before this.
Lied about what? a/v processing is not really same as real time a/v processing. Obviously for some people "real-time" has a different definition where latency is not constant or at least within a guaranteed range. For those people Go is great for any kind of real-time application. 
So, you've provided no example use cases *and* no source for the claim that it's idiomatic in Go to expose internal state publicly. Not even touching the fact that you've run directly in contradiction to DDD itself. Listen: this is a **dangerous** recommendation. It models bad habits for other developers to follow. I'm not being obtuse nor dramatic. For precedent: see how numerous recommendations to store MD5-hashed passwords infected the PHP community. This stuff matters. And if one is going to position an article as teaching material, then that person takes on a greater responsibility to the community. Otherwise add a corresponding disclaimer that says "Hey, this is for funsies, not for production."
You literally are not reading what I am writing. You lied about talking about money. You said "I've just said ... if you want to make money ..." which is not true. You did not say anything about money. You repeatedly said you cannot do audio processing in Go. Stop lying.
So much this. Go is a great operations language simply because of the ease of distribution. (and the rather good standard library) no more pip or rubygems or shit wrong version of the interpreter :| 
&gt; no source for the claim that it's idiomatic in Go to expose internal state publicly. I actually went to look at Effective Go, where I thought I had read about it being idiomatic to just expose the members that needed it instead of doing `GetX` and `SetX`. I was wrong. You're right. I'll make sure to put it in a follow up. Here's the link: https://golang.org/doc/effective_go.html#Getters &gt; if one is going to position an article as teaching material... If you thought this was teaching material, my mistake. I never meant it to be teaching material. Maybe I could have reflected that better in the blog post. I was really just writing about ways to apply what I was reading in the book when writing Go, as a way to help structure code in a language that offers very little in mandating how to do it.
See this comment from @shazow below. It's the best comment from this whole thread and I fully agree with the conclusions. Shortly said currently Go may or may not work on your a/v project depending on your requirements. This could be said about any other language(i.e. javascript). In my initial post my question was whether or not Go 2.0 aims to provide good support for low level apps such real-time a/v systems, drivers etc, basically to be able to replace C++ in these use cases. I don't understand why you keep making the argument that professional a/v systems are something special that I should have mentioned there. The software on most of them is developed in C/C++. If the language provides real-time capabilities (as defined by wikipedia[0]) then you should do whatever you want professional or not. The processing delay must be bounded. What boundary do you have in Go ? If you don't need the delay to be bounded then perhaps you don't need real time capabilities. You need some kind of almost/near/not so real time or whatever you want to call it... [0] https://en.wikipedia.org/wiki/Real-time_computing @shazow comment: Go 1.4 is from 2014. A lot has changed since then. It predates at least 2 major GC overhauls, and a full rewrite of the compiler from C to Go. It was no where near sub-100 microseconds back then‚Äîit was several orders of magnitudes slower, even for the average case. The new GC we're talking about was from Go 1.7. The latest version is Go 1.9. You don't need to repeat yourself, I've read your other posts and I understand your complaints. Nobody is going to give you an SLA. It's your job to make your code work within your own constraints. I suggest you give modern Go a try and run the numbers yourself for your specific scenario, if it's worth your time. If not, then don't. We're trying to tell you that we've used modern Go for similar scenarios and it worked well for us. That's not a guarantee. You're not going to get a guarantee. Do with that information what you will.
**Real-time computing** In computer science, real-time computing (RTC), or reactive computing describes hardware and software systems subject to a "real-time constraint", for example from event to system response. Real-time programs must guarantee response within specified time constraints, often referred to as "deadlines". The correctness of these types of systems depends on their temporal aspects as well as their functional aspects. Real-time responses are often understood to be in the order of milliseconds, and sometimes microseconds. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/golang/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.26
I believe one such OS is linux which may be quite popular(depending of what popular means to you) and it provides predictible latency&lt;with some patches of course&gt; https://wiki.linuxfoundation.org/realtime/start
I think this should stop....not sure how old you are but this kind of approach is really counter-productive. You should ask yourself why you wouldn't be able to make money with a real time a/v solution developed in Go. That was my point. Go can't compete with C/C++ in this domain for the reasons I already enumerated several times. You try to make a point that some a/v processing can be done in Go...what kind of processing and how well it works...well everyone has to judge based on their requirements.. Not the same can be said about C or C++. Whatever requirements you have they are covered. All the reference implementations for a/v codecs are written in C or C++. As it stands now you will never see any real time application in Go just for the simple fact they can't exist in a language that doesn't provide real time capabilities. 
Makes more sense, thank you for consideration, I appreciate that. My brother is a Canes graduate btw: was an assistant on the basketball team for 3 years back when Coach Haith was around and Jimmy Graham still played basketball. ;)
The go routines scheduler among other things...?
My main concern is that you have no guarantee on that 100ms or 100us latency. Nevertheless in a hobbyist scenario it could work just fine. It's all about the requirements but when I think about real time I usually think about constant or at least bounded delay. 
I had so much hope this won't be yet another pointless thread about the language and it would be about what kind of applications it would be used and in which kind of environments Go will be present. Or maybe what kind things are not currently possible with Go but they could be in the next years. But I was wrong.
&gt; For non existent GC pauses, the GC system can be turned off entirely with env variable GOGC=off &gt; I think this argument has been made before but I never seen a program with the GC off. I actually don't think it's feasible to write a such program. I think the option is for debugging only. 
Nice! Must have been fun to be there at that time. 
The story is somewhere if you google it. I think the bottom line is that Go was designed as a better alternative to C++ for stuff its designers did in C++ at Google. One major problem they had with C++ was the compile time, another was the complexity of the language.
So we are back to square one...
Jesus, you wrote that much and still didn't answer my question, what the heck
Yes it should stop because you still haven't answered my question and clearly have no intention of doing so, also you clearly aren't keeping track of who you are replying to because I have not done the things you think I have done according to your post.
Stop, please don't go on another tangent about some other thing, I don't want to read your same arguments a ninth time. I am asking the person I am replying to, not you.
What can be faster than C++?
It actually was inspired by this. https://youtu.be/yVw42wWZWrg
It seems you are correct in that it's intentions are to be used for debugging, bummer https://github.com/golang/go/issues/13761
well, AFAIK go was never meant for system programming (such as drivers)
&gt; I don't understand why you keep making the argument that professional a/v systems are something special that I should have mentioned there. I literally am not making this argument you need to keep track of who you are replying to
Fortran
If something looks too good to be true it probably is and this makes no exception. A way to escape the GC has been asked for a long time so I would have been surprised to see any such option without a blog post and some language changes.
He lost me at .NET. Really need a comparison to an over-bloated Microsoft conception? Microsoft is crap... has been since the early 2000's. Why are we comparing .NET to Go? Is anybody really surprised at the size and lack of speed in .NET core? Look at how it's designed... No thank you!
D might be something to check out. Does not have a large community but supports both GC and non-GC applications, has a fast compiler (dmd), is powerful (check its metaprogramming capabilities), and is simpler than Rust. I still prefer Go for what I do.
Well, I said as fast so it's more of aiming to be very close in term of performance if not equally fast, not faster.
Yes! You mean the extremely common general function found in many many languages, `map`! I love that one too. Which is another reason I stopped.
This is just a simple example, in real project, the `[]int` maybe db, logger, server, etc.. With this library, what you need is just write constructor function that accept dependencies or return dependencies or both, and you needn't concern about the initial sequence and dependency graph, everything is done automatically. At last, you call `inj.Inject(pointers...)` to get the final objects.
In 10 years I'd love to see Go conquer areas like mobile, AI, gaming, teaching and mathematics/physics/science. Also if webassembly ends up exploding, I want Go fully supported so we can bring Go code directly to the browser. I also want a fully featured, cross platform GUI library written in pure Go that looks dope.
go-fish, nice name
I ended up going this route. Thanks
I ended up starting with the standard library. I think it is proving to be beneficial in learning the language. Thanks
I agree that learning the standard library is the best choice. Thanks
&gt; First, are any articles or anything you suggest I read? Feel free to check out [this comment](https://www.reddit.com/r/golang/comments/56wk4v/structuring_go_api/d8n4axl/) which has a collection of some good articles that help with structuring code in a Go project. &gt; Third, can you take a look at some basic code I have put together and steer me in the right (or just better) direction? About your code I think it looks okay. Something you could improve is to do some better error handling. You could use the technique described in [this article](https://blog.golang.org/error-handling-and-go#TOC_3.) and keep the error handling of all your handlers in one place. &gt; const ( PasswordMismatch = "PasswordMismatch" ) If you think you'll add more errors later you could use `iota` like [this](https://github.com/upspin/upspin/blob/master/errors/errors.go#L68-L117). &gt; `const Debug = true` Another technique you could instead of a debug const is build tags. You could have a function with empty implementation in your normal files and guard that file with `// +build !debug` and have another file with `// +build debug` which will contain the debug implementation. Then when you compile with `go build -tags=debug` the go toolchain will use the debug implementation. You can see this technique being used in the [Upspin](https://github.com/upspin/upspin/tree/master/errors) project. Check the `debug.go`, `debug_stub.go` and `errors.go` files. I think it is also a very good project to learn from. And you can use build tags for all sorts of stuff like for example writing integration tests which since they might have to use a database or some other system you don't want them to run every type you do `go test` so you use a build tag and run them only with something like `go test -tags=db`. 
&gt; I started playing around with Go about a week ago and I am having a lot of difficulty with producing code that I am happy with. Go is not a toy language. Expect to spend more than a week to really understand it. &gt; Go's lack of traditional OOP is throwing me for a loop. It's actually OOP that is throwing you for a loop. Because of inheritance, it's rare that you can copy a class (for a domain object) from one project to the next. With Go, you compose your objects (structs) from isolated sub-objects (structs). It's almost like OOP mix-ins, except go enforces the rule "sub-objects don't know about the larger objects they are embedded in". At first, this seems like a serious limitation. But later, you realize that it forces modular code, and allows really neat re-use. For example, the "Mutex" struct can't know anything about the object it's locking, therefore it can be re-used anywhere.
I actually just thought of an example: using the json package. The json package won't operate on a type's private fields because it can't see them. The way around this would be for the package to handle serialization itself, which increases the cost of keeping things private.
&gt; As far as I understood initially Go was designed to replace C++ (at least at Google) but proved better fit to replace python and its friends(great thing for some of us). Is this noble goal still valid for Go 2.0? Any chance we can develop real time high performance apps, drivers, codecs, transcoders etc in Go 2.0 instead of C/C++? I am afraid you have misunderstood the design goals of Go. Please read these two articles: * [Go at Google: Language Design in the Service of Software Engineering](https://talks.golang.org/2012/splash.article) * [Less is exponentially more](https://commandcenter.blogspot.gr/2012/06/less-is-exponentially-more.html) 
I agree
Cross platform GUI library that just plain works. And no cgo. 
&gt;If you use Go packages which don‚Äôt offer a stable API, you might want to use a specific, known-working version. Your best bet is the dep tool, which is not part of the language at the time of writing. For `git` users using Go packages sans stable API, you can use `git submodule add https://github.com/&lt;user&gt;/rock rock` which will make a directory `rock` of that package's current commit in your own code. You have to change your import statements to reflect this `import "github.com/you/yourpkg/theirpkg"`, otherwise you're just relying on whatever version `go get` grabs normally. [Would you like to know more?](https://github.com/blog/2104-working-with-submodules) Edit: Never mind! Fuck me for trying to share knowledge. Thanks for the thoughtful responses, guys!
Just use `dep`.
Yes, that is what the article suggested. I actually quoted that advice in my comment. Thanks for your input.
Checkout https://GitHub.com/eliothedeman/bangarang Pretty similar premise but mostly for monitoring of timeseries data
There's also gopherjs for running go code in the browser https://github.com/gopherjs/gopherjs
Trolling? OP mentioned about "usage of nil" and didn't specify what he meant - nil maps, nil channels, nil pointers or meaningful zero-value types? Each of them have different nil usage.
Yeah I know. GopherJS is awesome. But I meant that I want to run Go *directly* on the browser in the future.
TL;DR see package [sort](https://golang.org/pkg/sort/).
I recommend you to read [this article](https://blog.plan99.net/modern-garbage-collection-911ef4f8bd8e?gi=b965bfa03ee7), which explains it better than I could.
I mainly created it cuz my Linux Distro wan't getting newer version of Go via its system package manager. Then just thought it would help shuffle if needed to check running same code across multiple versions.
I feel ambivalent about this. I still strongly couple operation lifecycle with its attached values: an interruption signal is a request-scoped value (like any other). Consider the case of boundaries in a distributed system, whereby request-scoped calls may use other backends (fan-out). A reasonable RPC system would serialize and deserialize attached context values across these boundaries ‚Äî no? Wouldn't a top- or branch-level deadline be worth propagating to callees? If you agree to that premise, then it follows that a deadline is an attached value. For example function GetResource in Backend A is called with a top-level deadline or now+5seconds. GetResource calls Backend B's IsAuthorized method (serializing attached values), which receives (deserializes) that then+5seconds deadline. That deadline is propagated across a distributed caller-callee RPC boundary. That is a useful property. Context admittedly elevates this deadline/interruption property above others in it's API, which may not satisfy purists. Then again, I would much rather have explicit and near-standardized cancellation contract than something fragmented or poorly understood. I cringe at the thought that things might become [opaque like this](https://www.safaribooksonline.com/library/view/java-concurrency-in/0321349601/ch07.html).
If context just becomes an associative copy-on-write list, as Dave suggests, it would make more sense to not call it Context, but AssocList, or something similar, as it is a general data structure.
It feels totally like project-specific thing in its current appearance and definitely doesn't deserve to be in a stdlib.
I don't think there's ever any harm in asking for people to clarify what they mean. It might make intuitive sense to you, the question didn't make immediate sense to me. It seems I'm not the only one who shared that opinion.
Maybe DigitalOcean? As low as $5/month. 
I second that.
I see people come in and complain about go all the time on certain threads, and I'm certain a decent proportion haven't really tried it before, you can basically tell from the shallowness of knowledge in the complaints.
Have you had a look at spf13/viper?
Is it any different to Heroku?
scaleway in Europe ?
Still compatible with 1.x that i don't need to reinvent my own wheels.
Did you take a look at [Gorm](https://github.com/jinzhu/gorm)? It supports relations, and also support custom SQL easily. Never used sqlx, but I think it should also cover your use case well.
I had a look at both. Gorm does support relations, although I'm not sure if it supports mapping the relations from raw SQL. It's also one of the heavier libraries there is, which I'd like to avoid if possible. I haven't been able to find a way for sqlx to handle mapping resultsets from many to many queries yet. Still trying.
Bad/misleading tittle. The article is about wanting separate things for cancellation and for request scoped values whereas the title implies the existing context shouldn't be used for or isn't meant for cancellation.
&gt; You have to change your import statements You're vendoring so use the `/vendor/` sub-directory and leave the import alone.
It's more like AWS, not heroku - you get a server (vps) with just the os, then install what you want, performance and reliability is good and it's cheap. You control the processes so no issues with long startup times if unused. Search for a referral link and you can try it for free for a few months. 
+1 and it's cheaper
If you don't mind a shady hoster... Cloud at cost? 
Maybe https://github.com/go-pg/pg/wiki/Writing-Queries
Sweet - thanks very much. I'll try Digital Ocean.
I think here the problem is bad design not the lack of generics. Your cli package does not need to know about your concrete configuration struct, so there's no reason to leak it. Just define config struct in main and wire it with your cli package there. Pseudocode: func main() { var c Configuration if err := config.Load("~/.myapp.yaml", &amp;c); err != nil { log.Fatal(err) } // ... }
Hey guys! I'm pushing myself to write code for a 100 days straight as part of the [100DaysOfCode challenge](http://100daysofcode.com/). For my purposes I wrote a simple static file editor, with which I can write [Leanpub books](https://leanpub.com/u/titpetric), [my Hugo based blog](https://scene-si.org) and bunches of other things. Today is Day 13, and I implemented the web server and API in Go, for delivering this web app. I hope somebody else also finds it usable :)
Does handle relations, but only using query building from the looks of it.
&gt; webview &gt; "native" &gt; cgo That's just the pessimist in me. I'm sure a lot of effort went into this! It looks similar to Electron minus bundling a giant browser with every app, which is a distinct improvement.
Yes, We already use https://github.com/urfave/cli for creating command line apps. this library is to abstract some project specific stuff(which uses kafka/postgres etc). It is not open source so I can't share the code. 
I am not a good writer and did a bad job, but when I am talking about configuration, it is very application specific, which is passing kakfa client/topics/statsd endpoints etc. We have many go apps (which we call daemons) and they do things such as read postgres wal logs, send avro records to kafka, read from kafka and create snapshots etc. We instrument them as command line apps. We were using context.WithValue to pas some of these things but we all know how that's not a good idea.
Let's take another example - every rpc server is application-specific, yet you don't need generics to implement it, do you? The same story with your configuration. Bad design.
Did you look at https://github.com/jmoiron/sqlx ?
Keep in mind though that MSHTML uses IE7's Trident engine at its core which is an abomination when it comes to browser standards. 
Viper, not Cobra, different snakes :) See https://github.com/spf13/viper You can have configuration without having to need generics. However the post does exemplify the hardest part of using Go: being able to correctly design code that works.
https://performance-dot-grpc-testing.appspot.com/explore?dashboard=5652536396611584&amp;widget=47519326&amp;container=437439770 
Yes, and I'd like to use it very much, if it can map many to many relations.
Exactly. And that's what stops me from trumpeting that it's an Electron-killer. The good news is that on modern Windows (8/10) it's going to be IE 10 and IE 11, both are not so bad.
Side project -&gt; assuming small, at least to start. The smallest tier of Google Compute, f1-micro, ends up being free CPU, and I'm paying under $0.50/month for traffic on one little project of mine. The limitation with f1-micro is you can't burn 100% cpu all day long, you only get bursts of CPU time. That works out fine for serving a small website.
Is there no way to get it to use EdgeHTML on Windows 10?
- ms = millisecond - Œºs = microsecond = 1/1000 of a ms So 100Œºs is 1/10th of one ms. In Human terms, instant. In Computer terms it is still significant. In one Œºs modern CPUs may zip through thousands of operations.
ah, ok. I get it.
Unfortunately, EdgeHTML only works with UWP, which in its turn doesn't play nicely with neither C or Go (only C#, JS and some weird C++ dialect). I wish Microsoft has made a way to embed EdgeHTML into pure WinAPI apps, but it's not the case yet.
That means it'll have similar implications with now right? I.e. if it hasn't been used in a while it'll need start up time?
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/scala] [Go gRPC performance compare to Java and C++](https://np.reddit.com/r/scala/comments/6uwbmt/go_grpc_performance_compare_to_java_and_c/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
There has been a somewhat similar library that struggles to use EdgeHTML, they seem to have a small UWP app written in C#, and the core app is compiled into some native DLL used from the UWP app. Here's some discussion on this approach: https://github.com/murlokswarm/windows/issues/1 Unfortunately, the windows port has been inactive since March and is far from being finished. So I though, as of today, MSHTML is the best realistic solution I could get working.
1. You're welcome to read my blog for some focused articles, https://scene-si.org, Go by example is a great all-round reference: https://gobyexample.com/ - and look at examples in the stdlib documentation, godoc for packages. If it's a back-end service, I'd suggest to get familiar with database/sql and specifically jmoiron/sqlx for MySQL., - just consume anything that's relevant to you, 2. For a front/backend service, you can take a look at my [titpetric/pendulum](https://github.com/titpetric/pendulum), it provides a simple web api for a front-end VueJS app (file browser + static file editor). In regards to your example code, I would bind the functions around a struct, ie, `Account`, `func NewAccount() Account`, and handle complete API endpoints for accounts here. In the example project above I do the same, albeit I just use a generic "API" name to group individual endpoints. While not a requirement, I prefer this over creating a package. It's sort of a trade off. If you have a small project, grouping functions around a struct is good. If you have a big project, you'll move onto packages for cleaner separation. If you have a small project (microservice), you might implement a flat structure for endpoints, like you did. If this project grows - you might want to separate the http interface away from the actual "native" api. I do this in the Pendulum API above, calls like `StoreHandler` invoke a more native API `Store` hidden behind it. It separates the HTTP logic and response structures away from the more internal API which could be used as a package import. You'll learn the most by writing a lot of code. The above example was written in about 4 hours, and with such time constraints I'm sure it's better than if I had a very long time to write it (of course, also not perfect but I only have minor thoughts about how I would more strictly separate the HTTP API and the internal API). Keep on coding :)
My phone is fighting me. Are higher numbers better?
Yes, Y axis is queries per second. Not sure why Go is the only one Sync here and how does it compare to Async though. 
Or Vultr at 2.50
When I first saw the design of context.Context I wasn't really happy with it. It seemed weird. But, the more articles I see that say "it should be like this instead", the more I appreciate the design.
Maybe host on aws lambda, using https://github.com/eawsy/aws-lambda-go-net/blob/master/README.md lambda has 1 million free requests per month for everybody. So if its really a small side project then this should be enough :-) I use it to test an upcoming mvp. So if it catches on then i am also sure it can scale enough ;-)
This is beyond meaningless.
1. Composition instead of inheritance using [embedded structs](https://golang.org/doc/effective_go.html#embedding). 2. What you said. D1 and D2 should probably implement interfaces. 3. Again, what you said. Interfaces are probably your best bet. &gt; I feel like I'm hitting the same strangeness of having to separate things that conceptually belong together I dare say the perceived strangeness results from your equating belonging together conceptually with belonging in the same object (i.e. you're thinking in OOP terms). Do you have any concrete examples that we could help you Go-ify?
Is this? The benchmark is done by Google itself.
Scroll down on that page and you'll see that the proportional fonts are sans serif. 
Yeah, the lack of a portable GUI tooklit is a much bigger issue **for me** than any of the popular Go 2.0 feature requests I've seen. Similar to things like this, I'm using a local web server to serve up a web based interface, but not trying to package it with something. I've recentloy seen a cross platform "xdg-open" alike that might be able to automate opening the web interface but haven't tried it yet.. This would simplify the workaround for users but still doesn't solve the underlying problem. The only truly "portable" toolkit I've seen thus far is Shiny and it it extremely primitive.. Great for drawing opengl smoke patterns but doesn't have actual GUI widgets like inputs and buttons and menus...
It has been said before, Go grpc is not optimized yet.
Where?
Saw this post a little late- but you can achieve a similar interface by defining only the inbound types [example](https://play.golang.org/p/w_GAZYO_D1)
They're slow and terrible, and that is if you even get the server online. Would not recommend it to my worst enemy. Scaleway seems to have a decent reputation to go along with their extremely competitive prices.
Unfortunately, Shiny seems to be mostly dead by now (https://github.com/golang/go/issues/11818). I may recommend Nuklear. It's also very basic, but it's easy enough to extend. I haven't used it with Go (only with C), but it was a pleasant experience. As for the external web browser as a UI - I can suggest `--app` command line option for Chrome/Chromium. It opens a standalone browser window with no menus etc - it looks like a real app.
Yeah I totally agree. I guess the author wanted to make a play on a previous article he had written with the title: "Context is for cancellation".
Should be "Go sync compared to async on Java, C++, C#" Not super clear what this comparison is demonstrating, though.
[NO! GOD! NO! GOD PLEASE NO! NO! NO! NOOOOOOOOOOOOOOOOOOOO!](http://i.imgur.com/YcAQlkx.gif) Okay seriously, just because your article starts with "this is an experience report" it does not necessarily make it an experience report. We really need to raise the bar. This is the definition of bad design. There are dozens of different ways you could have done this. This is not a good case for generics. I would go as far as to say that in this case generics would encourage bad design. Please for the love of god stop polluting the wiki and put some effort in your experience reports.
I'm using hostus.us for several things. $10/3 months for a solid Linux VPS with a single IPv4 address and multiple IPv6. Two gigs of RAM, I think and plenty disk and CPU for a go server. They often advertise deals on the low-end hosting forums, and they seem to stay valid forever. Look for one of those.
+1. They're not so much shady as outright fraud. And I wouldn't describe them as flaky so much as entirely non-functional technically. Avoid, seriously.
I like Uncle Bob's SOLID principles (http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod) which are fairly well explained in his videos, but you can find other explanations of varying quality. https://code.tutsplus.com/tutorials/solid-part-3-liskov-substitution-interface-segregation-principles--net-36710 is semi interesting to read and think about with a Go view on objects and interfaces.
The only things I used were the golang tour, gobyexample, the go wiki tutorial and the Json and Go blogpost. Everything else is just fluff that I neither go back to nor rely on. Once you've looked through the above, the /pkg reference is pretty much all you need.
I think there were some github issues about it. Java / C++ got heavily optimized but not Go yet.
Looks like a nice idea but I have hard time figuring out how this would be remotely useful anywhere. Storing every single token ever generated in memory and checking against them all when you make one is awfully inefficient. And you are using map[string]bool for it no less. Also using math/rand instead of crypto/rand isn't the best idea either. What use-case does this serve you personally?
Ah, I totally missed that, even though it's the first post listed under "related posts". I guess I missed the context in which the title may have been written :).
Okay great thanks for the post! If you don't mind.. I would like to know which programming languages did you learn before and how long ave you been programmer?
1. In this case, you create a struct B and embed it into D1 and D2. 2. Your first thought here is best, D1 and D2 have some shared interface that they implement. Think a file vs a network connection - both can stream bytes. 3. The framework should provide a well-defined interface and accept it. It doesn't necessarily need to be module-level helpers either, it can be anywhere. (e.g. gzip doesn't care where the bytes are going, disk or the network, it just wants to stream compressed bytes) To really grok the concepts, I'd recommend looking though the stdlib for all the packages implementing `io.Reader` or `io.Writer` - check out things like `*os.File`, `*net.Conn`, packages `log` and `gzip`, etc. You can open a file on disk, extract it through gzip, and copy it directly to a network connection (using `io.Copy`) simply because all of these implement or accept `io.Reader` and `io.Writer. Similarly you can make a gzip'ed log file with only a few lines too. It doesn't matter that the classes are different semantic types because the all use interfaces, not inheritance.
https://github.com/asticode/go-astilectron I'm using this successfully at work on multiple platforms
I think Dave is off the mark for context analysis. Acknowledgement that something is canceled almost always naturally comes back from some other source: something unblocking, another channel message being sent, a response being returned, etc... 
I wouldn't call myself a programmer, I'm a DevOps so really I'm a sysad who has then decided to learn how to code to make life easier. I started with bits of Bash, then moved on to Python, and now I do almost everything in Go. I've been using go for about 8 months and I would say I'm relatively proficient in it now. 
There's only one correct answer: Show us the code. Without it, nobody can give you a proper explanation of what's happening.
When you're using go routines, it essentially forks the process, which requires more system resources to perform. If you don't need to do things asynchronously then there's no point in using go routines.
Ahh okay.. Do you really thing other tutorials and books for Go beginners are fluff if they're not sysadmins or DevOps but are programming beginners who want to learn howto wrte their first programms?
Thing is, I don't think Go is a language for beginners. Python certainly is, especially because you have the python console where you can get immediate results. I would tell people to start there, and then work thier way to Go when they're familiar with programming fundamentals, such as flow control, functions, method, etc. 
That's very misleading. A goroutine has so little in common with forking a process that it's not even relevant.
Hmm so you think one of Go's problems is that it lack a lets say standard REPL like in Python , Ruby or other Scripting languages? Or are there more points like lack of packages against Python?
The use cases are voucher codes (like you see on Steam and other sites) or transaction codes for bank transfers. Anywhere you have to manually enter a code or an OCR process is involved. You would usually pre-generate a bunch of tokens and keep them ready for assignment. The map could point to an empty struct{} indeed, but the memory usage is insignificant, even for a few million tokens. math/rand is intentionally used, as each token has to pass the safety distance check and no "real" randomness is needed here. Turns out this is faster in tests.
No, it'll be always on. The limit is if you burn a lot of cpu in a spike, it'll get throttled to very very slow. If you get some hits randomly throughout the day it'll be 100% fine.
I don't know if it can map one to many, but many to many yes, with composition of the 3 tables.
composition and first-class functions are my friends when i want to rewrite and object-oriented design.
dlsniper is broadly correct, but first guess for that level of variation is that the rest of your system is not quiet. Double check with your system monitor that you haven't got other active processes.
&gt; However, context.Context‚Äòs most important facility, broadcasting a cancellation signal, is incomplete as there is no way to wait for the signal to be acknowledged. I don't see why waiting for termination belongs in Context. Just slap your goroutines in an https://godoc.org/golang.org/x/sync/errgroup
If you just wanna make SQL I like https://github.com/Masterminds/squirrel
Again feel free to comment on this post! ;)
The whole point of Context was to avoid writing the same thing for every single project. Especially considering how it can already tie into e.g. cancelling outbout net/http.Client requests! Common ways of doing things are good. 
Actually no, for those variations to be explainable you'd have to put the CPU from high performance mode to power saving while the CPU is doing a bunch of other things. The likely cause is garbage generated by the code in the goroutine and how that goroutine is used but without the code nobody can explain it. It's like asking your mechanic about a "strange sound" you hear in the engine without having the car with you. 
Squirrel """""helps""""" me by adding a pointless layer on top of an already excellent and expressive language, SQL. At least, that's what I got from the documentation.
Yes! Tried this and it resolved references that gogland could not, even when my project was set up correctly.
What is port "0" doing in this statement, I never seen port 0 being used before: net.Listen("tcp", "127.0.0.1:0")
You don't have to mock out the db if you use a test db for tests ;) If you do so your integration tests would be closer to the real environment, which is a win, at the cost of slightly slower tests, otherwise you're not really testing the db insertion, and there's not much point in your tests anyway. All InsertUser does is call the db, so why bother to test if you're not using a real db?
If you don't care which port number to use - you may use port 0. Then OS will allocate some random spare port for your app. Since it doesn't matter if our web UI runs on 127.0.0.1:8080 or 127.0.0.1:45234 or any other port - I'd recommend to use port zero instead. Later we get the actual allocated port number from the listener address and load webview with the URL pointing at that port.
Go isn't good for HPC
[Port 0 is a special number](https://unix.stackexchange.com/questions/180492/is-it-possible-to-connect-to-tcp-port-0) for requesting any vacant port.
Thanks for the tip. But what if I want to unit test the PostUser handler? Would I have to use some sort of mock database (assuming if I won't be using the real database), or can I somehow avoid calling the InsertUser function within the PostUser during the test?
Yep, to the point of no return. I don't believe that breaking context will happen despite all hand waving. Simply because of how Russ described "the path to go2", compatibility and stuff :)
Cool, I'll give that a try too 
Another I have used is https://upper.io/db.v3/ which I think will give you the relation mapping you are after https://tour.upper.io/sql-builder/02 - but does add layer on top of an already excellent and expressive language, SQL.
Beware, the $2.5 plan is "sold out" in most locations and have been so for a long time.
It's meaningless since they are comparing a synchronous Go app vs asynchronous Java/C++. In order for this to have meaning it needs to be Go async vs. Java/C++ async. 
Linode is also an excellent choice ‚Äî https://www.linode.com/linodes ‚Äî and also has a $5/month server ‚Äî https://www.linode.com/pricing.
Good solid TIL 
I struggle with finding the proper way to design multi-threaded applications/packages using channels. It is easy with mutexes since I can apply my knowledge from other languages. But with channels... There are the questions when it is actually useful to let something run in a go routine, which messages should be passed and how and when to use deadlock wakegroups and how properly.... Many tutorials count to 100. But I have a hard time turning this stuff into real world code with a broader interface than ".AddOne()". Hope that makes sense.
"Lack of REPL" as you called it is most definitely not a problem, rather huge advantage. Scripting languages cannot be compared to compiled languages like Go because binary witch machine code is faster than executing scripts. In Go there are various projects that use REPL, like [anko](https://github.com/mattn/anko), which basically introduces lightweight go-like syntax to be used in runtime or as script.
I also don't think Go needs a REPL... Of course the execution of an binary built by the Go compiler is faster executed than running an Python program for example.. I know that you can use a REPL in go like for example [gore](https://github.com/motemen/gore) I just wanted to know why sometimes other people familar with other programming don't recommend Go as a beginner language 
Does anyone know where to find the code for this benchmark?
Did you read this? [MutexOrChannel](https://github.com/golang/go/wiki/MutexOrChannel)
The go routines were more or less basically created for the entire reason you just described. The relieve developers from the burden of threads.
Based on my understanding of what you're trying to do: You should use `&amp;sync.RWMutex{}` to get a reference to that mutex. If you do not then every call to `ThreadSafeMap()` gets a new mutex instead of the same one. Assuming you want to coordinate between those maps you'll need to ensure everyone has the same mutex (instead of a new mutex or a copy of the mutex, which is essentially a new mutex), otherwise locking/unlocking it doesn't really do you much good. However, if you just replace `sync.RWMutex{}` with `&amp;sync.RWMutex{}` you'll suffer the same issue b/c you're just passing in a reference to a new mutex every time. So assign it to a variable first `mut := &amp;sync.RWMutex{}` and then pass in `mut` in every call to `ThreadSafeMap`. Since the map receives a pointer it should expect a `*sync.RWMutex`. Now all your `ThreadSafeMap`s will have a reference to the same mutex. You can't do `mut := sync.RWMutex{}` either in this case. B/c Go is pass by value what will happen is that your `ThreadSafeMap` will receive a copy of the mutex, which is not the same thing. You really need the `&amp;sync.RWMutex{}` assigned to a variable first so that you can pass a reference to the same mutex around.
I haven't seen many people discouraging others from learning Go as their first language. I think it might actually be good to start with Go, since it is more simplistic. Don't let other decide for you. Try it. Dive in. If you won't like it you can switch. There is no such thing as bad experience.
Squirrel helps people when they need to build a query at run time so they don't have to manipulate strings and potentially cause errors. You are correct in that it is not a solution to the question you asked about.
FTFY &gt; *contraption
I completely agree about a concrete example here, even if it's quite abstract. It would really help me to understand points 2 and 3.
Shouldn't this line `ThreadSafeMap{sync.RWMutex{}, make(map[string]interface{})}` guarantee a new instance of mutex is passed into `ThreadSafeMap struct` and stored in the struct during initialization? Why does any subsequent call to `Put` create a new `sync.RWMutex{}` ? Each `ThreadSafeMap` should have its own mutex so that subsequent write to a particular `ThreadSafeMap` will not block write to other `ThreadSafeMap` Note: I am implementing concurrent map with 4 partitions (ie. 4 `ThreadSafeMap` ), each `ThreadSafeMap` does not have to synchronize with some other `ThreadSafeMap` 
Go is pass by value, so when you pass the mutex to a function the value is copied. Pointer types are a special type in that they point to something. So when you pass a pointer into a function the value is still copied, but the copied pointer still points to the same location as before the copy. These special types allow the different parts of the program to share state. Those are addresses of the pointers copied on function call, they both point to the same mutex. Try printing the address of the dereferenced pointer. Go doesn't have references. Go has types and pointer-types, and those types and pointer-types hold values. Possibly the use of the term 'dereference' in literature is the source of the confusion.
or you can use Go version manager https://github.com/moovweb/gvm 
Use `gofmt` pls!
I didn't want to make the statement Go isn't a great beginner language indeed I think it is.. but sometimes I hear the argument that Python and Ruby are easier to learn sometimes there seems to be much debate about it: [Quora](https://www.quora.com/Should-I-learn-Golang-or-Python-in-2017)
Imo, the only issue with that package is that Wait() only returns the single first error. It's hidden nasty bugs from me in the past that took a while to debug because I didn't have full error information. In hindsight, it should have been obvious from the single error but hindsight is 20/20.
Oh. Then I think I misunderstood what you were trying to do. Since you're passing in a mutex to `ThreadSafeMap` I assumed you wanted to share one in order to coordinate between instances. If that's not the case I would avoid this entirely and simply embed the `sync.RWMutex` in your `ThreadSafeMap` instead: ``` type ThreadSafeMap struct { hashMap map[string]interface{} sync.RWMutex } ``` Taking a closer look there's a few things that I wonder about. You append the `threadSafeMapInstance` to the bucket, but that would cause a copy of it to be appended if I'm not mistaken. I would expect that thing to maintain a reference to a `ThreadSafeMap`?
google clould platform has a free tier. 
Your mutex addresses look to be the same -- they were just printed in different orders.
exactly, I do have mutex embedded into my `ThreadSafeMap` type ThreadSafeMap struct { mapLock sync.RWMutex hashMap map[string]interface{} } But the problem is that I found that the lock is not enforced Consider the following `println` bucket.mapLock.Lock() fmt.Println("start") fmt.Println("this is my thread", thread) fmt.Println(bucket) fmt.Println(bucketIndex) fmt.Println(bucket.mapLock) fmt.Println(&amp;bucket.mapLock) bucket.hashMap[key] = val bucket.mapLock.Unlock() I see the following output start start this is my thread 1236 this is my thread 299817 {0x4212ecae0 map[123:123]} {0x421224300 map[123:123]} 3 3 the above output is interesting because, I expect something like start this is my thread {0x4212ecae0 map[123:123]} 3 0x42731b6f0 0x42731b6f0 start this is my thread {0x4212ecae0 map[123:123]} 3 0x42731b6f0 0x42731b6f0 instead of having `start` back to back. `start` cannot be back to back because only 1 thread can gain access to the lock at a time. 
&gt; {0x4212ecae0 map[123:123]} &gt; {0x421224300 map[123:123]} hmm, it doesn't look the same. Each thread seems to have a different mutex 
Go is pass by value, so when you pass the mutex to a function the value is copied. Pointer types are a special type in that they point to something. So when you pass a pointer into a function the value is still copied, but the copied pointer still points to the same location as before the copy. These special types allow the different parts of the program to share state. Those are addresses of the pointers copied on function call, they both point to the same mutex. Try printing the address of the dereferenced pointer. The quirk about mutex is that the mutex must be passed by pointer in order for it to share its state. the mutex doesn't function properly if it can't share state. Go doesn't have references. Go has types and pointer-types, and those types and pointer-types hold values. Possibly the use of the term 'dereference' in literature is the source of the confusion. 
Your problem is that in your put method you are making a copy of the slice value. Because the buckets field is: buckets []ThreadSafeMap When you do this: bucket := cMap.buckets[bucketIndex] A copy of the bucket is made, if you changed it to: bucket := &amp;cMap.buckets[bucketIndex] Your undesired behavior should go away. You could also store a slice of pointers instead, as a slice of values that shouldn't be copied tends to sneak back up on you with subtleties like this later.
You could just select another location
Sometimes you have to have a certain percentage of unit test coverage no matter what your code covers and have to unit test without a test DB. In this case he would be unit testing that his code builds the proper insert for the InsertUser
Do you really need/want to do native applications? With Apple announcing Safari is getting Service Worker support I personally believe Progressive Web Apps are the future
The best way for getting maximum unit test coverage is to have an if condition there: ``` if !os.Getenv("IS_TESTING") { env.DB.InsertUser(user.Username, hashedPassword, user.Email); } ``` The impact there is minimum, you only lose a line. If you have a lot of lines of code in your file, then it's perfect.
The reason for the &amp;sync.RWMutex{} is you need to ensure everything "points" to the same instance, otherwise it passes by value. Now for your second question, the benchmarking tool is generating multiple benchmarks, and this it the reason for what "looks" like a race is in fact not, check the address of the cMap as follows : fmt.Printf("start : %d bucket address %p, map address %p \r\n", bucketIndex, bucket, cMap) It will show the cMap is a different instance, hence the mutex is different also. In the BenchmarkMyFunc(b *testing.B) add the following line and you can see it generating a new instance : my_map := NewConcurrentMap(uint32(4)) fmt.Printf("MAP ADDRESS %p \r\n", my_map) Also, I would in my opinion, change the type ConcurrentMap struct { buckets []ThreadSafeMap bucketCount uint32 } too type ConcurrentMap struct { buckets []*ThreadSafeMap bucketCount uint32 } When ever I am dealing with an object that must be pointing to the same objects etc, and to ensure GO does not pass by value anywhere, this kind of makes me feel alot safer as I know exactly what I am instructing GO to do. Hope this helps.
https://github.com/grpc/grpc-go/blob/master/benchmark/ https://grpc.io/docs/guides/benchmarking.html
Thank you!
It's reasonable to want termination confirmation when doing multiple things at once, but most uses I have of context in the request scope don't actually need that. It will be interesting to see how Context fits in, or doesn't, in 2.0. This could also be a good time to plug the slides for my recent golanguk talk: How to correctly use package context http://go-talks.appspot.com/github.com/cep21/golanguk2017/How-to-correctly-use-package-context.slide#1
Okay -- maybe I don't understand your code but what I really don't understand if your benchmark. I think there is something wrong there. It doesn't make any sense to benchmark the creation of a go routine. The code as it is posted doesn't even compile. You should try posting some code that compiles so that others can try it out.
Author here. I recently learned about the awesomeness of go generate and wanted to share in case others were interested. I by no means think you should actually use the library I wrote (other than perhaps in tests?). But it was a cool experiment none the less.
The best way to do this is to instrument your calls with a metrics client that either saves metrics to a local DB or remotely to a service like datadog or librato. There you can view not only your averages, but also percentiles, and trends over time.
I work on gRPC. This is true - we have historically spent more time and effort optimizing C++ followed by Java then Go. The grpc go team is now turning its attention on performance optimization and we are starting to see good gains. There is actually a blog post detailing our work so far and plans, we will publish it this week but you can get a preview here - https://github.com/grpc/grpc.github.io/pull/549. 
Having all the errors is *easier*, so do that with just a WaitGroup if that's what you want.
Haha... yes.
So let's change that 10 years from now
I use these https://docs.google.com/document/d/1Zb9GCWPKeEJ4Dyn2TkT-O3wJ8AFc-IMxZzTugNCjr-8/edit?usp=drivesdk But I more then super suggest this. http://www.informit.com/store/ultimate-go-programming-livelessons-9780134757483
For those who asked, here are some more concrete examples of each, phrased in more traditional object-oriented terms. **Domain models with common base functionality:** A web framework implements a user management module. Users might be anonymous (not logged in) or authenticated (logged in). The code contains a `BaseUser` abstract base class, with most login-agnostic user functionality, which is then extended by `AnonymousUser` and `AuthenticatedUser`. (AFAIK, this is how Django and possibly other OOP web backend frameworks actually work.) **Common functionality mixing in:** You have a conceptually comparable (strictly ordered) domain model. You implement a `compareTo` or `&lt;=&gt;` method that returns `-1`, `0`, or `1` for the actual comparison operation. Then you mix in some sort of `ComparableHelpers` mixin, and it implements all the other comparison methods (such as `&lt;`, `&lt;=`, etc.) for you. (AFAIK, this is how Ruby does its `Comparable`.) **Framework base class with helpers:** A framework for writing IRC bots supplies an abstract base class `BaseIrcBot`. It contains a number of integration points for user-defined bot implementations in the form of abstract callback methods, such as `onUserJoinedChannel` and `onReceivedChannelMessage`. Additionally, it contains a number of helper methods for functionality that bots can use, such as `sendMessageToChannel` and `sendMessageToUser`. Framework users are expected to extend `BaseIrcBot`, filling in the appropriate callback methods, possible using some of the helper methods in the implementation bodies. (AFAIK, this is now most OOP IRC frameworks actually work.)
Please see my other reply.
Please see my other reply.
Only if it drops the GC and introduces ways of controlling where something lives.
To be honest, I was confused by this response, because I typically associate SOLID with traditional object-oriented design. In particular, while SOLID itself does not talk about inheritance, I have always seen it demonstrated with such.
google app engine?
Yes if you are really interested in testing handler, then just mock the db, say a mockdb struct which defined all methods specficied in datastore interface. But instead of producing results from database it will produce/inserting result from/in an array of your data.
D has optional gc, hopefully Go can too
For sure, just so you're aware for a future project the web platform has both notifications: https://firebase.google.com/docs/cloud-messaging/ And payments: https://developers.google.com/web/fundamentals/discovery-and-monetization/payment-request/
Interface segregation says that the interface should belong to the client. This is harder in a traditional OO language that implements interfaces by having to explicitly extend a class with them, because the implementer must now import from the client. Golang's implicit interfaces help with this, allowing clients to create small interfaces that they need with far less confusion or friction.
I used a simple bash script to install a specific version of Go, and a config (`~/.goconfig`) file that a default version I load for each shell. When I want a different version, which isn't often in my case, I update my `GOROOT`, `GOPATH` and `PATH` in a shell to point to the alternate version. You'll want to modify the script to get the right file for your OS. Check the filename. The script assumes linux-amd64. I have these versions installed at the moment. $ ls -1 ~/.go/versions/ go1.8.3 go1.9rc2 There is nothing magical going on. Just a basic installer and a shell config file. See the `install-go` script, and `.goconfig` here https://gist.github.com/scottjbarr/00b4d037c71f8547f58cd838e0aef7a8 
For sampling from a Gaussian, [NormFloat64](https://golang.org/pkg/math/rand/#NormFloat64) has you covered. Just multiply the Normal distribution by your standard deviation and add in your mean.
Short answer: no. Also, good practice is to "wrap" your errors with added context, like so: `return fmt.Errorf("xyz failed: %v", err)` In some instances it might make sense to use a wrapper function to cut down on the "if err != nil" boilerplate‚Äîand some people on here advocate for it‚Äîbut I feel comfortable saying that, in practice, it's frowned upon.
You need to get this keyboard: https://pbs.twimg.com/media/DCIF7-2W0AEAv9c.jpg
Very useful wrapper. Haven't come across before. Thank you!
Most of these patterns you mention, that are common in other languages, can introduce strong coupling. We prefer to avoid that in Go. In fact, Go has been designed in a way to make some of these patterns impossible even. Instead, Go is about composition. I can recommend [this talk](https://www.youtube.com/watch?v=zzAdEt3xZ1M).
As for why it provides Zipf distributions: back in 12/2009 (long before Go 1, just a month after it was announced to the public), William Josephson added it with [this commit](https://github.com/golang/go/commit/52114724b779d2826746dfc3c2475f659bbd7961) and we see some feedback in [this review](https://codereview.appspot.com/176070) but no reasoning on why he wanted to add it. The [release notes](http://golang-nuts.narkive.com/7cjy5i2N/release-2009-12-22) mention it but no reason either. I can only imagine that Googlers wanted to have it in there because Zipf's law is often used in Natural Language Processing (NLP) and simulation thereof. The zeta distribution has many other uses, of course. &gt; Zipf's law states that given some corpus of natural language utterances, the frequency of any word is inversely proportional to its rank in the frequency table.
It's always a copy, even in the pointer case it's a copy, it just happens to be a copy of the pointer. Unless I'm wrong :D but I believe that's correct in all cases. If you keep using &amp; you're just taking the address of that pointer, and the next pointer, and so on.
If you are doing these operations a lot, you can define a struct wrapper around these functions, and have each of those check that the error is not nil before proceeding, something like this: https://play.golang.org/p/YbL-UOjRuS This is the wrapper style that elagergen is referring to. 
The go blog has a good post on error handling. It goes over different ways to get out of the if err != nil repetitiveness. https://blog.golang.org/errors-are-values 
https://github.com/pkg/errors
using a snippet helps.
I would highly recommend reading this article on this topic. It's very relevant. https://medium.com/@shazow/code-boilerplate-is-it-always-bad-934827efcfc7
Or make a code snippet in atom/VSCode
It's already there in vscode, type ife+enter and it stubs its out for you.
This all is very easy once you stop using inappropriate terms while thinking of it. It is not helpful to ask about the hair color or the accent of a bacterium. These are categories applicable to humans. Same in Go: there are no references in Go and there are no "shallow" copies (and no "deep" copy, all there is are copies of values). Putting &amp; before a variable does not produce a reference, simply because there are no references in Go. It produces a value of totally different type: var i int = 3 // create variable of type int and store 3 in this variable var p *int = &amp;i // create variable of type *int and store memory location of i init Note that `p` is not a "reference to i". It is not. Forget that now and forever. `p` is a pointer to an int and nothing else. The same applies to `:=`. This operator creates a new variable and assigns a value to it. The type is inferred for your convenience from the right hand side. So your copy1 := someStruct.listofStruct[0] copy2 := &amp;someStruct.listofStruct[0] is basically (writing out the type interference) var copy1 someOtherStruct = someStruct.listofStruct[0] var copy2 *someOtherStruct = &amp;someStruct.listofStruct[0] And now you see that `copy1` and `copy2` are totally unrelated. The have completely different types. `copy1` really is a copy of someStruct.listofStruct[0]: It has the same type and was assigned via = so a copy was made. On the other hand `copy2` is **not** a "copy". You asked the compile the "give me the memory address of someStruct.listofStruct[0] and store this value in copy2 (make this an appropriate pointer type)". Absolutely no copying here. Pointers are totally normal values. Making a copy of a pointer value makes a copy of a pointer value. No magic here. No deep or shallow copy, no references. Same like making a copy of an int or a complex256. By dereferencing a pointer you can "get back to the object pointed too". This is the only "reference" like step. In your case you can modify what copy2 points to by `*copy2 = ...`. Note the * which dereferences copy2 (if copy2!=nil). What everybody irritates at first is that some Go types use pointers internally: especially Maps and Slices. E.g. a slice is a view into an underlying backing array and two slices may look at the same backing array and each slice may modify what the other sees (as the see the same backing array). Such types have reference semantics. 
In gogland it's "err.nn" if anyone cares
Going a little off topic from generics, but... I didn't really like viper myself because it brings in too many different file formats that all get compiled in. Also it loads the configuration globally so it's difficult (impossible?) to load two config files into different structs. I would rather choose one config file format I want, e.g. BurntShushi/toml and just stick to that only. Why should I need yaml, hcl, and whatever other formats I don't care about in my app. http://godoc.org/github.com/spf13/viper?import-graph&amp;hide=1 vs http://godoc.org/github.com/BurntSushi/toml?import-graph&amp;hide=1
Read it now and I agree with the classification for channels and mutexes. But since you asked for missing resources for beginners, I would summarize my first reply like this: Helpful for me would be a tutorial based on a real world scenario where proper project/interface/struct design is shown and described. I am working on a raft implementation. When I am ready, I'll try to get reviews from somewhere.
FWIW, ~10Œºs [edit: ah, no, it was ~1Œºs. But still] is roughly what I observed at some point, when I tried to measure how long it takes for a goroutine to start up. So, from what little information you gave us ("something, something goroutines"), this doesn't seem all that surprising to me.
&gt; I didn't really like viper myself because it brings in too many different file formats that all get compiled in. No, they don't. That's not how any decent compiler works. Dead code is dropped. If you don't use those formats and the compiler can work that put, it won't include those parts in the binary. &gt; Also it loads the configuration globally so it's difficult (impossible?) to load two config files into different structs. It is impossible because you haven't read the manual at all. Viper works like net/http does. See http://godoc.org/github.com/spf13/viper#New for how to load as many instances as you need. &gt; I would rather choose one config file format I want, e.g. BurntShushi/toml and just stick to that only. But you are not the only programmer that needs configuration for apps nor is it possible sometimes to so that. &gt; Why should I need yaml, hcl, and whatever other formats I don't care about in my app. You don't need to care about those with viper either. But I do. I have enough apps that using viper makes things so much more easy to read since it's always the same interface to interact with the configuration that it makes things a lot more common between my apps. If viper is not for you, that's fine. But I highly suggest that you read the manual a lot more that you do now. 
I can understand immediately the flow of your code and where an error can occur. If I need to debug it I know where I will just wrap your error with more context, and that's all. Keep it this way, when you'll read it in some years you'll be happy to find so readable code !
Why you need to duplicate the filepath package? What problem with using `filepath.ToSlash` and `filepath.FromSlash` as imput/output wrapers?
In this instance, if you mock the db in the function given, the test would only test that your mock was written correctly, as *every* line in the function is related to db access. The point of a unit test is to test data in against data out so it's suitable for functions without side effects, for example a function to transform a value (e.g. calculate tax), a method on a struct etc. You can't meaningfully unit test a function which relies almost entirely on external state. Handlers are better tested with integration tests which are testing the entire flow of your application (including authentication, db access, rendering templates). That way you're actually testing what will happen for end users when they hit that handler, not testing how good your mocks are. 
Well, inheritance proved to be anti-pattern or nearly so in practice, and Go doesn't have it for reason. Even in Java it is recommended to prefer composition over inheritance. In Go you only have a right choice :)
I agree with most of the replies here, but I'd like to add this idea: If you use automated ways to put this snippet into your code, you are losing the chance to really think about those lines. Is this really an error that only the upper layer can decide about? Is there some extra cleanup needed when this place gets an error that other places don't need? Error handling code needs to be a first class citizen in your consciousness. Writing code like it can never fail is occasionally useful during beginning programming exercises, but professional code is not written that way, and if you hope to earn a salary (not just "get" it, but *earn* it) you will be in the habit of making robust code that responds to the errors that will arrive in a constructive way.
Use this package if you don't care about error handling.
You are simply declaring different stuff. copy1 is an element that CONTAINS a copy of list[0], copy2 is a pointer to the element [0]. 
Thanks for sharing this! Your Advocates Doc is ver useful for beginners! Do you also have a Markdown version of this on Github? And yes William Kennedy is a genius I read [Go in Action](https://www.amazon.com/Go-Action-William-Kennedy/dp/1617291781) and in my opinion its one of the best books about Go around..
 TL;DR: the elimination of the boilerplate error handling code is not particularly interesting when programming in Go, and that's fine. I think the Go way doesn't incentivize hiding complexity by syntactic abstractions. There are differences between semantic abstraction and syntactic abstraction (terms invented just now for convenience, sorry if they are mistaken ones). To clarify what I mean: - Semantic abstractions: state machines, callbacks, trampolines, exceptions, coroutines, message passing, threads, garbage collection, reference counting, scheduling, and so on. They are the things that could be implemented in the chip or OS level and could occur runtime costs. - Syntactic abstractions: preprocessors, templates, macros, operator/function overloading, generics, ADT, tuples, and so on. They are the things that typically are only interesting in the PL or compiler level. They could be zero-cost or not depending on the cleverness of the compiler. 
I don't joke about that. That's not funny.
Feel free to share the raft implementation with me when you're ready! Do you have link ano GitHub to this? I know finding real world examples of Go code is sometimes tough.. summerizing some of the problems for beginners is the reason i started this...
Can you elaborate? I spoke of that wholeheartedly and in good faith. ;)
This is a convention I've seen used quite a bit. Generally always begin with a lowercase letter and a colon before the wrapped error. Francesc Campoy does this in his excellent justforfunc YouTube series.
There's also Hetzner that offers more ram for half the price. I've been using it for years. The downside is that website and panel is archaic, but once you get ssh access you don't use the panel anyway.
You could mock your database in a way that makes it possible to define the result of the InsertUsers() call for each test like this: type Datastore struct { InsertUsersFn func(u *model.User) error InsertUsersInvoked bool } func (s *Datastore) InsertUsers(u *models.User) error { InsertUsersInvoked = true return s.InsertUsersFn(u) } Now in your test you can define InsertUsersFn() and a table test containing all relevant cases that your handler should test for before actually invoking InsertUsers() or returning an error. func TestPostUser(t *testing.T) { datastore.InsertUsersFn = func(u *model.User) error { if u.Email == "already@exists.com" { return errors.New("doesn't matter") } u.ID = 1 return nil } tests := []struct { username string password string email string statusCode int invokeInsertUsers bool // add more fields to check for more if needed }{ {"user1", "password", "new@user.io", 200, true}, {"user2", password", "already@exists.com", 422 true}, {"u", "password", "new@user.io", 400, false}, // username too short {"uer1", "pass", "not an email", 400, false}, // not an email {"uer1", "pass", "new@user.io", 400, false}, // password too short } for _, tc := range tests { // call your PostUser function either directly or via a httptest.NewServer() res := testRequest(t, ts, "POST", url, data) if res.StatusCode != tc.statusCode { t.Errorf("got http status %d, want: %d", res.StatusCode, tc.statusCode) } if !tc.invokeInsertUsers &amp;&amp; datastore.InsertUsersInvoked { t.Errorf("datastore.InsertUsers() invoked, expected: %v", tc.invokeInsertUsers) } datastore.InsertUsersInvoked = false } } This way you only test if your handler is behaving correctly. You can have another integration test with build tag integration to only test your structs against a real database when your schema changes.
Added binary downloads (linux, windows) on Day 14. You can grab them from the releases page if docker isn't your thing. :)
Do you know why the Go test was run using synchronous calls and the C++/Java was asynchronous? 
You can't improve all of it, but you can do a block-level assignment with conditionals: if err := CheckBarSlice(sliceBar); err != nil { return err } This will also work with variables you only need inside the conditional blocks (also works in the else statements).
Have you looked at [Go Buffalo]( http://gobuffalo.io/docs/getting-started)?
Agreed. GC just doesn't work with HPC. It's not elitism or trying to be macho because you run valgrind consistently, it's just a fact that a fundamental requirement of HPC is having interfaces which provide a deep level of control.
The Go 2 -&gt; Go 1 integration should be seamless because they want to release an update tool for the Go 1 source code that converts it into Go 2. Nothing more and no dialect whatsoever.
Thanks for the suggestion :) I feel like Go has all the tools I need in the standard library, and seeing as I want to learn best practices, I'd rather stick with that as much as possible.
Seems like an anti-pattern and against go's simplicity first ideal.
In my company we are using first way. It allows you to easily pass additional data(config, session store, models). It's also very clear and easy to read. You should split handlers and models(handlers shouldn't have db connection in them). Handlers are for reading session, i18n, cookies and every other Web stuff, where models are doing things like db queries or data manipulation. 
Thanks! I was going to separate models and handlers, but I'm unsure of what the best way is to do this. Would I attach functions to the blog model (load, create, update, delete), or would I create helper functions for this? How would I best pass the database to the models from the controller / handler structure? 
I would recommend writing the client side ui in something like Vue.js or reactjs. Then just have your go backend return JSON data that the frontend can use. It makes the backend simpler and faster and allows you to take advantage of the fairly rich ecosystem of libraries and tools available for ui development. 
Well, database connection, config and other similar stuff should be read in main, where you are using them to create your model. This model then you can pass to handler as a struct field and invoke functions inside handlers. For example: type Model struct{ DB *sql.DB } AccountHandler struct { AccountModel *Model } And in main: db, err := sql.Open(config.Database.Driver, config.Database.URL) if err != nil { log.Error(err) return } accountModel := Model{ DB: db, } handler := Handler{ AccountModel: accountModel, } Now you have your model and handler type, where only thing needed now is to create methods to them.
Usually I'd write a JSON API and use angularjs or react to build the front-end. Unfortunately I won't be able to do this for this project. 
Hmm, this looks like it would become messy very quickly, if you define a model and handler for each section of the site. In regards to the model, how would this work for a blog for example? Would the model have functions attached to return a single blog, all blog entries, delete a blog, etc? Would I basically be building an ORM here? 
Ha. This looks like a first step towards perl's old `CheckBarSlice(sliceBar) or die ;`, automatically assigning to and using `$_` of course
Is that enough? I was worrying about any other edge cases that might be non-obvious.
Actually this one is really nice. https://go-macaron.com But if you want custom then google away...
Thanks for the suggestion, but as I said, I'm not really looking for a framework :) I have googled my questions extensively but unfortunately there is a lot of conflicting information out there. Worse, concepts are usually explained with a super simple webapp that fulfills one purpose (a todo list for example), and is not organized in packages. 
Please, just no: https://www.reddit.com/r/golang/comments/649o0c/comment/dg0neoo. Same discussion on `errors.New` applies to `fmt.Errorf`. Only use them if you want to torture the people that use your code!
Solve problems as they come along. If you need to work with something special or unique - no need to wait for a silver bullet or a miracle. Special requirements require special code. For common cases, "filepath" does its job well.
What alternative do you think is appropriate and better?
&gt; but supports both GC and non-GC applications Not if you want to use the std library.
Rust can theoretically because it can provide more information with it's typesystem to the compiler = the compiler can produce better code (eliminate array bounds check and stuff, don't tackle me on the details).
I think it's great to make yourself a parameterized snipped. Currently in Gogland I created a live template called "wrap": ``` if err != nil { return errors.Wrap(err, "$VAR1$") } $END$ ```
+ fake benchmarks + flattend git histories + blatant lying when caught doing all of the above
Well, as far as we are creating our apps, code is pretty clean and understandable, even for new person in project. For 12 handlers and few models main and code structure looks pretty good, but you're probably right for very, very big projects, and that's why we are looking for better approach to this problem.. Yes, model would have methods like SingleBlog(), AllBlogs(), which return blog to handler and handler is passing this JSON object to front-end. Also for blogs, i think this would work pretty well. Handlers and models should be pretty straightforward, classic Add/Delete/Edit methods for posts/comments, maybe something more if you want your own photos and videos. What do you mean by building ORM? If you're referring to struct types being same(or very similar) as database tables, then you're probably right. You could create few struct types like AddPost/DeletePost/EditPost or one bigger struct which contains all these 3(or more) types and use this to pass data around.
I completely disagree. Go's fast compiler/strict typing/fmt tools etc makes programming way easier to start with than any other dynamic programming language. It's like having a piano teacher hitting you on your fingers when you screw up even on the basics.
I just want to add something that helped me long ago and that I think is true in Go/C++/C : A variable is just an adress location. Instead of telling the computer store this serie of bits in 0x015c5c15c1c5, you tell him to store it in Variable1. Variable1 is just a nicer name of a memory adress location. *Please correct me if I'm worng*
I appreciate your suggestions. This is a much more complex project than a blog, so I wanted to make sure I understand the best practices for building out each component. I'm still a bit weary of creating a model and handler for each component of the site though, it just seems like a lot of code duplication to me. 
&gt; return fmt.Errorf("xyz failed: %v", err) As /u/DenzelM says, this is a very bad idea. Among other things it removes any chance for the caller to investigate the error in any sane way. (e.g. `if err == io.Err`, `if os.IsNotExist(err)`, `if ne, ok := err.(net.Error); ok &amp;&amp; ne.Temporary()`, etc, etc).
Can be done in vim too. What I do is ignore errors with `_` and then go back and "expand" the blank identifiers into error checks using a custom key map (because snippets annoy me). nmap &lt;leader&gt;e xierr&lt;esc&gt;oif err != nil {&lt;enter&gt; With this you just put your cursor over the `_` and press `\e` and it generates the code. 
Yes, there's some code duplication, but it's actually very useful, because you're instantly seeing all handler/model dependencies and it's pretty easy to add new things to single types(this model needs config? Here you go, but one code line more). That's the place where you need to decide which thing is more important :) Also it's pretty important to have middleware(s) to pass things like authorization/session/translations between handlers(we are using context for this) when you're taking this approach. This makes you to duplicate essential things only(max 2/3 lines for every handler).
&gt; Note that p is not a "reference to i". It is not. Forget that now and forever. p is a pointer to an int and nothing else. To be fair with OP, reference and pointer are terms often used interchangeably. The only context that I knew where a distinction matters is when we're talking about passing by reference to a function. After searching to understand what you meant, I only just learned that in C++ a reference means a static pointer/alias to another variable.
I suggest working through this tutorial: https://golang.org/doc/articles/wiki/
What do you think about something like this for a starting baseline? https://github.com/dandee/HomeStash 
Really nice! Just started using it to generate user avatars like this http://imgur.com/VV8JDw8 I am wondering why the text is not exactly centered vertically though?
Variables refer to some stored value but they are just symbolic names for the programmers. Yes, it's just a nicer name of a memory address location, but the computer doesn't care and will replace them when compiling. Variable1 won't exists, it's all 0x015c5c15c1c5.
Plus, not thinking about each instance means you aren't adding comtext-specific details to the errors when you return them. Just `return err` should almost never appear in code; at the least it should be `return fmt.Errorf("failed to foo the bar: %s", err)`. Otherwise when those errors finally trigger and bubble up, you'll have no idea what actually caused the problem and you'll make troubleshooting that much harder on yourself.
&gt; The Go program, on the other hand, does not need to start a runtime. Yes, it does. Python's slowness comes from the fact that even the "compiled" .pyc files need a lot of work on the way in to memory, and it has to load quite a number of them even if you are doing basically nothing, whereas Go just memmaps into place and starts executing. It is reasonably likely that your program never GCs, though. I can't remember what Python does at the end of its execution; I think it might still deconstruct every object in case there's a \_\_del\_\_ method somewhere it has to run.
I'm using both, and neither. I can't say "neither" is best practice, but it suits me well enough in some cases where individual dependencies can grow beyond manageable limits. For example, with a pool of something like 20 connections to various databases with their own credentials, it serves me better to provide a single database factory than to figure out how I'm going to create and name the objects and pass them as arguments or properties. The database factory provides me with the resulting sql.DB based on a string (connection name). Think of it like holding a map[string]*sql.DB, and passing that to the functions. Except it's a package with a specific interface: `factory.Database` + `Get(name string)`. Adding support for new connections is then just the question of adding a few lines to a config file. Again, it depends on the scope/fragmentation of requirements, but if we followed best practices in every possible instance, I'd be working with about 300-400 different database connections with their own credentials for each available microservice that we run. Cutting this down to the major ones and not resorting to a global access everything database user gives us some trade off between practicality and security. GL :) Edit: I've had issues with the same line of thought before. So I created a bit of a research of possible ways to "pass stuff in" in a series of blog posts: https://scene-si.org/2016/08/01/golang-tips-and-tricks-part-3/ - I'm just gonna link this one, I think at the bottom I link every article in the series. For educational purposes only :)
This is funny. In other langues i freak out now because I am not checking my errors explicitly.
Nice point.. I also think that Go fast way to to compile and directly see where I made mistakes is a great way following good practices and rules even on the basics... I wonder why so many people favor Python all the time... Sure it is longer out but..some aspects I don't think are easier then Go for example: [Python Syntax: Indention](https://en.wikipedia.org/wiki/Python_syntax_and_semantics#Indentation) 
No, there is not better way. Go should have use tagged unions like `Result&lt;T, error&gt;` but its authors ignored all the modern knowledge on language design and now we have to use all of this error-prone boilerplate code.
What isn't simple about it?
Ugh, no. There is `stackerr` for that - https://github.com/facebookgo/stackerr
you should use one function to handling the errors, you code is ugly because you should pass the error to a single function lile func checkErrors(err error){ if err != nil { do stuff } } and call it with err := CheckBarSlice(sliceBar) checkErrors(err) 
https://github.com/MakMukhi/grpc.github.io/blob/53008d69fde443a01eb7b3338599dc1c73bd532e/_posts/gRPC-Go%20performance%20improvements.md
I think Rob Pike's article [Errors Are Values](https://blog.golang.org/errors-are-values) is probably the best compromise between something that helps with the problem while keeping the code fairly idiomatic, inter-operable with external libraries, and readable by everday go developers. There are more exotic exotic approaches like [using monads for error handling](https://speakerdeck.com/rebeccaskinner/monadic-error-handling-in-go) and even some [libraries to support this](https://github.com/asteris-llc/gofpher) (disclaimer: I wrote that presentation and library, but there are others out there) but these approaches typically fail because of the lack of parameterized types as well as the general lack of support across external libraries. I've still used monadic pipelining for some sections of production code, but doing so is a much heavier decision than it would be in languages with better support for the constructs.
&gt; I have a use-case where I may need to work with linux filepaths on windows, or vice-versa. I've had a similar use case like that. Or at least I thought I did. First I did manual replace of slash. It was messy and there's lots of bugs. Then I discovered `filepath.FromSlash` and `filepath.ToSlash`. Things improved but the system just seemed fragile and error prone to me. So I reviewed the requirements and now I am planning to rebuild the software so that there will be an additional server component which will be doing the final conversion. This component will always be running on a Linux machine so things are going to be much clearer I believe.
Fair enough. Sorry my suggestion wasn't helpful!
https://blog.golang.org/error-handling-and-go
Vertically centering text with variable font-sizes is actually not as easy as it may seem. There's the cap height (the height of the capitals), x-height (the height of the lower-case letters) as well as ascender height and descender depth. Not to mention different fonts behaving differently. In your example, it would probably look centered correctly, if one of your letters is a capital "Q". I will have to look into the freetype bindings and should be able to improve this. I'd actually appreciate it if you could file a issue for this, with your example image and font-info attached. Thanks!
To rephrase: Use this package if you are too lazy to do proper error handling.
I believe the experience and tools for the Go 1 -&gt; 2 interop may be reused to provide interop with other dialects (i.e. a low level Go dialect) though. After all Go 2 will be a kind of dialect of Go 1(or the other way around). 
Unfortunately the system that I connect to deals with both OSes interchangably, and passes raw paths on. I have to be able to deal with either case, and I can't do so at the source.
I have found this blog post to be very helpful - http://www.alexedwards.net/blog/organising-database-access. I use the 3rd method in that. And have found it very useful on writing unit tests.
Looks nice! I usually use `column -t` on unixes, but I like the look of the justification options that `align` provides.
Sure, if you're returning an err from `io.Reader.Read` then you'll want people to be able to check the error's type. A fair amount of libraries don't offer exported types, though, so it depends on the situation. 
The "right" way would be to use the x/net/html package instead of templates and perhaps when wasm becomes a thing with DOM access you can reuse the code and even provide interactivity (through the DOM/web APIs)
Ok..let's see how it goes in practice. We already have two projects that may be compared &lt;speed wise&gt;: Chrome and Firefox/Servo.
I use something similar to this to make these kinds of check a one-liner: func OnError(err error, text string) { if err != nil { fmt.Fprintln(stderr, text+": %s", err.Error()) os.Exit(1) // or log } } func Error(text string) { fmt.Fprintln(stderr, text) os.Exit(1) // or log } 
You could also use `type OptionalString *string` instead of a struct. Or generics.
https://www.golang-book.com/books/intro
&gt; reference and pointer are terms often used interchangeably And that is the root cause of the problem. Some languages *do* have actual references and they do behave differently because they *are* references. If you are trying to do physics and use energy and power interchangeably you will have a very hard time. These are different concepts and mixing them up just "everyday usage" of these terms might mean something similar will lead to major problems understanding the fundamentals. It is never helpful to even mention the term "reference" when talking about pointers in Go.
Glad to hear! I hope it proves useful for you. Configurable padding length is on the way too!
Well there has to be a way. For example you could treat the Linux the system as the source of truth and only store that kind in your code and only do conversions for the windows machines. Or you could try and do an abstraction of the path and only evaluate it lazily when you know the actual machine. I don't know exactly what your system has to do so it's hard to propose a solution but there has to be some way.
Is your question directed at beginners coming from another language, or complete beginners to programming?
Are people still using mongo these days? I thought it was just a fad. I'd be interested to see the db schema usecase that allows to use mongo at Rover.io.
There is also Nucular, a pure golang port of Nuklear.
No, Go 2 is not a dialect of Go 1, the tool is for updating the source code from 1 to 2 for autofixing problems with new features (generics?), Go 2 is not necessarily a super class of Go 1.
The reason they sell monitors at 144FPS and now 256FPs is because people can see and react that fast. Sure those are generally for video games. But pretending &lt;Xms is the end-all-be-all of human perception is arrogant.
I have a local database running on my machine when I'm developing. My application is set up so that in debug/test mode it'll clear the database and load a known set of test data into the local database. I run the tests against that. I do this because the database itself enforces referential integrity and various other conditions, so it's important that that logic isn't ignored during testing.
You are not working in your GOPATH. you need to either set your GOPATH to /home/eoinsapp/ or move your code to /home/eoinsapp/go/
thanks for the help. ill give it a shot
i love how go generate is pretty much an "implement the stuff rob pike doesn't understand yourself" mechanism
I would like to know what both sides have to tell.. So if you are a complete beginner to programming feel free to comment ;)
Also, fmt.Errorf is 4 times slower than errors.New !! (tongue-in-cheek, but more seriously, the former is a wrapper of the latter, which then adds an unneeded extra call and fmt as a dependency)
I've written a function called `die` many times that prints and exits if an error is not nil. It's not good in medium/large programs but it's fine for a small one. 
You are wrong. There will be two languages sharing the same runtime... at least that seems to be the plan. There won't be just a tool that will convert Go 1 to Go 2. So Go 2 will be a dialect of Go 1. Hopefully the runtime sharing API will allow to seamlessly plug other dialects and provide some/more control over the GC. https://blog.golang.org/toward-go2 We must not split the Go ecosystem. Mixed programs, in which packages written in Go 2 import packages written in Go 1 and vice versa, must work effortlessly during a transition period of multiple years. We'll have to figure out exactly how to do that; automated tooling like go fix will certainly play a part.
I use it to add a stack trace to my errors, and then to be able to annotate them without losing that stack trace.
One of my ten commandments of coding is that line returns aren't evil. optimizing for compactness almost always makes your code less readable, not more readable.
&gt; There won't be just a tool that will convert Go 1 to Go 2. The converter is only that, it converts from Go 1 to Go 2. &gt; Gofix is a new tool that reduces the amount of effort it takes to update existing code. It reads a program from a source file, looks for uses of old APIs, rewrites them to use the current API, and writes the program back to the file. Not all API changes preserve all the functionality of an old API, so gofix cannot always do a perfect job. When gofix cannot rewrite a use of an old API, it prints a warning giving the file name and line number of the use, so that a developer can examine and rewrite the code. Gofix takes care of the easy, repetitive, tedious changes, so that a developer can focus on the ones that truly merit attention. https://blog.golang.org/introducing-gofix
I know what go fix is and it will "play a part" for sure but I hope you can read the full statement, especially this part "Mixed programs, in which packages written in Go 2 import packages written in Go 1 and vice versa". 'Go fix' can't fix everything. You should know that if you used it.
While I love the Go wiki and documentation, unfortunately this doesn't go into details on the question I have. 
Just read this https://pavelfatin.com/typing-with-pleasure/ if you actually care about latency in terminal. That is proper engineering right there.
I can't find anything about "mixed programs" on that site, the word "mixed" doesn't appear at all? Also Go 1 with Go 2 in the same package seems unlikely if they write in that article that gofix is there to fix API changes so having both APIs at the same time should be impossible / a compiler error?
Why would anyone prefer a massive try-catch block to this? 
If this were Lisp, we could have a macro `(nil-check)` that expands to conditionally returning `nil`'s up to the last return field, followed by `err`, if err is non-nil.
Problem solved: https://twitter.com/NateTheFinch/status/899730215957561344
The best place to get started is the the Go Learn wiki itself. Check it out [here](https://github.com/golang/go/wiki/Learn). I've also put together a bunch of resources I've used throughout my time with Go, you can check those out here [https://www.berged.com/blog/go-time/](https://www.berged.com/blog/go-time/) Good luck out there
If this were Rust you'd type ? which is included on all keyboards.
Yeah that's my point. Stack traces are the lazy man's error handling. To quote /u/themerovius: &gt; I really dislike that package. It's born out of an unreasonable rejection of debug logging, it encourages useless error messages (It equates "helps telling the user what went wrong" with "barfing out a stack trace") and with the language as it is, it just fails if not everyone is using it (and thus violates the whole "errors are just values" idea). &gt; I think it's a perfect example of something that seems reasonable and helpful at first glance, but just encourages bad design and bad code when looked at with some distance. [source](https://www.reddit.com/r/golang/comments/6t9puo/which_external_packages_would_you_like_to_become/dljwh8d/?st=j6mqjden&amp;sh=7eed5b0f)
Give me Python's dynamic typing than having to fight the strait jacket of dumb static typing that doesn't stop run time panics.
There are more concise ways of handling error values. See Rust's `?` operator for instance. edit: Why the downvotes?
The function you pass to walk is going to see every file and directory in the tree. It's up to you to put logic in that function to skip over the things you don't care about. So you don't need a wrapper function, necessarily, but you do need some kind of logic.
tl;dr: `dep ensure` is too overloaded. Right now `dep ensure` wears two hats, and you're looking to add a third by sucking in `dep prune`. I'm new to golang, but not new to dealing with package managers that use git to sync up (Take a look at [Paket](https://fsprojects.github.io/Paket/github-dependencies.html) from the F# community). Over the past 3 days, I spent several hours just trying to get `dep ensure` to succeed. Each time I ran the command, it would time out at the end of writing out the vendor folder, resulting in me re-running the command. After a while searching for why `dep ensure` was taking so long as to timeout, I finally saw that I could use `-no-vendor`/`-vendor` to do the job by parts and at least get the `.lock` file updated. If there are two distinct parts then why not just have these be separate subcommands? I would prefer to have one subcommand that just straight-up restored the things in my `.lock` file, call it `dep restore`. Want to add a new dependency specifically? Call it `dep add`. Want to update an existing dependency? `dep update`. Want to implicitly add the dependencies from your imports? Sounds like a job for `dep ensure`. Want to remove unnecessary dependencies from vendor? `dep prune`. Overloaded subcommands are a way to make it much harder for new users to learn and figure out how to use your program. For a tool that is supposed to be incorporated into the go tool kit, I believe it is important to make it easy for the user to know what command they should be running next. You can say that it's just `dep ensure`, but now the user needs to parse all the available options increasing the learning curve.
&gt; I wonder why so many people favor Python all the time Programmer productivity as in time equals money. 
Seems like this could be expanded into a tool that actually parses the signature of the current function and fills out the correct zero values for types other then `error`. In the example he gives, he is returning `nil, err` on `func main()` with no return values. 
Another way around it: badthing := Operation() if badthing != nil { return badthing } Truly, the possibilities are endless.
Rust's ? operator seems to be just syntax sugar for a similar thing though. Go explicitly eschews syntax sugar. I can understand how the != nil pattern can get tiresome but it also affords the developer the opportunity to be very particular about how they handle errors. Not every case of != nil means a total failure of a process. Often it's merely that something has raised a flag in a procedure. By allowing the programmer to handle that we create greater accountability within our code.
I have to buy the new MacBookPro just to have this awesome feature. Awesome!!!!
So, in all seriousness, having used a number of other languages where error checking is putatively easier, including all languages that have exceptions (quite a lot of them), I find what actually happens is that the ease-of-use ends up affording a usage pattern where errors become so "easy" to handle that you... don't, actually. You lean on the default handling to do its thing. When that's the right thing, great! And it often is. But when it's not, it gets a lot less great really quickly. Network servers are a core use case for Go, and in my experience they are one of those places where you actually _need_ to think about the error handling every time you have it. You're rapidly changing error handling contexts, where the errors go, the semantics of the protocol and what an error means, what needs to be cleaned up if you do error and who needs to hear about it, etc. I find in my network code that while I may initially write a lot of the "default clause", fully a third of them end up with more logic in them before the program ships. That's a real number from a survey I took of one of my major network servers, _and_ I'm actually not a huge user of the error wrapping stuff either, I mostly have situations where "socket closed" is obvious even if it is a couple of levels down the call stack, so the 1/3rd of the error cases are doing something non-trivial and useful. When I write the same sort of code now in a language like Perl or Python it now looks more like my Go, because exception handlers encourage laziness, which leads to non-robust code. By contrast, consider a command line tool. If you encounter an error while working with a command-line tool, the vast, vast majority of the time, the correct handling is "Stop whatever it is you are doing, don't get 'clever' trying to clean up, and propagate some sort of helpful error to the user". And lo, in something like Python, that's exactly what the default exception handling will do for you if you don't customize it at all. I don't think this is a coincidence. In fact when I write my command-line tools in Go I've actually adopted a policy that panics are perfectly acceptable and normal if something fails, for precisely this reason. I've even... _gasp!_... got _libraries_ for dealing with shell-type things that panic! The shock! The horror! Libraries aren't supposed to do that! So overall, my position on this question is that basically everybody is right, but it's very domain-specific, which is why the argument never ends.
Could just use a template expansion
&gt; Rust's ? operator seems to be just syntax sugar for a similar thing though. It is. But it leads to simpler and in my opinion more readable code. Take this snippet for instance: func readString(r io.Reader) (string, error) { res, err := ioutil.ReadAll(r) if err != nil { return err } return string(res), nil } That could be rewritten like so without compromising expressiveness or readability: func readString(r io.Reader) (string, error) { return string(try ioutil.ReadAll(r)), nil } &gt; I can understand how the != nil pattern can get tiresome but it also affords the developer the opportunity to be very particular about how they handle errors. Of course, but adding sugar for said pattern won't prevent you from using explicit `if err != nil` when you need it. And let's be real, the vast majority of cases use the exact same snippet.
From https://golang.org/pkg/encoding/json/ &gt; The Go visibility rules for struct fields are amended for JSON when deciding which field to marshal or unmarshal. If there are multiple fields at the same level, and that level is the least nested (and would therefore be the nesting level selected by the usual Go rules), the following extra rules apply: &gt; &gt; 1) Of those fields, if any are JSON-tagged, only tagged fields are considered, even if there are multiple untagged fields that would otherwise conflict. &gt; &gt; 2) If there is exactly one field (tagged or not according to the first rule), that is selected. &gt; &gt; 3) Otherwise there are multiple fields, and all are ignored; no error occurs.
This was perfect and, yes, I should have found that on my own. Thank you!
Except that you've sacrificed a level of accountability in favour of sugar which goes against the design principles of Go. You're example is broken anyway. Your function signature requires both a string and an error but, as written, only returns a string. EDIT to account for your edit: Your try doesn't really work within the parameters of Go because you're choosing to return nil when an error may occur. Let's say you apply this logic in a library, at this point you've broken the basic error handling protocol of the language and now anyone using your library has to account for that. How far does this have to go?
How do I get the data without the wrapper. Currently I'm using a wrapper with a closure passed to filepath.Walk so I have access to my custom type within WalkFN... 
&gt; Except that you've sacrificed a level of accountability in favour of sugar which goes against the design principles of Go. I'm not familiar with these design principles, care to link? I also fail to see how you lose accountability by introducing relatively simple sugar. &gt; You're example is broken anyway. Your function signature requires both a string and an error but, as written, only returns a string. Fixed.
I've edited my post to further expound upon your edited post. I hope it helps.
&gt; EDIT to account for your edit: Your try doesn't really work within the parameters of Go because you're choosing to return nil when an error may occur. Let's say you apply this logic in a library, at this point you've broken the basic error handling protocol of the language and now anyone using your library has to account for that. How far does this have to go? You don't understand. The try expands to the same pattern in the snippet above. If `ioutil.ReadAll` returns an error, the function returns said error early. If not, nil is returned. Granted, this approach works better in Rust since a match boils down to an expression whereas you would need some temporary assignment for this to work in Go (but you wind up doing this anyway).
You should be able to define a structure with the various options you want to pass and then define a "walker" method on that structure, that you can pass to filepath.Walk. Something like (completely untested): type WalkerConfig struct { parseFiles bool parseDirs bool parsePrefix string } func (c WalkerConfig) walker(path string, info os.FileInfo, err error) error { if c.parseFiles &amp;&amp; ! info.isDir() { // do something with the file } if c.parseDirs and info.IsDir() { // do something with the folder } if c.ParsePrefix != "" &amp;&amp; strings.HasPrefix(info.Name(), c.ParsePrefix) { // do something with the match } return nil } then when you call filepath.Walk you pass a "configured" walker: c := WalkerConfig{parseFiles: true, parsePrefix: "x"} filepath.Walk("/", c.walker) 
Multiple return values are a tremendously convenient and relatively straightforward technique for error handling, with the huge benefit that they keep the program flow fairly linear. Boilerplate sucks, but the boilerplate in Go is much less than in Java, so it's still a win. Yeah, letting errors sort themselves out is often reasonable for many programs, though in microservices where you're coordinating between multiple disparate systems, it's quite easy to encounter an error, and have to determine a course of action to take, if only logging, in order to promote robustness. Erlang's model of treating errors as outside of the ideal case switch pattern matching is pretty good too, as this lets most errors get logged automatically, while specific errors can be reacted to in more interesting ways.
As a consumer, the function signatures don't tell your that they might raise an error. It might not be obvious to you unless you carefully read the documentation. If you want to stop operation after a single method call, you end up with the same thing. As a maintainer, all methods must check error on the reference before doing anything. Compiler and other tools won't help if you forget to do it. In general, you loose most if not all help from tooling/compiler you'd get by dealing with errors in the normal way. You also make the consumers and contributors of your code/lib learn a new pattern that they must remember only when dealing with this struct you provide. I'd say this has potential to lead to a human errors.
I know this will mess with a LOT of the language (consistency and such), but why can't nil evaluate to false in case of error? So we would save a very little code just like: if err { //deal with it } 
Fair points, but this isn't a new pattern. Edit: You could also have each function still return an error, but note in the documentation the additional functionality.
This promotes generalization of errors which makes them less useful. It could be useful in certain situations but most of the time, you'd want to augment errors with extra info which would make function call sites more verbose, almost to the point of no gain.
Thank you. That's what I needed.
At work, we went with the third options. All global resources such as database connection pool are being passed to request handlers via `context.Context`. The request handler will then initialize model struct by passing in the database connection pool into `model.New(pool)`.
So, this is confusing, but it is the nomenclature we have: what you have there are _Option_ types. Option_al_ types is when you have a type system that is dynamic like Python, but you may optionally as you like and the system will enforce only what's you've written. In the spirit of helpfulness, not criticism. It's not a great naming scheme.
you are right, but this is go land where any programming language innovation of hte past 40yrs is frowned upon.
because then you have falsey and truthy and it becomes more than just a matter of knowing what the values are, but also how go treats them. I really like that the only thing go treats as true or false is true or false.
I have just started learning go as a beginner to programming, the only background knowledge I have is some C and HTML/JavaScript from school. So far I have read An Introduction to Programming in Go by Caleb Doxsey and completed A tour of Go. While I understand the basics, syntax and am able to complete the exercises, I feel there is a large gap in the next step. There is no middle ground in the exercises, either they are trivial or broad. I still have to read "The Go Programming Language by by Alan A. A. Donovan and Brian Kernighan" and "Go in Action Book by Brian Ketelsen, Erik St. Martin, and William Kennedy". So I am not sure if my forthcoming suggestions are implemented already in those books. But what I would really like is a book with more "exhaustive" examples and exercises. Example: We just learned about Arrays, Slices, and Maps. When am I supposed to use a Map vs an Array? Later or I might have the question, if I pass and slice to a function, will it have access to the rest of the Array? It may be trivial but if there are at least varying exercises and solutions at the end of the chapter which cover a decent amount of variations in implementation, I think that would really help a beginner. This goes on to interfaces/structs/methods, I find there are not sufficient examples of intermediate difficulty. I understand Programming has a culture of learn it your self, research and read code from Github/Stack to find a solution. Break/Fix/Learn is great, but it can lead to a lot of unnecessary work later on, when a fundamental or trivial iota of knowledge is left for a new programmer to learn. Thank You for your time, and good luck in you endeavors. 
goreturns kind of does that: https://github.com/sqs/goreturns And yes, it could be made to be a lot more complicated.... but I didn't want to spend that much time on what was essentially a joke :)
Thanks for the feedback! Will update. I tend to use the two interchangeably but you're right they are different. I blame java for naming theirs Optional 
See, the problem is, it's a *lot* harder to see that your rewritten version may error out. You have that try deep in the middle of the line that is the only thing that says "hey, this could fail!" Same with the ? syntax. If the code in a block of code can fail, I want it to be extremely easy to tell where it will. This is why exceptions are bad, because they're invisible. All the syntax sugar that hides control flow is not quite as bad, because at least it's not invisible, but it still hinders readability. I love that I always know how a function can exit purely by looking at where the returns are.... and which of them may return errors.
I get where you're coming from, though I believe it's mostly a matter of personal taste. To be perfectly honest, I'm not sold on the `?` operator, in fact I think the `try!` macro worked a lot better in terms of readability, but that's an entirely different issue (with its own problems). You would obviously be free to do something like the following, res := try ioutil.ReadAll(r) return string(res) or forgo the sugar altogether. But scanning for the try keyword shouldn't incur much extra mental overhead.
Why not simply use a snippet? `iferr` then press `TAB`.
It now exists for real, see https://www.reddit.com/r/golang/comments/6v63c2/a_solution_to_if_err_nil/.
I'll never get back the thirty seconds it took me to read this "experience report". 
With respect to programming is the year 2017 or 1917, or is cut and paste programming the Go way?
Because that doesn't use my fancy pants touchbar :)
Please note: I actually use an external keyboard. This is just a joke :)
It does actually *work* though :)
Because what if you want a stacktrace? For example, you want something like Err opening file in func1 (arg 1,2,3) called from func2 (arg x,y,z) ... It's easy in go( return nil, errors.New("func2 " + argA + "|" + argB + "|" + argC + "|" + err.Error())). How would you do this in Rust? 
But (as far as I understand at least, I'm no expert in Rust) that it only works if the Error types are the same, which, given that Rust is strongly typed, is often not true. For example, if a function needs to do two things, each of which can err, _but a different error_, you need to box your resulting error type ((WhateverGoodReturnType,Box&lt;std::fmt::Display&gt;) and then you can't use ? anyways (since you can't convert IoError to Box&lt;IoError&gt;).
Then you would use an explicit if statement. It's not an either-or situation. As for Rust, you would either `map` the `Result` (error values are composable) or use an explicit match/if-else block (like Go).
The async here refers to explicit async APIs that C++ and Java provide. gRPC-Go does not provide an async API. goroutines are used under the hood to achieve concurrency. Do note that these are synthetic benchmarks that do not factor in real world considerations. I would urge caution in drawing conclusions across the various language stacks based on this. 
The Go Programming Language book and The ultimate Go course as n Oreilly
Obligatory link to https://medium.com/@shazow/code-boilerplate-is-it-always-bad-934827efcfc7.
Hmm, documentation from context pretty much states not to use context for databases (application scoped). It's indented use is for request scoped data. 
Be gone, blasphemer!
Rust is Rust, Go is Go, and both do things differently for many reasons. Neither is really better than the other because in the end the CPU will do many similar things with the code compiled to do certain things. Some of us like some things when writing the code that gets compiled, and some others like other things. For stuff that compiles to native executables through linkers and assemblers (and sometimes optimizers somewhere in there), comparisons on the syntax of the uncompiled code might tend to skew things towards some preference or another, which is somewhat silly. Some of us prefer some syntax, while others prefer something different. As long as either choice of syntax provides for a somewhat similar outcome, the differences between uncompiled code are not necessarily a hill to die on. Plus, this is a golang sub, so things done with Go are the star of the sub. Discussions regarding other languages that I would entertain on this sub would relate to the end result after compilation of somewhat equivalent code, which is a universe onto itself due to compiler differences.
Exceptions are also bad because in your stack, you lose control over detecting where issues happened, and try-catch blocks not only make things bubble up to where the error did not happen (the point where you have your try-catch block), but also come with the performance overhead of setting up try-catches on stack frames, which is not the fastest mechanism on earth. I prefer panics at worst, and error detection where the error happened at best. The latter makes debugging easier since Go will tell you where the error happened, and you get a more controlled approach to things.
Try Iris golang FW. It includes MVC kind of FW.
I've been programming in python and R for about 4 years. I've done mostly data stuff, e.g. database queries, file manipulation, ETL, analysis, plotting, but also some web scraping and API design. In those languages, I rarely if ever created my own data structures or defined the schema for JSON responses. The both have very comprehensive standard libraries, but they also very much encourage leaning on external libraries. Coming to Go, I'm really impressed with all the developer tools that make programming much easier. The hardest part for me has been understanding when to use built in types vs creating custom types, wrapping my head around pointers and interfaces, and adjusting to debugging without a REPL (in that order of most difficult to least). 
It's not that the large block is more convenient, but that the default is different. Try/catch defaults to failing loudly, returning an Error defaults to silent failure. Go forces you to decide what to do with your error. That could be good, or annoying.
I think what you are asking is if you need to mix your filtering logic with your "I've got a file node" logic or if you can keep them apart ... there are a few ways to manage this, from having either the filtering logic or the file node logic in a different function and calling them; or having a configurable filter function as raff9 said; to just using a comment to separate the two pieces. Might want to read: https://xojoc.pw/justcode/golang-file-tree-traversal.html
I think this is a weird distinction. If I strace a python program it does a huge amount of work before I hit "main()" (as in pages of syscalls), some of that is before the first line of code and then there will be more for each import. If I strace a similar Go program it does a few mmap()s, a bunch of signal stuff, clone();futex;futex;futex and then it's running my code. It's hard to argue that the work on the python side isn't to "start the runtime" or that Go doesn't suffer the same problem.
I have some serious questions about your use of this computer. Is this your daily driver? How do you like the keyboard on these new macs? Do you mind not having an escape key? How do?? I too have this computer with a touchbar. I don't like it, but I would like to like it. Luckily, we have external keyboard/touchpads at work, so I don't run into any issues while on the job. But I can't use this thing at all when I go home.
Oops, it returns two values, but main() returns none.
Are you maybe looking for sth like [SQLboiler](https://github.com/volatiletech/sqlboiler) that generates the code from the database schema rather than the other way round. It provides a ["raw query" feature](https://github.com/volatiletech/sqlboiler#raw-query) for writing direct SQL, in addition to its own [query building mechanisms](https://github.com/volatiletech/sqlboiler#query-building).
There is also the path package, which only handles / paths. That solves the unix filepaths on windows case, but not the other.
Have a look at [virtualgo](https://github.com/GetStream/vg)
I'd suggest to take a look at gokit - http://gokit.io/
&gt; And let's be real, the vast majority of cases use the exact same snippet. But that's a mistake. In general, different errors will mean different failure modes, so they should be handled differently. So if your error-handling is repetitive, that is a good indication that you are not handling your errors correctly. I would say, as a rule of thumb, if you are writing `return err` you should be suspicious of whether you are doing the right thing.
Go lacks either semantic or syntactic abstraction for error handling
&gt; Go is not an object-oriented language. https://nathany.com/good/
All feedbacks are welcome :)
I've written something like this since I couldn't find any of the 'frameworks' like you said, but my application is way more simple than the scenario you're describing, eventually I decided just write my own. IMHO, because there isn't a 'protocol' between the client and server like HTTP do, I doubt that there would be anything like `chi`socket communication, as one would have to define some sort of 'protocol' so it can provide mechanisms like 'routing keys' or 'parameters' like you've mentioned. If that's the case, I would say there are some other already existing protocols that would work just fine over sockets, then why reinvent the wheel? FWIW I used https://github.com/firstrow/tcp_server as a template do work on, with some modifications to suit my need. Not a native speaker, sorry for my grammar if it's inappropriate :)
I'd be happy with gofmt just doing this instead of forcing it onto three lines: if err != nil { return err } by adding a formatting exception where the error handling was trivial - it'd make it easier to read code by compressing trivial error checks to 1 line while not being a syntax change at all. The problem is not just the typing, it's that 3 lines for a simple return makes things harder to read. In top level handlers I never do this as the error needs to be reported properly, but in library packages or helpers where someone else will handle I do tend to just return the error rather than decorating it quite often. So it'd be nice to see that pattern being a lot less obtrusive.
Okay nice point more tools more packages more programmers coding it but as a beginner to programming do you really think the the productivity level is really higher in Python vs Go? I terms on howto deal with packages and vendoring in Go a clear point to Python but writing code in Python or in Go I don't think Python has many advantages in terms of Rapid Application Development I think they're equal
I agree, but I‚Äôd like to add that defaults have a strong influence on what follows. At work, I‚Äôve seen a fair amount of Python that receives a request, makes another backend request, and returns a response based on what it gets where error handling is 100% omitted from what the programmer writes. They should consider that backends fail and decide whether to use a cache or send a 503 or what. Instead they just do nothing and end up sending a 500 because that is the default. 
I was rather wondering whether it's apple:apple comparison, so the benchmark waits on whatever promises the async handlers return for other languages vs Go sync handling.
I think it's pretty arrogant to presume that someone disagreeing with you has to be rooted in lack of understanding.
That's true of Go as well- you return `error` which is an interface type. Anything not of that type can't be returned. If Go had sanitary macros or syntactic sugar for early-return like Rust had, it would be more or less exactly the same story - return the error with the zero type for the other value. The big difference in error handling is in how Rust and Go handle returning either-this-or-that results; Rust encourages container-enums, Go uses (basically) tuples and manual checking. Go's solution is easier to implement at a language level, but is clunkier and more error/bloat prone for developers, IMO.
It's not a binary proposition, though. In Fist, I can use "?" most of the time, but revert to an explicit return whenever I need something with more nuance. There's no reason why Go shouldn't be the same. As to the philosophy of Syntactic sugar.. All compiled languages are basically just runtime+sugar when it comes down to it, so why not make a language more beautiful at no cost to clarity when the opportunity arises? :)
1. Copy paste 2. Copy paste 3. Copy paste 4. Copy paste 5. Copy paste
&gt; I can't find anything about "mixed programs" on that site, the word "mixed" doesn't appear at all? Ok, let me help you with that: 1. Go to https://blog.golang.org/toward-go2 2. Press CMD + F or CTRL + F 3. type "mixed" (without quotes) 4. Bum! you found it! The statement is somewhere below the "Constrains" headline. Here is a bigger quote from the text: Go 2 must also bring along all the existing Go 1 source code. We must not split the Go ecosystem. Mixed programs, in which packages written in Go 2 import packages written in Go 1 and vice versa, must work effortlessly during a transition period of multiple years. We'll have to figure out exactly how to do that; automated tooling like go fix will certainly play a part. To minimize disruption, each change will require careful thought, planning, and tooling, which in turn limits the number of changes we can make. Maybe we can do two or three, certainly not more than five. I'm not counting minor housekeeping changes like maybe allowing identifiers in more spoken languages or ....... 
You could probably integrate this in vim-go. Is there a particular reason you chose not to?
I mostly use an external keybaord, but when I do use the laptop keyvoard it's fine. I don't find the escape button to be hugely bad. But I also don't use escape super often. 
https://golang.org/pkg/sort/ This "article" is so fucking dumb. 
I could give that a go but I think I should create an issue on vim-go's repo prior to doing that.
Yeah, you should definitely create an issue to discus it before doing work.
I'm curious. Why are you not able for this project?
IMHO the Go playground is a more than adequate equvalent to a REPL.
&gt; see and react that fast Perceiving flicker (e.g. noticing a single black frame within bright frames at x FPS) is not at all the same as reaction times. Human reaction times to light stimuli is on the order of ~190 ms (~160 ms for auditory stimuli).
In the sense of a beginner trying to merge a C project and a Go project, having some solid tutorials with cgo would be nice.
Last week I wrote a client / server framework where the server acts as a worker pool. Each server can handle a single type of job which is either some Go code or wraps an external command via the exec/cmd. I was going to make a REST interface, but I require tens of thousands of calls per hour so I opted to make its a simple protocol over TCP. I kept it simple to just three commands PING, WORK, and GET. I think it you really need to make it more generic in the CHI sense, you would have to use some form of generic text parser with a state machine. If you really do not need it, I would suggest just sticking with a small set of commands you can hand code.
Its even a more social one because you can share the playground on the web directly
I agree there is a need for more using C with Go tutorials one of the best beginner friendly things I found on the web is this presentation: [Go &amp; cgo](http://akrennmair.github.io/golang-cgo-slides/#1) I still take tis reddit as an input source for an new Go beginner guide or book and input like this really helps TY! 
I read the article before I wrote any code. I have working code implementing the -dironly, -fileonly and - maxdepth=X flags. At one point my logic, my walk, and my parse are all separate. There was a lot of repeated code and it was evident - even to a noob - as I added functionality this was going to turn into a mess. So, I refactored which cleaned it up a bit. I came across this video https://youtu.be/5buaPyJ0XeQ by Dave Cheney and was wondering if I could pass functionality the same way to the walk function - more in a functional way. I need a way to scale the functionality of my application without turning my code into if/else hell.
This particular project requires dynamic content without Javascript. It's unfortunate, but not up to me. 
Agreed, most of the site seems to suffer from the same fatal mistake.
Yea but in tcl we could just upvar 7 times and set the error in the implementer scope and let them deal with it.
Good link, thanks, I haven't seen it before. Nevertheless I've seen many discussions about it and people seem to be divided. Even Go authors themselves don't have a strong opinion (https://golang.org/doc/faq#Is_Go_an_object-oriented_language) Personally I think that an OO language needs to support type hierarchy, even though I strongly prefer composition over inheritance. But maybe I should present a broader context to the reader. 
in the case the user proposed he make the same stuff over and over, and if you make the same thing more than 1 time you need a function, if he need to handle the errors in particular case he can avoid using it
This is a great question, I recommend reading this article on applying clean architecture in Go http://manuel.kiessling.net/2012/09/28/applying-the-clean-architecture-to-go-applications/. 
It's returning nil for the error in the success case, otherwise try would return an error.
Is there a way I can prevent posts from this site from appearing in my feed? They're entirely without merit. Every second spent looking at one of the posts is a second I could have better spent staring at the wall. 
&gt; When a friend was reading through the source code for ssh-chat, he was surprised that I implemented my own Set type. I explained that while Go doesn‚Äôt have a built-in Set, it‚Äôs just a few lines of boilerplate to make your own on top of a map. In fact, I noticed that my version of Set evolved to be fairly specific to how it was being used. In retrospect, I‚Äôm glad that I was tweaking my own implementation iteratively rather than spending time working around whichever limitations a generic library might have had. Jesus Christ what is wrong with this guy.
`csvtk pretty` (https://github.com/shenwei356/csvtk) provides same function.
Well, Smalltalk programmers could argue that Java and C++ aren't object-oriented programming languages for various reasons, such as not being based on message passing, not having runtime modification of classes, and having primitive non-object types cluttering the system. I don't find it helpful to be too picky about what gets to be called OO.
However this brings yet another organizational question. Do you have a packages broken up on technical boundaries or do you have packages broken on functional distinctions. For example do you have a "domain" and "usecases" package or do you have a "user" package with sub-packages? If you go with the latter approach what lives at the user package level? 
I wonder how he handled the crypto.
&gt; It's hard to argue that the work on the python side isn't to "start the runtime" or that Go doesn't suffer the same problem. I don't understanding what you think you are disagreeing with. I said Go needs to start a runtime. Python needs to start a runtime. However, Python's starting of the runtime also involves a lot more reading things that are only _partially_ compiled and involves more processing to finish getting into RAM, so it takes longer, the more modules you load the longer it takes.
Getting compiled and being put in the object file during linkage are two different things: It is always compiled. What the current linkers (there are several) can do: Don't know.
The linker strips out the unused functions. Note that, to my knowledge, using `reflect` removes this guarantee somewhat. You can test this by building a Go binary, disassembling it with `objdump`, and then grepping for the function you're looking for. √©dit: here's some context wrt the linker not being able to do DCE as well when `reflect` is used: https://github.com/golang/go/issues/15583#issuecomment-217995359
Why aren't unused functions considered a compile error like unused variables?
A library package can export functions that never get called by a given main application. A struct may have functions that are never explicitly called, but are potentially invoked via reflect, so its hard to even detect.
Reflect makes it harder, but that should just affect exported methods on structs, right? You can't call package level functions or unexported functions via reflect.
What's wrong in this post? 
Go generate is actually a mechanism for running arbitrary code when you invoke it. The idea that it is especially for "generics" or even especially for "code generation" is a false one. I haven't used it often but in my use it actually reads over code and generates metadata, basically going "the other way".
&gt;give that a go
Thanks!
Exported functions are the things that call non-exported functions. If I'm uncertain about what exported functions are used I'm transitively uncertain about what non-exported functions are called. 
I actually made that button specifically because of mtanski's suggestion. :) 
Thanks for sharing. That's a really cool looking toolkit! Something I had in mind for "align" from the beginning is to keep it lightweight and use it for editor integration for source code alignment as well. 
Are there any tools out there to discover such funcs in a project? Can be nice for spring cleaning.
Why not simpy return the tuple? The client code should check the error any way instead of using the nil value returner. What I'm saying is: Instead of: if err != nil { return nil, err else { return value, nil } Simply do a: return value, err 
This is a good point. It does make more things transitively "dirty" that way. It is still possible to have an unexported method that is only invoked from package level functions (or not at all), we can confidently reason will not be used by our main application. 
You are asserting that "Go is not an object-oriented language". You are not explaining why nor you mention that this is your opinion (for the reason that it doesn't support inheritance). I believe that you should either explain your assertion better in the article or just mention the official answer in the Go FAQ and call it a day.
* It provides no new information * The article is essentially repeating the official docs * Clickbait title I think the first two are fine. There's nothing wrong with explaining or giving example about how a package works. There's always beginners that will find that information useful. But the third one can be quite an offender as it creates different expectations to the potential readers. In my opinion you should change the title to something like "Examples of using X in Go" so that you lower said expectations. Extra: * Messing with scrolling I am not 100% about this but I feel that you've made some changes to the scrolling of your website and it feels sticky. Like it when I scroll down through the code it stops scrolling. The scrolling on whitespace works fine though. *Never* mess with people's scrolling. It's one of the most annoying this a site can do.
Implicit code flow due to exceptions is also bad
I think so: http://i.imgur.com/x8LzyYN.png
Thanks! How do you access the entire response body as a byte array or string? I'm looking at the code and wondering if `godet.Params["response"]`, is a *http.Response in the following? remote.CallbackEvent("Network.responseReceived", func(params godet.Params) { fmt.Println("responseReceived", params["type"], params["response"].(map[string]interface{})["url"]) })
TL;DR: I'm going a bit through the usage of `go generate`, and `go-bindata`. All the principles of packing data up into the executable are implemented in [Pendulum](https://github.com/titpetric/pendulum) if you'd just like to read the code :)
Ramnode for $15 a year
Great article, thanks for sharing! It's nice to hear the perspective of someone who has a different coding background than myself. 
Personally, I HATE all the various sugar macros in Rust. I feel it greatly increases the cognitive load. When I write rust, my error handling ends up looking a lot like Go. 
Here is a simpler implementation as proposed by /u/TheMerovius https://gist.github.com/KevBurnsJr/2080536ba62a7f111ec9d11bd950f113
Thanks for valuable comments I will improve 
https://github.com/dominikh/go-tools/tree/master/cmd/unused
&gt; Clickbait title This. The title gives the impression that the post contains some *new* useful functions. It doesn't. If it had a more honest title, like "Using the sort package", I wouldn't feel the author was wasting my time. 
Don't want to be discouraging, but this is not something that would be a good fit into vim-go. It's generic and can be used by any project. 
Usually what you'd do is if err != nil { return nil, err } // possibly other code return value, nil You don't need the else, since we return inside the if anyway. The main reason to always return a zero value with the error is a sort of belt-and-suspenders approach to coding. Yes, you should always check the error before using the value. However, sometimes people forget, or sometimes people do silly things like assigning the value to a field in a struct thusly: val.SomeField, err = someFunc() It's a lot easier to tell something is an invalid value if it's a zero value. If it's a half-populated value, it can be hard to tell that it's not a valid value. And thus you may wonder much later on in the code why this value is making your stuff blow up. But if it's a zero value, it's usually pretty obvious in logs and debugging that you somehow are dealing with an invalid value.
Gogland can show you these as you type/browse the files or you can run yhe inspection on the project.
If it can map many-to-many relations, I'm fairly sure one-to-many should also be possible. How do you do many-to-many mapping in sqlx? I'd love to know, I haven't yet found any documentation on the subject.
Which is super annoying when it shows warnings for unused exported functions. 
They aren't used in your whole GOPATH. What would be the use-case to not show them as unused? You can also disable that specific inspection if you really want to.
Yes they are complied. No they are not in you binaries.
Such a function would be truly dead code (or only used for testing). If it's not used for testing, it probably shouldn't exist, and if it is only there for package scope testing, it should be in an _test.go file. 
This is the one thing I really appreciate about Go: if something seems really tedious, repetitive or hard in Go, you are likely doing it the wrong way. 
If my project is a library, some exported functions might not be used and still be useful.
Right. I fixed this part of the article. Thanks.
Looks interesting but needs documentation.
Then you should include tests for the exported functions. Gogland won't complain for exported symbols that are used in tests.
The "patterns" you list here are all about using inheritance &amp; OOP to solve some problem. *There is no direct replacement*, because they have been stated in terms of things that only apply in the classes-and-inheritance programming paradigm. It's like asking what's the pure functional programming replacement for an assignment; completely misses the point. Talk about a real, concrete, problem -- not about how an OOP program would solve it.
The most popular ftp library for Go is https://github.com/jlaffaye/ftp It doesn't seem to implement LRECL but you can implement it yourself. Looking at the code, it's literally few lines of code to implement a simple command. See e.g. implementation of "REIN" command https://github.com/jlaffaye/ftp/blob/master/ftp.go#L557
They don't. Serious answer: depends on what you mean. If you mean angle brackets from other languages, those are not in Go. But, you can do a lot of generic stuff with interfaces and reflection.
I wrote a package named [petrel](https://github.com/firepear/petrel), which is more or less a socket-based "So you'd like to define your own RPC" toolkit. It speaks TCP, Unix domain sockets, and TLS (optionally with HMAC). I haven't changed the version number to 1.0.0 yet, because I'm still pondering some API changes, but I've been using it as-is for about a year, in an environment where 1600+ clients are talking to a single server. I'm confident that it works as advertised, and is relatively efficient and free of unsubtle bugs. I also, somewhat insanely, wrote a Javascript library which speaks the Petrel wire protocol over websockets. That's, uh, way less recommended for real-world use though :)
[Read this section.](https://golang.org/doc/effective_go.html#interfaces_and_types)
For what reason do you see integrating the `astitodo` program as different than integrating the host of other external binaries that vim-go already integrates?
I made some notes for self on SOLID for Go here http://shabinesh.github.io/golang/2017/03/23/SOLID-principals.html Could probabaly help.. ?
Shorter names? https://play.golang.org/p/KS1jgLBq1E
This is because syncmap is not meant to be general purpose concurrent map. If you don't know what you really doing - don't use it. Pick mutex and standard map instead - it will be more efficient and less space costly. 
In the traditional sense of C++ Templates or C#/Java Generics, the concept doesn't exist in Go. However, there are many cases where using interfaces can accomplish similar goals. The sort package is one example of a generic algorithm applied in this way. That said, I would not call it a *good* example. The sort package is a very confused API that can't decide if it's a functional or interface driven design. 
`Delete` is equivalent to `delete`, `Store` is equivalent to `map[key] = value`, `Load` is equivalent to `x = map[key]`, and `LoadOrStore` is equivalent to if _, ok := map[key]; !ok { map[key] = value return value, false } return map[key], true `Range` is is a little more complicated but has sufficient documentation. 
If you want the long answer https://docs.google.com/document/d/1vrAy9gMpMoS3uaVphB32uVXX4pi-HnNjkMEgyAHX4N4/mobilebasic Basically generics make complex things easier but at a cost because they are generic. Much like how the open interface has a cost of type checking. You are attempting a one size fits all answer. The go team wants a specific use case to maybe implement a feature with a not so one size fits all answer. I still need to research use cases on why people embed interfaces in interfaces... Or maybe I should stay out of that lol. Eitherway, it's kinda like finding the perfect code for the reasons just described.
&gt; Note that, to my knowledge, using reflect removes this guarantee somewhat. That's a bad news. Does that mean any program that contains `fmt.Printf` would lead to a much more bloated binary?
Have you heard of libraries before?
Ones where I can call non-exported functions? No. If a non-exported function is unreachable from any exported function (or the init() ), it's dead code. 
I'm definite Go novice but isn't it a bit fishy that you can get to an infinite loop state like he demonstrated?
Not entirely. For example, if the linker simply didn't strip _anything_ then `xxx.T` and its one method `Bar` would show up in the diassembled code. 0:0 ~/gopath/src/github.com/ericlagergren/test $ cat main.go package main import "github.com/ericlagergren/test/xxx" func main() { xxx.Foo() } 0:0 ~/gopath/src/github.com/ericlagergren/test $ cat xxx/xxx.go package xxx import "fmt" //go:noinline func Foo() { fmt.Println("hello from Foo!") } type T struct{} //go:noinline func (t T) Bar() int { return 12 } 0:0 ~/gopath/src/github.com/ericlagergren/test $ go build 0:0 ~/gopath/src/github.com/ericlagergren/test $ objdump -D test | grep 'xxx' github.com/ericlagergren/test/xxx.Foo: 108704d: 0f 86 8d 00 00 00 jbe 141 &lt;github.com/ericlagergren/test/xxx.Foo+0xA0&gt; 10870e5: e9 56 ff ff ff jmp -170 &lt;github.com/ericlagergren/test/xxx.Foo&gt; github.com/ericlagergren/test/xxx.init: 10870fd: 76 45 jbe 69 &lt;github.com/ericlagergren/test/xxx.init+0x54&gt; 1087114: 76 09 jbe 9 &lt;github.com/ericlagergren/test/xxx.init+0x2F&gt; 108711f: 75 07 jne 7 &lt;github.com/ericlagergren/test/xxx.init+0x38&gt; 1087149: eb a5 jmp -91 &lt;github.com/ericlagergren/test/xxx.init&gt; 108716b: e8 d0 fe ff ff callq -304 &lt;github.com/ericlagergren/test/xxx.Foo&gt; 10871bf: e8 2c ff ff ff callq -212 &lt;github.com/ericlagergren/test/xxx.init&gt; github.com/ericlagergren/test/xxx.initdone.: It'd make sense that they'd work with the toolchain to make sure that simply importing `reflect` doesn't keep _every_ function, since a _ton_ of packages (especially in the stdlib) import `fmt`.
lol you've been trolled. this dude is a fellow pcj
It is a known issue. There is work being done to limit the possibly of this happening. Some edge cases my still exist.
I was surprised by this. I come from a Java background. There you have m:n threading. What Go uses is cooperative scheduling. http://wiki.c2.com/?CooperativeThreading Yes. It is fishy. As pointed out in the video, magic happens (jump to another function) that makes the coroutines safe. While absolutely terrifying, I can see how it does simply the approach. Now that you know about, please remember that if you enter a tight loop, you need to be mindful of Go's singling primatives. 
sync.Map is pretty useless. They should have waited for some kind of generics solution before introducing it into the standard library. Just use regular maps and wrap in a mutex later on if needed. 
Pardon me, but your opinion is useless, not sync.Map.
mutexs do not not play nice when used with layers of concurrency, it slows it down a good bit from what I read but I could be wrong. I have a massive program that does thousands and sometimes 10k+ iterations whose results are maps. Using workers that have workers, I've managed to cut down what initially took 15 minutes down to 6.5 minutes. Now, I have to make sure that the maps get written back correctly and from what I read, writing to maps isn't concurrent safe in go. A bit more digging and I found this package although the documentation isn't exactly robust.
according to this https://github.com/golang/go/issues/17973 mutex scales poorly. I should of mentioned that I have workers that have workers due to how much information that needs to process. Per job right now on a single day, I have to process at minimum 6000 individual things, with the upper parts being probably around 15k, so I wrote a program that has uses layers of concurrency. What once took 15 minutes now takes 6.5 but now the trick is to make writing these map values back safely and maps aren't concurrent safe from what I read about go. I stumbled onto this package but it has very minimal information. we need performance and since we're tapping out resources just to process these jobs, using mutex's will not produce the results we're looking for.
You can't print a map like that, you'd need to take a lock in order to inspect all values. You could either read sync.Map's godoc and figure it out on your own, or whine on reddit and get working solution. Since you've chosen the latter, here you go (MIT): func debug(m sync.Map) { s := make(map[interface{}]interface{}) m.Range(func(k, v interface{}) bool { s[k] = v return true }) fmt.Println(s) } While we're at it, you could add support for sync.Map to pretty-printing libraries like kr/pretty and so on.
&gt; should of Did you mean should have? -------------------------------------- This is a bot account.
It's not apples to apples
So the benchmark is misleading and shouldn't be there in the first place? I tried to read C++ benchmark code [0] but I gave up, it's not possible without code navigation. At least it reminded me why I switched from C++ to Go. [0] https://github.com/grpc/grpc/blob/master/test/cpp/microbenchmarks/bm_fullstack_unary_ping_pong.cc#L91 
&gt; Go forces you to decide what to do with your error. Well, no. It really does not. f, _ := os.Open("somefile") //-&gt; I'm sure it's fine to assume this works. f.WriteString("Hello, world") //-&gt; Silently errors because file is readonly f.Close() f.Close() //-&gt; Silently errors because file is already closed buff := make([]byte, 1000) f.Read(buff) //-&gt; Silently errors because file is closed `go vet` is fine with this. `go build` is fine with this. And of course the resulting executable fails silently. You'd think a language which is purported to be designed specifically for making robust server software would be a bit more strict about handling errors. Even when the language design requires your code to acknowledge errors, the easiest and shortest code to write is code that just ignores it. The next easiest thing to write is the reflexive boilerplate of passing the error up without doing anything with it. The hardest thing to do is what people say you should do: write handling code that's unique to that particular failure mode.
Why post a link to a tweet with a link to the info you're trying to share. 
&gt; See, the problem is, it's a lot harder to see that your rewritten version may error out. I deny it. It's immediately clear at a glance that something not normal is occurring inside the string expression. Two identifiers next to each other don't occur inside Go functions except for things that are "special". Not to mention that any sane person who genuinely had trouble noticing there was a `try` in that line would be using syntax highlighting. It would then very obviously be a keyword. Also, I maintain that if you aren't looking at the code closely enough to notice that it has `try` in it, then you aren't looking at the code closely enough to understand how it works, even if try wasn't used. There is a lot more to understanding what a function does than understanding its control flow.
I think the info is split in between 3 tweets.
I've also been using Go Mono as my default font in vim and even on the terminal. I don't agree that it looks like the ugly gopher. I believe it is quite a practical font that happens to look old, just like the language. And it has lots of haters again just like the language. Once you start using it, it slowly grows on you and that's when you realize how good it is. Just like the language... :)
It goes over _one_ way, several times: store an error in a shared location. IMO, it doesn't solve anything except where you're calling the same function repeatedly. If, as I find is more typical, each function you're calling that might return an error is a _different_ function, you then get to write wrapper functions for each of those: and those wrappers will contain the `if err != nil` logic you were trying to avoid anyway. 
You typed `_`. That means you chose to explicitly ignore the error.
We know. Everyone can click and see this person's history. But I believe it doesn't really matter in a welcoming community.
Please watch [this](https://www.youtube.com/watch?v=C1EtfDnsdDs) to see, whether or not sync.Map is appropriate for your use-case. It almost certainly isn't.
Yeah. And the second one includes a funny picture, it'd be hard to reproduce it here.
Is TODO(foo) syntax part of the Go spec? It's not, it's a generic way of annotation your source code for upcoming readers. Writing a Go tool that parses the AST for this kind of comments doesn't make it Go specific in anyway, because it doesn't have a special meaning. 
My first gut reaction was: Go doesn't have generics. We use interfaces for generic algorithms and type assertion/reflection for generic data types. Then I thought: Go *does* have some generic data types (i.e., maps, slices, channels and arrays). This got me thinking...how *do* generics work in Go for the few generic types we have? Does anyone have any information on this? Would this be a place we could use to start a discussion around the implementation (as opposed to the more common discussion on syntax) of generics?
&gt; Would this be a place we could use to start a discussion around the implementation (as opposed to the more common discussion on syntax) of generics? The Go team has said it many times before. They don't need solutions. They need problems. [Relevant discussion on golang-nuts.](https://groups.google.com/d/msg/golang-nuts/ENKY8suiUbs/jvkTmi3ZCAAJ) Edit: Quote the 3rd question and make it clear that I am replying to that only.
Forgive me for asking an honest question or being curious about how Go actually works...let me try again in a way that won't trigger your needless combativeness. I have this problem were I have to use type assertions with the empty interface and/or reflection whenever I need a data structure that isn't a map, slice or channel. For example, using the package "container/heap" from the standard library requires type assertions to be added every time I remove something from my heap. It would make my code much cleaner, more readable, and less brittle (and yes, I have accidentally screwed up before and had panics due to failed type assertions) if there were some mechanism to have static type checking on custom data structures like we get with maps, slices and channels. I don't have a solution to this problem, but it might be interesting to hear about how Go solves the problem for the built in data types.
&gt; I know they may be enough for go, but don't misslead people by calling an expensive and unsafe *void generics (which are safe, zero overhead and result in code generation) He is most likely talking about interfaces and not the empty interface{}. Interfaces are the generics of Go.
Related: https://www.reddit.com/r/golang/comments/6vhdv3/expanderr_expands_the_go_call_expression_under/
&gt; Would this be a place we could use to start a discussion around the implementation (as opposed to the more common discussion on syntax) of generics? To clarify, I was replying to your 3rd question which I didn't quote and that created confusion. That's my bad. &gt; let me try again in a way that won't trigger your needless combativeness. I know it's hard to express tone with written speech so I understand your feelings.
Shiver me timbers! If this becomes part of vim-go then I'll have to say goodbye to my argument claiming that exceptions are inferior to Go's error handling because IDEs make it too easy to automatically insert a default `try catch` and call it a day. :P You scurvy scallywag!
I think it totally makes sense for this to go into vim-go, but my patience with vimscript is pretty much zero (given that I don‚Äôt actually use Vim). If anyone could contribute Vim support, and upstream it to vim-go, that‚Äôd be much appreciated!
Thought it was a pretty good talk!
Actualy, there is no way to implement custom generics in Go. There still is discusion undergoing about it, and hopefully generics will be implemented in Go 2.0.
Edited my post for clarification :)
This is not done as "generics", these are just types. E.g. `struct{a int}` and `struct{b string}` are not treated as specialisations of a generic struct, but well, just types. Same for `[]int` vs. `[]string`. The only halfway "generic" is in make, copy and append which just implement what the language spec says about it. These are pretty simple (no "generics" used here). E.g. make just allocates cap*sizeof(elementType) bytes and "zeros" them You won't find anything useful there to implement generics.
As u/shovelpost said, I'm not talking about imitating generics with interface{}. I'm talking about a proper use of interfaces for dynamic dispatch, without using type-casting. This is completely type-safe. Furthermore, it can do things that static generics can't do.
&gt; If you mean angle brackets from other languages, those are not in Go. What about square brackets from Scala? ;)
Alas it's not something under my control. The assetfs package provides 'AssetFS' and not 'FS', and the bindata package also declares AssetDir and not Dir, etc. Best I could so is omit the field names: files := assetfs.AssetFS{ assets.Asset, assets.AssetDir, assets.AssetInfo, "dist", } But Yeah, the naming scheme is not terribly great. Some of it could be replaced with another go generate line but... why
If your keys do not overlap constantly you will surely have the same lock contention as before. In your scenario I suppose you can either try to shard map so you can probably decrease lock contention if keys do not overlap this often. Or - look at the lock free map implementation, tho I never used one in my experience with Go. 
I cannot confirm your statements about fake/flattend/lying from gmgolang. I can say is that both his articles reveal sources for you to try out and benchmark yourself. You don't have to believe him, but his efforts in comparing golang and .NET particularly about Model-View-Controller should be respected, but at any time you may still disagree with his results and his methods to attain his results and summary. I don't agree with the title of his article, golang vs .net http performance. It implies we are just comparing golang standard stuff with .net standard stuff. gmgolang actually uses iris non-standard http stuff to achieve his results. It would have been better to use a title such as Iris http golang vs .net http. If he is trying to promote iris http versus golang http, gmgolang failed to win the audience over with this article. Any real-world article these days should be referring to code with tls/https in it because real-world uses those and not straight http. As a result of this, the code was uninteresing to me. Ease of use non-standard go apis that support tls/https out of the box exist such as caddy: https://github.com/mholt/caddy I didn't see any benchmarks for it, but I believe it would be easier to get up-to-speed in golang with this api than any other. Beego has MVC which might be interesting to compare iris MVC benchmarks with: https://github.com/astaxie/beego There are other ways to get tls/https in your golang code. In my past I have managed to get tls/https working well with gorilla toolkit: http://www.gorillatoolkit.org/ If I recall correctly beego uses gorillatoolkit also. So from my standpoint, I believe gmgolang could delve more deeply into comparing his MVC/http with other known MVC golang apis along with other known .NET MVC/http apis if he truly cares to be thorough about it. As it stands, I'm sticking to golang/gorillatoolkit, but I would recommend examining caddy/beego before making any decisions on building new projects that use https/tls. Look at what comes with caddy and beego. Look at what's easier for you, what's more sophisticated for your requirements then decide. Benchmark all you want, but solving the problems-at-hand quickly has merit and I believe on that point golang will rock your world.
Look at e.g. [`runtime.makeslice`](https://github.com/golang/go/blob/365594ad59873cd8f7fde5ec158067bf695185ee/src/runtime/slice.go#L39). It's what the compiler replaces `make([]T, n, m)` with. There's also [`runtime.makemap`](https://github.com/golang/go/blob/cbc4e5d9c4f2444c5d40ae6333b4e1f4c9cfbd41/src/runtime/hashmap.go#L270) and analogous functions for other ~~types~~ kinds.
The code could be better. if err != nil { w.Write([]byte(fmt.Sprintf("%s", err))) return } You're returning 200 on error, better to use http.Error: http.Error(w, err.Error(), http.StatusNotFound) Header is set erroneously to text/html in case of an error, should be set to text/plain or left unset.
I'm not saying that it can't be understood. I mean that when I'm debugging a critical issue in production at 3am, when reading thousands of lines of code, I might miss these three letters for like two hours of banging my head against the wall. l might also miss it in particularly large code reviews. This is central to Go's idea of simplicity. It's simplicity that avoids developer mistakes by not hiding logic and control flow. 
I already fixed both [pendulum](https://github.com/titpetric/pendulum/commit/4b78bd8d00804270f3d3ac799694e88dba467355) and the article, where I also credited you with the improvement/edit ;). Thank you!
currently, at Schibsted we use gokit for several projects in production, processing large amounts of data, the structure that proposes works great 
Holding your fingers to your ears and screaming "lalalalala" does not make people's problems go away. Pretending not to know what the problem is? Give me a break.
OK, that makes sense :)
As a newcomer to Go who is still trying to wrap his head around the language I enjoyed reading [Who needs generics? Use ... instead!](https://appliedgo.net/generics/). I especially like the summary at the end giving the pros and cons of various approaches.
The time spent to develop some non-trivial code is in orders of magnitude bigger than time spent to just *type* the error handling code. Saving 0.001% of the project development cycle using some tool is not worth its development.
I'm not sure if it fits your requirements, but this is what I use to unmarshal YAML: https://github.com/gulien/orbit/blob/master/context/context.go#L118 In my case, I have no idea of the structure of the YAML document, so I'm simply using an interface{}. You might also try: `map[interface{}]interface{}`
Have you benchmarked? 15k is not that much. Also it's an anti pattern to share a heavily used data structure among large numbers of goroutines. Share memory by communicating. 
This tool can be used by more people than the original author. 0.001% of al go development is definitely not insignificant. 
https://blog.golang.org/slices And Go source is written in Go which makes it relatively easy to read if you know Go. 
Just to save somebody some minutes reading the readme and browsing the page to find out what exactly gokit proposes, I think [this should provide some insight](https://gokit.io/examples/stringsvc.html). My naive take aways: 1. declare your application as an interface, 2. implement your application logic to satisfy said interface, 3. provide a request transform that will make translation from http request object into an application call, 4. provide a response transform that will make the translation from your app logic back to a http writer This leaves you with a pretty well documented application implementation, its inputs and outputs. It doesn't really suggest that you should use packages for example (you could, sure), or how to nicely name your files to be managable if they grow into a larger monolith codebase. Is that about the gist of it?
Checkout [github.com/spf13/viper](https://github.com/spf13/viper/blob/master/README.md)
I wrote an example go web app without frameworks: https://github.com/ptman/urlredir . Feedback welcome
Looks nich I forked It I will take a closer look at the weekend and give you feedback to it soon!
Thanks for the reply! Any advices for startups new to go?
&gt; syncmap is not meant to be general purpose concurrent map To be clearer on this point, read the [`sync.Map` documentation](https://tip.golang.org/pkg/sync#Map): &gt; It is optimized for use in concurrent loops with keys that are stable over time, and either few steady-state stores, or stores localized to one goroutine per key. &gt; &gt; For use cases that do not share these attributes, it will likely have comparable or worse performance and worse type safety than an ordinary map paired with a read-write mutex.
https://www.youtube.com/watch?v=Tl7mi9QmLns
See the [video posted by /u/TheMerovius](https://youtu.be/C1EtfDnsdDs?t=1m37s) that directly answers why it's in the standard library, "so that [they] can use it in the standard library" (I suppose they could have put it into an `/internal/` package).
Video linked by /u/dchapes: Title|Channel|Published|Duration|Likes|Total Views :----------:|:----------:|:----------:|:----------:|:----------:|:----------: [GopherCon 2017 - Lightning Talk: Bryan C Mills - An overview of sync.Map](https://youtu.be/C1EtfDnsdDs?t=1m37s)|Gopher Academy|2017-07-24|0:08:10|19+ (100%)|697 --- [^Info](https://np.reddit.com/r/youtubot/wiki/index) ^| [^/u/dchapes ^can ^delete](https://np.reddit.com/message/compose/?to=_youtubot_&amp;subject=delete\%20comment&amp;message=dm0iz0g\%0A\%0AReason\%3A\%20\%2A\%2Aplease+help+us+improve\%2A\%2A) ^| ^v1.1.3b
Video linked by /u/unm95: Title|Channel|Published|Duration|Likes|Total Views :----------:|:----------:|:----------:|:----------:|:----------:|:----------: [GopherCon 2016: Keith Randall - Inside the Map Implementation](https://youtube.com/watch?v=Tl7mi9QmLns)|Gopher Academy|2016-08-18|0:26:50|92+ (100%)|7,206 --- [^Info](https://np.reddit.com/r/youtubot/wiki/index) ^| [^/u/unm95 ^can ^delete](https://np.reddit.com/message/compose/?to=_youtubot_&amp;subject=delete\%20comment&amp;message=dm0iz49\%0A\%0AReason\%3A\%20\%2A\%2Aplease+help+us+improve\%2A\%2A) ^| ^v1.1.3b
There is a difference between a nil slice (s1) and a non-nil but empty slice (s2). Suggested reading: [The Go Blog: Arrays, slices (and strings): The mechanics of 'append'](https://blog.golang.org/slices#TOC_11.)
There's also this: https://dave.cheney.net/2016/08/20/solid-go-design I think there are some rough patches there - the part on Liskov substitution doesn't examine the typical example of a Square vs Rectangle. Nor do most articles on it examine LSP violations when embedding a type anonymously against an interface.
Gokit has a great set of examples in the docs, we have an anti-fraud system with uptime close to 99%, yes the other 1% was not related to Go, instead was a bad cloud configuration https://medium.com/@benbjohnson/standard-package-layout-7cdbc8391fc1 is a must to read 
I think it'd be helpful to people looking at larger projects if it was refactored to put model, controller and views into separate packages. A lot of confusion is over how to break up applications into manageable size chunks, and right now you have everything in `main`.
awesome library
To expand on dchapes the var declaration means the variable is assigned a slices zero value, which is nil and will serialize to null. The make initialized a slice with length and capacity zero, which is a struct with three fields and will serialize to a initialized but empty json array [].
[See this tweaked version](https://play.golang.org/p/hxT9cvexTx). I'd say JSON.Marshal is correct here. The _real_ difference here is in the fmt package, where the friendly default Go print for a slice is eliminating more information than you expected. The `%#v` format string means to be more programmatically-precise about what is coming out and if I _am_ using the standard `fmt` package for debugging is the string I habitually use. Though nowadays I tend to use [spew.Dump](http://godoc.org/pkg/github.com/davecgh/go-spew/spew/#Dump); if you've got your goimports set up properly it's "free" to use it. I recommend against using the "friendly" output in debugging sessions, it elides too much.
I've programmed in a number of languages where this can theoretically happen for well over a decade and it has never happened to me in a production situation or in a situation that I care about what happened. (That is to say, I've written infinite loops but they were already bad bugs on their own merits; the fact they may have blocked other routines wasn't really a factor in my decision to fix them anyhow.) It's something I recommend you be aware of, and I don't mean to downplay it as if it can _never_ happen because I'm sure someone can pop up in reply to say it happened to them, it is not something you need to be constantly worrying about in practice. I find it up there with "what if something accidentally implements an interface I didn't intend?"; theoretically possible, in practice, I've literally never encountered a problem in my ~20 years of programming in languages where that could be a factor. (Python has a similar enough situation for it to be relevant.)
it is solved, thank you!
It's helpful to the nets to be sure to post _how_ you solved it, so future searchers can find your solution and not merely be teased with the fact that it was solved but they still don't know how. :)
What a wonderful way to indefinitely park a feature request.
Actually boundless implementation of a bytes.Buffer would be better, there's a lot of features missing: WriteString, ReadFrom (used by io.Copy) etc.
"Mutex scales poorly" is a bit of a generalization. RWMutex isn't sync.Mutex in general, and that program is also a pathological case where everything is at maximum contention; I suspect that in a common case where the computation you are doing is much larger than the cost of a lock you won't see that problem. You should benchmark before assuming performance, and you should _certainly_ benchmark something like that before bending the architecture of your solution to avoid a "fact" that may not even be true for you, when something easier may have been available to you. I still don't know what you're doing so I can't be sure, but I suspect-without-proof a case of doing communication by sharing memory, instead of sharing by communication. You may want to consider restructuring your task entirely to work in a different way. It's also valid to share "pre-written" maps that are then read-only for all users without locks. You may be able to structure your code into one goroutine that reads the incoming request and breaks it into pieces, which pushes the pieces down a channel to a pool of goroutine workers, who then have a channel where they push the results (`chan struct { Key Keytype, Value Valuetype}`) to a goroutine that puts them in the final map. Or perhaps something else, who knows. Is it really necessary for everything to be in one shared data structure that every goroutine truly needs intimate read and write access at every moment to? Generally not because even you have safely locked the map itself for reading and writing the fact that the values are still nondeterministic relative to what a goroutine expects means the algorithm doesn't really need that. Usually if they are sharing, it's something like "incrementing" which can be done by having each small goroutine prepare its results and send it to a single "reducing" goroutine to be merged into the final answer. This isn't even about "Go" per se either; Go happens to do some things that make this easy, but these are _general_ principles about concurrent programming. There are no languages or runtimes where you can have tons of threads running around and mutating a shared structure without paying lots of performance penalty; the hardware itself fundamentally doesn't like that.
[Source](https://twitter.com/maria_nynfa/status/900074666425020416) She also made [replacing Ruby with Go](https://twitter.com/maria_nynfa/status/898983625546375168)
Atom does that because it needs to have access to the go tools that it downloads. My guess is that if you take those binaries from GOPATH/bin and put them somewhere in your PATH where they are not affected by your GOPATH per project model, then this will stop happening (but I'm not familiar with Atom, just an educated guess).
I would like to give a shoutout to my project golang.zone I had some "trouble" finding the right structure so this is where I'm at now could probably be done in a more smart way. https://github.com/steffen25/golang.zone First project in Go using as few third party libraries as possible trying just to stick with the std libs. The project is running live as well on so feel free to try it Feedback is welcome :) 
The old company that I've worked for used to use c# for the API and node js for the rest (sessions, serving static files etc). Also, I'm planning to run in production with a go API and probably some crystal, even though I've good experience with node, won't trade native code for a scripted language..
I had fun writing it :). Also, the time is already spent, so now we can just use the tool.
The amblyopia makes the scene feel odd, but the concept and overall quality are fantastic.
Is there a reason to use node or ruby over Go for new projects? I use to be a node programmer but about a year ago I switched to Go for everything I use to use node for and I don't know why I would go back. 
From what I can tell, VueJS/Angular/React have a toolchain for Node. That being said, you can develop some of at least VueJS in the browser directly, so I'm not exactly sure if Node is a hard requirement. You'll definitely be better off if you have node in that combination to implement webpack/unit testing workflows, and possibly SSR (server-side rendering) of those kind of apps, if you need that thing. In terms of API services, concurrency and the like, I'm never touching Node again. If there's anything that I learned, I [definitely learned that](https://leanpub.com/api-foundations).
Thanks for the tweaked version, it helped me understand it. The spew.Dump link is broken.
So there isn't a library that implements this yet? I will try to implement myself as you described.
I'm using node for services that already exist and might be considered good enough to use. Generally it's useful to use existing prior work in any language if it saves dev time and time to market. From what I've seen, people are pretty exclusive as to what kind of stack they use (for obvious reasons), but there are complementary/equivalent implementations of some stuff in both languages. For example, if you want an image processing library, you have [bimg](https://github.com/h2non/bimg) in Go, and [sharp](https://github.com/lovell/sharp) in Node, and they are pretty much equivalent. In the end it's mostly the case of whatever language is more comfortable for the devs you manage to attract. I really use Node only for some tooling where it's untyped nature becomes an advantage. Somewhat. Most of the time, Go outperforms Node by a wide margin for any kind of network service which I've implemented in both languages, so considering that Node is single threaded and you have to bolt-on process management and scaling, I've just stopped developing back-end stuff with Node. I can't say it's not worth it, it just becomes obsolete as soon as you know enough Go to write even the simplest JSON API.
You know JS and are too lazy to learn a different language? Especially if you're a bit dim and can't get your head around threads and mutexes. 
There are other languages that do something similar to this. Stackless Python (or python with greenlets, such as gevent/eventlet) use a model very similar to this to run microthreads/coroutines that are not directly tied to OS threads (with key limitations due to the underlying language restrictions of Python, of course) I'm going to answer your two questions in reverse as it will lead to the answer better: There are a lot of upsides as you may know, but the real downside of this model is that your coroutine scheduler in your language/runtime **must** be good and accurate to work alongside your operating system to ensure that coroutines that *need* to be scheduled are scheduled and run. There's often discussion of "fairness" as well, and over time/releases Go has improved on fairness of wakeup to improve the overall latency 'observed'. Furthermore, with a "bad" scheduler there are possible negative implications on some hardware, if the scheduler is not aware of the cost of moving a coroutine across hardware boundaries such as across SMP CPUs, or across cores invalidating some of the caches, some workloads could work out to theoretically more expensive than letting the OS manage the threads. The good news is, the Goroutine scheduler is pretty good (but not perfect) on major architectures/OSes, and continues to improve with every major release. ---- So why don't other languages do this? Mostly, because it's **hard**. If you think of a huge ecosystem like Java and the JVM, with decades of history, you can't make a change in a sweeping way. Go had the advantage of having these primitives from the beginning, and also having a spec which is very carefully worded with regards to what is and isn't guaranteed in a given concurrency primitive (for example https://golang.org/ref/mem#tmp_2 ). There are definitely inroads into concurrency models for some of these languages even still... for example in the JVM world, you have scala's Akka framework which re-conceptualizes how you think about concurrency, but in a way which is still friendly to typical java code... you can get big concurrency, but you have to either specify constraints (execution contexts/threadpools) or code very carefully in some of these contexts to make sure you don't accidentally block an actor.
I already expected you did. Things like this are a fun exercise. 
This is genius!
Look at the example in example/main.go. You need to call the GetResponseBody method: if *responses { remote.CallbackEvent("Network.responseReceived", func(params godet.Params) { resp := params.Map("response") url := resp["url"].(string) log.Println("responseReceived", params["type"], limit(url, 80), "\n\t\t\t", int(resp["status"].(float64)), resp["mimeType"].(string)) /* if params.String("type") == "Image" { go func() { req := params.String("requestId") res, err := remote.GetResponseBody(req) if err != nil { log.Println("Error getting responseBody", err) } else { log.Println("ResponseBody", len(res), limit(string(res), 10)) } }() } */ }) } 
I think the assumption the plugin is making is that you have a default GOPATH who's bin directory is also in your PATH. For me, this translates to this being at the end of my ~/.profile: export GOPATH="$HOME/go" export PATH="$GOPATH/bin:$PATH" that way, any binaries that get installed with `go get` endup in my path if my current gopath is this default gopath.
#GoLang &gt; #NodeJS
I constantly ask myself the opposite question. Is there a reason to use Go over X for any project? I do full stack web dev in go/ember.js for a major tech company. To me Go is an optimizing language that can take whatever you wrote in X and make it run faster/more efficient. I believe the relative speed/efficiency advantage is minuscule (I'd be curious to see node 8.3+ benchmarks vs go), but could potentially save your company a lot of money on your AWS/GCP/Azure bill if you have a high traffic product. Go also shines if you have a computationally expensive feature that your project has to do, but this is almost never the case for web dev. As a trade off, I believe go code takes longer to write and you end up writing more due to its lower level design. Package management and debugging are not first first class citizens (community implementations are not as good imo) which can turn into time sinks for many devs. To get back to the original point, I believe that very few projects benefit from go ESPECIALLY in the early stages when there is uncertainty about the future of the project and dev time is the biggest cost.
gmgolang = kataras = Gerasimos (Makis) Maropoulos. Who is the "author" of Iris. Who is also the author of this article about Iris but does not mention it anywhere. And the evidence about his lies, the flattend git histories to remove proof of him stealing source code from other Go projects was already linked here so I don't see your point. Your whole post is mostly nonsense and bullshit. The point about not comparing Go but a third party framework with .Net Core was already mentioned here, you even answered in the same discussion thread .... https://www.reddit.com/r/golang/comments/6uoybi/go_vs_net_core/dlubqk7/. &gt; and I believe on that point golang will rock your world. I'm in the fucking golang subreddit, what do you think I'm progamming in?
If you need something quick I think their are quite a few situations where Node or Ruby can be the better option. Especially if you have a team with a lot of experience, give me someone with 5 years of Ruby on Rails experience and they could probably pump out new features faster then you can say the words 'CRUD app'.
TL;DR compiler magic.
**Features** * It can be *easily* used with `go generate`, from the command line or as a library. * Uses local files, packages, and automatically uses `go get` if the remote package doesn't exist. * You can rewrite, remove and change pretty much everything. * Allows you to merge a package of multiple files into a single one. * *Safely* remove functions and struct fields. * Automatically passes all code through `x/tools/imports` (aka `goimports`). * If you intend on generating files in the same package, you may add `// +build genx` to your template(s). * Transparently handles [genny](https://github.com/cheekybits/genny)'s `generic.Type`. * Supports a few [seeds](https://github.com/OneOfOne/genx/tree/master/seeds/). * Adds build tags based on the types you pass, so you can target specifc types (ex: `// +build genx_t_string` or `// +build genx_vt_builtin` ) * Automatically handles nil returns, will return the zero value of the type. * Doesn't need modifying the source package if there's only one type involved. *edit* * Added a sort [seed](https://github.com/OneOfOne/genx/tree/master/seeds/sort) to simplify sorting support, for native type you can just `genx -seeds sort -t T=string ....` then use `SortStrings(stringSlice, true or false for reverse sort)`, for complex types, you have to provide your own `less` function. *edit* * Added atomicValue (ala `sync/atomic.Value`) with Swap/CompareAndSwap support. * Adds build tags based on the types you pass, so you can target specifc types (ex: `// +build genx_t_string` or `// +build genx_vt_builtin` ) * Automatically handles nil returns, will return the zero value of the type. * Doesn't need modifying the source package if there's only one type involved, see the [fatih/set](https://github.com/OneOfOne/genx#modifing-an-external-library-that-doesnt-specifically-support-generics) example. 
How do you version lock developer tools? Node.js answered this beautifully with per-project dependency directory: .node_modules In contrast, Go tends to pile everything in $GOROOT/bin, so for example gometalinter tip often breaks CI as it adds new linters. I suppose one could move dev tools into a stable Docker image, but this requires Docker in Docker hacks for CI. Node generally handles this stuff much more reliably and conveniently.
There is not an assumption that you have a default `GOPATH`. There is an assumption that you have the various tools available _either_ in: * `$GOPATH/bin` (using the first `$GOPATH` segment) * Any of your `$PATH` segments /u/eveilslayer could work around this issue in a few ways: * Manually [go get all the required tools](https://github.com/joefitzgerald/go-plus/blob/4270e4b5c8fbae751243cdea49d77fa60effdc99/lib/package-manager.js#L27-L37) and ensure the resulting binaries are available on the PATH * Create a tools GOPATH (e.g. `~/tools`), add its `bin` directory to the PATH, launch atom via `GOPATH=~/tools atom .`, let go-plus fetch all the tools Either of these approaches will suppress the behavior you are seeing when subsequently launching `GOPATH=~/project-1 atom .`, `GOPATH=~/project-2 atom .`, etc.
Package management has traditionally been a weak point in Go, but I think that with dep, it's basically catching up to gem/npm. It's definitely much easier to make work than the hell that is pip.
&gt; multiplexers (tmux/etc) didn't have to worry/handle each specific process Processes running inside screen / tmux get a custom terminal type called `screen`. This might be where you'll want to start with your program. &gt; I wasn't sure on was how to inform editors/etc of the desired dimensions The process reads terminal information from the envrionment at startup. You could also [emulate a terminal resize](http://invisible-island.net/ncurses/ncurses-intro.html#xterm) but there'd be some side-effects that may screw up what you're trying to do. Can't say without more research.
&gt; The spew.Dump link is broken. Fixed. I though I did a web search but I actually jumped tabs to where my local version of the docs were open already.
Just bought your book!
I only use node for the build tools for VueJS. I used to use Node for server side code but Go is just so much nicer to develop test and deploy.
This question literally gets asked weekly, and every time you see someone post a use case and then someone else respond to them saying it isn't a true use case. It usually turns into somewhat of a flame war. Everyone has different opinions of the need, but the most common use case pointed to would be data structures. Lists, Sets, Trees, Stacks, Heaps, etc.
Same with strong type system, functions, classes, oop, garbage collection and literaly everything except asm. Some like it, some dont need it.
Other languages have done it. Java's first multithreading implementation called Green Threads didn't rely on OS threads at all. The major problem with user-space threads are system calls that are blocking. Go mitigates the problem by starting new OS-Threads if a running thread is blocking and wrappers around network system calls that put a goroutine to sleep and wake before a read or write on a file descriptor. In go 1.9 this functionality is extended for file operations.
You wrote an article saying ["Of course we need generics! duh!"](http://nomad.so/2017/07/go-v2-0-and-generics-its-a-no-brainer/). Your article has been [criticized](https://www.reddit.com/r/golang/comments/6pigrc/go_v20_and_generics_its_a_nobrainer/dkpob84/) about that. I was expecting some kind of follow up article or some edits but instead you kept insisting to the "duh!" mentality. We need more explanation and exploration of the problem and less "duh!". The Go team has made it clear that this is what they need from the community. [Look what they get instead.](https://www.reddit.com/r/golang/comments/6vedlo/im_confused_how_do_generics_work_in_go/dm0mfec/) Sorry, I just can't take your opinions seriously anymore.
* The convenience of type safety and knowing the type before hand rather than at runtime using `v, ok := x.(SomeType)` for an `interface{}`. * Performance, using interfaces{} have a noticeable overhead (although it's getting pretty tiny in recent Go releases) Here's a very simple example from my own project, [cmap](https://github.com/OneOfOne/cmap): the `map[interface{}]interface{}` based version is 2.5x slower than the `map[string]interface{}` version. CMap/4096-8 86.5ns ¬± 1% # vs StringCMap/4096-8 37.9ns ¬± 5% 
Always feel free to DM me if you have any comments/feedback/questions, I love to help :)
Everyone knows the problem. What we need is an exploration of the problem and a better understanding of it. [Please read this.](https://groups.google.com/d/msg/golang-nuts/ENKY8suiUbs/W58w3NgBCQAJ) [And this.](https://groups.google.com/d/msg/golang-nuts/ENKY8suiUbs/pH_-V6QICQAJ)
Awesome, thanks.
Writing any data store (such as: Hashmap, BTree, RBTree, Skiplist, etc) is quite bothersome without generics. You end up relying on interface{} to handle your values which presents a couple problems: - Performance: Overhead of using interface{} instead of direct type - Messy code: Utilizing type assertion adds unnecessary complexity to the codebase - Unsafe: Utilizing type assertion forces our type checks to occur at runtime instead of at compilation time While I do agree that generics aren't necessary for 99% of golang libraries. If you are writing a low-level library, you will find yourself encountering a need for generics more often than not. 
this overview on the subject from the golang wiki https://docs.google.com/document/d/1vrAy9gMpMoS3uaVphB32uVXX4pi-HnNjkMEgyAHX4N4/edit?pli=1#
I like the ability to generate as a single file, this could be quite useful
I still think its better to use Node for small personal project web apps where i'm the sole developer. In projects like those, I'm constantly switching between working on the FE and BE, and it's nice to just write JS everywhere. My brain doesn't have to deal with constant context switching.
Found the Twitch.tv engineer ;)
Solid article with good examples. üëçüèº
They recently fixed that in the vscode-go plugin, it was annoying as hell, now there's an option to set a specific path for the tools.
Have you read the source code? It's literally using generics under the hood
The C solution for generics is functions that work with `void *` pointers. An empty interface in go is basically the same thing. If you're comfortable dealing with void pointers in C, you probably don't see anything missing in go.
Google: Nest but yeah, Twitch uses a very similar stack to us
Think C without macros. You can definitely live without them but sometimes they are really handy. They have some downsides (add complexity, especially if abused, and are hard to debug) and upsides (can reduce repetition and mistakes).
More explanation and more exploration? Really? No, we neither. We need the go team to pull their heads out of their asses and listen to the thousands of people asking for generics! Pretending we need more justification is bordering on pathetic.
Take a look at retool. Its essentially glide but for tooling. Not as good as i would like it to he but still does the job and saves my bacon.
Isn't this backwards? As depicted, the Gopher is the sack of sand and Node is the idol.
well I would argue that dev time decreases dramatically with go, even for small programs/apis/what have you. I find myself writing fairly large chunks of code without hitting the compiler once and striking luck at first or second try. would never have happened in e.g. python. there I'd need to continously hit the run button and reach for the docs (even with tests) I would argue that go is an excellent fit for prototyping, startups doing mvps etc. ps: it's gone as far as me even starting to use go as a scripting language. bootstrapping our kubernetes deployments? easier to write a few lines of go code than yamls. doing some one-off etl? let's see... go :) 
Only 25 keywords means you can hold the whole language in your head. I'm amazed at how much code I can write correctly on the first try sometimes.
Alright, fair enough. Just wanted to understand what your criteria for inclusion in Vim-go are.
Interesting but it didn't really talk about go at all, more about GCP.
What a great presentation. This one goes really well with the [Understanding Channels](https://www.youtube.com/attribution_link?a=bu7L1okRVrA&amp;u=%2Fwatch%3Fv%3DKBZlN0izeiY%26feature%3Dshare%26list%3DPL2ntRZ1ySWBdD9bru6IR-_WXUgJqvrtx9%26index%3D5) video
&gt;* The convenience of type safety and knowing the type before hand rather than at runtime using `v, ok := x.(SomeType)` for an `interface{}`. &gt; &gt;* Performance, using interfaces{} have a noticeable overhead (although it's getting pretty tiny in recent Go releases) &gt; &gt;Here's a very simple example from my own project, [cmap](https://github.com/OneOfOne/cmap): &gt; &gt;the `map[interface{}]interface{}` based version is 2.5x slower than the `map[string]interface{}` version. &gt; &gt; CMap/4096-8 86.5ns ¬± 1% &gt; # vs &gt; StringCMap/4096-8 37.9ns ¬± 5% That's hardly insignificant: it's almost 3x as slow.
&gt;More explanation and more exploration? Really? No, we neither. We need the go team to pull their heads out of their asses and listen to the thousands of people asking for generics! Pretending we need more justification is bordering on pathetic. I don't like your tone. Not only you are refusing to contribute to the discussion but you have also chosen a path where you are closely flirting with toxicity. Nevertheless I'll do a last attempt to show you why the experience reports are really needed: [Please read this.](https://groups.google.com/d/msg/golang-nuts/ENKY8suiUbs/W58w3NgBCQAJ) [And this.](https://groups.google.com/d/msg/golang-nuts/ENKY8suiUbs/pH_-V6QICQAJ) I hope someone with your [intellectual capacity](http://nomad.so/2015/03/why-gos-design-is-a-disservice-to-intelligent-programmers/) can appreciate the logic and reason in these comments by /u/egonelbre.
I literally released https://github.com/OneOfOne/genx today just to counter that issue.
Yeah... I was really hoping to see some comparison metrics as well.
I started doing golang and react commercially and yeah it is a bit of a pain point on the workflow, I either run webpack to do pure UI testing usually in the beginning then I evolved it to watch the directly and spit out builds to a folder when changes are made that golang is serving from. Still haven't worked out if I can get the best of both worlds easily besides simply proxying requests to a webpack server to get hotloading then doing a final test without proxying before deploying. I haven't played around with server side rendering yet simply because I don't miss node and don't really want to give up golang unless I need too and I love the idea of simply deploying a docker container with a scratch container with a static binary and the build files. 
Another downside: build times. Looking at you, C++...
I believe your package naming follows some [anti patterns](https://youtu.be/zzAdEt3xZ1M?t=6m30s). I also think that you should rename `go-get-im.go` to `main.go`. You are also missing a License, documentation and tests. See this [report](https://goreportcard.com/report/github.com/chrisgreg/go-get-im). The code looks ok-ish but I believe it could be structured better. There are also some missing error checks, like [here](https://github.com/chrisgreg/go-get-im/blob/master/utils/utils.go#L36) and [most importantly here](https://github.com/chrisgreg/go-get-im/blob/master/api/reddit.go#L38). Also I don't believe you should be using panic so [freely](https://github.com/chrisgreg/go-get-im/blob/master/api/imgur.go#L60). Better [replace your panics with errors](https://github.com/golang/go/wiki/CodeReviewComments#dont-panic). You can also simplify [this line](https://github.com/chrisgreg/go-get-im/blob/master/utils/imgur.go#L77) to `if album {` I recommend using [gometalinter](https://github.com/alecthomas/gometalinter) which will help you finding some of those problems easier.
I'm lurking this reddit for like a couple of weeks, i didn't know about the "weekly" asking, sorry :)
Sure. What I noticed right off the bat: - `IsAlbum` uses `regexp.MatchString` which calls `regexp.Compile` each invocation. It'd make sense to create an unexported global to prevent the compilation each time. - [You](https://github.com/chrisgreg/go-get-im/blob/0278cc14968844cdd9b1176c78d24851070897c2/utils/imgur.go#L29) [panic](https://github.com/chrisgreg/go-get-im/blob/0278cc14968844cdd9b1176c78d24851070897c2/utils/imgur.go#L34) [a lot](https://github.com/chrisgreg/go-get-im/blob/0278cc14968844cdd9b1176c78d24851070897c2/utils/imgur.go#L39). Don't do this. Instead, return an error. If it's an error people should be able to check (e.g., `io.EOF`), export some sort of type or function that allows the user to check for it. Otherwise, wrap it in a little bit of state (e.g., `fmt.Errorf`) and bubble it up. - You don't need to create a new `http.Client` for each invocation of `GetAlbumImageLinks`. I'll come back to this one in a minute. - Don't forget to close `Response.Body` after calling `Do`. - It's a *nix convention to not print out anything to stdout _except_ necessary output. Logging (typically) goes to stderr. - `if x == true` is logically equivalent to `if x`. - `CleanUrl` should probably be `CleanURL` since Go's naming conventions say to use all-caps for acronyms (i.e., HTTP not Http). (There are other instances of this as well.) - `ReplaceAllString` in `CleanUrl` could just use `strings.Replacer` instead of regular expressions. - `CreateFolder` doesn't return an error, but `MkdirAll`does. - In `ParseAlbumJson` you pass a pointer to a pointer to `ImgurAlbumApiResponse` to `json.Unmarshal`. This probably wasn't intentional. Also, consider using `:=` in lieu of `var x = ...`. - WRT the comment about `http.Client`, a lot of the library could be methods on some sort of struct. This means you could have `type Client struct { c *http.Client, ... }` and let users determine whether they want to use `http.DefaultClient` or not. (I'd pass that parameter in via some sort of `ClientOption` type, e.g. `type ClientOption func(c *Client)`)
No worries! I realize now that my response may have come across harsher than intended, so sorry for that. Unfortunately these discussions never seem to end amazingly well. Either people agree with the use case for generics and support it strongly, or they don't and disagree strongly. There are likely some in the middle as well but those usually aren't the ones commenting, so you end up with two sides who disagree with one another speaking "passionately" about what they think is the right decision. It can grow slightly tiresome after a while since nothing productive tends to come from it.
One of the things I miss in node is using the same validation everywhere. We were able to write our validation rules once and share them on the server and client. We could also share utility packages like lodash on the front end and back end. I love Go. I chose it over node for our startup. Go has more predictable resource usage and I can diagnose any production issue reasonably well. With that said I can knock things out much quicker with node + react. If I want to get a project done over a weekend, I'm more likely to reach for node.
I do not think the intent of that particular dashboard is for you to draw conclusions across language stacks. They are synthetic benchmarks we track. For implementations that offer multiple APIs, we pick the most performant one. That is all there is to it. 
The README doesn't say what the project is about, and the link at the top of it just responds with Hello gopher! It would help if you added more info such as what the project does and who might want to use it.
Awesome stuff - I'll look to fix it up in the next few days. Thanks for your help
Thanks for pointing those out, i'll watch that video too
tbh, I've had much more fun just writing a `make.go` file that does what I want in _Go_, rather than fiddling with the beast that is `make` ¬Ø\\\_(„ÉÑ)_/¬Ø
One more question I forgot to mention in the OP - could Goroutines effectively speed this up? Would it make sense to spawn a Goroutine for each link being parsed - or is so little work being done before handing off to IO or a network request that it'd be a negligible boost? 
Make sure you use the search functionality before asking. Chances are someone else had the question before you.
I agree that `make` is a beast. However if you read the article, I've tried to explain how Go makefiles can be really simple and effective.
Only one way to find out :-) There's no real way to know without testing it.
I especially like the Caddy example. üëç
Like /u/elagergren said, I've also had a lot of fun writing `make.go` files for my Go projects. I believe a Makefile is still a great tool especially if it's just a few commands. Nevertheless when complexity increases or when portability is desired I find it a good idea to rewrite my Makefile in robust Go code. Here's a [basic example](https://github.com/nstratos/make.go) for those that are interested.
I agree with what /u/elagergren said. In addition: There is no check that an argument (username) is passed, so you get the following user experience: panic: runtime error: index out of range not great. Checking that one argument is passed `len(os.Args) == 2` and if not, print a help message would be a good way to handle it. If you end up needing additional options, look at the flags package. utils is not a good package name https://github.com/chrisgreg/go-get-im/blob/master/utils/imgur.go#L51 Is that intended, or left over from debugging? 
I didn't ask about language X. Seems language X is ALWAYS better than language Y. I specifically mentioned Ruby and Node. And there are good reasons to use Go over JavaScript. Go is almost always faster and safer than JavaScript, and in my experience requires less "magic" without adding any more complexity. Another thing you didn't consider is maintenance. JavaScript code bases are a shit show. Almost all Go code looks like it was written by the same person and is typically easier to maintain in the long run. So let's see, with Go I get: - Fast development - Better performance - Better Safety - Easier to maintain - Generally cleaner code that's easier to reason about - Statically compiled binary - Amazing tooling With JavaScript I get: - Supposedly faster prototyping - Lot's of third party libraries (which are actually unavoidable) - Cheaper (worse) developers? Last time I used npm it was shit so package management is not a plus for JS. I'm tired of hearing about how language X is better than Go but no one ever names the language, or when they do they name some unemployable language like haskell or rust (which has a slew of other problems) or erlang. If you want a job, you only have a few languages to choose from, Go happens to be the best one for most purposes IMO. The latest versions of C++ are actually kind of good, but C++ changes so often that a code base from five years ago will require a dev with an entirely different skill set than someone who knows modern C++, same with JavaScript. Ruby is basically a toy language, it's fun for learning but why a polyglot would choose Ruby over any other popular language is beyond me. Java is hell. Java has mile long class hierarchies, massive try-catch error blocks that pollute the code, and indentation is thicker than my neck. Every Java IDE is shit and it's a language designed for idiots who need half their app generated for them. This post is going to piss a lot of people off but it's the cold hard truth. Go is the happy middle ground between C and JavaScript that people have been looking for. C doesn't have generics. Rust has every feature anyone can think of and the language is going no where. Just because a language has a lot of features doesn't make it "better". In fact, I'd argue it makes it much worse for enterprise development. Develop your app with C++? Now you have 10 different kinds of C++ programmers to wade through when you want to hire a new dev. Develop your app in Go? Any Go developer will be able to understand it. Languages like C++ and Rust cost much more and end up having more bugs in the long run than apps developed with "simpler" languages. The "standards" found in other languages don't come close to those found in Go. 
Haha, I figured you might üòÄ I can't help but plug Caddy though. Makes my life simple.
Correct. Indiana Jones had to replace the idol with the sand. 
I shared it because I ran into it by chance and found it interesting to look back and reflect on how things were just 3 years ago, compared to today.
Performance cost of type assertions for interfaces is around a nanosecond. The penalty of them only really shows when you cause allocations in places that would otherwise satisfy escape analysis. The map examples probably show 0 allocations for stringcmap because string doesn't have to allocate, while interface does.
A subtle, obvious disadvantage to makefiles over `make.go` files is that it requires make. This means additional dependencies for, i.e, docker images, and requires that windows users are using a non-standard terminal.
That's exactly the point, if you're not using a pointer they will have allocations. Also all extra `v.(sometype).XXX` gets pretty ugly, or you have to check the value.
This article left me shocked, I had no idea people did the crossword puzzle that late in the evening! I always do it in the morning when I get to work. This platform has really come along way in the past decade and I love it. Good to see an example that I use so frequently!
&gt; Authors of Go wanted to give users more flexibility by allowing them to add their logic to any structs they like. You can define methods for any type you define, not just struct types. &gt; Authors of Go wanted to give users more flexibility by allowing them to add their logic to any structs they like. Even to the ones they‚Äôre not authors of (like some external libraries). Incorrect, impossible, and a bad idea.
Go vendor works in a very similar fashion I suppose. I use this tool *gvt* for vendoring. Though it's not as advanced a package manager as NPM
Go vendor works in a very similar fashion I suppose. I use this tool *gvt* for vendoring. Though it's not as advanced a package manager as NPM
Generally not a golang programmer -- but aren't synchronization primitives, including most kinds of locks, implicit if you follow the language's patterns? I did read a fair bit back that while they're made available in the standard library, they're discouraged because of Go's concurrency model.
&gt; Each time I ran the command, it would time out at the end of writing out the vendor folder, resulting in me re-running the command. `dep ensure` currently does a lot of work that is often unnecessary, and on large projects that can take a while. but, if this is your chief objective reason (as in, not UI design preference) for arguing that `ensure` needs to be broken up, then i need to provide some more context. right now, we have to rewrite `vendor/` out of an overabundance of caution - to make sure that the invariants provided by `dep ensure` are maintained (that all of your project code+Gopkg.toml/Gopkg.lock/vendor are always "in sync" at the end of a `dep ensure` run). however, we have plans in motion to obviate the need for the unnecessary writes, via [vendor/ verification](https://github.com/golang/dep/issues/121). &gt; Overloaded subcommands the alternative command verbs you suggest have a problem - either 1) they mislead the user about what's going on, or 2) they exit in partially-complete states that, in most cases, aren't desirable. in that vein: &gt; what command they should be running next the point of the design is that there _is_ no next command. you run `dep ensure`, possibly with some combination of flags and args; now, you have a compilable build. that's what dep is "ensuring" for you. this is an intentional choice, the aim being an improvement on the workflows of other package managers that _require_ you to keep mental notes on which commands you need to get back to a "good" on-disk state. Some commenters in https://github.com/golang/dep/issues/796 made similar suggestions to yours here; i went into a lot more detail in comments there.
The Makefile format is so awful, there‚Äôs no excusing it. Please don‚Äôt let it continue to spread. Use https://github.com/go-task/task. Use pure Go. Use bash scripts! Just don‚Äôt let that awful format perpetuate. 
I didn't miss the point, I just feel it's the last reason to avoid interfaces because there are plenty of others that I find more costly.
without setting off the trap
Honestly, I feel like a gopher would have the mass and general feel that a bag of sand would. Like, heavy and a little squishy, but not too squishy.
Here is what I use. Nothing too fancy. It does the job - COMMIT=`git rev-parse HEAD` BUILD_TIME=`date -u +%FT%T` BRANCH=`git rev-parse --abbrev-ref HEAD` BINARY='webapp' all: lint test build get-dep: go get -u github.com/golang/lint/golint go get -u github.com/haya14busa/goverage go get -u github.com/gorilla/mux go get github.com/pkg/errors go get github.com/pebbe/zmq4 go get github.com/urfave/negroni go get github.com/unrolled/secure go get github.com/lib/pq lint: gofmt -l -s -w . &amp;&amp; go tool vet -all . &amp;&amp; golint build: go build -ldflags "-X main.commitHash=${COMMIT} -X main.branch=${BRANCH} -X main.buildTime=${BUILD_TIME}" ./cmd/${BINARY} run: ./${BINARY} test: goverage -race -v -coverprofile=coverage.txt -covermode=atomic ./... YMMV. 
I would also recommend the tool govendor, works great!
Cool, maybe I'll look at it later. I'm getting drunk right now though, chatting with boys and gals on facebook, and am about to watch The Departed.
&gt; I believe the relative speed/efficiency advantage is minuscule (I'd be curious to see node 8.3+ benchmarks vs go), but could potentially save your company a lot of money on your AWS/GCP/Azure bill if you have a high traffic product. Go also shines if you have a computationally expensive feature that your project has to do, but this is almost never the case for web dev. I work in Node and Go at work (Like 80/20 Node to Go) in a very high traffic environment and Go just kills Node when it comes to performance. As our company has grown we've shifted a lot of our micro services from Node to Go and seen between a 3x to 15x boost in performance, depending on what the service does. The fact that Node isn't multi-threaded really limits it when you start writing high through put services. Node's main strengths in my mind are npm's ease of use and the fact that it's easy easy for people who are used to front-end work to get up to speed on back-end services very quick. It's a powerful language and it has it's place, but from what I've seen in production, it just can't compete with Go in performance.
&gt; As a trade off, I believe go code takes longer to write and you end up writing more due to its lower level design. Maybe someone who used Go and something else for the same project (after a rewrite) is willing to share his numbers.
&gt; i think that they are limited to such few cases that i can call "lazy programmers". That's the gist of it, but saving time and energy is a virtuous pursuit.
Wouldn't the usual thing to do for Node services to split up a server into single-core VMs or at least start as many processes as cores and put a load balancer in front of them?
You're covered: https://github.com/stapelberg/expanderr/issues/1 I wrote here already. I think this tool is excellent (because I wanted to write it myself). However I want to be also create standalone `if err != nil { return err }` statements as well and not a a short variable declaration. I hope we can introduce an option for that as well. Anyway hope it's something that we can integrate into vim-go :)
+1 for go-task, been using it lots lately, really nice and clean
I wrote a template for Go binary projects. It builds Docker images and should only rebuild when needed. https://github.com/thockin/go-build-template That said, Go's own dep tracking is imperfect, and if you want to do just-in-time code-generation, welcome to hell: https://github.com/kubernetes/kubernetes/blob/master/build/root/Makefile.generated_files
PIP is hell? That's news to me. It's quite simple. It's CocoaPods that I don't like. So finicky.
&gt; An empty interface in go is basically the same thing. This statement was never true and never will be true. `interface{}` is type-safe (even though not statically type-checked), whereas `void*` is not. Yes, the difference is important.
You are totally right I will update the readme later. Thanks :)
:)
Yeah, I don't see large problems with pip, could be better but it works very well. The fact that npm allows multiple versions of a package in node_modules firmly puts it in the worst package manage practices bunch. 
[Twitter is over here.](https://twitter.com/)
Go can skip the VMing portion of that and act as its own load balancer. Node is getting fairly fast, but is not likely to beat anything with proper multi threading support.
&gt; I find myself writing fairly large chunks of code without hitting the compiler once and striking luck at first or second try. would never have happened in e.g. python It can happen with any language if you‚Äôre familiar enough with it tbh. I do that with Python, for instance.
I agree that people want different container types, but Doubly Linked List is a bad example because Go's slice will outperform it in almost any scenario. Deques however are useful and would be nice to have. 
Simple as Sunday: explain the difference between setup.py, setup.cfg, requirements.txt, venv, and virtualenv. :-p I love Python, but the setuptools ecosystem is the worst package manager I have to interact with. 
Coming from Ruby, I really miss a good in-depth introduction to writing tests. It's usually only mentioned as a side-note, if at all.
1. True. 2. Also true. My bad. I oversimplified this. The thing that was on my mind was actually something like redeclaring an external type as a local type and adding sort.Interface methods to it. Somehow I though that you can simply do this on an external type. Gonna change this part. BTW do you know the actual reasons why methods are defined outside type declarations?
Node is supported in more cloud services than Go (e.g. AWS Lambda).
Yes I did. Not it is not. Making a slice is not much more than p := mallocgc(et.size*uintptr(cap), et, true) return slice{p, len, cap} No generics.
Node has supported clustered listening on single ports, ie: running an application in clustered mode on 8-core machines is trivial. No need to spin up N number of single core VMs and round-robin reverse proxy in front, I have seen excellent performance numbers from cluster Node. But then again it pales in comparison to Go.
Look up a linked hash map. It is a combination of a linked list and a hash map used to implement a fast LRU (least recently used cache). This is just one case where linked lists outperform slices, because deletes can happen in constant time vs O(N)
Very practical. Good point about embedding values during build. I also like this small enhancement to make https://github.com/tj/mmake
First slice shouldn't be var s1 = []int {} ?
Where would you put methods in `type foo int`?
In most companies people cost more than servers, so working quickly is more important than running fast software on the servers.
The "25 keywords" thing is technically true but misleading at best. It's a kind of a lawyer's trick - see [my comment here](https://www.reddit.com/r/golang/comments/6p5g1k/dotgo_2015_rob_pike_simplicity_is_complicated/dknu7de/). Regarding the simplicity claim, see my comment a bit higher in the same thread. TL;DR it's only partially true at best. 
I'm not sure that I understand his point about thread swapping being expensive. He says: * With threads, the OS does not know which registers are in use, so it has to save many registers. * With goroutines, the compiler knows that only three registers are in use so only has to save those. Ok, but presumably at other points in the program Go uses many registers (for performance). This implies then that the compiler has to generate code to speculatively save these registers every time it approaches a point where another goroutine could be scheduled. If anything, this sounds worse - with threads, at least the OS is only saving the registers if it actually does schedule another thread.
I love Makefiles this one I used a while back although I wouldn't use glide anymore and make the install rule differently https://github.com/gempir/relaybroker/blob/master/Makefile
Both pip and easy install aren't terribly robust, iirc. I've seen so many CI failures due to them poking a repo and failing to get an answer in time on the first attempt. Things have gotten a lot better with the advent of wheels, so that at least in concept you don't need to deal with compiling all the C modules.
That assumes equal quality code being produced, and the same cost of maintenance. Go is aimed at reducing the cost of maintenance. Given maintenance anecdotally accounts for 4x the initial cost of writing it, your numbers could be significantly affected by that.
I don't have that much experience with Ruby but it's an easy language to maintain I guess?
I completely agree. However as someone who used Python before pip and such existed....it's far better than it used be that's for sure especially with regards to C-extensions.
Try to work with multiple OSes with libraries that requires DLLs or .so. Here is where pip fails. A lot.
I never thought of it this way, but it is so true. Usually the first "naive" implementation ends up being the one that runs in production for 6 months until there is a reason to refactor it. The time we have saved by ditching the non-essentials can not be overstated.
I agree with both of you. I only found that if you're using too much void* (or similar constructs), you're dealing with a bad design issue.
#GoLang &gt; #NodeJS
No need to speculate. Registers are used in a lot of places in the generated code, but it uses just a small number of them and only those needs to be saved\restored during goroutine switches.
Thanks!
Thanks!
As others noted, you generally dont need to care about this because the chances of encountering this in real world programs is almost non-existant
Yea, everything we do is already behind a load balancer and it's not like the node services were breaking, it's just at peak traffic we were running far more instances of a node version of a service than the equivalent Go version. We made Node work for a long time, it was just costing us more. 
Has anybody had successful experience deploying docker containers on appengine ? Last time i tried, i had such a bad experience in terms of deployment speed ( time to build the image, then upload it, then waiting for the stuff to deploy) that i reverted to managing my own gce instance. But maybe i had bad luck..
I see, it makes sense putting it this way.
I've gone down this rabbit hole before as well as the approach you're describing is much easier in dynamic languages, where I started developing. However, with static typed languages, you'll have less headaches being explicit for each unique use case. Sending every request through a single function that processes a SQL statement looks like premature optimization and you'll run into these issues where one size does not fit all. In my web apps, I typically have the following functions: FindUserHandler() &lt;- service layer, called by the router, transform form data into Go data types FindUserLogic(id int) &lt;- business layer, models/schema/logic, sometimes not much here other than calling the data layer FindUserData(id int) &lt;- data layer, queries the DB It does mean re-creating this structure for each method on a model, but in my experience you're more likely to want to add something to a specific method than add something to every method. As a bonus, I typically have Postgres return a JSON response, so if there's no error, I can just serve the JSON back up the chain as my API response.
In those cases, which is your backend? I ask because I feel like Laravel or Flask would be much easier for me.
Technically, the syntax could support: ``` type foo int { func bar() {} } ```
For me, Go is less productive because people around here are anti-ORM in principle... so I never fully embraced ORMs in Go as well... and I keep loving and hating it.
I don't send every request through a single function. Update requests have one universal function, Get requests another, Create and Delete - another one. It has nothing to do with optimization - i'm just trying not to repeat myself. And it worked perfectly well until recently as i onlt generalize things that i have already repeated about 5 times and i think it's a very natural approach. P.S. If using Go implies violating DRY principle heavily, then i quit.
Wow, this looks awesome. I've been using AutoHotkey for automation, but this looks much cleaner from the examples. 
The first version of Javascript was also extremely simple.
Also, a lot of JS "keywords" can be used as identifier names as well, at least in non-strict mode. For example, the following code is valid var let = 4 
I use ORMs in other languages because I don't know much SQL, but to be honest if I could I'd rather just make SQL queries for everything.
I once rewrote the same project in both Go and Rust as an experiment. They took about the same amount of time, but the Rust version was twice as fast, and required less code. It also had half as many bugs make it past the compiler.
I find SQL very elegant but also tedious, in Go at least (In Clojure it maps much better IIRC). I want to do FindUser(25).Delete() instead of SQL and error checking.
http://go-proverbs.github.io/ might help. Go is not anti-DRY, but with static typing, a little copying is sometimes better than trying to combine features that aren't easily combined. In other words, if your function is general enough that you need to use reflect to discover what type of data you're working with, it's probably not idiomatic Go.
Applied to structs, that'd look like `type foo struct { stuff } { func bar() {} }`. The way you're trying to force it to work is making it worse! Also, the way it is now, you can define a method differently when built with different build tags / platforms / etc, by using more source files.
&gt; How else do you propose to handle a situation, where you encounter an error but can't return a `Result` ? 
&gt; Rust Can i ask what kind of project ? Can you share the code ? 
Did... did you just link to one of your own comments? That is some aalewis level euphoria.
One of the advantages of putting your CI processes into a Docker container is idempotency. Without Docker, Jenkins allows you to pollute your CI environment with artifacts from previous builds / runs. It's not guaranteed, but it's quite easy to fall into a trap there. Very important to stress this in any CI build: ensure you start with a clean slate! &gt; This is why I have installed Go and git on the Jenkins box. The only thing you need to check is... ...you forgot to check the version of Go, and the various libraries installed alongside! Important that versioning is enforced in a CI system, even better that a version manifest is one of the artifacts of a CI run. Otherwise, you don't have a record of exactly what got tested and how. Lots of good stuff in here, otherwise! I'm about to build CI &amp; CD system using Concourse. This might inspire me to write up my work in a blog post.
Don't forget SCons. Generally, if a package requires building from source and it's in Python, I look for an alternative.
I realise that. I faced such issues before and always managed to refactor things so that it was normal Go code (no reflection and interface{}) and not repetitive. In this case i just can't figure it out.
Sure https://medium.com/@robertgrosse/my-experience-rewriting-enjarify-in-rust-723089b406ad https://medium.com/@robertgrosse/parallelizing-enjarify-in-go-and-rust-21055d64af7e https://github.com/google/enjarify/tree/1ac4c5728eede44fa161c514aa946aa277490b99 
I'd rather use Makefiles than YAML.
"In this moment, I am euphoric. Not because of any phony commander's blessing. But because I am elightened by my ability to understand complexities of programming languages" ‚ÄïspaghettiCodeArtisan
Could you post a picture of them? How much do you want for each?
Do you have an example make.go file you can share?
Oh. I misread it. Why can't u return a result? 
I don't have any that I can publicly share, but here's camlistore's: https://github.com/camlistore/camlistore/blob/be17ff99a1bb549c746c91a065a3c6376986b357/make.go