&gt; how about moving res.Body.Close() upper If you do that, the program will panic because `res.Body` is nil before `http.Get()` runs. 2019/03/25 01:16:40 http: panic serving [::1]:61143: runtime error: invalid memory address or nil pointer dereference goroutine 18 [running]: net/http.(*conn).serve.func1(0xc0000f2000) /usr/local/opt/go/libexec/src/net/http/server.go:1769 +0x139 panic(0x129e7a0, 0x152c510) /usr/local/opt/go/libexec/src/runtime/panic.go:522 +0x1b5 main.index(0x1354b40, 0xc000106000, 0xc000100000) /Users/google/Downloads/main.go:23 +0x26 net/http.HandlerFunc.ServeHTTP(0x1305dc8, 0x1354b40, 0xc000106000, 0xc000100000) /usr/local/opt/go/libexec/src/net/http/server.go:1995 +0x44 net/http.(*ServeMux).ServeHTTP(0x1537ce0, 0x1354b40, 0xc000106000, 0xc000100000) /usr/local/opt/go/libexec/src/net/http/server.go:2375 +0x1d6 net/http.serverHandler.ServeHTTP(0xc00008ed00, 0x1354b40, 0xc000106000, 0xc000100000) /usr/local/opt/go/libexec/src/net/http/server.go:2774 +0xa8 net/http.(*conn).serve(0xc0000f2000, 0x13550c0, 0xc0000603c0) /usr/local/opt/go/libexec/src/net/http/server.go:1878 +0x851 created by net/http.(*Server).Serve /usr/local/opt/go/libexec/src/net/http/server.go:2884 +0x2f4
&gt; how about moving res.Body.Close() upper If you do that, the program will panic. `res.Body` is `nil` before `http.Get()` runs.
I see, Thanks for the info , I was hoping to use gobot official package but it seems the documentation and support is not the best to say the least 
You pass a pointer of a slice of the underlying buffer to the filter-function, this is not thread-safe (its possible that the slice contains parts of multiple messages or you will just miss messages). I think you have to copy the contents to a new buffer for every message and pass that to your filter-method.
Thanks, this makes sense to me. Does that mean I should never define a type for a primitive? Go itself has runes as "custom type", for example.
I'd use [http.Error](https://golang.org/pkg/net/http/#Error) instead of writing the status code and error separately. I'd also use [io.Copy](https://golang.org/pkg/io/#Copy) to pipe the content from the body to the responsewriter, rather than reading the whole thing into memory and then out again. So: mux.HandleFunc("/", func(writer http.ResponseWriter, request *http.Request) { resp, err := http.Get("http://www.mocky.io/v2/5c9879d42f00006e009f3037") if err != nil { http.Error(writer, err.Error(),http.StatusInternalServerError) return } if resp.StatusCode != 200 { http.Error(writer,"bad thing happened",http.StatusBadGateway) return } n, err := io.Copy(writer, resp.Body) if err != nil { http.Error(writer, err.Error(), http.StatusInternalServerError) return } if n == 0 { //only if there must be some content as a business rule http.Error(writer, "content not found",http.StatusNotFound) } })
Nice project. Well done
Creating aliases of primitive types is usually done when you are looking for some sort of extended functionality that the type itself does not support. So an example could be a string and you want to add a reverse functionality to the type - [https://play.golang.org/p/lQ7QwnHhPGB](https://play.golang.org/p/lQ7QwnHhPGB) .
If you want to add a method you must define a named type. If the values are not arbitrary strings (or ints, or ...) than it might be helpful to introduce a named type. If you have lots of typed strings and users must not mix them up in the API a new type can be helpful.
Structured data (JSON marshalling/unmarshalling) and making function coupling easier.
It does not build with GO111MODULE=on: &amp;#x200B; `./compile.sh` `Linux AMD64` `go: cannot determine module path for source directory /Users/mafa/Downloads/tmp/historian (outside GOPATH, no import comments)` `Linux i386` `go: cannot determine module path for source directory /Users/mafa/Downloads/tmp/historian (outside GOPATH, no import comments)` `Linux ARM5` `go: cannot determine module path for source directory /Users/mafa/Downloads/tmp/historian (outside GOPATH, no import comments)` `Linux ARM6` `go: cannot determine module path for source directory /Users/mafa/Downloads/tmp/historian (outside GOPATH, no import comments)` `Linux ARM7` `go: cannot determine module path for source directory /Users/mafa/Downloads/tmp/historian (outside GOPATH, no import comments)` `Darwin i386` `go: cannot determine module path for source directory /Users/mafa/Downloads/tmp/historian (outside GOPATH, no import comments)` `Darwin AMD 64` `go: cannot determine module path for source directory /Users/mafa/Downloads/tmp/historian (outside GOPATH, no import comments)`
Inside GOPATH with GO111MODULE=on:  `./compile.sh` `Linux AMD64` `go: creating new go.mod: module gitlab.com/n0r1sk/historian` `go: copying requirements from Gopkg.lock` `go: finding github.com/alecthomas/units v0.0.0-20151022065526-2efee857e7cf` `go: finding github.com/mattn/go-sqlite3 v1.10.0` `go: finding github.com/alecthomas/template v0.0.0-20160405071501-a0175ee3bccc` `go: finding gitlab.com/buddyspencer/chameleon v0.0.0-20190206095128-8375f25f3f4a` `go: finding gopkg.in/alecthomas/kingpin.v2 v2.2.6` `go: finding gopkg.in/yaml.v2 v2.2.2` `go: finding gopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405` `go: downloading gopkg.in/yaml.v2 v2.2.2` `go: downloading gitlab.com/buddyspencer/chameleon v0.0.0-20190206095128-8375f25f3f4a` `go: downloading gopkg.in/alecthomas/kingpin.v2 v2.2.6` `go: downloading github.com/mattn/go-sqlite3 v1.10.0` `go: extracting gopkg.in/alecthomas/kingpin.v2 v2.2.6` `go: extracting gopkg.in/yaml.v2 v2.2.2` `go: downloading github.com/alecthomas/template v0.0.0-20160405071501-a0175ee3bccc` `go: downloading github.com/alecthomas/units v0.0.0-20151022065526-2efee857e7cf` `go: extracting github.com/alecthomas/units v0.0.0-20151022065526-2efee857e7cf` `go: extracting github.com/alecthomas/template v0.0.0-20160405071501-a0175ee3bccc` `go: extracting gitlab.com/buddyspencer/chameleon v0.0.0-20190206095128-8375f25f3f4a` `go: extracting github.com/mattn/go-sqlite3 v1.10.0` `# os/user` `/usr/local/Cellar/go/1.12.1/libexec/src/os/user/getgrouplist_unix.go:16:35: warning: passing 'gid_t *' (aka 'unsigned int *') to parameter of type 'int *' converts between pointers to integer types with different sign [-Wpointer-sign]` `/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.14.sdk/usr/include/unistd.h:653:43: note: passing argument to parameter here` `# github.com/mattn/go-sqlite3` `sqlite3-binding.c:32520:42: error: use of undeclared identifier 'pread64'` `sqlite3-binding.c:32538:42: error: use of undeclared identifier 'pwrite64'` `sqlite3-binding.c:32670:22: error: invalid application of 'sizeof' to an incomplete type 'struct unix_syscall []'` `sqlite3-binding.c:32679:22: error: invalid application of 'sizeof' to an incomplete type 'struct unix_syscall []'` `sqlite3-binding.c:32706:20: error: invalid application of 'sizeof' to an incomplete type 'struct unix_syscall []'` `sqlite3-binding.c:32723:16: error: invalid application of 'sizeof' to an incomplete type 'struct unix_syscall []'` `sqlite3-binding.c:13942:38: note: expanded from macro 'ArraySize'` `sqlite3-binding.c:32727:14: error: invalid application of 'sizeof' to an incomplete type 'struct unix_syscall []'` `sqlite3-binding.c:13942:38: note: expanded from macro 'ArraySize'` `sqlite3-binding.c:35377:11: warning: type specifier missing, defaults to 'int' [-Wimplicit-int]` `sqlite3-binding.c:32524:49: note: expanded from macro 'osPread64'` `sqlite3-binding.c:35489:17: warning: type specifier missing, defaults to 'int' [-Wimplicit-int]` `sqlite3-binding.c:32542:57: note: expanded from macro 'osPwrite64'` `Linux i386` `Linux ARM5` `Linux ARM6` `Linux ARM7` `Darwin i386` `Darwin AMD 64`
Thanks. Much nicer. `fail` needs checking `fmt.Fprintf` for potential errors though to be identical to my code: func fail(w http.ResponseWriter, r *http.Request, err error) { w.WriteHeader(http.StatusInternalServerError) if _, err2 := fmt.Fprintf(w, "%s\n", err.Error()); err2 != nil { logger.Println("Failed to write response", err2) } } Now that leads to two `error` variables in scope. What's the preferred naming convention here? Using `err`, `err2`, etc. doesn't or reusing the name doesn't look that nice. Also GoLand gives a warning on `defer res.Body.Close()`: _Unhandled error_. Is that safe to ignore? To make it go away I ended up with: func fail(w http.ResponseWriter, r *http.Request, err error) { w.WriteHeader(http.StatusInternalServerError) if _, err2 := fmt.Fprintf(w, "%s\n", err.Error()); err2 != nil { logger.Println("Failed to write response", err2) } } func index(w http.ResponseWriter, r *http.Request) { var err error var res *http.Response if res, err = http.Get("http://www.mocky.io/v2/5c9879d42f00006e009f3037"); err != nil { fail(w, r, err) return } defer closeBody(res) if res.StatusCode != 200 { w.WriteHeader(http.StatusBadGateway) } if _, err = io.Copy(w, res.Body); err != nil { fail(w, r, err) return } } func closeBody(response *http.Response) { if response != nil { if err := response.Body.Close(); err != nil { logger.Println("Failed to close body", err) } } }
Thanks! I would also use the `if ...; err != nil {}` construct like /u/unix15e8 to make it a bit extra nicer: http.HandleFunc("/", func (writer http.ResponseWriter, request *http.Request) { var resp *http.Response var err error var n int64 if resp, err = http.Get("http://www.mocky.io/v2/5c9879d42f00006e009f3037"); err != nil { http.Error(writer, err.Error(), http.StatusInternalServerError) return } if resp.StatusCode != 200 { http.Error(writer, "bad thing happened", http.StatusBadGateway) return } if n, err = io.Copy(writer, resp.Body); err!= nil { http.Error(writer, err.Error(), http.StatusInternalServerError) return } if n == 0 { //only if there must be some content as a business rule http.Error(writer, "content not found", http.StatusNotFound) } })
from what I read I need to set CC aswell while compiling it. But I have to find a crosscompiler on linux first
Reddit doesn't properly support three backticks for code blocks (the new UI's text area does, but the old one doesn't). Formatted, your code looks like this: import ( "errors" "fmt" "io/ioutil" "log" "net/http" ) type httpError struct { wrappedError error statusCode int } func (h *httpError) Error() string { return fmt.Sprintf("error %s: %s", h.statusCode, h.wrappedError) } var ( non200Error = errors.New("response status code not 200") ) func fetchData() ([]byte, *httpError) { resp, err := http.Get("http://www.mocky.io/v2/5c9879d42f00006e009f3037") if err != nil { return nil, &amp;httpError{err, http.StatusInternalServerError} } defer resp.Body.Close() body, err := ioutil.ReadAll(resp.Body) if err != nil { return nil, &amp;httpError{err, http.StatusInternalServerError} } if resp.StatusCode != http.StatusOK { return nil, &amp;httpError{non200Error, http.StatusBadGateway} } return body, nil } func foo() { http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) { data, err := fetchData() if err != nil { http.Error(w, err.Error(), err.statusCode) return } if _, err := fmt.Fprint(w, data); err != nil { log.Println("Could not write response body", err.Error()) return } }) } This is nicer than my original code, but body of `fetchData()` still looks a bit too verbose and "Go'ish ". Also GoLand warn about `defer resp.Body.Close()`. I assume that's safe to ignore.
Good question . :) The same test but using just a Rest service run with SoapUI with 500 threads and 50000 requests gave me an avg of 560ms. I have been expecting to reduce that time using gRPC but results where similar. The same experiment but with a Java application showed a 30% lower time using gRPC (even when both times were higher than the apps made with Go).
Yep, I have been using pprof but could not see something interesting.. (I am far to be an expert on it, must confess).
I have been mostly doing devops and api using golang and elixir. started this to learn best practices, server side rendering, without using a framework. I will be adding following in coming weeks. instrumentation (prometheus) custom middleware (multi site ecommerce). anyone want to tag along ? your suggestions, code reviews welcome. 
Looks pretty cool for analysis. Would be nice if it supported text formatting and perhaps a flag to specify the format (regex perhaps). But I can understand why you wouldn’t go right for that. Structured logging is much better for tools and parsing, but haven’t been able to convert everything over yet. 
OT: you could just switch to ZSH.
there's some really great suggestions here - but in addition I'd recommend looking at logrus for some more structured logging
You define a type for a primitive when you are implementing an interface and a primitive is all the data you need for that.
To clarify, you basically have a function that looks something like: func GetFare(countryCode string, weightInGrams float64) (priceInCents int64, error) (save currencies as ints to avoid rounding weirdness, possibly some sort of bigint solution). This would work: https://play.golang.org/p/D1p3L8jyW8- (with better names). I personally wouldn't save those values to a DB when they'll be more readable in code. 
You'd also need some default behaviours set (what if a package is out of weight range? I'd also split this across different files zone_X_prices.go for each zone.
I think it is possible to support other formats as well (nginx logs, etc) and regexp pattern decoder. I'll implement it later, or PR from somebody will be nice too.
Wow, a map for all those, this is a really good idea! I might not need DB after all, it can be set in maps... Thanks for the advice, I'll try to plan it like this, see if I can work it out. Appreciate it!
Blurb (from Dave): I’m a fan of developing tests while you write your code. It felt right that I should make my tests the first consumer of my code (and I’ve found supporting evidence that this idea goes back to the early 60’s), but in practice, that is to say, the practice of TDD, this always seemed to slow me down and create brittle test suites. This is a talk about how relearning my approach to unit testing helped me understand how to practice TDD more effectively in my development workflow, but more importantly, how to design my packages as a unit, focused on their behaviour, not their implementation.
It was a violation of the httprouter license which requires that the copyright notice including the name of the author be replicated
Logstash uses grok patterns, so reusing those would be cool. I'd love to see support for https://github.com/sirupsen/logrus
Just a warning, there's a big bug in that code, you'd need a different data structure than a map for the prices to weight map because maps aren't guaranteed to return the keys and value in order. 
Don't know about the rest of the world, but plenty of "potential employers" who would hire people that bring them stolen code because they themselves have questionable ethics.
Something like this: https://play.golang.org/p/qBXy31Ji5TF
Damn, I just realised, I cannot avoid storing it in a persistent way, i.e. DB. Those fare tables change on a monthly basis, and my sister will update them on an admin page created by me. So I can't store it in code.
I'd say active cleaning, but you'll need to evaluate what the impact is during cleaning (for how long is processing halted) both when lots of transactions occur and when lots of keys are present in the system.
Ah, yeah, if it were yearly, in code would be doable, monthly is less fun. You could store it in a json (or some other thing) blob on a db and then update the blob when your sister saves. (or better create a new one so returning state to a previous state is easy). Then on startup (or whenever she saves) you do a single read of the json into a data structure like above and use that, avoiding a bunch of db code to read on every request. But using the DB properly might be better. With a table with a schema like: zone, weight_start, weight_end, price, is_latest, created_at And then your query will look like select price from table where zone=3 and is_latest=1 and weight_start&lt;=x and weight_end&gt;x (is_latest is used to keep track of historical prices)
Cool, thanks man!
TDD is dead. Pedantic programmers need not apply. You either know what you're are doing and test what needs to be tested or you don't know what you are doing and your are going to need to test a lot more than just your code.
Really good points. I will take a look on these things. Thank you for spotting them out :)
!remindme 1 day
I will be messaging you on [**2019-03-26 14:17:40 UTC**](http://www.wolframalpha.com/input/?i=2019-03-26 14:17:40 UTC To Local Time) to remind you of [**this link.**](https://www.reddit.com/r/golang/comments/b5a7j9/dave_cheney_absolute_unit_test_londongophers/ejc8kj6/) [**CLICK THIS LINK**](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[https://www.reddit.com/r/golang/comments/b5a7j9/dave_cheney_absolute_unit_test_londongophers/ejc8kj6/]%0A%0ARemindMe! 1 day) to send a PM to also be reminded and to reduce spam. ^(Parent commenter can ) [^(delete this message to hide from others.)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Delete Comment&amp;message=Delete! ____id____) _____ |[^(FAQs)](http://np.reddit.com/r/RemindMeBot/comments/24duzp/remindmebot_info/)|[^(Custom)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[LINK INSIDE SQUARE BRACKETS else default to FAQs]%0A%0ANOTE: Don't forget to add the time options after the command.%0A%0ARemindMe!)|[^(Your Reminders)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=List Of Reminders&amp;message=MyReminders!)|[^(Feedback)](http://np.reddit.com/message/compose/?to=RemindMeBotWrangler&amp;subject=Feedback)|[^(Code)](https://github.com/SIlver--/remindmebot-reddit)|[^(Browser Extensions)](https://np.reddit.com/r/RemindMeBot/comments/4kldad/remindmebot_extensions/) |-|-|-|-|-|-|
!remind 1 day
Go takes pride in being boring. See https://youtu.be/4Dr8FXs9aJM If you want a language that adds sexy new features on a regular basis, you've backed the wrong horse. That said, I do believe that generics are still coming eventually, but they are tackling the easier features first, and correctly adding the the big features incrementally instread of all in a single release.
you could also let your sister edit an excel file, that you read as your data :-) as long as she doesn't alter the columns, you'll be safe. (but of course you can check for that)
normally a model would only hold the representatie structure of it's table counterpart. if you need some display manipulations like FullName (where you only have first and lastname), you add a method to the model that give you back the full name. I use repositories to handle the connection between the application and the database, where the repository would access the database and will a memory map\[string\]interface{} with each record. But you can also choose to have a service layer (if you have a huge application) You could also choose to have the queries in query-objects, so they are more separated. &amp;#x200B; But you need to tell us more, I think.
[removed]
Just a minor nitpick, but you should rename `compile.sh` to `Makefile` [1]. Use `make` to execute all the targets, or `make darwinAMD64` to execute one. [1] https://pastebin.com/raw/mZJhP1j2
thanks, I haven't thought about that. I will definetely change that 
At what stage and from what part of the code are you wanting to provide this data? &amp;#x200B; As I see it, there are two basic possibilities: &amp;#x200B; 1. You want to provide some information from the \*\*event\*\* that occurs, which means it is going to be provided by the go routine as part of the event 2. You want to provide a handler with access to \*\*state\*\* information that it should operate against when the event occurs. &amp;#x200B; In the first case, the usual solution for event style interfaces is for your eventhandler's Handle function to have parameters. It is pretty common to at least have an Object/empty interface type parameter which is the 'source' of the error and which can be accessed through reflection/type-assertion, and a second parameter of a general 'event' type that can encapsulate the event specific details, and which again could be type-asserted to get at more specific details. See Java, .Net and other such event systems for example. &amp;#x200B; In the second case, (for example, needing a database connection, or an output stream, or a logging provider), just package the relevant data into the object that you pass to fulfill the interface. Go does not care that your object has more fields or functions than the interface requires. &amp;#x200B; You can also copy the example of the http package, and create a HandlerFunc that takes a function and returns a Handler wrapping it, and if you do that style, you would use a closure to capture that sort of external access into the function at the time of creation, before passing it in.
(I've been ill the last couple of days.) I think what you want is the combination of the following: 1. A goroutine that uses runtime.LockOSThread, and then sits on a channel waiting for work. 2. A nice API that converts calls to that API to a message on a channel for that goroutine, and unpacks the results nicely for callers. I [discuss this pattern in a bit more detail here](http://www.jerf.org/iri/post/2917). I use it all the time, though not for LockOSThread things. The remaining problems are if the Lua code calls back into the Go, which is where I really have no solution. You end up back at a GIL like Python has (Global Interpreter Lock, basically One Big Lock Around Everything) pretty quick. If you can precisely characterize the calls you may be OK, but there's no easy solution.
Thanks for you help! Definitely a good point of golang to know going forward. Since golang is storing the receiver when a method is stored, would it generally be the wise decision to always have the method take a pointer receiver to avoid making a potentially large copy of the receiver, even if the method doesn't change the receiver?
My TL;DW: - Naive TDD can slow you down when you're experimenting, discourage refactoring, and encourage often-changed tests that merely snapshot current behavior. - You should take a broader view of the "unit" under test. The units are not each internal function you write, but a whole package. Specifically the public API of a package. - You should test behavior, not implementation. In part, this means you should only test that public API. You should only test behavior that is observable to a consumer. (This helps have meaningful tests and preserve the ability to refactor.) - If code coverage shows internal code that cannot be exercised by the public API, maybe delete it. - If you find yourself wanting to use the same internal helpers in implementation and in tests, that's kind of dangerous. Maybe split that into a separate package. (So it can be tested on its own and the original package has a tighter scope of responsibility.) - These are all just guidelines, experience is key. 
Of course thank you for being interested. There is more to come I will add bench mark comparisons. 
Maybe use a function type instead of an interface and use closures to supply arguments.
As others have stated Go can not infer the type via the simple type inference strategy it uses. It just looks at what is on the right side of the '=' to determine the types. Other languages (Haskell, OCaml, etc..) generally use a more complicated strategy ( https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system ) or type system that allows them to infer the types. Using the naive approach, one can not tell if what is being described is an array, slice, or struct (using positional, parameters). 
I don't think such a library exists, unless you intend to re-invent QUIC (HTTP/3). HTTP parsers exist, of course, but I don't know of any that decode HTTP requests from out-of-order packets except those as used by QUIC packages. This smells more like an [X/Y problem](http://xyproblem.info/).
`net/http` provides `http.ReadRequest` and `http.ReadResponse`. I've used it to "impement" http over a unix socket in a test program that I wrote. They both take in a `*bufio.Reader`, which you should be able to construct? They turn a buffered stream of bytes into an `http.Request` or `http.Response`, which seems to be what you're looking for?
Really nice post.
I hadn't made the connection that the 'Ghost' was the previous account that was deleted. As I've never seen it before (just lucky I guess), I assumed that it was an actual username for an alt account. TIL.
And it's not limited to Rails apps, it'll work fine as long as you use Postgres and your schema uses foreign keys for relationships. As for auth it support JWT. Super Graph will learn your schema and build a relationship graph internally. Also it's very efficient with it's Postgres queries, no matter how complicated your GraphQL is it only generates a single fast optimized Postgres query.
I was going to have a go at this but upon further inspection your code is significantly cleaner and better managed than any project I've worked on so if anything your code would be reviewing me... Lol very nice work OP
&gt; "When you're structuring your package, always ask 'What does this package do?'. Never ask 'How does it do it?'." Isn't this Object Oriented Programming? 
Cool! I would totally use this -- is there a way (or plans for a way) to specify aggregation rules? i.e. if a lot of messages are similar but vary only by certain fields, I may still want to aggregate them. OR I want to see only those messages, and aggregate by the \_differences\_ in each field. (Make sense?) I would love that.
`(*net/http.Server).Serve` accepts any `net.Listener` – including UDP ones.
The approach seems to be very wrong: HTTP \_assumes\_ the underlying protocol is a connection oriented \_stream.\_ UDP does not provide a stream; the only guarantee it provides is that if a datagram was delivered at all, it was delivered in a single piece (but you cannot even be sure its contents is correct unless you do real checksumming and verify that).
&gt;What are you trying to access? Data known to the party who defines the handler? Yes. I actually did this without thinking about it, never *really* used interfaces so I was a little confused about the correct usage. I think this should work, though it seemed a little dirty and incorrect at first. 
I was saying 99.9999999% of the world has no idea about him being a hack. It's just this small community that does. He applies to a job, employer just sees a rockstar dev.
Clicking "save" is less work
Have you hit the flamegraph trace on the pprof web interface of the running program? you may be able to see where cpu time is? 
Yep, and the QUIC engineers already did: [https://quicwg.org/base-drafts/draft-ietf-quic-transport.html#rfc.section.2](https://quicwg.org/base-drafts/draft-ietf-quic-transport.html#rfc.section.2)
I'm not sure I understand how this should work. HTTP, in general, has relatively large requests. For example, if I just make a GET request for google.com, the headers alone are ~1.3 KB - which is already above what you should assume to be able to fit in a UDP packet. So HTTP, specifically, doesn't really make a lot of sense over UDP (unless, as pointed out by others in this thread, you add re-transmission and re-assembly of packages and the like, as QUIC does). That being said, there is the [textproto-package](https://golang.org/pkg/net/textproto/), which allows you to parse HTTP-*like* protocols. i.e. if all you're interested in is the general format of "some foo=bar headers, plus an empty line, plus a body", then that might suit your purpose.
Safe 
dgryski
I would assume you would want developers who don't necessarily write Go ...to be writing the assembly code _for_ Go. In this case, I would say that better comments would probably be the best solution to some of the examples shown. &gt; 116 avo lines to 1507 assembly lines For everyone else, this sounds great! 
Yes they are thread safe, though care should be used if passing pointers to structures through the channel. Make sure the ownership is transfered or pass values. 
The point is in a lot of cases writing assembly code is repetitive and error-prone, and having it generated by a tool makes a lot of sense. That tool can be a regular compiler, a specialized script (like the perl script for openssl), or more generic high-level assemblers like peachpy or now avo. As somebody who writes assembly code for optimized hash functions and crypto, I'm really glad to have a tool like avo.
I've been following the following people for the last 6 months and I am really happy. [**bradfitz** ](https://twitter.com/bradfitz) [**empijei** ](https://twitter.com/empijei)‏ [**corylanou** ](https://twitter.com/corylanou)‏ [**goinggodotnet**](https://twitter.com/goinggodotnet) [**mattklein123** ](https://twitter.com/mattklein123)‏ [**VladimirVivien**](https://twitter.com/VladimirVivien) [**fatih**](https://twitter.com/fatih) [**bitfield**](https://twitter.com/bitfield) **-&gt; He is very helpful in code reviews.** [**benbjohnson**](https://twitter.com/benbjohnson) [**peterbourgon**](https://twitter.com/peterbourgon) [**francesc**](https://twitter.com/francesc)‏ [**davecheney**](https://twitter.com/davecheney) [**broady**](https://twitter.com/broady) [**dgryski**](https://twitter.com/dgryski)
Yes, I certainly see the benefit to not writing assembly by hand (I program in higher-level languages after all). I was just pointing out that the approach to requiring learning Go to write assembly might not be the most universal way to improve outcomes (even for Go). Then again, maybe this will be like SASS and people won't care they have to use Ruby to process it.
This tool is more focussed on improving writing assembly language for Go programs. It expects the Go ABI and generates Go-style Assembly. For more general use cases (i.e., non-Go programs) there's https://github.com/Maratyszcza/PeachPy which is one of avo's inspirations.
Have db.Send\*Items return an interface{} containing a slice of the relevant values, and it should work out. Note that's an interface{} containing a slice, _not_ a []interface{}. (Although you could make that work in this case, it'll annoy you later, probably.) A bit inelegant, but effective.
thank you &amp;#x200B;
I’ve built my own version of it using the community version as a guide. We’re thinking about putting it in production in the coming months. 
oh thanks! any suggestions ?
Short answer: you can't. See https://stackoverflow.com/questions/12753805/type-converting-slices-of-interfaces-in-go/12754757#12754757. Longer answer: you're always going to have to write the conversion to `[]CommonItem`. You can do this in `db.get{A,B,C}Item` or as a separate routine. Option 1: in `db.get{A,B,C}Items`, collect into and return an `[]CommonItem` instead of `[]*{A,B,C}Item`. It's kinda iffy because if you actually wanted to use the specific type you would have to type-assert each element. It is slightly slower than your approach because the interface assignment isn't free, but is close enough to probably not matter. type CommonItem interface { Validate() Prepare() } func handleCommonItems(getItems func() []CommonItem) http.HandlerFunc { for _, item := range items { item.Validate() item.Prepare() } return func(w http.ResponseWriter, r *http.Request) { sendJSON(items, w, r) } } func main() { router.Get("/a", handleCommonItems(db.getAItems)) } Option 2: use a converting closure. It's extra boilerplate and slower than the above *and* your approach. Not sure of any benefits over the other options. type CommonItem interface { Validate() Prepare() } func handleCommonItems(getItems func() []CommonItem) http.HandlerFunc { for _, item := range items { item.Validate() item.Prepare() } return func(w http.ResponseWriter, r *http.Request) { sendJSON(items, w, r) } } func main() { router.Get("/a", handleCommonItems(func() []CommonItem { as := db.getAItems() items := make([]CommonItem, len(as)) for i := range as { items[i] = as[i] } return items }) } Option 3: what you have in the post. It's the fastest (and simplest) way to go about it. Unfortunately.
A common example is defining an int as a Celsius type and a Fahrenheit type. Both can have ToKelvin methods that match the same interface, but you can ensure no function expects one and is passed the other by mistake. 
Yes. Please use this project. It's giant and already GPL'd. If you are going to write code and contributed it to the common good, be sure you understand why you are using a BSD license instead of the GPL. If you don't want people to contributed their changes to your code, that is fine, but just make sure you understand how companies take BSD code and make proprietary commercial forks for profit without requiring any contributions back to the original authors. BSD code has it's place, but there is a reason that coreutils is GPL'd code now just like the Linux kernel.
Yes, something else to consider
Planning to do the same . Not a golang expert. But was able to achieve what we needed. Would love hear back from you on the performance part after deploying in production 
Damien Gryski is probably one of the best people to follow on twitter imho. Really smart guy.
We are giving it a chance because we want to put in some custom middleware in front of some services.
[The Go Programming Language Specification](https://golang.org/ref/spec#Channel_types) states: “A single channel may be used in send statements, receive operations, and calls to the built-in functions cap and len by any number of goroutines without further synchronization.” In other words, you can have multiple writers and multiple readers all using a single channel without a mutex or other lock. The channel itself manages the data and ensures the safety of concurrent access.
*bows*
https://killedbygoogle.com
Option 5: code generation. 
Is this new? It's pretty neat. Seems like a play by Microsoft to get into the CI/CD market, if they aren't already.
It's relatively new. It's been in beta for a few months. I think it predates Microsoft acquisition by a bit. It's still in beta so you have to request access but I think they give it to anyone who asks. &amp;#x200B; &amp;#x200B;
OT: If you're just looking for a bash history that works across multiple sessions per-user, Bash history supports everything you need. [https://pastebin.com/UGErnuKY](https://pastebin.com/UGErnuKY)
Go interfaces are not like Java interfaces or C++ abstract classes. They don't describe points in an inheritance tree, and it's probably wrong to think about them in that way. More concretely, interfaces in Go don't have names like `Boxable`, describing concrete attributes. Rather, they have names like `Reader`, describing behaviors. Interfaces are behavioral contracts that types can implement. They don't say anything about data. So, you wouldn't have Boxes or Boxable. Rather, you'd ask what you want to _do_ with the boxes. Do you want to seal them up? Then you'd have ```go type Sealer interface { Seal(strength int) error } ``` Do you want to have something that can store data? ```go type Storer interface { Store(data []byte) (count int, err error) } ``` Presumably you define these interfaces because you have some code that can utilize those methods and perform those behaviors without knowing (or caring) what the underlying types are. ```go type StoreSealer interface { Storer Sealer } func PackageUp(data []byte, sealStrength int, dst StoreSealer) error { if _, err := dst.Store(data); err != nil { return fmt.Errorf("error storing data: %v", err) } if err := dst.Seal(sealStrength); err != nil { return fmt.Errorf("error sealing destination: %v", err) } return nil } ```
Interesting site. The first point, is that all of the solutions listed on that site, except for the obscure Noop, are not programming languages. Also, Go is not an end-point solution, it's a language for creating solutions. End-point solutions listed on that site have a limited scope of viability, whereas Go's scope of viability extends to the usefulness of the solutions that have been created with the language. Go has a vast multitude of reasons for its continued existence, it's increasingly systemic in Google and in the software industry. Whereas solutions like Google+ can exist or be killed, but it won't really affect Google or the software industry at large, as it's not systemic. 
What about this? &amp;#x200B; `package main` &amp;#x200B; `import "fmt"` &amp;#x200B; `// A simple box` `type Box struct {` `Data string` `IsOld bool` `}` &amp;#x200B; `// Our package` `type Package struct {` `Boxes []Box` `}` &amp;#x200B; `func newPackage() *Package {` `return &amp;Package{}` `}` &amp;#x200B; `func (p *Package) ChangeDataOfFirstBox() {` `p.Boxes[0].Data = "Changed"` `}` &amp;#x200B; `func main() {` `p := newPackage()` `p.Boxes = append(p.Boxes, Box{Data: "HI", IsOld: false})` `p.Boxes = append(p.Boxes, Box{Data: "HI", IsOld: true})` `p.ChangeDataOfFirstBox()` `fmt.Printf("new Data: %v", p.Boxes[0].Data)` `}` &amp;#x200B;
Actions are only available in private repositories at the moment.
&gt; Do I need to define a bunch of setters? Yep. What happens if some user-provided `Boxable` doesn't have a `Data` field? If you need this field to be present in all cases, leave it out of the interface and make something like: type Boxable interface {} type Boxed struct { Data string Boxable } And store `[]Boxed` or `[]*Boxed` instead. Another alternative could be: func (p *Package) ChangeDataOfFirstBox() { switch box := p.Boxes[0].(type) { case *Box: box.Data = "Changed" case *OldBox: box.Data = "Changed" } } But it would only work if `Package.Boxes` contrains pointer elements. Also you'd need to know the types beforehand, so user-defined types are out.
Couldn't have put it better myself.
Incorrrect. It's curated. And even if it were just a copy and paste newsletter, it takes work to decide what to copy and paste. Your judgement was hasty.
That was indeed true but you can now have them in public repositories as well. Proof: https://github.com/kjk/siser/tree/master/action-go-test (that's the action I described in the article). 
Thanks, but i really want to use my solution. It just fits my needs. 
I'm thinking about [https://github.com/satyrius/gonx](https://github.com/satyrius/gonx)
Getting an error when signing up.
https://twitter.com/FiloSottile https://twitter.com/andybons
Well, it can be useful, but the example in article is a big overkill. `go test` can (and should) be run using precommits.
Will do it too. &amp;#x200B; I'm thinking of creating something like .red.yml config file where you can configure which logs to aggregate and so on.
True. My goal with this article was to provide a step-by-step introduction to the simples GitHub Action. The potential of what can be done with Actions is indeed almost unlimited.
.js files are static files. Treat them the same as you would an image or html file. Static/dynamic files refer to if there is server side processing of them. Since js is all executed on the client, you don’t have to worry about them. 
if a file not change in server ,it's a static file . js file if not serve by nodejs ,it's a normal static file.
Also, "replace" in go.mod lets you use a local package. Critical if you need to test your module in a different project before pushing the new changes.
I made myself a kind of work around by having a handler that would first check if requested url is a file and it exists, otherwise always return the index. Worked for me. 
And what exactly did you hack Oo?
For MySQL, I used the same logic as in here [https://github.com/go-sql-driver/mysql/blob/master/utils.go#L579](https://github.com/go-sql-driver/mysql/blob/master/utils.go#L579) 
Some ruff code to give you and idea of how it could be done based on the php code logic provided; &amp;#x200B; 1) First build your conditional SQL query and store the corresponding values in a slice. username := "user1" postName := "post1" sql := "SELECT * FROM mytable WHERE " conds := make([]string, 0) vals := make([]interface{}, 0) if len(username) &gt; 0 { conds = append(conds, "username = ?") vals = append(vals, username) } if len(postName) &gt; 0 { conds = append(conds, "postname = ?") vals = append(vals, postName) } sql = sql + strings.Join(conds, " AND ") fmt.Println("sql=", sql) fmt.Println("vals=", vals) &amp;#x200B; 2) Then pass the query and values to sql/database. &amp;#x200B; stmt, _ := db.Prepare(sql) rows, _ := stmt.Query(vals...) &amp;#x200B; &amp;#x200B; Note that you should refer to proper examples of using sql/database and check all errors etc. A good resource for beginners would be [http://go-database-sql.org](http://go-database-sql.org)
So A simplified explanation is to build the arguments while building the query. This might actually have been what I was looking for. I had no idea I could add multiple vars like that.
I'm using Postgres for my latest project, and was thinking about the same problem. I found [this post on stack overflow](https://stackoverflow.com/a/43700931/8736825) which would seem to work elegantly. This was surprisingly close to the solution I had guesstimated. I'm not entirely sure this would work with the MySQL driver, so i might require some testing on your part.
If you want to find out more about adding vars like, see Variadic Functions [https://gobyexample.com/variadic-functions](https://gobyexample.com/variadic-functions)
I have actually tried this, but it creates the problem where I am searching user_name = '' which returns nothing, because there are no rows with nothing as the user_name.
after translating it to go when I do the if() statements I can just add the var to the interface and add the sql with ? in it and hopefully that will work. I will test it out and see.
The API doesn't expose a public function that would allow you to see the SQL query, anyhow the query is how you pass it in. &amp;#x200B; If you really want to see how it looks from the databases perspective you could simple log all queries at the DB, eg: in MySQL use the "log" file option.
I am actually getting this error: `sql: converting argument $1 type: unsupported type []interface {}, a slice of interface` This I think I have messed up the interface somewhere. I will try it out with only part of the query instead of the whole thing. Thanks for the help though, I think this got me on the right track once I figure out using interfaces with the query function.
thank you so much
thanks to all input I got until now. I am guy who do daily posts (not one of those bots) on [https://twitter.com/golangch](https://twitter.com/golangch) and look for new input. 
First of all, there will be no 'Go 2'. Go 2 is a concept under which potential language changes are gathered. A little bit of 'Go 2' will probably come out in the next version 1.13 in form of an enhanced errors package and binary number literals. All changes will be backwards compatible so there is no reason to not write code right now. 
cool. tweeted via https://twitter.ch/golangch
Ok thank you.
WOW I am dumb... when I got the error because I replaced this: &gt; `LIKE '%" + user_name + "%'` &gt; `args = append(args, user_name)` with &gt; `LIKE '%?%'` &gt; `args = append(args, user_name)` Instead, I should have done &gt; `LIKE ?` &gt; `args = append(args, "%"+user_name+"%")` I should have none this after the first time I ran into this problem I spend an hour on it. 
Thanks to u/swdee I got it figured out. While creating the sql string as swdee suggested I also build the args interface. ``` sql := "..." args := make([]interface{},0) if(strlen(user_name) &gt; 0){ sql += user_name = ?" args = append(args, user_name) } if(strlen(post_name) &gt; 0){ sql += post_name = ?" args = append(args, post_name) } results, err := db.Query(sql, args...) ``` So far this works all my tests. It was really just that easy. --- Also, I said I couldn't find anything when searching for this, I actually never looked up interfaces which has dozens of examples showing how to do this exact thing. So thanks again to u/swdee!
Check out openfaas.com. 
=&gt; [https://twitter.com/golangch](https://twitter.com/golangch)
That makes much more sense to me now. Thank you. Brain is stuck on a lot of past OOP languages, your comment helps shift that thinking for Go :)
Oh hi, we met at the last party, actually. 
Yup! Thanks! I ended up coming up with that exact same solution afterwards in the wee hours, but then realized in my case, the "you'd need to know the types beforehand" part is what I wanted to avoid. If I knew beforehand, this would be fine. u/peterbourgon's comment definitely helps steer my brain into a right direction to utilizing the interfaces to ensure behavior, and not think of them as something that can be an "instance of" like in other languages.
With https://github.com/rogpeppe/gohack it is even simpler :)
Is there a complete reference / documentation anywhere about the complate Go assembly syntax / instruction set, say for x86 assembly?
omg... thanks so much :-)
Is this like a multi curl implementation as an API?
A thon, says so right there.
Gohack is useful, especially when you need to do a quick edit on a external dep. Note that Gohack does a clone for you, so it might not use the library you are currently making changes to (different path), but a fresh clone instead. So I find it easier to just write the replace myself. Only takes a few seconds afterall, and you have total control. Have you had any scenarios or any tips you can share about this, if anything comes to mind right now?
I'm not familiar enough with Python to say for sure, but it doesn't sound like it. A Google of pyenv makes it sound like you're switching between your running version of python, 2.7 or 3.x. Instead, it's more like pip requirements files, I think: Myapp1 requires libx v1.0.0, but MyApp2 uses libx v2.0.0. I can build both apps on my machine with ease, even though libx v1 and v2 are incompatible.
To be fair, the common wisdom in OO land is "Tell, Don't ask". &amp;#x200B; Which is more or less what OP is saying. &amp;#x200B; [https://pragprog.com/articles/tell-dont-ask](https://pragprog.com/articles/tell-dont-ask) 
Interesting, I can see how the form based interaction could be useful to some people. Personally, I prefer to work with a decent text editor and a well crafted template. I don't like the way that the form imposes metadata into the subject line. Afterall it's only 50 characters; I need each of character to convey my message! I feel that you may missed an important point from 'rule 5'. I find it extremely valuable to have the phrase "If applied, this commit will..." in my head before I write my commit message. It helps to maintain the imperative tone and gets straight to the point. I believe every good commit template starts with this phrase. I.e. `# If applied, this commit will` I think you should replace "Type in the subject" with that. Also, the README has some minor typos: - The subject is limited to 50 characters; not 72. - The body is wrapped to 72 characters; not 320(!)
&gt; ...closet MRA Bob Martin heh
How's this different from hasura.io?
Thanks for the detailed reply. That's pretty much what I was finding on my own, but didn't know if I was just searching for the wrong things.
I've collected resources I know about here: https://github.com/dgryski/go-perfbook/blob/master/TODO#L130 in preparation for adding them to a section of the perfbook. Let me know if you find any others.
Could you give some example of good commit please? About readme (see gitcomm/prompt.go): - The subject length is limited to 72 characters (50 is too short) - The body length is limited to 320 characters (too long commit body is hard to read, but you can always change it during editing in text editor) It's a typo about body wrap in 320 chars :) I didn't understand this phrase: &gt; I don't like the way that the form imposes metadata into the subject line. Afterall it's only 50 characters; I need each of character to convey my message! What did you mean? Subject is a brief description of commit. Gitcomm let's you type anything you want. Template is a good practice. Gitcomm makes everyone fill commit message with rules that were accepted by all contributors in your team
To amend /u/hexaga's Option 2: \`\`\` type Item interface { Validate() Prepare() } &amp;#x200B; func handleItems(getItems func() \[\]Item) http.HandlerFunc { return func(w http.ResponseWriter, r \*http.Request) { for \_, item := range getItems() { item.Validate() item.Prepare() } sendJSON(items, w, r) } } &amp;#x200B; func main() { router.Get("/a", handleItems(db.getAItems)) router.Get("/b", handleItems(db.getBItems)) router.Get("/c", handleItems(db.getCItems)) } \`\`\` We've removed the closure and are passing the various \`db.getXItems\` as first class citizens to \`handleItems\`. In turn \`handleItems\` returns an anonymous function to use as a route handler. This option has less boilerplate and is just as performant as copy pasting!
Expect thinking in composition rather than inheritance to also take at least a couple of weeks, in my experience. But I'm yet to miss inheritance now that I've made the transition, in conjunction with proper interface usage. (I think there are a handful of cases where inheritance makes sense, it's just that they are the exception, rather than the rule. GUI widgets work really nicely with inheritance; the Liskov substitution principle has a fairly direct mapping to "how these things have to work on the screen" in that case and it's quite nice, but I've never worked in another domain where inheritance was anywhere near as nice as it was there.)
Added new features. See last commits
Ahh. Thanks for the tip !
I feel like more broadly it's a TDD thing in respect to "what does this unit need to do?" You then write a test and make it work (and then refactor)
Interesting, super easy to use! I just need something like this instead of AWS serverless. Thanks for sharing!
I began this project a few years ago. My first OSS venture that actually got a bit of attention, though there's only one small package that uses it. Since I'm between jobs again I figured I'd dust it off and make it a little more complete. I'd appreciate any feedback on the structure, things I did wrong or issues/PRs. Hope someone will find it useful.
@dgryski's links are excellent. I would say once you really get into the weeds, Iskander Sharipov's "complementary reference" is really useful for understanding the frustrating differences between AT&amp;T/GNU syntax and Plan9. He did the bulk of the work to add AVX-512 support in the Go assembler, so he really knows this stuff. https://quasilyte.dev/blog/post/go-asm-complementary-reference/ 
&gt; https://quasilyte.dev/blog/post/go-asm-complementary-reference/ Added: https://github.com/dgryski/go-perfbook/commit/6e9fe0ee94ef82fccebc1c68e1a8a8469a098cd9 :) 
I think what is missing is a single and complete reference for the Go x86 assembly - not having to dig through a number of links like plan9 assembly (that differs in some ways), a quick guide to Go's assembler that is incomplete x86 assemble instructions - that are not fully supported - yada yada. The godoc documentation of avo could become such a place - if only each function would be documented i depth. 
The point is the documentation is https://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-instruction-set-reference-manual-325383.pdf , there are only slight differences needed to convert to what Go expects (and that is covered by those posts). It doesn't make sense to have a Go project duplicate the information provided by Intel.
[removed]
That could be read as imply that because something is possible, it's not hard.
I don't know. I have a rails app that is growing and needed a GraphQL api so I built this. 
I don't think this is better. It's a bad of use of `defer` IMO.
I like this approach. It definitely cuts down on the boilerplate. Error handling is definitely one of those points where I like the way Go handles it but the additional code required does make me wince a bit.
I agree. Not a huge fan of using defer in this way, especially where it closes over a variable like this. I think its better to just factor out the common error handling logic into a helper function and call it explcitly.
Github link: https://github.com/mmcloughlin/avo
&gt; Could you give some example of good commit please? Here one from the linux project: https://github.com/torvalds/linux/commit/93417a3fda2060f2a34e3341904024c5b6980d1f The body tells why the change was needed, providing an example; in this case there is problem when a certain build flag is used. Then the body describes what was changed to address the problem. The subject is brief and imperative. For a project as big as linux, it can be useful to include the module (i.e. scope) that change affects, in this case "genirq". &gt; The subject length is limited to 72 characters (50 is too short) All the links in your README talk about a 50 character subject. It's seems that industry agrees with this as a guideline. But it is only a guideline, not a hard and fast rule. Nevertheless, I think it's confusing if you decide to change it to 72. &gt; The body length is limited to 320 characters I see no reason for this; if the author took the time to give a detailed description that exceeded 320 characters, then kudos to them. I think I would struggle to fit two paragraphs into 320 characters, and I regularly write 2-3 paragraphs per commit, something more. &gt;&gt; I don't like the way that the form imposes metadata into the subject line. Afterall it's only 50 characters; I need each of character to convey my message! The metadata I'm talking about is the type ("feat:" in your demo) and/or scope ("genirq:" in the linux example). The projects I tend to work on are small and giving a scope is unnecessary. IMHO, type is superfluous. I can put those 6 characters to better use and keep within the 50 character guideline. To achieve consistency across a team, I believe that there's no substitute to code reviews. But a tool to assist authors is always welcome. I would still prefer the editing experience of a good text editor that did auto line wrapping and provided column rulers and spell checking. If you want auto validation then that should be placed in a commit hook or maybe a receive hook.
In case speed matters, to save cpu resources for instance, be aware that defer is not free. It would be preferable to write code like this err := f1() if err == nil { err = f2() } if err == nil { err = f3() } ... if err == nil { return } log.Println( "error in handler:", err) ... There will be a small overhead, due to the err == nil tests, but it will be less than the defer instruction. 
[removed]
I like the approach because it's readable and it's another way of looking at errors. &amp;#x200B; But I must say that I never put this much inside a handler in the first place. I've looked inside my code and a max of 2 errors can occur. But your solution gives us time to think about error handling again :-) 
Or you could just do the obvious: func myHandler(w http.ResponseWriter, r *http.Request) { err := validateRequest(r) if err != nil { goto errorh } user, err := getUserFromRequest(r) if err != nil { goto errorh } // ... return errorh: log.Printf("error in myHandler - error: %v", err) w.WriteHeader(http.StatusInternalServerError) } But they all, aside from the original, suffer from not providing context about the error. What if validateRequest and getUserFromRequest happen to return the same error, for some reason (possibly because they also do not provide context). How are you going to differentiate where the failure occurred?
You are right, but you made my cry because of the goto. Good point about the error context which is also missing with the defer instruction.
We did consider moving to a separate function. The reason we went with the defer is readability - the code is all there for you to see whilst reading that function, not hidden away somewhere else. I don't believe in hiding things away in functions to aid readability, as its actually achieving the opposite by making the programmer go find that function to get the full story. 
&gt; but you made my cry because of the goto. That is a shame. `goto` was included in the language for good reason. Use it where appropriate. The paper about "goto considered harmful" was about jumping between functions using goto, which is problematic. Go does not allow that in the first place. Granted, I don't think this is an appropriate use.
Providing enough context in your errors is key, as the article states. It isn't as much about using the defer as it is a re-think about how we compose errors within our codebase. 
goto was considered as it provides some of the same benefits as the defer, however when using goto as standard practice over a team of hundreds of developers it was considered to have more pitfalls than that of the defer pattern. 
Thanks. These are somewhat contrived examples, but at the same time I wouldn't shy away from composing larger functions if readability and comprehendibility (not at word...) would suffer for braking them up. 
What pitfalls are those? `goto` in C has many pitfalls, as described in the infamous "goto considered harmful", but Go is designed to not allow you to encounter those pitfalls.
It is, but it's also basically as close as you can get to the [Go 2.0 error handling proposal](https://go.googlesource.com/proposal/+/master/design/go2draft-error-handling.md) today, so it does have a nice path forward. I'd considered this approach in the past and also rejected it for Go 1.0, but I'm looking forward to being able to use this nicely in 2.0.
Order of declaration can be a problem with goto, which doesn’t mix well when you consider we favour composing larger http handlers in cases it can aid readability. goto is also something people have less experience and understanding of over a defer statement. I’m not against goto personally, I just think there is a time and place for it in lower level code rather than standard practise across a very large codebase with lots of developers. 
I fully agree that `goto` is useful sometimes and has its place, but "remembering to type it every time you have an error" has a demonstrated poor track record. C uses this all the time but it's very error-prone to get right, just because it's so easy to forget something and _nothing_ will tell you that you did, or even hint to you that you did. You can get linters for Go that will warn you you're ignoring errors, though.
This is the standard way you're supposed to do it: func ErrorHandler(name string, errhandler (w http.Response, r *http.Request) error) http.Handler { return http.HandlerFunc(func (w http.Response, r *http.Request){ if err := errhandler(); err!=nil { log.Printf("error in %s: %v", name, err) statusCode := http.StatusInternalServerErrror if coder, ok := err.(interface{Code() int}); ok { statusCode = coder() } w.WriteHeader(statusCode) // other handling, etc. } }) } func myHandler(w http.Response, r *http.Request) error { var err error err = validateRequest(r) if err != nil { return } user, err := getUserFromRequest(r) if err != nil { return } dataset, err := db.GetUserData(user) if err != nil { return } buffer := newBuffer() err = serialize.UserData(dataset, &amp;buffer) if err != nil { return } err2 := buffer.WriteTo(w) if err2 != nil { return } } And register it with `http.Handle("/path", ErrorHandler("myHandler", myHandler))` or whatever.
Cool. I remember using a few different packages a couple years ago that either didn't have recursive watching or if it did, it was very inefficient. Will be good to see this stabilize and give it a try. 
I'm not sold on using defer in their example. The first three error-returns functions are middleware that doesn't need to be in the handler, the fourth one makes sense, and the last one could use a helper function to keep the logging consistent. My rule of thumb is that if you find yourself doing a lot of error handling in a function that doesn't return an error, wrap all that stuff in a function that does return an error and handle that result.
AIUI, recursive directory watching on Linux is straight-up inefficient. The kernel does not do it well. So it doesn't matter what you wrap around it, it will not work well. /u/tywkeene, that doesn't make this a "bad package" but I'd suggest making this an up-front and obvious documented fact about your package, because otherwise, you're going to get reports about how *your* code isn't working well, when in fact it's actually the OS.
I think you meant to post this in /r/GolangJobOfferings/ 🙂
It would be cool to have a major version change. But otherwise: Very nice!
&gt;preliminary support for Delve to call Go functions &amp;#x200B; Finally! This has always been a glaring feature gap in the debugger. &amp;#x200B; Kudos to the delve team for working on this
This is another option we considered, but I’d class wrapping as obfuscation. It isn’t obvious at all what could be hidden in the wrapping function and isn’t obvious that it even exists in the first instance. The decision to keep the error handling inside the function itself is one based around readability and programmer cognitive load. 
&gt;AIUI, recursive directory watching on Linux is straight-up inefficient. The kernel does not do it well. So it doesn't matter what you wrap around it, it will not work well. Are you aware of any write-ups or documents that go into more detail on this? I'd be interested to see if there's any ideas on getting around this from the kernel hackers, might event be able to figure out a kernel patch. The way I wrote it, it's more like a single watch for each directory in a list, which is somewhat heavy, but I'm sure could be trimmed down. I'm hoping at first glance that this design sneaks around the kernel, hopefully in a scalable and efficient way. Thanks for the heads up, definitely worth looking into and I'll write benchmarks soon (been meaning to anyways) in the future to make sure it's viable at all.
From my experience hiding away bits of code you don’t like or consider ugly never ends well when working in larger teams. Best to put it all on the table out in the open so there is no confusion as to what is going on. 
&gt; Order of declaration can be a problem with goto Isn't that a problem regardless? If you move the `defer` down in the example code, it is going to behave quite differently. &gt; goto is also something people have less experience and understanding of over a defer statement. That's interesting. Given that most ALGOL-inspired languages include `goto`, while few include `defer` (or anything resembling defer), I would have thought the opposite was more likely to be true. Out of curiosity, are these points something that you measured, or just gut feeling?
 if err != nil { return } This one-liner looks nice but will not survive `go fmt`.
It’s based on gut and experience. Though, I don’t think I’d be far off the mark in an assumption that defer is a more widely used go idiom than goto. Certainly internally this is the case. 
Yeah this is true, it was more for purpose of the example - but yeah gofmt spits that one right out. 
Hmm to chime on to your first example. Appending works fine with this, however I assume there's no way to retrieve the struct via function on the Package? Since the types are different? &amp;#x200B; [https://play.golang.org/p/u7WJ2pYDCVt](https://play.golang.org/p/u7WJ2pYDCVt) (line 22 is what I'm assuming is impossible since we dont know the user defined type?)
I would do it like this check := func(err error) error { if err != nil { log.Printf("error in myHandler - error: %v", err) w.WriteHeader(http.StatusInternalServerError) } return err } err := validateRequest(r) if check(err) != nil { return } user, err := getUserFromRequest(r) if check(err) != nil { return }
Yep this was considered and whilst I do like it I couldn’t justify the additional function call overhead for what seemed like no functional benefit over the defer. 
I would recommend; The Go programming language by Donovan and Kernighan
Isn't it inlined since Go 1.8 when mid-stack inlining was enabled? I will have to check that.
Try free "Essential Go" book https://www.programming-books.io/essential/go/ (this is my project). I tried to structure it to provide both basics and advanced information. Most code examples have links to online playground where you can quickly change the code and experiment. Also try search. The idea is to give a quick way to find the content you need. E.g. type "json" and that shows a list of chapters that talk about json parsing/encoding. And there's a keyboard shortcut for search (/) so it's possible to navigate the books without using a mouse. I'm still working on the book (both the content and presentation) so I'm happy to hear improvement ideas.
Afaik this won't compile unless `db.get{A,B,C}Items` returns `[]Item` / `[]CommonItem` interface slices already, or option 1 in my answer. If it doesn't you must have some sort of conversion code.
I meant something more like this: https://play.golang.org/p/F9uHPljrAmX In the package you are writing, you can't know every type of `Boxable` beforehand, so you can't access fields of them. You can however pair each user-provided `Boxable` with your own fields/information in a struct that is accessible to your package *and* the user's if you wish.
That makes much more sense now, was really stuck trying to wrap my head around the course I'm going through for interfaces/structs. Thank you!
I’m sure you would enjoy either option. This question lacks the context necessary to guide you in any particular direction. Perhaps you could add some so that people can provide more directed guidance? Welcome!
I can't tell you what you should do. I can tell you what I do: I use Go (proof: https://github.com/kjk?tab=repositories) C# is also a good option. However, at this point dotnetcore is still not as good for cross-platform / Linux / building stand-alone binaries for deployment on Linux. Go does that by default. I also much prefer Go's concurrency (go statements + channels) to C# (async / await). But they are close enough that my main factor would be which technology I know better. For me it's Go. 
I have this and it is a great book. 
Wow, I'm reading through some of the topics that initially were giving me trouble and I'm finding the explanations clear and concise. Well done. I'm definitely going to be sharing this one and reading up on it my self!
[gobyexample.com](gobyexample.com) [Golang Standard Libary Docs](godoc.org/-/go) 
Is this something special with the beta? I don't see the same options in my public repos that I see in private repos.
Which options and what is different? Did you sign up for the beta at [https://github.com/features/actions](https://github.com/features/actions) ? I have the same "Actions" tab in both There was a time actions were only available for private repos but they enabled them for public repos in late january. See [https://developer.github.com/actions/changes/1/](https://developer.github.com/actions/changes/1/)
Thanks, good to know the content is helpful.
your preference... I don't use that construction I've got so used to reading the `if err != nil` lines that it actually takes me longer to understand what's going on when it's not present. Also I've had weird shadowing bugs because the `err` is actually defined inside the if-statement scope, and is undefined outside it. But perfectly valid, if you prefer it :)
Go might be a good fit, but you should have a rough idea of what you want to do. Go is a good candidate for API´s, backend code, moving data around etc. For the client side, I don´t know much in terms of Go but there are frameworks available, a lot of front end developers implement their entire client in javascript with some insane mess of dependencies and frameworks. The Go team seems more committed to forward and backward compatibility, so you might end up spending more time creating value and less time keeping the code in alignment with the current C# and framework releases. There tend to be fewer dependencies, fewer frameworks, and the deployment can be a just a single executable or a truly minimalistic docker container if you want it to. The use of UTF-8 for strings rather than UTF-16 can reduce the memory requirement for your hosting environment. I think Go might be more cost-effective in the long term if you need fewer resources. Startup times are also always fast. 
So I'm going to tell you a story. I did my degree in astrophysics and now I work as a software engineer at NASA. Most of what I do now is full stack, but I also do data analysis, some weird stuff specific to scientific work, and high performance computing and heavily parallelized development too. BTW, I even recently wrote a paper for a conference about using go to develop something for my work at NASA! I knew nothing about go a year a half ago. It didn't happen overnight. During my degree I did programming purely for data analysis and some basic scripting for quality of life work for my research. All in python. If someone asked me to write a program that did anything besides math, I would be completely lost at that point. That was almost seven years ago now. It takes time, practice, and what I consider the most important part, start doing things that are beyond your abilities. Because they aren't. I didn't know how to actually make a web app until a year or two ago. I knew what a rest api was, but didn't know how to write one. Don't be disheartened. Don't give up. Keep at it and it will eventually make sense. For some people it's easier. It wasn't for me.
What? .NET Core supports standalone builds. They are not a single file like Go builds are, but they work.
Which is why I said "not as good". I agree that C# / dotnetcore is a viable option and it'll become even better in the future because Microsoft is investing it in. And in some ways its better than Go, but in some ways it's not as good. Ability to generate a single executable that can be deployed by copying to a server is one of the ways in which dotnetcore is still behind Go. &amp;#x200B;
I guess. Is deploying a folder that much bigger of a burden over deploying one file? It just feels like something small to earn the description "not as good". It's just something to be aware of.
Isn't this going to be pretty slow if the cli being tested takes a bit to spin up? 
This article might help https://blog.dgraph.io/post/caching-in-go/. Basically, for the same memory, freecache provides higher hit ratios than bigcache whereas bigcache scales better, and has better performance than freecache.
I imagine the idea is similar to https://godoc.org/gotest.tools/icmd. However `gotest.tools/icmd` is more of a library to integrate with `testing`, where as commander seems to be a separate framework and test runner.
Well, it depends on your case. Benchmark for your use case. APIs are trivial to use, should be easy. Don't rely on Internet benchmarks, always benchmark for your use case. Resist the temptation to over optimize, before a need arises.
As someone who has/does both I would say that either one can be a great option for different reasons. Ultimately, it depends on your requirements, comfortability, etc... to echo an earlier comment, can you provide more context?
Are you a beginner at Go+Programming or just Go? What language do you come from? If you're experienced, I absolutely recommend The Go programming language by Donovan and Kernighan. If you're new to programming, try the online interactive tutorial that is built on the playground. If this is a bit too hard, try some simple Python courses. The REPL (Interactive shell-like environment) makes it easy to learn. The come back to Go.
Start by the Tour of Go. Then read Donovan/Kernighan. Note that the language is called Go (golang.org is the website and not the name of the language).
I swear by https://gobyexample.com — great well written resource that gets you into the language. Granted, I’ve always been a more project oriented person myself, and had some prior programming experience, but it worked wonders for me
Yes, you stated the difference. I tried different testing libs for go but if you want to test your app, for example in a docker container, you always need to setup a complete go environment.
Could you explain it a little bit more to me?
Great work! Off topic: Is that your dog on the book cover? :D
Thanks. The dog is from public domain photo collection. This is actually a collection of books (https://www.programming-books.io/index-grid) so I needed a way to generate a lot of covers that share a theme. So I chose puppies as a theme. 
I’m beginner in go. I Know C, C++ and Ruby. Thanks for your respinse
Let's say I have a cli that has some initialization time. It has to connect to a remote server or something. When commander goes through and tests wont the cli have to initialize fully for each test?
Yes and no. Commander executes every command from \`/bin/sh\` oder \`C:\\Windows\\system32\\cmd.exe\` and does not use you current shell. If your shell has still a heavy initialization commander would always executed it.
Quick overview: Tour of Golang A little bit more detail: gobyexample.com A lot more detail: GOPL by Donovan and Kernighan
Take a look at `net/http/httptest` package, specifically at Server type, you can start a HTTP server returning a mock data. 
Are you German? (:
This is awesome!
Yes :D
&gt;https://discuss.dgraph.io/t/the-state-of-caching-in-go-dgraph-blog/4157/7 Any update on your implementation of `Caffeine` bbased cache
Store them in a yaml file which the app can read into the data struct of your choice on startup.
Hi &amp;#x200B; Well, I have been checking that page and did this: func TestHelloHandler(t *testing.T) { ts := httptest.NewServer( http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) { fmt.Fprintln(w, "Hello, client") })) defer ts.Close() client := ts.Client() //res, err := client.Get(ts.URL) // Create a request to pass to our handler. We don't have any query parameters for now, so we'll // pass 'nil' as the third parameter. req, err := http.NewRequest("GET", "http://localhsot", nil) if err != nil { t.Fatal(err) } // We create a ResponseRecorder (which satisfies http.ResponseWriter) to record the response. rr := httptest.NewRecorder() handler := http.HandlerFunc(helloHandler(client, "http://localhost")) // Our handlers satisfy http.Handler, so we can call their ServeHTTP method // directly and pass in our Request and ResponseRecorder. handler.ServeHTTP(rr, req) // Check the status code is what we expect. if status := rr.Code; status != http.StatusOK { t.Errorf("handler returned wrong status code: got %v want %v", status, http.StatusOK) } // Check the response body is what we expect. expected := `{"alive": true}` if rr.Body.String() != expected { t.Errorf("handler returned unexpected body: got %v want %v", rr.Body.String(), expected) } } Basically, I have tried to create a mock server, then a client for such server and then made a request through the handler I want to test. The result was: {"level":"error","time":"2019-03-27T11:16:57+01:00","message":"Error en response: Get http://localhost/hello: dial tcp [::1]:80: connect: connection refused"} --- FAIL: TestHelloHandler (0.01s) handlers_test.go:38: handler returned wrong status code: got 500 want 200 handlers_test.go:45: handler returned unexpected body: got Error en response: %s want {"alive": true} FAIL exit status 1 I am not sure about the url´s I am using. My handler should call /hello so the mock server should be answering calls to that endpoint but I do not know if what I am doing is right... &amp;#x200B; &amp;#x200B;
You can register mock responders with "pre-cooked" response using this package: [https://github.com/jarcoal/httpmock](https://github.com/jarcoal/httpmock) &amp;#x200B;
This might help, it's called concurrency but it is centered around calling multiple websites. [https://github.com/quii/learn-go-with-tests/blob/master/concurrency.md](https://github.com/quii/learn-go-with-tests/blob/master/concurrency.md) 
Any suggestion for someone who knows only shell scripting attempting to Learn Golang?
Instead of the server, I've successfully used httptest.Recorder to record and test the response of handlers.
Here's my punt at some material [https://github.com/quii/learn-go-with-tests](https://github.com/quii/learn-go-with-tests) Good luck!
We have started working on it. I just created GitHub issues today. The repo is here https://github.com/dgraph-io/ristretto/. We should see some code in the repo soon.
Did one of those authors publish a C book by any chance?
Yes , Brian Kernighan together with Dennis Ritchie wrote: The C Programming Language book
gotour and go by example. And of course writing a lot of Go! Even if it takes a long time to do the most simple things it's still the quickest way to learn
I'll suggest you to have a look at justforfunc #16, https://youtu.be/hVFEV-ieeew Francesc Campoy is exactly showing what you're looking for. 
Is this available in an ebook format (e.g epub) would be nice to be able to view offline.
Campoy has a nice video for this https://youtu.be/hVFEV-ieeew
One of those books rarely anyone knows. By no means a legend :D 
I happen to use both more than any other language except perhaps Typescript or SQL during months I wind up on the data or frontend side of things. Since I have used both in professional and hobby environments, It depends more and my mood at this point. At the moment work tilts more towards C#, so my hobby work has tilted more towards Go, but I have deployed both to Linux as well as Windows and both are very enjoyable. If you know one more and one to learn, pick the one you know less. If you need to accomplish the job quicker, pick the one you know more.
Thanks for the help but it does not seem to be exactly the same. He is testing a simple handler. What I need to test is handler that calls another service. To be clear (and let me know if I am wrong) he is: \- preparing a fake response for the handler \- send a request to the handler and check the fake response &amp;#x200B; What I need to do \- start a fake server to mock my backend service \- prepare a fake handler with a fake response from such fake backend service \- prepare a mock request to be used by the backend client to call the fake backend \- prepare a fake request to call my handler \- do the request to my handler and let it call to the fake backend through the fake client \- check the results... &amp;#x200B; It seems far more complicated from what is explained in the video. Regards J &amp;#x200B;
You can use something like [apitest](https://github.com/steinfletcher/apitest). It will create the initial request into your handler and also mock out the external backend. If you want to avoid a dependency use the default \`httptest\` package.
&gt;https://github.com/jarcoal/httpmock Thanks for your help. I do not want to start to add more packages to my test when I am actually unable to understand and get running a simple sample.. :) I would prefer to keep it simple with the default tools and burn my brain to understand how the test works before add more tools. Regards J
I saw it but it explain a simple handler test and not a test of handler that needs to call another service. My case seems to be far more complex.
Yep, this would be the case, but my sister is an average user, she can't SSH into a server to edit a configuration file, that's why I'm planning to create a GUI interface for updating the data.
I think I do not get you. Seems your advise regarding the refactoring is going far from my current go knowledge. Is it wrong to pass the client to the handler? How could I replace it for an interface? &amp;#x200B; Thanks in advance J
Try [https://golangbot.com/](https://golangbot.com/) Walks you through how to do things topic by topic.
I agree with the OP here. I prefer the request validation to be in the handler and not middleware. Middleware is for cross cutting concerns. The request is specific to this handler so it belongs in the handler - it's more explicit and easier to reason about. I've seen middleware get overused on large projects and it's a bit of a pain to maintain.
It's only called Golang for SEO purposes on public websites, but the language is called Go :) As others have said, Tour of Go and Go by Example are quite good. The beginner resources on YouTube are alright but the series that pops up the most is by a Python guy who might confuse you because he keeps accidentally writing Python instead of Go... Otherwise a decent series. To wrap your head around concurrency, definitely watch Rob Pike's talk "concurrency is not parallelism". I would recommend watching a lot of his talks actually.
&gt; helloHandler(client, "http://localhost") is creating a handler which will access http://localhost as the backend service. Nothing is listening there. You should use ts.URL instead. (The servers client does not automagical direct all request to the test server.)
Might be easier to just make an Excel file with some macros or formulas.
I've been working on this for fun too: https://github.com/fwip/posix-utils I've been spending most of my time on `ed` - it's a lot of fun to write code to spec, sometimes.
I created a simple test suite you can fork and modify to test your specific load on: https://github.com/Xeoncross/go-cache-benchmark
Can't wait for GoLand to support that in breakpoints, too. So many times I've had to create a local variable (and then "use it") to hold the result of a simple function call to be able to set a conditional breakpoint...
💯
as /u/drvd responded, you need to use `ts.URL` since the test server uses random port every time it's created.
[removed]
Why not php or nodejs? I am pretty new to golang, but I have used php a lot and nodejs a bit here and there. It depends on what you are making and what it is for. # PHP * Tons of frameworks (this could actually be a bad thing I guess). * Fast to get started. * Cheap hosting EVERYWHERE Php has had a lot of speed improvements over the years, but since working with go the first app I rewrote in golang from PHP it could easily handle 10x the traffic. One great thing about php is how many resources there are for it. If you are worried about price because you need 10 devs on payroll... php is cheap and fast to produce. Great for mockups and beta version of web apps. # Nodejs Nodejs can be pretty useful, I mean html, css, js and that's it. You don't need to learn another language... Well I guess you will need to learn a few things about packaging and setting some stuff up and of course prepare yourself for the bottomless packages that are sometimes bigger than your whole project. &amp;nbsp; Node is pretty fast to write in and because it is basically js wrapped with magic tons of people know it and can help with any issue you have on stack. If you know js and have experience in other languages it is super easy to get running. I think it took me a long weekend to get a basic social media website working (edit profile, post on a wall, login, forgot password stuff, add friends, alerts that sort of thing, but super basic raw html, no css nothing fancy, some bugs here and there). # Golang Actually depending on what you are doing, in some cases go is pretty fast to write in even though I am still learning it. Really the only troublesome part is dealing with types int, float, string and probably learning structs if you are coming from js or PHP they can be a bit different... Not really harder just time consuming for the most part. If you know golang then learning isn't the issue. The issue might be price, hosting projects is pretty similar price for golang (hard to beat php thought, thats basically free for smaller projects), but finding devs in your area might be hard. There are tons of devs, but just clearly isn't as popular as php or js. &amp;nbsp; To make a basic server with some html webpages takes you 5 mins. Golang has some AMAZING libraries (net/http, database/sql, html/template). Just like any language you have to learn how to use them, but there is some good documentation out there. One thing I have found sort of sad is that there are not very many videos about learning golang compared to other languages, but the golang community has been helpful with questions not just on r/golang, but also stack and the other places. # Java &amp; Python I have a soft spot for java. One of my first big web apps was in java. if you are making an android app, using java makes a lot of sense by reducing the language count. I don't know if I would personally use it for anything web-based if I didn't have an android app though. There are just an equal number of good alternatives. &amp;nbsp; Sort of a similar answer with python. php 7 is so why spread and in many cases faster than python from my experience. I wouldn't really use it unless you needed for a special reason. # Perl ... Honestly, I haven't seen a perl project in a while, I know they are still out there lurking in the shadows... somewhere. Actually, I love perl, many of my first websites where perl before getting into php. But to be honest I have written and rewritten tons of webapps in both perl and php. Now days in php7 there is so little performance difference that I almost can't believe it. For that 0.0004 seconds difference using the more popular one would probably be a better choice. For finding devs, frameworks and so on. &amp;nbsp; There are still some nice libraries in perl that can be useful, but if it is a webapp it is hard to be the amount of code out there for php. &gt; In some tests according to [benchmarkgame-team](https://benchmarksgame-team.pages.debian.net/benchmarksgame/faster/perl-php.html) php is actually faster. There are other things to take into account, but php has made a lot of improvements. # .net I honestly have very little experience with this, haven't used it for... some time. The one problem I have with .net is how locked in you are... well in some cases. I just love the flexibility of node,golang,php,perl,python you can slap it on anything balls to the wall and just run with it... maybe I should have said just go with it hahaha. 
Hi I have finally got it working, thanks a lot for all the help. I have finally refactored my code -as advised- by creating this struct: &amp;#x200B; type HandlerOptions struct { Client *http.Client BackendURL string } &amp;#x200B; Then changed my handler definition as this: &amp;#x200B; // Handle hello calls returning uuid func (o HandlerOptions) helloHandler(w http.ResponseWriter, r *http.Request) { &amp;#x200B; And the defined my test case as this: &amp;#x200B; func TestHelloHandler(t *testing.T) { ts := httptest.NewUnstartedServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) { fmt.Fprintln(w, "hola") })) l, _ := net.Listen("tcp", ":9496") ts.Listener = l ts.Start() defer ts.Close() client := ts.Client() options := HandlerOptions{ Client: client, BackendURL: "http://localhost:9496", } req, err := http.NewRequest("GET", "localhost:8080/", nil) if err != nil { t.Fatalf("could not create request: %v", err) } rec := httptest.NewRecorder() options.helloHandler(rec, req) res := rec.Result() defer res.Body.Close() b, err := ioutil.ReadAll(res.Body) if err != nil { t.Fatalf("could not read response: %v", err) } if res.StatusCode != http.StatusOK { fmt.Println("Status code wrong") t.Errorf("expected status OK; got %v", res.Status) } fmt.Println("Paso 1") d := string(bytes.TrimSpace(b)) if err != nil { fmt.Println("error") t.Fatalf("expected an integer; got %s", b) } if strings.Compare(d, "hola") != 0 { t.Fatal("Dio 1") } } &amp;#x200B; Yes, I know, It aint perfect and I shall work it, but now is running and I finally understood what I am doing. So, thanks a lot! &amp;#x200B; Regards J
Yes, thanks, I know. I already fixed it and posted the solution in another message. Thanks a lot!
Well, finally I understood your advise. :) I already fixed it and posted the solution in another message. &amp;#x200B; Thanks a lot!
&gt; There tend to be fewer dependencies, fewer frameworks This is why I got into go from php. Php is a hot mess of frameworks right now.
Are any of these features exclusive to GoLand or are they also part of the Golang intellij plugin?
In Go plugin for IntelliJ IDEA Ultimate you could find everything that contains GoLand itself.
Jetbrains IDE’s have also seemed to me to be extraordinarily expensive unless you use it for work. Are they worth it for just doing side projects/learning?
&gt;Jetbrains IDE’s have also seemed to me to be extraordinarily expensive unless you use it for work. Are they worth it for just doing side projects/learning? &amp;#x200B; Depends on the language and your current experience with development in general. They offer a good set of certain features... that you will use once you understand them. 25€ a month for all their tools is certainly something, but not that much considering other monthly services. You can also apply for their open source licensing if you provide some kind of open source project and are an active maintainer / committer. &amp;#x200B;
In my opinion, absolutely, if you find yourself working on non-trivial projects. Like any other tool, you need to learn how to use them effectively, but I find myself far more productive in jetbrains IDEs, even compared to somewhat lighter-weight things like vscode. For smaller stuff I just use vim.
Great tutorial and a good practice. There are cases where vendor migrations can be more complex but I think this is a good practice to start off with.
The refactor, debug, and other ease of use features lead me to favor it over VS Code. By the third year, it's $53 / year, which seems pretty inexpensive to me. It's relative for anyone, but if you're a student or a core member of an open source project, it is free. If you aren't in a formal school and are learning to code while making minimum wage somewhere, I could see that starting to look a little pricey. In that case, I would recommend VS Code.
In addition to OSS licenses, I believe they also offer free or discounted licenses to students.
I do something similar based on [Ben Johnson's article about structuring Go projects.](https://medium.com/@benbjohnson/standard-package-layout-7cdbc8391fc1) It's really come in handy when I had to switch out a dependency recently. Adding extra functionality is a breeze too. 
Just to clarify, the IDE license price is $89/year or $8.9/month, depending on how you choose to pay https://www.jetbrains.com/go/buy/#edition=personal
I wrote a few blog posts https://marcofranssen.nl/tags/go/ didn't cover the httptest package mentioned in another comment,however I think these will help you as I wrote them at beginner level.
Not yet. It's on my long term todo list.
&gt; Are you aware of any write-ups or documents that go into more detail on this? I tried to google one up for you when I posted that, but I couldn't find anything clean. It seems like I'm having a harder and harder time finding this sort of thing in searches, lately. &gt; Was pretty much wrapping this up lol. Well, that's why I made sure to say this isn't useless. The problem is that people try to write the next Dropbox with it, where they have to recursively watch an arbitrary number of directories, and it blows up. But if you know in advance that you've got some bound on the recursion, this package can still be helpful. You just want to make sure to let people know that no, this package won't magically let them recursively watch 25,000 directories, and it's fundamental to the OS, not because your package is bad.
&gt; The *Rename* refactoring also helps rename methods declared in interfaces. When renaming such methods, GoLand will offer to rename their implementations as well. This is massive 😍 &amp;#x200B;
I will check. Thank you!
Bookmarked, thanks for the link! 
No, they are not worth for learning . Go has a great number of tools for editing, debuging, refactoring etc. They are all opensource and you can download them from github and use as you want. If you really want to learn hows this all works = stick to "unix is ide" philosophie: use vim with vim-go plugin. If you want write some code that works and doesn't want to dig in all this tools source code = use GoLand.
Well, zigging to a lot of other people's suggestions, in my opinion this is where you want to use "errors as values". Rather than trying to convince your net/http calls to return some specific value, wrap the API call behind an object: type remoteApi struct {} func (ra remoteApi) CallAPI(params...) (result, error) { ... } By wrapping it behind that call, and assuming it can't panic, you've reduced the possible state space of the return values to either some result, or some error. Now, if you either use dependency injection to inject alternate implementations on an interface, or even just hack on that object until you can force it to return a particular value. (Depends on whether you make multiple calls. If you only make one, I'll often go with something like type remoteApi struct { forceResult result error error } func (ra remoteApi) CallAPI(params...) (result, error) { if ra.forceResult != nil || ra.error != nil { return ra.forceResult, ra.error } // do real work here } This will require some refactoring. It is good refactoring and I don't feel bad about suggesting it. :) You'll also need to separately test that the method is returning the correct `result` for whatever the remote API returns. For that I generally suggest, again, not trying to use HTTP directly, but have a table of responses to desired object, and code that takes an io.Reader and returns a `result` object. Basically, you want to get to the point where the HTTP code is so thin that it can't really be wrong, because all the possibilities for wrongness have been moved out to other code that can be easily tested. All the "real" HTTP code does is the minimum to set up the HTTP API call and feed the response into the separated parser. While if you really work at it, the sort of code you've got there can be bashed into being testable, it's really a lot easier to break it into pieces and test the pieces, because the sum complexity of those individual pieces is _much_ less than the complexity of what it takes to try to abstract that entire environment out. The little tests will mostly be taking in io.Readers or something and emitting a test result out, whereas the whole abstraction could involve bringing up entire HTTP servers, etc.
And that's only if you decide to upgrade, love their license 
Very helpful thank you!! I closed the issue and I'm using this method now :)
They are absolutely worth it, just buy one and use the perpetual fallback license if it expires if you don't want to keep renewing
I thought there were small differences like debugging isn’t as advanced?
Free licenses for students. Pretty incredible for a company to do this with no strings attached. I'm a big fan of their products, especially Goland 
[removed]
As a student I'm using IntelliJ for free and it's boosting my productivity immensely. Especially the ability to embed Java modules inside a Go project makes it so you only have to have a single project for all your code. A single window open, all code accessible. And compilable and indexed. I love it. I'll pay once I'm finished here.
Not for Go. The plugin is identical to the IDE in terms of functionality. GoLand is however lighter as it does not have all the Java related features.
Agreed and me too! I use Goland everyday. The speed at which they’ve kept up with Go developments is very impressive.
60 euros for a full year is expensive?
See, I agree for some types of projects and disagree for others. For my personal smaller projects, vim or vs code is perfect. For work, goland is a life saver. Makes me much more productive large projects in an enterprise environment. And helps me onboard Java developers easily who are used to using an ide.
file.Read may return error (check it), but always returns the number of bytes read - wich may be less than the buffer size! This is where your math goes away. Also, instead of Seek+Read, use ReadAt.
Worth every cent!
&gt;I tried to google one up for you when I posted that, but I couldn't find anything clean. It seems like I'm having a harder and harder time finding this sort of thing in searches, lately. I tried the same. Really hard to search the lkml, you'd think they'd have a somewhat modern search engine. More proof I think that the kernel hackers are stuck in the 90's :P &gt;The problem is that people try to write the next Dropbox with it, where they have to recursively watch an arbitrary number of directories, and it blows up I'll admit I was one of these people. Initially did it with C, then Go. Go is a lot easier though, and I think I might still be able to make something work with some concessions made. &gt;You just want to make sure to let people know that no, this package won't magically let them recursively watch 25,000 directories, and it's fundamental to the OS, not because your package is bad. Yeah, I'll probably do benchmarks and display them alongside a warning in the readme. I really wish this wasn't the case though :( 
Is this a subliminal message? 🤔
Go with docker but be ready to use containerd as well. Rkt is not the mainstream solution, while docker and containerd are.
Thanks for the reply! &amp;#x200B; I did try ReadAt. // read at partBuffer := make([]byte, chunkSize) n, _ := file.ReadAt(partBuffer, int64(offset)) file.Read(partBuffer[:n]) But I kept on getting the same error. &amp;#x200B; What doesn't help is that the error isn't in the documentation. &amp;#x200B; I'll look at this again tomorrow. I'm going to intentionally break the php version to produce the same error and work backwards from there. Hopefully it produces something.
For one ide yes. I use more than golang in side projects and these are side projects/learning outside of work (c++ dev full-time); maybe they will turn into a job, but for now it’s just for fun! When there are pretty good community supported free options, $89/year for one ide is a lot.
How is the performance of jetbrains IDEs these days? the last time i used one was for python maybe two years ago and i just remember it being super bloated and slow esp compared to something like vscode. Is that still the case? 
Generating interfaces from existed structs - that's what i waiting for a long time. Guys, if you are missing autocomplete by value, vote for this issue: [https://youtrack.jetbrains.com/issue/GO-7024](https://youtrack.jetbrains.com/issue/GO-7024) &amp;#x200B; &amp;#x200B; &amp;#x200B;
That's a bit of an apples vs oranges comparison, i.e literally the most featureful IDE vs a text editor with Go support from dozens of third party binaries. Still, why not try it out and see for yourself?
*A* way: func TestHelloHandler(t *testing.T) { ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) { // Write the mock response... if _, err := w.Write([]byte("Hello")); err != nil { t.Fatalf("Error writing to w: %v", err) } })) defer ts.Close() res, err := http.Get(ts.URL) if err != nil { t.Fatalf("Error sending HTTP request: %v", err) } defer res.Body.Close() if res.StatusCode != http.StatusOK { t.Errorf("Got %d, expected 200", res.StatusCode) } b, err := ioutil.ReadAll(res.Body) if err != nil { t.Fatalf("Error reading response body: %v", err) } if s := string(b); s != "Hello" { t.Errorf("Got %q, expected Hello", s) } }
r/lostredditors
I'm very happy with the features of vscode and the plugins available for go. Was just interested in hearing some other opinions/experiences without taking too much time out of my day.
[Official playground](https://play.golang.org/), [different maybe better playground](https://goplay.space/)
Of course, I didn't mean to say you should switch or anything. I just suggested you should try it out personally since everyone has a different idea of what fast/slow enough means and it even depends on the machine you are testing with.
This is going to sound harsh, but what’s up with the easy-to-google questions? If you visit the official website https://golang.org/ you’ll see a yellow-ish panel where you can type code, and execute it online. It has buttons to “Run”, “Share”, and to visit the “Tour”. Then, if you click the “Pop-out” link in the top-right corner of that panel, you will be redirected to the official Go Playground — https://play.golang.org/ This is very passive aggressive, but please read this: http://www.catb.org/~esr/faqs/smart-questions.html
It's common for companies to do it because they know you'll use a free IDE while a student, but also know that you'll get your employer to buy you a license for the IDE of your choice outside school. It's a good business decision that's a win for everybody.
The "bloated" part of the IDE you may have encountered is due to IDE indexing all of your project files at start up. It needs to run it occasionally, but after the cache is set up it runs smoothly. And generally, in my experience, faster than VSCode.
This is awesome. Since you said that, I am trying it out! I wish more tech conferences did this.
"All Products Pack" subscriber here. USD$25 per month is totally worth it. I use at least four of their products on a daily basis and a couple others occasionally. I'm a convert.
No, it's not indexing. I used jetbrains ide(for ruby) before and it works slow as hell even after indexing. 
Then " The Go programming language" is probably what you want.
It’s worth every gorram penny. Great job!
I wish there was a way to also change the signature of an interface and have that affect all implementations as well.
I'm using VS Code, but I'm so into testing it... Hehe. Will see if company can buy one for me!
Interesting, I thought JetBrains had deprecated the Go plugin to push people towards Goland. I think that was their stance for a while, I remember being really annoyed by it because I use IntelliJ for Java, Ruby and Python.
Never use any ide before. What is the reason to use ide like goland instead of normal vscode with the go extension? Im just wondering from the [features page](https://www.jetbrains.com/go/features/), it list capabilities of handling JS and DB as well. I thought jetbrain have other IDE specialized for that like [datagrip](https://www.jetbrains.com/datagrip/?fromMenu) and [webstorm](https://www.jetbrains.com/webstorm/?fromMenu). Any significant difference when using goland to write JS and interact with DB instead of using those particular specialized IDE?
I only had this experience like 4-5 years ago. Nowadays hardwares are cheap, also they tuned it. Use Pycharm perfectly fine for over 3 years now.
Wow this is almost as good as VSCode except you have to spend money to use it.
Speak for yourself
No not at all
Incredible? I don’t think so. They just want to keep students from learning other ide’s so when they join the work force they will ask their bosses to pay for jet brains stuff
Vscode is impossible to setup so that hovering above local vars shows their type. Please tell me I'm wrong.
Loads of tech companies do this. There is nothing spectacular about it
Great questions. Goland doesn’t really offer anything important that you can’t get VSCode or emacs to do.
You are wrong 
What do you do to get it working, starting with default vscode config?
I'm imagining you press "Refactor" button and it submits dozens of pull requests on github :)
He was, idiot.
I'm the lead maintainer of [Modern Honey Network](https://github.com/threatstream/mhn) and it uses a project called [Honeymap](https://github.com/threatstream/honeymap) that is written partially in Go. Firstly, if you just run `go fmt` on the go files and submit a PR, I will surely accept it and merge it in. Other than that, the code itself is old, uses an old library (hpfeeds), and could be restructured a bit. If this interests you, please feel free to contribute as you see fit, or PM me and we can discuss more about this project and specific needs I've found.
I’m using it for rust with racer and it works. I’m sure there is something similar for golang.
Oh. Don't say I'm wrong, then. ; )
You know you aren’t speaking to idiots. You can try all these IDEs for free. Sounding like you know everything because you use VS Code isn’t proving anything. Just makes you look like a dick. FYI. 
This comment is just like the one you made in the other thread. 
Oh look a jetbrains employee calling people a dick.
This post is just like the hundred other Jetbrains spam post you people post everywhere. Just pay for ads.
How crazy do you have to be to believe fucking Jetbrains has a conspiracy against you. 
Is it just me or did they really change the font? It looks...*thinner*.
The text looks *thinner* for some reason. Any idea why?
I have had zero issue with go in vscode with type hovering for local or global types. I'll look at my conf in a bit. I just had surgery tho so I'm high af on pain meds and might not remember so feel free to pm me for details if I forget.
I have used jetbrains IDEs for many years and also VScode... But I haven't even tried goland yet as VScode has been smooth sailing for me for a while once I got it all set up to my liking. Are the added features of goland enough to convert? Also, this may a dumb/small issue, but on Linux (Ubuntu 18.04) in 4k my jetbrains IDEs don't look 'right' (bad font scaling, etc.) and ive lost days of work trying to adjust them... vs VSCode, which just looks great in any res for me. If they fix that... Might help convincing me 
Memes asside... PHP performance can be decent but if I had to go back to my PHP days I would hang myself. 
What would the request load on the apis be? How will it be hosted? How much IO read/writing will there be? How many threads per request? How quickly does it need to be built? What systems does it need to plug into? What's the stack? Make sure you look into modules that support your stack for go or you may be building support / modules yourself (and maintaining them), go is growing but a lot of other languages have established modules and libraries that go doesn't have yet (or ones not still in early dev / beta) which may change your mind. We use a lot of Go and Python. Python mainly for AWS lamda / serverless (yes I know lambda supports go now!). Go for our larger apps that make heavy use of go routines for IO bound tasks. I will say that for light weight APIs python on AWS lamda with flask and Zappa has served us very well, esp with raw dev hours and cost. For everything else It's Go... (and some legacy php apps that I'd rather not talk about).
Pay peanuts, get monkeys. The username fits.
Need a video series explaining the good features and how to use them. Might switch from VSCode
Worth every cent.
VSCode's shine is starting to wear a bit for me. I'm finding the quality of extensions to be not so great. I started coding Go in vim using vim-go but switched to vs-code in my new workplace to fit in with my colleague's set-ups. I'm using the beta version (0.9.3-beta.4) of the go plugin with the bingo language server and it seems a lot less functional/stable than my old vim-go setup using guru, as far as refactoring goes. Maybe I'll give Goland a whirl again
Try emacs
Now I KNOW you must be a troll ;)
Accend friend. The lisp can do anything 
Some starter project ideas: Live chat with persistent history of last N hours... eventually adding encryption à la signal or telegram but obviously simplified just to learn encryption / security with go. Web crawler that can search an entire site for a given string or regex expression (but don't DOS a site which is very easy to do accidently with go). A simple system monitor that will poll your system for stats (mem, hdd, temps, cpu / load avg) that sends an alert via email for warning / critical. Will teach you how to use the os module and running system commands. To learn about GC and some other more advanced topics writing your own "simple" caching system is a great way to do it. Rewrite the go core to support generics /s 
I think most of the wrappers are either not safe or not efficient. Check out the README here https://github.com/grandecola/mmap/
This is part of the update as well. Change Signature refactoring will also update implementations.
No, GoLand is basically WebStorm + DataGrip + Go support.
I'm not sure if I can help you here, but please open an issue on the tracker https://youtrack.jetbrains.com/issues/Go and my colleagues will be happy to help you out.
Have you tried to open an issue with our support? We are generally pretty fast in replying/sorting out issues and maybe we can either solve this or register a bug and work on it. You can submit and issue here: https://youtrack.jetbrains.com/issues/Go
I just want a really great Mac native Go IDE.
The one sort of boring project I've done already is an IRC bot with a web front end and DB backend to store quotes and such and some other features built into it. I've gotten a little bored with it though. 
Looks like it’s grabbing a bad version of x/sys. Try reinstalling golang if you’ve recently updated it. I got very similar issues when upgrading from 1.10 to 1.11. 
By index.js so you mean a node app? 
I don’t know if they would find value in a CI pipeline for every project. For a few that are centered around CI pipelines, it definitely would be, but not every one. Instead, you could just use the standard Go tests and then the beginner could simply run the tests. That way it all happens on their desktop and their failures aren’t made public for everyone to see in the CI pipeline. Remember that one of the biggest hurdles to using something like a tutorial is the barrier for entry. If they’ve gotta create a GitHub account, clone a repo, and then pull it correctly, edit code, push the code, create a merge request, wait for the CI pipelines to finish, click around to see if the test passed, it’s going to be far too much work. Instead, if they can pull, edit code, and then “go test”, it’s a lot more accessible. It would be great for a sandbox for that as a tutorial, but I would shy away from it for every tutorial. I certainly would have liked to have had some experience in CI pipelines before my first pull request to a public repo with Travis CI. 
How I Can to import the oficial Go playground into iframe with custom code init?
If you stick to the EAP versions you can use every JetBrains product for free. You get every new feature earlier but in some cases you have to deal with bugs. It is a double edged sword but for FREE.
Maybe your machine is too weak. I see this being thrown around rather often, but really can't relate. As the only time I had that problem was on my laptop. Where I run vscode now for very same reason, because I can't run anything better on it. And after jetbrain vs code for sure feels like a downgrade.
&gt; How I Can to import the oficial Go playground into iframe with custom code init? JsFiddle uses `&lt;iframe&gt;`, why don’t you use the same for Go Playground? &lt;iframe src="https://play.golang.org/p/7vin2BK8_A6" width="400" height="200" frameborder="0"&gt; &lt;/iframe&gt; Here you can see an example: https://jsfiddle.net/L9m26tbq/ 
That is true only if you work with small scale hobby projects or the programmer in question is a beginner.
Spoke for me!
You have a debug flag enabled that echos shell commands as they're run. Check `:help vim-go` (search for `debug`) and your vimrc.
Yeah, I would say it is great for simple projects. Maybe 1 or 2 page things like a js minify thing or whatever, but when you get into huge projects just the scaling gets crazy and can even be worse depending on the framework.
Thanks, is useful response. 
[mimetype](https://github.com/gabriel-vasile/mimetype) is a Go library for MIME types detection based on magic numbers. You can check the issues tracker to find instructions on what problems need help.
man do what you are doing. Im really enjoying getting news about golang via your newsletter. Keep up with the good work!
This thread seems like a promoted one. I'm still using VSCode simultaneously with IntelliJ Idea with the Golang plugin and i'm ok with them, so i'm not considering to buy such an expensive product being even a good IDE.
I tried upgrading from 1.11 to 1.12 but it didn't work. I don't want to completely reinstall go because I have a lot of repos cloned into my gopath with stashed changes that I don't wanna lose. Is there any other that it can be done? can't I just upgrade the sys package using go mod or something?
Nah those are generally included in the install. Fortunately tho, your gopath is separate from your go install. So you can remove the old go and then reinstall it without touching anything in your gopath. 
This is a thread to let Go users that we have a new release out and allow them to discover our features or give the IDE a try. It's posted by my colleague and it's not in any way shape or form a paid thread. We do pay for ads here and in other places, but that's unrelated to this topic. As for using IntellijJ IDEA Ultimate + the Go plugin. Congratulations, then all the features we mention relate to the Go experience are also available in IntelliJ IDEA Ultimate 2019.1. As for pricing, please let us know what would be a better price point than the current $89 in first year and then $53/year from the third year, with a full perpetual license, https://www.jetbrains.com/go/buy/#edition=personal I hope this clears things up.
Very fair, I'm tempted to leave the CI stuff in even if people don't look at it, it gives me a good indication as to what tutorials are breaking when new versions of the language come out (not that it happens often with Go, but for other languages). So I guess the flow I would go with now is - 1. Fork the Repo 2. Switch to challenge branch and get tests passing 3. Commit to your forked repo And for those that don't want to use Git, the text version of the tutorial is going to be followable without having to go through additional steps. &amp;#x200B;
"Too weak"? I don't think that mbp with i7 and 16gb ram is weak. Vscode works perfectly. Even atom works better if you know what i mean. After many years in IT i can say - even Netbeans end Eclipse IDE's works much better even on on old hardware, but jetbrains products run like turtles on top-tier hardware. &amp;#x200B; And okay, an example of "what i mean slow" - when i press cmd+p (probably jetbrains has another hotkey for it), ide opens search-by-filename window. So, i press cmd+p in immediately start typing something that i need to open. Any editor - does this in miliseconds. Jetbrains - lags for a second or two and lose all stuff that i expect to be typed. After indexing. God, even facebook search works faster.
If you have problems with any of the latest 2019.1 released IDEs, could you please spare a few minutes and help us track them down and fix them by opening an issue on our tracker? https://youtrack.jetbrains.com/issues/Go for GoLand or https://youtrack.jetbrains.com/issues/Ruby for RubyMine, and so on. Thank you.
little confused on what you mean by reinstall. When I upgrade golang I just delete my goroot and unpack the new one from the tar.gz into the same directory. My gopath remains untouched. When you say it would require reinstalling go but my gopath is separate it is kinda confusing because the package sys is in my gopath/pkg Do you mean completely removing everything and reinstalling again but pasting the $GOPATH/src directory after reinstallation that I currently have to retain all my projects?
Hm x/sys should be installed as part of the go install itself. I would clear out the cache and try that. It does look to me like the x/sys files are in some way corrupted. 
&gt;https://github.com/dgraph-io/ristretto/ Finally, well done .... let me know how i can help. 
This is are sys directories in my $GOPATH/pkg/mod/golang.org/x/ directory sys@v0.0.0-20180627142611-7138fd3d9dc8 sys@v0.0.0-20180820145501-1a700e749ce2 sys@v0.0.0-20180909124046-d0be0721c37e sys@v0.0.0-20181029174526-d69651ed3497 sys@v0.0.0-20190215142949-d0b11bdaac8a &gt; I would clear out the cache and try that. and try what? do you mean just delete all the contents of my gocache directory?
I'm using hashicorp's go-plugin. The main motivation is to factor out db-facing error prone extras to a separate program, and keep the core functionality rock solid.
I am currently writing a simple mattermost bot in golang and I wanted to provide a simple way for people to extend the bot via plugins. &amp;#x200B; I actually tested go plugins as well as hashicorp's go-plugin. For me it felt that go plugins are easier to get started initially, with go-plugins you need to understand how the communication between the main process and the plugin works. After playing around with both I decided to use go-plugins as it was easier for people to actually develop their own plugins. 
sqlx really is amazing. It still doesn't make things as easy as in, say, the Java world, but it's much more reasonable than plain database/sql.
I played with plugins when they came out, they has some issues (they needed to be loaded in the main file -not in a package-, couldn't be _unloaded_,... ) not sure if it's different now, but at the time it wasn't what I needed
Hey! I've opened an issue to discuss about the subcommands feature: [https://github.com/celicoo/docli/issues/10](https://github.com/celicoo/docli/issues/10) &amp;#x200B; I would love to know your opinion about it.
Makes sense. But it sounds like Goland has all the tooling configured out of the box right, instead of having to set up your Go tool binaries like gofmt for VS Code?
I had issues getting the Go extension for VS Code to work until I turned off Go Modules by flipping the feature flag environment variable.
An you get that stuff by just opening a go file
Used it recently in a project. I like. 
I like sqlx, but I like gorm too... it works as well.
Cool video What program was he using at [2:51](https://youtu.be/ynUUGWvqA4c?t=171)? It is some type of GUI to run REST queries.
It's [Postman](https://www.getpostman.com).
Besides having all the tooling needed self-contained, GoLand also has features that are not currently available in any other editor, such as built-in profiling, all the debugger changes in this release, about 14 different completion features, see https://blog.jetbrains.com/go/2019/01/17/code-completion-in-goland/, refactoring support (Change Signature, Rename, etc), instant search for/in files, and many other features I talked about here: https://blog.jetbrains.com/go/author/florin-patanjetbrains-com/ Also, our support is always happy to help you, regardless if you are a paying user or not, for us what matters is that you are as productive as possible when using our tools. My suggestion is to give it a try, see if you like it, and if not maybe give us a feedback on what we could improve in the future.
[removed]
[removed]
If you pay yearly, the subscription price is USD$249 for the first year, $199 for the second and $149 for all following years. Might be worth it for you if you pay for it anyway.
Any feedback would be very much appreciated. There's definitely a LOT of room for improvement.
They have an overview video here, which fast tracks through a couple of the features: https://www.youtube.com/watch?v=DlF6EJurb88
If you do like playing with bots, I am writing a framework for discord bots: &lt;[https://github.com/andersfylling/disgord](https://github.com/andersfylling/disgord)\&gt; It's written from scratch so it doesn't rely on discordgo. It's around 20k loc at the moment, but I would love some help with "go generate" to generate all the constants from the discord docs (markdown files), and in the future the data structures. If this is something that may interest you, feel free to PM me, open issues/PRs.
Another thing to note is that go plugins are linux/macos only at the moment. Not sure if that would also affect your decision. There is some work underway for windows (https://github.com/golang/go/issues/19282) but I would suggest either go-plugins or maybe having the client compile them in.
Not a bad extension, it is something between pure evil and ORM. Some nice extra features. Recently used in project. 
If you get IDEA and add the Go plugin you get the functionality of Goland and also support for Java, Ruby, JavaScript, etc.
Something's wrong, then. IDEA works fine on my 2013 MacBook Pro.
Definitely needs a lot more documentation.
What are all the red X and green "V" you see after a test? the t.Error statement? if so what if there are +20 t.Error statements?
Ohmygod! You haven't installed postman yet?? What are you waiting for? XD
I propose it to use in every project I'm involved in.
There are a bunch of libraries out there, but I think this one would help: github.com/metaleap/go-xsd It requires TLC for 1.2 support though but you could also try github.com/ivarg/goxsd
I can't recommend anything specific, but there are a ton of options out there via Google which all seem to work a little different. I'd recommend taking some sample data and trying them all out to see what produces the structs closest to what you want.
You can always use reflection package main import ( "reflect" "encoding/json" "io" ) type CommonItem interface { Validate() Prepare() } func WriteCommonItems(w io.Writer, items interface{}) error { v := reflect.ValueOf(items) if v.Kind() != reflect.Slice { return errors.New("recieved non-slice value") } for i := 0; i &lt; v.Len(); i++ { item, ok := v.Index(i).Interface().(CommonItem) if !ok { return errors.New("slice element doesn't implement CommonItem") } item.Validate() item.Prepare() } return json.NewEncoder(w).Encode(items) } 
Those are Check Marks and Crosses to symbolize the success or failure of the individual assert (Is) statements. If there were a lot it would flow onto a new line. It's a good point. It'll be fun to come up with a nice solution. :-) 
[removed]
We use Go plugins an a closed-source product at $dayjob. There have been a lot of headaches with it. I'm not sure it was the *wrong* decision to support plugins, but if I could tell 2-months-ago-me what I now know, I would have been a lot more hesitant to say "yeah, we can do that". It seems that the intended us-case for plugins is *in-tree* plugins; when you have code you don't want to always include in the main binary, but you have no problem with it living in the same git repo and getting compiled at the same time. It does *not* seem to be a good way to let users/customers add in their own code; there are headaches if you try to use them that way; they have to sufficiently emulate your environment when compiling the plugin: - The plugin compiler version must exactly match the program's compiler version. If the program was compiled with 1.11.4, it won't work to compile the plugin with 1.11.5. When distributing a program binary, you must communicate what the compiler version you used is. - Any packages outside of the standard library that are used by both the plugin and the program must have their versions match *exactly*. This means that when distributing a program binary, you must communicate the exact versions of all dependencies; we accomplish this by publishing the output of `GOOS=linux GOARCH=amd64 CGO_ENABLED=1 go list -deps -f='{{if not .Standard}}{{.Module}}{{end}}' ./cmd/the-program`. Plugin authors will need to pin those versions in their `go.mod`. - The plugin must be compiled with the same `GOPATH` setting as the program (even if using modules). This means that our users who use plugins must set `GOPATH=/home/circleci/go`, even though they don't have a `circleci` user. - In order to work on things like Alpine Linux's musl `libc6-compat`, everything must be compiled for compatibility with LSB 3. Setting `_FORTIFY_SOURCE=2` with GNU libc causes the CGO 1.12 runtime to require LSB 4. Several distros (including Ubuntu 14.04, which CircleCI uses) patch their GCC to define `_FORTIFY_SOURCE=2` by default. When compiling plugins, users/customers may need to fuss with setting `CGO_CPPFLAGS` to make things not fall over. - Because plugins use the libc dynamic linker, they force CGO_ENABLED on; cross-compiling is no-longer easy to do. Someone wanting to compile a plugin for the GNU/Linux program binary from their macOS workstation must compile the plugin in a VM (or Docker, since Docker for Mac runs in a VM).
There's also https://insomnia.rest
So many people misunderstand what the plugins can do today. They don't currently easily enable 3rd parties to make plugins for your app; the compilation environment needs to be *identical*, so in practice only the original build system can reliably build the plugins. The issues are full of people finding all the little differences in their build environments.
sqlx feels like the perfect Go thing to deal with databases. Been using it for the last couple years, just writing SQL queries to get stuff in/out of the DB, and it’s great. An ORM would be out of place in Go.
There was an open issue I saw that matched my complaint. I'll check again though. Thanks! 
I like the idea of branches with failing tests. Its a simplified version of what actual development can ressembles
Looks nice, but ironic that it's written in D and not Go
[removed]
I think you should characterize what you think a beginner is. Envision, in your mind, who that person is. Are they someone that has a high school degree? Are they 10 years old? Have they programmed before? For example, let's start with this sentence: &gt; The first thing we’ll need to figure out is, how do you declare a function within a go program? OK, so usually, if you're aiming at a beginner, you have to start with "What is programming? What is a program? What is Go? What do I need to program?" And even if you figure they know some of this, then you have to wonder "What is a function? What does declare mean? What does a Go program mean?" and so forth. This is one reason it can be painful to provide a resource to a beginner. Indeed, when you see, let's say, a tutorial on a framework (like Angular), you rarely see it aimed at a true beginner whose never used some web framework before (so, you don't see an explanation for the basic architecture of a typical web framework is, what a router is, what MVC is, how a framework typically implements it, etc.) They just assume you've seen another one, and skip to the details that are specific to that framework. I recall a talk by Guy Steele once where he tried to build the talk based on "axioms", that is, a few defined terms, and then he'd define terms off those terms, and so forth, (maybe he assumed you know definitions of one syllable words, and then defined multi-syllable words off those, and then more multi-syllable words off those). The idea is to think about where someone might start and what they know, and then add to that, and so on and so forth. (I've tried writing beginner stuff, and you end up having to go over really tedious things you feel you don't have to explain, but do because you're assuming too much).
Thanks for the heads-up. Please note that it's sometimes safer to just open an issue and the support team will deal with it as it.
It's a really good library. It's definitely an improvement and solid evolution on top of the core database library. But there are some things still missing for me. There is no support for bulk insert/ update operations. And not much for query building support too. Since we use postgres as our db. We tried go-pg and love it. It has the bulk support, query building, schema migration tools, etc that I want and need. What is really nice about sqlx is that is it database neutral. But you miss out on some db specific features.
I'm using them but the main reasons were to avoid intimidating people with the main code base and so that plugins could hypothetically be licensed differently than the main code base.
I find insomnia to be better. Both are solid though, way better than using curl to debug REST calls lol.
to me, the idea of not being able to use the latest version of my software is too unbearable
Have you compared debugging in Goland vs VS Code? The improvement is notable, with much clearer variable inspection possible. Also, Goland is much better at providing intellisense when there is an unresolved error somewhere besides being faster at showing suggestions. Finally, rename works, which I've never gotten to work in VS Code.
This is excellent feedback and exactly the reason I posted this in the first place, so firstly thank you! These are certainly things I'm going to be taking into considerations as I go about improving the tutorials already on my site. I do realise that there has to be a balance in terms of explaining enough for absolute beginners to latch on to and not causing issues with the programmers coming into the language for the first time. I'm going to see if I can come up with maybe a way I can accomplish both with like hover-ables that explain key terms at the start of an article, or having a glossary that people can reference which explains things in more detail.
I've used gorm for a few medium-sized projects and tbh by the end of them I wish I'd just gone straight for SQLX. I like what gorm is trying to achieve but I found it got in the way more than I liked.
&gt; And not much for query building support too. I'd strongly recommend [squirrel](https://github.com/elgris/sqrl) for that.
Beyond that, you probably need to have an elevator pitch. That is, explain what kind of person should be learning Go. Sometimes, a person is learning, say, a second language, and they go shopping for that second language. Under what circumstances should they learn Go, and under what should they look for another language. Like someone might ask, should I learn Go or Rust, or even Go or C, and why.
then pay for the newer versions - all I'm pointing out is upgrading isn't a requirement, it's just an option. Don't force upgrade if you don't need the features yet.
Just curious. Did you consider using a embeddedable scripting language like https://github.com/d5/tengo?
I love how all you Jet Brain Shills get automatic upvotes. Is this your marketing departments strategy? Post every update to reddit and pay for mass upvotes? Disgustingly manipulative. I won't buy a product from a company that participates in that kind of behavior 
I prefer VS Code.
When something has X in the name I automatically like it. Mobx, sqlx
Anyone has some longish time experience with sqlboiler? I'm thinking about using it in an upcomming project but I'm still undecided...
x/sys is certainly not part of the go standard installation and has to be downloaded separately.
you can keep your gopath sources but delete the mod cache in $GOPATH/pkg/mod have you tried `go mod download`or `go mod tidy`in your project directory?
Exercism?
tidy worked thanks so much
I really hoped to use them in [Benthos](https://github.com/Jeffail/benthos) but given the technical limitations they have it's almost guaranteed to be easier to just compile your own plugins into a fork or build a custom main function and use Benthos as a library. I'm retaining a small amount of hope that one day they will be more flexible, but I don't know of any ongoing work to make that happen.
Plugins were always a tech demo, or half-baked feature. You shouldn't be using them for anything important.
I think we need more examples of things going bad with Gorm; beginners (or even me) can't really imagine what goes bad until it happens, etc. Maybe then Gorm will even add to the docs: don't use if you're trying to do this, that or that with SQL..
I wouldn't say it was _bad_, just that I'd feel things would be quicker and more effecient going direct to SQL than messing around with what Gorm provides. I like what Gorm is trying to achieve and can absolutely see the use for it, it's just not for me. 
It's nice, I like it. Used it in a few projects over the years.
`go mod tidy` solved the x/sys error but I am getting a new one for another package now. # github.com/miekg/dns Dev/Projects/golang/gopath/pkg/mod/github.com/miekg/dns@v1.1.6/scan.go:436:29: string not terminated Dev/Projects/golang/gopath/pkg/mod/github.com/miekg/dns@v1.1.6/scan.go:436:44: syntax error: unexpected EOF, expecting comma or ) when I tried go get for this package I got the same error, I dont have this package in my gopath neither do I have it in my cache directory.
Yes I find it to be comparable, many times better. I am able to rename variables best in emacs. Another free text editor.
The gorename tool already doing that
I'm of mixed opinion on this. It's nice to have choices. But I also feel that sometimes people create just another option that doesn't really offer much difference, just because they felt this one thing was missing. Now you have 10 project all doing basically the same thing, when 5 of those people might have been able to put that same effort into contributing to the 5 other project to improve them. It's like all the http routers and web frameworks. So much overlap. With this project in particular, while I think the documentation approach is interesting, I wonder if it wouldn't have been better to announce it after you had at least close to feature parity with any of the existing usable CLI/flag packages? 
Yes, this was actually my first idea - I had a look at lua for golang especially. Personally I didn't like the feel of it and it feels like I have to try to implement too many features to be able to work properly. With grpc it is possible to use different programming languages in your plugin and therefore limit the user as little as possible. 
&gt;In the other hand, Docli parses a doc string (that you write following some basic rules) into an AST, that it's used to be bind with struct fields - that flexibility comes with a cost, which is losing the type safety. So in your opinion, this trade off is worth it? Is type validation not a pretty big feature of a flag package? Does it mean your project will leave it to the user to check the type of each flag and arg and do necessary conversions and error messages? 
https://github.com/osstotalsoft/bifrost this is my own implementation of an api gateway, with service auto discovery from a kubernetes cluster 
Tried but it has too much drawbacks. Right now I'm compiling the plugins within the project, they are imported/initialized using Go templates.
Thanks for sharing. These are really harsh unpredictable constraints. 
Package manager, that is the real question
Go modules, that is the real answer(?)
I moved to writing Go full time about a year ago (after using it for personal projects for a couple years while working as a dev using other languages). Since learning how to use interfaces properly, I’ve missed generics a grand total of zero times. I’m now at a Java-heavy company that acquired my Go shop and find myself explaining Go’s way of doing things often, and folks tend to fight me on it rather than keep an open mind about doing things a different way. Idk the author of this tool but given my experience, my hunch is it’s a D dev that decided to create a tool to make Go conform to the style of other languages rather than learn how to utilize interfaces and templating etc. properly. Granted, it takes a shift in thinking, but I look at learning a new language like visiting a new country- open your mind to how they do things.
ELI5 “why should I use goland if in my daily job I used vscode with sublime settings and have many languages to support where one of them is go” ?
Good to see VSCode and Goland take the top spots, well deserved. Almost 10% decrease in confidence in the Go team is very unfortunate, but not really surprising. I'm assuming the way the whole vgo vs dep situation played out really left a bad taste in some people's mouths. Still, wherever dependency management is this time next year, I'm sure it'll be better than what we have now.
you the man! that was it!
I very much respect your choice in text editor. It isn't for me but those who are good at it are amazing
My posting history makes it pretty clear that I am not affiliated with them and am a real account. I'm just as much of a fan of VS Code and Visual Studio, but for other languages. It's okay to have lots of enthusiasm. 😋
I hope `gopls` (official LSP server) gets stable soon. Community implementations are struggling to follow all that modules confusion...
I think there just is not only a lot to new ways of programming that come from go but also a lot don't become apparent until years later.
I'd say it's more about some people resisting to generics
Funny, I think the people most disappointed at the current generics situation ("contracts") are the people who *want* generics. At least that has been the case for most people I've talked to in meetups and conferences.
I wrote a library that could load grpc services from compiles plugins but ended up rewriting it because it was too hard to deal with managing plugin dependencies/versioning. Not worth it in my opinion. 
[removed]
Hi, I'm the author of this tool, and also a professional video game developer. I program mostly in C++ and C#, so clearly Go is not my favorite language, I must admit it ;) I've actually implemented this tool to be able to use several Crystal features which I really missed a lot when using Go for my web related developments. Obviously I could use interfaces and reflection for everything, but generics and modules can be very convenient, and the generated code runs often much faster than its interface/reflection-based equivalent. And if you wonder why I've used D to implement it, it's just because that's by far my favorite scripting language :) Much better than JavaScript, Ruby and even Go, so since several years I use it to implement almost all my command line tools.
This is planned :)
[removed]
&gt; FYI, to reproduce, just call a func that allocates a large integer slice. Watch memory spike, then when func exits, it gets garbage collected off the heap, but that doesn’t seem to be freeing back to OS. How large?
If you're not reading till `io.EOF` then there might be a small amount of usefulness to doing so, to prevent anything else reading from it. But if you're reading till `io.EOF` then it doesn't matter.
In this particular case we are reading the entire stdin.
If I need to do those things I just program in Rust instead of golang. Emacs + Rust is far better at all the things you mentioned.
My messaging service, which I'm working on for a while and which I use in private projects, got a new code structure making the handling of messages much easier to understand. I also added regression tests and changed to my own logging framework (instead of simple and dump log-functions). Take a look and feel free to give me feedback and your opinion.
Thanks for the info I'll try it out.
Me too. My company’s primary blocker for modules is losing all the tooling. 
It depends on migration tool that you use. I don't know of any migration tool that would allow you to keep everything in one file. I would suggest to keep one file per migration. It is will make it easier to go back and find exactly what was changed. It make sense to have you most updated schema in one file. I use [dbmate](https://github.com/amacneil/dbmate), its easy to use and will dump the schema after it is done with migration. 
Without knowing how exactly are you measuring "memory usage", what OS, what tool, what are the exact numbers, etc. it's impossible to say if that's intended behavior or maybe over retention bug in your program or maybe you're not interpreting the numbers correctly. Accounting for process memory use is a subtle and complicated topic and it's easy to draw an incorrect conclusion. Also, consider that not releasing memory right away can be the right thing to do for performance. While it might feel that releasing memory immediately is the right thing to do, if other processes don't use memory then releasing memory to OS and then requesting it back is more expensive than holding on to it for some time so the allocator can be faster by doing that. 
Go module mirrors (aka public proxies) will solve that problem. see https://blog.golang.org/modules2019 And https://github.com/gomods/athens
Not sure what you're asking. If you just want separate releases and VCS repos, then just set up a separate repo just for releasing Go packages and set up a build script that squashes all of the commits for a release into one and pushes it?
Does Gorm make the mapping between JSON payloads via a RestFUL interface easier to INSERT / UPDATE into the database? I.e. mappings are done automatically instead of explicitly naming them here? https://github.com/kaihendry/GoApiTutorial/blob/master/model.go#L31
I would recommend anyone reading this who uses Goland on mac OS to wait for another update to upgrade to the latest version, I updated from 2018.3 and have been having a major issue with lag on 2019.1 , it's reporting false positives on errors and takes an IDE restart or opening and closing the file that you are working on for Goland to fix them. &amp;#x200B; No such issue exists in the previous version to my knowledge , and it could be something particular to my installation, although I doubt it , as all I did was update from the previous version without changing anything.
&gt; sqlboiler ORMs feel weird to me.
Not sure I understand your question. Here is an example of a project written in golang that is both a compiler and llvm. https://github.com/golang/go/wiki/WebAssembly
Uncaught TypeError: root.createSVGPoint is not a function at getEventPoint (dotgo-paris.html:7994) at handleMouseWheel (dotgo-paris.html:2854) I can't scroll
You can use transactions: begin a transaction before the test, run the test, rollback. Something like [go-txdb](https://github.com/DATA-DOG/go-txdb) does this automatically for you.
I don't agree that it's ugly, but I do agree that it's more verbose than other module systems. I find Go to be more verbose than I expect in many aspects, but I'm getting used to it and I think I even appreciate the verboseness sometimes! I'm not familiar with the go-bindata incident (I assume this is the issue: https://github.com/jteeuwen/go-bindata/issues/5). I don't think the disappearance of a maintainer can be solved with a central package repository. As soon as you depend on an external service you are exposed to the risk that it might disappear, centralised or not! What if Microsoft decide to kill Github? I think a decentralised system stands a better chance of survival. Paired with gomodules replace directive; we'll all survive. I get the feeling that you're actually asking for a way to discover packages... I which case I think godoc.org does a good job.
It’s a fantastic choice. I highly recommend it.
Truncate should be faster than delete.
I just think it hasn't been a priority for the team and not much effort has been dedicated. understandable with other improvements they've made
There is no need to jump in to modules so soon. I would say wait till 1.13 comes out and all the tooling is mature to make your move.
For sure. Which is why we haven't switched yet. I just want to, because due to our dev environment setup there's a lot of extra custom tooling I've had to develop to make GOPATH work with our environment that I'd love to delete.
Walmarts experimenting with adding go plugins alongside lua plugins for their proxy t edge compute platform. So far the results have been painful. Build environments are very finicky. We ran into infinite recursion on a piece of type verification and that wasn't fun.
Thank you for responding, this is what I am asking about basically. I just was wondering what features of Go allow it to be so versatile compared to, say, Rust or Python. Is it just the libraries that the community has created for it?
No, it is not. Rust has Cargo. I don't have much experience with Rust but it is very easy to use it and start hacking. Javascript has NPM. It is easy and standard. Go has several package manager. We have to pick one, no standard. 
[removed]
errorx 🙂
Try this one: [https://github.com/godiscourse/godiscourse](https://github.com/godiscourse/godiscourse) Here is the todo list and finished list: [https://github.com/godiscourse/godiscourse/projects/1](https://github.com/godiscourse/godiscourse/projects/1) &amp;#x200B;
What's their reason for that? Contracts are genius
&gt; JavaScript has NPM You have got to be kidding me... https://www.slant.co/options/4234/alternatives/~npm-alternatives But seriously, the go package managers that you make reference to are all *candidate* implementations, the go maintainers go to great lengths to pick the right solution. This means lots of trial solutions spring up first and then one eventually wins or the learning from all those trials go into the official builtin solution. That solution is gomodules. It's still pretty new so you'd be forgiven if you hadn't heard of it.
How did he manage to disable the vertical scrolling on an Apple Magic Mouse's touchpad? I'm impressed. ;-)
Neither can I. :")
There is a lot written about it. Like [here](https://utcc.utoronto.ca/~cks/space/blog/programming/Go2ContractsTooClever) and [here](https://npf.io/2018/09/go2-contracts-go-too-far/). While I'm firmly in the pro-generics camp, there is some excellent, well-reasoned criticism *against contracts specifically* from the anti-generics camp like [here](http://jmoiron.net/blog/notes-on-the-go2-generics-draft/), [here](https://dave.cheney.net/2018/09/03/maybe-adding-generics-to-go-is-about-syntax-after-all) and [here](https://blog.merovius.de/2018/09/05/scrapping_contracts.html).
Hi, my observations: Maybe look at your data type choices in Item. I don't see why quantities should be strings. That would save you having to convert them all over the place. My general rule is if you add with it it's a number otherwise it's text. If you need to represent a not set case then use pointers and check for nil. Try and delegate more logic or helper funtions to the Item struct. 
Rust could do the same. Python probably could but not as easily. Go has been set up from the start to have zero dependencies at runtime. You sometimes (nearly always in practice) need libc, but that’s it. It doesn’t need a set of external libraries, even things like libssl. Everything is built into a single binary. That property makes it very attractive for a lot of tools like docker and kubernetes. In many ways, for a go application, docker becomes superfluous as you don’t need to pack along a set of your own dependencies like you would with python. (There’s very good reasons to still use docker with Go tho). Being compiled, and easily cross compiled, makes it extremely attractive for all these tools. It’s also stinking fast, while including a ton of high level features like closures, and channels.
Thank you so much for the reply. Im gonna try my best and learn programming the proper way. Im reading and writing go codes everyday now. Slowly but at a consistent pace and im not planning to quit. I really hope i will excel in the future. And i do hope you will also have a remarkable future for all your efforts!
Have you come across with [https://github.com/moncho/dry](https://github.com/moncho/dry)?
I haven’t dug into the code, but from the readme I can’t see where the Ca database goes. Gotta prevent duplicate serial numbers and whatnot. Also, it would be brilliant to add the subjectAltName to certificates via an argument. That’s my biggest annoyance with OpenSSL. 
There isn't any (yet). I agree that this is something that's needed tho... I need to generate these (mostly self-signed and locally used) certificates pretty often and this helps me do it more efficiently so currently I only have to take care of it myself. I'll check out the subjectAltName through arguments. This should be easy enough to add. &amp;#x200B;
Gonna be easier in Node, but Go can certainly do this. There's definitely a stable websocket library around somewhere. The interface is what's going to be interesting. If the go service serves as your backend and you write the front end in JS, thatd make the best of both worlds. 
Hi, I actually covered this in a project course that I built on my site, you can find it here: [https://tutorialedge.net/projects/chat-system-in-go-and-react/](https://tutorialedge.net/projects/chat-system-in-go-and-react/) &amp;#x200B;
Oh awesome, thank you and I’ll check it out!
Thanks for your reply! Yeah our front end is written in vue, so probably looking at just adding a go backend for concurrency. You are probably right that if I want proper test coverage, two weeks is going to be hard (plus I need to learn how to write go). In your opinion, how difficult is it to learn go? Also, I’ve written some node related socket.io code a few years ago, but that experience left a pretty bitter taste (granted, that was before promises and es6 were the rage so it was tons of callbacks and messy code). Is go code cleaner?
Can you please help us identify these errors so that we can fix them asap? Please describe either here or on our tracker at https://youtrack.jetbrains.com/issues/Go how to reproduce these issues. Thank you.
If you're using modern JS, the way you'll be writing code is going to be nearly identical. The way concurrency works is different in go, and may be a little weird to figure out at first, but will feel natural once you grok it. Otherwise, it's gonna come down to subjective reasons to choose whatever language you want. If you're expecting this app to need performance, JS might not be the right boat to board
Not really, but there is some syntax for updating a few columns, which would be easy in SQL as well, IIRC...
We use docker-compose to start a database instance (postgres), create a test db, run migrations via flyway, which includes test fixtures, then runs all the integration tests (in Go) and then stops the database server and shuts down; all in one make command.
Thanks for the workaround. Unfortunately, I don't understand what I should do with this or what problem does it fix. Can you please help me out on this one? Or even better, just open an issue on our tracker and my colleagues will know what to do with it.
Go is a better choice if you want concurrency. You might consider elixir as well though for more real-time applications. Checkout elixir and Phoenix if you wanna build a real time chat.
We use flyway, which is total independent db migration tool with lots of features, just run it in a docker container and point to your local migration scripts: https://flywaydb.org/
Completely delete the folder: `$GOPATH/pkg/mod` and run `go mod download` There were changes made to the modules system throughout 1.11.x versions (still an experimental feature) that makes it a bit unstable.
I used Postman so many times before but for some reason always run to curl first...
Docker is more the industry standard so you'll get the most community support with Docker. In terms of what OS to build your image from depends what your are building. Because Go is a single contained binary with no external dependencies you can actually run a Go program `FROM Scratch` which is the smallest container you can get.
I've just added subjectAltName through arguments and added a ca db implementation.
done 
Realistically if you already know Node.js, then that is probably the better choice. Learning Go and producing a production ready application in 2 weeks is not very. If you're interested in Go, you can definitely become productive with Go in that time though, it just takes more time to learn the ins-and-outs of the language - like any language. Go would be a fantastic choice for this kind of system though. You can work with websockets, and Go is very, very fast. Whether that actually matters in your case is another question though, and it'll depend on how many users you expect to use your app.
Stdin/out/err is local to the process, so closing it is not needed, it will close once your application exits.
I've used this approach for years, and it works well. There is a problem of nested transaction. That is testing code that itself starts a transaction. Some databases do support this but not all. If you are using a database that doesn't you can design your code in such a way that the start and stop transaction logic is external to the typical database logic. As a simple example you start the transaction in a handler/controller hen pass that (maybe via context) to the data layer. This design also allows to have a transaction that spans multiple unrelated data models, but that's an unrelated issue. 
This is so clean, good job.
Thank you :D
Great shout! I think the pool is stil quite small though that's all!
Wait. Who is resistant to generics? It certainly isn't the Go team. The Go team has written *many* generics proposals over the years, with visible work dating back to 2010 (and who knows what has taken place in private). Ian Lance Taylor alone has written at least five different proposals for generics. The first four were abandoned due to flaws in the design. His latest work, contracts, seems promising but hasn't been fully put through its paces yet. Do you mean some people resisting the desire to break backwards compatibility? Any one of those flawed generics proposals could have been implemented with the intent to fix it later, but "fix it later" is incompatible with the compatibility guarantees that the Go team wish to provide. That is why Go doesn't have generics yet.
You may want to change your TWILIO\_AUTH\_TOKEN if not done yet and hide TWILIO\_ACCOUNT\_SID , TWILIO\_FROM\_PHONE
wait until this guy discovers email
lol
LOL! 
You can also just take your job seriously, respect your team and show up on time, instead of having everybody wait again for mister sleepy head.
Can't be bothered to show up on time, but has enough spare cycles to develop an elaborate notification system? What a great teammate!
dbmate is fantastic and is very close to rails migration if you have experience with that. The only feature I’m missing out on is loading the dumped schema into the db on freshly created dbs, test dbs, etc. 
Any conversion to/from strings should be happening at your storage interface - i.e. when you are writing to a file, storing in a database, serializing to xml/json, etc. Consider what the above code would look like if the values in those structs were stored as numeric types: if sc2.StraightTime.RemainingQuantity == 0 { sc1.StraightTime.RemainingQuantity = sc2.StraightTime.OrderedQuantity - sc2.StraightTime.InvoicedQuantity sc1.StraightTime.RemainingFunds = sc2.StraightTime.OrderedValue -sc2.StraightTime.InvoiceValue) sc1.StraightTime.RemainingPercentage = 100 } etc, etc. On the whole though, I look at this function and my mind just boggles... what are you left with when this exits? It sure looks like you are setting sc1's Remaining fields based on sc2's other field values, which means no necessary relationship exists between those same field values in sc1 and sc1's remaining fields? Example: if sc1 had OrderedQuantity 50 and InvoicedQuantity 10 and RemainingQuantity 40, on entry into the function, and sc2 had RemainingQuantity 0, OrderedQuantity 100, InvoiceQuantity 75, then on exit from the function, sc1 has RemainingQuanty 25, OrderedQuantity 50, and InvoicedQuantity 10, and no longer has any internal consistency? It just seems really weird.
You know what's even crazier? He even had the spare cycles to write a long-ass article on it, but not show up on time at work!!! 
You can always run `$ go mod tidy` to clean up the file. I'm not 100% on the ins and outs of how this will work yet, but try run it after it's downloaded those dependencies the first time, and see if it adds the extra noise to your `go.mod` file again the second time.
This is peak engineer. So focused on how to use the tools of the trade to solve a problem that they don't even think to see if this problem has been solved elsewhere. I've been guilty of this too sometimes.
I'm happy to see that it links to SQRL :)
[removed]
It does everything the original does and is much lighter, what's not to like? :) 
Implement the [Sort interface](https://golang.org/pkg/sort/).
Thanks for the info. I suppose I’ll start with Docker then. Cheers
I tried that first, it still keeps it there :( If I clear the mod file and run just `go test`, no issue, mod file stays clean. Running all package tests, it adds the noise back in. I just fear it'll cause dependency issues for someone pulling in the package or someone simply wanting the base package and not the wrappers.
On the mac, scrolling only seems to work on Google Chrome. Fails on Firefox and Safari for me. I don't know why people interfere with scrolling. It's irritating because it looks like this page has some good content.
I believe the only way to get around this is to add more go.mod files. I'm not sure, but maybe with the replace directive you could tell it to use whatever the containing package version is.
me2neither
That doesn’t mean you’re reading or not reading until EOF, though. 
Also, would this library be of any usefulness? I only did this to learn, but if it is useful I could spend some time doing more methods like "Add", "Delete", "Reverse"...
If it’s in go mod, it’s needed. Go modules don’t have the concept of “optional dependencies”. They’re either dependencies, or they’re not. At least, that’s my understanding. You may have success using build tags to selectively enable different parts of the build. For example, having a `// +build echo` would only build the file when the “echo” tag is present. It’s my understanding that the Echo dependency would still be listed in Go mod, but would not be actually downloaded unless that build tag was provided. 
We are using ioutil.Readall which reads until EOF.
I just tried this yup. I placed a `go.mod` in `wrapper/echo`, `wrapper/gin`. That worked. However, in each sub mod file, its referencing the main package as "v(tag)-(commit)". I feel like this would also be an issue because its referencing an old/tag and commit I do a new release? Although it solves the root issue, it seems to bring up another unless I'm overthinking.
It's cute that people think that node\_modules is INSANE. You made my day Vugu author.
From what I can see it looks for direct closes or deferred closes within the same function, but I think that also works for creating a closure and passing that somewhere else.
This should be handled like most i18n. I don't know of a good way, but I think maybe a set of build tags may be do the trick. How you handle error messages from libraries is like you handle any string or data returned, you wrap it. There is no automatically translation layer that I know of, so you capture what is important to your customer and manually translate it. 
I'd give this a shot if it worked on browsers that did not support WASM. Looks really interesting, I'd love to use this one day.
Node_modules is insane, tho. Want to make hello world? That'll be 500 modules and 2 gigs of storage, please!
We both know you're being hyperbolic and inaccurate. If you want to build a hello world app in React, with Webpack, multiple build process plugins, libraries, etc, you're a moron OR you're just learning the ecosystem, in which case that's fine. The project I'm working on at work is 500MB and it's 8 screens combined with some sufficiently complex logic. You're pretty far off.
I code in both node and go, and I've generally liked the nested dependency model of node. At the very least it's inspired software reuse at previously unseen levels. That said, I don't think 500MB for "8 screens" is a compelling example of svelte node_modules. I just checked the size of the latest Go service I deployed (also has reasonably non-trivial business logic, realtime multi-user networking, etc)... it's a container that includes an entire OS, and yet it's still just 7.31 MB.
What's the base/common size of the generated WASM?
Will you share the results?
Oh, I'm not arguing Node Backend vs Go. I've also worked on a Node backend and I would much rather use Go, but Rust and Go people are deluded in thinking they are going to replace the frontend JS ecosystem overnight. Whatever is in node\_modules literally doesn't matter to me or my company. I have a company laptop with 1TB of storage. I won't run out if I work on hundreds of apps with large node\_modules folders, and it doesn't matter to our build process either. 99% of that 500MB is build tools, not code deployed to clients.
VSCode and Sublime Text 2/3 are the only text editors/ ide solutions if you work with more than 1 language to be fair. 
So the idea would be to basically extract the possible error messages from the library's code. And translate it myself.
It would more likely be you log (either with extra verbosity, or real log) the English, but you return to your caller a translation of "failed doing X" and add a "try doing Y" if there is a common remedy for X. But over all there isn't going to be a good way to capture all the error messages that a library can return. Especially if it reaches outside of it's own code. 
&gt; ...but Rust and Go people are deluded in thinking they are going to replace the frontend JS ecosystem overnight. "Hey here's a very early proof of concept project to write web UI's in Go" "WHY ARE YOU TRYING TO REPLACE AND ENTIRE ECOSYSTEM OVERNIGHT?" Sounds like you're just making up motivation to support your argument. People are making new things. New things are cool. It really is just that simple. If WASM replaces the node/webpack/SPA web client paradigm that would be neat. The existence of such things does not mean this is some kind of war or battle you have to pick up a sword to fight about with people on the internet. If you don't want to use this, don't.
I really hope one of these WASM client frameworks succeeds. I'm keeping an eye on them for a couple of projects that I would love to be pure Go. I really don't enjoy working with React/Angular/Vue but I would like some of the features they expose instead of just using html/template.
Vim and Emacs are good solutions too :) 
Overnight was an embellishment, I admit. Making new things IS cool, I totally agree. This project is cool. My main point was that node_modules is absolutely a sane thing to exist because the JS ecosystem needed it to grow and be what it is now. I think if you're going to make a cool new compiled frontend solution, don't attack the thing you're supposedly trying to improve. I work with the JS ecosystem everyday and I am not won over by the bullet points that were provided.
Advantages of using URL: * It's easy to find the source code * You have full control of the name *before* you think about publishing, so there's no race condition * Accessing intranet/private repos is trivial * You can see the provenance of your dependencies *in your source files* * Forks can peacefully coexist without renames Disadvantages: * Import names are longer * Import names don't always match package names 
I thoughr there was a javascript interpreter shism from Mozilla? Why not use that? Or am I wrong about such a thing existing? 
If your problem is the way things are done in the front end rather than the language itself, nothing gonna change really. You ll just have React clone done in go with some minor differences.
Error message in a user facing web app? Or in an API or CLI? For the latter: don't do it. I18n almost always doesn't help me google the problem or understand it. I really have problems with git, when the terminal language is German. (The output has improved though over the years.)
https://godoc.org/modernc.org/sortutil#Dedupe
Maybe check https://godoc.org/modernc.org/wm/tk#View
I am in total agreement about API and CLI. I was thinking about end-user programs for people who cannot understand English. Especially when file handling is involved or internet connection fails. You don't want a "file X not found", but rather "datei X nicht gefunden".
Sounds like you want a “set”, which golang doesn’t have. Instead, store them in a map and extract them into a slice when you read them, which you can sort with the sort interface. It depends how often you are calling it tho. You would need to optimize for your usage pattern. 
Some (and if you're lucky, all) errors may have been exported by the library. Having a look at those may help a little.
My goodness, what do you do if someone is sick or on vacation? Close down?
Did you read the post? He is building a system to text his team mates every time he is late (and from his own explanation this happens more that occasionally) because he apparently has no control of going to bed on time and waking up on time. I mean, come on 10:00 most people that have real jobs already spent half a day. You don't build a system to text that you're late is it happens once. I think a lot of developers are so spoiled with flexible times, high salaries, easy jobs and making demands that they forget that they can at least have the decency to show up on time and respect others people's time for those nice salaries. But yeah, considering the down votes, I bet I'm not with the majority here 😂
Yeah it's ridiculous, but you don't have to wait around for one person.
Could this be a bug?
Interesting article, though I think this should be repeated for those that don't read through it all: &gt; Should I do this? &gt; &gt; **No!** &gt; &gt; This post was intended to show you what you *can* do, not what you *should*.
Some times I do something like this: type Application struct { Token string } func (app *Application) PrintToken(w http.ResponseWriter, r *http.Request) { fmt.Fprintf(w, "token: %s\n", app.Token) } func (app *Application) UpdateToken(w http.ResponseWriter, r *http.Request) { app.Token = r.URL.Query().Get("token") } http.HandleFunc("/", app.PrintToken) http.HandleFunc("/update", app.UpdateToken) However, I’d need more details about your project to give you a better suggestion.
 &gt;How would I pass the token to each HandlerFunc? &gt; Your HandlerFunc can also be a method on a struct, which means the struct instance can store state. Additionally you can even wrap one function with another to create "middleware". This is an approach to reusing functionality by applying it before and after other handlers: https://gowebexamples.com/basic-middleware/ Often you will see Auth middleware updating either the request header or the Context before the handler runs. &gt; I was just wondering how to share Information (variables) between files or packages. Files in the same package have access to all public and private symbols automatically. Different packages can import each other and access public (uppercase first letter) symbols. &gt; Is there something like get and set in go, or is there a diffrent way of doing it? &gt; Not sure what you mean by this. Is this referring to getter and setter functions to expose access to a field? You have the choice of doing this vs making a public variable exposed in a package. 
What if you add a replace directive, so that it looks for the main package in `..` instead of using a version number?
&gt;Should I jump off a cliff? &gt; &gt;**No!** &gt; &gt;This post was intended to show what you *can* do, not what you *should*.
Exactly. 👍
https://github.com/rthornton128/goncurses 
&gt; Ok, so you want to use polymorphism in Go, but don’t like interfaces? Fine, another language! Please don’t ever do stuff like this.
Yeah you're full of shit. Every one of our developers are using that same machine and nobody is experiencing anything remotely close to performance problems. In fact we are using some older MBPs with zero issues. Your machine is either defective or your greatly exaggerating due to some unhealthy hard on you have for VSCode
I tried middleware, but they didn't change anything. Let's say I generate a random token for each user on the "/" route. Then the user leaves the site for the Google Login Api and then comes back after logging in, but on a diffrent route, lets say "/chat". How do I get the token from "/" to "/chat" without using something like URL Parameters, since the user leaves my site?
Skip straight to the announcement that has details: https://medium.com/gopherjs/gopherjs-1-12-1-is-released-2d2a63d748b8 
NPM is a broken cesspit leaking faeces all over your vegetable patch.
They say it can be large on the site, but compresses well. The [http://www.vugu.org/](http://www.vugu.org/) site is implemented in itself and comes in at 3 MB (According to chrome debugger).
Emacs is solid i used it for several years but that second thing is probably bad, doesn't even have a built in OS.
Attempted this as well. Worked fine for the actual repo. go.mod was clean at root, `wrapper/gin` go.mod was clean and only contained gin stuff, `wrapper/echo` go.mod was clean and only contained echo stuff. Tests ran fine for all. But then spinning up a new directory with gin, and importing the wrapper, causes go to complain about ambiguous import found (wrapper) in multiple modules. Looking it up it seems to be a circular dependency issue, where the wrapper requires the main package, and the replace is causing it to keep looping.
[removed]
Then you would have to either use sessions, or you have to cache their token by some parameter of their request header: https://gowebexamples.com/sessions/
[removed]
If your tests are part of the module path then the dependencies are valid. Why would you not want to track the version of your test deps? Sure they pass right now with your installed dependencies but what if one of those test deps make a breaking change and now your tests fail? Might as well track them properly? Another option is to move your tests outside that module path and do blackbox testing against your module. 
I do think it would be better to have a type 'baseanimal' or something that dog and duck have as an anonymous member (or in this case even just an alias). That way you actually get something way closer to the example for the 'bad way'. Which would make the point to actually use interfaces even stronger. Right now it looks like using interfaces means to be forced to duplicate code.
\&gt; If we say that a Go package is the atomic unit ... Because I do not agree with this, I cannot receive the subsequent admonishment. Instead of changing our understanding of what an atomic unit is, we should change our understanding of what should be tested and how. &amp;#x200B; In terms of code (avoiding the topic of testing infra)... Unit tests should be for computations and typically be table-driven (functions, preferably pure / internal). Functional tests should be for behaviors and typically be usage-driven (package APIs / external, but not necessarily). Integration tests should be for systems and typically be interaction-driven (processes, regardless of compilation type). In this way of thinking, unit tests would certainly not be as common as functional tests. And that's OK for all the reasons this talk emphasizes. Not every function is worth unit testing. However, usually, an API's surface is worth functional testing thoroughly. Also worth saying... When refactoring, unit tests should only need to be altered when those specific atomic units are modified, not when the package API is modified. Stated differently, if a unit test is restricting refactoring, then it is likely that a functional test is masquerading as a unit test and it should be relaxed and/or scoped better.
"No node. No JS. No npm. No node\_modules folder competing with your music library for disk space." &amp;#x200B; You had me at hello!
Hey everyone! I wrote this library because we had the need for abstracting or logger to our own interface at one of our projects (as most people do, I guess). I think the API is nice to use since I like the style of the zerolog API. This library allows you to create loggers with different \*backends\*, i.e. different actual log implementations. Currently, you can choose between logrus (nice console output) and zerolog (nice JSON logging), plus an addition implementation with zerolog that logs in GELF format. The library also allows you to unite multiple loggers together, making them behave as if they were one. &amp;#x200B; I would be glad if some people could give me some hints for stuff I might've done badly or in an unidiomatic way as I started programming in Go only recently.
yes it worked, thanks
I’m not sure about general guidance, but I prefer to close things with defer religiously. Closing stdin /feels/ weird, but it’s just a name for a construct. Since it follows the same rules as other files, treat it like one in my opinion.
You should separate interface and implementation into separate packages. Also consider adding zap backend. [https://github.com/uber-go/zap](https://github.com/uber-go/zap)
1 comment in this thread but nothing is here. someone is shadow banned.
I need a set of slices, and silces can't used as key for map
*several JavaScript devs are aroused*
I've been working on pomerium for a few months and wanted to share! Pomerium is an open-source tool for managing access to internal applications and resources. For those familiar, pomerium was inspired by Google's [BeyondCorp](https://en.wikipedia.org/wiki/BeyondCorp). **tl;dr** Pomerium: - provides a single-sign-on gateway to internal applications. - enforces access policy based on **context**, **identity**, and **device state**. - aggregates access logs and telemetry data. - is a VPN alternative. Github is : [https://github.com/pomerium/pomerium](https://github.com/pomerium/pomerium) Project page is : [https://www.pomerium.io](https://www.pomerium.io) Happy to answer any questions and appreciate any feedback, thanks!
Yes. I made a test repo on Github and it also didn’t work with submodules. 
https://godoc.org/golang.org/x/text/message
Turn the IPs into strings and back. 
No, but net.IP can be. Use a map[net.IP]bool. Then you can range over it like you would a slice but it guarantees uniqueness. 
It says invalid map key type net.IP It can't used as key.. or i need to import something else?
Any more details about this? There are many typos on the front page.
The idea of gopherjs is great, but the runtime overhead is huge
Yea you May need yo serialize it to a string then. 
What sets golang apart from the rest is its speed since it gets compiled into native code. Its like c but with a builtin library accompanying it. I would argue that python is more versatile and had a bigger library but doesn't run as fast as golang. In addition golang had a very unique threads system as a first class citizen. Primitives like `chan` and key words like `go` make it very easy to program multi threaded software which speeds thing up significantly when dealing with io based operations. Web stuff is very io heavy and therefore golang is ideal for it. But to be honest I never pick a language because I want it, i pick it based on project needs. Sometimes clients have software restrictions and so I end up using languages that they bring, at other times I pick a specific language because it has some specific qualities that make it easier to do specific operations. For example, with golang you can write asm code inline easily. But unlike c code, it is much easier to write and test. So if I work on an embedded device project, i pick go if I can. At other times, it might be a project involving some ML models. If that is the case many ML engineers use jupyter notebooks which is all in python. So them for ease of read I would work in python. Best way to expose yourself to new languages is by simply contributing to some open source project written in the language you want to learn.
[removed]
[removed]
[removed]
In the interface example, I feel like NewDog and NewDuck should return concrete types instead of interfaces
This looks a lot like Vue, from the single page component to the directives and approach to state. 
Why are you saying you can only compile from source on Linux ? It's a left-over from using ImageMagick ? 
I think it'll make a seperate package at this point for the wrappers only... Thanks for the help!
Honestly? I disagree with both you and the person that's arguing with you. The average Node project *is* insane, sure. But nowhere near as bad as what you've just said. "Hello world", whether it's as a server-side app or a front-end one, would require ... Literally no *node_modules* at all. As for the other commenter ... As much as I absolutely loathe Webpack, I have to admit, the current "hipster" front-end development ecosystem (sane framework of choice + bundler) is pretty much the best I've ever worked on. I don't miss the days of vanilla/jQuery based front-end apps at all. I don't have to fuck around with enormous script files (actual modules, mothafucka), I don't have to worry about load order of scripts (everything's bundled), I don't have to worry that I'm not supporting your dinosaur browser (Babel), and (thanks to the way React handles rendering components) I don't have to worry about manually writing code to update every related HTML element when I so much as sneeze and need to bump a counter. So yeah. Webpack sucks. node_modules sucks. But they succeed, because thus far, nobody has come up with options that are indisputably "better" in every way. Everything is a game of tradeoffs. node_modules and Webpack both give you an incredible amount of flexibility, at the cost of storage space (former) and complexity (the latter).
Wow. Looks like you put a lot of work into this. Nice job!
Have a look at TinyGo: it's a Go compiler for microcontrollers https://tinygo.org/
You pass around a pointer to a slice and then get the value of the pointer in (almost) every method. Slice is already a reference type so there is no need to do this. It's like you have a pointer to a pointer. Your Shuffle methods use math.Rand, which means it's not that random; should use crypto.Rand instead. Some of these algorithms are just going to perform poorly; you should build some Benchmark tests to see how alternative implementations run.
Yeah I had the same thought. In the case of the `Boxable` interface, it really depends on what methods it exposes. If the interface is only meant to be a box-like wrapper around `Data`, I agree that the interface as a field approach is kinda worthless. OTOH, I have used this pattern before with handling keyed resources and it worked pretty nicely: package keys // really repetitive stuff that is defined in many other packages with slight variations type KeyIndependentLogic interface { DoSomething(Foo) Bar } type KeyedLogic struct { Key string KeyIndependentLogic } type SomeBigComplicatedStruct { things map[string]Foo // simplified for brevity } func (*SomeBigComplicatedStruct) ApplyLogicToThings(applyThese ...KeyedLogic) map[string]Bar { // ... } // in a galaxy far far away: package galaxy var packageLocalKeys = []keys.KeyedLogic{ keys.KeyedLogic{ Key: "this key", KeyIndependentLogic: keys.SomeReallyCommonOne("something"), }, keys.KeyedLogic{ Key: "more keys", KeyIndependentLogic: &amp;myLocalImplementation{x: 42, y: 24}, }, keys.KeyedLogic{ Key: "another key", KeyIndependentLogic: keys.LogicFunc(func(f Foo) Bar { return Bar{} }), }, // ... etc } func something() { x := keys.NewBigStruct() ys := x.ApplyLogicToThings(packageLocalKeys...) }
&gt; No, but net.IP can be. `net.IP` is a [slice](https://golang.org/pkg/net/#IP).
I'm not a fan of webpack/roll-up, hundreds of npm deps
Thanks for this! This makes a lot of sense and answers my main question, which I worded poorly. I'm not trying to decide whether Go is better and if I should learn it, it's more I was curious about it's properties. So this answers my question exactly. I use Python and have been working on learning data analysis with it, so yeah I wouldn't replace it with anything I've found so far. But I have found it kind of clumsy with some things, and I've always been super impressed by web applications written in Go. I can't say the same for Python unfortunately. Basically it's just good to know what I could use Go for. It will make it easier to keep an eye out for projects because I'm definitely going to start learning it. Again, thank you so much for this answer.
Stupid question maybe, but how do you run Go on board? You still have to have Unix system on it right?
Whats the value in separating the interface and implementation into separate packages? Just seems like premature abstraction as this project isn't very complex.
Perhaps building is just untested on other platforms? Try it on yours and let us know.
Just to end up with hundreds of go modules which will have to be preprocessed into the build anyway. I mean really, do you think that front end developers just decided that f it, lets blast our projects with dependencies for no reason? I guess there are some but... hell do you really think that poorly of people. The reason why it's like that is because client side development is a lot more complicated than server side, that's taking complex auth flows into comparison. Reason for this is 1 due to always async / event driven nature of the browser where you have to take into account everything all the time. 2 It has a lot more moving parts. If you believe that frontend complexity is somehow related to language choice, you're mistaken.
Very cool, I'll be keeping an eye on that.
If you’re a C/C++ coder you’re going to love Go. From your link to the EGL library: &gt; The project was born for accessing the GPU of the Raspberry PI (check this post) but now it has been generalized to be go installable on other platforms too. This has the benefit that you could develop Open GL ES 2.0 applications on your desktop computer using Mesa and deploy them on embedded systems like the Raspberry PI.
Many SBC are running Linux these days, they’re plenty powerful! From his link to the board: &gt; ROCK64 is a credit card size 4K60P HDR Single Board Computer powered by Rockchip RK3328 **Quad-Core ARM Cortex A53 64-Bit Processor** and support up to **4GB 1600MHz LPDDR3 memory**. It provides eMMC module socket, MicroSD Card slot, Pi-2 Bus, Pi-P5+ Bus, **USB 3.0 and many others peripheral devices interface for makers to integrate with sensors and devices**. **Various Operating System (OS) are made available by open source community such Android 7.1, Debian, BSD and many more to come.**
I really love how this will change the frontend world. The unique downside I see is the size of the apps. Vugu web, that is built with Vugu is 13 MB uncompressed. That's something that should be improved, but holy cow, Go compiled on our browsers... amazing. 
I don’t see a lot of cool stuff on Reddit lately. This, is cool and useful. Nice job
[removed]
[removed]
[removed]
Political guys from `dep` killed all other workarounds on package management. Luckily go team don’t want for a workaround to be a part of toolset, so designed a thing that at least allow to have a real package management solution. Go modules I mean. 
[Ory/hydra](https://github.com/ory/hydra) might be what you're looking for. 
what about [https://github.com/ory/hydra](https://github.com/ory/hydra) ?
Go modules is not a package management solution. 
Ok thank you. I see the problem now...
Whether I see this with OAuth 2 in dev it's because I have a redirect set up to 127.0.0.1 but I'm typing localhost into the browser. The cookies and local storage for the two are different so your oauth 2 client won't be able to find the state it has stored to validate the redirect. 
Ah, I see. Sometimes it's a good idea to read the introduction :). I'm not really coming from any particular language, I strive to choose the right language for the job per project. Seems like I got enough indicators here that Go may be it, so I'll give it a try. Thanks for the input!
I don't understand whats so bad about reusing code in the form of a dependency.
Especially in compiled languages like Go, where the compiled binary doesn't really care where the code came from. For nodejs and frontend JavaScript I get it tho
Hmm that would be the case if my UI was integrated into my Go app but as I said the api is "headless". BUT I see what you're saying and this would still be the case as my Vue app is running on :3000 and my Go app on :8000. I was wondering if there was a way to still do auth server side when the API is headless. If that makes sense. &amp;#x200B;
&gt; It should be able to use more 'global' utilities across the project Don't do this. Go isn't Java. Read through some of the standard library -- it is incredibly rare to configure a package as a utility. You can achieve a similar and less coupled application by passing instances of structs and interfaces.
The reason you shouldn't do it is because it is wrong. Ducks don't have 4 legs. /s
It’s not necessarily complexity. If I like this abstraction and want to use it my project now has transitive dependencies for every logging library that is supported as a backend even if all I want is the Logrus backend. 
I wonder if tinygo could help here
I've made a start on a library for just this, it's private at the moment but it mostly works for what I need. It's in no way production quality or even prototype quality to be honest but I'd be willing to open it to a select few if it's useful? &amp;#x200B; I've gone down the route of making it a query builder rather than creating a multitude of fixed endpoints. &amp;#x200B; Message me privately if you're interested. There are no docs right now so you'll have to dig into the code... &amp;#x200B;
No actually I was very wrong all together. My problem was with axios in vue not setting the state cookie haha 
Its hard to understand what you mean. Maybe give some exaples? Maybe in your favorite language...
Let's say you are getting xml data that you need first name in but you are collecting it from 3 different apis but name can be nested in one 3 deep and 1 deep in another. What's the best way to collect that and call it in your code base by it's type? Not just call the data directly by it's array. Is there a way to call up this data without initializing the array constantly between files? I tried to normalize the data by a struct of interfaces but Its getting complicated. 
Use a separate struct (or map or whatever) for each API's returned data, and extract the data you need into a common struct that normalises the results, that you can use in the rest of your application.
Yeah as soon as I wrote all that I was thinking why not a map of struct interfaces. Or struct of structs
“A little bit of copying is better than a little bit of dependency” - Rob Pike
You are both right! Originally, when it depended on ImageMagick, I tested only the containerized approach on OSX and Windows. Now that ImageMagick is no longer required I gotta test if the \`go install ./...\` works across all platforms. &amp;#x200B; Thanks for the heads up!
Just because its a quote, it doesn't become true. The question is why? Not if there is a Rob Pike quote out there. And also, when does the benefit of maintaining copied code vs using it as a dependency (such the main author/community can maintain it for you) intertwine or outweigh each other. Honestly, if it's more than one tiny code block from stack overflow or it has some complex logic. I would day use it as a dependency. I would be worried if the project just copies everything instead of reusing and potentially contributing to the projects they take from. There's no need to increase the cognite load like that unless you just want one or two funcs/consts from a package that has a bunch of LOC and bloat. And obviously don't forget to add credit(!) and check the licenses. Now, I know this was a big issue before modules as people could have different versions of libraries and dependencies in the gopath before and we resorted to solutions such as dep, and others. But the built in modules fixes that issue now. So why is that quote a valid argument /u/BubblegumTitanium ?
Sounds reasonable. Would it make sense to make a different package for each implementation? This way, you reduce unwanted dependencies even more. 
Can you explain why I shouldn't commit the vendor directory in libraries, please?
In this case, it was because ImageMagick is full of CVEs: [https://www.cvedetails.com/vulnerability-list/vendor\_id-1749/Imagemagick.html](https://www.cvedetails.com/vulnerability-list/vendor_id-1749/Imagemagick.html) &amp;#x200B; It's still leveraging other people's libraries (urfave/cli and fogleman/gg), Its just that they are all Go dependencies now &amp;#x200B;
That'll do it :)
That'll do it!
Can it use any SAML IDP? A Lot of the docs seem setup for one use-case with a range of technologies.
I didn't mean to make it sound like one of the ten commandments. You're certainly right however that just because its a quote doesn't make it true. Having said that, the person that said has worked on enormously large projects for a long time and has probably seen a lot of things go wrong and right in that time. Like you said what is the threshold and how can someone know when they crossed it? I don't know but I bet it depends on a case by case basis and you'd need experience to determine that. I didn't mean to throw it in your face as a fact but the quote came to mind and I thought it would be stimulating to bring it up. 
Makes sense. I have old Raspberry I don't use but don't want to install full Raspbian on it so I will try to find some very lightweight distro and maybe that tinygo project will help with rest. Not looking for graphical interface but maybe some home automation projects. I like go more than python 😂
Doesn't appear to work on Chrome for Android. The first page loads but new pages don't load when you hit a link.
VMWare's go-kcl is working well for us at Crunchyroll in a production system handling 1kmps across 12 shards to an autoscaling server group of consumers. It's built-in dynamodb support for checkpointing has been a solid set-and-forget. There is usually a short delay in processing when deploying new AMIs to the consumer server group since the shard leases have to expire but apart from that it hasn't missed a beat. https://github.com/vmware/vmware-go-kcl
[This concept](https://eagain.net/articles/go-dynamic-json/) is what I use to deal with this problem.
The developer has server-side rendering on his todo-list. Rendering works, but he hasn't developed the router yet. It might become a very nice library for making sites with excellent SEO and sharing capabilities.
Yes, but if it still depends on WASM for interactive functionality. That still leaves a lot of browsers out of the race. To hear that this integration is so tight is truly wonderful, but the lack of support by browsers would be "game-breaking".
I tried cookies and it works great. Thank you for the quick help.
https://github.com/go-testfixtures/testfixtures
https://github.com/mholt/json-to-go If its JSON you can drop sample JSON output and it'll generate the structs for you
&gt;I mean really, do you think that front end developers just decided that f it, lets blast our projects with dependencies for no reason? &amp;#x200B; *RANT* Yes they actually do, its a knee-jerk reaction to anything even if the job usually would be one line of javascript. Of course, having things as a component and maybe as redux middleware requires more line of code but without all the frameworks, componentization and abstractions it would have been one line. So you get a bunch of NPM dependencies, security risk and the downside that no one can actually read the code and be truly confident in their understanding anymore.
This is definitely the way to do it. Since it sounds like you’re dealing with separate apis this probably isn’t relevant, but just in case: I’ve found https://github.com/mitchellh/mapstructure very handy if you need to inspect the json first to find out which schema is appropriate, e.g. unmarshal to an an errors struct to check for an `errors` property before trying to deserialize to a valid object.
Thank you!
Thank you. It's great for getting the structure first
Since it´s experimental for now should deter anyone from going full scale right now. The browser support is pretty high right now. At least on the high-volume site, I have GA on, I think about 9-10% would need to upgrade, during 2019 or early 2020 that will almost not be an issue. How server-side and front-end interactivity will play out is hard to tell since the router hasn´t been developed yet. Fallback and graceful degradation might be easy to implement in some cases with simple interactivity like clicking links, validating forms, etc.
That's simply not true. I'm not sure if prejudice based bs is even worth responding summerizing and attempting to demean entire group of people professional integrity, by a person who probably doesn't even work within that domain. And rest of your paragraph doesn't really make coherent sense. &gt;Of course, having things as a component and maybe as redux middleware requires more line of code but without all the frameworks, componentization and abstractions it would have been one line. What would have been one line? Can't really understand to what you're referring here. &gt; So you get a bunch of NPM dependencies, security risk and the downside that no one can actually read the code and be truly confident in their understanding anymore. Who is the "you" here specifically. Please name it. Google, amazon, which fintech companies, dropbox? Who is exactly doing this. Which developers embrace this practice exactly? Some freelancers? Few marketing agencies doing wordpress / static sites for small businesses?
Thank you!
Exactly! Especially as you add more backends you won’t compound the issue as people’s CI pipelines get bloated downloading more unused logging libraries. 
I built a TON of libraries for all kinds of things that go didn’t have a standard library for, but sadly are all encumbered as they were written for a former company. I would say go for it, but ensure you actually own the license for it. 
&gt; Can it use any SAML IDP? At the moment, pomerium only support OpenID Connect and Oauth providers. &gt; A Lot of the docs seem setup for one use-case with a range of technologies. &gt; A Lot of the docs seem setup for one use-case with a range of technologies. What use cases did you have in mind? 
 [https://app.quicktype.io/](https://app.quicktype.io/) is another (which also has a vscode plugin) is my goto for being able to paste json as code
Are you referring to using an interface to fetch some normalized data and have various underlying implementations that fetch the data and normalize it for you? (Therefore implementing the interface). Example: type Data struct { Fact string } type Fetcher interface { Fetch() (*Data, error) } type googleFetcher struct { ... } func (f *googleFetcher) Fetch() (*Data, error) { ... } type bingFetcher struct { ... } func (f *bingFetcher) Fetch() (*Data, error) { ... } Under the hood, the fetchers will have wildly different implementations and underlying representations of the data, but before they return it - they would normalize it for you.
Yeap that's definitely the piece of the puzzle I was missing. Thank you!!
No problem. Could you share a bit about your specific problem? I've done this previously and there's a few extra things to consider, but it really depends on your use case.
👍🏻
Any generalization of more than 10 million developers is bound to be somewhat false, and the one line of code is on the extreme of what I have experienced. There are some widely used development practices, especially in the front-end space which would benefit from critical research and debunking. It was an emotional rant and not in line scientific discourse. &amp;#x200B; &amp;#x200B;
I'm curious why you decided to add "Add" to the names of all the arguments, e.g. log.Debug().Err(err).Str("name", nm).Int("id", userid).Msg("login failed") becomes log.Debug().AddErr(err).AddStr("name", nm).AddInt("id", userid).AddMsg("logged in") It doesn't seem to me that the word "add" is adding any value. You're never going to have a `RemoveInt` or `GetInt`, right?
Oh, I didn't realized it loaded at all. On Safari mobile is bombs for some script error, and then when you fix that apparently any Go binary gives an out of memory error due to the size. I'll make an issue to do a round of mobile testing and document the basic status of what works in what environment.
Actually static server-side output is definitely one of the goals, although I realize you wouldn't know that from just scanning the home page and docs. The vugu.org site is already doing server-side rendering. But yes, an actual router and a clearly documented way to do this is needed. I also definitely think outputting JS on pages as a fallback for non-wasm cases (or even just in general, using Vugu only for static site templating) should be and will be supported, I just wanted to solve the most important Go+Wasm problems first. Overall, the points brought up here are totally valid and on the roadmap.
I checked it out, tinygo looks really cool for embedded devices but it has limitations that make it unworkable for Vugu. E.g. maps have a size limit (and Vugu uses them extensively to keep track of hashes so it does as little DOM manipulation as possible).
Well the devs at my work deal with a great number of consuming api's with adwords but they are doing it in php. I was kinda trying to understand their problem and how they were getting to a point where they were getting confused on which api to call and which to remove in files. I love Go but I never worked with consuming apis that are unknown size and dynamic before. I figured Go is meant for apis and being able to call data by what it does and not by what it is, would make this much easier. I was kinda planning this and trying to tackle it from a go stand point. But I never had to deal with so much changing data before so my concept in my head upon doing it was a bit murky. I also kinda told them that it might be possible in go and they were a little interested. But a couple of weekends later and Im not producing much of a concept. Thank you for your example. I think especially your kinda shells of code is a good idea first until I get the whole concept down. Instead of trying to start with the details first. Would there be an easier way to some how unmarshal/normalize data more easily? Like i know you can just unmarshal and then just throw it into a (normalize map of types) but is there maybe a more elegant way to do that? 
I feel it is a rule of thumb is that your go routine can't really return anything other than a channel. So that return is weird, unless it's a sort of summary value. Now in order to return something, your function either receives a channel and you send values through that channel , or creates a channel outside of the go func(){}() and return that channel. Now, if what you want is to store some value and that reflects a "state", I would make the function part of a struct, have a "member" value where you store the value you cared and protect it with a mutex. &amp;#x200B;
Hey, I ended up figuring out the issue on my own. The problem was, the Goland Help plugin is incompatible with the latest version of Goland, I uninstalled it, restarted Goland, the reinstalled it, and everything seems to be working normally again now. Thanks.
Do you have code samples or libraries you are trying to use?
This at least https://blog.golang.org/json-and-go gets me to the consuming portion of the unknown dynamic apis.
your controller should not include repository responsibilities, I think you should follow clean architecture paradigms (more boilerplate code though).
Personal preference, I guess. I'm adding a value to the log statement, that's why I chose Add...
Nice simple CRUD app. These nice little apps are great for testing out new app isolation and deployment methods. See, http://unikernel.org/projects/. Also new testing methodologies. Also keep that around because some company is undoubtedly going to ask you to write an equivalent CRUD app in less 15 minutes in application to some brain-dead position they are offering. 
You may organize your code following the MVC pattern.
I think I understand what you're asking. Couple options: Declare a pointer of the type of reqWillSend.Request before kicking off the goroutine, and pass that pointer as an argument to the goroutine func. Pass in a *sync.WaitGroup that you've called Add(1) on, and call Done() inside the goroutine as soon as you set your request pointer to reqWillSend.Request. Whoever needs to use that request struct outside the goroutine just needs to Wait() on the WaitGroup, after which the pointer to the request struct will be pointing to the data you want. This might be useful if multiple workers need to read the same request data. Or create a channel of the appropriate type, pass it into the goroutine as an argument. Goroutine will pass the reqWillSend.Request through the channel and return. Whoever needs the request data will block waiting on that channel, read the request into a local variable, and close the channel.
Thank you for the update.
While I did figure the issue out, I would like to note that the issue seems quite odd as the plugin that caused the issue is a Jetbrains plugin, [https://plugins.jetbrains.com/plugin/10490-goland-help](https://plugins.jetbrains.com/plugin/10490-goland-help) , any idea when it will be updated to work with the latest updated version?
IntelliJ IDEA Ultimate supports many languages as well.
Of all the attempts at building golang client side frameworks, this looks like the best yet! Good luck on this ! Hopefully the entire community rallies around this and we can have a defacto frontend framework for go that's actually production ready someday soon. On another note, has any thought been given to how you plan to deal with state management as this evolves? Building something like Vuex based on channels seems like it would be pretty straight forward, but I'm not sure how the mechanics of webassembly actually works with Go so I'm not actually sure?
Hello amiGos, I made this webhook handler a while ago. I didn't want to use Jenkins, didn't know much other deployment tools, nor I looked for one, and I was eager to practice Go. If you decide to look at it, be warned, code might be gross to the eye as well as the way I organized the files (I didnt). Some feedbacks would be awesome! Especially on how hard/easy is it to use. You can make comments on the code, but I know it's old and not good looking. I make better code now I swear 8) &amp;#x200B; Don't hesitate to use it if you feel that would be helpful to you &amp;#x200B;
Hello amiGos, I made this webhook handler a while ago. I didn't want to use Jenkins, didn't know much of other deployment tools, nor I looked for one, and I was eager to practice Go. If you decide to look at it, be warned, code might be gross to the eye as well as the way I organized the files (I didnt). We can absolutely discuss the project, especially if this looks hard/easy to use. If you decide to comment the code, I know it's old and not good looking. I make better code now I swear 8) Hope this tool would be helpful to some of you.
The constraint satisfaction library I know of written in Go is called gofd (https://bitbucket.org/gofd/gofd). The authors of that project released an accompanying research paper "Solving CSP with CSP" https://bitbucket.org/gofd/gofd/downloads/gofdpaper.pdf You may also want to take a look at go-formal, https://github.com/go-formal/sat
&gt;Any packages outside of the standard library that are used by both the plugin and the program must have their versions match &gt; &gt;exactly &gt; &gt;. Is this true even with Go modules support? I thought one of the main pain points GO modules wanted to solve was to let people use multiple versions of a lib and treat them as different libs. I know this is trivial with Go modules for major versions (different import path) but does it help in any way with minor versions (same import paths) ?
Benthos looks really interesting. I'm currently writing a similar but single purpose system at my day job and have been running into performance issues with locks, channels, etc. Thanks for sharing this. I'll study the source and try to learn a thing or two, and I'd really if you have any tips writing high throughput "event buses" like this :) Also, do you have any benchmarks on how Benthos performs?
TBH I wanted to understand * How it's an alternative for VPN (it's for sure a protected proxy, but seems protected at application rather than physical level) * If it supported the single-sign-on process I tend to use I was thinking about putting it between okta and an application so that okta can grant requisite permissions to new users (probably specified vanity domain i.e. anyone with email ending with @microsoft.com). It's something the VPN at work does. Very cool project, my comment wasn't to take away from that.
I use the mux router and the "[golang.org/x/oauth2](https://golang.org/x/oauth2)" library for the authentication. For the cookies I use the http.Cookies built in functions. The user goes to the "/login" page, where he gets a cookie with the token and a MaxAge 7200. Then he gets redirected to the google OAuth2 API. When he returns to the "/callback" route, the cookie is read and the token in the cookie is checked against the token that returns from the OAuth2 API. If I delete all cookies and clear the browser history in Chrome it works on the first try, but after that it never works.
Forget about this. Comparing every struct by hand... easy and fast. Only thing to keep in mind is, I have to adjust the function if the struct changes.
Because windows is garbage??
I've definitely given this some thought and basically I'm going to attempt to keep adding things without adding any sort of data binding, but instead use data hashing to determine if things are out of date. I tried doing a sort of observer-pattern-ish system where you change something and it broadcasts an event and while it's possible I was doing it wrong, it was really messy and didn't feel useful at all. From what I can tell, there are only two main things that "data binding" does for you: 1. You can tell when something changes and perform work after that (or reduce work because something didn't change); and 2. You can ensure that values from two different components are shared and stay up to date. With those requirements, I believe (still to be tested and proven) that 1. can be handled with hashes. The DOM syncing code does this right now and while it still needs more optimization, it works fairly well. And 2. really just sounds like... a pointer to me. (And some mutexes to make sure things don't access it at the same time - but that part is pretty much already working.) If I want component X to have a child of component Y and X needs to say "update this value whenever you have a new one" - I don't see any reason a pointer wouldn't suffice. Anyway, there's definitely a lot more to be prototyped and tried out. But I feel like the Go language can help with this a lot in ways that are just not possible (or at least it just doesn't work the same) in JS. And the simpler the better, assuming it works and solves the right problems.
I’m not sure we are talking about the same things here. It’s not the data binding that I’m talking about, im talking about managing application state across a large number of components, similar to redux, elm, vuex, mobx, etc. It’s sounds like your speaking more about 2 way data binding.
Thanks lots. I have sent a message via Twitter ... really appreciate the help. 
Nice, what you did is called path redirection, and it is at the base of each microservice/service architecture. 
&gt; it is at the base of each microservice/service architecture. Do you mean things like gateways offering SSL termination &amp; path redirection to specific services?
GTK on Windows has always been… suboptimal. Both in terms of performance and also in terms of platform-specific bugs getting actually fixed. But either way, the best way to find out where it's lagging is by [throwing a profiler on it](https://docs.microsoft.com/en-us/windows-hardware/test/wpt/) and actually measure. 
I think a proper word will be routers. Like https://traefik.io/ Below is a diagram for a front proxy example. https://www.envoyproxy.io/docs/envoy/latest/start/sandboxes/front_proxy These days I don't even know how to explain what an Api gateway is. But usually it is a place where you register APIs. I am saying this because there is also the concept of IAP (identity aware proxy), that can also do ssl termination and authorization. SSL termination can also be done on the load balancer and from there you can pass the trafic on http to the backend (whatever that is, a service:port, anoter front proxy/reverse proxy, etc) 
Go convention is to have your `main.go` file inside `cmd` and the other files "elsewhere" (based on the size of your app, at the root would be fine); you have it the other way around.
I would never put my password in that config file as plain text.
So many new words, thank you! Is it usual for a reverse proxy to focus on either grpc or http or does one usually do on both layers depending on whether it's a http packet or not? I'm still learning all this. Sorry if it's too much.
Would you use an environment variable, a trust store, a secret or sth else?
Programming, 3 new words every hours :P But really yeah, "reverse proxy" might not be the right definition
That's on point. The precise reason why I made this
I would do a env variable indeed. In addition I would integrate with hashicorp vault.
What are you storing in the cookie?
In many cases, you might want the exact error so that you can google for suggestions. Like, "not master" might be more helpful than "nicht meister" when failing to connect to mongo.
thank you for your thoughts. Right now file and cli param is available. But password as env is definitely something worth adding. Thanks ;) &amp;#x200B;
I'd recommend greasing the Java library up with a REST interface, if you can, and remoting over specific requests. Changing out that library sounds like a rich minefield of surprises as a million subtle behavior changes get in to your system. Or make sure you test the heck out of the new library, using real data, and making sure it really does what you want.
Thank you for the suggestion, i used the cobra generator from spf13. What exactly do you mean by "the other files" the ones for the token and kubeconfig in a separate package?
Negative.. windows is awesome. I spent the last 6 years working on linux and unix systems. Came back into a windows environment and nothing like just having everyone yell 'reboot it' and that being a valid root cause.. ah windows just needed a reboot again.
is there a good solution for doing TOFU against the k8s api without the openssl client connect and bash? I couldn't find something for retrieving the certificate from the k8s api without external tools like openssl client connect
Great job you did here! Did you consider using CEL for the policy engine?
Very interesting topic. Thanks for sharing. It is really hard to hear what you are saying. I would love to have this presentation with better sound.
Go 1.11 modules do not help with different minor versions (same import path). It will choose the newest version mentioned in any of the `go.mod` files (unless the main module `replace`s it with a specific older version).
Can I use this for my soundcloud username?
I've never used it, but it looks like optaplanner has a RESTful API via [Execution Server](https://www.optaplanner.org/learn/documentation.html#execution-server). You still have to build the model via Workbench, but in this case that should already be done.
The Iris maintainer send to have some issues and is pretty toxic. 
Based on your async requirement, you don’t necessarily need concurrency. You could, for example, add a job to a queue and return to the user, and have another piece of the system process these jobs with a piece of serial code. You don’t want to add the complexity of concurrency if you don’t know what you’re doing. As far as keeping track of goroutines if you do end up performing work concurrently, you may want to look into the context package and use cancellation, or wait groups, or error groups. Any of these techniques might be helpful, depending on the specifics of your situation.
And you made a new account just to spread this controversy? Congratulations on bringing more toxicity to /r/golang. 
If you really want to make cross-platform a first-class priority you might want to port to Qt. I've had far better luck with Qt applications on Windows.
Sorry you had that impression but I'm not related to anyone on that issue. I'm new to Go and found that issue while trying to decide what libs to use to make a simple Go REST poc. Just thought sharing this could be useful to other newcomers. My process when playing with new tech includes googling things like "x technology sucks" to better prepare for pain-points. So far I'm leaning towards https://github.com/gorilla packages and would appreciate feedback.
Looking at your snippet, it looks just fine! When they say you should know how it stops, they’re specifically talking about things like channels and waitgroups. If your goroutine is ranging over a channel, you would want a way to stop it after you’re done sending it data. If your case, you’re just calling some functions, using the goroutine in the background. You know it will stop when it’s done the call or errors out, so there’s no issue. One detail tho, is those may run in an arbitrary order. You cannot trust they’ll happen in that specific order, and they may all run at exactly the same time. This may be desired behavior or not. If one depends on the output of the other, I would recommend wrapping them all in an anonymous goroutine. Basically just: go func() { saveToDatabase() doApi1() doApi2() }() But yours will work fine as well, and I would see no major issues with it. 
Gorilla is very good but also pulls in a ton of stuff. I went to Gin and have been very happy. Performance isn’t very crucial and the Jsoniter integration right out of the box is nice.
Related reverse proxy that supports SSL via lets encrypt: https://github.com/Parquery/revproxyry
I like how there are two different opinions on Windows and both are voted down
You are invited to help me working on a kafka prometheus exporter: [https://github.com/google-cloud-tools/kafka-minion](https://github.com/google-cloud-tools/kafka-minion) . I think I have a lot of comments in code, but I am also happy to provide you a higher level overview of how it works. Maybe we can learn from each other? :-). &amp;#x200B; It might only be interesting to you if you work with Kafka and Prometheus. 
i guess because one doesn't answer the question and the other is objectively wrong never change, reddit
Hey! I would be interested in helping out. I work with Kafka and Prometheus at work along with Kubernetes. Anything in particular that is a first good issue to work on?
I will try that out, thank you.
We need some help fixing linter errors in Caddy: https://github.com/mholt/caddy/issues/2541
Iris
What open-source software do you use? Have you looked at bug reports? That's more useful than listening to random people pitch their projects, which you've never used and probably have little interest in ...
3meta5me
Yeah, they are different but related issues. I think to have a productive discussion we'd need to look at actual code snippets to ensure we're on the same page - it gets real abstract real quick. But basically, I think you can just create a struct with the data you would normally put in a Vuex store and have a pointer to it from multiple components and use that as the shared state - I think that *might* work out. If you're interested in following up, feel free to make an issue on GitHub and we can continue the discussion there in more detail: https://github.com/vugu/vugu/issues
Define "good"
hoverfly
You are most welcome to contribute to the Go project itself. As a starter, have a look at the "Suggested" and "Documentation" labels. This is a good place to start - https://github.com/golang/go/issues?q=is%3Aopen+is%3Aissue+label%3ASuggested+label%3ADocumentation. Next up, if you are feeling adventurous, have a look at "Help Wanted" issues. 
You might have success using a choice wrapper for or-tools: https://github.com/bpowers/ortools
I wonder if they plan on X11 support. After all, Wayland is still a relatively young protocol, compared to X11. On my Ubuntu 18.04 the “Hello, World” example fails with wayland: wl_display_connect failed
What you are suggesting makes sense, sounds more like the most idiomatic Go based approach, time will tell though, it could get complicated pretty quick. There are a few Go based redux implementations as well, [https://github.com/luisvinicius167/godux](https://github.com/luisvinicius167/godux) and [https://github.com/dannypsnl/redux](https://github.com/dannypsnl/redux) , but I will still create the issue later today as I do not like the idea of attempting to reproduce formulas that work in javascript in Go just for the sake of it when there is most likely a better / simpler way of doing things. Of course it will we hard to tell until some reasonably sized apps are written for the frontend in Go. 
Your more then welcome to help us on the go-avro project: https://github.com/actgardner/gogen-avro Go-avro is a golang avro schema encoder/decoder. The codebase is quite old and is in need for refactoring. If you want could you help us start resolving some basic go-linting warnings that are currently in the code. https://github.com/actgardner/gogen-avro/issues/78 Another project that you could contribute to is a personal project of mine: commander. Commander is a event driven consumer/producer with the support for different dialects (currently only Kafka). If you want could you help me developing more middleware or dialects. Please PM me if you are interested or open an issue. https://github.com/jeroenrinzema/commander
Yup the other *.go files. You can just have them in the root package or of you really want, place them in a sub package. Convention is to have either/both: `pkg/mypackage/mypackage.go` or have an internal folder: `internal/app/app.go`
&gt; How it's an alternative for VPN (it's for sure a protected proxy, but seems protected at application rather than physical level) Pomerium *can* be an alternative for a VPN especially for web-based internal applications. But pomerium very much acts at the application tier (level 7); I am hoping we'll be able to support other protocols in addition to HTTP very soon and have already started implementing a SSH over websockets which is one of personal use cases. If you use case is a custom protocol, or needs access blocked at level 4, a VPN is probably still your best best. &gt; If it supported the single-sign-on process I tend to use We should! We support Okta today. We support setting [access conditions](https://www.pomerium.io/docs/config-reference.html#policy) on domains based on user, groups, or someone whose domain ends in a certain postfix. &gt; Very cool project, my comment wasn't to take away from that. Thank you. I didn't read it that way at all. Let me know if you have any questions or need help trying it out I'd be happy to help. Cheers!
Dynamic access-policy is absolutely on the roadmap. I'm still researching possible policy languages (say, similar to OPA or Hashicorp's Sentinel) but none seem like a great fit for pomerium. I'm unfamiliar with CEL. What is it? 
Hey Zeus-man, I am very happy that you are interested. I don't have any particular issue in mind, but I intend to improve these things and any input from other developers on this is more than welcome: &amp;#x200B; \- Improving test coverage, especially for decoding all the kafka binary messages. The binary format sometimes changes with newer kafka versions. To ensure that all kafka versions will be supported and future kafka minion changes are compatible, I'd like to add tests on this \- Improving the go application architecture itself. I am kinda new to Go and I still have to learn a lot, if you think you could solve some of the problems more elgantly I am extremely happy if you can refactor things to reduce complexity for contributors. \- Testing kafka minion in your own kafka cluster environment is also very helpful. This way we can figure out what should be improved or if there are any outstanding bugs. \- One more thing I am currently working on is adding "group meta data" messages. These messages provide more information about the consumer groups. &amp;#x200B; If anything of these issues particularly interests you and I could help to onboard you, let me know. You can message me via pm here, email (see github profile) or discord. &amp;#x200B; PS: I am also running all of these things on Kubernetes clusters :-)
created one around a month back, might interest you: [https://github.com/abhishekkr/weeproxy](https://github.com/abhishekkr/weeproxy) &amp;#x200B; provides * HTTP Proxy based on URL path mapped to Backends * round-robin load-balancing * graceful stop/restart * prometheus performance metrics at /metrics * configurable header customization * rate-limiting (same config for all backends) * circuit breaker (same config for all backends)
[CEL](https://github.com/google/cel-spec) is an expression language. It's what powers Google Cloud Armor Rich Rules engine and Firebase Realtime Database Rules. There's a Go [implementation](https://github.com/google/cel-go).
Hugo, fzf, lf, 6cord, wtf, primitive
See also: https://up-for-grabs.net/#/filters?tags=Go and https://up-for-grabs.net/#/filters?tags=Golang
If you are interested in deep learning and machine learning, you are invited to help on Gorgonia: https://gorgonia.org/gorgonia . The readme should be enough to get started, but if its not enough, that's a PR to be made!
[https://github.com/ethereum/go-ethereum](https://github.com/ethereum/go-ethereum)
Take a look at http://go-colly.org/docs/ To my best knowledge scraping is hardly ever limited by performance of the programming language. There are other things like network that usually limit your ability to scrape more than CPU.
What do you mean ?
* https://github.com/ipfs/go-ipfs * https://github.com/ipfs/ipfs-cluster/
Lots of new updates. \- Docker image is now much smaller like &lt; 20 MB. \- Added aggregation function queries in GraphQL \- Added Auth0 JWT token support \- Whole bunch of other performance and bug fixes
I would love some more help on https://github.com/jivesearch/jivesearch. There's a lot of open issues and tons of instant answers that would be a great starting point.
Go buffalo is an awesome web framework and could use extra hands 
hey! i like the configurability a lot! i've written something similar in node, but i think i might switch to this :) 
what does that mean
https://github.com/spaceuptech/space-cloud &gt;Space Cloud is an open source, high performance web server which provides instant realtime APIs on the database of your choice. Build highly scalable apps with the agility of a prototype!
Totally random but this is awesome. I would love to contribute based on what you mentioned. Cheers to open source! 
Bad post is bad.
edited
Extra plus vote for this. An all-or-nothing move, with language included and then a key underlying technology you have a lot of familiarity with is a very risky proposition. It's generally safer to dip your toe in the water and just focus on proving out the bit that has value to your business. Unless the constraint satisfaction library you are currently using is limiting that, and it can't be solved horizontally, keep it. In the meantime, look for alternatives and make an agnostic interface that allows you to compare results so that you can prove out a new library next to the old.
edited
Always start with the official documentation [1][2], then continue from there. [1] https://tour.golang.org/ [2] https://golang.org/doc/
Always start with the official documentation [1][2]. This applies to every programming language. Then, you can continue with other resources. [1] https://tour.golang.org/ [2] https://golang.org/doc/
github.com/openfaas
Thanks for the feedback :D please do! Being the sole user of this tool, please do not hesitate to message me or open an issue if you need anything !
One of the dangers is with infinite/semi-infinite state goroutines that rely on an infinite loop or self recursive call. A program can crash of memory leak because of lack of control over these goroutines. That's why you should never start a goroutines if you don't know how to stop them. Might want to implement some state checking and/or use Context API. This is way less problematic if you just need to delay a simple task asynchronously. Happy coding :-) 
I apparently had to logout and back in to see this in my public repos. My public repos didn't have the actions tab, and manually navigating to `/actions` returned a 404 iirc. It's all working as expected now. Thanks for the post, and for making me dig deeper into getting actions on my public repos!
Engineer: Data Structures and Algorithms. Developer: How to follow a tutorial and ask for help on StackOverflow
Interesting. I like that you didn't just immediately jump to fifty folders. Viper is pretty huge to pull in to something stated as "simple", though.
What is a practical use for something like this? Just curious because one isn't given in the README.
Of course, just unmarshal into a `map[string]interface{}`. It will allow you to look up your known keys and overwrite their values, as well as ranging over all of the unknown keys. Once you're done modifying it, just marshal the map back into JSON again.
json.Unmarshal into a *map&lt;string&gt;interface{} and it'll retain all fields. 
Exactly. Ensure to do a Type check before reading the members but this works well. 
That is one way to do it, I'll try to discuss with the team about job queueing.
Does this help? https://play.golang.org/p/LJs6gKujKPg
Do not use `map[string]interface{}`! Use a struct with fields of type [`*json.RawMessage`](https://golang.org/pkg/encoding/json/#RawMessage). If you don't know the key names, use a `map[string]*json.RawMessage`.
Yes, and over time OptaPlanner will support GraalVM &amp; Truffle, which means you might be able to call it directly from Go some day.
[Gaia](https://github.com/gaia-pipeline/gaia/) has some cool features including a nice admin ui and some outstanding issues which can be worked on. And the community is pretty awesome. ;) 
A bit cumbersome to use unsafe and a C file. This can be easier accomplished by a small assembly file using something like this: TEXT ·jump(SB),NOSPLIT,$0 MOVQ addr+0(FP), R15 JMP R15 or this: TEXT ·call(SB),NOSPLIT,$0 MOVQ data+0(FP), AX CALL AX RET In go: func jump(data []byte) func call(data []byte) data, err := syscall.Mmap(-1, 0, 4096, syscall.PROT_EXEC|syscall.PROT_READ|syscall.PROT_WRITE, syscall.MAP_ANON|syscall.MAP_PRIVATE) if err != nil { log.Fatalln("mmap:", err) } // copy the byte array to data and run it: copy(data, code) jump(data) // or call(data) err = syscall.Munmap(data) if err != nil { log.Println(err) } 
I'm working on [crusttech/crust](https://github.com/crusttech/crust) recently. It's a project that provides Messaging (Slack-like) and CRM. There's a number of open issues, and there's more than enough work to go around. Long term there are integration plans for Zapier, IFTTT, message federation, IOT integrations, workflow bots,... and I'm around to lead you towards your first PR :)
`json.RawMessage`, not `*json.RawMessage` though (it's essentially a `[]byte` so no need to `*` it)
I'm not sure what the exact problem context is, so best suggestion I can give is to to use `map[string]interface{}`, e.g. https://play.golang.org/p/1sz9lcNFTpV. You can use a type switch to distinguish between the types as you need. _However, that might be more annoying to work with in the rest of the code._
Golang-migrate 
I got interested on your first question and as it turns out this is actually an expected behavior due to the nature of go's interfaces. You can read more about it here - [https://dev.to/pauljlucas/go-tcha-when-nil--nil-hic](https://dev.to/pauljlucas/go-tcha-when-nil--nil-hic) . 
&gt; they’re specifically talking about things like channels and waitgroups When I see this thing I usually understand it as "always have a way to stop the goroutine, or understand if it won't stop". Channels, mutexes, and wait groups, etc. can be used for synchronisation, but that won't guarantee that a goroutine will exit. Essentially, the comment "never start a goroutine without knowing how it will stop" is there to get you to think about whether that goroutine will leak, and stick around for the life of your application. @OP: If it were me, I'd also put `context.Context` in those function calls, as it would allow you to control when those goroutines exit, as long as they had been written to utilise the context. The built-in HTTP client and most database drivers support the use of `context.Context` though, so if your code got stuck on one of those actions you should be able to cancel it with the `context.Context`. Of course there are always bugs that might make a goroutine stick around forever. Metrics can really help with this, just keep an eye on the number of goroutines active in your app over time.
Write your own type and implement json.Unmarshaler interface.
Method `UnmarshalJSON` (implementing `json.Unmarshaler` has a pointer receiver. This sometimes matters.
``` ~$ GO111MODULE=on go run gioui.org/apps/hello go: finding gioui.org/apps/hello latest go: finding gioui.org/apps latest go: downloading gioui.org/apps v0.0.0-20190401103553-1fc75d4eba96 go: extracting gioui.org/apps v0.0.0-20190401103553-1fc75d4eba96 go: finding github.com/google/go-github/v24 v24.0.1 go: finding gioui.org/ui v0.0.0-20190401100332-f86326051453 go: finding golang.org/x/image v0.0.0-20190321063152-3fc05d484e9f go: finding golang.org/x/oauth2 v0.0.0-20190319182350-c85d3e98c914 go: finding golang.org/x/exp v0.0.0-20190321205749-f0864edee7f3 go: finding golang.org/x/sync v0.0.0-20181221193216-37e7f081c4d4 go: finding golang.org/x/net v0.0.0-20190108225652-1e06a53dbb7e go: finding golang.org/x/sys v0.0.0-20190329044733-9eb1bfa1ce65 go: finding google.golang.org/appengine v1.4.0 go: finding cloud.google.com/go v0.34.0 go: finding golang.org/x/text v0.3.0 go: finding golang.org/x/sys v0.0.0-20190312061237-fead79001313 go: finding golang.org/x/image v0.0.0-20190227222117-0694c2d4d067 go: finding golang.org/x/tools v0.0.0-20190312151545-0bb0c0a6e846 go: finding golang.org/x/oauth2 v0.0.0-20180821212333-d2e6202438be go: finding golang.org/x/mobile v0.0.0-20190312151609-d3739f865fa6 go: finding golang.org/x/net v0.0.0-20180826012351-8a410e7b638d go: finding golang.org/x/net v0.0.0-20180724234803-3673e40ba225 go: finding github.com/BurntSushi/xgb v0.0.0-20160522181843-27f122750802 go: finding google.golang.org/appengine v1.1.0 go: finding github.com/golang/protobuf v1.2.0 go: finding github.com/google/go-github v17.0.0+incompatible go: finding golang.org/x/crypto v0.0.0-20180820150726-614d502a4dac go: finding github.com/google/go-querystring v1.0.0 go: finding golang.org/x/sys v0.0.0-20180824143301-4910a1d54f87 go: finding golang.org/x/net v0.0.0-20190311183353-d8887717615a go: finding golang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2 go: finding golang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a go: downloading gioui.org/ui v0.0.0-20190401100332-f86326051453 go: downloading golang.org/x/image v0.0.0-20190321063152-3fc05d484e9f go: extracting gioui.org/ui v0.0.0-20190401100332-f86326051453 go: downloading golang.org/x/sys v0.0.0-20190329044733-9eb1bfa1ce65 go: extracting golang.org/x/sys v0.0.0-20190329044733-9eb1bfa1ce65 go: extracting golang.org/x/image v0.0.0-20190321063152-3fc05d484e9f go: downloading golang.org/x/text v0.3.0 go: extracting golang.org/x/text v0.3.0 # gioui.org/ui/app/internal/gl go/pkg/mod/gioui.org/ui@v0.0.0-20190401100332-f86326051453/app/internal/gl/functions.go:28:23: fatal error: GLES2/gl2.h: No such file or directory compilation terminated. ```
I suspect you're using wayland, though (it seems to at least try to support x11, otherwise why would it pull in xgb)
Is there any cases or examples that a goroutine will not exit/leaks? In example when performing a database operation or third-party api calls like above.
On Ubuntu you'll need `libgles2-mesa-dev`. The author should have mentioned it in the readme.
Always need more advanced patterns! 
you can have pointer receivers and still use the non-pointer type. You can't do the reverse. That's how `bytes.Buffer`, `sync.Mutex`, and `sync.WorkGroup` (to name the few I know off the top of my head) have zero values that are "ready to use".
The answer is really "it depends", but it can certainly happen. The thing is, any case where this actually happens in production is a bug. You could have a misbehaving third-party API that never times out, and maybe you forgot to set timeouts on your end. You could have a database query that ends up in some kind of locked state that it can't get out of because of poorly designed tables and queries. You could have made a mistake specifying an escape clause from an otherwise infinite loop. In many cases, it may even just be that by not specifying a timeout you make too many goroutines over some period of time - they don't have to never close, just take longer to close than you expect. Using `context.Context` can help mitigate many of these issues, because it's designed to tell goroutines when to quit. But even then, you can make mistakes when implementing it, or get stuck at some other point for too long before the `context.Context` is checked to see if it's done.
Much better! Now it ~$ GO111MODULE=on go build -o /var/tmp/hello gioui.org/apps/hello go: finding gioui.org/apps/hello latest go: finding gioui.org/apps latest # gioui.org/ui/app os_wayland.c:107:2: error: unknown field ‘shape’ specified in initializer .shape = gio_onTouchShape, ^ os_wayland.c:107:11: warning: excess elements in struct initializer .shape = gio_onTouchShape, ^ os_wayland.c:107:11: note: (near initialization for ‘wl_touch_listener’) os_wayland.c:108:2: error: unknown field ‘orientation’ specified in initializer .orientation = gio_onTouchOrientation ^ os_wayland.c:108:17: warning: excess elements in struct initializer .orientation = gio_onTouchOrientation ^ os_wayland.c:108:17: note: (near initialization for ‘wl_touch_listener’) 
Thanks for your tip ! It has been changed :)
I am an active Kapacitor user, but I haven't written many udfs, I haven't needed to yet. Most of the time I get by with the exec node and python scripts, however I can write golang I just haven't been bothered learning how to UDF yet.
Do you have some open-source codes for the exec node I could peep into?
The documentation is pretty excellent for all influxdatas products.
Believe me, I am more than aware. However, I do not recommend relying on auto-addressing. It's a subtle footgun. Especially in the case of synchronization primitives. It takes one unintended copy (e.g. passing a mutex as an argument) by an unaware engineer and you end up with two mutexes when you wanted one.
how does that translate to "take pointers to things that are already pointers", though?
I think there has been a misunderstanding somewhere. Addressability and pointers are related but distinct concepts. In this case it all commutes nicely and works out. I'm simply recommending to be explicit in the types you use. `json.RawMessage` is always a `json.Marshaler` but is only a `json.Unmarshaler` when it is addressable. The type `*json.RawMessage` is always both since it is always addressable. 
Awesome! I'll try it out soon because I tend to do a bunch of small fiddly things this would work well for. One note on your readme: // Me API es su API Should be // **Mi** API es su API 
More on nil channels https://medium.com/justforfunc/why-are-there-nil-channels-in-go-9877cc0b2308
Damn. If this support graph databases like Dgraph it would be exactly what I need for a project I'm working on.
The author of txdb. I plan to implement savepoint feature and it will be provided as an option for registration of txdb. I just haven't figured out yet the design of such feature, since not all databases support it, but MySQL and PostgreSQL are most common, and they do support it. So yes, at the moment nested transactions are not supported, so you would need to test a smaller unit (function) which does not have a logic of nested transaction. In the near future, we should have that feature available.
Take a look at https://github.com/nathanielc/morgoth
ducks have 4 legs or more, depending on the number of ducks
what I miss in this example, is when introducing an other animal, you can actually use a common animal.makeNoise that will only do that for the animal that isn't a dog or duck
encapsulate your error in a new OwnError object that has an error code and an error text. Standard text is English (as example) and then, when you need to "translate", use the code to find it in the error translations.
what human would like to watch millions of rows filled with data? I can't imagine that this "solution" would be human-friendly.
You could also work on Badger (which Dgraph uses). We could use contributions there.
sorry, I tried to speak loud, but the room wasn't well mic'ed. I have the gist transcribed on the project github. https://github.com/Soypete/Example_KNN_golang
\`http.Client\` redirects based off of HTTP status/header redirects. Since the server returns a 200 OK status, I'd guess that page is using Javascript to change the page URL, which you'll need to dig into the page's Javascript to figure out.
Hi! Is it possible to get away with using only Micro instead of Kubernetes? How much of their functionality overlaps? I always strive for simpler whenever possible and Micro looks appealing in that regard.
Sessions and REST?
Please stop bringing these events from other languages such as JavaScript. We have channels, use them. You don't even need a library on top of them to use them for events. In the very least events listeners can't work in Go because the callbacks are an antipattern in Go most of the time and because due to the lack of generics you will be typecasting all the time, which again is an antipattern when it can be avoided.
just a qeury, (Im just starting into go) Isnt it better to use Sync waitgroup over channels ? Since WaitGroup has better syntax and more readable code.
The requests themselves are state-less but a session is kept with cookies for user authentication (login/logout).
The provided play ([https://play.golang.org/p/\_NPWRX4KqFB](https://play.golang.org/p/_NPWRX4KqFB)) triggers the race detector.
Probably because there is no control between the two go functions so it's _theoretically_(?) possible the first go func could take longer than 100 ms to execute? Anyway, here is a better version: https://play.golang.org/p/CBS9mJ0uxn3
Don't read the [request.Body into a byte array and then pass that to json.Unmarshal](https://github.com/bruno-chavez/go-web-template/blob/master/controllers/login.go#L23). Go supports io.Reader/io.Writer on basically everything important - including JSON decoding. err = json.NewDecoder(resp.Body).Decode(value) 
`moon.Moon` should be `moon.New`
What is the purpose of setting c to nil if it is never checked for nil? The code works identically if the value of c is not reassigned.
I've started getting a bad case of the hives every time I use a raw Go routine. If it's not behind an error group, I just have a hard time sleeping at night!
Yes perfect - thanks alot guys !
If you implement the RPC directly in net/http it’s absolutely possible. It just sets the Method to a string. 
It was a silly example to show how it's safe to assign the local c to nil while also closing the actual channel. It's a virtual way to do `close(c)` from both the caller and receiver without a panic. See the OP's article for more.
That is way easier to use, thank you!
Thanks for pointing that out.
Why would an API be concerned with maintaining authentication or access control state? That sort of thing is typically handled via a protocol such as OAuth via an access token which is provided on each request. Making the API itself stateful is precisely what REST aims to avoid.
The variable within the scope of the goroutine being set to nil is not relevant to the channel being closed. Remove the param/arg from the goroutine and the resulting code is racy and does panic on close. [https://play.golang.org/p/IjooqgXGw00](https://play.golang.org/p/IjooqgXGw00)
Your best bet may be to fork \`github.com/gorilla/rpc/json\` and implement the method transformations yourself, and register your custom JSON codec via \`rpcServer.RegisterCodec(json.NewCodec(), "application/json") \`
I think that this article is written by beginners. But he can't go from being a confusion to them. It also contains simple bur important errors for those who is beginners. For example: [https://play.golang.org/p/GspB3DWx0xh](https://play.golang.org/p/GspB3DWx0xh) &amp;#x200B; &amp;#x200B; &amp;#x200B;
The code in the TL;DR will break because it's a quick summary/reference showing the different ways to work with variables. All the code blocks in the actual explanations should work and go in-depth of the why and how. :) 
Removing the DWARF tables should be helpful in reducing binary size, via linker flags `go build -ldflags="-s -w" ???.go`; stack trace messages are still preserved, only debuggers suffer, so it's safe for production.
&gt; only debuggers suffer, so it's safe for production Well... assuming you never need to remote into a production server and attach a debugger because you aren't sure how to reproduce an ongoing issue is probably not always a safe assumption. I love that you can debug remotely.
Code should be fixed or separated in two blocks otherwise beginners will still run it as example to see what it does. 
Awesome!! And the binary size is smaller than 3Mb on Windows 7. https://pasteboard.co/I8a3lZF.jpg
I've obviously done a terrible job explaining this. You seem to understand closing nil channels, so I'll chalk this up to a miscommunication and point further readers back to the OP's post to see how beneficial setting channels to `nil` is for certain use-cases. Basically, it's a convention that the caller should close the channel - not the receiver. The receiver can get around this by setting the channel to nil when it's done with it for it's own book keeping purposes.
Very interesting. I'll check it out. Thank you.
Remember to be careful what you make concurrent though. Too many projects crap it everywhere because you can. Winds up like JS
FWIW, my tool https://github.com/evmar/webtreemap is designed exactly for this use case of "dump some data into a treemap". For example it can be used at the end of a shell pipeline. It's used in a number of binary size analyses (that was its initial application).
So how exactly should I implement authentication with an API? having some trouble finding the best solution, and even though using sessions does make it stateful as you said it was the best I could come up with. For example, lets say I have a web app in whatever front-end framework like React, Angular, etc, doesn't really matter, it lets you save your favorites superheroes and displays all the ones you have saved, using sessions it would be something like this: + User visits `/login`, credentials are sent through HTTPS to the API and get checked, if everything works fine a session is created. + User visits `/superman` and saves Superman to his list, the API receives a POST request with the id of Superman and it gets saved with the user id in whatever DB since it has access to it thanks to the session. + User visits `/saved`, the API receives a GET request and knows that has to send back all saved superheroes by this user, in this case only Superman. Is there any way to achieve this while keeping the API stateless? I don't really know how OAuth works, nor how to implement it, any guidance would be helpful. As a followup question Is there a good reason to not use sessions and having a stateful API?
Could also add pi calculus; choreographic programming is a way to amthematically formulate communication between distributed systems or between processes. It uses channels as well (even buffered types) and a lot of other complex behavior to let you model you systems. &amp;#x200B; It has helped me out a few times. But I still struggle with it, as I so rarely feel the need to write it (not writing anything crazy complex on my end, but it is used in some crypto currency programming).
I'm not an expert on this by any means but [REST as a standard is intended to be stateless](https://en.wikipedia.org/wiki/Representational_state_transfer). This doesn't mean you can't have a stateful API, it just means that it's not a *REST* API. I'm sure others can do a better job of answering your other questions than I can.
when moon, sir?
What?
That's a good point, guess I should make my comment a bit more caveated
[removed]
I agree with the comments about being hard to follow: the contents is great, but you may want to reshuffle the order. Beginners tend to blindly copy+paste, and their likely copy the first thing they see. My suggestion is to start with "this is the best way" and then go more in detail about the other cases when/why etc.
Thanks for the feedback! You make a really good point.
Can do moon.NewHandler, does the same thing as moon.Moon :-)
Please do! Hope this helps. Thanks for typo correction 
Interesting. Whenever I work with errors across goroutines I tend to end up with an ugly mix of ad hoc solutions and boilerplate. Can you expand on how you use them? Are they as simple and generally applicable as they look? I had a quick look at the code, and the [unit test](https://github.com/golang/sync/blob/master/errgroup/errgroup_test.go#L65) makes it look quite nice.
Don't worry too much about things like OAuth etc if you are just building a web application. Technically a proper REST API should be accessible by another client/application and not just yours. That is where the whole stateless API thing comes in which should not depend on things like cookie based sessions etc. But in your case, if you are just doing some backend queries for your own web app, you are totally fine to do it this way even though technically it is not a full REST API. You are just calling some endpoints internally that return data back to your own frontend. Nothing wrong with that. &amp;#x200B; If howver you want to expose your data to say another 3rd party with some restricted access where they possibly wil build their own User Interface, then you have to utilize things like OAUth etc. to ensure that those external apps can still be authenticated by you before data is revealed. This is because those external apps would not know anything about your own cookie based sessions implementation. 
We're working on it! I think at the moment because everyone understands how to run software we're not yet tackling that problem but with kubernetes and everything else, the complexity is increasing so much that people would prefer to focus on the development side, not operations. &amp;#x200B; Locally you can run micro with zero dependencies. And you can choose to run that on any platform without the need for kubernetes. Remember though that kubernetes is a container orchestration system with some added features. You can get away with running services in a simpler way and use micro on top.
https://stackoverflow.com/a/18125763/5272101 If the struct is named `Moon`, the constructor function should be named `NewMoon`, except if your package name is `moon`, then the function should be called `New`
There are also some examples written in both Go and Python here: https://github.com/influxdata/kapacitor/tree/master/udf/agent/examples 
Go newbie question: Are debug-enabled Go binaries considered secure in production, even in SaaS environments? At a previous employer with services written in C++, debug builds were forbidden from being installed in production for security compliance reasons.
I would love to answer your question of how I use them but it's a very broad question. Error groups have a pretty small API so there's not much to it. I try to follow a few patterns to make effective use of them. 1. Treat your code like a tree as much as possible (so main is your root and everything just flows downwards, with as little circular deps as possible). 2. Thread contexts throughout your code as much as possible (when reasonable, e.g a function that adds two numbers obviously does not need to accept a context). 3. Anything that does something non-trivial should be returning an error. Assuming the above, anything that runs in the background or that you want to run multiples of (i.e concurrently) should be invoked within an error group. The error group should also wrap a context, so that if one of the go routines exits with an error, the context will get cancelled, causing your program to exit. I'm happy to discuss more if you have more questions.
I'm aware of this and it is applied here, `moon.Moon` is just here for memeing purpose
I don't think they are large seeing as they are 100% self-contained, especially when using `-ldflags="-s -w"`. 
Most people don't think of the binaries as being debug vs prod builds because, as far as I'm aware, very few people use the linker flags to strip symbols. I'm guessing that for security purposes, your biggest concerns would be that having delve on the prod machine or having delve's remote control port open to the web would be risky. Personally, I'd be fine simply making sure the firewall doesn't allow external connections, and when I need to remote debug, another tool will allow a specific valid IP address to connect through the firewall to delve, but the firewall will tend to be blocking that port and will never allow more than that valid IP address. As for the binary, I wouldn't want it to be runnable by the same user as the web application, but otherwise I'm comfortable with its presence.
as are all the images. It's amazing how bad presentation can take away from a point. I can't read the text easily, nor any of the labels, so I don't.
Another thought... if you want to reduce space, I believe you can reduce the size of a binary more without losing debug abilities via a tool such as https://github.com/upx/upx at the cost of some startup time (for decompression).
You should use [JWT](https://jwt.io) — JSON Web Tokens. I use [gin-jwt](https://github.com/appleboy/gin-jwt). And [a project](https://github.com/teamxiv/growbot-api/blob/master/internal/api/api.go#L93) I use it with.
Deciding to rewrite a stalled, years old program in a new language is a classic move towards never finishing said program. If you can’t answer this question yourself based on your own Go knowledge the answer is almost certainly a resounding “No.”
Well it has undergone a rewrite before, just not in a new language.
Hey, that is an awesome explanation. Thank you very much.
Thank you so much for the insight! looks like I'm sticking with sessions for now and if I ever consider exposing the API I'll need to look for other solutions.
The go runtime isn't as bad as people make it out to be. [Go vs C](https://imgur.com/MyDt6vh) Also that font gave me eye cancer.
@amurices Sounds like a really cool project to be honest! Go inter-operates well with OpenGL as far as I know: https://github.com/go-gl Whether you will have issues with the GC or not, I cannot tell. It also depends how much garbage you produce and how you align your data in memory. Rust also sounds like a good candidate, and if you've thought of learning the language before, this could be a good time to do so. In essence, I don't think either of these languages will prevent your project from being successfully completed. Wish you the best of luck, and once you decide, please post back with a link to the repo so we may follow your exploration and development from day one. Cheers, Robin
No. You do not want garbage-collection anywhere near video rendering. Stick to a manually managed language like C or Rust.
While I'd tend to recommend Rust here as well, I don't think this is a problem. This isn't a fast-twitch video game. It's either not in real-time, or dropping a frame isn't going to be a problem.
&gt; On a side note, I really hate this page's font. It is very hard to read. Out of curiosity, what is the DPI the display you used to view that page?
It's more efficient to parse it once and execute the parsed template each request.
Creating it only once will be faster. Creating it on every request will be more useful for development. You could do both.
The dependency management section does not take into account anything described in https://blog.golang.org/modules2019.
Thank you for this! Exactly what I needed and no CGO headache
Looks like author never really found out about Go modules, current error type draft or generics draft. Anyway, Goos read.
No, I know about it. In fact I even mention the draft about errors. But this is a dialogue about the current state of things, not what is a draft of something maybe to come in the future. 
some of the bad seem misguided -- particularly the bits about package level data hiding, anonymous interfaces, and duck typing.
From the documentation: Once parsed, a template may be executed safely in parallel, although if parallel executions share a Writer the output may be interleaved. That means it’s safe to call it many times in parallel. Since compiling it is the one of the most time consuming, you would want to do that only once. 
I think it is 227 https://support.apple.com/kb/SP715?locale=en_US 
A couple issues here: 1. Your post shows no effort. Go has a wonderful community that prides itself in helping beginners and fellow experts alike, but there’s a minimum level of effort that you need to demonstrate to show that you aren’t taking advantage of that help. 2. Protocol buffers are not a de facto replacement for CVS files, as they have extremely different use-cases and goals. In addition to showing what you have already researched and tried, a brief explanation of why you want to do this will go a long way toward ensuring that you get the most relevant advice.
try nim-lang the executable size is a key feature that they care [https://nim-lang.org/features.html](https://nim-lang.org/features.html)
Was wondering about this too. If you are starting fresh, or get a chance to fix things, go modules is the way forward.
What about Go Modules? Been out for a bit. No good?
[removed]
First, you should remove debug information under release mode using `-ldflags="-s -w",` Then, have a look at this : [https://upx.github.io/](https://upx.github.io/), perhaps its what you are looking for.
This
More like a JSON querier than a database.
Planning to support JanusGraph soon enough! Dgraph supports only GraphQL at this point, its difficult to work with that with the current query generator we are using!
14px copy? Even on mobile it is too small, it should be at least 16px on mobile, 18px on desktop
Channel variable is being accessed by two goroutines without locking. 
Parse once and reuse. Although tiresome for development. You'd use a library like https://github.com/abenz1267/cachy though. Shameless self-plug, I know. 
Looks like I missed it your post, my bad. I am more excited about generics more than error.
Why would I wnat to use this one instead of e.g chi. Or what would be the pros of it. The con I'm seeing by skimming through the docs is that it doens't use standard http handlers.
Well that’s one way to write clean code
Can't say I'm a huge fan of this syntax. Why not: names := []string{"Bob", "Sally", "John", "Jane"} short := pie.OnlyStrings(names, func(s string) bool { return len(s) &lt;= 3 }) That seems much more "Go-like" to me. I'm also not sure about the performance? In general most stuff using callbacks will not be high-performant. I looked at [the implementation](https://github.com/elliotchance/pie/blob/master/strings.go#L51) to see if you were doing any special tricks to minimize copying/allocations or whatnot, but it's just append() in a loop. Doesn't strike me as especially performant? In the vast majority of cases all of this is just fine, but seems a bit strange to advertise it as having high performance.
I agree with this. I've written some GL code in go, like emulator frontends, and it's running quite fast on low end hardware like a raspberry pi. I've actually never noticed any slow down due to the garbage collector kicking in.
If your goal is to learn go, then it's worth the rewrite. If not, keep C++ as it is the language for this kind of tasks.
It seems to provide the same adapters that other routers and frameworks have: https://godoc.org/github.com/go-ozzo/ozzo-routing#Handler But I am with you on the comment about the motivation for a new router amongst the existing competition. I'm of a mind that when there is a huge number of choices, a new option should explain why the other options are not sufficient and why effort was put into a new solution instead of improving existing ones. Otherwise it's just yet another entry into the "fastest router" competitions. 
Yeap it's right in the go blog https://blog.golang.org/json-and-go 
Well, this simply cannot happen with a proper Go installation. (Note that you cannot cd into the directory for package bytes and run `go test`. The source code for Go and its stdlib are tested and built differently). But inside your project it is basically impossible that `import "fmt"` works and `import "bytes"` fails. Can you provide more details?
 // Declare variable without setting value var message string Well, the comment is plain wrong. `message` is set to the zero value of string. The comment sound like there are uninitialized variables in Go. Cheat sheets for beginners might be helpful but should not be misleading.
From the most pragmatic point of view possible: Go’s interop with C-based libraries might be the death knell of this. Calls into C functions [are orders of magnitude slower](https://www.cockroachlabs.com/blog/the-cost-and-complexity-of-cgo/) than the equivalent calls from C or C++. For most things, say calling a database, that kind of overhead is a minimal fraction of the overall elapses time, but in scenarios like this where you are building really complex objects by making tons of calls several times per second... might be enough to make it impractical. From a learning perspective, you should totally do it. Go is like a much saner C++, with very strong opinions, some cool concepts and one fifth of the features.
I would agree with @curiousGambler. Have you heard of the book: [https://martinfowler.com/articles/refactoring-2nd-ed.html](https://martinfowler.com/articles/refactoring-2nd-ed.html) it might be helpful. Also if you're learning a language, the first thing you write in it is going to be poorly written. So if you want high quality code.
It's not clear how this plugin could have caused the issues as it was not supposed to work with the previous release, 2018.3, either. As for when the plugin will be available, I don't have any update on this for now. You can use our online help at https://www.jetbrains.com/help/go/ meanwhile.
C++ is actually a good procedural language (much better than it is an OO one) so I'd recommend you to stick to it. Just throw the 'good' (modern C++) practices out the window and apply your own. I once came to see a Java program written in procedural style (almost exclusively static methods) it was a really liberating experience. The alternatives you mentioned have both their issues. Go suffers from slow C interaction and Rust requires a long time to get comfortable.
"I currently do not handle errors on purpose to not slow myself down. But I don’t ignore them either. Like any self-respecting software engineer I panic when I receive an error." WTF? Error handling is the most important thing!
I use cobra for all of my non-trivial CLI’s, flag for everything else. Any libraries anyone else uses for CLI? One my favorite parts of cobra but not obvious is the default initializer function you can set. When the library was still new to me I’d wrap all my callbacks in a function that would initialize my program and then invoke the callback I passed in. Glad the author/team saw the pattern and designed for it.
Can you make an argument about why they're misguided?
yes -- but i get exhausted thinking about writing a point-by-point argument. here is one: &gt; On top of that, because go encourages package level compartmentalization it’s deemed “OK” to expose many static methods on a package. However, this often times encourages people to use global mutable variables as state and closes off extension and testability. Statics, in my mind, are only acceptable if they are purely immutable. he acknowledges that packages are the unit of compartmentalization but fails to make the leap to realize that if he wants to completely hide something from a package -- that he should simply make another package and scope his symbols properly. he does, however, make the leap to the idea that this encourages globlal/mutable state -- which it doesn't. this simply doesn't make any sense to me. i don't understand what he means by 'it’s deemed “OK” to expose many static methods on a package.' to start with, the terminology he uses doesn't make sense and it feels like something someone who doesn't genuinely know Go would say. what exactly is a static method on a package in Go? almost each section of his "bad" stuff seems to be predicated on a fundamental misunderstanding of the concept he's criticizing and seem to be based, partly, on his expectations of other languages. i feel like he wasted 8 months if these are his takeaways from Go. there is so much bad here that it is difficult to discuss for the sheer amount of time and energy it would require when the solution would be for the author to actually learn Go. 
Try/catch/throw them then it becomes someone else's problem ;)
I've been using [kingpin](https://github.com/alecthomas/kingpin) for some time now, for a few reasons. * It's quite nice to build individual commands, arguments, and flags with their types and descriptions. * It's quite flexible with what you can achieve and requires nothing from your implementation. * It's accessible and expressive meaning that maintaining applications is straight-forward. I remember stumbling upon cobra a few years ago now, and found that it didn't really provide anything that I was looking for at the time. By the looks of the project now however, it might be a good time to check it out again.
&gt; almost each section of his "bad" stuff seems to be predicated on a fundamental misunderstanding of the concept If you have already commited on being negative about somebody else's efforts, you should at least give them the benefit of expending some more energy by explaining exactly how and why they are wrong. Or, if that's too "exahausting", consider leaving them be. The way you're actually skirting the answer makes me believe that you yourself don't have enough Go knowledge to be able to make the criticisms you're making with any authority. &gt; seem to be based, partly, on his expectations of other languages. I think that anyone with some tennure as a developer will probably have their experiences of Go coloured through the prism of some other language. Instead of dismissing that as a "wasted 8 monthts" I think you should consider their point of view and try to address their "fundamental misunderstandings". Anyway, I realize that I don't really have anything constructive to say neither to you, nor to OP, so disregard this as the rumblings of another programmer coming to Go with fundamental misunderstandings. :)
funny, i like it
Just an update, did a video on Chi. Check it out here: https://youtu.be/zeme_TmXyBk
&gt; The way you're actually skirting the answer makes me believe that you yourself don't have enough Go knowledge to be able to make the criticisms you're making with any authority. yup. 
At first glance it looks like Kingpin supports slices, which are the only thing I find myself wishing the standard “flag”package had. Ace! I do really like “flag” though. It’s so simple that I can use it without referring to docs almost all of the time... I’m a long, long way from that level of comfort with Cobra! The Containous (Traefik) folks have a pair of libs called Flaeg and Staert. Much, much more complicated than I need, but if you want integration with things like Etcd, Consul, etc, there it is.
Having used cobra for a while on some tool for a cloud provider, I can say that its quite nice to work with. However if I would have to build some CLI tool now, without any language restriction, I would rather use Rust for better Regex processing speed. Pretty much most of my reasoning from moving CLI tools development from Python -&gt; Golang can now be applied from Golang -&gt; Rust. Speed, safety(type, concurrency),... And Rust has some solid CLI projects that are quite popular now a day: Ripgrep, FD, exa, etc... that can be used as reference.
Want to contribute too to get some go experience :) 
Why is your css so bad?