The Go team has done a great disservice to the community by creating a wholly irrelevant recommendation in their style guide around naming method receivers. This has caused a slew of people to latch on to and defend idioms that argumentatively make little sense and in my opinion, provides little additional value to the clarity of go code. I'm regularly surprised that go programmers forget that **this** and **self** at their core concept are simply *keywords*, used in languages (even in non-class based languages) as a tool to communicate access to an object or a type. It makes very little difference if the object access keyword is **this**, **self**, **a**, **b** or **srv**. What is important is that the keyword is consistent and even in languages that allow you name the keyword, communities will prefer you be consistent in whatever name you choose which more often than not defaults to this or self because *everyone* of a basic level of skill will recognize what that keyword means. If those keywords feel ambiguous to you, which are used for consistency purposes to make programmer's lives easier, then you need to spend more time understanding your programming language of choice or programming in general because you are missing some key concepts. But if it is so important to name your keyword with some acronym representation of your actual type name, go for it. But the *substance* of that naming is irrelevant outside of consistency purposes. The only thing important naming wise on a type is the naming of your method and data members which convey the real purpose and use of the type. The receiver name is simply a keyword that you recognize to gain access to those method or data members either by value, reference or otherwise. So I compromise. All of my types in go have a receiver named **t** as so: func (t *SomeType) MyFunc(...) { ... } You can imagine t means "type" or "this" but actually it means nothing more than "the keyword to access SomeType". Every time I see *t.* in my code I immediately know I'm accessing the type and don't have to recall what the hell I named the method receiver. I could use self or this but god damn, I be burned at the stake as some kind of programming witch. And guess what, when I steal a function from a type or copy and refactor a type for another purpose, guess what I don't have to do? Rename all of my method receivers, which is just one more thing I can keep off my task list making my programming life just a little bit easier. Keywords to the rescue. To each their own. To my last point: Go allows you to name your receivers with your own *keyword*, so they are indicating to you via language syntax that the naming of method receivers is irrelevant and inconsequential. Otherwise the language would enforce a paradigm of some sort, perhaps an auto generated keyword? Sound familiar? 
I share your concern, I don't necessarily want much to change, just a decision to be made. Essentially, "the go community encourages use of X for dependency management." What X is doesn't really matter to me at this point. Im partial to GB, or nuts, but just want to use what everyone else uses. Others may have strong opinions about their favorite, but I'd love this to go the way of gofmt so we can all move on. NPM, and Cargo may not be favorites of everyone who uses them, but if you write JS or Rust you know what dependency management tool to use if you want to interact with the community. The main sticking point I see is libraries that depend on other libraries, do/should they vendor? If so, the developer in charge of main will need to handle possibly having libraries referencing different versions of the same library. If not, the library maintainers library may fail to build at any moment, and the developer of main will have to deal with that. I'm not sure there is a satisfactory answer.
My original draft had a bunch of additional reading and references in the end, including this. Perhaps I should put it back in. I was hoping to provide some original discussion around the topic with some concrete reasoning and examples, rather than rehash what's already out there.
If you read some of Rob's other papers and talks, you'll see that what he's advocating *isn't* becoming the BDFL for Golang, it's that friction should be reduced to zero whenever possible for the greatest number of people. Whatever dependency system the community decides to throw their support behind isn't going to fix everyone's problems. But if you create a solution that is mostly right most of the time for most people, that's going to be a damn sight better than, e.g. pip or npm, which never does exactly the right thing without lots of configuration and doesn't handle complex use cases well at all. Like the rest of the language, I think the philosophy they're going to take here is "if we can automate it, we will, but if we can't we'll get the hell out of your way". Look at the `go` tool: in a "Rob Pike is BDFL" world, it wouldn't give you access to the compiler directly, it would enforce its build system and the rules surrounding $GOPATH and whatever as canon law. But it doesn't, because although those defaults are very often good enough to solve most peoples' problems most of the time, they aren't perfect. It's perfectly possible to use an external {build, dependency management, packaging} tool, but the idea is to create a system that packages sane defaults all together.
`go get -u golang.org/x/tools/cmd/goimports`
I'm running latest 1.7 master and it works perfectly fine for me. What do you get when you run `go version`?
`go version go1.6.2 darwin/amd64`
Yep. `tomb` is very close to what I wanted, but I dislike its requirement that functions return an error, especially the need to return a sentinel error during clean shutdown: &gt;If any of the tracked goroutines returns a non-nil error, or the Kill or Killf method is called by any goroutine in the system (tracked or not)... Alive is set to false &gt; &gt;... &gt; &gt;Tracked functions and methods that are still running while the tomb is in dying state may choose to return ErrDying as their error value. The calling convention is also different. Whereas with `tomb` you call all your goroutines with `tomb.Go`, with `threadgroup` you insert calls to `Add` inside the goroutines. Perhaps the most important difference between the two is that calling `tomb.Go` after shutdown results in a panic. When using `threadgroup`, `Add` returns `false` after shutdown, allowing calls to abort early and gracefully. This is really helpful for controlling the behavior of exported functions after shutdown. AFAICT, with `tomb` you would need to add a separate boolean `closed` field to your object to achieve the same.
There's actually a guide on how to write basic web apps in the docs: https://golang.org/doc/articles/wiki/
your arg is ARG!
Yes I am using this one as an example. I am not sure if it's the right way to do it
Indeed, but could not find any tutorial for this.. Swagger looks ok 
go-swagger can do the client as well iirc
At a glance, this could be simplified even further. Instead of doing all the last line jazz, just join the slice with '\n'.
&gt; Two, the docs say that we should not signify that we satisfy some given interface I really find that strange. Even last night I was thinking about a way to have godoc pick up on which methods implement which interfaces.. why should it be so opaque? 
It is indeed the most fastest release yet.
That was just requested this morning - your hard work is really appreciated!!
&gt; Sorry, I can't agree. golint does have some false positives, but they are super rare. Modulo those exceptions, I think it's completely correct to treat it as canon. That's fine that you disagree, but I'm not claiming this as my personal opinion. It's the mandate of the author and project. [Read the _Purpose_ section of the README](https://github.com/golang/lint#purpose). It's also a hotly debated thing in the issues ([example](https://github.com/golang/lint/pull/148)). Take a look at the big slew of closed issues with various complaints.
All you ever need to know about receivers in Go: [_"The name of a method's receiver should be a reflection of its identity; often a one or two letter abbreviation of its type suffices (such as "c" or "cl" for "Client"). Don't use generic names such as "me", "this" or "self", identifiers typical of object-oriented languages that place more emphasis on methods as opposed to functions. The name need not be as descriptive as that of a method argument, as its role is obvious and serves no documentary purpose. It can be very short as it will appear on almost every line of every method of the type; familiarity admits brevity. Be consistent, too: if you call the receiver "c" in one method, don't call it "cl" in another."_](https://github.com/golang/go/wiki/CodeReviewComments#receiver-names)
Now it does xD https://github.com/leonelquinteros/gotext/releases/tag/v1.1.0
Your fear is unwarranted. It explicitly says that the alias would effectively be invisible and would behave exactly like the original type, and you wouldn't be able to declare new methods on the original type, so it wouldn't be allowed. Beyond that, Go specifically disallows defining methods on a type outside the package where it is *defined* (note that a package with an alias in it still wouldn't be defining the type). The reason for this is that, if two packages, A and B, define the same method on a type defined in a third package C, and then later a fourth package D imports both A and B, all of a sudden you have a method with two definitions. A and B would be incompatible with each other and it would have to be illegal to import both into the same program. This is something that the Go designers very specifically prevented in the design of Go, and they have rejected the ability to do this repeatedly. They aren't going to change tack now. Also, Robert Griesemer wrote this: &gt; @josharian: Adding methods to a type via its alias name in the receiver specification seems like it should be possible if the alias refers to a locally declared type since the alias really just means that type. It should not be legal if the type is imported (it's not legal now). But it we restrict aliases to imported objects only, this question becomes moot.
This. It's good to see everyone on the same page at the end; something needs to be done and actual decisions made.
do we know what the issue is yet?
IIRC they're revealed once the release happens
Thanks for both replies.
Good overview of all options. Thank you.
AGPL with an exception clause for FOSS &gt; FOSS License Exception &gt; =============================================================================== &gt; &gt; This Exception applies to open source applications built with UniDoc and &gt; UniDoc extensions ("The Software"), and to open source Derivative Works of &gt; the Software, that use the Software under the terms of GNU Affero General &gt; Public License, version 3 ("AGPLv3"). The Exception extends AGPLv3 by providing &gt; additional grants that allows developers of FOSS applications to include UniDoc &gt; with their FOSS applications in combination with other software licensed under &gt; the licenses from the "Open Source License List" below, provided that: &gt; &gt; You obey the AGPLv3 terms for the Software and the Derivative Work, except for &gt; the separate parts of the Derivative Work ("Additions") which constitute independent &gt; work and are not dervied from the Software. &gt; &gt; - All Additions are distributed subject to one of the licenses listed below. &gt; - Your software distribution provides complete source code for the Additions. &gt; - The Derivative Work and its Additions are intended for use in end-user applications &gt; and do not constitute software intended for use by software developers, such as &gt; software libraries, components, and development kits. &gt; - If you violate any of the terms in this Exception, you lose all rights granted &gt; to you by the Exception and revert to the terms of AGPLv3. &gt; &gt; UniDoc reserves all rights not expressly granted in these terms and conditions. &gt; &gt; Open Source License List &gt; &gt; Name Version &gt; Academic Free License 2.0 &gt; Apache Software License 2.0 &gt; Apple Public Source License 2.0 &gt; Artistic license From Perl 5.8.0 &gt; BSD license July 22 1999 &gt; Common Development and Distribution License (CDDL) 1.0 &gt; Common Public License 1.0 &gt; Eclipse Public License 1.0 &gt; Educational Community License 2.0 &gt; European Union Public License (EUPL) 1.1 &gt; GNU General Public License (GPL) 2.0 &gt; GNU Library or "Lesser" General Public License (LGPL) 3.0 &gt; Jabber Open Source License 1.0 &gt; MIT License (As listed in file MIT-License.txt) - &gt; Mozilla Public License (MPL) 1.0/1.1 &gt; Open Software License 2.0 &gt; OpenSSL license (with original SSLeay license) 2003 (1998) &gt; University of Illinois/NCSA Open Source License - &gt; W3C License 2001 &gt; X11 License 2001 &gt; Zlib/libpng License - What does it mean exactly? 
I suppose it means that you can use this library in your open source software, if it has approves license, without releasing it under GPL or AGPL license. You can't hoverer use it in your libraries if they intended for other developers and not for you end product.
&gt; AGPLv3 Aaaaand at this moment you lost my interest completely. I understand a desire to have an income, but at the same time I also know that AGPL has no **real** legal power, because license doesn't state where one one's software begins and another one's ends. Using AGPL on Windows, for example, can be considered a violation. Long story short - any sane legal worker would advise against using such library. As will do professional developers, including me. Sorry, but no. I suggest you look at MongoDB how to properly write your license if you want AGPL. However I would recommend you to consider at least GPL. AGPL doesn't make it harder to bypass license boundaries - it makes any usage complicated. P.S. Never seen AGPL library with dual licensing getting any significant attraction. It's really hard to define API "boundries" even with end user software, but with library it's almost impossible.
Look at the pricing tab. The license is designed to prevent a lot of use, but make it available for testing. Then when you want to use it in your project you pay them money. Just a different model.
OMG that's true indeed. Thanks for pointing out. Makes me feel silly now for chosing that title. %-) All - For the records, the "..." in the title are meant to be a standard ellipsis as used in plain English text. No technical meaning whatsoever.
GitHub link: https://github.com/unidoc/unidoc
&gt; (solid engineering imo) ...and in line with how Russ Cox characterized Go in [an interview](http://www.pl-enthusiast.net/2015/03/25/interview-with-gos-russ-cox-and-sameer-ajmani/): *"Go is more an engineering project than a pure research project. Like most engineering, it is fundamentally conservative, using ideas that are proven and well understood and will work well together."*
I've created a library for the Go language to interface to Envisalink modules. Currently, it only works with DSC alarm panels. It has only been tested on an EVL-4 module, but presumably also would work with EVL-3. Included are command-line utilities to (1) bridge the EnvisaLink module to an MQTT broker and (2) bridge the MQTT broker to Apple HomeKit. This allows for integration with HomeKit, but also could be integrated with other services like HomeAssistant using MQTT. I currently have been running this with the HomeKit integration using a local Raspberry PI 2 and the iOS 10 Beta 1 Home app. Comments and pull requests are welcome!
The idiomatic way is the flat style to avoid extra indention. It's all over the standard library. https://golang.org/doc/effective_go.html#if
Any chance of the videos being uploaded eventually? There twitch channel doesn't have anything
Despite the comments in this, I've been looking for something similar for personal use. Thanks for this!
They will be on YouTube on 3-4 weeks. I'll post the link here when they're ready.
Awesome! Thank you!
There is a super active #goa channel in the gopher Slack that is very helpful. https://gophers.slack.com/messages/goa/
Once you've defined the links all you need to do is include the special "links" attribute in the default view: View("default", func() { Attribute("id") Attribute("href") Attribute("name") Attribute("links") }) Take a look at the [goa-cellar example](https://github.com/goadesign/goa-cellar/blob/master/design/media_types.go#L86).
Did you find the source of your leaks yet?
Do I need an invitation or something? I'm unfamiliar with Slack, but I just created a new account and tried to login from the link you provided and it says invalid email and password. **edit**: I googled and found an invitation link. Thanks.
Yet net/http's API looks like that exactly because it was created before Context, and thus couldn't use Context in a simpler way. That makes it the very opposite of a model to copy..
Just pass ctx as first argument.
Thank you for doing a better job with the slides this year. Hopefully this happens every year. Hopefully the missing ones will be up soon.
Sounds like you observe this issue: https://github.com/golang/go/issues/7348
It just has examples of how to use the go standard library's crypto functions. Completely different purpose as libsodium/nacl.
O wow, this gave me an idea how to fix it. You can delete the shortcut that says "godocserver" and bam it's fixed.
I've felt the same way and have been using vim for about half the time you have. Honestly I got lazy about having vim configured as an 'ide' for 4+ languages. I picked sublime (mostly at random) to give a new tool a chance. It's definitely not eclipse or visual studio, thankfully. It works nicely for non Java stuff and I've been happy with it. 
go generate and macros and other meta programming tools get me so excited but in practice they are insane. 
Haha that's how I read it and I was terrified (but intrigued)
Yeah at first I thought it was a magic potato. 
The http package in stdlib -- and every 3rd party package built atop it -- spawn a goroutine per request which is why you cannot get your endpoints to block. Capitalized function names denote public functions that can be accessed from other functions via package.FunctionName as opposed to package.functionName which is not allowed (private)... I recommend that you quickly run through the "Tour of Go" and "Effective Go" tutorials before going much further. :-) It's highly likely that your Go code will use far less memory, execute far more requests -- under any load scenario -- with lower latency, higher throughput, and trivial deployment (single binary executable) than python. As for Dockerized micro-services, absolutely yes! You can find tutorials on building Docker images barely larger than the single file executable placed on them, allowing hundreds or thousands of containers on a single server/instance if required. One thing to be aware of is issues surrounding using crypto, including HTTPS client/server handling, may require some additional files to be added to the Docker container, thought this may be obsolete information at this stage...
Rob's slides will be on talks.golang.org at which point the submitted link will work.
Anything not enforced is optional, thus all patches that require user intervention are optional. A problem in the security industry is people assume that just releasing a patch will fix the problem.
On a side note, you seem to be thinking of [parallelism, not concurrency](https://blog.golang.org/concurrency-is-not-parallelism). Python supports concurrency (threads, corountines, etc.), it's just hard to get Python code to run in parallel. 
&gt; If you look carefully, they use both styles in different scenarios. My argument is that the flat style is useful but the scoped-style should be preferred because it provides a consistent style in all scenarios. In other words, with Go's simple design goals, scoped ifs allow for less cognitive dissonance. You're ignoring the increase in *cognitive dissonance* introduced by both the nesting and indentation/new scope.. 
I am curious, is there any reason why you chose gorilla/websocket instead of golang.org/x/net/websocket ? 
Regarding docker, here's an old but still relevant post about building docker images for go binaries with scratch for your base image. Results in sub 10mb docker images. https://medium.com/@kelseyhightower/optimizing-docker-images-for-static-binaries-b5696e26eb07#.q7kaas8f3 So yea...excellent choice for dockerized microservices.
Nice. Thanks for the link.
No. I'm considering that. I'm saying that when the nesting is natural to the algorithm, it provides better, immediate, visual insight into the structure of the algorithm than the flat style. When there are dependencies inherent in an algorithm, the flat style requires manually parsing the algorithm to be able to discover the dependencies. It's my belief that dependency management is one of the most critical elements when writing software so we should make it a priority over visually appealing code.
I am a big fan of the [Ginkgo](http://onsi.github.io/ginkgo/) testing framework. It allows a sensible test structure, is very readable, and has nice features like the 'watch' flag. This will run tests every time it detects a code change, so if you are debugging code, you can easily see if the test you are concerned with begins to pass. 
Thanks I was not aware of it. Looks like a nice BDD framework for Go.
Can you give some "real" algorithm to compare different implementations of it?
Regarding 3: Good practice is to assign sane behaviour to zero/empty/null argument and use that as default, see stdlib again.
What's everyone's stance on using HTTP/2 instead of websockets?
Appending to a slice can potentially be an expensive operation, eg. if the slice needs to be resized. This can make a big difference in performance. Prashant Varanasi has a talk a from gopher con in may about profiling and optimizing go apps and he's got an example where initializing the slice capacity ahead of time makes a pretty big impact.
+1 for Ginkgo. Went from vanilla testing -&gt; testify -&gt; ginkgo and have been very happy ever since. For smaller libs, I think keeping to vanilla testing is not a bad idea though (with an assertion lib). Nice article @op!
&gt; One thing you also want to consider is sending Ping/Pong frames to act as a keepalive and to help you know when clients disconnect more easily. does gorilla already do this? https://github.com/gorilla/websocket#gorilla-websocket-compared-with-other-packages
Oops, looking at the source code it looks like Gorilla does provide a default Ping handler. Oddly, I've always written my own. Documentation for it is here: https://godoc.org/github.com/gorilla/websocket#Conn.SetPingHandler
&gt; https://github.com/golang/go/issues/7348 Maybe put as much information as you can in that bug? It's an old bug that hasn't gotten any love so any information you could provide could be useful.
I started one before searching for existing clients. Silly me. It's production ready now: https://github.com/ekyoung/fbmessenger
This blog is really hard to read with the background coming through between every paragraph. Also, personally, I like to see fully-executable code examples, including the package imports so I can copy-n-paste into the Golang Playground.
Very cool! Is this open source somewhere?
From what I understood, they aren't meant for the same usage at all, and are not mutually exclusive. StackOverflow concurs: http://stackoverflow.com/a/28583517/1685538
Yep, ginkgo + https://github.com/maxbrunsfeld/counterfeiter + https://github.com/tjarratt/gcounterfeiter is a great testing suite 
I use it almost everywhere. Not because of data size: just to be sure I'm calling the right object's method. Also my previous main language was Java, so I'm used to passing objects by reference all the time.
I think perhaps a more important reason for having pointers is to allow only 1 location for a variable. If you create the same variable in two locations (in memory) how do you ensure they stay in sync. This is exemplified here: https://www.golang-book.com/books/intro/8 That being said, I would argue it is a bad practice to have multiple functions modifying a variable. So in my code, I seldom have pointers. If you want to consider the concept of values and variables more - take a look at this talk by Rich Hickey: https://www.infoq.com/presentations/Are-We-There-Yet-Rich-Hickey
If you are starting out, I'd recommend you to stick to the standard library. Assuming a small project, [writing go web applications](https://golang.org/doc/articles/wiki/) will provide you with the basic stuff and concepts you will need. Assuming a larger project, writing the API in Go for the backend and using a javascript framework like AngularJS for the front _might_ be better than using Go templates.
In of itself not directly, Go 1.7 addresses this to some point by allowing dependencies that consist of only binary data, but the compiler still produces a statically compiled binary. So in short; Golang at the moment, does not have anything like a DLL or JAR to dynamically use, *but* you can link binary packages.
It installs without problem for me. Runs without crashing and it does find the vendored linters. The only issue I have (but I don't know if it is related to this branch, I don't use gometalinter in my projects yet, though it is on my roadmap), is that some linters are VERY greedy. I run it using gometalinter --vendor --debug --deadline=5m ./somePackage/ And I get these warnings: WARNING: deadline exceeded by linter interfacer on somePackage (try increasing --deadline) WARNING: deadline exceeded by linter unconvert on somePackage (try increasing --deadline) WARNING: deadline exceeded by linter aligncheck on somePackage (try increasing --deadline) WARNING: deadline exceeded by linter varcheck on somePackage (try increasing --deadline) WARNING: deadline exceeded by linter errcheck on somePackage (try increasing --deadline) WARNING: deadline exceeded by linter structcheck on somePackage (try increasing --deadline) after 5 minutes of my laptop completely freezing. I'll try some comparison with the master branch a bit later and will report here. Edit: go version go1.6 linux/amd64
Ran it with "--fast" on all our internal code and it looked OK, only got some warnings: WARNING: failed to kill vetshadow: os: process already finished WARNING: failed to kill gocyclo: os: process already finished WARNING: failed to kill goconst: os: process already finished 
I think it's good practice to only use pointer when you actually need to modify state, not as a default thing that potentially will cause race conditions and confusion of what the current state actually is. Having the modify state as a practice also makes it clear which methods that will change something and which that will not. Only care about "too big" and "too slow" when you know that you need it (and you have a benchmark that shows the improvement) 
In the error, the compiler complains that the `client.Send()` function requires a `Command`, but recieved a pointer to a Command (`*Command`) instead. Try dereferencing the pointer, by changing the last line to: client.Send(*firstCommand)
It works! Thank you so much for your reply!
This gives you a way to do that when all you have is a terminal connection to a computer, like a remote server. Even if it's on the same network, you can quickly verify that the networking is set up correctly straight from the command line.
I don't know if there was a talk, but you can also look at https://github.com/dvyukov/gosmith for generating bizarre go programs.
&gt;[**GopherCon 2015: Dmitry Vyukov - Go Dynamic Tools [23:25]**](http://youtu.be/a9xrxRsIbSU) &gt;&gt;Dynamic tools can provide significant value for small time investment. But frequently they are underappreciated by developers. In this talk I will describe three dynamic tools for Go: data race detector, fuzzing system and execution tracer. The first two tools are related to bug finding, and the tracer can give insights into performance and latency issues of Go programs. I will also share our experiences of systematically applying such tools at scale. &gt; [*^Gopher ^Academy*](https://www.youtube.com/channel/UCx9QVEApa5BKLw9r8cnOFEA) ^in ^Science ^&amp; ^Technology &gt;*^5,348 ^views ^since ^Jul ^2015* [^bot ^info](http://www.reddit.com/r/youtubefactsbot/wiki/index)
...also the marshalling and unmarshalling overhead and very few primitives for synchronization. It's a pretty blunt tool.
&gt; Using AGPL on Windows, for example, can be considered a violation. I've never heard that one before. What's the argument? &gt; I suggest you look at MongoDB how to properly write your license if you want AGPL. So, [GNU AGPL v3](https://www.mongodb.com/community/licensing)?
I don't get it... it's just like gin and echo and others. Dependency injection is a solved problem with Go: route handlers as methods on a struct that carries its dependencies. Your solution looks over engineered.
Sorry, missed this comment while at GopherCon..WRT to #golang this developer summed up some things concisely I think are important: https://twitter.com/enlamp/status/754006302293127172 -- but of course, depends on what you are trying to accomplish with streaming..
speedtest is what you want
You do not test init(). You test the package interface. If init() fails your public interface will fail or else there is no need for init() anyway
1.) Done. I will be sure to add more useful documentation. 2.) I plan on improving performance by storing underlying values by reference instead of copying entire structures. I might be able to still incorporate your suggestion into the update but I just need to think more about this going forward. I really appreciate the feedback thanks!
It's true that it isn't a _problem_, but it's also something that _never_ needs to even be considered when using scoped if/else.
Just like Golang isn't perfect, I think their decision to prefer the flat-style is wrong. I outlined several points in [my pros and cons](https://github.com/nicerobot/go-style/issues?utf8=%E2%9C%93&amp;q=is%3Aissue%20is%3Aopen%20label%3Aif%2Felse%20) for why i think the flat style is less ideal than the scoped-style. Some examples: * The flat-style allows for many types of bugs and oversights that the scoped-style inherently avoids. * The flat-style requires techniques to work around code flows that aren't required to work around with the scoped-style. See [metamatic's comment above](https://www.reddit.com/r/golang/comments/4t6dxz/the_pros_and_cons_of_ifelse_styles/d5h1ysp). * Scoped-style ensures variables are scoped close to usage. * Scoped-style encourages a consistent flow and function declaration paradigm. * You can never _easily_ ignore errors in the scoped-style. * ... I believe that the scoped style if/else is far more in-line with the design principles of Go and the idiom should change to prefer scoped-style.
they pick the server by your ip location. it's worldwide. turn on the debug by DLOG=* fast. and you can see the download url, there is a country code in it as us, uk etc
 const nthreads int = 20 Omit the explicit type when it can be inferred. &gt;https://github.com/killermouse0/MassHash/blob/master/masshash.go#L22 `f` is not `Close`d when that error occurs. Also, you should be using `gofmt` to format your Go source code. Set up your editor to do it automatically. for { select { case &lt;- quit: return default: time.Sleep(500 * time.Millisecond) } } I don't understand this (from `main`). You could just write `&lt;-quit` instead of all that. It will block until there's a value to read. Why do you think you need a loop and sleep here?
Slice? Just making sure that was a mistake - slices are already essentially pointers and there's almost never a good reason to use `*[]int` over `[]int`
Goroutines are not threads. Stop thinking in threads. Spawn a goroutine for each hash you want to compute, make it print the hash at the end. The whole point of concurrency in Go is to make you not have to manage threads. Some people might protest against the "print the hash at the end". Maybe you want the printer goroutine since the documentation doesn't explicitly say that stdout is atomic, but the way things are implemented today it's not necesary. Then use sync.WaitGroup to wait for the goroutines to finish.
Got it. Thanks!
First, nearly all languages are pass by value. A pass by value language is any language which creates a copy of whatever you give it at the function boundary. If you give it a pointer, it creates a copy of the pointer. To be a pass by reference language, you have to be able to write a function `swap` s.t. integer a = 1 integer b = 2 swap(a,b) print(a) ==&gt; 2 Key point being that `a` is not a reference to `1`; it is `1`. Its actually impossible in most languages. Do not pass pointers unless there is an explicit, well documented reason why you need to. The reality is that Go's core language developers are immeasurably smarter than you. Despite conventional wisdom being "passing pointers is faster because otherwise you have to copy the entire struct", there are a multitude of optimizations Go has in place to make that less of an issue than you'd think. Meanwhile, when you create a pointer, you're basically telling the Go runtime "I care more about where this thing _is_ than _what_ it is", which impacts a different type of optimization the compiler/runtime can employ surrounding memory allocations. In C, every `malloc` results in heap-allocated memory. In Go, instantiating a struct in a function doesn't _always_ result in heap allocated memory. If you create a struct and it never leaves the function, Go can stack-allocate it. If you create a struct and pass it to another function directly, Go can copy the struct in place, which means it can still be stack-allocated. If you reference it then pass the pointer, now Go has to heap-allocate it, which means more GC. Additionally, good programming practice recommends the use of immutable variables wherever you can. By passing references, you're opening yourself up to unintentionally mutating structs all over the place. There are two cases where passing a pointer makes sense. 1. If your function literally needs to mutate the inside of the struct. There are cases where this might be useful, primarily in some struct methods. 2. Some singletons where there is internal state you probably don't want to copy. A good example is a database connection; most database libraries will return their "connection" struct as a pointer. 
No binaries for ARM anymore?
Is there a command line client? 
Were there every any official ARM binaries? Looking through the previous releases, I can't find any.
/u/metamatic was kind enough to send me a test case, and it turns out that it's the "usual" problem of gotype only working if dependent packages have been `go install`ed.
A few things to remember about using pointers: 1. In most languages that "don't have pointers", what they call "objects" are just pointers in disguise. What these languages call "pass by reference" is really just passing a pointer *by value* in exactly the same way that Go does. As far as passing things around is concerned (i.e. ignoring things like inheritance), pointers in Go behave exactly like you would expect objects in languages that "don't have pointers" to act. Assigning to a field through the pointer/object affects all copies of it, but reassigning the pointer/object itself only affects that copy. Under true pass by reference, assigning to a parameter inside a function should reassign the variable passed in by the caller. 2. Never use pointers to interfaces. Interfaces in Go can hold any type of value which satisfies them, including pointers. If you need a pointer, put it *in* the interface. There are some very rare cases (usually involving reflection) where you need a pointer to an interface, but otherwise it's not worth thinking about. 3. Only pass around a pointer to a slice if you need to resize it or wholly replace it, and just returning a new slice is insufficient. 4. If you don't need multiple structs to refer to the same value, then it's usually best to store that value in the struct directly rather than storing it via a pointer. If the field needs to be handled via a pointer, that's fine, because you can just handle the struct itself via a pointer. Adding an extra layer of indirection *inside* the struct doesn't usually help anything. Obviously, though, if the only way to initialize the type is to call a factory function (i.e. NewValue) that returns a pointer, then you need to store a pointer, but otherwise, storing values directly in a struct is typically a good idea.
google speedtest cli
Yeah, sorry, I've meant an array
Please, don't claim it's "zero-dependency". go get -v github.com/ddo/fast github.com/ddo/fast (download) github.com/ddo/go-fast (download) github.com/ddo/go-between (download) github.com/ddo/pick-json (download) Fetching https://gopkg.in/ddo/go-dlog.v1?go-get=1 Parsing meta tags from https://gopkg.in/ddo/go-dlog.v1?go-get=1 (status code 200) get "gopkg.in/ddo/go-dlog.v1": found meta tag main.metaImport{Prefix:"gopkg.in/ddo/go-dlog.v1", VCS:"git", RepoRoot:"https://gopkg.in/ddo/go-dlog.v1"} at https://gopkg.in/ddo/go-dlog.v1?go-get=1 gopkg.in/ddo/go-dlog.v1 (download) Fetching https://gopkg.in/ddo/pick.v1?go-get=1 Parsing meta tags from https://gopkg.in/ddo/pick.v1?go-get=1 (status code 200) get "gopkg.in/ddo/pick.v1": found meta tag main.metaImport{Prefix:"gopkg.in/ddo/pick.v1", VCS:"git", RepoRoot:"https://gopkg.in/ddo/pick.v1"} at https://gopkg.in/ddo/pick.v1?go-get=1 gopkg.in/ddo/pick.v1 (download) Fetching https://gopkg.in/ddo/request.v1?go-get=1 Parsing meta tags from https://gopkg.in/ddo/request.v1?go-get=1 (status code 200) get "gopkg.in/ddo/request.v1": found meta tag main.metaImport{Prefix:"gopkg.in/ddo/request.v1", VCS:"git", RepoRoot:"https://gopkg.in/ddo/request.v1"} at https://gopkg.in/ddo/request.v1?go-get=1 gopkg.in/ddo/request.v1 (download) github.com/ddo/go-spin (download) github.com/ddo/go-between github.com/ddo/pick-json gopkg.in/ddo/go-dlog.v1 golang.org/x/net/html/atom github.com/ddo/go-spin golang.org/x/net/html gopkg.in/ddo/request.v1 gopkg.in/ddo/pick.v1 github.com/ddo/go-fast github.com/ddo/fast 
&gt; Global state: not even once. In the given example probably a package local "constant" is to be initialised at runtime. Just panic() if this initialisation fails. That's all you need to do. Sometimes its definitely better to break the rules instead of passing extra context thru many invocations just for the sake of following them. 
Symmetric design is fragile in presence of real-world concerns and changes [1](https://drive.google.com/file/d/0B59Tysg-nEQZOGhsU0U5QXo0Sjg/view), [2](https://jaxenter.com/carlo-pescio-clever-code-interview-127779.html), [3](https://www.youtube.com/watch?v=FAZ4GjPKmVI). For a better approach see [DDD in Go](http://www.citerus.se/go-ddd), [2](http://www.citerus.se/part-2-domain-driven-design-in-go/), [3](http://www.citerus.se/part-3-domain-driven-design-in-go/), [code](https://github.com/marcusolsson/goddd).
I disagree with that type of structure, at least for this type of project. If you're having to introduce something that forces you to go against the pattern of the rest of the project, it should be considered a separate project/library in itself in my opinion. For the scope of this project, I can't see (of course without hindsight) any need to do something like that. If I do, I'll definitely take this into consideration.
I feel Caddy is such a nice development, Apache and Nginx both feel cratered by feature creep and odd licensing - something fresh and clean is much appreciated.
I believe that splitting your code into generic packages like handlers, service and repository is the root of your problems. What you can try is instead splitting to packages of what is important for your application. Try to start with a piece of paper first and name the most important components of your application. Those might make good candidates for packages. This is how usually Go code is organized. It's obvious in the Go standard library and the majority of Go projects that strive for idiomatic code. As the proverb says: _"Design the architecture, name the components, document the details."_ P.S. Some interesting discussion and points from Egon Elbre that might help [here](https://forum.golangbridge.org/t/comparing-the-structure-of-web-applications/1198/2).
pip &amp; virtualenv greatly reduced the pain for end users (*), but packaging was never designed as first-class citizen in the Python ecosystem: "There should be one obvious way to do it" (zen of Python) (*) both started as community projects, if I am not mistaken. Go developers expect the same miracle for vendoring right in Go-land.
&gt; I've never heard that one before. What's the argument? Well, it's kinda tricky. Basically, because whole system is closed source, including kernel that makes it incompatible with AGPL. You may argument - but GPL works on Windows without violation. That is covered by "System Libraries" part in (A)GPL v3, tho their definition of "System libraries" can be a very interesting topic (Dockerfiles for example) for itself. Another thing is that directly linking WINAPI from GPL can be considered a violation in certain situations tho, BUT GPL allows you to use other FOSS approved licences, so you can create wrapper around WINAPI and use more permissive licence. As far as I know - even MinGW project decided to use MIT for parts of code that directly connects to underlying OS. With AGPL it becomes tricky. Because between your AGPL program and "end user" can be a huge amount of system and other libraries and programs (server software for example), you have to state boundaries. Otherwise the definition of "end user" is becoming very vague. &gt; So, GNU AGPL v3 ? Their code is under core is under AGPL, but their API has an exception about that. Their client libraries are Apache. And even with that, they also send you signed paper "on request" that they would not sue you if you only use MongoDB without modifying it. Aaaaand even with that it's still tricky, and a lot of people are either a) buying a commercial license for MongoDB b) avoiding it altogether. Sources: http://blog.differential.com/a-mongodb-story/ http://blog.mongodb.org/post/103832439/the-agpl http://www.mingw.org/license http://programmers.stackexchange.com/questions/107883/agpl-what-you-can-do-and-what-you-cant https://www.gnu.org/licenses/gpl-faq.html#WindowsRuntimeAndGPL https://www.gnu.org/licenses/agpl-3.0.html 
I don't see any issue in your architecture that would prevent unit testing or clean coding. I myself use a similar approach, slightly more complex however: I have several common packages in addition to main: * `api`: implements handlers/services for `/api` rest endpoints (json), * `web`: implements handlers/services for other endpoints (html), - front-end/browser form processing happens here * `web/templates`: templates generated by `egon` - just rendering of html * `common`: provides some shared functionality (self contained package) * `common/subpackage`: some more specific self-contained packages * `api/structs` (this could be in `structs`) - most of the CRUD sql code is here The basic point of all these in comparison to yours is that: 1. I am dividing the handler/service into `web` and `api` packages by role - handlers are usually defined just in one `handlers.go` file alongside all the services (implementation), 2. Each package is as self-contained as possible to avoid circular dependencies (diamond dependency problem). When I import a package it's import line is finite/unidirectional. 3. I have absolutely no issue adding tests, even in sub-packages. From what I read, you could avoid the dependency passing a bit, perhaps with an Object Factory pattern, but people using Go generally take a negative stance towards DI as it's not idiomatic. If however you'd like more information about DI in Go, I'd suggest you take a read of some of my articles of how I leverage it for some benefit. 1. [Dependency Injection patterns in Go](https://scene-si.org/2016/06/16/dependency-injection-patterns-in-go/) 2. [Dependency Injection continued](https://scene-si.org/2016/07/07/dependency-injection-continued/) I am also the author of [API Foundations in Go](https://leanpub.com/api-foundations) which you might find an interesting read for your case. If you figure out how to contact me (twitter), I'll gladly send you a free copy.
You may check out this package for a simple example: https://github.com/snickers/snickers - the `rest` package is very similar to what I have under `api`, and the database connection comes from an object factory under the `db` package (`db.GetDatabase()`). The simplicity might or might not work for you.
I'm fascinated by the wiring in the banner photo at the top of the article. Nothing there is a generic component I could pick up at a store in the US, so even though it might be very generic where you are, it's fun to look at for me. :) Also, the powdery tile around it and chunky block components plugged into the cabinet--some in disarray--gives it a gritty look. Very nice.
So... I'm a bit new to Go, but from the looks of it, you accomplished all this by interacting with the file-like objects that the Rpi has for the GPIO. It's just some simple standard library work, right? The Bash seems to indicate that Could you verify your top few lines of code (package and import) or link to a Gist of the entire contiguous file so that a newbie feels a little more comfortable? :-D
`panic` is for coding errors (for those writing code using this package). Failure to set a required environment variable is an end-user problem and `log.Fatal` (as written) is far more appropriate (assuming there is no sane default or way to guess at one; e.g. as is done for `GOROOT`).
I definitely believe in splitting handlers and domain logic up. That way I can test application functionality without worrying about making HTTP requests. I am partial to removing the `repository` package and giving `service` access to the database connection though to make things simpler.
&gt; There are usually not right on wrong decisions in coding style. They are just decisions. Which is why i used the word "prefer". And if you read my pros and cons, I said exactly the same thing. &gt; you are seeing problems where they do not exist. You're wrong. I've written ~30K lines of production Go code. I've reviewed and refactored 1000s of lines and I've seen all these issues i've raised again and again. It's why I chose to use the scoped if/else style and it eliminated all those problems. I prefer code that is less likely to allow bugs as it's written and as it's maintained, and I'm telling you, the scoped if/else is that style. It doesn't mean it's always the best. I'm just saying it should be preferred. &gt; Go is about simplicity. Think again. There are many type of simplicity. Consistency is a form of cognitive simplicity which the scoped if/else style provides. &gt; It's Go not Golang. And you think I'm pedantic? I'm talking about the language spec and I prefer Golang because it's a better search term. &gt; Forget about all this. This is totally not worth it. I agree. Pushing against a community of folks unwilling to be open to even honestly and respectfully _consider_ the possibility for change is aggravating. I wrote a well thought-out pros and cons and from my extensive experience in this industry have weighed the pros and cons of each style. I'm commenting on a documented style outlined in some guides, claiming it's a bug/anti-pattern, and providing supporting evidence. And you discount me and my views as pedantic. And, honestly, I don't/didn't want a debate/religious/flame war about this. All I want(ed) is a complete list of pros and cons of a particular style. It's irrelevant that it's the idiomatic way because the Go authors chose it. Like i said before, they've made other mistakes. I think their preferred style is one of them and I don't prefer that style. I'm just looking for evidence that contradicts me. If there are more pros for the flat style that i've overlooked and that outweigh the cons and the pros of the scoped style, i want to know that. It's very easy to be blinded by your own preferences and I'm simply trying to avoid blinders by asking everyone else to weigh in. In the end, I'll keep writing in my style unless I find sufficient reason to change. You keep writing in your style.
All the packages are in the standard library, yes. Here you go: [gpio.go gist](https://gist.github.com/titpetric/bc3e43b2c6efc2cd9364cf52ffbc17c4) - save, run 'go run gpio.go' - alas, you'll have to modify pins1[] and pins2[] and most of main() to what you'll wire up.
This is definitely true, especially with modern platforms where memory isn't a problem. However, if one method on a type has a pointer receiver, I think all methods on that type should be pointer receivers, too. This keeps confusion down, and encourages only a single kind of usage (always pointer or never pointer) for each individual type.
I'm curious why you decided to use cookies and csrf tokens instead of bearer tokens like most other JWT implementations. Also, why use asymmetric key encryption if the middleware must know the private key? And lastly, you don't verify the signing method, so you would trust a JWT that I created and signed with your public key and a signing method of HS256. This is a common vulnerability in JWT implementations that use asymmetric keys, and it's the entire first page of results you'll find if you Google: jwt vulnerability
&gt; Which is why i used the word "prefer" You used the word "wrong" and you keep using it. &gt; And you think I'm pedantic? I'm talking about the language spec and I prefer Golang because it's a better search term. I didn't say or implied your are pedantic. I merely pointed out that the name of the language is Go and not Golang. It's fine if you type "golang" to search about Go but when you talk about Go then at least say the name correctly. Do you also say Clang and Dlang? &gt; Pushing against a community of folks unwilling to be open to even honestly and respectfully consider the possibility for change is aggravating. I did the effort to read your code and comprehend it and I also read all your comments and issues on Github. Isn't this enough "consideration"?
Substitute dependencies for local interfaces to break circular import; which is subtly different from "create interfaces so they can be injected". But, a `blog.User` and `blog.Post` would tie such idea together. If things are deeply interlocked they should be in the same package. Now `blog/admin` and `blog/manage` packages would depend on `blog`. Then you might also have `server` that serves and presents the blog content, and ties together `blog`, `blog/admin`, `db`, `blog/manage`. (Assuming a simple regular blog) Now when the whole system is not a blog, but has more things, you would separate out... let's say you also have a gallery.. you would first bud out `user` from `blog` and make it depend on `user` and create `gallery` which would use `user`... Now the thing that needs to tie those all ideas together would be some `dashboard` where the end-user can see all his possible actions and modification. Now the way that `dashboard` depends on `user`, `blog`, `gallery` could vary, either there are `dashboard.Users`, `dashboard.Blogs` interfaces ... or a direct dependency, if you either are not concerned about testing or the direct dependency contains something that can be substituted. It would depend on how the end-user perceives the application... as it will cause the least amount of mis-communication between intent and action when changing code. *However it may not be the least amount of code.* Imagine how the whole package tree creates value for the end-user and do not worry about repositories/interfaces/services/controllers etc. When making a change see how the "value-tree" changes and adjust packages accordingly... So, depending on the situation and context of the problem any of your proposed solutions could be used, or even some solution that you did not mention. For example: [goddd](https://github.com/marcusolsson/goddd) uses `cargo` package to contain interlocked domain models.
thanks for the tool - it's really nice. but in Golang library context "zero dependency" usually means it has no dependencies on other libraries, i.e. so that one can embed it into his vendor folder without any concern about dependencies' version conflicts and so on.
Thanks for the great feedback! The package is fairly opinionated for now and I think I might expand on the options struct to allow for more user input. As for why I chose to use cookies, I was heavily influenced by [this article.](https://stormpath.com/blog/where-to-store-your-jwts-cookies-vs-html5-web-storage) Essentially, using http only cookies and an X-CSRF-Token is a very reliable strategy for dealing with both XSS and CSRF attacks. However, there are downsides of this approach. Would love to hear your thoughts, though. I chose asymmetric signing because I like the idea of sharing a public key to allow others to verify a token. Maybe I was thinking too far ahead, but I imagined a user might want to have an auth server and one or multiple api servers. The auth server could contain the private key and share the public key with the api servers. Again, something I should add as an option to allow the user to choose. ~~Completely agree on the signing method vulnerability. I'll need to provide an update ASAP. I built my package on top of [this library.](https://github.com/dgrijalva/jwt-go) The library mentions that they'll be making changes to address this that are likely backwards incompatible. But I should go ahead and provide my own checks in the mean time.~~ EDIT - the library now checks the signing alg thanks to a generous pull request from github.com user se77en. Thanks!
sorry for the confusing, any better description that you can suggest
 expectedFactorial := 720 actualFactorial := GetFactorial(n) assertMatch(t, expectedFactorial, actualFactorial) why not just if g, e := GetFactorial(n), 720; g != e { t.Errorf("wrong factorial: %d != %d", g, e) } 
If single letter variable names are a problem then how about: if got, want := GetFactorial(n), 720; got != want { t.Errorf("wrong factorial: %d != %d", got, want) } For better or worse, this "funky" way is considered the ["standard" way of testing in Go](https://golang.org/doc/faq#testing_framework).
Actually, with more fleshed out variable names, this looks better. I like `got` and `want`; they're both short and descriptive. Thanks for your help!
&gt; every dependencies are singletons with a " map[request]SomeData " That sounds bad. I wouldnt suggest that either. I dont like calling them singletons though. I think I understand your point. I suppose I disagree (not calling anyone wrong :) ). I really love http.Handler's interface. It feels like a great Go interface because it defines only the required input. I've written pretty complex systems and haven't had many issues with "closures of closures of closures. I like defining structs/functions that are explicit about what they need to work correctly. Can you link me to a post describing what you prefer instead? I would be interested in reading about it.
&gt; so how to you pass dependencies to your handlers? You keep a struct with your dependencies and assign your handlers as methods to that struct.
You can pass dependencies by writing function which you pass the dependencies to. The function returns a closure which takes response writer and request. This way you can use the dependencies in your closure.
&gt; can turn of beginners that want to experiment. In my experience with being a beginner and with other beginners, no one wants to experiment. We just want a minimum-viable-opinion on how to develop with that language. Or even a framework/library. I get pissed off whenever I have to learn a new framework or language, and the first few days are spent reading how to use it, instead of directly using it. Most beginners have a goal, and it certainly isn't "experimenting". Unless you are a experienced dev who is "beginning" in a new language, tool or framework, with no time constraints.
I would also advice table driven tests, for example: tests := []struct{ input int expected int // or want }{ {input: 6, expected: 720}, {input: 1, expected: 1}, // etc... } for _, test := range tests { if got := GetFactorial(test.input); got != test.expected { t.Fatal() // etc... } }
&gt; Your dependencies still need to be instantiated at "request time" or they are global You initialize the struct once when the program starts. What's the problem with that? &gt; What if Dependency1 depends on Dependency2 and a Dependency3 not listed here ? If you find out later that you also have a new dependency3 then you simply include it in the struct.
I totally agree with this way being fine, apart from when it is used incorrectly. I've seen a lot of tests like this: if got, want := GetFactorial(n), 720; got != want { t.Errorf("Wrong result") } which are totally unhelpful. Having some sort of assert function (like provided by https://github.com/stretchr/testify) can help people write tests which have a nicer standard output on a large team.
I think it helps a large team to have one less dependency to the project and write descriptive messages instead. If people on a large team write error messages like this: &gt;t.Errorf("Wrong result") Then there's something really wrong at large.
What's wrong with using https://github.com/davecheney/gpio ?
&gt;Most beginners have a goal From what I've seen, many just wants to learn and they need to be told they should pick a project and learn along.
Just to confirm, is this because `new()` returns a pointer by default? (e.g. `&amp;Command{}`)
&gt; Yes they are , in your example they are , they are not created inside your handler. just because they are in main doesn't change the fact that your dependencies are still global, relative to your handler. No, you're wrong, sorry. They are literally not global, you cannot access those values globally, they're only accessible inside the function they are made in. 
dope thank you
Go is very simple and quick to learn. However, it needs a better dependency management system that allows locking versions. Going latest with all the dependencies can break things and happened me a lot of times with Golang projects.
At first, I was thinking, "gah, another one...". After looking at the readme, I can see how that would be helpful in a lot of cases. I'm curious on performance however. Do you have any comparison benchmarks? 
I know users are already aware of other similar libraries. I really liked using this on my personal projects so a github upload made sense. Performance is a high priority for the next update. I will be sure to include benchmarks as well.
Yes. "./Stockfish-master/src" is a folder. I thought that I could execute Stockfish only with the path of Stockfish. Now, I solve my problem and I know how to do it. I must say that execute Stockfish in this way it isnt stupid because this is only a part of a bigger project. Many thanks for your help.
In terms of headers vs. cookies, my experiences fit better with [this article](https://auth0.com/blog/2014/01/07/angularjs-authentication-with-cookies-vs-token/). My APIs are consumed by mobile apps and by webapps from a different origin (CORS). Anyway, so long as you're using cookies, you may as well set `Secure: true` on them so they're only sent over https.
We've been using the net.x version of this context package from Google for two years now and I cannot imagine designing a large-scale system without it. For instance, having request-scoped data stored as a Value allows our logging system to send an immense amount of contextual information at almost any point deep within our app without the low level code knowing a damned thing about its calling context. Here's a lengthy example I posted trying to convince the AWS Go SDK team to use this pattern (I failed): https://github.com/aws/aws-sdk-go/issues/75 Learn it, use it, love it. That's all I can say.
I think JavaScript is exactly the opposite of beginner friendly because it sets you up for making huge mistakes without ever preparing you for them.
I just love how people will do ANYTHING to not read other's people code. Even creating unmaintainable code themselves. Jokes aside, your last example is contrived at best. Just like you said, the context.Value is intended for values that may not exist in scope. And yes there is very good way check for it: func FromContext(ctx context.Context) (*User, bool) { u, ok := ctx.Value(userKey).(*User) return u, ok } Yes I agree, that this breaks type system. It's sad, but until one day that we finally have generics (and proper type system inference) - this is a hard reality. From my experience the best code is the one that everyone in the team can understand, then the one that follows "strict rules". Over abuse of interface{} is bad. But over abuse of closures is just as bad - you just move the toxicity from compiler to your colleagues mental health. I think we can call it - closure oriented programming. Funny thing, but it took me 5 seconds to fully understand what you were doing in context.Value example, and around 5 minutes to fully understand second one. Give them back to me! =D Other than that, it's very well written article. DB instances should be not be stored in context because they don't have any relation to **context**. Logger instances are tricky one - as you said if logger contains scoped data, that may be a very good reason. P.S. As for the "insanity" that happens somewhere in this comment section - DI (like Java or C# DI) is not a solution. Request scoped DI would hurt your application performance. Badly. P.P.S. Martini is pretty much alive. Is just slow. Too slow. 
I am still sad to see that the "static analysis tools" mentioned in the documentation [1] have not been released by Google. I've been told that the tools exist and are helpful. Of course it is not clear if these tools are separable from Google's development / build system, but even a blog post explaining how they perform the static analysis would be a start. With this landing in the standard library in 1.7 I am hopeful that this could happen. [1] [Github: context.go source](https://github.com/golang/go/blob/master/src/context/context.go#L25)
I recommend that book to lots of noobs now. I now recommend Go instead of Python.
Checking for "ok" on `interface{} -&gt; type T` assertions is always good practice. In the case of the context package, you are expected to wrap `ctx.Value()` calls within your own package. Since Value is implemented as a `map[interface{}]interface{}`, _and since keys in Go maps are evaluated first by their type_, you can key the value assignment by a package-private variable. [1] [1] [See the 'value' section](https://godoc.org/golang.org/x/net/context#Context)
https://gopkg.in 
Thanks for the feedback. I'll give that article a read. Definitely agree with the web/mobile argument.
https://github.com/skelterjohn/wgo may ease your angst.
&gt; Go makes object oriented programming possible with structures. *sigh*
I've been doing Rails dev for a while and just got interested into Go. I recently ran into a case where I needed to do some date calculations and thought this might be helpful for others. I'm not sure if this is the way to reuse code in Go and share it. Any feedback would be appreciated!
[Yes](https://golang.org/dl/), since 1.6
I implemented JWT with public/private key signing and deployed it to production. I found on the hard way that public/private key signing doesn't scale that well (of course by design) and this ended up eating a ton of CPU constantly. For this reason protocols like SSL just use public/private keys to share a secret for generating session keys that use symmetric encryption for all messages after the handshake. We had 1.5 million users, so YMMV. It's a shame though. The cool thing about using asymmetric encryption is that you can have a SOA with only one service that issues keys. Then you don't have to distribute the private key to other services and worry about them being compromised and giving the attacker the ability to impersonate any user. Too bad it just doesn't scale.
Yes, though `new` can *only* ever return a pointer, so I wouldn't spring to use the word "default".
worked perfectly when there were no errors. why does a for loop and an if statement not work in this case? I feel stupid for missing the default scenario on the switch but I don't see why it worked when the other ways did not.
Tools can help generate table driven tests from source code. I use [gotests](https://github.com/cweill/gotests) for this.
I'll agree with the other reply, sometimes beginner-friendly does mean that you forbid beginners from doing something that is potentially dangerous to develop a habit of.
what's wrong with just using godep (or similar vendoring tools)?
Because that's a selection between channels; in case of no error, your -errs chan is empty, a receive will wait indefinitely. A select with a default just chooses the default case in this case.
Converting int to string will probably interpret it as a `rune`, so it will output the unicode code point. Use [strconv.Itoa](https://godoc.org/strconv#Itoa) or [strconv.FormatInt](https://godoc.org/strconv#FormatInt) instead (or, better, just use `%d` instead of `%s`.). There are several other things how you could improve your code: * Don't use `f.Read` and assume it actually reads the 2 bytes. [The interface](http://godoc.org/io#Reader) allows short reads. Use [io.ReadFull](https://godoc.org/io#ReadFull) to guarantee, that `b1` is filled as good as possible (also, check for errors) * Reading data and then wrapping it into a `bytes.Reader` is unnecessary. Instead, just pass f to `binary.Read` (also, check for errors) * Use `defer f.Close()`, directly after opening `f` (or rather, after checking the error of opening it). Not only is it more idiomatic, it's also safe against `panic`s
The thing is vendoring only work with application. You gonna have a bad time if lib writer start using vendor.
binary.Read(...) reads only as many bytes from Reader as needed by the type of given variable, so there's no need to create intermediary bytes.Reader, [example here](https://play.golang.org/p/G5G6Mon-0a) Another option, if you have []byte already, try converting directly using binary.BigEndian functions, something [like this](https://play.golang.org/p/CIfQP6ibco)
hard to hear the speakers
Apprently you're supposed to be able to use GPIO mmap without eleveated privs "soon"... (See https://github.com/raspberrypi/linux/pull/1112/files) I don't know if Dave's lib supports that already, apparently https://github.com/stianeikeland/go-rpio does.
Duuude, lava lamps are cool. One suggestion is to make a R2D2 replica that would do it's "panic scream" when a build fails, but it's nowhere close to the lava lamps' level :p especially 12 of them. It's going to be hard to come up with something better than that.
I've been interested to use it for my own packages, but I'm not sure how stable it is (the uptime report link doesn't seem to work, getting a server error on some pingdom page). To me it feels like it could go away any minute without notice, since it looks like it's just run by one dude on his own home page.
It's pretty reliable. I wanted that more people used this. There's also this self-hosted alternative: https://github.com/slimsag/semver
Well, having read the new release log from the 0.9 version it seems the maintainer rewrote the whole thing to cut down on feature creep. As to the LE support I am personally very happy about it since installing and maintaining sec certificates on different platforms is a royal pain the the arse (I have wasted hrs if not days of my life on this trivial obfuscated BS). But that being said I'm happy to have the LE feature available as a plugin so that it doesn't bug other people down!
Thanks. Unfortunately, I didn't ask for opinions of how I choose to spend my time. I asked for input on the pros and cons of the if/else style forwarded as idiomatic by most of the community. If you aren't interested in contributing to my pros and cons, you are completely free to ignore the post. I choose to focus on this because: * I consider it to be a flaw in the ecosystem upon which I dedicate a tremendous amount of my time, and * whenever the question arrises, few seem to have considered all the points for and against the various styles, instead, just saying it's idiomatic (in other words, because you're told that's the way to do it). When there are very real ways for a style to introduce bugs into the lifetime of a program and there is a very easy and consistent way to avoid those bugs with almost no effort, I don't think it's trivial to consider changing styles. Avoiding common pitfalls is one of the big reasons Go even exists. It should prefer that throughout and definitely over a relatively minor readability style. In other words, if you have to type two extra curly braces and one extra word but you can always avoid a few types of bugs without even thinking, doesn't that seem like a beneficial technique?! I think so and it's why i almost always use scoped ifs. And in the many 10s of thousands of lines of production Go i've written, it has served me well through refactors and not hindered readability in the least.
If you're the application developer and not the syadmin, I'd say Cloud Foundry is fine: it's easy to use and very convenient when you have a stable CF environment to deploy your applications onto. But as the other poster said, I've got the impression that it takes a lot of machines and manpower to keep CF running smoothly. So if that is part of your job role, might be better to avoid it.
Hey, It's very recommended, almost mandatory, to do error checking. For instance, you have https://github.com/dylanjt/gohunting/blob/master/gohunting.go#L31: req, _ := http.NewRequest("GET", emailHunterUrl, strings.NewReader(formValues.Encode())) Without checking this error, you are ignoring any error when creating the request to the EmailHunter URL. 
Thanks! This was laziness I overlooked and forgot to brush up before publishing. Will tend to this asap, thank you for taking the time to look through the project.
Starting to learn Go prompted me to play around with docker containers (cross-compile, pre-built servers, ...). Being unable to list tags got annoying pretty quick. (:latest of project X is a 460MB ubuntu-based container, what I wanted was :alpine-latest at 8MB, but nobody but the web page told me that.) So I set out with a couple of structs, http.Get and json.Unmarshal and rolled my own simple tag lister. Please tell me what I can improve. :)
Cool, I hadn't realized that `go-kit` allows adapters to multiple types of service discovery. I'll look more closely into it. On first glance it seems pretty straightforward, but I'll need to investigate a bit. Thank you for the suggestion!
sadly there are no vods on the twitch channel, i didn't had time to watch it live
Do you have an example of that solution?
Thank you! Totally missed that. I grabbed the Printf from a Hello World tutorial and didn't even think to change that... I've been too spoiled by Python's print function.
Thank you for that example, super helpful. Will try it tonight after work. Here's another question though: my real-world use for this will be to do MANY small file reads from 100-200 MB files. Will this method work well for that or is there a preferred way to do many small reads?
If you are worried about the number of reads, wrap the file in a `bufio.Reader`. That will, as the name suggest, do buffered io, with no added code complexity.
Yes, you could run a reverse proxy on port 80 and then fan out to the different backend services. Though I just can't get over how paranoid some corporate firewalls are. Can't send HTTP traffic to non-80/443 ports? What a pain.
&gt; Would you use CloudFoundry or Kubernetes for your projects? They seem similar in that they are running your app in a container to better utilize your vertical stack. They're not really the same thing and are difficult to compare. Cloud Foundry is a platform for application and container deployment, while Kubernetes orchestrates containers. Use Kubernetes when: * you want something that will put a container somewhere appropriate on your cluster and run it for you * you want a developer experience where you push containers, and you want to own the containers * you're resource-constrained (but also see [minikube](http://kubernetes.io/docs/getting-started-guides/minikube/) and [pcf-dev](https://github.com/pivotal-cf/pcfdev)) * you need your containers to run with high privilege levels Use Cloud Foundry when: * you want to run, deploy, and manage applications, and you don't want to manage containers * you want a developer experience where you push applications or containers, and the platform manages them for you * you need your applications to have strong security defaults * you want to enforce twelve-factor applications 
I'd echo what jxf said , but one thing I wanted to say is administrating Cloud Foundry actually doesn't require a lot of people or time, I'm not quite sure why others are saying it does unless what they're saying is "I never really learned BOSH, fuggetaboutit". I run or help others run three moderate sized (50+ servers each) CFs on Azure, AWS and vSphere and really I spend maybe a couple of hours a week for each, they run themselves otherwise. Most of my time is helping devs with their projects, not running the platform. That said, - Running CF open source requires BOSH knowledge which has a high learning curve, but is very productive once you do learn it. If you have money you can subscribe to a commercial CF like BlueMix or HP or Pivotal which makes it easier and gives you a support - CF does require a lot of VMs out of the box, you can customize the BOSH deployment manifests to use fewer fairly straightforwardly... though with the open source version, but again, need to understand BOSh 
Have you looked at Aerospike yet? Interesting article... I'm still not fully sold on the whole nosql stuff. I'm currently working with postgres and Aerospike for caching ... 
Do you consider bosh-lite (https://github.com/cloudfoundry/bosh-lite) to be a reasonable way to run CF on a single machine?
Depending on the project, you could use Go just for api's and do the frontend (including templates) exclusively in Javascript.
I tried that as well long ago. I ran into some issues which made me pic vimium over cVim (don't remember what it was anymore). Also 16k users vs 205k users.
`gorm` is nice, I used it for a brief period. However, it could as well be too much. I typically go with standard library and add `sqlx` if I feel it tedious to boilerplate reading from query results into structs. It's a thing layer adding some convenience. I do like writing SQL by hand rather than it being generated by ORM. So YMMV. The rest should get you started pretty quick and you'll add more libraries as needed (image handling and resizing, authentication, various API wrappers, mail sending helpers, etc.)
Then you're on the right track friend. HTML is pretty simple and once you get it down enough start diving into JS. :)
For #1 https://www.gophercon.com/schedule/ If you go to July 11th or July 12th and click on Room 501-504 or Room 505-507 you can see the full descriptions of the talks. The only talk (that I'm aware of) that wasn't what was described was Kelsey Hightower's, which he changed right before giving it. If anything else changed on the fly, there's really not much the organizers could do about it. For #2 They sent out an email. I don't have the text, but here's one response: https://willnorris.com/2016/06/gophercon-family-track And the post to their twitter account: https://twitter.com/gophercon/status/734856127310073856 I can't speak to the family crash room, but I think you've got some good suggestions that might be worth including on the survey they emailed out in the last couple of days.
[removed]
Do you have a github or [playground](https://play.golang.org/) link to your go code? Also, I find it hard to follow what you are trying to accomplish. Simply saying what you have done in node doesn't really tell us the problem you are trying to solve. A straight transformation from node =&gt; Go is unlikely to be idiomatic, it's easier to just state the problem. ie. I want to build a websocket-based server which broadcasts a repeating series of floating numbers. Do you want a delay between those broadcasts? Or is that just how you have to do it in Node? etc.
I'm not sure exactly what you're getting at but here's [an example of using tickers and timers](https://play.golang.org/p/m5mCpGtzMS)
So, is swift the new Go then?
AngularJS only starts working once it hits the browser, so Node.js or Go is irrelevant, in fact you could event have an HTML page sitting on a cdn and it would work. But also I would advice you skip out on AngularJS, I have used it extensively and It's awful. 
Do consider Deis as well. It's an open source Kubernetes based PaaS.
https://godoc.org/github.com/Mparaiso/gonews/core In my opinion these symbols could be reduced in complexity - things like "controller" don't really make much sense at the logical level Go operates at, unless describing a piece of hardware or attempting to match somebody's pattern, which should have been referenced in the documentation if so. A "gonews Container" isn't really a clear type of thing. This is fine. func MapRowToStruct(columns []string, scanner Scanner, Struct interface{}, ignoreMissingFields bool) error This Container is a trigger for me, passing around context means...always passing around context. I've been doing it but am attempting to figure out how to not. Private variables in packages seems like an ok alternative. func UserProfileController(c *Container, rw http.ResponseWriter, r *http.Request, next func()) I'm not convinced on interface types in this kind of thing, although that's what I'm working with now. type Container struct { ContainerOptions ContainerOptions CSRFGeneratorProvider TemplateProvider SessionProvider LoggerProvider FormDecoderProvider // contains filtered or unexported fields } I haven't used Ruby on Rails, but my understanding is there is a reputation for slowness due to "on Rails"'s significant functionality that enable the day one application.
&gt; **Q**: What happens if a service goes offline? &gt; **A**: Whenever possible, a service should call its client's [`Close()`](https://godoc.org/github.com/ursiform/sleuth#Client.Close) method before exiting to notify the network of its departure. But even if a service fails to do that, the `sleuth` network's underlying `Gyre` network will detect within about one second that a peer has disappeared. All requests to that service will be routed to other peers offering the same service. If no peers exist for that service, then requests (which are made by calling the `sleuth` client [`Do()`](https://godoc.org/github.com/ursiform/sleuth#Client.Do) method) will return an unknown service error (code `919`), which means that if you're already handling errors when making requests, you're covered.
ifft is a great option (unless you want to code a scripting language), i would go a simple web API+json objects... if you need more than that... write a scripting language (go parser+ast) theres also a bare-bones javascript intrepeter for/in go. (not even bare bones, its really nice) 
I was actually trying to use that one, but all it did for me was panic in a very unreadable/non-understandable way. Gladly, I came across this interface which I'm using soon after - and don't need to look back since. Honestly, I'd most likely use a lib for I2C/SPI/UART interfaces, because they are *way* more complex than just a read/write 1 bit GPIO.
In that case I hope someone else will :-)
If you own a Mac you can test stuff on, sure.
[removed]
&gt; should have used some trim function This rings home for me. My coworkers have a habit of throwing regex at *any* string matching or trimming problem, no matter how simple. 
You could try it out. There can be a non-trivial amount of copying data back and forth between the Go runtime and the JVM, and you're fairly limited in the types that you can bind to Java. One project, [gojava](https://github.com/sridharv/gojava), has already kind of "ported" gomobile from using the Android APIs to regular Java APIs, so it might be worth a shot. Another possibility is using protocol buffers to communicate between the core application logic and the GUI. This can be a lot more complex but it removes any kind of coupling to a certain platform or language.
In theory yes, I've never done it myself though. Keep in mind that the calling between java and Go in itself has performance penalties, and unless you are spending a lot of time inside Go, this might not work so fast.
See also https://commandcenter.blogspot.ch/2011/08/regular-expressions-in-lexing-and.html He speaks specifically about lexing and parsing, but the larger points can be generally applied. My personal opinion is, that regular expressions shouldn't be used pretty much ever, except for interactive use. They are unreadable, unmaintanable, undebuggable and slower than a hand-written alternative. If you have the time, just write actual code.
Why do you want to move the core to Go?
Comparing Apples to Orchards are we? Kubernetes orchestrates containers, Cloud Foundry is a PaaS and to begin with orchestrates containers as well as VMs. A long time user of BOSH. Enterprise Yaml Architect. :)
You can use [gRPC](http://grpc.io) to define a server and client interface and move the business logic slowly to Go, with the UI doing less and less over time. 
Yeah, it is. I'm currently using the community edition simply as a cache for database queries. It's really fast, hence i chose it for caching in front of Postgres. I'm just currently wondering if i'm overcomplicating things by having basically 1 database and 1 cache instead of just using 1 fast database. Aerospike gives me few houndred s for requests.
Our internal Go guidelines recommend avoiding regular expressions and I suggest alternative string operations when I see them during code review.
I don't think Go is a very good choice for hackathon projects. If you're looking for something like "here's a collection of libraries to help you bootstrap a Go app", the awesome-go github repo is your best bet. Honestly, the node one isn't even that optimal. There is really one choice for career hackathon participants, and its Meteor. Some people [talk about Twilios seed pitch as being one of the most impressive things they've ever seen](https://news.ycombinator.com/item?id=11985368). Meteor is the exact same way; in five minutes you can have an app serving real-time live data to clients on web, android, and iOS. Given a couple hours, you can have react native apps getting the exact same thing.
Your proxy is probably set up wrong. Caddy to Caddy proxying works fine for me...
It just uses `transparent` preset and `without`. Proxies to a `gin` based application just fine as well as to `apache` site. My guess is that my upstream `caddy` is not set right. That one uses `fastcgi`. However, it does work fine standalone. And I built a minimal, very simple config that still fails. The reason it works for the first request (yes, i does load a page without assets or I can load just one JS or CSS file) and then stops is it seems to detect a failure (max_fail is 1 by default) and then starts 404 everything afterwards without even trying to pass upstream. I might try troubleshooting it a bit more if I have time to waste this weekend. Could be something to do with health checks or with tls mismatch or ...
then use non-standard trim? It's at most a handful of lines of code.
I just like developing my own structures, interfaces, and lists. I'm have more C experience at the hardware level and would prefer to stay completely in Go. My hopes are that a good GUI library becomes ready for prime time use in the future. In the mean time, I'm looking at using SVGo and img libs to create diagrams and maybe edit SVGo SVG diagrams in a web browser. 
Nice project!
Sqlx looks like a good fit, thanks
Why not use atomic writes? var sum int32 for i := 0; i &lt; 100; i++ { wg.Add(1) go add() } func add() { atomic.AddInt32(1, sum) }
It is seriously impressive just how good this plugin is, it feels like a mature, polished, official part of IntelliJ IDEA. Everything just works, including debugging which is no small feat. At this point, what remains is mostly quality of life improvements so if you haven't tried out IDEA + this plugin, now is your chance.
I won't backseat engineer, none of us know your problem domain at all, you do. If you see benefits in Go, then Go for it. You asked how, not if you should, so that's what I'll comment on. I would do everything I could to stay away from marshalling in the same process space between languages through native bindings I.e. gobind as you mentioned. Even if you had some extremely demanding needs in certain hot spots, you could probably shift them to be in Go or Java. I would focus on client / server through via whatever mechanism you think is most appropriate. I personally would avoid thick transports like HTTP, extraneous encodings like XML/JSON. Protobufs over any local transport would work well, could even simply have your UI create worker processes in GO and IPC. It's not particularly fancy but gives you a very high throughput pipeline where memory latency is more binding than cpu. Just food for thought, have fun man.
I know of https://github.com/cayleygraph/cayley
thanks :) my first that has so much success. I've created an hidden markov model editor, and also an neural network library with CUDA support and no one bats an eye, but when I create an ~150 LOC wallpaper generator I have 6 stars and 2 pull requests in one day
These aren't docs, these are posts/comments that show up on SO's site and could potentially break their layout.
Yes, it works with the following: - IntelliJ Ultimate or Community - WebStorm - PHPStorm - CLion - PyCharm (I've tested the Community Edition a while ago and it worked, haven't tested the latest but should continue to work) - RubyMine - AppCode (I haven't tested it but should work) - DataGrip - Android Studio If you have any issues, ping us on: https://github.com/go-lang-plugin-org/go-lang-idea-plugin or https://gitter.im/go-lang-plugin-org/go-lang-idea-plugin
Do the first. Have the function return some value and only export the functionality through that value, to enforce the restriction that it has to be called before the API is used.
I like it. That sounds like a winner. Thanks!
Well, a mutex IS a "fits all" solution. But "fit all" != "maybe there is an even better approach".
Thank you for the nice words, it's nice to hear this from users!
the only issues i've had with this plugin so far has been the spotty debug mode -- sometimes the breakpoints catch, and sometimes they don't. i kinda have to either re-run the debug mode a few times until it works, or i have to restart the IDE. but everything else is great. 
Seriously? My debugger sucks... 
I totally agree, the plugin is impressive. It makes writing go even easier. I had an issue (not related to the plugin itself but go development and Intellij IDEA) I use the plugin "file watchers" to run gofmt/goimports after a save. Lately, when this happens, the cursors is move up one line (doesn't happen always), anyone knows why or how to fix it? It's quite annoying.
Isnt only *one* of the characters supposed to be dumb and wrong?
Wow. This works with Pycharm!? So I can use the same editor for both python and go-programming?
Looks great! I've not seen much of the image packages so the code made for interesting reading. There is a bug on the last bit of main() where you're taking a slice of the filename. ".jpeg" is 5 chars.
Yup ;)
That was my intention, generally 'one-size fits all' is criticized for not being effective in every case [sometimes not even in the [average case](https://www.thestar.com/news/insight/2016/01/16/when-us-air-force-discovered-the-flaw-of-averages.html)]. But thanks, I clarified my post a bit.
Interesting read about the pilot stuff, thanks for the link.
Need to get Docker hub updated: https://hub.docker.com/_/golang/
Either it's me reading it wrong or the docker API is really weird in general. 60% of their API docs don't in any way correlate with what I see when I hit the hub registry with a browser or REST client. As to GCR.io, I can't test it myself since I don't have an account there and it's not for public images. In theory it should just be massaging some URLs...
&gt;Either it's me reading it wrong or the docker API is really weird in general. I always wind up a bit cross-eyed myself. There are a bunch of places where you have to make sure you either do or don't have a trailing slash or else you get 404s. &gt;As to GCR.io, I can't test it myself since [...] it's not for public images. Sure it is. Here's one: gcr.io/google_containers/hyperkube-amd64
Having looked at documentation for other languages, I'm a bit concerned about the quality of it all. Quite a bit of what I've seen is quite opinionative and goes against some languages preferred coding methodology. 
i forget the url, `google go lang javascript engine` gave me this and more https://github.com/robertkrimen/otto
That t-shirt is fantastic.
Having used a variant of this for a few years, I want to say that the correctness benefits this offers are drastically understated. Parallel pipelines are something many a newcomer gets wrong in code review, and a high quality construct like `Group` to reference in these cases is indispensable.
Good approach. My first thought was to combine the first two options. That is, provide a setup method and if the client does not call ituntil the first search, then do the lazy init.
My excitement for this video went up manifold when I saw who it's by! Frecesc, I've been watching a lot of your talks from various Go conferences and I really appreciate your enthusiasm and passion. You also have a great way of teaching/sharing information. Really excited about this, thank you!
Because reddit users don't read the reddiquette and moderate based on opinion, not based on quality :) People disagree with my opinion that regexps shouldn't be used and express that by downvotes. I don't worry about it, it's just fake internet points and I have enough of them :)
Awesome. Please keep doing more.
Really want to thank you guys for this plugin! Have been using for about 6 months now and it has been great from day 1. Makes developing (and debugging!) so much easier in Windows.
Thank you for your kind words. It's great to hear this.
I browsed a bit through the available docs and apparently there is no way to access those features without having a google cloud account with the relevant access bits set and going via `docker login ...` All I can get out of the gcr.io endpoint with curl is either 404s or 401s. And, apart from taking apart what `docker login` does to construct the relevant URLs and POST parameters, I see no documentation how to do that yourself.
Well, you can `docker pull gcr.io/google_containers/hyperkube-amd` so obviously some of the endpoints work. Or are you specifically saying that the tag list endpoints are giving you 401? I'd never seen a 401 on a public image for any endpoint I tried.
you're right. it does seem a lot better now after the update. thank you for your hard work! 
I can't even get as far as the tag endpoints, and a straight translation from the docker REST verbs just gives me 404s. I tried lower endpoints in hope of finding my way down the tree but apparently anything that **could** end up as a push/pull further down is locked behind auth. The "best" I could so far get out of gcr: % curl 'https://gcr.io/v2/repositories/google_containers/hyperkube-amd/tags/' {"errors":[{"code":"UNSUPPORTED","message":"Unknown tags endpoint: "}]}%
Legit, already filed a bug report against it as it seems it can't be vendored, as it uses relative package imports.
Sorry I'm just juggling words all over the place, it wasn't directed at your project but at the web dev market in general.
This is why I love go, readability. That and the added benefit of getting wonderful docs automagically generated from the same source.
I agree with you, screw the opinions and regexp. Here, have some more imaginary points.
I think you should avoid lazy initialization completely and just force the implementer to call setup first before anything else. Unintended side effects are never a fun suprise and makes it harder to debug. Been one too many times when I've wasted hours on some failed API call and realize it's just because it wasn't set up properly beforehand. That and not reading the docs completely...
Thanks everyone for your comments and suggestions. I have one more question. How about the GUI projects ui and libui ? Go ui uses cgo to communicate with the C based libui GUI library. Can anyone comment about when these will be ready to use? 
So I added a documentation page for setting up golang using only basic tools on a CentOS system. What's the review process like?
 // Assume this takes a long time to calculate hardToCalculate := len(job.parameter) select { case &lt;-job.ctx.Done(): case job.responseChan &lt;- hardToCalculate: } `select` is non-deterministic. Does this do, what it is supposed to do?
Makes sense, thx.
The Go plugin for IntelliJ is awesome. I recommend it to all new people, especially ones with a Java background. Highly recommend!
Redis is fast no doubt but we had to use SCAN which wasn't that great. Sure it was our mistake but Scylla supports this just fine and it actually seems as fast as Redis on simple lookups.
The error looks specific to MySQL. My guess would be that you need a terminating semicolon at the end. I don't know MySQL at all so not sure if this is required.
To drill down on this a little: csv.Writer wraps the writer given to it in a bufio.Writer, so Flush is, indirectly, calling os.File's Write, which can return an error. A call to Error would return this, but the deferred Flush is run *after* the check for errors. If the file is small enough to fit entirely in the 4kb buffer that means no errors are reported even though everything failed. I wouldn't have deferred Flush. I'd have just done: //write records w.Flush() //(annoying that csv doesn't return the error directly) return w.Error() If there's an error while writing a record, it doesn't really make sense to bother flushingthe file's still incomplete and the flush would probably fail anyway. But if there's an error during the Flush, you definitely want to return it. (To /u/campoy: Sorry for the backseat coding, I enjoyed the video greatly and look forward to more!)
Yes, [CONDITION is a reserved word](https://dev.mysql.com/doc/refman/5.7/en/keywords.html).
The condition keyword needs to be escaped with backticks, like this: "INSERT INTO bikes(`condition`)"
&gt;Afaik static files served via ServeFiles are already compressed. They're not, or at least not last time I checked, but [I wrote something to do that](https://github.com/lpar/gzipped).
For now, you can add more questions by copy-pasting the questions from the quiz file -- It should be [fixed in the next release](https://github.com/dgraph-io/gru/pull/32).
Thank you everyone! It is now fixed!
As someone learning Go, this was very helpful, thanks for sharing.
I'm not sure why you want to return a closure .. and provide access to things from that? I read your entire post and honestly I am having trouble understanding what you are wanting to do. I would suggest you take a step back from "I want to solve my problem using X paradigm" and let a solution more natural to the language work itself in from the user interaction you want. Start from the other side of the fence, far away from the weeds of the implementation details. When trying to make a usable API you want to try to clear your head of all the little details, in this post you all about nodejs servers, where you get your data, intervals you update things in, etc. All this noise distorts your actual question which is how to provide the user a clean interface to do a thing. It also makes it hard to decompose someone who's not deep in your problem to actually help. That said it's clear your super interested and having a great time with this problem, thats fantastic and it's cool you are careful designing the back end. But now ya got to push all the details deep in the weeds out of your mind and be me. Be a user and start from a clean slate! Make a main outside your package and import it. Now, without any of the functions in the package distracting you make a struct, name is not important I.e. UserStruct. Now add a single function of what you want the user to accomplish. If you can join another UserStruct into your current one, add a method called Join(), just stubs. The purpose is just to mock out the API from the user side. You can look to all sorts of areas of the standard library for different interface idioms. Once you have a better idea of your user interaction it would make asking a question on how to satisfy that interaction easier, as well as answering it :-) Have fun. Feel free to ask a more abstract question as a reply to this and I'll try to help later if I can. Maybe more on the form of: As a user I want to Subscribe to a Feed of Events. I want to be able to Merge multiple Feeds into a single Subscription later, still retrieving all Events.
Honestly, now I want to ask you to look at my code and find where to trim unidiomatic and/or stupid out of it.
Why do you post a 2 - 2 1/2 year old video?
It's a nice idea but the problem with this is it adds another marshaling step for users. It would make adoption a bit harder to justify coming into it with existing code. If I already have a ton of structs and need to change all their types, meh, no thanks. I would rather call a library and maybe register some hook JSON key names with it and get an error. Also still allows chaining without struct tags changing my data. Less changes since keys may be common and shared across structs. I made a library with very similar user flows it looked sort of like this: myValidator := legit.Func(l legit.Value) bool { .. } emailValidator := legit.Email() emailValidator = emailValidator.MaxLength(100) emailValidator.Register(jsonKeyNamesHere ...string) Could also have a validator thats purpose is simply to call other validators if the current JSON struct key was of a certain type. selector := legit.KeyContains("email") emailValidator = emailValiadator.With(selector) Then someone does their standard decoding of any type of encoding through whatever means they prefer. This also allows them to bypass validation on flows that don't need it. Then they could just call the validator with their data to check for an error, gives a nice clean integration point. I.e. data =: struct { .. } ... decode my way. if err := emailValidator.Validate(data); err =! nil { Just food for though, have fun! 
If you look at OP's post history, they've been posting NATS stuff non-stop since the account was created. They're a moderator for /r/NATS_io. The video is a rehosted Gophercon video, in a playlist only about NATS, on a channel created by the people behind NATS, conveniently at about the same time OPs account was created.
Yes, strings are reference types.
String is a synonym for []byte. All slices are [fat pointers](http://www.drdobbs.com/architecture-and-design/cs-biggest-mistake/228701625).
`string` is not a synonym for `[]byte`. They have significantly difference in semantics. They are neither aliases (like `rune` and `int32` or `byte` and `uint8`), nor do they have the same underlying type (like when you do `type foo int`), nor do they have the same memory representation (`string`s don't have a capacity, for example).
I clearly don't because confused why this is on r/golang 
The technician is [Rob Pike](https://en.wikipedia.org/wiki/Rob_Pike), one of the creaters of Go.
Yes one process is capable of using all 12 cores. Read up on the net/http source. It starts a goroutine per request which is automatically multiplexed onto as many cores as available.
&gt; All this noise distorts your actual question which is how to provide the user a clean interface to do a thing. It also makes it hard to decompose someone who's not deep in your problem to actually help. Very true! I'm not OP but thank you for your amazing answer here and below!
Out of curiosity, how does one trade in type safety for less tedious code? Doesn't interface{} in checkers bite when refactoring larger piece of code?
A trade-off for sure, but the tests will still fail after your signature change so. I guess I don't modify signatures enough and especially not with automated tools to care. I don't mind a bit more type sloppiness in tests as long as there are good tests and coverage. 
Aren't table-driven tests already made easier by https://tip.golang.org/doc/go1.7#testing ? (I haven't actually got the time to test Go1.7 yet, but it seems to solve the same issues)
Here's a neat little site that will show you how your struct gets packed: http://golang-sizeof.tips/
I don't think I can, very well. Best I'd do is copy-paste from [wikipedia](https://en.wikipedia.org/wiki/Reference_type). That doesn't cover the "exactly", but computer scientists are very bad when talking about things exactly anyway :)
Worth mentioning that go4.org does not guarantee BC changes. Make sure to vendor this dependency. 
Is this being used in any projects?
That's a little different. Those are good for breaking up a test into different named and separately-runnable units (which functest could use itself), and it's good in particular for taking a big test and running it under a few different configurations. But it doesn't really help with the boilerplate code that functest was built to reduce. 
How about a code review? - do not ignore errors, especially from ioutil.ReadAll(req.Body) - the sources for the package should be placed under edgegrid subdirectory, otherwise it does not work with goimports (import path guessing relies on directory name). - the import statements should be grouped (stdlib, internal and external packages in separate groups) - instead of encforcing body limits **after full the body was read** (`len(preparedBody) &gt; c.MaxBody`) use io.LimitedReader and peek for io.EOF - use fmt.Sprintf in `func (c *Config) signingData` there's no need for allocating temporary slice
I never thought that I would describe myself as traditionalist.
&gt; or feature requests welcome! for me - the true `TableDrivenTests` will be: If I can use external **metatable** ( csv?) * for simple golang testing * and generating documentation ( html tables, markdown tables ) for example a simple csv based testdata for your first example will be : In1,Want1 0,0 1,1 2,4 3,9 
ELI5 what NATS.io is? I don't have a specific use case in mind when I read the start page.
In the *Crypto for Go Developers* talk at Gophercon, there was the following advice: func DontDoThisAnymore() [32]byte { key := [32]byte{} _, err := rand.Read(key[:]) if err != nil { panic(err) } Return key } Instead, do this: func NewEncryptionKey() [32]byte { key := [32]byte{} _, err := io.ReadFull(rand.Reader, key[:]) if err != nil { panic(err) } return key } Can anyone explain the advantage of the second version? Why is it discouraged to use rand.Read() directly? (I don't think the video of this session is online yet) Slides at https://github.com/gophercon/2016-talks/tree/master/GeorgeTankersley-CryptoForGoDevelopers 
Thank you. That makes a lot of sense.
Thanks, in that case I will remove mine
This discussion should answer your question: https://groups.google.com/forum/#!topic/golang-nuts/ZRKSJ3GPkLw
I was not attempting to share entire playlist, did not realize that when I pasted URL for the video from GopherCon was attempting to share it would pull in the entire playlist vs just the video I wanted to share; Sorry about that - certainly nobody wants to watch a playlist.. 
I'm not sure I understand what the problem is. On Heroku, you're supposed to use the `DATABASE_URL` variable directly as your connection string. When running a Heroku app locally, the `heroku` tool will read a file called `.env` in the root directory of your heroku app. Here you can set environment variables, including `DATABASE_URL`, to be used when running locally. For example: DATABASE_URL="connection string here"
True. Although he looks really different. Food was scarce back in the days, I guess :)
If a raw Config object is not useful, and you have a method New(), why not use Config non-exported by renaming it to lower case: config?
limiting the user causes people to write more libraries to fit their needs
Writing a keylogger? I found this: https://medium.com/@marin.basic02/sniffing-global-keyboard-events-in-go-e5497e618192#.ambyxdhns
Go does have crypto secure random numbers a single function call away: "crypo/rand".Read(b) Neither crypto/random or math/random produce random numbers, they both produce psudo-random numbers which are certainly not random. It's a complicated topic. Your question as it is worded has no answer. To ask which method of generation is more random is meaningless, this video might shine some light on the problem: https://www.youtube.com/watch?v=sMb00lz-IfE
How often will these actors be spun up and down? If you are spawning a ton, you may want to avoid defer.
What do message passing, and callbacks look like ?
Sounds fun. Ill try that out. Thanks!
Yes I'm using database_url variable directly as my connection string. However when i check it on heroku logs, it's using the old connection. http://imgur.com/a/6GCwJ 
You're probably going to want to shell out to something like ffmpeg. You could write bindings to libav/libffmpeg, but.. it's not a good idea because of very restrictive licensing reasons AND it'd be a lot more work than just shelling out. Plus, shelling out doesn't have very much overhead because the amount of work done in the external process here is very significant. Beware, you mention youtube videos which might imply MP4 / H.264 etc. These are incredibly patented technologies and you'll need to pay a license fee to MPEG-LA in many situations working with them...
This is not an uncommon practice, but it's a very bad thing to do. SSL computational costs are trivial these days. Don't do a bit of network I/O unencrypted if you give a damn about the security of your system and don't want to expose the data in the system to bad actors -- or anyone else for that matter.
I'm not doing any I/O unencrypted? I wrap SSH connections (which are already encrypted) into TLS connections to get around deep packet filtering.
Not to put too fine a point on it, but you would control your headers when you hit a problem that requires you to control your headers. In the example you gave you are making a request for the response to be in JSON. If you don't even know what that is, you don't have to bother with it. If later on you learn what JSON is and you want a response in JSON, you'll find you have to set the header, and there you are.
The .NET Core runtime doesn't have any GUI toolkits. It's basically server-side only, much like Go.
Looks like your question is about HTTP headers rather than about Go - correct me if I am wrong. HTTP Headers do not only control the format of the response but also [a lot of other details](https://en.m.wikipedia.org/wiki/List_of_HTTP_header_fields). Maybe you want to go through some HTTP tutorial (search the Web for `http header tutorial`) to learn about the purposes of the various HTTP headers.
With a custom HTTP Client you can control client timeouts and TLS settings amongst others.
Why not just printing the result from the go application and execute the program from node and use the output? Way simpler, fast and bulletproof. https://nodejs.org/api/child_process.html#child_process_child_process_execfile_file_args_options_callback
Git comes to mind.
Reference types *are* the variable. For example, in c++ if you write ``` int a = 42; int&amp; b = a; // assuming: void my_func(int&amp; foo) { ... } my_func(b) ``` when you pass `b` to `my_func` you're not passing a copy of `b` or a pointer or a copy of `a` (well, above the covers, that is)you're passing the memory stored in `a` and modifying the `foo` parameter modifies whatever `a` is. Very similar to pointers, but no dereferencing is involved and they're not a physical value on the stack like a pointer is. (Again, above covers.) Kinda confusing if you're new, and I probably didn't explain it very well tbh.
Okay, so I have to ask a couple questions before I give a more thoughtful response in vein. First .. long shot here, but are you using lossy RLE? You say you are using RLE images.. on top of getting some, but not all data.. leads me to think maybe you are using lossy encoded files? Worth a quick sanity check. Second, your general application flow makes no sense to me, the web sockets and everything. Since you are just sending JSON data, make a very thing golang service that listens over HTTP and returns JSON. Then write tests against your implementation without the nodejs and web sockets transport obfuscating where your problem may be. Don't test system integration points at a system level before you have vetted them at the component level. That all said there is a few places in the code you posted for failure in all sorts of ways. Maybe you snipped stuff out for brevity but if your wanting help finding a bug the code your not actually having trouble with provides no value. So, you are not checking errors. That's wrong. But you have a fatal error in your applications logic. Inside of a loop which must decode a file in serial.. you are launching Go routines to do the work in parallel. So more demanding decode chunks are going to cause overlap on short ones. Tldr race condition from concurrency that provides no benefit. 
To be more clear, go decodeLRE should be decodeLRE(). If you want to try to leverage multiple cores do it on a per file process if possible. If you still want to decode across multiple go routines you need to ensure serial responses through other means. I.e. don't send just a []byte to decodeRLE, include a channel. Each call to decodeRLE create a channel to send it for returning the decode result. You can use any LIFO structure for this. Then send that result from the main thread... to ensure serial responses.
If you want to keep it private bitbucket still has unlimited private repos. You can use git or mercurial AFAIK. You could also just use Vagrant and/or virtualbox if you want a consistent emacs experience across platforms.
Hey thanks for the reply. I would agree and definitely argue that most of this tool does not make sense as it's going to be a Photoshop plugin and their entire ecosystem is just crazy. Most of the plugin is run in CEF (embedded Chromium) as an HTML/JavaScript app, but also has access to Node.js for utility. What I found was, parsing these large files and decoding the images was far too slow and locks up the whole tool, even when using Web Workers. It just wasn't fast enough. So I had it in my head to offload the file reading/decoding part and so far Go has mostly worked for that. Regarding the encoding of the images: it's a very dead simple encoding where any repeating pixels are stored as runs, eg. a sequence of 0000 gets encoded as 40 (4 zeroes). Regarding error checking: I do a check for every error in the actual file, I left it out just to keep the sample pseudo code short and sweet. The whole Go app runs perfectly, concurrency and all, when run on its own. It's only when I attempt to pass these decoded arrays back that I run into trouble. I tried using Node's Child_Process.spawn and attaching a stdout handler, but it seems far too slow. I then tried the websocket route, but don't always get all of the messages sent as I described in the OP. This very well could be a race condition thing, or the connection closing before all the messages could be sent... no idea, hence why I asked here in case there's an obvious step I'm missing =) But I can assure you the sample code I put up really is the bulk of the program, I just stripped out the RLE decode part as it's really just a loop of getting bytes and adding them to the array.
If you're looking for something more automatic than vcs, [syncthing](https://syncthing.net/) can set up automatic synchronization on a set of folders. You'll still want vcs to do vcs things, but sync'd folders can help avoid the "forgotten commit" problem.
http://i.imgur.com/TnQRX6v.gif
Ah perfect thank you. 
short answer, no long answer, you are trying to access (as neo user) configuration files under /etc/ directory which can be accessed by root user and by a privileged user in general. In more detail, the process spawned by neo tries to access root only files... i do not know on why you should access as a non root user the cert files. All of my nginx configurations run by root user with no problems until now (1year +). Another option (not tested) would be to store the cert files in a directory which your user (neo) can access, say at /home/neo/somewhere, this should only be accessible by root &amp; neo I suppose but you should investigate any unwanted security holes - issues by doing so.
Use chown to change the permissions on your certs. chown neo:neo path/to/cert 
&gt; i do not know on why you should access as a non root user the cert files. All of my nginx configurations run by root user with no problems until now (1year +). I was running the Go service as root for quite a while without problems. Nevertheless I've been that it's a bad practice. But maybe it's not? &gt; Another option (not tested) would be to store the cert files in a directory which your user (neo) can access Yeah I thought about that but moving the letsencrypt files is not desirable as they get refreshed often and of course the potential security holes that you mentioned.
Use Polymer https://www.polymer-project.org/1.0/
The following is equivalent to your code because a failed type assertion returns the zero value (see last para of https://golang.org/ref/spec#Type_assertions): func NonceFromContext(ctx context.Context) string { nonce, _ := ctx.Value(ctxKeyNonce).(string) return nonce } 
Then make /etc/letsencrypt/live/neo.com/cert.pem Neo readable - either by adding world-readable rights to the file and r-x to all ancestors, or adding neo to a group which have such rights.
`git push thumbdrive --mirror`
He should be fine as long as he is not reencoding these videos, but rather just repackaging them into another mp4. ISOBMFF is free from fees. On the other side, this restricts the usage to having video clip, he wants to combine with, encoded with the very same audio/video codecs (and parameters/profiles) as youtube video. https://trac.ffmpeg.org/wiki/Concatenate
So what aspect of Go strings makes them not reference types in the usual meaning of the term?
Git + https://github.com/google/hesokuri might be the best of both worlds. Runs a daemon that tries to fetch and fast-forward unless there are force pushed commits. Haven't run it myself since I do all of my dev on a cloud VM.
why not just func AuthToken(ctx context.Context) (string, bool) { return ctx.Value(contextKeyAuthtoken).(string) }
+1 this is what I do for source code across 3 computers. Works great.
Well right now it doesn't work right? But because you have so many moving parts you are posting here for help instead of having a working solution you can make small measurable changes to improve performance. I don't understand how the ordering of the RLE decode doesn't matter. Code must be missing that gives byte positions to the caller. anyways I told ya what I would do, remove the "go decodeRLE()" it takes two seconds. Test it and see if it works. If it does you know it's a concurrency problem. If it doesn't, it's elsewhere. That said, I also told you precisely how to do it concurrently safely :-) the struct I wrote should be an example you could work in within minutes. Happy coding.
I would not add more moving parts to this personally. Just more failure points to obfuscate problems. I would simply create a process and send it JSON with Work to do. I.e. work: decodeFile, then have the process send it's results on stdout. Go behaves very well in this setup and you have a direct pipeline between data. Wait for complexity to be met by demand. Once you have a working solution you can experiment quicker and have a baseline to measure against.
Thanks for the suggestion! Does mutex.Lock() itself ensure that other goroutines are blocked until it's unlocked? Or will those goroutines just complete and skip doing conn.WriteMessage if the mutex was locked? I guess what I'm wondering is, do I need to make the goroutine wait until the mutex is unlocked with a loop or something, or does mutex.Lock and Unlock take care of that for me?
If mutex is already locked, `mutex.Lock()` stalls the process until it is unlocked and available for use, then proceeds. So only one process will be able to call `conn.WriteMessage(...)` at a time.
I'd suggest [redigo](https://github.com/garyburd/redigo) for Go and [redis](https://www.npmjs.com/package/redis) for node. But, they are just clients, you would have to have a redis server running on the machine; the same is true of rabbitmq or any other message broker. If you can't do any dependencies, maybe a websocket is your best option. Also, do you really need gorilla? If you're only using the websocket functionality therein, consider using just [websocket](https://godoc.org/golang.org/x/net/websocket). And for node, [ws](https://www.npmjs.com/package/ws) is preferred over [websocket](https://www.npmjs.com/package/websocket) due to performance (~6 million downloads this month for ws vs. ~200k for websocket).
Ah I see, thanks for explaining this, this makes a lot of sense now :) 
Can this potentially be used to write Windows 10 universal apps in Go?
For an async Python http client, look at [aiohttp](http://aiohttp.readthedocs.io/en/stable/).
Hi, sorry for the late response I realized I needed a better grasp on the problem before asking further questions. But anyways, I essentially re posted this question, expect with playgrounds and github links. Anyways: here is the new [post](https://www.reddit.com/r/golang/comments/4ulbba/using_gorilla_how_should_i_go_about_creating/?ref=share&amp;ref_source=link). If you have time to take a look, I would highly appreciate it, but if not that's ok too. Thanks
When I have little projects I like to pick at from various locations, I put them up on [Cloud 9](https://c9.io/). This lets you pick up right where you left off, regardless of what machine you're on. edit to say that a C9 environment is Ubuntu Linux, which I guess might be a little different from what you're used to. I only use Linux so I don't know how much it differs from Mac.
You need channels. The way I handle multiple clients is to create a `Client` struct for every connected client. Each `Client` has an outgoing channel which is passed to the *sending* go routine that I spin up when a new connection is established. The *sending* go routine has a `for` loop with a `select` statement that watches the outgoing channel for any new messages. Then I spin up a *receiving* for loop in the handler function, much like you've done in your example. If there are messages from connected clients that need to be passed to any central processors, that can be done with channels. There's a global map of Clients, and when a new Client is created it's added to the map. If I want to broadcast something to all clients, I iterate through the map and stick a copy of the outgoing message into the outbound channel of each Client. When the connection closes, I remove the Client from the map. In your case, each handler of any particular feed can iterate through a global map of clients whenever it wants to broadcast to everyone (or to everyone who is subscribed).
The standard library of Go has support for the PNG, GIF and JPEG image file formats. While the PPM variant is nice and nerdy, most non-Linux folks are probably more happy with PNG files. BTW, i just send you a [pull request](https://github.com/markphelps/go-trace/pull/1)  Annother suggestion: Your next task could be to make the rendering faster via Gos support for concurrency  at least if your computer has more than one cpu core :). For example, you could use a [WaitGroup](https://golang.org/pkg/sync/#WaitGroup) to start N goroutines (one per Core) to render the rows in parallel.
You should do this. We just did something similar at work with go. Learned loads. Go makes it somewhat easier to achieve as well
Thanks for the PR! Greatly appreciated! I was hoping to add support for more standard file formats. You are awesome. Also, yeah I was thinking about updating to use goroutines to make the render faster. I initially tried that with the anti-aliasing (since it actually calculates each pixel value 100x then takes the average) but it actually made it a little slower. In order to create a new goroutine for each pixel, I'd have to change the render function to write to a map instead of directly to the file since the pixels would be 'completed' out of order (if i'm not mistaken). But yeah that's definitely my next endeavor. Thanks again!
I'm not actually sure if this is a best practice. My friend who is pretty knowledgable with Go suggested I import my primitives package that way. I wanted to qualify it with a shorter name so I didn't have to type 'primitives' everywhere in main. I wanted to basically build a library with the 'primitives' package but also include a working main. Is there a more idiomatic way to do this? 
actually now with the switch to use the `image` package (thanks to /u/Frakturfreund) I dont even have to maintain a map since thats basically what the image is before calling `write`. So slick.
I made a library for doing stuff like this awhile back: https://github.com/djherbis/socket It can handle broadcasting and subscribing to multiple 'rooms'. It's meant to feel a lot like socket.io, though sadly I haven't got my socket.io go library fully working yet.
But what does Go have to do with React?
https://peter.bourgon.org/go-best-practices-2016/#repository-structure
I guess it's gonna teach about making rest apis and using react for the frontend. should be cool
Unlike some languages, Go doesn't encourage lots of small files.
Okay so this almost works... the problem is, even though I see that messages are getting received on the Node side, I don't see the decoded data at all... is it because the arrays are too big? EDIT: it appears not all the messages are getting sent. Out of 639 decoded images, I only see 12 or 13 messages received in Node.
Someone mentioned a library which would be good but I'll second this when (no ifs!) you really want to understand the go way of solving the problem. I'll add to this, though: Maybe have a single dispatch goroutine (and eventual pool) which route messages from broadcasting clients to listening clients, handle client additions and deletions. Therefore the global map of Clients has fewer points of access/modifications. I'll compare it to the 'gopher book pile' example that Rob Pike always talks about. Seriously, watch a Rob Pike lecture TheBeardofGilgamesh =)
Creating your own Client can help reduce the amount of repeated code by virtue of setting a custom Transport. Many client libraries for web service APIs create their own `http.Client` to handle authentication. For example, you could have the client perform basic auth for every request it makes (quickly scribbled code, may not compile): type AuthTransport struct { http.Transport Username string Password string } func (t AuthTransport) RoundTrip(r *http.Request) (http.Response, error) { r.SetBasicAuth(t.Username, t.Password) return t.Transport.RoundTrip(r) } client := http.Client{ Transport: AuthTransport{http.DefaultTransport, "bender", "killallhumans"}, } This client would then execute all requests made to it with the username "bender" and password "killallhumans" (although in practise, you (a) wouldn't harcode username/password, and (b) use a better auth scheme, like tokens.) You could of course expand this to use slightly better authentication methods, perform additional checks before making a request, track request/response statistics, add logging, check for invalid requests, handle error responses...
I was looking for a pure GO CalDAV and CardDAV server, too but eventually settled down on Baikal (http://sabre.io/baikal/).
Maybe this is a kind of a summary of the book ;-) https://pivotal.io/platform/pcf-tutorials/getting-started-with-pivotal-cloud-foundry/introduction
So where's the results?
Tell them I'm excited haha! Also if you can please ask if they'll have a digital copy on top of the paperback :))
I'd like to use ray tracing for a commercial Go project but do not know if I'll have issues with patents. Knowing there is text out there like that is good, directly including a strong Go ray tracing package is on my list. The name doesn't really make sense, and only should be compared to others within your github namespace if you want.
The article is really great, i really enjoyed the read. The only thing that was a little bit concerning for me is the huge timeload to render the last retina size image. I think 4 hours a little bit too much. I think using goroutines will have a huge impact in performance and will render considerably faster.
You should take a look at https://github.com/creack/goray, might be helpful.
Thanks for the feedback! I'm glad you enjoyed it. It was 2 hours if I remember correctly, but yeah I am going to experiment with using goroutines to try and speed it up. 
Hi there again, glad to see you still going at this. I gave you a good deal of design considerations in your other thread, I'm going to write this with those assumptions still made. Since the time between the stock quotes is a constant this trivial to implement. Some others have told you to maintain a client list, but that is only needed when there is disparate state to maintain. There are pros and cons with each approach but this one is simple to implement while you continue to familiarize yourself with go. On mobile, excuse formatting/typos , but the basic concept: type Provider interface { Subscribe() chan *SeriesPoint } type MultiProvider struct { providers []Provider } type BroadcastingProvider struct { clients chan *SeriesPoint symbol string } func (b *BroadcastingProvider) Subscribe() { return b.clients } func (..) start() for { nextTick := time.After(100 * time.Milizecond) seriesPoint := ... For { select { case b.clients &lt;- seriesPoint case nextTick&lt;- Break } } } Just food for thought, sometimes basic patterns can be good to get started with and you can refactor later. This solution is not without a good deal of caveats but it would be an OK start. Have fun 
Because there is no requirement for a struct or interface to have its own file unlike for example Java. But Go doesn't discourage many small files either, so I'm not sure why this is an issue at all.
This is cool! And from HP? Anyone know what type of projects they're using Go for?
Isn't this O (n^2 ) ?
Pretty nifty. A fair amount of false positives for SQL injection, although it's completely understandable. For example, if in the given function `tableName` comes from a trusted source (e.g., _not_ the client) then the following query is safe from SQL injection. func createSQL(tableName string) string { return fmt.Sprintf(`SELECT * FROM "%s" WHERE my_col = $1`, tableName) } Similarly, const myColumns = "a, b, c" func createSQL() string { return "SELECT " + myColumns + " FROM my_table WHERE my_col = $1" }
In this case yes, because the append copies all the elements at the end, everytime it shifts forward. This means the last element is copied multiple times. That is inefficient and O(n^2) indeed. The append instead should keep track which stretch of elements should be shifted at once. It's a little bit more bookkeeping but that way you only every copy elements once. There is no memory allocation too, so it is pretty fast. For example, I do this here: https://github.com/tdewolff/minify/blob/master/common.go#L15
Good job, I'm sure it was a good learning exercise. Now it's time to add unsubscribing so they may eventually be GC'd. An interesting pattern for this that removes a bit of book keeping is having Fetch() be a send operation to whom it's subscribed. With the send being a channel to reply on. Then the publisher only has to respond to pending send operations in an ephemeral list. Sending channels on channels is kind of a cool feature of Go.
Thanks for the advice. Right now I am doing essentially what you're saying as in have a Map of open clients and then a map of the feeds their subscribed to which would be like a slice of their Keys (this will probably change but I think the general idea will be the same).
I'm writing a NDS emulator in Go (https://github.com/rasky/ndsemu) and I don't have major issues with go-sdl2 (besides the fact that you need to lock the main goroutine to a single thread, and this should not be used for anything else). In my case, I'm running everything in multiple goroutine and blit the final image concurrently in the main goroutine. You said you built a simple engine. If it's simple, where would you expect your profile time to go? It's well possible that cgocall is the single Go-level function that takes more time if you don't do much. I don't have suggestions for the little "pauses" you see, especially without looking at the code. 
What is (ifs)? I have been thinking about this problem for a while and I have thought of an idea that would be delete heavy, but reduce the broadcast complexity. first I would have a map of all open clients, each of which would point to a struct that has a slice of feed_keys ["EUR/USD", "GBP/JPY", "KRW/JPY"] and the actual *Client address. And each feed which is associated with a forever loop would have a map of client keys that they fetch to broadcast to. This means that everytime a client leaves their will have to be n+ 1 deletions, but it also means that each forever loop will only iterate over subscribers. Anyways I'll read up on Rob Pike and see what I can find. Thanks
Yeah but what is lambda-linux ? There is no page on the website that explains what lambda-linux is. I am downvoting.
This is neat, but I wish they named it something better. Just about all Go linters are AST scanners, and the "gas" name is just utterly unmemorable.
*Lots* of false positives elsewhere. For example, assigning an error to `_` is exactly how you tell errcheck that you really meant to ignore the error, but gas both duplicates errcheck and does it worse: [/home/tv/go/src/github.com/tv42/becky/asset.go:135] - Errors unhandled. (Confidence: HIGH, Severity: LOW) &gt; _ = os.Remove(tmp.Name()) 
No need to be complicated and slow. [This](https://play.golang.org/p/YSG7q7uQgv) is a linear time, cache efficient solution in less code.
Possibly - I haven't seen the code. go-json-rest-middleware-jwt is tied to jwt-go v2 and the problem is caused by v2-&gt;v3 change. You can vendor v2, which should make the package work without changes, or you can try using the branch with v3 upgrade (check pull requests) or make your own changes.
Interesting, thank you! &gt; I wouldn't suggest qualifying your imports. How else can you do it? In the [tsenart/vegeta](https://github.com/tsenart/vegeta) repo, the one [that article](https://peter.bourgon.org/go-best-practices-2016/#repository-structure) mentions as a good example, it uses a qualified import. [main.go](https://github.com/tsenart/vegeta/blob/master/main.go) &lt;- [attack.go](https://github.com/tsenart/vegeta/blob/master/attack.go#L19) &lt;- [lib/attack.go](https://github.com/tsenart/vegeta/blob/master/lib/attack.go#L51) [Using this import](https://github.com/tsenart/vegeta/blob/master/attack.go#L16) &gt;vegeta "github.com/tsenart/vegeta/lib"
I know that project but I dont want PHP, now I use Radicale (http://radicale.org/). 
Looks really nice! Just take a look at ur naming Convention interfaces prepended with I are not idiomatic
It depends on your structure in lib. If you're making subpackages in lib and using those directly, use the subpackage names. If you are importing /lib as if it's a full package, you can qualify, behaving as if it's an external dependency
That's understandable! I just felt that the facebookgo/inject way was a quick and easy way for me to get started. Thanks for the article! To handle singletons, do you think this would be appropriate? (Imagining that the notebook is a database/cache connection, i'd like to avoid having multiple connections where the service is reused). type Notebook struct { poems map[string][]byte } var notebook Notebook func NewNotebook() *Notebook { if notebook == nil { notebook = &amp;Notebook{ poems: map[string][]byte{}, } } return notebook } What's wrong with test packages adding another dependency? Do they add to the final build size when running `go build`? though I think the go compiler ignores *_test.go files :)
Thank you so much for your contribution!
Thanks! If I had a `providers.User` interface, do you think that `providers.SimpleUser`would be a good name for a struct that implements it?, so this: https://github.com/VJftw/orchestrate/blob/develop/commander/providers/user.go turns into this: package providers import "github.com/vjftw/orchestrate/commander/models" type User interface { New() *models.User } type SimpleUser struct { } func NewSimpleUser() *SimpleUser { return &amp;SimpleUser{} } func (uP SimpleUser) New() *models.User { return &amp;models.User{} }
We'd definitely be open to a PR if you have a good solution :)
&gt; What's wrong with test packages adding another dependency? Do they add to the final build size when running go build? though I think the go compiler ignores *_test.go files :) No, but I think people starting with Go go a little overboard with 3rd party dependencies because the stdlib doesn't provide bells and whistles. However proper use of the standard library (which the community is still trying to contemplate) show that most 3rd party dependencies have little to no value. See: https://golang.org/doc/faq#testing_framework Specifically with goconvey, it makes a great test runner, but the language for writing tests brings little to no value in my opinion.
And here I am excited that aws lambda added go support.. 
I just meant "no ifs" as... if you are coding go you'll eventually learn 'the go way'. "if and/or when" but just the "when". Not a coding suggestion just word fluff. Delete heavy is fine, in my opinion, but my suggestion was to keep all routing localized to its own goroutine. So every time a client leaves you simply remove its mapping from the dispatcher. There would be a single delete of the mapping when a client is removed. The individual feed loops would just pull the feed data and wait for the router to send it a message. The message would be 'send your newest information to this *Client or net.Conn'. The feed loops themselves do not contain information on who they are sending to, just that the router has told them "send to this". EDIT: got bored, wrote example. https://play.golang.org/p/Qu3oYGqR2z The control is... inverted. The dispatcher doesn't dispatch messages but figures out which feeds talk to which clients. There is some duplication detection as well, by tracking the message offset in the feed, per client ID.
It's not like PHP where your source and static files co mingle. Try something like this http://www.alexedwards.net/blog/serving-static-sites-with-go although I prefer http://www.gorillatoolkit.org/pkg/mux for routing. If you need any more help let me know
Here's the code, you're welcome to crib anything you like: https://github.com/natefinch/juju/blob/add-cloud/cmd/juju/interact/query.go#L115 
You would need a handler to accept the request for the image URL, read the file, and write it to the response. Any web framework (for example Gin: https://github.com/gin-gonic/gin#serving-static-files) should have a way to serve static content so you don't have to write that handler yourself.
Good info. That tutorial is perfect. Thanks!
Good background. This should be just the boost I needed. Thanks for the feedback.
Thanks for clarifying. Indeed I did not mean to say that dependencies are a problem especially in testing. Rather, as you pointed out, Go beginners tend to overuse 3rd party packages (like I did and probably partly still do, just because there are so many interesting packages to try out :). 
Oh cool, I will look over your solution tomorrow when refactoring the "hack" I wrote. If curious you can see the code I wrote here: [It's all located in the main.go file](https://github.com/MKwenhua/market-feed-sim/blob/master/web.go) Also this is the Micro-service I have running [This is a testing page to see what it does](https://damp-beyond-64138.herokuapp.com/ind), but you will have to open up the console to see the data sent back. [if you see any bugs or corrupted data just let me know]
Thanks again I studied your code and it helped me figure out immensely. I ended up modeling my SeriesPoint point off of the method you used for the room struct. Anyways, thanks again!
The interface might not even be necessary. Unlike Java, Go needs no preemptive interfaces, see [this article](https://medium.com/@cep21/preemptive-interface-anti-pattern-in-go-54c18ac0668a) on Medium for details (and the related [discussion](https://www.reddit.com/r/golang/comments/4pjsyi/preemptive_interface_antipattern_in_go/) on Reddit).
This indeed seems clumsy. Not being familiar with the Go AST capaibility, would the correct way to identify what the import names would be for ["os", "io/ioutil"], match any function calls, and inspect the arguments?
&gt; In order to mock parts, i've created further interfaces so that I can set mocked services, but this has ended up with me creating arbitrary interfaces (providers.IUser) just for this to work Not sure why you're not mocking the concrete types directly
You are welcome.
Have you got any good resources for documentation of their APIs? Specifically, I'm particularly interested in the API that let's me query what gyms are in a given area, what pokmon are in that gym, and what team owns it.
Nice! This would have been soo helpful to use as a reference! The only code example I found on Github was another C++ implementation.. I should have searched better ;)
Nothing persists on the stack, so if something will outlive the function call, it's got to be allocated on the heap. The compiler does this for you automatically under the covers. Making this decision is called "escape analysis" . You can see what's escaping by running a command like go run -gcflags -m main.go I haven't specifically measured, but the performance impact will be slightly slower function calls (because of the heap allocation) and the creation of garbage which will have to be collected later. If you're feeling ambitious and want to try some benchmarking, I'd be curious to see the results. :)
Someone else will probably give a much more detailed understanding shortly, but the FAQ might help: https://golang.org/doc/faq#stack_or_heap How do I know whether a variable is allocated on the heap or the stack? From a correctness standpoint, you don't need to know. Each variable in Go exists as long as there are references to it. The storage location chosen by the implementation is irrelevant to the semantics of the language. The storage location does have an effect on writing efficient programs. When possible, the Go compilers will allocate variables that are local to a function in that function's stack frame. However, if the compiler cannot prove that the variable is not referenced after the function returns, then the compiler must allocate the variable on the garbage-collected heap to avoid dangling pointer errors. Also, if a local variable is very large, it might make more sense to store it on the heap rather than the stack. In the current compilers, if a variable has its address taken, that variable is a candidate for allocation on the heap. However, a basic escape analysis recognizes some cases when such variables will not live past the return from the function and can reside on the stack. 
Glad to hear it helped! :D
I believe your answer is detailed enough and I will follow-up with reading the information provided in the link. However, the use of closures and "functional programming" as the book I'm reading (go an introduction) mentions seem so foreign. Maybe understanding will come with consumption of more information later in the book. 
The correct way would be when you see a function call `x.WriteFile` to use go/types to figure out which object `x` refers to. If it refers to a [PkgName](https://golang.org/pkg/go/types/#PkgName) value, you can then get the Imported [Package](https://golang.org/pkg/go/types/#Package), and check its Path. It's not enough to just find the import name for "os", because a local variable might shadow it.
Regarding the *index out of range* error, you have to append `line` to the `outputBox.buffer`: `outputBox.buffer = append(outputBox.buffer, line)`. I guess that's what you wanted to do.
Edit: Never mind, I can't read and am not able to write a good response now either. Sorry. &gt; The app currently crashes with a panic, saying index out of range at main.go:53. I believe that's actually a problem in outputbox.go:17 but I'm not really sure what? In outputbox.go:17 it looks like you are trying to add a new element to the slice (array). The index out of range problem comes from the fact that you haven't allocated space for the new element. You can choose to allocate the required space earlier on, but because you don't know how many elements you'll want to store in it, you can also grow the slice when you add a new element in outputbox.go:17. To do so replace line 17 with: outputBox.buffer = append(outputBox.buffer, line) Be aware that this internally creates a new array, one with the correct new size. It is advised not to do this too much as it can become measurable, but looking at your code I think it wouldn't be too bad in this case. (The alternative is allocating enough space beforehand, but as I've said earlier it's hard when you don't know how many elements you'll like to store.) PS: Writing this on someone else's phone. Sorry if I've made a mistake / didn't read correctly.
First off, dope job asking concise questions. Makes it super easy to help out. The out of range error is simply because you're trying to insert a value at an index = length of your slice. You need to use builtin append(...) to "push" a new value to your slice. 
I would just use a simple but performant multiplexer such as [httprouter](https://github.com/julienschmidt/httprouter) to handle routing, then code the rest by hand. The truth is, Go provides everything you need to create a restful API within the standard library. A lot of these libraries/frameworks will include a ton of stuff that you might only scratch the surface of, leading to code bloat and other potential issues. It seems like some want to turn the Go ecosystem into a Node.JS like structure, which imho is a pretty bad idea. For instance, the go-json-rest library includes the [force-ssl middleware](https://github.com/jadengore/go-json-rest-middleware-force-ssl) library to just, well... force SSL it seems. However, this is all the code you need to achieve that: func handleHTTP(w http.ResponseWriter, r *http.Request) { // Check Method. if r.Method != "GET" { http.Error(w, http.StatusText(http.StatusMethodNotAllowed), http.StatusMethodNotAllowed) return } // Redirect all other requests to HTTPS. http.Redirect(w, r, "https://example.com"+r.RequestURI, http.StatusMovedPermanently) } ... // Start serving over HTTP. go func() { if errHTTP := http.ListenAndServe(":80", http.HandlerFunc(handleHTTP)); errHTTP != nil { fmt.Println(errHTTP) os.Exit(0) } }() If you take a look at that code, is it really that daunting to just add in yourself? Is including another library/plugin really necessary? I think that can be said for a lot of things, especially a restful API. You're still going to have to have a server, with routing and handlers defined. When you break it down, there's not much a framework would add for you, unless possibly you plan on using the majority of its features.
You have very weird repository structure. Why duplicate everything from src/ level down instead of just putting the code in the root of/in the two direct subdirectories of nogfx-cli?
Hi one of the contributors to this project here. Thanks for all the great feedback we're doing our best to take it all onboard. We would like to encourage people to raise issues on github if they have improvement suggestions. Also please keep in mind that the tool itself is still in very early stages of development so there are still plenty of bugs and things to improve on. Thanks! 
Thanks for explaining it so well. Makes total sense now! In my final app I'll have a slice of objects that'll transform into text and the output will be capped at some length anyway, so I might go with a set size then.
Thanks! My dynamic language background showing here, I think. ;)
Definitely use what is the most comfortable to you. Even handling middleware though is easy enough in Go. For example, for pre 1.7, here's how you could add a Context object to each handler in a chain, with httprouter as the multiplexer: type HandleCtx func(context.Context, http.ResponseWriter, *http.Request, httprouter.Params) func Begin(h HandleCtx) httprouter.Handle { return func(w http.ResponseWriter, r *http.Request, ps httprouter.Params) { ctx := context.Background() h(ctx, w, r, ps) } } // Example of using the Context object within middleware. func AddToContext(h HandleCtx) HandleCtx { return func(ctx context.Context, w http.ResponseWriter, r *http.Request, ps httprouter.Params) {. ctx = context.WithValue(ctx, 123, "value") h(ctx, w, r, ps) } } ... router.GET("/member", Begin(AddToContext(myHandler)))
Lol. Well this project in particular was built by our cloud security team with our http://www8.hp.com/us/en/cloud/stackato.html product in mind although we hope to make this project useful for Go projects in general. 
Tim has pushed up this change to handle the const and string literal case for the second example: https://github.com/HewlettPackard/gas/commit/81b5e98828d0e9ea17440e4cc17b1580984f374c The first example, well that will require full taint analysis. Something that is on the roadmap but still early days :-) 
I, too, have a background in python before go, so seeing stuff like this where you loop over an array/slice and modifying it at the same time makes me get really nervous and itchy. But in any case, it runs fine and does the job efficiently so many thanks for this tip!
Other than gorilla/mux and cobra, I use the standard library pretty much exclusively. YMMV but I find that extra dependencies are rarely worth it in the long run when they are primarily for coding convenience (as opposed to functionality that I don't want to implement myself, like crypto or something like that). For context, I'm writing infrastructure-level API microservices daily. These days I'm gravitating more toward gRPC than RESTful APIs generally.
So you made a bitset?
learn and use Git :) also maybe Sparkleshare :)
Interesting use of channels to grab next random key. A nitpick, I would separate out the key gen/save/etc from http server into its own package/file. 
Can't wait. Though I am not a great fan of mixing JS frameworks with Go. Nevertheless, it should be fun to red.
Thanks for the feedback, that was just what I was after. I didn't know if I could justify splitting up the files into separate packages, but thanks for doing so. Also I mainly didn't do so because it was just quicker for me to be honest. Thanks again!
This tool communicates with PokVision's servers. So I haven't looked into the official Pokmon Go APIs yet. But there is a great Nodejs module which has a lot of the API mapped out already. https://www.npmjs.com/package/pokemongo-api
What is your work flow with using gRPC and Go? Sine May 1 Open API is the industry standard, feel like this might overshadow gRPC?
I really like this. Solid effort. Will hurt my productivity a little ;)
PHP, Lua, and JavaScript. They're all forgiving enough to let you do that.
What ever that means! Just code and build cool shit. 
Does the app panic? If so post the trace. If the app just freezes waiting for input, wrap all your sends with a timeout. So that way if the send operation fails you can print whatever it was you were trying to send to debug. Reason being is sometimes when you think you are deadlocked on a send it can end up being a call at the send site, I.e. *ch &lt;- foo.Call()* may have Call() blocking forever waiting for an EOF during an IO operation or something. Also set deadlines on all your IO and print timeouts to stderr it can really help with debugging. It's easy enough to implement simple wrappers to do this.
For an additional challenge, you can go one step further to see if a function is aliased, e.g. `wf := ioutil.WriteFile`. However I'm not sure if this can be checked during static analysis since a wf can be assigned at runtime.
I used https://github.com/zenazn/goji in the past when I was learning Go. Mainly because how easy it was to get started and it had a way to deal with context. Goji was great and we are still running it in production currently. It is very approachable even when I had no idea what I was doing. Much later on, I found that I had been using none of the amazing tools that Goji offered. Since then I have been slowly moving towards using just the std lib with the contexts in &gt;=1.7 (and also https://github.com/tylerb/graceful until I figure out how to graceful shutdowns on my own).
I think what's making this extra annoying to debug is that I'm using termbox and it's taking over the output, hiding stderr messages. So I'm not sure if it panics. The wrapping sounds great. But I'm not entirely sure how I'd implement it. Do you have any example to clarify? Thanks for taking the time!
But gRCP has no browser support. How can it be a replacement for json rest?
Looks like this part is a few steps ahead of where I am right now, but I'll definitely be keeping it handy. Thanks for the tip!
Thanks for your responses.
It's difficult to see but the code does store 8 bools per byte. `func ij()` returns two values: i := index &gt;&gt; 3 This is the same as index/8, to turn bit index into byte index. j := byte(index &amp; 0x7) This masks all but the lowest three bits (0x7 is 0b111). These are the bits that were lost in the `index &gt;&gt; 3`operation. They repesent a value between 0 and 7, which is the index of the bit within the i-th byte. 
Do you add folder by folder (project by project) or is it ok to sync all the home even if it's big ? I've a lot of projects since years that i don't change often, some that change more often. I wonder if it's better to customize each folder (scan less often) to don't waste resources. 
A config file with multiple locations/names/ranges to cycle through would be a nice addition.
I needed something similar so i made https://github.com/wader/filtertransport I suggest adding default unicast (0.0.0.0 and ::) to the filter list.
Haven't tried it, but looks solid. http://echo.labstack.com
Interfaces are idiomatically named as verbs: Reader, Writer. If your interfaces don't naturally fit that style, it's a sign your design is a bit askew or inverted. It's also reflected in your package names: models, providers. Packages should generally reflect your domain (package user, package project) rather than the mechanics of your application architecture (package provider, package models). For example, will you ever have a non-simple user?
https://blog.golang.org/go-slices-usage-and-internals 
Uh... MPL? This is not gonna get very far (in terms of actual usage in the wild). Why would anyone bring copyleft code into an otherwise fully BSD-licensed stack?
Thanks for this! I also came across this yesterday https://github.com/yeptcorp/gapi-example which seems to follow that pattern, so I could have `user.Provider` which provides users etc. `user.Resolver`, `user.Validator` etc. 
In C, never put your implementation in your .h file.
Your data structure makes no sense. 
HTML POST Submission is procedural. So you can insert a `&lt;input type="hidden" name="variation" value="sep"&gt;` in between multiple products to know where the `"variation"` of the next products begins. The HTML Form: &lt;form ...&gt; &lt;input type="text" name="name"&gt; &lt;input type="text" name="desc"&gt; &lt;input type="text" name="variation"&gt; &lt;input type="text" name="variation"&gt; &lt;input type="hidden" name="variation" value="sep"&gt; &lt;input type="text" name="name"&gt; &lt;input type="text" name="desc"&gt; &lt;input type="text" name="variation"&gt; &lt;input type="text" name="variation"&gt; &lt;input type="text" name="variation"&gt; &lt;input type="hidden" name="variation" value="sep"&gt; &lt;/form&gt; Go: names := r.PostForm("name") descs := r.PostForm("desc") variations := r.PostForm("variation") products := make([]Product, len(names)) count := 0 for i := range products { products[i].Name = names[i] products[i].Description = descs[i] // make sure this does not panic for { if variations[count] == "sep" { count++ break } // here i assume []ProductVariations is of type []string for simplicity products[i].Variations = append(products[i].Variations, variations[count]) count++ } } This is kind of a hack and untested. But this could work if I understood your problem correctly.
Sorry if that came off as a bit harsh. (In my defense, I didn't have my first coffee yet ;)) I try to consider the ecosystem my project will be interacting with when choosing a license. The Go world, much like the Python world seems to center itself around BSD and MIT. Since PostgreSQL's license is BSD-like as well it's in general less friction to choose a similar license. Many will even expect it before touching stuff that has to be linked to their production software. The Clojure world congregates more around the EPL, so that's what I'd use there (and BSD/MIT are EPL compatible). Java and C(++) are all over the place depending on the community. :)
Why? I'm learning Go and I would like to improve my programming skills.
I've read this, but the only solution that I see is to do a new slice and a copy between them. But, although I do this, I have the same problem.
Sorry, what was wrong with go-json-rest? That's totally the right direction to go in my opinion. You'll end up writing a lot of code you don't need to if you just use the standard library. ...but yeah... Don't fall into the trap of 'stdlib only'; it's *pragmatic* advice you'll hear form a lot of people because doing dependencies correctly (especially for libraries) is hard; but it's not *good* advice.
I think you might be doing a shallow copy of movsKnight, here's how you should do it, vs. how I think you are doing it: https://play.golang.org/p/5F-zNLEeRy edit: Note that since I'm using ints, the inner copy is an actual 'deep' copy of each int. The values in your slices are list.List, which is also a ptr-based struct under the hood, so you'll need to do a deep copy of the list objects as well. All that being said, I think I would solve this problem a little differently than you are. If you gave us more details on 'what' you are trying to accomplish (not just how), we might be able to provide a more straight-forward soln.
It looks like you've just removed the license, which means, in practice, nobody can use your code in their projects. /u/jinks makes some good points about choosing a license, but really, it's up to you. Check out www.choosealicense.com to learn some more about the different kinds of licenses. Regardless of that, neat project. I was looking into integrating some existing Go code for some Postgres extension work some time ago, but didn't find anything. With some more work, this could be a really useful library. Keep it up!
I use: * React.js /w Redux * Go * PostgreSQL, Redis, ElasticSearch * AWS, Ansible, Terraform and Docker /w FreeBSD, Ubuntu or Alpine If I'm doing something other then Go, I switch out the backend for either Rails or Node.js. If you want to see what stacks big companies use, check this out - http://builtwith.com/ 
Some of the other replies also recommend this structure and it does make a lot more sense to me now. I was more familiar with the Java-esque way to start with, but that ultimately felt wrong after reading the effective go doc. Thank you!
I'm sure that is a fine stack to get started with. I started out as a "full stack web developer" years ago (ie, raw JS, some jQuery, HTML, PHP, Apache, Mysql, Ubuntu). I'm now a backend distributed systems developer. I've not touched JS or HTML in years (aside from very small things) and am happy about it. I find myself dealing with Go, Perl, Python, Mysql, Redis, Elastic Search, Kafka, Docker, Vagrant, some very limited Chef/Ruby (which I avoid like the plague), Centos7, and a slew of other things I'm sure I'm forgetting. 
If I do this I have a compilation problem because it doesnt find the list, but Ok, many thanks, I understand what I need to change to improve my errors. BUT I still have the same problem that at the beginning. I dont know why Go returns me the slice by reference and not by value.
I think based on what I'm seeing you are using slices somewhere that a two dimensional vector would be a better fit. Then you can benefit from standard vector operations and calculating vector positions in a grid can be extrapolated without the need to accumulate state. I'm sure there is a good a deal of generic vector2 implementions. I am on mobile so don't want to hack any code up, but Google Vector2 golang and see where it takes you. Since it looks like this is for a game, you could create a grid or world struct. You could interact with that to maintain your game state and vector list. Lots you can do here, I'm sure you will have fun along the way whatever your approach may be. 
Go always passes by value [copy], but some values are pointers, and copying a pointer means you still point to the same thing. Slices are an example of this, passing a slice will just copy the pointer to the backing memory, it won't copy the backing memory. You need to copy the backing memory explicitly.
Nil slices don't spring into existence, neither do nil structs.
&gt; regexp.MustCompile("ioutil.WriteFile|os.Create") The regex is bad too. a) It's not using raw string literals. b) The `.` is not escaped, so it will match any char. `ioutilXWriteFile` will match, for example. Corrected: regexp.MustCompile(`ioutil\.WriteFile|os\.Create`)
Well, nil slices are equivalent to empty slices in all instances except when comparing to nil. The same isn't true for maps. 
I've always been unhappy about that too. I believe it's either an oversight, or an implementation detail. In the latter case, a map will be implemented as a struct with additional buckets allocated and be represented as a pointer to such a struct (whereas a slice is directly represented as the struct). In this implementation, making the zero value of a map legal would require to allocate separately for every map that you use (e.g. when you have a map as a struct-field, every creation of such a struct would need to both allocate the struct *and* the pointed-to value of the map). I don't know. I don't think there is a really *good* reason why we can't just have the zero value of a map be valid. At least I couldn't come up with one so far.
A nil map has 0 length, you can range over it, and you can even lookup values in it (but it's always empty). A nil slice has similar properties. You can't assign to any elements but you can check the length and range over it.
Oh, the obvious follow up question is of course: Why not let the pointer be nil and allocate the separate struct on first assignment. The reason is, that map is a reference type, so if you have a `type Foo struct { M m[int]int }` then func X(f Foo) { f.M[23] = 42 } func main() { var foo Foo X(foo) fmt.Println(foo) } couldn't actually modify `foo`, as it's passed by value, so the pointer saved in it can't change.
see [grpc-gateway](https://github.com/grpc-ecosystem/grpc-gateway) for browser support (and Swagger/OpenAPI support).
Adding this kind of functionality would cause a lot of incosequent behaviour. You see, maps are reference types. A map can be `nil` because the pointer that refers to the map is a nil pointer, which means that it refers to no map. For example, this means that when `m` is a non-nil map and you do n := m n["foo"] = "bar" then `m["foo"]` is also set to `"bar"`. If assigning to a nil map would cause a map to be generated, than this property of sharing is suddenly violated: If `m` is `nil`, `m["foo"]` would not contain the same thing as `n["foo"]` because after `n["foo"] = "bar"` the variable `n` refers to a map whereas `m` is still `nil`. `nil` is a reference to nothing, so there is no way the map that sprung into existence when assigning to `n["foo"]` would also be referred to by `m`. I believe it is much more important to preserve the property of maps being reference types than adding any convenience hacks which most likely only cover up erroneous code anyway just to get rid of some infrequent error checking. If a map is nil, that's a situation you have to deal with. Just having the language do something in this case is bad language design. Fail early, fail often. Panicking when a nil map is assigned to is the most sane choice.
Instad of a `map[int]map[int]string` you might want to consider using a `map[foo]string` where `foo` is a type comprising two integers.
I've been using the Swagger editor to discuss and construct schemas, then using [openapi2proto](https://github.com/NYTimes/openapi2proto) to generate protobuf definitions and finally `protoc` to generate the Go structs. This allows us to have Swagger's editor and browser support with Google's tooling. This has been handy as it allows us to utilize JSON or Protobuf payloads on RESTful endpoints that can be hooked into any toolkit or framework. This also opens up the service to also operate with gRPC. To easily utilize both JSON and gRPC, I'd recommend looking into: [grpc-gateway](https://github.com/grpc-ecosystem/grpc-gateway), which uses a separate proxy service for JSON or [Gizmo's RPCServer](https://godoc.org/github.com/NYTimes/gizmo/server#RPCServer), which will allow you to run both in a single process. 
* Go * PostgreSQL * Maybe Redis if needed * Vanilla JS + jQuery * Bootstrap I tend to go minimalistic when starting a new project. Simple things are usually robust.
Hmm, I see what you're saying w/r/t to the n := m aliasing. I wonder if it's avoidable? Like even a nil map contains a pointer to the nil map data, so that your n,m aliasing example would work. If you could find a reasonable implementation, I certainly don't agree that it's bad semantics -- it just makes code simpler.
The obvious answer is that maps are a pointer type. If maps were structs (as opposed to a pointer to a struct), then copying a struct that contains a map would copy the map. This is undesirable most of the time.
Consider this code: func main() { var m map[string]string // m is nil f1(m) f2(m) // what is m now? } func f1(x map[string]string) { x["foo"] = "bar" } func f2(x map[string]string) { x["blah"] = "bloop" } If maps are auto-created on assignment, it's not clear how this code should work. The intent is obviously that the functions should be modifying the existing map, but auto-map-creation would make that confusing. Is x auto-created and then discarded? Big source of subtle bugs. Is m modified outside of f? Again, unexpected side-effects.
I use: * go * mysql (google cloud sql) * redis (digital ocean or linode) * heroku it's a solid, stable platform that i've been using the past few years. Heroku works excellent with golang and performance for the price is great. 
the semantics i would desire is that m would be {"foo": "bar", "blah": "bloop"} it doesn't seem materially different or more confusing to me that "is m still nil" vs the normal "does m still have the same items in it, or were some deleted or added?" i guess basically what i'm asking is, what is the purpose of even letting maps be nil?
It literally does not matter at all. Do work. Learn a lot. Do more work. Learn more. Asking what to learn is the wrong approach. Learn more. 
If you do not make the Map when you create the struct it belongs to than you are opting to lazy initialize it because it may not be needed. So the only time you have to check if it's initialized is if you are using the feature you are wishing didn't exist. I'm ignoring cases like local scope maps.. that's silly. Maps from external package providers, well that seens like odd API design but checking nil I don't find unreasonable. Compiler magic allocations for complex types such as map sounds like corner case hell. Doesn't mean I don't get the fact it's tedious .. I agree. But it makes sense, least to me.
This is called autovivification by the way. https://en.m.wikipedia.org/wiki/Autovivification 
There are Centos packages available already in base, though they're ancient. There are newer ones oddly enough in the epel 6 repo, but it doesn't look like they've made it into epel 7. But the go 1.5.x from epel6 might be a good starting place to build something more modern. Or you could use the fedora epel srpm to build one of the 1.7 RCs. Good luck!
Daniel is that you? 
I think Fedora remove some elliptic curves from "crypto/*" due to patent issues so it might not be the best base.
Yeah, they have a patch to remove elliptic curve P224 (iirc) for patent issues according to the bug reports in the spec files. I actually used the epel-6 1.5.1 as my starting point and debated whether or not to include the patch in my rpms. In the end I decided to be on the safe side and not include the curve, but I might make a flag to re-enable it so anyone interested could just rebuild the rpm. Not sure how much interest there would be in that though.
Use Linux, OSX or a VM. Windows isn't a developer friendly OS. 
The same argument would apply to slices, though: A slice is a reference type but when you `append` to a slice it might or might not change other slices referencing the same data. And indeed that leads to confusion for beginners (not knocking on the slice behavior, I love the slice design). Slices are neither pure references nor pure values, so why not design maps in a similar way?
Of course. That's why I said you might want to consider instead of you should.
Slices are value types that contain a reference. The design of `append()` is a bit confusing, but it's not really possible to make it any better (just try to make something up to see that it likely can't be done). &gt; Slices are neither pure references nor pure values, so why not design maps in a similar way? What is the argument here? Slices are illogical and quirky so maps should be illogical and quirky, too?
 func main() { var s []int // s is nil f1(s) f2(s) // what is s now? } func f1(s []int) { s = append(s, 23) } func f2(s []int) { s = append(s, 42) } And yes, I know why this code works as it works, just saying that "the semantics would be weird" isn't really a good argument when we are collectively perfectly fine with accepting whatever weird semantics with slices.
I think this has been formed out because people were used to it from frameworks in other languages (rails, laravel, ...) and also because it fits the mvc pattern well. Anyway: this is a pretty large guide. There are a lot of shorter posts as well: https://www.gitbook.com/book/astaxie/build-web-application-with-golang/details 
&gt; What is the argument here? Slices are illogical and quirky so maps should be illogical and quirky, too? I do not consider slices "illogical and quirky". I'm saying you cannot claim the behavior from alternative map-designs would be unacceptably weird, because slices clearly demonstrate that we can accept (and understand) behavior like that without problems. I can, btw, also come up with a map-implementation that *doesn't* suffer from either of these problems: https://play.golang.org/p/rIcm2AtDON It ignores some of the less important details (like actually hashing stuff and dynamically growing the map and everything), but it should illustrate the point, that you can have a map design that * Has a well-defined zero-value by initializing all fields to 0 * Behaves as a reference type (when not nil) * Allows inserting values into a nil-map * Without changing other nil-maps, so it *only* behaving as a reference type for non-nil maps Is this design strictly better? I am not sure, but I don't think so. But it illustrates that the current behavior is an implementation quirk and that alternative implementations are *possible*.
&gt; to get auto-magic maps, you'd either have to have weird reference passing semantics, or magic initialization that was not all zeros. I don't believe this is strictly true: https://play.golang.org/p/rIcm2AtDON Of course this is not a complete implementation, there *might* be problems further ahead and of course I am probably overlooking other quirks of this kind of implementation. But it shows that with a little bit of imagination you can implement a lot of different behaviors.
What DB can we use with this program? For MongoDB and Sphinx Search Engine we created custom decision on PHP5, here is a small report http://multi-programming.com/blog/trigram-method-in-automatic-spelling-correction. 
Why use app engine?
The `length` field does not represent len(data). It's count of bool elements.
It's the background we bring from other languages and frameworks like (Java with Spring or Ruby on Rails etc). The first web app I've written in Go was a terrible mess with packages like `model`, `controllers` etc. Looking back at it, makes me cringe but it served as a stepping stone to move to more idiomatic Go code. Unfortunately there are very few "official" examples/documentation about Go web applications and structure. This had lead to countless blogs and articles, a big part of which is written by vocal members of the community that have kept the structure and design patters they were using in other languages even if they make no sense for Go.
&gt; Get rid of nil-slices (this has nothing to do with maps, it's just for consistency and as a general principle). The overloading of nil is a cost that I find too high to pay, just define the zero value of a slice to be a slice with len and cap 0. There is no need to change slice-implementation, just remove the overloading of nil for slices from the language. The nil slice is a slice with length 0 and cap 0. I've no idea what you want to change there. How would your suggestion behave differently from the current nil slice? &gt; Do the same for maps: The zero value of a map is an empty map ready for use. And how does sharing work in this case? Suddenly whether a map assignment is sharing depends on whether the map is empty or not. &gt; Maps work as reference types: Passing a map or assigning it to another map-variable should modify the same map This does not work for your implementation with the zero value of a map and is in general tricky to implement if you want this behaviour for the zero value of a map, too. That's because sharing always involves a pointer and a pointee. Either you need to generate a pointee whenever you create a map variable (even for empty maps) or you need to generate complicated code to handle the case of an empty map without a pointee when copying data structures that contain a map somewhere. In your code, you decided to simply complicate the copying code. &gt; The thing that needs to be added is, that the compiler needs to add some code to map-assignments. Congratulations! It's useless because now we cannot compile an assignment into a simple copying operation, we have to have a special case just for maps. This can get arbitrarily complex because you can have structs with arrays of structs with maps in them, etc. etc. &gt; significantly simplifying the language I don't think that your proposed semantics simplify anything. I spent great time to elaborate on the bug-hiding aspects of what you want, but you didn't even bother to respond to that part. &gt; two overloads of nil What overloads of nil? Nil is only overloaded for being a nil pointer (which is the case with a nil map) and a nil slice.
The managed service works well for me.
&gt; How would your suggestion behave differently from the current nil slice? I said that. Remove the overload of nil for slices from the language. Don't have "nil"-slices anymore, just have empty slices full stop. By extension, of course, remove comparisons to nil (which is, as mentioned, currently the only difference between a nil slice and an empty slice with no capacity). &gt; Congratulations! It's useless This is a very strong word. It makes me feel like you are not really trying to be constructive here. It's probably more useful to push the issues of implementation back (I was simply trying to demonstrate that if we *want* certain semantics, we can always implement them in some way) and talk about the semantics first. How to achieve them, then (and if the disadvantages of however this is going to be implemented), is the implementation question and we can talk about that separately. I agree, that it's non-trivial, but currently we seem to mix the two up too much for my liking. For the imagined semantics, you can pretend that instead of being initialized to a 0-pointer, they are initialized to whatever `make(map[])` returns. &gt; I don't think that your proposed semantics simplify anything. They do, though. One of the most common occurrences where the [make the zero value useful](https://go-proverbs.github.io/) proverb is violated are maps, certainly for me. There is little I find more annoying than needing to have a `NewFoo`, *just* because `Foo` contains a map. They also greatly simplify maps of maps. &gt; I spent great time to elaborate on the bug-hiding aspects of what you want, but you didn't even bother to respond to that part. Because they are addressed by what I'm imagining. You say: &gt; &gt; If widgetInfo is nil well, as mentioned, there are no nil maps in my dream world. There just are empty maps. And if you pass an empty map to your code, it just gets populated *exactly* as expected, instead of panic'ing. Your code is only potentially buggy *because* there are nil-maps. I.e. if the solution to whatever bug you want to have uncovered by a panic, is to initialize some map with the return of map, my wished-for semantics would fix that bug, instead of uncovering it. The only way the code you mentions under my imagined semantics would lead to a bug, is if you'd write `updateWidgetInfo(widgets, map[Widget]Info{})` and *of course* that's a bug and it's also a bug in a world where there are nil-maps. Disallowing nil-maps is a strict improvement in terms of semantic simplicity and number of bugs. &gt; What overloads of nil? Nil is only overloaded for being a nil pointer (which is the case with a nil map) and a nil slice. And a nil-map, a nil-channel and nil-interfaces. How a map is implemented is immaterial to it's semantics, so claiming that the overload of nil for map is just because it's implemented as a pointer is disingenuous (case in point: slices and interfaces are not implemented as pointers and can still be nil). The predeclared identifier nil has five different meanings and this fact is [leading to problems](https://golang.org/doc/faq#nil_error). Removing some of these meanings would be a good thing.
Plug of my WIP to possibly spur some ideas: https://github.com/kylewolfe/rumble. I'd like to find time / interest in working on it again.
Have you ever tried an application that requires you to use it's package manager to download "the whole net" in dependencies? Many developers do not consider the costs that dependencies bring. If they can save 10 lines in their own code by importing 1000 lines conveniently hidden in a dependency (which might also depend on other things), they will gladly do that, given that a package manager exists that will facilitate the process. Go on the other hand has created a community around a certain way of programming that usually favors [smaller dependency trees in order to make programs that compile faster, are easier to maintain and simpler](https://youtu.be/PAAkCSZUG1c?t=9m28s). So what I am saying is, I hope we get something out of this that works for Go and not a mere imitation of something that happens to work for a different programming language.
I'd like to learn how to make a large real world API using only the stdlib as you described. Could you give us some open source projects using this approach? I want to see a materialized real world app using that approach, all I find is hello world.
It's considered the "standard" postgres driver for Go by the community. It's the one used by default in examples, articles and [books](https://astaxie.gitbooks.io/build-web-application-with-golang/content/en/05.4.html). It has the largest number of contributors and stars. It's the most widely used and battle-tested of the rest. And also just check of some of the names: https://github.com/lib/pq#thank-you-alphabetical 
&gt; By extension, of course, remove comparisons to nil (which is, as mentioned, currently the only difference between a nil slice and an empty slice with no capacity). Yeah, okay, comparison to nil should just check if the capacity is 0 as otherwise there is no visible difference between a nil slice and a non-nil slice. &gt; (I was simply trying to demonstrate that if we want certain semantics, we can always implement them in some way) We can have a lot of things, but many of them come at a considerable compile time or runtime cost. Making copies much slower is not really a good tradeoff. &gt; There is little I find more annoying than needing to have a NewFoo, just because Foo contains a map. They also greatly simplify maps of maps. You can also check if the map is nil in every function that writes to the map, but otherwise you have a point (albeit a minor one) there. &gt; there are no nil maps in my dream world. (...) Disallowing nil-maps is a strict improvement in terms of semantic simplicity and number of bugs. My example referred to your first dream world in which there are nil maps but assigning to a nil map would cause a map to spring into existence immediately. Yes, in a no-nil-maps dream world my example doesn't apply, but as I say, such maps come with considerable implementation and performance complexity as we now either need to run code to initialize variables containing maps (even global variables) or run complex code every time we copy something that contains a map. Both propositions are not really great. My strategy when dealing with maps is to say this parameter better not be nil in the documentation and panic when this is violated. Fail early, fail loudly. Violating an API's rules is grounds for immediate panic because the program is faulty if that happens. &gt; And a nil-map, a nil-channel and nil-interfaces. All of which are pointers behind the scenes as all these are reference types. Not exactly overloading. &gt; (case in point: slices and interfaces are not implemented as pointers and can still be nil). Slices are the exception I listed, interfaces are pointers to an interface structure. &gt; Removing some of these meanings would be a good thing. Only if the same effect can still be reached by another mean. I do support having a different reserved word for each occassion for clarity but not as a language change (because I generally do not support code-breaking language changes).
With pip(python), on the paper it's wonderful, but I have a lot of conflicts because of the wrong version of pip, setuptools, distribute or I don't know what eggs or not eggs. I can have a requirement.txt with versions that do not more exists and so on. Finally the solution is to keep a "wheelhouse" (a zip of each package) and virtualenv, finally what we do in Go with GOPATH and vendoring. I really hope the Go contributors will find a stupid simple solution ! gopath + forks + go get is already better than a lot of pm for me.
Isn't that the fault of the developer and not the package manager though?
I've used https://github.com/jackc/pgx with great success, it's got most of the things out of the box (jsonb et al)
I have built a library that can help achieve exactly what you're looking for [form](https://github.com/go-playground/form) You would format your HTML like so: &lt;form ...&gt; &lt;input type="text" name="Name"&gt; &lt;input type="text" name="Description"&gt; &lt;input type="text" name="Variations[0].Name"&gt; &lt;input type="text" name="Variations[0].Description"&gt; &lt;input type="text" name="Variations[1].Name"&gt; &lt;input type="text" name="Variations[1].Description"&gt; &lt;input type="text" name="Variations[2].Name"&gt; &lt;input type="text" name="Variations[2].Description"&gt; &lt;/form&gt; and then Decode directly into the struct value decoder = form.NewDecoder() r.ParseForm() var product Product err := r.Decode(&amp;product, r.Form) ... I hope this can help :) 
&gt; We can have a lot of things, but many of them come at a considerable compile time or runtime cost. Making copies much slower is not really a good tradeoff. I tend to disagree. I don't believe maps need to be copied in large quantities often enough to make the cost be significant. But eh. That would need to be tried. I would probably, if I would redesign go, just not have maps be reference types. If you want to change the content of a map, pass a pointer. For index-expressions the same syntactic sugar can apply as for struct-fields. Works well enough for structs (and slices, if you will). That would also bring down the edge-cases for reference types to channels. And they inherently need to be references, I think. &gt; Slices are the exception I listed, interfaces are pointers to an interface structure. No, they are not. They are a two-word `struct {*typeinfo; *value}`. Otherwise, http://research.swtch.com/gorace wouldn't work as it does (replacing them by a pointer is one of the proposed solutions there, to make go memory safe in the presence of races). And at the point where a rule doesn't apply to 2 of 5 things, the 2 can hardly be called an "exception" (even if it doesn't apply to 1 of 5, it can hardly be called a "rule", in my bool). And it's overloading as soon as there is *more than one*. And this overloading actively leads to issues (the famous "nil-error" case). &gt; Only if the same effect can still be reached by another mean. I strongly disagree. The concept of nil-slices is as useful as a bum-wart. I am not only talking about eliminating the overloading here, I am talking about eliminating the whole concept. Same applies to maps, it was a mistake, in my book, to have a useless zero-value that you would need such a key-word for. The other three are significantly harder (and I think nil-pointers are a good thing), though. &gt; I do support having a different reserved word for each occassion for clarity but not as a language change (because I generally do not support code-breaking language changes). Well, I'm not talking about a language change in either case. :) I'm talking about time-travel or go2 :)
An example someone else gave was func main() { var m map[string]int f(m) fmt.Println(m) } func f(m map[string]int) { m["hi"] = 1 } I think you need this code to either panic (like it does right now), or print map[hi:1] -- if you just silently instantiate the map in f but that doesn't make it back to main, you've created a very easy way to silently introduce bugs.
Yes, which is why I said that maps suddenly sprining into existance is a bad thing. The current behavior is for `f` to panic, which is fine.
The behavior I want is that that your first call to n.IsNil() would be false, and n.Get(42) would return "foo". Otherwise the cure would be worse than the disease, because it would be easy to introduce silent bugs (especially when passing maps to functions that modify them; see my reply to FUZxxl).
Yeah, it's not terrible, it's just annoying. If there were a way for *all* maps to magically spring into existence, I think it would be better, but you've convinced me there's no way to do that without having the compiler initialize nil maps to non-zero values behind the scenes, or by having some kind of weird hidden reference type behind the scenes, both of which seem very much not worth it in a simple language like Go. 
Unused imports are also the fault of the developer. Yet the Go compiler does it for us. Some people find it annoying but on large projects with many people (some of which might come and go) it makes a huge difference. In this case, we are talking about open source scale. So I hope they get it right.
How do you handle server side rendering for your react views with Go?
Following notice is being added to the top of the readme. Bo normally Panics on error (a reason is displayed). Errors are not generally returned. This decision has good and bad points. Bo requires using lots of method calls. Checking for and handling an error on each one would add significant lines of code to your app. There is some comfort in knowing the program will abort rather than continuing with an unhandled error. Also, single return values allow chaining and embedding. I know some apps cannot live with this approach.
That's absolutely brilliant!! Thank you!
That sounds seriously unworkable.
I've been listening for a few weeks and can very much recommend it!
Seconding this recommendation. More convenient to use than `pq` (it doesn't have the problem of prepared statements have to be "re-prepared" for each transaction, for example), and has good things like tunable connection pooling and logging hooks.
&gt; Bo requires using lots of method calls. Checking for and handling an error on each one would add significant lines of code to your app. There is some comfort in knowing the program will abort rather than continuing with an unhandled error. Also, single return values allow chaining and embedding. I know some apps cannot live with this approach. Then expect nobody to use your library. "Being shorter" is not an excuse for not handling errors, and knowing your program could abort at any time is in no sense of the word comforting.
Thirded. I've used pq, pg, pgx and dat and settled on pgx as being the most comfortable match for "idiomatic postgresql" schemas. (I'm also using a local fork of [xo](https://github.com/knq/xo) that has a couple of lines tweaked to use pgx connections rather than db, and it's turning into a nice environment for a complex webapp).
One of the problems with doing that is that if the database restarts, all those db.Stmts become invalid. So unless you wrap them in re-prepare logic, prepared statements should not happen at the start of your application to be used through your app lifespan.
Using heroku is an awful idea. You aren't learning how to setup a system and how your programs work under the hood. There is a level of attraction that is their platform that you do not want to become a crutch. You want as little as possible between you and the system. Once you have setup hundreds of servers and know Linux, the shell, etc, it becomes mundane and repetitive and only then will I recommend leveraging things like heroku. Stick to basic virtual machines.
This may seem ham-fisted and weird but I think it would be good if a packaging manager somehow could inform the developer of the impact of bringing in a dependency. So it would say something like "by adding this dependency you add 3 transient dependencies bringing in 10k lines of code". 
npm3 addresses this (at least partially, if not completely)
I don't know but try and use https://play.golang.org or https://gist.github.com when posting snippets.
Sure but I think the author is asking for a higher level API library, not a lower level web framework if I am understanding the question correctly. This is one of the problems I have found, In Go there aren't really many good, working high level API libraries and far too many micro web frameworks. I have tried https://github.com/manyminds/api2go a while back which implements the json api spec, however I couldn't get it to include more than one level of nesting. For example if your data model is "user" has many "group", each group has many "permission", then api2go would not end up including the permissions if I fetched users.
Yes, and it's the responsibility of the maintainers to not let users poison the ecosystem. That being said, it's also their responsibility to provide a solution preempting the need for someone to do this wrong.
Thanks for putting it up on github later when you have time, I am interested to participate this effort. Starting with your spec file and maybe submitting my makefile etc ... All in all it is good to have more persons to maintain a golang package. 
Not sure what you mean by this; perhaps I'm not familiar with "the usual meaning of the term", but I often hear people talk about maps and slices as "reference types", and I understand strings to be something like an immutable slice of bytes--thus making them 'reference types' in the same fashion. In particular, I don't see how your cited post invalidates this understanding.
it's sad that he doesn't seem to follow your advices. 
Very nice point. I'll make sure to make a note of this, and practice problem solving in Go first then see what tool fits best. I think I seen a developer do this before when he was working on his video game Crea. He was like at one point "Yeah, this tool doesn't fit what I am doing"( I think it was like a C+/HTML UI thing) and this was like halfway within the project, so he found something else and it worked perfectly for him. I was confused why he had did that, but I see why, he was focused on solving the problem more than what tool he used.
I actually find many JS tools to be difficult to use: npm, Grunt, Gulp, Bower, etc. Many of the commandline tools are archaic without following almost universal conventions (`gulp` is one of the few cmdline tools that doesn't accept `-h` or `--help`, seriously wtf?!); the "documentation" often consists out of badly written "howtos"  not infrequently out of date  rather than to-the-point technical documentation; things seem to change faster than I can keep up with; and due to ever increasing complexity debugging things when it all goes wrong it a nightmare. I often find myself wanting for Makefiles and shell scripts  and that's not because I like Makefiles and shell scripts!
[removed]
One of my recent projects started on pq and switched to pgx due to its `LISTEN`/`NOTIFY` handling. This project was pretty firmly rooted on PostgreSQL already, so I also switched to using pgx directly, and I find I prefer it over using pq via database/sql.
Ok I fixed it: val += int(scl[ri-1] - scl[li-1]) These lines where the problem. I did the subtraction in uint8 but it looks like the number should be able to go negative. Casting bot numbers into int before the subtraction fixed the problem. All algorithms are implemented here: https://play.golang.org/p/5d-dbIxZa8 (There is some cleanup to do^^). 
&gt; Bo normally Panics on error So what do your users to do handle errors? Wrap all calls to your API in a recover()? That seems more cumbersome than just handling the errors. &gt; Bo requires using lots of method calls. Checking for and handling an error on each one would add significant lines of code to your app There are strategies you can (and should) use to make error handling less repetitive: https://blog.golang.org/errors-are-values
I basically gave up on Python because of dependency management. No, really.
It looks like you send the hsts header when the request is HTTP. The hsts header should be sent for the HTTPS requests (see https://developer.mozilla.org/en-US/docs/Web/Security/HTTP_strict_transport_security).
Thanks! My question is: if I give you a type, and you know it's an integer type but you don't know how it was declared, can you tell me how many bits it is? 
I'll be back at my comp in two hours and I'll mock up some examples for you. By the way, welcome to Golang!
**Defaulted to one day.** I will be messaging you on [**2016-07-31 03:34:35 UTC**](http://www.wolframalpha.com/input/?i=2016-07-31 03:34:35 UTC To Local Time) to remind you of [**this link.**](https://www.reddit.com/r/golang/comments/4vaaip/number_of_bits_in_an_integer_type/d5wsita) [**CLICK THIS LINK**](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[https://www.reddit.com/r/golang/comments/4vaaip/number_of_bits_in_an_integer_type/d5wsita]%0A%0ARemindMe! ) to send a PM to also be reminded and to reduce spam. ^(Parent commenter can ) [^(delete this message to hide from others.)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Delete Comment&amp;message=Delete! d5wsiz0) _____ |[^(FAQs)](http://np.reddit.com/r/RemindMeBot/comments/24duzp/remindmebot_info/)|[^(Custom)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[LINK INSIDE SQUARE BRACKETS else default to FAQs]%0A%0ANOTE: Don't forget to add the time options after the command.%0A%0ARemindMe!)|[^(Your Reminders)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=List Of Reminders&amp;message=MyReminders!)|[^(Feedback)](http://np.reddit.com/message/compose/?to=RemindMeBotWrangler&amp;subject=Feedback)|[^(Code)](https://github.com/SIlver--/remindmebot-reddit)|[^(Browser Extensions)](https://np.reddit.com/r/RemindMeBot/comments/4kldad/remindmebot_extensions/) |-|-|-|-|-|-|
No need to allocate an `OptionFlag` on the heap. Just pass one of the constants: reflect.TypeOf(FooOption).Bits() Or pass the zero value if you don't want to rely on a specific constant being defined: reflect.TypeOf(OptionFlag(0)).Bits()
You can use unsafe.Sizeof. type OptionFlags uint8 var x OptionFlags fmt.Printf("bits: %d\n", unsafe.Sizeof(x)*8) // 8 https://play.golang.org/p/0T6RSglTlE Fun fact: while it looks like a function call, unsafe.Sizeof is a compile-time constant expression.
No, `*new(OptionFlag)` allocates a value on the heap, which is wasteful in this case. `OptionFlag(0)` could be stored on the stack or in a register.
Ah, I was playing around with this but couldn't figure out how to use it without declaring a variable of the type. I think some combination of this and /u/DeltaSixBravo's answer might be the winner. Thank you! flags, err := strconv.ParseUint(optionflags, 2, int(unsafe.Sizeof(OptionFlag(0))*8))
For using new in this case, Does escape analysis catch this case and replace allocating on heap with on stack?
It probably does, since the pointer is immediately dereferenced and discarded. But using a value directly is clearer than relying on compiler-specific optimizations.
&gt; Isn't *new(OptionFlag) roughly the same as OptionFlag(0)? Yes, it's completely equivalent.
Please don't. It completely obscures the control flow, it hides *actual* panic's (they will often also be an `error`, plus, re-panic'ing will loose all the stack trace, so your panics will seem to originate from `ct`), it's friggin' complicated ~~and it doesn't even work (`recover` needs to be called directly in a defer block, otherwise it doesn't work)~~. Just use `if err != nil`. And believe me, after a while you'll grow fond of it for it's clarity of error flow.
As explained in the exercise at the end of blog.golang.org/constants, you can compute the maximum value pretty easily. A related but much simpler trick can tell you the number of bits in a uint (which is the same as the number of bits in an int, by definition). https://play.golang.org/p/iJXv87kszu var x uint64 = 1&lt;&lt;32 if uint(x) == 0 { fmt.Println(32) } else { fmt.Println(64) } Once you've got that, you can refine it to this version, which is in the standard library source (strconv/atoi.go): https://play.golang.org/p/D5nzvMGlP2 fmt.Println(32 &lt;&lt; (^uint(0) &gt;&gt; 63)) You want 32 or 64, and 32&lt;&lt;1 is 64, so all you need is a 1/0 if it's a 64-/32-bit number, which you can get by ^uint(0)&gt;&gt;63. 
&gt; new is specified to allocate memory in some way. Yes. Decrementing the stack pointer is an allocation. &gt; The compiler may perform escape analysis to determine the best place to perform the allocation (on the heap or on the stack), but that is a compiler-specific optimization. The spec talks neither about the heap, nor the stack and there's a reason for that. The terms don't make a lot of sense in the terms of the language. In your parlor, you must assume *everything* is allocated on the heap, as that's the only way to actually implement the language without implementing escape analysis. &gt; The goroutine example that you provided works because the func literal is a closure which shares x. That behavior is specified and has nothing to do with escape analysis. Apologies, I was taking a short-cut. https://play.golang.org/p/10EInPAiLU I also disagree with it having to do *nothing* with escape analysis, but that's a different story. The point remains: The two expressions are semantically equivalent. It would make no sense to treat them differently. Any sensible compiler will treat them equivalently. You should still sometimes choose one and sometimes the other, but your motivation shouldn't be about stack or heap, but about readability. The mantra is "write readable code. It's the go teams job to make it run fast".
What is "golang"? Do you mean go? In that case no. Do you mean gc? In that case yes (if we ignore NaCl). But gc is not the only compiler and what gc does could change in the future (it has changed in the past). The fact of the matter is, that you should never rely on the size of an `int` to even stay the same between compilation passes. Just use a sized `int`, if you possibly need more than an `int32`.
I'm using upper.io, seems to be working well. https://upper.io/db.v2/
Yes, it help for Go adoption ! But virtualenv is very great, I like to use GOPATH like that.
Thanks, I've updated it to only set the header when HTTPS is being used now. There's not much information to go on in the http.Request struct, because most of the time, `scheme` is empty and the URL doesn't contain the full URL.
I tried virtualenv, it was an interesting concept, but I still had trouble with dependencies. If Python had NPM, it would be unstoppable.
Please no
Please, please, please don't start releasing open source projects using this paradigm!
Virtualenv is much inferior to GOPATH. Instead of just saying "hey install my packages *here*" you have to clone the whole interpreter in order to trick it into installing in the right place. 
That is so panics don't bubble up the stack and users of gob receive errors instead. However, what you have in OP is not good. Please don't release any code that does that.
Sorry just logged in today and saw this. One example, which I kinda built my structure off of, is [Refer Madness](https://github.com/larryprice/refermadness) written by Larry Price. It was created awhile ago and the structure imo is still valid today, i.e. registering handlers. From this example, I built my first Golang/React app, which is Resounden ([GitHub](https://github.com/beeker1121/resounden) - [Homepage](http://resounden.com/)). The current application I'm building follows this basic structure (with a lot more added on, such as authentication via JWT, CSRF protection, etc). Unfortunately, this application will be for a new SaaS, so I can't release the source to it (not yet at least). Also, someone sent me this video which explains the concepts better than I can [https://www.youtube.com/watch?v=yi5A3cK1LNA](https://www.youtube.com/watch?v=yi5A3cK1LNA)
Slice could have easily been improved. For example, you could have two magic types instead of one, say ThinSlice and FatSlice, where ThinSlice doesn't have a capacity and can't be appended to. That way when you're just passing around views of data (the common case) people won't accidentally append. If you want to go even further, instead of FatSlice, you could encapsulate it into a data structure, say, Vector, like every other programming language. That way it is impossible for users to screw up the internal buffer, and it would also get rid of the annoying repetition whenever you call append. That does have the disadvantage of requiring a non-trivial copy for safety. But FatSlice is basically what you get if you take a normal Vector and just don't copy the internal backing store ever. It's still a lot safer than the status quo in Go since you don't have to worry about it being appended to when passed to a ThinSlice method.
Silly me. That can be further simplified to n := t&gt;&gt;60&amp;8 | t&gt;&gt;29&amp;4 | t&gt;&gt;14&amp;2 | t&gt;&gt;7&amp;1 in &lt;https://play.golang.org/p/av089hes8Z&gt;.
The thing is, this isn't error "handling", in addition the way this is implemented has a pretty big tax that if used in code hot spots could cripple an otherwise healthy app. At least you wrote some code and learned something, in not going to chastise you or say it's stupid. It just lacks some propeties that Go programmers are drawn too, that's all. I know err checks get tedious and your intentions are in good spirit, but you are better off attracting away some of the more tedious chained nil checks in a small struct and use an interface similar to the scanner. I do this fairly often for similar control flow. Other than that, you should avoid funcs with many many error checks anyways. Try to keep functions tight and targeted to a few operations and it might feel less cumbersome (even if how often you do it isn't).
You can already avoid people accidentally appending: Just set the capacity to the slice length. Adding a second slice type is just confusing extra complexity.
Hi Rob, I'm a little floored that I'm talking to Rob Pike right now! Thank you for taking some to answer my silly question. Unfortunately, the solution you've given doesn't seem to answer my question. I'm not trying to programmatically determine whether there are 32 or 64 bits in an int/uint, I'm trying to determine whether there are 8, 16, 32, or 64 bits in a type that's an alias for a sized int/uint. EDIT: Okay, I went back and reread what you wrote, realized that I had focused on the second thing you said rather than the first, actually went and read the blog post you referenced, and came up with this: int(math.Log2(float64(^OptionFlag(0)))+0.5) So I guess you did give me an answer after all! Thank you, Mike
Just handle the errors or pass them up the call chain. This is how go works. I appreciate experimentation but attempting to make Go behave like language X is a recipe for a bad day for everyone involved.
If I read this correctly, this is some exception system using panic&amp;recover. As everyone already told you, this is frowned upon in the Go community, and adds some overhead. 
 &gt; sift -i 'defer.*\&amp;err' fmt/scan.go: defer errorHandler(&amp;err) fmt/scan.go: defer errorHandler(&amp;err) go/types/eval.go: defer check.handleBailout(&amp;err) go/types/check.go: defer check.handleBailout(&amp;err) encoding/gob/debug.go: defer catchError(&amp;err) encoding/gob/decode.go: defer catchError(&amp;err) text/tabwriter/tabwriter.go: defer handlePanic(&amp;err, "Flush") text/tabwriter/tabwriter.go: defer handlePanic(&amp;err, "Write") text/template/exec.go: defer errRecover(&amp;err) text/template/parse/lex_test.go: defer t.recover(&amp;err) text/template/parse/parse.go: defer t.recover(&amp;err) Examples of error handling with panic/recover in standard library.
There are a few Go graphs with at least some support for it (pending or live). Dgraph is new and is focused on GraphQL support (https://dgraph.io/) and Cayley has a pending PR with very limited support for GraphQL: https://github.com/cayleygraph/cayley/pull/449. 
Eleanor McHugh has an example of this in her Go Developers Notebook book, called Exceptions. When I read it, I didn't know if she was advocating the pattern or just showing an experiment. It definitely seems like it goes against the goal of Go, which is to handle errors directly and not bubble up exceptions that will crash your program. 
You probably could given enough time, but it wouldn't be worth the trouble. The first thing you'll think about is how to interface your program to the phone network. You can of course roll your own system using PBX software like Asterisks, but this is going to be super time consuming and too tangential to the problem you're actually trying to solve. So instead you should go with something like Twilio. Now Twilio is a service with APIs, but you probably don't want to write your own API bindings for Twilio because somebody has probably already written some good ones for you. Do you want to make phone calls or do you want to write a library wrapper for the twilio API? Those are not equivalent problems. So you probably use something like https://bitbucket.org/ckvist/twilio (there are others). Now, Twilio also has a nice tutorial on using some of it's APIs with Go here: https://www.twilio.com/blog/2014/10/making-and-receiving-phone-calls-with-golang.html and if you follow that you get part of the way there. However, this tutorial is just sending MP3s that are pre-recorded. So now you need to build some frontend software that collects audio and sends it to the twilio API. Go is pretty bad at building front end applications. It's best for command line utilities and long running server processes. So you have to figure out how to get audio from a microphone into an mp3 to send via Twilio. There might be good audio libraries for Go, but I'd be surprised. So maybe you decide to build a frontend in JavaScript that streams audio to your Go application over WebRTC which is is then streamed to Twilio (you can cut out the go portion and do WebRTC to Twilio directly) or maybe you use C#/C++/Something else to build a user facing application that streams audio to your server. Then your server streams the audio to Twilio or your own PBX. Either way, you're going to want to use libraries and existing services or it's going to take you a year or two to get anything working, if not longer. Also, audio streaming is latency sensitive and GC pauses may or may not hurt you. Lots of phone related applications are written in C/C++ for this reason, but if you're trying to learn it probably doesn't matter.
error message is in. Well...apparently it prints "new user" after settings "fasthttp.StatusOK" ..... but it doesn't set the status, instead the error occurs.
&gt; but you are better off attracting away some of the more tedious chained nil checks in a small struct and use an interface similar to the scanner. I do this fairly often for similar control flow. Could you share an example of abstracting away into a struct and using a scanner like interface?
also your code is atrociously formatted. Try and use https://play.golang.org or https://gist.github.com next time. Look at the line the error is on in fasthttp and you'll see the cause of the error.
I'm assuming you already know about methods and deliberately want something mutable. In that case, you can take advantage of the fact that the func is a closure: func NewFoo() *Foo { var foo Foo foo.Bar = func() bool { // do something with foo } return &amp;foo } However, if you want to be able to move the same `Bar` value into different `Foo`s and always have it referencing the current containing `Foo`, you'll need to pass it in as an argument, and use a method: type Foo struct { BarFunc func(*Foo) bool } func (foo *Foo) Bar() bool { return foo.BarFunc(foo) }
This is interesting and I'll be keeping an eye on it. I'd love a great cross platform backup tool. It would be even more fantastic if there was eventually support for NTFS file permissions and VSS on Windows :)
Worst case I'll need to hit google. Best case, pop will give me a useful answer, or a big clue, to my question/search. I'll give this a pop. Nice work :)
It's very kludgey and not well integrated. Trying to explain to non-Python people how to install stuff is harder than it should be. The whole concept of "virtualenv" is based on the interpreter having bad defaults of assuming packages are installed globally. C-based modules have a lot of problems installing. The split between setup.py and requirements.txt is poorly thought through. 
When I said Scanner I meant the (text/strings/audio/etc)/Scanner package in stdlib. But there is an example of variations of that pattern that lift a lot of burden from the caller for certain types of APIs on the golang blog "errors are values". Often the type of APIs where continuous err checks would be tedious. To be a bit more specific, think of structure which can require an intricate setup that may span many calls. An important characteristic must be that the caller does not need to know the state of the structure to produce future calls. The caller knows the target state and how to call the API to generate it. There may be an opportunity for desynchronization in state early on, but the API could simply not return any errors until the end user asked to commit the new state in whatever way shape or form, or if he asks to peak at the error state. I.e. call an Err method. It shifts the burden of checking a structure wide state before each mutation to the callee but it's a good exchange some times. I've done it on some network clients that have a cumbersome initialization where several send/ack cycles are done before I need to check the state of the client. Hope that helps. Happy coding.
If you persist one http.Client I'm pretty sure that would mean your API isn't thread safe. 
Maybe it's avoiding the default client that I'm thinking about. Sorry then!
Thank you! I really liked the first one.
One thing I sometimes see that annoys me is: Take a `context.Context` in all your calls. And support cancellation :)
As a relative newcomer, I also find this really frustrating and confusing. If you read the spec, it is pretty specific about how passing works, but then there's just a lot of not totally explicit sugaring that muddles everything up. This is further confounded by slices feeling a bit magical and non explicit, and interfaces implying both by value and by reference arguments. Also the '*' token is just overloaded in general, what with it being both a weird type specifier in methods, a dereference prefix operator, and a multiplication infix operator. And then it's meaning as a type specifier is used in non obvious ways (struct embedding).
Is there a particular reason why pointers act differently according to what data type is used. For example, why are slices automatically a reference, while when prepending a &amp; infront of a struct will also result in a reference while prepending &amp; infront of ints and strings results in a pointer? Why can't every datatype use the default pointer that ints and strings use? 
1. I don't know what exactly you mean by `reference` (as-in C++, Java, etc.) but `val` is a `pointer` which is its own value that points to something else. In this case it happens to point to the memory location of `x`. 2. It's not a reference. `val` is a copy of the slice `x`. Slices share underlying array, which is why you can seemingly modify `x`. Change `val[0] = 9` to `append(val, 9)` and see what happens. See https://blog.golang.org/go-slices-usage-and-internals and https://blog.golang.org/slices 3. You didn't pass anything by reference, `&amp;person{}` and `new(person)` gives you a pointer.
Your question includes two separate aspects. 1. Passing an argument by reference 2. Using that argument within the function Let' look at each of these aspects in turn. 1. Pass by reference There is actually only one way to pass an argument as reference (or rather - passing a *pointer* to a value. as Go has no concept of references) - see your first and third example. func f(name *type){...} Slices and maps are always passed *by value*. The thing is that this value *contains* a pointer to the actual data. Passing by value only does a shallow copy, so the pointer within the string or map variable still points to the same data. 2. Using a pointer value within a function The basic form is like in your first example: *variable = data The dot notation in your third example is just a convenience. Instead of (*val).Name or things like val-&gt;Name (as C++ or Perl would do it), Go just uses the same notation as for non-pointer values: val.Name That's easier to write than any of the above, and still everyone knows what's going on. 
&gt; EDIT Why am I getting downvoted? There is no reason to downvote this post. Downvoters, please re-read the rediquette. EDIT: Thanks for downvoting ;-P
Agreed, 60% is not much, but consider that this is just v0.2.0. Things may get better. Also, the percentage alone does not tell us what exactly is covered by the test. If all critical operations are well tested, and tests are only missing on functions where failure is not fatal for data integrity nor for service availability, then I would say I could live with those 60%. But yes, high test coverage percentage definitely would raise the confidence.
That is why I did not say `uint` but "unsigned integer type of 1, 2, 4, or 8 bytes". The set problem is not determining the size of `uint`.
This definitely clears up a lot of misconceptions I had about pointers. The reason why I thought 3 was not a pointer because if you do ```fmt.Printf(&amp;mystruct{})``` it will print the values in the struct instead of a memory address. Thank you.
Hi /u/mwpastore, One last factoring gives `n := (t&gt;&gt;60 | t&gt;&gt;29 | t&gt;&gt;14 | t&gt;&gt;7) &amp; 0xf` since the shifts will lie outside the bottom four bits in all unwanted cases, see &lt;https://play.golang.org/p/S_glnUdeSN&gt;. A compiler should turn any of the variations into a constant; it did in the one I looked at.
Apologies, I misread what you where trying to say :) If I'd actually clicked the playground link I wouldn't have :)
Ok.. so is the reason why I don't have to use the * before the val.Name because when the (.) dereferences it? 
I think the crux of your confusion is that you aren't fully understanding what slices are. Slices are basically like a special kind of pointer to an element in an array, along with the information of the length to the end element. That said, you can actually take the address of that slice information, and pass the slice info by reference. But when you pass the slice as a value, that information is copied to a new location in memory. It's just that the reference to the starting element in the array is indeed a reference. Slices are a helper on top of the actual memory element, which is an array. So think of slices as special case pointers, not as a concrete memory type (int, float, struct, array, etc).
Yes, I supposed that this was the problem. But I dont know how to solve it. How can I do to copy memory explicitly, I mean, I need to use a specific function?
Wiki fixed, thanks.
I wrote [mailchimp-go](https://github.com/beeker1121/mailchimp-go) after seeing they didn't host their own library. Deciding how to structure it was the toughest part, and I spent a lot of time looking at other libraries to plan it out. While it's modeled around the MailChimp API, I think the structure/layout is pretty valid for any mid-to-large level API. If the API were smaller, say only 3-4 endpoints, I would probably just code it all in one package (all files in the main package folder instead of splitting up endpoints into separate folders). Edit: Just to highlight some of things you pointed out, there's a method for [setting a custom http.Client](https://github.com/beeker1121/mailchimp-go/blob/master/mailchimp.go#L40-L43), and this is how it [handles errors](https://github.com/beeker1121/mailchimp-go/blob/master/mailchimp.go#L89-L97). Edit again: It would probably help to point out what was focused for the development of this: * Single `http.Client` object is used for all API requests, with the default KeepAlive timeout. This will reuse the connection if multiple requests are made within the timeout period, resulting in slightly better performance. * Custom `http.Client` can be set by the user via `SetClient` method. * Each API resource and sub-resource (endpoint and sub-endpoint) is its own package within the library. For example, the `/lists` resource logic is in the `/lists` folder, the `/lists/{id}/members` resource logic is in the `/lists/members` folder, and so on. * Resource methods are named for what they do according to the standard HTTP methods. For example, all packages will export methods `New`, `Get`, `Update`, and `Delete`, which makes each resource idiomatic. You could choose to name these methods `Post`, `Get`, `Put`, and `Delete` if you want to fit the naming conventions better. * Conversion of native Go types (string slice, time.Time object) into JSON and vice versa. * API error responses are decoded into a custom `APIError` object, which the user can cast into ([example](https://github.com/beeker1121/mailchimp-go/blob/master/lists/lists_test.go#L62)). * Custom types for handling request parameters.
Ok, found the solution myself. I was thinking: what to compress? There's no body as a response.... adding ctx.SuccessString("text", "ok") Solved it.
&gt; `int(math.Log2(float64(^OptionFlag(0)))+0.5)` Beware that only works for unsigned, not signed as well, like you originally asked.
&gt; Can take the address of literal struct declaration. Can not take the address of 123. That is an arbitrary exception, though. In principle, taking the "address" of a struct literal is no more (and no less) sensible than taking the address of an integer literal.
While these look different, #1 and #3 are both pass by pointer. Yes, you can mutate the original memory space within a function call, but that's what pointers are for. If you tried to operate on the pointer itself within mutate, the original value would be unchanged, because you copied the pointer when you passed it in: func mutate(val *person) { val = &amp;person{"Goober"} // this change will not be reflected in the calling function } Example #2 is an interesting case. You are NOT actually passing a pointer there. You are making a copy of the slice and passing it to the mutate function. A slice, however, is a very simple struct that wraps an array: def Slice struct { arr *[]int // this pointer is why it appears to be passing by reference size int capacity int } So underneath the hood, you are copying a bit of metadata (size and capacity) and a pointer (just like #1 and #3). So you can mutate the elements within the slice, but you are performing those manipulations on a copy of the original slice. This matters A LOT. If your mutate function appends new elements, you will get big problems. If you add an element, the element will show up in the original slice, but the size value will change only within the copy (it got passed by value, remember). Even worse is if you append beyond capacity, forcing an expansion. Within the mutate function, the slice will allocate a new array, copy over the existing elements, then continue appending. But this will not affect the original slice (the pointer was passed by value). The new elements you appended are now gone, the size of the original slice is wrong, and you have a bug in your code. This is why all slice manipulation functions return the slice `foo = append(foo, "bar")`. Now the only place this gets a bit "odd" is when you are dealing with interfaces. Take the following: def Foo interface { DoStuff() string } func main() { var foo Foo = &amp;ThingThatImplentsFoo{} mutate(foo) } This version of `mutate` won't work. A pointer to an interface is not allowed. This is because an interface variable already contains a pointer (note the assignment). def func mutate(foo *Foo){ // do stuff } Instead, you write the function like this. Now, you are passing by pointer, just like all the other examples. def func mutate(foo Foo){ // do stuff } I hope this helps and doesn't delve too deeply into stuff you already know. Good luck learning Go. It's worth it!
Not really arbitrary.. the integer is not mutable, the struct is.
It really depends on the type of web app you have in mind. Is it a standalone http API? Will there be templates or other assets you plan to render? Will you have subpackages that other apps might import? How is the app initialized? The most basic suggestion I can give you is to keep your codebase flat, by which I mean you should stay away from creating directories for controllers, models, etc, like you might do in MVC frameworks.
Sure, as long as you actually return foo ;). Also, this way means you have to specially construct each `Bar` value for a particular `*Foo` value, but as long as you're okay with that, it should be fine.
I must admit that I didn't give it much time to verify what is said above. Most of what I'm saying about it is from what I read from various forums, and my hour-long experience with it. I'll give it a deeper look tomorrow. If it's still problematic will be back with complete analysis. Nevertheless I'll be happy to see some more suggestions in case there's anything else available that I'm not aware of. Thanks!
You should try [Visual Studio Code](https://code.visualstudio.com/). It is a good editor, and also has [vscode-go](https://github.com/Microsoft/vscode-go) which is a great plugin for language support. The vscode-go repo also has instructions for installing a debugger you can use to step through code ala Visual Studio.
Pet peeve in example code: Mode argument to creat/WriteFile should almost always be 0666 (or 0777 for executables) unless there's a good reason not to. 0600 makes sense in some rare cases (not sure why here), but I see 0644 a lot which is almost certainly wrong in every case it's used.
Author of [go-debug (atom)](https://github.com/lloiser/go-debug) Can you please tell me what you don't like about it?
Some very good advice and links in there, thank you!
If you ever need help, a guy made something called How2 on github. Same essence, but it wasn't written in Go
Isn't it exactly the same in C though? Of all the Go concepts, this isn't really anything new and strange. 
Good god, you could not be further from correct here. What you're suggesting is terribly dangerous. 0644 for files, 0755 for directories or executables (usually) is good practice to ensure a secure filesystem. 0664 and 0775 can be a fair compromise under certain circumstances too, but if you ever have to resort to 0666 or 0777 then you've done something very, very wrong (or you've hit a usually rare edge-case).
I've been running *nix systems for years, and do understand file creation and unix permissions. Why would you want to open up files so that anybody on the system could write and/or execute things? It's an obvious security vulnerability. Unless I am actually missing something here (though in this case, I'm pretty confident that I'm not)?
That's a lot of text for 6 bullet points: https://golang.org/ref/spec#Assignability
So... you didn't try or read the man page. That's why you don't see what you're missing. The permission you give to creat is maximum permission. The user's umask is used to determine final permissions. Typically this defaults to 022 or 077 which yields 0644 or 0600 respectively. But it's rarely up to the developer to decide what's right in *my* case. Perhaps whatever code is generating these "page" files in the example need super special protection. So run the process with a umask of 077, but what if I want more than one user to be able to edit the files? Ideally, they'd be 0660 (i.e., umask of 07), which becomes impossible to enforce because you've specifically taken that ability away from the users. I've seen people work around this by creating the file and then immediately changing permissions, which is a different kind of stupid, because now users can't *restrict* permissions. The only time I've seen it make sense to use anything other than 0666 for data files is when they're actually sensitive wrt the application domain, e.g., ssh or gpg key data.
I am not involved in this project, so I cannot talk from the trenches. However, I found [issue #21](https://github.com/restic/restic/issues/21), "Implement Compression", which is still open. So it seems that compression is on the "planned features" list. 
The author of restic did a [feature comparison](https://github.com/restic/others) among various backup solutions, including Attic and restic. TL;DR: &gt; attic: review,dedup,encrypted,python,authenticated,unmaintained &gt; &gt; restic: review,golang,encrypted,authenticated,dedup,incremental,ssh,s3
Heh. It's a common thing. I should make a public version of the doc I wrote at work to send to people I find doing this during code review. You begin to rage against it when you actually really need a group to share files and you can't because of bugs everywhere people are creating because of what they needed in their uses cases. If you only ever have needed 0644, it all looks the same.
They only return non-negative numbers which are more convenient to work with in the majority of use cases.
Fantastic! Tagging structs always drains the life from me. Didn't see GoImpl in 1.7 either, that'll be real handy for go-grpc.
There is a note in the documentation that says: &gt; By default, session cookies last for a month. This is probably too long for some cases, but it is easy to change this and other attributes during runtime. Sessions can be configured individually or the store can be configured and then all sessions saved using it will use that configuration. We access session.Options or store.Options to set a new configuration. The fields are basically a subset of http.Cookie fields. To expire sessions in a CookieStore on browser close, set the MaxAge property of the Options to 0. 
&gt; Go is strongly typed programming language. The set of values allowed to store in variable is determined by the variables type. Because of that arbitrary data cant be just assigned as in dynamically typed language like Python. Just 2 sentences in and the author has already demonstrated that he doesn't even know the most basic properties of type systems. Hint: Python is a **strongly** typed language, it is not a **statically** typed one however.
Ah ok, anyway I see that someone made a fork with snappy compression, I'll give that a try, hopefully it will end up getting merged.
Go programs are statically compiled, why should hosting provider matter?
If the struct literal is mutable, then why does the same struct initialization code allocate multiple times if the code is run multiple times? Saying that you're taking the address of the literal sounds like the literal is in read-only memory and you're taking a pointer to that memory, which is not mutable.
Some hosts don't allow you to run your own binaries. And if you need to tune the system or set permissions or something, you might need root privileges to do that, which is pretty much impossible on shared hosting.
Yeaaaa can't wait anymore :)
[This](https://gist.github.com/314e8b5334639280095437230957a982) code works on OSX El Capitan. It just modifies your clipboard. Try it. 
Sorry man, read this a couple times but not sure I understand what you are asking. Are you thinking mutability would relieve an assignment operation or further allocations after the initial? My guess is no.. so maybe your question is just written unusually or I'm having trouble braining. Ive exhausted this topic fully in this thread I think, if you want more information on below seek out composite literals in the language spec: person := person{} Below you should look at address operators and perhaps assignability to better understand why you may not take the address of immutable values, such as numerical constants like *20*: person := &amp;person{) 
Hello, for golang you will need something like a VM, dedicated, etc. They have 5$ servers that could run go here: https://www.godaddy.com/pro/cloud-servers
It really depends on what the project theyre expecting from you demands. It's difficult to guess because there's no obvious overlap between golang development and reactjs exclusive javascript. Most likely they're wanting you to build some api service, so I would look in to how to write restful http api's in golang.
If their hosting supports fast-cgi, Go has a package for it and you could use that (probably).
Pertinent [golang-nuts discussion](https://groups.google.com/forum/#!msg/golang-nuts/Kle874lT1Eo/E5dnkXkLYnQJ). If you need a uint64 value, you can do `uint64(rand.Uint32())&lt;&lt;32 | uint64(rand.Uint32())` or use [a custom rand source](https://gist.github.com/anonymous/3908425).
exactly. that would make way more sense.
Its actually an open [issue](https://github.com/golang/go/issues/4254)
Please don't use godaddy. They offer pretty mediocre service at inflated prices. Their customer service is pretty bad (as you discovered they don't even know what their hosting supports), and they have all kinds of scummy and unethical practices too. I'd recommend going with pretty much anything else. Having a lot of success with Digital Ocean lately.
The conclusion is correct in this case, but the problem is when your premise is wrong you can draw *any* conclusion. The correctness (or not) of the conclusion then has no relation to the premise. I have a few years of Python background and what grates me most in these types of posts is that people frequently compare **weakly** typed languages to **statically** typed languages, which is apples to oranges to begin with, and point to Python as a "bad example". In my personal experience Python has one of the best type systems when it comes to **dynamic** languages.
I'm not sure what the point of you comment is. You know perfectly well what the author meant - we all do, yet you choose to cast the rest of the article in a negative light (maybe even stopped reading) over a point that isn't entirely false? &gt; Go is strongly typed programming language. true &gt; The set of values allowed to store in variable is determined by the variables type. true &gt; Because of that arbitrary data cant be just assigned as in dynamically typed language like Python. also true. you can absolutely assign arbitrary values to variables/labels regardless of what types they in Python. Even after all that *you* yourself seemingly conflate *static* and *strong* typing. It's true that Python is *strongly* typed, but it has nothing to say about *assignments*.
&gt; you can absolutely assign arbitrary values to variables/labels regardless of what types they in Python `x = "3" + 3` Illegal in Python, legal in JS.
You had your day wheel, it's wheel's turn now.
No, the `"3" + 3` is illegal, and it has nothing to do with assignment.
Following that line a JavaScript variable named x has the *value* "33", a Python variable would have no value at all. It can also demonstrate nicely that it is *possible* to have weak typing in a statically typed language in which case x would either be "33" or 6 depending on if x was declared as string or int (but it would at least be consistent). Of course you can't have type inference then without getting into the same order-of-operations mess we know from PHP or JS.
&gt; it would only compile the main file, and than fail on not finding functions in the rest of the files. Only the main file (with main() function) is runnable in Go. The plugin won't do a compilation step for anything else. What is your expectation? Would you want to run the project from any file? Or why is compilation a thing you've mentioned? &gt; I guess this is what you get when trying to integrate a very opinionated language into an IDE built for Java. The plugin is not yet a 1.0 release which means there is room for improvements. So far we have not had this feedback so nobody looked into this problem. It has nothing to do with Go or the IDE being built for Java (it can in fact run PHP, JS, Haskell, Python, Ruby and a host of other languages just fine). Input like yours will help the plugin move towards the right direction so thank you. Can you please describe exactly what you've done? Like: I've opened the project folder, then navigated to a random file, pressed run and expected things to run but they didn't (and maybe mention some examples so that it can be easily reproduced). Thank you!
&gt; i do not know on why you should access as a non root user the cert files. All of my nginx configurations run by root user with no problems until now (1year +). Nginx can drop its root privileges after it has acquired all its ports and cert files. Because of the way the Go runtime works this is currently not possible for Go programs (there's an issue somewhere on the golang github with all the gory details, it's a tricky problem to solve).
There seems to be a 3 second delay when I use :GoSameIdsAutoToggle... anybody know why?
Great, I updated into this after I installed go1.7 and now it seems autocompletion is not working anymore( I use YouCompleteMe ).
I would recommend taking a look at Google Compute or Amazon EC2. For Google Compute, you can find promos all over the internet for $300 in credit for the first 60 days. This would essentially let you test their larger offerings risk free. Amazon's Nano / Micro packages are very reliable, and depending on your spec needs, would run anywhere from $0 to $15 a month.
Actually, MaxAge 0 means Max-Age not specified in Gorilla sessions. Set MaxAge to negative value to immediately expire the cookie. Also, Max-Age is IE feature. I don't know what happens on low level in Gorilla cookies. Setting Expires to current time should be the most reliable way to expire cookie.
Hi Rob, Here's sizeof(unsigned-integer-type) as a one-line const. I found it interesting because a typed constant is needed early on to get its top-bit set, but after that it would have been handy to slip back to untyped otherwise the uint64 multiplication overflows in all but the one-byte case. The division gives a mask for the multiplier to avoid the overflow. &lt;https://play.golang.org/p/f5sFjrO6WS&gt;. sizeA = ^uint64(0) / uint64(^(^tA(0) &gt;&gt; 1)) &amp; 0x20400080000001 * uint64(^(^tA(0) &gt;&gt; 1)) &gt;&gt; 60
Checkout the docs. You have to set `updatetime` to something small.
Setting the MaxAge to 0 seems to work for what I want to do. Thank you st3fan!
PGX is very solid.
doesn't work (send a 4 digits hex instead of a 2 digits hex) with "caf" https://play.golang.org/p/6atg1shJbn
https://play.golang.org/p/FCUo4-4QmH Note that this will give incorrect values if your string includes values which cannot be represented as 2 digit hex codes (e.g. emoji), but since you specified 2 digits in your description of the problem, it's broken as designed :-)
:) yes, but we want go to interpret \xe9 as a one byte, and with your example @metamatic, "\\x" would be interpreted as 2 chars : \ and x
It feels like Go has been a version behind. Right now there is solid lib support for 0.8 and 0.9, but I've not seen any support for the latest version of Kafka (0.10). We've been using https://github.com/Shopify/sarama.
My example doesn't attempt to convert "\xe9" to a string. That's the reverse of what you asked for.
Yeah, I think it's time to tell us what the actual problem is.
OK. NodeJS, being built on JavaScript, is [probably computing the hash on the UTF-16 representation](https://mathiasbynens.be/notes/javascript-encoding) of the string. Your easiest option will be to convert your Go string to a UTF-16 representation and then hash it as a byte array. See Go's [unicode/utf16](https://golang.org/pkg/unicode/utf16/). A better option would be to fix the JavaScript code to convert the string to UTF-8 before hashing it, because [UTF-8 everywhere](http://utf8everywhere.org/); but you say you can't fix the JavaScript, so...
Also, as per [this page](https://github.com/golang/go/wiki/SQLDrivers) it's the only pure Go driver which is both included in, and passes, the test suite.
I don't know if you have checked them out in a while but they offer a more modern platform these days on reliable infrastructure. At 5$ for a small VM it's much like digital ocean with similar price point. They use to be mostly cheap commodity shared hosting.. which has the standard caveats of mass abuse. Just something to think abiut, I personally use to use digital ocean last time I had a web server because Godaddy didn't have a similar product.
and the simplest way to do that would be [upgrading to node6](https://github.com/nodejs/node/wiki/Breaking-changes-between-v5-and-v6) and try to use a fallback function on our js app.... 
Looking at the [commit changes](https://github.com/nodejs/node/commit/b010c87164) and your code examples, could you just change: `Buffer(key, 'binary').toString('hex')` to `Buffer(key, 'utf8').toString('hex')` ?
Thanks very much for the explanation.
or the opposite, within go app, try to convert to a binary string ?
I had this issue recently after installing a newer version over an old one. If that's the case, try deleting everything from the old version and after installing the new one it should stop.
Try again.  (latin small letter e with acute) encodes as C3 A9 in utf-8.
can try https://play.golang.org/p/nlJR3bv8IU
fixed it ;)
I also saw that node is technically treating the 'binary' type as 'latin1' encoding, so maybe this would work instead? http://stackoverflow.com/questions/24555819/golang-persist-using-iso-8859-1-charset
Godaddy is much worse than simple bulk pricing. Look at their homepage now: ".coms for $2.99". Fine print says: "When you register for 2 years or more. Additional years $14.99*" So its $11 a year at 3 years. That is not bulk pricing. That is deceptive advertising. Compare to name.com who provides a simple price on first search with no nonsense. I don't have to bust out a calculator to determine the actual price. Yes other people do it. Dish Network and Comcast come to mind. Other companies I will never give money to. Just because it is legal and commonly practiced does not mean I have to feel good about it. Yes, you can read the nameservers, but not update them. A support ticket quickly confirmed that.
Doesn't compile on Sierra. 
Excellent read, can you do the whole stdlib?
I'm the author of [API Foundations in Go](https://leanpub.com/api-foundations) which I can recommend (I can even send you a free copy - authors privilege :)), and I can recommend some articles on my blog, https://scene-si.org - apart from that, the biggest reference is just *reading* code of projects which are interesting. One series of examples you should never miss is Go by example: https://gobyexample.com/. It's very much dealing with Go as a programming language, and not so much in the realm of putting it all together to an application. As you have, from what I understand, a front-end developer background, you might find some struggles translating that specific knowledge into Go (back-end), but if you have a clear goal in mind, finding information how to do it and people who are willing to lend a hand is very much possible. My inbox is open if you ever have any question(s) :) Best of luck.
thanks guys. I do love digital ocean but for this project, I'm afraid we're stuck with godaddy basic hosting as it is already paid for.
Thanks! Unfortunately godaddy is already paid for. 
http://pastebin.com/SRBv43iz
https://play.golang.org/p/nB1jJnPsgm Here is your code changed from a struct to an int and nothing is different. Also, p.Change() does not modify p because it has a value receiver, it copies p, modifies the copy, and returns the modified copy. The original p is unaffected, not that you would notice because it's not stored anywhere. The fact that Hello() and Change are pure (aside from printing) diminishes your argument.
Thanks so much for this will look into it!
I shall see if this approach works! Thanks!
It has been part of alice since July 2014. I'm not saying they are better either, just pointing out an error.
Ok, so you deleted your replies? In your most recent reply, you mentioned that the spec supports you. What I found in the spec was this: (emphasis mine) &gt;Taking the address of a composite literal generates a pointer to a **unique** variable **initialized** with the **literal's value**. You also mentioned that preforming a conversion is completely different, to which I will say that the conversion does absolutely nothing other than tell the compiler what methods to use. I could have done the whole thing with the builtin int, but then I would have to use regular function rather than methods (methods being pure syntactic sugar in this case). int, myint, and struct{I int} all have identical in-memory representations and none are references. I should warn you that this arguing is more fun than frustration.
Nice article. I would mention that ReadFull returns io.EOF instead of io.ErrUnexpectedEOF when zero bytes are read. Forgetting this fact has led to a number of subtle bugs since io.EOF is not usually handled upstream as an error, but a condition to terminate on.
Instead of using an int of -1 to represent a draw, make a type called Player that aliases int and then make constants for Xplayer Oplayer and Noplayer. Bonus points if you can do it using iota. 
It's explained in the spec: https://golang.org/ref/spec#Assignability https://golang.org/ref/spec#Types https://golang.org/ref/spec#Predeclared_identifiers func() {} is not a named type string is. "x's type V and T have identical underlying types and at least one of V or T is not a named type."
The project currently has been generating C, Python and Go code in one directory. I wonder if that's not the issue...
Ok, thanks for help me. I think that this code is really useful.
Why include error if there isn't one? Return an error if it exists, otherwise return the data being requested. Use status codes to help the client react accordingly. 
&gt; Following that line a JavaScript variable named x has the value "33", yes that's what *string concatenation* in js is defined to do (convert the number to a string and concatenate it) &gt; a Python variable would have no value at all. the python variable wouldn't exist at all because the expression is invalid &gt; &gt; It can also demonstrate nicely that it is possible to have weak typing in a statically typed language in which case x would either be "33" or 6 depending on if x was declared as string or int (but it would at least be consistent). yes a language being statically typed doesn't mean it can't also be weakly typed. not sure what your point is. &gt; Of course you can't have type inference then without getting into the same order-of-operations mess we know from PHP or JS. i don't know what you're taking about here. look, i don't know what any of this has to do with my replies, your original comment or the quote you used in your weak attempt at discrediting the author. here is the quote again &gt; Go is ~~strongly~~statically typed programming language. The set of values allowed to store in variable is determined by the variables type. Because of that arbitrary data cant be just assigned as in dynamically typed language like Python. you keep talking about how Python is strongly typed, but i don't know why, because no-one said it wasn't. Python being strongly typed doesn't prevent anyone from storing arbitrarily typed values in a variable because it's dynamically typed e.g. `x = 1; x = "a"`. you can do exactly the same things in Go by bypassing the static typing e.g. `var x interface{} = 1; x = "a"`.
That website of yours is super cool! I can not stop watching the gophers battling it out in a game of tic-tac-toe :D I implemented that "named enum" based on earthboundkid's suggestion, but seeing that multiple people suggest this approach gives me confidence that it is the right thing to do. I really like your implementation of the board with a single slice. It reminds me of the way we learned to implement heaps in university (obviously other indexing formula). I wonder which solution is "better". It would certainly make my NewGame() function look nicer if I implemented the board your way. Thank you for taking the time to comment on my code!
Edit your subject to say what the "thing" is so others know whether to bother reading the post. I started, and gave up when it wasn't readily apparently. There's one writer, many readers.
That would be twice slower depending on the underlying implementation. I actually find the golang random stuff useless, as in most other languages. It does not generate random floats in a standard fashion either, see [this github issue](https://github.com/golang/go/issues/12290)
Obviously, avoiding "net" or "fmt" as a package name is common sense; but feel free to expand on "price to pay"
Yeah, I was too lazy. I added at least some tests now: https://github.com/makkes/shorty/issues/4
&gt; That would be twice slower depending on the underlying implementation. Like almost any default random source, making two calls to the underlying generator for one value is going to be slower than one call. That's why I linked a custom source. Additionally, expecting a mathematically random stream from a PRNG (ints/floats/otherwise) isn't going to lead to happy times.
Use something like DigitalOcean or Vultr, and save yourself the massive headache of dealing with GoDaddy. (They're not called GoDaddy because they're good for Go).
I think I go through cycles of loving and hating Go at the moment myself. The new things in 1.7 are keeping me happy for now though ;)
&gt; you keep talking about how Python is strongly typed, but i don't know why, because no-one said it wasn't. OK, now I get where your confusion comes from. The article has been changed... The quote in my original post is(was) a direct c&amp;p from the article. The author has changed it in the meantime to say "statically" instead of "strongly". So what you thought was **my** mistake was actually the **author's** mistake (at that point) I was calling out, i.e. I missed [this reply](https://www.reddit.com/r/golang/comments/4vh6yc/assignability_in_go/d5zfgp1).
What optimizations?
Is 8 MB significant? Given the average USB stick is now around 16 GB in size and hard disk sizes many multiples greater than that, files of that size do seem rather insignificant.
Hi guys, it's still kinda beta but very relevant to this. Check out my site https://www.merknera.com it's written by go and facilitates games of tic tac toe written in different programming languages. Full details can be found here on how to write a bot that works with Merknera: https://github.com/mleonard87/merknera/wiki
Author here. Thanks! I'm glad you enjoyed it. I have a list of 29 packages I plan on writing up.
OS X Sierra needs Go 1.7 or Go 1.6.3. https://github.com/golang/go/issues/16354
THIS is why I'm excited to be just getting started with Go! :)
This somewhat bumps into the age old issue of not being able to truly control certain things about a user's browser. If Chrome is set to "Continue where you left off." then it might simply persist your cookies when you close Chrome, making a "session" cookie actually permanent. If this is an issue, you might want to instead look at short lived cookies that you keep extending as the user performs actions (often called a heartbeat). If you'd like to see Google's wontfix response, take a look at... https://bugs.chromium.org/p/chromium/issues/detail?id=128513 Also, you could set a browser to clear ALL cookies when a tab closes, but it will also clear cookies with expiration settings. Firefox causes this behavior with "Show my windows and tabs from last time" checked. This violates the standards: http://www.w3.org/Protocols/rfc2109/rfc2109 so you'll get people assuming it isn't true, but between FF and Chrome, that's a lot of users...
oh! Sounds like you're in a real cow pie here then. Anyway, https://www.godaddy.com/help/which-programming-languages-do-you-support-with-cgi-26 makes me think that basic doesn't even allow CGI on your basic plan, so I'm guessing it's not possible.
I include the error variable because I don't know there isn't one until it's time to separate out the potential response from the error. That's the way the RTM API responses go -- they always consist of a single outer key-value pair with a key of "rsp", with the inner dict having always having a "status" key with a string value and an "err" key having a dict of strings, with "code" and "message" the only keys. The process of checking each returned struct for errors is identical, which is how I can write the IsOK() code above. Do you have any specific suggestions on how to improve the code?
I'm on Go 1.6.3. Same deal. :/
Read the article he linked too. That article is just trash because his colleague refuses to move on from C world nothing else. Go was written with certain goal on mind. Anyway, asserts are really bad, I agree on that. Avoiding it in language forces programmers to write better error handling code. Plus it is trivial to write your own assert function. That is just being pedantic. Stack frames limited to 100 is a valid concern but there is way around it. Not enough to hate a language. Every language has it's share of baggage and shortcomings. These things improve over time. I personally, do not like a GC language. Would have loved to have option to free memory on my own even though GC is enabled. This would have give me best of both worlds.
The author should look more into the current tooling for the language, as with the Intellij Golang plugin and VS Code using Delve, the debugging story got a heck of a lot better. That being said, I've been using Go since 1.0. I was there when there was very little tooling support save for what is provided with the language (go fmt, go get, etc). Using the latest tools I am only trivially more productive than I used to be. I very rarely have to use a debugger with Golang, whereas with Python I am constantly using ipdb. This is just the nature of the language and how it's built. The appeal of Golang is the absolute minimalism that underlies the philosophy of the language. Sometimes I don't always agree with it, but as I've used it I've definitely seen the benefits. I think that most people I've worked with, who have used it for any significant amount of time, end up agreeing with that sentiment. For example, In the beginning I was very much for the addition of Generics, which seems to be the most contended missing feature. I didn't agree with Rob Pike's original comments about how generics provide less value than they claim, at the cost of higher compilation time. Now I'm not so sure. I've worked on several quite large Golang projects by now, and I really haven't missed them one bit. Sure, every once in a while I'll have to write a function for a list of int vs a list of int64, but those functions are usually so small and simple that the net effect is that I write them once and never touch them again. It is at most a 5 minute cost. Now, if they included generics, and that raised the compilation cost 10 seconds every compile, that would clobber the initial 5 minute cost of writing that function quickly. I'm not saying Golang is perfect nor feature-complete. I'm sure they will keep adding features in the same philosophy they have been following, and that the story around DRY code, debugging, and compatibility will get better. A very good case in point is the addition of adding the frame pointers to the compiled output, which the author points out. I'm excited for the 1.7 release, and the team keeps pushing out more stuff very quickly. 
They don't need a specific authority to make a standard. As long as it has well defined specs I think it's fair to say that you have a 'standard'.
I've wanted this from time to time. The usual case is where I'm writing a periodic process that will create a ton of (or several large) temporary objects. When the process completes, I know those structures are no longer needed and would like to manually free the memory. Arguably, I should not try to be smarter than the compiler/GC. I do think, though, that if I could allocate a large memory space as a scratch space and manually manage it (but let GC handle everything else), it could improve performance in certain limited cases. There are [some packages out there](https://github.com/teh-cmc/mmm) that can help you manually manage memory if you encounter one of these cases, but I haven't used them. 
congrats to the go-kit team for another great release!
&gt; when multiple have the same package name and the same functions, and types. That really shouldn't happen very often. In practice, I manually have to edit imports approximately only when importing them under different names (e.g. for generated proto packages, which have annoying names).
do a `go get` on the repository url of `go-bitstream` and it should auto detect things from there
if it were a friendly debate, I'd love to participate. I see very strong value in goa.
I did folder by folder with different settings. source code scans every 30 seconds, the "Documents" folder every 5 minutes, etc.
The go-gl binding suffer from this too!
That's one of the reasons why you shouldn't do that (i.e. have a different package-name than the last component of the path) :) Anyway, I hope you learn to love goimports as the rest of the community does :) And welcome to the community, while we're at it :)
im assuming because garbage collection? although i havent seen this compared to another managed language that produces a standalone binary
would a pool not solve your problems?
In many ways Go is "over-indexed" for the domains of network driven I/O bound command line applications and services. Its great for those domains but its very hard for me to see it seriously extend to the domains of UI or graphics. I'm betting on Swift. Swift feels like a modern and expressive statically linked language. Its expected to adopt advanced concurrency in Swift 4 too so there's potential to use it for IO bound applications on the backend.
PS: If there's anything unclear about the gorilla/sessions API or behaviour, please open an [issue on GitHub](https://github.com/gorilla/sessions/issues/new) and I'll gladly talk it through. There's a lot of existing docs, but they can always stand to be more comprehensive.
This is the approach we use, keep in mind there is two big pitfalls with providing the hosting from inside the api endpoint. First, frontend devs are very bitter when it comes to path lengths, if everything is prefixed with /dist eventually someone will ask why can't we have /img for static images? You need to be firm on only having one static path, or before you know it, every time there's a *need* for a new prefix you have to modify and redeploy the backend. Second, this makes your application monolithic by nature, as soon as you want to put half the service into another instance, you're going to have a hell of a time writing your own api gateway. The solution is to think about the services lifetime, if its ever going to be expanded appon, just use a api gateway to begin with, it solves the problem the article addresses indirectly, and allows much better possibilities for HA when you need it.
Yep, these are good points, and I'd hope that anyone at scale would be serving static assets from nginx/Varnish (or Caddy, even) to a CDNalthough a Go service as an origin still works. This simple example could still proxy to another backend service (or services) if you split that out, but keeping in mind how coupling might affect you in the future is always good advice.
Also if anyone's interested, we use vulcand since it allows some very complex rules without introducing much latency. Another good alternative is traefik, very similar design but can also handle docker containers if that's your thing. Others are kong and tyk but from experience they're much too bloated for our use cases.
I would update your code example as well. What you have currently is what has commonly led to bugs. Consider the following change: buf := make([]byte, 8) if _, err := io.ReadFull(r, buf); err != nil { if err == io.EOF { err = io.ErrUnexpectedEOF } return err } It some cases, returning io.EOF is exactly what people want, but this example at least makes people think about it. Example bug: https://github.com/golang/go/commit/9deb940d2481396944f090dd9f205f2d5b3d94ee 
Yes, good point and one of the great ironies of Go.
From what I've seen the preferred Go solution is to use pools and handle object creation/destruction outside the hot path. Of course that won't stop the GC from doing its thing at inopportune moments, for example when you throw away a lot of "spare" pool objects after a burst. The Go team's stance on it is that if the GC gets in the way you don't tune the GC or disable it, you **fix** the GC to not get in the way. That's obviously a work in progress, but I'm pretty optimistic that in the end Go will have a pretty darn good GC because of it.
Lots of people are decrying the lack of a good, platform-independent GUI library for Go, especially Andrew Gerrand brings this up a lot. Sadly so far no one has been willing to make one.
I'd like to hear more about how goa2 grpc stuff would work. I've been using proto files as single source of truth and code-generating out of that (js, go, etc.).
I would if I knew how
Because it is a all in one binary. It contains the runtime, all the dependencies for every bit of code in there. Because of this you can run this as it is on any computer which can run an ELF binary(for *nix systems). No need to install libraries, binaries, or anything else. C still needs couple of shared libraries, even when you try to statically link the program. 
It's a touchy point. It's an argument between fail-safe (die on any unexpected problem) and fail-operational (don't die unless explicitly told to do so). Your program may not die from an unexpected error, but if your error handling doesn't handle the error that it thinks it's handling, you have undefined behavior later on. You might be trying to use some object that isn't fully populated or a connection that isn't really established, for example. And you need logical error handling, because if you simply die on any error, you've just reimplemented uncaught exceptions. Passing the error up the chain to die further up is the same deal. At least an uncaught exception stops you in your tracks and makes you think about what you ignored. The problem is this usually winds up punishing the user, not the developer. So neither solution is really that great. The question is which is less preferable, a program that quits unexpectedly and cryptically or one that keeps running but does bizarre and nondeterministic things? And that depends on the situation.
Are there any legitimate scenarios where error values may need to be ignored? Also, I wish Go had a solution to handle errors on the defer-path better. Often times I end up writing a function that may complete successfully (i.e., needs to return nil), but could get failures in the deferred code. As of now, I just log errors in the defer-path and hope that that case never occurs in the production. 
Can you factor out common functionality from the above snippets to make the code less repetitive? If not, then the "repetition" might just be an optical illusion.
This sentence doesn't make sense to me: &gt; Because an error in Go must either be 1) handled/ignored right then and there or 2) returned to the caller, you can track the path of the error. It might be easier to track when the function returns early, but it's nigh impossible to track the call stack of an error since it doesn't have one. I'm finding that really challenging to deal with; a minor database flub spits out something way at the top of my request handling and unraveling how it got there is difficult or impossible. I'm also not finding that the forced error handling is resulting in "rock solid, stable software." Since the error interface is so naive, and most errors are complex, I'm often just passing them up the chain or deferring "proper" processing for later. Sure, a go function documents that it returns errors in ways that python doesn't - but knowing that a function can return an error is nearly useless if there's no documentation on what kind(s) of error conditions result, and what the caller should do to resolve the issue. I love go, but it's error handling philosophy is not why.
Swift has been released as Open Source. It can now run on Linux.
&gt; It might be easier to track when the function returns early, but it's nigh impossible to track the call stack of an error since it doesn't have one. I had the same problem until I painstakingly converted all my errors into [these](https://github.com/go-errors/errors). Now I get stack traces in logs and panics! 
&gt; I would have designed a message bus for low latency distributed system using GO Isn't that what NATS and NSQ are already doing? Especially NATS aims for "throughput over everything" afaict.
FYI: The `!` in Ruby has no semantics language-wise, it's just part of the method name. AFAIR, Rails peps have decided that in their project that would mean a method throws, but in general it can mean anything.
We need a service aware, fault tolerant , brokerless message bus plus ususal stuff. We have a peculiar requirement because of the way platform is divided into zones with each having its own restrictions on services. Difficult to do.with generic message buses. Unless I.misunderstood their descriptions. Please correct me.
I wouldn't call go's error handling "elegant", but I agree it's better than exceptions (checked or unchecked) in pretty much every way. I think error handling simply isn't a solved problem yet. Go just comes pretty close (though, arguably, a `Result&lt;&gt;` generic type like in rust comes even closer).
Yep. Here's an example in mine. I wrote a program that takes (mostly math) expressions written in Go, compiles them, and runs them in a tiny VM. The program features compile-time type checking. If the type of the expression is not known or uninferrable at compile time, it will return with an error. However, this error is ignorable, because at runtime, the system will still type check (same code, same error). Of course at runtime if you have a type error, then you're SOL. It means you wrote bad expressions
Counter points: "With that said, package main is often larger than other packages. Complex commands contain a lot of code that is of little use outside the context of the executable, and often it's simpler to just keep it all in the one place. For instance, the go tool is more than 12000 lines spread across 34 files." "On the other hand, it is also easy to go overboard in splitting your code into small packages, in which case you will likely becomes bogged down in interface design, rather than just getting the job done." Via: https://blog.golang.org/organizing-go-code Packages like "api", etc. are much in the same way useless out of the context of the executable/app. They serve as an *organisational* approach to structuring your application, as opposed to packaging self-contained functionality for use by clients as is suggested in the linked article. As for "common", it again depends on re-use. With development scope and growth, smaller, more-focused packages will emerge. For some things, usually it takes 2-3 iterations of refactoring to come up with a suitable, frozen, interface for some operations that you do. When that happens, you have justified cause to create a new package - but it's still up to you if you actually *need* to.
Jeez, is it a sect of some sort?
Can an `interface` help factor out the common behaviours of `echoResp` and `loginResp` so the code you give twice can exist in a common subroutine called from both?
Hey, thanks for the upx tip. My 1.6 binary went from 41.8 to 6 MB (rewrite of cairo-dock-core with web, dbus, gtk, gupnp...) Now I'm feeling I'm not dealing with something java-like... File size Ratio Format Name -------------------- ------ ----------- ----------- 41835056 -&gt; 6026580 14.41% linux/ElfAMD cdc time (upx --ultra-brute): 5m30s 
Still wondering why one professional who doesn't particularly like a language would hang around a sub Reddit dedicated to it and put energy hating it.
&gt; It was a huge mistake to have net/http call recover. If an error warrants a panic, your binary should just crash (and fail loudly, instead of silently). ...says the guy who isn't on call.
You should also consider rust and it's awesome try! macro. 
Sounds like Rust is the language for you.
You'd need to use such a macro this way to get the exact same functionality: x := try!(f()) { return nil, err } ... which isn't too much shorter than the original Go code. 
Except it is
Also this one: https://www.gitbook.com/book/codegangsta/building-web-apps-with-go/details
Coming from the javascript world i am kinda excited. Just started learning go and this seems nice and clean. I always struggeled writing fast and simple a clean API in nodejs. All frameworks kinda looked blown up. So i will definitely look into your project and try to learn some things and maybe even use it in the future!
Yes, I know it's not the best. I figured as I learn and build out the API I'll find my ways to improve and think about handling certain problems such as any application globals. Right now, those 2 are the only ones and it made sense given how small it is at the moment. As the code grows (and my team, it's just me at the moment) and we learn it will get refactored and improved upon. 
You have an example app. Any chance you can post the example code too? 
That is what I thought, but an important aspect for me is to understand the underlying libraries/tools I use, and the sheer amount of code that is generated in the `cellar` example somewhat overwhelmed me a bit. And doing a lot of stuff in other famous web frameworks such as Symfony2 and RoR I know where this wish to standardize and abstract boilerplate away can lead. If I look at the generated code, most of it is clear to me. I see that one part is basically generating the datastructures, another is generating the function that ensure the validity of those datastructures and the other part is for assembling the middleware stack.
I've found that https://github.com/pkg/errors has really helped with * Keeping track of the call stack from the source of error * Keeping stack trace between goroutine boundaries * Adding context to the error as you go up the stack (with `errors.Wrap`) * Keeping the original error intact so it can be inspected where appropriate It's a drop in replacement for both `errors.New` and `fmt.Errorf` and you can apply it the majority of your codebase with a few simple `gofmt` commands. It's a really great example of both the power behind using a simple interface for errors is, as well as how a lot of the power in Go is in the tooling.
I tried that but couldn't get it to work. The anonymous outer struct idea I mention in another response is the closest I can come so far. I'll update with the fresh code hopefully sometime this afternoon. Thank you!
Use CloudFront CDN with SSL to an ELB -HTTP-&gt; Go, put your static files on S3 You get: * DDOS / malformed request protection &amp; WAF * Caching of static responses and metrics * Automatic updates by Amazon for SSL security patches * Auto-scaling support from the ELB if you need it later (and you bake AMI's etc) * Split traffic between API and content based on path * Don't pay for application servers for static content, upload / update separately * Better global response times and costs for bandwidth
Using `!` in a method name to show that it mutates something a Clojure convention.
Thanks, I'll look into that!
&gt; ...says the guy who isn't on call. Uhm except that I am? For a service with hundreds of millions of users. Don't make assumptions and don't talk down to me.
I'd think you could implement a fail middleware if crashing is a better fit for your business needs. And nobody's suggesting _silently_ failing. The http stack doesn't eat those exceptions, you still get the error trace.
Actually, I want my service to *not* go down in the face of crashing binaries. I was at the receiving end of such an outage. It wasn't fun. But it uncovered a serious problem, *that our service didn't survive the crashlooping*. You need measures in place to protect against such an outage and those measures can't come from within the binary, because you can *never* protect against bugs doing that (it's most often not even code you control that leads to it). So you better make sure that you protect against QoD, against cascading failures and you better make sure that you can get back up when large parts of your tasks are dying simultaneously. If you believe that recover'ing in the http stack would provide any safety, you are just tragically mistaken and will be taken by complete surprise when your stuff *does* eventually start crashlooping. There's also the simple, well-known fact, that most distributed systems are well protected against fail-stop failure modes, but *not at all* against byzantine failures. And yes, I *much* prefer my service going down, to it silently corrupting our user's data due to an bug that was not discovered because it only threw a 500. My opinion is well thought through. Failing tasks are discovered, log entries are not.
Don't use SSL on the Go app, only Nginx. Edit: I'm getting downvoted by people that probably don't have experience doing those scenarios. Why you shoudn't run SSL on a Go server: - SSL is not fully suported by Go - Recompiling your app to get the last features / securites fixes - No hot reload to get the new certs. - Can't change the settings ( like #2 ) - It's a pain for managment/ deployment 
Not sure I buy *everything* the author is putting out, but it is an interesting perspective and a refreshing break from typical blog posts on go error-handling.
I really like how the go tooling does its help and usage. I decided I wanted to use it for another project I was working on. So I took the liberty of pulling it out into its own library. One of the biggest changes I made is allowing args to exist before the flags.
For now, only the core language is supported by I guess this will change.
You could do this with a regular function if Go supported parametric polymorphism.
Yeah, that's one of the reasons I'm still not sure how to go with this. If the server is on Nginx running in 443 (HTTPS) and the Backend on 8080, even if it's the same machine, isn't the JS on the Frontend calling the Backend from the client ? Meaning the data should be encrypted in both cases, but the backend having priority ? Nginx is basically just serving static files.
before cutesy naming and descriptions please write documentation on your package and exported methods.
It was a Ruby convention back in, like, 2001 (that's the date on my *Programming Ruby* book). Methods that end with `!` mutate the object; methods that end with `?` return a boolean.
&gt; Nginx is basically just serving static files. SSL prevents tampering as well as providing security.
Hmm, I wonder given all the effort into appends efficiency how much is saved by this approach. I'm sure it was measured and I respect the Go authors.. but this seems like the algorithm is a bit more complicated than needed?
I spent some time on this, and if there was a way to map strings to struct types, I could do it. Ah well. It was worth a try! Thanks for the suggestion!
This was the best I could do. respMap is the tricky bit, and I don't think it can be done. :-( // Call makes the API call defined by the supplied request. // RespType is an interface covering all valid response types. // respMap is a map between methods and response types. func (c *Client) Call(r Request) (RespType, error) { method := r["method"] respType = respMap[method] var m struct { RSP respType `json:"rsp"` } if err := c.doReqUrl(c.url(c.urlBase(), r), &amp;m); err != nil { return respType{}, err } return m.RSP, m.RSP.IsOK() } // r := Request{"method": "rtm.test.echo", "ping": p} // echoResp, err := c.Call(r) // if err != nil { // return err // }
&gt; So you don't actually want your service to crash, you just want to have some other container managing the Go code and catching the crash, rather than having Go's http catch it. That is not at all what I said. &gt; Which is fine, but one of the beauties of Go is that you don't need a container and a separate web application server to get started. People learn bad behavior from that. For example, they learn that recovering is not a completely bad thing to do. Recovering is wrong *no matter* what the environment you're running in is, because it means you are ignoring an error, that could do lord knows what. A panic means, your program is broken and not to be trusted and recovering means sticking your fingers in your ears and pretending that in truth everything is fine. Putting your software in containers, putting them behind a loadbalancer, canarying, isolating users, blacklisting query of deaths, load shedding and being able to recover rapidly - all of these are just my answer to your claim that you don't ever want your binary to crash because then your service would be down. A properly run, productionized service (which, pretty much by definition, is the only sane version of a service that you care about) *must* be able to survive crashes, because *you can't prevent them*, go or not go. Above outage was a Java binary segfaulting. If you think just because go is "memory safe" (it isn't) it can't catastrophically crash or corrupt data in an unrecoverable way, you are simply wrong. And it is *much* better, in pretty much *any* scenario, to have your binary crash, than leave it running in a known to be broken state. Even *if* that means your service goes down, because downtime is predictable, it's noticeable and at least you know it won't wreak havoc by giving incorrect answers.
&gt; Go could keep all of the advantages of its current model, and remove all drawbacks, if its type system could accommodate a Maybe type. This is very arguable. Such a type system would need generics and it has been argued very often, that they would take a lot of simplicity from go (and I tend to agree) thus taking away most of the advantages of its current model. &gt; Everyone else in the past 30 years of computer programming knows it's the wrong solution for error handling. And as Anatole France said: "If fifty million people say a foolish thing, it is still a foolish thing". I am not arguing that go's error handling is perfect, on the contrary. But saying that we can't revisit ideas or throw out things that are assumed to be correct just isn't a way to innovate either.
&gt; that they would take a lot of simplicity from go A lack of generics does not make Go simple. It might make the compiler simple, but it makes the language so inflexible that people end up doing complicated things to solve problems (like using interface{} and reflection). Simplicity is being able to write one algorithm that you can use across a multitude of data types. Simplicity is being able to directly pass the return value from one function as an argument to another function. Nothing is more natural and essential as `f(g(x))` but in Go this is not possible with functions that return multiple values. Note that Go already has generic operations: `range` works the same on `map[int]string` as it does with `map[float32]complex128` and even `[]int32`. But somehow being able to write our own operations removes simplicity from the language? I don't follow. For what it's worth, `range` also does something completely different for a channel, which is confusing. Just like running `select` on a channel and then using `default` to signal "there's nothing on any channel". What's simple about that? Nothing. It's terse, not simple. Instead of making `range` just a function, which is the most simple and basic component in programming, it's a special keyword that has different behaviour on different types. There's nothing simple about reusing a keyword for multiple behaviours. I think a lot of people confuse "limited" with "simple".
&gt; but it makes the language so inflexible that people end up doing complicated things to solve problems (like using interface{} and reflection). &gt; Simplicity is being able to write one algorithm that you can use across a multitude of data types. Programmers debasing themselves by using `interface{}` is just more proof that so many are willing to pay $100 to get $1 as long as they feel clever while they're at it. You want to "write one algorithm that you can use across [types]"? [Go ahead and do it](http://clipperhouse.github.io/gen/#) without sacrificing runtime performance for all the reflection calls. &gt; Simplicity is being able to directly pass the return value from one function as an argument to another function. Nothing is more natural and essential as f(g(x)) but in Go this is not possible with functions that return multiple values. If you need to compose functions, [design around that](https://golang.org/pkg/bufio/#Scanner) by maintaining an internal error state. Just because you've seen a function signature: `func SomeErrorFunc() (val Type, err error)` doesn't mean it's the **one and only** manner of error propagation. 
There's a pretty common issue that I ran when first using vim-go: dot complete on dependencies only works once you've "go install"ed them. It's a limitation of one of the tools it calls. hope that helps!
License? If you copied it from the Go tree you must retain the copyright per the Go license. And you should license any code you wrote on top of it.
I'm pointing out the alternatives that already exist to solve the common cases where generics are useful. &gt; Because there is nothing simple about in-comment annotations read by an external program which generates more code for you. This is considerably more complex than actually having generics. You're correct, there's nothing simple about templates, annotations, and an external program to generate code for you. But once you call that external program a compiler, it's suddenly just magic and unicorn dust and all the complexities of template programming go away? Other than which external program is generating the code, how are these so different? // +gen linkedlist type MyType struct { // elements } func main() { list := NewMyTypeList() list.PushFront(NewMyType()) } type MyType struct { // elements } func main() { list := new(List&lt;MyType&gt;) list.PushFront(NewMyType()) } &gt; There is also nothing simple about using mutable state hidden within an instantiated object compared to real function composition. How does this "real function composition" `f(g(x))` handle errors in `g`? Invisible control flow via exceptions skipping the call to `f` and returning mid-statement? Maintain the error using mutable state within an instantiated sum or monad type? There's nothing simple about any of these options. It's a different trade-off than [pet language here], but that doesn't make it more complex, just different.
https://github.com/golang/go/wiki/LearnServerProgramming This has been pretty useful for me, It's a collection of a lot of good material.
for now there are only 2 functions for ussage which I documented in the README.md file. what do you mean by documentation? in source documdntation for golang? I though it was an over kill for such a small librery but I can definatlly add it. thank..
nice, actually I have not... looked for okmething like this to use in my project a while, eventually ended up creating one for my own ussage...and shared it... 
I'd be more interested in your reasons for not liking Go. There's no way to guarantee that anyone will like the language, but I'm always intrigued by the reasons people dislike it. 
This argument has been had before and I have no desire to repeat it :)
Except if [you want to keep your ads revenue](https://xenforo.com/community/threads/adsense-ctr-cut-in-half-after-switching-to-ssl.83732/).
You cannot generate numbers in a range and still be Gaussian. You can specify an certainty that a value falls in a range, but cannot guarantee it. This is just a math thing, but really doesn't matter that much to you because the numbers we generate are close. You can approximate Gaussian by averaging a few of these linearly distributed random numbers from math/rand. [Here](https://play.golang.org/p/n93Sc-u7Mq) is some example code that I think will do what you are looking for. [Here](https://docs.google.com/spreadsheets/d/1CmSrNbiU8O_7wy4hZtPyc-lhxNKzILW4Cug4E57Ca44/edit?usp=sharing) is a quick sample of what the example code I posted generates.
Ah yes, ad bidding! My experience has been that golang is not the bottleneck on this and you can scale easily to that size with the appropriate architecture. A big factor in whether those numbers can be hit include processor power as well as available bandwidth. How many servers are you using for this? What is your current architecture and components? More information shall help answer your question.
A similar issue could cause sort.Sort to crash if Less() returned different results for the same pair. This has been fixed.
What is the reason for putting variables into a route anyway? Because it looks more RESTish? Result of this trend is that frontend developers construct request strings by hand instead of leaving this job for some specialized library which can take care of all escaping etc.
Go forces simplicity while Java encourages complexity. This applies to everything in their respective ecosystems; editors, tooling, libraries, language. To write Go all you need is a text editor and the Go compiler and you will be productive. With Java, this is definitely not the case.
.NET Core is exciting, but still pretty immature. Tread lightly, friend!
It depends, flatbuffers can be very fast if used correctly. For example: when u know the exact size and amount of your data. Those are very specific cases and when this is not the case the performance compared to gRPC with protobuf is nearly the same
Thanks, very helpful.
I'd say Java encourages flexibility rather than complexity. With Java, I always felt compelled to make single-responsibility classes and strategies, pulling code apart way more than will ever be warranted for the task at hand, but...maybe someday we'll resize these components! (and never end up doing so) With Go, it just feels like more trouble than it's worth. That said, sometimes the flexibility is helpful, and Go will fight you on it. Ask anyone that's tried making a collections library/package. Java's tooling is much better. Go is just starting to embrace vendoring, and while I haven't tried the Delve debugger yet, I'd wager debugging on Java is still much easier and more widely supported. I've never been much of a debugger, so this doesn't bother me. I prefer Go, personally, but miss some aspects of Java. 
There's also `howdoi` made in python. But I'd prefer a Go tool. I hate pip. 
Hi there, I am from gRPC team and saw this thread.. We have been working on making it easy to answer these type of questions by having gRPC performance in a dashboard running continuously. You can see the performance numbers at: 1. [Multi-Language performance dashboard](http://goo.gl/gSfNeX) 2. [C++ Performance dashboard](http://goo.gl/8an9TJ) If you need to run these benchmarks in your environment, the source code is present in grpc, grpc-go, grpc-java github repositories. If you see drastically different numbers in your environment, please let us know through github issues. 
I have a mixed feeling when it comes to Go web frameworks. On the one hand, I know that they help with the boiler plate. Need a web app with a template dir? The stdlib does not have the boiler plate, you need to write a function or two, it's not difficult, but you'll need to repeat that simple code in every app. On the other hand, I cannot ignore the fact that web frameworks are not welcome in Go. So the more I invest in using one, the more I feel I'm on the wrong land. The community is clearly divided on this topic, there does not seem to be anything to address this in a foreseeable future.
People always compare the languages. Nr 1 the tooling support for java removes any language burdens. Nr 2 The amount of libraries available in the maven/gradle echo system is massive and the quality is excellent since there are from open source companies that makes money supporting them etc. Nr 3 Running on a virtual machine provides you with excellent support for runtime debugging, troubleshooting and diagnostics that you just can't get from go in the same way. The tooling here is excellent. Intellij Idea is free.. Eclipse is free.. nothing that Go has comes even near in terms of features. Even if they have plugins for those platforms the support is not even near as good as for java. The database driver support is also excellent and usually provided by the database projects themselves. Look in to spring boot! It's not your grandpa's java anymore. It's a nobrainer. 
https://github.com/astaxie/build-web-application-with-golang https://github.com/thewhitetulip/web-dev-golang-anti-textbook Cheers
Ah, makes sense.
Yeah it is a year or so out of being production ready, but it is really interesting especially with service fabric. 
Go is still behind (probably) in the area of GC. Go's current GC is roughly equivalent to Java's Concurrent Mark and Sweep. Java, on the other hand, comes pre packaged with several GCs for whatever floats your boat. In particular, G1 represents an impressive feat of engineering (and is a great choice for webapp like things). On the flip side, Java's parallel collector is great for batch jobs where long pauses don't matter. Beyond that, Java comes with a bunch of knobs to turn to tune GC to your specific needs. Go is much more of a "use what we give you" sort of a language. While not bad, it does lack some flexibility. That being said, even with the worst GC settings, I've never seen Java really truly suffer a huge portion of CPU dedicated to needless GC. So Go's approach may be better suited to a larger range of developers. The languages are pretty comparable at the end of the day. I think the biggest thing java has going for it is the gigantic ecosystem that already exists due to its age and popularity. That isn't to say Go doesn't have nice stuff. It does. Just that Java reigns supreme when it comes to ecosystem simply due to its age.
SublimeGo is best
Just want to cast another vote for Go. As someone with 4+ years of Java experience, and ~8 months of Go, I absolutely love Go for many of the reasons I hate Java. It's more opinionated, and sometimes the "right" way to do something isn't immediately obvious... but reading through the code is so much simpler. Less setup. Faster compiling. More IDE options. The list goes on.
What type of web development are you looking to do? The reasons for picking Go vs NodeJS could help guide that choice.
Very little beyond standard library stuff. Often gorilla mux but not much else. 
fwiw text editors (e.g. Emacs) can do this is as well. gorename integration for refactoring support, goimports integration for automatic dependency lookup, etc.
you should also ask this question in r/java as well.
Out of personal experience, it depends on what you would need to do. I am currently working on a distributed platform which started out with purely Go services. Development wise, this is an absolute pleasure to work with. We spent several weeks/months trying to optimise one of our services - an image processing/compositing service - without any luck (we even started doing cgo bindings with cairo etc.). We then did a test in Java with the Java 2D library and after 2 days this gave us far better results so it made sense to switch it over. Development wise, none of our developers want to touch it. The point to this is as other people have mentioned before. Java will have things that it's better at than Go and visa versa. Which ones do you need? 
You should for yourself answer if you need a bus (which gRPC is not) or a point-to-point RPC solution (which gRPC is). gRPC builds on top of HTTP/2 which has some advantages and drawbacks. If you need it's streaming features it will be hard to find something comparable. If you have simple request-response communication with small payloads it carries quite some overhead that you probably don't need. If your payload always fits into MTUs then something UDP based could be attractive. And if you need guaranteed ordering between requests then neither gRPC nor a simple UDP based solution would work for you. Discussion latencies or throughput will be worthless without knowing the complete software, hardware and networking architecture. So you need to benchmark this on your environment.
I agree with all of this, great set of posts man. Encrypt at the edge of your network, it can actually be more secure because their is less complexity. A lot of the things you resort to with complete end of end encryption increases the attack surface greatly, SNI, managing certificates and lines of trust.. client cert Auth ends up in the mix. It adds up fast. Clarification from father in thread: I want you to look at the last N big security compromises.. the ones that made headlines outside the IT Sector and find summaries from reputable source. Then feel free to dig deeper on the subject matter of the compromise. You will notice a theme and what I want you to play close attention to is entry point. Hint: it wasn't a lack of TLS. So I am going to let you in on a rude awakening.. Security is not encryption. Encryption does not provide security, it simply provides data protection from being observed by unintended parties. I can't let this turn into walls of text as fun a topic as it is.. so to simplify this the best I can do right now would be.. Security is everything. Am I talking in silly rhetorics? No. It's literally everything. It's physical. It's software. It's operations. It's social. It's absolutely massive. What "this" collective set of proximities form is.. your surface area. The larger the surface area the more opportunity for potential attack vectors. Requiring encryption in places that are at very low risk greatly incrincreases attack surface for very little reward. You need to properly manage your risk vs reward because you are against massive odds. This means from the software side of things you need to justify the risk of every inch of surface. Automation pulls in more libraries. More dependencies. More things to patch. More surface. The reward may be well worth the risk, you better measure it first. Automation and a proper CI / CD pipeline is paramount to moving quickly and preventing human error. I'm not saying otherwise. But it does not mitigate the risk associated to systems it may control. It also introduces complexities with an entire separate beast of IT Security which is compliance. Depending on which markets you operate in, counties, etc. You have to prove your security practices are within compliance of external entities. You can't tell them my app is secure I have automation bro. You need to prove every touch point in your infrastructure. You need different types of security scans for different types of infrastructure. The more complicated a components implemention within your system the more cumbersome it becomes to prove it under audit compliance. You need different types of scans, you may move that service into a higher tier of audit requirements, which costs time and money. Time better spent on anything else. This goes on and on with compliance. Automation doesn't always help here. A pain point for the newer devops movement at smaller companies for example is Sarbanes Oxley Act which most larger companies will face (if public traded for example). It's a complicated topic and I'm not going to deep dive it in a randomly deep nested comment on Reddit. But within one of its provisions is the assessment of internal control. It's a beast and interpretation is its own field nearly but the take away I want you to have is .. it's not that simple man. Security is not encrypt the things. That is ignorant. You do not encrypt things because "encryption is good, it's so easy to do". No. You do not. For the reasons I listed and a million more. Complexity must be justified in general. For any system. Get the essentials right. Design a decoupled set of systems. Encrypt where you need to. It's usually just at the edge of your network for your 99% run of the mill SaaS. Protect the users data from observers outside your network. Secure your networks edge and focus on your application security as it faces publicly. It's where most vulnerabilities stem from. Get things that matter right. Establish a strengthened set of access controls inside your network at the host level. Automation is great here for managing these sort of rules. Do the things that help mitigate as much risk as possible for the best reward. If you run out of those things, encrypt everything purposelessly if you really want to. Log data.. must encrypt. Request for your companies public media.. better encrypt it from your media server to your cache tier, just so it can be terminated before being requested from your web servers to be rrencoded again over TLS to the end user. Hey, least we prevented someone who was on our internal network from changing some pixels. Who cares if we just pulled in a shit ton of surface area through client libraries, servers, lines of trust, pki, etc. After all you know best. This is about all the time I want to waste. You are right though, encrypt everything.
I have 10+ years of experience with Java. I'm also on my 3rd Golang project. Two of those 3 projects are rewrites from other languages (the first one from Python, and the current one from Java). I still like Java, but the problem with Java is that even if you plan to keep it simple -- it's difficult. Because people who solved problems in Java solved them having in mind the most complex use cases they could think of. Consider for example spring dependency injection vs facebook inject (cca 500-600 lines of code). Of course, Spring contains thousands of other features, but sometimes you need only dependency injection! You can use guice (which is also a beast if you compare it to inject). But at the end you will always end at least with a few of Java's overengineered solutions for something (orms, application containers, dependency injection, AOPs, ...). There is one thing where Java is simpler than Golang (at least for me): it's reflection. More reasons for go: fast startup time, low memory usage, ease of deployment (no need for application containers) and faster compile times. Today, I'd go with Java *only* if I need a nontrivial library which isn't ported/written in Go yet (and I don't have the time to research&amp;write it myself). 
You won't get an unbiased answer here I'm afraid. 
Not so much a bug as a fundamental feature of the router - it does not prioritize routes and is very strict about node combinations in its radix tree. With microservices one would typically have a proper URI structure that dose not have a mix of parameter and static variations at the same URI segment. An Gin will work fine. Supporting legacy URIs could be problematic. If you are looking for a flexible router then `goji`, `echo` frameworks have it and `chi` is an interesting one I am watching out for. I am playing with `lars` currently, which is like `gin` but just a router and with a twist (you can provide your own strongly typed context structure). 
Go and Java are both fine languages to write a web service in. They both have pros and cons. But take a step back and consider which way the wind is blowing: Go is an up-and-coming language. It's not going away any time soon, only getting stronger. Each release brings major improvements for people doing massive websites. (Most sites aren't pushing the boundaries, so they are already "good enough" in Go.) There are programmers moving from every major language to Go. It's considered cutting-edge, associated with Cloud deployments, and will attract forward-looking programmers. On the other hand, we have probably passed Peak Java. Sure, the Java ecosystem (Scala, etc) will keep things going for a while. But most Java projects are now considered "legacy". At best, it's an "enterprise" language (from what I can tell, that's a Latin word meaning "slow".) You may be able to find more Java than Go programmers, but many of will only be using Java because "that's what they know". Many aren't interested enough in programming to level up their skills with new languages.
No problem, I was something I had to figure out for a project recently as well. 
This last part is a good tip. It took me a very long time to figure out to search for golang instead of Go. 
Amen. I've also have lots of little tools that integrate into emacs that make it more powerful than any other IDE I've ever used. It takes a tiny bit more knowledge than knowing how to click a button, however.
I'm not sure what implication you are trying to make, Java costs more to develop? More to run?
&gt;Input could be Unix-style path, CSV-formatted data, hostname etc. The [first](https://golang.org/pkg/path/) [two](https://golang.org/pkg/encoding/csv/) examples have dedicated packages that will deal with edge cases; using `strings` functions for them is not ideal.
Why does java cost more than golang? 
as a newbie, I don't like ide much, the reason is because whenever you reach some sort of problem and the documentation is not there than you are screwed. But if you know how to build stuff from text editor, its much easier to figure out what went wrong. However I think this is because I havn't work on enormous project yet.
The difficulty in securing string operations (or, more generally, array operations) is one reason why I strongly prefer to use lexer and parser generators wherever possible. `lex` and `yacc` (and there equivalents in other languages) are guaranteed to never introduce buffer overflows (modulo bugs).
Thanks, much appreciated.
It's important to note that a lot of frameworks and libraries are offering Typescript definitions or are full on making Typescript a first-party citizen, moreso than I saw with things like CoffeeScript. Take a look, for example, at Angular2, which strongly recommends Typescript. I personally love it, and have moved a few of my ES5 NodeJS apps over to TS.
The plugin for Go for IntelliJ is absolutely fantastic, so I have to disagree with you there. It's developed internally and supported by JetBrains now, and I now see at least monthly releases with major improvements. Additionally, I can't agree with the argument that more features is better. Go simply doesn't have a need for more features because it focuses on simplicity far more than java does, and in my opinion, this is a good thing. I'm curious about what you mean by "the tooling support for java removing language burdens." Go does this by default and doesn't generally have a need for a complex build system because go applications are a single static binary that you can compile on any platform for any other platform. Additionally, CGO, if you are more than a beginning C programmer, is extremely easy to use if you have platform specific components that you need to implement. It's difficult to argue with runtime debugging support, but [delve](https://github.com/derekparker/delve) has been getting much better and is already very useful. On top of that, I've found that I don't have nearly as large a need to use a debugger with go in comparison to other languages because the same classes of problems you generally use a debugger for just don't come up as often. One of my favorite things about the language is that if your code compiles, unless you have a nil pointer dereference, it will generally do what you expect it to do. I've also worked extensively with every database driver in go, and I wrote a code generator that generates go structs and functions for the big four relational db's(unfortunately proprietary) - this was actually very easy in the long run, because go includes the sql interface as part of the standard library. That means that people extending it or just implementing their own code only need to follow that interface, and the only things that differ are sql syntax and a few of the supported features. That being said, I'll admit that it's undeniable that jdbc has a very long and proven history. As my last point, one of the best parts of go is how complete the standard library is. As far as I know, it is the only net package in any programming language that is competitive to other webservers. It's not the fastest, but it holds its' own in every benchmark I've seen. Go as a language has also picked up massive support from the open source community and many very large companies. So it's obvious we have different opinions, but I really do hope you take a look at the language and play around with it if you haven't. You might really like it (like I did). Also, I'd love to hear any reasons you disagree with anything I've said here. I don't want to pretend I don't have a bias. Edit: also, the compatibility promise is amazing. I've never had to refactor anything after a new release.
Sort of both. Java engineers *are* expensive. They're generally the best paid engineers. But moreso Java applications, and particularly the JVM, doesn't/don't scale well [1](http://www.theserverside.com/feature/Why-Java-Applications-Fail-to-Scale-Linearly) [2](http://www.javaworld.com/article/2078731/java-platform/jvm-performance-optimization--part-5--is-java-scalability-an-oxymoron-.html). Improvements are logarithmic instead of linear. Meaning throwing a lot more money at resources to get smaller and smaller improvements, and more admins to maintain great resources.
I was mildly impressed by the screenshot so I went and `go get`'d it. Some suggestions: - Don't use panic for everything - Use flag or maybe urfave/cli so people aren't lost when they run the binary - It doesn't work for me on Ubuntu/xfce4-terminal: . $ cribbnotes_cui ~/Documents/crib panic: (PopulateToc) error on SetCursor on toc view: invalid point goroutine 1 [running]: panic(0x581760, 0xc820012830) /usr/local/go/src/runtime/panic.go:481 +0x3e6 main.main() /home/alex/devel/go/src/github.com/jameycribbs/cribbnotes_cui/cribbnotes_cui.go:70 +0x906 Edit: so with that last panic, it seems that if I am in tmux + split pane, it craps itself. Works fine otherwise. However gocui examples work fine in the same environment, so I think you are misusing gocui somewhere. But, there are tonnes of other panics. Such as scrolling down too far in vim mode (j j j j j) past the end of the document = panic. Again, avoid panic for ordinary errors, and prevent regular panics by doing things like bounds checks.
You can still go dotnet cross platform without dotnet core
It's easy to learn, it won't take you too much time, and, judging by its popularity and the amount of useful programs that use Go, it's very useful. Also, there are lots and lots of resources from where you could learn, and everything is well documented. Just go to https://tour.golang.org
No offense, but "building microservices with &lt;any&gt; framework" - is oxymoron. Gin is good framework for building web applications, but from micro services POV is overengineered.
Exactly! This is exactly my reason for thinking Go will be a waste of time for me. C/C++ and assembly is very useful to me because that's what is mostly used for microcontrollers, embedded systems, etc. But recently I've been working more and more with embedded linux systems instead of programming without an operating system, and so Python and PHP have been useful. Would Go be useful in this instance?
Yea, I'm a Go fan, but Java has the larger ecosystem. Right tool for the job, and many tools work interchangeably.
After 10 years working with Java and the last two years working with go I can say I've found these Cons in go compared to Java: * Lack of generics (or templates as you would call the in c++). * No stable debugger (delve is the best one I've used) * Official testing framework (go test) won't show results until all Tests are finished. * Cannot make an import cycle. If A imports B and B imports C, C cannot import A. Will cause a compile error. Obviously B cannot import A as well. * You'll find yourself reading the actual code to figure out how to use a library, especially non standard libs but some times standard libs as well. (Documentation is sometimes harsh). * Maven has been replaced with go get and now I've got no idea how was I able to wait such long times for dependencies to download. But the thing is that I rarely need generics, and almost always you can "workaround" the generic with an interface; if you can't, probably you need to copy some code twice. not very cool for a dependency injector but fair enough for the typical web application. Even though there is no good debugger for macosx, delve in Linux will let you do some debugging and inspecting. In macosx I use delve whenever I convince myself that print debugging isn't enough. Fact: if you write tests, with go convey specially, you won't need much debugging. but if you aren't a friend of testing your software, you will enter a world of pain with debuggers in go. Here is something I miss about Java, being able to see test results as they run. It might seem stupid...and it is, because I'm running out of arguments. :/ Import cycles? Just don't do it, it's not something you need. In Java you import classes, in go you import packages and all its public content. I've never had such a problem with Java, so I've never considered as a problem. It happened to me once in go, but it was a clear bad design and had no trouble changing it. From time to time I find myself reading go code to figure out how a library works, but I don't mind at all. First, go code is really easy to read and most code is in the same file, in Java I would have to visit at least five classes (hence files) to understand the logic. Finally, sometimes I read some standard libraries just to see how the developers achieved some "trick", and that has been a really good experience for me. To be fair I will make the following statement: If stackoverflow would vanish from this universe, I wouldn't want to be working in a Java project. Maven is long gone and has been replaced by go get and go build. There was a time when I couldn't live without maven and now I'm thinking how did I survived maven. Well, these are my highly opinionated cons list. I would only consider Java if some client wants an application that requires, for instance, generating PDF files. You'll find a library to generate PDFs in Java but is highly unlikely that you'll find a mature library for PDFs in go. It's an example that I'm making up, but if your doing micro services , that would probably a service itself. If I needed top notch performance I would go for Java too; if you're into tweaking the GC that's something you cannot do in go. Choose whatever you like best, at the end of the day you'll be working with this project, not me :) 
Thanks for responding. Do you think Go is useful for embedded linux programming? I would never use Go, or any garbage-collected language, for real-time applications. However, for some of the non real-time stuff that people still like to run fast, Go is becoming more popular. The efficiency of your algorithm matters more than the language you use, however, it would be nice to save CPU cycles whenever you can, without having to write things in C.
Go can be used in quite some places where Python or PHP is used. Learning Go is not too hard, and knowing more languages can't hurt.
go is great in linux systems environments because it builds to a single portable binary file. this gives it the same portability advantages of python but with the safety and performance of a compiled language. compared to something like java, it's very nice not to install and configure a JVM or worry about jdk version compatibility of different software components. A go binary is just a binary like something you would produce from c or c++.
I've already been down voted and it's been explained else where. If you want to reduce my comment to "encryption causes security issues" then go for it. I'm not feeding trolls on here anymore. If you really want to learn I'll take the time to explain but add ask a more specific queation and read the other reply I said was a good post first.
If it useful for YOU, use it, don't give a sh*t about what others say. Remember practicality beats purity every.single.time.
Honestly not trolling, if like to know more about this. Afaik, TLS can be a pain the ads to update certificates and you have to figure out some way to consistently deploy it and make sure it's enforced, but it's the only way to ensure data, like login credentials, isn't transmitted in the clear. If there's info contradicting this or edge cases I'm not thinking about I'd like to know about it. 
I'm not an EE, but I've had good success running cross-platform Go code on embedded linux ARM boxes in an IoT application. It's much more performant and resource-friendly than the python code running next to it on the same device. So, I'd say yes Go is worth it. Especially over python and PHP for embedded applications. 
&gt; it can actually be more secure because their is less complexity And it is less secure because there is less encryption. If you want really good security, encrypt everything, and be careful and methodical about it. Works great when you have 100% automated deployment and you know what you're doing. The idea that it "can be" more secure because lower complexity is non-sensical and reductionist. Less is better than more -- except when it isn't.
I'm recently developing some stuff on embedded ARM Linux with as little as 64mb of RAM. I can say that Go is far superior than C/C++ in terms of developer experience. The most obvious win is the ability to *effortlessly* cross compile my code, *plus* all its dependencies for all supported target, with just one installation of toolchain. It's really painful when it comes to cross-compile the web of dependent 3rd-party libraries with their own poorly written autoconf scripts or some arbitrary brand-new and shiny build systems. In traditional Linux embedded development, it's almost impossible to do it in a less suffering way without the help of something like buildroot or yocto. 
Go is great for hard are systems in that it's asynchronous go routines and channel architecture make dealing with the asynchronous reality of the physical world much easier to handle.
You're going to need A LOT more RAM and CPU and even so, you'll not be able to handle as many simultaneous connections and your response times will be substantially higher too. But yes, stateless apps scale out, so your statement is largely correct.
sold
Dude, I'm talking about the "one machine" scenario.
The idea is that the std lib has everything you need to make a web service, so using a framework probably means that you just aren't using the language properly.
why not?
Haha, apologies. :-)
vscode with go plugin is beautiful as well. Delve works well as a debugger, super simple to setup and use. Microsoft did good for once i think. https://code.visualstudio.com/ with https://marketplace.visualstudio.com/items?itemName=lukehoban.Go 
No worries, wasn't really clear from this thread.
However, the very nature of errors is to change the control flow of your program. Do you log and pass the error up? Do you execute a recovery operation? Do you crash loudly? Even if you do the trick from https://blog.golang.org/errors-are-values where you combine past errors as NOP operations, you still end up checking for errors eventually and then you continue or fail. I don't see any case where handling an error would NOT eventually lead to some kind of branching (even though branching operations happen in other cases than errors, but that's unrelated). Even ignoring an error is about controlling the flow of operations, not computing values. Recognizing common error patterns is what gave birth to exceptions in the first place.
I have been developing with Go for a week, and already I can open up a github project(of someone else) and understand exactly what's going on. Normally it takes me a long time to track down what does what with other languages since I have to figure out what class/function/method gets functionality or inherits from what. 
Starting in games, then moving to web... The concept of simply "buying more hardware" is very foreign to me.
You can do something like: email := "fake@fake.com" line := "echo hello your email is: " + email + " | cut -c 1-8" out, err := exec.Command("bash", "-c", line).Output() if err != nil { log.Fatalf("Command line error: %v", err) } fmt.Printf("Command line output: %v", string(out)) Use the bash command and give the -c option to read commands from the string which contains the command line. Im not sure what your command line is trying to do though. 
The command is trying to dynamically format an email to a particular user by piping it 
GC pause times should be well below 10ms in 1.7 (coming soon). More like 1ms for most applications.
Java and classes will not go away until a lot of strong developers retire decades from now.
Only if you have the time to do it yourself with what's been written already. I would expect more work overall with Go than with existing C things today.
Sorry, I don't. Anything like that we've left in java for the moment. Almost everything we have is now JSON, so we've pretty much avoided anything but the simplest XML stuff in go.
Sure but in my case it don't know if there is always a leading slash so ended up with if statement. 
Well, that I'm aware of, but is that the case with Strt as well? Or is it just because it spun off from Trfik?
Thanks for the feedback! I will work on the things you mentioned.
Can you try and see if this configuration can be set in a GtkBuilder file and if so, just read in the builder file? It might be something missing still in gotk3
That said only .Net Core can rival Go in speed.
COBOL is still not dead, so it's pretty much a given that Java will outlive us all.
Which language is more fun to you? Because all of the above can do the job for you.
It's not working because `exec.Command` is not launching shell for you. So piping with | will not work, you need to do piping manually by launching two commands, using `cmd1.StdinPipe()` and `cmd2.StdoutPipe()` and connecting them. See this SO question for examples: http://stackoverflow.com/questions/10781516/how-to-pipe-several-commands-in-go
Does anyone have a good up to date comparison to k8s? I'm thinking of moving to swarm with HA being such a pain on AWS w/ k8s.
I pulled the license directly from the Go code and added a line for modifications by me. Im not a lawyer but since it remains the same I figured that made sense?
Ad Hominem, really? What, EXACTLY, are you suggesting I'm wrong about?
My guess is OP is running 'go run a.go'
Yes but a.go, b.go and common.go are files in same directory test/
They tried to copy some of the concepts but missed the point of how k8s implemented them. Like Swarm mode has Services, but they're far less flexible than Kubernetes services. There are dozens of features in Kube that Swarm folks probably haven't had time to even think about. I don't know of a huge comprehensive bulleted list, it'd take a while to aggregate. I'm still finding new Kubernetes features, pretty much every day, that I don't know about despite knowing a non-trivial amount of information about it and how to deploy it. Surprised to hear you're having such a hard time with HA k8s on AWS. Do you really need apiserver being HA or can you live with etcd being HA since the other components are stateless and can safely handle being down? Anyway, I thought there was more than one bring-up for AWS that including HA master components... ~~kube-aws~~ kops is experimental, but looks pretty cool and supports HA on AWS.
&gt; Does it counts as embedded? Nope, the Go binary runs on an OS = not embedded.
Goclipse to the rescue!
&gt; Even then Third Party Libraries will be completely hit or miss. Most aren't written with cross-compatibility in mind Uhhh ... how can you write non-cross-compatible libraries in a language that has the code abstracted through a VM?
I'm having a wonderful time developing Go on a Raspberry Pi 3 with docker + hosted cloud9 + gogs. I just wish Docker would release official ARM packages as compiling new releases of it is relatively painful. Server: Version: 1.12.0-dev API version: 1.25 Go version: go1.6.3 Git commit: a4634cd Built: Tue Jul 26 03:10:06 2016 OS/Arch: linux/arm 
&gt; whether there is actual performance benefit in using concurrency when the very next operation depends on the result of the concurrent operation No. Just make the call synchronously.
&gt; MEAN stack MongoDB? Run ....
&gt; With Go, you are going more low-level, and unless you want to manually handle all of your request handlers, Node (MEAN) would be a bit easier, although with more overhead (in terms of dependencies and etc.) Eh, there are a few frameworks out there now that kind of make this point go away. They might not be as mature as Express/Hapi for Node but still pretty good IMO (echo, gin, martini, mux router, fasthttp router, etc). &gt;I might lean towards Node in your case, just because there are LOTS of helpers specific to Angular/React/etc. along with countless db addons/etc. With React, I would definitely go with Node. This whole isomorphic JS thing seems pretty neat (haven't played with it myself). With Angular, I'd say go and node are on equal footing. You can build an API/web server in go and then a heavy angular client app. DB wise, agreed on there being more helpers for node but go is slowly getting there (Mgo for mongo, tons of sql related packages)
There can still be OS-dependent code in a library/program, even though it's implementation is cross-platform. It can be simple things, like writing paths Windows-Style, because it was never meant to run on anything but Windows, using system dependent libraries, or maybe even system calls. Forking a process and system level threading for example is completely different between Windows and Unix and hard to abstract. Even languages like Python can have problems with this. You also have to keep in mind that Mono tries to provide more or less the whole .Net ecosystem, which is a daunting task to say the least and not all of it behaves exactly like their windows coubterpart
ATMs, home routers and modems, TVs are not embedded systems too at your opinion? 
So the obvious question is, why were you even in doubt?
&gt; Multiple return values is something a C programmer pines over. Everyone else knows it's wrong. Well, Go is advertised as C with multithreading .... 
&gt; But once you call that external program a compiler, it's suddenly just magic and unicorn dust and all the complexities of template programming go away? Fucking YES. It's completly different having 20 int8, int16, int32, int64, int128 etc functions in your code OR letting the compiler do the job. You don't code your own jump table for the same reason you don't code in ASM - programming languages are there to make life + code easier, not mix it to a pile of shit. I don't want fucking boilerplate and Go is just stupid shit in regards to generics. The language even HAS generics but you as a programmer are not allowed to use it.
Competition is good. Hopefully the race is toward ease of use instead of odd corner cases that really big clients are requesting. All I want to do is load a container multiple times, with a different set of environment variables, as independent services. I scoured kubernetes documentation and found jack.
Thanks. It's going to be a busy year.
Error handling generics same keyword functions differently dependent on type (range ....)
Exactly. The Kindle did not replace books. TV did not replace radio. Radio did not replace newspapers. Cars did not replace trains. Facebook uses PHP, NetFlix uses Java. The existence of Go doesn't cause them to be obsolete. But Go is at the center of a new wave of computing (Docker, Kubernetes, consul, grafana, InfluxDB, RethinkDB, etc).
You should never do that.
This is exactly what I need! Thank you &lt;3
Exceptions in Python permit a flow of control that is totally unavailable to any other type of value in the language. Idiomatically, that special control flow is the only thing they are used for. It is not typical to see exception instances used like other values. That is not true of errors in Go. They are idiomatically returned, passed, and used like other values. The blog post you linked shows this well. Exceptions are far more "special" than error values when it comes to control flow. Perhaps "nothing to do with" was too strong, but they are fundamentally different approaches to error handling and should be treated as such.