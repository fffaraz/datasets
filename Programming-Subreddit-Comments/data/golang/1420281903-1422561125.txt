The Gopher was designed by an [artist](http://en.wikipedia.org/wiki/Renée_French), not a programmer.
Unless someone is providing a diff you'll have to download the full batch
Love the idea :)
I'd like to add some points about Go's potential for performance vs Java and Python. Go allows more of the things that C does which consitently allows C to outperform most other languages. Cache misses are quite important to avoid for high performance code. Reducing cache misses requires controlling the memory layout of your data structures. Go allows you to do that. Java doesn't which makes it harder to avoid fracturing of memory and cache. Right now Java usually runs faster than Go, because Java garbage collector is a lot more sofisticated. Although there is not reason the Go garbage collector couldn't be a lot better. Code generation is also likely a lot better for java at the moment. Go has a lot of potential to improve e.g. with support for vector instructions etc. So I think it is really just a question of time before Go edges past Java. Although like with any language code isn't likely going to be faster automatically by being written in Go. You have to utilize the facilities the language gives you. I'd say Go simply gives more opportunities to tune your code.
But I guess this would make Go a lot more suitable for creating e.g. command line tools or systems composed of many small executables. And even on your link it seems like Java is still consuming quite a lot. Memory of course isn't usually a big problem on server which might explain why it has been quite successfull there but a lot less so on the desktop. 
`get -u github.com/jstemmer/gotags` It seems that `go` is missing in this command.
I think *reaction* on such questions show up the "sickness" of this sub/r/, users afraid and minus any critics without thinking. Guys your faved /r/ is not religin take it easy do no evil ;) 
Being less suitable for "command line tools or …" leaves a gazillion other kinds of system. As you say 2-4x memory isn't usually a big problem … and that's the default allocation, without JVM tuning.
If you are using apache have you setup a reverse proxy to your go app? 
I'm trying with a full VM from https://www.modern.ie/en-us/virtualization-tools#downloads
the success of a language is through its community, idk about this community.
I see! Good to know, thank you!
Why not run it on an app engine instance instead?
You can have a function with the same name per platform, so a NewFoo() in your Linux file, and one in your non Linux file. Create an interface the two versions of the struct both implement and have the rest of the code just use the interface. Check out the implementation of file info in the os package as an example.
Thanks for writing a non-sensationalist programming language comparison. Some fairly random things came to mind that may be useful in Go: 1. You can kind of do "inheritance": https://play.golang.org/p/N8RA-r9Gju 2. You can type just "go get" in a project directory and it will go get all the things 3. You can do arcane and powerful things using the unsafe and reflect packages 4. You can do even more powerful and arcane things with the C package
He used assert in a test, that's a bit different.
&gt; Given the lack of a single winner in this space, I chose to write my package ‘the go way’ and not attempt using a package manager. I'm not sure that's "the Go way". Here's [what the Go team have to say on the matter](https://golang.org/doc/faq#get_version): &gt; If you're using an externally supplied package and worry that it might change in unexpected ways, the simplest solution is to copy it to your local repository. (This is the approach Google takes internally.) Store the copy under a new import path that identifies it as a local copy. For example, you might copy "original.com/pkg" to "you.com/external/original.com/pkg". Keith Rarick's goven is one tool to help automate this process.
No it's not
I haven't looked at the code in depth but from a functionality standpoint, do you know if it is still possible to get the fundamentals (P/E ratio, beta etc.) ? I have something in that vein on my bucket list but haven't had time to get to it yet.
I didn't know that Shopify using Go and Boltdb, any article about that?
Does anyone know a simple package that adds indexing and searching capabilities to Bolt?
Yeah, but I'm writing Golang, not C if you read the post. I just need to open the serial connection to perform simple functions. Thanks for all the doubt in my abilities though. 
Hey man, thanks a lot. I kinda knew all this, but couldn't get anyone to spell it out and solidify my understanding. Much appreciated. 
OK, you have several options. One is to call c functions from Go by creating a thin wrapper in C. This is very simple and has several advantages, including the fact that you can start with go code that does nothing but call the c code, then slowly ease your way into converting c to go as you get more comfortable. You don't have to do it all at once. Another option is to use this library https://github.com/tarm/goserial and do a one-to-one port from the c code. That code is very short and simple so you could probably do it in a day.
No; however, they employ a number of active Go community members, have a number of Go projects on their github account, and have job postings "Go developer" listed as skills. However, nothing detailing what they're *actually* doing with it.
Yeah, that's my plan is to do a port per se. I won't be using all of the commands provided by the documentation, I should be able to finish programming this in a few hours of testing and debugging. 
Yeah, I expected to catch a little flack for that :). In truth - the assert function I wrote is just there for DRY purposes. I found myself writing the same 6-7 lines of code in every single test, so I wrote a reusable method. I'm not really caught up in the dogmatic aspect - I just wanted to write good code. Looking at the code - how you you recommend avoiding the assert without writing a lot of repetitive code? I'm still very much a novice in this space, so all opinions are welcomed and appreciated.
Thanks! Now that I've built something, I'm finding talks and reading other source code to be the most helpful. The go-github code was really great to follow for my purposes.
Thanks will look at the code for improvement when I have free time :) it took me 1 hour to create this I had zero time I believe these are not the only problems 
Can you show some sample code to explain what you are doing ?
Is it possible for several compiled Go executables to safely interconnect by opening and using the same Boltdb file on disk? This is paramount for Go project I'm contemplating so would appreciate feedback.
I edited your sample code to make it compile and added a replacement version http://play.golang.org/p/v0n32IpkXP It looks like you are using strconv to round the number, is that correct ?
doesn't look like it. "Please note that Bolt obtains a file lock on the data file so multiple processes cannot open the same database at the same time."
I've tested it, it can run on android via [GNURoot](https://play.google.com/store/apps/details?id=champion.gnuroot)
Well that would definitely be helpful! Not sure how I missed that, thanks!
Sure I do
You could easily write a proxy, though, that uses sockets.
&gt; It uses less memory You're concerned about memory usage for command line tool which lifetime is 0.5s? This is plain insane. Looking back at responses I got each time I'm bringing this issue I don't care anymore.
Thank you! From a quick browse, I'll give you my basics, though I'm still not a very well-versed Gopher. * For those functions returning an error along with some form of a response, you can use _ instead of assigning to a variable that won't be used. * When making service calls, you can use [a goroutine](http://golang.org/doc/effective_go.html#goroutines) to make the call asynchronously. go func() { doStuff() } * Feel free to shorten some variable names that are obvious enough without needing to be verbose. There are plenty of resources on naming conventions in Go. There's a good section in [the Go book](http://www.golang-book.com/4/index.htm) to cover this, along with talks from Rob and other contributors.
You do?
Looks awesome :)
I've also been working on something very similar using the go/ast library -- Just a simple utility to generate CRUD functions based on a struct definition. There's definitely some cool things that you can do with the AST library. I wish there was more content out there on how to use it effectively (particularly in the way of parsing multiple files/using the go/build package to discover other sources) From what I can see, your package does something similar. I've taken the route of trying to build up the AST for the crud functions themselves, versus using the template package. I haven't released it yet, but i was planning on naming it 'sqltk', for sql-tookit. The intent being to generate typical boiler plate type stuff without any runtime dependency -- Maybe it's something we can combine our efforts on?
I highly recommend running the code through go fmt before outputting, it's actually very easy to do from code - just import go/format and run the output of your template through format.Source.
I had good success porting an existing command line application to go. It's nice to have the behavior and stuff all figured out, so you can just concentrate on the code.
Any project is a good project. I started by writing a JSON client for reddit data, then wrote a SGF parser for Hex board game data, rewrote it to handle Go games instead, then rewrote part of some code I had to manage search engine rankings, and now I mostly write Go for vanillaseo.com's backend
1. Rename the package "stellarutils" -&gt; "stellarnet" or "stellar". 2. Remove stuttering, i.e. the package name is part of a type name. e.g. full name of "stellarutils.StellarTxtQueue" would be much better as "stellar.TextQueue"; similarly "stellarutils.ResolveFederationUser" -&gt; "stellar.ResolveUser"; and there are more of such. 3. Make package specific and useful. e.g. ResolveFederationUser, don't return some sort of "FederationResponse" that contains "FederationJSON" return only the exact information and type that it should return; something like "stellar.Address" (not sure what would be the correct name). 4. Remove queuing altogether from the main package - keep it only for main methods, structures and API. Either leave it out altogether or make communication queue a separate package, "stellar/textqueue". 5. Is "Txt" the correct name, isn't "Message" or something else clearer? 
I built a YouTube downloader, which can also convert the videos to mp3 for podcast listening. The implementation required Streams and Threads and was big enough to have several packages. It made me familiar with some important parts of Go. 
What is the goal of the bash script?
These are also great when you just want to dive slowly into concurrency. Probably the first concurrent code I wrote in Go was when I tried to optimise on of my old Python scripts for performance :-)
Goblin from [suckless'](http://suckless.org/project_ideas) project ideas page. Simple tools, good sample code (albeit in C), and something you can use.
I agree, I'd recommend 'column_type'
I like the attempt but my gut feeling is that you need to be extra cautious. Especially about which methods you export etc. I am still trying to see the limit of doing it and from my experience, trying to discriminate too many types via an interface is a bit of a PITA. Better use a struct in those cases. But for 2 or 3 types, it can be nicer and more memory efficient than a struct based tagged union (well, depending on whether your struct embeds pointers or value types, and depending on the value type sizes etc.). Plus in that case, you can use a type based switch statement. In my experience, the time spent thinking about the API design was more consequent than the time spent writing all the methods.. but really I have mostly been playing with the idea so far. So I would be still cautious about using code generation for that (maybe I am too paranoid :). But by any means, keep experimenting. :) (and would be cool if you put an example) Also I think Rob makes an allusion to something similar in here (talking about writing n squared number of methods being yucky) https://www.youtube.com/watch?v=PXoG0WX0r_E
That is an excellent idea. I'll modify the tag format accordingly. Thanks!
Not a huge fan of underbars... Maybe colType? dtype? I get the 'type is too commonly used' argument, but it is also legit given that we're describing a database column type. It doesn't really bother me, but I appreciate the feedback.
I don't think the exact name is particularly important, as long as it's a bit more specific than just 'type'
Thanks so much for the early feedback. I'll keep checking in. Feel free to suggest modifications/improvements/features in the issue tracker. For the most part, this work was 70% demonstration and 30% something-im-gonna-use (I actually am using it in a RESTful API project, so mission accomplished). Improvements: * tag parsing with reflect.StructTag [#3](https://github.com/tristanwietsma/tabler/issues/3) is a definite must-have. I'll have to change the format a bit for tags, but should be trivial and will make it easier to add other attributes. * type as a label is a contested choice [#4](https://github.com/tristanwietsma/tabler/issues/4). I hear ya. Not sure yet.
I think that sounds awesome. Ping me when you get something scoped out and I'll jump in. Go is starting to remind me of that joke about emacs being "a great OS with an OK editor" in the sense that the language isn't perfect, but the ecosystem/tooling is nearly ideal. I see a lot of potential with metaprogramming to make that even more true.
There's an example along with the generated code in the example directory. It also generates the mentioned wrapper for exhaustiveness checks. Like with anything one can go crazy with this, but for things similiar to xml.Token it should be fine.
issue created; im gonna revamp the tag parsing first and hopefully get a few other features scoped out.
Thanks! I saw Bleve listed on the Bolt Github page. But that's a bit overkill for what I want to do.
hmm, perhaps I should namespace the attributes? current implementation assumes every field in the struct is a column, but that was just for this initial iteration. feasibly, you could have a *sql.DB reference in there and instead of building functions to return strings, tabler could build full featured I/O methods.
So what *do* you need to do? :)
Great article. I've found I've jettisoned the OOP pattern and gone back to procedural programming. Makes my SQL nice and easy to be left of center per the article. 
I've decided to try and tackle common network protocols for my recent learning excercises. Things like socks5, ftp, smtp, etc. Just basic versions of the servers, nothing too fancy. This is helping build my understanding of Readers, Writers, and the net library. You also learn how the underlying protocols work and get some practice reading RFCs and implementing things from a spec.
Just double-checked the compiler's behaviour to be sure, one cannot create new implementations for an interface with nonexported methods from scratch. However with embedding... You can override all the public methods. At least thats how the gc compiler seems to work. I couldn't pinpoint the relevant part of the spec though. Anyway, assuming gc follows the spec (and I think that's a reasonable assumption) this technique doesn't seem to add much in terms of type safety.
Also, as I've noted in the README, method per variant on the interface type is nice for documentation.
You might want to check out [btcd](https://github.com/conformal/btcd) and many of its core packages such as [btcwire](https://github.com/conformal/btcwire). It is a fully-validating Bitcoin daemon which is an alternative to Bitcoin Core. It touches basically every facet of the Go language and makes extensive use of the Go stdlib including areas such as databases, networking, tls, x509 certificates, crypto signatures, containers, byte manipulation, json encoding, hashing, big math, time manipulation, and runtime profiling, . It also uses standard Go practices such as testing, benchmarking, and proper package design. Finally, the code strives to pass other common Go tools for higher code quality such as 'go vet', 'golint', and 'goimports'.
I could add an option to generate an isShape() in addition to the normal interface definition. I should probably also make the exhaustiveness checking wrapper optional -- it should be a user's decision whether he wants it. Other ideas that come to mind are: * a Default()/Any() method so that the exhaustiveness checking doesn't always require the user to explicitly consider all cases, * specifying an optional interface (or set of them) to embed into the sum type.
I can see where your coming from here... How about putting a Shape() Shape method on both Circle and Rectangle and having them return non-exported implementations of Shape? After all both a Circle and a Rectangle are Shapes. You get more code generated, but a smaller surface API.
If I understand you correctly, yes I guess that would work. And it could actually make even more sense. :)
Write something that you need in your day to day life or work, little helpers. Go is great for command line tools because you get a single binary that's dead simple to deploy. Cross-compiling is also really easy. My first project was a single-file file server with uploader. It runs on my RaspberryPi now.
Seems like this is all, right? https://github.com/jteeuwen/go-bindata See also: https://github.com/progrium/go-basher
As a counter example, look at crypto.ssh. Or anything that has different "backends". It can still be more appropriate to export interfaces for others to consume.
Hmm, but how would I guarantee reliability of a home-grown solution like that? I like the idea (although I don't quite get the how/why implications of using a proxy with sockets..) but the ACID compliance is ultimately not something I want to have to re-test at the end of a dev-cycle, its hard enough for DB designers to get it right to begin with!
It would just be a thin shim on top of a single process using Bolt. So it would still be ACID, as long as you wait for writes to complete before you signal the calling process.
Tempest, meet teacup. When was the last time you had a global variable go out of scope, and thus be a candidate for garbage collection?
This is pants-on-head-retarded.
Well C# has ref/out keywords than can point to the middle of a struct.
Looks great. I was actually just browsing around for one the other day for use in some tests. I will check it out tomorrow at work.
Have a look at [`strings.Join()`](http://golang.org/pkg/strings/#Join) for combining a slice of strings. [Programming in Go](http://www.amazon.com/Programming-Go-Creating-Applications-Developers/dp/0321774639) is a great book that got me started. Everything else I've picked up on has come through reading the source code of projects on GitHub. Check out [awesome-go](https://github.com/avelino/awesome-go) which has a bunch of cool projects and examples. Otherwise, referencing the docs and source of Go's standard packages.
I'm really curious what the author was expecting to happen. 
I'm working on a command-line password manager. I currently use a simple bash-solution: bash + texfile + GPG, however using Go would give me an opportunity to add nifty things like sqlite integration, crypto, etc. 
I made this: https://github.com/lann/squirrel
Reading through the packages in the standard library helps a lot, as the general structure of the libs gets you a good grasp on what's in them. Googling works best with the `golang` term, and oftentimes leads you back to the standard library if it's a common problem. If you want to split a string, `golang string split` will take you to the strings package on golang.org. The information there of course also details how to put a slice of strings back together again.
Is it good practice do something like test := "this is a test" test = string.Split(test, " ") test = string.Replace(test, "is", "a", -1) Like keep assigning a variable to the outcome of some sort of mutation? Till you get the desired result. 
Awesome! I'd love to see an sFlow collector! 
The compiler will not let you do that. When you write: `test := "this is a test"` The compiler is able to infer the type that `test` should be (which is `string`). This is synonymous to: `var test string = "this is a test"` From there on, `test` is always of type `string`. http://play.golang.org/p/cL981JmO7l
I once tickled a bug with a Perl XS module that deallocated a global variable unexpectedly. Segfault ho! Took a while to diagnose that one.
&gt; Technically this and the limitations on builtin types and interfaces could be alleviated by automatically declaring an appropriate type that wraps/renames the specified one. Unfortunately, you can't do that. You can wrap a type from another module in a _new_ type, but it won't be the old type. Already bashed my head against that wall. There's no way to re-export a type and make it so you don't have to import the original module.
So do I need to create a new variable for each mutated string?
Depends on what you mean. `strings.Split` returns a string slice (`[]string`), so regardless of whether or not you can reassign something of a different type to the variable you're going to hit problems when you call `strings.Replace` since that method's signature is: `Replace(s, old, new string, n int) string` In what you provided your first argument is of type `[]string` which will cause a type error. So yeah, you would in fact need to create a new variable to hold your string slice. http://play.golang.org/p/8RV0NYnw0M
Why do people use Vimeo for conference vids? You can't speed them up. It sucks to watch slow talkers at regular speed.
"columnType" it is.
That wouldn't be good practice in js either 
Can you post a code snippet and I'll tell you what's wrong. 
do you mean having people sign in with google+? if so then that should not be the only way a user can Login/Register on a webpage.
Going over data structures and algorithms is a good place to start as you will get the nuts and bolts of C based language structure. And if web apps are your goal checkout my [example](https://github.com/jcrubino/beego-composer) that uses Beego web framework with an example of registration and authentication.
It sounds like you're trying to run before you've learned to walk. Honestly that's a great way to learn to run quickly, but let me back you up just a bit and explain this error at walking speed. My apologies if this is too basic for you, but I want to make sure all go beginners can follow along. First, we want to look at the function signatures of the functions that you're having problems with one at a time string.Split -------------- //go version func Split(s, sep string) []string /*javascript equivalent javascript's split and replace functions are actually different, but this is what it would look like if you just translated the go functions to javascript */ function Split(s, sep) There's some useful information in the go version that is missing from the javascript version and we can use this information to solve your problems. Namely go tells you exactly what kind of things each function accepts as input and returns as output. In the javascript version, all we know is that the function takes in 2 things and it may possibly return something. We programmers have to rely on context clues, good documentation, or reading the whole function source to figure out what those things are. The go version tells you right up front that it takes in 2 strings and spits out a []string. what the hell is []string - A short tangent on slices ----------------------------------- In go, []string would be pronounced as "a slice of strings". A Slice is essentially go's version of what javascript calls an array (i.e. a numbered list starting at 0). Go also has things called arrays, but I'd recommend you pretend they don't exist for now and just read "slice" as "list" until you get a little more familiar with the language. So to give another example, []int is "a slice of integers" which you should think of as "a list of integers" string.Replace ------------ So now that we know that split() takes in 2 strings and returns a slice of strings, lets look at replace. //go version func Replace(s, old, new string, n int) string //javascript equivalent function Replace(s, old, new, n) So like before, the go version tells us exactly what kind of input and output it expects. It takes 3 strings and an int as input, and it returns a string as output. Putting it all together -------------------------- The error you're getting is happening because you are trying to feed the output of string.Split (a slice of strings) into string.Replace which is expecting a single string. A slice of strings is different from a string, so go knows you've done something wrong. In your case, in sounds like you either you want to do the replace *before* the split, or maybe you want to loop over your slice and call replace on each string in your slice. If you do want to undo your split by combining your slice of strings back into a single string, then you'll wanna use string.Join Final Note -------------------------- For the record, javascript also chokes if you do this and with a much less helpful error code. I hacked together [this example](http://jsbin.com/naviwurotu/1/edit?js,console) to prove it. The difference is that go helps you find and fix the error much faster by giving you a more useful error code, providing type information in the function declaration, and giving you the error before any of your code even begins to run.
Here's what I do if it's of any help. On the users table I have an auth column, and before a user is created I assign them a unique token. That token will be stored in a cookie when they log in. I won't go into too much more detail as it's probably easier to see what's going on in code, here's [part of an API I'm working on](https://gist.github.com/daryl/b25833f128caa6986bec) which utilizes this.
What a coincidence. I just tackled that today :) Our backend RESTful API has to work with mobile, web, etc. Cookies and sessions are out! A token based solution using the excellent jwt-go library works well. The general solution is: 1) On client, ask for userName and password 2) Exchange the userName and password for a time-limited access token via HTTPS. Use jwt-go on the server to create the token. Use bcrypt to encrypt and compare passwords. 3) Add the recieved access token to the request header for any RESTful API requiring authorization 4) On the server, add an access token checker middleware for those routes. JWT tokens have an expire (exp) and not before (nbf) timestamp. JWT validates those when it parses the token from the header. 5) On client, periodically refresh the token. Our tokens expire in 5 minutes. I refresh them every 4 minutes. 
Please wait for few days. I wrote a authentication system based on none framework. The speed is good and i tried to programming as clean as possible.
It depends entirely on the project manager, and the developers.
I was grumpy because I haven't added vimeo support to gophervids yet: https://github.com/dgryski/gophervids/issues/1
Yes, sure, I know how interfaces work. And functions take arguments and return values. Still, people come up with stuff like functional options. It's not about using an interface in the usual, obvious way -- but about how we can use them to get as close to sum types as feasible.
I know but if I put it in simpler terms, I would rather say that `a circle is a kind of shape`. Rather than saying that `a shape can be a circle or a rectangle`. So that when you define a losange later, you just have to define it as a shape and don't have to say: it's a shape but it's neither a circle nor a rectangle. The disadvantage of the latter being that it also forces you to modify the circle and rectangle definitions after the fact to say that they are not losanges either. I don't know if putting the assertion in this way makes sense to you or maybe it's more confusing... Said differently, the method that you've chosen for encoding your sum type is something I had tried initially but I realized that I was trying to be extensional while interfaces are inherently an intensional encoding.
Simply reimplement software from the GNU Core Utilities: http://www.wikiwand.com/en/GNU_Core_Utilities
Any general purpose programming language can accomplish that, but Golang is always going to be more effective as it's much simpler to code and maintain than other languages. It's also much easier to train new programmers in Go so it's the ideal programming language for businesses. Go does support a library for creating simple UIs so this is very doable. One of the stronger suits to Go is the fact that it has robust support for web technologies, considering it's used internally by Google. As a result, you may easily create self-contained web servers and use them as user interfaces accessible from any web browser.
Some of the usecases are: * log traffic of honeypots * for implementing capture the flag services 
If you converted the number of words that have been talked about on this subject into code, you could just use go as it is and implement the few lines of code that generics would have saved you. I'm not saying generics are bad, but either fork go or use go. Its all open source. Seriously I would love to see someone just implement generics in go.
Cool, thx. At least some results without errors - unfortunately not the easy way I hoped for. ;) But you're right, XML is too rich to have an easy decoder for everything.
It isn't clear to me that you understand what you are doing. You may need to spend a bit of time learning how floats are represented in memory, and then trying to understand exactly how you are manipulating the bits in memory. My suspicion, though I can't prove it, is that you will discover that this isn't even remotely doing what you expect, and once you understand what is _actually_ happening, a much easier and more effective way to do whatever it is you are trying to do will become clear to you. (FWIW, there's nothing Go-specific about that statement. All the languages use the floating point provided by the CPU.) If you'd like a specific suggestion, [this guide](http://floating-point-gui.de/) is probably what you need.
A number of people have, using the preprocessor approach. Not sure how popular these projects are. Personally I'm not using anyone of them, and every time I'm tempted to try writing one myself "the right way" I'm reminded of that fact and go do something else with my time on earth. 
but reddit.... seriously though, I have more interesting projects I'm working on in the little spare time I have (right now - an in-code cloud aware load balancer for network clients). I would have done it if I thought it would be worth the effort, but it's not just writing the pre-processor, for this to really work well you need to adjust tools like gocode, linters, syntax highlighters, etc. 
So ruthless haha, reminds me that I should go do something productive myself. I knew I shouldn't have created a reddit account...
Thanks for the feedback. This is admittedly one of my first Go projects, and I kind of hacked my way through it. I will definitely be making improvements to this going forward, as I am heavily using the code it produces now (and I imagine that code needs to be cleaned up as well). Currently, I am parsing comments using the tokenizer (ast/token) in conjunction with regexp matching. This is how I am matching structs to documents in MongoDB. Regarding the braces in my switch statements...I come from a C/C++/ObjC background, and I think I just did that out of habit. Using braces enables you to create variables inline without preemptively allocating them. I am definitely looking to use `go generate` in the future. I think that will standardize code generation across the go ecosystem, which is an incredibly powerful tool IMHO.
Sure, that's the way it will be done. But I thought it would be a good opportunity to learn something new, just for the case if some other data won't allow this KISS method. :)
So in context of myself also not "showing code", if you have more interesting things, why do you care about golang generics? Specifically because people have been talking about generics for years now. If you think generics will make your life easier then code talks. If you come up with the way to implement generics then you have twenty people who will rewrite all the go tools. Or maybe you feel there are not the people who will do that? Maybe the real question is, is there a prototype language that we can play with without having to modify the entire stack? Go actually seems pretty close to something like this. But there is a huge difference in duplicating rob pike's lexing videos and diving into the current golang code. I would love to fail at implementing generics, but I am not that interesting in dealing with syntax highlighting at this time. Anyway I'm only about a quarter of the way through the dragon book so I'm sure my opinions will probably be wildly different next week.
Yeah, that's fair, I just find interesting to explore the different ways of using interfaces. I am just a bit cautious still. *By the way, just realizing that my above post looks wrong taken out of context, looks like we are doing kindergarten geometry :)*
Yes, that's why I said "odd xml". They're all equivalent, just with numeric suffixes. The author should have read something about xml before using it. Anyway, I can't change it, I just have to handle it. They even used &lt;bar1 id="1" ... /&gt;, repeating the suffix as id attribute...
The thing is: I miss it as a developer *sometimes*, but obviously not enough to either a) ditch Go with all its huge advantages that make my life happy for C++/Java/etc, or b) implement it or extend an existing implementation. (BTW In the load balancer project I mentioned, I'm actually about to use a bit of code generation and AST parsing for a specific task, where I guess generics would have enabled me to achieve the same thing). I think that given that it's not coming from the core Go team, no generics project would really become mainstream enough to create the mentioned ecosystem. And again, personally for me it's a nice to have anyway, so I don't really care if that never happens. 
* mitm attack
Why don't they make a clearer statement in the FAQ or somewhere else, so that this discussion dies!? Ambiguity is the worst here....
It'd make about as much sense, to be honest.
He said that there are no plans, not that there can't be plans. By leave it as is, Rob probably meant 1.x. There's currently no plans for 2.x either, but we can still expect it to happen in like 5 years.
To clarify our API is completely stateless and doesn't rely on cookies or sessions. That doesn't preclude using session or local storage for storing the refresh token in a web app. On mobile app, the keychain is used to store the refresh token. The short-lived access token is kept in memory only.
I like the idea of the project; this looks really useful. My comment, however, is less academic. The name is so bad! It can be fun to use Go puns, to be sure, but this one takes the cake for ugliest :P
I think your use of the word "probably" proves my point here
I got it to work nicely with my tests. Thank you. Here is a couple of comments for you: * I feel that your public API is a bit broad. You should limit [exported identifiers ](https://golang.org/ref/spec#Exported_identifiers) to those you expect the user to use. * You should write some [documentation comments](http://blog.golang.org/godoc-documenting-go-code). Maybe you could also put in an example or two. * I liked that I was able to input my own public key during testing instead of relying on DNS. * If you expect others to work with you on this, you should adhere to the [`go fmt` coding style](http://blog.golang.org/go-fmt-your-code).
Haha yeah you're right, I just mean to say that Rob's statement isn't as unambiguous as it initially seems which is consistent with them being ambiguous everywhere.
Not really, the upgrade path will be a gofmt just like 0.x days. A minority of packages will break because they're doing something wrong, just like many of the 1.x updates.
I guess you _could_ implement it without breaking backward comparability in a high share of cases. However, look at Perl 6 and Python 3...
You could just unmarshal into a map[string]interface{} like this: http://play.golang.org/p/N1NFQ9cQ5q
Try https://github.com/bitly/go-simplejson
Try using this library for arbitrary json; it's pretty useful. https://github.com/antonholmquist/jason
Try with: cookie := http.Cookie{Name: "locality", Value: "here", Expires: time.Now().Add(time.Hour), HttpOnly: true, MaxAge: 50000, Path: "/"} And finally, you should make a redirect: http.Redirect(w, r, "/", http.StatusFound)
Iterating through all cache items on garbage collection, with an acquired exclusive lock, isn't going to be pretty.
And if you want to then conditionally decode that map in to a struct, use https://godoc.org/github.com/mitchellh/mapstructure.
Added some basic tests. If anyone wants to modify them, go for it.
[Here's another complete web app](https://github.com/emadera52/sixty) that uses the Beego framework. You can see it [here running live.](http://60plusadventures.com/) I plan to get back to work on it next week after a holiday break followed by dealing with a failing primary drive on my dev system.
[Here's a complete web app](https://github.com/emadera52/sixty) with user authentication, csrf protection, etc. that also uses the Beego framework. [You can see it here](http://60plusadventures.com/) running live. Feel free to register (which logs you in if successful), log out, close the window/tab, open again in a new window/tab, log back in, update your profile etc. Use any comment block to report problems or suggestions. I plan to get back to work on it next week. Since the holiday break I've been dealing with a failing primary drive on my dev system. Top priority will be to implement email validation and lost password processing. 
Thank you, I appreciate it
Thanks! I'll take a look...
Yet another? Last time I looked for one (for webfist... http://webfist.org/) I couldn't find one and ended up shelling out to some Python thing because Brett Slatkin and I were under the clock for a hackathon thingy. So thanks! 
hackathon looks like much pressure on you [Verify DKIM signatures](https://github.com/davidlazar/go-dkim) [libopendkim wrapper for Go](https://github.com/eaigner/opendkim)
you can use the mxj lib, that works similar to the json lib in general cases https://github.com/clbanning/mxj you can simply unmarshall to a mxj Map (=map[string]interface{}) and have something like { "foo": {"bar1":{"-name":"a"}, "bar2":{"-name":"a"}}} if you don't have a huge xml, this is the simplest code you can get, for large xmls you can use the raw tokens from the xml.Decoder and build it yourself (http://blog.davidsingleton.org/parsing-huge-xml-files-with-go/) 
Good discovery - this is one that will stick with you across all languages, because it is a consequence of HTTP. Keep in mind that if you need to edit headers after "sending" output, you can use a buffer to store all of your output before flushing it over the wire. However, this will increase the delay between the request and the client receiving data (and it will take up space in memory - probably only relevant for very large output), so there is a tradeoff.
I've always found looking at the godoc for the project to be a good starting point.
If you want to read a large project, I suggest reading the go language lib, because it is full of good style, has plenty of tests, and will be very useful to understand, regardless of what you want to do. In particular, it contains good documentation on each of the packages, which explains the big picture. Docker has quite a few sub packages with little documentation, so you're going to have some difficulty. On the other hand Docker is quite interesting so you may find it rewarding anyway! My usual process is read the docs, then read the tests, then run the tests, see the coverage, and see if you can figure out how to cover an additional case. Most importantly, understand *why* the case has not been covered, and what it means if it is reached, particularly in relation to the state of the rest of the program. Then you might also have something useful to contribute, so hey, that's good too.
I want to emphasize and underline this. Typically standard libraries are sort of garbage under the hood (even if in some sense they are quality code in the sense that they are battle-tested), but the Golang code is really, really good and usually quite easy to read. Stay away from heavily algorithmic stuff like TLS unless you know TLS itself already, but otherwise read that stdlib. It is always a joy to read the source code of a standard function and see either A: pretty much exactly what I would have written anyhow or B: the most obvious optimization for what I would have written anyhow. If you'd like something concrete, I'd suggest [bytes.Buffer](http://golang.org/src/bytes/buffer.go). (You may need to step up to [the godoc for that](http://golang.org/pkg/bytes/), then look at the other "Package Files", for certain symbols. Note that the godoc has all the source, though for the purpose of browsing, is unfortunately lacking a "jump to source implementation" feature which would make it easier to navigate multiple-file packages.)
Any other Gophers in/near the Research Triangle (Raleigh, Durham, Chapel Hill) interested in teaming up? I've got some app ideas, but not enough Go skills to complete them in the timeframe.
I started tackling this with [Flotilla](https://github.com/thrisp/flotilla): [login](https://github.com/thrisp/login) &amp; [principal](https://github.com/thrisp/principal) handle authentication &amp; authorization respectively.
Agreed, the Golang lib is a good place to start as well
I built this app some time ago and it's deployed in heroku: https://github.com/elcuervo/minimalweather you can check the code and the "quirks"
&gt; Note that the godoc has all the source, though for the purpose of browsing, is unfortunately lacking a "jump to source implementation" feature which would make it easier to navigate multiple-file packages. Just run godoc locally with the -analysis flag: http://golang.org/lib/godoc/analysis/help.html
thanks!
Last time I tried it was easier to cross-compile from Linux to Windows (at least from Arch).
I went through everything perfectly with MinGW32 until it came to actually building go-gl where I got an error because I had used a 32 bit gcc but a 64 bit Go. I don't care to downgrade to 32 bit, so I went with MinGW 64 bit but then I couldn't even build GLEW without pages and pages of complaints from the compiler when I run the same build script (pulled from here: http://stackoverflow.com/questions/6005076/building-glew-on-windows-with-mingw/6005262#6005262). I'm thinking I may have messed up my MinGW 64 bit installation. I already had 32 bit installed so maybe they overlapped weirdly. Next time I try, I'll start from scratch with 64 bit.
Someday when I have the extra hardware lying around, I definitely intend to have a linux machine for projects like this. Until then, I'm sticking with Windows.
You totally missed an opportunity to name your project "godec" ;)
Yes, I sincerely regret that on the authors behalf as well! On the whole go-codec looks really impressive. I don't quite understand difference between "runtime reflection or compile-time code generation"..? Wish people could be bit more straight-forward about what their stuff does. Simplicity that you know does the job is much better than Eloquence that may do the job.
Starting from scratch with 64 bit didn't help. While building GLEW, I get a lot of linker errors. Why is this such a problem!?!
By following [this guide](https://github.com/golang/go/wiki/WindowsBuild) I managed to use [glfw3](https://github.com/go-gl/glfw3). The 64 bit notes helped.
How about [Gogs](http://gogs.io/)? It's a GitHub clone in Go.
The articles talk more about what each does. Typically, encoding will use reflection at runtime to introspect the type, and figure out how to encode or decode it. The reflection has some performance overhead. For some extra work, you can run a tool beforehand which will look at the types, and generate a go file which explicitly states how to encode/decode the type. This means you do not pay the overhead of reflection at runtime, and gives significantly better performance. The downside is that each time the go-codec library is updated or the structure of your types change (e.g. change struct fields), you will have to re-generate. The codecgen article at http://ugorji.net/blog/go-codecgen digs deeper into this. 
you're passing the string returned by hex.Dump() as the 'format' argument of Printf. it's trying to parse % characters for formatting, and is missing the corresponding argument. for example, Printf("%d", 5) prints "5", while Printf("%d") prints "%!d(MISSING)". Try replacing fmt.Printf with fmt.Println to see the difference: https://play.golang.org/p/tnESm0I2n1
Printf expects a format specifier in its first parameter. It's complaining that there isn't one.
fmt.Printf's first argument is a *format string*, in which %-sequences can be used to substitute the following arguments, if any. If you use your hex dump as the only argument to printf, and the dump contains a percent sign, Printf will be confused as to what to do. Either one of the following variants will work better: * fmt.Printf( "%s", hex.Dump(res) ) * fmt.Printf( "%08x", res ) In the above code the format string does not change as the input changes, so your program will behave in a more predictable way. If you're curious, a detailed list of available formatting options can be found at http://golang.org/pkg/fmt/
now there's what i wanted. thank you for your quick reply!
Hi all. I am _one of_ the go-gl developers and also creator of [Azul3D](http://azul3d.org/). For go-gl, you should really take a look at the bindings generated by [Glow](https://github.com/go-gl/glow) rather than the ones in the "gl" repository. These are, sadly, not the ones that people run into when they visit the go-gl GitHub page, but they are vastly superior (IMHO). - They don't require Glew to be installed on the system. - Just MinGW and Go! Note: I'd also reccomend GLFW 3 (https://github.com/go-gl/glfw3).
That looks really nice....just what I am looking for. I'll check it out. 
This is a pretty amazing package.
You may want to do some performance analysis, and look at some packet sniffs when sending large chunks (i.e., try sending a single megabyte in one slice through a normal socket and your buffered socket) through this library with the default settings. I'm not 100% sure, but I strongly suspect you will discover some surprising and unpleasant side effects you probably weren't expecting to be as large as they are.
Hey, The application looks a little light on documentation? What exactly is the purpose of GoAuth? Do you mean OAuth2? Basic Auth? Or is this a full authentication system to be used for a variety of purposes exposed through HTTP? It seems like a crazy amount of dependencies required for something like "auth" (including other tools like Redis, Neo4J, etc).
Also in the future Go has very good documentation. All you have to do is go to godoc.org/package/import/path - for example [godoc.org/fmt](http://godoc.org/fmt).
[A mere glimpse of the world of reg​ex parsers for HTML will ins​tantly transport a programmer's consciousness into a world of ceaseless screaming.](http://stackoverflow.com/a/1732454/1048862) Have you tried using an XML parser instead? 
Offtopic, but Azul3d is a really cool project! I've been messing with it a bit, and if I keep poking at it I'll probably come contribute.
Not the OP, but wrangling same issue as OP right now. I tried this and got: $ go get github.com/go-gl/glow/gl-core/3.3/gl # github.com/go-gl/glow/procaddr/wgl cc1.exe: sorry, unimplemented: 64-bit mode not compiled in Which is the same problem I got after installing Glew and trying to get go-gl/gl. 
Made another one for ya. http://play.golang.org/p/9bsdDgDKy4 Just have a temp struct to partial decode. Made a wrapper at one point too: https://github.com/chrhlnd/dynjson
Cool article. I'm a little confused about one thing though: &gt; **ldflags** Extra flags to give to compilers when they are supposed to invoke the linker, ‘ld’, such as -L. Libraries (-lfoo) should be added to the LDLIBS variable instead. whereas the example below uses LDFLAGS for -l: /* #cgo LDFLAGS: -lsass #include "sass_context.h" */
Very glad to hear ! I have some big plans for the future and would love your help! [Keep in touch](http://azul3d.org/doc/community.html), please =)
The application have none any purpose, it is an example application, how you can write authentication system in go. GoAuth is just a name, I just choose it :-)
Literally ANY language will be able to accomplish the task. You can do it in x86 assembly if you want. The point is, what's the most suitable for the job? What's the simplest, cleanest, easiest, most popular/standard way? The answer is Python.
What would be a rough quote?
Yeah the buffering will mainly be used while reading preambles, or headers for a given protocol. Most of the time Read will be used for the body of the message/or structure. I found it interesting the golang http server used 2k and 4k pools for writing. https://github.com/golang/go/blob/master/src/net/http/server.go#L482-L486 Definitely needs some testing though. Thanks for the tips.
It is not TheGoWay. If I remember correctly, he wrote it last year to prove a point in a mailing list discussion. He does not advocate its usage nor does he use it himself. He just moved it from Google Code to Github and someone discovered it now. Latest commit: "Be clear: don't use this." https://github.com/robpike/filter/commit/719f41397a0cd4c4b12b3176a49821de294efb75
Interesting project! I used to use filesystem-backed with PVM Xen before the KVM days, so this is right up my alley.
I don't see anything wrong (right now)? It just redirects to the proper import path for me.
Pike is so funny guy, curling his robpike.io spits out pile of poo. ^Literaly^, ^it ^streams ^repeatedly ^1 ^rune ^(0x01F4A9 - PILE OF POO) ^with ^40B/s
This is so great.
ah thanks for the tip, I've reorganized the code :)
After learning Common Lisp and moving to Go just after 1.0 was released I did something very similar. I went a lot further too, implementing more functions. I also have never used my library. http://github.com/howeyc/ligo
Audio support isn't perfect, but otherwise this is very impressive piece of work.
"You shouldn't use it either." awesome.
&gt; cgo does not support relative lookups of C files Can you clarify what you mean by this? Do you mean local #includes?
Hopefully, as with last year, the talks will be live-streamed.
Summary: go-codec supports compile-time generation of encoders and decoders for named types, which does not incur the overhead of reflection in the typical case, giving 2X-20X performance improvement over the idiomatic runtime introspection mode. Idiomatic encoding and decoding types within go typically relies on the reflection capabilities of the go runtime. This affords flexible performance without the need for a pre-compilation step; the go types contain all the information needed and the runtime exposes the full types via reflection. However, introspecting the runtime to get this information has a noticeable overhead, which can be eliminated by a pre-compilation/code-generation step. To eliminate that overhead, a pre-compilation step must be done to create the code which would have been inferred at runtime. This is why Protocol Buffers, Avro, etc have better performance than runtime-based systems. go-codec now provides the same capabilities, with the accompanying 2X-20X performance improvement depending on the size and structure of the named type. See primer: http://ugorji.net/blog/go-codec-primer 
You need to upgrade to a newer version of go that supports the .io domain.
The project structure is awkward (=non-idiomatic).
Good to know. I think it would be useful if the README of either glow or gl contained a comparison between the two, discussing their tradeoffs. Anyway, thanks for your advice.
Time to upgrade to Visual Go Studio 2015.
Hey Mongo fix your mongo-tools directory structure, it hurts eyes.
OP apparently haven't made his way through documentation yet, if he had he'd discover CGO_* env vars.
This *is* impressive. MMC3/MMC6 support isn't complete by the author's admission in the code, but any support along those lines is an accomplishment unto itself. The size and completeness of the codebase tells me that either the author has done a lot of work like this before, or it's a port from another implementation, or both.
Awesome! Nice job!
Wow, I am doing something very similar (minus the CORS). Where I work we have a super similar structure as you've described minus the desire to allow CORS. For the past few days I've been working on reworking it in go. We use socket.io 0.9.x so that's the first painful hurdle I had to jump, but meh, no problem. The socketio spec is super easy to implement (since the googollee one you're using uses code.google.com/p/...websocket and i'd much rather use gorilla websockets). first question: are you using socket.io 1.0+ ? If you are, then googollee's socketio server uses gorilla websockets and if you check on [gorilla's websocket documentation page](http://www.gorillatoolkit.org/pkg/websocket) you see a section for origin considerations. what you probably then need to do is track down where in googollee's socketio code, the upgrade is handled and add whatever you need to there (and preferably expose it in the Configuration as a param to the socketio NewServer). maybe that'll help? maybe i missed the mark on the question? if you are not using socket.io 1.0+ then you're using 0.9.x and you're where I am. edit: (if socketIO 0.9.x) wanted to add looks like Configuration has an Authorize func(*http.Request, map[interface{}]interface{}) bool. Have you tried setting that function as always returning true in your config for NewServer? 
Check it out saturday too learn from it.
How it differs from hugo?
It's browser who sets Origin
I actually discovered about 20 minutes ago what you mention about googoolle's dependency. Wish I saw your comment earlier :P I'm now trying with gorilla, and using gorilla docs (was even on the exact page you linked to.. at least I know I'm thinking soundly!) Q1) Yes, 1.0+ (latest version.. forget off top of head. Tried older 1.0+ versions but wanted to stay above 1.0. I've got 1.0 running in production for a while now like 10 months?) Will report back with progress. EDIT: OP updated, "problem" solved. I went with gorilla websocket, checked their documentation, added 1 line to their chat example, and bam.. I now have something I can work from. Thx for the help!
Thanks, that explains it perfectly - I might just have been in a slow corner when reading the article yesterday but I get it now with your comment as guide point. Yes, there will certainly be LOTS of situation where compile-time gen. makes perfect sense (i.e. the majority of web apps I can think of: how often does one change the DB layout (and hence JSON flow) of core data set.. not that often!)
Note that this isn't the full schedule.
Holy chicken and egg, Batman. 
Nah, it's easy. Install Go 1.4 somewhere (the document provides a default location), and that will be used to build the compiler. Then the compiler rebuilds itself. The second step is quite common in the gcc/clang world.
My first goal after recently going through the go tour, etc. was to build a blog app, so as I keep working on that personal project I'll probably peek in here from time to time to see how particular problems were solved. I still want to complete the work myself to gain the experience in doing so, but afterwards I may look more seriously at contributing to this project instead to avoid future reduplication of effort. Either way, thanks for publishing this, most of the other blog engines I'd found on github for go were either quite old (in some cases pre1.0) or way more complicated than they needed to be for just that task (hugo).
Yes. If you already have gccgo, that will also work. 
How's the performance in comparison to other emulators? I know that NES emulation isn't really hardware hungry but you should be able to compare the emulator, right?
I highly encourage you to go and work on your project, it is great to learn a new language by doing some project! And of course, whenever you want to contribute to blgo, your PR will be more than welcome :)
I, perhaps somewhat foolishly, agreed to do a live-coding demo for a mini-conference called Hey!Stac. I didn't screw up as much as I thought I would.
Sorry about the formatting, here the script #!/bin/bash for pkgname in build-essential libaio-dev openssh-client nfs-common do dpkg -l | grep $pkgname &gt; /dev/null 2&gt;&amp;1 &amp;&amp; echo "$pkgname : exists" || echo "$pkgname : does not exists" done ====================== build-essential : exists libaio-dev : does not exists openssh-client : exists nfs-common : exists 
Why do you want to convert it?
Ok... but why do you think it will be better if written in go?
It runs the latest version of godoc built with the latest version of Go. We need to restart godoc anyway. By switching directories, we can keep the latest stable version running while the newer revisions build (or don't).
For the same reasons people prefer Perl/Python over shell scripts
Performance is probably the #1 thing that could be improved. I can get fullspeed on my Mac desktop, but it's a newer machine with good specs. It's entirely possible to make an emulator for an 8/16-bit console which focuses so much on 100% hardware accuracy that it needs a powerful machine to run full speed, look at [bsnes](http://byuu.org/). But nintengo is not trying to be 100% hardware accurate, so there's definitely room for improvement.
Is the full schedule available?
I don't get it. Can't you just build compiler as single static binary? Current process is kinda redundant.
I'd love to see more videos like this. Also, I really miss programming with a buddy. Coding alone all too often leads to brick walls and mental blanks. I find i'm *so* much more productive when working with another person.
https://golang.org/pkg/os/exec/
Ah, I missed that godoc was running (thought it was just hosted static files).
For a second there, I thought I was going to hack with Andrew Bird. 
I interpreted the title as a question for a self post, and I suspect SpNg did the same.
Anyone know the colourscheme Andrew is using? I've been trying to get a white on black or black on white scheme, tried several things but can't quite get it to work properly. Another colour always finds a way to bleed in there. He might just have syntax off. I remember there was an issue when I tried that but I can't seem to recall what it was.
I'm glad you like it. I use it in all my projects and I also try to show gratitude to the devs that make my life easier :)
He just has syntax off.
I haven't had time to play with it but I am hoping to evaluate this soon: https://github.com/mijia/modelq
oops, that's exactly what I did. I didn't even click on the link...
At first I was looking at the go server wondering how static content was served magically, then I realised it must be https://github.com/codegangsta/negroni#negroniclassic on line [26](https://github.com/kostonstyle/goangularjs/blob/master/main.go#L26)
Even though it relies on reflection, it's probably still faster than the idiomatic Clojure functions :-/ Welp, I know what will be keeping me busy for the next hour or so....
Thanks, this is great.
In my program I have a file (that's referenced by a variable) that is read and written to that I don't want my tests to touch, so I made a copy of that file and reference that file (and location) in a variable in TestMain. This way, the main program, has a file to use when the tests are being run but not the same file as the production code runs on. 
Very soon.
What compiler do you use to build this compiler? This is the part of the bootstrapping problem we're solving.
Those things are as rare as hen's teeth in Australia... &lt;hint, hint, Andrew...&gt;
Oh I see, I may have misunderstood the meaning. I thought bootstraping involved compiling go 1.5 code. Hmm so once this new compiler is finally built using go, it will come as static binary.
A cherry blue keyboard. http://i.imgur.com/GWfV3.gif
The pattern is easy enough to write and to remember. Why would you advocate loosing type safety by using this package? instead of writing the code again? 
I actually used it in production..., I often find myself lost in this trivial channels + goroutines + WaitGroup combination. 
Not in the near future, no. But maybe someday!
This was already possible before Go 1.4. For example: https://github.com/AudriusButkevicius/gohashcompare/blob/master/main.go#L50 Obviously, involves a bit of witchcraft.
One pattern I try to follow with interface{} collections is to supply a guard function so that type errors can be caught early and conveniently. If it's just a container class then I'll supply the guard to the New() function, and I'll apply the guard at insertion time so errors are reported to the inserter (who is responsible for the type error) instead of the code that is trying to use the wrong type object. Here it would be useful because you could detect an invalid work item type before dispatching it to the worker, making it simpler to report type errors back to the caller.
The downside of Go being able to pull from GitHub, which is itself so trivial to publish to, is that it has blurred the line between "storing a library I wrote myself in my repo", "putting something up others can look at and comment about", "I'm using this in production but don't expect anyone else to use it and I'm just showing this to others for reference", and "I'm publishing a library with the claim that this will be useful in your code". It isn't clear to me where the author thinks this falls. I find myself asking this question about posts on /r/golang about once every two days. There's just a stream of these things (this is at _least_ the third implementation of basically this exact library we've seen in the past 3 months, and there's a couple of other recurring libraries that come up to, such as people manually re-implementing sync.WaitGroup or doing funny things around channels to implement things they already support). It actually matters which is which, because the nature of feedback that is suitable is different for those levels. If it's the lowest levels, general encouragement and broad strokes of suggestions are appropriate... on the other hand, if you're claiming this will be useful in other's production code a level of feedback is called for that would be downright _mean_ to apply to someone's "First Go Project Evar!", you know?
GC doesn't affect my applications very much. Mine are compute heavy, and I avoid allocating as much as reasonable. That said, if you don't already know, Go 1.5 will have a concurrent gc that puts limits on how long the world will be stopped.
Not at the moment, but it is a feature really easy to implement. Feel free to open an issue at github if you want! Anyways, it is highly probable that I will include it in the next version :)
Irrelevant correction: gcc is written in C++ these days, although it was C until a few years ago. The gccgo frontend was always C++. 
The JVM is also stop the world (ParNewGC, the non-concurrent phases of CMS, G1, etc). However, Go let's you easily write, with some potential ugliness in extreme cases, write very low allocation code. Less allocations = less need to GC. What is your actual latency requirement? P99 &lt; 10ms? P999? P9999? Can you use multiple workers and a more predictable front end (HAProxy, nginx) to route around nodes in GC?
&gt; The downside of Go being able to pull from GitHub, which is itself so trivial to publish to I think the problem is people do not know how to use gists - they write 50 lines of code, call it a library and host a repo for it. While in fact it should be a gist at most.
Sure is "witchcraft": [the function](http://golang.org/pkg/testing/#Main) is classified as internal and is not really supposed for the end-user. That's partly why I was excited about `TestMain` – it's actually a stable, non-private interface.
Glad you like it. The Actions interface{} will probably be beneficial to you but isn't complete. It will allow you to hook into when an Actor is Jailed, LetOut, etc and do something like log the event, send an email, set a firewall rule, whatever you can dream up.
Java has had to face this question as well. In addition to the excellent points raised by /u/fubo, one alternative is going off-heap for your objects. Peter Lawrey's Chronicle project[https://github.com/peter-lawrey/Java-Chronicle] (extremely low latency logging) and Martin Thompson's Disruptor (extremely fast cache-aware inter-thread messaging) are two examples. Going off-heap is fun in a geeky way, but requires careful handholding. One thing that is better about going offheap in Go compared to Java is that Go's structures are inlined (an array of structs is not an array of references to structs, unlike Java).
Whats the point of setting a custom header hashbang? Are you simply trying to make it clear to the backend which requests are coming from angular? This seems dirty. 
It's possible that chunking the input into alternate buffers will allow the GC to collect the previous buffer before the current one is full. Just a suggestion.
Just set up a VM or Docker to do this ;)
Work like [xxd(1)](http://linux.die.net/man/1/xxd) ? hexdump and reverse
&gt; but please leave your NodeJS mindset outside the doors and try doing things like the rest of us do. Please don't represent yourself as the community. everybody has their freedom to do what they like, Also please don't apply your opinion to everybody. You can only represent yourself. Don't talk "no-one does this, no-one does that".
Yes, this.
Is mangos protocol compatible with nanomsg? Is that what implementing the "Scalability Protocols" means? So I could throw in some mangos services with some, say C, nanomsg services?
&gt; buf := make([]byte, 16) Make much much bigger buffers. at least 1024 times bigger. edit: Second, xxd does not give a shit about unicode AFAIK. Remove that entirely if you just want to print out the hex dump, you might require it for the format display but I'm honestly not even sure I've ever seen a multibyte char in xxd.
Your program has a bug that manifests itself when `Read()` returns less than 16 bytes. You might want to use `io.ReadFull()` for your use case. Apart from that, you don't need to convert `r` to `int` before comparing.
Thanks for the suggestions - this version is much more comparable for speed (one file that takes 8 seconds for OSX's xxd takes 12 seconds with this version). https://gist.github.com/richmidwinter/d7d73b3a105cdad78f1e It does just blast the output out in one write, which is probably cheating a bit. I'm sure I'll keep tweaking though.
Constantly mallocing small chunks of memory in my experience was a large factor behind the slowness of my program.
He isn't constantly allocating memory—he only allocates the buffer once and reuses it.
You're right, I'm an idiot. Please continue.
`Read()` may return less than 16 bytes. This may happen at any time, not just at the end of file. I'm pretty sure that was not your intent. The `io.ReadFull()` function does not read the whole file; it calls `Read()` as many times as needed to fill the supplied buffer. After an `io.ReadFull()`, either the buffer is completely filled with data, or an end-of-file has occured, or a different error has occured. Please read the documentation of functions before insisting they do not solve your problem.
You don't need to buffer the whole output; how about you use a `bufio.Writer()` to buffer the output instead? This should be faster than using `fmt.Printf()`; as opposed to C, all standard IO streams are unbuffered by default. You should also use `WriteByte()` instead of `WriteRune()` if you don't care about unicode as the latter has a little but not negible overhead.
The bug is exactly as described by OP. Have a look at this for an example: https://github.com/felixge/go-xxd/commit/120804574f12033999f23e6cf6a3b75961f14da1
No, I'm looking for a pointer to the interface not the structure. I'm trying to call a function that takes a pointer to an io.Writer, not an io.Writer... 
I'd say Rust offers a much better 21st century language than 1970's C language but is very adept at being able to wrap and inter operate with C libraries and C style system calls. In this respect it excels much better than Go, but has a lot of similar niceties as Go plus its own language feature goodness that exceeds Go in some areas. But if I needed to write a middle ware project tight now I'd be more inclined toward Go. However the project am actually going to undertake involves using the Oracle C API OCI driver library, and for that project am going to use Rust.
You can see the bug by entering the following in a terminal where `./xxd` is your xxd: mkfifo foo ; cat -u &gt;foo &amp; ./xxd foo ; rm foo (leave with `^D`)
Okay, i think I the solution to my question is: var pf interface io.Writer pf = f t.Dump(&amp;pf) 
see above...
If I was doing a code review and saw that you were passing the address of an interface value to a function, it would raise a flag. An interface value is designed to be copied. An interface value is a reference type, just like slices, maps, channels and function variables. Unless there is a unmarshal operation happening, this is questionable.
I think that it is a misunderstanding. &gt; I've seen familiar concept, probably coming from NodeJS, it was called debounce or something, also there was an attempt to introduce it to Go. Why ass-broken? It does not sound like SOLID to me, especially the S part or I fail to see it. If I had to implement handling for bad login attempts, I would create some Login structure (controller) that would cover all cases and then register it as an RPC handler. What you propose is to create Login method and then wrap it in 3rd party library to achieve some error handling (or fault tolerance). The second I was given such construct, I'll refactor it to something sane and readable. &gt; Are there other use-cases for this library or did I totally misunderstand it? I don't see how this isn't SOLID. "a class should have only a single responsibility (i.e. only one potential change in the software's specification should be able to affect the specification of the class)" BadActor only effects itself. It is a cache with some special features. My middleware that I create seems like a pretty classic use to me. The middleware separates the logic into small units. Almost like a function chain. It is a very powerful pattern. In the code example I provided, I created a rate-limiter by using BadActor to help generate the signal and a few features to help handle that signal. BadActor simply **helps** in the process. There were no errors, which I think is important to think about. The result was purposeful. &gt; Are there other use-cases for this library or did I totally misunderstand it? What may help is for me to explain the philosophy. And to do this, I'll use an example. The NSA slurps the internet. When an *event* happens, this allows the NSA to react. They are able to answer questions like "Why did this happen?" or "What exactly occurred?" But collecting this data will not help them in their cause of being preventative. You need data to be combined with some signals intelligence. The majority of logging systems do exactly this. As developers we become just like the NSA, we log everything, we log too much. We lose the signal. And we end up reacting to things instead of preventing or diverting them. BadActor is my first attempt at helping developers think about how they should generate quality signals in their code and how to handle them. *Also, something like A/B testing would be a form of signal generation that isn't security related. Signals are good :-) 
How does this compare to Otto?
I think Otto is not a live now, take a look this issue https://github.com/robertkrimen/otto/issues/100. But the main stop factor to use Otto is performance. Simple benchmarking of rendering of react application shows: - node.js 3ms - duktape(native) - 7.64ms - otto 42.92ms So, the performance's difference is huge. Also duktape has simple and clean design. See goals section http://duktape.org/guide.html#introduction.5.
 Rust is definitely more complicated/difficult than Go or C. Unfortunately, its main features (memory/data race safety without GC &amp; cost-free abstractions) necessitate a lot of conceptual overhead. There aren't really any other good options when it comes to bare-metal performance that's memory/data race safe.
The function should not be doing that. I mean, you *can* call it with an \*io.Writer, but it's just a silly way to code if you understand how interfaces work.
It doesn't work that way. When the GC stops the world it has to scan all pointers to see if there are still any live pointers pointing to allocated data so it can collect it. The GC is not generational so it doesn't matter if those pointers or the objects they point to are freshly allocated or not, it's still going to scan all of them. If you have billions of pointers and objects, this just takes a long time, there's not really any way around it without adding more complexity to the GC and object accounting. 
Novice use of Rust's unsafe blocks is a recipe for terrible pain, because there are many subtle rules that have to be followed within Rust unsafe blocks to avoid things going wrong in really hard-to-debug ways. I think non-experts should stay well away from unsafe. Probably novice use of Rust will involve falling back on slower ref-counted data structures instead of the more efficient kinds of references, in order to avoid compiler errors they don't yet understand (the borrow checker causes a lot of questions), perhaps resulting in code which is safe but slower than Java or Go. So I think Rust is for people who are really ready to take on all the complexity of that model and are willing to work to get the best out of it. People not willing/able to invest would do much better in Go.
Nice article! Minor nit: it's not considered idiomatic to use ioutil.ReadAll when you don't have to. Your GetIssue function could very easily do something like this instead: err = json.NewDecoder(resp.Body).Decode(&amp;ghr) if err != nil { return err } While it isn't a big deal for this application, [this post](http://jmoiron.net/blog/crossing-streams-a-love-letter-to-ioreader/) has more information about why ioutil.ReadAll is rarely necessary. 
if you want a bdd style test framework check out ginkgo. There is also a capybara style webdriver framework called agouti: https://onsi.github.io/ginkgo/ I have used these and they work well.
wg.Wait() is indeed blocking, the program will not proceed past that point until wg.Done() has been called the specified number of times, in your case 6. The issue is your "out" channel. It's unbuffered, which means sends on it will also block until something is there to receive the signal...but that's not happening until your for loop at the bottom (item := range out being more or less the same as item := &lt;-out), which is being blocked by wg.Wait() The reason the second snippet works is because wg.Wait() is no longer blocking the for loop from executing. You've sent it off to it's own corner to wait until all the expected sends have occurred, and only then allow it to close the channel. That also means your for loop can stop trying to receive from the channel and safely exit. The other way to resolve the situation is to make your channel buffered up to the length that you expect it to hold. Here's an annotated version of your program: http://play.golang.org/p/b5zK1LN5n5 For fun you can try running it with the goroutined waitgroup, but add a "programmer error" by changing: wg.Add(len(items)) to wg.Add(len(items)+1) The program will proceed normally, handle all the values sent out on the channel, and then deadlock.
This is cool, but I can't help but feel this is like hammering a square peg into a round hole. Have you done any benchmarks on these in comparison to the more "idiomatic" imperative solutions? 
It is absolutely a square peg in a quite circular hole. I mention something similar in the README (and imply it with the name of the lib). This was more of a "I was so preoccupied with whether or not I could that I didn't stop to think if I should" kinda thing. Specific for loops are the much more correct way to do this type of computation in your program.
Awesome, Ill try it out.
I think it's just a joke. Comparing go and rust doesn't really make a lot of sense, they're very different languages trying to accomplish different things.
I'm confused how you take it as bashing? The quote makes Go sound better than Rust.
Was this article generated by an algorithm?
The algo is not perfect yet, the title does not match the content.
The game Go is a ultra-high-level view of war, at the strategic level. Chess is a view of a battle, at the tactical level. The IMHO completely-correct idea here is that Go is higher-level than Rust, and thus not really in competition to each other. This is neither criticism nor praise of either language, just a description. It's why I ultimately agree the two languages are virtually not competing with each other. The more I see about Rust, the more it looks to me like it is going to end up being significantly more difficult to program in than Go for any given task. The Rust implementation may come out running faster, using memory better, and being safer, but if it takes two or three times longer to write that's not _always_ a win. I will particularly be interested in watching how it manages to do architecture; things that are obviously correct at the micro level often start to break down at the macro level. (I mean, once you learn to see this, it's just _everywhere_ in language design.) Personally, while it's too early to ask this properly, I'm intrigued by the question of whether Rust will be able to grow a runtime compatibility layer with Go, now that that is all factored out. What if we could transparently integrate the two, without all the overhead that cgo currently imposes? Interesting question. [I elaborated on this theme more 17 days ago on HN](https://news.ycombinator.com/item?id=8791394). People here may find it interesting.
I wrote a book about Go! It's called "Learn Java in 21 Days"! I'll be RICH!
Now, [combine that with composition](http://www.jerf.org/iri/post/2929) and you're really cooking with gas. __Edit__: This just occurred to me, I'll have to blog post this later, but this combo play of interfaces and composition offers an alternate way of viewing the world, which I note I've been subconsciously using as a design principle in Go without realizing it. Rather than viewing an object as part of an enormous network of objects that all have references to each other, which is one of the reasons that OO programs can become hard to test since the dependencies inevitably trend towards sprawling across the entire program, if you program in interfaces and composition, you can begin to view an object as a self-contained world that _contains_ everything (via interface composition) that it needs to perform its duties, instead of _referencing_ everything it needs to do its duty. This implies that the [Law of Demeter](http://en.wikipedia.org/wiki/Law_of_Demeter) for Go, rather than saying "talk only to your _immediate friends_", ought to be "talk only to _yourself_", for a slightly modified definition of "yourself" that includes things you've composed into "yourself". Rather than "inheriting down" all my objects, in my non-trivial Go code I've noticed I'm doing an awful lot of "composing up" my complicated domain objects. Logging isn't something they "use", it's something they _have_. As my blog post notes, since composition enforces strict separation between composed elements, this doesn't result in an explosion of complexity the way trying to do this with inheritance would, and what would in conventional OO languages be very large and unwieldy objects actually work in Go just fine. I'm still noodling with this idea since I did just have it while writing this; feedback welcome.
Cool! Looks like a lot of fun.
Tron is a movie and a video game, but the game "Tron" is four separate video games in one. The name of the game you made a version of is usually called Light Cycles. 
very cool.
Tomorrow's conclusion: message passing + shared memory = bad, Rust = good. Yawn. 
Thanks for the post. I added a link to it from my Go install post: http://www.goinggo.net/2013/06/installing-go-gocode-gdb-and-liteide.html If anyone else has documentation for Sublime, Atom or anything else please send me an email bill@ardanstudios.com
Nice tool!
Plus you have to re-deploy or re-distribute your binary when the keys change.
Thanks for the help! I was assuming that there was essentially infinite buffering by default and that programs would have to manage channel memory usage themselves (though what I'm building has small enough input that this wouldn't be relevant).
This is a really cool idea!
You may want to look at os.Environ(). Or os.Getenv(key string)
I've had problems with vim 7.3 on *osx 10.10 so I suggest updating. https://github.com/fatih/vim-go/issues/214 
what's the API key for?
Database
All URL paths you *do* handle are of the form /time/* anything else is handled internally and will hit the default 404 handler. make sure you handle /.
Awesome thanks!!
Good feedback, thanks! I will definitely take your advice in paragraphs 2 and 3. For protocol enforcement, I will likely do it using configuration rather than take a closure. The reason for this is that thar be dragons there, and a big purpose of a library like this is saving the developer from themselves (viz. your second paragraph). A quick examination of the [XSS Cheat Sheet](https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet) shows that there are a million and one ways to fool protocol enforcement, so I plan on doing something very careful and well-tested there. For transforms, I am planning on using closures. I've been thinking of the best way to structure the closure API. Thanks again!
I agree with NaNiwa: Use http://jmoiron.github.io/sqlx/ - in general just some convience-functions on top of database/sql. I tried all major Go-ORMs: You hit wall even with simple examples. I would say they are years away from being usable (experience from .NET and Java over the years). In general the relational-database access-story in Go is a little bit difficult. For example you have to work around (also in Sqlx) a nullable datetime. Or when Marshalling in different directions - from SQL to JSON - some extra work for sql.NullString is needed for example. 
Indeed, though "Tron" is shorter and easier to type. Made mention of Light Cycles in the README.
Oh, hey, another useful test: Stability! Sanitizing an already-sanitized string ought to be a no-op, ideally no bytes changed. This is fantastically easy to write tests for but can be a pain to get right. If for some reason the parser makes it hard, I could understand slight modifications perhaps still happening, but you want to make sure you're testing for no double-escaping (and there are some subtle kinds). I've lost track of the number of "forums" where I couldn't press "preview" without getting multiplying escapes in my message....
If anyone who is familiar with vim but looking for something different then checkout spacemacs. It's emacs evil mode (vim mode) with some of the popular emacs packages integrated. Right out of the box it looks gorgeous. 
I bench it with xxdOld and xxdNew. The new one gives a better performance: http://play.golang.org/p/97ObN4yAj8
As the author of Gorm, I had a pretty good time with Rails many years without problems, and really happy with the time ActiveRecord (ORM) saved for me, so I can't really understand those people who think ORM is useless, maybe they just get used to write SQL ;)
You might want to be more specific about what you're looking for. If you're not averse to implementing it yourself, [my reading of the library Mutex](http://golang.org/src/sync/mutex.go?s=712:760#L11) suggests that you probably ought to copy &amp; paste the current Mutex and plug in the bits that turn it into a counting semaphore from a book's implementation of that algorithm, and the result will be a better-integrated lock than if you just wrote it yourself. Bear in mind that since Go is ultimately a conventional shared-mutable state imperative language that if you pull in conventional multithreading constructs in a grand way, you _will_ be taking a trip back to conventional multithreading hell. What protects Go from that is social rather than technical. I'd actually guess you know that, but I still wanted to make sure it's out there. If you post your specific use cases, you may be able to get some help in the idiomatic way of performing them with Go's constructs. I would suggest even if you have lots of experience in a more conventional language that you perhaps at least ask and consider the answers. Mind you, I won't deny that there is still a time and a place for conventional stuff, even in Go (which is why the atomic package exists in the first place, after all), but still, I'd hesitate before reaching too deep into the conventional toolset given the known outcome it produces...
You can trap the signals using http://golang.org/pkg/os/signal, then clean up and exit if appropriate
First, to save everyone else the effort, the [properly-formatted code](http://play.golang.org/p/ZshA1kjabI): func registerDomain(domainName string, n int) bool { resp, errr := client.Do(r) if errr != nil { if n == 1 { return false } registerDomain(domainName, n-1) } bodyBytes, err2 := ioutil.ReadAll(resp.Body) if err2 == nil { resp.Body.Close() } else { resp.Body.Close() if n == 1 { return false } registerDomain(domainName, n-1) } return false } The playground stripped the comments when I hit format, not sure why. Anyways, you're painfully close to the answer and will kick yourself (no offense), but you need to `return registerDomain(domainName, n-1)`, not just call it... you are exactly correct that the failing call is continuing on because of the lack of return. Also you appear to never `return true`, which you probably need in the successful clause of the ReadAll, which means no matter how you recurse you can never get this to say `true`, which is probably not what you mean. You could also transform this into a loop, which would technically be more idiomatic Go, but, on a code snippet this size, meh. Though to be fair you probably stood a better chance of getting the logic right with: for i := 0; i &lt; maxTries; i++ { res, err := Thing() if err != nil { continue } res2, err := NextThing(res) if err != nil { continue } return true } return false On the other hand, the recursive solution can become cleaner if it goes beyond one loop, though at that point you're staring down the barrel of some irreducibly complex code, probably.
I use [goth](https://github.com/markbates/goth) for oauth login. It's fantastic and easy to use.
I would use a process call to wget. The code is much simpler and you can retain a process handle which will allow you to terminate without the need to turn your code into something resembling erlang. :-) I did this recently on a large back up project for TV and backed up 35000 broadcast files this way.
"The best golang lib ever"
Your link is going to `127.0.0.1:9000`. Consider linking somewhere else.
What do you have on the right side of your screen, and how can I get it to work on my machines?
Yeah, some documentation or even some comments on the code would be great.
Thanks, fixed. Local godoc install.
This is kind of like the DIY IDE. I'm personally not looking forward to spending the better part of a day installing and configuring vim plugins only to discover the multitude of missing functionality. I would love it if [go had a real IDE and and a working integrated debugger](https://odinsql.com/2014/12/go-needs-ide-intergrated-debugger/). 
**[flotilla](https://github.com/thrisp/flotilla)** started with gin, but is something else currently. Addressing the posted article: - gin had this content negotiation system and built in templating that was removed immediately, flotilla defaults to using [djinn](https://github.com/thrisp/djinn). Which is its own problem, but one that ends up being user configurable and replaceable in a flotilla application. - flotilla has evolved a concept of an engine that is a router(plus some other odds &amp; ends which could even be optional) that is separate and theoretically configurable/swappable. The default engine is built using httprouter. In the article instance, the default engine could be swapped for one using regex and its on the horizon to tackle alternative engines -- with the hope that someone with skill might even develop an engine superior to the default to be used as a new default. - performance gains: doubtful, though untested. I haven't even gotten to the point where I could be comfortable testing for performance(as a part of the project, and personally programming knowledge-wise/skill-wise). flotilla isn't aimed at shaving millisecond performance gains, but there is room to consider performance overall in relation to other frameworks/libraries. flotilla: based in gin but evolved to difference in its current form, still in the martini/gin family if you're looking at where it fits in go frameworks/libraries. 
I just found it on Github and it's amazing, maybe the most advanced Go web project.
It's interesting, what's the appeal of this versus other frameworks though? As I had mentioned, Gin was appealing because it had built in support for templating, binding, and some other helpers (redirect, return a string, etc.) Does flotilla work as mainly a middleware handler?
Interestingly enough, with a new project I've been working on I started with httprouter but quickly ran into the tradeoffs of using a trie based router over a simple slice of routes. I ended up writing my own router for the project, https://github.com/codegangsta/mix, it has the typical martini-style API but it isn't a trie: m := mix.New() m.Get("/", func(rw http.ResponseWriter, r *http.Request) { fmt.Fprint(rw, "Hello world") }) The fun part is the grouping feature, which allows you to group routes together underneath a certain path, and you can optionally provide middleware for a group: m := mix.New() m.Group("/admin", func(m *mix.Router) { // add routes here and they will be protected with basic auth }, auth.Basic("user", "pass")) I plan on documenting and releasing the library in the next week. It has been working really really well for our project and performance is pretty crazy fast.
Also, I can't figure out how to make it save with \n line endings, there's no option for the most basic of settings. I really *want* to like it.
My application has bursty demand and the times at which the bursts will occur is uniform. Also, it doesn't have huge memory requirements or allocation rates. I've had good results simply turning off GC entirely during demand intervals and then turning it back on afterward. See: http://golang.org/pkg/runtime/debug/#SetGCPercent YMMV of course. Profile, load test, etc.
&gt; It's the only one I know that support contextual renaming of go symbols Since the *gorename* tool does that, any editor that can run external an executable can be configured to have that feature: https://godoc.org/golang.org/x/tools/cmd/gorename 
exactly what I a friend and I were talking about today, saying we wish we had this for go! thanks
Are you working on Windows with it? I just checked my code on Linux and it definitely puts just \n at the end of lines. One annoying thing I couldn't disable is its habit of saving backup files or something that look like foo.go~ all over the place. I've added them to gitignore but still you see them in the file tree and it's annoying. 
Interesting. I actually wrote a router not long ago ([Zeus](http://github.com/daryl/zeus)), but it was only about 2 weeks ago I decided to stop using it myself and just rely on the net/http package alone. It's simple really, pretty much everything can be solved with the strings package and a couple of extra lines. func main() { // ... http.HandleFunc("/posts/", handlePosts) // ... } func handlePosts(w http.ResponseWriter, r *http.Request) { // Trims slashes then splits by slash segs := utils.GetSegs(r) size := len(segs) switch { case size &gt; 2: http.NotFound(w, r) return case size == 2: // posts/:id postsWithId(w, r) return } // posts switch r.Method { case "GET": postsGet(w, r) case "POST": postsPost(w, r) } } func postsWithId(w http.ResponseWriter, r *http.Request) { switch r.Method { case "GET": postsShow(w, r) case "POST": postsUpdate(w, r) } } I'm sure this probably isn't for everyone, and the code simplicity an extra routing layer offers is nice, but don't underestimate the tools you already have.
In your example what is the purpose of reading in the private key into the server config if you're only doing password authentication?
The private key is the thing that gives the server a fingerprint and identifies the server. It is intended to mitigate man-in-the-middle attacks, since then the attacker has to consistently spoof the server.
So even though public key auth isn't being used the private key still is used as a server identifier?
Working [playground](http://play.golang.org/p/tWQuIvR8aK) with Card and Player converted to interfaces. Learned a few things, still don't know if this is the right approach.
odd that it didn't do it for my parent comment. anyway, it sounds like a pretty trivial configuration option to add, have you looked at the code to see how difficult it would be to patch this?
&gt; I am not a language theorist, nor do I claim to be a language expert. In fact, prior to actually using Go, I’ve barely heard of generics, communicating sequential processes, and other “cool” and “advanced” concepts. I’ve heard of all the new cool programming languages such as Clojure and Rust, but have never looked at any of the code. So my view of Go is basically one of a developer n00b. As the post alludes to, the reality for most businesses is not the theory that backs up the design of the language, but rather picking a language that gets the job done. Go, compared to other languages, seems lacking when it come to that theoretical background, but when it comes to getting the job done, Go seems seems to be batting better than average. 
I love it. Unfortunately the case statements add about as much clutter as the original err checks and a much less recognizable structure results. 
I will. 
This was one of the things that impressed me most when I started with Go - full SSH client and server implementations... I used it to replace complex and error-prone bash scripts that scripted scp file transfers, with zero problems since it went into production.
North of Edmonton, four hours north? Wow, I thought I was already pretty far north. Yea, Nathan is right. You should drive down and make it a weekend. I am sure after the workshop we can all hangout :)
The conscious goals I'm striving toward are simplicity &amp; extensibility. The project is still very much a personal "how I'd prefer to learn about and do things instead of using someone else's framework", and in that sense undifferentiated from other frameworks excepting personal preference. The starting point was yes, a mainly middleware handler derived from gin(and a previous project I had called fleet that was a toy fork of martini) with less emphasis on speed and more concern for use in bringing a code base built around several python flask application to go.
I find it hard to remember the reference date, therefor I made a lib that uses the excel date/time format: https://github.com/metakeule/fmtdate
You will have to write custom marshallers for the Car and Garage structs.
I once scanned over my biggest, non-trivial project in Go, and approximately 1/3rd of the error statements actually _did_ something with the error, be it reacting somehow (retries, etc), logging something specific, wrapping it, on occasion going down separate code paths, examining it, etc. It is a heavy-duty network app but I'm not sure that makes a huge difference. What I don't like about this pattern is that using it will tend to train you that the correct thing to do _is_ just to simply return the error out. But what I find is that while that may be a sensible default thing to do when you're first bashing out a function, over time as you refine it properly you often end up _doing_ things with the error, and this pattern will inhibit that; the first time you actually do something sensible with the error other than just return it, this entire pattern just becomes noise worse than the original once it starts containing actual error-handling code. Along with the lack of clarity involved in using a switch statement to do something other than switch, which is itself a problem not to be underestimated in terms of understanding a function by reading it, the indirection this adds in following the control flow which comes perilously close to giving up on the entire idea of structured programming within that function (_also_ something you may occasionally have to do, but a bad default), the fact that this will inhibit refactoring the function due to making it much more difficult to properly pull out subexpressions within it, the fact that this will train you to be sloppy with errors is even on its own terms a bad idea. I think you're trading away a _lot_ of really important things you may not be able to currently perceive to obtain a slight benefit to something you can. I don't think that's going to be a good trade for you in the long term. I think if you did this pervasively with your code throughout a non-trivial project you'd wake up one day and discovered you've created a monster.
Golang is mostly imperative.
about returning errors by default: I respectfully disagree, it is very easy to handle any error: case 4: thing, err = fn() if err != nil { thing = defaultThing() err = nil // handled } I think if you get used to this pattern there is no lack of clarity but you gain clarity, that is at least my experience from the last weeks. It makes it really easy to understand what is going on since you can easily concentrate on a single case statement at a time and reason about it. Then if you want to see the big picture you look at the order and the shared variables both are visually easy to spot. But the best of all: In fact it makes it easier to refactor: You may start by returning any error and as you process you can easily factor out single or multiple case blocks if they were doing to much. And even if you use the jump trick, it is very easy to refactor jump targets to functions: You can find all places that jump to your externalized function by searching for something like "jump 4" inside your function. I think you argue on a theoretical level and you simply have to try it out to see if it fits your needs.
finally got around to reading this and only regret not reading it sooner.
[login](https://github.com/thrisp/login) for [flotilla](https://github.com/thrisp/flotilla) is derived from working with flask-login, still alpha but functional.
Great job - this'll be useful. Did you use any tools to help you build all those binaries available for download on the Releases page? 
I find myself doing a lot of if err != nil { return fmt.Errorf("Add some context: %s", err.Error()) } That context could instead come of prior log entries of course.
Thanks! I used [gox](https://github.com/mitchellh/gox) to cross-compile. The script is [here](https://github.com/NickPresta/chameleon/blob/master/build.sh).
A great perspective for Go newbies. Highly recommended. Among other things you'll learn to ignore snarky comments by old hands who are a bit over-eager to show their superiority. ;) 
Go has only one loop - "for loop". Let us understand this through an example.
Exactly. That's why I love hearing these silly language debates over in /r/programming. As as a student or an academic, use whatever language you like for whatever theoretical reasons float your boat. When you get a job, you use the language your company needs. That being said, I see a lot of innovative startups using Go. Maybe it's just a lack of experience but I don't see that same ecosystem with Rust. 
Someone's nostalgic for basic, it seems. :P
I think stack traces are helpful for debugging, but do not add anything to error handling. Au contraire, you now changed the error type and might break error handling code by introducing them, Your solution even does not keep the original error making it impossible to type switch on an error type. For webprojects I need stack traces to be reported to the issue database for critical unexpected errors. But for them I don't want to proceed the request if such an error happens, so I panic and catch the panic at the outermost middleware in my stack and there the stacktrace will be generated and reported. Normal errors such as validation errors are either handled gracefully somewhere or ignored. No need for having a stacktrace for them. 
My biggest argument against this is that you cannot add a line of code without renumbering every case statement below it. That makes it a bit too brittle to be reasonable for me.
You are right about that. Although this is not much and no error prone work. On the other hand it has the nice sideeffect that every commit/diff shows you the complete new order and this might help spotting errors (wrong order). To benefit from it, add a comment to the case line, describing, what this case is supposed to do.
Interesting point though I never used basic or any goto language ;-) I just felt the need. But seriously, the jump setter is not the main point, just a nice optional bonus feature that surely might be abused.
Are you trolling? Because it looks like you're trolling. I was simply responding for the user's need for context in error messages.
&gt; I think you argue on a theoretical level and you simply have to try it out to see if it fits your needs. Come back in a man-year on your code base and tell me about it then. Anything works for two weeks being done by one developer. And remember my standard isn't whether your code _works_, but whether it is _better_. (That's a really easy mental substitution to make.) To make my purpose in typing this that all out clear, my ideal outcome is _not_ that I talk you out of using this. Which is good, since that probably isn't on the table. My ideal outcome is that you are sensitized to what to look for as you continue on, and thus realize sooner that you have problems than you would have otherwise, possibly by quite a lot. And hey, if I'm wrong, fine. I can deal with that. When the Go community is all doing this in three years, I'll reevaluate happily. Go ahead and prove me wrong as hard as you can. But in return, I'd just ask that you periodically put your head up and re-examine what you are doing, compared to using normal Go idioms, not as a favor to me, but to yourself.
I don't know how I could prove you wrong. But then it is not my interest to convince you. The sole point of posting it is: It started as an idea and I stuck with it and so far been happy with it. It gave a clear pattern to my error handling and helped me understand the implications of my code better while also encouraging me to reason about the order of execution and error returning. I can't say what will be in one year, but so far returning to code using this pattern was a non issue: It helped me understand my "old" code. A function using this pattern might be viewed from a highlevel as [func signature] (shared variables) // ignore complicated loop declaration (1 do stuff maybe set err) (2 do stuff maybe set err) ... (err return or wrapping) and that pattern is always the same making it easy for me to find and understand stuff.
I use Windows only for gaming which could explain why I never really looked at C# but yeah, then I was probably missing that one.
I did end up reading the article, and I liked it, but the title is very misleading.
I'm saying that memoizing "b" also prevents from memoizing "a" simultaneously, FWIW. Cheers!
You're looking for [this post](https://www.reddit.com/r/golang/comments/2qbc4u/type_safe_templating_with_ego/), which is likely not searchable on account of being `[deleted]`. Thankfully Google has no such limitation, and as of now your previous post is the [only hit for "GHP: Hypertext Preprocessor"](https://www.google.com/search?q="GHP%3A+Hypertext+Preprocessor").
It wouldn't be difficult, but there are many such patches to add. It's a waste of time. They should have just integrated neovim to get the most functionality from the editor, Vim mode or not. Instead they opted to do everything from scratch like every other novice developer. Now they alienate themselves from contributions because no one wants to waste time modifying their crappy custom editor.
This was so confusing to me the first time. Someone was trying to be way too clever for their own good.
I am wonder how "GHP" compares to PHP complied with HipHop. I am curious to see if Go is faster or slower.
If you got to the point where you're thinking about *slots*, I'd say you're probably over-thinking it. I guess maybe I'm just a little bitter from having to interact with what I'd call random gibberish in several different languages and environments that don't always agree on what the letters are and even when they do, they sometimes have different meaning... but IMO, the reference time concept makes so much sense that I'm surprised I hadn't seen it used anywhere before. The worst part for me isn't even that I must force myself to lookup the values whenever I write more than the one or two formats that I can type from muscle-memory, for fear of getting it wrong, again. Nope. It's that after all that I cannot confidently return to read the code at a later date without fetching the lookup table again.
IIRC it's not totally custom, it's based on Kate or something along these lines. But I might be wrong. Personally I hope the Arom plugin (and atom in general) would become sufficiently good so I can really work with them. Right now as I said, LiteIDE is the most sensible compromise. It's not a great editor but it has by far the best Go integration. 
yes but the question is how when the marshaller interface doesn't distinguishes between pointer and value recipients.
UPDATE: bmo111 fixed Bcrypt passwords, we can go on...
I like that the 'reference date' method gives me an obvious, non-ambiguous representation so that I don't have to look up symbols again when I look at old code and want to check something. *However*, I agree 100% that their chosen format for the reference date is dumb and cannot imagine why they didn't make it ISO format.
Great. Let me know if you have any issues. I think I parse like 34 formats automatically but if there's something not on the list, I would be happy to add.
Well, so, there are a couple of things here. First, re: interface names specifically, usually interfaces with names that end in -er provide a single method that is the verb form of that name. So `Player` would provide a `Play()` method, for example. But also, usually you define an interface if you want to leave it up to callers of your library to provide their own types. It's not clear from your examples what your callers would do. For example you could have a type called `Player`, representing a player of the card game: type Player struct { name string hand Hand } type Hand interface { AddCard(Card) } type Card interface{} func (p *Player) DealCard(c Card) { p.hand.AddCard(c) } So callers could supply their own `Hand` and `Card` types.
The entire point of Go is "try not to be a smart ass". Everything is as explicit as possible, to the cost of having to repeat a lot of code. Even if something is not "idiomatic", it's very hard to come up with something difficult to understand in Go. The underlying algorithm might be hard, but the language itself just tries to stay away as much as possible, so all you need to do is trying to figure out the logic behind a piece of code. Bad programmers will be bad programmers in every language, and come up with solutions that are not solutions at all, or broken or overly complicated; if you give these people C++ they can really make your life miserable if you are unlucky enough to have to work with them. With Go, their potential to do damage can be slightly reduced because the language doesn't allow you to play the "smart ass" card. 
This is some rich satire. ...right?
I've been playing around with something similar but pure Go. Using a little wrapper around [gred](https://github.com/PuerkitoBio/gred), I can write tests that use Redis without needing Redis installed like this: https://github.com/guregu/rediscache/blob/master/cache_test.go#L19
Quote: &gt; Go: In our last rankings, it was predicted based on its trajectory that Go would become a Top 20 language within six to twelve months. Six months following that, Go can consider that mission accomplished. In this iteration of the rankings, Go leapfrogs Visual Basic, Clojure and Groovy – and displaces Coffeescript entirely – to take number 17 on the list. Again, we caution against placing too much weight on the actual numerical position, because the differences between one spot and another can be slight, but there’s no arguing with the trendline behind Go. While the language has its critics, its growth prospects appear secure. And should the Android support in 1.4 mature, Go’s path to becoming a Top 10 if not Top 5 language would be clear.
Well, not knowing what you want to do with Card, it makes sense that any type can implement it. If you wanted to do something special with it, then you'd specify that in the interface. Like if you wanted your library sometimes to tear cards in half, you'd put a `Tear() error` method on there or whatever. Having types print themselves with strings (and incidentally having them satisfy the `fmt.Stringer` interface) can be very useful. Check out what happens when you print various values of os.FileMode. I understand that this is just an exercise in getting used to interfaces, but do bear in mind that it's usually better not to over engineer things. In real code you'd probably just run with whatever gets the job done. You can always add interfaces later.
That is something I would love to see. 
Actually this is working code and was when I first posted, but at that point quickly hacked out to without worrying about interfaces but "just getting it done." Feel free to check out what I'm doing at http://github.com/frenata/gaga, I mainly refrained from that because the "my first go project" posts on here can get a bit tiresome. Felt like I needed a bit of help with adding the interface abstraction so that the Deck struct and methods surrounding it could remain useful for various other card games than the one I implemented first. You're absolutely right about types printing themselves being useful. For a while I didn't have that in the Player interface and printing the name of the player was clunky, with type assertions since the data was coming back from an interface. After adding String() string, boom! Way easier. :)
I had this as Show() for a while before realizing I could accomplish much the same effect with greater benefit besides by simply making it String() string.
I found the code but it's kind of messy and I purposed it for use for martini, I was utilizing the layout but I needed to be able to do sub-layouts. I've used it on a few projects and works perfectly as needed. I'lll map out how to use it in martini, and just using the standard html/template library.
if debug { if foo != nil { panic("bug") } }
i wonder if the absence of a lot of questions might be a good thing... ;)
I am looking for something a bit more idiot proof. I will just end up forgetting to set debug.
But it doesn't have generics!
 const debug = true func Assert(expression bool) { if debug &amp;&amp; !expression { panic("assertion failed") } }
There's two basic solutions. First, it is permissible for the test code to declare a different package than the rest of the module. This will give it only the public, external access that the rest of the world has and you will no longer be able to penetrate the public interface. Alternatively, and the one I prefer personally, take advantage of learning how your test code violated the interfaces badly, and learn how to structure your code to avoid that. Of course you can often violate constraints if you directly manipulate private members, but if you find yourself violating constraints by the order you call functions in, that strongly suggests the functions themselves may not be correctly factored. If you find your test code still desiring to reach behind the data curtain and do something sorta kinda like what the real code does, often there's a way of harmonizing the two so the test code is still just calling functions. The ideal is probably to do both; start with the first and learn how to fold in the second. Personally I get a lot of mileage out of being able to test the internals of a code, because I do not want "what I need to test the code properly" to automatically be converted into "an external import". I also find myself often thinking of the code in three layers; the external interface, the testing interface, and the "private" interface that the test code shouldn't touch. YMMV. But ultimately I don't think there's a royal road here. Keep finding these problems, keep fixing them, and you'll just get better until eventually you realize one day that you haven't had this problem in a long time.
My thoughts exactly. Languages above the line are probably the ones that are the most nuanced and hard to grok.
How do you run your tests?
The killer feature of html/template is that it always automatically does the correct escaping depending on the context. Its security model is based on this paper: http://js-quasis-libraries-and-repl.googlecode.com/svn/trunk/safetemplate.html#problem_definition
I added a basic TOML support for configuration
There's no standard solution to this problem.Bear in mind that if the JSON decoder decides anything in that "garbage" appears to look like JSON you may get extraneous messages or lose them. If there's anything you can do about that stream, you should, even if it as simple as guaranteeing that it will never have [ or { in it. (And maybe a few other things.) You shouldn't have a problem with memory leaks, because if the underlying stream is endless it must be doing some sort of streaming in there, and prepending it with a byte via the multireader will have little effect. Edit (4 hours later): After further pondering I see what you mean about leaks, and I was only right by luck that you'll get no leaks with your plan to reimplement. If you use a combination of `[:1]` and `append` in your re-implementation; when `append` decides to reallocate due to the capacity of the underlying array running out, it will only copy the Readers in the current slice into the new array and re-point the slice to the new array. At that point, anything in the old array will be eligible for GC if nothing else has a reference to it, and those no longer pointed to by the new array will get GC'ed.
go test
I tried, but it requires 2 fields, not only username * 2015/01/15 23:31:33 sql: statement expects 2 inputs; got 1
I'm currently learning go and to be honest it's one of the smallest languages you'll ever use. It's so simple yet powerful. Also the documentation on golang.org is pretty great. So many questions aren't necessary.
thank you, I pushed it now and gave you credits
sorry just go to til now
don't worry, avrtno fixed it, check latest commit
Well, this would have been useful when I was moving stuff around last week. Course, that will happen again. Glad to see it.
I also recently bumped into a similar situation with json.Decoder...see this stackoverflow.com post for some more details. The gist of it is that this can't be avoided because json.Decoder will always do buffered reads and will very likely read additional data past the last delimited "}". The thing is, if you read a continuous stream of messages it all just works but if you read a finite number of messages you could very well have additional data left over in the Buffered() method. Using the technique in this post demonstrates how to utilize that data if need-be. http://www.reddit.com/r/golang/comments/2sjo6m/decoding_json_streams_with_some_garbage_and/
Nice! Go Go!
[Changelog](https://github.com/golang/go/issues?q=milestone%3AGo1.4.1)
firk said "Car and Garage", not "Person" : http://play.golang.org/p/5oXz5nWtGI If you serialize just the refid of a Driver, you need to have some way to fetch back the driver from its refid (database call, mapping ...)
We are actually hiring a Go developer to work on our monitoring and devops tools, so if you want a private office in NYC you can apply [here](https://careers.stackoverflow.com/jobs/39983/developer-site-reliability-team-stack-exchange) :-)
Let me know if you guys like these articles with the real-world tests or not. I don't want it to seem like spam, but I know a few of you enjoyed the previous one where I used Gin which is why I did a follow up. Thanks!
You asked for input: I am not sure how fair the Heroku setup is to what a normal server would be. I've seen countless blog posts about the differences in speed from a VM with 512 MB and a dyno with 512 MB. It may be worth pointing out to readers. Also I think there are better ways to both measure and layout your benchmarks besides reading from a heroku dashboard and inserting into a narrative paragraph. Also just as a side note I found a few phrasing situations where I couldn't tell whether you were saying things were faster or slower. Disclaimer: Maybe these things are just me and I'm a grumpy old man. Edit: Clarification
I appreciate the feedback! I've definitely noticed that performance isn't as great as it would be on Linode (that's where these apps used to be hosted) but there is a huge benefit of no server maintenance which is what we were aiming for. I agree, there are better benchmarks, and I will continue to explore those options. Like I had mentioned, I don't have 100% trust in the Heroku platform as far as how accurate their data is, but I'm basing the data versus other Heroku data and same setup, so the benchmarks are equal in that regard. I'm not the greatest writer, I speak the majority of the time in if statements, functions and loops. Part of this project is for me to become a better writer, because I believe it's beneficial for me to think out the process of what I'm doing and be able to look back in a year and hopefully say "Man, if I knew then what I know now". Again, thanks for the feedback!
Yeah, same thing happened to me. It was a bit confusing that they rolled back the hg repo.
That's the point. TL;DR: You'll get better performance from a VM/VPS. Heroku may be nice for people who can't be bothered with configuring a server, but in the same stroke *you can't configure your server*. (At least, not with the same amount of control) This is probably my largest issue with it. There are many others such as their performance numbers are very different than what's actually measured, your assets waiting in a queue, how things are routed, and many more. If you really want a long read on it then check out this: http://genius.com/James-somers-herokus-ugly-secret-annotated 
&gt; http://genius.com/James-somers-herokus-ugly-secret-annotated That's alright. Take a look at the article I posted in another comment. I would be wary of taking their numbers as "the word," particularly the part about the numbers. 
Yup, I remember when that came out. I'll have to review over it again, but we're definitely not at that scale yet. This app is running on 3 dynos. It looks like based off the comments, the guy is talking about using a least connections algo rather than a round robin or random as far as sending requests to dynos. The issue is, because these dynos are VM's in a VM, they COULD be doing a least connections to the parent VM but that may mean that the dyno is backed up. We're not in a position to move, and I've looked and there's nothing really out there comparable unless I use docker with Amazon Beanstalk. That could possibly be an option, but right now we're happy as-is.
gowalker.org is a website. It does not have access to your GOPATH.
https://github.com/avelino/awesome-go#embeddable-scripting-languages
heka (https://github.com/mozilla-services/heka) embeds a lua interpreter for custom behaviors, so there is some precedence to what you're trying to do here (using lua).
There are also [Duktape](https://github.com/olebedev/go-duktape/blob/master/README.md) bindings [available](https://github.com/olebedev/go-duktape/blob/master/README.md).
It might be pretty easy for me to have an uninformed opinion about it, that's correct. I chose to make use of the online community to further my understanding about a subject I have little experience with and benefit from the experience and insight of other people. If I were to have the good fortune of working alongside Go developers, I'm sure I would have asked one of them the same question in person, hopefully followed by a more helpful reply.
In theory you're right, in practice you're wrong. If you see no difference between godoc.org and gowalker.org it means you don't need extra features of the latter. These are taste matters, how come other opinion can influence what you'd like more?
It's up to personal preference. Use whichever one you find most useful, or both, or neither. godoc.org is just an app for viewing Go doc comments and searching for Go projects. gowalker is the same but with more bloat. My preference is godoc.org because it's less bloated and works properly without JavaScript enabled. Also godoc.org is [maintained by the Go team](https://groups.google.com/forum/#!msg/golang-nuts/_rbVuzl-OqA/N_xoNaD4kAoJ).
O I hadn't seen that library thanks for linking it. It is an interesting way of representing what would normally be a hex or base64 string.
It's not idiomatic for Python or Ruby either. It was stupidly copied from Java. Finally we're starting to see it dissolve.
You may also want to consider specifying a simple API that allows an external program to connect to a socket to your Go program and receive "jobs", then implement job handling in the target scripting language. Unless you've got a really good reason that these scripts _have_ to be in-OS-process with your Go code, you probably shouldn't worry about that; adding that as a requirement really limits your options. Working up some socket communication in JSON is usually pretty simple. This also minimizes your commitment to a given scripting language, if you find your users prefer another one later. (One protocol I like is "length-delimited JSON": Four bytes in network order of "how much JSON you are about to receive in bytes", then that much JSON. It's a simple, but powerful, protocol, that is very easy to implement in a huge number of languages.) Also, if you are worried about performance, watch out; those scripting languages are _slow_ and it literally doesn't take much for them to end up being 100x slower than Go (with just a bit of bad algorithm on the scripting side)... and I'm basing my number off the "real" JS interpreters, an interpreter implemented in Go without the man-centuries of optimization done for JS will probably have its _opening bid_ at several hundred times slower than Go. (Not a criticism of otto, it's the nature of the beast.) At that point it takes an awful lot of workers to make up the difference. You might find [this comment and the attached story](https://news.ycombinator.com/item?id=8901983#up_8902739) enlightening. Or, failing that, at least interesting. I don't know your problem so maybe you really do have terabytes upon terabytes of stuff, but it'll be good reading even so.
Along with ThommasWooD's comment, I really have no idea what you're talking about. godoc documents everything in the GOPATH that is set while running it, too. That's why I've frequently advocated to people that they run it locally and prefer it to golang.org, because in addition to always being guaranteed to be the same version of the Go core library that you are running, it also documents everything on your GOPATH which of course golang.org does not.
I guess what I am trying to do goes with that comment's "spirit", I am trying to limit the dependencies as much as I can, and have the code be as straightforward as possible, but I still need some dynamic user-defined processes. If Go had dynamic linking I'd just do a plugin system, but since it doesn't I have to resort to some sort of scripting language. Even if scripting will have a performance hit, it won't matter that much, since the reduced data will be cached and won't need to be recalculated. You can only create or delete a map-reduced specified by a user.
While I applaud the "outside of the box" thinking, this seems like a huge anti-pattern.
That format should be ["2006-01-02 15:04:05"](http://golang.org/pkg/time/#Parse)
You don't need to "concentrate" on the servers/database. You can set those up in a day, save yourself an incredible amount of money, and get total control of your system. And relational databases don't scale writes unless you do application-level sharding, which is very difficult. Hosting on Heroku is never cheap.
I find the way Sourcegraph does things interesting. They try to make interfaces for common operations on items and reuse them throughout the different layers (for a simple web app, you might not have more than 2 layers). Check this for a proper example https://github.com/sourcegraph/thesrc Also, you might want to read https://sourcegraph.com/blog/building-a-testable-webapp
Thanks you! really useful!! ;)
Create a simple "framework" and let user write those programs in Go. It should be really simple.
The answers suggest that this is likely to be a problem related to face normals, not go. I think this post is in the wrong subreddit. 
Maybe.. but I wasnt sure.. maybe it is a bug somewhere in gosdl or go opengl because my the vertices are CCW so everything theoretically should work??
You've enabled depth testing, but aren't clearing the depth buffer. Not sure if that's the whole issue, just something I noticed.
Very nice! Admittedly, I actually initially read this as "OpenStreetMap API", and thought "Wow, that's kind of neat but something I'd probably never use...". It wasn't until I read the project's readme that it clicked that this was for OWM. I can definitely see myself using this in some stuff! The only small issue I've seen so far is that it doesn't make use of net/url's QueryEscape function on the locations, it seems. I actually assumed net/http's client request functions would do this automatically but I guess they must not. For example, this will work fine: w.CurrentByName(url.QueryEscape("Port Huron, MI")) However, doing just this will not: w.CurrentByName("Port Huron, MI") Interestingly, it seems like OWM's API does make some exceptions on requiring escaping for more popular city queries such as "San Francisco, CA" or "San Antonio, TX".
thanks. I did try both with the depth buffer (plus clear) and removing depth buffer entirely. Still no luck :(
gof was written after a very early release of fzf and therefore has only a small subset of features. http://qiita.com/mattn/items/edea1be5a6d84663ab8b#1-4 
Yes, I will follow some examples. Thank you so much for the basics and concern :)
This sentiment is silly. Web browsers aren't difficult to write and don't require 5M SLOC (very few things require that much code, and I'd argue that chromium's codebase doesn't either) to work fine and demonstrate the principles of web browser layout engines and web browser engines in general. Take for instance: Servo (rust) https://github.com/servo/servo/ 3S (haskell) https://hsbrowser.wordpress.com/3s-functional-web-browser/ LURE (lua) https://github.com/admin36/lua-LURE Weasy (python) https://github.com/Kozea/WeasyPrint I don't think anybody's implemented an engine in Go, but it's simply a matter of time.
General hint for newbies. Try things out on the playground. https://play.golang.org/ For example cut and paste to original suggestion and Run. Then replace the original date format with "2006-01-02 15:04:05" and Run. Finally use time.RFC3339 as the Format() parameter and Run. Do some research to find out why they are different. You'll learn about Playground quirks and RFC3339. Then decide which suits the needs of your program. 
Yeah, sorry, that's what I meant. So the stats you refer to about req/sec, is it finding a video and playing it? Curious to know what the average logic is in each request.
I'm planning to rewrite my Negroni-Boilerplate using your library :)
Logic is minimal, the meta data and information is stored in a DB and data is stored in a persistent in memory cache called "go cache" I'll probably eventually upgrade that to use redis in the future, but the nice thing about go cache is I can save structs and load data mapped directly to a struct. Saving it to redis I have to save the struct as JSON to redis and unmarshal. Not a huge deal but go cache is a quick alternative for smaller scale. The meat of the app is an inbound redirect URL which routes traffic server side to content of our choice.
Interesting experimentation. Keep up the good work and good luck.
FYI, this is not my work -- just sharing a link
Hey, I just decided to pick up GO this weekend. [Here](http://astaxie.gitbooks.io/build-web-application-with-golang/content/) that I found from digging through old posts on /r/golang. From what I could tell from reading comments on posts that reffered to the book, it is highly recommended. I just began to skim through it and it seems good, but I am probably going to use another resource from [this list](http://dave.cheney.net/resources-for-new-go-programmers) to quickly learn about some of the constructs of the language that I am not familiar with (i.e. maps, structs, slices), since the first and second chapters of the book just go over the GO language. 
I apologize for any vagueness, I just woke up... Data being referred to as an interface is actually referring to a small header of sorts, and though the underlying data is nil, the interface itself is not. If you change if m["data"] == nil { to if m["data"].(*Data) == nil { asserting it to the Type *Data will follow the path you were expecting - namely, it will report that the data is nil.
Worth linking to: [Why is my nil error value not equal to nil?](https://golang.org/doc/faq#nil_error).
Nice idea.. i will start searching other posts.. Might get overview that how others learnt it.. Thanks for the list :) and Happy learning time mate..
This project - "Conception" is an experimental project, looking for ways to make software development more efficient.
I'm not seeing the portion of the project written in Go. It looks more like an IDE for writing Go. 
Or - if m["data"] == nil { + if reflect.ValueOf(m["data"]).IsNil() { If you need to work with interface{}.
How about the [go tour](https://tour.golang.org/welcome/1)? Perhaps that's not enough like a real project to work for you; towards the end it gets into concurrency and composition of interfaces, and even has you write a web crawler. I found it fun when I started learning Go.
I played with the dom framework and I really like it, but the Canvas interface is missing a drawImage method and there's no equivalent for requestAnimationFrame. I also wanted to use a few non-native Go imports as possible. 
I see no reason why not. Android 4.4+ uses Chromium for the WebView component. Just follow the same template the project, then embed the html, js, and js.map files into your app. Display the html with in a WebView.
I never figured out how to add an ico to a Go binary, this sure makes it a lot easier. Well done!
I just wrote [this guide](http://www.dougcodes.com/go-lang/building-a-web-application-with-martini-and-gorm-part-1). Martini is a great introduction into web development because it handles a lot of the heavy lifting for you. I'm getting more into negroni/mix which is similar but requires a bit more work on your end to create apps but the output is more performant. I'm going to soon write the same guide but use negroni/mux and not use gorm (an ORM which helps simplify communication between your application and MySQL database). I build web apps in golang all day long professionally, let me know if you have any questions!
Thanks jerf. Yes there's an impedence mismatch between json and our increasingly relational like data objects in Go. We don't control over the JSON schema used for the messages so firik and legec recommendations seem the least worst at this point.
You just helped blow my mind. I'm new to both Go and JS, heck, new to web development in general. In my mind, I would be using JS and web sockets to connect to a server running Go. This however creates a whole new level of WOW for me. What are the pros and cons to using GopherJS? versus just writing in JS 
Disclaimer: This is just from glancing at both websites. These two projects are vastly different. Inspeqtor is a small program you run on a box to monitor and send alerts. It is configured with a "simple text" file. That sounds great, but often you don't know where to set the thresholds for your alerts. You also need to update the config on each box, which is a pain if you have a lot of boxes. The Boson sub-project scollector would be roughly similar to Inspeqtor. But instead of alerting, it forwards the data to Bosun. Boson has a web UI where you can view graphs of your data and set alerts interactively (while looking at history that tells you how close to the threshold you have been getting.) So it's a replacement for Graphite, plus a replacement for clients like collectd. Only the data is stored in a time-series database (one that is robust and scales due to the HBase back-end.) So if you have 1 or 2 boxes, Inspeqtor might be useful. But if you're doing things at scale (10's to 100's of boxes), Boson will be a *lot* more useful.
Thanks :-)
How bad are the garbage collection pauses?
No, I meant on native desktop builds... personally I avoid GC'd languages for any kind of game, especially on twitchy retro-esque 2D ones, because it's basically impossible to avoid dropped or delayed frames due to GC.
No there's no technical difference in this regard, and frameskipping is unpleasant in any game. It's just that 2D twitch platformers generally need tighter controls and concentration than most others, so it's especially intolerable in such games.
I see. Anyway I've not cared about GC too much (The first priority of Ebiten is to develop game easily). I'll create torture test later. Thank you. FYI: Go developers are trying to make time limitation for GC: http://www.reddit.com/r/golang/comments/2cwer8/go_14_gc_plan_and_roadmap/
Well as long as the garbage collecting doesn't lead to dropped frames then it doesn't matter if it uses a GC, which in turn depends on the amount of work the GC has to do. So if you avoid creating a lot of 'garbage' during gameplay then the GC pauses should be small enough not to cause frame skips, I know XNA games often used to allocate all game objects up front and reuse them during gameplay in order to avoid the GC kicking in (which was very bad in the first generations of XNA). Of course with the work on reducing GC latency slated for Go 1.5 this might not be that much of an issue after that release: http://llvm.cc/t/go-1-4-garbage-collection-plan-and-roadmap-golang-org/33
Fair enough. Unfortunately the only guarantee they intend to provide is a pause of less than 10ms. That's already most of a 60hz frame and well over a 120hz frame, so it doesn't help with the framedropping problem.
&gt;So if you avoid creating a lot of 'garbage' during gameplay then the GC pauses should be small enough not to cause frame skips, I know XNA games often used to allocate all game objects up front and reuse them during gameplay So basically you have to fight the language to have performant code... &gt;reducing GC latency Unfortunately the only guarantee they intend to provide is a pause of less than 10ms. That's already most of a 60hz frame and well over a 120hz frame, so it doesn't help with the framedropping problem.
I'm not exactly sure why you would use Go if it was a performance critical problem (coming from ruby). Ruby already has the capability to do C and C++ bindings. If performance were an issue, why not use those and bypass all the overhead of JSON serialization, spinning up new processes, and general system IO. Go is good language and everything, it just wasn't made for being embedded into scripting languages. C/C++ or even Rust do a better job at that. Go just isn't the right choice for this sort of a problem.
Any story behind the name? Seems odd :)
I'm afraid there is no story. Ebiten is a Japanese word which means tempura of shrimp that I like :-P
I like this.
While I like Go, this feels very much like a hack. A fun hack, but not something that should probably be done for a production application. Personally, I'd look to Rust instead of Go. [Here](http://blog.skylight.io/bending-the-curve-writing-safe-fast-native-gems-with-rust/) is a nice write up. If find Go easier to write, but Rust is still fun and better suited for this.
I wrote an sFlow decoder for [gopacket](http://code.google.com/p/gopacket/). I didn't have access to sample data for all the different types, but it should decode most of what you're likely to see. It's not a complete collector, of course, but it's a start. :)
This will give you the performance of CGI. Ick. And why use 'go run' instead of actually compiling the compiled language? 
Doesn't this also introduce a race condition, the `err` here isn't guaranteed to have any particular value at all (what if you have other deferred statements, perhaps that raise their own errors). Whilst this may work, I would suggest that relying on a shared variable from the parent closure is a bad idea, at least you *are* guaranteed that that enclosing function's stack frame is still in tact, but you really ought to think carefully about why you are doing something like that.
GC pauses are driven by allocations. I don't see why most games would do a lot of allocations during gameplay, particularly not the kind of games that you'd make with this toolkit.
What a fun little library! :) A small experiment just to try it out: http://data.gopher.se/js/plasma/ Any plans to support drawing an image.Image “directly” to the screen?
I would've totally appreciated a pull request adding those methods ;-)
thanks for the feedback, I am glad it was useful.
I run user Lua scripts from Go using the C API (could easily be LuaJIT), and also load Lua modules written in C++. I took a look at https://github.com/aarzilli/golua but it had too much complexity just to transform the Lua C API to a more Go-like syntax and add some helper functions. I just: /* #cgo pkg-config: lua #include &lt;lualib.h&gt; #include &lt;lauxlib.h&gt; #include &lt;stdlib.h&gt; */ import "C" and then I have 2 helper functions, one to pop Lua errors and return as the Go error type and the other to load and execute Lua code passed as a Go string.
Thank you for trying! Wow, amazing plasma! Did you use a color matrix? &gt; Any plans to support drawing an image.Image “directly” to the screen? What does 'directly' mean? Isn't image.DrawImage enough?
Rust is neat for sure, but I wouldn't touch it over Go unless I knew that I would need to optimize beyond what is easy to do in Go.
sorry... hopefully soon I can start experimenting with more gopherjs+dom stuff.
The plasma package (sub packages really) use the go-colorful package when generating the palette It seems to work OK to use NewImageFromImage on each frame, I was just wondering if you had any plans on supporting drawing individual pixels (might not make sense to support that though)
Would this be useful for articles or content as well? For example, if I write an article and I update it, should the key change for that article? Is an md5 hash an acceptable way to generate a key? I'm thinking of doing a concat of the article ID and last update timestmap to create the key.
I linked this a couple of weeks ago. I added a quick three minute video to give an overview, so I wanted to share it one more time. I won't share the link again unless I add a big feature.
Since the Etag is used to answer questions like "should I download this again?", then yes, it should change if the page content changes. I use MD5. It's broken as a crypto hash, but it generates OK Etags.
It is, but calling `go run` from the shell is not the right way to go about this.
This is the first I've seen the date published. Marking my calendar now.
Cool &amp; thanks mwholt :) I'd love to make a GUI down the road to handle the file. I also wish I had known about the go generate tool earlier in development.
go build. It is a great tool for building a single application, but multiple binaries requires some shell scripts (Added bonus, you can't really use make because go build hides the dependencies.)
It sold out 750 tickets last year. They've doubled the number of available tickets for this year. 
**edit2**: I retract my "dislike", based on the following post: http://www.reddit.com/r/golang/comments/2t28vi/what_do_you_dislike_about_go/cnv36iq Error type checking. I actually *love* checking for return errors, as that is the method i preferred in my Node development and how i designed my node libraries (to return an error, etc). But ~~casting~~ asserting in go is not the most graceful thing, and as a result trying to understand what an error is, can be quite painful (imo). I honestly feel like i'm doing something wrong, because it seems so oddly designed, but every Go developer i've talked to has confirmed that i am doing it "right". I'd love to see improvements here.. some type of nice SwitchType and automatic type ~~checking/casting~~ assert: switchtype err { case io.EOF: // ... case FooError: // ... case BarError: // ... } That of course is just a pipe dream, but it would clean certain areas of my code up considerably. **edit**: And as an example, this is the sort of code i have a problem with: if err != nil { if exiterr, ok := err.(*exec.ExitError); ok { if status, ok := exiterr.Sys().(syscall.WaitStatus); ok { log.Printf("Exit Status: %d", status.ExitStatus()) } } else { log.Fatalf(err) } } This is a standard library example of getting an ExitStatus from a Command. This is not too bad, but it's made worse when you start implementing your own Error types. And to be clear, i'm not claiming that this is a huge problem. I'm not saying Go is doing something wrong, nor that i am doing it right. I could be doing it entirely wrong (as i mentioned already). This area of Go is just not obvious to me, and it makes identifying Errors difficult for me.
There isn't much I don't like. I think most folks are wrong about the list of stuff they say they need. Short list of things I don't personally like: - Lack of version standard for libraries. - The inferred method for parsing datetime from strings seems prone to errors for odd dates. Everything else in the language is low level, why not let us be explicit? - Importing directly from version controls feels great at first but what happens in 10 years? I think this combined with a lack of a version standard is going to be a growing problem for the community. - ~~JSON RPC library doesn't implement the standard correctly. You have to look to the Gorrilla library for that.~~ A few other things but overall my dislike list is short, the issues small and most aren't a big problem. I do think we need to get a handle on versions and imports sooner rather than later.
I feel like any current scripting provides provisioning just fine, what do you feel like ansible/puppet/chef/bash is lacking? I would really hate to see something like maven emerge in Go. I do think we need proper dependency version and the issue with chained dependencies is a good one as you say here.
amqp driver implementation is merged to master.
I think he meant *asserting*.
 - the way the regex match works - the lack of generics and the type switch - i just want to put two animals types in an array - crashing on what used to be exceptions, out of bounds calls - to read json from web you have to make a struct containing all the fields (actually there is a way around this but its a pita too) - time.Sub(type Duration) vs time.Add(type Time) - theres no reason cryptographically safe random numbers should not be available in 1 line of code from the stdlib - a, err : = stuff(); b, err : = stuff2() causes an error b/c of the re-use of err - no underscorejs feature-set 
Well, it ~~doesn't~~ does automatically type cast the err variable, ~~but~~ so this works: switch err := err.(type) { case io.EOF: // ... case FooError: // ... case BarError: // ... } **edit**
I find that Go lacks some features that improve code correctness, and this is demotivating me to use it for big projects. It doesn't need to be perfect, you can have good practices using an imperfect language (hell, I still use PHP), but I wish Go would do a bit more to ensure good habits and help write maintainable, elegant code, since it really seems positioned well for that goal. That said, I like that Go gives us at least a memory-safe language that I can wrap my head around, so I'll definitely keep using it! * nil: It's a shame that almost anything can be nil. Manually having to check for nil everywhere litters the codebase, and causes risks that we forget a check and crash the application at runtime. Something like std::optional&lt;T&gt; or Option&lt;T&gt; is an elegant way to get rid of a whole class of null-related bugs. It's best if the compiler complains if you forget to handle the case where it's null, like Rust does. (I know there are some situations like I/O where you can get an error as well as a result, but in practice most Go code doesn't check this, and this particular situation could then be handled through a custom return type. But the (result, err) convention is so deeply entrenched in Go that I'm afraid this will never be changed.) * Lack of map/filter/etc operations. I don't do a whole lot of "functional" programming, but these are simple concepts to read and they would have made much Go code easier to understand. When I read code with a for loop that does the same, I really have to squint and watch the loop conditions and code very closely to ensure that it does what I *think* it does. * Every variable is mutable. You can't even set an immutable variable at runtime, only a compiled static const! Immutability can prevent a whole class of bugs. Immutability by default is even better. * Yes, I would definitely appreciate generics, but I haven't suffered too much from it, since I'm mostly creating end-user code and not in the business of creating reusable libraries. But still, I cringe a little bit for every interface{} that I write...
When you range over a slice, you get a copy, not an alias to the underlying item. Coupled with the fact that there is no error or warning for calling a mutating method on a temporary copy, this means that you can have "non local" problem code. e.g. 1) write a method which takes a non-pointer receiver, e.g. to calculate summary data of a Foo. (This is reasonable) 2) write a for loop which ranges over a slice of Foo, calling this method to get the data (this is reasonable) 3) Update the method to cache the expensitve summary information, changing the method from a Foo receiver to a \*Foo receiver (so you can store the cached info). Everything *compiles* and *runs* and passes functional tests, but your speedup from cacheing the information doesn't materialise in loops :-/ Yes, to be careful you can check *every* callsite of your method on Foo to make sure it is never called on a temporary. But that sucks and it's the sort of thing you don't want to have to do in a statically compiled language. I'd prefer: 1) make the range variable an *alias* for the underlying slice item (a la perl for loop) 2) give a warning or error when: a) a method takes a non-ptr receiver and writes to it (such methods should be c++ 'const' like, or we should get an error) b) a mutating method is called on a variable whose value is not read Example problem code: https://play.golang.org/p/7JJDPi-UdM
You can build multiple binaries at the same time pretty trivially. If you put them under the same tree, you can do `go build ./...` from the root of the tree and it'll build everything under that directory.
No one mentioned this one yet: There is no clear, ideal way to make a permanent long-lived daemon using Go. Everything I've found looks like a hack. A single unhandled error bringing down the whole thing? Something like OTP for Erlang would be nice.
[10% of Super Early Bird tickets sold](https://twitter.com/GopherCon/status/557594964096733184) just 23 minutes in. Don't wait.
Now that you mention it I hadn't noticed the go doc bit. I just looked at the code to see what they did I guess.
Yeah, prevailing wisdom seems to be use a supervisor system to restart it. Not ideal, but it also adds a bit of simplicity to your app itself. I'm coming from windows services in .net where the app has to know at a very low level how it is being hosted in the service manager. Letting my app be agnostic to all that and managing it from the outside seems refreshing in a way.
I hate how interfaces are incompatible with arrays, slices, maps.
Yeah, this is a little scary. I've just made it a practice of always using defer to clean up and close down, and include a helper routine at the top of every goroutine that catches panics and logs their stacktrace.
How do you handle collecting the binaries? With my bash concoction I just specify each package destination with -o
It's worse than not ideal; it's a bad idea. If your system is servicing 10,000 requests and one fails, it is not a "solution" to crash the whole process and restart when you just needed that one request killed. If your Go program is anything other than some sort of essentially-single-threaded service you can't lean on an external supervisor. (That is, of course, a legitimate Go use case in which case you can; the "if" in that sentence is not extraneous.)
Even acting like you like generics or might have a use for them is enough to have Dave or Andrew, (sometimes Brad) condescend you out of existence. Otherwise, it's great.
The moment that I stopped forcing python/C++ idioms on Go, I started enjoying it. However I wouldn't mind: - Default values for function arguments plus named arguments in general (we already have them for creating new `struct`s) - (not directly related to the language itself but) a good debugger and a native desktop GUI toolkit that's part of the std lib.
You're point about reusing err values is not true. See here: http://play.golang.org/p/VVu3EJiRnZ
Huh?
Could you explain a bit more about the Option&lt;T&gt; approach? In my (very limited) experience with Rust, it does not reduce the error checking verbosity much, because you have to either: * use unwrap(), which the compiler does not complain about, and which can panic at runtime due to a None; * use match to match the Some(data)/None cases, which is equally verbose. 
And to their fairness, trolls have latched onto it as a rather ignorant sweeping criticism of Go. I know they have solid intentions regarding the direction of Go, etc.
Do you mean something like this: http://godoc.org/github.com/kardianos/service ? I think you mean "un-handled panic". True, but log them and let the OS service manager restart for you. Then fix them. Errors should be common. Panics not so much.
i think he means this []string is not compatible with []interface{}
* Libs version pinning and management like Gemfile and Gemfile.lock * You have to use Godep which I really do not like that it is not embedded into the toolchain * I think they should put more stuff into stdlib like yaml, ssh etc.
It's best to think of Go as a better C. That makes it a lot easier to accept some of the decisions the designers made. The biggest issue is the complete inability to specify library versions, which means that like every other language we'll have to re-invent the wheel. The lack of generics is not as big an issue as it first seems, because there are a lot of situations where you can shift your mindset a little and define an interface instead. But it is a real issue, because when you need them you REALLY need them (when implementing all the data structures the language leaves out, like trees and sets and graphs and sparse mulitdimensional arrays and variations on lists and maps with specific performance characteristics). I mean, you can work around the lack by using interface{} everywhere but then why the hell are you using a statically typed language in the first place? Again, you can work around it, but the lack of localization support in the core is a pretty big issue for those of us who live outside the USA (try parsing a Hebrew or Julian datetime, for example - the latter is pretty important for astronomical algorithms).
lack of code reuse. it needs at least one of {generics, subclassing, macros} I don't like the inside-out pattern of making my type fit some interface and then something like the heap standard library package can heapify it. That doesn't fit most of the ways I want to think about code.
&gt;max &gt;most &gt;likely &gt;less I'm aware of this, but games kind of need NO unpredictable pause time. (It really does depend on the game, though. If you're making flappy bird you could write it in pretty much anything and get 144fps.)
I'm not sure this answers your question but my major dislike about Go has been the reaction of other programmers on Reddit. It's a neat language that's fun to write stuff in and has some great features. However, most of the Reddit discussion I have seen has been complaining about a lack of generics (I've never needed to use generics but apparently they're really super important?) or seemingly misunderstanding the philosophy of the language ("It doesn't have feature X from language Y"). I've done some web dev in both Go and Python and much preferred the Go route, and would recommend it to others.
Am i remembering this wrong? I thought i remembered Go using a single ready when JSON-RPC required a socket for large data. I can't back that up with documentation now though so I may not have been remembering correctly. If so strike this one.
&gt; Actually I have yet to find a language that has solved the issue I posted elsewhere in this thread about this; it's a pretty well solved problem in other camps. Take a look at [Cargo](http://doc.crates.io/guide.html#cargo.toml-vs-cargo.lock) and [Bundler](http://bundler.io/rationale.html). Both of these tools handle version graphs over distributed repositories with aplomb, for their respective languages. That said, they're second-class citizens not at all unlike some of the solutions for Go. NPM and Bower do an okay job, but have quirks that I feel disqualify them from the discussion. Most notably: flattening and version pinning are total afterthoughts for both, instead of features called out in the tutorials on day one.
Thank you, I’ll give it a try :)
No Macros (like Rust)
Forking has traditionally been a necessarily in opensource programming. I honestly think that I am missing something because there are successful open source go projects, which somehow get around this problem. That said I don't think source code should a concept of a conical location, nor should it care where it exists.
Could you expand on why you feel Cargo is a second citizen for Rust? At least, it's included in the Rust installer now, so everyone has it available.
generics; not the actual lack thereof, but the constant whining about the lack of generics is tiresome. 
Have written a couple of serious apps with Go now (largest at ~50 packages and ~30k LOC), and would say that Go is in the top 5 or so languages I'm highly proficient in. The two things that I long for the most during development (no surprises here): * Generics, it's really hard to write low level helper packages without it. There are always ways around it but I've had a few times now where I've really had to fight to get around it. * Good dependency management, godep is good but there are still some rough edges (I want to be able to use goconvey to watch tests using godep).
interface{}, it says exactly nothing. So ugly.
languagewise, I like go a lot. Great alternative to something like node.js. However, tooling wise, this is where things get unconfortable for me. The most striking one is managing external dependencies. I can't easily host dependancies in an internal repository Since the all reference external domains in import statements. The other is a lack of a decent visual debugger. A Visual studio extension that allowed go debugging would be great. Third is lack f support for building shared DLLs. For example, I would love to make a python extension in Go.
Oh wow, I was unaware that it was included with Rust these days. 
A non-go programmer's perspective: The reasons I havn't gotten into it: * My impression is the major selling point of Go over Python is scalability and performance, but we already have Moore's law for that. Also, it's possible to optimize the 5% of your Python that's really performance critical with many tools like cython or just write small bits in C. Sacrificing other things for performance (ie, the inconvenience of compiling) may not always be desirable. * Corporate influence - concern that direction could be dictated by Google's corporate needs, and not the community. * Code can't be run in both the browser and server like javascript can. Seems like a very promising language and ecosystem overall however!
https://github.com/hooklift/gowsdl ?
1. Lack of operator overloading. I enjoy the most writing graphics-related things in my spare time, so.. I would like to have them for vector math. 2. Lack of generics. I know it's a hot topic, but really. Would be nice to see things such as LINQ and Rx in Go one day. Which also maybe implies a slightly shorter syntax for closures with automatic argument/return type deduction. Well, goroutines and channels kind of help with Rx part, but still you can't make a generic filtering function or what not. 3. Embeddable runtime. Even though Go is fast and all that, I write my things in C/C++, but would be nice to use Go as a scripting language on top of that. That also implies tools for doing bindings easier.
Two main reasons I like Go: curly braces and the fact that it is open source but not designed by the mob. 
* I don't like that there aren't many numerical libraries written in/for Go. * I don't like the overhead associated with calling C functions from Go. * I don't like that there's no way to turn off array bounds checking. * I don't like that sometimes values which do not escape to the heap are allocated to the heap by the escape analyzer (Admittedly, this not a huge deal if you know to watch out for it and takes less time to deal with than a memory leak does, so is definitely worth it.) * I don't like that some of the library I/O functions do allocations behind the scenes that are of comparable size to the data being read and that the only way to get around this is by using the unsafe package and handling endianness manually. Relatedly, I don't like that the `binary` library uses reflection to read slices of floats. * I don't like that math functions only work on `float64`s. * I don't like that I have to rewrite all my `[3]float32` data structures for `[3]float64` instead of just writing them once. * I don't like that I can't access private fields with the `reflect` package. * I don't like that once I get close to my machine's memory limit, I need to start manually checking the heap size and running `runtime.GC()` myself, since the next GC cycle is scheduled to run when the heap gets to a size larger than what I can actually hold. (Of course, if I had to write this list for C or C++ or Fortran or Ocaml or Python or etc. it would be much, much, much longer, so here I am.)
 * Lack of safe and efficient ways for sharing nontrivial data among goroutines. We still use mutex when chanels are inappropriate, and run into bugs. * I personally don't like the coding style enforced by gofmt. * Lack of debugger. * Lack of embeddable script languages. * Lack of support for Gtk3 or Qt5. OTOH, GC pauses and lack of generics are no problem for me.
You're probably referring to the wiki tutorial on golang.org -- have you tried looking at [the documentation for the net/http package](http://golang.org/pkg/net/http/)? It's quite thorough and has some useful examples.
Just: `interface{}`
To my knowledge, it was always a part of Rust. But the language was changing so fast, the Cargo codebase got out of date and they hired on Yehuda Katz (developer of Bundler for Ruby) to help them get the program in working order. While that was happening, they removed it from the main distribution while it was non-functional.
How about this one http://blog.campoy.cat/2013/12/writing-moder-web-app-with-go-tdd-rest.html
I am waiting for Rust to go v1.0 to really evaluate it. The problem is that it looks like a language with a lot of bureaucracy going on and not much simpler than C++.. so I won't be that sure it'll become popular, I am sure most C++ programmers won't trade their mess for some other kind of mess... I wouldn't. Go has a lot to offer, simplicity, great build system, compilation time, GC, very good performance (as long you stay in Go-land) to attract programmer and managers (ie. easier to grow a Go dev than a Rust or C++ dev). It's a shame (for my user case) it has this wart.
Hate isn't the right word here, but I'm not sure "go generate" is a good direction to take. I fear everyone and their uncle is going to look at code transformation and generation, but the semantics of the transformation are going to be encoded in (verbose) code. Handling generics comes to mind. I think that a "good" macro facility (hygenic, quasi-quoting) would make many code transformations more compact and principled. 
Thanks for linking the godoc search. Had no idea that existed. I do find one of my largest fears is not having control over the repo I'm working on.
There's an eval library for Go: https://github.com/0xfaded/eval It wraps the reflect API for creating new variables, etc at runtime.
Didn't think about popping into IRC and actually asking the devs of the project for help. I don't really have any Go projects that I currently use / interest me. Looks like I'll need to try to find one.
Go could support negative indexes, so we could write slice[:-1] instead of slice[:len(slice)-1] 
You can be completely explicit if you want to format a time: s := fmt.Sprintf("%d/%d/%d", t.Day(), t.Month(), t.Year())
Neat - splitting is pretty awesome.
I'd say func (t *ThingWithDBConn) Get(id int) (t *ThingRequested, error) Does that make sense?
Primarily the tooling. It has everything you could need, but nothing that I want. I'm debugging a line so I comment out a call to some net/http function. "Error, unused net/http import". I temporarily remove modification of a variable. "Error, unused assignment". Thanks for the help Go, now I have to comment out two lines in separate parts of the file. This makes debugging simply insane. And gophers will just say "unused imports are a code smell". Maybe. Let me tell you another way of dealing with this problem: Hey, that Go compiler that's so smart? How about if you hit an import that isn't used, just *don't compile in that import*. Ignore it! Or, remove the import statement for me. Or, give me a debug flag that says "don't be so anal". "Just use goimports". Wait, I thought the Go toolchain was the most advanced thing since sliced bread, now I need to add complexity to my build process just to get around an *opinion* that the Go developers have about compiler design? Along the same lines, forcing me to keep my code in `$GOROOT/src` if I want the tools to work properly. Fuck off. I like Go. And its good for a language to hold opinions about some fundamental ways it works. But Go is opinionated about all the wrong things. Its not that it has wrong opinions. It just chooses the wrong things to have opinions about. 
My current side project assigns a package level variable with the DB object. It works well enough for what I need it for. var DB *sql.DB 
It's okay, but do you pass a pointer to a struct to the Get* functions (perhaps as a receiver)? Or the struct (or pointer to it) is returned by Get*?
No, you're getting the User from the connection. Maybe it'd help us understand what you are doing if you defined the Things a bit more in your examples.
Refactoring. Maybe I am missing something but it doesn't seem easy to do things which are fairly trivial in Java/Scala such as extracting methods, inlining, renaming and much more. I'm using sublime text right now, but it seems in order to "safely" rename something I have to go use gofmt in the command line and the rest is a lot of copy and paste. 
What are you Getting then? ThingWithDBConn is some thing to just hold the connection or session. I assume that when you call Get it's not going to be called on the same type of object you are getting.
Return it. 
&gt; What are you Getting then? I'm getting a Thing by ID from the database. For example: func Get(db *sql.DB, id int) (Thing, error) { row := db.QueryRow( `SELECT id, ... FROM things WHERE id = $1`, id, ) var thing Thing err := row.Scan( &amp;thing.ID, ... ) if err != nil { return nil, err } return thing, nil }
`gofmt -r` isn't really safe. [gorename](https://godoc.org/golang.org/x/tools/cmd/gorename) is.
&gt; parsing datetime from strings Not the other way around.
He talks too slow... 
I think it is actually sane to chase down every place a library is used to change the version number - because you should only change the version number when the API changes, and when the API changes you really do want to check all places where you use the library...
What am I doing wrong? Can't get it to work: package main import ( "errors" "fmt" ) var FooError = errors.New("Bad boy") func bar() error { return FooError } func main() { err := bar() switch e := err.(type) { case FooError: fmt.Println("Bad boy") } } Trying to run/compile this I just get: ./foo.go:20: FooError (type error) is not a type
~~JSON RPC library doesn't implement the standard correctly~~
&gt; db.Get(thing,whatever) This way you need either some sort of ORM or multiple GetXXX methods for all the sorts of things. Am I wrong?
I hear you, but... Any programmer working on a Go project has been in the situation you described, yes it is annoying as hell, but, in return for that pain you get a 100% clean source code.. no "test_a" vars doing nothing left around to clutter the code, no import "whatever" left there just to create noise. Our C++ is literally full of these things, until somebody has enough and starts chasing warnings.. and it's not pretty.
Makes it awkward to set up tests. Not that I have a better suggestion. Its either this or a `type Server struct{}` variable. Dependency injection as in goji isn't bad either but bleh reflection.
&gt; Nobody should have to chase down every place a given library is used, just to change the version number. Shouldn't they? Shouldn't it be explicit? My code works with 5.1. You want to use it with 6.0 ... how do you know it works? It should be explicit so that you know you're not using the version I've verified as working. Have you been to DLL hell? Plus, there are various tools to rewrite import paths, if you need to update an import version (though in general, find and replace works just fine, since the likelihood of there being a string like "github.com/foo/bar/v2/" anywhere but the import path is pretty low. &gt; gopkg.in isn't accessible everywhere Go wants to be. I don't know what that means. If you're talking a corporate firewall, well, blame IT security rules, not me. &gt; from a secure computing standpoint, encouraging a middle-man to sit between you and a reputable source repo like Github, is needless and worrysome. If you don't trust it, or don't want another possible point of failure, you can host your own version of it trivially. &gt; godep, or something like it, really belongs in the Go distribution as a first-class citizen. It would go a long way to fix a whole host of issues Maybe. I really like that the default is "just use VCS and don't break your code". I think it makes go packages a lot more stable in the wild than they might otherwise be. If you find a package you use is not trustworthy... don't use it. Fork it or use something else. 
http://go.lad.nu/post/working_around_insanities_in_the_go_stdlib_and_missing_features_of_the_language/
&gt; we all know very well You're wrong. the community didn't even bother to fill in the ACTUAL use cases for generics: https://docs.google.com/document/d/1vrAy9gMpMoS3uaVphB32uVXX4pi-HnNjkMEgyAHX4N4/edit?pli=1# so if you know any VALID use case for generics, feel free to contribute to the document
Suppose I'm using a physics engine in C, and it's pausing too long- I could find out why (too many allocations?) and improve it (use a custom allocator?).
Read " Programming in Go: Creating Applications for the 21st Century" and "Effective Go" from Golang.org. That's all
I hear you it's easy to hack the compiler to not warn about unused imports and variables: https://github.com/anlhord/go/commit/8917d0ab466f8794c49f184cf3f0c14a4a61780d https://github.com/anlhord/go/commit/b57a22abff3b9857dff933f32f066d1e0b33f77e enjoy the new go experience :D
&gt; Or, give me a debug flag that says "don't be so anal". I think the problem here is that it re-creates the problem with warnings on C/C++ compilers. I believe that Go is deliberately opinionated in this way, and always runs in the equivalent of a "warnings as errors" mode. While this makes Go very compelling as a business language (like a Java competitor that makes it easy for noobs to write high quality code), I agree that it's a misfeature in the eyes of a power user. My solution: provide a fiendishly convoluted trick to disable this nanny-like behavior that's hard to pull off in an IDE. Something like a special environment var, command-line flag, special keyword combo.
Perhaps you listen too fast?
Could the splitting be used to change sql.NullStrings and it's siblings to just return the value? type NullString struct { String string Valid bool // Valid is true if String is not NULL } http://golang.org/pkg/database/sql/#NullString 
The make/new distinction. Seems ugly to me.
I'd rather kill myself in batches of 100. I like Go, but not to the point of being silly. 
I watch all talks at 1.5x speed.
Two problems: * two copies vs zero for a run of go build against a single application. * go install ./... still doesn't solve the problem of knowing the names of each compiled object specified by ... Which goes back to my original point of requiring shell scripting for what I would consider a common use case (e.g. client and server in the same directory). 
The SomeDescriptiveName type should be a interface, right? I would follow the pattern of [sourcegraph/thesrc](https://github.com/sourcegraph/thesrc). This use the follow pattern for access to the database: https://play.golang.org/p/y6yl2v_637 
I disagree on the python comparison. I find coding in go actually faster and easier than Python in that the compiler takes care of so many issues that you would have to take care of with extra testing in Python. Also, Moore's law is sort of stymied lately. We're going parallel instead of faster single cores and python's concurrency and parallelism capabilities are a joke compared to go routines. Have you actually used asyncio? And then used go routines and channels? 
That's really great, thank you for making it!
Before I answer, I want to recommend you read [the code for database/sql](http://golang.org/src/database/sql/sql.go). It's surprisingly readable (like much of the standard library) and internally consistent. When you do `db.Query(..)`, the sql library can take a few codepaths. If supported by the underlying driver connection, an optional `Queryer` interface may be used directly. If the driver *doesn't* support `Queryer`, then a statement is prepared *by database/sql* and then executed. The actual behavior of Queryer will be, by design, implementation specific; the lib/pq postgresql driver for instance will issue a simple text query [if there are no arguments](https://github.com/lib/pq/blob/19eeca3e30d2577b1761db471ec130810e67f532/conn.go#L629-L633), but fall back on preparing a statement. We discovered this recently when looking to use pgbouncer in transaction mode, which doesn't support prepared stmts. This is likely what other drivers do as well, because this offloads argument substitution to the server and thus is the easiest and safest way to avoid injection attacks. Because of all this, the best way to avoid prepared statements is by: * checking that the driver supports Queryer (lib/pq does, as discussed) * not using query arguments (most drivers will probably prepare for this) This isn't necessarily what you *should* do though; as you suggest getting the security right is an absolute nightmare.
It says "an empty interface", which makes perfect sense and is compatible with any other type literal declaration. ETA: it's also anonymous, just like the thing it represents. 
It's a newline.. List of \ characters here https://golang.org/ref/spec#Rune_literals
GPM: https://github.com/pote/gpm
I've seen plenty of dirty Go code, primarily in the realm of commented out "unused" imports and variables. It is superior than the alternative because at least it is clear what is and isn't necessary for execution of the program. But it produces similar cognitive load, because now I look at that and think "why is that commented out, was he going to use it later? maybe I should keep it" 
What I understand is that if I have a string A which I can parse with arguments in B, I should use fmt.Sprint() because it's safer this way than calling simply db.Query(A, B)
Also, fmt.Println includes a newline, fmt.Printf does not
- You're right that there aren't many, but github.com/gonum is working on it - Is calling C faster in other languages (python, etc.)? I don't know, but I've heard members of the go team saying it's about as fast as it can be. - You can turn off bounds checking: "-B" flag. It's unsupported, but as far as I've seen it works (as long as you don't have out-of-bounds accesses of course) - FYI, there have been codereviews in the last 2 hours that improve a large class of escape analysis - How can you can set private fields? I thought you could only set public fields of private data types. I agree that it would be nice if the numeric types were more fungible (similarly with []float64 and float64). Unfortunately, I think that's the price of simplicity.
I use it outside the package in my db migration code. 
For what it's worth, I found that net/http is about twice as fast as nginx for static file serving for at least one use case. In particular, it seems to hold up better under very heavy load,
&gt; What's missing in your case is the actual semantics. What happens after you do Update? What exactly do you update? Does your model re-select from the database? It's not obvious that the data in thing is exactly the same as it's in the database, e.g. due to triggers. Update executes `UPDATE ...` statement. No re-selections. No triggers. But if there were some triggers updating the table, `Update` would certainly need to re-select. &gt; How do you know whether you already called a .Get() on a previous thing? I'm sure you will happen to pass some extra data along with a model to know if it was filled or not. No need to call `Get`, actually. I decode data from the request to a thing, then validate the thing and call .Update. &gt; And what after .Delete()? How do you delete? You could keep using thing afterwards. By deleting the record (by ID), or by setting the DeletedAt field. It shouldn't matter. Yes, I could keep using it afterwards, but so could you after you called `db.DeleteThingById(thing)`. &gt; The difference is: acting on an object like it was the actual database (wrong imo and a huge anti-pattern, there are too many ORMs where anything can go wrong) vs executing queries with some data. I don't see anything wrong with it, if the semantics is clearly defined. &gt; It's also about what you think when reading the code. When I do thing.Update() I expect thing to be in sync with the database. And the database is updated using data from the thing. Or do you expect it to be in sync before? &gt; If I do UpdateThingById(thing) I treat thing as just data. So do I. &gt; Another view point: what if you have X.DoSomethingWith(Y)? So you should also have Y.DoSomethingWith(X)? Instead db.DoSomething(x, y) which will do all the necessary and optimized queries for achieving the task. Well, I can have a simple function for that: `func DoSomething(x, y ...)`. No need for the methods on the DB object. So far I don't see anything wrong with my approach. Besides, if I have methods with the same names on things, I can, for example, auto-generate REST routes for all the things. I can come to some obstacle later, but I for the life of me cannot see why. It's all pretty straightforward.
Gorp's `.Select` accepts `interface{}`. You certainly can do that, but it means reflection, and that's exactly what I meant by "some sort of ORM".
&gt; Currently I produce a list of packages by walking the source tree and looking for directories with .go files. Once I have the list I run go build for each package specifying -o bin/&lt;pkgname&gt;. I also do some checks to avoid unnecessary compiling. So… pretty much exactly what go install does? &gt; Multiple invocations of go build cause multiple compilations of shared packages And this is why go install keeps object files.
Only one way to create a pointer to an int.
(Also, I should add: Go is currently my favorite language by leaps and bounds, I'm actually wearing a Gopher tee right now.) &gt; Is calling C faster in other languages (python, etc.)? I think it's pretty fast in Fortran (not 100% sure for more modern languages). Still, I'm sure that the Go team has made it as fast as it was possible to make it. But I bring it up more as one of the things that I need to weigh when deciding to write something in C vs. Go, and less as a complaint at the language design. &gt; You can turn off bounds checking: "-B" flag. Oh, wow. I feel silly for not knowing this one. Scratch that complaint off the list! (You just shaved six minutes off I job I started running while writing this post!) &gt; FYI, there have been codereviews in the last 2 hours that improve a large class of escape analysis Do you have a link to this? I'm interested in reading more about it. &gt; How can you can set private fields? You can't. This is the behavior you want 99% of the time, but it ends up meaning your I/O types need to have all public fields, which is kind of a pain. &gt; I think that's the price of simplicity. Oh, definitely. If you want to keep your language from becoming C++, you need to draw a line in the sand somewhere, and I'm impressed at anyone who has self-restraint to draw that line before generics.
This isn't specific to Go, actually. There are many control characters like that ( tab = \t, etc ). The newline separators are actually different on each platform, too. Worth looking into if you're formatting text more than non-trivially. https://en.wikipedia.org/wiki/Control_character
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Control character**](https://en.wikipedia.org/wiki/Control%20character): [](#sfw) --- &gt; &gt;In [computing](https://en.wikipedia.org/wiki/Computing) and [telecommunication](https://en.wikipedia.org/wiki/Telecommunication), a __control [character](https://en.wikipedia.org/wiki/Character_(computing\))__ or __non-printing character__ is a [code point](https://en.wikipedia.org/wiki/Code_point) (a [number](https://en.wikipedia.org/wiki/Number)) in a [character set](https://en.wikipedia.org/wiki/Character_encoding), that does not represent a written symbol. They are used as [in-band signaling](https://en.wikipedia.org/wiki/In-band_signaling) to cause effects other than the addition of a symbol to the text. All other characters are mainly __printing__, __printable__, or __[graphic characters](https://en.wikipedia.org/wiki/Graphic_character)__, except perhaps for the "space" character (see [ASCII printable characters](https://en.wikipedia.org/wiki/ASCII_printable_characters)). &gt;All entries in the [ASCII](https://en.wikipedia.org/wiki/ASCII) table below code 32 (technically the [C0](https://en.wikipedia.org/wiki/C0_and_C1_control_codes) control code set) are of this kind, including [CR and LF](https://en.wikipedia.org/wiki/Newline) used to separate lines of text. The code 127 ([DEL](https://en.wikipedia.org/wiki/Delete_character)) is also a control character. [Extended ASCII](https://en.wikipedia.org/wiki/Extended_ASCII) sets defined by [ISO 8859](https://en.wikipedia.org/wiki/ISO_8859) added the codes 128 through 159 as control characters, this was primarily done so that if the high bit was stripped it would not change a printing character to a C0 control code, but there have been some assignments here, in particular [NEL](https://en.wikipedia.org/wiki/Newline). This second set is called the [C1](https://en.wikipedia.org/wiki/C0_and_C1_control_codes) set. &gt;These 65 control codes were carried over to [Unicode](https://en.wikipedia.org/wiki/Unicode). Unicode added more characters that could be considered controls, but it makes a distinction between these "Formatting characters" (such as the [Zero-width non-joiner](https://en.wikipedia.org/wiki/Zero-width_non-joiner)), and the 65 Control characters. &gt; --- ^Interesting: [^ASA ^carriage ^control ^characters](https://en.wikipedia.org/wiki/ASA_carriage_control_characters) ^| [^Cancel ^character](https://en.wikipedia.org/wiki/Cancel_character) ^| [^ISO ^2047](https://en.wikipedia.org/wiki/ISO_2047) ^| [^C0 ^and ^C1 ^control ^codes](https://en.wikipedia.org/wiki/C0_and_C1_control_codes) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cnwa2rr) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cnwa2rr)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
I use prepared statements the most when I'm doing bulk inserts with Sqlite3. Inserting 1000 rows with no prepared statement takes about 10x longer than inserting 1000 rows with a prepared statement. But, this matters less with mysql and postgres because you're not limited by the physical hard disk as much. EDIT: typos
Ok. Thanks! I have a last question: Where I should put the 'validate' function to validate data, for example, of Thing struct? For the moment, I do this like: func (mdb *db.MyDB) ValidateThing(thing *models.Thing) (bool, error) { // bla, bla, bla } I put the validate function as method of MyDB because all 'validate' methods will needs access to database for validate, and the data to validate is for the database and no one else... Or I should put the 'validate' methods in another package? I'm a little confused in this..
Well, you can't make an omelette without breaking some eggs. If you code it as thing.Get(db, whatever) you likewise need to write quite a few methods, unless you write a specific set of methods to access just your designed db with your set of structures. It is an option, but writing code when modifying the database feels awkward. I'm not particularly fond of reflection, but it's not that big of a deal, I think, unless database access is all your application does. I mean, it's not like it is bound to be a bottleneck. I like reinventing the wheel, but in this setting I feel it is better to set for an already existing ORM (well, gorp is not exactly an ORM, but close enough)
Very useful! Thanks! :)
I have seen some issues with the mapping of 'localhost' to 127.0.0.1 sometimes on my mac (usually when dealing with a VPN). Use the 127.0.0.1 address or [::1] (the IPv6 equivalent) and you should be able to connect fine.
- `:=` is unfortunately misdesigned, a defect which surfaced too late in the design process to fix it. That it can change from reassignment to shadowing declaration as a result of seemingly trivial refactoring can lead to subtle bugs that can be difficult to detect. To compensate, the compiler currently doesn't accept some code which is valid according to the spec in order to prevent some of the worse situations where this can be a problem. - The zero value, while it simplifies things in many ways, can also be seriously limiting as far as what kinds of invariants you can maintain and in what ways the language could grow in the future. For example, any attempt to add runtime generics to Go will run into the problem that anywhere you have to use boxing to make the code generic, you can also get nil values.
Rust now has `if let`, making the common cases less verbose.
Okay. I have to admit that my comment was slightly wrong. Some things were removed from the language, like the implicit int rule or the `gets()` function. If your code uses neither of these and it doesn't compile under C11, something else might be wrong with it.
Because panicking isn't actually unsafe. If you use unwrap just as a way to get the value in an `Option`, then yes, you're using it wrong. But, if you use it in a situation where there *has* to be a value or else the program is incorrect, that's perfectly legitimate.
If you work in a field that doesn't have to worry about different date formats I can see it not being a problem. What's 01/01/2006 though? Then answer is depends on weather you are in North America or Europe. This is a very common problem in parsing date strings and I dont' think Go does a very good job with this implementation.
Yes I dislike Go and I tried to state my reasons in a candid way not hiding the less noble ones. All of them are pretty reasonable from this side of the fence, and I still strongly agree to them while reading them. FWIW I still consider Go an improvement on Python/Ruby. So the "obvious misunderstandings" are not quite so obvious to me, they are only obvious within the Go programming culture.
You can add this as well since you are funcs with go keyword for better utilization of threads runtime.GOMAXPROCS(runtime.NumCPU())
reflect.Slice: http://play.golang.org/p/BLXobCiXcA
This would be awesome. Not to mention simple.
Similar story with exceptions. "Yeah, Go is dead simple and it hastens my development and program execution speeds by an order of magnitude, but NO EXCEPTIONS?! NO DEAL!" See also complaints about gofmt.
I agree. If Go was the only language in the world, that would be the logical solution. But, since Go is not the only language in world, the logical solution is to use something else :).
Good Job, a Pusher implementation with small memory footprint.
I am sorry I didn't look into the code. But looking at the example in Readme, I have some suggestions. Have you looked into https://godoc.org/golang.org/x/net/context . And even if you are implementing your own context, pass it as the first param to a function, as is the convention.
I can rewrite many things in Go and I often do. It's just a pain to have to hand-roll my own RNGs, computational geometry primitives, Numerical Recipes functions, etc. Especially when that code has been written by other physicists and is thus completely unreadable garbage (but very fast!). Plus, once I've translated a function from C to Go, I need to write tests to make sure I didn't make any typos.
It is youtube for me. Maybe a international cdn issue? Where are you located?
Isn't it obvious? Because it was recorded on a conference that has nothing to do with google.
just thought it was weird, they could have uploaded it to youtube...but google doesn't worry about stupid things like this.
oh its a different video every time you reload
Ragel is like yacc in that it generates optimized state machine code directly into your source files. No extra dependency other than for development. Edit: I might play around with this
Oh, for sure. But let's take the current project that I'm working as an example. This project has a series of inner loops that collectively take about 240 ns per iteration. Every time I need to run this program, that set of inner loops is run about 2^40 times across 16 cores, which takes about 4 and a half hours. If I added a 60 ns function call to the mix, now the wait rises up to almost 6 hours, which would have a very real effect on my workflow and productivity. I guess it also has to do with my optimization philosophy. I know a lot of people who don't think optimization is worth it unless is speeds up a program by a factor of 2 or 3 or whatever (or even only if it speeds it up asymptotically in some cases!) and there are certainly cases where this is true. But getting small ten or fifteen percent speedups are much easier, and if you can speed up your program by 15% four times in a row, you've halved its runtime. If you always pay attention to the little things over the course of a several month development cycle, these things really add up.
I've had the exact same issue. One solution to this is to wrap all queries in a transaction. This should be the case for any kind of write, doing it for reads feels wrong so the fmt.Sprintf solution is useful there.
Excellent! When you're done, put it in that corner with all the other middleware implementations.
I'd take these screencasts a lot more seriously if you endorsed it using your real name instead of codegangsta which sounds like a script kiddie trying to get some cred.
Not all pseudonyms were created equal.
Apologies if that has ended up being a first impression. The @codegangsta handle is for my twitter and GitHub profiles. When I started maintaining projects like Martini, Negroni, Gin and CLI the name just started sticking with people :P I do use my real name multiple times in the course. In fact, my face and real name is on the right hand side of every page.
&gt; Are the exercises done in browser or locally? "Exercises are expected to be done locally on your machine. I believe the best way to learn programming concepts are to do so in your own programming environment. The first couple lessons are all about getting your local Go development environment working so you can follow along with the rest of the videos." Just updated the FAQ with that answer! Again thanks for the great questions, they will be valuable to others.
Why not just move the loop into C as well? It seems the overhead is only a problem if you're making it one. O(number of calls to C).
Because using a nick name allows you to distance yourself from your work.
Dude, I would of been more impressed if it read like this: Essential Go: A new screencast by Jeremy Saenz author of Martini, Gin, etc... Follow me at @codegangsta Bam, instant credibility to all us people who've no idea who you are.
It's a very nice and reasonable article. The only thing that irritated me is func (self *Interval) Start() uint32 { return self.start } `self`, `this` etc. as a method receiver name is one of the few things in Go code that make me twitch. It is explicitly discouraged in the [style guide](https://github.com/golang/go/wiki/CodeReviewComments#receiver-names) and conveys no information about what this `self` is.
What editor font is that?
So, as a general rule for database/sql: * Use prepared statements when doing bulk inserts as /u/lhxtx says, remembering to close them after. * If doing single inserts/queries, just use plain db.Query()/db.Exec() and trust database/sql criteria to prepare statements behind the curtain.
Although Ken and Rob are on Google's payroll, Go is not related to Google. As /u/nosmileface said, the conference isn't related to Google either and the organizers chose Vimeo to host their videos
Thanks for the tip! I updated the overview page to pretty much say that as the first sentence
To be fair, the same style guide admits freely that they are not trying to encourage an expressive name that provides more information &gt; The name need not be as descriptive as a that of a method argument, as its role is obvious and serves no documentary purpose. They actually advocate for something which pretty clearly offers less information (single or double letter references) for the sake of brevity since you can expect to be using the reference on most lines of the method.
eh, i kind of disagree with the not for new programmers, looking at the previews looks like it gives a pretty good idea what things are. might go into some detail as to what the variable types are and how they differ but overall i'd say it looks like a good building block. other than that small bit, i agree with everything else.
&gt; I am culturally biased but I could mention a bunch of fellow German CCC hackers Please stop thinking everyone know's who you are outside your group. "Hacker" aliases are ten a penny today and only the real famous 'celebrity' ones stick, and these were usually placed years ago. It's like me saying "i'm at the top of The Sims rankings, you should know the name 'lovestospooge1979', now buy my stuff!"
Source Code Pro http://sourceforge.net/projects/sourcecodepro.adobe/
Not dead, just not done by me anymore. Unfortunately I couldn't sustain that kind of pace without getting burned out. The a-la-carte course style like this one is definitely more suitable for my sanity :)
Personally I like using `this` because it doesn't require me to think of a new receiver name for every struct, and it's consistent so whenever I go back and look at a method I don't get confused which variable is for what.
bindvars are driver dependent: oracle uses ":name", postgres uses "$1,$2,...", mysql uses "?" and sqlite3 supports both "?" and "$1,.." I agree with you in principle, but there are legitimate reasons to have to avoid prepared statements. It's a common frustration with the Go sql library and that some of its behavior is either undocumented or driver specific.
Looks great! Can't wait to see more advanced topics covered!
It's ironic that googling their aliases reveal nothing about them. Yet google their names and there they are.
One thing that can be dangerous about using a self-referencing word like "this" or "self" is when the method doesn't have a pointer receiver. In that case, it's operating on a *copy* of what you might mistakenly think is truly "this" or "self" - so be judicious.
&gt; I am not advocating for generics inclusion. I'm not advocating either. But advocates should explain what do they mean by generics (unrelated things). (typically generic collections / algortihms/ natural querying / functional-style map reduce etc) The people who need generics should also contribute to the document the actual problems trying to solve.
Depends what you're going for and where you're at. I won't recommend one either way here because I've not read a Go book from front to back -- only parts of them. There's [plenty](https://github.com/avelino/awesome-go#e-books) of free (or inexpensive) ones that are decent, but the way things are going I personally stopped buying programming language books in favor of more updated or bite-sized online resources. (Edit: I'm specifically referring to programming *language* books which describe syntax, methods, and libraries. I still use books for less temporal things like theory, history, and algorithms.)
Alright I don't personally find the material compelling, but if I was just now getting into Go, it would be great. I'm buying this on behalf of the past me who had to learn the hard way.
Awww shucks you didn't have to do that :) The cool part is that all my future courses will be hosted on this platform, so you will be notified when a new one is out and you can add it to your library easily.
Oh yeah. Can you post your .vimrc ?
Will you be updating this course at all or is it in a final state? I am mostly wondering about anything to do with concurrency.
&gt; (But of course, it really depends on the person.) that's the major point, really
Any chance for intermediate to advanced material? Thanks. Keep it gangsta!
Yup. This is just the beginning, I'm hoping to produce other courses on more interesting topics :)
You might have some luck with https://code.google.com/p/rsc/source/browse/c2go for converting C code to Go - I haven't personally used it, so I don't know how and in which cases it works. Regarding setting private fields, as long as you know where something is in memory (e.g. via using reflect) you can change it using unsafe and direct memory access, obviously a mandatory disclaimer, dragons ahead when using unsafe.
Interfaces and concurrency...
With 1.4 you have `func TestMain(m *testing.M)` for setting up stuff like that, https://golang.org/pkg/testing/
You are right, in order to login you need both cookies. But to get those cookies you can only make GET request to the front page. From then it gets 302 redirect and responds with cookies required for the POST request. So you cannot move forward until you successfully get redirected with cookies in response. How far have you reached? Did you solve it?
Yep, this makes perfect sense.
i would be happy with a runtime error here. i too wouldn't like them to give me some other value. to me it feels like the turning of the negation in this case into a no-op rather than complain loudly is actually "giving me another value". i ask for negation of X, i end up with X thanks for your insights!
I realize below it is not a conscious noop but just how signed arithmetic works. 
If you want the reasoning behind much of this, check out The Practice of Programming, by Kernighan and Pike, 1999.
Ha! I might as well do the same. Three year veteran here. Hardest lesson I learned is first always see if there is something already built into the standard library. 
I've got those two cookies, but when requesting the login page (or doing the post request), the response header removes all cookies. Someone sent me a pm saying it's because the site know my program isn't a browser. I'll have to search how to make my request more browser-like, with a user-agent and such. I'll try to work on it tomorrow.
Neat. Thanks for sharing. Love the pragmatic inlined string approach to code generation :)
For what it's worth, C gives the same result, as can be demonstrated by this program: #include &lt;stdio.h&gt; int main(void) { short x = -32768; x = -x; printf("%hd\n", x); return 0; } 
You're just lucky here. Signed overflow is actually undefined in C (and C++), and your program can legitimately do anything (including failing to compile, crashing, or returning 42). See, e.g., http://blog.regehr.org/archives/213
Interesting! I guess the Go behavior is an improvement then.
Problem solved. Operator error. I had temporarily changed my GOPATH to a different drive to test something and forgot to change it back. There was an empty code.google.com directory below the GOPATH. Doh! In any case, thanks for your help. 
Oh, interesting. I didn't know that existed. I'll have to look into it. (I wonder how it handles void *'s...)
html/template and text/template
Not remotely what I was referring to. A templating language allows for dynamic content to be displayed on a webpage.
Not understanding. Go's templates allow dynamic data at run-time just like other template engines.
Doesn't the plain sql package make '?' the only one necessary?
Ahh, you were just vague so I wasn't sure. For example in Django I could do something like this: {% for item in list %} &lt;p&gt; item &lt;/p&gt; {% endfor %} This is the desired functionality I am looking for. 
I didn't mean to be. See http://play.golang.org/p/0YjA9OkLOM 
No worries man! You were helpful, thank you good sir.
You should probably just have a read through of http://golang.org/pkg/text/template/ Lots of stuff the templating language can do. 
Havn't used asyncio, but have used Node quite a bit and recognize the async paradigm can be awkward sometimes. It probably doesn't belong in Python at all. Regarding real world web app performance with Python, I do run a comment service that handles up to 1000 python mediated requests per second and Python is not a bottleneck, so I didn't need to make any special considerations for concurrency. I'd really like to try go's celebrated coros!
+1. Why does it matter what version of go is in Debian? You shouldn't be shipping code to end users, and developers should be in control of their go version.
Damn sun! nice post +1 and +1 for the question about the older framework
No, the sql package doesn't do anything with the query string. It's up to the driver to do, and most drivers just prepare and leave it to the server. If you are using sqlx, you can use `db.Rebind` to be able to use '?' queries across different drivers, eg: db := sqlx.MustConnect(...) db.Query(db.Rebind("SELECT * FROM foo WHERE bar=?"), "bar") 
&gt; a single CPU's worth of work by the new (Go) version was at least as powerful as a entire server's worth of work by the old version You know, I'm tempted to start collecting these stories. There's been this myth around for a while that using a scripting language for network stuff isn't that big a deal because "you'll always be waiting on IO anyhow", but if that were true, we shouldn't see this stream of stories about "We had a server in [Ruby/Python/Perl/etc.], and after having optimized it all we could in that language we ported it to Go and instantly went from X dozen servers to X." It really doesn't seem to take much "scale" before the language is in fact just too slow.
Ah I see so it was bandwidth that stopped them from scaling down. It would be nice to know what caused them any delays. It sounds interesting.
It's nice to hear about the performance improvements but otherwise this article is pretty weak. What's the takeaway here? That Go is better than some other language that wasn't even mentioned? It would have been interesting if the author could have expanded on how the Go app was structured, lessons learned, performance tips, you know just something of actual value beyond a feel good story of increasing throughout. 
Still, after maybe 10k lines of real application code in golang I havent fully figured out how to represent the same struct in multiple places/modules without duplicating lots of code and having struct copy functions that are error prone if a field is added but not added to the copy function(s). Currently my project only has like three rest entities so its not much of an issue or attantion point for me. I guess that go generate could help with these kinds of things...
Something I've been building over the past few days. The backend is written in Go, and the frontend is built with [Mithril](http://lhorie.github.io/mithril) using LiveScript. There's a link to the source on the site, but [here's one for the lazy](http://github.com/daryl/qstn). Let me know what you think or if you have any ideas to make this better.
I started work on a project that'd use SQS. After a cursory glance and a copious amount of WTFs I filed a quick bug report + PR for github.com/goamz/sqs. Then I *actually* read the code. I had to open a beer.
[This](http://play.golang.org/p/a-svSYaTkG) gives me the following error: prog.go:6: constant -36768 overflows int16 [process exited with non-zero status]
[http://golang.org/pkg/html/template/](http://golang.org/pkg/html/template/) Yes, it does. 
Where's the top questions? Or rather, I would like to see my own poll and the results
All polls are anonymous, you get results (hopefully) after you share your poll with your friends, cat, dog, etc.
Or use Google Spreadsheets and get instant results that can be piped in graphs and charts and etc. Cool POC, but I really hate surveymonkey and all the other random ones that simply aren't nearly as well done as Spreadsheets winds up being.
As I was writing that I couldn't get past a 401 and made no progress.. I cleaned up the code and asked both page with a perfect header (I've copy pasted every values that my own browser send + a user agent I found on the surf page) and it seems like it's working! My only way to see what's going on right now is by checking resp.Status, and resp.Body. Is there a quick way to filter the resp.Body so it only prints what's between &lt;body&gt; tags?
Cool, cool. :)
The old version was python twistd. The biggest bottleneck we had was that the process that controlled the assignment of IPs was single threaded, so we could only handle as many requests as that single process could take. Even with that, we had to do major hackery for the processes that did the actual relaying, eventually spawning off 4 plus processes and using haproxy to balance between them, because each of those would get CPU limited. The major advantages of doing this in Go was that we could share the state information easily between all of the go routines that needed to deal with concurrency management (helping to make sure we only established so many connections per IP to an ISP), and were able to take full advantage of all of the CPUs on the system so that instead of CPU being the bottleneck it became the network card. As a follow up, the network card limitations have turned into their own set of problems. With a 10Gb NIC we've had to do extra stuff to spread software interrupts from the card across IRQs, and some other performance things we'd never seen before. Better problems to have in my opinion. 
I get it, here's my not anonymous poll: http://qstn.co/q/4eJzHTTv Edit: Seems I didn't get it, how do I share except on twitter? I don't have facebook. 
Thanks, it'll be useful since for some reason I don't have the same behavior in my browser. And I'll need it again for parsing the page I need probably. 
We've definitely seen that here at SendGrid. All of our profiler reports show that a significant amount of time is spent just in the code handling the network transmissions. For this service we could have tried to use the spice(2) system call, but that path was rejected because it moved us in the wrong direction architecturally. In the end every byte of data you have to touch costs CPU, and unless you are bandwidth limited there is an advantage to reducing that cost. 
Go through the tutorial here: https://golang.org/doc/articles/wiki/ You'll find everything you need for the assignment. 
Yep! If you try it out I'd like to know how it went :)
Mithril was actually pretty nice to work with, especially using LiveScript. It's well-documented and has some great examples on the blog, so getting it up and running wasn't hard at all. I've never tried Riot, so I couldn't tell you which to use, so go with your gut, or stick with Angular if that works for you.
Yep. The gains I saw over Python -- I can't be sure -- might have been just the packet handling. Go is pretty awesome, even outside the concurrency.
Just write your format string and treat it as a string, not a date. There's no reason to let Go parse your format string.
PS: just noticed that the latest version is on github https://github.com/rsc/c2go.
Awesome. Thanks.
The first one is the recommended package.
+1 the one on code.google.com also [wasn't updated](https://code.google.com/p/go-sqlite/source/list) since 2013.
packt also released this one, which has gotten 17 reviews, evenly split between 5- or (1- and 2-) stars: http://www.amazon.com/Mastering-Concurrency-Go-Nathan-Kozyra/product-reviews/1783983485/ $46 new, $60 used?!
I did a major HL7 messaging system for one of the top 3 health care IT corporations. While I am not allowed to say who it is, I can say, performance increased 5 to 1. After my NCA/NDA, I am going to write another commercial one. 
I used matt's in a distributed systems class and it worked flawlessly 
Having looked at the first chapter of concurrency patterns, I can believe the 1 star reviews more than the 5 star ones. 
Hi, I'm the SendGrid engineer that did the original rewrite in Go (although most of the real work was done making it production-ready, but I was not involved in that). One of the big takeaways for me was that it's much easier to do multi-processor concurrency in Go than in Twistd/Python. (Just set GOMAXPROCS to something greater than 1). Not to mention that it's much easier to write and read. As far as how the app is structured, we use godep for dependency management. I built my own SOCKS library (there didn't seem to be one out there at the time), but the protocol we use has changed so it's not really pure SOCKS anymore. For control messages we use a custom protocol so I built a library similar to net/http for that. Not sure what exactly you're interested in knowing, but I can try to answer any other questions. A few things that got us in trouble early on: - trying to do locking at too fine of a grain in order to get performance. We got performance at the expense of readability of the code. It's the age-old "premature optimization is the root of all evil". - Using defers inside of an loop that never exits. Beware of those. - Gotchas when writing the relay part (it's just a TCP proxy) and handling teardown cases when one or the other end of the connection breaks. - io.Copy uses a 32K buffer which can add up. - We used the go profile tool to help discover memory leaks.
I've been using mattn on [TMSU](http://tmsu.org/) for several years and have never had a problem.
Yes, that's correct. Even 'C.malloc'ed memory is not touched by GC. It only scans memory the runtime allocated itself. It would be unsafe to do anything otherwise. 
Superb idea.. I think. Be interesting to see if/how the rapid dev cycle from PHP can be duplicated in Golang - how is your own experience from using your library?
Agreed, but [Clients are safe for concurrent use by multiple goroutines.](http://golang.org/pkg/net/http/#Client) Having it global can be good for preserving cookies and for connection caching.
i've been working with node for a while now and i started learning go. i'd say it's probably worth your time, but it depends on what kind of work you're looking for and what your goals are.
yes! Give Go a go you won't be disapointed
nit: the GC only scans memory inside the virtual address range that the garbage collector knows about. This has two side effects 1. this is why Go programs report a very high VSS on systems that care about such things, on startup the GC reserves(*), but does not allocate, a large contiguous block of virtual address space which represents the heap. 2. because of the first property, malloc(3) or mmap(2) will not return a pointer to the virtual address space previously reserved by the garbage collector. * this is complicated in real life for windows/386 platforms which have a very fragmented virtual address space, this is an outlier that does not invalidate the overall theory of operation of the garbage collector.
In similar situations, I've just sucked it up and let there be a "type" string parameter (or whatever you need) on all types that I use, set unconditionally by a constructor and never touched by any other code. A bit inelegant, but such mismatches are inevitable when you start trying to cross-serialize like that and I've stopped caring after so many years of dealing with it whether my solution is "elegant", just that it works as simply as possible. Blame the impedance mismatch and move on. Seriously. Blame it. Take a good solid moment and just blame it until you feel the responsibility lift from you. Mmmmmm, oh yeah, that's the stuff right there. Also, as a careful rereading of my first paragraph will show, this opinion has nothing to do with Go. It comes (among many other things) from using JSON to interface across about ten languages for a fun project we do at work. That's no reconciling all these languages and the way they do it. That said, of your two choices I would prefer the interface, as odds are good that you may find that it begins to grow, which would then be the best counterargument against what I just said. ☺ And in the "zig instead of zag" department, there are some alternate JSON libraries for Go. You may find one of them is better at this. IMHO and in my experience this is my biggest complaint about the encoding/json implementation... It deals poorly with tagged-type JSON, and I use that all the time. I haven't tried them, perhaps someone else will pop up with a review.
That looks like a nice application
There are plenty of http frameworks that can help you do this. But, the http.ResponseWriter expects you to write []bytes to it. Where/how you get those bytes is up to you. As you show, you can read it from a file. But, you might also return some json. Something like: results := Results{Total: 100} data, _ := json.Marshal(results) // import "encoding/json" //might not want to ignore error, might be ok w.Write(data)
I just found that you can cast the input to a []byte so w.Write([]byte(anyargument?)) is that right? Is a data-value mapping possible as well (I am coming from having used $_POST in php before) and also is json basically the best way to return data? I'm a bit new to web dev so I'm still testing the waters and seeing what can be done. Thanks (Also my use-case is selecting from a db and returning results to the client.)
If the package author can take precaution to reduce this type of user errors, it will better for him/her in the long run. I like this approach: http://blog.gopheracademy.com/advent-2014/nigels-webdav-package/
The thing that affected the project at the end, would affect other projects that run C code, like GTK+ bindings and such?
Perhaps pedantic, but that's a conversion, not a cast. But any string can be converted to a []byte, and any []byte can be converted to a string. So yes, you can echo back a posted form value that way: w.Write([]byte(req.FormValue("name"))) If you're only dealing with data (no presentation), then yes, json is the most common way to do this. The main alternative is XML, but it isn't nearly as common. For your case, you should consider creating a struct that looks like the data you want to return: type User struct { Id int Name string } Mapping your DB record to it (or an array of of them if you're dealing with multiple records) and returning the serialized json.
By the way, this poll app was created in Go. Here's the recent reddit post of the creator: http://redd.it/2tfhbq
If you want accurate (and far richer) data you might think about (1) allowing people to select multiple options and, concomitantly, (2) not counting one selection as one person.
Thanks for that article. I was thinking along those lines.
Hystrix is an amazing library for Java. Looking forward to see this Go package evolve.
And add more options. 
I always used the simpler calls - no dump, trace, group or table. And I did this exactly because I needed. So far, the experience is on par as with PHP. The trick is to have something to restart the application for me. 
You could translate OpenSSL to Go
In your func, you should expose a parameter that defines a URL that your http will make calls to. In your test, you can then pass your httpTest servers URL.
&gt; func panics(doesItPanic func()) (r interface{}) { &gt; defer func() { &gt; r = recover() &gt; }() &gt; &gt; doesItPanic() &gt; &gt; return &gt; } Thanks for the tip!! I will update the blog and will put this method there as well!
Yup
Thanks.
Updated my post http://whizdumb.me/2015/01/24/checking-for-panic-condition-in-test-cases/
When you say you put the glew.h, glexw.h and wglew.h in GL for Go, do you mean that those files are in the same directory as your project? Like in your GOPATH? These files shouldn't be in your GOPATH. I've never used this gl library before but looking in gl.h I see the following statement: #include &lt;GL/glew.h&gt; Note the angle brackets. This means that the C compiler is looking for these header files in the system includes folders. There are several such folders and their location depends on the OS you're using. [Here's a link to the GLEW installation page, that should help you get the files where they need to be.](http://glew.sourceforge.net/install.html)
Uh oh...
The other answers explain how to do it at a low level. A nice helper library is github.com/unrolled/render I usually create DTOs (data transfer objects) when dealing with databases, otherwise you may inadverttantly expose too much information from your domain objects. With render it would be simple like this ``` r.JSON(w, 200, &amp;userResponse) ```
i moved to linux after adopting Go because I deploy on Linux servers and do a lot of CGO. It annoys me to develop in a VM. So I use my mac for email &amp; office stuff and linux for everything else.
You're on the right track, you've just made a couple mistakes along the way. What you need to do is first set up another mux for handling static files: package main import ( "net/http" ) var mux *http.ServeMux func main() { mux = http.NewServeMux() mux.Handle("/", http.FileServe(http.Dir("./public"))) // ... http.ListenAndServe(":8888", nil) } // There are better ways to check for static files, // this is just a lazy way which checks if the url // contains a dot, if so it will assume it's static func static(h http.HandlerFunc) http.HandlerFunc { return func(w http.ResponseWriter, r *http.Request) { if strings.ContainsRune(r.URL.Path, '.') { mux.ServeHTTP(w, r) return } h.ServeHTTP(w, r) } } This way everything in the public directory will be served as a static file, this is where you'll put your assets. Your post handler was correct, but I also added a conditional to first check whether the method was POST, otherwise it will serve a 404: func postHandler(w http.ResponseWriter, r *http.Request) { if r.Method != "POST" { http.NotFound(w, r) return } field := r.FormValue("textfield") fmt.Println("textfield: ", field) // Here is where you would // do a database query. w.Write([]byte(field)) } You also weren't actually sending any data at all when you AJAX'd your server, to do that, you'll need to add the name attribute to your input. &lt;form action=/post&gt; &lt;input type=text name=textfield /&gt; &lt;input type=submit /&gt; &lt;/form&gt; For the JavaScript, a simple way to send data is to use [FormData](https://developer.mozilla.org/en-US/docs/Web/API/FormData). Just a word of caution, FormData is IE10+, so you'll probably want to use an alternative, but for the sake of this example I'll use it: var form = document.querySelector("form") form.addEventListener("submit", function(e) { e.preventDefault() var x = new XMLHttpRequest() x.onreadystatechange = function() { if(x.readyState == 4) { console.log(x.response) } } x.open("POST", "/post") x.send(new FormData(form)) }) I hope all this made sense, [here's the working code](http://cl.ly/ZSui) if it helps. 
One note : Are you speaking to /u/dgryski or Mr Cheney? I agree with you that he (Cheney) doesn't explicitly prove it's better (that would require a deeper contrast of other languages), but the way I read his post is that, given Go's design values, the error mechanism fits Go "better" than all other available mechanisms (including the various flavors of exceptions).
This is great! I just have a few more questions if I wanted to use jquery on my front end (the htmls), all of that would need to be served in the same way too? I am confused as to how to keep the html page the same while filling &lt;div id="fromserver"&gt;&lt;/div&gt; with that was from the server.
I think the example is weak. This is a scenario where non-error values can suffice. http://play.golang.org/p/CeNUmPyb8H for an example. Here Check() can be implemented in one expression. A stronger type system would even be able to show if Positive() was misbehaving by returning an invalid cmp value, or if Check() incompletely matched all the possible outputs of Positive() That being said, I don't entirely disagree with dave. Unchecked exceptions are scary, and a secondary value to denote that the input, and letting that value contain some information as to why it failed. I hate to be 'that guy' that beats the functional programming drum, but I do think this is something that haskell does better with its Maybe and Either typeclasses. http://lpaste.net/119207 
i agree. on windows java is the only language i could use opengl with.
I have been using it at work. Application thats written in golang does crazy amount of network i/o. Always thought memory overhead was because of GC. 
I'd love to see someone refute my article with an attempt at an option type or monad, but you have to write it in Go.
&gt; With that said, you only need to check the error value if you care about the result. &gt; Knowing the difference between which errors to ignore and which to check is why we’re paid as professionals. Personally I find that to be both an extremely powerful, as well as uniformly correct statement. Very nice read!
Except that there's int.TryParse .... int.[Try]Parse actually shows the irrevocable opposite. But even if TryParse didn't exist, I think you're missing the point. A consumer can turn an exception into an error value, or an error value into an exception. If .NET didn't provide a TryParse, you could just write your own helper (and sometimes, I write my own atoi helper in Go because I know it won't cause an error, the Must pattern, if you will). Given the above, that it's possible for the consumer to convert one to the other, my point, and I believe what Anders was getting at, was that there are many more cases where you'll want the exception to bubble. For every example of TryParse, you'll have ten things, like opening a DB connection, executing a query, mapping rows to structs and so on that should all be MustXXX and bubble up to a global error handler.
being nitpicky here, but the opposite of positive is "not positive", not "negative" so your example is a bit contrived
This is a Go sub reddit and this is an article talking about Go. I think the stipulation to constrain the solution space to that which ie available in Go as it exists today is completely reasonable. 
just for the url alone, I thank you sir.
You have `&lt;script src="js/getData.js"&gt;&lt;/script&gt;` on your index page, but your server doesn't serve any javascript, so obviously nothing is executed.
The second one has moved to GitHub: https://github.com/mxk/go-sqlite
It's because it's moved to GitHub, as it says on the main page: https://code.google.com/p/go-sqlite/
It requires login.
Your average program doesn't do 10k concurrent calls to C code, so probably not that much.
Typically you (or me, at least) just run the tests, upgrade the dependency to the latest API compatible version, and then run the tests again. I see no need for a separate branch with API compatible updates?
For this kind of problem I would use a graph data structure. Nodes' graph have a adjacent() method that returns its neighbors.
That is so fetch. But really I wish the whole yellow on white would die in a fire. 
Code is read more often than written, and Go's datetime format, idiosyncratic though it may be, is massively easier to read, especially at a glance.
http://blog.gopheracademy.com/vimgo-development-environment/
You might want to clarify this isn't a replacement for Godoc (my initial assumption given the name), rather it's a middleware for capturing API requests and automatically generating docs. Neat tool.
Nice tutorials, although there's about 2 pages of rambling introduction before actually stating what's going to be built. Maybe make that the first sentence?
http://farazdagi.com/blog/2015/vim-as-golang-ide/
Good call, thanks for the feedback!
&gt; I wanted to build this site to let me be lazy and continue writing strftime format strings in Go. &gt; Ironically, I can now write Go date format strings now after building this site. You win this time Russ Cox.
vim-go looked kind of heavy to me, though I might install it eventually. Currently I'm only configuring the coding style to match go fmt autocmd FileType go setlocal noet ts=8 sw=8 sts=8 
Amusingly, we [renamed](https://github.com/polydawn/hroot/commit/04dea49) one of our projects - similarly an alternate transport for images - from Docket to [Hroot](https://github.com/polydawn/hroot) after Shykes (a core committer and manager of Docker) called us a [domain name typo scam](https://groups.google.com/d/msg/docker-user/l9nNc9yJciM/FiDccNQMZWEJ). I'm not suggesting you rename your project, just letting you know that there's been inane drama over a 'Docket' name before. My colleague’s [response](https://groups.google.com/d/msg/docker-user/l9nNc9yJciM/lhj9sRsD45oJ) to that allegation is pretty comprehensive: &gt; labeling members of your community who are trying to invest in broadening and enriching the ecosystem as scammers seems somewhat rude. At any rate, cool project - I'll definitely be checking it out!
As a final project for a MOOC computer science course I created [this website](http://60plusadventures.com/) using the [Beego web framework](http://www.beego.me). Complete source for my project is [on GitHub](https://github.com/emadera52/sixty). Take into account that I have no web design experience. As someone who does, you'll know how to make a site look good. :) That's something I hope to learn after learning a lot more about Go. The Beego framework is pure Go. Based on my own research it does a better job than other complete frameworks in terms of doing things "the Go way". Not to say it is perfect in that regard, but in learning to use Beego, I learned a lot about Go. Building a full blown, consumer facing website using just the Go standard library supplemented with a few third party packages is certainly possible. The question is how practical is it? I'd love to see those who suggest that path post a link to such a site. Even better, a link to the source code. I'm talking a site that handles routing, resource and other intelligent caching, blocks external attacks, full database support, effectively uses Go concurrency, is easily scalable, includes logging and admin stats, persistent session management, http context management... and the list goes on. I have no connection whatsoever with the Beego author(s). I do believe that Beego is a viable solution for someone whose primary focus is web development. 
I'm familiar with this list, and I got confused when I found this in build process: [`… | grep -v blogspot`](https://github.com/jpillora/go-tld/blob/master/generate.sh#L6) The upstream list is a list of TLDs suitable for use in cookie logic. `evil.com` shouldn't be able to set cookies for `com` (thus reaching `yourbank.com`). Similarly, `evilsite.co.uk` shouldn't be able to set cookies for `co.uk`. This list exists because which suffixes represent boundaries and which aren't isn't at all obvious. For example, `.us` used to be government-only, delegated to states and then to certain state entities, despite now being open for public registrations. You don't want `evil.k12.ak.us` to be able to set cookies for `good.k12.ak.us`, since they're administratively distinct: // The registrar notes several more specific domains available in each state, // such as state.*.us, dst.*.us, etc., but resolution of these is somewhat // haphazard; in some states these domains resolve as addresses, while in others // only subdomains are available, or even nothing at all. We include the // most common ones where it's clear that different sites are different // entities. k12.ak.us k12.al.us k12.ar.us k12.as.us k12.az.us k12.ca.us k12.co.us k12.ct.us k12.dc.us k12.de.us k12.fl.us k12.ga.us k12.gu.us …but there are exceptions: // k12.hi.us Bug 614565 - Hawaii has a state-wide DOE login Similarly, `a.com` shouldn't be able to set cookies for `b.com` – but even there are deeper divisions relevant to trust: // ===END ICANN DOMAINS=== // ===BEGIN PRIVATE DOMAINS=== // Amazon CloudFront : https://aws.amazon.com/cloudfront/ // Submitted by Donavan Miller &lt;donavanm@amazon.com&gt; 2013-03-22 cloudfront.net // Amazon Elastic Compute Cloud: https://aws.amazon.com/ec2/ // Submitted by Osman Surkatty &lt;osmans@amazon.com&gt; 2014-12-16 ap-northeast-1.compute.amazonaws.com … // Amazon Elastic Beanstalk : https://aws.amazon.com/elasticbeanstalk/ // Submitted by Adam Stein &lt;astein@amazon.com&gt; 2013-04-02 elasticbeanstalk.com // Amazon Elastic Load Balancing : https://aws.amazon.com/elasticloadbalancing/ // Submitted by Scott Vidmar &lt;svidmar@amazon.com&gt; 2013-03-27 elb.amazonaws.com // Amazon S3 : https://aws.amazon.com/s3/ // Submitted by Courtney Eckhardt &lt;coec@amazon.com&gt; 2013-03-22 … // GitHub, Inc. // Submitted by Ben Toews &lt;btoews@github.com&gt; 2014-02-06 github.io githubusercontent.com … // Heroku : https://www.heroku.com/ // Submitted by Tom Maher &lt;tmaher@heroku.com&gt; 2013-05-02 herokuapp.com herokussl.com …and yes, this list includes `blogspot.com` and friends. Why is Blogspot singled out for removal but all the other private domains retained? The build process also runs it through `grep "^[a-z]"`, which removes the ICANN-assigned [IDN](https://en.wikipedia.org/wiki/Internationalized_domain_name) TLDs, which also seems wrong. ([Opened issue #1](https://github.com/jpillora/go-tld/issues/1).)
Replied on Github 
Its really awesome, gofmt on save is nice but you're missing out if you don't have goimports on save.
The approach of using mmap and then forcing raw memory to be viewed as a structure (with the foul.* stuff) is interesting. This might allow having back-end and a front-end processes, one being careful to avoid GC and keep tight timing, and the other doing lazy stuff that isn't quite so time-sensitive.
Your dream has just come true: iOS port of Go complete https://groups.google.com/forum/#!topic/golang-nuts/mmB2q8RqB-Y
Oh, that's a relief! 
I tried using each of these http.Handle("/", http.FileServer(http.Dir("./html"))) http.Handle("/", http.FileServer(http.Dir("./html/js"))) http.Handle("/html", http.FileServer(http.Dir("./html/"))) http.Handle("/html", http.FileServer(http.Dir("./html/js"))) http.Handle("/html/js", http.FileServer(http.Dir("./html/js"))) but none of these seem to work and my filesystem looks like this * /src * /webapp * main.go – my go web application source * /html * index.html * /js * getData.js * jquery-2.1.3.min.js What could I be doing wrong? X_X
you missed that last part.... compared to other languages that will just do this by default. But yeah I will take a look at this package I didn't see it when googling around. I also asked in the go-nuts irc channel and was pointed to the stack overflow article that I gave credit to.
Disclaimer: I'm one of the authors of Prometheus. Happy to answer any questions.
Redis is now the first implementation, memcached is the next step. Advantage is that you can choose implementation directly from settings(dsn). 
At SoundCloud, we currently use [PromDash](http://prometheus.github.io/docs/visualization/promdash/) for all Prometheus- and Graphite-related dashboards. In PromDash, you can configure as many different Prometheus servers as you like, and even show data from multiple servers in one graph. If you are using [Console Templates](http://prometheus.github.io/docs/visualization/consoles/), these can currently only display the data of the Prometheus they are being served from (although nothing would prevent you from serving a JS lib which retrieves data from other Prometheuses). In the future, we also plan on having hierarchical federation between servers, where e.g. you could have a global Prometheus aggregating lower-fidelity data from more detailed, per-datacenter Prometheus servers.
It's working! On another note, could you explain a little bit about how the code works? I'm a bit confused as to the different purposes between the mux.ServeHTTP(w,r) and the h.ServeHTTP(w,r). Also about the purpose of checking if the url contains a '.' or basically the purpose of the if statement in static(). I feel that if I don't understand the Go API more, I will get stuck on more questions. Thank you so much!
IMHO, if you're that worried about GC pause issues, you probably should use a language that lets you control that rather than fight Go. On the other hand, I think games programmers sometimes overestimate their performance needs, especially with GC. A game that you finish but has occasional 25ms pauses every couple of minutes is better than a game that you never finish because you're still fighting with some memory issue to get it _just so_ before you even benchmarked whether you really need the performance....
Id love to see a histogram of the frame rates. I want to see if the Go GC can deliver the steady frame rate the c++/rust people doubt it can. 
 Would be interesting to see community driver "plugins" like "puppetforge", i.e: quickly register net/http/pprof metrics etc.
Do you mean a plugin for the client library (that is, the instrumented/monitored application)? By the way, when you include the Go client library, you already get a lot of process metrics included by default. That is, the number of running goroutines, heap size, etc. See https://github.com/prometheus/client_golang/blob/master/prometheus/process_collector.go#L35-L64 and https://github.com/prometheus/client_golang/blob/master/prometheus/go_collector.go#L15-L18.
Woah! This is great.
Yeah, is `nut` not equivalent to `godep -r`?
Interesting read.. I've been in that place some months ago.Nowadays I basically gave up on Go for my projects, which is a shame because I love the language and I've been promoting it around and even used it for the server side of my last game. People are always worried by the GC, but that is not really the problem here because GC is predictable and so are memory patterns in most games, and also the GC is on the radar of the Go team and it's almost guaranteed to get better. The REAL issue with Go is the colossal hit you get every single time you call a C function. This, for something like OpenGL is just a showstopper. To give you an idea, my DX11 game has some peaks of 6000 "draw calls" per frame when the scene gets really busy and still mantain 60fps, that is a frame every ~16ms. If you are really good, you can reduce the number of API calls per draw call to 5-6..more realistically you're looking into 10... leaving you with about 36000-60000 API calls per frame. At this point, do a simple test in Go, make a loop that calls any C function (fast function, I use something like timeGetTime on Windows and glfw3.GetTime on Linux) and time it. On my PCs, for something like 40k calls, it goes almost to 8ms! That's basically half of my frame time budget gone just in the overhead of calling into C. Of course with C++/D/Rust this is roughly 0, with C# is about 1/8 (less with .NET native) of what I get in Go.. and I can live with that. These numbers are also confirmed in my own 3D Go engine... as soon I raise the number of draw calls the framerate get huge drops regardless of resolutions and number of triangles put on screen. Sadly, this doesn't seem to be on the Go dev team radar at all, and it's a shame, because the language and the ecosystem are an awesome match for game developing. There are proposed "solutions" to this, in the form of batching calls together so you go into C every N call... very smart, but incredibly hacky.. if you need to get that hacky just to use a language IMO it's much better to stick with what is working with no hacks. Good luck to the OP nevertheless. 
I never realized the benefits of having a small language. Go eschews many syntactic sugars that other languages choose. When you write in Go, there really isn't much argument on style, and reading someone else's code becomes a lot easier, because we're all using Go Fmt and we're all working with a tiny language. Compare this languages like Python, C#, or Java. When you work in those languages, there are many different ways to solve the same problem, and in an attempt to increase expressiveness, they've designed languages that can have a single codebase with totally different, equally expressive, styles in different parts of the application. That's my single favorite thing about Go, but it's taken me a while to choose this over things like brevity, performance, and safety, and ease of use.
Will fix
If you want no problems from the GC, consider having all of your subsystems manage their own heaps of memory manually. Allocate straight from the OS. This is the thing to do in games even when you aren't using a GC. Keep Go's heap tiny, don't go crazy with goroutines (GC's gotta scan each goroutine's stack, too), and your GC pauses will be tiny.
Thanks! We use GoCycle with the `-over 10` option, which means functions that score over 10 are marked as problems on Go Report Card. It might be a little strict, but it seems to give good results so far. And thanks for the direct link, good idea!
which, as far as I know.. doesn't work on Windows.. thus.. totally useless... plus, it comes with huge performance penalties due to missing escape analysis. 
Static binary deploys. 
My current job has me fucking around with ruby gems through multiple environments. The versioning, transitive dependencies, lack of consistency when pulling in dependencies, ridiculous startup cost, and the need to install a new ruby for every application has me *begging* for static ELF deploys.
Native (and sensible) structure serialization/deserialization. Being able to define a struct, then using json.Unmarshal(someBlob) or xml.Unmarshal(someElement) into your struct with *no extra work* is obscenely useful. Or at the worst, annotating your fields so that json/xml/etc can all unmarshal to the same field seamlessly is beautiful. Most "bad code" I encounter is the result of not understanding how powerful and useful strong data models are, and go's structs embodify that. Fuck the associative arrays; Write structs that make sense, can be automatically tested, have a good data contract, and don't need serialization/deserialization boilerplate built for them. That's in addition to everything everyone else has thusfar noted; statically compiled binaries, minimal language subset, goroutines.
Implicit interfaces. Interestingly they don't do much for adoption, but they do a ton for keeping people using Go. It takes awhile to really "get" Go interfaces (and why being implicit even matters) -- but once you do, it is a bit of an "ah-ha" moment and everything gets easier. 
Readability/syntax Nimbleness of the language == not a big learning curve (and yet the language remains quite powerful, which is for me a proof of a great design)
SINGLE MOTHERFUCKING BINARY DEPLOY Introducing Go to an established company is so much easier because all you have to do is rsyncing binary
Or use the `runtime` package to do GC manually (or use GOGC to turn it off)
1. Easy to keep in your head. * Stellar standard library, helps with #1. * Export determined by casing. * They ability to easily do stuff like [this](http://play.golang.org/p/UH7NSZroMg). * But most importantly: I find myself being able to read someone else's code like it is mine. Looking at other people's code in C# or Java, I must first understand some complicated design. In Ruby, I must decipher some clever tricks the author learned the week he wrote the code I use. In Haskell, I have to remember a great amount of DSL and operators that every library comes loaded with. In Go, everyone's code is formatted the same, the casing is the same and in the end, I don't feel dumb looking at other people's code.
come on.. you can code those things in interpreted basic and get all the performance you want with today's hardware. If I am talking about cost of calling into C I am thinking about a modern 3D PC game where you want to put millions of triangles on screen. If your game has half the polygons on screen than your competitors (with no other advantage) I can assure you users will notice it... and telling them: "but.. but.. but.. I used Go.. here, read my blog.. cool right?" it's not going to save it. 
Thanks, I took a look at this tonight and this package handles encoding great. Has an issue with mac because it looks in the wrong directory for the charset.json file but otherwise it's perfect.
For me the simplicity of Go is a function of both the simplicity of the language *and* the standard lib. For someone who has worked on the JVM for quite a long time, and watched numerous well intentioned developers writing library's and all they do is add abstraction over the monstrosity that is a very old codebase (the java stdlib), Go is a breath of fresh air. At work some other people have written an abstraction, over a library which is an abstraction over a HTTP server and all I think is *WHHHYYYY* My only fault with the stdlib with Go is the lack of a standard way of doing middleware, but that isnt a huge problem. 
- its 'less is more' design - stability, maturity, dependability - concurrency (goroutines, channels, select) 
Please DO NOT SET GOROOT, you don't need it! Just GOPATH. And then your source goes under %GOPATH%\src and binaries compiled with "go install" to %GOPATH%\bin.
I switched from vundle to `vim-plug` and used the opportunity to add vim-go. 'goimports' sounds like a huge time saver! 
Well, I don't need to backup my claim, cause it's a claim of non existence. GCCGO is not avalabile on Windows.. period. You're welcome to provide a link and prove me wrong. That's the best [google](https://groups.google.com/forum/#!topic/golang-nuts/yloYrwtOJzg) can offer on "gccgo windows" .. if you know more than google I'll be very happy to read it. 
No, not a single call, but again you fill arrays in your program with the data needed to draw the frame (minus textures which you have already uploaded to the GPU ram), and then during the frame update you only have to make few calls in order to have OpenGL/dx render all objects in that frame based upon the data in said arrays, then for the next frame you fill your local arrays with updated data for next frame, rinse and repeat. In other words, you construct the frame locally in your programs memory as arrays containing the necessary information to render said frame, you then send that data to the gpu using a small set of external calls (binding the arrays as being of certain type) and finally call render on that data, for OpenGL you would use VBO (vertex buffer objects) or VAO (vertex array objects). You do not make a external call for each primitive you want to render (quad, tri), followed by a call for each set of texture coordinates, etc, unless you have lived in a cave for 20 years or so.
Sure mate, you're right, I am an idiot and you know a lot of stuff. Well done sir. Hope to see your games out soon.
&gt; I've only read the article and briefly read some doc, but one of the things that confuses me a bit is that apparently, Prometheus expects the libraries being built-in into your applications, which is rarely possible unless you have full control over your stack. That's the recommended way, but obviously not always possible. We've [exporters](http://prometheus.github.io/docs/instrumenting/exporters/) for things like [HAProxy](http://www.boxever.com/haproxy-monitoring-with-prometheus) and JMX to help you bridge that gap. &gt; Are there any pre-made 'daemon' that monitors basic system-wide disk/memory/cpu usage that could be extended? Or are you expected to write something like that yourself? The [node exporter](https://github.com/prometheus/node_exporter) does that, and there's even some consoles built in for it in Prometheus at `/consoles/node.html` 
I'm sorry you are taking this discussion as being antagonistic, it certainly isn't from my side, your claims of 6000 draw calls per frame just doesn't make any sense to me. Any chance you could describe how your rendering pipeline works ?
This is especially true in a Ruby shop. Performance gains/hardware reduction are secondary benefits.
Well I guess graphs are kinda like waveforms. And you were unconvinced when I said we should consider a resolution better than 1ms :)
Point 5 is a great one. Being able to pick up code and not have to first understand code style before you can get to the task of understanding the logic is really nice.
&gt; Native (and sensible) structure serialization/deserialization. Being able to define a struct, then using json.Unmarshal(someBlob) or xml.Unmarshal(someElement) into your struct with no extra work is obscenely useful. That's not a language feature.
Hey again why are you being so antagonistic? Now from your description your game has some rather high pipeline demands, and to be clear, I'm not advocating Go for AAA type game development, native code and non-GC is pretty much a must to cram the last performance drop for such high end games. But your premise was that of Go being out of range for games due to the overhead penalty caused by calling external code, and that doesn't make sense since the low level api's today minimize the amount of api calls you need to make per frame update. Here's some (old, Go has improved in performance since) videos of a 2d game engine in Go, not near the demands of your described pipeline but it shows that Go with GC should perform well enough in the 2d space for a wide range of games: https://www.youtube.com/watch?v=iMMbf6SRb9Q https://www.youtube.com/watch?v=BMRlY9dFVLg Of course, anything which is possible in say XNA or Monogame etc, will also be possible in Go, they are also garbage collected.
I think I know pretty well what Go can do and can't do... it can actually do much more than the link you provided. [link1](http://www.youtube.com/watch?v=5ZSuD9XDSus) [link2](http://www.youtube.com/watch?v=cjn3twYB7xQ) [link3](http://www.youtube.com/watch?v=uzQ2dnVac3Y) . You seem to have problems with numbers.. since no matter how many times I've explained to you, you keep thinking you can draw a modern game with 2-3 calls.. fine.. I did the best I could, I accept failure.. so I'll just leave you to it. EDIT: If you fancy reading something VERY similar in numbers and testing methodologies try [this](http://code4k.blogspot.com/2011/03/benchmarking-cnet-direct3d-11-apis-vs.html).. it's about evaluating the cost of draw calls using 3 different C# 3D frameworks, at it is quoting a paper from DICE about Battlefield 3 calling at 4000-7000 DC per frame (but yeah.. DICE, a bunch of amateurs right? Surely YOU know better). By the way.. the link puts C# at a cost of 4ms per frame on 7000 DC.. which is slightly higher than what I tested on my machine.. if the proportion is the same.. Go would be at 4x4=16ms on their test machine.. and there it goes, say goodbye to your 60fps. 
What specific problems did you have with StatsD &amp; Graphite?
Not sure about Python, but isolating the dependencies of a ruby application is as simple as changing an env variable, just like with Go. 
&gt; just stop allocating and dropping stuff. That's easy to say, but harder to do. It's not too difficult to avoid the "big stuff" like chewing through multiple megabyte []byte buffers every frame, but if you do any concurrency you pretty much inevitably end up with a steady churn of little objects and you will eventually have to GC, where "eventually" in a game may be "every 10 or 20 frames" pretty easily. And yes, I agree that Rust &amp; Go are not in particular competition. I've seen a few people report the experiences I'm expecting between the two, and I expect them to live harmoniously in the end. A lot of blog ink will be spilled before that happens, though. (Rust is going to end up irreducibly and significantly harder to use than Go. For putting in the extra effort to write that harder code, you will obtain additional benefits that Go can't really provide, but in practical engineering terms it won't always be the right choice; you can get the same thing with people who choose C++ in places where the additional complexity is simply nothing but a burden because Python would solve their problem just as well, in a fraction of the time. If you can get "good enough" for less effort via Go, then you should, and Go has the advantage of offering a much better "good enough" than most of its current competition.)
The language features are reflection and struct tags.
Cross platform GUI stuff is never as refined or good as a platform-specific implementation. Many have tried - the results just aren't there. Best way to go is what Xamarin also does: offers native GUI bindings for each platform, and allow all backend-code to be shared, and Go already has a very easy way to separate platform specific code. Seems like the way to go...
I already own xamarin, its OK, but some of the stuff feels like a real mess sometime. I'm not looking for a cross platform GUI kit, just one where I could use Go for both iOS and Android in the app's code, even if I had to implement the UI separatly for each 
update on this: I have since purchased the video series and I have found the videos to be quite good.
I'm not sure I understand *the page*. Is it some kind of microblog?
I'm a Go newb. Can you explain #3?
Is there a good reason to build your go app inside the container (as he does) instead of just adding the binary?
Looks like it means that all strings are pooled and compressed.
That said, it'd be pretty cool if someone decided to build Prometheus support into Grafana, although we're pretty happy with PromDash at SoundCloud for now.
&gt; `const TEST_STRING = "test"` Should be something like: `const testString = "test"`. See https://github.com/golang/go/wiki/CodeReviewComments#mixed-caps
Hi - I'm the author of that package. I'm not quite sure what you mean by a a named cell range, would you care to expand? 
Any particular reason to call the struct Stringer in your case study? It doesn't implement the Stringer interface... That was one thing that confused me a bit.
i didn't even know that their was a Stringer interface sorry about that, If you give me a sec I will change the struct name to something less confusing.
It means your project can be built by any generic Docker build server. That's important for instance if you want to put your project on github and have dockerhub build and publish images for you.
not finding that github 
https://github.com/go-gl/glow
Lots of similar posts to this on this subreddit. Why not mark gl as simply deprecated... The only problem I've run into so far with glow is the missing x64 windows binaries. The problem I think is that looking at the top level github.com/go-gl repo gl is FIRST in the list and the most obvious choice based on the descriptions on what to use for opengl support in go, whereas glow should be infinitely preferred.
Similar for underscores in the package name. Otherwise nice concise article.
Lol, true :)
Revel framework uses this: https://github.com/robfig/go-cache
You're right, thanks!
Great article, it's a shame it points to the older `go-gl/gl` OpenGL bindings instead of the newer (and completely go-gettable without external GLEW dependency) one at https://github.com/go-gl/glow#usage. For your window/context creation and input needs, https://github.com/go-gl/glfw3 is the latest bindings for GLFW (with 3.1 support coming very soon).
Not a problem, I went through the same struggles you did on Windows so I created this easy to use portable environment for Go. I don't believe in installing so you can look at how I setup environment paths for all the tools you need (yes, you also need GIT and DIFF, but most people won't tell you about DIFF :-) The project sets all the paths you need in this batch file: [__Global.cmd](https://github.com/josephspurrier/golang-portable-windows/blob/master/workspace/__Global.cmd) Shameless self promotion here: [golang-portable-windows](https://github.com/josephspurrier/golang-portable-windows)
Go can't find my GL/glew.h so screw it
If you don't install using the .msi (just extract files using .zip) Go on Windows, then you need to set GOROOT. The go*.msi creates the environment variable GOROOT. By default, the installer points to C:\Go and automatically sets the GOROOT.
Thank you, I will definitely have a look at it.
In your response, you need to clarify that C:\Go\gopath is where you store your src, bin, and pkg folders. If /u/nxshiftit wants to develop from somewhere else, GOPATH should point to that location.
We've been discussing it for a while, and we might soon. https://github.com/go-gl/glfw3/issues/123
Well, the annotations, reflection, and built-in libraries for xml/json (de)serialization *are* inherent to Go. I haven't seen any talk of removing either the language features or the libraries. So when you say "inherent to Go", I'm not sure what you're thinking. Did you mean to say "exclusive"?
Easy, well-defined concurrency. I've just spent the past day writing a python program that needed some very simple concurrency, and it was hell. This program needed to work on python2.4 through python 2.7, and I spent the last 50% of the work guessing why, where and when the GIL was being held, preventing other threads from running. I would say most of the programs I write day-to-day don't need concurrency. But when I need it, I'm sure as hell glad it's as easy as it is in Go.
A solid foundation to build software and libraries on, with the ability to make your libraries/software available with a single command: `go get -u your/import/path`. That's the main reason I switched from C++. Everything else is icing on the cake.
Agree. Also, didn't know about godo - thanks. I tend to just use make - is this not cool anymore?
(Since you've got the HTML loaded according to your other comment, I'm skipping that part.) [GoQuery](https://github.com/PuerkitoBio/goquery) is feature-complete and well-maintained. And very easy to use if you're familiar with jQuery. Once you get the text of an element (like `&lt;body&gt;`) you can just use a bufio.Scanner to read words. (Or use strings.Split)
I like make too :) However, make isn't installed by default on Windows.
 Hi @shelika, Yesterday I wanted to do the same thing, then found your project luckily. I will not waste my time to reinvent the wheel and now focus to make a [slack-cli](https://github.com/siddontang/slack-cli) with your project. Thank you! :-)
When I saw the struct named Stringer, I thought of the interface also, definitely worth renaming it and the similarly named field to something else IMHO
Hey, I appreciate the curiosity. :) I'll quickly point out that gopherjs_serve_html is just a helper utility and completely optional. If you replace the "type/go" with "type/javascript" in index.html and build the javascript yourself via `gopherjs build main.go` and point "src" to the output file, then gopherjs_serve_html is not needed. I use it for development because it automates the building .js output step (and starting an http sever, etc.). Those gist packages are not very idiomatic Go, and they're largely a relic of past experiments. I am slowly refactoring them to be better (good import paths, names, removing useless helpers, etc.). That gist6418462 in particular has 2 funcs for printing source of funcs. You can see example usage and docs at http://godoc.org/github.com/shurcooL/go/gists/gist6418462.
I love the picture with the JS books side by side.
Javascript is a very nice DOM manipulator. End of story.
Hej, tl;dr: We won't open-source Bazooka in it's current form. While we were optimistic at some point that Bazooka needs to be shared with the rest of the community, too many well-designed tools arrived in the meantime which show how the field advanced. Those tools in spirit provide what Bazooka does for us at the moment. We are phasing it out in favour of other tooling which has already significant adoption and support. Baseline is that there is not much to be gained by putting it out next to the very good alternatives, as it doesn't add any new dimension or presents a novel approach to an unsolved problem. Additionally some operational aspects and the usage of un-maintained third-party software are deal-breakers and would require a significant investment to streamline. That said it was the right tool at the right time for us and that is all it needed to be. We are looking forward to how the landscape will develop and hopefully bring some of our experience of running Bazooka for couple of years to other projects. Let me know if you have more questions.
really helpful responses, cheers guys. Maybe a separate question but what kind of distro's are you guys deving on these days?
I use GoQuery everyday and it has never failed me so far. Highly recommended.
Thank. I should have included that :)
Can anyone please elaborate on Go being used for aandroid apps? Will there soon be support for this?
&gt; I suspect mobile developers would much rather develop Android apps with Go than with Java. It's not Java that's terrible, it's the rest of it. Frankly I would prefer Go over Java, but if the whole process is the same then the language is largely irrelevant.
It already is in the latest release. There's also iOS ports nearly ready. https://docs.google.com/document/d/1N3XyVkAP8nmWjASz8L_OjjnjVKxgeVBjIsTr5qIUcA4/edit
...or OpenGL ([mobile repo](https://github.com/golang/mobile))
Are you the writer of the book on the left? http://www.flutterby.net/2014-05-28NodeJSPresentation/diagrams/JavaScriptGoodPartsVsDefinitiveGuide.jpg
What's a 'Google Go'?
I disapprove of posts like this one, claiming "A network throttler in go" which would be interesting code, but then to find that it's a wrapper for tc, which is much less interesting. Downvote from me, sir/madam. Despite the clever name. http://www.lartc.org/manpages/tc.txt
Ahh you are correct on both cases. 
"Image editor written in Go" func main(){ // code that runs photoshop.exe }
And the implication that the "bad parts" are much, much larger than the "good parts."
Node.js has a very big limitation which is RAM limit, if you have a 64-bit server you can use up to 1GB RAM or extend with clusters until you consumed 8GB RAM (assuming you have 8x core), then it freezes..... With Go you have top-tier speed, extremely low memory consumption and amazing scalability
I was teasing at your username, and I get your point.
I know, I replied instead of editing my post. Sorry :) Mostly due to I was heading to a meeting, I appreciate the username joke, I upvoted it from a 0 to a 1 :)
This is why the three-argument slice was created. See "Full slice expressions" under https://golang.org/ref/spec#Slice_expressions 
Submitting my own blog post. Is that OK?
Already in the introduction the problem with the language name is apparent, it's name. First it is the dreaded "Google Go" and after that the author jumps "Go" and "Golang". In this specific case of an quite lengthy article it would probably be better to just quickly introduce Go and then just use Go. I've also made the "Google Go" reference myself a couple of times to be able to reach a point quicker. The word Go by itself is so quickly said that I'm afraid that people won't have a chance to even register it otherwise. Starting to alternate between Go and Golang probably makes it worse having people wonder if there is a semantic difference between the two. The name is great minimalism though and I support that decision. I just have to learn refer to it as "the programming language Go" or something similar.
Almost none of the built-ins beyond chan communication have any kind of thread safety to them. If you use a built-in function without reading how it works (eg, http://golang.org/ref/spec#Appending_and_copying_slices), you're going to have a bad time.
You can write nice code and elegant APIs in Java, but much of the ecosystem is not so. Android development is one of those not-so-elegant things, and moving to Go wouldn't alleviate that. Of course, if Google wanted to move forward with Go as the first class language of Android development, it would likely necessitate a rewrite of core systems, which in turn would present the opportunity to make them elegant.
The problem here is that there is no way to get a timeout on the read of the stdin. Why one would I want to do this? I'm running a state machine that is taking user input and I don't want to block the display of messages that are occurring while the user has yet to press return to complete the blocking read. I can't find any way around polling selected channel of a go routine that sends the read io to the channel that is selecting it. The other things I've concluded is that as I've written it, the Close() routine will cause a deadlock on the threads. Close() should do nothing... It's unfortunately pathological, and not idiomatic, but I don't think there's any other way of getting this desired behavior. 
Complaint about no IDE support? Why would Go need IDE support? 
All strings are compressed and concatenated inside one large buffer that don't have any pointers that GC should follow. This allows you to store really large amount of strings in there without increasing GC pauses.
Yep.
That is...strange. Why not? Did you meant `users/count` for the second route?
Easier debugging, with e.g. instruction cursor, locals/watches/stack traces, etc. Sure, GDB can technically do that, but it doesn't work on all systems (you need a finicky Python plugin) and is pretty hard and/or inconvenient to use.
bone have been updated since the last benchmark.
You missed the point that Collection is a nested list, so the example would be like this var sum float64 for _, v := range input { if v.Flag { for _, u := range v.Collection { if (u.Cost &gt; 50) { sum += u.Cost } } } } It is already quite a lot nesting levels and some temporary u and v variables that, when actual operations have more than few lines become hard to follow. Extra allocations are of course a valid point, but in my opinion readability/concern-separation should take preference, because unless this code is on some performance-crititcal path, the difference would be neglible. And if it is, then it will most probably not change much so it can be rewritten to iteration-approach. In Go, the problem is, that implementing proper, type-safe map-reduce would probably require support for parametric polymorphism.
Check out this [excellent presentation from the last GoCon on anti-patterns](http://talks.golang.org/2014/readability.slide).
I have found Google employees to be excellent sources of gopher t-shirts.
GoFirstWorldProblems. :)
go style has fewer nesting levels. ie var sum float64 for _, v := range input { if !v.Flag { continue } for _, u := range v.Collection { if (u.Cost &gt; 50) { sum += u.Cost } } }
Even with languages with well-supported debuggers (and I admit it's not a good story with go) I prefer prints. Not just logging, because these are things that are only in when I'm looking for a problem.
Yes, but at expense of more lines of core, thus creating more cognitive burden. Also, following what is happening in this loop is a little hard already (at least for me). Again, my case is not that one is more powerful than the other, since they are both doing the same thing. It is not a case of code golf either. My completely biased, subjective opinion is, that iterative style does not separate concerns well. You basically tightly couple the HOW you iterate over the collection with WHY you are doing it. This tend to create issues when someone needs to modify that code, because they need to very closely follow all the execution paths and variable flows to be able to understand what is happening. Also extending this loop makes it harder to understand, follow and maintain. Think about the case, that now, instead of summing costs, you need to add Cost &gt; 50 items to the array, sorted by Cost. In functional style, you just modify a single line to archive that. In iterative, you need to create temporary list, maintain it sorted etc. How many lines of code you need to change to archive that? This code will probably get copy-pasted to 3 different places where simillar-but-not-the-same behaviour is needed creating maintenance overhead. Anyway, map/reduce style is just another tool, as the iterative style is, I think both has their usage. I think it is worth learning and understanding, it requires some initial time to get used to. EDIT: I accidentally a word
Naw, they need to send a cease and desist first.
There's on SO an explanation of exactly the same behavior : http://stackoverflow.com/q/27568213/263525
As a rule of thumb: if the name ends in "-er", "-or", "-able" it's probably an interface because it describes behavior (what it does) rather than what it is.
&gt; Yes, but at expense of more lines of core, thus creating more cognitive burden. With respect, that is crapola, especially for this example. Nesting provides more cognitive burden than a continuation clause at the beginning of a loop.
+1. This talk was great. One comment about field ordering in structs. If your struct will be used in a large slice that takes a lot of memory, it is probably more to your advantage to give up some readability and save memory by packing the struct (ordering the fields) so that fields align on word boundaries. (Like C structs.)
If you've got interface{} all over the place you're probably doing it wrong. If you are a beginner and think your problem needs reflect or unsafe you're probably doing it wrong.
Very nice! Good work.
functional vs procedural style mostly. If OP is trying to write functional Go I can see where he/she might run into issues.
I didn't even know it does multiplexing. I'm new to this. I you had to have a third-party add-on for this. 
My head is spinning with the long list of options. All the benchmarks starting to make me sea sick. The more I research this I find more attractive options. Now my new favorite is https://github.com/dimfeld/httptreemux :)
not actually designing your app out front and just diving in to code it all without having enough experience to do so
I had to change O_CLOEXEC to be zero in the Go source, and only for the 5.1 release's kernel. I did some fairly low level work and on later kernels I didn't have issues.
I'm guilty of this. And it always comes back to bight me. Do you have any resources for learning how to properly plan out and design a project? How much detail do you go into when designing? Is it just a back-of-the-napkin design with a few requirements laid out up front and the rest will get filled in later on when more is known? Or do you go into great detail upfront on the design and have things planned out relatively well? 
Something like http://play.golang.org/p/zjRGOHJ-Hl maybe
My understanding is that there were some kernel behaviors regarding high resolution timers and some other calls that don't do the right thing from Go's perspective. Googling 'golang on centos5' yields a handful of articles that are all on the old side. I also found this, which again, has some stale info: https://github.com/golang/go/issues?q=RHEL5 
That's what I ended up doing in my production code, I simplified it (perhaps mistakenly) for the blog post.
the tools can do this for you. run go get github.com/haruyama/golang-goji-sample/controllers go get github.com/haruyama/golang-goji-sample/system etc... or try: go -u ./..
Thinking of errors as strings. I've seen Go programs where every error returned is an errors.New/fmt.Errorf call that isn't even assigned to a variable, making it very difficult (and brittle) to inspect the error.
I don't really see this anywhere (at least not as an antipattern). Usually I see reflect/interface{} used when there really aren't better solutions available (check out `container/list` and friends). The only antipattern example I can think of is Martini, which tries to be too clever with its reflection magic (the author admits as much here: http://blog.codegangsta.io/blog/2014/05/19/my-thoughts-on-martini/). 
Wonderful! Thanks!