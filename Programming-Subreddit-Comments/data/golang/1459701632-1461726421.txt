Was more taking a dig at package managerless languages. But then you probably have mirrors of websites and packages hosted elsewhere. 
The implementation from the paper: https://bitbucket.org/cyberroadie/go-sctp
Hi Everyone. This is really in early alpha, with a couple of things missing. But I really hope you guys like it, and that you find that it's a fun project. Feel free to submit any issues, and any comments, and regards are very welcomed. I also know that a code needs a bit of polishing here and there... :P I'm working on it. :) Thanks!
Hell yea, that's a fun project. =)
This seems to rely on a lot of C, which kills cross compiling :(
The [commits](https://bitbucket.org/cyberroadie/go-sctp/commits/branch/sctp) for the SCTP support were written in late 2012, several months after the release of Go 1.0. The Go runtime was still largely written in C until Go 1.4, so it makes sense this code is a mix of C and Go. I'm curious to see how much work would be needed to modernize the code, e.g., so it could be up streamed into the `net` package. SCTP would be useful for a number of applications, like publishing metrics (monitoring data) from servers/applications.
I recommend inserting the list of features/benefits into your framework's readme. When searching for a web framework, the first few questions that I have for each framework that I see are: Q1) What can this web framework do for me? Q2) How easy/hard is it to use? Your readme needs to be able to answer at least Q1 at a glance. 
(Side-note: people are too trigger-happy with the downvote button.) I expect it'll definitely be worth it in the long-term, for all the reasons that many projects are worth doing in Go instead of C. The new SSA backend which is giving us smaller executables and faster compiled code is already one payoff, in a very short amount of time.
From what i see: * That is not web framework, more a CMS: You present fixed-structured pages. * I failed to see any MVC * Do a README describing the ideas * Don't name your sql.DB con (it's not a connection) * Don't register Routes using a YAML file (we are not Ruby)
You can use "go build -v" to see which packages are being compiled and "-x" to see actual process calls in case you want to dive further. The important part is to understand that "go build" doesn't cache compilation of packages, it just creates the final file and throw all intermediate files. So if your program is made by 3 packages, "go build" will normally recompile all three of them. You can use "go build -i" to force Go to create .a files for dependent packages (stored in $GOPATH/pkg), so that you don't need to compile them over and over. I run "go build -i" as my standard build command.
OMG, full 3D support, too!
&gt; Debugging: gdb and pprof both work with Go Delve is showing great promise as a *Go aware* debugger: https://github.com/derekparker/delve/ Early on it only worked on Linux, but these days it is even better as it now works on Windows as well. 
&gt; The GoNet code is more readable and generally performs better than that of its C stack counterparts. Fascinating if true. I wonder how much that's due to being just a subset of full functionality and how much is due to Go being easier to write than C. 
Use ffjson or better yet easyjson, both are blazing fast.
I can't tell if this is disparaging or not, but I'm seriously considering checking it out. I enjoy Go, but there are still some pain points that Pony (at first blush) seems to address.
Everything I've seen looks pretty neat. Does anyone know about benchmarks? The only benchmarks I found were comparing it to Erlang, Scala, (I have no experience with either) and some other languages I've never heard of. Obviously this language is nascent and optimization opportunities abound, but I'd like to understand what its performance class is.
Sweet! I debated creating this myself. Any chance you can toss in some sorting within categories by stars?
This awesome. If somebody ask you about search feature, tell about Ctrl/Command+f, or *grep* it from *command line*
&gt; "go install" actually installs your app to $GOPATH/bin Or `$GOPATH/pkg` if it's not `main`.
I was just pointing to the fact that this issue seems to be resolved now. At first I actually thought rsc's comment was because of the post.
Yepp, also, fully portable, and can operate on a raspberry pi!
Hah, totally. I compiled a list of Rob quotes internally for years before showing it to him somewhat recently.
The lowered latency is a HUGE win for end game raiding.
Also, it's completely legal to fully automate it! I even encourage people to come up with bots to play this fully emerged game, with a deep and engaging story line! 
Use `go build -v -i`, whenever something's slow. You'll figure out what is slow and it will probably not continue to be slow.
Ran "go build -i" on one of my "gin-gonic" test programs. It doesn't seem to make the compiling faster. Which is kind of weird, isn't it? You would think that not compiling these dependent packages would make the compiling faster: import ( "database/sql" "log" "strconv" "time" "github.com/coopernurse/gorp" "github.com/gin-gonic/gin" _ "github.com/mattn/go-sqlite3" )
Fine i could discover libs that I didn't know... How did you select them ? It lacks some famous, for example govendor and gb. I would like to see how much dependencies they have and the date of the last commit for example...
Oh, wow, I had written similar tool myself for personal usage ([github](https://github.com/yamnikov-oleg/fabulous-go)), but your's even cooler!
Have run the "go install #pkg_link" on all of the github packages.
Nothing like hacking up an automated test, good on em.
reddit is a rude place. A thread called "beginner looking for feedback" wouldn't have been shot down. 
Interesting, but I’m wondering what is the memory usage of the Go implementation compared to the C implementation, what is the impact of garbage collection, which version of Go was used, and how good is tapip compared for example to Linux or FreeBSD stack (it looks like /u/hegbork answered my last question in another comment). 
Me too! I remember excitedly pointing it out to my friends. (no one cared, I have no friends)
What is this guy trying to accomplish with his misleading and lies?
Go's dependency management story is vendoring. Not sure how that makes it reliant on Github?
Ok. It just seemed worth clarifying. :)
It doesn't. The fact that all of the packages are on GitHub does. I feel like this is pretty clear. When you install a dependency for go, you download it from GitHub X% of the time. When you install a dependency for node, you download it from NPM Y% of the time. Both of these statements are true, and X and Y are each very close to 100. That's literally all I'm saying.
Cool, so kinda like https://mholt.github.io/json-to-go/
Not yet. I should return a error message or make a request to &lt;server&gt;. What do you think is better?
I'm pretty sure the "no implicit interfaces" is incorrect. I remember hearing in one of their talks that they have both nominal and structural sub-typing, so you can choose if you want an interface to be explicit or implicit.
This issue was the reason I switched to https://github.com/gocraft/dbr. Good to see a pretty easy work around although imo it's nicer to have the data access lib handle it.
&gt; Go doesn't need to "redownload the language". I'm not saying *Go* does. I'm saying the *CI* does. The CI spins up a brand new instance of Ubuntu every single time it runs, so it needs to set up its environment again. The only way to get around it is to cache the dependencies (which our CI actually does automatically on a more abstract level by caching entire build steps), which I believe is what you're calling "vendoring". Correct me if I'm wrong, but Go recently added this feature by automatically including a vendor folder in every repository, and what you're saying is to include that vendor folder in the source control. Please let me know if I'm misunderstanding what you're saying. NPM does that automatically, and has been doing that automatically for as long as npm has existed (I believe; certainly since before Node's first major release). The difference is that people *generally* don't put the node_modules folder (the equivalent of the vendor folder) in source control. That's not really a language or environment difference, so much as it is developer decisions. You could argue that Node developers (in this case, this includes Facebook) make the poor decision not to include the vendored dependencies in source control, but you can't really argue that Node relies on npm uptime more than Go relies on GitHub uptime.
Thanks for this. Right now I'm using go-metrics' Meter everywhere and sum the m1 rate in a graph. Looking at the code of [meter.go](https://github.com/rcrowley/go-metrics/blob/master/meter.go) it looks like I could use the value returned by Count() to do what you suggest. I did try it, and it *looks* like it works, however I get some weird behaviour in my graph, like there's a massive peak at the start of the graph no matter what I do. I'm not sure if it's because of influxdb or grafana.
Good stuff! This automates what I've been doing by hand for the past couple days. Haven't tried it yet, but pulling it down now.
this tool is so freaking awesome
&gt; Nothing npm does is ever runtime, actually. It's not even compile-time. It's install-time, for which the best analogy is "whenever you run go get". And if you have all of the dependencies already in node_modules, npm install does nothing. (well, it validates all of the dependencies are there locally, but it has to do that, doesn't it?) The difference is that `go get` is run *only* when you want to add or upgrade a dependency whereas `npm install` is typically run on every build. &gt; Also, from what I can tell, the vendor folder in Go was only released in August 2015, and only by default a month and a half ago (1.6). That's what I meant by "recently adding this feature". You're confusing the general idea of vendoring with the addition of tooling support. I'm talking about vendoring in general, explicit tooling support is irrelevant to this conversation. &gt; As for releasing vs. simply adding as a dependency, it's weird to say that tarballing is the closest analog to static linking. When you install a node module, most of the time you're using it as a dependency, and all of its dependencies are installed at the same time. If it's coming from a tarball, it itself does not contain the dependencies, but where are you getting the tarball? The tarball is analogous to the statically-linked executable file. Dependencies in Go are source-code only. The source code for the toplevel program should contain everything needed to build the aformentioned tarball. No tarballs are injested. For example, if you're writing the node program `foo` from scratch, you'd `npm install` your dependencies into your `node_modules` directory and commit them to your version control. You do this every time you add a new dependency. Then your build system bundles this all up into a tarball to distribute/deploy. That's the intended analogy at least; its accuracy may be dubious. &gt; I don't think it's a spectacularly bad idea, and it mirrors many production environments (Docker and things like Docker). Production environments need not have the Go compiler installed. Go programs have no runtime dependencies (no interpreter, no VM, nothing). By requiring your CI server to re-download the Go toolchain for every build, you're just slowing yourself down and adding in another network dependency for no obvious gain. &gt; But my point is that if you have to download Go, you have to download the dependencies as well unless you've "vendored" them, which is basically what we're talking about now. You don't have to download Go and you *should* vendor your dependencies. &gt; for the record, this whole argument is a little moot because most node development occurs without vendoring The conversation about vendoring is relevant because you asserted that Go is equally susceptible to a leftpad-esque fiasco, which is untrue because the Go community solved this problem with vendoring (Go did not invent this, it's just conventional in this particular community).
Can someone explain what exactly is `m := New()` doing in the following code? func TestMapCreation(t *testing.T) { m := New() if m == nil { t.Error("map is null.") } if m.Count() != 0 { t.Error("new map should be empty.") } Why can you create a map without declaring the map itself? I would assume you have to do something like m = make(map[string]Animal) 
The inability to use IN with params and not being able to access multiple result sets returned from my stored procedures are the only real walls i've hit with Go. I look forward to them figuring some way of handling this in the STD Lib. I use SQL Server via ODBC. 
There is a New () function in the package that does just that
This is from /r/enneff's introductory video back in 2012: https://youtu.be/XCsL89YtqCs?t=3m45s
[Go 1.5 Vendor Experiment](https://docs.google.com/document/d/1Bz5-UB7g2uPBdOx-rw5t9MxJwkfpx90cqG9AFL0JAYo/edit#)
How does an intersection type differ from a tuple?
Personally, I would expect that to work and just assume the path is /.
I wonder how much overhead these will add once they're implemented server-side.
Yes, especially the copying of the *Request each time.
Yes, that's true. It's a gotcha. Sorry. I'll try to improve the documentation of the Var interface to make that clearer.
Thanks
Yes, at the moment. I want to extend it, but wanted to see first if there is some interest in it at all.
Looks like the link DDOSed the site. Maybe Rails? :P Update: Looks like Heroku. Maybe he got over the free-quota.
I don't think it's a performance problem, but it's not necessary: At least the documentation of the redis client used claims to be thread safe and also uses a connection pool.
My 3 most wanted additions in the Go ecosystem: * Pure Go, cross platform UI library * A way to write UI for mobile with pure Go * Adding context in http and database/sql Having the 3rd will already make me `fmt.Printf("%v%%", 100/3)` happier!
&gt; 1. Pure Go, cross platform UI library &gt; 2. A way to write UI for mobile with pure Go +1
Don't know if it could be possible, but i would like to see which one i already stared (to make a personal bookmarks, and see bookmarks of others...)
Thank you! Your javascript solution is really elegant. Good work.
The `defer` also has nontrivial overhead.
So you have measured how it performs against a Redis Round-Trip?
There's quite a difference between your first two points and the third. I don't see the first ever happening.
Is it usually better to take in structs as pointers to structs in arguments to methods? In what cases wouldn't you use a pointer (besides when you are taking an interface)? Coming from a language (Ruby) that doesn't have pointers so I don't have any intuition there.
&gt; There's quite a difference between your first two points and the third. Indeed. UI capabilities is what Go is missing the most and other than that the rest are pretty minor for me.
&gt;The key benefit of Go over Ruby is parallelism really? 
&gt; and block that port on the host. However, the stdlib doesn’t support this in any form, so you’d have to pick a stoppable http server Incorrect. All you're doing is making sure something is already bound to that port so just use [`net.Listen`](https://golang.org/pkg/net#Listen). E.g. something like: func TestFoo(t *testing.T) { // Bind to port 1234 l, err := tcp.Listen("tcp", ":1234") if err != nil { // do something, perhaps t.Skip() } defer l.Close() // close at end of test // Test that something correctly detects that // it can't bind to port 1234 } 
In Go, the interface system allows you to easily construct useful error types whilst implementing the error interfaces so it works with useful functions from the stdlib. type MyTypedError struct { UsefulInfo1 string UsefulInfo2 int } func (m *MyTypedError) Error() string { return "blah" } When you receive an error from a library you can then make a type assertion and get the useful info you need. You can also have known errors as values and compare for them. I suggest you read the following: - https://blog.golang.org/errors-are-values - http://blog.golang.org/error-handling-and-go That's not to say all libraries out there *actually* return useful errors, but that's true of any PL (how many Java libraries just `throw new Exception("derp")` ?). Using a library that has crappy errors? Fix it :) 
Did you read my post? If I'm dealing with lots of library code that can return multiple errors, I can't rely on type-casting because I don't know what the type is. I need more by default than a string. Besides, I shouldn't have to write all this myself. I had read both of those articles before making this post. They don't change a thing about my complaints. As far as I could tell, the error I described originated in the standard library. How am I supposed to change that?
IMHO, writing it *backwards* only makes it more confusing for zero gain 93% of the time.
&gt; Is this ok for performance? Since you need to ask (i.e. your benchmarks and testing didn't suggest otherwise), the answer is *yes*, it's fine.
&gt; Besides, I shouldn't have to write all this myself. This clearly illustrates the "problem" all this complaining is about.
I knew about all these, but I always have to Google them any time I want to change them. Saving this for next time I need to do this.
Just curious, where else has it popped up? It's kind of strange, them picking out _this_ video in particular.
Looks like it's a local cache that gets written to Redis when `Release` is called?
The kinds of errors that could be returned a part of the API and as such they are potentially subject to changes. i.e. if a developer wants you to be able to distinguish errors, they will document which errors could be returned and what they mean. If they only offer you the error interface without further information, then they want to keep them an implementation detail and by not treating the error as opaque, you are violating encapsulation and potentially make yourself vulnerable to subtle bugs when the API breaks. If the developer of a package only gives you an error, then that's because that's all they want you to have. Take for example the [http-package](https://godoc.org/net/http#pkg-variables) -- they clearly want you to know some of the errors that can happen, so they give you the ability to explicitly check for them. They don't want you to handle other errors, because other errors are implementation details and subject to change. Frankly, I don't see any real difference to other languages. No matter if Java or Python or anything else with exceptions: You catch exceptions by type or by catch-all and if something changes the exceptions they throw, you are pretty much fcucked.
I suggest using strconv.Quote() to do the quoting, which is what expvar itself uses for expvar.String.
&gt; I can't rely on type-casting because I don't know what the type is. How are you going to handle an error if you don't know what kind of error it is?
Well, I'm just getting started with Go, so I'm kind of asking all these questions to better understand how things work.
Why the requirement for no external services? I use https://github.com/sendgrid/sendgrid-go (disclaimer, I work with SendGrid). You could also look into https://golang.org/pkg/net/smtp/
&gt; unless I go into the implementation code and check out all the errors everything can return. This violates encapsulation! How does it violate encapsulation? If a package has defined a few errors like `ErrNotExist` staring with capital then it's an exported variable which you are meant to check for. It's basically part of the public API of the package. The same way you are using the packages's functions, the same way you use it's exported errors. Read the documentation of the package and you might not even have to check the code. I really cannot understand where the problem is.
Just use the net/smtp package to send the email. Then you can use your local system or any other mail servers for outbound mail.
It probably shouldn't. strconv.Quote produces Go-quoted output, which is similar but not exactly JSON.
The Python docs explain it best, I think. You can think of indices in a slice as being *between* elements. For example, given the string "example": e x a m p l e 0|1|2|3|4|5|6|7 If you only have one element, there are two slice indices: One before the element and one after it.
Can you elaborate on why allowing index to be len(str) has to do with append(a[:i], a[i+1:]...)?
Very interesting; never knew about this, thanks!
This exactly, well put. Additionally, combined with open ending as Go has, it's very convenient for various string manipulations, as gohacker mentioned.
So do these additions make four now? https://www.cvedetails.com/vendor/14185/Golang.html
The problem is two fold. How do I interface with a mail server using Go? How do I setup, maintain and secure my own mail server? I think you need to figure out the latter first then worry about interfacing with Go. Just my 2 cents
This part? Well, as secure as your TLS implementation is. Just remember to do password hashing for storage.
I have never seen routing show up in my profiles.
Depends on the router you're using. One of our massive 10k+ LOC API servers that serves 10's of thousands of requests per day uses Martini as the framework, which relies heavily on reflect and other dependency injection. When doing a heap profile we see that as much as 20% is used in Reflect calls, specifically Martinis dependency injection and router. 
also, routing benchmarks are a bit wonky, is your app's performance really dominated by routing? really?
I don't know much about netsec. I just skimmed the wiki on side-channel attacks and the docs on subtle.ConstantTimeCompare(). How would an attacker use this current vulnerability? Can you infer the length of the password by the time the comparison takes?
So if I understand this correctly, everybody using v1 and not vendoring now has to update all code? That's one of those things not handled well in Go at all. Sure gopkg.in exists - but not used as widely as you would expect/hope... Anyway - for the future's sake - change the `github.com/labstack/echo` in the installation step etc to gopkg.in...
Thanks for the tip! It's corrected in the article now.
I tried to make the code to look a little bit better (completly untested): https://play.golang.org/p/Xxx1VaMOGa What do you think?
The equality operator short-circuits as soon as it finds an inequality. So you begin by trying to guess the first character, and once the time it takes increases a little bit, you know you've guessed it correctly since it tried to compare the second character. And you keep going until it lets you in. Thus constant time comparisons are used, as they prevent counting timing to estimate progress in guessing the password.
I'd love to read a more recent article that would include the latest improvements in Go, especially the gc, if and how it affects Go's domain reach and similar for Rust.
That makes sense. Thanks for the explanation.
No, but look for global mutexes for map access
Go and Rust both derive from dislike of C++, but they have different reasons for disliking it. Go says that C++ is too *complicated*; Rust says that C++ is too *dangerous*. They both agree that programmers cannot be trusted to handle memory, but they have different ways of fixing it. Go handles the memory for you; Rust won't compile unless you handle it correctly yourself.
Sounds about right. I've thought on several occasions that Rust is what C++ would have been if it was designed entirely around the STL without the C compatability. I guess that explains why it drives me nuts every time I try to learn it. Go is, as someone said, 'a better C, from the people who didn't bring you C++'.
We're too entrenched with Martini. We tried once to make the switch but with the dependency injection nothing was standard. 
PSA: if you don't vendor like we don't feel free to use our company 1.3 fork that won't be updated: [github.com/kyani-inc/echo](kyani-inc/echo) Or feel free to fork that yourself. 
&gt; Rust can do everything Go can, but faster, safer, etc. Let full fledge Crypto / TLS libraries appear for Rust then we will know that Rust can deliver useful and practical software for users. For now Rust has Servo web render engine which still has major chunk of C++ code in it 
Check again: [https://github.com/servo/webrender](https://github.com/servo/webrender) Not a line of C or C++ It's already well known that Rust can deliver useful and practical software for users...it's stable and used in production. Not sure how your counter point is an claim against the one I made. It is pretty well known that any program that manually manages memory will always be faster than a GC...
I commented on an earlier commit (about adding ffjson not being useful because it was not using the code gen aspect) and the dev seemed opened to pull requests. Perhaps redo your work as a bunch of tinier commits and submit it! 
I wish the Rust folks the best but suspect they are going down the same path as Scala. The language is trying to include too many features and not enough opinion about how to use them. Go is very opinionated which leads to more maintainable code. Rust's power and complexity are a blessing and curse for coders especially maintainers. Ideally, I want an opinionated nature of Go with the safely of Rust.
You can make a channel in Rust just as easily as Go... Rust actually supports both 1:1 and M:N threading models. Again, as the author stated, Rust has more control. 
No - they only have to do that if they pull down updates willy nilly and don't check their dependencies in any way.
&gt; Rust actually supports both 1:1 and M:N threading models Care to share? Nothing is turning up on Google search results for "Rust M:N threads" or "Rust goroutines". EDIT: According to https://news.ycombinator.com/item?id=10225903, Rust's lightweight thread solution was removed from stdlib, so it doesn't actually have an M:N threading story. The solutions seem to be `mio`, which is (apparently) very similar to libuv, that is, an event loop model, not a threading model.
Lucky is the engineer whose server requests occur evenly throughout the day.
In production I would surely use gorilla sessions. I actually nearly used them for this tutorial too, but I had some problems with the session saving and didn't feel like solving them (gonna investigate this when I have some time), and just used the cookie libraries.
I actually don't know for sure, but is it a race condition where you change the owner of a lock with an atomic pointer swap and not holding the lock, while other methods check the owner with an normal equality test and increment the depth? it would seem that someone could swap the owner while another is doing the equality check on the owner. 
Cool, I think I recall running into something like this too, from what I remember you just need to put something into your session and save it before it actually creates a session cookie with Gorilla.
Thanks for the tip! I'll check it out as soon as possible, this may have been my problem.
Maybe I am reading it wrong... Let's say no one owns the lock so owner is nil. Two different callers call Lock with their ids. One of them will be able to compare and swap to take ownership, but we don't know which one. And one of them will acquire the lock, but we don't know which one. Does that not mean one caller could get the lock who does not own it, and then when they call unlock, it panics because the cx doesn't match? 
Hey, I'm the author, if there are any questions feel free to ask me. I say that it's almost feature-complete because I have yet to implement a "/scrape" endpoint. However, at the same-time, a "/scrape" endpoint isn't actually necessary, but for my URL of choice, it is. There's still a lot to be done, but I've enjoyed learning (yeah, the code's gonna be really ugly) Go with this project.
Both blog posts happened within a day of each other. I remember the discussion was about both of them. I couldn't find the reddit post for this second article but I figured anyone interested now might want to go back and see the comment thread from last time.
I use gmail to send emails in some projects and it still works - checked it yesterday. You could use a sysvar to hold the actual values so those are kept out of the code. You should never ever put credentials in (public) gits. 
Rust's safety is not just about memory management, but all resources. (Files, network connections, etc.)
woah this is cool
Hacker News has an [official API](https://github.com/HackerNews/API) which* would work far better than scraping their site.
It already works in visual studio code,for the record
That error is caused during linking. Make sure your user has permission to read the /usr/local/go folder.
Have you used Atom with go-plus? If so, which do you like better? That VS cross platform editor looked kinda nice I just haven't spent the time to investigate yet.
It is? I generally use it to see if my code compiles while developing, but before I'm running tests. What's so bad about running `go build`?
What's the "Interface" example supposed to be showing? You don't use the Sampler interface at all.
`which go`
I gave my user perms to the repo and the error has disappeared, thanks! Although now I'm seeing something now; I'm seeing corrupt input when trying to use http.Get
As I read on programmers.stackexchange.com: Java succeeded because it had Oracle behind it. C# had Microsoft. Rust has Mozilla, but look at who Go has: Google. Give it a few years, and it's going to be huge.
Why is this so important. If tou needed that type before you just had to declare it. No need for a dependency just for an interface definition.
few questions for you about this 1.) How'd you even find that? 2.) How did you get clearing the gopath/pkg from that? 3.) When you said clear what did you mean? I just moved everything in that directory out into another one and then tried running the program again (with go run, vs go build).
If the Go standard library needs a ReadAtSizer then it makes sense to define it in the Go standard library. Plus it standardizes the odd possibility of some implementations that call the method `GetSize()` or something else instead. Nice to have for global compatibility.
naw it didn't work ah I was just searching google, I'll search golang.org in the future, thanks! How does the pkg folder get repopulated?
I believe go build and go install will cache object files in pkg.
Just tested it, works beautifully! This is incredible!
bah, I rm -rf the directory within $GOPATH/pkg, ran go build on one of my other projects, and then checked the pkg directory and it's still blank O_O
The article is full of mistakes and inaccuracies. Like any other reporter. the author clearly didn't took time to understand/check everything
http://doc.rust-lang.org/0.11.0/green/
I think it's more like D being the "fixed" C++ (along with some fresh, new language complexity) with Go being the "fixed" C, with a more conservative feature set. Both now having a GC as a major component to make developers more productive as well as safer, but also a common characteristic that they are pre-compiled to native code. I think maybe it isn't all in black &amp; white and there are three groups here? With the GC and high level feel of D, yet being pre-compiled to native code and allowing low level code, I think it really formed a new group and that was/is its main attraction. Java / .NET / Python / Ruby / PHP / Lua &lt;==&gt; D / Go / Nim / Crystal / .NET Native &lt;==&gt; Rust / C++ / C.
Java had Oracle behind it?
Good post If there's one thing to me that's sad about Go's design is mutable package variables. - Encourages nasty global state - Often used in an opaque way - Can introduce maddening bugs by accident
It's strange to think of both a REST and GraphQL API framework in one project, just because GraphQL needs just a single http method and single endpoint.. if GraphQL works out, it could be the successor of REST, which I sure hope happens. But first we need a solid, clean and well functioning graphql library for Go. And who knows if the GraphQL spec itself doesn't need some time to bake further
For the case the error does not contain data, instead of constants, just use an empty struct: type EOF struct{} func(EOF) Error() string { return "end of file" } // ... func someFunc() error { return EOF{} } // ... err := someFunc() if (err == EOF{}) { // ... }
Well, storing it in memory is a-ok so I misspoke earlier (Redis uses in-memory storage), but it just adds on something for the tracker to handle. I think that Redis (or another in-memory KV storage) fits the use-case for peer information better than an in-house solution for a few reasons, really: it handles peer redundancy, so the tracker doesn't have to; it offloads burden from the tracker to another application and in Redis' case this is an application that has a lower system-wide burden; and it's ridiculously fast. When I was building Notorious, I was looking for a solution that could scale well enough to handle TPB, WCD, IPT levels of traffic and while Notorious isn't yet there, I think the grand picture of Notorious would be well suited for the task.
GraphQL is just a different way to access your data. Think of REST Layer as a way to express the schema of the data you wanna expose in a generic way. The “protocol” used to expose this schema is then exchangeable.
O HAI DO YOU ALSO LIKE UPPERCASE MENUS
Indeed, but historically memory management has been the biggest source of safety problems in C.
As noob I'm surprised that a map that you write once and is read the next times create contention. Is not [RWLock](https://golang.org/pkg/sync/#RWMutex) for this kinds of things?
Could you post a gist? Thanks!
This is almost the definition of an unnecessary micro-optimization.
I think the advantage to the JS way is you can do error handling for both functions in one place, if you don't care much about it. It does make it more difficult to distinguish though.
Wow, I wonder how people come up with this sort of useless ideas.
I think this is pretty cool, but this post currently stands at 12 votes total with only 4 points. Downvoters want to explain why?
It's really getting the gears turning.
Without hating on the OP, I don't find this project to be particularly useful or interesting. nil pointers are the least of my problems in Go, and besides the additional build system complexity, I think the new optional idiom costs more than it saves. Props to the OP for making it, even if it's for his own personal interest, but it doesn't seem to be particularly interesting to me. If you disagree, feel free to use your upvote button accordingly.
Hey, at least they took the time to understand the language/project's name is "Go," not "Golang." That's better than most!
IMO, the pattern of https://golang.org/pkg/os/#IsExist, that is a function that takes an error and indicates if it indicates a certain type of issue is a much better approach. You can keep the error instances private if relevant and they can evolve over time without being tied to a specific implementation.
Yes, no, depends. Run besides your Tests a parallel Benchmark function. This gives you more insight than any guessing. Try with sync.Mutex and sync.RWMutex and even such a thing: https://github.com/coocood/freecache/blob/master/cache.go#L12 distributed locks.
map[something]bool is more useable and reader friendly. No comma ok idiom.
Merge it!
Well done! But isn't building a REST API and integrating it with a database already really easy without frameworks like this in Go??
`map[T]bool` has three states: true, false, and not present. `map[T]struct{}` has only two states, present and not present. In this case, we get lucky in that the value returned from a map[T]bool is the zero value (false) if the key isn't present. `map[T]bool` also tempts you to assign false to a key rather than delete it. Depending on how the set is used, the items in the set could be a small number, but the phantom falses will never be removed. Also, using `len` no longer returns the number of items in the set. As far as readability, I'm torn. `map[T]struct{}` can only be used as a set. I think it's a common enough idiom that many programmers will recognize it. `map[T]bool` can be used for storing actual bools for keys, in which case present and false might be significantly different from not present. As people have said a million times, it's very unfortunate that we can't define a generic `set[T]` and implement it 1 time the most efficient way.
Question, when will an orm handle the nastyness of structs with slices in them for me? I know this is a driver level issue but I can write some awful boilerplate which circumvents the issue for me so I don't know why these ORMS can't handle that. As an example I have some struct: type ItemFromSomeoneElsesAPI struct { Name string References []string } This doesn't work with GORM does it work with this?
Wouldn't it be incredibly hard to accurately measure those small time differences when you as a third party (duh) get different ping-times on each request?
I agree with this statement... Also, Optionals are great, but creating a whole new dialect of a language and adding even more complexity to the build process in return for lanugage-level optional support doesn't seem to be a good trade off... I would much prefer to just create a an Optional type in raw Go, similar to how Optionals are implemented in, say, Java.
Not sure if this is still the case, but reddit used to add downvotes to confuse bots. See: https://www.reddit.com/r/explainlikeimfive/comments/z4o44/eli5_why_reddit_autodownvotes/
Go build doesn't cache, only go install (and go get, as it includes install step in default application) does.
I've never done it, but probably. Still, I'd rather not rely on network conditions for my account security. You also assume the attack is mounted over the network; it could be an inside job.
i didn't realize the Washington Post had a section dedicated to computer science, good for them.
They do fuzz the numbers a little bit but with ~12 up votes with (at the time) 67% upvoted there were a few. Not that it matters or anything, I just wanted to see some discussion.
Thanks for taking time to reply ;) The web side of development is still quite new for me.
This is incredibly difficult to achieve without generics though.
Autocorrect will get you every time.
Well spotted, didn't even notice when I posted.
Fair enough, however I am still not convinced that optionals even have a place in Go at all. I mean it's already idiomatic to just check for nil everywhere (e.g. errors), and the fact that I can return multiple values couple with the fact that it's convention to return optional errors in case something goes wrong, it should be safe to assume that if an optional error value is nil, then I do not have to worry about the primary return value being nil. Also, unlike Java, we don't always return pointers--in fact, it is best practice to only deal with pointers when absolutely necessary. Sorry that this was kinda rambly--I hurredly typed it up as I am about to head to a meeting.
Lock upgrading is cool. Say you have a shared map acting as a cache.. You get a read lock, which multiple threads can have.. Then you find that the value is missing so you upgrade to a write lock and generate the value. Right now you have to check twice - Once with a read lock, then again with a write lock.
Still with this myth, smh
I think my favorite is 'GO'.
The optional idiom doesn't cost more because you already have to handle all errors or use _ which is seldom a good idea. Sgo merely gives us compile time checks for the current state of affairs in regards to error handling.
Was thinking the same thing. It's a cool idea but I think the API would be more idiomatic and efficient. 
You could implement something nasty with `interface{}`.
I understand the reasoning. I just don't think it's performant in practice. Have you benchmarked it?
I like VS Code much more after using it. I started with Atom, but I found the Go support in VS Code is much smother, intuitive and frankly meshes better with the developer. I feel like Atom in nearly there, it's just clunky.
Honestly, unless you are only mailing yourself, you're going to have a hard time getting mail delivered reliably without just using a third-party service. The spammers have won. I'd recommend mailgun, but anything will do. 
That's a very interesting experiment. Kudos to the author for the hard work on this.
If `References` has SQL type `jsonb` then everything should work as is, e.g. see https://github.com/go-pg/pg/blob/v4/exampledb_query_test.go#L54-L61. If type is `text[]` then you need to add array tag `pg:",array"`, e.g. https://godoc.org/gopkg.in/pg.v4#example-DB-Model-PostgresArrayStructTag. But probably I don't understand your question.
6/15, turns out I don't know anything about Go...
I agree. Although we'd never move from using vanilla Go at work and I don't think this should be added to the language (the small size of the language is a big positive in my opinion). One thing I want to do at work when I have some free time is develop some static analysis tools that do checks like: - ensuring every single handler has authentication - ensuring service names are correct (we have a microservices architecture and have to call other services by name, it would be easy to check that the service name is a valid service name with static analysis). - ensuring every request param is validated before being used etc. - ensuring errors are checked
People forget, in the problems of "now", that these problems don't make the solutions of "then" wrong. Scaling is weird that way long periods of "this is how it's done" followed by short tumultuous earthquakes of "and now it's not at this scale"..
You're answering me like a politician. You still haven't substantiated what the cost of this idiom in particular is. I'm interested in hearing why you think this idiom is not worth it. In order to understand that I need to know what you see as the most substantial costs.
That wasn't supposed to support my point, that particular quip was beckoning proponents of optional to present *some* evidence to support their rhetoric of how disastrous nil is. Every time this topic comes up, people are quick to quote Hoare and make dramatic speeches, but no one presents any metrics or data about the severity of the problem. None of this resonates with my experience (I'm not a particularly good programmer, but I can't recall spending more than a couple minutes debugging a nil panic--particularly when you have a stack trace), so my minimum criteria for believing the hysteria is *some* data about the severity of the problem.
Not always but as you optimize parts of your app, use caching etc... then it can represent a larger part of your performance. You rarely get a single huge performance gain, often it's lots of small changes that combine to give you a high performing app. There's nothing wrong with people who develop the router pieces wanting to make sure they are as optimized as they can be. Ultimately you have the choice of which one to use - convenient but slow or fast and maybe a little learning involved.
&gt;6/15 I'm both confused &amp; interested to know what you are talking about, honestly...
More details are available here: [Go - DLL loading, Big int](http://www.openwall.com/lists/oss-security/2016/04/05/1)
I'm assuming you mean dynamically loadable plugins a la java and not a plugin-based application architecture. An undetermined future Go version will have a "go plugin" buildmode. That's what you want, that's what I want. Until then, there's no simple native way to have dynamic plugins in your process. With that in mind, I've been keeping my eyes open for a while for alternatives. Here are the fruits of my labor; * DLL-based plugins on Windows are possible, maybe this is also possible on other platforms? Either way you're stuck with C-based API's. * Use an Embeddable Scripting Language (otto, lua) * Hashicorp's [go-plugin](https://github.com/hashicorp/go-plugin) package accomplishes dynamic plugins by building plugins as binaries, and wrapping your code with an IPC-RPC protocol. This is the best 'out of the box' solution as far as I know. Unfortunately all of these have significant developer- and performance overhead. I realized that for my intended use-case, an on-demand compiler is the way to go. * Create a pluggable application architecture and define the generic Plugin interface. * Determine how plugin packages are going to export valid Plugin instances. * Create a template that takes in plugin package names and that generates code that imports those packages and loads them into the application core. * Use that template to generate new main packages based on required plugins and platforms/architectures. * Finally compile the generated main package into a fresh binary. You can do all of this in a custom command that takes in the plugin packages, os and architecture as arguments.
I'd think that highscalability.com would also offer inspiration
I think an [overview](http://thesecretlivesofdata.com/raft/) of [Raft](https://raft.github.io/) would be cool, like why it exists, how it works - then wrap it up by using some popular implementation to build a distributed in-memory key-value store (just a map). Maybe with [go-agree](https://github.com/michaelbironneau/go-agree) for time-saving.
Not sure this is complex enough, but something I've been working on lately is forcing myself to refactor code using RWMutex to instead serialize reads and writes using channels
The author of the linked post :-)
This doesn't really show how to leverage it at all, a little disappointed as it is fundamentally just the hello world example.
I'd use https://github.com/denisenkom/go-mssqldb with something like the folowing: package main import ( "database/sql" "fmt" _ "github.com/denisenkom/go-mssqldb" ) func main() { dsn := "server=localhost;user id=me;password=pass;database=my_db db, err := sql.Open("mssql", dsn) if err != nil { fmt.Println("Cannot connect: ", err.Error()) return } err = db.Ping() if err != nil { fmt.Println("Cannot connect: ", err.Error()) return } defer db.Close() rows, err := db.Query("SELECT users.id FROM users WHERE users.age = ?", 12) if err != nil { fmt.Println("Cannot query: ", err.Error()) return } defer rows.Close() for rows.Next() { var val []interface{} err = rows.Scan(val...) if err != nil { fmt.Println(err) continue } fmt.Println(val) } }
I don't want to be that pesssimistic, dementor-like Reddit Guy, but this really seems like another instance of "yeah because we can" symtptom. Really, what is the value in it? I have examined the official page too, but everything is wrapped, and it seems like you are doubling the work you have to do.
Oh no I commented on the wrong thread! Both URL had log in it... https://logpacker.com/blog/the-second-golang-war
Maybe "approaches to concurrency" and do `sync/atomic` too, and just weigh pros and cons of each method. Mutex is sometimes the right answer. Lock free is cool too.
It'd be cool to use isomorphic templates with GopherJS. Has anyone tried it for executing templates client side?
This is cool, but I'm a fan of using built ins where possible. Tar isn't too bad, `tar -xf file.tar.gz` to extract (add a j if it's a bzip2), swap x for c to create, add a v for verbose (like many commands). That's met 99% of my needs with tarballs to date.
I had never really heard about markov chains until I read [this terrific article.](http://setosa.io/blog/2014/07/26/markov-chains/) I wanted to make sure I understood it (and practice writing Go) so I wrote this little toy script for weather patterns. Let me know what you think.
Go is a modern programming language, is it not?
Cool. BTW you can use time.Second as a duration argument, instead of 1e9.
https://golang.org/doc/codewalk/markov/
It's a simple hack, I'm not trying to get it kick started :-) If you want to point out race conditions, you're going to have to be more specific than that; otherwise you're just blowing hot air.
thanks, it helped.
Instead of `for {}` use `select {}` to prevent `main()` from exiting.
Yes, that is what I ended up doing finally and mentioned in the post too.
Yeah i know - if i just would make a blackjack game i wont use interfaces at all. But if you get the job "Make it generic - we want to implement more then one cardgame" you have to construct it like that (well - in my opinion). Sometimes it was refreshing because often i implemented a interface and basically just cobbled together my classes. If i changed one thing in my implementation i didnt have to touch any other implementation. 
So do many implementations of `tar`.
Work through an example of making a not easy to test function into a testable one using interfaces to allow you to mock dependencies. Jeff
i made a really simple markov chain for a bot of mine in golang with redis https://github.com/blackdev1l/ritalobot/blob/master/markov.go
Gofmt's style is no one's favorite, yet gofmt is everyone's favorite. [©](https://go-proverbs.github.io)
A performant, reliable, distributed, horizontally-scalable SQL data store. I'm excited to try this out. 
I always run `go fmt` on my Go code, did I miss something?
As I opened it first, it was a formatting mess. This was also a cause for my comment. Now everything is fine and I don't see any additional commits. :-/ Thus, I assume now, it was a browser glitch. My apologies.
No worries. I learned something out of it because I always use `go fmt` and now I know what `gofmt` does too.
It's definitely reliable, and distributed, but it's not horizontally scalable -- since all writes must go through the leader. Instead rqlite gives you the functionality of a fault-tolerant, replicated relational database, but with very easy installation, deployment, and operation relative to many other systems. For more background on why rqlite is useful, check this other post: http://www.philipotoole.com/replicating-sqlite-using-raft-consensus/ 
Just make a struct to hold your two types and then make an array of your new struct. 
Maybe. You would only be able to make card games that follow a traditional deck of cards and that fit your assumptions. And because of that, the interfaces aren't necessary since you always know Ace through King, and four suits. (Your architecture doesn't seem to take into account jokers either). And if you were to implement a card game a la Magic or something like that, you'd almost certainly have to implement new architecture...
&gt; You're still thinking in Scala. ... Who are you trying to protect? I know, I know. And this is my concern, I don't know if I should just be more "trusting" when I'm writing Go. Scala had many ways to keep things locked-down, that in a real application might not be that important. The reason the option has it's value be a pointer is because it may not have a value. For some context, I'm just playing with the idea of a basic CLI parser to try and put some of the things I read about into use. So, an option would be something like `--foo` or `--foo=bar`. An argument, if it is there, will always just be whatever it is, so will always have a value. That is an interesting approach there, similar to what I had seen above in a way I suppose, though may not take into account the fact that the value could be nil when being accessed I guess (at least from what I currently know!)
Right, that is very interesting. I had feared that may be the case. Could you possibly point me to where in the standard library the first method is done? I'm just curious to see it is all! Thanks for the insight, this has been very useful!
No, it uses unsafe pointers and atomic compare and swap; no need to check.
Do you even know what the ABA problem is? I don't see any generation numbers, so I guess you didn't consider it.
I get where you're coming from, but yeah, there's really no need to be so strict and protective. Idiomatic Go is to say a string with no value is "": if params[0].Value() != "" ... That said, check out the Go "flag" package. It uses pointers in the way you describe. 
Only set one of the values in the struct for each item in the slice. Then you still have the order preserved.
The danger of bad programmers.
Invert your structs/slices: type InputParameter struct { argument *InputArgument option *InputOption } var params []InputParameter I used pointers for the struct fields assuming that the types are structs, and you want to be able to detect a nil/zero value.
Aah! Right! So then you can just check which type it is by checking which isn't nil - that makes a lot of sense, and has the advantage of avoiding making methods that intentionally do nothing. Perfect!
This was very overdesigned. I started to get confused at the `Shuffle([]cards)` function; Surely randomizing a list is generic enough that type information isn't needed? You don't even need to look at the items. If I wanted to do it as generically as possible, I'd define all the properties of a playing card first and then tuck those away into a separate place where the games can't touch them, then make a `Game` interface that a black jack game could simply hook into. 
You're putting a blatant bug in your program, no wonder the program misbehaves.
It greatly depends on how do you define a 'modern programming language'.
Why are you trying to run something asynchronously and then bending over backwards to prevent the program from exiting? Perhaps your actual use case has been simplified a little too much for the blog posting? I would just remove the "go" keyword and block on your loop: https://play.golang.org/p/cPaf6O_b7W Any time you see a busy loop it's a red flag.
The solution to doing this the way you want to is to add a method to the interface. This is how you do explicit interface implementation in Go. type InputParameter interface{ ImplementsInputParameter() } type InputArgument struct { Value string } func (_ InputArgument) ImplementsInputParameter() {} type InputOption struct { Name string Value *string } func (_ InputOption) ImplementsInputParameter() {} params := []InputParameter{} // params := []InputParameter{"hello"} compiler error: String does not satisfy interface InputParameter
 type Foo struct { Arg1 String Arg2 String } var theSlice []Foo // or if you knew you'd have 5 and only 5 'Foo's var theArray [5]Foo And then your args are inside a struct? I'm confused as to what else you would need? 
/u/mwholt already explained this one, I'd never thought of it that way. :)
Which location, in particular, are you so worried about? The idx? It's only every increased, it will never jump back and forth. Neither will the current slab ptr, it will always get a new value. Just dumping a load of acronyms without voicing any specific concerns is arrogant to say the least...
From the README &gt;Can it unzip and untar? &gt; &gt;No,... Just reminded me, of one of my old project which is kinda similar but for unpacking(unzip, untar, ... you name it) https://github.com/gernest/kemi For someone interested in packing(archiving), then this can also be a good lesson for unpacking with Go 
How do you guarantee that the current slab pointer will always get a new value?
[... that's awesome](http://img.pandawhale.com/85470-mind-blown-WOAH-gif-The-Matrix-kaJw.gif)
Sure, but there is a difference between checking that there is an access token and that the access token is authorised for this particular request. We have middleware for the first.
Make a custom type of interface slice and then code ur own setters and getters to include type asserts for the 2 types type urtype []interface{}{} func (u *urtype) insert(type1) *urtype {} func (u *urtype) insert(type2) *urtype {} // ... Other set get functions
I am pretty sure, I am not talking about Go's select.
And in this case it's definitely "not vulnerable", because of deferred reclamation, without the need to bring out the hazard whatnots. I just try to make damn sure that the problems I solve exist in the real world, that's all; I'm not in it for the mental masturbation any more. Thanks for the heads up!
Why? I'm not being difficult here, but that's the primary question you should be asking in this situation. If you want to store some things in the same storage to me it means one of two things: 1. You just want to store things and for some reason don't want to store those things in two different containers. This is a bad idea, types matter. 2. You want to store things in the same container because you'll be processing/using them in the same way somehow. This means that there will be some common access function. That means that they have the same interface for doing things. So just make an array of that interface.
I should add that using a slab allocated structure, especially one backed by the allocator in question; means you can forget all about deferred deallocation. This little baby is pretty much guaranteed to always return the last freed item :-)
The value in it is that the developer is using a simple and statically typed language. Further, concurrency and error handling is much cleaner in Go.
Option 2 is where I would like to be, but I haven't yet thought of a viable way of making this particular problem work that way. Option 1 on the other hand, I have got working with the help of other folks in this thread, and the types can be retrieved and handled with reflection in what seems to be a safe way. I understand your point, and I'm going to keep exploring options, mainly just because it's fun to keep exploring the different solutions. I am only a couple of days into using Go, but would like to make sure I get started with it on the right foot! So, I'm trying my best to write idiomatic code.
I think UML is heavily biased to certain languages (like Java) and it requires a slightly different approach to apply optimally to Go. Adding abstractions where none is required is overkill and adds complexity with little real benefit. A card is a value type, nothing more, so an interface makes no sense IMO. Same with a deck (a well defined collection of cards).
I was inspired to experiment with Markov chains by the very same article. I always assumed they were horrifically complex until I read it. Great stuff.
You shouldn't be linking against untrusted code; it can do much worse things than reassign a package variable.
To this day, this tweet is still how I remember them: https://twitter.com/_tessr/status/626076327133577216
I actually just pushed Unzip and UntarGz functions that I threw together real quick; they're very, very simple and I'm sure they can be improved a bit; it looks like your code tend to more details!
Did some more benchmarking; 1000 upgrades/downgrades from 10 threads on the same lock vs. unlocking/relocking a regular sync.RWMutex in the same fashion: 2016/04/10 03:35:30 RWMutex: 3.288477368s 2016/04/10 03:35:34 lock.RW: 3.599337031s I'd say the added possibilities are well worth a minor synthetic performance hit like that. Can't really see how you can go much faster in Golang if this is what you want to do. And it's quite reasonable to assume that whatever you're trying to accomplish with the upgrade/downgrade affects performance more than any implementation detail ever would.
It is a contrived example to enable readers to reproduce the issue quickly. The actual use case is shown in the first code snippet which involves starting server in separate Gorountine.
That sort of context type is for passing data which pertains to the immediately related scope. So, a request context will hold request-scoped data. If you need server-scoped (in other words, http.Handler-scoped) dependencies, create a type which holds them and define methods on that type which will act as the handler funcs. For Handler dependencies, see https://elithrar.github.io/article/map-string-interface/ For request context, see my library https://github.com/codemodus/chain (if possible an upgrade script will be provided for the changes coming in 1.7).
I, too, was somewhat confused by shuffling. I don't really understand what this means: &gt;i have to provide a Shuffler implementation and everytime anyone wants to shuffle the deck he has to reorder this wish to our Shuffler. In an OOP world i could do that much better because you dont have to write code for this Shuffle thing. So back to the white board. Why is there a generic shuffler and a shuffler interface for just essentially randomly changing the order of cards? Am I missing something?
&gt; That sort of context type is for passing data which pertains to the immediately related scope. I am curious, is it a bad technique to pass db down with the context and why? &gt; If you need server-scoped (in other words, http.Handler-scoped) dependencies, create a type which holds them and define methods on that type which will act as the handler funcs. Also what are the advantages of creating type + methods over just passing it down with the context? 
Is it faster than fasthttp?
&gt; I am curious, is it a bad technique to pass db down with the context and why? One disadvantage of the context as implemented is, that it is relatively slow, as it's basically a linked list. If you stuff too much stuff into it, that will become noticeable. So if there is a better place, like a struct-field as suggested, use that. &gt; Also what are the advantages of creating type + methods over just passing it down with the context? An access to a field is O(1), whereas an access to a context value is O(n). It's also cleaner: Instead of having a wrapper which injects your value, the value is just always there and available.
It's a little misleading since all the heavy work is done through net/http, isn't it?
&gt; which may mean the function did not complete successfully (e.g., data was not flushed to the disk) The os.Open opens a file for read, an error from f.Close is harmless here.
Of course, most Go web servers are just http.Handlers, but the idea is to serve from memory, which for gzipped content makes a very big difference it seems, as well as keep the code a bit more... manageable.
Well, this is not a net/http implementation, but I might port it to fasthttp if their numbers hold true. Then it'll be even faster! :) EDIT: It doesn't have HTTP/2 support yet, so I might wait a bit... or maybe have both.
It'll be very interesting to see how the chaining and middlewares libs will look like with coming 1.7 ! It's not that it's so much difficult now but there is too many ways to do it when we begin... About db, i like to begin and end a transaction in one middleware (that i do in Python). I'm surprise to don't see such examples with Go ?
Really great idea. I use BoltDB for simple KV storage but it gets unwieldy fast when you start increase the complexity of the scans. This is super useful for unit tests, as well, akin to something like H2 in Java-land. Have you done any benchmarking compared to other ORM solutions (like gorm) on other RDBMSs? I'd be curious to see how they compare.
I just tried locally, adding a switch that allows the use of both fasthttp and net/http. I might not be using it optimally, but I do not see any measurable benefit to using it (server on a C1 instance, boom on VC1L instance). I'll play with it some more, though, as it looks interesting. EDIT: Converting header handling to []byte for fasthttp seems to make the HTTP handler ~8% faster than with net/http (which already bypasses the .Set/.Get methods to avoid unnecessary additional canonicalisation). Using the string-based header handling in fasthttp did not execute the boom test faster than the current net/http solution.
Checking out the source, it looks like `build.go` has a number of options: https://github.com/grafana/grafana/blob/master/build.go Try running with the `package` option (`go run build.go package`) and it looks like it'll build .deb and .rpms of it which you can then install whichever is appropriate for your distro.
there is a 'go install' which will install a binary under $GOPATH/bin, just place a $GOPATH/bin in your system's $PATH
&gt; One disadvantage of the context as implemented is, that it is relatively slow, as it's basically a linked list. Now that makes sense. Though I still have to wonder. If the object that contains db is put in the context first then it should be very fast to take it out as it's the first item of the linked list, no? &gt; It's also cleaner: Instead of having a wrapper which injects your value, the value is just always there and available. Yeah, now that I know the explanation I start to feel that it's clearer as well. Though to be honest there's something "unclear" to me about making a struct and defining method handlers on it. What I mean is that it feels as if I am coupling the "web layer" with the "db layer" if you catch my drift. What are your thoughts on that?
It's out of the scope of go tools. Use whatever method you would use for other software, eg. Makefile with an `install` target with suffice. For instance, docker has a Makefile but without an `install` target. In this case, in the spec for Fedora's packages, the binaries are just copied over to proper locations.
The documentation (https://godoc.org/golang.org/x/net/context) states: "Use context Values only for request-scoped data that transits processes and APIs, not for passing optional parameters to functions." Regarding coupling; If the handlers require access to info in your database, then there is a coupling by necessity. To minimize the ramifications of the dependency, use interfaces. Instead of having a field in your handler type which carries an instance of a struct, define an interface which provides the methods that returns what is needed. In that way, the database layer can be swapped out or mocked for testing.
Along with http://github.com/codemodus/chain, I also setup http://github.com/codemodus/catena. catena uses the http library's http.Handler definition, but uses the same API as chain. chain will likely be modified to be identical to catena and will have an upgrade script available to minimize impact when 1.7 is released.
/u/TheMerovius's response answers this. I was providing the quote from the docs to reinforce the justifications. Beyond that, hiding everything in the context type is disingenuous. Looking up handler-scoped needs from a request-scoped type feels disorganized. A handler which allows it's methods to access types via fields provides for a more clear design. Maybe looking at it through an analog can help. If one rides their bike to work, they would have their journey-scoped items in a back-pack (laptop, extra coat, etc.). The bike-scoped items would go in a bike bag (bike tool, extra tube, etc.). It would be possible to take the bike bag off and put it in the back-pack, but putting a laptop in a bike bag just doesn't make much sense (nor would it fit in that case). I hope this silly/extended analogy helps.
The compiler could insert a scheduler check into loops that may not terminate and that do not contain any function call.
That's a bit rude, don't you think?
&gt; Looking up handler-scoped needs from a request-scoped type feels disorganized. A handler which allows it's methods to access types via fields provides for a more clear design. Maybe it's something I am doing wrong in practice that does not allow me to see why it's wrong to throw db in the context so let's get a little more practical. Please bear with me. We define a package that will handle anything db related, let's call it `store`. The package `store` provides an interface with all the db functions we will need so that for example we can write `store.GetUsers`. And of course `store.New` will give the implementation. The package `store` seems "orthogonal" to me. You can use it on a web application by somehow passing it in the handlers (through the context in my case) or a console application or even a 3rd party application. It also seems easily extensible as you can just add more methods depending on the needs. I have trouble understanding how defining handlers on that `store` package would make it more clear. Suddenly the "db layer" is telling you how to present the data to the user. And what if I want to use `store` on a console application (as well)? Why define the handlers on it? Maybe this is a bad example but it is what I usually use when writing web applications in Go. If the architecture is bad I wouldn't mind improving it and make it more clear. 
You can say it in nicer words if you want to spend the time, but do you disagree with the underlying message?
I see where you're confused now. Create a type which contains the store. type node struct { DB store } func (n *node) testHandler(ctx context.Context, w http.ResponseWriter, r *http.Request) { user := n.DB.GetUser() v, ok := getReqData(ctx) if !ok { // handle error } user.SetSomething(v) // etc. } I'm sorry if I made any errors.
Grafana probably has package build &amp; install scripts somewhere in the source tree... Seems there is not a "go" way to do it but you should be able to see what they did to take the executable and package it for RHEL &amp; Debian.
I wasn't really aware of any official Docker image that helps you build a minimalist Go binary with Godep as the dependency management tool. So, I created one that I thought could work. Any comments are appreciated, I'd love to hear if there are/were better ways to do this. Also, feel free to give it a try: https://hub.docker.com/r/garukun/godep/ I didn't create much of README for this, presumably, you can begin with the example in the repo.
no worries. It's not so much the 'put it the bin in a new location' i'm after it's more the systemd and etc files i'm after so I can daemonise it Thanks
I'm not sure that I know what a "bad programmer" is. I think busy waiting like he did is a poor technical solution (he admitted as much), but I had never considered the impact of a busy for loop on the runtime. Calling someone a "bad programmer" for trying and erring reflects worse on you than him, in my opinion. Very bad taste.
 &gt; go test -race 2016/04/10 21:04:20 10000 * new: 1.676457ms 2016/04/10 21:04:20 10000 * Alloc: 8.916637ms ================== WARNING: DATA RACE Read by goroutine 27: github.com/fncodr/godbase/poorslab.TestPerf.func3() /Users/nelsonjs/go/src/github.com/fncodr/godbase/poorslab/poorslab_test.go:68 +0x4ed Previous write by goroutine 6: github.com/fncodr/godbase/poorslab.TestPerf() /Users/nelsonjs/go/src/github.com/fncodr/godbase/poorslab/poorslab_test.go:58 +0x4a9 testing.tRunner() /usr/local/Cellar/go/1.6/libexec/src/testing/testing.go:473 +0xdc Goroutine 27 (running) created at: github.com/fncodr/godbase/poorslab.TestPerf() /Users/nelsonjs/go/src/github.com/fncodr/godbase/poorslab/poorslab_test.go:74 +0x485 testing.tRunner() /usr/local/Cellar/go/1.6/libexec/src/testing/testing.go:473 +0xdc Goroutine 6 (running) created at: testing.RunTests() /usr/local/Cellar/go/1.6/libexec/src/testing/testing.go:582 +0xae2 testing.(*M).Run() /usr/local/Cellar/go/1.6/libexec/src/testing/testing.go:515 +0x11d main.main() github.com/fncodr/godbase/poorslab/_test/_testmain.go:54 +0x210 ================== 2016/04/10 21:04:22 10000 * Alloc/Free: 1.792754804s PASS Found 1 data race(s) exit status 66 FAIL github.com/fncodr/godbase/poorslab 2.826s http://blog.golang.org/race-detector - further reading for you.
You've still got data races in this. Run `go test -race` to see the gory debugging details.
How does it cope in the face of invalid XML? This is very common with feeds; unescaped characters, etc.
In my experience it works very well.... but... it's missing some wrappers for libraries and calling these functions yourself can sometimes be somewhat buggy. Plus the generated code gets a bit big, a 2MB js file is a bit of a load... Tho it's still a good thing that it exists.
A little gotcha I had with my project recently was that it couldn't do outgoing HTTP calls to HTTPS servers. Turns out alpine didnt have `ca-certificates` See https://github.com/quii/mockingjay-server/blob/master/Dockerfile
Thanks for the feedback, it is one of the reasons I submitted this here. I'll change the method names now while I still can. I still have the repo labeled as pre 1.0 so I'm alright with making breaking API changes right now. Edit: This has been addressed: https://github.com/mmcdole/gofeed/pull/18 If you see any other non-idiomatic Go things, please let me know.
This is one of the things that drove me to create this library. I looked long and hard for a library that handled all of the various feed formats/versions while at the same time, could handle parsing semi-broken feeds. A super strict feed parser isn't useful for me. I've done the best that I can in that regard while still utilizing Go's xml.Decoder. I run the decoder in non-strict mode which helps recover from some common issues. I also handle many common feed issues myself: unescaped/naked xml is parsed fine, improperly namespaced elements still get parsed, usage of non-standard date formats is handled, invalid tags for a given RSS/Atom element are simply skipped, etc. These were the scenarios that Mark Pilgrim's extensive unit test cases covered and I'm currently passing all of them. 
I love LaTeX, I am not sure what the author meant by finding it difficult to control.
I work in scientific publishing where we use LaTeX. If you want publication-quality output you end up doing quite a bit of black magic. I can totally understand someone not wanting to learn how to do that if they don't want to pay someone to do it for them and know another way of getting what they want.
Probably a stupid question but here goes. Given these probabilities: []float64{0.1, 0.8, 0.1} And your `update` code: p := chain[state].probabilities choice := rand.Float64() pSum := 0.0 for i, p := range p { pSum += p if choice &lt; pSum { return i, nil } } Suppose the `choice`gets the value 0.09, won't it always return at the first probability float?
Kernighan is such a cool guy, very humble, very pragmatic, and has this comforting tonality in his speaking and writing.
Yes, for that tick, given `choice = 0.09` then `update` will return 0. That would be the correct behavior. The state would be updated to state 0 (in this case "rain"). On subsequent calls to `update` choice will be re-assigned to any number 0.0 up to but not including 1.0. So it will return 0 if choice is low enough, but choice will be reassigned each time update is called, so it wont always return 0. Try running the program yourself to see, you'll note that the state alternates as expected between "rain", "sun", and "cloudy", if it didn't alternate we would know there was a bug.
Oh right, I missed that detail. Thanks for explaining! 
Your interface InputParameter is public &amp; usable/implementable outside your package. Now; add a private func to that interface (look at the lower case letter m): type InputParameter interface{ markerFunc() } And implement it in your structs: InputArgument and InputOption. Now nobody out of you package can implement InputParameter!
I don't really do much publication work so I will have to take your word for it. But I am interested in the type of work that you do. When you say publication-quality do you mean for publications like technical magazines? I just use it for writing research/white papers -- it works well for that I suppose :) ... I did have quite a battle with getting tabular data to word-wrap properly though so I can see how that would be annoying. Thanks for your feedback
This is pretty much what I've gone with for the time being: type ParsedInputParameter interface { isParsedInputParameter() } type parsedInputParameterLike struct{} func (_ parsedInputParameterLike) isParsedInputParameter() {} type ParsedInputArgument struct { parsedInputParameterLike Value string } type ParsedInputOption struct { parsedInputParameterLike Name string Value string }
Well, Kernighan used troff, in particular the GNU groff implementation, as he has done for all his books AFAIK. It's a less noisy syntax than TeX that doesn't get in the way as much for reading text. Also, it follows the Unix philosophy of having small programs do one thing well by having preprocessors that produce troff input from their own languages, e.g. tbl(1) for tables, and post processors that can turn its intermediate form into various output formats, primary PostScript and PDF these days. This makes it easy to adapt to particular needs as you can intercept, tweak, etc., instead of being stuck inside the monolith TeX with only TeX to hand. Rather than write low-level troff for everything, though that's quite nice, one creates macros, e.g. `h` for a heading, and it can be invoked by starting the line with a `.`, e.g. `.h 1 Introduction` might be a top-level heading. There's been widely-used macro sets written over the years, including `ms` mentioned by Kernighan, and a popular modern one is `mom`. http://www.schaffter.ca/mom/mom-01.html More background can be found on the old http://troff.org/ site, including Kernighan's classic paper on troff, *Troff User's Manual*, http://troff.org/54.pdf and if you're interested and trying to get going then the GNU groff mailing list is friendly and covers all troffs, e.g. Heirloom as well, not just GNU's.
He mentioned that he still had to do hacks to get everything production ready, just like you mentioned with LaTeX though. Unicode support was apparently lacking in \*roff, so he had to rewrite certain sections to hide that. It doesn't *sound* any better than dealing with LaTeX. But, I haven't used either much at all, so I was just trying to figure out what the options are.
Yep that's what I did and it all worked. Thanks ! 
Thank you Ralph for your insightful comments. There is also the Plan 9 version of troff, which, according to the manual, support Unicode: http://cm.bell-labs.com/sys/doc/troff.pdf
[I found this, might be up your alley.](https://www.hakkalabs.co/articles/getting-started-gopherjs)
Personally I write the first draft in Markdown, then translate to LaTeX to make final edits and formatting tweaks. Actually writing in LaTeX is too distracting.
Thank you for checking it out, I will update that to make it work with Windows.
Indeed, and having tried out fasthttp, it only gave the aforementioned 8% boost, and the difference between 4.8 and 5.1 seconds to complete 20000 request for ~4KB does not seem like something worth the effort and cost of losing http2 and more "standard" behaviour. :) If I was only interested in HTTP/1.1 support, I might have ended up writing a HTTP library that cuts some corners to be faster. I think it could be done faster than fasthttp while still taking care of everything that matters... I do not agree with all the approaches taken in that library, but I have no tried any of my ideas to see if my thoughts are correct, and that is indeed a project for another day (a day that may never come - so much to do, so little time...).
Latex is good with math equations. And the fonts just look great. But Latex does not have good support for codes. Algorithms are ok, but tedious. No good support for regular codes, syntax highlight, etc. Also, latex floating environment can drive people crazy if they want to place long figure/codes in certain places.
Thanks for introducing me to `-race`! I hadn't known of it before and it'll come in handy in general. Unfortunately, it didn't raise any warnings.
Thanks, that much i know, I never used underscores anyway besides SQL, but don't you get warnings when using underscores in go? 
Kernighan was around during nroff and troff's development by Joe Ossanna at Bell Labs. He took over development after Joe's early death, producing *ditroff*, device-independent troff, when hardware moved on from a CAT phototypesetter IIRC. So it certainly was the "devil he knew". :-) As for choosing troff for *The Go Programming Language*, I remember reading Alan Donovan say that Kernighan let him see what was available, Alan researched, settled on troff, and then found Kernighan was a primary author of several early papers on computer typesetting as well as instrumental in troff's development!
why ? just why ?
Spaceless programming. And I don't like remembering which names are keywords. We also have to remember which names are special identifiers too, so we don't write valid Go code like: package main import "fmt" func main() { true:= false fmt.Println("True is:", true) } Using kanji for those 64 names means we can use *any* lowercase-initial name as an identifier. 
&gt; ouldn' Cool! I'll add this in! Thank you!
Can't tell if you're talking about true:= false fmt.Println("True is:", true) printing True is: false or my solution to it. 
I wrote my dissertation in Markdown, translated to HTML/CSS then converted that to PDF with PrinceXML. Prince is very good. 
Why say "kanji" instead of "hanzi" if all the examples are Chinese, not Japanese? Is "kanji" an English word now? :-)
I think this is it - https://news.ycombinator.com/item?id=11262318
If you mean that `strings.Join(..., "/")` won't work there, that's not true. The `/` and `\` separators are interchangeable on windows.
You install GNU groff, typically packaged as `groff`, and you use groff(1) to run a pipeline of commands for you, including troff(1). `groff foo.tr | ps2pdf - foo.pdf` gets you going. If you like lower-level stuff then read the *Troff User's Manual* I mentioned above to get an idea of the formatting commands. Otherwise, pick a macro set, ms and mom are popular ones, and read their material. You tell groff the macro set with the -m option; the macro sets are actually called s and om, but take their name from this option to become `groff -ms` or `groff -mom`.
Until you try to use non-canonical path in a map. Or pass it as an argument to a program that doesn't. Or UNC paths.
Rather than Raft, I am looking forward anyone who can explain Paxos well with Go. (Make it simple :) )
I can read Japanese. Several of the characters in Qu are simplified in the mainland style. You could allow both variants though. 
Well, maybe that claim is because the writer does only work on web stack. Memory layout access control is critical in some industries but not in web. Why? This is why: https://www.youtube.com/watch?v=rX0ItVEVjHc
I'm currently using quagga for my anycast routing. I feel exabgp is superior for my needs, and want to go in that direction. Could someone compare gobgp and exabgp?
Finding out the Japanese versions of the characters is tasked for the next version!
I find this project very interesting, especially given the popularity of Go on the mainland.
I stand corrected, thank you. I was thinking that at least reads are scaleable, but perhaps there is no option to avoid the Raft state machine for reads (unlike, eg, etcd). Still, interesting project. 
Thanks! I love that I can just read this and understand what it's doing.
The Auth example on that page "Example (Auth)" shows how to use a service account key. If you don't specify any auth stuff, it probably uses google.DefaultTokenSource (https://github.com/GoogleCloudPlatform/gcloud-golang/blob/master/internal/transport/dial.go#L121) which should work fine locally if you have gcloud installed and setup or on GCE with no additional setup besides adding the correct scopes to the VM.
Awesome! Now I just need a Tesla.
&gt; Spaceless programming. Where does the desire for that come from? Space, Tab, and Enter are some of the most convenient-to-hit keys. &gt; We also have to remember which names are special identifiers As opposed to having to remember which characters are special identifiers and then switching character sets to type them?
This particular project (Qu) may not be adopted, but if it inspires some one else to create a Go-based language using Hanzi/Kanji, and those Hanzi/Kanji become defacto standard aliases for the keywords, special identifiers, and some package names in Go, then I'd be quite happy. 
I sorta wanna do a web design service with "free lifetime hosting!" that just does the site in Hugo and hosts on S3. It's pretty unlikely that the restaurant down the block will ever cost much. 
Thanks, you're right! I'll fix it.
biggest difference is RIB. gobgp has it, exabgp doesn't. For route advertisement, gobgp has cli commands and grpc api, exabgp has configuration file support and text based api using PIPE.
I guess I'm just confused what the target audience for this is. How many people often try to write (Go) code on smartphones? How many people can easily switch between character sets while writing code, while also remembering the meanings of the keywords? Seems like a nightmare for code review and collaboration. Edit: I've also never met a developer who thinks whitespace is anything but good for readability. At least, the sort of consistent whitespace you get from gofmt.
The fact that `int64` is `整64` is odd. On the one hand, it makes sense if `整` is `int`. On the other hand, you mention that all Kanji have an implied space before and after, but `int 64` isn't valid Go.
&gt; How many people often try to write (Go) code on smartphones? Could be an untapped market there! &gt; How many people can easily [...] remember the meanings of the keywords? About 1.3 billion Chinese for starters. &gt; whitespace is anything but good for readability If you use a variable-width font, an editor can add some space between characters when rendering, just as they often do colors. &gt; gofmt Qu uses gofmt to generate the Go code, 
I'd like to be able to write short programs `包正；功正{形println（“你好，世界！“）}` on a Qu command line prompt instead of needing to compile a source file for such short programs. As for your comment about `整64` translating to `int 64`, there's parser support for those few exceptions, which are workarounds for Go. *(I need to reply to that comment here because of a golang subreddit timeout restriction.)* 
Damn I wish I wasn't a poor state school student &gt;.&gt;
Almost always golang when searching Google. I assumed Google have some form of substitution for Golang and Go when blogs only refer to Go. But the search results page doesn't bold Go like it does Golang, like it does for other substitutions, so I'm not so sure. If you're looking for a worst example, I think R must be right up there due to it smaller length and likelyhood full text indexers don't index it at all.
Here's what I do: type Logger func(...interface{}) var debugLog Logger = nil func SetDebugLogger(logger Logger) { debugLog = logger } var errorLog Logger = nil func SetErrorLogger(logger Logger) { errorLog = logger } And I use it like this: if errorLog != nil { errorLog(r, "cancelled:", result.Err) } Works great. Binding it to the standard logging library is as easy as doing this: library.SetDebugLogger(log.Printf) library.SetErrorLogger(log.Errorf) And of course you can bind it to any method from any other logging library as long as they have the same signature, or you could write a simple wrapper method to adapt the function as appropriate.
I find the snippet autocompletion in Atom to be absolutely _enraging_. I haven't spent much time changing the "complete" key(s), but the out of the box default of basically autocompleting at any instant for nearly any key press drives me up a god damned wall. Oh, but yeah, go-plus is pretty darn good. I've found none of the path stuff is a problem with plugins when using homebrew to install Go, either. So that might help some people trying to make all of this work properly. Maybe not, but I figured I'd share just in case.
The problem is not the paths, it is the assumptions made by the go-config package within Atom, and the fact that for production code, you can't include those packages into git, nor pollute your .gitignore file.
You can build a shared library and use it with Ruby-FFI. Give it a read: https://c7.se/go-and-ruby-ffi/
Awesome, except by using GitHub's emoji syntax instead of actual emojis, it looks like nonsense outside of GitHub: http://i.imgur.com/GHfiBEW.jpg
They only count the search results for 1) "Golang programming" 2) "Go programming" if it's associated with the word "Google" See: http://www.tiobe.com/tiobe_index?page=programminglanguages_definition
really cool. nice api. 
I did not think about that. In my brief time working in China, never saw anyone name things in Chinese, but that was a pretty English-centered team.
I've written c# and SQL longer then Go, but do many times more searches for those then go. Why? I know the full go spec because it is small and for libraries I use godoc.org, rarely do I use a search engine. My behavior will hilight non-go languages depite most of my time is in go. I'm very good at other langs too, they and their libraries tend to have many more corner cases.
You can further simplify the call (perhaps at the cost of a bit of readability) by using the following, if you don't need to keep the returned function around: func Something() { defer metric.NewTimer("something")() // do work } 
when you say snippets, do you mean "auto insert a snippet of text"? It sounds like you are asking how to quickly run tests. You can do that with "cmd+shift+p" -&gt; "&gt; go test" and you get options to run a specific test, a specific test file, or all tests in the package.
Great article! I have posted this shameless plug elsewhere on this sub: I wrote a little middleware for working with JWT in Go webapps --- [https://github.com/thermokarst/jwt](https://github.com/thermokarst/jwt). It is fairly flexible, and pretty straightforward to use. 
It's a bit rude, but he also has a point.
There is also [simplebolt](https://github.com/xyproto/simplebolt), which only deals with strings, but may be faster (for strings) because it doesn't use reflection.
I worked recently with JWT for a project where I was using it to identify users instead of using Django's CRSF because I wasn't using Django to serve my htmls. JWT works great!
Try: IsSleeping bool `json:"-"`
You can safely do concurrent reads from the map as long as you don't write to it. If you want to write to it then you have to grt exclusive access to the whole map (no other goroutine should perform any operation on it at the same time) Use a rwmutex to flag access to it. 
This article made me think of [Why Javascript Development is Crazy](http://www.planningforaliens.com/blog/2016/04/11/why-js-development-is-crazy/). This is supposed to be about using JWT in a Go app and yet the author brought in a third-party HTTP router to do things that could already be done quite easily with the standard `net/http` package. Then they even went as far as to set up an entire fucking React application with Bootstrap! *Why?* JWT is conceptually pretty simple. That's the whole point, in fact. If the author really wanted to get people to use JWT by showing how easy it is to set up and use, they could have done it in maybe 20 or 30 lines of pure Go without using a single external library. There are *plenty* of other articles that show how to set up a Go HTTP server and React if someone actually needs it. I would imagine that by the time someone is even thinking about using JWT, they've already read that stuff.
Just to clarify what might be the premise of one of your questions: &gt; Concurrent read/writes of keys already existing in the map of values which are primitive types (int/float/pointer/etc)? "Primitive types" have the same concurrency guarantee as maps. Concurrent reads are safe. Writes concurrent with reads or other writes are not.
Ok thank you!
That's good to know, thank you!
My thoughts exactly. Excitement followed immediately by sadness.
I search on "golang". When I produce content I try to write "golang" at least once, and thereafter simply say "go". I do appreciate the simple 2-letter word when using it on the command line, but yeah, it was kind of dumb. On the other hand, search engine tech just gets better and better.
Semaphore pattern is a good one. The big caveat to note here, is at the end of blog: &gt; Note that this implementation will cause clients beyond the maximum number to queue without bound, until they hit the system limit of the listen(2) backlog. So you can still be DoS'ed by exhausting your sockets; you'd have to drop below the HTTP layer to drop connections at the network level. (I think.)
Nice, I was going to setup something similar for golang + Aurelia.
In addition to what /u/Akkifokkusu says, which is correct, I will also point out that using `select {}` to make your main thread infinitely loop is probably superior to `time.Sleep` (and innumerably superior to `for {}`). 
Thanks. :)
I would add that you will be better off using `time.Sleep(300 * time.Millisecond)`. It works for the same reason `12 * 1e9` does, but is very readable. You can change that to `time.Second` or `time.Minute` or whatever. I've heard that `&lt;-time.After(someDuration)` is better, though, I don't think it really matters. 
If you have not already tried vs code + golang plugin, you can try it. It supports delve on mac.
Excuse my ignorance here, but what exactly does JWT buy you over just plain oauth2? 
You'd have to create a raw socket with the syscall package to configure the backlog -- clunky, but can be done.
Decoupling of services. With JWT, a resource server doesn't need to call out to an authorization server to verify a token because everything needed for authorization is embedded in the token itself. The token is signed so that the resource server knows it was issued by a trusted authorization server and its claims are valid.
Ah, thanks for the source, that make alot of sense.
Oh yeah select is definitely the idiomatic way, I was just experimenting around go func
I was expecting a fasthttp hello world test to be something like the [example in the library itself](https://github.com/valyala/fasthttp/blob/master/examples/helloworldserver/helloworldserver.go) in order to test the library it claims to be testing. This is, essentially, the worst possible deployment of reuseport, multiple serial implementations running beside each other, with all the extra runtimes that involves and no capability to leverage the concurrent design of fasthttp itself. It's also the only place I've seen anyone claim fasthttp is slower than net/http. 
No, these are previous designs for generics written up by someone on the Go team at Google.
more like atom snippets
Just to add that RWMutex is made for these situations https://golang.org/pkg/sync/
Yay, more minimicronano-networking-benchmarks that do nothing and run on localhost. 
Any word on what Rob and Russ think of this?
Hi there. I'm one of the project contributors. How could I help out? The docs are a bit out of date (my fault) but delve now supports Windows (+Mac &amp;Linux) and the plugin ships with it so you don't need to do anything for it (provided you are on a 64bit machine, a limitation in delve right now). To get this running you need to create a "Go Application" run configuration and the debugging button will be active. Please feel free to ping me here or open an issue in the tracker or for real-time chat, try https://gitter.im/go-lang-plugin-org/go-lang-idea-plugin Looking forward to help you out.
Go2 is such goto
groupcache doesn't have time-based expiry, so I would say no. Use memcached or Redis, IMO.
what is there to think about documenting past mistakes? everybody already said that they are open to generics, but they have to satisfy the needs of the language (like fast compile times, etc)
In today's fast http world, the network is the bottle net event on GB lines. To run it locally, it pushes the server to its full potential although wrk uses almost 40 percent of cpu time. As you can see the pipeline helps a lot to push more requests from wrk.
Why does that grant it sudden consideration?
How do you manage to put in the bibliography?
&gt; https://github.com/go-lang-plugin-org/go-lang-idea-plugin/wiki/Documentation#debugging-a-go-project I've very reluctant to use VS (for no specific reason.. simply don't trust microsoft will keep this friendly policy for ever, I remember Balmer era..) Nevertheless I really would like some screencast of someone using VS studios with basic go features in practice (code generation for testing, code linters, code revision and specifically debugger). That would be super cool!!. 
Consider that groupcache doesn't have the concept of setting data, just getting data from somewhere else (or computing it, etc) and caching it. You also can't tell whether something came from the on-memory cache or the getter function or another host. I don't think you could implement your page count thing with it alone.
No deadline, since there are currently no plans for a Go2. https://docs.google.com/presentation/d/1JsCKdK_AvDdn8EkummMNvpo7ntqteWQfynq9hFTCkhQ/view?pref=2&amp;pli=1#slide=id.g118cf9b85c_0_360 or https://www.youtube.com/watch?v=4Dr8FXs9aJM at 3:45
Where can we find the list of this features proposed to Go2? Thanks a lot.
The punchline: &gt; I won’t discuss a specific implementation proposal here: my hope is that this document helps show people that generics are worth having ... This is very disappointing. The Go team has been consistent in saying they don't need to be persuaded on generics by "here's why" arguments. They need to see it actually done in a way that doesn't pollute the language. 
thanks!!
I take it back! Just learned that MS made the VScode open source. Looking into it right now! 
That is not true, actually. Both Rob and Russ are open to generics if a nice solution is found. 
Is there a way to debug tests on packages using Delve/Intellij? I am able to run `dlv test` from the command line (OSX), but I can't figure out how to do the same from Intellij.
but please keep in mind... there's probably not going to be a go2 for a long, long time, if ever.
I think gc/ Netpoller /syscalls use threads that don't count against maxprocs. Reducing spawns will prob reduce system contention since more threads are being run then cores. Numactl will prob give interesting results.
This label is a catch-all for all things that can't be implemented without breaking go1 compatibility promise. Go2 will only happen if major stakeholders in the language (so essentially Google) find a major thing they really, really need/want that requires the compatibility promise to be broken. Should that happen (which it may not for 10 years. or ever) it will open the floodgates. Until then NONE of the things labeled `go2` will be implemented in their current form.
By making it compile slower and not adding generics? Donno.
Depends on the signing algorithm you are using. For HMAC-SHA you need to distribute your secret to the other "microservices" to verify a token. If you use RSA or ECDSA as a signing alg then you only need to deploy the public key to the "microservices" to verify that the token is valid. Your auth server with the private key can only sign tokens. You also may need to check a global blacklist because you cannot simply invalidate a token. It only invalidates through time (expires) or in the blacklist, until it expires. Correct me if I'm wrong.
No
I'm just spitting out my ideas on what they could do. There could be a line defining at the top with the same syntax as imports with what type names will be considered generic variables. I.E. Typedef("T", "X", etc) Then similar to the syntax of String() one could declare a generic struct like: Type (T, X) Struct example { Foo T Bar X } I think stuff like this can minimize the verbosity that generics can have, while keeping true to the syntax and styling already established by Go. 
Worked out of the box on windows for me.
Yeah, I was a bit lazy on that initially as I was just wanting to see the other logic functioning. I ended up using a WaitGroup and scanning for valid exit command from the user, thanks!
Making the `handler()` callback synchronous did indeed clear up my original, seemingly inconsistent issue. I think I'm mostly just surprised at how the issue displayed itself, since logging would be missing that would had to have been hit prior to the concurrency issues brought on by using the assemblers in separate threads. In getting that handled, I was then able to wrangle one or two issues specific to my own implementation that likely helped obfuscate the original concurrency issue. Thanks so much! Oh, and that's a good thought about the `tcpassembly` package not respecting my own `-race` instruction. I assume I could go rebuild that package myself with `-race` and then build my own project with it to see it catch a race condition in the way the would be expected?
It's just a small package I made for this project to hold onto some odds and ends like tailing a device and reporting packets it's moving over the wire, my implementation of `Stream` for the assembler, etc.
totally agree! nice benchmark to see raw http performance but in practice there is much more than just "hello world" (authentication, authorization, databases, other services, logging, ....)
Ok that makes sense, thank you!
My take away from this is, that with Go being self hosted and the garbage collector getting reworked, the team is starting to look to the future for a Go 2.0 within 5 years.
Err, the bottom of the doc links to four specific proposals and explains why they didn't pan out.
tests?
Good question. A few reasons; I enjoying writing programs in Go. I've never written a compiler before and I think this was a good exercise for me. I feel like I learnt a few new tricks. On top of that, I'd be delighted if what I've done here was to in any way help someone else, whether that be in relation to Go itself, or what goes into writing a modern compiler. But most of all, programming is fun.
[GitHub release for those wanting to avoid SourceForge.](https://github.com/visualfc/liteide/releases/tag/x29)
You don't need to build a tree just to convert (f x) notation to f(x); it can be done in a single pass over the tokens like so: http://play.golang.org/p/aJBP6f6jhC
Does it make sense to use jwt in web applications which support both browsers and mobile apps? I have been trying to learn authentication in Go but I am struggling to find a good enough solution with an easy tutorial
Please post to subreddit so we can upvote that link instead.
wouldn't channels be more idomic than setting callbacks? (real question, not being sarcastic) 
This is pretty neat! Thanks. :)
No, for libraries such as this, the idiomatic way is to have callbacks not channels. 
Well, VSCode is Atom on steroids...
Sorry, but "synthetic performance"? There's only performance. In what universe is performance synthetic?
Credit for the majority of the comments should go to [James](https://github.com/thejameskyle) who wrote the original version in JavaScript which you can find [right here](https://github.com/thejameskyle/the-super-tiny-compiler). :)
It seems to me the author is just looking for reasons to say Go isn't perfect. I agree with that, but I don't agree that Go isn't fit for what he calls "application servers". Especially when he says that Python and PHP are more fit.
And now it compiles with delve support and QT5 without the need to patch source. Note: was too lazy to pull request a bugfix.
And gofmt would also make the hundreds of people's code look the same too which would help a lot.
Quite an interesting article, I will admit, it would be nice to be able to write some slightly less verbose code, or code that's perhaps a bit more transparent at times. There have however been plenty of solutions that prove that Go is a more than capable language for "application servers". The way I projects in Go is that they can be composed of several well-defined services that interact with each other. You can swap bits out, and add bits, but keep the API stable and you'll have a pretty flexible application system of servers.
Why only 400 concurrent requests? Please, try at least 10K and make "core pinning" for fasthttp with reuseport. It is very interesting to see results, as long as more detailed info on CPU/Memory usage. Thank you!
An application composed of several well-defined services can be done in one application, one server and one binary, and without a microservice architecture. I'd hate it if I had to write a microservice architecture for every damn app :)
Sure --- you can set up a refresh token as well, so on your native app your user authenticates once, and then periodically snags a refresh token from the API.
DIY man, they expose a JSON file of hotkeys for you. I bound hotkeys on mine to cycle back and forth just like I do in Atom and Sublime. 
As a customer and developer, this company has been kind to us. 
Hi! Author here. The difference between Go and Python for application servers is that Python does have the ability to define higher-order abstractions, like custom schedulers or monads on top of generators. Python also makes it fairly easy to build immutable data structures. We make heavy use of both Python and Go and the Python code is expressive and concise, with very little duplication, while the Go is verbose, with lots of copying or code generation. I think Go is great in many ways, and I think many languages should strive to learn from its success. Perhaps the way I should have phrased it is "at some point, when lots of companies have multi-million-line codebases built over a decade, Go will need to grow the ability to define safer invariants and abstractions, as we've seen in other languages" Cheers!
If by "global" you mean search and replace among all project files, it's not yet possible with VSCode: https://code.visualstudio.com/docs/editor/codebasics#_common-questions https://github.com/Microsoft/vscode/issues/1690
The thing I do not like is that it requires so many tools. All I really want is to be able to have it run go fmt, go build and go run. All the lint and other tools I'd just as soon not have to have in my go path.
Python is more expressive, but ages worse. The problems start when many programmers over many years express themselves differently in the same codebase. Python really lacks typechecking for these cases. Testing is not a replacement for types. With Go, programmers express themselves in approximately the same style, and there are types. Modularity is achieved by splitting out into packages. And deployment is a dream. Don't be blinded by the short term expressiveness of Python.
I have a fork from encode/json which support the labels, *omitunmarshal* and *omitmarshal*, example: type User struct{ Name string `json:"name"`, Password string `json:"password,omitmarshal"` } then you can unmarshal the password field, but when you encode this struct, it omits the *password* field Any interested in this patch, should you think I should make a pull request to go?
So how does it compare with the IntelliJ plugin? Haven't used that yet. I keep switching back and forth between Atom and VSC for Go.
&gt; It’s had hundreds of contributors from many backgrounds. [...] Haskell, on the other hand is brilliant for application servers What world does the author live in? 
I think it compares quite favorably. The IntelliJ plugin has a lot of nice features like global / search replace in a project, but for all I know there is an equivalent VS Code plugin that does the same. For typical coding, especially with the gocode code completion, I think it is just fine. Definitely a viable option for daily work.
Python may have the ability, but if you're laying monads on top of generators then it gives the impression you're writing something else as Python, e.g. Haskell. The "expressive and concise" Python might be hard to read to a Python programmer, not a other-language-as-Python programmer.
Did you try turning it off and on again?
Does anybody know how to "run" the current Go file? In TextMate I can simply press Cmd + R.
Having a predictable, uniform codebase is certainly worth a lot, but it simply cannot be overstated how valuable it is to be able to trust that all the tricky concurrency patterns are library functions that can be trusted to work correctly. As your system grows bigger, older, and smarter, this becomes increasingly important.
Have you tried using Ctrl+Tab with 10+ files open? It quickly became a nuisance for me. Ctrl+P alleviates the issue somewhat, but as more files get opened and I switch between projects it becomes harder to instinctively remember the name of the file I want which breaks my flow 
Has anyone made a comparison with Sublime with Gosublime? I use sublime + terminal and it works great. How is a start up time on VS code?
I use Go in a line of business application. I get the feeling we code differently and value different things. For instance, I almost never use "final" variables in C# and Java, so I don't miss them in Go. I tend to build up a responsive framework dedicated to my problem, and the need for code copying, code generation, custom schedulers, modades, and immutables, are not needed. For instance, I don't generate custom structs for database access as many people do. I either abstract almost all of the data access away to the framework or do most of the work within the database itself. I don't want to even imply that you are "wrong", but you may want to consider if there are other reasonable ways to think about code. How are you achieving your goals? Is there another approach that would be more suited to Go, rather than trying to use the same approach used in another language?
No, the idiomatic way is to offer a synchronous API and have the user worry about concurrency. 
Pointers to strings?
A fun little project I did, just to get some Go practice. I did a version of this before in Clojure, and before that in Java. Go was a bit more challenging, in that it doesn't offer any kind of built-in GUI framework for viewing the mutations in real-time. My solution was to just serve the images out via net/http, and then a bit of Javascript to reload them every 1000ms or so.
Hm....missed that. Looks like it can be disabled though, will do that.... https://code.visualstudio.com/Docs/supporting/FAQ#_how-to-disable-crash-reporting 
If that doesn't help, try the good old: rm -rf /
&gt;Syntax highlighting works, 'Go to Declaration' works great (takes you directly to the source code, including the SDK classes) and above all code completion using gocode worked out of the box. So this is at Go feature parity with LiteIDE as of 3 years ago? I'll stick with LiteIDE- thanks :p New release of LiteIDE just out: https://groups.google.com/forum/#!topic/golang-nuts/MKBpm8EMFdk https://www.reddit.com/r/golang/comments/4et2a4/liteide_x29_released/
Release notes: https://groups.google.com/forum/#!topic/golang-nuts/MKBpm8EMFdk
Valid comment :-) I have actually not used LiteIDE, so let me check it out. Point is that it is now possible to have a decent Go dev environment with nothing more than a text editor, which lowers the barrier to entry.
nice! wrt the GUI stuff, I believe that for your use case, "shiny" should be sufficient: - https://github.com/golang/exp/blob/master/shiny/example/basic/main.go - https://github.com/sbinet/iview or, even: - https://go-review.googlesource.com/#/c/22107/1/shiny/example/imageview/main.go 
json web tokens excels at protecting apis that are going to be consumed by desktop and mobile clients - you can't use sessions because mobile clients don't support them. Plus server and client are more decoupled (if not totally).
SDK classes? nonetheless, nice work microsoft.
Python has slightly less immutability than Go. At least Go has a const keyword. You can't have const variables in Python, and both Go and Python have to express read-only data through getters (A python property is just hidden behind function calls to getters and setters anyways). 
I see this pattern a lot in Javascript. For example `setInterval` returns a callback which stops the interval.
And that's somehow different from passing "", here? Hell, that whole function is bad idea, but I didn't want to go down that road.
That's a very good and valid point, actually! 
Yes, it is my favorite server language cause of the simplicity and performance of the language. Here are two gitbooks you might find useful, * [One rather short](https://codegangsta.gitbooks.io/building-web-apps-with-go/) * [And a more detailed one] (https://astaxie.gitbooks.io/build-web-application-with-golang/content/en/index.html) Hope it serves you well, and hope to see your project up and running!
This looks like hill-climbing rather than a genetic algorithm. Are you planning on adding crossover?
Uh, gosublime and vim-go are pretty good environments within *text editors*. 
I think you're correct that it's not technically a GA, although it did start out as one in my original Java implementation. Originally I started with crossover and found that it simply converged faster when I mutate a single candidate repeatedly, and then abandon the less-fit mutations. I am planning to try crossover in the Go version. In particular I want to see if that can help it get over what I think are local minima.
Startup time isn't amazing but it's better than Atom. Atom and VS Code are two editors that are functionally amazing but both take needless performance and privacy hits because of stupid design decisions. Gimme a FOSS editor with that functionality in a compiled language without a web-view and without analytics and I'd be all over it. It'd be the king of all editors.
I made my own app using [golang-goji-sample](https://github.com/haruyama/golang-goji-sample) as a base and ended up liking golang for web apps a lot. Give it a try and see.
I've manage to disable linting for example, but it still barks if I don't install everything. 
I didn't like the lack of tabs at first, but after a while, you figure out it is better. I especially love having up to 3 docs open at once in the same window. 
http://swe-kb.nabuden.com/2016/04/15/microsoft-code-overview-first-impressions/ Please chime in with comments. VERY Go Oriented Review!
Are you using a separate GOPATH for each project? Don't do that.
Real programmers deliver value and use whatever editor they want to
I do that. (I have one project). Why I shouldn't ?
What problem is this solving for you?
used sublime with gosublime before and now switched to code. It compiles, vets, lints in the background on save. That's really cool. so you don't have to type in 'build' yourself. Other than that it's kind of a taste question, like tabs and overall look and feel
No reason. In a real world environment where you handle several projects at the same time, you MUST keep them as separate as possible.
Explaining it further, I have several non-related projects that are deployed to disparate environments. GOPATH HAS to be separate for each, although your development environment remains the same. See http://swe-kb.nabuden.com/2016/04/12/my-personal-way-to-setup-atom-editor-for-go-development/ for a set up of Atom.
Welcome to the real world. Continuous delivery. Continuous Integration. You deploy through a system that to allow you to deliver must run your tests (assuming nothing), and the allow you to deliver. For home grown systems, or freelance work, sounds good, for real life, Godeps is the devil.
Maybe I should switch too ... the only reason for switching away from Intellij is that it uses ~1.3GB RAM. How many RAM does VS Code use on avergage? Edit: fix typo
Thank you. I've found a description here: http://stackoverflow.com/questions/35343143/vs-code-tasks-json-tasks-work-individually-but-not-combined Edit: This extension makes it really easy: https://marketplace.visualstudio.com/items?itemName=mattn.Runner
Thank you for sharing, /u/CaffeineComa. This is a cool diversion from the usual. I was a part of a project that used Watchmaker's GA for a tuning exercise: https://github.com/sladeware/groningen. Watchmaker is not complex, but it is nice to see how simple a bare scaffold can be built in Go as a comparison.
Yeah you don't have to take that tone with me, no need to be like that. I have plenty of experience of CI, CD, etc thanks. https://travis-ci.org/quii/mockingjay-server Having one $GOPATH does not preclude you from having reproducible builds, running automated tests, etc. 
Yeah. Absolutely possible. 
There are a bunch of libs you could use for it. Just have a look to https://github.com/avelino/awesome-go#web-frameworks
I'm a full time Vim user at the moment and have been for the better part of a decade, but I'm longing for a richer interface. Atom hints to how you can do things like linter / compiler messages better when you have more than a terminal.
You can always try IntelliJ to have everything out of the box, including debugging working without needing to do anything (delve is shipped with the plugin) 
Assuming Go 2 would have generics, and much of the standard library has changed. Do you think it would be possible to have gofix do at least the majority of the work of converting Go 1 to Go 2 projects?
You'll need to create a task, which has a configuration similar to: { // See http://go.microsoft.com/fwlink/?LinkId=733558 // for the documentation about the tasks.json format "version": "0.1.0", "command": "c:\\go\\bin\\go", "isShellCommand": true, "args": ["build"], "showOutput": "always" } More details at: http://go.microsoft.com/fwlink/?LinkId=733558 And *File | Preferences | Keyboard Shortcuts* shows the default build shortcut is ctrl+shift+b 
&gt; I am baffled by the fact it is not THE standard Really? Tech adoption is a social process. LiteIDE, by modern standards, is ugly. Also, much of the community is based in Asia. I'm not saying these are good reasons not to use it, but I believe social factors drive people away. 
this.
definitely 1st option, in my opinion 2nd one is not a good idea - why use two mechanism which do the same thing (persist data across requests).
I use Goclipse (an eclipse plugin) for Go development and personally am okay with it. The only problem is Eclipse startup and warmup time, but if you work all day or just don't have to turn off your PC it also isn't a problem since you actually have to start it one time per day. As for code, I hate it along with Atom simply because of HTML view that really bugs me. If code had a standard editor (not webview) it would be way better.
Will it make sense to drop sessions and cookies entirely by using JWT? Also if you have time, I'd love to get some expert comments on http://github.com/thewhitetulip/web-dev-golang-anti-textbook/
Okay, but I catch sight of that golang is not too good for web app front-end. How do you solve such a purpose? Or do you use golang for both internal services and for serving through the web? 
- Find out how Docker can help you while developing a Go application - Learn how to create a Docker container for a Go application for production
Go is amazing for RESTful APIs it's not as good for rapid front-end as say django. Front-end I would write in whatever frontend framework you use and consume the API
Nice to see my old evolisa ported to Go :-) Somewhat related, I actually made a genetic programming app in Go to mutate math formulas this weekend https://github.com/rogeralsing/go-genetic-math //Roger
Hey Roger, I hope you scrolled down enough on that Github page to see that I credited you for the inspiration. :-) That math GA is pretty cool. You know for a long time I wondered about the possibility of using a GA to evolve actual code. For example, having a very basic set of declarations, statements &amp; operators for the "DNA", and try to evolve something that sorts a list. A few years back I sketched out an outline of a program to target (simple) Java assembly language, build the candidates with Jasmin, and then live class-load them for evaluation. Unfortunately I never got much further than "idea" stage with it.
IIRC Andrew Gerrard (sp?) said he abandoned it a while back and prefers writing code without it. Less taxing on the eyes I think. So the whole "no highlighting" thing has been kicking around here for a while now. 
Take a look at [quicktemplate](https://github.com/valyala/quicktemplate) for writing non-trivial yet clean and fast html templates. This is usually an essential part of real-life web applications.
Go actually handles both, just like any other web server application. An HTTP request will come in to routes you define in Go (/page for example), and via your Go code you decide what to do on the backend, such as retrieving or saving data to your database. Finally, you serve up the frontend as a response to the request. Serving the frontend of your site to visitors could be as simple as writing a text response to the request (i.e. someone visits http://yoursite.com/page in a browser and you use Go to simply respond with 'Hello'), serving up a static file (page.html), or you can use Go's html/template package to serve dynamic HTML. The frontend then can be built using standard HTML, CSS, and JS, or you could use React, etc - it's up to you. Go is also great for creating whatever service you need on the backend; creating a web server is just one of the things you can do with it (and the standard libraries in Go you can use to develop web applications, net/http, html/template, etc are amazing).
http://i.imgur.com/R9lvZMC.gifv 
That's right. Looks like groupcache does not provide an API to get whether the key is available in cache. It is a must requirement for this use case. Thanks for the suggestion. I gave a try with redis. Here is the snippet. https://gist.github.com/dineshappavoo/a07fe5d8d74e9d182c7882853e944240 . I appreciate your help. 
You shouldn't close it really. `*sql.DB` is a pool of connections, so individual opens/closes are handled internally.
Indeed. None of the pain points mentioned in this post exist for the IDEA plugin. Everything just works.
Wow, VSCode does not have a "syntax highlighting off" option?
Hi, I'm the author of fasthttp. Here are my suggestions regarding the fasthttp code: * Just remove getListener function from fasthttp code. Prefork mode with SO_REUSEPORT usually has no any benefits in benchmarks if wrk is running on the same host as the server and if the number of concurrent workers is low (400 in this case). This should simplify code for fasthttp case :) * Use [fasthttp.ListenAndServe](https://godoc.org/github.com/valyala/fasthttp#ListenAndServe) instead of manually creating a Server instance and calling Server.Serve() on it. This also should improve code readability for fasthttp case. Server instance should be used only for tuning server-related params, which is unnecessary for this benchmark. * Run wrk with 2 threads on a machine with 4 CPU cores. This allows dedicating 2 CPU cores to the server and 2 CPU cores to the wrk. 12 threads slow down the test by an additional context switch overhead for this machine. This also results in timed out requests. My old 4-CPU core machine shows the following results for 12 and 2 threads (pay attention to latencies): 12 threads: $ ./wrk -t12 -c400 -d10s http://localhost:8080 -s pipeline.lua --latency -- /plaintext 16 Running 10s test @ http://localhost:8080 12 threads and 400 connections Thread Stats Avg Stdev Max +/- Stdev Latency 312.99ms 294.36ms 1.98s 72.19% Req/Sec 44.83k 45.65k 128.81k 78.12% Latency Distribution 50% 233.53ms 75% 464.19ms 90% 726.76ms 99% 1.25s 4977312 requests in 10.03s, 602.84MB read Socket errors: connect 0, read 0, write 0, timeout 18 2 threads: $ ./wrk -t2 -c400 -d10s http://localhost:8080 -s pipeline.lua --latency -- /plaintext 16 Running 10s test @ http://localhost:8080 2 threads and 400 connections Thread Stats Avg Stdev Max +/- Stdev Latency 7.32ms 5.05ms 46.61ms 70.00% Req/Sec 257.69k 36.30k 360.57k 66.84% Latency Distribution 50% 6.26ms 75% 10.14ms 90% 14.24ms 99% 22.90ms 5135552 requests in 10.05s, 622.00MB read Requests/sec: 511071.09 Transfer/sec: 61.90MB 
bmatch was programmed in parallel with some c and cpp experiments on search algo comparison with SMART. maybe package needs some further clean-ups 
"A way thay doesn't pollute the language" is a cop out, though. All programming is dirty, to some extent. They should be more specific.
As someone here as already pointed out, most of the times you don't have to worry about closing the connection. All the connections will be closed if the application exits( If that is what you are worried about), and by the way the `database/sql` manages the connections pool for you.
It really depends on the driver, for example the mgo db driver uses a connection pool, when you call close on the session, it does not close the connection it instead releases the connection to the pool, so in many situations after doing the action is the best solution, in others holding it open forever is the best solution.
I just accepted the defaults for the launch.json file and it seemed to work. You do need to close and reopen the file you're editing to be able to add break-points etc. Is `dlv` in your path? Does the Go plugin complain about missing programs? EDIT: launch.json: { "version": "0.2.0", "configurations": [ { "name": "Launch", "type": "go", "request": "launch", "mode": "debug", "remotePath": "", "port": 2345, "host": "127.0.0.1", "program": "${workspaceRoot}", "env": {}, "args": [] } ] } Output from `dlv version`: Delve Debugger Version: 0.11.0-alpha Build: f37a26d525902194a6430a0079392512c53beb51 
Depends on how you implement it. In practice, you need to share some data between the authorization service and authentication service whether it's a secret or a public key. So they aren't that different in that respect. For RSA you do need to be especially careful with the library you're using to make sure that you're validating that the signing algorithm is RSA. When I want the ability to invalidate a token I use the key ID field 'kid' and have that point to secrets stored in Redis. When you want to invalidate a particular token, you just delete the key in Redis and you're done. Doing this adds a layer of complexity that JWT was supposed to help solve, but I'm not aware of other better options for things like per user logout unless you're going to use a nonce and reissue a new token on every request (which introduces other complications). If you're interested in dead simple JWT authorization check out Caddy server with the JWT add-on. Disclaimer: I wrote the add-on because I'm a big fan of the automatic HTTPS and the ease of configuring it compared to nginx. 
I really like your caddy middleware :-) I've refactored github.com/dgrijalva/jwt-go because it's way too slow and I didn't like the whole API.
Have you tried `go build`?
I suspect you're doing something seriously wrong. Have you set your GOPATH environment variable?
There's also neomake, which in neovim is asynchronous. A bit harder to set up, but nice once you get it working.
I suspect the problem is that (s)he likely has a main package in containsMain.go, and some other package in myfile.go and anotherfile.go. Recommendation: create a "commands" subdir, move containsMain.go in there, and import your package(s) in that file. Or else leave the files in place, but edit them all to be in package "main". It's meant to be simple in Go, but honestly this gave me a headache in the beginning too.
There's quite a bit of correct and useful advice in there, great resource.
If you don't know what you are doing, don't make a close function. 
Yes and it works well with one file. The problem is when I have multiple files. Currently I have: ~/myProj /bin/ /pkg/ /src/foo/mylib/afile.go /src/foo/quux/containsMain.go afile compiles just fine and I get the pkg. containsMain just gives &gt;foo/mylib/treeUp.go:6:2: cannot find package "tree" in any of: /usr/local/go/src/tree (from $GOROOT) /Users/qwerty/Documents/arbetsmapp/go/test/src/tree (from $GOPATH) 
Yes, but I have spent two hours and I still can't get it to work. I have a bunch of small projects to do in the coming months and I don't want multiple folders for each project. Is there anyway to compile it with multiple files in one folder? I am used to compiling c with gcc. Is there no way of doing something similar with golang?
Show us your code.
Okay, we need some source, and your full folder structure. 1. Do all your files in myproject/ have "package main" at the top, not something else? 2. In mylib/treeUp.go, you import "tree", but seem to expect that it can be found. Where does this "tree" come from? The import path should be absolute, like "myproject/tree", "mylib/tree", "github.com/user/project", etc. 3. Why is your GOPATH "go/test"? Are you using some GOPATH management tool? We need some source to tell you what is wrong. Building Go is incredibly simple, but I suspect your imports are pointing into nothingsness, and you might not have fully understood the concept of GOPATH. A side-note: If you want to have a project with a main package (containsMain.go, I believe) and a lib, you should organize it so that the main package is in a separate folder. You can either put the lib in myproject, and the main package in myproject/cmd, or put the lib in myproject/lib and the main package in myproject, depending on taste.
Yes, but those multiple files need to be part of the same package. To re-state: *what error message are you seeing*?
Seems like your GOPATH is improperly configured, or more likely from the error: you aren't importing absolute paths from the GOPATH. Should be fine with: GOPATH=~/go Main=~/go/src/foo/quux/main.go Lib=~/go/src/foo/mylib/afile.go (I am guessing it's package mylib) And in your main.go: package main import ( "foo/mylib" "fmt" ) func main() { fmt.Println(mylib.tree) }
treeUp.go:6:2: cannot find package "foo/mylib" in any of: /usr/local/go/src/foo/mylib (from $GOROOT) /Users/katleb/Documents/arbetsmapp/go/src/foo/mylib (from $GOPATH)
Your previous comment suggests that your project is at `~/myproj` with `{bin,src,pkg}` under it? Your $GOPATH (from this output) is `~/Documents/arbetsmapp/go` (e.g. your project isn't in your $GOPATH). Just check your locations again, the debug statements tell you where it is trying to look, if your package isn't there - then it obviously won't find it. If you move it there, it will start working - assuming all else is set up correctly.
Web apps -usually- use concurrency though
I use it a lot for our game server written in Golang. Seperate goroutines for player connections, rooms that users play in, and database communication.
Web apps always use the concurrency Go as as net/http uses it. And as a regular user, it depends how you design your app/what are your needs. 
Indeed, but you're probably talking about the standard lib implementation of stuff like net/http. I guess I meant implementing it directly, not as a client.
You really should be.
Literally unforgivable.
We use it for a http load balancer style application, where we have backend pollers in their own threads polling databases, polling other backends, updating internal caches. Then http requests to stdlib net.http respond with the caches contents. We appreciate the cheap (not free) concurrency for this application, but the static typing / most-errors-are-compile-time is right up there. Although, we could achieve similar results using Java or Erlang, Go feels more enjoyable and being able to use it for web apps or this style (we have more) means less languages and tooling to learn and maintain.
Umm, okay. I really love this. This is definitely replacing nano for me. Nice work!! Really excited to see how this develops.
I wrote this JWT middleware: [https://github.com/thermokarst/jwt](https://github.com/thermokarst/jwt), but it too has not been battle-tested. It requires users of the middleware to write their own logic for setting and verifying claims (there is certainly a trade-off here: provide a lot out of the box, or provide a lot of flexibility). Ideally at some point I would like to whip up some drop-in options/default for that logic, while still providing the option to use your own thing. Kudos on Caddy --- I haven't had a chance to use it in a production setting, but I have played with it a bit here and there and I am a big fan.
Yeah, I ended up porting older poller style backends from Java to Go for the same reasons.
The one advantage of pico/nano are that they're generally pre-installed everywhere, but it definitely would be nice to have a text editor with sane keybindings on the server. I hope something like this emerges as a standard.
The link worked for me.
You should have the folder $GOPATH/src/myProj That folder can contain unlimited files, but all files that end in .go must have the "package main" declaration at the top. If you want additional packages, create a new folder $GOPATH/src/anotherPackage or a subpackage like $GOPATH/src/myProject/anotherPackage and import it with "anotherPackage" or "myProject/anotherPackage" respectively. Once you've fixed the organization of your code, just cd into $GOPATH/src/myProject and type "go build" and it'll spit out a binary if you have a func main() 
Unreadable on mobile :(
I assume that the glibc comment only applies to cgo apps. AFAIK there is no glibc in native go apps.
A bunch of the gonum libraries are concurrent. I use it all the time in my own work
You should mind your language in this forum. 
So what? You are in the Go thread on Reddit posting a Go related thing. How is that a search problem? And even if you post a blog post, you can still have tags for it (and the search engines are supposed to be smart enough to pick it up correctly). 
Cool. Any reason why you didn't make this go get-able, and are instead using a Makefile and a src directory?
Me, too. In the meantime, [I wrote my own editor](https://www.github.com/marssaxman/ozette) that is basically a simplified nano clone with more normal keybindings, mated with a tabbed window manager. 
I personally use this method but I default the loggers to stdout or stderr to save people just wanting to see if it works and I make sure each message has a prefix to identify the library so it's clear what messages would be suppressed by replacing the loggers with nil. Or setting a more suitable output. This way users will know about issues and will actively choose how to show them if they don't like it in the terminal. Rather than possibly never knowing because the loggers default to nil.
Interesting project! It would be really cool to see some features similar to Sublime Text's such as multiple cursors and an efficient fuzzy search. Another interesting editor is Slap. https://github.com/slap-editor/slap
~~Seems like a silly argument but, I'd put John Carmack at the top of that list and he uses syntax highlighting, I doubt anyone would call him lazy.~~ edited: misread post 
Please don't do this for anything you distribute. Those debugging symbols are actually important. What if someone needs to find out what is going wrong with the binary's interaction with the OS?
afaik, the standard socket library is fine. I'm using it for my own project. Speaking of socket, you would have websocket and tcp socket. At first, I started with tcp, and it worked great. However, my front end (AngularJS) cant have a tcp setup up and running so I switched to websocket. It's working fine now. Be my guest to checkout my repo for reference. Take a look at server.go. Sorry for messy code, I havent review it yet. https://github.com/v36372/thesis
go build *.go will compile all go files in the dir together
Actually, some file systems do have compression and it ends up being faster.
Some of them, like btrfs, let you turn it on. You have to worry about small changes to large files though - for example if you have a 4GB VM then you need to mark it to not be compressed by btrfs.
No, always close the connections you open after you are done* with them, otherwise you will leak connections and some of the database systems does not close idle connections automatically if not configured to do so. * "done" state can be different per use case and database client, for OP's case DB conn should be closed in main function - most probably after closing the listener.
Is WebSocket really an option for Android? I think TCP sockets seem like the way to go.
Until recently, this exact argument was used as an argument *against* pico/nano, because "vi is installed everywhere". It's not a good argument.
ZFS always works on (configurable) record-size chunks, compression works just fine on large files/volumes.
Care to expand on how it's not a good argument ? It seems to be an excellent argument for a lot of people. 
Every Go program used to use cgo until 1.5 if you used networking (unless you were using the netgo build tag)
In my most common code I only use it for a timer, nothing else yet, but in case performance is unacceptable I would use it to parallelize a part of my code.
Because taking the argument to its logical conclusion would involve all of us using ed forever.
Could I suggest sticking to the [XDG Base Directory Specification](https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html] for the config? Supporting it would be a relatively small change: configuration gets stored under the directory pointed to by $XDG_CONFIG_HOME if it's defined, or ~/.config if it's not.
Yes. I think so! Add one of these "uptime" things to your program, and you have basic concurrency. (or is it parallel?) Anyways its the first thing I code in a web app... package main import ( "fmt" "time" ) func main() { // Run time boottime := time.Now() // Duration var uptime time.Duration go func() { for { time.Sleep(1420 * time.Millisecond) // Display Uptime! uptime = time.Since(boottime) fmt.Println("Uptime: " + uptime.String()) } }() // do things other than sleep time.Sleep(10 * time.Minute) } 
Yes. Because someone figured it was time for an improvement over ed, despite it being more widespread at the time.
The goal is to use the standard keybindings that are used in other text editors. In a text editor, `Ctrl-Z` is usually undo. Since micro runs in a terminal, it is impossible to access Cmd key events because the terminal only sends Ctrl events. Usually the terminal uses Cmd events for its own keybindings (`Cmd-Q` closes the terminal itself). This is simply a limitation of terminal text editors, and terminal applications in general
Micro is now go get-able ~~provided you also move the runtime files to `~/.micro` yourself~~. EDIT: The runtime files are now embedded in the go binary so all you need to do to install is `go get -u github.com/zyedidia/micro/cmd/micro`. See this [commit](https://github.com/zyedidia/micro/commit/8656335da4584a1a900d18a28eb47a4459b19c7f).
This is exactly what happened to me. I learned it because it looked so simple and easy to build concurrency with it but then stayed because of the minimalism, productivity and tooling.
I use a $5 digital ocean server. To deploy, I just push to git and pull on it and build. I used to have a homemade auto deploy but it had too many points of failure. 
You can take a look at what Java has: http://www.tutorialspoint.com/java/java_generics.htm
i hope there will be a video of this talk released 
Ah, OK. I was so confused for a bit. 
Yes, would be great if all the resources were embedded in the binary.
&gt; I come from a Ruby/JS background I'm not sure the classical definition of *Generics* applies to dynamic languages like Ruby/JS? I can only offer my experience of *Generics* to the language I used and that was C++ with it's introduction of templates (the first form of generics in C++). For simple things, templates did seem to work and work well. But as they where used for more and more complex coding constructs the compiler and linker errors became more and more obscure. I suspect it is that name mangling, unresolved rubbish that is so common in the modern generic C++/STL that by not embracing generics the designers of Go are trying to avoid.
AWS
Google App Engine. Most of persomi.com production services (www.persomi.com is Wordpress on App Engine but not Go obviously).
That's the point - you don't stop.
Google Cloud Compute Engine (production) Digital Ocean (personal project)
We're using websockets from the gorilla package for incoming connections from players, with a seperate goroutine for both reading and writing packets. The packets themself are (de)serialized using protobuf, a bit of a pain to get running well, but it works wonders once you have that done. There is a small message routing system in place to have every packet type handled by its own handler function, on the read goroutine of the user. The gameplay itself runs in rooms that users connect to, being its own goroutine again to ensure the game code itself does not run concurrently with handling messages. All packets that have to be handled by the room instead of the user code, get send into a buffered channel that the room goroutine will read out of and handle. Its a simple select on emptying that buffer, and waiting for the next game tick to happen every 50th of a second. Feel free to pm me for more questions.
Expected snake oil, turned out to be really interesting. 
Ian Lance Taylor, of the go team, put together a mock proposal of what generics do, why they'd be useful and what they might look like in go. https://github.com/golang/proposal/blob/master/design/15292-generics.md
In reality, what it does is replace the need for interfaces with specific types defined at compile-time. Where this comes in handy is when you need to support things that don't fit an interface (mostly built-in types, like the various numeric types and string). The other major advantage is that what you put in is what you get out. So, like, if you have a generic container in traditional Go, you use interface{}... which means when you put a value into it, it accepts anything (even if you really only want it to accept one type), and when you get a value out of it, you get interface{} and you need to convert to the concrete type (which could fail, makes your code slower, etc). With a true generic container, what you put in is what you get out, so like List&lt;Player&gt; would accept only Player values, and when you get a value out of it, it's always a Player. The main problem with generics is that they make your code harder to read, because you don't have real types in the generic code, you have some placeholder for the real type. Also, it tends to mean that you need a lot of awkward annotations on functions and types, like `func (list List&lt;X, Y&gt;) Get(x X) Y` .... where the stuff between the &lt; and &gt; are types used in that code (for example, int and string).. try reading a whole file full of that, and then imagine generics used inside other generics, like type List&lt;X, List&lt;X, Y&gt;&gt; (yes this happens *all the time* in languages with generics... so much so that it was a huge relief when C# finally stopped requiring a space between the &gt;&gt; to differentiate from the bit shift operator). It's kind of awful. Handy at times, but always awful. And that's why many of us are wary of adding generics to Go. We've been burned by them in the past. I don't even care about compile times or code size or any of those other tradeoffs that people always bring up with generics. I care about code clarity. Generic code, as defined in other languages (such as C++, C#, and Java), is really really unclear. I hope there's a third way, that can enable some of the code that is really bothersome for Go devs right now (like custom containers, e.g. trees), without making the code horribly ugly and hard to understand. 
What makes it even worse with Java is runtime type erasure. In the end it is just Object and you can not get any information via runtime introspection (with some exceptions that are awful to use). So I' d rather stick with go's verbosity before trading for a half-done generics implementation like Java has it
For example: greetings := []string{"Hello", "Goodbye"} // messages will be []string{"Hello, world!", "Goodbye, world!"} messages := Map[string](greetings, func(s string) string { return s + ", world!" }) // This could be safely implemented with generics with something like. // We call with the type T, so the compiler will be able to see if we're doing // something stupid here at compile-time. func Map[T](collection []T, fn func(T) T) []T { results := []T for _, item := range collection { results = append(results, fn(item)) } return results } // The alternative is writing one of these functions for each type, hence the // argument about having to write a lot of boilerplate code to get around the // lack of generics in Go. Something like that anyway. There are far more applications for generics than just this kind of thing. But basically, it'll help you make more "generic" _things_ that can be used with different types. 
Please check the about section. GO programming basics, I have adapted from his book. Rest everything I wrote from what experience I had, I wanted to write a book based on real application rather than the typical trend of giving some lame example and then expecting the user to magically understand the advance concept. Also lately I was thinking to move that section to appendix, rather than as a chapter. Any more comments? if you want to send a PR I'll be happy to receive it!
Dedicated server with Debian for production and personal projects as a freelancer. I do this since decades and wonder if on the cloud I could gain something ?
Google App Engine, just make sure that you are aware of the limitations ie: urlfetch etc..
Depends, if you really need high availability and reduced amount of ops the cloud can give you it pretty easy (Hosted services like DBs, load balancers, Object store etc) without configuring it yourself (Multi-datacentre, 24/7 monitoring etc). Also if your workload has spikes or is growing pretty fast you can automatically increase the number of servers up and down and be billed by the hour or even minute depending on cloud provider. Though, one of the many good things about Go is that it has really good performance so 1 box can get you pretty far. If things are going smoothly as it is I would say you no need to change and reevaluate if you ever encounter issues where a cloud provider could help. 
... and I love that about the IDEA plugin! If it had to compile the project for every little thing it would be unbearable for me (It takes about ~1.2 minutes for Go 1.6 to compile our project).
I actually read most of the book when I started looking at Golang a couple of weeks ago. I really like like that you don't use frameworks or additional (unnecessary) packages. The authentication part could have been longer, though. I understand the theory behind it, but actually implementing it seems harder.
Welcome to reddit.
I had to turn my phone sideways.
We use AWS: - Docker images contain Go binaries and other non-code dependencies - Docker images on private Docker Registry - EC2 CloudInit pulls down latest Docker image and runs it App behind AWS load balancer.
Excellent!
&gt; The first example does seem very convenient and simple. In contrast, I can understand how the second example can potentially "open the floodgates", since if you create a generic list/collection type for ints and floats, where do we stop? I think you are misunderstanding - you only create the generic function or class once, then you can use it many times with any type you want. Here is a simple example in C++: template &lt;class T&gt; T doSomething(T item) { return item + 5; } int testInt; float testFloat; doSomething(testInt); doSomething(testFloat); Now, I can call "doSomething" with any type passed in (as long as it can use the + operator). This may sound pretty close to interfaces, the difference however is usually generics traditionaly are closer to code generation. For every time you use that function with a new type, the compiler will generate code specifically for that type. Currently, interfaces can solve that problem, however you need to write code for every type that you want to have an interface. Generics would solve this by (more or less) automatically generating code for every type needed.
This so much. Having to write a script that will hit a rest API and create output files with the returned data. The amount of data I pull back is close to 20-30GBs. Without concurrency, it took the script 3-4 hours With, ~1-2 hours 
Have you tried compiling like this: go build -tags netgo
ibm bluemix
If by "install" you mean `go install`, I never use it (all my dependencies are in `vendor` under project root). `go build` is more than enough when I actually need to compile. Otherwise, IDEA's error detection / code correction is more than enough for me *while typing*. ~~Aside from runtime nil pointer errors,~~ what specifically does the IDEA plugin miss, but the compiler doesn't?
Probably worth filing an issue to make sure it doesn't regress for 1.7.
Google Compute Engine is awesome, very fast and easy to use with great options. Also I think I read somewhere that it's cheaper than Google App Engine, haven't checked this though.
Same but I cross-compile on my machine, push the binary then reload the service (all with ansible)...
Loving this, it maybe my default tiny text editor going forward!
I found that article very ideomatic.
I'm amused at how many people think Go sucks because it doesn't have generics. Use something else. Don't try to convince the Go team to fuck up the language to appease your want for your pet feature. Go does not have generics, yet somehow manages to be a popular, useful language. If you're so high up on your horse that you just can't use Go because of a lack of generics, that's just fine. The Generics discussion is frustrating because it's provably obvious that Go doesn't need them to be successful.
#
A bit offtopic as not related to golang, but Idris and dependent types look tempting
I think generics won't ever find their way in Go or they will not be of use. Go has its design and generics will not fit into it without redesigning (in fact recreating) basic Go concepts. In fact, go has one killing thing (its concurrency model, just in case you know nothing about Go). Without these magic goroutines it'd be a language with an odd (not to say awful) syntax, smth like Pascal of XXI century or whatever and no one would actually use it. If one day there will be a language which shall offer the same performance and usability combined with all these sweet things (generics, lambdas, java-style collections etc) it'll kill Go in no time in my opinion. I don't know what everyone who's bagging for generics is looking for since Go isn't an object-oriented language and thus it'd be a huge nonsense to see generics in it. In fact, most hard core gophers (among those who really like the language design, not just goroutines) whom I know don't want generics.
You did! 😱
You did! 😱
Simply put, I think Go needs a way of eliminating duplicate code when implementing generic containers. It need not be the "usual generics" which comes with contravariance/covariance headaches but a simple type-safe template substitution (think C++ templates only far less powerful). This will remove the need for `IntContainer`, `StringContainer` and the likes...
Yep - I think you're on the right track here.
there are two places in my production code that downright scare me because go doesn't have generics. that being said, i'm moving all of the stuff i control from C# to go.
Build it using Docker ([example](https://github.com/arachnys/athenapdf/blob/master/weaver/Dockerfile.build)). There's also a pretty straightforward [guide](https://medium.com/iron-io-blog/the-easiest-way-to-develop-with-go-introducing-a-docker-based-go-tool-c456238507d6) on it. Also, you can easily mount your current working directory to the build folder or run the binary in a Docker container.
I think what you want is template package like defined [here](https://docs.google.com/document/d/1vrAy9gMpMoS3uaVphB32uVXX4pi-HnNjkMEgyAHX4N4/preview?pref=2&amp;pli=1#heading=h.wko1dvdznk4y). It would really fit go very well and should be, in comparaison to "full" generic, way easier to implement. The problem is that going this way would completely remove the possibility to have more powerful generics in the future. 
I find it very impractical to use struct tags for that. What if you need different validation for POST/PUT? E.g. some fields are mandatory for POST, but optional for PUT? In general attaching behavior to structure definition is a bad idea. I would even say that json's ",omitempty" is evil. But it's a lesser evil.
Meh, even focused into two hours of the day, routing performance still isn't important
It sounds like you want to use Rust. So if your using Go and expect it to behave like Rust then I doubt it's the language that's flawed. Rust is a good language in its own right. If that's what you like then use it. Don't blindly demand every other language be Rust. **edit** spelling
Yeah. It's great to be able to kick off an email to somebody without having to wait for the network request to finish. There's no guarantee that the message will take, e.g., 400ms and it's rude to keep the client waiting.
Pattern 4 address this issue, as it separates the validation of the model from the validation of Post/Put requests. Regarding struct tags, the most common validation packages I found all use tags to perform simple validation. I see your point about coupling validation with the data, and I agree it's not a perfect abstraction. However, I think this is a case of practice over theory, and it seems that this is a weaker coupling, as the tags only have meaning in the context of the validator.Validate function, do not have any default behavior, and can be swapped out like an interface (consider a completely difference library that uses the same "validate" tag).
I can see why you'd want this, but I don't think it makes sense in this context. Json encodes, data, which can be stored in structs. A struct can implement an interface, making the interface type acquire data. But the interface itself does not contain data. Consider: type Product interface { Sell() uint Buy(uint) error } type JimsProduct { BasePrice float64 Tax float64 } type BobsProduct { MinimumQuantity uint PricePerItem float64 } If both of these structs implement Buy and Sell, then they are of type Product. But they have completely incompatible data, and so must be encoded/decoded separately. I suspect a general solution for Unmarshaling an interface would entail defining a struct that contains all the data for any instance of that interface, and defining ways to "cast" that generic struct into a specific type, which implements the interface.
I can give you materials for YourLanguageSucksSucks instead
Consider this generic struct, which can be cast into various geometric structs based on the provided optional data: type Object struct { Id int SphereData *Sphere // let this be optional CubeData *Cube TriangleData *Triangle ... } Logically, only one of the pointers would be non-nil, and thus you could convert the generic into your desired type.
wow. I've been using govendor for some time now, but I was blown away by the features added since the last time I updated it. 
https://github.com/ksimka/go-is-not-good
&gt; On *nix: Behind a reverse proxy of some sort. Look up "pound". It's been a while since I used Pound, but when I did it required frequent restarts due to memory leaks. This was on a somewhat high traffic site, averaging ~1000rps, peaking around ~1700. I made the move to nginx for reverse proxying/load balancing/ssl terminating a few years ago, and I couldn't be happier.
I find it very reassuring that I am not the only one who encounters these problems when dealing with JSON in Go, which is very tedious, most especially when dealing with dynamic data of a struct's field. In the end, I have to resort to creating a data structure for every action, such as creating a user and updating a user. To make things even more complicated, a field of that User struct is dynamic, so I need to create a create and update struct just for that field. At some point, it gets pretty crazy but this seems to be the "Go way".
ed shall live on!!!!!
As said above, unsafeMEMCHR is using (not misusing) unsafe package for 1 byte long pattern search. If you look into it, there are proper boundary checks and slice over array should be always aligned in Go, isn't it? Furthermore see the link in the header and check the MEMCHR source code: http://www.stdlib.net/~colmmacc/strlen.c.html And what is wrong in explicitly passing pointers to the slices in the other algos. Go does pointer passing anyway if function parameters are slices. I checked into the the Go test report - RAM carnage does not happen on my machines (go versions go1.5.1 - go1.6.1 darwin/amd64, OSX with amd64 CPU's, Dual core 2 - i7, 4-12GB RAM). What system you used for testing? 
Honestly, I'd be perfectly happy if the following worked: type T interface { Do(x interface{}) interface{} } type IntT struct {} func (s *S) Do(x interface{}) int { return 0 } And IntT was considered an implementation of T by the compiler. 90% of the time, I don't care about generics, but 90% of the 10% of the time that I would like them, I'd be 100% happy if only the return type of interface{} could be overloaded in the implementation. Java does this, and it's super handy at times, even outside of generics. I'm usually okay with passing interface{} in as an argument as the code is mostly hidden from the end user (talking library code, here), but conveying return types to an end user is super important. Also, 97% of statistics are made up on the spot.
Thanks. I wondered about that and hadn't had the chance to research it yet.
Use Interfaces. IIRC Generics means a method can work with any type. I find this somewhat unsafe, especially if you are exposing something to the net. Rather if the method implements a interface, only compatible types are accepted and the maintainer of that method is not responsible for weird type fuckups by someone else.
Can you elaborate note on the Pi?
&gt; slice over array should be always aligned in Go, isn't it? aligned based on the size of the type, yes, and 16-byte aligned on the heap. but if you reslice the slice it can 'mess up' the alignment (e.g., https://play.golang.org/p/HYCXEwGChG) for example, see: https://golang.org/src/crypto/cipher/xor.go the stdlib only reads words if the arch supports it. &gt; And what is wrong in explicitly passing pointers to the slices in the other algos Memory accesses. `&amp;T` could cause the compiler to think it escapes, allocating it on the heap. Passing a pointer to a three-word struct (i.e., a slice) has no benefits, especially if it causes a memory access. &gt; RAM carnage May be my fault now that I think about it.
The [non-nil nil](https://golang.org/doc/faq#nil_error) thing is missing from the list. That's a legitimate complaint. Some of these other complaints, however, seem silly. &gt;The select statement is blocking, but if you add a default case it suddenly isn't. Why is this bad? How else would the default case work? This is the obvious way for it to work. &gt;Go does not require break at the end of every case in a switch statement I hate that you have to write `break` at the end of every case in C# even though there's no fallthrough. There's no need for a superfluous `break` if there's no fallthrough. What's the problem? &gt;If you import a library or declare a variable, but do not use it, your program will not compile even if everything else is valid. Debugging is fraught with adding and removing "import" statements. Use `goimports`. Variables can cause trouble, however. On the other hand, an unused variable is often a bug, and the Go compiler has helped me catch many bugs with this *feature*. &gt;Go's error type is simply an interface to a function returning a string. So? You can add whatever you want to your own `error` types, you can even create your own interface for errors. Again, what's the problem?
Java's runtime erasure is a big deal. It is counterintuitive when more complicated cases are considered. .NET did it right. Generics are handy in .NET. But it is one of those tools that can be over used. It can also solve difficult real problems. I was glad to have generics in a few difficult cases. Most of the time I don't miss them. 
&gt; Java's runtime erasure is a big deal. I know, it causes a lot of pain sometimes. What I meant above was purely for the syntax, since that's what the parent comment mentioned. What I'm hoping for is an implementation that's at least close to the Java syntax, with much better compiler and runtime behaviour. Time will tell.
linode production
Managed to solve this. This page https://elithrar.github.io/article/approximating-html-template-inheritance/ helped. Basically, I had to change the code with which I parsed the templates to: tpls, err := filepath.Glob("views/user/*") if err != nil { log.Fatal(err) } layouts, err := filepath.Glob("views/layouts/*") if err != nil { log.Fatal(err) } for _, layout := range layouts { files := append(layouts, tpls) t.templates = template.Must(template.ParseFiles(files...)) } 
In Scala, at least, sum types are marshaled with a tag in json object like: {"components":[ {"_type": "image", "url": "http://imgur.com/a.jpg", "metadata": ...}, {"_type": "paragraph", "html": "&lt;em&gt;hey&lt;/em&gt; world", ...}, ... ]} You do switch on the tag, `_type`, to select appropriate data constructor. Probably you can do the same with Go.
I looked at your commit, which was very helpful, and I think I almost understand everything that's happening in your code right now. The only thing I do not understand is the float64 variable called out and the the mutex in Manager. What are they used for? Could you further elaborate on that?
&gt; thats why Haskell is so popular in academia. as well as scala in twitter Meanwhile, gophers solve real industry problems (docker).
&gt; Is it a RESTAPI or a monolith/server rendered web app? Why not both?
My Pi running latest Raspberrian has my home automation server (written in Go) which exposes an HTTPS API (caddy auto-https). This and other ([serve](https://github.com/jpillora/serve), [gotty](https://github.com/yudai/gotty), [cloud-torrent](https://github.com/jpillora/cloud-torrent)) processes managed by systemd.
'We' should grow up: stop whining and be master of our own destiny. So either: 1) Get over it and love Go 'as-is' 2) Move to another language (there are so many - take your pick) 3) Create your own language or dialect (be bold) 
I still don't think Generics in Go would do anything that you can't do with careful thought and interfaces.
Personally I've been adding a Validate() method to the interface, which returns `error` if there's a validation problem. That can be kicked back to the API consumer. So, like pattern 2 in the article.
Uh, I'm not sure if you're joking or not. We do have type safety. If you have generic code that needs to work on multiple types, you just have to copy and paste it (or, preferably, generate it). Yes, that's not ideal. I think you're complaining about using interface{} for generic things... yeah, don't do that. &gt; Also i think that golang should only be for computer scientists anyway. generics raises the bar and complexity of the language so only good programmers will use it. &gt; when we get generics, golang may not be "simple" any more. but thats good. golang will be ready for industry LOL wut? Please tell me this is a joke. Go is being used in industry right now. Many major software companies have some code written in Go, and more are picking it up all the time. If a programmer wants something complicated like Haskell or Scala, Go is not the language for them. It never will be. Making it more academic will not make it more useful or better. I don't want to use a language that is so complicated that only a small number of people can use it. That limits who I can talk to about it and that limits my job opportunities. 
&gt; unsafeMEMCHR.go does not do this It's not something your code *does*, it's what happens if somebody passed a resliced slice. If you read 8 bytes at at an odd address you have an unaligned read, full stop. This is entirely possible with your code. &gt; pointers *[]byte/*string is a dubious API. I'd even call it terrible. It's tells me you're modifying what I pass, which you're not. Also, keep in mind a Alice's data is distinct from the slice itself. Slices contain internal pointers to data, so the data could likely be on the heap but the slice itself does not need to be. 
For anyone interested, here's the [Bluemix pricing page](https://console.ng.bluemix.net/pricing/) including info about the free tier. My [hello world on Bluemix](https://github.com/lpar/bluemix-golang-hello-world) project is a bit out of date, but the links in the README are still useful.
You might also need to Close() the results of a query, if you don't enumerate all the rows. See [the docs](https://golang.org/pkg/database/sql/#Rows.Close). You should also close compiled statements when you're done with them, and transactions.
Assuming you found it on guthub, check stats like number of contributors, stars, last commit, open issues, build status, unit test coverage, etc. That should give a clear enough picture.
&gt; My case is a chat system with 3-4k users on at once. Damn, nice. Is that just one server with 1 Go app running? Again, sorry guys if my questions seem out of line with the "Go app" remarks, I'm just so used to the `nodejs's` "multiple instances" design. I keep thinking I will need to run multiple Go App's on 1 server, but that's not the case?
Well I'd say the only challenge you'll face is the languages' strict nature, but you should be good. JS is slow. If you need / want speed, learn Go.
It is currently still node in production, I am still in the process of rewriting. It spins up 3 cluster children plus one master to recover and deal with some requests it makes to our internal API, along with allocating connections to the children. I plan to have golang to just be one process, as golang will automatically spin up more threads if it needs to (as it has done in small scale tests)
http://play.golang.org/p/7u5DY7mkzI Intermediate structs `webPage` and `component`. And more useful types `WebPage` and `Component`. Not sure if I'll actually do this. Example is based off of https://golang.org/pkg/encoding/json/#example_RawMessage 
&gt; No spinning up workers or interacting with Redis or RabbitMQ. You do it all in your Go code using Go's excellent tools for concurrency. This seems like just what I want... For example, our gameserver is behind a load balancer that round robins towards 3 node instances. When a player joins a game and if the other player is on a different node instance guess what? The entire life of that game for all movement data, player skills, cooldowns, hp regeneration, everything all has to utilize Redis' Pub/Sub just to talk between those two node instances. The solution? I could disconnect the player that is about to join that game, and direct them to a different directory/upstream block on nginx that connects to that specific node instance (port).... It just seems so silly to do all this. I'm looking forward to Go now and appreciate your feedback. Seems like it's just what I need
Lookahead would be insufficient on its own in this case, unfortunately, since you *cannot* distinguish the two cases without doing name resolution first. To allow lookahead to work, you'd have to require an awkward disambiguation syntax, like `(List&lt;N, M&gt;)(v)`, and the errors would be unpleasant. This can be so easily avoided just by using square brackets that it doesn't seem like it's even a question.
Hehe, Go is really cool !
&gt; I moved from node.js to Hey, I forgot to ask. Since you came from nodejs as well, do you have any advice for a fellow JS dev to help with the migration process? Maybe things you wish you would of knew before switching, etc? The only thing I am worried about is the syntax differences. But, I think I will do fine once I start actually reading / learning.
&gt; A Go implementation might make this easier to manage, but it doesn't remove the problem entirely. I was just thinking that single Go app for 1 physical server would be sufficient [and more appropriate]. (instead of having to manage multiple node instances per server) -- Then, use Redis for Pub/Sub to communicate between physical server's to scale later? (I'm not entirely sure here)
&gt; One very important difference to keep in mind is that they are not scheduled preemptively While strictly true, it's not often an issue because the Go runtime can switch goroutines a) at every function call, and b) at several language keywords (select, etc) (not an exhaustive list of scheduling points, but you get the idea). So generally even a collection of CPU-bound goroutines are scheduled reasonably fairly.
Embrace the struct and the slice. You'll rarely deal with arrays directly. The thing about Go is you need to put your effort into configuration. It's worth the time to build out your structs completely and beautifully because it makes using them very easy.
Yes, that's true, but it can occasionally happen when you have some sort of long-running [e.g. multi-dimensional] loop that is highly optimized (so no function calls anywhere.) Optimizing e.g. numerical code will mostly push you to move away from possible scheduling points, since all of those are associated with slow operations, so it's good to be aware of it, and -- if necessary -- take charge of the problem manually.
I'm not sure why this was the solution, but after I kicked off my two main goroutines in my main() func, I started an infinite for{} loop to keep the program from closing. Instead I changed it to a select{} on a whim and it solved my problem of the program hanging after a seemingly random amount of time. 
the most elusive keyword: `despiteallobjections`
Right! I must have wanted "machine code" out there.
Basically I agree. I've also seen cases with, eg, a HTTP server that spawns 10k CPU-intensive goroutines (admittedly a pathological case) and then has degraded request latency because the scheduler doesn't know how to distinguish between the small number of latency-sensitive connection goroutines and the large number of non-sensitive processing goroutines. Of course you can avoid this with better application design.
Go is a good replacement for node. It's my main use case here at work
He's right though -- you need to think about scaling. Sure, for now you can use channels for player communications, and go will use all cores by default anyway -- but if you need to scale, you'll still need something. Which means from a design standpoint, it might be better to do all of your communications through pub-sub anyway, even in-process (Go has excellent redis support). Then you could scale up transparently. 
I have been using Glide up to now because I thought it was going to become the preferred tool for vendoring, a lot of articles have been written about it over the last year which somewhat made me pick it. However I see govendor talks about it using a "standard" vendor file, from the looks of it "vendor/vendor.json", what does it mean by a "standard" vendor file, is this going to become some Go standard?? edit: fixed typo
I tried writing a benchmark for this, but in my tests, there was no consistent performance benefit to inlining: package bench_test import "testing" func BenchmarkInline(b *testing.B) { bytes := []byte("abc123") m := map[string]int{} for i := 0; i &lt; b.N; i++ { m[string(bytes)] = 1 } } func BenchmarkOutOfLine(b *testing.B) { bytes := []byte("abc123") m := map[string]int{} for i := 0; i &lt; b.N; i++ { s := string(bytes) m[s] = 1 } } $ go test -bench . testing: warning: no tests to run PASS BenchmarkInline-4 20000000 85.7 ns/op BenchmarkOutOfLine-4 20000000 83.7 ns/op Go 1.6 on OS X.
The vendor file spec from govendor is defined here: https://github.com/kardianos/vendor-spec It was proposed to use this file for go everywhere here: https://github.com/golang/go/issues/13517 tl;dr There are fundamental differences left to be worked out in the community and nobody on the go core team seems to be interested in stepping up and driving a decision. (Probably because Google doesn't care about vendoring internally.) There will be bikeshedding until the end of time until somebody with the power to make an executive decision does so. (In general, I agree more with sdboyer and mattfarina in the above discussion but I'm a nobody.)
Why do you think there has to be a "clear winner"?
I'm a Node.js developer in the day job. Go is strictly better than JavaScript except for the package management story and the package ecosystem (go is quickly catching up). (Unless you're writing a one off script.) You might find this talk interesting: https://www.twilio.com/signal/2015/videos/high-performance-messaging-with-golang-and-redis
in this case why not just do it runtime and embed T into IntT?
Luckily Go provides really nice interfaces; so if you can find a clean abstraction you can worry about that later. If you no longer have redis pub/sub locally and everything is in the same memory space you'll be able to scale a lot longer before needing to move concurrently (if ever). While you're looking into pub/sub frameworks, take a look at [gnatsd](https://github.com/nats-io/gnatsd) as a pub/sub. The [throughput](http://bravenewgeek.com/dissecting-message-queues/) is very impressive.
Yeah! There's a talk somewhere about uints/go, but the gist is to just use normal ints everywhere unless you need uints for performance reasons and know exactly what you're doing with them 
First part depends on allot, but basically comes down to can your 100% trust that a program will always build when your updating your changed...if not then vendoring is probably a good idea. As for, should you check in dependencies in the vendor folder, the answer is yes you should; others may not agree but here is an article I wrote on why you should https://medium.com/@joeybloggs/go-vendoring-for-consistent-builds-e0dc8187606e#.t1zjxtgu0
I guess I just don't run into the problem enough but I still wonder why folks won't just implement their code using interface{} as the type and then make it type safe by creating typed accessors. Yea you'd have to make new accessors for every type or interface but its not the core logic being copied here.
&gt; Of the few keywords in Go ... That meme you introduce your post with isn't really accurate in practise. In order to get the number of keywords down to 25, the Go designers created 39 special identifiers available globally. We can assign to them, and so do things like: package main import "fmt" func main() { true:= false fmt.Println("True is:", true) } In practise Go programmers have to treat the special identifiers like they would the keywords, but taking extra care not to assign to them because it might slip through the compiler. So really there's 64 "keywords, etc", which is similar to Java's 53 and C#'s 78 *(those two numbers from memory)*. 
As @karnd01 pointed out, it really does depend. Personally I think you should try to decouple one library from the next as much as you possibly can. If you need to do URL normalization for instance, you could create a standalone library to do that which is then included locally into your project. For 3rd party libraries, the best option for stability and security seems to be saving and including them locally to your project. Ideally these libraries have very few dependencies, if any, outside of the standard lib. As you're looking to offer a library to other Go developers, again I think it would be ideal that the library is as self contained as possible. Would it be possible to just copy over the code from all sub-libraries into their own file/folder in the main library, making the imports direct? Otherwise, keeping a static version of each included library in the main seems the best option.
This seems similar to https://horizon.io/ by the Rethink DB guys. (Spoilers: Not released yet.) It would help to have an architecture document so people can evaluate the way it works.
I looked up UUID generation in Go the other day. The conclusion I remember coming to was that UUID turns out to be more or less trivial to generate yourself so you don't really need an external library if you don't want to use one. 
Thank you so much! I'll start there.
Or use https://github.com/laher/goxc And save 29$ a month.
I'm not seeing the use case yet. I don't think I've needed to stop and resume signal handling before. When would you want to do so? Typically, I do the following: sigChan := make(chan os.Signal, 1) signal.Notify(sigChan, os.Interrupt, os.Kill) When the signal comes in, I can stop workers, clean up, etc. Two lines and a select statement. 
Yup, no need for a wrapper. Used upx on top to get even more compression.
I'm a node developer, also looking to switch to go. My main likes for node is how well it "talks" with my JS front end with things like socket.io, can anyone comment how easy or friendly it is to build a react and web socket frontend with a Go server handling all my socket and REST functionality?
I don't use musl to have smaller binaries. In any case upx offers very little for its downsides, so that's also not a good idea.
Are you using anything like Kubernetes or Mesos too? And if not, how do you manage your containers?
Terrible example. Not go fmted, not having structs defined for the api objects, nothing even close to be of particular use to the specific domain (IP Street) itself. 
If your library depends on dependency A version 1 which has method DoSomething() And in your root package you also use dependency A version 2 which no longer has method DoDomething , but now method DoSomethingElse() how is the root package supposed to know that the library needs a different version than itself because they have the same import? And that's just a simple example, many more versions could be at play.
Actually, it's just GOPATH/src, the rest with github can be replaced with whatever path you need. If you do want to share your code, that's a different story. Also, I'd suggest you to star with the language by reading the manual. 
I just need a static build to not carry 250Mb worth of Go dependencies in my docker containers. Can you point me to where it outlines the downsides or upx?
plot: they use it
GOPATH (or go package management) is like monad. Everybody blogs about it. Different people have different ideas about it. So many tools are written for it: https://github.com/golang/go/wiki/PackageManagementTools Once you get over GOPATH, it'll be easier. Don't put too much effort around it. Just follow https://golang.org/doc/code.html for now. Good luck.
404 for me
Fair enough... Disk space/ram tradeoff is nothing new. 250Mb is not binary size, it's the container size, and if I keep go environment it baloons.
Minor nitpick, `webPage`'s `Components` doesn't have to be a slice of pointers. I kinda prefer to avoid working with pointers unless I really have to, such as when I need to optimize (in this example, you don't need to) or when I work with json unmarshal/marshal. Your usage of the pointer isn't needed since it will just decode it just fine.
Interest to know and yeah, select{} sleeps whereas for{} spins.
That link works for me. 
Thanks! I didn't even think of firebase, although I already knew it. My team and I will definitely look into it :)
Not sure how common it is, but several components of Diego, the Cloud Foundry backend, do something similar. One of the contributors made a library to support it: https://github.com/tedsuo/ifrit I don't have a simple example offhand, but this is how it is used: https://github.com/cloudfoundry-incubator/rep/blob/master/cmd/rep/main.go#L319
&gt; It's not something your code does, it's what happens if somebody passed a resliced slice. If you read 8 bytes at at an odd address you have an unaligned read, full stop. This is entirely possible with your code. Nope it does not. Look into the code. &gt; []byte/string is a dubious API ??? what you are talking about ? &gt; Also, keep in mind a Alice's data is distinct from the slice itself. ??? what you are talking about ?
Using `revel` you can fairly quickly bootstrap a REST Api, took me like a week or so to get some simple website setup. I recommend using `gorm` to map go easily into a relational database.
I found Code a bit lacking in features compared to a fully suited Atom environment. (And honestly, waiting 2 seconds to start it is nothing if you work at it for hours)
basic net/http is good enough and for 3/4 endpoints you should not need more. &gt;terms of logic for each endpoint it's quite heavy, with it communicating with Databases, other API's and other servers. Code smart, an API won't help 
#
Framework free is the way if you don't have too many endpoints but I would also take a look at: https://github.com/valyala/fasthttp
stick to the simplest possible solution. start by analyzing what you need. now look to see if net/http does it. Only If it doesn't (eg, lots of middleware with context passing is needed) then go for a framework.
Right, I think I should indeed avoid vendoring in the library. What about any cmd (in the cmd folder) in the library? How would I specify that v1 of the main lib works with v1 of a sublib, but that v2 of main works with v2 of sub? Or should I just mention that in the readme and people will use their vendoring solution to enforce that (ie. but the responsibility in their hands)?
Putting vendor folder under the cmd.. Hmm interesting idea, I've never tried that before.. might work. I agree it should be avoided, but that's not always the case.. I just had a project break because a dependency was updated with breaking changes and I neglected to vendor it and although anyone using my library before that and vendored it will continue to work fine...but anyone trying to use my library now, it's broken. I don't think it's such a big deal in your case because you maintain the dependencies your looking at vendoring, just there is no "right" or "one" way to vendor
It's up to you. For me, I like simple, clean, high productive, and high performance choice. And I am using Echo now. Maybe a little heavy for API. 
Following back up on this: thank you for the thoughtful feedback. I've wound up rewriting it to use the native go tools.
What if i implent grpc servers with goroutine? grpc servers uses http2. or what about using tcp, http servers together..??
What did you learn? Was implementing an actor model in a language with built-in messaging primitives easier?
How would you make it better?
Go is built based on CSP. Aren't Actor and CSP two theoretically different approaches? Why would you want Actor in Go?
Getting the first few bits up and running was easy, I could cheat by using channels as backing queues for the actor mailbox. Channels are a good fit for e.g. a "bounded mailbox" as channels are async when the influx message count is within the allowed bounds. But if you want an unbound mailbox behavior for your actors, you need concurrent queues w/o bounds. So in the end, implementing the framework itself didn't benefit much from the built in Go primitives. They are however awesome when testing your actors. I'm currently getting up to speed with Go, so something that I've noticed are: * I don't miss generics _that_ much.. there are some pain points, but in general, its not that bad. In some cases I even think that the lack of generics make the code cleaner as its very easy to fall into the trap of resorting to "generics porn" just because its possible to solve some tasks with complex generic contructs. * I don't miss inheritance at all so far. * and VsCode is a darn awesome Go editor :-D
First of all, nice approach to the problem. I tried to solve it too, in a way though that's not worth posting here ;) But are you aware that you can put comments at the end of lines? 127.0.0.1 localhost foobar # comment I think that would greatly simplify the parsing and the readability of the hosts file. Also, could you provide binaries? **UPDATE** Nevermind, I implemented it in Python (may still need a little fine tuning and error handling): #!/usr/bin/env python from sys import argv def main(project): with open("/tmp/hosts") as hosts_file: old = hosts_file.readlines() with open("/tmp/hosts", "w") as hosts_file: lines = [] for line in old: original_line = line line = line.strip() if not line: lines.append(original_line) elif "#TOGGLE" not in line: lines.append(original_line) elif project not in line.split("#TOGGLE")[1]: lines.append(original_line) else: if line.startswith("#"): lines.append(original_line.lstrip("# ")) else: lines.append("#" + original_line.lstrip("# ")) hosts_file.writelines(lines) if __name__ == "__main__": try: main(argv[1]) except IOError as e: print e 
Do you mean to machine code/native executable?
This might be useful for instrumenting (measure time, logging, etc) your sql statements. Imagine it as middlewares for sql
Yes, after reading the description, I thought, "oh, THAT kind of realtime." I guess I'll have to keep on writing my cruise missile's guidance in C.
I would love it, Scala as a language is great. I just can't deal with the community of functional programmers that make you think you have to write _everything_ in a functional style, otherwise you're doing it wrong.
&gt; I don't miss generics that much.. there are some pain points, but in general, its not that bad. In some cases I even think that the lack of generics make the code cleaner as its very easy to fall into the trap of resorting to "generics porn" just because its possible to solve some tasks with complex generic contructs. Same here. There are a few spots in my codebase where it would be nice, but those spots are the minority so far. A few times I found myself going down the over-abstraction path and after hitting the wall a few times, I'd say "what am I really doing here?" and just write out straightforward code that does what is needed and move on. I believe that has forced me to simplify a few things and keep my code direct and to the point. This system is a second system and would have the second system effect regardless of the language it was built in, but it's definitely simpler and works better than the C# generics soup that was the previous version. I do not regret choosing to rewrite it in Go. &gt; I don't miss inheritance at all so far. I've been doing this for over 20 years and I stopped using inheritance many years ago (long before I adopted Go). Now don't get me wrong, I think interfaces and interface inheritance is great, but class inheritance? I cannot think of a *single* instance in my entire career where I used inheritance and didn't come to regret it. Every single time I refactored an inheritance model to a composition and interface based model, it was absolutely better. Class based inheritance is the devil. 
It depends. In Google interviews, you usually could choose the language (or they asked you before the interview how you'd rate yourself in various languages and then choose one that you rate yourself highly in). I once made the mistake of trying to solve a whiteboard coding interview problem in C, when the problem was mainly about parsing strings and managing a stack. So by choosing such a low-level language, I actually made the problem much harder for myself. The same could happen to you with Go for certain problem classes. Luckily, I was allowed to switch to Python in the middle of the interview, which made things much easier for this problem.
Normally, in my experiences, you'll be directed to use a specific language or given the option to use "any language you're most comfortable with." So, I'm going to hazard that your answer will most likely be no unless the latter situation happens. Speaking from the perspective of an interviewer, I told a candidate to a project in X language (99% chance it relates to what we're hiring them for) and they rebuttal with "Can I use language Y instead?" I would already be skeptical of whether I'll see a desirable outcome. Interviews are a two way sales process, you're selling yourself to the company and they're selling themselves to you. You look a lot better in that process if you're willing to follow the instructions you're given without changing anything. This is all just my opinion though, both as someone who's been an interviewee and interviewer. I once asked a candidate to write a regular expression for me, they told me they could only do if they could use a tool like one of the many online live regex testing tools (and usually have a reference) which I was fine permitting. I use tools in my daily work, if that's what they need, then let's see how they do. After a few minutes the candidate instead just Google'd for a far more complex regular expression to submit for the interview. That was my limit there.
The Gorilla tools are pretty handy, but you won't need or want anything more than that, based on my experience.
Give the guy a break, this looks like a typo due to translation. He actually made a proper README, which more than a lot can say....
&gt; Or does your company require experience in specific language(s) to get hired? Isn't that that the case in most cases? Why hire some Golang guy if you have a Java/.Net-Stack in your company?
A bit of both :) Thanks for the clarification. Maybe it was with older versions of go that required stuff beyond just libc... Anyway... I guess now i have to find a best practice for doing split container builds. Right now i do something like this: FROM golang:alpine MAINTAINER Vasili Sviridov ADD https://github.com/lalyos/docker-upx/releases/download/v3.91/upx /bin/upx RUN chmod +x /bin/upx \ &amp;&amp; apk --update --no-cache add build-base git \ &amp;&amp; git clone https://github.com/kelseyhightower/confd.git $GOPATH/src/github.com/kelseyhightower/confd \ &amp;&amp; cd $GOPATH/src/github.com/kelseyhightower/confd \ &amp;&amp; mkdir -p /artifacts \ &amp;&amp; go build -x --ldflags '-w -linkmode external -extldflags "-static"' -o /artifacts/confd . \ &amp;&amp; upx -9 -v /artifacts/confd WORKDIR /artifacts CMD ["tar", "-cf", "-", "."] This is a build container. When I run it it spits out tarred directory with the binary. And then on the runtime container it looks like this: FROM alpine:latest MAINTAINER Vasili Sviridov ADD artifacts.tar /usr/bin CMD ["sh"] I use it as a base container, so it's not running the tool directly.
thats a very nice idea. Thank you for sharing.
I interviewed at Facebook using Go on the whiteboard. The interviewer was not familiar with a few of the implementation specifics like maps so be prepared to explain some of the language and stdlib internals correctly. They also took photos to review later with other Go developers.
This is great, just installed delve a couple of days ago, and all that certificate signing was a little bit troublesome. specially vs installing on windows/linux where you just do go get delve.
[godoc specifies](https://golang.org/pkg/text/template/) that the parameter for `template`'s range function "...must be an array, slice, map, or channel." You might be able to "hack" it using pipelines dynamically wrapping your type, but then you're probably better off just writing an iterator that outputs on a channel to begin with.
Nice!
Thanks for clearing that up
https://play.golang.org/p/RsgemGUCBA
That's what I did? Since slices are pointers to underlying data structures, I thought that by doing what I did I would modify the underlying data 😅
Yes, that's what you did with s = append(s, "o"). And no: Slices are not pointers to the underlying array. Slices are value types like a struct with several fields and one field is a pointer to the underlying array. Modifying the underlying data happens when your write to a slice element: a := []int{1,2,3} b := a // copy of a but same underlying array b[1] = 9 // modify underlying array print(a[1] == 9) // true c := a[:1] // subslice, same underlying array print(len(a)) // 3 All you can do is modify the values stored _in_ the array, not the array itself. Note that append may produce a _new_ underlying array in which you lose all reference to the old array. Now read http://blog.golang.org/slices Re-read it at least once.
&gt; Is it because wg.Add() only adds the first 3 go func? So the wg.Wait will possibly cause the main thread to close first before the 4th go func executed? Not sure what the actual context is, but moving the wg.Done() parts to the 'consumer' goroutine fixes the case: https://play.golang.org/p/PvPtN_m9-5
Case by case. I've applied for a DevRel job at Google and I used Go in the whole process. 
They do... Source: Me 2 months go
&gt; Rails provides organizationial principles for your code Read: since we used Rails we have no clue how to organize things without it. Which leads to: Controllers! And MVC and all the fluffy bunny stuff that Rails (a framework) offers and Go (a programming language) doesn't. Excitement! 
typically you do a channel and iterate over that (probably what bufio.scanner is)
Yeah concurrent updates would be good if it's possible (we don't know what's the usecase). In this case the sql update is the slowest part, not the php code. 
In my use case, the depth-first search for a single website is the business case in my company where I work as a working student. Like "hey, can we check if our customers implemented us right in their website? You can program? Try to check that". So I need to limit my search on the given site (compares host for found links after fixing relative links to absolute links, checking for illegal characters "@, #" and file endings, some sites linked big .msi packets ...) while also limiting the connections per second to not DDos our customers. Was funny in the beginning without the limit. But I like the idea of worker nodes and a database integration, never used a DB before but it would allow access to my PhantomJS-Loader without logfile loading that distributes the found links into PhantomJS-webserver instances to check javascript on the pages. Also the edge graph stuff seems very interesting, but I don't quite understand how do you "you create a sort of mimic of an edge graph, which tries to graph out all the URLs on the web based on their importance" with a breadth-first search if you only get the top links? Or do you get the top links and their linking on the start page as well? 
It's all great but: * GO is not a scripting language, you will need to compile into an executable and run that on your server, which in any case is better than PHP * You will surely gain improvements as long as your database can handle it. I guess, at some point it will be your bottleneck * The answers to your other Qs are all *yes*, altho I do not understand the first one, but I think I answered it with my first point.
Cool! How does this compare to Cayley?
But that's the main reason vendoring exists, is so you don't have to change import paths, or have separate repo or branches for each version.. but to vendor(include) the code at the version that works. The above example doesn't really relate to @tdewolff as he is the maintainer of the libraries he wishes to vendor, but when you aren't... unless I'm completely missing the point of vendoring, but if that's not why then people would have been including dependencies withing their repo under whatever folder and adjusting their import paths to be local, and the official vendor implementation would never have been needed.
A simple ?: is neat and useful. But there is no (sensible) way to prevent ugly nesting: (foo() ? a() : b()) ? (bar() ? 7 : -1) : wuz() ? g() : 8 Which doesn't simply hurts readability, it kills it. 
"The" C-like ternary operator was not included because of readability issues, and it's pretty easy to abuse. I'm personally apathetic about it. I don't think it'll add a lot of value. BTW, Go does have ternary operators (not "the" conditional expression though). e.g. `s, ok := v.(string)`
I've only ever used it in moderation, so I didn't consider that people would nest ?: inside of ?: inside of... Yeah, that makes sense.
The only expression in this snippet is the type assertion, which has one operand. "n-ary operator" means "with n operands"
Possibly after v1.0 -- right now we're focusing on GraphQL.
I have been waiting a long time for that TimeoutHandler fix. I am glad that it has been added :)
Unfortunately sounds like you'll have to end up waiting for the crawl delay. This isn't something where you can use a bunch of proxy IPs to crawl the same site, as the DDoS possibility is real. PhantomJS, because it's a headless browser, will also take a lot longer to initialize and crawl websites with. For the edge graph stuff, the best would be to read the steps listed out in the Stack Overflow post. Basically you start with a seed list of URLs (I use the Alexa top 1 million domains), and give each of one a starting credit amount. As you crawl each URL, you pull all the links found on the page and redistribute the original page's credit among these links. Before distributing the credits though, you want take 10% of the original credit amount and give this to a Lambda page - a placeholder page which when 'crawled' (not a real page) will redistribute it's credits to ALL of the URLs in the database. This process continually repeats. Also thanks for the point on .msi files, I'm going to add that in as a check to my crawler.
I'm not sure how bufio.Scanner is implemented, but it would be nice to use its interface rather than wrapping it in a goroutine that dumps data into a channel. It's not a bad workaround, but it's not as straightforward as a simple for loop. Oh well.
Yeah, that's what I figured. Thanks for the info.
By your last statement, that snippet is indeed an example of a ternary operator in Go (albeit, not the one that most languages, and people have been accustomed to, "the" ?: one). It is an assignment operator (in the context of a type assertion) which has 3 operands. Go is filled with left-associative ternary operators.
We chose to licence our code under similar open source licences (GPL compatible) so it doesn't matter so much.
Correct; our dependencies are managed by our own tools. Git submodules handles cloning all the repositories.The *entire* GOPATH is our repository. So, clone the repository, cd into it, and then you can start working (after pulling submodules, of course). Our build server also checks out the repository (including submodules) and builds from that. If a dev has added a package to their local GOPATH, the CI will fail. You can have a separate audit script that checks the list of submodules on your internal git server.
You can use [*gb*](https://getgb.io/). Basic usage: $ mkdir -p myproject/src/helloworld $ cp main.go myproject/src/helloworld/ # Put the source there $ gb vendor fetch github.com/spf13/cobra # As an example of dependent library. $ gb build Note that you *have to* fetch *all* third-party libraries (the ones other than the built-in standard libraries) for a gb project. Not sure what's still missing for your requirements though. Edit: There is a manifest file (which is literally a JSON file) stored in the vendor/ directory under the project directory. It records both the `importpath` and the `repository` URL for each package independently. I suppose one can change the `repository` URL to map to elsewhere, but I have not tried it. Edit2: The manifest file is employed by `gb vendor restore`.
This is why I suggested you vendor your dependencies, so you don't have the URL business to worry about. The repo is mostly for reference, so you and your colleagues know which libs are safe to vendor into your projects. I think this should suffice for your use case? The big takeaway is to use vendoring, not `go get`.
You say that the difference is that cayley is on top of an existing database. But dgraph is also on top of a database, rockdb (why not boltdb ?).
Sorry, I must be missing something. Even if we use vendoring, it still fetches it (using govendor or a similar tool) from the main github URL, not from our internal repo. So there really seems to be no way to lock this down. Please correct me if I am missing something, my knowledge of Go vendoring is still limited at this time to basically using govendor.
'sqlhooks will intercept Query and Exec functions and instead run your hooks' Instead ? Or also ? 
I'm pretty sure you can vendor the dependencies under a "github.com" folder and then the import won't change.
OK, so I am looking at the vendor/vendor.json file and let's say for my gin library: { "checksumSHA1": "XxSDNaJf0LpjvMapDmmhNIlf+MQ=", "path": "github.com/gin-gonic/gin", "revision": "5caaac4c5c712a9e7a7de29e6c24ef46c753017f", "revisionTime": "2016-04-14T23:39:28Z" }, how would I vendor it to say "check it out from git.mycompany.com but put it under github.com"? 
Well, about 0.001% of commercial companies would agree to that...so not really an option.
Serious question: What do you think the **equivalent** size of a **statically** linked C program is? We all know the binaries are larger than ideal and the devs are aware of this and are putting effort into reducing it, but I can only think two cases where the binary size might be problem: storage size and transfer size. In both those cases I don't think it's *real* problem most cases because the binaries compress very well (just test it `gzip binary`) so the problem can be solved with transfer compression and filesystem compression.
YES! Q: I've forked a package and I haven't upstreamed the changes yet. What should I do? A: Assuming you've pushed your changes to a accessable repsoitory, run govendor fetch github.com/normal/pkg::github.com/myfork/pkg. This will fetch from "myfork" but place package in "normal". This will do very well. I think we can definitely live with this. All give gold to HectorJ above.
do you mean here? func (a *API) String() interface{} { return a.api } I wouldn't. I would `func (a *API) String() string` because that is typically what a `String()` method does. If you want to have an accessor for getting at `a.api`, you could have `func (a *API) URL() *url.URL`. If you find that you need something that is not specific (ie, you wont always return `*url.URL`, then use an interface. See http://go-book.appspot.com/interfaces.html for an example of that. Cheers!
i'm glad you answered this, it's a common misconception people have.. it's worth adding that slices are passed by value, not by reference, just like everything else in go.. this means the fields (len, cap, and pointer to the array) are all copied every time you pass it around. if someone wants to modify any of those fields they, as usual, need a pointer to them (*[]T), not a copy.
We have just have six EC2 (m3.large) instances behind a load balancer. Once container per instance. Some folks run multiple containers per instance hence the need to "manage" those containers. When we first deploy a new codebase we just spin up new instances (usually just 2) and point some traffic at it to see if it holds up. Then we increase instance count and redirect remaining traffic to it. Keeping it simple!
Note that whatever solution you chose, you won't be able to run `go get` anymore.
https://play.golang.org/p/VLxS2-z3NQ
&gt; Attackers might be trying to steal your information from www.tysonmaly.com (for example, passwords, messages, or credit cards). NET::ERR_CERT_COMMON_NAME_INVALID Then: &gt; The www.tysonmaly.com page isn’t working &gt; &gt;www.tysonmaly.com redirected you too many times.
I don't have https on my site, I think reddit might be trying to force https
Yeah, that's what I meant but my sleepy head thought byte code was the correct wording. Thanks for correcting me. 
sorry about the first link to this post, somehow https got stuck in there and it was causing redirect issues
You might also find https://github.com/pmezard/licenses useful
Aha, yes, that's it. And thanks for the tip, I didn't know about golanglibs either.
I'm pretty sure I've seen someone do this, and the C program is still (edit: significantly) smaller, though obviously the C program does grow because of static linking. But I think all the other points are valid. I don't really think binary size is a big deal at the moment and it is even getting better, as everyone here has acknowledged. But I think the deflection is a little counterproductive.
bmatsuo's understanding is correct. In addition, RocksDB is just a library which can store key-value pairs on disk. When you interact with RocksDB, you don't do out-of-process calls (network) -- it's not unlike reading from the disk / ram / ssd. OTOH, when you use a graph layer, which is what Cayley is -- the data distribution and how many calls would be required to run your query isn't in your control. And that affects query latency significantly. We chose not to use BoltDB, because it acquires a single global mutex lock over all reads and writes -- this would be bad for both latency and throughput.
Yes, interfaces are satisfied implicitly. You can have the compiler check the interface for you if you assign to a discard variable of the type you want: ``` var _ io.Writer = (*myWriter)(nil) ```
Not really, Akka and Akka.NET allow users to pass any message to any actor. Actors can change behavior over time and may or may not respond to a certain message type. Therefore both Akka and Akka.NET use `any` and `object` as the message signature for methods like `Tell` Even though both have good support for generics.
&gt; I'd much rather see a candidate express their ability solve difficult problems using tools their familiar with If those tools are not used in the company .... well, like I said, hiring a Go guy that has to learn Java/C# from scratch + all the required frameworks ... have fun wasting 4+ months for this one employee. Or take the one that knows the tech stack and can start right away.
Ah, so you're marking a thread as done after its message has been consumed by the final goroutine. That's a nice and simple solution for waiting until all child threads are done. 
How do you get the build artifacts out of the container? I found the tar trick, but if you run the container without redirection it just starts spitting out garbage to the terminal all day long :)
If the tests were complete... I'm confident the ternary operator was cut in favor of minimalism, not due to a belief or actual evidence that it increases bug rates...
For those of a certain age, Time-based One-Time Pad, not Top of The Pops.
Since you mentioned that you are new to Go and it seems that you are trying to write Go code the way you write Python code, I would suggest you to watch Rob Pike's excellent talk "Go proverbs" especially the parts: [interface{} says nothing](https://youtu.be/PAAkCSZUG1c?t=7m35s) and [Reflection is never clear](https://www.youtube.com/watch?v=PAAkCSZUG1c&amp;feature=youtu.be&amp;t=15m22s). 
Bingo. Amazing how many developers appear to be missing this point... "You won't need Redis" means you'll never be able to scale across multiple machines without using "stick" (i.e. stateful) load balancing, which pretty much defeats the purpose of using HTTP, a stateless protocol, in the first place.
The input to the program is completely out of my control. Think of it as any arbitrary JSON. It may contain `mylist` or may not. `mylist` could even be an integer or another map. What would be the ideal solution in this case?
&gt; Perhaps the slow point is the loading of each of the web pages as CPU load seems to remain relatively low throughout the operation This is *very likely* the issue. Go used properly can, effectively, fetch all of the URLs *in parallel*. This will use a fair, but likely manageable, amount of memory, spike the CPU usage, and very likely spike the CPU usage on the DB server as well. If the program and DB server run on the same server, you'll likely bake it out, but the job will get done quickly. And, if the load is too high, i.e. the front-end becomes sluggish and/or unreachable, you can make it fetch in smaller batches.
You can unmarshal JSON into concrete type structs: http://blog.golang.org/json-and-go - this can be done even with optional fields, just include named fields for the expected values, and the ones not present in the JSON will be skipped. Which is firmly preferable to do unless you have NO IDEA ahead of time what form your JSON data will take, in which case: * Your life will be full of pain since you are getting fed arbitrary data, and * Your code will end up looking pretty close to what you alread have.
The thing is that it is not actually JSON. My function receives `map[interface{}]interface{}` as input and I don't have control over it. I guess in this case, I'm pretty much stuck with what I have. Thanks for the help!
Structurally speaking, whoever is passing you map/interface/interface is doing the dirty deed. That is a worthless data type that should be killed off at the first unmarshal step in a program. However if you know anything about that data - I.E. "it will have either a list or a string in each tuple", then even though the caller was too lazy to do it, your code can structure the data; define your struct, marshal into it "manually", and use that data for your loop &amp; test.
That's not simply stating things. That's making fun of people in a jerk manner. The original post's author acknowledges this difference between `net/http` and Rails. He then goes on to state how having less done for you is actually an advantage. That makes the root comment not only unkind - it's also either a straw man or a misunderstanding. Alternatively, it could be a practical joke (based on the root comment author's username).
My previous implementation was using cgo calls with C doing the heavy lifting. Under some circumstances the cgo overhead was outweighing the benefits of using C. So I decided to move the C bits to pure go and see what the performance looked like. I wanted to keep the structure as close as possible to speed up the conversion. The AIO library is born mostly out of wanting a reason to better learn the syscall interface as implemented by golang, and the above. As far as performance goes, reads and writes that are small (&lt;32MB) are about the same as io/ioutil (ioutil is probably a little bit faster as my test did not account for the time taken to perform the Open in ioutil.WriteFile). However, on the hardware I have available as the chunks get larger the AIO library starts getting faster. I am showing about a 20-30% increase in speed vs using ioutil.WriteFile when I write 1GB+ chunks out to EXT4 or ZFS. Now, I fully accept that the use cases for writing 1GB chunks in one operation are probably between never and almost never, but there you go.
This seems like exactly the kind of thing that could fit well as a caddy directive. IIRC think mholt has even expressed interest in adding minification on the fly to caddy. EDIT: https://github.com/mholt/caddy/issues/622 yep, this specific minifier even!
It seems that you're saying you would rather wait 50x longer for your compiles in exchange for smaller binaries. This is a unique perspective in my experience. Can you please confirm my interpretation of your position? Can you also provide some background as to why binary size is important to you?
Exciting. Congrats. (Sorry, I haven't read the docs yet). Are there plans to support inference engines, probabalistic queries, and fulltext? 
I'm not sure why no one recommended this, makes me think I might be misunderstanding your question, but reflect.DeepEqual seems to do exactly what you want.: https://play.golang.org/p/oggz_D4-jQ
Vuls(Vuln scanner for Linux) v0.1.3 Released. Dockerfile, No password in config, Proxy support, Readme in French, Fixed some bugs.
Considering the dev machines aren't internet connected, they could probably hack around this by modifying host files or internal DNS to point the common repo hostnames to their internal git server. It's a horrible hack, but it would probably work.
Many thanks for this. Currently yes the DB and web server run on the same box - and its quite a small one too at that. I guess what I've learned from this is that at the minute, the current process is actually suitable for now. Perhaps GO is not necessary considering the CPU load isn't the issue. I could probably implement a rolling process (in GO - I don't like the idea of a PHP script running indefinitely) that will fetch a record every 30 seconds and have it run continuously, or something along those lines. Or perhaps batch run every 2 hours or so - mainly because at e.g. 30 second intervals, with 3000 records, it would take approx 25 hours for each one to be covered. 500 records every 3 hours would make sense at the moment, which could be increased to 1000 when needed. I'm completely bootstrapping this so I will likely wait until necessary to fire up another box - which will be used for this processing. I imagine I won't need to do that for some time though it seems. Sorry for rambling, just getting my thoughts out at the same time. Never had to deal with scalability issues before. Really appreciate all your help!
So you are basically saying that you are the one that chose to have map[interface{}]interface{} as a function input. This is bad practice regardless of the fact that "you are not sure about the JSON input". If you really want us to help give us examples of that JSON input in all it's forms. I am pretty sure there is a much better way to handle this.
+1 good stuff
Who maintains the golanglibs.com website. I don't see any contact information and notice it's not pulling the "correct" github repos. I can't find a way to contact anyone or look at source for the site. For example, searching for "sqlite" and selecting popular brings up "go-sqlite3 — [DEFUNCT] SQLite database driver for Go" (https://github.com/phf/go-sqlite3) rather than the expected mattn/go-sqlite3 active repo with nearly 1200 stars. Maybe not sorting the repos by stars when finding a name match? 
can't find it in package manager.
I really don't know about readability. For me, this... func (d *decoder) decodeHttps(s *tcpStream, t time.Time) { prefix := s.dstPort == 443 ? HttpsRequest : HttpsResponse if s.reported || !d.dumpTcpBlockStart(s, t, prefix) { return } s.reported = true fmt.Fprintf(d.out, "\n") } ..is much more readable than this: func (d *decoder) decodeHttps(s *tcpStream, t time.Time) { var prefix = HttpsRequest if s.dstPort == 443 { prefix = HttpsResponse } if s.reported || !d.dumpTcpBlockStart(s, t, prefix) { return } s.reported = true fmt.Fprintf(d.out, "\n") } or even this: func (d *decoder) decodeHttps(s *tcpStream, t time.Time) { var prefix string if s.dstPort == 443 { prefix = HttpsResponse } else { prefix = HttpRequest } if s.reported || !d.dumpTcpBlockStart(s, t, prefix) { return } s.reported = true fmt.Fprintf(d.out, "\n") } ...like, you just made me read 3-4 more lines and extra indentation level for something so simple. Why. Yes, it is extremely easy to abuse^^don't, ^^then? . So is goto, and it is present in golang in properly limited form. With that said, I have no idea how difficult is it to add to golang compiler - if it would add a lot of unnecessary clutter, then I'm all for omitting it.
You can also run something like `go run main.go` instead of building etc
I have submitted a request to the package manager mantainers, still pending, soon will be aviliable. :)
I thought ranging over a channel blocks?
I have to tend to agree with you. I was never asked to whiteboard any code in my interview and have never personally seen it on any interview board I have been on.
Yeah, it's using the actual SQLite C code. To be honest, I think that's better since the SQLite code is so mature and battle-tested you can feel comfortable putting your data into rqlite. You still end up with a single binary, statically linked as usual, which makes deployment really easy.
That was me, would love to see it happen.
This is nice. I compared to two other options, and this seems cleaner. Another project had words that just didn't make sense where yours reminds me more of the ease of the requests library in Python.
If you added support for customized cookies then your package would be perfect for my needs! Cool project.
I just noticed because blitz.io (a site to load test things, for when you are too lazy to do your own) failed to find a &lt;meta&gt; tag on my site, because they were looking for one inside &lt;head&gt; and I had no head-tag because of minification. I actually had to disable minification to do load testing there!
I don't think this looks any better than the standard library. 
`GetAsync` doesn't have any way of returning connection errors. 
Yeah. And the extra features aren't super compelling. What's the difference between requests.GetAsync and http.Get in a goroutine?
If it had methods for all the normal HTTP verbs, as well as support for custom/nonstandard ones, it would go a long way towards being more useful. The standard library is great for many things, but not when you need a simple python-requests-like REST client.
I'm not so much a fan of the Get() taking "args ...interface{}". It seems it would be easy to pass the wrong order or wrong type of args and not get compile time checks. Why not take an Options struct? 
False. I work at Google and let candidates use any language they'd like. They just have to be ready to explain the language if I don't know it.
The difference is `requests.GetAsync` is misdesigned so there's no way to limit the number of outgoing connections or receive an error back if the connection fails. /snark
My suggestion is to take a trust but verify approach. Using the built in parser package you could easily walk your repositories and verify imports against a white list. Having said that, I also encourage people to minimize dependencies. With Go I find very little need to use 3rd party packages often due to the completeness of the standard library. I'm not suggesting that you always reinvent the wheel, but I find myself thinking twice before pulling in 3rd party code.
Unfortunately it seems that recruiters there don't agree with your idealogy. Most of the engineers I talked to at Google raised their eyebrows when they found out I was required to interview in C, Java, C++, Python, or JavaScript. But the recruiter wouldn't budge and set me up with one of their front-end engineers instead.
Gosh. What a long article for something that has been described before. And no, containers aren't machine images. Blah.
Interesting, thanks for your reply. I hope you don't mind the pun on the question but had to do it :p Also, this could be in the description next time :p Do you have any benchmarks / comparison for how the code looks like between version? Thank could also be interesting to look at. Cheers 
How come the developers haven't shown any strong interest in including a minifier in the templating engine? My templates tend to look pretty bad when output because of the whitespace (solved by the whitespace consumption operator in 1.6). However, if a minifier were in the templating engine, then it could be done in a single pass. Currently you must render the template and then run it through a second pass minifier. I see there has been some [interest for a few years](https://github.com/golang/go/issues/3164), but just no solid plan to implement it. Surely this would be great for performance? 
Something like https://github.com/tsenart/vegeta will also handle coordinated omission http://highscalability.com/blog/2015/10/5/your-load-generator-is-probably-lying-to-you-take-the-red-pi.html
nice one! :)
This https://golang.org/ref/spec#Operators is the complete list of operators in Go. Neither of them has three or more operands. I will agree that not only expressions can have operands. And something that Mr.Pike says is true, is not true just because Mr.Pike says it. Of course, you're completely free to rely on authority, rather than logic. 
Really cool! I am assuming this was a self challenge because simply making the container is only half of the equation. However , props!
I'm relying on your original statement that `"n-ary operator" means "with n operands"`, and from my understanding, it fits the logic (FYI, the [tokenizer](https://github.com/golang/go/blob/master/src/go/token/token.go#L70) considers it an operator).. But yea, agree to disagree.
agreed i wrote a bash script to do just this; its a little inconvenient you have to save your go files as a diff extension (or foo_template.go) and use `//+build ignore`... then generate them. i had to learn awk and sed (from the 1970s!) to write it, it took a day but it worked really well. i had planned to share my script but my hd exploded. `ginny` was the best go generate tool ive used; it does 100% what you need
I think I appreciate this article for its ELI5 container content than its Go content, but the Go was nice too.
I know, when I ran my first timing test comparing anything to a native map I remember staring in disbelief for a while. It's a mean beast, and not just the hash function. The HashMap takes a hash-function as a parameter though, which makes that part comparable.
done ! :) https://github.com/alvarolm/GoGuru/issues/4
Looking forward to your feedback!
I thinl it's more of learning from mistakes thing. Language author got a lot of experience with language, found where he/they were wrong, made a package to deal with problem. Possibly to be included Go2
You can use "errors by behavior" just like the `net` package with `net.Error`: https://golang.org/pkg/net/#Error I commonly write a `pkg.Error` interface with methods that represent behaviors a user would want to inspect and a `Cause() error` method that returns the original (wrapped) error. Similar to Rust's error trait that came about post Rust 1.0. 
Haven't heard of go generate before, looks interesting - is it basically a way to include your own functions within the compiler, that you can call from your Go code? I'm not sure I fully understand it.
Pretty cool, thanks for the info.
Wishful thinking.
Ultimately personal opinion, but I think a lot of people would agree with the statement. 1. You as the programmer have to spend more time in the planning stages, so ideally more thought goes into your code. 2. In a statically typed language, more checks are performed by the compiler, resulting in more bugs found before they occur at runtime - better code. 3. Using static types saves on memory allocation. 4. No need to check for types by the compiler (or interpreter). I guess you could phrase it as 'writing better applications' if you want.
yeah we can do both, but why do you want to do a REST API inside a monolithic web application?
Oh, I didn't mean pervasively changing how errors are handled throughout the stdlib. I meant that the stuff from `github.com/pkg/errors` could be moved to `errors` at some point.
Even when you get all this fancy error-returning stuff together, multiple return values still ruin function chaining.
Oh I was just thinking to use them as a code for comments in the hosts file, so your program can make use of them something like this: # ## # 10.4.10.1 something # # # # 10.4.10.2 another ## # 10.4.20.2 something else and if "## #" { changeTo("# #") or something..
Are you a Java programmer by any chance? :)
Because why would anyone ever switch out golang? It's the best! /fanatic
Do you mean a GUI package for SDL or something like Qt/GTK? Qt, GTK and probably most other GUI frameworks have drawing surfaces for OpenGL you could look into, if that is what you need. You could probably find a way to hook SDL into one of them, but I would recommend looking at their drawing APIs to see if they have what you need instead.
It's legal in HTML*, just not XHTML
DEP stands for [Device Enrollment Program](http://www.apple.com/business/dep/) Basically it's an API that apple allows an organization to access. The API lets you sync devices which were purchased from Apple with a MDM(Mobile Device Management) server. # DEP The DEP process is built into the latest versions of OS X and iOS and the devices will check in to the service the first time it boots when it's taken out of the box. As a system administrator using DEP, I can configure any device purchased by my company before the user gets it and opens the box. # VPP VPP stands for Volume Purchase Program and allows companies(usually schools) to mass purchase apps from the iOS and Mac App stores and assign them to devices/associate them to their employees/students AppleIDs. It's another web API. Apple makes simulators that you can run locally for testing if you're developing against these services. These are written in Go. 
I think you have a valid point, perhaps you might have worded it a bit more lightly to avoid upsetting the Go fanatics in here.
I have used Java, but dislike how verbose and slow it is. And it has convinced me that a hierarchy of unchecked exceptions are the best way to handle errors. It forces you to handle errors or throw them to the caller in a fashion much like Go, with the threat that your program may die otherwise. Go's method of error handling is basically the failed experiment that is Java's checked exceptions, only it's even worse. Go's errors don't provide context by default (the stack trace), and the encouraged pattern of passing only interfaces and not the actual type of the error makes it frustrating when all the error does is give you a string. That we are basically encouraged to compare strings to find errors makes Go appear to hearken back to the dark days of typeless languages when everything was a string.
I mean QT/GTK. Making UI for map editor in OpenGL is an overkill I think. I'll take a look into those and see if they have the surface! What do you mean by "I would recommend taking a look at their drawing APIs"? Thanks!
Comparing the APIs, it seems that `github.com/pkg/errors` has a much smaller surface. There are several packages dealing with this stuff around, this one seems to be newer than most, supposedly refined and essentialized. The Temporary interface Dave mentions in the talk is not part of the package. That part is about how asserting an interface type is more flexible than asserting a concrete one.
I meant that Qt/GTK and others provide their own simple interfaces for drawing images and various shapes on their drawing surfaces, you could probably use those instead of SDL.
Nice ! I made good use of sync.Pool in one of our service, it helped quite a bit.
Sorry if this is a dumb question, but is Go good for this? I thought Go was mainly used in the webserver realm, would Golang be good for a large text adventure project?
Go is good for almost any project from OS level applications, Web and anything in between... I would not use it to do native GUI apps at the moment because support is not that great in that area (some may have differing opinions). But you can use go in almost every situation where you would have used python or java in the past. 
Thanks for the response! I'm currently working on a text game in C++ and having to constantly manage memory is getting to be a burden, so I'm looking to do a rewrite of it soon, before the codebase gets too big. Go has been on my radar for a long time, and statically linked binaries sound really nice right now because I'm tired of wrestling with CMake.
You may want to have a look at things done by dgryski https://github.com/dgryski/trifles
But why do you use Go then? Java is way more popular and according to you it is the way better tool and should be used by everybody.
Perhaps the issue is there's only two "permissions" for identifiers, viz. on the one hand, names (i.e. the 25 keywords) that can't be used for standalone identifiers, method names, or struct fields, and on the other hand, names (i.e. everything but the keywords) which can name anything. So "len" can name a struct field, which is useful, but can also name a function, which causes confusion with its use as a special identifier. "map" can't be used as a standalone identifier name, which would cause confusion with its use as a keyword, but it can't be used as a struct field either, which would be useful. So perhaps more than just those two "permissions" would be useful to prevent true being false, or: package main import "fmt" func len(ss []string)int{ return 2 } func main() { a:= []string{"abc", "def", "ghij"} fmt.Println(len(a)) //returns 2 } 
It seems it does: https://github.com/golang/net/blob/master/html/parse.go#L678 p.parseImpliedToken(StartTagToken, a.Body, a.Body.String()) https://github.com/golang/net/blob/master/html/parse.go#L1956 // parseImpliedToken parses a token as though it had appeared in the parser's // input.
`trifles` is just my playground. All my interesting repositories are at the top level. 
I am describing Java's unchecked exceptions. You are free to ignore the error if you wish, but the threat is that your program may die otherwise.
I never realized Java had two distinct types of exceptions, so I've learn something today. C# has only one type of exception an it is always unchecked and not runtime. **Java Checked Exceptions** *Anything that is a subclass of Exception except for RuntimeException and its subclasses is a checked exception. The Java compiler forces you to either catch checked exceptions or declare them in the method signature.* But after reading [this page](https://docs.oracle.com/javase/tutorial/essential/exceptions/runtime.html) it also sounds like a bad design decision. 
Nice. Please add what databases are available. 
This made me have a gigglefit. I feel like this is something i could plaster on any of my work before it gets too big. "/u/cawdrizzle this code doesn't have any unit tests!" "Bro check the disclaimer. "
Although I like the approach, when it comes to error handling I would rather rely on the standard library. Don't you think that something as fundamental as error handling should be part of standard library? I understand there might be different needs for different use cases, but this package seems to be for general purposes. I like the way errors are handled in Go, but I don't like the fact there is no web page on golang.org dedicated solely to error handling as some Go users, beginners especially, tend to have problems with it. I think there certainly are different approaches for libraries and different approaches for applications. In applications it is often about finding the cause when reading the log which is extremely difficult when using only if err != nil { return err } *Errors are values* is a nice proverb, but a razor is just some steel and wood too. It nevertheless doesn't mean everyone knows how to handle it.
Looks pretty cool! Nice UI, btw. 'Gonna check out the code in more detail when I get back from work.
Huh, I've literally started doing same thing week ago (but in pure go) in my [go-nagios](https://github.com/efigence/go-nagios) project
So that everything passes from the REST API even the UI. Dogfooding basically.
&gt;I have used Java, but dislike how verbose and slow it is. And it has convinced me that a hierarchy of unchecked exceptions are the best way to handle errors. It forces you to handle errors or throw them to the caller in a fashion much like Go, with the threat that your program may die otherwise. The problem with Java's unchecked exceptions is that [it _doesn't_ force you to handle them, or even visibly ignore them in the code](https://docs.oracle.com/javase/tutorial/essential/exceptions/runtime.html). If you want to be able to ignore errors with the threat that your program may die with a stack trace Java style, just sprinkle if err != nil { panic(err) } through your Go code. Stack traces seem great with small programs, but once you're debugging a web application you regularly get [hundreds of lines of garbage](https://dzone.com/articles/filtering-stack-trace-hell) which you have to sift through to find the 1 line of useful information. But if you really want stack traces all the time, [it's a 1-liner to produce them](https://golang.org/pkg/runtime/debug/#PrintStack) at any point, or you can [use a wrapper](http://blog.bugsnag.com/go-errors) to add them to your `error` values.
From the `sync/atomic` BUGS section: On both ARM and x86-32, it is the caller's responsibility to arrange for 64-bit alignment of 64-bit words accessed atomically. The first word in a global variable or in an allocated struct or slice can be relied upon to be 64-bit aligned.
Nice! Good to know there are more developers putting Go tooling for Nagios. There are more projects to come on this subject, but in due time. :-)
I also really like xlog: https://github.com/rs/xlog
It's quiet frigging awesome!
True. I'm still pretty new to Go, so I'm still figuring out the differences.
I'm not sure exactly which you mean. I'm going to asume, this one: 'Working with APIs with PHP is a pain in the ass.' From somebody who has about 15 years of PHP behind me, I can honestly say that it *is* a pain in the ass. Because of many of the following reasons: 1. Unpredictable and high memory usage, 2. Fixed size of FastCGI pools, 3. Not event driven, not multi-threaded, 4. Not strongly typed - I even wrote a static analysis code sniff for very common problems (using undeclared vars, typos, itd.) 5. Did I mention it's not event driven? It's by far the biggest issue, as waiting for IO just blocks a worker. If you're coupled to a 3rd party API, it's almost impossible to design it to be fault tolerant without adding additional SW to the mix (nginx/haproxy,...). 6. Not even close to 12Factor (yet?) It may be an unpopular opinon, but for all the benefits PHP has, it also has real pain points, of which I've collected my share. The best advice to writing high-volume/low-latency APIs is to stay away from PHP as far as you can. Case and point - we ended up using a pure nginx+lua+redis implementation of several API calls, to get around the requirements that PHP could not meet. Speed improvement is just ridiculous - we're literally in the 0-1ms range, while with PHP you'd be lucky to be in the 10-20ms. I've cut about 2 chapters of philosophizing about best practices and listing these and other experienced faults of PHP, just because we agree here: focus on the positive. I'm trying to show how Golang is a viable option which circumvents many PHP faults, and some of Nodes. That doesn't disqualify individual advantages of each of them.
Very interesting! Sounds great. Thanks.
Ty so much, it worked perfectly!
This isn't an answer to that question, but I've found I don't want those tools in a Docker image because they're immediately out of date, or if I'm volume mounting in a gopath from the host system, I have them already. I drop in a script that I can optionally run once after the container is running that'll install them. 
Incredible stuff. Thanks. 
&gt; Not very clear how to use it on a given binary though. This is because it's in the .gosymtab section of the Elf binary (other places for other binary formats..) so it's fairly easy to get access to. I shall definitely poke around in there!
because the local in the for loop is a copy of the object in your slice of slices. When you modify the copy it does not modify the object in your slice of slices edit: [here](https://play.golang.org/p/IkODYcAmie)
&gt; js.Global.Get("document").Call("write", "Say hello to GopherJS") What is static about it? All variables and methods are dynamic here thru method calls, and it is really no different than writing document.write in JS. 
Some spontaneous thoughts while I read the article: 1. Creepy. 2. Reminds me of Jeep Cherokee hacking story from last year. If adding remote API access to cars becomes mainstream in the car industry, then I think my next car should be a vintage car. 2. Why can't *I* have a Tesla Model S for my Go projects?!
On the other hand, it creates a need to manage distribution of compiled binaries for multiple os/arch/go version combinations. One problem for another.
ah! my suspicion was confirmed then, thanks!
For a standalone binary it's fine, especially when it doesn't matter if the thing succeeds or not. If it matters, you should inform the client somehow. And wrap additional logic around it for retries.
I found this package useful and the implementation to my project was very straightforward, why the down votes?
I'm not aware of any off the shelf solution but if I had to do it I'd use zookeeper and take inspiration from the Java curator framework for things like distributed locks.
C++ ensure calling the destructor when the instance of object goes out of the scope. But Go or some programming language that uses GC doesn't ensure the calling. Because GC will be run in the time when Go's scheduler want to do. So SetFinalizer may not match your expected. I suggest to use contract-programming that use interface WriteCloser that dgryski says. 
I had tracking protection enabled in Firefox and subscribe form did not work. I managed to subscribe by turning off protection
Do you know any example queue that supports delayed delivery?
pseudo code: create a new bytes buffer execute the template into the buffer dump the buffer where you need it But that still not going to get you the exact raw text of the template, i.e. I'm assuming you want the actual template code, and since all the Template struct is private and you're stuck to methods, there isn't much else I can think of -- there probably something with reflect and/or unsafe you could do but more trouble than benefit. The way standard templates work assumes you have control over the template code to start...so the easiest most go way I can think is just copy/paste. If you have thousands of templates its still sort of a data munging exercise you can write a script to read a file and output the data to another file. 
I will be giving this a try, also there's another source that does this http://golangweekly.com/ 
I am not sure if I understand your answer. Are you indicating that downloading a binary Go library from http://trustme.not is safe because it is Go? 
I've used go-bindata a few times, it does the job of embedding things well enough. I wish there was an official method in the language.
Yes, it runs the same command you mentioned, plus installs a couple of libraries I always end up wanting (like a pretty printer for debugging) and then does this: go get -v golang.org/x/tools/cmd/... This works for me, and I don't end up rebuilding the image that often. I remember now why I don't have this in the Dockerfile. 99% of the time I just volume mount my gopath into the container, which means the tools installed at image build wouldn't even be used.
It depends on the type of app and expected traffic but yeah that's fine, however one way I've accomplished this before is to setup a pool of go-routines that wait for work (requests in this case) and are sent the data via a channel that all the workers pull from. The goroutine pool can either be a fixed size or auto scaling based on how many requests are sitting in the queue pending processing. That way if you get an influx of web requests you aren't overloading the server with goroutines and you're able to set a cap on the number that are spawned, and adequately adjust the size automatically to handle the back log then scale it back down once the queue is lower for a certain period of time.
Sure. Amazon SQS
&gt; GPG-signing, as used on GitHub for signing commits and tags That's just a feature of the underlying VCS (git in this case) &gt; Or am I just another security zealot?! :) I don't think so, but it all seems out of scope to me. Those are all things provided by a dedicated distribution system/service and doesn't even need any support from the Go toolchain, so it seems like the obvious thing to do is to just use existing tools. 
Thanks, great feedback.
Good for Haskell Gurus. Go developers have better things to do than convincing Haskellers otherwise.
(a) is terrible enough as it is, but to enforce it on the programming language seems down-right Orwellian. You might want to read up on the the war on general purpose computing. 
So what alternative approach do you suggest?
Seems to me you got a lot of wrong notions. Generics are compile-time, not run-time mechanism, incurring no memory cost, faster than dynamic dispatch. They allow the compiler to do better type-checking (which it already does, unless you are using interface {}). Generics are more convenient both when writing and when reading code. We write our abstraction exactly once (and it needs to be understood exactly once), and then clearly ask for a concrete instantiation. Surely Array&lt;string&gt; or Queue&lt;Task&lt;int&gt;&gt; communicate intent better than MySpecialIntArray or MyQueueOfIntReturningTasks ... Or, if you really like writing concrete expansions of simple blueprints that much, perhaps you can seek employment as a compiler ;-)
Serious question – Who exactly are the Haskell gurus in that thread? 
Yeah you're the fucking man, dude. I think you're single handedly making people use vim because of how good the go integration is.
There's no need to start up a local server for running unit tests against `http.Handler`s in Go (even with gorilla/mux). Please take a look at this similar post that has been corrected to use `httptest.ResponseRecorder`: https://www.reddit.com/r/golang/comments/482z9s/testing_gorillas/
Not surprising considering how much free time a Haskell developer must have. 😂
Looks like it works on windows if you're compiling with gccgo Otherwise it looks like contributors are actively working on a fix. See https://github.com/golang/go/issues/11058
I don't think they were specifically "slamming" Go as a whole. Michael O. Church did appreciate certain points about what the language did (e.g., &gt; Go deserves credit for starting the "maybe we need a new systems language" conversation. which ties to what Jelvis said about the language not bringing anything new to the table in terms of programming language design. Church's opinion on Go is especially summed up in the last paragraph: &gt; The people who annoy me are the ones who misunderstand what the language is for. They generate a lot of hype about an intentionally bland language... However, was Go well-designed for the intended niche? In general, I'd say yes. Should that be read as something to the effect of "damning with faint praise?" I'm not sure, but they do attack *some* things about Go, but *not* all of it.
Simplicity should have been, theoretically, the main feature of functional programming. They are jealous to see that Go win on this part. When i discovered Python decades ago. I thought it's a toy. What can i play with this toy ? But it works also ! I had the same feeling with Go. What can I do with a language that I can learn in one week-end ? Nothing less than the websocket app that I was looking for since so long...
Thanks /u/farslan for awesome work! A little question: how do I use snippets with ultisnips + vim-go + deoplete + neovim? I can use them (by pressing Tab i.e.), but there is no autocompletion shown for them.
more github shovelware. companies should stop dumping crap into github until they have something meaningful to show off
Very cool! As a shameless plug, I've maintained a pretty extensive [email](https://github.com/jordan-wright/email) library for a while now that handles all this stuff for you.
go-bindata also works for me, from simple text files to third-party binaries 
&gt;companies should stop dumping crap into github until they have something meaningful to show off Why? How does it impact you?
Don't Haskell devs slam eveything that is not Haskell?
Tryout go-guerilla (https://github.com/flashmob/go-guerrilla)
I don't like this at all. I grew very fond of the idea that in order to have someone use a library in Go you had to give them the source. I understand that this is useful for people and will most likely not affect my use case at all, but I still don't like it.
I'm using pathogen. Can I update just by going to the vim-go bundle and running `git pull` or would that give me the development version?
It is probably worth noting that most of those answers are also from 2014.
Of course they are. They are gurus in the best language ever. Meanwhile, the lowly gophers are busy (re)building the Internet. Also, I wonder why the bower folks moved from nodejs to go for their server stuff, guess we'll never find out :( Oh and SpaceX using it for telemetry makes no sense, no wonder that they exploded so many rockets instead of landing them. 
I would rather see plugin support.
Oh that makes so much sense. Thank you for the explanation.
You can use github.com/albrow/jobs It only requires redis. It also lets you have delayed and reoccurring jobs. 
I actually referenced that exact article in a blog post a while back: https://npf.io/2014/10/why-everyone-hates-go/