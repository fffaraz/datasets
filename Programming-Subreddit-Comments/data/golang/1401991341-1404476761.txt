Forking means cloning the parent process into a child process and continue executing the same executable from the same point, and sharing memory, which would cause the runtime to also be shared, which is what causes issue. When calling cmd.Start, it starts a new child process *executing a different executable* which does not share any memory nor the Go runtime. I'm not entirely sure but I think it starts the new process under a subshell which inherites the same environment as a copy, but it's not shared.
What can you do with Juju? https://www.youtube.com/watch?v=9h5hgfnZcBQ
Sadly some really useful comments have been removed by the user. After his hint I now added pipelining too.
I think you're right. The readme was moved over from Launchpad more or less as-is, and on Launchpad it wasn't the primary source of information about the project. I think it needs some serious updating. Juju is a service orchestration tool. It lets you easily deploy, configure, relate, and scale up &amp; down services on the cloud provider of your choice (or on your own hardware) with a just a few commands in the command line or clicks in a web UI. So, for example, you could deploy a web service to 6 machines behind HA proxy and connect them all up to mysql and redis, then scale up and down the number of databases or web service machines on the fly: The commands to do that would look like this (and no, I'm not leaving anything out for brevity, this really is all you have to do): juju bootstrap -e amazon juju deploy my_service -n 6 juju deploy haproxy juju deploy mysql -n 3 juju deploy redis juju add-relation my_service mysql juju add-relation my_service haproxy juju add-relation my_service redis juju expose my_service // your service is now deployed to 6 machines on EC2, // connected to mysql replicated over 3 machines, // behind HA proxy, and connected to redis. You can then do things like scale up the database if you find it's becoming a bottleneck: juju add-unit mysql -n 3 or scale back the web servers if you find you've over-provisioned: juju remove-unit my_service/2 There's also a fancy web GUI, if that's how you roll: (demo site) https://jujucharms.com/sidebar/ And it does a whole lot more... you can deploy to containers, you can configure your services, set up individual networks for services. It really is an amazing tool, and I would say that even if I wasn't working on it :)
Thanks, looks pretty interesting!
Damn. If I ever got around to implementing a Julia compiler in Julia I was going to name it Juju but now the name is gone so I probably won't bother.
As an update, I profiled both the struct pointer return and the (int, error) return - with a few hundred thousand HTTP requests there was no discernible difference in memory usage. I did however only replicate the "bare minimum" (router, ServeHTTP methods, etc) to conduct this, but memory usage was about 24.6MB and the top20 results did not show any noticeable changes.
I do realize this is old (Sept. 2013) but according to [comments on Hacker News](https://news.ycombinator.com/item?id=7854532), a release of the project may be prepping for this or next week.
Nowhere does this tell me what juju is. Please fix.
Huh, this looks cool. Let's check the registration page. &gt;The window to submit a registration application will open at 4:00pm PDT on April 15th and stay open until 2:00pm PDT on April 18th, so you’ll have **plenty of time to apply**. :(
This is a quite good book going through how to build web applications... which includes different databases. * https://github.com/Unknwon/build-web-application-with-golang_EN
Huh. I wish they separated out their Google topics. I'd love to see these, but Google I/O is always slammed with people.
The 'reflectionless' word gave an obvious bone to bite at :) To state another point for using a straightforward declarative binding : if you embed a struct, you don't have to go back to the original definition to add extra tags to each field. e.g. : type BookingForm struct { Room model.HotelRoom //how would you bind fields from this struct using reflection ? From time.Time To time.Time } 
Here is a more comprehensive version [someutils](https://github.com/laher/someutils) . Am sure you can learn one or two this from that. 
Have a look at the [POSIX standard](http://pubs.opengroup.org/onlinepubs/9699919799/). It specifies how the core utils are supposed to work. If you want to do something great, try to implement your utilities in a way that they conform to this behavior. It's a bit tricky, even GNU doesn't get it right sometimes.
unrelated to that library, but somehow I got sucked into andlabs blog, he has a [great overview of the template package](http://andlabs.lostsig.com/blog/category/go)
I think that code looks terrible. It's absolutely overengineered (who the fuck needs more than one file to write a head?) and doesn't obey standards at all (for instance, head is supposed to print a little header before every file when multiple files are used).
To be more idiomatic I'd suggest put each utility in their own directory. Then instead of a makefile you can simply `go fmt ./...` `go clean ./...` and `go install ./...`
Appreciated.
Nice. We were looking at centralized logging recently and this is another option.
if you run linux and are not afraid of running go tip (until go1.3 is released) running the [wakeup](http://github.com/andlabs/wakeup) example ist just a matter of `go get github.com/andlabs/ui` and `go run main.go` from the wakeup example which then looks like [this](https://i.imgur.com/9NcETL8.png). 
I agree, I don't have time to search atm, but feel free if anyone wants to.
Found by /u/SteazGaming in a [neighbouring post](http://www.reddit.com/r/golang/comments/27gjk7/andlabsui_platformnative_gui_library_for_go/ci0nhjh).
Using GTK on linux, don't like it, I'm a Qt fan. XD
&gt; Go has native concurrency support, not parallelism Go has both.
Please post the code somewhere easier to access. Github, Pastebin etc. It's too difficult to view where it is.
This is pretty freaking awesome. Especially the part about adding functions to templates - had no idea you could do that
Here are gist listings of most pertinent code. ssozp5cpp.cpp https://gist.github.com/jzakiya/2410458be9c79b2f1c9a ssozp7cpp.cpp https://gist.github.com/jzakiya/8c9e960587c6c821fc3b ssozp7cppmp.cpp https://gist.github.com/jzakiya/0030d38ddebd1464665c 
_FUCK_ that looks sexy.
GNU coreutils has a very good test suite which could easily be adjusted to point to the go implementations. As the GNU coreutils maintainer I can attest that most effort goes into the tests as they define the interface and edge cases. The code itself is secondary and simple in comparison. The other awkward part of coreutils is the system differences, whether that's due to disparate platforms or avoiding particular bugs within a platform. GNU coreutils abstracts that away in a separate project called gnulib.
Oh wow! I didn't think I'd run into the 'real' coreutils maintainer! Thank you! I have been thinking about creating the tests for it and I was looking for a good way. As you said, the function of the utilities are more important than the actual code behind it.
You will see the blank identifier used in required, but "unused" imports like the following: import( "database/sql" _ "github.com/lib/pq" ) the pq package is a postgres database driver, but your code will not directly reference pq (you will communicate with pq through the sql package), so you must add the _ to avoid errors that you're importing something without using it. 
You'll also see it in cases like the one you gave, where you want to throw away one or more return values. Sometimes, you'll see code that uses this technique to throw away err (which is a terrible idea; don't do it :).
I would understand separating the functionality and command line interface into libraries and executables where the executable parses command line arguments and uses the library to actually do the work. That allows one to use the coreutils as libraries without launching a separate processes which is pretty nice. The code seems to try something like that but ends up having the executable as a uselessly dumb wrapper and all the cli logic is in the library too. (See [cat.go](https://github.com/laher/someutils/blob/master/some/cat.go) and [catmain.go](https://github.com/laher/someutils/blob/master/cmd/cat/catmain.go) for example)
There's also something similar with the plan9 utils: [goblin](https://github.com/jdparent/goblin)
I'd love to see an update after you make it more idiomatic and wire up these tests!
Looks really nice. Congrats 
I've wanted to write this myself for a while. I'd encourage you to approach this as if you were writing a library, writing nice APIs and then having a separate piece for each application which is only responsible for command-line parsing and picking the right library function and arguments. A nice cross-platform Go API for these tools would be huge (recursive copy is a simple example of something that's useful but not nicely packaged for you with the stdlib).
Have to agree with you. I've been coding clojure since it's beginning (for fun or very small tools for internal use only) and for me the key aspect of your post is: dependency. You can't start something useful in clojure without adding at lasts 4 or 5 deps. Worst : there are many many outdated libs in clojure. It seems like clojure developers produce libraries faster than bunnies. What could be good if properly maintained and evolved. Just count how many posts with ANN suffix you can find in clojure list. Well, I really like and enjoy clojure. But this too much open approach led to thousands of small non maintained libs and slow adoption. This made me think that stuff without a solid organization behind them (like Google, apache, spring, codehaus) are less long term reliable. But I can be deceived. Nice and true post. 
Great discussion. One of my favorites that isn't addressed here, though, is `io.Reader` and `io.Writer`. These make almost everything easily streamable and many things buffer-able. This is much higher level than what Dave discusses, but I think this is a huge win over other languages where you are constantly tempted to just, for instance, load entire files into a variable before writing to the network.
https://github.com/andlabs/ui
I prefer these. Many GNU and BSD utilities are anti-Unix in design. http://harmful.cat-v.org/cat-v/unix_prog_design.pdf
Go has concurrency _primitives_ and no parallelism primitives, but yes, one can write parallel code in Go that uses all cores.
If Go is fast, then why are interfaces nearly 3x slower than structs?
Because interfaces are how Go implements dynamic dispatch. The difference is the same as the difference between static and virtual dispatch in C++
&gt; Instead of adding and removing additional stack segments, if the stack of a goroutine is too small, a new, larger, stack will be allocated. Is the new stack allocated on the heap, like H()'s stack in the hot split example? Or is it allocated in free stack space?
&gt; I would understand separating the functionality and command line interface into libraries and executables where the executable parses command line arguments and uses the library to actually do the work. That allows one to use the coreutils as libraries without launching a separate processes which is pretty nice. That would be a pretty nice thing; I'm working on a similar thing but it's written in C. &gt; The code seems to try something like that but ends up having the executable as a uselessly dumb wrapper and all the cli logic is in the library too. (See cat.go and catmain.go for example) There's a reason I called the code "terrible"
Thanks!
Package syscall, see how os.Chmod or os.OpenFile is implementead for windows.
Seems good. Is it stable and ready for use?
Why Go doesn't allow making .dll or .a libraries? Do you know when is it going to be available? Or how else would you approach plugin architecture?
Also keep in mind that Go has at least two compilers available: Go and GCC. People in other subreddits seems to constantly forget this.
I have a noob question. Do you know if I use json.NewDecoder() in my http.HandleFunc() and I receive a huge json, if I can begin decoding before the transfer is complete to save time and memory?
cant wait for it to complete..much better if u can put some screenshot on ur github account..
i like every post mentioning golang become faster and faster :)
From the [implementation](http://golang.org/src/pkg/encoding/json/stream.go?s=540:577#L16), it looks like it will begin reading a value to look for a complete JSON value, and then once that's entirely in memory, it will unmarshal that. For reading and decoding a single JSON document from the network, I doubt you'd see a significant difference from reading and storing the value yourself, but the API still fits nicer with `net/http`, in my opinion. That said, the larger benefit of `json.Decoder` comes into play when you have a stream of *multiple* JSON documents. See [this example](http://play.golang.org/p/EVDrLso93d), and in that case you can easily consume one object at a time, saving memory, and thus time.
Yo.. thanks. So a good summary might be?: &amp; allows you to pass the address of the variable in question, which allows a function to then take the value of that address with *?
In C, yes. On Go, you don't have to do the * part.
Nice to see you! It would be great if the coreutils would conform better to POSIX. I would really love it if they would actually turn of all the GNU extensions and non-standard behaviors when POSIXLY_CORRECT is defined.
I thought you had to? Otherwise errors? http://play.golang.org/p/xxzcBLBH9I If you take away the *, you'd get: ``cannot use &amp;i (type *int) as type int``
GCC's Go compiler doesn't do escape analysis. It allocates much more on the heap which can really slow it down.
As always, a splendid talk.
You're right, I misspoke. When I was writing it I was thinking about using the . operator on it, and how it dereferences it for you on that case (in C, if you you don't want to dereference it first you have to use the -&gt; operator). I wasn't even thinking about stuff like assignment.
Couple of things: 1. Please comment your functions - your code (mostly the private functions, it seems) lack high level comments and require reading through to understand what's going on. 2. This package is pretty cool, and shows some good forethought, but i'm not convinced the utility it provides is worth crossing the line from 'write my own simple code' and 'use magical third party import' - especially given that this package does things I wouldn't be interested in (like, rendering error to html, custom parsers, limiting templates to .html, validation, and so on. These similar but not necessarily related things may be better as gists / code snippets. Just my 2c. =) Great work regardless.
 Am I right in saying that Haskell does this too? Edit: a word.
&gt;Am I write I don't know. Do you implement the ``io.Writer`` interface :) ? Jokes aside, I only know about Haskell using \_ in pattern matches when you don't care about the value, which is pretty similar to how Go uses it, except with assignments instead of patterns since Go doesn't have pattern matching.
1. It's probably performant enough, but you'll only know by benchmarking and profiling. (and make sure you are using a good load test tool; *ab* is not a good tool) 2. It seems fine to me. Are you having particular problems with it? 3. The right thing to do is execute into a bytes.Buffer, and deal with a template execution error cleanly (which may involve returning a 500 response). If you don't get an error, io.Copy(w, buf).
Thanks for the reply. * No concerns there. I use wrk &amp; boom and typically load test on a VM identical to my production VM. I haven't done any profiling as I'm attempting to figure out if there's another approach to compare it to (pprof results might show template.Execute as a hot spot, but that could be normal given the parsing and reflection it needs to do). * The biggest problem is the repetition - writing out 6-7 `{{ template }}` just feels a little clunky. However, I can deal with that if there's no request impact to the multiple includes and pipelines. Django's [template inheritance](https://docs.djangoproject.com/en/dev/topics/templates/#template-inheritance) example best sums up what I'd like to do with html/template: {{ extends "base_generic.html" }} {{ block title }}{{ $title }}{{ endblock }} {{ block head_scripts }}{{ template "checkout_scripts" }}{{ end }} {{ block sidebar }}{{ template "sidebar_type_2" }}{{ endblock }} {{ block content }} ... {{ endblock }} * I hadn't thought of this. What are the negatives of this approach: more garbage per request (equal to the size of the executed template)? Otherwise, being able to return a HTTP 500 without the writer issues I explained above is ideal. 
It has a lot better code generation, though. Also, some times optimizing for small code can give faster code. GCC is a lot better at optimizing for smaller executables. The executables produced by the Go compiler are huge. 
I don't like the merge() function as implemented in the example. It looks like I'd need to write a separate copy of this function for every stage of my pipeline.
Couple problems: &gt; you could define a method on any type in Go You can define methods on any type *declared in the same package*. This means you can only declare methods on types you've created. &gt; you could just define it as function, if you like In this example, it wouldn't make sense to define a `Drive` function. It makes more sense to define it on the Car type. That way your code reads like this: c := vehicles.NewCar() c.Drive() instead of this: c := vehicles.NewCar() Drive(&amp;c) Also this change doesn't make it a "package wide function". You're simply turning a method (which is a function with a receiver) into a function (with a parameter). Also, your `Stringer` suggestion is actually much worse. You suggest the following: func (s Stringer) String() string { return Car(s).Brand } What happens if `s` isn't a `Car`? You're casting it to a Car, and then relying on a Brand property. Sticking with the suggested method (defining a String method on a type) would be a much better option. The example you gave where a user might not realize that `Car` satisfies the `Stringer` interface isn't exactly something you should worry about. It's possible, yes, but so contrived that I doubt anyone would write such a method.
I've been doing some more research on this and stumbled across [this SO answer](http://stackoverflow.com/a/11468132/556573), which will allow me to do the following: *templates.go* var tmpl map[string]*template.Template ... tmpl["index.html"].Must(template.ParseFiles("index.tmpl", sidebar_index.tmpl" "sidebar_base.tmpl", "listings_table.tmpl", "base.tmpl") tmpl["about.html"].Must(template.ParseFiles("about.tmpl", "sidebar_index.tmpl" "sidebar_base.tmpl", "about.tmpl", "base.tmpl") tmpl["create.html"].Must(template.ParseFiles("create_listing.tmpl", "sidebar_faq.tmpl" "sidebar_base.tmpl", "create.tmpl", "base.tmpl") // etc, etc... *base.html* &lt;html&gt; &lt;head&gt; {{ template "title" .}} &lt;/head&gt; &lt;body&gt; {{ template "pre-scripts" . }} {{ template "sidebar" . }} {{ template "content" . }} &lt;footer&gt; ... &lt;/footer&gt; &lt;/body&gt; &lt;/html&gt; *index.tmpl* {{ define "title"}}&lt;title&gt;Index Page&lt;/title&gt;{{ end }} {{ define "pre-scripts}} {{ end }} // None on this page, but we can't set a default in our base template like Django can so we need to still define the block (even if its empty) {{ define "sidebar" }} {{ template "sidebar_index" }} {{ template "sidebar_base" }} {{ end }} {{ define "content" }} {{ template "listings_table" . }} {{ end }} Upsides of this approach to my current one: * Far more modular (this really counts as two upsides) * Can "redefine" title, sidebar, etc. as each `*template.Template*` only contains one instance of each `{{ template "name" }}` Downsides: * More code repetition (at least during `init()`) - we need to spell out the components of each "final" template (which script block, which sidebar blocks, which content block) for every template in our application. We only do this one, but it's clunky and still prone to human error. Could possibly mitigate by defining map[string][]string and then ranging over it to call `template.Must(template.ParseFiles(v...))` but haven't tested that yet. * Not clear whether there are net speed or memory improvements - I would hope that having to pass smaller compiled templates rather than a whole `ParseGlob(dir)` would be better on a per-request basis. 
``secondary`` (which, by the way, should be ``secondarypkg`` according to your ``main``) doesn't know about the ``Placeholder`` type. Why not just move ``Placeholder`` type definition to ``secondary``?
Look into interfaces. Usually you would define an interface in secondary and your foo function would accept that interface. Then in main you just have to make Placeholder implement the interface, and you can pass it to secondary.foo. If you want to accept any struct then you should look into the reflect package, but that doesn't seem to be what you're after.
I agree with your comment, but the cast in his String method is completely safe. s is a Car because of the type Stringer Car Statement just before. This is not the fmt.Stringer interface.
Interesting, thanks :)
If PlaceHolder is a type that secondary, and other parts of the system need to know about then it should go in it's own package, or an existing package. For instance Ainar-G suggested moving it into secondary which would work just fine. Then you reference it in main as secondary.Placeholder. Likewise, you could put it in it's own package, then import it into main and secondary. Finally, as Logiaptorr suggests you can either 1) use reflection, or 2) use interfaces. The former, you'd consider if Foo will need different behavior for a few special types known before hand, the later if it will need to deal with any type in specific, but "generic" way. From the snippet you show, I assume you just need to make Placeholder known to your system, and should either move it to secondary or put it in it's own package.
So on what port does the javascript client make a request ? 3000 ? ws://somesite.com:3000 ? 
I think Go is meant for simplicity. You trying to include block of html code of course break that rule. Think of it as a "if something is difficult to make, probably i am doing it wrong".
I believe they share the open file descriptors for instance. 
I was referring to the example on the readme page
You make to `ws://somesite.com` however you'll get proxied to `ws://example.com` (Because in example it's running on port 80). Let me change it to make it more clear.
Thanks, term "Reverse Proxy" confused me. Usually reverse proxies are run on port 80 to handle end user clients and the backends go to various other ports.
This package is exactly doing it. However it's an http.Handler primitive. You need to plug (add it to a muxer) in your serves before you can make use of. If you wish to have multiple backends that still possible, you just need to make your own logic with the WebSocketProxy struct which has the `Backend()` function. This package is intended to be used in other applications. Here is a server which uses this package: https://github.com/koding/kite/blob/master/reverseproxy/reverseproxy.go
Thanks for your feedback. I updated the post to address some of your concerns (clarifications). The Stringer suggestion is not worse, because it is type safe and raises an complier error if you pass the wrong type (Stringer is a type defined "on top of" Car). It is just more explicit which is a nice option to have in your tool belt, IMHO.
I store named templates in a template file so I can dynamically change them without recompiling the code. Then, in the code, I can reference the templates contained within the template file(s) by name. I'm able to do ~50k requests per second with templating enabled, so the performance is above the OS's apparent per-listening-socket speed. Next, I'll be profiling my code with many socket listeners to improve performance.
I, too, desired to have Django-style template inheritance, so I added it. The Go dudes didnt want any part of it -- possibly with good reason -- so it exists as a separate project on bitbucket: https://bitbucket.org/adamcrossland/mtemplate/wiki/Home
To answer your question #3, I read somewhere last night (and refactored a bunch of my code) to have template.ExecuteTemplate on a bytes.Buffer. If there's no error, then I have buffer.WriteTo(w), but if there is an error no "gibberish" is written.
They didn't give an explanation for why they didn't want it?
Writing into a bytes.Buffer first is going to generate a trivial amount of garbage, probably ~1 allocation per request. That's going to disappear in the noise.
It's all in the error: # secondary ../Go/src/secondary/secondary.go:4: undefined: Placeholder In the secondary package, Placeholder is undefined. It is defined in the main package, and it is not imported into the secondary package, so Placeholder is out of secondary's scope. You should put Placeholder into secondary, and then import that into main. A couple more simple debugs and otherwise your code will run.
Thanks for the clarification—although some (high-level) benchmarking &amp; profiling shows a different result: * Writing direct to the http.ResponseWriter: 30.7k req/s (avg) 33 ms/req (avg) * Writing to a &amp;buf and then buf.Write(w): 21.2k req/s (avg) 47 ms/req (avg) The code is as below. Swap `&amp;buf` for `w` and move the header write above ExecuteTemplate for the direct approach: func renderTemplate(w http.ResponseWriter, name string, data map[string]interface{}) error { var buf bytes.Buffer err := tmpl[name].ExecuteTemplate(&amp;buf, "base", data) if err != nil { return err } w.Header().Set("Content-Type", "text/html; charset=utf-8") buf.WriteTo(w) return nil } The profiling results—it seems the handler spends a lot more time re-sizing the bytes.Buffer via makeSlice (?), which explains the latency increase and the throughput decrease. (pprof) top10 // writing straight to the writer Total: 14.4 MB 4.0 27.7% 27.7% 4.0 27.7% bufio.NewReaderSize 4.0 27.7% 55.4% 4.0 27.7% net/http.newBufioWriterSize 2.6 17.8% 73.2% 2.6 17.8% newdefer 0.5 3.8% 77.0% 0.5 3.8% runtime.malg ... (pprof) top10 // writing to a bytes.Buffer first Total: 14.3 MB 3.1 21.5% 21.5% 3.1 21.5% bytes.makeSlice 3.0 20.9% 42.4% 3.0 20.9% bufio.NewReaderSize 2.8 19.5% 61.9% 2.8 19.5% newdefer 2.8 19.4% 81.2% 2.8 19.4% net/http.newBufioWriterSize ... Is my analysis wrong here? Would creating a 10K (i.e. typical parsed template size) buffer from the start help, and if so—how?
with the coming go 1.3 and its [sync/pool](http://tip.golang.org/pkg/sync/#Pool) you could create a pool of buffers and reuse them to get better performance 
Are there any good Lua bindings / implementation for Go? If using some lua bindings I'm worried about the performance impact of using cgo.
/u/jwhardcastle — did you benchmark any of this? I'd be curious to see your implementation (i.e. in a Gist or on play.golang.org). My results in http://www.reddit.com/r/golang/comments/27ls5a/including_htmltemplate_snippets_is_there_a_better/ci2rk4b showed a fairly substantial drop in req/s when I wrote to a temporary buffer.
I didn't do any benchmarking or profiling (frankly, I'm a go newb and didn't have any idea how). Sorry.
Thanks—I ended up nutting that out. A 10k bytes.Buffer seems to have the lowest performance impact, but I may need to tweak that as I optimise for my (probably) 95th percentile in terms of page size. I end up losing ~6.2k req/s (27.6k -&gt; 21.4k) and gaining +9ms latency in exchange for the extra safety around template rendering. Not sure if that's worth the hit yet as I'm refactoring some code and need to see what the impact may be on a more complex, larger page. http.ResponseWriter directly Requests/sec: 27666.80 buf := bytes.NewBuffer(make([]byte, 0, 1000)) Requests/sec: 21420.36 
You clearly didn't read the post which addresses that in the first paragraph. 
I was able to do it just by calling the parser recursively, more or less. I haven't looked at html/template in a long time, and I'm sure that it has changed significantly in the mean time, but perhaps I should revisit it. Not that I have a chance to do something better than Rob Pike. I might be less busy than he is.
I don't understand. In Go, parallelism is a function of properly concurrent code + GOMAXPROCS &gt; 1. There aren't first-order primitives, but that doesn't mean there's no native support...
There was a long discussion about the whole subject -- not necessarily my just mtemplate thing -- on the golang Google group. It got kind of ugly, and I don't have any taste for that, so I bowed out. As I recall, the crux of the issue was that they were on the very cusp of releasing a major rearchitecting of html/template and it was too late add anything new. It also got bogged down in the whole "that's not the Go way" thing. Sometimes, it's more effective to just release your code and see if the world wants it or not.
That article hits the nail on the head on why I like Go so much: it forces better OO design. I still lets you do it badly, but now it's more natural to favor composition over inheritance.
This reminds me of much of the discussion I'd see 10+ years ago on whether or not C was an object-oriented language, and I think the article nails it on the head, even answering in much the same way (e.g. the use of structs). Object-oriented is a style of programming - whether or not a language lets me say `class Novel extends Book {}` or `Automobile.prototype.drive = function(){}`, you can still practice object oriented programming in the language. I've seen z80 assembly written with an object-oriented approach, and Java which is technically OO but in practice is essentially imperative. What I like about this article is that it starts with the question most people ask: "Is Go an Object Oriented language" and proceeds to answer the question people ought to ask: "How does one go about object-oriented programming in go?"
In a lot of ways, this is a back-to-basics approach, which we could've been doing with C for the longest time if there wasn't such a successful PR-blitz convincing people that we needed an "object oriented language" to practice object-oriented programming. To me, Go let's me keep composing my objects like I was doing with C all along, but the huge advantage that I can deploy without going down that rabbit-hole of library dependencies C applications inevitably run into.
I really liked the article (even upvoted it) but just had a comment not being approved because I pointed out that the article uses the word subtyping wrongly, where embedding would be the right term. Subtyping in Go is achieved by the use of interfaces (structural typing), not embedding. Embedding is about composition and delegation, a "has-a" and not "is-a" as the article describes. Apparently, the OP didn't agree and censored me, so sharing it here.
Yes, the README seems to do a poor job "selling" it somehow, like...where's a code snippet telling me how awesome this thing looks!
Go is not an Object Oriented language. It has objects in the language, but that doesn't make it Object Oriented any more than having first class functions doesn't make it a Functional language. Go is a Concurrency Oriented language. The baked in CSP is the unique and powerful abstraction that Go brings to the table that hasn't been done before in a main stream language.
You should learn from this guy: http://youtu.be/j4XT-l-_3y0
I've been looking for a pure Go snmpv3 implementation as well. For now I've settled with wrapping the snmpget/snmpwalk/snmptable commands from Net-SNMP with os/exec calls in Go. I've used the netsnmp lib to write a C and C++ application in the past. It has a pretty complete SNMP implementation, but I wouldn't consider it very developer friendly.
You might appreciate the approach I was recommended here - using a simple pool of bytes.Buffers is appreciably faster than using a fixed 10K buffer, and *faster than using no buffers at all*. http://stackoverflow.com/questions/24120466/writing-http-responses-to-a-temporary-bytes-buffer/24121613#24121613 Ends up being 26k (10K fixed) vs. 29k (no buffer) vs. 33k (pool) requests/second with a 64 buffer pool.
It's a dumb discussion because the definition of "object oriented language" is uselessly vague. You end up having to invent one for any such discussion which means that you can choose whatever definition suits your purpose.
FYI in case you aren't following this thread, /u/elithrar_ ended up [using your suggestion](http://www.reddit.com/r/golang/comments/27ls5a/including_htmltemplate_snippets_is_there_a_better/ci3emgu) in a roundabout way to solve the issue. :D
Maybe read articles before commenting shit on them?
It isn't really concurrency oriented either. While concurrency get it's own first class primitives, it certainly isn't programming oriented around concurrency. Plenty of apps are not concurrent, so I wouldn't call it that.
I did. It talked around the point coming to the conclusion it was an OO-ish in that it supported some subset of OO features. I wanted to point out that thinking of it along those lines was a mistake and that you should think of it as a CO language.
&gt; Instead of inheritance Go strictly follows the composition over inheritance principle. Go accomplishes this through both subtyping (is-a) and object composition (has-a) relationships between structs and interfaces. &gt; &gt; The mechanism Go uses to implement the principle of object composition is called embedded types. Go permits you to embed a struct within a struct giving them a has-a relationship. Isn't the article stating exactly what you are claiming it doesn't? Perhaps I'm misreading things, in all honesty it is getting a bit subtle for me. EDIT: Oh, you mean the way he explains how an anonymous field works later on? Yeah, I see that I think.
IMO Concurrency is its primary programming 'paradigm' and while you can write programs without using those features directly in your program they are in the libraries you utilize and impact how you code. Though I guess if you compare it to say Java where it is impossible to write a program without using OO then I guess not as much. Though I tend not to think of things in extremes, but more in what it the best/predominant thing a language has to offer.
The subtyping example is not true subtyping because it does not support polymoprhism. The code here will compile error http://play.golang.org/p/gD4Sd2XjFW You can make it compile by passing in doge.Animal http://play.golang.org/p/EtSY_3wGuW But run the code and it will call the Animal method not the Dog. This problem can be worked around using interfaces: http://play.golang.org/p/ZaeKQJTCaN And interfaces may be composed cleanly using anonymous fields http://play.golang.org/p/VECZNteHTY
Also typos. Typos everywhere, to the point of detracting from excellent content.
I took the "roundabout" approach as sync.Pool just provides the framework to implement a pool. In my case, the [bpool](http://godoc.org/github.com/oxtoacart/bpool) package saved me having to implement it myself :)
One tricky part is that the context needs to be passed through. For instance, if your template pulls in something that is just `{{.}}` then that part of the parsed template AST will need escaping depending on what references it. If that's dynamic then you need more information.
Go is object oriented in the sense that it has user definable types that are best described as objects in the most abstract sense. What it doesn't have is class types. The differerence is often contrived considering most object oriented languages are of the simala derived "class" - "inheritance" driven model, but Simula doesn't adequately define object oriented in its most trivial interpretation of the term. The fact is that Go has user defined types that enable users to exploit polymorphism and define methods upon them. They are objects; just a much simpler, more composition oriented implementation of objects. 
The article doesn't hit any target. The point that needed to be made was how Go favors composition over inheritance. Unfortunately, this article just skims that subject. It doesn't go into how inheritance chains are filthy. It only quotes other people saying so. I would have liked to see the points as to why inheritance is bad design. 
The short answer is that you end up having to fight the type system when you define new data and that many things would fit in multiple places in the inheritance tree or would not fit neatly an any place in the tree. Also, managing which behaviors get overridden gets messy, especially with multiple inheritance. Almost all the time you can't care about what attributes something has or what exactly something is as much as what it is capable of doing, and interfaces fill that role exactly.
An example like this feels like it really should be on tour.golang.org
&gt; Though I tend not to think of things in extremes Then by that logic Go is OO. OO means that you call methods on data containers. Go uses structs and embedding, other languages use classes and inheritance, while others (e.e JS) uses prototype chains. Go is OO in much the same way as JS is functional: the standard library uses it (for JS see Array methods) and it's a common paradigm. Languages can be multiple paradigm, so Go can be OO AND CO. Of the six basic paradigms, Go aligns most with imperative and OO.
I get it now. It's interesting and makes sense. Certainly challenging my sense of things :)
How does this compare to html/template with regards to html/template's security model?
Yeah, he explains it as subtyping and as a "is-a" relationship which I think is misleading. There were some confusion about that on the comments, which I replied but my comment got removed so I posted here.
Thanks for the response. From looking at the source, it doesn't seem that the basic Get has been implemented for SNMPv3. However, I should be able to base a GetV3 function on GetNextV3 - I think it's pretty much the same, just a different PDU.
The problem is is that routing is super cheap to begin with. As part of serving an actual request, it's a tiny, tiny, fractional amount of time spent routing - like under 10ms, even with a PHP framework. I know this because I spent the time making a route exporter for a PHP framework (which obviously routes much MUCH slower than any Go framework) to nginx, so it could do all of that matching in C. It ended up being not worth it at all - classic mistake of not benchmarking beforehand. It did shave off 5ms, but even when using a very stressful list of exported routes (e.g. 5000 routes of 4+ parameters and query params) it barely impacted overall load times at all. I don't mean to put down the experiment, but comparing routing performance seems to be all the rage today, to see who has the smallest ns/op, when I can pretty much promise it's not a worthwhile optimization (even if you're Facebook). 
&gt; like under 10ms Some of the systems I work on respond entirely in under 10ms (including meaningful CPU-intensive work, json serialization, etc.) The key takeaway (and first rule of optimization) is: Measure, measure measure, measure. While 5ms from routing was not meaningful in your application, there are those very high performance applications where 5ms savings would be huge. In fact, the # of allocations was also very important/useful to have for the results here as more allocations means more GC.
The pursuit of better performance is rarely a waste, even if it's just for the sake of learning. Shaving nanoseconds off of something used periodically? Meh. Shaving them off of something that's going to happen with EVERY request? For free? Sign me the hell up. Even better is when this comes on the form of a drop-in replacement. Or when additional features are brought to the table. Maybe finding changes that will find their way into the standard library where everyone can enjoy an even more performant system out of the box. Personally I'm interested to see how this affects embedded performance, or performance on devices like the raspberry pi.
Really really nice article. Go is so pragmatic when it comes to OO. Nice! 
That's the beautiful part about it, this isn't necessarily taking away from things with an objectively larger impact. These are contributions from people who *are* interested and just devoted their own time to creating these packages. I also have things I'd like to see more, but I can personally say that the latest restful app I've deployed was more enjoyable than the one before it due in no small part to httptreemux. And I don't have to worry about potential slowdowns at any point by using it, which is nice.
&gt; more allocations means more GC I don't think this is necessarily true. See [Dave's](http://dave.cheney.net/2014/06/07/five-things-that-make-go-fast) discussion on Escape Analysis.
Looks like a stab at providing some Erlang like process communication. 
Sure: I migrated the comments two weeks ago and removed martini and gorp in the meantime. You can find a [demo in my blog](http://blog.pascalj.com/article/comments-hosted-with-disgo/).
your implementation is far better for flexibility and usability. I say you just open a pull request and see what happens.
You don't need to look at it. But it's nice that someone does. By the time you or someone else got your rendering optimization sorted out, someone else will have optimized routing (or whatever else people are fiddling with), so that doesn't become a bottleneck.
If you're moving from C, Go will be an easier transition semantically. I think you'll find everything you need from a server perspective and then some.
Absolutely. There are libraries for websockets/socket.io/redis that are really available and easy to use. Plus go is (subjectively) easier to write concurrent code with, no callbacks to manage. I say give it a try, having a clearly defined goal for a first project should help tremendously.
Since you are doing bitcoin stuff, you may be interested in [this](https://github.com/conformal/btcd).
Bookmarked, looks like it's time to start using github for me.
If you posted this in /r/node or /r/nodejs you might get different answers. Anyways, for my recent projects, I have used PHP (just because of my experience) with Nginx for the actual website and NodeJS *only* to cover the WebSockets--one of its special areas where it dominates against the competition.
Even in node you're more concerned about message passing (socket.io) than directly sharing code. Not sure I've ever even seen it done that way. But yeah, using go on the server isn't an issue.
Anything C can do Go can do better* ;-P *Except stuff that requires embedded work with small memory or super high performance tuning.
The benchmarking tool is counting allocs *after* escape analysis has eliminated as many as it can.
Yes, like I said: measure, measure, measure, measure. 
I did not mean to disagree with your assertion that routing is an... interesting... candidate for perf tweaking as even the worst routers were at 0.2-0.3ms per route. I did want to emphasize: * 5ms is a very large amount of time in many modern systems * Measure, measure, measure, measure * GC There are many systems that do HTTP routing where 5ms matters. Perhaps not the ones you work on.
There are a few GPIO libraries like [this-one](https://github.com/davecheney/gpio) And when you're coming from C, you absolutely have to give Go a try, you'll love it once you grasp a few basic concepts. I also coded in C/C++ before, and the simplicity of Go is a relief.
I need to read a bit about Go, I didn't know there was already that many libraries. I've got some exam this month but I'll definitely try Go, thanks for the input. I hope I'll be able to finish the first part of my project haha.
Is there some reason that Voice is map? You are never storing more than one key/value pair in each map. That's a curious a probably wasteful approach storing the data.
Does this do what you want? http://play.golang.org/p/UKUMdOdnd-
Could do this: http://play.golang.org/p/vOCGpJHeAm For a large map that you doing a large number of random lookups, you'll want to index it by extracting the keys to a slice so that you can do random selection.
Yea, thats much cleaner. I keep forgetting structs can be used as data structures (the first Go book I read said they were 'classes', so that is how I think about them).
You need to read a different book!
As someone mostly working in Rails for my job; I could conceivably write every part of my app in Ruby; but I'd rather use a bunch of languages that were intended for the domain they're being used than one language being stretched past its comfortable domain. I've never seriously used Node, so I can't say whether JS is being stretched here. It's more of a philosophical response to the idea of it being easier to use one language instead of two.
Prefer structs over maps. You can still access by StructName.Var so it's easy to use as if they were collections of key-value pairs. And then hold your ExampleStruct in a slice of []ExampleStruct.
yeeeeeah I thought the same thing, but actually someone pm'd me to stay with node.js. I'll take a real decision after trying Go obviously
[goxc](https://github.com/laher/goxc) is also a great cross compiling tool which happens to include some handy packaging functionality for assets.
Numeric types in javascript suck for financial transactions.
With Permutation: http://play.golang.org/p/GwOWPQMAff
You'll need to have the user source them - (that is, `source &lt;file with env variables&gt;` or `. &lt;file with env variables&gt;`). For example, if you wanted to change `$GOPATH`, you'd need to have your program have a command for the user to run that (essentially) says "export GOPATH=...." by: `source &lt;program&gt; &lt;option&gt;`
Care to explain why prefer one for another? Newbie learning here... Feedback is really appreciated. 
Hmm, but doesn't that only set it within the Golang's context? It won't actually change it in the parent shell process?
That is correct.
&gt; takes the bytes from the mouths of little CPUs Brilliant!
The amount of already-available libraries also surprised me when I started with Go. For one of my first projects I had to scp some files to various machines, and I was amazed that a simple, clean library for SSH stuff was readily available written in pure Go, which made deploying the application fantastic, no external dependencies, no fiddling with executing ssh/scp commands, ... it just worked.
...perhaps it would be more useful to suggest alternatives it might support. (the obvious answer to your question is, because, like most people (not all, I know, but most) the author doesnt care about other code hosting platforms)
&gt; It would be even better to have: &gt; /image/cat.jpg/width/400/height/300 You want the URL to end in the extension to be recognized as the file type it is. 
Why not use standard URL notation? /image/cat.jpg?width=400&amp;height=300 Those are parameters, not identifiers, and the real URL actually ends with the expected extension.
Same goes for Go. Unless you use big.Rat which could be implemented in javascript as well. Never use float for money.
&gt; You want the URL to end in the extension to be recognized as the file type it is. This is what `Content-Type:` does. If you leave it off or specify something unhelpful, we have a [MIME sniffing standard](http://mimesniff.spec.whatwg.org/) which can detect [common image formats](http://mimesniff.spec.whatwg.org/#matching-an-image-type-pattern) based solely on the response body. The URL makes no difference to web browsers.
the issue with mime-sniffing is that it can be disabled by sending a no-sniff header. however, i would assume a responsible dev would include a content-type header or at least a proper file extension. which is something you can't always rely on.
To clarify and amplify the "can't do that", changing the user's environment would be considered a security vulnerability, particularly due to the ability to screw with their PATH, the exact thing you want to do. Not only is this not possible, it's really, _really_ not possible, like, the entire OS is fighting you tooth and nail. While you can change the environment and then start a new shell, this is pretty user-hostile; you're trading in a what may be a nifty short-term experience for a long-term experience of recurring pain. You break a lot of nice things that way. Don't go that way.
If you're going out of your way to send `X-Content-Type-Options: nosniff` without sending a proper `Content-Type:`, browsers should let you shoot yourself in the foot. Regardless, extensions don't matter: * "File extensions are not used to determine the supplied MIME type of a resource retrieved via HTTP because they are unreliable and easily spoofed." [MIME Sniffing standard, WhatWG](http://mimesniff.spec.whatwg.org/) * "Extensions must not be used for determining resource types for resources fetched over HTTP." [HTML 5 rules for determining content types](http://dev.w3.org/html5/cts/html5-type-sniffing.html) * "If and only if the media type is not given by a `Content-Type` field, the recipient MAY attempt to guess the media type via inspection of its content and/or the name extension(s) of the URI used to identify the resource." [RFC 2616 (HTTP/1.1)](http://www.w3.org/Protocols/rfc2616/rfc2616-sec7.html) Specify a `Content-Type` and you're done.
Love liteide 10/10 better for go than intellij or anything else. Debian user here
I have translated ssozp5cpp.cpp into go and the main hangup is creating runtime arrays. Example: In C++ I to create a global array at compile time that I want to size at runtime when I know how large it needs to be. In C++ I create a global pointer to the array: uint *primes; and then within the body of a function at runtime I determine its size: primes = new uint[max]; and then I can use 'primes' as a normal array and access its contents. In go I tried doing this globally: var primes *uint32 then within the function did this: primes = new([max]uint32) I understand in go you aren't supposed to (normally) use pointers, but it's not clear how you are supposed to declare an array at compile time that you size during run time. This is the main thing (so far) that is hanging up my translation from running. Otherwise, it "seems" I've got the rest done correctly.
I'm personally a fan of how sites like placekitten operate: /:width/:height/:asset It's succinct and easy.
...which is exactly the point I was making. The difference between Node and Go is that Go comes with big.Rat. And if it didn't, it still comes with int. Javascript ONLY has float64 numeric types.
Well done. I managed to give my IRC bot a snapchat account and have it rehost and post the snaps it receives to our IRC channel. This should be fun :)
I agree that query string parameters would be good for easily building URLs but as someone mentioned below caching could be an issue. I've looked it up and for example here (https://developers.google.com/speed/docs/best-practices/caching?hl=sv) it says 'Don't include a query string in the URL for static resources.' Could you expand on how encoding the parameters could make the server less vulnerable to DOS? Is it just that the rate at which the attacker would be able to request images would be lower because of having to do all this encoding/hashing (a potentially slow operation)? Thanks
&gt;The use case is we'd like to modify the user's PATH variable to control which version of a program is being run. (Alternatives would be messing around with symlinks or just mv-ing files around, however, the PATH seems like a lighter and less messy way of doing it). Symlinks are almost certainly the 'right' way of solving this problem.
I quite like this solution. It should be relatively simple to generate the URLs as you want this to be flexible and not much faff. But an application server could easily generate all these signatures and serve a HTML page with all these 'safe' URLs in it. Just for completeness, it is possible to specify named transformations and disable custom transformations (with parameters in a URL) in the configuration file which would mean that only URLs as /image/t_squarethumb/image.jpg are processed by the server.
True, but it *is* possible to implement an arbitrary precision decimal type in Javascript without using the Number primitive but JS is a stupid language anyway. 
&gt; in go you aren't supposed to (normally) use pointers Not true. Pointers are very useful for passing along structs that you don't want copied (but instead wish to pass by reference), and that sort of thing. Globals, on the other hand, are something to be avoided in any language. Usually in Go you work in arrays if you know the capacity, and slices if you don't know the capacity. [Effective Go](http://golang.org/doc/effective_go.html#arrays) is a great resource for learning idiomatic practices. As far as creating a slice of a known size, use [make](http://golang.org/doc/effective_go.html#allocation_make).
This is the correct solution, but beware that you'll need to do it differently if the security of your system depends on this being random. If security is at stake, and you need to ensure randomness in the face of an adversary, be sure to use crypto/rand after making sure your system has enough entropy.
Select the first one only. It is perfectly randon
This. Just as a side note, the Gentoo tool [eselect](http://git.overlays.gentoo.org/gitweb/?p=proj/eselect.git) is using symlinks for such problems heavily. (Yes I kow, that's not Go but just a bunch of shell scripts.)
Hah, do you have a link out there? Thats awesome! Honestly the reason I made this was so that people could play around and do some cool stuff with the api, so right on!
http://play.golang.org/p/8lk9U8EQoi Here, I commented the code pretty well to explain it. Hope this helps. I need to run, when I get home I will explain a good way to close a of goroutines at once. The trick is closing a quit channel.
http://play.golang.org/p/CeCTiNpXZc I made some comments. The points are line 9, put the value into channel; and line 24, read the value from channel and print out.
As /u/ManticoreX mentioned, a good way to do this is to have a quit channel like your example, but then close the channel to signal all goroutines to stop. A closed channel will send the empty value to any recievers (http://play.golang.org/p/SjvjhVl0gM). Here's an example of closing the channel to end many goroutines: http://play.golang.org/p/rIaTnFdEzz &gt; I thought that you have to put a value after the 'case' so it knows what case to run the next block of code in, but this is an expression All these are valid cases for select: case foo := &lt;-fooCh: case barCh &lt;- bar: case &lt;-bazCh: Only the first of them assigns a value to a variable. &gt; That aside, I can tell that this is sending channel 'c' the value of x, and that later on in line 23 it is printing the output of 'c' The sending and receiving are synchronized for unbuffered channels. It's easiest to think of them happening simultaneously. &gt; as far as I can tell, the fibonacci function hasn't even been run yet Most likely the goroutine printing the values will only start running once the fibonacci function hits the select statement and starts waiting on the channels, but it doesn't matter which one runs first. &gt; Does this go'd count thing block until fibonacci is run in line 27? c &lt;- x will block until something is attempting to receive on c &lt;-c will block until something is attempting to send on c In this case, the value is passed from across the c channel when one goroutine is on line 9 and the other is on line 23. Whichever one reaches there first will wait for the other one. 
Ok, here is an example I wrote that shows how you can quit the goroutines at once. The returnchan isn't needed. Is just used to prove that the goroutines ended. http://play.golang.org/p/njGDVi0qIZ As a heads up, a closed channel will always send the zero value of the type. I use a struct{} because it uses essentially zero RAM
That trick with the struct channel and the closing c looks really useful, but for now I'm trying to keep my 'quit' channel open because I plan on using it multiple times in one execution, for restarting functions.
Thanks for the feedback. I've updated the post to more accurately reflect this.
Can you tell me more about your setup. I've checked it against a bunch of different resolutions and screens. It looks normal to me everywhere I've seen it.
Accessing a value in a map is much more expensive. http://youtu.be/x05KubVlh_M
Aha, ok. A colleague and I are actually having a discussion about this very thing. I'm used to systems like Python's virtualenv and Ruby Bundler which do use symlinks. However, he mentioned a project called Environment Modules (http://modules.sourceforge.net/) which is apparently used more in the HPC space, and uses PATH manipulation. He suggested that the script can output code to change the path, which is then eval-ed by the shell - as in, when we ran the command, it would have a wrapper to run the script and output the new desired PATH, which the wrapper would then eval. Thoughts? I'm still leaning towards just using symlinks, but I'm also keen to hear him out.
To expand on the security issue: If you could change the users path, you could make it so that (e.g.)`sudo` ran a program you chose (which captured the password). 
AFAIK, creating a new channel is relatively cheap. I wouldn't go too far out of my way to keep one open. Whatever event kills your goroutines can always re-create your quit channel right after closing it so that it can be "reused" later. Something like this http://play.golang.org/p/0MEFfLPsx0 
One of my favorite talks from GopherCon 2014, because I learned lots from it. The small composeable reusable content is just awesome. That sequence generator for instance.. Totally simple and powerful.
Hah, yes, sorry. I think I actually signed the the entire path with the secret (this was about 10 years ago!)
Sounds reasonable enough, but I think I should show you what I'm going for. I can't run it in a Go playground because it takes user input, but I'm going to take my brother to school and then I'll pastebin it. EDIT: Here we are. http://pastebin.com/xHDvuvAs Clearly my wrapper function isn't working, so I may have to add that quit listener to every server function there. But I want to ping that quot channel once, and then have everything die. Then I can restart it or just break the entire function. Also, lines 24-28 seem wrong... Is there a faster way to do that?
Thanks for the link I've actually been looking for a good vim-go setup. Lately I've been using sublime which has been great but I still love vim for quick editing or when I'm not using X .
How does this compare to github.com/str1ngs/jflect ?
The idea is: retrieving an image that has already been processed is inexpensive because it's cached (hopefully), but if someone were to request a 100x100,101x101...6000x6000 sized images, it would create a lot of work on the server side. I think the protection is really just obfuscation. If someone sees a height and width in a URL it encourages 'tinkering' or abuse. As for throttling request rates, I think you're using throttled, which would accomplish this more simply. 
Or https://github.com/tmc/json-to-struct edit.. nm, my link is forked from OP's project.
Why not just support git? Is there something github is adding to the equation that this depends on that out-of-the-box git doesnt provide?
go*, bad name.
I personally don't like to use anonymous structs, but I use this tool as a starting point for a lot of JSON documents.
I'm the author of Bolt. It's being actively developed and maintained. We use it in production to serve data out of a half terabyte data file. The library is mostly feature frozen so the API is stable. Most of the focus right now is around optimization (and reliability when bugs are reported).
Works great, thanks! It would be nice to have an option to track idle time independently of the screensaver actually kicking in. In a toy project I used MsSinceUserInput from screensaver.QueryInfo() to get this.
Awesome! This should be a standard lib and tool for go in this or any solid implementation.
I just checked in the compute setting. It's 17px on my screen. reddit comes out at 13px, but Github is 15.2px. It may be a bit larger, but not much. I also find reddit personally a bit too small and not really optimized for design. Twitter ranges from 16px - 26px. Digg is 16px. A lot of the blogs I commonly read have 18 - 22px. So 17px may be a bit on the large side, but seems to be inline or close to it with many sites. At 50% it would be rendered at 8.5px which seems way too small to read. It could be a preference thing. I'll play with lowering it a bit.
Holy crap, I wrote the same lib yesterday :P I haven't had time to put it on Github though.
Woah. I started this when I saw [tkych/cl-spark](https://github.com/tkych/cl-spark) on HL. Did you see that too? Please message me when you push it up. It's a pretty simple implementation, so I'd love to see where our ideas diverge!
When the console sparklines stuff first hit, almost everybody was writing one. https://github.com/dgryski/dgospark (Just a tool, never made it a package.)
The first issue is that http.ListenAndServe doesn't return. It will block until the program ends or an error occurs, so your program is never getting to line 24 through 27. Also for it to be cleaner, you don't need to select statement at all (if it ever reached that point). You would instead just &gt;do &lt;- quit &gt;return I think you might be setting this up a little obtusely. What is the goal of the application?
I do think it is personal opinion. The design of the site is very good any way. It just seems that the size of font is just inconsistent. (I know it's a responsive site so the size will change depending on the view size). I'm sorry, I didn't want you to change your site for the sake of one user.
Hi everyone! For those with multiple GOPATHs and the vim-go plugin, I wrote the following vimscript function to automate GOPATH handling (based on the path to my Go projects) and it works pretty nicely: https://github.com/demizer/vim_runtime/blob/master/vimrc#L531 So if I keep my Go projects in ~/projects/go and edit a file in ~/projects/go/go-rst/src/github.com/demizer/go-rst/parse/lex.go then the AppendGopath() function will add "~/projects/go/go-rst" to the GOPATH so it looks like GOPATH=~/src/go-utilities:~/projects/go/go-rst I have a GOPATH for each project. It will simply replace the path at the end of $GOPATH with the GOPATH of the current file. If I open a file that is not in my Go projects directory, then the function above only sources my default GOPATH where I keep all of my go utilities. This function is mostly for editing in vim with vim-go to get the code utilities working. I do all of my "go get" management in the command line so nothing that I don't want gets installed into my go-utilities GOPATH.
It is quite "obtuse" at the moment, this is sort of a first draft. My end goal is pretty far away, but my first checkpoint is to get everything here working (that means starting, stopping, and restarting when I ask it to), and after that I know what's up with that "unimplemented BS" that's commented out at the bottom, and I can get it to work.
Well, OP did say they wanted to work with SQL and didn't specifically mention ORMs. Not everyone uses an ORM. 
Like Trevor said, http.ListenAndServe doesn't return. Once you go into it, there's no coming back out. You want to use [http.Serve](http://golang.org/pkg/net/http/#Serve) instead. You pass it an [http.Listener](http://golang.org/pkg/net/#Listener) which you can close later. If you make your listeners outside of your goroutines then your goroutines can just serve them up. When you close your listeners, their corresponding goroutines will stop blocking on the http.Serve function and close themselves automatically. No quit channel required. :-) Disclaimer: I haven't personally used http.Serve myself so I could be totally wrong, but I think that's how it works. Check out [this google groups thread](https://groups.google.com/forum/#!topic/golang-nuts/7ErVh1_b0kY) for more details.
Exactly haha! I sure will!
According to Andrew Gerrand multiple GOPATHs is actively discouraged. I was skeptical about having multiple projects in a single GOPATH but after using it that way for a little while I've had zero issues. I think sticking to the way the language devs intended it should be done whenever possible. https://groups.google.com/forum/m/#!topic/golang-nuts/dxOFYPpJEXo
because it's lazy and meaningless go is already Go go already has a json package For an alternative, json2struct is not *great*, but it is a lot more descriptive
Very descriptive. I like it.
No mention of gocode? https://github.com/nsf/gocode
See [this](http://blog.golang.org/go-slices-usage-and-internals) link for more info. Slices are more than just a reference to an underlying array. Whenever you append to a slice, there is a chance that the underlying array will change as it grows. This change will not be reflected in the original slice.
The reference to the underlying array is a value, and in Go, everything is passed by value (even pointers/references). So your function that receives a slice is receiving a copy of the slice header. The slice header contains important information like starting address and size. When you append to the slice in your other function, the copy of the slice header gets modified, but the original calling function doesn't see that copy, it still has its own. That's why functions like append return the new value, which is the modified slice header. Here's a great, in-depth post by Andrew Gerrand himself about Go slices: http://blog.golang.org/go-slices-usage-and-internals Also you can play with this here: http://play.golang.org/p/i4zpWK4COz
Not yet.
That's kind of how the reader interface works. In that case you pass a slice of bytes, say `[]byte{0,0,0,0}` and the read function will overwrite it with data and return a number of byes read.
As I use [gocode](https://github.com/nsf/gocode) - which has the ability to receive $GOPATH - I just use a tool that sets my $GOPATH based on the project I'm working on ([gvp](https://github.com/pote/gvp) for example). I typically have one vim session per project, rather than one master vim session.
When you pass a slice, the following informations are passed by reference: * the contents of the slice fields The following informations are passed by value: * whether the slice is nil * the length * the capacity If you try to enlarge the slice with append in your child function, you might change the length and capacity which the parent won't see. A slice looks like this in the implementation: type []byte struct { data *byte // pointer to the first element len int cap int } except that you cannot access any of these fields directly.
Emacs is very powerful for golang development. I configure it in my Scame project, like in your blog. I use also gotest.el [2] (i'm the author) to launch unit test in Emacs. [1] : https://github.com/nlamirault/scame [2] : https://github.com/nlamirault/gotest.el
https://www.youtube.com/watch?v=XEQziFzKSgA This video is from Pycon 2013, but it gives you a good idea of the differences between traditional OO (with specific comparisons to C/C++/Java) and how Go is structured. I watched it last night, and it was very helpful.
Go is classless, but it's still got OO concepts in it. Think of a type as your class. If it only contains one property, you can base it on the type of that property, otherwise use a struct to base your type upon. For the constructor, write a function that returns an initialized instance of that type. Then give it methods. If you want it related to some other type, find the functionality that is common between the two and make an interface out of that. There's no private or protected, so stuff you want hidden will have a lowercase-starting identifier which makes it "package-private" in Java terms. Capitalizing will make something public. Because of first-class functions and their properties of closure, many of the design patterns built in to common Java operations are unnecessary. You don't need a Runnable or a ClickHandler or any of those other oddities where it's basically a function wrapped by a class. The best thing to do is just clear your mind, unlearn what you have learned, and approach it without trying to find Java analogues. That way instead of trying to fit the square Java peg into the round Go hole, you'll learn the language using more natural idioms.
I uploaded my stuff to Github https://github.com/maurodec/bars
It depends a little on who you ask but Go is OO in every sense that matters. http://nathany.com/good/ &gt; Go is a thoroughly object-oriented language. It allows methods on any type we define, without any of the boxing/unboxing found in some other languages. &gt; &gt; Go does not use classes, but provides many of the same features: &gt; &gt; * message passing with methods &gt; * automatic message delegation via embedding &gt; * polymorphism via interfaces &gt; * namespacing via exports &gt; &gt; There is no inheritance in Go, so leave those is-a relationships at the door, and think about OO design in terms of composition.
Cool, I like the Braile option. I got an [issue](https://github.com/joliv/spark/issues/2) suggesting it on mine, but I decided not to go with it because it would only give 5 ticks of resolution, and it didn't seem worth it. It looks really nice though. I do like the command line example in the README, as piping it in is a pretty common operation with tools like this. Maybe you would even want to integrate that into the package as a main()?
I was thinking of doing an app just like spark but on a separate repo.
Nice reply. I think this is what I expected to see when dealing with slices. Not only because it explains what others try to mean but also because shows what the workarounds do under the hood. Thank you 😊
Why can't you just test the function independent of the loop? 
I guess all of those "gadgets" should be in their own subdirectories, so they can be directly `go get`-able.
Made a small fix to protect against division by zero that would happen if all values are the same. See pull request.
True for the caching, but in the context of a image resizing service, signing doesn't make much sense. You want people to be able to request images of any size, and should hard-limit it if it's too expensive.
I for one am excited about this. Could you post a code example that implements locks correctly?
I would do one of either of the following: One, drop the IsWriteTooLong function and the WriteTooLongError struct and just create and export a single error that can be checked for via equality checking, i.e., `var ErrWriteIsTooLong = errors.New("write is longer than the length of the rotate buffer")`. (I'm coming to view a direct call to errors.New() in library code as a code smell; odds are you want to return an error that can actually be checked for.[1]) Two, put the size of the buffer and the size of the attempted write in the new error struct: type WriteTooLong struct { attempted int bufferSize int } func (wtl WriteTooLong) Error() string { return fmt.Sprintf("write length %d exceeds maximum file size %d", wtl.attempted, wtl.bufferSize) } Splitting the difference is sort of the worst of both worlds. Personally I favor the former. This is a Writer likely designed to be used by code that doesn't know that this is the underlying writer, and I'm having a hard time even imagining what code one would write that would receive the WriteTooLongError struct, slap its forehead, and figure out something "shorter" to write. The second choice may seem superficially more helpful, but I think it's taking pains to preserve information and present it to a user that will have no ability to use it. You may also want to let the user hook this file up to a signal (often HUP, but it should be configurable by the user) to reopen the file, as that is a common use case for this sort of thing and is hard to fix from the outside. &gt; `// ensure we always implement io.WriteCloser` &gt; `var _ io.WriteCloser = &amp;Logger{}` Cute! Did you pick that up from somewhere? [1]: To clarify for those who may not know, errors.New() produces a new Error object that will compare [as equal to itself, but not equal to any other error](http://play.golang.org/p/nqEQHjBgJa), so you can easily use it to create errors that can be returned, but also be easily checked for.
Damn, I looked for things in go called lumberjack, too. Hrmph.
I haven't investigated, *yet*, how to package and distribute software properly for Go, mainly because all of the above are intended as stand-alone scripts (I would package them properly if they were libraries). But yes, good advice. Thanks.
Right on; but just to clarify: supervisord is much more than something that handles my logs. It also monitors my services, restarts them based on my config if I want, allows me to control them via cli or a web api if I want, etc. etc.. Check it out if you haven't yet!
So, you're right, the latter is a much better version of what I wrote... I'm not sure why I didn't write it that way. Just not thinking. The reason I don't like the former is that I am a really huge fan of having contextual information in an error. Like the way OS errors actually tell you what file they failed on, rather than just "file doesn't exist". So, like, in this case, instead of "write is bigger than maxsize", you get something like "write of 1024 bytes is bigger than max size of 100 bytes", which might make it blatantly obvious where the problem is ("oh hey, I though the max size was in megabytes, not bytes, oops"). While it's likely that no code calling write will actually be able to handle WriteTooLong, if I don't make it an error you can check for, then I'm explicitly making it *impossible* for anyone to handle it, and that's not my intention.... although I guess by masking the rest of the filesystem errors with return fmt.Errorf("foo: %s", err) ... I'm sort of doing that anyway for the rest of the errors. Sigh. As for the compile-time interface check... I forget where I saw that first. I know we use it in Juju, but I may have seen it on go-nuts, too.
Ahh, sweet. I'm keeping it as-is then.
Oh yeah, I knew about restarting services etc, but didn't know it did logging stuff. I definitely will check it out.
Sure, it's super simple. Note that if you use the standard library's log package for logging, you don't need to do anything, since it already implements locks to prevent concurrent writes. Really, any premade logger should do it already, but if you want to write your own, it's pretty easy. Here's a generic way to do it: type LockedWriter struct { w io.Writer *sync.Mutex } func (l LockedWriter) Write(b []byte) (int, error) { l.Lock() n, err := l.w.Write(b) l.Unlock() return n, err } // usage l := LockedWriter{&amp;lumberjack.Logger{ /*config*/ } } // use your locked writer 
Oh and yeah, handling sighup as "rotate now" is a good idea. I'll do that. 
&gt;You may also want to let the user hook this file up to a signal (often HUP, but it should be configurable by the user) to reopen the file, as that is a common use case for this sort of thing and is hard to fix from the outside. Not OP, but I'm interested in accepting/handling signals for my programs. What's a good way to learn which signal should be used for what?
&gt; While it's likely that no code calling write will actually be able to handle WriteTooLong, So, first, let me say I respect that opinion and I'm just chewing things over here. Since Go is tending to encourage people to produce source rather than binaries, we can run off the assumption that they have source. For something like this, I've been tending to trim my libraries down as far as possible, until the public interface is as small as it can possible be, and as easy to understand as it can be, on the assumption that if you need to go in there and crack open something private for your own purposes, it isn't _that_ hard for someone advanced enough to realize that's what they want. On the other hand, losing relatively less advanced programmers in a maze of options, types, functions, configurations, etc. is very easy to do. I exaggerate for clarity, and only for clarity; obviously, regardless of what you do for this particular error it really hardly matters and it isn't a "maze" no matter how you look at it. Also, as packages get very large and it isn't so easy to just run in there and open something up different behavior is called for. On that theory, I still really haven't gone looking for a go package manager but I personally would very much like to see one that can manage patches as well as packages before I commit.
I think this is a different package that OP wrote.
Or rather think "has-a" instead of "is-a" when it comes to embedding structs. :)
Besides the HTML version you can browse directly, PDF, ePub and mobi versions are also freely available. I try to update the book as often as possible. Any help with content would be very much appreciated (feel free to provide content in the tips section with "provided by:" or even just do some copy editing and send me PRs via GitHub).
"While technically Go isn’t an Object Oriented Programming language," Incorrect. (First line of Chapter 6...)
(crickets) 
The aim of the eBook is to show Go newbies the mechanics of using Sourcegraph while programming in Go. You will be able to check on documentation and real-world usage examples, while coding.
This is one of the major reasons I use supervisor over mmonit: I don't need to write a log configuration file (i.e. logrotated). The app config is contained in one file, is portable, and managed by one program.
So what is wrong with that chapter? The Go FAQ asks: [Is Go an object-oriented language?](http://golang.org/doc/faq#Is_Go_an_object-oriented_language) It answers the question with: *Yes and no. Although Go has types and methods and allows an object-oriented style of programming, there is no type hierarchy.* Which is pretty much what the Op writes in that chapter. 
Updates: I removed the IsWriteTooLong function. I think the criticism that it's not really ever going to be used is pretty valid. The Logger now has a Rotate function, which you can call at your whim (such as in response to SIGHUP), and does what you'd think it does. Finally, I added locks to the structure. With the addition of the Rotate function, which also needs exclusive access to the datastructure... I can't pretend anymore than I can get away without my own lock. I had hoped to avoid double locks on write (one from the logger writing to Lumberjack, and one inside Lumberjack itself), but it really is required, and honestly, the time to lock and unlock is going to be dwarfed by IO anyway. Because I know someone will ask, here's some code to rotate in response to SIGHUP: import ( "log" "os" "os/signal" "syscall" "github.com/natefinch/lumberjack" ) func main() { l := &amp;lumberjack.Logger{} log.SetOutput(l) c := make(chan os.Signal, 1) signal.Notify(c, syscall.SIGHUP) go func() { for { &lt;-c l.Rotate() } }() } Pretty easy.
Technically, go **is** an object oriented programming language. It just doesn't have classical inheritance or classes.
Actually, I just added this to the docs on Rotate, since it's probably going to be pretty common.
Basically... do the go tour and then just try to write Go. Post the code on [golang-nuts](https://groups.google.com/forum/#!forum/golang-nuts) with explaining [what it does](https://code.google.com/p/go-wiki/wiki/HowToAsk)... and ask how to make it more idiomatic. Personal styles vary... so you'll make different mistakes than other people. Probably the only relevant book I can recommend is [The Practice of Programming](http://cm.bell-labs.com/cm/cs/tpop/)... it kind of explains the data-oriented mindset. Also read some Go code... The standard library is a good example: http://golang.org/pkg/ (when you click on a function name it will show the implementation). Also read code by the main contributors.. e.g. [Brad Fitzpatrick](https://github.com/bradfitz?tab=repositories) and [Andrew Gerrand](https://github.com/nf?tab=repositories).
With all the damn loggers people are writing these days, it was only a matter of time before someone saw 'logger' and thought 'lumberjack'. :)
Addition of compile time Type Check for concrete types implementing interfaces would be great. var value InterfaceType = (*ConcreteTypeImplementsInterface)(nil) http://golang.org/doc/effective_go.html = Interface checks
Slightly off topic but often overlooked feature: [testing.T.Parallel()](http://godoc.org/testing#T.Parallel)
So, there's some very useful stuff going on in this little project. The fact that it's a fully capable NES emulator is almost besides the point. Well done, OP. In case anyone stumbles in here from Google, this this is basically a tech-demo for: * Using Go within an Android App * Hybrid C + Go + Java dependency graph * Building Go programs (and dependencies) from Gradle * cgo wrapper for JNI * Calling OpenGL ES from Go
I think Google doesn't care. They can't fix audio in Android for a couple of years, so why do you think they'll bother with some shitty Go app?
Thanks for pointing this out, you're exactly correct. There's a few rough edges yet with it but the main goal was to get something substantial written in Go running on Android.
You can't define methods on interface types. [link](http://play.golang.org/p/HQnZP-JnUo) edit: For your new question, I think the SendNotification function is just a base-case demonstration going a bit too far. I imagine SendNotification would also do other work that needs to be done every time a notification is sent (checking if the user already has a similar notification, updating a database record, etc).
Thank you for making and posting about this. I've been wanting to write an app for Android partially in Go. OpenGL from Go is also something that is of interest to me. Your code shall be my guide :)
OK, that makes sense. However, I rephrased my question a bit.
&gt; I don't understand the purpose of the SendNotification function in the blog post. Why not call Notify directly? Maybe that is a different way to ask my question too. (I modified my original post)
I was tired of templating config files and code with bash variable expansion og jinja2 scripts, and wanted something with easily customizable delimiters and strict checking for missing variables. I think I'll se alot of use for this myself anyway. Any feedback/code reviews are welcome. 
How skilled do you have to be to write an NES emulator? How skilled you have to be to have it run in Android? Edit: All I'm saying is that this shit's impressive and I wanna have the skillz :(
No worries. Post looks great now and I really appreciate your response and update on the matter. Cheers!
In this blog post, the sole purpose of the "SendNotification" function is to have a function which takes a Notifier as an argument, and then see what types qualify as Notifers : *User and *Admin are valid Notifiers, but User isn't. The code inside the function is pretty irrelevant, and indeed, if you just need to call ".Notify()", there is no need to wrap that call inside a function.
Would you mind giving an overview of how you connect your Go code and your Java code? I realise the source is there, but I'm not sure I'd be able to see the big picture clearly digging through the source tree...
Yes, it is. Companies and projects using Go: Google, CoreOS, Docker, Heroku, Iron.io, Github, Sendgrid, Twitch, Soundcloud, Splice, Cloudflare, Canonical, just to name a few.
Also, keep in mind that some very critical projects at Google are running on Go. Any downloads from Google are served by a Go app and all the SQL foundation of YouTube goes through a Go layer (https://github.com/youtube/vitess).
Well, one is for a specific implementation of an interface, and the other works for all Notifiers, so it really depends on the use case. 
any plans to release on google play?
I try to keep this page updated, but haven't really added all the anouncements since Gophercon. https://code.google.com/p/go-wiki/wiki/GoUsers
It's just pretty standard JNI stuff. native stubs and loadLibrary() in Java: https://github.com/scottferg/Fergulator-Android/blob/master/android/src/com/ferg/afergulator/Engine.java Then CGo comments and imports in jni style in Go: https://github.com/scottferg/Fergulator-Android/blob/master/src/Fergulator/machine.go
Not really, no. As others have mentioned, this was a technical demonstration of running Go on Android. The emulator is a hobby project of mine that I've been gradually improving for some time now, but there are much better ones currently available on the Play store.
Yes. 
The `SendNotification` function appears to be just an example of a thing that uses the Notify interface, given the minimal implementation for example purposes. Yes, as written, it's just an obfuscated way of calling `.Notify()`, but this is the sort of thing you have to cut a blog post a bit of slack on... a longer implementation of SendNotification would just be noise. Given that, the way I'd do it in real code would be for no code to appear at all; just an implementation of `.Notify()` and you're done.
You're welcome. Reddit's format doesn't do a whole lot for allowing you to post a link *and* describe it. Besides, I genuinely mean that bit about Google - I've researched various thing for golang and wound up back here in this subreddit more times than I can count.
12 edit: You're getting down votes because you're asking a question that can't reasonably be answered.
We just had a conference, attendance 700 (sold out), where many companies presented about how they were using Go http://www.confreaks.com/events/gophercon2014 A week and a half ago there was a sold out (200 attendees) conference in Japan with the theme of Go in Production. Is Go ready for production? yes, its been in use for years.
Absolutely. We've been in production with it for nearing a year now.
Not really. It's like you'd ask if bash is production ready. Companies use it for side things but it was never a main dish. Language lacks of few things that's why it is only useful for simple tools like docker or sql proxy like vitess. 
bash isn't production ready? Gadzooks! I have so many experienced system admins to notify immediately!
[DigitalOcean has an online terminal emulator for their droplets that is written in Go, apparently.](https://www.digitalocean.com/company/blog/new-super-fast-droplet-console-thanks-golang/) 
&gt; Language lacks of few things Such as?
Could you see doing this for a real-world project? Is the performance good enough that it would even make sense?
You clearly know nothing about vitess. It's hardly a "simple tool"! And I wouldn't say that about Docker, either.
You're right. Go is very much an Object Oriented language, just not in the way some people have come to expect. I think Go's interfaces yield much more flexible OO designs than the typical class-based model.
Well, it just sits in front of SQL and modify or cache requests. What's so complicated about this? That someone works on such tool for a long time it doesn't make it a rocket science. Same goes for Docker. It's just a configuration tool for LXC. Read config file, exec commands, launch LXC. Really _very_ complicated.
You can't make shared libraries for example.
Everyone uses Python nowadays...
If you are no going to jail for that hen how come that is illegal. Go is so limited...
That is actually a good thing. Static binaries make deployment so much easier.
Complex code is often a result of lack of talent.
But you can't do plugins and stuff.
What 'stuff' are you speaking of? There are other ways to achieve interoperability with third party code -eg http://golang.org/pkg/net/rpc/
Correct. I'm saying that the code deals with complexity, not that the programs themselves are complex. I rate the programmers behind both projects pretty highly. I'm guessing you don't.
tl;dr: put any automated tasks you want run in a test function, so it always gets run with go test.
But that's like driving nail with a table. That's the thing, in Go instead of solving the problem you have to look for workarounds.
Technical writers hate him!
Problem is that tools like Docker are completely unnecessary. I admire their complexity, but that's like engineering for engineering. 
It's a good thing for what the language is trying to be, and that consistency in the language's goals are a big reason to like Go. Shared libs have a place, but that place is usually in a C program. Go doesn't need to do everything javascript, C, Python, etc. can do any more than C needs to do everything that assembly can do.
Are there a lot of loggers being written? I'm actually in the market for something to use on top of lumberjack. I had planned on maybe just the std lib log package, but I would consider other options. 
Interesting; however relying on any given 'example' for code structure would likely be a dubious venture. The examples are grabbed from GitHub repos, may or may not be correct, and don't include information like the API. On the other hand, this is pretty neat, and there are a lot of methods with poor documentation and no examples; I could see this fitting that case for me.
Yes but, it's like difference between apache and nginx. Apache has pluggable plugins which can be useful, but it has also drawbacks in term of speed. Nginx has so called plugins which are compiled to binary during compilation. So you have to recompile nginx to add another "plugin". I am working now on blogging platform for go which has support of plugins, but you have to add import for that plugin and recompile to binary. It's not that hard.
To be fair I'd rather say that Go is a bit more complex Nginx, but instead of being able to use ready made plugins you have to sort of write your own. What's the point writing blogging engine in what Go essentially is a bloated web server?
Cool! Here's one that you can use in the browser (just have to `go fmt`): http://mholt.github.io/json-to-go/
Docker just released 1.0 "production ready" and is programmed in Go
Well it's not only simple blogging platform, it has multiple plugins (comments, ...) and possibility to easily write new plugins. So kind of alternative to wordpress, but statically compiled with no need to setup environment around.
Sorry, didn't mean to offend anyone's sensibilities with article title. Yes, it's a takeoff on the "lose weight with this one strange trick" ads. I call it a dumb trick because the example I give doubles the time it takes to run the tests, which is a pretty dumb idea.
Or shared libraries
I've learned a lot of things through copying. It can really help if you're stuck trying to get there from first principles. If you attempt to reverse-engineer the example you're using you can come to a pretty good understanding of the problem domain, and your code might even be an incremental improvement.
Cool. Thanks for patience
Hmm, you seem to be running the big outer "for" loop as fast as you can. Each select instantly exits if there is nothing to do, because of the default clause. So in fact, you are spawning an infinite number of goroutines, but the program is so busy running this loop that they don't start. Do you see lots of "Receiving.." messages when the program runs?
no, only one.
Thank you, it works now. I feel so stupid I did not see it myself :P, thank you for your assistance :)
You probably want to do something like this... package main import ( "log" "net/http" "code.google.com/p/go.net/websocket" ) type register struct { out chan string reply chan int } var enter = make(chan register) var exit = make(chan int) var say = make(chan string) func mindChatServer() { var users = make(map[int]chan string) var userID = 0 for { select { case m := &lt;-enter: users[userID] = m.out m.reply &lt;- userID userID++ case m := &lt;-say: for _, user := range users { user &lt;- m } case m := &lt;-exit: delete(users, m) } } } func mindClient(ws *websocket.Conn) { var uidChan = make(chan int) var outChan = make(chan string) var errChan = make(chan struct{}) enter &lt;- register{out: outChan, reply: uidChan} uid := &lt;-uidChan close(uidChan) defer func() { exit &lt;- uid close(errChan) }() go func() { for { select { case m := &lt;-outChan: websocket.Message.Send(ws, m) case &lt;-errChan: close(outChan) return } } }() for { var message string if err := websocket.Message.Receive(ws, &amp;message); err != nil { return } say &lt;- message } } func main() { go mindChatServer() http.Handle("/", websocket.Handler(mindClient)) if err := http.ListenAndServe(":12345", nil); err != nil { log.Fatal(err) } }
Guess I was late to the party with that one...
What are the significant differences between this tool and godep?
You're the worst of the neck beard that I've ever seen. No exaggeration. BASH isn't production ready? It's the default fucking shell on so many OSs now that it's mind boggling. Go isn't production ready? What evidence of this do you have? Any massive failures? Major projects that were being written in Go, but had to be halted to pivot to a new language? Any evidence at all? LXC isn't necessary? Sure, you're right. Because in reality everybody could use extremely terse interfaces to the OS provided controls for things like LXC and KVM. But most of us have shit to do in our lives, so we use tools that make it simpler. Get over your "Everything has to be hard" syndrome, please. Everyone uses Python nowadays? Seriously? To replace BASH? I don't use Python as a shell. I know I _could_, but then again I could write in assembler instead of a higher level language. And I think you'll find Python is as popular as Ruby or Perl for sysadmin scripting languages. I'm actually really surprised you're _not_ a PERL guy, though, what with your outlandish statements, no proof, and most-difficult-approach-wins attitude. Shared libraries were NOT a design goal. They intentionally made Go not use shared libraries so the developer could deploy a single binary with no external dependencies. Just because it doesn't do what you expect, doesn't mean the project didn't think of it. You should really read up on the design principles of Go before saying foolish shit. Can't do plugins. Lots of Go projects (Heka, as an example) allow you to extend the original application with LUA. That basically fulfills your need for plugins. But again, you've missed the point of the language in the first place! It was designed to provide a single, monolithic binary with all functionality built into it. By the way, using things like RPC or a RESTful API between system components is a major component to building SCALABLE systems. That way, if I have a front-end serving application facing clients, and a back end data process serving the front end, by decoupling them and using a standardized interface, I can add many of each to suit my capacity needs. This is how adults build large systems. Always has been. @phonkee, the NGINX and Apache example is wrong on many levels. Apache can easily be just as fast or even faster than NGINX. People often configure it incorrectly or use the defaults, which are not fast. NGINX's default configuration is. Either of them can easily overwhelm a host's capabilities. The example is also incorrect in that plugins are not the cause for slowness. Poor control over programming practices, and little effort put into code profiling and performance tuning are often the leading reasons why plugins perform worse than the parent process. An example of where "plugins" work quite well would be the Linux kernel. Modules are loaded as plugins to the kernel itself. A good module will have effectively no performance degradation over natively compiled-in code. TL;DR /u/UnreachablePaul your name suits you well.
Sort of what I expected. Goyaml is the only really viable parser out there. Luckily, it's also perfectly good, which may be why no one else has bothered :)
Yeah, that was my first thought when I saw the line about it just being a bash script. There's no excuse for writing a tool for Go programmers that isn't also written in Go. We write in a cross platform language with no dependencies... take advantage of it!
Provide the functionality you're implementing as a library. Allow users to call your code to use it. (library approach) The other alternative is to expect functions as parameters. (framework approach)
This probably depends on what you are trying to achieve. One way I have experienced this is like http://play.golang.org/p/V5Z8IYuIRn, where the functions are fields in a struct and are initialized with the default implementation but can easily be changed.
First, be careful of "Sadly I initially used code from a website on the internet but I forgot where." You could be distributing code without the right to do so. Chances are no one is going to give a crap for something like this, but a good habit to get into is including a comment linking to where you got code from on a small project, or a seperate list of links on a larger one. This isnt even for legal reasons, though it will help with tracking down licensing later if need be, but when your borrowed code breaks or just needs to be changed sometimes it helps to find where it came from to check the comments or whatever and see what other people are doing. Secondly, as nice as Go is there is one huge limitation from the perspective of writing a bot: No shared libraries, so no 'plugins' shy of having to recompile and restart your bot every time. Probably not a big deal for you, but just something to keep in mind. As for your code itself, it looks fine, but I would be careful of your title parsing code. You might want to make a page that has &lt;title&gt; QUIT bye &lt;/title&gt; in it and see what happens. I havent tested it, but looks like it should make your bot quit. You may even just want to make Message() strip newlines for added safety. You do get points for prefixing the title with something, this stops people from forcing your bot to send commands to other bots edit: reddit killed my formatting, I meant &lt;title&gt;\nQUIT bye\n&lt;/title&gt; with a hard newline before QUIT and after bye
IRC bots are one of my favorite pet projects. There are a lot of options for ways to do plug-ins without recompiling and restarting every time. You could use an interpreter (Otto, custom DSL, whatever), have commands be executables in a known location on the filesystem, have them interact with the client process as part of another process via rpc. Go has many powerful communication facilities built into the standard library, it opens up room for creative implementations.
I would also refactor functions that take the same arguments into methods on the Bot struct since then you can get it automatically and those huge if-else branches edit: you are also concating strings in a loop thus generating garbage for the gc to clean up, not a big deal but those most probably wont change so can be made once
I was planning to get rid of the struct later if I fully decide to rewrite the connection. The if-else doesn't seem that bad. What other things could I use in replacement for it?
switch statement is visually more appealing but look at the irc libs linked, all of them parse the protocol and dispatch to functions registered (too much indentation also signals to you to refactor shit)
It will do that and even raise the dongers for no extra charge.
I think your best bet is go-qml ( https://github.com/go-qml/qml ).
I'm not sure about overall state, but the state of the Qt/QML binding to the Go (https://github.com/go-qml/qml) is pretty stable. There are some issues with windows, but I hope it's going to be fixed soon, the author has not much time to deal with foreign platform. 
Here is one of the best ones I have seen. https://github.com/andlabs/ui
Good question. HTML5, Gtk3 and SDL2 works, but you would need to specify a use case. 
For delicious upvotes, just write that the shit is impressive and that you want those skillz. 
Basically HTML is your best bet. Everything else is a distant 2nd and QML is really the only thing that's far enough along to really consider using.
For a standard widget-oriented GUI app, does it make sense to use QML? It seems there's no reason it wouldn't work, but most of the QML examples seem focused on either mobile apps or OpenGL/3D stuff.
I slightly reworked your example to illustrate a common pattern I use. http://play.golang.org/p/ByoUzfqOpn
BTW, I just released v1.0 Lumberjack. The only major change was that MaxAge is now an int representing number of days, instead of a time.Duration, to make deserialization easier.
Can someone provide a mirror link for the video?
&gt; If you look at a cat picture on the web, there's a really good chance it went through a Go program. 
It works like crap
Interesting... I always thought that a call of an unfulfilled method would panic in such a case.. Great to know!
Yes, KDE uses Qt and is switching some things to QML and they have all the traditional widgets based fixings.
This is pretty new, and requires Go 1.3 (which is still in the release candidate phase) but it is also the most promising native UI library I've seen.
It supports native looking widgets and have some, i.e. standart form elements.
1.3 is fine by me, its for an experimental piece of software
HTML5 wouldnt work for this use case. 
I'll give that a parse through 
HTML wouldn't be an option in this case
Latest version of Skype works fine here. But come on, Microsoft had never been fond of Android and has no reason to make the Android edition smoother than the iPhone edition. Rather the other way around. 
The site is up again.
Out of curiosity, why isn't HTML an option? 
Needs to display video and handle input from separate hardware. A browser would introduce too many variables.
I see. Those are some heavy requirements for _any_ GUI toolkit. They're generally only supported on mature toolkits like GTK and Qt. New-ish / small / pure go toolkits are not very likely to provide this functionality yet. For what you're after, I'd strongly suggest looking at the Qt or GTK bindings.
You could embed the browser yourself using chromium embedded framework (its C++ but its very simple to setup) Then have Go launch the browser and bind to a port. Have the browser go to local host on that port and you are golden. I get this may not work for you, now, but I'm currently building a framework just for this.
FYI: Below is plusplus bot written in go. it count votes with "DeleteYourLife++". https://github.com/mattn/go-plusplusbot
I was looking at this and was seriously considering using Lua for Go and then the wxWidgets Lua bindings. It looks a lot better maintained than anything for Go as yet. Or if you can handle Tcl, the gothic Tcl/Tk bindings for Go.
Could have been an option, but as I mentioned, would introduce too many variables for an application thats supposed to be secure. I'll keep it in mind for any future projects without the requirements &amp; sensitivity of this project. As for the framework you're working on, do you have anything published at the moment or plan to do so in the future?
I looked at chromium-embeded framework, and got frustrated at the prereqs. I wanted something I could pass around to other go enthusiasts without requiring them to muck about with C++ libraries. So I started rolling my own: https://github.com/thingalon/goui It uses the system's native libraries via cgo to launch a new window with an embedded browser, which it points at an embedded go webserver. It's still under heavy development right now, with next to no documentation and only OSX support so far. But I plan to build in Windows and Linux support too. If you happen to use OSX and would like to try it out, check out the example app: https://github.com/thingalon/goui-example If you're working on something similar, Klathmon, I'd be more than happy to help out. 
If the Tcl/Tk state for Go are as horrendous as they are for Python I'd rather not :) How are wxWidgets?
Nothing I would feel comfortable giving out in its current version. Basically it will be an embedded web browser which will allow you to add your own webserver/language of choice (PHP, Go, JAVA, python, etc...) Just tell it which executable to run, port and default page and a few other settings and things (limit navigation to a list of domains, disallow right click, etc...) It will also run on windows, osx, and Linux. I'll be making a post in /r/programming (and perhaps here) when it's ready for prime time.
I'll be on the lookout for said post. Sounds like an interesting project. Will you be limiting access to all other ports/browser capabilities aside from those requested by the application?
Mine is a bit different. Its cef (precompiled) with some extras that make deployment and configuration easier. See my other reply to the comment above yours for more info. I'll probably be finished in a month or so and ready for release, it'll be under the MIT licence for the most part.
Sounds interesting. :)
More or less. As for browser features it will launch with being able to control printing, navigation (forward and back with keybindings/mouse buttons), hostname white listing, and right click. It will be up to the developer using it to ensure their server is secure and locked down.
Haha, well as of today, 1.3 is actual stable, so good timing!
I was just scoping it out, and I noted down Lua/wxWidgets as something promising to investigate further. I haven't tried anything realistic with it yet. (I am also kind of checking out Go to see whether I can push it for any new projects I'm involved with.)
I created the Meetup. Let's get some members and organize the first meeting! http://www.meetup.com/golangMN/
Ahh. Thank you 
Wow, the static analysis is awesome (http://golang.org/lib/godoc/analysis/help.html)
Is it true?
https://github.com/davecheney/autobench
&gt; The method set and implements relation are also available via the package view. I just woke up, but I'm wondering how godoc finds the implements relation now. This is IMHO a great addition in documentation. 
It won't, because it will make more complex under the hood, and I think that's good for keep making Go simple
Are there any plans to enable this on golang.org for the standard library packages?
It's achieved through the oracle analysis tool, I think.
If the interface/video codec isn't anything complicated then SDL2/Qml should work fine with Go. Of course, it's also possible to use C libraries, for the codecs, with some effort.
I always find duplicate code to introduce more complexity. 
In the midst of all the great 1.3 features, I feel like we've missed that *badass* ASCII gopher. If there aren't several of those in the next Go release, I will be extraordinarily disappointed and `rm -rf` immediately.
As someone who hacked on an inotify tool, amen. That's one of those areas where a cross-platform API would be extraordinarily useful, yet it just isn't there.
Thanks, this approach seems the most elegant to me.
/u/enneff, did you notice the ASCII gopher is rendered as an ASCII koala in the location bar? Represent.
How do I enable the static analysis? I just installed Go 1.3 and started godoc -analysis="type,pointer" -http=:6060 and opened http://localhost:6060/src/pkg/sort/sort.go in the browser, but it looks like before, without any analysis links, but on the bottom of the page it says "Build version go1.3." **Edit:** when I exclude my local GOPATH, it works
&gt; that badass ASCII gopher 5 of the 7 characters are non-ASCII.
Have not seen this before, exactly how do you? 
Skype audio is lagging. App can be smooth as Obama at banana party, but audio has too much of latency to allow comfortable conversation and there is nothing application can do, because it is a kernel issue that is not being fixed.
Eh, makes for a good showcase of Go's UTF-8 support.
tl;dr no
Awwwww... :( I guess I could a REALLY complicated shell script that would merge the mods and the main codebase at compile time and have people compile it before they run it... Or I guess I could use exec.Command() and have the mods right to stdout as the output... IDK, they're all bad solutions, thanks tho.
I asked about this [on r/programming](http://www.reddit.com/r/programming/comments/28ihq4/go_13_is_released/cibiu0x): isn't the non-incremental stack copy going to hurt latency?
goweb is my favorite.
[net/http](http://golang.org/pkg/net/http)
for small web apps , go-martini + angular play very well and for big project net/http is your best friend.
I think each project goes to https://www.mturk.com/mturk/welcome and some children in India figure that out in realtime
You could try doing it via things like RPC
Its going to be a big app. I am concerned about directly working with net/http. It would be really nice to have routing, orm, validations, input filters, etc.
And how do you see this awesome text gopher?
This is the answer. You can set up bi-directional communication using RPC.
You could embed a V8 vm and have the mods written in JavaScript. 
Great stuff; I was just on #reddit-gamedev talking about Go and it's stop-the-world GC. Speed improvements made there are really nice in 1.3 (~50%).
It is the same order of magnitude delay as append() reallocating a slice's backing array. Edit: Okay, I can see you're concerned about the pointer manipulation, but still this is nothing compared to what the GC does. How big do you expect your stack to get? (i.e. what is the longest stacktrace you've seen?) Unless you're doing massive recursion, your stack isn't going to be huge. If that is the problem (you need immense stacks), you can use queues/etc instead of recursion to code your algorithm (and make it more memory-efficient too probably).
Well, I would expect the reallocation to be done with something `realloc`-like, that is often a no-op and in any case a fast bulk copy operation, while this stack copy needs to iterate on any pointer and possibly change it. But given that stacks are typically relatively small (if you don't write non-tail recursive functions), the costs could indeed be fairly small.
I like to think he means he's writing deplorable binaries and just hoping that he's not a coworker.
I would solve this using RPC
There's a project that is porting gpm to Go. You can keep track of it's progress [here](https://github.com/mtibben/gogpm) The goal for gpm was simply to solve a need and it gets the job done for *nix users with under 100 LOC. I leave to others the more generic approach. :) 
True. Ubuntu 14.04 was providing Go 1.2.1, but since there is now 1.3 I have updated readme file, so it points to golang installation page. Thank you
You should use fully qualified paths for your imports (i.e. import "github.com/elcct/defaultproject/web"). The way you have them defined now, it's not possible to "go get" this code, and it means you must have a gopath with this code at the root of the gopath, which is not something most experienced gophers are ever going to do. Here's my suggestion: Move everything from src/web up to the root of the repo. Change all the imports to use the full path. Please use gofmt on your code. 
The reason I have not used fully qualified paths is that this project is intended to be a base for your own project. Once cloned / downloaded you should put it in your own repository. As of fmt, it runs every time you run make. I have noticed that even after using fmt source code on github not always look great, but is formatted fine locally. Thank you.
I commented that this project is intended to be a base of your own project, so I don't see a point using full paths. Is this really wrong?
Deploying RoR however is a pain in the ass.
Thanks for the answer! However, the package name is used across multiple languages (Java, Go, ActionScript and PHP) so I'm not really allowed to change it. Why can't I just use a relative (to my package) import like `import ./example_protobuf_messages`? Consider the following tree: . ├── bin ├── pkg └── src └── github.com └── example └── myexample ├── main.go └── example_protobuf_messages (compiled proto files here) How do import a go file in `example_protobuf_messsages` (that has a `package example_protobuf_messages` declaration) from within `main.go`?
Don't use makefiles unless you really need to run something other than the Go commands... this code wouldn't need it if it was structured in a standard way. it's just as easy to find and replace "github.com/elcct/defaultproject/web" as it is to find and replace "web", and much less likely to replace some valid string somewhere else in the project. Note that you can do go build ./... to build the package in the current directory and all subdirectories. This works for go test etc as well. It's a lot better than doing ./*go.
I know it is not, but I can't see the structure they suggests useful in web application scenario. How do you version your workspace then? Do you have any hints that could make it complaint and also easy to use? 
Essentially what I am trying to make is a web end user framework, with the idea being you could install, say, a forum or a blog just by copying a file into a folder (I'd probably create a GUI to do it as well). It would be like an easy way to setup your own web services.
In Go, when you're working with a workspace, all your imports have to be absolute. See: http://golang.org/cmd/go/#hdr-Relative_import_paths So in your main, you'd probably say: import "github.com/example/myexample/example_protobuf_messages" For your own convenience, you can give a shorter name to the import so that you can use it more easily. import mproto "github.com/example/myexample/example_protobuf_messages" # ... later on m := mproto.GenericMessage{}
In the title ya dingus
Makes sense. I'll give it a shot, thanks!
makefile is gone now. Thank you.
Aww, I was hoping the Go standard library has a function that would print out a cute gopher in the terminal.
Yes. It would lend itself to being easily understood by the interviewer.
Yeah, yeah, you know what I mean. :)
Hi, I'm new to Go, but I've decided to learn it with the primary purpose of using it for future interviews. Its core syntax, being very similar to C, occupies a sweet spot in the language design space, imho. And at least it would be more "common" than Haskell, the language I'm using in my everyday job :)
Has the interviewer specified a list of acceptable languages which doesn't include Go? Then no. Otherwise: yes.
Like /u/UnreachablePaul, /u/fungussa, and /u/k_wolfe mentioned, RPC would be a great way of handling this. I found out recently that Packer accomplishes a plugin architecture by using RPC. Check out the initial plans for it on the [GitHub issue](https://github.com/mitchellh/packer/issues/1).
You don't need a workspace in the repository. I actually don't even know what that means. Workspace doesn't really have a good definition in Go. Your application references labix.org/v2/mgo ... other packages/applications in my GOPATH may also reference labix.org/v2/mgo... that's ok. It's the same code. No reason to have it in two places on your hard drive. You should never have to change your GOPATH. You set it once when you install go, and leave it forever and ever. (some people don't work this way, but this is the way Go is set up to work by default, and to work in a different way is to swim upstream). The only time you need different gopaths is if you need two copies of the same library at different revisions. This should hopefully be rare if the library maintainers are good at their jobs. For example, there's no reason you'd ever need two copies of mgo. It is stable and any changes to it will be minor bugfixes that don't affect behavior, so shouldn't break anything. When I fork your code to my repo and start writing my application, I just find &amp; replace your import path with mine. It's a one liner in bash or the editor of your choice that I do exactly one time ever. If you don't use the full path, then you *have* to constantly change your GOPATH, because your package names aren't unique. "web" could be anything. but github.com/elcct/DefaultProject/web is very specific. 
You're right. Go has a bit different concept to that I have been used to, but after giving it some thoughts it actually makes sense. Default Project now works the way you described and it is much easier to install :) Again, thank you for making me aware of this.
So it only works with the standard lib?
I do and have. It's easy to read, it's easy to write and not make syntax mistakes. However, the backward varName typeName will make you look like an idiot when you write C# code on the board and write public static void Main(args []string) :P
No, you can't do this. Heka (https://github.com/mozilla-services/heka) is heavily plugin-based, and it has a RegisterPlugin() function similar to what you describe, but all plugins must be statically compiled in; if you want to introduce a new plugin, you have to recompile. We get around this problem by having Heka embed a Lua sandbox (https://github.com/mozilla-services/lua_sandbox), which allows us to dynamic injest Lua code into a running Heka server.
No problem... most people (including me) have a difficult time transitioning to the Go way of organizing their projects and code. Some people have reason to work in a different way, but for most people, it's easiest to work with just a single Gopath and full URL package names for everything.
No, it works on any package that can be compiled with 1.3, I think. All the packages in my GOPATH worked with both pointer and type analysis.
I did. :-) And look at me now!
So much boilerplate :( More of a comment about MVC apps than your project though.
Are there certain questions where Go would have a disadvantage?
Maybe you could expose Go functions to JavaScript via [otto](https://github.com/robertkrimen/otto) and have plugins in that?
Two month ago, I would have said no, but I am slowly getting comfortable with the stdlib, concurrency patterns, etc, so in two month or so, I'd probably pick Go as interview language.
Well, you could make a router app that handles HTTP connections from the outside (bound to `:80`) and watches some directory for apps. You can present an interface on `/admin` and do whatever else you want here. Given an app in the directory, e.g. `forum`, it would launch `app/forum -bind localhost:4804`, supervise the resulting process (relaunching if it crashes, etc.), and route all `/forum/*` requests to `localhost:4804`. Done. From here, bonus points for: * Privilege separation (run each app as a separate reduced-privilege user with caps on memory and IO use) * Environment isolation (run each app in a minimal environment, without access to the host filesystem) * Network transparency (run apps on a separate box from the frontend) * Load balancing (run several instances of the forum behind one frontend) * Automatic failover/recovery/scaling * Service discovery * Logging * Scheduling * SSL * etc. etc. There's one catch: at this point, you've basically reinvented Docker, Flynn, Heroku, CloudFoundry, and everything else in that space.
&gt;There's one catch: at this point, you've basically reinvented Docker, Flynn, Heroku, CloudFoundry, and everything else in that space. I was crying as I read your post until that line. Phew. OP, you'll find out that once you've built the convenience you're wanting, that it will break for anything non-trivial and then you'll start bolting on more features until you approach something like willglynn named off.
I do, and it makes it very easy to solve complex questions. Especially when they come to the "ok, now how do you scale this". Concurrency and everywhere an io.Reader/Writer make all that trivial to write on a whiteboard.
He writes beautiful code, is friendly and cooperative and handles feedback well. I'm a fan. 
I knew someone would call me on that. The problem is not that workspace is not well defined. The problem is that the word brings a lot of baggage with it. People think they need multiple workspaces or one per project, which is not true. Workspace just means your gopath. 
I think if they'd called it the download zone or code dumpster, there'd be a lot las confusion and people trying to do wacky things based on an assumption that they know how workspaces work. 
Gotta give it time. It's slow - monitor the console and it'll tell you it's doing static analysis. For the 20 or so packages in my GOPATH, it took 10 minutes...
Really, I've found that net/http and a mux router (such as gorilla/mux) is all you need. An ORM like gorm comes in handy, but isn't necessary. I'm working on a pretty good-sized app myself using a RESTful API that has an AngularJS frontend. You can find it [here](http://github.com/jordan-wright/gophish) if you're interested.
Why are you posting this? It's not your package, is it? It does not seem production ready if it is, and your vague title and the (understandable, if product is not production ready) README does not explain anything about what this is trying to solve or how to use the package.
It also looks rather unidiomatic. Looked at the godoc enough to see the word 'callback' plastered all over it and noped right out of there. It looks to me like someone is trying to port a library from another language they like, and wants to use it in go (underscore.js maybe among others). Really, this is not how to do things in go. Go has everything you need to do complicated, highly concurrent things out of the box. You don't need a library to do these things.
It would make sense to me to have a plugin architecture to an application where users can extend it by dropping code/an executable into a plugins folder, and it will be magically discovered and integrated. In go you do not have as many options as in languages with dynamic loading / linking. You can make the user recompile with their additions, or else have some kind of interprocess api that they can make a standalone thing to conform to. Not nearly as nice as some apps have where you can drop a code file or a dll or jar file into a folder and be running.
No, it's not my package. I just thought it was interesting, especially given that it implements a pattern seen less often in go code. fwiw, I found the autogenerated API docs fairly self-explanatory, but maybe that's just me.
Does it support generics yet? No? Okay I'll check back in 6 months
Thanks ! Having a real world example to work with helps a lot :)
Wat? git push heroku master
I did this in my last round of interviews.
afaik. you need to create a kernel driver for that, and you can't write windows kernel drivers in go. 
But in this case it's a bunch of complicated functions that could just be written as 'for' loops. They'd be shorter, more efficient and much easier to read.
Why do you forbid him from writing one?
To save him the time.
Me too!
not sure if you came across this [https://github.com/tarm/goserial](https://github.com/tarm/goserial)
Hard to explain without generating a flame war, but I'll try. I'm a full time Haskell coder, which means my first-choice tool is Haskell. With it I'm more productive that with any other language, and I can write code very declarative and most of the time correct and reasonably efficient. The other side of the coin is that Haskell jobs are thin on the ground and very "niche", so I wanted to learn something new but at the same time potentially useful to stretch my "imperative brain cells". I already know C++ and Python, not attracted by dynamic languages (I like types!) and Rust is still too young. Go seemed a nice choice considering all my criteria. Makes a bit more sense now? :)
Use net/http and for rotuing: http://github.com/julienschmidt/httprouter
now that you mention it, i'm not sure, i never tried it, just found it on google, and thought you might check it out.
This is the other side of that: something that talks to serial ports, rather than something that *pretends to be* a serial port. I would suggest writing a Go application that talks [RFC 2217](http://tools.ietf.org/html/rfc2217), a standard way of presenting serial ports over TCP/IP. From there, [Wikipedia has a list](http://en.wikipedia.org/wiki/COM_port_redirector#Open_source_solutions) of tools applicable to various platforms, including several that can bridge RFC 2217 to a virtual serial port on Windows.
I'd use psuedo code. Using a software language to answer interview questions on a whiteboard seems silly to me. Now, if you are talking about a coding test/example code where I have access to a compiler to remind me when I'm being an idiot...yes I'd use Go. ;) 
Then it's time to end the discussion. Ofcourse, it's still not possible to write windows drivers in go. 
**still**, but it's not impossible. If author has time, then he can implement that driver in Go.
&gt; given that it implements a pattern seen less often in go code. Because people use Go to not use that pattern...
Great work guys! This framework is really shaping up nicely...very tempting to use it for an actual project. Do you guys have any benchmarks for performance against net/http and other http libs like martini?
No, really, ratatask is right, it simply can't be done in Go.
I've had it running for a few hours. The source view remains unchanged. 
It can, just needs time.
Macro the duplication out!
Ah, I've seen Gordon referenced a few times but looks like that may be legacy: http://www.reddit.com/r/golang/comments/e4x7x/does_the_go_gopher_mascot_have_a_name_if_not_i/
Or a less fancy but more straightforward title: *Sending a POST Request From Your Go App*
I will! I had 3 interviews where I chose Python to solve "big-data" related problems. In all three of them the correct algorithm usually requires some kind of tree. In Python the trees consume too much memory and too slow to rebalance. I will definitely use Go in the future.
You don't have to rewrite the language, but you might want to write libraries that will be kernel compatible. That's why I said you need time, but that is certainly not impossible.
Oh, most definitely!
Do you know if it has any Chinese backdoor in there?
Why is martini better for smaller apps and net/http for larger? Is it strictly a matter of better performance with net/http?
Just curious, why was hot reload removed?
Let us know how you get on.
I was more interested in something similar to the techempower benchmark for the latest version. The router is nowhere near being a bottleneck for any framework out there. I am more interested in benchmarking the areas of frameworks that actually take up serious resources.
LGTM
It doesn't matter if it's Go, use the same logic to figure out which language to use. If the group you're applying to uses one language dominantly, use that language if you're familiar with it. Otherwise, use a similar one. If they list a smattering of different ones, use your favorite. Remember, you're going to be following the conventions of this group. If they don't use Go very much, don't use it. Show that you're willing to play along.
Nah, the app is just derping. [Web screenshot](http://i.imgur.com/Uppd1sR.jpg)
This would be a dream come true. I'm sure the memory usage benefits would be out of control if all of Android was written in Go. I wouldn't be surprised if the whole OS would end up performing better. Though maybe I'm wrong -- it seems like the new ART system for Android might improve Java performance a ton. On that topic, it seems interesting that the proposal specified Dalvik, when it's deprecated.
This problem I think you'd better ask the U.S. government weather the CPU has backdoor. I am serious concerns about it.
Andrew's being awfully nice, the person couldn't even read the three sentence abstract.
How about you read the doc (http://golang.org/s/go14android)? It's not long.
hot reload I think should be a module. also it's only support linux now and not necessary for the system. I will write a new module to support hot reload. Now like now integrated into the beego's http logic.
That sounds like you're learning Go to improve yourself. That sounds fine. I don't understand where "purpose of using it for future interviews" comes into this though.
Doubt that will happen. I think they said round 9 was the last one.
I can't tell if you're joking around or if this is a hilarious coincidence.
Their latest blog post[1] (which was also for Round 9) indicates they are working towards Round 10: &gt; Busy schedules delayed Round 9. We apologize for the delay and thank you for your continued interest and patience! We welcome you to join in for Round 10. [1]: http://www.techempower.com/blog/2014/05/01/framework-benchmarks-round-9/
&gt; if all of Android was written in Go Do you even hear yourself?
Wonderful news! I missed that completely :-\
"How would you do X in JavaScript, given that JavaScript programs are single-threaded?" perhaps.
what does LGTM mean?
I really hope this is true, or at least i hope google realizes android needs a newer more "modern" language. I hope google embraces either go, or comes up with a similar answer like swift. I know in the grand scheme of things java is "new" language relatively speaking. But i think most people can agree swift is a good thing (or will be), and google should have a good answer for developers.
Sounds like a good plan :)
I always hoped this and learned go as my first language, Worth it :) 
This is awesome. I'd imagine this will cause a spike in Go popularity, and also a rise in popularity of Android as a game development platform. I guess the second would be far harder to measure, but anyway it's a fascinating development
Looks like a great thing. I hope, that one day it would be possible to write normal Android apps in Go too.
Cool ! 
Like gophish - great example of some elegant patterns. Thanks!
http://play.golang.org/p/ZgCx42VE1_
Maybe two years, three years? They can do it if they want to. They are massive! And have billions. 
Person that put bloated monster like Java must have been the stupidest person ever lived
Groovy, Scala, Clojure – everything works with dalvik/art right now
It's not about if they could, it's about why would they? The benefits wouldn't outweigh the cost. It makes more sense to optimize the existing codebase than the rewrite it from scratch. Not only would it cost a ton, but it would probably cause a ton of regression bugs that would piss off users.
See [Debugging performance issues in Go programs](https://software.intel.com/en-us/blogs/2014/05/10/debugging-performance-issues-in-go-programs). Also, people can't magically read other persons code... unless you are in NSA. :)
I'll just leave this here... ;) http://en.itar-tass.com/economy/736804
Both. Just passing on some knowledge he's/she's picked up from Andrew. Heh.
Things You Should Never Do http://www.joelonsoftware.com/articles/fog0000000069.html Though I think the law of programming he cites applies the least to Go. Java on the other hand...
Well yeah. You have lots to get done rewriting all of Android in Go. I'm on to you!
Where's love for the USA?
Thanks, /u/barnybug! The design patterns aren't the greatest, but I'm working to make it as modular as possible, and decouple things where I feel it's needed. It's absolutely a work in progress!!
http://golang.org/pkg/regexp/ is the way to go with that sort of problems. If you have very specific needs in term of performance, then roll your own implementation. But given your `strings.Split`, I doubt that's the case.
So, is that a good implementation for finding just one occurrence? Meaning, "the go way"? I thought on writing a regexp, sadly, the contents of the "start" and "end" string variables could be also special characters and I'm too newbie in Go to understand how to properly escape those if they're given as a parameters. 
Struggling to understand why this spam was posted, rather than something useful from the [Go blog](http://blog.golang.org/go1.3). 
The new GoDoc static analysis features look quite cool. Some screenshots here: http://golang.org/lib/godoc/analysis/help.html
I only found examples on the web, using a `bytes.Buffer` for the `multipart.NewWriter()` argument. The gist shows how it can be done using an `io.Pipe`. Now I just have to figure out the ContentLength, which is sadly required by the API I wrote this for...
I figured out the ContentLength. If you only have the one file and no other parts, you end up with a multipart header like this: --c066c9a9641fdfd1bdc429c573be50cca93f62c745f6cb19b456dcf34821 Content-Type: &lt;ctype&gt; Content-Disposition: form-data; name="file"; filename="&lt;fname&gt;" &lt;data&gt; --c066c9a9641fdfd1bdc429c573be50cca93f62c745f6cb19b456dcf34821-- if you strip out the placeholders you get 201 characters and than add the filesize and the string lengths of fname and ctype and you are set. edit:code formatting..
Yes, I think it's beautiful language for doing elegant, readable solutions to the sort of questions you'd be likely to get in an SWE interview.
The Go snippet is all that there is, however full details at http://pastebin.com/7BN6Jijd . Both NGINX and the Go program read from the same root directory (same index.html)
Not sure - I could turn on the profiler. However I hacked a quick epoll C webserver (nothing fancy) with a master process and 4 workers and I am reaching the Golang performance - they are basically the same. The difference is I am running epoll in Level Triggered as it was the quickest to hack.
Sorry not being so clear. I'm not an English speaker and even in my mother tongue it's hard to explain what I'm trying to do. I'll check regexps then. Thank you. 
Nice. Thank you. I think I'm going to say to myself "RTFM" 😊
There are some tricks you can do by batching several packets together. I read about this in thttpd originally. Is it possible that NGINX is doing this and Go not? It could perhaps explain a difference. See the bottom of this page: [thttpd benchmarks](http://www.acme.com/software/thttpd/benchmarks.html)
I checked and I also get half the speed of nginx
Well-written C is hard to beat, but it shouldn't be hard to make Go perform better than double as slow as C.
https://github.com/wg/wrk
If i would guess, i think that probably is more of a IO bottleneck than the resulting compiler optimized binary.. First theres a need to prevent all memory copy, trying to reach a optimal "zero copy" situation.. check if Go are using the proper syscalls (more performant).. only than we would end with the compiler optimizations differences from C vs. Go So, i think it would be really gratifying to spot some IO, memory copy, syscalls bottlenecks first.. Lets not forget that nginx by using C will be "manually optimized" for zero copy.. giving that Go allow the programmer to use pointer indirection.. its possible to achieve the same thing in Go Edit: also memory allignment is pretty important.. you need to do it manually in C while in Go it probably does it automatically.. but it need to be checked in this particular case
for zero-copy they both use sendfile. syscall stats for Go: http://pastebin.com/J8n4igK3 syscall stats for NGINX: http://pastebin.com/pL0GakHv
Great job!
damn, I love the automated API document
This is better: https://github.com/julienschmidt/go-http-routing-benchmark#conclusions
Couple of ideas: 1. Try setting GOMAXPROCS=1. I know it's counter-intuitive, but being single-threaded simplifies things for the runtime scheduler. It may be slower, but it's worth a try. 2. I suspect NGINX is probably doing some internal caching of frequently-requested resources. Try adding a map of resources being requested to the number of times they're requested per second and store the top 5-10 in memory and serve from there. It'll add a bit of complexity (which is what you get when you write your own server), but you should get some nice performance from it.
Go 1.3?
I tried both now and actually 1.3 is slightly slower on average, but not by much. I'm getting ~130k rps with Go, haven't tried nginx for comparison. BTW are you on a Mac? I remember there were some networking performance issues on OSX
No, I am on Linux. Also the build time with Go1.3 is considerably longer - have you also noticed that?
Nope, actually go 1.3 builds slightly faster here: $ time /usr/local/go1.2.2/bin/go build foo.go real 0m0.082s user 0m0.066s sys 0m0.019s $ time /usr/local/go1.3/bin/go build foo.go real 0m0.069s user 0m0.053s sys 0m0.019s 
Neat! I wrote https://github.com/ngerakines/preview that does something similar but for other document types.
Look at different wrk settings. Reduce the number of simultaneously open connections, bump the threads up, and increase the duration. A two second duration isn't hugely useful. You should also look at posting the latency figures from wrk as well, which *are* useful.
My multipartstreamer package will let you upload files from an io.Reader without reading the whole thing in memory. Only supports a single file though... https://github.com/technoweenie/multipartstreamer
You did force your view pretty strongly on the JSON response though, by forcing the structure to have a result and status. Also, returning the status code in the response body is kinda against REST since it's not really related to the resource, it's redundant (the HTTP response already contain the status) and a result/status on the response resemble an RPC approach. Don't take me wrong, nothing personal, just a constructive criticism. 
Ah! Thanks for bringing that up. You can override the PayloadWrapper with your own format. The [default wrapper](https://github.com/crawford/nap/blob/master/nap.go#L20) is what generates that structure. I need to write some real documentation for this... I agree with your point about the code being redundant and it should probably be removed.
Run your build with -v to see if it's rebuilding dependencies. I've noticed that under some circumstances (not sure what triggers it, alas) Go will rebuild some dependencies every time you build. Nuking the compiled package tree seems to fix this for me.
Ah, interesting! Can you set the req.ContentLength with your approach? Edit: just saw you pass the size, so I guess that's a yes. Cool!
I believe fmt.Fprint(...), or any fmt function, has a lot of overhead compared to echoing some static ASCII text.
Try not using fmt. w.Write([]byte("hello"))
Sounds like a prime use for table driven tests. var regions := []string{ "NA", "EU", "FOO", "BAR" } func TestSomething(t *testing.T) { for _, region := range regions { //test here if &lt;failed&gt; { t.Errorf("Failed testing Something for region %s", region) } } } Same number of tests, but now they test 4 things each. Make sure you log the region that you were testing in any of the failures or you won't know which one caused the problem.
You might have a compile error in your gopath? or in one the the tests?
This is something I had to start doing as well. The testing package doesn't provide anything as succinct as 'assert()', and Go's 'val,err' idiom makes it hard to accomodate tests cleanly in such a fashion. Running data through a table seems to help this tremendously. For more advanced tests, it helps to use a map to plumb the expected test results to the test as well. This works well with strings, and even structs, thanks to Go's inline declaration syntax. for k,v := range map[string]string { "HELLO": "hello", "World": "world", } { result := strings.ToLower(k) if result != v { t.Errorf("Expected '%v', got '%v' instead", v, result) } }
That's actually better than I expected. The first test is around 53% of NginX's performance, and the simpler test is around 64% which is pretty good considering NginX is written for speed, has been optimized over many years, and may be doing all sorts of tricky, unsafe-if-done-incorrectly, memory tricks that C allows, and Go explicitly disallows. I'd expect this to get closer over time, but NginX is generally regarded as very fast, and Go's inbuilt HTTP library may never match it for speed.
This is fantastic! By any chance is there an opposite of this? I'm working on something that would require me to call Ruby code from inside of a goroutine. I'd like the same mechanism (child processes).
It's not DRY so that indicates that you should do it a little differently. As other said, table driven would work and you can do that with either testing or fancier testing suites.
Hi, I've built something extremely similar to this a while ago. A few things I did that I think you didn't: 1) the signature of the handler is Handle(w http.ResponseWriter, r *http.Request) (interface{}, error) So you get direct access to the response writer, so you can write explicit headers, or streams, etc. I've implemented an internal error struct that implements the error interface, which makes forwarding errors from the handlers upwards simpler. The main handler checks the error type, and if it's our framework's error type it copies the code and message to the response. If it's a generic Go error we just create a 500 error with the message. 2) I made a request handler interface that has pre-processor and post processor. I'm using composition for a standard pre and post processors for request handler that can be overridden. This is used to enforce caching headers, validate input, etc. The interface looks like this: type RequestHandler interface { Handle(w http.ResponseWriter, r *http.Request) (interface{}, error) PreProcess(http.ResponseWriter, *http.Request) error PostProcess(http.ResponseWriter, *http.Request, Response) } notice that if the pre-processor returns an error we don't approach the handler function. This can be used to implement authentication, etc in a uniform way. 3) I used Gorilla's schema module to all automatic input assignment and validation. I've also generated basic documentation using reflection and struct tags. EDIT: 4) I've added internal processing times as part of the basic response object, measuring the time it takes to run the handler. 
It's not redundant if you want fine grained, application specific codes. But in most cases what HTTP has covers your bases so it's indeed not needed.
As far as I know, GC is only scheduled when you allocate memory. If you never allocate memory, the GC would never run.
Oh I'm just thinking of a proof of concept program; it doesn't have to do anything useful. It could just be an empty main().
My intuition is that that's not true. Almost every program allocs stuff, so adding the overhead to the allocator required to register "I just performed an alloc" wouldn't be worth it.
That'd probably work. No allocations in an empty main thus no deallocations. 
I've personally been using https://github.com/Sirupsen/logrus happily. Writing a custom formatter is straightforward, and it's been a pleasure to use out if the box.
The GC is run from the function that allocates memory. http://golang.org/src/pkg/runtime/malloc.goc#L173
Did the test - only a little bit better 91836.18req/s The full log at http://pastebin.com/0KDECX0N
I have also posted the question on go-nuts https://groups.google.com/forum/#!topic/golang-nuts/YIlpcoUPY_M
Besides, who doesn't like logging in zalgo, right? The ops teams love me.
If you're looking for rotating logs, may I suggest https://github.com/natefinch/lumberjack ? It's sole purpose is rotating logs. It plays well with any logger that can write to an io.Writer (including the standard library's logger). Lumberjack is v1.0 and has a stable API, so there's no need to worry that it will change and break your code. That being said, it's just one part of the logging infrastructure, it doesn't provide formatting or levels or anything like that. Something like logrus or the standard library would be needed on top of it.
Well, it's good but it only rotates over size, what I'm looking for is more likely working on time periods. Thanks anyway.
log4go does the same thing with more functionality.
I let logrotate handle that for me, or rolling your own would not be very difficult. I very much prefer having my logging system not be tied to "files", because doing so removes a lot of flexibility.
So, it's interesting, I actually started off writing Lumberjack with the ability to rotate both over size or time periods, but the more I thought about it, the more rotating over a time period generally didn't make sense in the real world. Think about the extremes - either you're getting very little logged, let's say 1 meg of log messages per month. Why bother rolling over? Why not keep the old data until it becomes bothersome? In the other extreme, if you're getting 10 gigs per day, you don't want to fill up the disk just because your rotation schedule says rotate once a week. Generally rotation is to avoid filling up the disk, which is why lumberjack only rotates based on size. That being said, I don't know your use case. And if you want, you can write a little code on top of Lumberjack to rotate based on time, instead (since it exposes the rotate method). Or, of course, you're welcome to fork it and make it work the way you want.
One use case I can think of is you can omit the date from your logs and just put the time if you rotate daily. If you are generating a lot (for some definition of "a lot") of logs, it could make a significant size difference.
If the date in your logs is causing your logs to be too big, you should just zip your log files. Conveniently, lumberjack is totally compatible with the std lib's compress/gzip library: log.SetOutput(gzip.NewWriter(lumberjack.Logger{/* config */})) 
They're not similar at all, take a closer look.
It looks interesting, but man, the documentation is horrible. I can't really condone use of a package that doesn't at least document all its exported types, methods, and functions. For example, what level does Printf log at? What does IsTerminal actually do? What is Termios for? When would I want to create an Entry? Sorry, disqualified. (for me... note I am not the OP) 
I was looking at segmenting GC pools to shorten the GC time. This means running separate processes in Go, to get a separate GC pool for each and doing some kind of RMI/RPC between them. Then if you know that one process has a fixed working set, you can specifically disable GC on just that one process. (And then carefully watch its memory use in case you have a bug.) So that way you can guarantee that something doing critical work (e.g. audio generation) stays responsive.
I checked and I also get half the speed of Nginx. [Nginx] Requests/sec: 31780.82 [Go FileServer] Requests/sec: 16088.43 Here is my detailed result. https://gist.github.com/yosssi/4d719cccdf185259ea1d My result of Nginx is shown at `1. Nginx` and one of Go FileServer is shown at `4. Go with a file server`. And I created a Go file server which can cache file data. https://github.com/yosssi/go-fileserver Its performance is the following: [Go Cached FileServer] Requests/sec: 25581.43 This is shown at `5. Go with a cached file server` on the above gist file. Its performance is still lower than Nginx's. And I changed Go Cached FileServer to use `io.Copy` instead of `http.ServeContent` at the following line: https://github.com/yosssi/go-fileserver/blob/master/file_server.go#L48-L49 Its result is below: [Go Fixed Cached FileServer] Requests/sec: 59517.07 This is shown at `6. Go with a cached file server which calls io.Copy instead of http.ServeContent` on the above gist file. This version of the file server is super fast and faster than Nginx. Perhaps `http.ServeContent` (http://golang.org/src/pkg/net/http/fs.go?s=3310:3414#L103) might have a problem concerning performance. I will continue to investigate.
I'll grant you, he's technically using technically wrong there. You are technically correct, best kind yada yada.
I really like http://github.com/op/go-logging
A simple logging package in Go: https://github.com/cenkalti/log
&gt; Besides its formatters are awesome, still doesn't provide solid support for rotating logs. Should be pretty easy to combine it with github.com/natefinch/lumberjack. Lumberjack implements io.Writer and logrus' Logger uses an io.Writer.
You could use the same technique in Ruby. All this is doing is wrapping a RPC API.
Looks interesting for bigger projects.
Go's Andrew Gerrand said I was correct, so that's all I need :)
I'm partial to my own, log15: https://github.com/inconshreveable/log15 There is comprehensive documentation: https://godoc.org/github.com/inconshreveable/log15 You can write custom formatters and custom handlers with just a single function, and it attempts to be very batteries included, despite its minimalist API.
Nice.
Some deployment issues. I expect it to be updated this week.
rpc seems a bit odd, anything like an "inline go" option? :)
man that is just dang fast, nginx is "screaming" and go almost keeps up with it? nice.
Is there a blog that summarizes these results?
I tend to work on web services and other long running processes that run on their own, serving requests. If something is reported as having gone wrong I need to look back in time to figure out what happened. Log files are great for this, assuming thought was put into the code to log out relevant information. It's a place to dump out a bit of data and a timestamp for the benefit of the person trying to figure out what happened at 2:00AM. You could certainly do this with with a database, queue, email, etc., but logs tend to win out because the are on the local filesystem. When things are going bad, that tends to be more reliable than a DB connection or something. Another common use for such logs is analytics. With a simple grep through a directory of log files one could get a general idea of how many errors or something are occurring. There are entire products like Splunk that are made for reading in such data and performing complex analytics.
How did you miss the obvious name, "banish"? :D
Hey , I have been working on this small router longer than I would like to admit. It has taught be a lot about go and I rewrote it like 4 times from scratch as I learned new things. I would love constructive feedback and also hope to keep adding onto it. I have left pretty good comments for anyone looking to change stuff. 
This'll have way too many allocations.
Look great.
If the standard libraries / language doesn't work, then usually this means that you are doing something wrong somewhere else. e.g. I'm not sure, whether taking a region/id for each call is the best way to do it... something like this, might be better... type Location { Region string Id string } func(l Location) Call() { } Also see [HowToAsk](https://code.google.com/p/go-wiki/wiki/HowToAsk); it's hard to give any good suggestions, if I don't have the complete understanding of the problem.
hehe it actually came to my mind, but I ended up choosing Vaban ;)
[Here's](http://play.golang.org/p/AdZ6iXaqsI) my code golf version. Someone on HackerRank has a shorter version though.
upper.io/db is not a full-featured ORM, and thus it does not impose any hard restrictions on data structures nor automatic table creation, indexing or any additional magic, it just manages the most common operations so you can focus on the complex stuff.
Another clever trick is printing indentation using the Stringer interface. It's not my creation; IIRC Rob Pike tweeted it quite a while ago. http://play.golang.org/p/22vTcFC1g9
Nice! Here's my go at a concurrent one: http://play.golang.org/p/BIb00hIF1S I was gonna have three independent goroutines just sleeping for various times with no interaction, but I couldn't get reliable timing on the playground. 
Umm, did you implement pattern matching in go? that's kinda wicked. I love it. Also love this type of post for this sub to get more interaction.
Try to use gccgo compiler with -O3: go build -compiler gccgo -gccgoflags "-march=native -O3" -o bin/server src/main.go
If you don't have strange Cgo delendencies that are near impossible to set up under osx or windows, the VM seems really useless.
Well the VM closely mirrors our production environment (CentOS, MySQL, Nginx, etc). So we use it for some basic tests as well. Is it useless? No, I don't think so. Overkill? Perhaps.
Sublime Text or vanilla vim + boot2docker on Macbook Air. Nothing fancy.
I am using the vim to write my code, and create some container(Docker) to run code.
I generally hate bundles, but https://github.com/fatih/vim-go is a wonderful setup out of the box. It bundles some crap in there I wish it didn't, but more good than bad. We recently have been banishing the last of our ZSH scripts to make it work entirely natively on all platforms, and if we find any specific issues, we abstract them to keep it working on all platforms. 
No, I don't even think it is an overkill. I do the same thing, have a Vagrantfile with me everywhere so that I can literally "test in production". It is not only a good practice but also saving you time in the long run. 
This is a really useful example of how to build a go web app. Now when people say 'don't use a framework' - I know where to look for ideas.
What are these `craps` ? :)
Just updated today! https://twitter.com/golang/status/481506143135473664
Where can I find gin? I must not have the right google query.
Even so, ncurses bindings may be the way to go. It's a mature library and covers many more corner cases than you might initially think.
Why not use newlines instead of semicolons? It'll be the same length and much more readable.
Thanks for hint, but it even got slower - 60563.36req/s
I use Sublime 2 and Digital Ocean's VPS. I am sharing workspace directory with my Windows 8 using dokan sshfs (it mounts VPS directory as a network drive) Works great so far... When I have something simple to test / write I just use my Go installation in Windows. I also use Github's account to store my codes. And Xshell 4 for ssh sessions.
May be right, I'm reading about ncurses usage right now. But I'd be more than ok with ignoring some dusty old edge cases for a nice and smooth tui lib :)
"golang gin" yeilds what you want via a tweet -- https://github.com/codegangsta/gin
ncurses bindings are a dead end IMO—much better to wrap termbox with the primitives you want.
What about your build process? Do you use a simple go build, or make file, etc?
Compiled, fast, pragmatic for OO, backed by Google.
Using Closures http://play.golang.org/p/ZdogZpRJEB
Actually, I wasn't even referring to the "dusty" ones, I mean the perfectly normal ones, like "title longer than the space to hold the title" and (hundreds of) things like that.
An editor (gedit / nano / ed), a shell (ksh93) and git for version control.
I don't remember why I did that last year, but I think hackerrank considers newlines to be \n or something. Either way, just fmt it.
The problem is when people say "don't use a framework" they never define what they mean by "framework". Go's net/http package is technically a framework: it provides the building blocks. There's also a big difference between a "big" framework like Revel (which I personally dislike) or Beego, something like Martini (which sits in the middle), and the smaller, composable frameworks like Goji or gocraft/web. Tight coupling isn't always just downsides, either: for example, for gorilla/context to be portable across routers, it needs to use a global request map, locks and you need to explicitly wrap your handlers with context.ClearHandler (if you forget, it leaks). In contrast, Goji and gocraft/web can do proper per-request contexts without any global maps because their routers take care of it. Both of their routers &amp; context implementations are faster than the two Gorilla packages combined too, at the slight cost of being harder to swap out later. Goji is compatible with the http.Handler interface though, so swapping it out (for whatever reason) isn't much work. If you can use a simple, composable framework that is compatible with http.Handler, do it. You'll save yourself reinventing the wheel, you'll still learn from the process (writing middleware handlers will teach you most of what you need to know), and you'll likely end up with a cleaner API to test against too. /endrant
I didn't dig into the code to deeply but i did send you a pull request with some spelling / formatting suggestions. How are you liking working with Golang so far?
some advice on the router, before match you should handler the path first. it will improve your performence much better. you can write some benchmark on your own router. it's a good way to learn Go that writer the router.
That was helpful. Thanks
With gin I generally don't need to even do that. I just fire up gin and it will detect when a file has changed and then fire off 'go build' for me. 
A couple issues: 1. You will only ever use one cpu because of runtime.GOMAXPROCS(1) without changing it you won't see much improvement because the workload is mostly CPU bound. 1. Your code is creating a ton of go-routines, each one has a stack and other memory associated with it and with the number of iterations in the loop you will run out of memory pretty quickly. Here is a version that completes, uses more than one CPU, and uses under three megs of memory on my laptop: https://gist.github.com/danieltoshea/b29f7d3487cb54aaa8a8 Please note this was the simplest refactor I could do to your code, that uses a fixed number of concurrently running go-routines. For more info on ways to approach this type of problem I recommend : http://blog.golang.org/advanced-go-concurrency-patterns the related articles are also good. Best of luck!
I was just looking into doing some benchmarks today. Thanks for the advice on how to handle the matching I will be working on that next can't believe I didn't think about that!
vim + [fatih/vim-go](https://github.com/fatih/vim-go), [gvp](https://github.com/pote/gvp), [gpm](https://github.com/pote/gpm), [gvm](https://github.com/moovweb/gvm). started using docker recently for testing, as it's a lot easier to spin up a docker container than a full-blown VM. 
How are compile times on the pi? I know go compiles really fast, but the pi is quite slow.
Why pass in the feed variable as a pointer? It doesn't create a new feed variable for each iteration so you are still have the current value from the outer function passed to the inner function. Maybe I need sleep.
Ah, "edge cases". Got it :) But seriously, I'd expect a terminal ui library to handle those, that's what it's there for, isn't it? Maybe the user can even specify weather the text should overflow, be wrapped or cut off.
That looks rather interesting, I wonder how it handles resizing. I'll have a look at it, thanks!
This looks like a race condition, not a closure problem.
You do need sleep :) &gt;It doesn't create a new feed variable for each iteration Except it does. 30 for _, feed := range feeds {
I use Vim, with vim plug-in from golang installation and vim-autoclose.
I haven't used docker before, what are the pros of using docker to run code. Could you point to any link, which would get me started with Docker for testing go programs ? Thanks 
Linux, Sublime Text, Git. I don't can't see any way to improve upon my current env for what I do (I'm a researcher). Most of my code is written, run for a few months, and then hidden away never to be used again/
I don't like how this package is named "`main`". It should be a proper Go package and `test.go` should probably go to an `examples` dir.
They're not bad at all, but clearly not as fast as a high end workstation. Go in practice is quite fast and does a good job of masking the Pi's limited cpu power.
&gt; // Receivers should only be pointers if the method modifies the receiver. A &gt; // *Example can still call a method with the receiver (e Example). I tend to disagree with this convention. Where does this actually come from? It makes sense for those simple types but for a decent-sized struct, what is the problem with always using a pointer receiver?
Agreed. The Go FAQ has [quite a lot to say](http://golang.org/doc/faq#methods_on_values_or_pointers) on pointer vs. non-pointer receivers. My personal policy is that receivers should generally be pointers unless the type is a slice or map.
It certainly is. You race to use a closed-over variable in the goroutine before the closing loop has a chance to modify it. However, I think the author has a point in calling it a closure-related problem, since the code looks more or less idiomatic. Of course, there's never anything obvious about a data race. Edit: the core problem here is the subtle difference between a closed-over variable vs a properly captured one.
Take a look at: https://github.com/nsf/termbox-go (a pure Go implementation of termbox)
Although this idea is quite nice and the design is functional, there are two issues for me: 1. This change is backwards-incompatible as existing code might expose packages whose path contains a component named internal. Adding this feature would violate the go1 compatibility promise. 2. People might start to do this thing where they hide their useful API inside internal packages because they they either believe exposing only a minimal API is proper software design or because they believe nobody is going to use the low-level API anyway or for other reasons. As a solution to the first issue, one might use one of the disallowed characters for import paths (!"#$%&amp;'()*,:;&lt;=&gt;?[\\]\^`{|}) as a prefix meaning "this package is internal". Such a solution is a bit uggly IMHO.
Isn't there a 'go get' convention for tagging a repo? I seem to recall that it will look for 'go1.3' or somesuch, so it knows to grab that changeset (and not 'HEAD') for that version of the go compiler.
Yes, golang-dev, but all such concerns have already been discussed and quelled. :)
I don't read golang-dev. They volume is too high for my inbox and the online interface of Google groups is just horrendously broken.
It's all about filter rules. But we don't have all code reviews go to golang-dev anymore so it's much more followable than it used to be.
Read the Document link Nomer posted and you can see it will only create a single variable. I've had this type of bug in my code several times before I learned the lesson.
2 is not particularly relevant, such people would already have privatized all that stuff anyhow. Now they can just organize it better. &gt; either believe exposing only a minimal API is proper software design or because they believe nobody is going to use the low-level API anyway or for other reasons. You say this as if it's obviously a problem, but I'd disagree that it's obvious. It is only _sometimes_ a problem, and is merely one of the huge number of dimensions one must analyze a package on before deciding to use it. Personally I've been working as hard as possible to produce as minimal a public footprint as possible in my code releases, basically striving to make the fewest possible tokens show up in the godoc. Do I _need_ this public function? Do I _need_ this parameter? My theory is that since it's source anyhow, if you need to crack open the abstractions, you know where to find them, and in the meantime, the _average_ user of a library does not need or want to be confronted with anything they don't need to be. The balance is different when distributing binary libraries, but for source I think this works pretty well.
Thanks i'll take a look
Thanks for the help. so you are building up the buffer with a zero byte struct (struct{}{}), and once the buffer is filled it is blocked until it is freed with &lt;- buffer correct? Seems to run slower than just running one proc with no goroutines. I'll be watching the video from above and reading the blog you provided and provide an update. Thanks again.
Your handler signature ([]byte, int) seems simplistic. How do I set a response header (like Content-Type or Cache-Control) from within a handler? Recommend sticking with (w http.ResponseWriter, r *http.Request) Also, var Param appears to be global and mutable which may cause weird collisions when you start handling requests in parallel.
This strikes me more as a documentation problem than a visibility problem. There are public functions in the standard lib that have "FOR INTERNAL USE ONLY" in their docs. Change godoc so that public functions flagged as internal don't show up in the output docs.
I also really like Dave Cheney's proposal, too: https://groups.google.com/d/msg/golang-dev/_cAggq73yME/6G5-NrDCgRwJ
&gt; believe exposing only a minimal API is proper software design Well it is. Complete and minimal is the way to go.
&gt;&gt; believe exposing only a minimal API is proper software design &gt; &gt; Well it is. Complete and minimal is the way to go. While your statement is true, people tend to ignore the "complete" aspect and provide small APIs that only cover some of the common cases, making it hard to use the library in corner cases. Sometimes it's important to be able to look under the hood.
nice, simple, pragmatic the Go way to do things, and I like it
1. It's not a language change. The spec remains untouched. It's a change in the build tool. &gt; disallowed characters for import paths (!"#$%&amp;'()*,:;&lt;=&gt;?[\]^`{|}) You can't put most of these in a directory name.
&gt;&gt; disallowed characters for import paths (!"#$%&amp;'()*,:;&lt;=&gt;?[]`{|}) &gt; &gt; You can't put most of these in a directory name. Then use one of them that can actually be put in a directory name (like = or !)
If I put an upper-case-named value in an "internal" package, I assume that even though others would be unable to import it, it would still be a public value, right? One use case I would have for this is making it so values made public strictly for encode/json or some other similar thing that needs public values is not cluttering up my godoc or letting users penetrate abstractions simply because they current _must_ be able to see my internal serialization details.
While I am not a Google engineer, this is also what I speculate as the origin of this convention. I do break this convention with larger struct types because it is cheaper to pass a pointer than make a copy. I added this to the documentation in the package.
Correctly me if I'm wrong but isn't that the behavior of any closure implementation? It's called closure exactly because the external scope's **binding** is visible to the function, not a copy of each variable for when the closure was created/defined.
I'm working on a graph database in Go as well. Glad to see others using Go for DB systems.
If you can find documentation for this, please message me or create a pull request. Thanks :)
Although I appreciate the work, is there a reason someone should use this over Go's https://godoc.org/code.google.com/p/go.crypto/nacl/secretbox package? Also: `rand_str` potentially has bias. You are better off just reading the raw bytes straight from rand.Reader and base64 or hex encoding the result instead of coercing it. I wrote an article on how to do this properly: http://elithrar.github.io/article/generating-secure-random-numbers-crypto-rand/ func GenerateRandomBytes(s int) ([]byte, error) { b := make([]byte, s) n, err := rand.Read(b) if n != len(b) || err != nil { return nil, fmt.Errorf("Unable to successfully read from the system CSPRNG (%v)", err) } return b, nil } func GenerateRandomString(s int) (string, error) { b, err := GenerateRandomBytes(s) if err != nil { return "", err } return base64.URLEncoding.EncodeToString(b), nil }
As a Java developer, I suggest that Go should not predicate their design decisions on the actions of Java developers. 
I was a bit lazy and used someone elses code for the random string as stated in credits sadly. Thanks for the read. I will look into it and hope to use it in my future works!
Agreed that it was mainly bad developers. Any java developer that actually read about the language knew not to use sun.* packages. Eclipse and other IDEs would even warn devs against doing it. But people still will use any API available to them. It's really about trying to minimize the ways a dev can stab themselves in the foot for not reading the docs. If the compiler/runtime can enforce certain behaviors, it's better overall. I see it similar to to iteration order of a map in Go. In pre-1.0 Go, order iteration of a map was predictable. But with Go 1.0 they randomized to order to make sure no one depended on it, as they plan on an implementation later where the iteration will be random due to implementation (instead of just the pseudo random it does now). See [bug 2630](https://code.google.com/p/go/issues/detail?id=2630).
Always comical how the little anarchist wants total control but then ends up using tooling written by somebody else. 
&gt; they randomized to order to make sure no one depended on it Another solution could be to randomize the API of internal packages for external users.
Note that the two links in the second paragraph both link to fail2rest, here's [fail2go](https://github.com/Sean-Der/fail2go).
Its good to bring students to learn and understand about new technologies, Good One.
I am using https://github.com/juju/loggo really nice hierarchical logger in a similar vane to log4j but without all the junk. There are a couple of log rolling libraries around as well such as https://github.com/mipearson/rfw Best logging is simple and minimal in my view, tools like logrotate do a great job of archiving and deletion.
Thanks for catching that! Fixed my post
Do we really need "internal" package? to me, it is a problem of organization. instead of hiding internal package, we might just organize them and call them a new library. making no private packages forces developers to organize code carefully.
I don't understand this. Care to elaborate?
First read this [CodeReviewComments](https://code.google.com/p/go-wiki/wiki/CodeReviewComments). Then `func (conn *Fail2goConn) JailStatus(jail string) (int64, int64, []string, int64, int64, []string, error)`. Don't use `Fail2goConn` use `Conn` the package name already contains `fail2go`, hence the qualified name for the type can be `fail2go.Conn`. `(int64, int64, []string, int64, int64, []string, error)` use named returns, and don't return so much values from a single function, use a struct instead. `fail2banInput := []string{"status", jail}; fail2banOutput, err := conn.fail2banRequest(fail2banInput)`, there's no point in always specifying `fail2ban`, it's obvious from the package what you are dealing with... something like `in := []string{"status", jail}; out, err := conn.request(in)` is sufficient. If you find prefixing something a lot, then you are probably naming things badly. &gt; Is there some sort of library that could walk+cast for me? The encoder/decoder should usually do it instead. But for some reason that ogorek, doesn't... and there isn't another available. You can write something like: func index(v interface{}, idxs... int) interface{} { var ok bool for _, i := range idxs { v, ok = v.([]interface{}) if !ok || i &gt;= len(v) { return nil } v = v[i] } return v } val, ok := index(v, 1, 2, 4).(int64) And always check the "ok" value, otherwise you'll get a panic. &gt; For assertions should I just use the reflect pkg? If you have a *question* whether you need reflect, the answer is no. If you *think* you need reflect, the answer is still no. If you *know* that you need reflect, then the answer might be yes. &gt; When serializing JSON I just call json.Marshall on a map, is this going to be overly costly or a bad idea? When in doubt, measure. I would just say that it doesn't matter performance wise. &gt; Makefiles ok? Generally, no. For big projects, you might need one (but then the script will do a lot more, e.g. cross compilation, version tagging, adding optional libraries, embedding files...).
Really love it, great job. The settings package is really nice. There are a lot of good ideas and practices in this project, I hope it will be an inspiration for go beginners. Regarding the managers (ex: UserManager), we are using exactly the same idea in Gemnasium API (we're calling them datastores, but the principle remains the same). We should probably blog about this, as it's very hard to find resources (at least in golang) on this subject. This approach enables us to switch datastores for fake ones for testing, so we don't need to touch the DB for unit testing. Using build constraints, we can switch back to real datastores, and have acceptance testing running longer (during the night for instance).
You should never, ever write any public packages for crypto stuff, if you are being lazy... alternatively put a big red notice on it that "it has not been through a security audit and is for experimental purposes only". Dealing with crypto requires attention... HeartBleed already showed what happens, if you don't pay attention and don't have good practices. The main problem is that someone can pick-up the crypto package that you wrote and use it as if it were secure.
Great that for you being able to call a method is full on anarchy. I bet you only call 2-3 methods that your mum picked up for you
there's https://github.com/gabriel-comeau/tbuikit but the author seems to have abandoned it
Line 25, ignoring the error. Line 28, ignoring the error. Line 40, Line 44, dialing twice? Why? Unbounded goroutine growth, you should use probably use a connection pool. Not closing your connections. Here is an example that allows you to use the same `DialTimeout` connection for the SSH session: https://gist.github.com/alexzorin/8a4320eae3c9c0af5aa5
The Go sessions listed on the schedule this year are as follows: "Organizing code and managing dependencies", "Testing technique", "Making your code faster: benchmarking and profiling", "Sourcegraph: A code search engine in Go", "Authentication and third party APIs" In the past almost everything eventually ended up on youtube (even if they were not shown live on youtube from the event). There are a lot of videos up already, but they all look to be "IO Bytes", which seem to be small-form stuff, not the recorded sessions. Hopefully the Go sessions will be recorded and posted in the next few days.
Oh you are absolutely right! I was too busy looking at live ones. Indeed let's hope they will end up on youtube. Thank you very much.
Thanks a lot, and I agree that it was not very smart to ignore the first errors (line 25/28), I must have been lazy. The reason for dialling twice was to use the DialTimeout method that I did not find the ssh package. I had actually no idea you could even reuse that connection with ssh.NewClientConn. Closing the connections is of course a good idea, another newbie misstake I guess :) I never thought about using a connection pool, but it sounds like a good idea. I will try to find some documentation on that and improve the code a bit more. If you have any recommended books/sites to read its more than welcome. And thanks a lot for the gist example, I am learning new things every day. Being a Devops/Sysadmin, Go is the first language apart from Python that I really enjoy learning and using!
What problems are you having, specifically? Many of those issues are shared with DB packages in other languages too. Chances are you won't run into these in most use cases anyway. Using http://jmoiron.github.io/sqlx/ will help simplify a few things. 
It's worth noting that to answer the question I went digging in the source code for the SSH package: https://code.google.com/p/go/source/browse/ssh/client.go?repo=crypto#186 I've found that Go's library source code is usually very easy to read, in contrast to a lot of other languages. Many times the docs are insufficient to give you an answer.
I've asked @golang, so we'll find out: https://twitter.com/dgryski/status/482066189234241537
Cute name :)
Thanks again, I would not have thought of the idea to dig into source code of the SSH package itself. But its true that it was much more easy to read than I first thought it would be.
Have a look at Rack's api http://rack.github.io/ Request goes in (aka ENV), response is in the format [code, headers, body] Pretty standard for WSGI style frameworks
Ask on the go-dev mailing list/search the Go issue tracker.
You can also mix and match... func() (important string, uninteresting Info, err error).
&gt; does they implement __this__ in future. After several readings of your post, I still have no idea what "this" is. May I also just register a HUGE NOTE of concern with the combination of "We are trying to implement a wallet project. which stores and manage _cash_.", "How do I use a database in Go?", and "When I (or worse, _WE_) couldn't figure it out we just used another language". You do not appear to be at a level where you should be writing code to manage cash. Sorry if that sounds harsh. But stopping now is better than the pain you're going to feel later, pain that may include legal pain, and possibly literal jail time for you personally (a longshot, but not a long _enough_ shot that I'd be comfortable with it). Run. No joke. Run. You are not getting compensated enough for the risks you are taking, whether you realize those risks or not. Do whatever it takes to find another job. By the way: Compare [this](https://news.ycombinator.com/item?id=2974770) (my post) with [this](https://bitcointalk.org/index.php?topic=97272.0) or [this](http://arstechnica.com/tech-policy/2012/08/bitcoinica-users-sue-for-460k-in-lost-bitcoins/). This is real shit. _Particularly_ compare those posts if you're being coy and not mentioning that the "cash" in question is BitCoin, which I expect is moderately likely.
And the official response is that they are being recorded and will be available later: https://twitter.com/golang/status/482236088023404544
There are 15 sessions that are listed in the "Developer Sandbox: Go", * Organizing code and managing dependencies * Testing techniques * Making your code faster: benchmarking and profiling * Camlistore: Android, ARM, App Engine, everywhere * Building a web app on App Engine * Sourcegraph: A code search engine in Go * Authentication and third party APIs * Building a web app on App Engine * Sourcegraph: A code search engine in Go * Authentication and third party APIs * Camlistore: Android, ARM, App Engine, everywhere * Go compilation complexities * Organizing code and managing dependencies * Testing techniques * Making your code faster: benchmarking and profiling
As screencasts: https://twitter.com/francesc/status/482260176225857537
Are you testing with Go Playground or with Go 1.3? The new release adds a faster single pass regex parser for simple ReGex scripts.
I'm using 1.3 and will give the regex a try. Thanks!
 // and should be in the form of "Package pkgname ..." and "ExportName ..." // respectively. package conventions later // Last in a file should be a main func. This func should only be present in a // package named main to generate a binary file. func main() { (╯°□°)╯︵ ┻━┻
Misleading title. The code above has nothing to do with [routing](http://en.wikipedia.org/wiki/Routing)...
The analogous situation would be the inability to build against a third party implementation of the Go standard library, right? Is there any danger that anyone will write such a thing? :/ The only similar problem that seems likely to actually arise in this way is build issues for those using fast moving and possibly broken APIs in the walled-off portion, and the consequences of their actions falls squarely on them, so I don't see any real issue.
hey that's me! yeah I'm excited for them
Note that it's [gender](http://en.wikipedia.org/wiki/Gender), not [sex](http://en.wikipedia.org/wiki/Sex_(disambiguation\)). You should also include an other gender for binary non-conforming people. Also in my opinion using they instead of he/she is better.
It's not really a pitfall of closures in Go, it's a pitfall of closures in general. eg. javascript has always had this issue: http://jsfiddle.net/a73Mr/1/ 
Just a question but i was looking and it seems that in go I can't test if something exists in a map without iterating though it. What did you have in mind?
Looks neat - well done :)
Wow .. That was fast. Can't wait to play with it.
I was just thinking about API documentation today and looking at Swagger, Apiary.io, Mashery, etc. Seems to me like each of them has their own DSL which can be used to generate scaffolding for an API. IMNO, I think that seems way too constricting for anything except throwaway experiments. I think a better approach would use integration tests to generate the API docs. Maybe godoc-like tool could look at any use of httptest.NewServer to deduce valid paths and responses. That way there would only be minimal special formatting in tests required to document external APIs. Then keeping API docs up-to-date would involve simply updating tests.
&gt; keeping thanks for your advice. but I also want to generate the test case based on the comments.
Thanks. Will change.
Interesting approach. I've been experimenting with something [similar](https://github.com/alecthomas/rapid), but the approach I've taken was to define the service through a DSL in Go and use that to generate a JSON Hyper Schema. The schema can then be used to generate documentation and client bindings. I'm still not 100% convinced it's the right approach, but I'm definitely sick of having to update my server code, client code and documentation for every change.
Now with a more intuitive filename structure (i.e. you pick a filename, lumberjack logs to that filename. Only backups have a timestamp embedded in the name.) Distributed using gopkg.in to keep backwards incompatible changes from breaking anyone.
And thank you for helping more women and kids get into tech :)
 import ( "github.com/joshuaboelter/mux" ) func main() { // the primary router router := mux.NewRouter() router.AddFilters(RecoveryHandler) router.AddFilters(MyLogger, SessionContext) // appended to the previous one router.HandleFunc("/health", GetHealth).Methods("GET") router.HandleFunc("/xyz", GetXyz).Methods("GET") // admin routes adminRtr := router.PathPrefix("/admin").Subrouter() adminRtr.AddFilters(AdminCheck) //only applies to this router (and only when it matches) adminRtr.HandleFunc("/something", AdminHandler).Methods("GET") http.ListenAndServe("localhost:8080", router) } func MyLogger(h http.Handler) http.Handler { return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) { start := time.Now() log.Printf("&gt;&gt; %s %s", r.Method, r.URL.Path) h.ServeHTTP(w, r) log.Printf("&lt;&lt; %s %s %v", r.Method, r.URL.Path, time.Since(start)) }) } 
I was really hoping this would involve real ice cream.
The Go booth where we did the talks was out in the main area / hallway and super loud. We had no microphones and everybody (us and adjacent booth presenters) were all yelling to be heard and people in the back still couldn't hear anything. It wasn't a venue to record anything. We'll have to do them again to get recordings. 
http://play.golang.org/p/Pqa0t1Y7L4 It is interesting to see that race condition does not seems to get triggered on the playground.
std::cout and printf() have default floating-point precision on output of 6 digits after the decimal point. Go Println uses "only as much as needed to be exact.", which is this case will be more than 6. 
The playground is single-threaded. The data race won't occur when if GOMAXPROCS=1. I just tried it myself on my own machine. ./benandjerry | grep 'Ben.*Jerry' prints nothing, but GOMAXPROCS=2 ./benandjerry | grep 'Ben.*Jerry' prints a bunch of "incorrect" output. A goroutine won't yield in the middle of a memory operation, so there is no way for that particular race condition to occur unless multiple OS processes are used.
There's two issues at work here. First, floating point is only completely accurate when its components are all multiples of powers of two. That means that regardless of C, C++, or Go, [they can't exactly represent 0.1f](http://www.wolframalpha.com/input/?i=0.1+in+base+2) as it has a factor of 1/5. It also means that extending the number causes the bits that aren't covered by the mantissa in the 32-bit float to be filled with junk. Secondly, what's being printed isn't an exact representation of the contents, either. There's rounding going on in all of the print instances, with some calls rounding more aggressively than others. Just to be clear, these aren't Go-specific problems: they are intrinsic to IEEE 754 and the fact that you can only use 32 or 64 bits to represent all the real numbers, which means you can represent at most 2^64 real numbers and the rest get rounded to the nearest value.
Go isn't a functional programming language, contrary to what you stated in your article. Also, I think its a bit unfair to compare Go's performance to Ruby's considering the two languages are in two different use categories. It might've been fairer to compare it to C, since throughout your article you touted it as a better version of C.
I wonder how many goroutines it would really take to lock up a system like this. 3 million sounds like a lot, but if he's only using a single core anyway they aren't being threaded so what would cause the cpu to crap out? Alright I got bored today and tried something out. Using Mint on VirtualBox limiting to 1 cpu and only 1028 memory. I'm creating three million goroutines that loop for a million times. The CPU is running fine, but my memory usage is causing my machine to swap about 1.2 gigs. Picture of code and proc explorer https://imgur.com/MqNyURZ
I don't understand why you would write games in go on android when everyones been writing games in c/c++ for ages. Many of the frameworks are c/c++. 
You keep saying "files", but files don't matter -- a package consists of all the files in a directory lumped together, where each one has a "package foo" statement (foo is the directory name). So you can't import a particular file, only a package, which is a directory. http://golang.org/doc/code.html &lt;-- this is the documentation you want.
You don't understand why someone would prefer one language over the other? I mean, the language may not appeal to *you* but can you seriously not see other people having a different opinion on that?
If you just want to split into files (and not packages), then you don't need any kind of import, at all, files inside the same package share the same scope If you want to reuse in multiple projects, put those things into a separate package, or a subpackage and just import. Generally in Go we don't import by relative path, only absolute, we don't have to import much actually.
Maybe some people enjoy Go more, or are more productive in go? Just a wild guess
For pretty much any reason you'd pick Go, probably thinking of things like safety, simplicity, maintainability; you could find any article discussing Go in a general sense and it would answer that question. There are SDL bindings for Go which is great for game development and SDL2 should work on Android.
Have you tried using Docker? Containers have a lower overhead than virtual machines, which is especially useful if you work on a laptop due to the reduced power consumption. 
http://www.pkgname.com/ &gt;✗ goop is a shit pkg name &gt;Don't mention 'go' in your package name. Go is implicit in any package. Go is absolute and infinitesimal. Other languages should rename their packages; for instance 'rails-ruby' and 'python-django' would remove any ambiguity.
It also doesn't like hyphens, but railsgoop or pythongoop would be fine.
In regards to problem two, you shouldn't really import something as "./mylib".. use the full go directory: import "github.com/username/mylib" otherwise you'll give errors on go get in the future on a different machine, or others will if they pull your code. 
I did it via running go install on each sub-package...then, I import the full path in each .go file I want to use the sub-package in.
Correct, we use the buffer to limit the number of goroutines running at any single point in time. Creating goroutines is cheap but not free, and the program is still creating far more than it needs to complete and the management overhead for those goroutines is pretty expense. Better approaches would be to pre-allocate and start a fixed number of workers and partition the search space between them. The less waiting the goroutines have to do on input the faster your program will run and the greater it's utilization of multiple cores will be. Best of luck!
How about this instead? "install" works right now, with other subcommands on the way. Dependency files feature options to dial in a commit, such as 'tag' and 'branch'. Basic semantic versioning for commit tags is also in place. https://github.com/eanderton/grapnel Edit: I'm working now on eliminating the external lib dependencies so you can build w/o needing 'go get' or a working grapnel first.
I don't know if its just me, but I find gopkg.in versioning model fairly sufficient.
pkgname is a shit pkg name tester. Things that should not be flagged: * gorrilla * logo * goal * congo * mongo * golf Things that should be flagged: * mongodbgo1 * mongodbgo2
That seems like about $26 worth of advice not 2 cents.
&gt;a package consists of all the files in a directory lumped together That's the part I was failing to understand. Thank you very much! And this means that I should put my reusable components in different directory, outside my current directory and that way I can use them in multiple projects. Right? 
but there is go get, so what's the point?
That's correct. 
why would you want this ?
pkgname is a tongue in cheek joke, it's not meant to be a reliable, 100% sure pkg name tester. Mostly, we created it to start a discussion, or make people think twice before using unoriginal names for their packages. This comment describes our thoughts perfectly: http://www.reddit.com/r/golang/comments/25uixa/choosing_a_good_package_name/chlef7y &gt; You know a language has hit maturity when major libraries and packages start being released that don't nervously stick the implementation language in the name, but just confidently go out there and name themselves something distinct.
Great job! Being Django-like, this looks very similar to what I've been slowly working towards with [jigo](http://github.com/jmoiron/jigo), but you've got a bit farther than I (jigo doesn't yet have a completed parser or a way to evaluate the ASTs it builds). The code even looks really similar. I'll be taking a look at how you approached different things as I go to implement more of the "jinja-like" spec I've set for myself!
cause c/c++ pita
Here's what I posted on r/rust: &gt; I'm going to play devil's advocate here. Go's design philosophy is to make programming easier and more fun by reducing cognitive load on the programmer. It's deliberately designed to be simple and easy to work with. All of the complaints here if implemented would make the language more complex and less in line with its design objective of simplicity. Whether you agree with that philosophy is a whole other thing. &gt; &gt;Rust to me has gone the other way - it's very feature rich which is exciting and provides some powerful features, but it lacks the simplicity of Go. As someone who uses both I'd say they each have their upsides and downsides. There's a lot to like about both approaches and each has its place. 
Go designers have made the decisions on each of these points for sure. I would love to see an official response on golang.org blog addressing these issues, and telling us is any of OP's concerns are invalid, and clarify the decisions behind the ones that are of legitimate nature. Also, would the legitimate issues be mitigated by Go v2? 
Well said. I fell in love with Go because I could so easily keep the whole thing in my head. After writing Go code for a few days, I was fluent, and I can stay fluent in it without writing it every day. My programming life also includes lots of C#, JavaScript, Python, Ruby, what have you, but every time that I return to Go, its just there. There are definitely times that I've cursed the Gopher and wished for generics, but I calm down and find another way around what I was trying to do. No big deal. And I think about the sweetness of defer and goroutines and channels and multiple return values...
The OP's concerns only matter if they matter to you. The Go team has countless times described their design process at every stage and they don't need to continually defend it from everyone with a blog. They're building a language; not a one-size-fits-all solution. Furthermore, Go v2 is currently not of any concern to the Go team. Should v2 come around, I'm guessing it'll answer the generics problem but nothing else - Go is not (and was never intended to be) a functional language. 
It's all about where you decide to put the complexity of writing a complex software. It could be in the language and in its requirements for "red tape": who owns this? Is it mine? Is it borrowed? Will outlive me? Is this immutable? .. or it could be in your code: dang.. I need to write a stack for my float32 matrix and a stack for my float64 matrix. Unless you are working on an airliner avionics controller (in that case, go for the SAFEST solution), where you decide to put your complexity is irrelevant.. it's going to be there anyway. 
Go has built-in support for unsafe code. It's called package unsafe. It's true that Go has no language solution to heap allocation, but the Go team has an escape analyzer to try and limit heap allocation. Does anyone know how portable that is, so, for example, could an alternate compiler could use the escape analyzer to avoid code duplication? I don't understand the point about type inference. How is Go's worse?
I find the concept that the Go team should stop what they are doing and take their time to come up with an "official response on golang.org" to a random dude that happens to like Rust more, and blogged about it, quite amusing. 
Rust (and Haskell) allow types to be inferred "backwards", i.e. you can write code that works like Python or Ruby: *Python* # create an empty list v = [] if some_condition: # and sometimes put a value into v.append("foo") *Rust* // create an empty vector let mut v = Vec::new(); // (no type annotation needed) if some_condition { // and sometimes put a value into it v.push("foo") } `Vec` is a generic vector type, that is, it can store any value inside it. For languages without "real" type inference, the `let mut v` line is invalid: the full type of `v` is not known because the type of the elements is not known. For languages like Rust and Haskell, the compiler "looks forward" to see how `v` is used, and can infer that the element type is in fact `&amp;str` (the type of string literals), due to the `.push`.
In what way? The languages are strongly typed, so you can't really get surprises: either the refactored code works as you expect or there is a type error. And if you change the code in such a way that the compiler can no longer infer (rarely happens IME), it will tell you, and you can just add an annotation. That is, explicit type annotations are optional, not illegal.
I'm a little puzzled by the design objectives that you list. When Go was first released they said it was designed for fast compilation of massive codebases. I don't remember much emphasis on the other stuff.
I'd like to see Go gain generics, option-types, and union-types, but it's hard to see how they would work with the language as it is today. For example, if you have a union of two interfaces and a concrete type that implements both interfaces, which of the union types is it considered to implement? On the other hand, if you restrict unions to concrete types, you can't do a union of result type with error type, which is one of the main uses of the union type. The interaction of option type and pointer types is also hard to work out. 
In Rust, does v become a Vec(string)? In python, v is a list of whatever object if my memory serves me correctly (which is similar in spirit to []interface{}). 
Yes, you are correct. (I was just meaning to compare code appearance, not the details of static typing vs. dynamic typing. :) )
IMO Go vs Rust is a great example of the ideas in the Worse is Better essay. Go is a classic 'Worse-is-Better' design while Rust is a 'The-right-thing' design. http://www.jwz.org/doc/worse-is-better.html 
Yea, understood, I just didn't know how it worked in Rust. Thanks for the elaboration.
Inference-at-a-distance gets annoying when intervening code changes. In your vector example, imagine you put some code between the definition of v and the v.push("foo"). If you, say, accidentally push an integer, you then will (presumably) get compile errors on the v.push("foo") line, which is nowhere near the code that you actually changed. One could concoct even more subtle examples due to type inheritance
Does anyone know how much of an effect these language features have on compiler speed? One of the primary goals of Go (in fact, I think it was the first goal) was to write a language that didn't have C++'s slow build times for massive projects. I could see the Go authors making the decision not to add, e.g., algebraic types, because the infrastructure required for them would greatly slow down the compiler.
You can write a few lines of [goproxy](https://github.com/elazarl/goproxy) to have a local proxy do that, without changing the code.
i think these all add complication. i can hardly imagine that will happen
It takes me around 10 minutes to rebuild the entire rust compiler from scratch. How does Go compare on similarly-sized projects?
To the untrained eye the Haskell and Rust code might look like he was trying to be as concise as possible, that's just what Haskell and Rust look like...
This is known as the waterbed model of software complexity. You can push down this corner over here, but it's just going to smush over into another corner.
Precisely my thoughts.
The best reference is Rob Pike's talk outlining the rationale for many of the design decisions that drove Go: http://talks.golang.org/2012/splash.article
I think, I get it know: By using goproxy as a proxy for all projects you would not need to change any code of the projects. But then you need to know every ressource you want to cache in advance or you simply cache all requests no going to localhost which might or might not be what you want. Most of the time I want to have a clear separation between CDN and non CDN ressource in the code (e.g. to be able to grep) and only want to cache the former, but that's just me. For caching every external ressource (to be completely independent of internet access) a proxy clearly would be the better choice.
Simplicity makes it simpler to reason about both: the performance characteristics and program flow. Lazy evaluation makes it hard to reason about performance implications. High level abstractions make it hard to reason about program flow.
BTW /r/programming is also having a good discussion on the same post. [here](http://www.reddit.com/r/programming/comments/29fp6w/why_go_is_not_good_will_yager/)
Heck, that title is misleading. The author ambushes the Gopher, and then tries to crucify the language.
Didn't quite get what the author meant in the embedded part. How low do we go? OS level, Realtime on an fpga, or as a vsdl type language? 
It's always generics. Always. Seems like everything else is flavor and/or "programmers aren't protected from X or Y mistakes". 
This is initial release of this very small web server for static content. But I believe it can handle a lot of traffic. Comments and criticism are more then welcome. 
&gt; m map[interface{}]struct{} I for one, appreciate the no-nonsense design of just using a map-backed store for unique values. Having structured access to types like this (Has(), Clear(), etc.) is nice to have and should yield some nice, clean code.
As an experienced developer, I tend to crave uber-flexible languages like Rust, D, or C++. However, when I consider which technologies to bring into a team in a corporate development environment, all those same features make me cringe since they make it impossible to keep everyone on a team writing code that everyone else can understand. The worst case is when seasoned greybeards start lobbing C++ template black-magic at problems, with the expectation that junior developers will come up to speed rapidly to maintain the very same code. Any sufficiently nuanced language reinvents the same problem on teams with mixed skill levels. In the end writing stable software in the large means using stringent language grammars, or stringent style guides. Quick understandability and discoverability plays a huge role here - junior developer or otherwise. TL;DR: It's like setting a reading level cap on a newspaper: it's about communication, not implementation.
A quick skim of https://github.com/fatih/set/blob/master/set_nots.go and https://github.com/fatih/set/blob/master/set_ts.go shows a lot of IMO, unnecessary duplication. I think it would be better to use a `Locker` interface like http://golang.org/pkg/sync/#Locker. To get a non-thread-safe version simply means creating a type that implements the interface using NOOPs.
But that's 2012, after they had decided to sell it add a mainstream language. It was released in 2009, I think.
Thanks for posting this essay. I enjoyed it.
But a lot of the ideas are visible even in the original internal announcement talk from October 2009: https://www.youtube.com/watch?v=rKnDgT73v8s
You have the gopkg version as v0...is the API still unstable?
You either have the wrong link or wrong title. This is the Go vs Ruby link: http://matt.aimonetti.net/posts/2013/06/23/using-go-vs-ruby-for-web-apis/
Interesting talk (but I like 'const' in C++!).
A note to gophers: There has been very little effort put into making the Rust compiler fast so far, as the focus has been on solidifying the language for a 1.0 release. There are several known ways we could speed things up, the work just hasn't been done yet. So any comparison here is bound to be wrong, from the start. Go's speedy compilation is awesome. :)
You're code doesn't work like you think it does. http://play.golang.org/p/lXrlaNrFHg It launches the go routines, and then sends a single bool over start. The main function go routine blocks trying to send over the channel. Then one of the wait routines starts, collects from the channel, prints, and closes. None of the other routines will get past "&lt;- start" because only one value was sent over the channel. The main routine will pick up from having sent over start, reach the end of the function, and terminate the program. (Also, since it's only one core, the busy work doesn't really do anything as far as measuring Go's ability to handle go routines.)
Do you know if this could work as a drop-in replacement? 
Just to complain a little, Google publishes a library called Gin (though it's for GWT). https://code.google.com/p/google-gin/ Gin is a GWT version of Guice (their dependency injection framework for Java).
Another Go web framework I starred on github and will probably never use. There are so many, I'm sticking to `net/http + gorilla mux` until things consolidate. I just can't keep up with all the new, shiny frameworks anymore. 
&gt; One could concoct even more subtle examples due to type inheritance Rust doesn't have inheritance.
&gt; Rust tries to avoid emphasising subtyping, although the language does have it for certain classes of types I think we can get away with just removing subtyping from the typechecker entirely, which would make this completely go away. (It's never been a problem in practice, of course, but it's theoretically ugly.)
Agree, I always seem to go back to my own little web framework that does what I need it to. 
The problem is the error messages are confusing. It's particularly bad with global inference in Haskell, where changing the internal details of some function can cause unexpected type errors in some other function, because the inference changes the types that are inferred. This isn't as much a problem in idiomatic Haskell (which has a lot of explicit signatures on function, rather than omitting them) or in Rust (since you can't omit function signatures).
I wrote the original article, glad it was of some use!
I've only scanned your post and haven't started working with it yet, but as both a rubyist and pythonista who is simultaneously excited and intimidated to move closer to the metal: thank you!
I don't see how that is confusing. You get the same error messages as if you changed the function signature in Rust or Go. But yes, this is non-issue if you adhere to idiomatic Haskell. But the example was not focused in function signature inference.
That original problem was just an *example* of error messages pointing at places you might not expect: you're using `v` *everywhere* as a `Vec&lt;String&gt;` (e.g. pushing multiple strings, passing it into `Vec&lt;String&gt;` functions etc.), and then a single push of an `int` causes it to flip to `Vec&lt;int&gt;` and the errors point at the `String` usages. In a perfect world, one would prefer that the error points at the `int` usage, since that's incorrect one. &gt; You get the same error messages as if you changed the function signature in Rust or Go ... Yes, that's my point: it's not a problem in Rust because it doesn't have global inference.
Also, one silly nitpick complaint, for the map, why not call it gin.M instead of gin.H, so its consistent with mgo? Also kinda easier to remember.
No, it could not. Despite the comparisons, it's not similar to Martini. (I think the OP [author] does himself a disservice by hitching his marketing to so many comparisons)
The name can cause confusion, because there's a [live reload utility for Go web servers](https://github.com/codegangsta/gin) by codegangsta, also named gin.
I hate to say it, but consolidate into what? There are different frameworks for different use-cases: Revel and Beego if you need everything and the kitchen sink, there's the micro frameworks (Goji, gocraft/web), and there's a bunch of components (the various Gorilla packages, Alice, Negroni, etc). Each step down involves more glue and more features to add-on, but it's about striking the balance for your project. I've been leaning on Goji after previously using gorilla/mux &amp; context, and I appreciate the tighter coupling of request context and the router—which has some performance benefits too. I still think it's early days yet, but I don't think there will be "consolidation". Go favors composable pieces over monolithic tools, and so we're likely to see a bunch of web.py, cherrypy, Flask and bottle -style packages appear. Some of them might even appear to have the same features (gasp!) but so be it. The community will rally around projects that scratch an itch and are well maintained, and that might mean a few projects fall by the wayside on the way there. 
I hereby claim all cocktail-related names in the Golang space ;)
Gin is not mine, Just posted it as I thought other might think it interesting. 
&gt; But I don't see how that impedes to use with the error type. It certainly prevents use of _the_ error type, which is an `interface { Error() string }`. It could still be used for concrete errors though, granted. Maybe you would have `type MyResultType union { MyValueType, MyErrorType }` and `MyErrorType` could implement the `error` interface.
'consolidation' was a bad word to pick. I meant, let someone else battle test these and weed bad ones out (either bad designs or discontinued projects).
Yeah I wasn't really testing if it ran all of them, just if I could create that number of goroutines without a problem.
There's no way to do it without using unsafe because it breaks rules of the type system. Sorry.
(note that converting []uint32 to []int32 or vice versa is not considered legal - see http://golang.org/ref/spec#Conversions)
I wish there was a framework for frameworks where you can have an abstraction layer so you can switch your app easily between frameworks
Ok. Looks like unsafe is the way to go in this situation. Thanks for responding! 
That sounds horrifying.
So when do we see the screwdriver? 
The current master yes, however v0 is used in production by me for months. It is stable. It's just gopkg doesn't support 0.1, 0.2 and so on. We were thinking to make the api as 1.0 once we had good way of sorting functionality. 
Using unsafe for this isn't too bad at all. http://play.golang.org/p/KxWLUMFPGv 
except the single scariest line of go code I have seen yet: `a2 := *(*[]uint16)(unsafe.Pointer(&amp;a1))`
It's not *that* scary if you know C :) (unsafe.Pointer(&amp;a1)) ==&gt; gets the pointer to a1 (*[]uint16)(unsafe.Pointer(&amp;a1)) ==&gt; casts that pointer to a []uint16 pointer *(*[]uint16)(unsafe.Pointer(&amp;a1)) ==&gt; gets the value of that []uint16 pointer
Why is unsafe needed. Why not just cast: http://play.golang.org/p/CLLYapeI3H
Time to start writing up GSRs
I searched but couldn't discover what GSRs are.
Yes, I agree that it would be convenient, if your caching is similar for all your projects. Just wanted to note, that with cdncache you wouldn't have to change anything in the production environment as well IMHO, because an environmental variable to distinguish development from production is almost always needed.
If you're coming from Ruby or Python or whatever, that's way overcomplicated. Here's the simple story: "Pointers" to structs are the references you are used to. If you use nothing but pointers-to-structs you'll get pretty much Python or Ruby semantics. If you use value types, instead of references you'll get _shallow_ copies of things passed in. This can be a performance optimization because you may avoid "boxing" things (it's a bit more complicated as to when something ends up "boxed", and that's not even the best way of describing something pointed at, but that's a good first approximation) and sometimes it just isn't worth the paperwork of tracking a pointer, especially in a GC'ed language, for something very small that can be simply copied just as quickly. Passing pointers to simpler types is also something Python can't do, because it sneaks some value semantics in on you. Pass a variable containing a number to a function, and the function can't change the number. A pointer-to-int is more like passing an int in a list to a function, so the function could change it. It's another reason to pass copies sometimes, especially of non-structs. (I'm simplifying here too, I could describe Python semantics with a great deal more detail, but this gets you going, and from there you can work out what's going on yourself.) The whole memory thing and the numbers and etc etc etc are, frankly, irrelevant to understanding pointers in Go, because Go does not permit pointer arithmetic, which is when that actually starts mattering. Now, it's good to know _in general_ so you understand your computer more deeply, and every serious programmer should know it! But you don't need to go that for Go... Go pointers are not really _pointers_ in the C or C++ sense. They're references. (As is usually the case in the software engineering world, getting a definition everyone can agree to is pulling teeth. In this case, I think the distinguishing characteristic between pointers and references is whether you can do pointer arithmetic. If you can, it's a pointer. If you can't, it's a reference. And the reason why references are safer is precisely that you can't do pointer arithmetic, and get in trouble with it.)
That was kind of my reaction. I'm coming from Perl which also has the concept of references, and of all the new concepts in Go, pointers has been one of the least troublesome for me. Maybe because, as you say, Go pointers are really references. Having said that, I do enjoy this type of blog post. Some people will definitely benefit from the explanation, so I hope they keep coming.
Was making a terrible roundabout joke about http://en.m.wikipedia.org/wiki/JSR
OP wants to avoid the copying operation.
Yes, to be clear, I don't want to be critical of the post itself. Again, every serious programmer ought to know that stuff. (In fact, every serious programmer ought to be able to explain that to somebody else, just like that.) It's just that from the POV of "explaining Go pointers to a Python programmer", it is an overcomplicated approach.
Yeah but it gets a lot scarier when you remember that Go has GC that relies on knowing about and controlling allocations.
Not sure if you class this as related, but [this tripped me a little](http://golang.org/ref/spec#Method_sets) when I started learning Go. My thinking was that I could call a pointer (`*T`) method from a `T` method set, but Go will not implicitly do that (but it will implicitly go the other way, `*T -&gt; T`). This is likely what you want anyway, because the method receiver in Go is [always copied to the stack](https://groups.google.com/forum/message/raw?msg=golang-nuts/D1MBeW3MXoI/K_e5TgB2WdAJ). So declaring a method on `T` causes the target object to be copied, whereas a `*T` receiver will copy the pointer.
Couldn't the compiler just look ahead again and see that it's inferring two different types and throw an error on the original variable declaration line that references the two other lines that are causing the error? Seems like the least confusing way to present that condition, but I've never even really looked at haskell so maybe that wouldnt work there for some reason.
That auto restart on fail is designed into Erlang/otp.
Two things: * Wouldn't "IString" make more sense than "Stringer" ? As an interface names go, it's not the best, but it is a tad more readable IMO. As far as I know, there isn't an idiom for distinguishing iterfaces from types, but in this library, it seems to be important. * The example in your README doesn't seem to align with the latest version of your library. Where is the func for `b.String("hello world")` implemented? Or is this an implicit behavior in 'string'? I would have expected something more like `NewString("hello world")` instead.
Actually there is an idiom for distinguishing interfaces, although it might not apply in this case: http://golang.org/doc/effective_go.html#interface-names &gt; By convention, one-method interfaces are named by the method name plus an -er suffix or similar modification to construct an agent noun: Reader, Writer, Formatter, CloseNotifier etc 
1. It is well known practice in Go to name one method interfaces after the method + "er". Stringer is already an existing interface (the exact same) in the fmt package. You can think of this as a generalization of that for other types. 2. My examples align perfectly with the library. You might not know that a type conversion looks exactly like a function call. String("hello world") converts the string literal "hello world" to the type String. This is only possible, if the type String is convertable to string which is the case since String is based on string. The new type String is necessary to be able to define a custom method String() string on it to fulfill the Stringer interface. In short: the interface Stringer here is needed so that it may be optional: var Stringer = nil. The String type is necessary, so that strings can be converted to fulfill the Stringer interface. Dig deeper into how interfaces and types work in Go and run the code, then you will understand.
This seems as good a place as any to ask: What is the golang equivalent to Flask? And another related question: which projects are the community currently rallying around?
I don't think there's yet something the 'scale' of Flask (with all the community contributed packages). Martini (https://github.com/go-martini/martini) was getting there, despite a few shortcomings when it came to 'idiomatic' Go, and has a ton of community contributed packages. I personally think that Martini gets a harder time than it deserves: it is certainly pragmatic, and any performance "loss" from reflection still makes it faster than any Python/Ruby framework out there. The only genuine downside IMO is that it might 'teach' a newcomer some bad practices. 
I'm going to ask the "obvious" question first. Why not just pipe your command through less or vimpager at runtime?
Hmm, that's an interesting though. I wonder when one would run into trouble using unsafe. Do you think the GC can deal with things like this OK? http://play.golang.org/p/yXYn0uiws0
I don't it's kind of a why not I guess. I have no real goal. I'm extremely new to go. I'm just experimenting and mucking about.
https://groups.google.com/forum/#!topic/golang-nuts/yNis7bQG_rY According to this, the GC should do the right thing and not deallocate the memory pointed to by the unsafe pointer.
I think the best way would be to not support multipart forms and return an error for that case. It does not make sense to process large bodies 2 times. (or to save a large file and then notice that it was not allowed to be uploaded). File uploads could be made by a separate request and then other security mechanisms that don't depend on the body should come to play. Less is more.
GIL in cpython still allows one thread at a time. while go gives the option to lock as we wish.
I am looking for your feedback especially what's the good approach approach for authentication and authorization in server side. Is there any good packages available which provide 'roll based access control' ? My code is here: https://github.com/baijum/pitracker
How mature is that Go zeromq library? Is there one accepted as the standard one now? And does it play nice with goroutines?
Also slow as dog's balls. 
I primarily used Python for its terseness, but recall answering at least one question in Go while interviewing at Google. 
it's a great package, it definitely makes piping a whole lot easier
This post is one year old. I was experimenting with ZMQ a lot. I think ZMQ is not a nice fit with Go. Go's concurrent primitives are powerful. Also ZMQ sockets are not thread-safe you need to be careful with them.
Could you explain your use-case to use locks ? Just curious
[Here](https://groups.google.com/forum/#!topic/golang-dev/ZTD1qtpruA8) is the discussion of the proposal in the golang-dev mailing list. I personally don't know how to feel about this. It seems like it does what makefiles have successfully been doing for decades now. The code generation examples are nice, but wouldn't it be better if they instead added a standard code generation tool?
Your readme would do well with some installation instructions or a screenshot or anything hinting at some high-level detail of this app.
All I know is, time to learn YACC!
Yes, thanks I'll also put a version online soon
I've made this post enough to start feeling self conscious about making it. If you need a parser generator, sqlite's lemon parser generator is +Inf times easier to work with than `yacc`. You might want to check it out.
exactly
I think it would be interesting to separate fancy preproccessing like simple algebra and refactoring into another command to keep compile times during development down. In its current state it doesn't seem to necessitate another command, however.
On the one hand that would be handy, so you don't need to commit compiled files. But on the other hand one of the nice things about Go is that you know you can run "go get" once and it'll grab all the dependencies and unless something is seriously broken you'll have your library/command installed. If you start depending on cli tools "go get ..." turns into "go get ..." "yacc not found!!!" "apt-cache search yacc ... apt-get install yacc ... go get ..." "xyz not found!!!" "apt-cache search xyz apt-get install libxyz-tools ... go get ..." until you finally get it installed.
Oh okay, I must have missed that part. Thanks.
It's pretty idiomatic Haskell. It takes getting used to, since it's a fairly different approach from imperative programming.
&gt; In its current state it doesn't seem to necessitate another command, however. I think as a way of unifying the build pipeline, this is a great idea. I also like the fact that it opens to doors to generated code.
What, no dependency injection? I am disappoint.
I'd rather not work with makefiles' horrid syntax. I don't know what kind of 'standard' tool would cover even the use cases mentioned, much less ones not thought of yet.
I thought the point of tokenizers is that they are much faster than regular expressions?
You didn't quite understand one of the core concepts of Go: [*interfaces*](http://golang.org/doc/effective_go.html#interfaces). The use case of your application is perfect for this. The interface in this case would define four fields (`IconPath`, `AppName`, `Title` and `Text`) and one method (`Push`). Then you'd have several implementations for Linux, Windows and OSX that all implement `Push` differently depending on the command. To me this seems a little bit different to what /u/f2f does but I'm too new to Go myself to see why (s)he does things this way.
&gt; Honestly, I'm impressed that you kept your sanity with such an Interface{}-ey implementation. Right now, all I see is a very elaborate hammer in search of some hard to pound nails. So I have to ask: what would you use this for? I believe its most useful characteristic is that it can provide a uniform interface to any "tabular" data. So basically, as an ORM. If you look at the related http://github.com/jonlawlor/relcsv and http://github.com/jonlawlor/relsql packages, you'll get a sense for how that would work out. Those don't have as good docs as the rel package though. What's neat is that the query rewrite will (hopefully, at some point) allow most relational operations to be pushed upstream into the sql server, which will circumvent the overhead incurred by performing relational operations using go reflection. Currently, it only rewrites project and rename, but some cases of restrict, join, setdiff, and union should be able to be pushed up. At that point, the only overhead will be query construction, which is small. Once I finish playing around with the join operation there may be a case for performance even in reflection - the naive approach to a natural join is a nested loop, which has worse performance than a merge join. Then again, I haven't implemented the merge join so it is moot. &gt; A related topic is the infamous generics debate. Would generics in Go have helped the implementation/maintenance of this at all, or would it basically boil down to a performance tradeoff of some kind? I guess it would depend on the way they were implemented? I looked at the gen package to see if I could use code generation instead of reflection, but the types get very complicated very quickly, and I didn't think I could reliably put something together that way. Prior to this I attempted to write something similar in scala and parametric types didn't help (although that may have been because the type inference engine basically lost its mind trying to figure out wtf I was doing, and I lost my mind trying to figure out wtf it was doing). Maybe now that I have a working version with reflection it will be easier to replace parts of it. Ideally, all of the relational operations would have a static type check, which I think is rel's biggest shortcoming.
True. Maybe a better way to put it would have been "A pretty seamless way to deal with complaints about a lack of generics."
That makes perfect sense, thanks.
Thank you for the well-thought out reply! This is fascinating. I don't think I've ever seen someone put together a completely "pure" ORM, and *then* implement SQL generation as a "side-effect" before. 
When you put it that way it does sound simple ;) I guess I'm too used to things like gem and composer. There seem to be a few efforts in that direction for Go, but not one project that has become the defacto tool. 
Need to add dropbox to the running list of major companies using Go in production. And Apple, who've been advertising for Go developers for the past few weeks now. Who keeps this? Damian? 
I'm not familiar with how LINQ was developed, but it can pull the same tricks (and more, which is a blessing and a curse). I believe it was designed similarly, although it was probably intentional instead of accidental.
This is implement of GNTP (Growl Network Transfer Protocol) client. https://github.com/mattn/go-gntp
Not at all, because this is only for package maintainers. It is not run for regular `go build`/`go install`/`go get` invocations.
This is really great news! Strong open library's are what the community needs to continue to grow. 
could I get the link to Apple advertising for Go developers please ?
Oh, also you can do predicates via functions, e.g. http://play.golang.org/p/akE60YsWz7
http://golangprojects.com/golang-go-job-in-Senior-CDN-DevOps-Software-Engineer-Santa-Clara-Valley-Apple.html
I added Dropbox to GoUsers before I posted the story here :)
gdb is not a debugger?
It's not mentioned officially but it basically stopped working, and won't work in the future. https://code.google.com/p/go/issues/detail?id=6963 https://groups.google.com/forum/#!topic/golang-dev/UiVP6F-9-yg/discussion
&gt; database/sqlbuilder: allows developers to generate sql statements programmatically. Would it have hurt them to release that _before_ I started writing my own one? :p
Dropbox is a relatively large company at this point, and we use lots of different languages, including (still) tons of Python. This shift to golang-based services is mostly happening in the infrastructure team (my team, as it happens), which comprises only about a small portion (15-30%?) of the engineering org.
Is it going to be easy to understand for black people?
Once again, thanks. I'll be trying this out soon (as I said in another comment, I'm in cleanup mode for a little bit). In particular, using slices of predicates to represent "and" and "or" is a great idea! It will also make the implementation of Join's Restrict rewrite rule (which allows for theta-joins) to be cleaner: https://github.com/jonlawlor/rel/blob/master/join.go#L231 Also: &gt; Also use some sort of base type "type V interface{}" or something for wrapping all the values. I.e. homogenize the types with a wrapping type and then provide methods for going from Struct -&gt; [][]X and the reverse. This makes it easier to write generic code without having to use reflect everywhere. I tried this out at first, but the interfaces for things like Project(interface{}) ended up with type conversions that callers would have to use as Project(rel.V(some type)). In retrospect, the problem was the Project interface, not that tuples were typed. I'll see if I can refactor all of that reflection. As an aside you've been the most helpful critic that I've had on this topic. I've definitely hit the point where I can use outside advice - so would it be alright if we continued this discussion in email (or on github, or google hangouts)? It will be a bit before I finish incorporating your suggestions.
Thank you for your feedback. Completely agree with you. It's a direct port of the PHP version version. I have already push an update to avoid the loop through the elements: https://github.com/gsempe/retwis-go/commit/dd31d9f568a7022c4e4c46b0ce02be322cf019bf 
[godep](https://github.com/tools/godep) I've been looking into this for an internal project. Haven't made a decision yet, but figured it's worth a look.
That poor frog ;_;, RIP.
I feel like this needs to be here: https://github.com/coreos/go-semver https://github.com/jm/go-semver https://github.com/Lispython/go-semver https://github.com/myfreeweb/gosemver https://github.com/hashicorp/go-version I don't know specifics of how the all differ, but I figured some reference would be good for somebody who stumbles upon this post.
Nice, thx for that list. Most of them sadly do anything (or more) a bit wrong. That's why i wrote this one. If there's no need for full validation (some even allow negative major numbers) most of them work fine.
I like [negroni](https://github.com/codegangsta/negroni). It's juuuuust right.
I did some digging for the history of LINQ, and they did it simultaneously. Take a look at http://channel9.msdn.com/Blogs/scobleizer/Anders-Hejlsberg-LINQ - specifically, the first 4 minutes or so. The really great thing about it is the static type checking. His comments on how the compiler doesn't know anything about the sql language is spot on.
I'm using it right now...works like a charm :)
Mind if I ask you a question? [I'm working on a new dependency manager](http://github.com/eanderton/grapnel), and am attempting to overtake some of the existing crop of tools since they're all missing some features here and there. So... what features in particular are you looking for when considering such a tool?
Also made this comment on the post, just thought I'd mention it here too to compliment visibility: For the sake of clarity, I will substitute any mention of the reference data type with REF, while any variation of the word 'refer' will be used literally. I was confused when you mentioned, "when you manipulate the reference it will change what it refers to, rather than the referring value". My interpretation of that: when you manipulate a REF, you change what the REF refers to. You do not change the value of the variable that REF refers to. From my understanding of REFs (which is very limited), manipulating a REF will change the value stored in the variable the REF is referring to. You cannot change the reference of a REF once it is initialized (I know that you mentioned this when explaining references towards the beginning of the post). This example in C++ was what I used to verify whether the scenario in the comment you made for the statement `*ap = 5 ` (ap and ap2 would be different if they were REFs) was true. int b = 2; int&amp; ap = b; //ap refers to b, so any use of ap will be evaluated to 2. int&amp; ap2 = b; //ap2 refers to b, so any use of ap2 will be evaluated to 2. ap2 = 10; //value stored in variable b is now 10. Any use of ap and ap2 wil be evaluated to 10. ap and ap2 can never, ever reference anything other than the variable b. This also meant to address your explanation, "when you make a copy of a reference, they are now independent." In the following example, even if you modified the third line, `int&amp; ap2 = ap`, ap2 would be a copy of ap. The comment made for the last statement would still be true, even if the assignment was made on ap instead of ap2. I'd really appreciate clarification on this one. Apologies if I'm just having a really simple misunderstanding. Thanks!
Aside from the current crop of not-quite-feature-complete dep managers, the conventions seem to orbit around 'go get', which IMO, isn't the best: Libraries: * Put the root of your library in the repo root; this way 'github.com/jmking/mylibrary' maps to the right code. * Tag the latest stable version of your repo "go1" so that 'go get' won't pick up HEAD/tip of your repo by mistake. * Do not make sweeping API changes once you have a stable version; make bugfixes only. Instead, start over with the next API-changing version on a completely separate repo, because 'go get' won't know the difference otherwise, and you'll break everyone's software if you don't. Programs: * Go ahead and put your code under src/ * Place the 'main' portion of your program in the 'main' package under src/myprogram/cmd/main.go or somesuch. This way, the code under src/myprogram can be in its own namespace. * Leverage git submodules. It's not the cleanest mechanism, and the metadata goes away if you're no longer in a git repo. But it does provide you with some crude pinning capability since you can force it to use a commit hash or tag for each clone. * Optionally, vendorize depdendencies ([see Dependency Management section here](http://peter.bourgon.org/go-in-production/)). Edit: While not entirely pointless, it seems like a crude hack to an already well-solved problem that is under-served for Go. To me, it seems dangerous due to how licensing in libraries may or may not apply to redistribution of code. I suppose that as long as you don't modify things, and keep the original licensing intact, it should be okay. But again, I am not a lawyer. The Go community has a very heavy BSD bias which may be largely responsible for influencing this trend. I mentioned this elsewhere in this thread, but some of us are aware of how bad the situation is, in comparison to other language dependency management systems. [I'm working like crazy to get something better put together](https://github.com/eanderton/grapnel), but I'm only one man.
I like stdlib most and use something like that as my middleware in different projects. It might become slower than other frameworks if you need route-specific middlewares, otherwise stick to this approach
Very clever! I'll definitely make use of this. Thanks.
You should do that in tests: https://github.com/pierrre/imageserver/blob/master/http/handler_test.go#L13-L15 https://github.com/pierrre/imageserver/blob/master/cache/server_test.go#L13-L15 It breaks the package dependency.
Dropbox people reading this thread: I see the testing is done with gocheck. I've recently been looking at different testing libs. I'm curious which libraries were evaluated and why was gocheck chosen?
Orthogonal to what I need (and yes, I've looked at all of them). For the record, [this](http://ulfurinn.net/2014/06/24/sql-ast-builder-for-go/) is what I started.
OIC, something like LINQ. Is the Dropbox SQL stuff any good?
Also anything can satisfy `type X interface{}` so there is no need for conversion.
This one is relatively new but I like it: https://github.com/nitrous-io/goop
Heh already reported some issues :) However mainter seem unresponsive.
I find it more neat to use the form: var _ = Jedi(new(Knight)) Or var _ = Jedi(&amp;Knight{})
Eh seems decently responsive to me. I like that it doesn't force you to mess with your main GOPATH. And the dependency files are nice and readable. 
Yes, me too. However, AIUI both of these allocate memory.
Its not a package manager, but I really dig the idea of gopkg.in. 
What version of Go and gdb? 
Anything with the signature `(http.Handler) http.Handler` will be extremely flexible, provided that the other components you are using are compatible with the http.Handler interface (the ones worth using are). This includes vanilla net/http, gorilla/mux and a few other routers, Goji (https://goji.io/), Negroni and so on. With net/http or gorilla, you just wrap the handlers like so: `r.Handle("/", RecoveryMiddleware(LoggingMiddleware(CompressMiddleware(http.HandlerFunc(IndexHandler))))` (which obviously gets a bit clunky &amp; error prone). This is where something like Negroni or Alice can help, since it makes middleware ordering cleaner. I use Goji, which is pretty much the same, but also includes a request context (for passing data between middleware/handlers) - which supports both the regular `func(http.Handler) http.Handler` type and an extended `func(web.C, http.Handler) http.Handler` type. Either way, if you hitch yourself to the http.Handler wagon it's easy to change your mind later on.
I wouldn't call 5-6 days "unresponsive" for an open source project.
Any references on the interceptor pattern ?
I just made some progress! https://www.youtube.com/watch?v=xC62IenB9qM
I use [gvp](https://github.com/pote/gvp) and [gpm](https://github.com/pote/gpm). Every new project (or ones that I want to work on), I just run `gvp init`, list the dependencies in the `Godeps` file and run `gpm install`. It's pretty simple. gpm does not handle dependencies of dependencies, though, so.. it's not the best solution.
No, the escape detector will see that they don't leave a function scope (because they were never in one), so they'll only be on the stack. However, since it's assigned to the null variable, I'm 99% sure they will actually be removed at compile time, once they've been checked. But definitely no heap allocation.
I'm scared. I don't know what made me scared though.
The node.js people are coming!
You don't put this in a test, you put it right next to the type declaration; it's a nice, cheap, short way of documenting intent.
The sort example at the bottom seems to imply that
He answered me after 2 or 3 days .... Seems ok.
Isn't this guy the creator of express.js and bunch of other super popular JavaScript frameworks/tools? Its nice to see the Go community capture creative minds.
Fantastic news! Can't wait to see more people ditch server-side JS for Go.
&gt; Can't wait to see more people ditch server-side JS for Go. And then ditch Go for Rust (or whatever becomes the new hype) when they migrate. But yeah, I'm happy that JS is becoming less popular... I was getting scared. These days most of our projects are JavaScript and I've been thinking of switching jobs just to maintain a more diverse skillset. 
He has some crazy stats on the Node Package Manager. [In May, @tjholowaychuk was fully or partially responsible for 32MM downloads, or about 10% of all downloads in May: http://npm-stat.com/charts.html?author=tjholowaychuk …](https://twitter.com/seldo/status/474684725794439168) 
Wow, you're right, I can't believe I missed that 'languages'. There was a popular article on reddit last week, "Go is not Good", this was in response to that. I've added a hyperlink to it at 'weaknesses' to make that clearer.
People will ditch Go for Rust only if Rust is a better tool for solving the kinds of problems that Go solves. node.js was seriously broken from day 1 (and still is), therefore people are throwing in the towel. 