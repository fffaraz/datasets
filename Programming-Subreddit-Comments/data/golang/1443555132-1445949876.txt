It is in English...? Including the commits and many of the issues. If some of their users speak Chinese primarily, it makes sense that the issues they'd file would be in Chinese. The open-source world isn't just an English-speaking one - Go in particular has a large base of Chinese developers.
I seriously hope you are not part of the committee that enforces this CoC. It's evident you're not capable of putting yourself in someone else's shoes or thinking outside of the box. These rules weren't written with real potential victims in mind, which makes me think that the team itself is not very diverse. It's pretty clear that @Andail_Chanter does not mean to incur in any of these awful behaviours. 
Not only is it in English, it's one of the best READMEs I have ever seen with pictures and everything.
Thank you. I appreciate the link.
You're a cool guy :) Have a nice week.
It was faux egotism for humor's sake. 
s/magic/dynamic There is no "magic" in go, except the make and append functions which are built in and "magically" work. DI is about exchanging compile time safety for run-time percs.
Interesting. I've run go on beanstalk before pretty trivially with their docker support, but this is a nice step anyway.
if you own the domain you can put meta tags to point it at the actual repo. Go get will work with that.
It's a shame that the link is missing in the presentation: https://github.com/manishrjain/gocrud if anyone's interested.
Yes!
Nice, thanks. I'll definetaly look into the implementation but the idea differ a little. From what I saw you are generating a random, non-recoverable password, whereas I did not want to rely on password manager or memory for any sites. The password complexity definition is interesting though.
 I really like zmq patterns and the abstraction it provides on top of bsd sockets, however I've moved away from zmq a while ago due to licensing ( http://250bpm.com/blog:15 ). Have been using gnats + nsq and pushing billions of messages every month. https://nats.io/ http://nsq.io/ If you are running a distributed system 100% in go, mangos is also a good option: https://github.com/gdamore/mangos
This looks really interesting and I'm going to try it, but MongoDB?? *Please*.
I find it hard to consider that a criticism of any particular library, though, since nothing can. It has often seemed to me that in 5-10 years the Go community opinion will be that you should never use `go` directly. I've never seen it stated in the Erlang world but you'll also find that their closest equivalent `spawn` rarely is used directly; usually it's behind some framework to handle it in some manner. And in Erlang, a naked crashing process doesn't bring the whole VM down. (It does in Go for good and reasonable reasons, but it's still a relevant difference.)
&gt; used this approach for some fairly wide cross-language communication and I can't say any language is really good at this. The problem is fundamental to JSON; you have no control over the order of the incoming keys, and there is nothing you can do about the possibility that the "type" key will come last, after megabytes or gigabytes of other stuff, all of which you need to hold in some sort of holding pattern until then. Thanks for taking the time to write this, I am happy enough with the RawMessage approach as the messages I am dealing with are small, thanks!
What is usecase of messages in your app? Just chat? I would use Pusher for prototype and worry about scalability when it will be a problem :)
Ah thanks! Never would have thought of that. Just habit for me to put a `default` at the end of a `switch`. I'll give it a shot.
Is there somewhere I can read more about this? Or would you mind explaining why this is the case?
/u/postman_ doesn't stress this but it's important that you understand the difference between switch and select. Have you done the [Tour of Go](https://tour.golang.org/list) yet? It's a great way to get to know the language, doesn't take a lot of time, it's interactive and also deals with [select](https://tour.golang.org/concurrency/5). 
Truth, didn't occur to me. I did the tour maybe a year ago, but that information apparently didn't stick with me. I'm much more of a "have a project and build it through trial-and-error" kind of learner than reading, or even the tour. I feel like I could have done that tour a million times, and that concept probably wouldn't have sunk in until I screwed something up that I needed. Guaranteed I won't forget it this time, though! Edit: And to drive the point home further, I saw that page earlier today, and clearly didn't read it carefully enough, haha!
Well, now that I've just learned this, according to the docs: &gt; The `select `statement lets a goroutine wait on multiple communication operations. &gt; A `select` blocks until one of its cases can run, then it executes that case. It chooses one at random if multiple are ready. So basically, the `for` loop would have been sleeping while it was waiting for something to populate a channel, but instead, because of the `default` it just kept running through the loop over and over again. The difference on my machine was that it went from 99% CPU to 0.1% when I removed the `default`.
Ok, this makes sense. Say I want to register [gorm](https://github.com/jinzhu/gorm). Would I have to implement all the functions I am using in an interface? 
Interesting approach, I might give it a try. Recently I was looking for something that would generate CRUD methods for a given struct based on the `db:` tags, but I could not find any, does anyone know?
I know this sounds like patronizing advice, but you should read (or re-read, if you already have read) [Effective Go](https://golang.org/doc/effective_go.html). I re-read it every few months and I'm still finding new bits of useful information. It's *packed* with useful info which isn't often evident on the first (or *n*th) read. Don't try to absorb all of the details in one read, but when you come across something that doesn't seem right, or you seem to be fighting the language, Stare at the relevant sections of that doc in a zen-like fashion. It's helped me out so many times I've lost count. I'm actually thinking of printing it out so I have a hard-copy at hand. (I seem to absorb information better when reading real paper, but YMMV :-) )
I'm going to guess you've got no realistic chance of swapping out gorm with some sort of test version of it. In that case, if the "environment" interface was: type Environment interface { // whatever goes in here for the environment } I'd make a concrete object that composed that in: type Env struct { db // whatever the gorm DB's type is Environment } Then you can still swap `Environment`s in and out, but you have a concrete place for the db. (You also can choose whether to embed the gorm DB object or not.) Composition is so nicely flexible on this front. I'd also consider wrapping all direct invocations of gorm behind a more conceptual API (i.e., instead of directly invoking it to load a user, have a LoadUser method somewhere), and giving that conceptual API an interface. It depends on how passionate you are about unit testing, the probability of ever swapping gorm out, and what the cost/benefit is for this level of abstraction. A lot of my recent Go work has been on infrastructure stuff where it is to my advantage to make it bullet-proof, but not everything has to be up to that standard. I tend to err in favor of testing at the moment, just because of where my head is.
Thanks for sharing. I will definitely be looking at how you did this.
https://github.com/brk0v/http2/tree/push-promise
This is almost certainly due to processor cache rather than algorithms : http://igoro.com/archive/gallery-of-processor-cache-effects/
I tried it again, but using a random index each time in the lookup in the benchmark. That certainly hurt lookups in the slice, but the shape of the map's line is essentially unchanged. New graph: http://i.imgur.com/BqOQGzc.png, code/results pushed to the "scrambled" branch on github.
Why a map lookup should be O(1)?
Are you looking to make a cross-platform library that can be used with SDK apps or one that can be used with pure go mobile apps? The former is a little difficult now since the gomobile tool can only [generate bindings for a single package now](https://github.com/golang/go/issues/12245). In addition, it [doesn't support third party types](https://github.com/golang/go/issues/12570). However, you could publish your code and require users to either plug into it or write wrappers for it. If it is for the latter, then take a look at how the x/mobile packages are written. Edit: I should clarify that I mean that sharing your library with third parties is difficult. Not sharing between an ios and Android app. 
Your test code is wrong. https://github.com/connor4312/maps-are-not-o1/blob/master/no1_test.go#L43-L45 - You're testing the time it takes to retrieve *every* member of the map, not the time it takes to retrieve one member. If you remove that inner loop, map performance is O(1) (as you'd expect), and sorted slice performance is not. Edit: I missed the division in the R code, please stop upvoting me.
I am looking for the first option, cross platform library that can be used with objective c and java. The other option would be using C++ but since my server is already built in Go I thought it would be a wise choice to keep with Go, but those two limitations you mentions would pose a problem since I would need to couple multiple packages together
But n O(1) lookups is linear and should be a straight line. Except for the performance effects of processor caches : https://youtu.be/WDIkqP4JbkE
I'm testing how long it takes to retrieve every member of both the list _and_ slice. The code in R divides the runtime by the number of elements, so that the _average_ runtime to get some item in the slice or map is measured. https://github.com/connor4312/maps-are-not-o1/blob/master/plot.r#L12 I'm not retrieving a single arbitrary item, since the runtimes for binary search (and in a minor way, map lookups, since some items are in buckets with more collisions) vary depending on which item is being retrieved.
Ah; I'd misread your graphs and thought that both axes were the same scale, and that performance of your map was approaching O (n) at the upper end (slope being near 1). dgryski probably has the right of it then; cache effects are going to hurt access times to any large data set.
Also I wouldnt open a new gorm instance each time... Gorm utilizes go's database/sql package which handles connection pooling very well.
Awesome! That actually sounds pretty good to me then. I am going to give it a shot on my IOS app tonight :D. Also, have you run into any bugs or issues that are not already documented? 
So are you saying I should have one connection for the app?
Okay, thanks!
Could you please provide a little more information about how you use gnats + nsq together? Aren't they both addressing a largely overlapping use case? 
**average** characteristic. One should not forget that the worst case is O(n). 
It's not portable code. `targetBytePointer` is not necessarily 4-byte aligned, if I read the code correctly, so access to it will raise a hardware alignment exception on some CPUs (and will be "slow" on others). Should be fairly easy to make it aligned. But at that point, it's probably more efficient to just use `Threadsafe` anyway. The Go compiler isn't optimizing the output much (in general) and `SetAtomic` is fairly long.
He did try again with random indexes [here](https://www.reddit.com/r/golang/comments/3n0lf8/go_maps_dont_appear_to_be_o1/cvjrv92) and it didn't really change things.
What are the pros and cons of doing this vs. putting the collection of functions in a package, not attached to any struct? 
&gt; The worst-case complexity of a lookup is logarithmic. Only if the "chain" is a balanced red-black tree. But map chains are frequently implemented as linked lists. In which case the worst-case complexity would be far, far worse than "logarithmic". So which is it? How is the chain implemented?
Boom! Less is more :) Are we about to enter the era of Go being within 20% of the performance range of C?
If we want to talk about testing overhead, the rand.Intn() call has about 30ns/op on my laptop, and all the calls to r.get() are indirect calls through an interface.
EDIT: Am I right to assume that this fixes the alignment issue? https://github.com/boljen/go-bitmap/ (link was broken)
Yepp, definitely. Using `uint32` through-out looks much more idiomatic. Any particular reason for doing the `unsafe.Pointer' casting? I see you have a benchmark. Any numbers comparing the approaches? (I'm not a low-level CPU expert, so I'll bow to empirical data regarding performance. :)
Would you perhaps know whether any []byte slice is 4-byte aligned from index 0 onwards? For some reason I prefer working with []byte bitmaps, one of the main reasons being that I wrote the initial non-thread-safe map as such. Benchmarks are skewed (no memory allocs except for mutexes) PASS BenchmarkAtomic-8 100000000 23.3 ns/op BenchmarkAtomic_Parallel-8 300000000 5.52 ns/op BenchmarkFuncs-8 300000000 6.14 ns/op BenchmarkMutex-8 5000000 419 ns/op BenchmarkMutexParallel-8 10000000 166 ns/op BenchmarkAtomicUint32-8 100000000 14.8 ns/op BenchmarkAtomicUint32_Parallel-8 300000000 7.85 ns/op ok github.com/boljen/go-bitmap 16.376s Thanks btw for the feedback!
It can be interesting if you have a bunch of different implementations for an interface, one of which is not attached to any data. I have used such a trick in the past.
This doesn't feel idiomatic to me. Struct methods should be to alter the data contained by the struct. This pattern should be achieved by a package that is imported.
You are absolutely right. In the worst case, chaining by linked-list will be O(n) for one item. If you count the number of steps for n items, the total number of steps is 1+2+3+...+n = n(n-1)/2 operations. The amortized cost is (n-1)/2 operations, in the worst case. I think you see a mixture of that and other factors (e.g. cache) in the graph. That said, the graph shows that the search is much faster than O(lg n) curve of binary search. Having said this, I think to understand the "average complexity" O(1) of searching a map, you should not search for all items (even though in a random order). Instead, generate a random M number of items. Search and average run times of these M items. You can do this experiment several times and average the averages. That will be more indicative of the average running time of search a hash table. 
Very cool! I think I'll have to reread it after my morning coffee in order to really comprehend it. :)
Looks much more readable (for my non-color-impaired eyes, at least), thanks!
After a little revisiting with CLRS, I think another possible reason for this is that searching a hash table by chaining has average complexity of O(1 + alpha), where alpha is the load factor, which is n/table size. Go grows the table dynamically by doubling the size when it becomes too big. Doubling the size will change the load factor. So alpha is not always the same. So, what you see is something that is slightly larger than constant as n increases. That said, I think a different probabilistic experiment needs to be designed to get a more accurate picture of average running time of searching a hash table.
I donâ€™t understand how a map/hash table could have O(1) access times unless the map is so big, or there are so few elements, that there are no hash collisions, which would be an exception and not the rule surely.
&gt; Would you perhaps know whether any []byte slice is 4-byte aligned from index 0 onwards? All slices allocated on at least the amd64 platform should be 16-byte aligned according to [this mail thread](https://groups.google.com/d/msg/golang-nuts/HFjwPFYrCqg/oSttxY8ajr4J). Thanks for the numbers.
hmm, a bit unrelated, I was going to say that icon doesn't look like a YAM, that's a Kumara! (in NZ it is anyway) However it turns out that New Zealand yams are different (I didn't know this). Googling "yam" vs "yam nz" has different images.
ha, happy to change it for an image that more accurately resembles a yam :)
I did the following go get github.com/alexbrainman/odbc it put it under C:\work\pkg\windows_386\github.com\alexbrainman\odbc.a 
That *is* the rule, though: most hash tables expand as you add items to keep the "load factor" (the ratio of entries to buckets) below a set value. Usually the load factor is kept well below 1, so that you have a lot of empty buckets. This doesn't prevent collisions from ever occurring, but unless there's a problem with your hash function, the likelihood of a collision remains constant as the hash table grows, so the average access time remains O(1) (and the actual access times don't vary too much from average). 
great!
You can replace // tarDir if err := tarFile(path); err != nil { return err } return nil with // tarDir return tarFile(path) 
Oh, I love this. Thank you so much!
The average case is [not really O(1) and can't be](http://www.reddit.com/r/compsci/comments/2z74z8/why_is_hashtable_lookup_o1_rather_than_olog_n_or/), although the difference doesn't show up over any realistic storage size.
This is one of the best plugins I've ever come across. It makes magical vim even more magical. Great work!!!
Yeah, pretty good. We all love it.
I would probably write the main function with the `go`'d code doing the http request instead of the normal flow to make it more clear how things work. The business with the wait group is less elegant than it could be. Edit: [My attempt](http://play.golang.org/p/yJxkF10JwM)
Thanks a lot. Once you have it impossible to be without it!
I had the same "Aha!" moment when I started to understand the power of interfaces like io.Writer and io.Reader. Just a couple of notes on your final code: * You can use filepath.Walk to do most of the work you are doing in the tarFile and tarDir functions. * You don't necessarily need a pipe or MultiWriter for this. You can make your own io.Writer that wraps the normal calls. I do this in a small package I wrote called [wrapio](https://godoc.org/github.com/icub3d/gop/wrapio#NewHashWriter). I updated you example using the above and it shortened the code quite a bit. My version doesn't submit to nanobox but you can wrap the for loop in a goroutine and get a similar effect by giving the API call the gzipped writer. edit: here is the link: [https://gist.github.com/icub3d/aa86bc52d90203504760]
Thanks for the comment, I've updated the code to reflect your suggestion.
Why default workers to 4, instead of `runtime.NumCPU()`?
Sorry. I was playing with the active version, instead of the dev one !$%@*! And I destroyed it obviously... it took me a while to repair... a beginner's act!..... in spite of all the securities I have..... Should not occur again (I hope ---( ).
Looks nice. Could you outline why I should use this and not just s/bcrypt directly, or is this only if you have to support Python passlib?
Good work! I currently use [mcf](https://godoc.org/github.com/gyepisam/mcf), so always good to have more options for this task.
You shouldn't use bcrypt directly because: - bcrypt has a 77 character password length limit which is rather blargh. Python's passlib sensibly implemented a bcrypt-with-SHA256-prehash mode to resolve this. My library implements this, and its hashes so produced are compatible with the output of passlib. - bcrypt uses blowfish, a pretty old and deprecated cipher. - So I wouldn't recommend bcrypt for new usage. My library currently uses scrypt by default. But my library also offers seamless upgrade and management of old hashing methods. For example, suppose you have bcrypt hashes in use. Or suppose that at some point in the future, scrypt becomes broken, however unlikely that may be. The library will then provide a seamless upgrade path to a new, unbroken mechanism. The Password Hashing Competition has just concluded and chosen Argon2 as its winner. At some point I will probably add support for Argon2 to passlib, and then users of passlib can use it if they wish. Essentially it comes down to this: You shouldn't choose to use "bcrypt", you want to outsource the decision as to what mechanism to use because most people aren't experts on this matter, and the best choice varies over time. Think of NaCl: although I have a lot of criticism for the design of NaCl, it had some good ideas. You don't want to give people a function to invoke a crypto primitive; you want to give people a function to do what they want, which is, for example, to encrypt and authenticate some data with a shared secret key. With this library, you don't have to make the decision to use bcrypt in the first place, and if the algorithm this library does use becomes deprecated, it will be seamlessly transitioned automatically. You can't rehash people's passwords when they're in storage, but when someone next logs in you can use your temporary knowledge of their plaintext password to rehash the password with the preferred algorithm if the hash algorithm with which the password is currently stored is a deprecated one. Essentially it's a question of using e.g. packages in passlib.hash directly versus passlib's Context object. Basically the library provides a "Cryptographic Right Answer" (IMO) for password storage which non-experts can be directed to. So long as you call Hash and Verify and handle upgrades as suggested, password hash lifecycle is managed automatically. Algorithms may be changed out in favour of more preferred ones and difficulties may be adjusted according to the times. And hashes will be upgraded automatically to reflect these changed policies as people log in. You can customise the policy if you don't like the default one, or want to 'vendor' it. The one caveat is that if the default algorithm is changed from scrypt, you will have to opt in to that, as otherwise there would be obvious problems with multi-server applications (e.g. server A is updated to a new version of passlib, logins handled by it get upgraded to some new hashing method, server B is still using the old version and can't understand the hash, so now people sometimes can't log in.) So if I ever change the default hash from scrypt, I will probably introduce a function like passlib.DeclareMinVer("YYYYMMDD") or similar, to be called at initialization once all servers are upgraded, probably with a warning or similar emitted if not called to encourage people to upgrade. Of course this isn't applicable if you instantiate your own context. By default, passlib generates scrypt and verifies bcrypt, bcrypt with SHA256 prehash, sha256-crypt and sha512-crypt, which are more or less the modern hashing methods worth using, aside from PBKDF2. Argon2, the winner of the Password Hashing Competition, will be supported at some point.
Nice, I wasn't aware of that library. Some thoughts: - I think my library is more idiotproof, and provides a simpler interface. - That library encourages upgrade hashing to be done in a goroutine, to enhance the user experience, which may provide a slightly better user experience when upgrading hashes than my library, which does it in one. But you can always do this yourself by calling NeedsUpdate in my library, and since upgrades are rare I'm not sure it's especially important. - Its implementation of e.g. PBKDF2 seems to be its own standard. There are a lot of incompatible implementations of PBKDF2 as a password hashing mechanism, alas; just look at how many Python passlib supports. - mcf uses singletons (packages) for each method, whereas my methods are instantiable. This makes it easier to change costs, though it means you can only use one cost in a binary. So there's a tradeoff here. - No support for sha256-crypt or sha512-crypt. These are pretty popular in e.g. Linux /etc/shadow, so if you need to support that it's no help there. (Fun to note that that library links to Python passlib's modular crypt documentation too. Really, some excellent work by Python passlib there.)
Thanks for the detailed reply! Do you have any info on why blowfish is `a pretty old and deprecated cipher`. To my knowledge it is still fine, if it is sufficiently costly and you cannot afford the memory used by scrypt. Related to that, you use "bcrypt.DefaultCost", which is '10' and in my experience is rather low for bcrypt nowadays. A cost of 12 or 13 is probably more appropriate today.
I don't think anyone would use Blowfish in a modern, clean-slate design, so from that perspective it's almost by definition deprecated. Schneier has suggested people use Twofish instead: https://en.wikipedia.org/wiki/Blowfish_(cipher)#Weakness_and_successors To be fair, these criticisms of Blowfish are not necessarily relevant to its use in the context of a password-hashing algorithm. The principal issue I have with bcrypt is its password length limitation (usually implemented as silent truncation, even), which has no place in a modern password hashing algorithm, hence my implementation of bcrypt-sha256. I will change the recommended cost to 12. Thanks.
Read the N. Wirth's Compiler Construction. Also here is my vision of declarative language written in golang https://github.com/kpmy/lomo
Nice work @3zcurdia :) I have the same question as @FogleMonster about the file format. Any details?
Thanks for the link, but this looks like an imperative language, and I'm particularly interested in how the declarative aspect would be different... Any more pointers? Thanks!!
I'll check it out, thanks! Do you know if it has a section about declarative languages in particular?
Congratulations to vim-go team
Also, there is no difference between parser for imperative language vs. parser for declarative language. All way down to AST (abstract syntax tree) it will look similar. Difference will show itself on semantics of nodes and virtual machine/code generator implementation.
A similar implementation of the same algorithm can be found [here](https://groups.google.com/d/msg/golang-nuts/TTKPzAjwOV4/5315kJgCfWgJ). It doesn't perform as well as yours, but it does handle unicode and duplicates as one would expect. The author chose to store the runes in a struct, however using a rune array for the *Bigram* type as you suggested would work just as well. One quick suggestion about your implementation is that you should call *strings.ToLower* on the entire string, not on each slice. You get a noticeable performance hit calling it that many times.
That is an excellent question, I added the flags last minute so people could change them, but I will correct that.
Looks cool. BTW the example in your readme doesn't build. You appear to be referencing package (fsnotify) that no longer exists.
Written in Ruby, by the smug programmer who created the worst QA site in the world. Even if I didn't think Discourse was stupid, why do we need another Go forum?
You da man! :)
More discussion on the differences between scrypt and bcrypt, for those interested: http://security.stackexchange.com/questions/26245/is-bcrypt-better-than-scrypt
Exactly, my first thought when I saw the title was to say "smaller != better".
Quick question: Why did you reinvent the wheel and added a new string format for storing scrypts? The [java implementation](https://github.com/wg/scrypt) already had a nice format (which format I already saw very often in use in commercial products). Just curious since I wrote myself a little helper library to make our own password storage compatible with that format (Which had the nice benefit to get some test vectors for validation).
On the other hand more verbose code is not automatically better https://medium.com/@webseanhickey/the-evolution-of-a-software-engineer-db854689243 
&gt; I come from a JS background, which means that you have to be as precise with your statements as possible. wat
I've implemented a library that can be used for map/reduce style jobs, and also as a hadoop client: https://github.com/dgryski/dmrgo
It's not really any different. 
Thanks, I'll have to update that.
Thanks much! Can I ask some things like what you use for deployment and DB stuff?
"smaller != better" is not at all the same thing as saying or implying that "verbose == better". There is very little relationship between terse/verbose and quality.
With a quick glance you are not setting [GOMAXPROCS](https://golang.org/pkg/runtime/#GOMAXPROCS). Go &gt;=1.5.x will default to using all cores but if someone runs this app on &lt;1.5.x you are running all those threads with a single CPU. You should probably just add runtime.GOMAXPROCS(runtime.NumCPU()) at the very start of your main. No matter what number of goroutines you use.
it's very easy to make mistakes in JS because the language is so damned forgiving. Meaning that putting a brace on the wrong line will create an empty object and an undefined. An undefined value evaluates *almost* the same way as having a `false` boolean. Etc. etc., you have to be careful and always on the lookout for code that will trip you up.
After building *one* web app with Go I can't see myself ever using node again. I spend so much time worrying about structure and "plumbing" with Javascript, it's insanely unproductive.
The article does a lot of relation to JavaScript, but it takes next to no consideration of anything else. It seems uninformed by an understanding of general, non-language-specific software development practices. An example of this is a particular fascination with syntax, which is not really relevant to much. 
Basically, that JavaScript being your primary language has taught you some shitty lessons, and that if you learn to program with JavaScript you lack some fundamental concepts present in nearly every other language. Much of JavaScript's bad reputation is well earned. I'll try to go over the major points from your blog post. * Learn about types. Languages may handle them differently, but almost none of them handle them the way JavaScript does. Javascript introduced the world to amazing things like 'NaN', which is a numerical value: typeof(NaN) "number" Strongly typed languages can't allow something like that. * Dealing with upstream repositories. `go get` is there for convenience, it supplements but does not replace your ability to grab a specific version of an external dependency. If you know you need a specific version, nothing prevents you from getting it and using it. [Go 1.5 added more tool support for dealing with this, so you can still use `go get` while also vendoring specific versions.](https://docs.google.com/document/d/1Bz5-UB7g2uPBdOx-rw5t9MxJwkfpx90cqG9AFL0JAYo/edit) * Style. Some languages have it, some languages don't The ones that do tend to use style to replace boilerplate, such as semicolons or parenthesis. You don't need parenthesis in your 'for' declaration, because it's form is strict. The word for, your conditionals, then open curly brace to declare the beginning of your subroutine. The parenthesis are only helpful in other languages to distinguish your conditionals, which are already distinguished in Go. * Similarly, semicolons only matter if your end of line could be somewhere other than the end of a line. For example, if you really wanted to throw a bunch of code onto a single line, semicolons permit that, and you should feel bad for wanting to do it. * Implied 'break' in a switch/case block is another piece of boilerplate. You'll type 'fallthrough' a whole lot less in Go than you would type 'break' in any other language, because the default is the common case. * Multiple return values solves a real problem in the real world. Being able to return an error code without relying on it fitting into the the type of the result you expect is huge. Lots of languages make this sort of basic handling really hard. If you call a function in most popular languages, a return of 0 is also a return of false, which is a common test for error. You end up doing things like negative numbers for return values, and then you need different negative numbers to use for different error cases, etc. This problem just doesn't exist in Go and other languages that adopt this practice. * In the same line as returning errors directly, lots of languages (including javascript) implement the try/catch/throw form of exception handling. Javascript makes it optional, which means it's mostly useless as nobody uses it. Other languages require it, which generally makes it useless as you're not handling an exceptional situation, you're trying to overcome an inability to return an error. 
You have to be, you're right but other languages will let you know if you fuck something up. The issue with JS is silent errors and weird evaluations as well as the whole `undefined`, `NaN`, and whatever else. When you read Javascript The Good Parts, that's pretty much what I'm talking about: you have to be on the lookout for the good parts and you have to stay away from the shitty parts.
I've had custom stylesheets disabled since forever ago. I don't miss them.
Man, I meant something completely different by that. I should've edited better. I've pretty good knowledge of type systems. I guess I meant that I don't use it on a day-to-day basis. Back in school, I started out with C, also did some C++, Java, and C\# so I definitely have some background in it.
The point is that the viewpoint is lacking. Your opinions seem essentially uninformed and therefore kind of irrelevant. JavaScript is a very quirky language, so many of the quirks you find in Go are actually reverse quirks--things that aren't all that quirky. 
"When I tried out Go (as a Node developer) " Given the title, it is only reasonable to relate Go to JavaScript. I have to say I find these comments overly negative and not the tone I'm accustomed to from the Go community.
Thanks for the tip!
Go compiles down to a single binary, so either compile the binary on the target server, or make sure you cross compile it correctly if developing on a different platform. Then its just a matter of copying it to the server and building an appropriate startup script (sysvinit, upstart, supervisor, systemd, etc). Like /u/robertmeta said, you should just start with sqlite if you want to use a database, or you can just keep it simple and start with filesystem storage (perhaps using json as the data format).
Well it's a much more serious language these days, but I agree with your assessment of how damaging it can be to learn it as a first language.
Did you miss the part where it was 50% sarcasm?
You still have to deal with order of operations even in memory. Transactions and guaranteed order are awesome for this. Additionally, SQLite can be an in-memory database!
&gt;How With a testing framework. Go has one in the standard library. &gt;Why To produce easier to maintain, less buggy software. [This is a good video on the topic](https://www.youtube.com/watch?v=D9GQ9nBHhIc)
It's funny that parenthesis are one of my pet peeves in JS and Nodejs and many other frameworks advocate a design where you have to use way too many parenthesis. 
Why not just use sql@1.doSomething() and sql@2.doAnotherThing()?
Because you want to simplify the common case, always. Importing a version should, by default, go to a simple namespace. If you wanted to import both versions, you could import them with a name like "sqlV1" and "sqlV2".
Handwritten parser and lexer tutorial: http://blog.gopheracademy.com/advent-2014/parsers-lexers/ This helped me a lot in my project. Then, if the syntax is similar enough to Go, you can use Go's text/scanner package: http://golang.org/pkg/text/scanner/
Ill break the parallel rendering code into another Library I have on Github, thanks for the advice.
You must have caught this sub on a bad day or something, I've not usually seen this much negativity here, especially in response to what is a very positive article about Go. Whether Node is "good" or not, it's interesting to see how someone primarily developing in it reacts to Go idioms/practices, both positively and negatively. Thanks!
Cool link, I'll look into it, thanks!
Libraries often have state or initialization with side effects. For example if you imported two MySQL libraries the latter would probably overwrite the former. You also wouldn't be able to transfer data between the two different versions because the types would be different. For example suppose you were using a redis library and passed around a redis connection everywhere in your own code. If you had two versions of redis included which redis connection would you define for you functions? (And how would you convert one type of redis connection to another?)
&gt; Javascript introduced the world to amazing things like 'NaN', which is a numerical value: &gt; typeof(NaN) "number" NaN is from IEEE-754. Javascript did not invent it and almost all languages behave exactly the same way. It's also a highly useful construct - I use it almost every day in Go.
If you continue writing blogs like this and investigating in detail you are going to surpass most people on this subreddit in golang knowledge. This is an excellent way to educate yourself. However, because you are using javascript as a point of reference when critiquing golang, most of us are going to be rolling our eyes because javascript represents all that is bad in the world 
Erm... what? Salting is taken care of automatically. You don't need to do anything.
&gt; An undefined value evaluates *almost* the same way as having a `false` boolean. Do you not use triple equals by default?
There's a situation such as: ``` if(someVar) { //use someVar } ``` where you're checking if the variable is just defined. Both `undefined` and `false` will make that block not execute.
Thanks! I'm not sure. I haven't posted here before so I don't know the community well enough.
How does it compare to Gin?
Which is the incorrect way to test for defined. You should use: ``` if(someVar !== undefined) { //use someVar } ```
I think you have a good thing going here.
That seems totally reasonable to me
I can't think of a situation where importing two versions of the same package would cause problems with overwriting initalization/state, excepting I suppose if some third package has some option that is changed between sql versions, and the value that sql@2 sets is incompatible with the value that sql@1 sets. However the solution to this is quite simply- reset the "import" cache when importing a new version. IE, sql@1 and sql@1 get two entirely separate compilations of each package they import. However, there's almost no state in packages at the top-level and this might not even be a problem. The packages could simply be aware that, to support versioning, they may not rely on third-party package state. Edit: In fact, this is already an issue! Two parts of your program (or two packages) can both import and configure a third-party package's state. Nothing changes from versioning this way.
That is really cool. Thanks !
For everyone interested - a second episode is up at https://youtu.be/eTjNtNnVOGY
How does this compare to config managers like Viper, which seems to be more full featured?
Well, it's just lightweight. Viper is a powerful tool in the shed, but usually would be excessive for most CLI applications. You know, we typically don't tend to store loads of config data. On the other hand, Viper provides lots lots lots of amazing features and I would definitely go with it for a complicated service with lots of configuration data.
&gt; Save writes a configuration from `path` and puts it into `v` pointer. Shouldn't this be worded the other way around? Either way, nice work. I'll be using this.
Eh, nice catch! Gonna fix it in a while.
Not surprised, second post on go-nuts the first time this was posted there last year is somewhat illuminating. Wonder if that's the reason the author moved the repo... https://groups.google.com/forum/m/#!msg/golang-nuts/_JzRd8bifqU/mVtMkoisb78J
&gt; get food to make yourself more long :D
Of course, Sieve of Atkin is faster but a bit more complex. My goal was learning Go and its standards while writing a lib. So I pick a simpler method. 
Probably the most useless comment you could ever write... I'm just trying to do the best I can, if you don't like it, just don't use it.
If you use git for managing releases you could do: VERSION := $(shell git describe --always --tags --dirty --long) Which always replace version with information from git. 
If you're going to share your code on a programming forum, you should expect programmers to look for errors and flaws. You probably shouldn't take it so personally.
It is? https://developers.google.com/protocol-buffers/docs/proto3#generating
Feature-starved is not "lightweight". &gt; Viper is a powerful tool in the shed, but usually would be excessive for most CLI applications. Any application would benefit from 12factors-way configuration. As I can see you don't provide flag- and env-based configs. &gt; If `path` doesn't exist, Load will create one This is a horrible design decision. Thanks for telling about the Viper though, it's a great tool.
I did as I wrote them. 
&gt;Feature-starved is not "lightweight". In fact, it is. Why would you need all the stuff Viper provides (like remote config?) for a silly 100-line CLI tool? &gt;As I can see you don't provide flag- and env-based configs. I didn't need one and I doubt most folks do. &gt;This is a horrible design decision. Elaborate please. What's wrong with creating an empty config in place of non-existing config?
&gt;One doesn't need any libraries of this sort for a "silly 100-line CLI tool". I need one, a couple friends of mine need one, a guy above needs one. Seems legit, doesn't it? &gt;It seems that this is the main driving force behind your design. 10\10 &gt;Read-type functions shouldn't cause such serious side-effects. How is it serious? How is creating of an empty config file is serious? It doens't remove anything, just creates an empty file.
Thanks. I will try this.
&gt; I need one, a couple friends of mine need one, a guy above needs one. Seems legit, doesn't it? Anecdotal evidence is kinda worthless. My point is that your library does nothing substantial that couldn't be done with a call of os.Open and a call of a serializer library. &gt; 10\10 What do you mean by that? &gt; How is it serious? How is creating of an empty config file is serious? It doens't remove anything, just creates an empty file. Any change in the filesystem is serious. By the way, does your library somehow handle the fact that the process might not even have the write permission for the directory in question?
If not for paperback, golang bootcamp is good place to start. Good sessions. https://www.golang-book.com/guides/bootcamp
&gt; I don't have any problems with it, do you? I don't because I won't be using something that should be called "a snippet of code" as a library. &gt; That you are absy right, the fact that I didn't need flag- and env- based configs and 90% of all the features Viper provides was the main driving force behind my design. Judging by the feature set sizes you don't even come close to a 30% mark. &gt; Yeah, it does. It would return a corresponding I/O error. Returning the error when the file is missing would be a saner decision.
I love miniLock.io, it's a really straightforward, no-nonsense way to encrypt things. I previously wrote a Python port, [deadLock](https://github.com/cathalgarvey/deadlock), but wanted something with better performance and requiring no C compiler or Python installs for end-users. This is the very first outing for go-miniLock, so be gentle. As-is: * Offers a developer-friendly way to use go-miniLock as a library. * Comes with a very anaemic CLI tool for miniLock. * Deliberately partitions header and body to facilitate later use in creating a Free/Libre [Peerio](https://peerio.com) server. Constructive thoughts welcome, as is code review. Sorry if it's messy!
I know great book: [Mat Ryer - Go Programming Blueprints](http://www.amazon.com/gp/product/1783988029)
:) awesome to hear.
Criticism, with suggestions and input, is how we learn from mistakes. Everyone makes mistakes, but what separates the people that improve from those that don't (of which there are plenty) is the ability to learn and the willingness to improve.
The main issue is that this library doesn't innovate anything. You are right in that it's my opinion though and I'm free to voice it here. &gt; And why so abrasively singling out this post among the half dozen "configuration management" posts in the past several weeks? I didn't notice any other posts because I browse this subreddit quite casually.
Mind a little friendly competition? Here's mine: http://danjou.de/goup/ (you can upload files as well).
is this actually a valid way to do something: `someslice[:]`? please tell me i can get a slice copy like that!
It's a perfectly valid way to get a slice that fully contains an array. You can also use it to re-slice an existing slice, but it won't be copying the underlying data. Re-slicing a slice like that will just make a new, mostly-identical slice header (potentially with a different capacity, otherwise identical) pointing at the same data.
Why didn't you use https://github.com/BurntSushi/xgb ?
tbh i totally wont because its copy(b,a) and not copy(a,b)... im just kidding.
JSON is quite hard to write if you're human.
You can use your operating system's service manager to configure your app to start. Ubuntu uses Upstart or systemd. You can install supervisord which can manage your service for you. Other option is to detach the service from your she'll session. Common tool for that is screen.
If you decide to use something like screen have a look at [Byobu](http://byobu.co/). It should be in your distros repositories.
I've been working on learning go and figured a wm would be a good project, so I looked into this. Sadly, all the example code is busted and won't run.
C developers look down on C++ developers who look down on Java developers who look down on Go developers who look down on Node developers who look down on PHP developers.
A MUD was one of the first things I worked on in Go, just as a way to feel my way around the language. I have no experience coding a MUD, but played them a lot in college, so figured, why not? Go is a great language for it... possibly the perfect language, honestly. High concurrency and all text-based networking stuff is perfect for Go. Here's my repo: https://github.com/natefinch/claymud, though it's no where near complete... I honestly don't even remember what state I left it in. At one point I could walk around in the world, but then I started refactoring some stuff and I'm not sure where I ended up. I started using boltdb (https://github.com/boltdb/bolt) for storage, since it required zero setup and is pure go, so I didn't need any external dependencies. It's technically a key value store, but it works well enough for a MUD if you're not too worried about the integrity of highly relational data... which I suspect you're not. Check out wolfmud: http://www.wolfmud.org/ That guy wrote his original MUD in Java back in the day and is now rewriting it from scratch in Go. He and I have talked back and forth some. He seems a lot more dedicated than I could really be on mine, though it's obviously still a side project for him. As for scripting languages, I highly recommend looking into Lua - it's what a lot of MMOs use, and it's a lot more sane than most hand-rolled scripting languages. There are a couple Lua interpreters in Go, I recommend https://github.com/Shopify/go-lua, since it was written by a large company and should be well supported and complete.
Definitely. I'd recommend picking apart one of the routers out there. You'll be shocked by how simple it is to do yourself, and from my experience having more application logic in the router was a huge advantage.
Oh wow. I have to take a look at that some time. /bookmarked
now running ChromeOS, but when on Linux, Wingo was for me the perfect middle between XMonad and the usual default :).
btw, if I see you here. There is a small, but annoing bug in wingo: there is a 1 pixel glitch between window content and window decoration (best seen in corners). Didn't managed to fix it myself, but since you are there, may be you can check it out? And, thank you for xgb and wingo! :) Used it in some my small projects. It's really great!
I think he is referring to https://github.com/codegangsta/gin and not https://github.com/gin-gonic/gin
People mentioned screen which is a good choice. Have you considered deploying using docker? 
Why not screen/tmux/nohup? /Independent dev having his own fun, so no ops team :)
Oh sweet! I happened to work on the same thing a while back: https://github.com/didip/tollbooth
We are using it in production for our API :) Simple, powerfull et easy to integrate.
Nice work, the CLI tool is very straightforward :). Hadn't heard of miniLock, from what's on the website it has many of the same design goals as PGP but aims to be easier to use, is that correct?
I downloaded protobuf, install it and follow the tutorials on grpc website. When I want to generate proto.go file it shows me: helloworld.proto:30:10: Unrecognized syntax identifier "proto3". This parser only recognizes "proto2". What am I doing wrong? 
Thanks! I'll try to keep the API and CLI usage fairly constant from now on, but I do intend to add useful features without overbloating things. miniLock encompasses several things: * A symmetric encryption system for arbitrarily large files, based on the NaCl toolkit recommended by diverse crypto-experts. * A metadata obfuscating header for the above * A user-friendly key derivation system for deterministically generating keys, based on Scrypt and NaCl, which encodes small and friendly public keys. * A really friendly GUI for the above The combination is more than merely a simple PGP: It's a PGP replacement for person-to-person encryption that removes the need for permanent key-files, encrypted or not, entirely. It exposes less metadata than PGP. miniLock public-keys are small enough to double as fingerprints and can fit in the smallest of practical communication media (microstatus etc.), or can be easily QRcoded or printed on business cards or put in an email signature. miniLock is also authenticating without being non-repudiable, which is far more valuable for messages and file transfers. This means that, given a file with a supposed sender and supposed recipient, I know that *one of them* made it, but not which. If someone shows me a file that you supposedly sent them, I know that they could have just forged it. But *they*, on receiving a file purportedly from you, *know that you sent it because they didn't*. Very clever way to ensure privacy and certainty of origin without providing a long-term incriminating record. Most of all, miniLock is designed for people like Journalists, Lawyers and common users. It's really easy to use and hard to get wrong. go-miniLock is *not* designed to be user-facing and easy to use by common folk, it's a CLI tool and a go library. Direct people to [miniLock.io](https://minilock.io) for user-friendly. :) But, what go-miniLock *can* offer that miniLock.io doesn't is versatility. miniLock can be used as the basis of a session-free authentication system for microservices etcetera, possibly even bypassing the need for SSL. It can be used to encrypt data-at-rest by servers on arrival, or to encrypt log-dumps for archival. It can also be used with GopherJS as a way to write miniLock JS apps that are transpiled in whole cloth, without needing miniLock.js bindings to begin with. And, because Go is increasingly useful for mobile development, it may form the basis of apps to extend the reach of the "user friendly" side of miniLock, too. Sorry. Can you tell I like miniLock? :)
I am very interested in collaborating and would be happy to merge any contribution you want to make. If you look at my projects you'll find that I welcome collaborators.. Hugo has over 200 and BEP makes most of the decisions on the project today. 
upstart / systemd can manage the process for you. and you get rotated log output in /var/log by default.
Well, note that I said "outside of development". If you're developing, tmux away, buddy! (still don't use nohup, though. nohup sucks) If you're deploying something when you're not actively developing, all three methods mentioned above won't persist across a server reboot and in general are kind of a kludgy way to keep a process going. What would you rather do for deployment? **tmux** ssh me@mybox tmux attach -t &lt;session name (provided you gave it a meaningful one)&gt; ctrl-c ./mything &gt; /var/log/mything.log 2&gt;&amp;1 ctrl-b n ctrl-c tail -f /var/log/mything.log (or look at syslog, depending) crtl-b $ &lt;and give it a nice name if you haven't&gt; ctrl-b d And then have to reattach to check logs and whatnot, or: **nohup** ssh me@mybox ps (find my job's pid) kill &lt;job's pid&gt; cd /wherever/my/bin/is nohup ./mything &gt; /var/log/mything.log 2&gt;&amp;1 &amp; tail -f /var/log/mything.log As opposed to: **upstart** ssh me@mybox service mythingd &lt;start|stop|restart&gt; tail -f /var/log/mythingd.log Or: **supervisord** ssh me@mybox supervisorctl restart mythingd tail -f /var/log/mything.log The latter two are just so much more convenient, IMHO, and much easier to transform into a deployable package, if you decide to go that route, because you've already done a lot of the footwork. Plus, correct me someone if I'm wrong, but once you've run something with nohup, it does exactly that: ignore SIGHUP. So, if you've decided to get all fancy and provide SIGHUP-driven config reloading, you lose that. Small niggle, I know, and you always have like SIGUSR1, but it's one less signal you can use. 
IMO it is a valid use case to name your return value but not use the name, great way to highlight the meaning of the return for godoc while still being explicit about what you are returning (some people don't like the bare return).
Heeey, I wrote one too! https://godoc.org/github.com/shazow/rateio Doesn't come with a bunch of limiters out-of-the-box but easy to bring your own and &lt;100 lines.
So this is a really neat idea. The core idea something a lot of test code could use, especially if it were easy. However, I think the fact this is a port (which was kindly called out directly) resulting in something very un-Go-like, both in the sense that the result is not idiomatic, and in the sense that the resulting API is really painful to use. There's `interface{}` flying every which way, with the corresponding blind casts, and without generic types there's not much ability to clean that approach up with reusable code. So I'd suggest that this is a perfectly fine place to use struct tags and reflection. Use struct tags to specify the sort of data you want to instantiate. Create a "factory" object that provides the context for the created objects, and allows you to "register" custom handlers as needed, though simply having recursive creation and some light attributes in the struct tags will be a good start. And then you end up with an API that looks something more like f := factory.New() var obj &amp;ConstructableObject{} f.Construct(obj) instead of that mass of functions on every invocation. The neat thing about passing things in through a function like `func (f *factory) Construct(x interface{})` is that the end user don't lose the type information, so the user is not constantly paying for dealing with casting things back out of `interface{}`. You should also find it's relatively easy to ship with a library of basic support for the basic types. Since this is test code, the usual objections against reflection don't apply.
I was hoping it would be as easy as something like casting, but I must be doing all the wrong things. I have very similar code working with pyvmomi, but no casting is required. I can simply dig into the various objects without fuss. I'm mobile with a toddler rolling around on me, and what follows comes from memory. Please forgive mistakes. The Returnval array is an array of an interface. PerfEntityMetric does not directly implement the interface, but PerfEntityMetricBase does. PerfEntityMetric has an anonymous PerfEntityMetricBase field. I can use the GetPerfEntityMetricBase function on one of the Returnval items, but I don't know how to access the fields of interest in PerfEntityMetric from that point. Very vexing.
Any reason not to do `slice2 := append(nil, original...)` ?
Ensure : $ protoc --version libprotoc 3.0.0 
It might make sense, to decouple the receiving/parsing of packages from the processing. For example, if you have a bittorrent client that needs to receive a package and write a chunk to disk - it might turn out, that a simple receive-write-loop is not very performant in this case, as you need to write for a disk-write to succeed before reading another package and the other way around. Decoupling that into separate goroutines might make sense. I don't think it depends very much on UDP/TCP whether concurrency is appropriate, but mostly on what you are trying to do with the data. If it's a problem that can well be abstracted into separate concurrent processes, you should probably still do it :)
First of all, thanks for coming itt. I am a huge fan of yours tbh, love what you do for Go community. I still think that we both are fairly biased (you created Viper, I created Store). I initially got a little frustrated with dozens of features Viper provides out-of-the-box (yet in an optional manner), since I was looking for a rather tiny wrapper for os.Open or some sort of. Interesting, but I am not the only one. A couple of my colleagues faced exactly the same issue also. That's why I hacked a dead simple Store in under an hour. Now take a look at README.md of Viper. I had to scroll 3 screens of text to understand how to basically (de)serialize a config struct. This tiny entry barrier is already high enough to cause some sort of frustration.
This is not a Go project (not that it doesn't look nice).
Interoperability ? 
That's why I said abuse ;) but yeah, for example using Go instead of Java for Android apps without need to go full native ;)
Will take a look, thanks :)
To be honest, I too never felt held back by Martini in terms of features. But to switch just the frameworks and keep the same kind of routes I already had, and then see a &gt;1k more requests per second was a good bonus. As for the issues raised in that article, since I am using it for an API and not templates I hadn't seen the template bug. And I don't use regex in my routes anyways. So I guess Gin was just more suited for my needs and an overall win. 
Congratulations to CERN team for LHC.
This only allows you to write the app backend. It doesn't allow you to tie into the native UI. Not sure if you get access to sensors etc. either.
For something simple, like a message multiplexor (think chat server), a single thread is quite often more than enough. There is a certain amount of queuing in your network stack that is more than adequate when each packet is self-contained and handled quickly. However, should your processing involve blocking operations, such as writing to a disk with unpredictable latency (think Amazon EBS or an external USB drive that may need to spin up) or calling out to web service, then some kind of concurrency is warranted.
Thanks for this! It seems especially useful when dealing with configuration files, and I've already had cause to use it in a project for work. Will definitely contribute where I can.
You have to set GOBIN as well as GOPATH. The way they have the environmental stuff set up really makes me question if they have a clue what they're doing. try export GOBIN=/home/me/go/bin 
but the version does not support golang!! Only these languages: C++/Java/Python/Ruby/Nano/Objective-C/C#. 
It does. It's just not mentioned in the usage. The idea is to support any plugin with the "mylanguagename_out" flag.
15 years or so of stunning open sources libraries and legacy code ?
I wrote a rough draft of solutions for this in Elixir: https://gist.github.com/mmmries/cd84b0d6008f58b83d95 I would love to get some feedback from people with more actor model experience about what I can do better.
thanks, I'm aware of this actually my code should be updated to similar to your answer
Thanks for posting this! I really wanted to go, but ran outta time.
Hm, interesting. https://github.com/str1ngs/jflect is pretty good however it doesn't handle dynamic json well. I will look forward to trying this package in those situations.
fmt.Sprintf() *does* return a string
You're asking why do ``` return fmt.Sprintf("%s:%d", c.WebHost, c.WebPort) ``` instead of ``` return c.WebHost + ":" + strconv.Itoa(c.WebPort) ``` ? It's just nicer to read, and easier to modify in the future.
I do yes. The golang is just ramping up but it looks like a lot more in future. I am in the docker / kubernetes area, there's a lot of go in play over here and the landscape looks pretty good for those projects. Can't really comment on larger golang demand though.
Because that won't work, WebHost is a string where WebPort is an int, and in Golang you can't concat two different types. fmt.Sprintf() is a helper that handles the typesetting for you, notice the %s and %d used. Check out https://golang.org/pkg/fmt/ for all the details. 
`WebPort` is an integer. Go is strongly typed so you can't concatenate an integer to a string.
Well, `c.WebPort` isn't a string, so your code won't work. `printf` functions are pretty readable to many programmers. Seeing `%s:%d` immediately shows what the output string is going to look like. I personally prefer seeing the format up front, and the data later.
Aye I agree with pre optimisations, but coming from other languages I would just build out strings so I found the fmt.Sprintf quite strange and was trying to find the reasoning behind it. Thanks for the good answer. 
Python 3 was such a failure that people are skipping it and just porting Python 2 code to Go instead.
server/create.go and server/delete.go seem to share a lot of code that is unnecessarily duplicated. server/routes.go doesn't use field names in a struct literal. It's allowed, but probably shouldn't be done because it can cause subtle bugs. Comments should also explain _why_ or explain when you do something that's not blatantly obvious. Comments like this: // Parse data from request if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil ... Just clutter the code. It's pretty obvious what's going on. See my PR for more reasons why your Go code sucks :-) 
Thoughts on how to de-duplicate server/create.go and server/delete.go? Originally I had two functions, one that returned an interface from the JSON request, and another that printed JSON response but our dev team told me to pull it.
The biggest issue was the anonymous structs which were shared between files. Other than that, I wouldn't pull to much out of the handlers because it'd over complicate the code.
Speaking of premature optimization, this post on SO shows simple string concat vs. appending to a `bytes.Buffer` vs. using `copy` - http://stackoverflow.com/a/23857998 
Seems fairly common. PHP has `sprintf`, python has `format` (`'{0:s}:{1:d}'.format(addr.Hostname, addr.Port)`), C# has `String.Format`, Java `string.Format`, etc... Even Haskell has an implementation of printf. 
I just started a remote work in Go :). Give me a few weeks and I can tell you how it's like. 
I agree with barsonme, the anonymous structs are ugly. Just declare a struct. You can just turn that create.go/delete.go into one unexported function and then make Create and Delete functions that call that function as appropriate. Repeated code like that makes your project impossible to maintain as it grows. I want to do horrible things to some of the people I work with because of Ctrl+C/Ctrl+V code.
see https://github.com/bitly/go-simplejson
Please no. Go has a simple and straightforward build process. "go get example.com/foo" should not turn into "download the source code, download fifteen compiler plug-ins of these exact versions using this package manager, build them all in *this exact order*, install pip to install and run this Python script that calls a bash script that generates twelve makefiles and a LISP-based configuration file; oh, and make sure that libc is at this exact version that was installed on my Ubuntu when I first started the project". You might think I'm exaggerating, but I've worked with people whose build procedures in their C/ObjC/Ruby projects are about that level of complexity. I don't want any of that in Go, no matter how many lines of code those plug-ins will "save" me.
I do, been doing so for the last two years. Demand seems reasonably high, though I've been working at the same place for those 2 years (I keep an eye on the postings as I'm looking for a new job in the coming months). It does seem that the positions are mostly intermediate/senior, so it may be harder for someone with little professional experience to find that kind of job.
\o/
Some initial suggestions, in addition to those provided by others: - `Model` should probably be `Person` (It will make the code easier to read when used by others) - `os.Getenv` will return an empty string if the environment variable doesn't exist. You could either check for these and provide feedback where appropriate, or, as this is a package, provide a "configuration" struct in which to define these. Or you could allow users to provide the full connection string, or even the MySQL connection returned by `database, err := sql.Open("mysql", d)`. Packages should probably not rely on environment variables. - Packages should probably not use the `log` package in most instances. Instead, return errors with descriptive strings that can be logged by code that includes the package. Pass the info up the chain! Hope that helps!
Well actually you can write generics this way. It's not ideal but it's possible. You can do it the same way C++ does; convert templates to concrete implementations before compiling. I came up with a mechanism for this via go generate about a week ago. Been sitting as a stack of papers on my desk until I get a chance to prototype it.
Looking forward to take a look
Sure you could. Fork the Go parser and lexer, then make your own generator that generates Go code, then hand off the generated code to the Go compiler. Adding generics would be a large change to the language - all the way down to the lexer. The whole toolchain would have to be updated. I think making it flexible enough to allow for this level of customization would mean it's no longer a Go compiler, but something more akin to GCC.
Great work on this. You're working on issues on the JSON side that I'm hoping to eventually tackle on the xml side (github.com/kylewolfe/simplexml). What I think needs to happen, though, is for a real solid library to emerge that can handle what your doing at the map[string]interface level, so that it covers the needs for any encoding library / dynamic structure (also unmarshal a map[string]interface to a struct). Additionally, I think there is a need across all encoding libraries to support what I'm calling an UnmarshalStrict, which returns used and unused parts of the struct and []byte during Unmarshal. The problem is that this logic needs to be inside of the decoder, making it non trivial to add.
To amplify on the other two replies that already exist, it is sufficient to use code generation to implement _anything you like_. Do you want to take a regex and convert it directly into Go code, rather than running through an interpreter? You can do that. You can literally do anything; you'd be writing a compiler that targets Go. On the flip side, if you want to modify the language with something as deep as generics, you're probably better off simply forking Go. The reason being is that any compiler plugin technology deep enough to permit that is either A: just the aforementioned code generation in disguise anyhow or B: a massive overhaul to the compiler to permit such a deep level of modification that nobody is ever going to do. That specialized to something like "generics", because as others point out, this would have to go in very, very deep. Far, far deeper than, say, merely implementing a new operator, which at least conceivably could be done as a plugin. And there's not much virtue to doing generics as a plugin anyhow... there's essentially 0 chance that a change as deep as generics and any other similarly extreme change would ever just "go together" through a plugin interface. It can't bring much benefit to Go.
Thanks all for answering my question. For GoLang been a new language it has a pretty good demand for remote jobs. I expect the language to keep growing. Thanks
https://godoc.org/?q=ftp First result is an FTP client: https://github.com/jlaffaye/ftp
You might want to check out [gen]( https://github.com/clipperhouse/gen) -if it's not directly usable, you can implement your own "typewriter", or at least get some ideas for how to structure your implementation.
Yeah, my code was a bit simpler and I only tested strings (no conversion from int), I guess that's why the difference was higher for me :)
You caused me a lot of confusion naming that function `parseJSON` when it's really something more like `walk_js`, and even the `_js` part of that name is confusing since it's a type called `js`, when it has nothing particularly to do with JavaScript or JSON. `parseJSON` is neither parsing, nor dealing with JSON.
Sorry!
I don't think those tests are testing the same things or showing the correct results. For example the `copy` example is dealing with `[]byte` and not a `string` like the others. Secondly using b.N as part of the test itself will mean that depending on the speed it could be dramatically different then the other benchmarks. This is due to Golang benchmarks trying to fit as many tests into a default of 1 second as possible. Finally the use of b.ResetTimer() and b.StopTimer() around only for loop doesn't make sense in this case. It's due to these mistakes that I think he came to the conclusion of `copy` being ~12,000x faster. Here's my version[1] of the same test, without `copy` as I couldn't wrap my head around what it's actually doing enough to create a 1:1 benchmark using strings. [1] https://gist.github.com/montanaflynn/180b897bb2945ec36b9e
I work remotely and the majority of our software stack is in Golang. It's definitely my favorite language to work with on a day-to-day basis. 
I work in the RTB (Real time bidding) field. Our services take a very high number of requests per second and must respond within a very short period of time (Under 60ms).
Using a router that drops into standard library HTTP interface is okay in my opinion. Using a whole web framework like Gin or Martini is probably asking for trouble. You'll likely spend more time learning the framework than you would implementing your application yourself, and you'll also raise the barrier of entry on your users as they'll have to understand your chosen framework.
Could you perhaps expand on how this differs and what advantages this might offer? 
Similar type library https://github.com/chrhlnd/dynjson it also tracks version information when you modify the underlying data and propagate changes up the hierarchy allowing editing of the raw data for easy modification in parts of the tree without full decoding.
Similar nice lib is Jason: https://github.com/antonholmquist/jason
[removed]
More like a tree HTML formatter, unrelated to JSON.
beautiful idea. But recursion considered harmful...
Even `fmt.Sprintf` is 10times slower, but it still much faster than IO which will be the bottleneck and maybe not a high frequency path. So, `fmt.Sprintf` is just OK. However, it maybe is better that merge `c.WebHost`, `c.WebPort` into one field named `c.Web`?
Instead of using graphql-go, you can also use the official [libgraphqlparser](https://github.com/graphql/libgraphqlparser) implementation from Facebook. It's a c library and they have provided a [golang example](https://github.com/graphql/libgraphqlparser/tree/master/go) to get started.
still an alpha, but I'm interested in gauging whether there is interest and listening to feedback
Neat. Definitely keeping a look on this.
It's Go not Golang.
Thanks. I live in US :) 
Have a look at [goquery](https://github.com/PuerkitoBio/goquery).
In addition to GoConvey, I'm a big fan of the assert package in [testify](https://github.com/stretchr/testify).
I don't know of one I'd actually call equivalent. People are doing some great work on implementing Go for arbitrary data structures but the truth is that Python is just more suited for a task like that than go. Why choose though? Setup a small python service to parse and pass back the data and consume it in Go if you need.
Haha, well webdev is out there though most Go frameworks are immature. Revel and Beego are good to look at. Go already has a strong ability to do distributed programming. I would look foward to a great rpg engine written in go. Good luck!
GoQuery is exactly the thing. :)
Another +1 for goquery, but depending on your task you may want to check out https://github.com/ericchiang/pup as well.
excellent! I look forward to trying this out, looks comprehensive and very well documented +1 for usage of the ContextHandler interface too, hoping this catches on more and more
wow. Go is based around internet uses but they didn't implement a simple ping system?
Would love to have you test this out against github.com/coreos/dex. No reason it shouldn't work, I don't have time to give it a shot at the moment though.
You don't, in go or otherwise. Doing stuff like this is unethical and illegal.
Sometimes it's useful to compare languages to learn more about the pros and cons between them. 
Here's a solution to the first exercise: http://play.golang.org/p/-d6zHH1iIf *Note: play.golang.org has a fixed time so `rand.Seed(time.Now().UnixNano())` does not have any effect and the duration of time taken will be the same for both people.*
&gt; a system you don't own *without permission and with malicious intent
I claim, that someone who doesn't understand why ping doesn't just simply work as a go library, won't be able (nor intends) to use this for defense or "understanding how the bad guys work".
Also here http://www.welovegolang.com/
You were setting `rand.Seed` every time you would want a random number. You should set `rand.Seed` once and leave it which will fix your issue of the number being the same for both people. http://play.golang.org/p/lVbDFaVLH_
You thought about the fact that it's not illegal before you wrote that it was illegal? I'm not defending anyone. I'm not advocating creating a mal-intended piece of software. I'm stating that *you* were wrong. It's not illegal. It *is* a great way to understand how the bad guys work. Whether he is doing that or not is irrelevant to what I said.
&gt; *without permission and with malicious intent **AND** If you don't have permission, intent is meaningless and it's illegal. If you have permission and then you abuse that permission, it's still illegal. If you have both, it's legal.
seconded
Cool! Thanks
Interested to know what others think of the code. Thanks.
Thank you ! :)
I think you missed my point. The hammer analogy was chosen for a reason. 
I see HaProxy has an API
Well this thread turned into a shit-storm. Thanks to anyone who posted helpful information!
Ok but in this case the program can terminate before the goroutines are completed. Since the `wg.Wait()` is in a goroutine the code does not wait for a goroutine to complete, so it just exit.
https://tyk.io/
Well, as useful as that may be for specific questions, you really ought to use a [local tool](https://www.reddit.com/r/golang/comments/3lahav/aligncheck_helps_to_find_inefficiently_packed/) for that sort of thing. (Linking to a reddit discussion because it appears to legitimately be the best link.)
Is this open source? I've been building an API with Go and I'd be interested to see how other developers are managing certain parts.
Sorry in advance for shitty commit logs :P [https://github.com/knrz/horoscope-api](https://github.com/knrz/horoscope-api) :)
If you're wanting a local tool, you'll actually want to use [maligned](https://github.com/mdempsky/maligned) as it [provides more precise information](https://github.com/golang/go/issues/12884), as mentioned in the article.
https://getkong.org/ . It is in lua
Output from https://play.golang.org/p/pYOZvBEZf5: Test coroutine Spawn coroutines CO[0] have 1 elements CO[1] have 2 elements CO[2] have 1 elements CO[3] have 0 elements CO[4] have 0 elements Got data: 'CO[1] = 0' Got data: 'CO[2] = 0' Got data: 'CO[0] = 0' Got data: 'CO[1] = 1' This looks accurate. 4 elements were created and added to the channel. All 4 got printed out. What was the expected output?
I reviewed the authboss and the sample program. It is a good package overall with rich feature-set. Couple of things I could not understand from sample: It appears to use Google as authentication provider. I need to replace it with the proprietary LDAP authenticator function like I described in my original post. Then it appears that the login/logout pages are automatically provided by authboss and I got no say in it. I already have a login form and the handler function for that form. In the handler function I call my authenticate() which returns TRUE if the username+password were correct. I don't know what to do next in that handler function. Possibly a silly question. From what I have been reading, I need to create a token and start a session. I have no idea how to do that. Thanks in advance! 
Agreed. Nothing's worse than someone who constantly does the most "efficient" thing even if it makes the code worse/less ergonomic/etc. In most cases, you don't need to use as few CPU cycles + bits as possible.
Yes. As a strawman. I got that. OP didn't ask for a hammer, they asked for a gun. They didn't ask for a tool that could be misused, but they asked for a weapon that *might* (though, see other comments in this thread, I don't really believe in that) also be used for ethical things, but *should* only be available to people that are a) aware of the ethical complications of what they are doing, b) are trained with it to prevent them accidentally misusing it and c) have a clearly defined need for it. I totally understand, that using the analogy of a hammer makes your point stronger. It's just a very bad analogy, because your point is pretty weak.
Why not just [add your code as a function](http://play.golang.org/p/lDJkrppvsM) instead of importing a whole additional package (note, that the time package will most likely already be imported in a real program anyway) just for this one simple thing? It seems to be kind of blown out of proportion. Especially as `time` is pretty much guaranteed to be more widely used and thus better tested th~~e~~an `github.com/daishisystems/month`.
How does this not work? The data seems exactly correct, even with larger values for rand.Intn
Exactly -- sometimes the random number is 0
Go is still simple. Trying to optimize any codebase's performance is always a tough one.
Thanks for the correction :) I actually wrote it as "than" first but it somehow looked wrong to me m(
I'm right there with you. OP originally had a single person "class" with 3 small methods split across 4 files. That's significantly more broken up than the 1 file per class "java style" that you're talking about.
No, this is more to an alternative for https://github.com/gorilla/securecookie, simpler and faster.
I was under the impression you could just do fmt.Sprintf(c.WebHost, ":", c.WebPort)
Sorry, it was my fault, the output is correct. But i cannot run it in my computer. I just copy pasted it and used `go run main.go` my go version is 1.5.1. Any ideas?
Sorry, it was my fault, the output is correct. See my response to /u/anupcshan.
Sorry, it was my fault, the output is correct. See my response to /u/anupcshan.
Ok, there were some issues in the code, this works also on my machine: https://play.golang.org/p/yacwB_DvRM Thanks for the support!
Good stuff, thanks
Dear tests, I love your so much that I keep forgetting you :) 
No worries. I had to look twice myself 
It would be nice if the compiler automatically reordered your struct fields for optimal packing efficiency.
I should. :)
Any suggestions for analytics? On the front-end I'd typically drop Google Analytics, but I don't know what to do here. :/
No problem. :) 
You've fallen for the trap of multiple go routines writing to the same channel. You need some form of a semaphore to determine when to close it. At least that is an option.
I don't, but some of the people on our team do - we're also hiring if anyone is looking! https://www.rainforestqa.com/jobs 
I live in Raleigh, NC and there is very little demand locally. I know of two companies using it here and I've been looking for quite some time. In NYC/Boston there seems to be more demand.
&gt;I am located in the East Coast? I'm Ron Burgandy?
i'd avoid soundcloud if i had the option. they've been hemorrhaging talent from chronic in-fighting. most of my friends left, and those who remain are unhappy. i used to work there, and it was one of the most unpleasant gigs in my career. not saying this from acrimony but rather warning.
You made a good point. In the examples shown, I am ignoring errors just to reduce the size of the code. In a real world use case you should handle every errors.
That can easily break any serialization or interoperability code with binary protocols, or with atomic operations, or with structures padded to avoid false sharing of cache lines or other processor specific tweaks. 
Shouldn't all those things be solvable somehow? For example, surely you don't serialize by dumping the in-memory bit pattern anyway. (Disclosure: I'm quite fond of what DataDraw does and wish that more language implementations were automatically that aggressive, perhaps with profiling inputs or something.)
Anything that could be classified as semistructured data, sparse attributes for example.
Congratulations Ron?
This is the first time I see someone using two `import` statements in a row: import ( "github.com/pmylund/go-cache" ) import ( "io/ioutil" "os" "path" "sort" "strconv" "strings" "time" ) 
"It depends". Sometimes not wrapping the error also makes it hard to properly act on, especially when the underlying error sources from something used through an interface, which means the underlying code has no control over the error, and you may not really know where it is coming from, so you really want the higher level error, rather than an essentially random error. (Which is hopefully still available if you need it, though.) Having used every major error paradigm you'll see people propose, from exceptions to sum types and everything else, my conclusion is: Errors are _really_ hard!
The same since you can't do anything stupid in driver for inserts. Only SELECTs are interesting (fresh results https://github.com/jackc/go_db_bench/pull/2).
Indeed, you are right. This would avoid any misunderstanding and unnecessary help requests. I have just pushed [changes](https://github.com/celrenheit/spider/commit/d9662a5bbb57c59a253c70224981e847790268b5) to better handle errors in examples and in the README.md.
Buy a stick of ram and be done with it. Jenkins even have a nice plugin that can set up various versions of Go for you
Tried following https://github.com/goincremental/negroni-sessions and example https://github.com/adamar/Negroni-Example The implementation is partially working. The session is maintained through browser restarts ( even when there is no cookie). Not sure if this intentional. This is probably not working as securely as I would have liked and I might need to do more study. But for now, I am unblocked and can go ahead and add more features. I will revisit the authentication later again to improve it further. Thank you everyone for the suggestion.
I designed a service using the Mailgun library for sending emails and tracking you can see it in your manager mailgun.com. https://github.com/dev-lusaja/Go-Mailgun
I think most of the third-party dependency management tools support tags and branches. I know gvt does. I know the vendoring plugin for GB does. 
However you generalize the point. You exactly figured out what you have to deal with in this article but in general you must know the downside. NOTHING BUT REALLY NOTHING is worser than someone who makes something inefficent and ignores to make it efficent while not knowing the downsides.
GPL3 is just as useful in Go as it is everywhere else. You just have to make your code available.
&gt; it can't be used in so many webapps because of it's license You are thinking of the GNU Affero GPL license, which requires you give out source when you run the server. (And only if you modify it.) The regular GPLv3 doesn't affect servers. The GPL is based on copyright, which only triggers when you copy and distribute the code. Only people distributing code need to worry about licenses. 
- read file normally - unmarshall it e.g. https://gist.github.com/border/775526#file-gistfile2-go-L78 (Line 78, main function)
https://golang.org/pkg/encoding/json
Thanks for clarifying it. However if you see any improvements can be added to the library. Please create an issue [here](https://github.com/go-resty/resty/issues).
Please don't do it paierlep's way. Reading the entire file at once is a bad idea that will cause issues for very large files. Go has a very commonly-used set of interfaces, `io.Reader` and `io.Writer`, that allow you to use buffered I/O instead of reading into massive byte arrays. To read JSON into a Go struct, use `json.Decoder`. Let's say that you have the following JSON in a file called `data.json`: { "name": "TwinBladez", "monthsActive": 2, "latestLink": "Importing JSON into Go" } Let's say we wanted to check if the user's name was `TwinBladez`. In Go, we'd do the following: https://play.golang.org/p/UB5Z4J4Bqr Note that this won't run properly on the Playground because it references a nonexistent file `data.json`. Check out the [encoding/json documentation](https://golang.org/pkg/encoding/json), especially the Marshal and Unmarshal documentation, for more information on how the package works.
This program seems to only work for 1 object. What if I had like 100 that were in the same file eg. {"name":"TwinBladez","monthsActive": 2,"latestLink": "Importing JSON into Go"}{"name":"Reddit","monthsActive": 10,"latestLink": "JSON"}...
That's malformed. It should have a pair of square brackets around it to indicate it's an array of objects. 
Does https://godoc.org/github.com/fasmat/trueskill mot support that? Also, I've found python code in general easier to translate to Go than C#/Java. https://github.com/sublee/trueskill
I see. In C++-speak, addressable would basically mean an lvalue, right?
You may want to look at the [Decoder example](https://golang.org/pkg/encoding/json/#example_Decoder) in the encoding/json package - it seems to handle exactly what you're looking for. Decoders can decode objects in sequence like that with multiple calls to Decode.
That's up to you I think. I'm sure performance is comparable. Which one is more maintainable? e.g. If you come back a week or a month later and glance at one implementation, are you able to instantly understand what's going on? There are lots of things I really dislike about postgres from a MSSQL point of view (pgSQL being the big one) pgSQL? Do you mean pgadmin? I'm also curious about what other things you find you don't like coming from a MSSQL background.
While this might not be valid JSON, in the real world, having to massage poorly formatted data is unfortunately a reality :). Try the following: https://play.golang.org/p/sKNTHG8Ld2 It implements a line scanner, wraps the strings in an io.Reader, and deserializes them into an object.
Hey look at that, I jumped the gun, already deleted this thread and.... https://github.com/fasmat/trueskill/blob/master/game.go#L57 "TODO"
Yes, they are similar.
Go is not more performant than Java/Hotspot JIT in MANY circumstances. In fact I would make the generalization that it is less performant in most circumstances.
How do you handle a correctly formed JSON array with your example code above?
It is definitely hard to implement a system that is practical in handling errors. I do think that Go is the closest, simplest step toward a working solution so far. That's only my opinion though. I guess that it is because of the "errors are values" mantra and the subsequent design of error as a specific interface. Errors should be indeed accounted for in the design of the type system. The problem is that error values appear dynamically so it is difficult to deal with them statically. Go takes the easy way that works today by using multiple returns. This is the most convincing attempt I have seen at dealing with errors so far. Usually, it seems that people would like to encode the fact that a value can be erroneous (or not). It's a long shot but I could imagine some attempt to deal with this in the future. But it would probably require some flow-sensitive analysis amongst other things (concurrency makes things a bit hard here). It would also probably require types to be encoded as interfaces in some intermediate representation (**because a type is in fact nothing more than an interface around a resource : memory** ). That would allow the use of subtyping to deal with erroneous values of a certain type. Interestingly, if it is possible (i.e. computable), the same principle would allow to deal with nil checking at compile time (easier rules for definite assignment as nil would be a true bottom type now). But yeah, that's the higher level view. 
Because I couldn't find an existing tool, I made this. It simply finds and prints the location of a go executable's main.go file. For instance: $ Src goimports # prints: /home/mehlon/go/src/golang.org/x/tools/cmd/goimports/goimports.go I use this to quickly open and read the source code of a command, without having to search for it in my GOPATH. 
That is a perfectly legitimate key name. As others have said, your issue is that the file itself is malformed json. The whole thing needs to be surrounded by brackets, and each object should be separated by a comma. Having said that, there are ways to deal with this. Have a look at the example pointed out by /u/SaidinWoT below using the json Decoder.
Oh okay. I tried that method but it doesn't seem to work when I use the format with the lower cases, but works perfectly fine when I run his code (which use capital letters). This is what I ran: https://play.golang.org/p/BJ01ydmDdV and this is the output : Knock knock. : Who's there? : Go fmt. : Go fmt who? : Go fmt yourself!
https://play.golang.org/p/CMX6MPlzK5 There's a fix. You need to make the struct method start with uppercase, and tell the parser explicitly that the field name is 'firstName' 
BLESSED. Thanks so much, it works perfectly!
Author here. If you have any kind of question, i am ready to answer this. Even feedback would be cool. Positive or negative. Both welcome :)
perhaps a regex match for valid base 64 chars (alphanumeric, `+` and `/`.Whether or not it means anything is up to you from there. You could also try to decode with the base64 package. If the input contains invalid base64 chars it will return an error. Why are you downloading unknown data?
I'd go for http headers, or doesn't the server tell you what it's sending? Not sure if there's a content transfer encoding header in http as there is in mail. I'm on mobile, so sorry if this doesn't actually exist.
Broken on mobile... Questions are cut off 
It is definitely solvable. Have you tried aliasing?
I know the answer [spoiler](https://play.golang.org/p/JQbT0MupO5) and it works in the playground but it doesn't work in your quiz. 
spoiler does not work :-/ 404
not ready yet, sorry
thanks, working on that
you forgot Println - it is from fmt (first p is capital)
I wasn't even looking at the print statments because you screwed them up in question 7, and there is a builtin with a lowercase p that could be used without import. 
probably use C pkg and write a header line for the relevant win32 api system call, and then use that func i dont got specifics tho :? maybe someone knows
Check the Content-Transfer-Encoding header. It should indicate base64 encoding or not.
This question just hit /r/programming in so many ways and I think the answer is the same. the thread is here: https://www.reddit.com/r/programming/comments/3o72dr/why_sql_is_neither_legacy_nor_lowlevel_nor/ the tl;dr is: Use materialized views if you absolutely have to store logic in postgres. You're probably better off managing it with your go code. Why? Loose Coupling -- if your database is tightly coupled and has critical business logic that your application Has to have, you run a bigger risk of your database creating headaches instead of storing data.
Try [Google](https://www.google.com/search?q=windows+screen+capture+Golang&amp;btnK=Google+Search)
should be working now
Yup! Awesome
Would someone mind explaining #8, "Unsafe"? I've never used uintptr before, which is part of it, I'm sure. 1. Why does uintptr + 1 advance the pointer one byte? I couldn't find the size of uintptr, but would have expected it to be 64 bit, and that adding one to it would advance it 64 bits. 2. Why is it 2 instead of 256? I'm guessing this is little endian? Is that system dependent? Edit: I looked around at other examples, and saw people adding the size of a value to uintptr to advance by one element. I guess adding to uintptr is always in bytes, not element size. Interesting! Edit 2: Found a Stack Overflow post describing uintptr as a way of getting the address as a number. This makes sense now. Adding 1 to it, then converting back to a pointer, and given little endianness on this specific system.. I get it now. uintptr is cool :)
That does seem to be possible, but does that then mean that most of those errors are probably non-issues?
Specifically, the endianness? Ya, that's what I expected. 
Valid points, but said a little harshly. It nerd-sniped me with # 8, and I ended up learning about uintptr, so it was worth my time :)
This is a good start, but these are only integration tests. By that, I mean that they depend on an external module (your mysql server) in order to work. These kinds of tests are important, but they're not the most useful kind of test. What you really want are tests that don't rely on external modules a.k.a. unit tests. Unfortunately, the way your code is laid out right now makes it kind of hard to write unit tests. You'll need to use a technique called "dependency injection" to be able to swap out your dependencies (in this case the DB) with something else like https://github.com/DATA-DOG/go-sqlmock or https://github.com/erikstmartin/go-testdb. Now there isn't one right way to inject your dependencies, but in this case, I'd recommend the following approach. 1. remove the *sql.DB variable from the package's global scope 2. modify your connect function so that it returns a *sql.DB. 2. modify your the Create and Delete methods in the person package to take a *sql.DB as input 3. turn your handlers into methods on an Env struct as described in the dependency injection section of [this blog post](http://www.alexedwards.net/blog/organising-database-access) and have them pass the *sql.DB from the Env struct into the Create and Delete functions on your model. 5. modify NewRouter to take in a *sql.DB and use it to create the Env for your routes. This will involve moving the routes slice initialization into the NewRouter function. 6. Finally, call connect in main (like you're doing now), and just pass the db handle down into NewRouter. If you've done everything else right, it'll pass all the way down into your model's create and delete functions via your handlers and their Env struct. I know this seems like a lot, but once you've done that, you'll find that you can begin unit testing at any layer of your application by just creating a mock *sql.DB and "injecting" it in place of the one that person.Connect returns. It may feel like for something this trivial, having unit tests is overkill, and that feeling arguably isn't wrong. That said, if you wait until your code base is complex enough to need a test suite to start making your code testable, you'll find it nearly impossible. It's way easier to start make sure your code base is testable BEFORE it gets complex enough to make you wish you had tests.
Thanks, updated questions with fmt.Println(...).
Awesome thanks!
why wouldn't you provide a link to the answers?
I cannot take away from you joy of discovering them on your own :) (sorry, just kidding) Just because it is not ready yet. I'm doing it at my spare time so will do it when I will have a little more time. At the meantime the best probably would be just ask there.
Well your JS is not compressed so viewing source is a pretty easy solution
Wow, this looks like the best MVC I have seen so far! Thank you for releasing it!
Please support [RNN](https://en.wikipedia.org/wiki/Recurrent_neural_network) and [LSTM](https://en.wikipedia.org/wiki/Long_short-term_memory)?
I actually wrote https://github.com/djherbis/nio for similar purposes, https://godoc.org/github.com/djherbis/nio#NewReader but with customizable Buffer functionality and size. This library looks pretty handy too though.
Glad you like it!
Exactly.
Well regardless, Go has a decent debugger now anyway with Delve and IntelliJ so if someone wanted to debug they can!
I think this might be a mistake? https://github.com/verifiedninja/webapp/blob/master/route/middleware/logrequest/logrequest.go#L17
https://github.com/mattn/gyagowin
[removed]
If you mean the hardcoded date, that's how Go's date formatting works: you offer the preferred format using that exact date/time as your formatting example.
That looks very nice too! I didn't find it, when I searched and asked on the Go forum. Your "buffer" package looks to be really cool. I will definitely give it a spin. 
You might want to try using [github.com/gonum/matrix/mat64](https://godoc.org/github.com/gonum/matrix/mat64) instead of go.matrix.
what was your biggest challenge developing this?
Agree
After some googling I've found [this issue](https://github.com/golang/go/issues/9365) with lots of info on the topic. In particular, Ian Lance Taylor wrote: &gt;I am not a crypto expert. But I believe that the Go runtime is somewhat resistant to this kind of attack because every map uses an individual hash seed that is chosen randomly at run time. Since an attacker who is not on the local machine has very limited visibility into map lookup times, I think it would be quite difficult to run such an attack remotely.
Yes. I actually just reimplemented the above function in Go, I guess because I have a bizzare need for all my tools to be written in Go.
Very cool, I like how small and focused the package is. Now I'm wondering if it would benefit me somewhere in my code...
Oh that's interesting. Seems rather counterintuitive given how string formatting functions work in Go, and also how date formatting works in other languages.
This? echo "GET /" | nc -v www.google.com 80
Nice idea -- needs working search maybe (and a global search)
Besides the speed which is listed, has anyone used this? What are some of the benefits over the other web frameworks out there or the standard http library? 
Its definitely better than the standard HTTP library because it adds an incredibly small amount of overhead yet increases programmer productivity substantially. Its unlikely you could implement your own router for cheaper, unless your application simply doesn't need a router. But the same could be said for Gin as well. It seems like Gin and Echo have very very similar APIs and performance metrics. **Startlingly** similar APIs. As far as micro web frameworks go, you can't go wrong with either of those two. 
Great. Thanks for the input. It looks very simple to use for sure. 
This looks interesting. Some more comprehensive documentation would help a lot, maybe a more complete example than just serving static assets in the website folder. Good job
Your websocket example uses Go standard library websockets, I thought they were "broken" and you basically had to use Gorilla websockets.
Your right about that string Actions; I've updated them to be type int, and provided package level constants that can be used.
He means something like ``` struct App{ logrus.Logger Other Fields } app := App{Logger: logrus.New()} ``` My thought on this is while this does not make it that obvious, I don't see a pragmatic alternative. I find it good enough that I am warned if I am trying to put in the wrong type. 
No.
After a few issues with my machine, I've posted a new screencast (a little bit late). Check it out! https://youtu.be/LQi0N0nA5RA
Thanks for pointing out that the `Transaction` stuff was weird, because it was. That was a remnant of a different direction that scribble was headed, but ultimately got left in unnecessarily. I've removed it, and tried to simplify things by just having the driver call the methods directly and just passing in the path/resource you want to use. Thanks for all the great feedback
Even within the stdlib there's stuttering, "io/ioutils" being one of the big ones. It's just a guideline.
It was not particularly difficult (for me) since I've built a few systems like this before. Basically getting up to speed on the Hashicorp Raft API is the biggest part. This system is a simple reference though, not a production-worthy piece of code. That would require significantly more work (testing, documentation, configuration and management).
I am trying to implement a small site in both. Echo advantage is in ability to have paths like /static/*filename and /:city coexist and resolve correctly. I was able to workaround that in Gin on a couple of projects, so it's not a showstopper but a nice to have feature. Gin has easier to write middleware. Echo adds an extra wrapper and I still have to understand it and find a way to do complex things like aborting, modifying route, and rescanning). Gin also uses "official" context package. Mind you, I have not used rendering integration, validation, and binding but I do file uploading and streaming with Gin. I don't like the way Request/Response accessed in Echo (methods rather than fields) and that there is not shorter accessor for response writer (it is c.Response().Writer() now). It's easy to add though.
Whoops, thanks for letting me know! Just fixed it
Awesome, I'll check it out. Thanks for the recommendation :)
Read a bit about WaitGroups. This is how I've handled them all and they work very well.
Exactly my point, means you can't use it in any client projects where they can't release the source, e.g. government systems, so to me gpl go libraries are not usable for many projects, so I move on to the next library that is BSD or MIT licensed.
Why not contact the author and negotiate an exemption?
Poorly worded by the poster, it produces a binary executable that includes its own runtime. The comparison with Java whilst alarming is also passable. Since Go includes its own scheduler and GC. The obscene size of Go binaries is no joke, and I'm looking forward to them solving that, currently at 6MB for a "Hello world" as fas as I know.
Thanks. I will set up a global search. What do you mean by "needs working search" ? Is it not working? It does for me On Firefox or Chrome.
For example deployment with Kubernetes :)
AFAIK gccgo does bring that down quite a bit... but then you miss the interop stuff of Go 1.5...
&gt; Poorly worded by the poster, it produces a binary executable that includes its own runtime. Just like statically linked C. I wouldn't just call it "poorly worded", but plain wrong or irrelevant. Every non-trivial language needs a runtime and it obviously either ships it (statically linked C, goâ€¦) or it requires it to run the code (dynamically linked C, Java, perlythonubyscriptâ€¦).
I you haven't already, look at http://www.golangprojects.com/ - only downside is that filled positions are rarely removed.
Nice! May I suggest you look at the tag start and termination conditions. It doesn't seem to be mentioned very detailed in the documentation. Take a look at how twitter and others terminate hashtags, and make it like that. There are a lot of things you do and don't want matched. Of course, you could make it configurable. It seems like you handle most cases, except that twitter allows certain other characters to terminate a hashtag. [Here](https://gist.github.com/klauspost/be90532e3f3242d3014a) is an example for something I made a while ago for twitter-like hashtag splitting, with a matching javascript regex. Other than whitespace it terminates on `'.', ',', '!', ')'`. Add a ton of tests/example. You don't want common things like `klauspost@email.com` to trigger an `@email` mention for instance. 
take a look here... fairly new site http://golangnews.com/stories?q=Hiring:
Instead of waiting for someone else to do it, you could learn how to code and do it yourself.
Seems that `Delete` was partially implemented =P: https://github.com/otoolep/hraftd/blob/master/store/store.go#L144-L146 https://github.com/otoolep/hraftd/blob/master/store/store.go#L218-L223 Also I'm not sure how `raft.Apply` works but will it be invoking your callback synchronously and serially, or asynchronously? https://github.com/otoolep/hraftd/blob/master/store/store.go#L135-L138 Because the apply callback locks the map to `set` or `delete`: https://github.com/otoolep/hraftd/blob/master/store/store.go#L212-L214 It suggests that the callbacks will be async and done from any goroutine. But if that is, then the application of the raft log on your `map[string]string` isn't guaranteed to occur in the proper order. For instance, what if 2 `set` requests are sent at the same time: set a 1 set a 2 the two `Apply` callbacks occur and then they race to the mutex lock: https://github.com/otoolep/hraftd/blob/master/store/store.go#L212 but then for some reason, the `set a 2` gets the lock first?
Have you tried running a go webserver on Android, and using a web browser as GUI? 
Yeah that looks very cool. It seems to be heading in a different direction than I want to go down.
I'm hacking on a tiny experimental package. It treats layouts as data and then I use encoding/xml to encode to android xml or HTML. So far I've only got a trivial version working for HTML. It outputs to xml as well but I haven't started connecting it to android code.
Didn't work for me at all. Chrome on osx. 
I didn't think in any real (aka biz) use-case before starting this project, I just thought that using Neo4J for that could be cool :)
Mobile is dead. Everything is Node.js and jervascript. React.js Angular.js Gojs
top kek
Yeah, DELETE is done now. As for the ordering, the keys will be changed in exactly the order that the Raft leader received the requests. That is the point of Raft. The map is locked because a GET operation may run concurrently with a SET or DELETE, not because of how raft.Apply works.
I absolutely could, and that's the leading option for a pet project right now, but it ends any hope of shipping an app for others. The very first step, "launch this from terminal and then go to localhost..." is a complete no-go for 95% of potential users. Localhost servers also suffer uniquely risky vulnerabilities as the whole filesystem may be considered "same host" for CORS purposes!
Would it be possible to create a golang app which on start launches a webview to point at localhoat and starts the server? The approach you describes is definitely not a viable solution from a user perspective.
&gt; Well that is a true statement, every language in the end generates native code. That's a false statement. QBasic never "generates" native code, it's always interpreted by an interpreter. Same with Ruby and Python - without an interpreter, they're useless text. Go has a runtime, but Go code is still compiled directly to native code. You're conflating a "runtime" with "native". They're completely orthogonal concepts, much like "garbage collection" and "reference counting". Swift, for example, uses reference counting to manage memory, does *not* make it a non-native language. Native is *not* only C code. The penalty you pay to call C code has *nothing* to do with whether you're "native" or "not". You're conflating multiple concepts/issues into one. 
You will notice huge performance improvements with go compared to node code *that requires npm packages*. Your node_modules folder grows above 100k lines of code very easily and the smallest Lambda workers just time out because they can't load it all. Sure, you could upgrade it, but as soon as you scale up the workers it makes sense to try to only use what is actually needed. Writing it in go allows you to use the resources you have way more efficiently . 
Can you run "adb logcat" and start your application?
Well stated. I definitely think there's a really good place for Node.js in Lambda and I'm not surprised that was where they started. The JAWS framework is particularly interesting (and amazingly convenient) for using Node.js to build microservices in Lambda. However, given that every millisecond counts, I felt that Go made far more sense. It's a little disappointing that they charge in 100ms rounded up. It would be nice to be charged in 1ms increments or even nanoseconds. It is absolutely possible to have Lambdas running in nanoseconds and if we are talking about "micro" services. Though when hooked up to API Gateway, you aren't exactly going to get responses as fast. API Gateway is actually the slower part of the equation (or whatever happens between Lamba and API Gateway). To be frank, I think it's just too slow to think in terms of 100's of milliseconds. ETL type purposes (a common use of Lambda) are a different story and those are more like seconds and minutes anyway. I'm more interested in composing many tiny services that would be quite common to run in well under 100ms. Even the IP-&gt;geolocation lookup service (using Maxmind's data set) I've done runs faster than that. I mean, this is to say IF Amazon is really all about the "pay for what you use." I am really enjoying Lambda though. I'm going to throw more load at things and see if I can produce errors, but so far it's been rock solid and fast...And easy.
A full featured image/webp package (Encoder and Decoder) Image compression libraries in pure Go (pngcrush, mozjpeg)
Git repo: https://github.com/haisum/rpcexample
Go still lacks a high-class XMPP library.
I think Go would profit tremendously from having equally powerful equivalents to Wordpress and Drupal (Gopal!). These are basically the reason why PHP is still relevant today. So I think this would give Go (the community and ecosystem) a great boost - lots of developers flocking from PHP to Go, lots of websites getting faster overnight, Go becoming the [standard for web development like PHP is](http://w3techs.com/technologies/overview/programming_language/all) and a huge boost in job openings for Go. Win win all around. 
IMO Go ORMs don't quite stand up to those found in frameworks like Django and Laravel yet. Significant improvements in that area would would be nice, but also laborious. Edit: why the down-votes? Have you guys even tried using those ORMs? Some impressive stuff.
Having what I'd describe as a good amount of experience with both the Django ORM and the Go database/sql library, I'd say that: 1. dynamic lang ORMs map well to dynamic lang facilities 2. it works poorly with Go because Go itself works against it 3. these reduce code but incur the cost of incredible complexity I do agree that there's still a lot of room for improvement in the way Go libraries often deal with sql, but I don't think those improvements will look like the Django/Laravel ORM.
I agree that Go doesn't make this kind of abstraction easy. Something might be possible using a combination of AST walking generators and interfaces though. The result wouldn't be exactly the same as those ORMs of course, but still have the potential to be incredibly useful.
The [exp/shiny](https://godoc.org/golang.org/x/exp/shiny) package is an attempt at a cross-platform app framework. The sensor access and sound libraries you talk about are already part of the mobile repo, as works in progress. 
Very similar package for more general use (not only Twitter): https://github.com/matryer/anno
I was trying to work on some side project that needs sentiment analysis using natural language processing. There are some small projects that do that, but they seemed nowhere near Python's NLTK in terms of maturity. I see a lot of potential in Go when it comes to machine learning. It can easily take Python market share in that area in a few years.
I would very much like to see a good QUIC package :) Not only for chrome users, but also because it gives huge wins over unreliable crappy networks (like mobile) for general non-HTTP usecases. On the other hand, it's probably more likely that the wins of QUIC get incorporated into TCP, than that QUIC itself becomes widely adopted for non-chrome/non-HTTP usecases :)
A fully-featured plotting library that allows for the creation of journal-quality plots. Plotinum and friends are nice, but they aren't on the same level as what you can get in other languages (because a good plotting library takes a massive amount of manpower to write). Probably the most sane thing to do would be a semi-comprehensive wrapper around pyplot via CPython. gonum needs to be greatly expanded and certain existing parts should probably be aggressively audited, too. The current maintainers are awesome, but there are very few of them. Writing good numerical code takes a while and requires a lot of very specific background knowledge. I've been focusing on just writing B- and I-spline implementations for the past few months, and the amount of background reading you need to do just to keep yourself from making something harmful is significant.
QUIC is like TCP but over UDP, specialized for HTTP. It kind of combines TCP features with TLS so your TLS handshake only requires one round trip and since it isn't TCP-based, it does some clever things to improve perceived performance. Basically: faster page loads. Go to google.com with Chrome and click the padlock icon, then the Connection tab, and you'll see it uses QUIC.
I've used https://github.com/cdevr/WapSNMP for my simple use cases, but I agree that something more fully featured would be nice.
Anything GUI related which will stay alive.
&gt; Are you sure you want a bunch of PHP coders in here asking questions? Yes, languages are tools, not religions. Using PHP doesn't make someone dumb. There are a lot of practical reasons for using it, and billion dollar companies depend on it. 
I would like to see a authorisation framework that could be used in a typical web application. Some sort of role / activity based permissions.
[removed]
I started one a few months ago: https://github.com/Preetam/snmp It only supports SNMP v3. I need some more time to clean it up, support more of the protocol, and test, but it's a good start.
I'd like to see a nice wav and/or mp3 decoder. We need good audio base libraries first though. (Think `io` for audio.)
I kinda do when I look at the open PHP positions and most of them are tied up to some CMS/framework, it's rarely people wanting developers to take care of their in-house custom thing... but the other comment is right, I guess the low barrier of entry on PHP is another reason - the reason they get into PHP at least, not necessarily the reason they stay (assuming that after a few years they are proficient enough to understand Go as a next step). Go also has a super low barrier for entry - you can learn it in a weekend and as a compiled language it is harder to shoot yourself in the foot (comparing with PHP where you can happily sum an integer with a string).
[removed]
&gt; The reason for PHP's success is its low bar to entry. It's the reason people get into PHP in the first place, but not the reason they stay after many years (when they are proficient enough to understand Go - let's be honest, Go is not that complicated and PHP's standard library is much larger). I can see how someone that is smart and picks up PHP could easily get into Go after a couple years, even sooner. &gt; You've never used Wordpress have you! Not Wordpres but I've done a lot of work with Drupal and there's definitely nothing even remotely close to it in Go. &gt; Are you sure you want a bunch of PHP coders in here asking questions? It would be annoying at first, yes, assuming that you're refering to "PHP Developers" that do nothing but copy and paste code from StackOverflow and call it a day - but any good PHP developer would be more than capable to pick up Go and that's kinda what communities are for. If it becomes a problem we can always put together a "Go for PHP developers" document that would over time cover most of people's questions.
[removed]
Audio base libraries would have nothing to do with the standard library. At the moment there are no standard types for implementing audio streams. They could live anywhere.
Yes, I'd really like to see a 'native' go gui solution with a lot of development happening, I had great hopes for 'gxui' but development seems to have stalled somewhat: https://github.com/google/gxui Then there's 'shiny' which is also interesting, : https://github.com/golang/exp/tree/master/shiny
Unfortunately there is still a lot of SOAP in the world. Ignoring it isn't an actual option in many cases.
These are cool but there's only *two* of them. Be really interested in seeing more.
Both - there're topic-related channels (docker, devops, jobs etc.) and location-related ones as well. 
I never thought about trying it this way. It still feels incredibly dirty, but less so than a string.Contains() against TypeOf().String(). In my specific case, I only need to handle this if it *is* truly anonymous, so this concept will work for now. I wonder if the developers of Golang will improve the reflect package to allow an approach that ensures a bit more integrity. Thanks for your suggestion.
MS= Morgan Stanley or Microsoft? 
Thanks for the feedback. There is a lot room for improvement in the package.
I'm actually working on a CMS. I have a basic version running in production and it works pretty well, but right now it pretty much just supports rendering markdown posts to HTML, themes and "includes" for themes which are reusable HTML template snippets. The main fallback that I can see is to make sophisticated plugins isn't as easy as it is with Wordpress. My thought is that they would need to work over an HTTP level where there are REST end points that are hit and some template logic that would be able to communicate with these end points, but it's still something I'm working out. My blog dougcodes.com is powered by the CMS, and I run it for free on a heroku instance and is cached by cloudflare and between both services I get free SSL so it's a nice setup. My thought is to have it an open source project that people can self host if they want, but basically have a product that is hosted on Heroku or Digital Ocean with one click installers.
What about [Gorm](https://github.com/jinzhu/gorm) and [Xorm](https://github.com/go-xorm/xorm)? Have a look at this list: http://awesome-go.com/#orm
It is perfectly valid, and I would expect it to remain as such for Go 1.x. Anonumous structs will not suddenly be exported. However it will also be true if the passed struct type is just unexported. Here is some code that analyzes fields in a struct: http://play.golang.org/p/QjixAKL6_Q
http://apiumbrella.io/ One more. It is done in ruby
Nice, my current client run all their Go applications on Heroku and we have been very happy with the performance. That said, benchmarks like this are pretty meaningless unless you know what each request actually _does_ :)
I'm a PHP coder and feel I have a fairly good grasp of computers
That looks to be around 5ms of processing (and the average is going to be even lower) so not very much. As a rule of thumb, a simple proxy will typically take 1ms per request on average.
* A python interpreter built in Go that would have no dependencies on any installed Python * A GUI lib for CAD type apps 
Heyyy.... I don't know, sorry :( Does it work on a real device?
This looks really cool! I'm currently building my own RESTful API with MongoDB, there are a few differences with how you've set yours up and a few things I hope you don't mind I steal (Using alice to wrap your endpoint functions). Good job! I'll definitely be using this in the future
Do dumb people know they're dumb?
yeah.. It does work on real device. :-)
are there webp encoders for other languages?
Sure, thanks! Also, feel free to ask any questions. I love Alice too, it provides an elegant way to deal with middlewares on top of http.Handler!
Thanks so much. You have posted the most useful ones.
I would disagree that that's [an "abuse" of interfaces](https://go-talks.appspot.com/github.com/guregu/slides/comiket/comiket.slide#23). You might get a performance win on making everything in Visible have to be Animated as well, though you might not, depending. Remember it's perfectly fine to implement: func (w *Whatever) Animate(delta time.Duration) { // deliberately empty } Also, over time, you'll probably find that in general you want something more "semantic" than checking for whether something is a *Player... most such questions can be turned into method calls. The more you do that, the more you find yourself able to easily implement things like "I win if my AI partner makes it to the exit" or something. Methods can be polymorphic, type checks are explicitly throwing that away. You can provide default objects that implement "not a player" behaviors for those calls, and if you put that on what is otherwise an empty struct (`type NotAPlayer struct{}`), they can end up consuming 0 bytes of RAM.
One option is to define an [UnmarshalJSON](https://golang.org/pkg/encoding/json/#Unmarshaler) method on your map type. In that function, you'll use encoding/json to unmarshal into a temporary `map[string]string`, then convert everything over. It's not even necessarily _all_ that wasteful... it ends up overallocating a bit, but it's what the encoding library would be doing anyways other than that, because it's all `[]byte` to start. But I'd also put out there that `encoding/json` is designed more for ease-of-use and common cases than absolute power. It is not out of the question that you'll have to go get something from github or something. I don't think you're there yet, it's just something you should have in the back of your mind... it's not a crime to not fit into encoding/json's view of the world.
You're right, I can't tell. All I know is I'm alright when it comes to writing software
http://play.golang.org/p/-gWdAsjSwM would be similar solution with better performance while decoding big amount of data but requires custom int64 type
8 standard 1x dynos. I haven't ran into any issues w/ using up too many connections per router..probably because I try to close the connection ASAP. If I'm writing analytics to a database, I cache what I want to write and close the connection and have another function going through the cache and writing to the database behind the scenes. The bulk of these requests are all purely read-only, and all that data is cached.
Do another push and you might get a different IP.
I'm very impressed. We traditionally work in c/c++ for the speed, but go gets us 80-90% of the speed with a much simpler codebase and less dev time.
Relative to PHP, Go is in the mainstream of manifestly-typed static type languages. If you wish to be considered a professional, sooner or later you're going to have to pick one up; for all the advancing that dynamically-typed languages have made in the past 20 years, manifestly-typed static type languages are still the dominant technologies. Go is probably one of the easier ones to pick up, because of the similarities between interfaces and duck typing. But if you don't pick up Go, you're eventually going to have to pick up something like it. There's really no reason to wait around.
You could try to vendor the dependencies with submodules and clone your repo recursively.
If they are writing to the map, they must synchronize. If they are only concurrently reading, you are safe. But be _sure_ there's a phase where you are non-concurrently writing, then a clear transition to concurrent reading, and nothing in between. However, I'd also be curious as to what you are doing. Between arguments you can pass in to the goroutine and closure arguments you can implicitly pass in, it sounds strange that you would access a map to get a unique key when the goroutine might have a way of simply having the value in hand. Perhaps the real solution involves getting rid of this map entirely, or failing that, factoring the map read out into one event prior to the goroutine's creation.
PHP is not a background, it's a mess. ;)
There's no particular problem about being a junior PHP developer that would make learning Go difficult. Don't try to learn Go as PHP, learn Go as Go and you'll be fine. It's hard to tell what is going on in someones mind but when I see this kind of question asked by junior developers it's often some version of questioning if they can handle the complexity or anxiety over percieved relative difficulties of languages. So through my career I've heard a lot of "I'm only a [Python|Ruby|php|perl] developer, I've always been intimidated by [Java|C++|C#|and now Go], do you think I can learn it". IF this is the case than I strongly encourage you to learn it. There's no magic to any language, it's just time and some endurance to get unstuck when you do, and you will. When people say software engineering is hard, I think it's percieved incorrectly. It's not that it's complex (which it is), but that it's very difficult to live with the pressure of that compexity over long periods of time. Nobody realizes everything they need to about Software Engineering all at once, it takes dedication and time. Go is no different. So if any of that applies then all I can say is keep with it and don't be daunted by your perception of Go. If you stay with it to get past some of the new conceptual models in comparison to PHP, I think you'll find it surprisingly easy. In your specific case I think Go will be a great language to learn in addition to PHP in that it will introduce you to more core language theory concepts. Also you'll have a go to language for when PHP is too slow, or not an appropriate fit. Anyway, best of luck and I hope you pursue it and find it a good experience.
&gt; If they are only concurrently reading, you are safe. This is strictly speaking incorrect, AFAIK. While the *current* map implementation by the gc toolchain allows this, there is no such guarantee made by the language spec and as such that can a) change at any future go version and b) might not work for different compilers (think gopherjs and other third-party compilers, not so much gccgo). Apart from that, a big +1 for the rest of your answer. If the map is never written, it is superfluous and shouldn't exist. If the map is ever written, accessing it without locking is definitely unsafe.
Hi jerf, thank you for taking the time to read my post and comment. I've taken onboard what you've said and agree that I would have to learn a language like that eventually so I'm going to start now!
I don't know, do you?
&gt; First, as a pragmatic matter, a map implementation that was unsafe to concurrently read with no writes would be very strange Not really. For example you could put a small cache in front of a large map, to speed up access. You could implement the map as a rebalancing search tree that makes often accessed elements faster to fetch. You could do all kinds of micro-optimizations that require this. However, I take my statement back, I remembered [this thread](https://groups.google.com/forum/#!searchin/golang-nuts/concurrent$20read$20from$20map/golang-nuts/3FVAs9dPR8k/SAOJlRQDx2AJ) ending differently (and it very clearly states that concurrent reads are correct).
I did that too! :) https://github.com/ilikeorangutans/tiled
Maps have a header and allocate memory under the hood to make room for new entries, even if you guarantee that each goroutine uses a different key. So if two goroutines each try to add a new entry to the map at the same time, even though they have different keys, it's a race condition. If they are only reading, you're fine, but once there is a write, it must be the only action on the map at that time. You can use a RWMutex to help ensure this.
Sounds like you should contact Travis and make sure they know about this problem and are working on a solution.
&gt; I wonder if there was a sysops somewhere taking a sigh of relief that the I/O on the drive dropped after this release since the same template file wasn't being opened and read thousands of times per minute anymore. Unless the machine is really struggling for memory, that should all be page cache hits, anyway.
I took the Mensa test. I'm not dumb.
Unless you become one. Yes, I passed.
Based on https://joeshaw.org/net-context-and-http-handler/ idea
Hi ianwalter, thank you for the reply. I was hoping to use it as part/ for a web application but just for learning and fun purposes.
please stop thanking everyone, its a thread 
Hi Steamweaver66, thank you so much for the detailed reply and taking the time to read my post. I completely agree with you about being apprehensive. I look at the code and the kind of developers that use it then compare myself and always come out worse off. I really appreciate your post and it has given me a boost in confidence! I certainly will pursue it, thank you again.
Going to visit C90. If you decide to get a stand I will try to come around! :)
Does it come with a secret handshake?
I have zero practical use for this, but I'm going to read it anyway. You can have my upvote sir. 
Looks like your question was answered; however, I want to show anyone who is here a neat site I stumbled across for making a Go struct from copy/pasted json. http://mholt.github.io/json-to-go/
Uhhh, tell me more about this design choices? 
What are you trying to accomplish? You're asking about why your solution doesn't work, but we don't know what the problem is. This is probably not the right way to be handling JSON. I'm sure there's a better way. Explain the problem from the beginning, and then we can probably better help you.
I wrote a quick JSON format loader: https://gist.github.com/guregu/48e6b50e70fad59049c0 Your package looks nice though!
When you start a podcast, it opens up the screen for that episode. But, the scrubber for that episode is on the main page, so you have to exit out of the page to change the time.
Yep, I notice that and extremely annoying, that and the overall alignment of some elements in the page, seems amateurish.
You won't struggle simply because of the fact that you currently do PHP. In fact, you might find that the lack of quirks and strange behaviors to be a load off your mind. Perhaps as a junior dev, your lack of experience will make it so some of the things you learn are completely foreign and thus hard to wrap your head around, but that was bound to happen at some point in your career, assuming you wish to learn and grow. Speaking as someone that also started off doing PHP, I would wholly recommend you get into Go sooner rather than later. Doing web services in Go really helps you grasp the nature of the HTTP request which tends to be taken for granted when doing PHP (since much of it's handled by apache/nginx).
I think it's fun to use this when having demos at presentations.
Embedding != inheritance. So for instance the DummyTask does not contain a Result string. It contains a GenericTask that contains a Result string. So the t.Result = "success" is really t.GenericTask.Result = "success", go just wraps that up for you. This is embedding and composition vs inheritance. Interfaces however define behaviors that structs can implement. So given your example anything than implements both functions `GetResult() (string,error)` and `Process() error` can be passed as a Task to another function. Generally speaking you would implement the shared functionality in functions that take an Interface value as an argument. Those functions then use the *just* the interface of the value provided to accomplish the goals. It may take a bit to really get used to the differences, especially if you were doing a lot of OOP before. 
take a look here https://play.golang.org/p/lezghED5N1
The reality is that I probably don't want a *interface{}, but I want to be able to modify the interface, so I figured I wanted to pass a pointer to the interface. Still, someone else posted an alternate example that works - so I'll work backwards from that :-)
I learnt my first bits of programming developing trojans and worms when I was a pre-teen. Can make for some fresh change of air. Also, op can't inb4.
Thanks, I'll drop in :)
Not sure if I'm missing something, but the example in the README looks pretty racy.
Yes.
TIL json tag "string" exists, thank you! If only there were a way to handle an int that might sometimes be encoded as an int and other times as a string for those fun times consuming data marshaled by php...
you are both in chit water, It is just that andrew being more publicly known now has more people pointing and laughing and gossiping about him. andrew is foolish, among other things.
To add to my last reply: Early on while learning other languages I had peers at the next desk to chat with and mentor me. Now I'm mostly on my own as far as coding which isn't as much fun. Most of my friends have moved over to management roles and happily left code behind. 
Racy? How? I'm not a fan of this, but I don't get how the example is racy at all. 
 g := gopher.New() g.Start() // Start the gopher g.Activity = gopher.Loving // Change the gophers activity. Default is Waiting. g.Color = gopher.Magenta // Change the gophers color. Default is White. g.Prefix = g.Activity.String() // Add prefix text g.Suffix = "golang" // Add suffix text time.Sleep(4 * time.Second) // Run for some time to simulate some serious work g.Stop() // Stop the gopher When you modify the fields on `g`, presumably some other goroutine is reading those fields. That's a data race. At first glance it seems like a flaw in the design of the package. I filed an issue: https://github.com/toashd/gopher/issues/2
Apologies. I misunderstood and thought he meant profane, not race conditions. You're right. 
When I read the original comment I interpreted it the same way. I had to take another look at the example code to realize what they meant.
Why was *what* annoying? *Ignoring errors and whether or not the result is correct given the requirements:* Correct me if I'm wrong, but isn't all that code the equivalent of a simple glob? package main import ( "fmt" "path/filepath" ) func main() { procs, _ := filepath.Glob("/proc/[0-9]*") fds, _ := filepath.Glob("/proc/[0-9]*/fd/[0-9]*") fmt.Println("Total number of running processes is:", len(procs)) fmt.Println("Total number of open files is:", len(fds)) } You can use the same patterns in your shell e.g. `echo /proc/[0-9]*/fd/[0-9]* | wc -w` 
maybe there is a way to join forces xD I only did it cause I couldn't find any library that actually does more than load the XML.
i c, thanks for the info ;)
A build-in language feature that make us writing less "if err != nil"...
Wierdly I was looking at this package today because it implements a "getGoroutineId" function, which can be used for 'goroutine-local-storage'. It parses the call stack (which is a little weird, but it's bradfitz, so yay). Here's a library which copy-pasted bradfitz's work: https://github.com/tylerb/gls The fact that this is coming into the standard library is encouraging - perhaps a _GetGoroutineId_ function will end up in the standard library, after all.
Having a Gython would be great, yes :P or maybe make it a Python to Go compiler/transpiler :P
This is a rough homomophism to [Church numerals](https://en.wikipedia.org/wiki/Church_encoding), try doing it with functions. It's an interesting subject in the branch of lambda calculus and hence related to [type theory](http://iml.univ-mrs.fr/~lafont/HETT/coquand1.pdf). That said, it's a quite old research topic. It's very interesting but not very useful in and of itself (because "useful" deductions have already been made and part of them are already in Go's type system). 
Many thanks for sharing your thoughts and feedback. I've pushed a fix with a redesigned API together with using mutexes. Now it should no longer be racy.
Currently it has the following function that allows this: rbac.IsGranted("admin", "view.dashboard", func(role, permission string, rbac* Rbac) bool { return user.Role == "admin" })
Thanks for the link.
What about this: https://github.com/chai2010/webp?
Ah, thanks for the explanation! I didnâ€™t know about that; thought that the number of buckets was always constant.
If Brad Fitz is finding it useful in the context of what will be or is net/http, then maybe it will be, since he's a core contributor working on a core library. I know I've encountered a situation myself where it was either global variable or goroutineID, and of course since I didn't have a goroutineID available, global variable it was. And it limits me. In particular, I encountered a problem where a type had to implement a TextMarshaler, which has no way to pass in a context, no way to pass in what I need to pass in to the type itself, just no way to control anything about the context, so I end up with a global variable that means I can only have one of this sort of connection instead of it being properly modular. It's OK-ish, but frustrating. I get being a bit nervous, I get considering it bad style to reach for it first thing, but it exists in all those other environments for a reason.
Interesting, didn't know about them, will take a look.
I can't. The type is out of my control at the time. Serialization code has that problem. I know this sounds like there's a simple solution, but I spun on this quite hard before giving up. I just got constrained into no solution. Fortunately the "no solution" just means my test code got nastier with fiddling with the global variable, rather than missing out on actual functionality, but it is a real problem that can happen. Like I said, I get the presumption of guilt that comes with needing thread IDs, but they show up in those other environments for reasons other than "developer laziness".
nah, I haven't had time to push something presentable yet
That's only because they weren't using Plan 9 or Arch Linux ;)
brotli is a terrible idea for most connections, i.e. everything that isn't just static assets (and you don't need go support for these, you want to just compress them on-disk), while gzip works very well for dynamic pages too.
You are my spirit animal. Plan94lyf
There's no reason brotly could also be implemented for the cases where gzip work well. The brotli algorithm could be used both for static assets and for content that is generated on the fly.
Aww. You're my spirit animal too, b4ux1t3.
If you didn't want to export the Rhymer type you could also create a public interface that the rhymer type adheres to and return that from your New() constructor.
Thanks for replying, Brad, and sorry for hijacking the conversation: getting http2 into the standard library is a great thing, well done. Yeah we only want it for debugging. It's _just debugging_, but also *it's debugging*. Specifically it's useful for deciphering logs. We do currently use gorilla/context, we create uuid, pop it into log messages, and it works a treat. Personally I'm OK with that, but there are murmurings in the camp that it's undesirable to pass around a request object (or in our case our RequestContext type) everywhere. It's just a bit refactor-refactor, dependency-dependency. So, given that it's fast we might still use glc, with the understanding that it may break in future versions of Go. Thanks
This. Public interface/ private struct is a great pattern.
We do, and it's great for most stuff - we use gorilla/context. But this means we're passing a request parameter around to almost every function in our code where we want to log anything. It's not ideal.
FYI, Gonum has many of these capabilities. Slightly different mentality though (gonum has weights and sticks to pure []float64 while this defines types and methods, i.e. Coordinate, Float64Data) [gonum/floats](https://godoc.org/github.com/gonum/floats) for max, min, round, sum, etc. [gonum/stat](https://godoc.org/github.com/gonum/stat) for mean, std, variance, etc. [gonum/stat/sample](https://godoc.org/github.com/gonum/stat/sample) for sampling without replacement If you're the author, Regression may be a nice addition. If you're interested, please start a thread on [gonum-dev](https://groups.google.com/forum/#!forum/gonum-dev). Quick comment: math.Pow(2.718281828459045, b*s[j].X) can be replaced with math.Exp(b*s[j].X)
Thanks, I hadn't heard of gonum. Stats also works fine with pure `[]float64` data as you can see in [examples/main.go](https://github.com/montanaflynn/stats/blob/master/examples/main.go), the types are there for convenience and in the future will allow for cool stuff like calculating statistics automatically by adding more data. I started with only functions but I really like the idea of something like this: func getData() []float64 { // Do stuff to get the data and // store it in var data []float64 return data } var d Float64Data = getData() fmt.Println(d.Mean()) d.AddData(99.9) fmt.Println(d.Mean()) I am the author, but I'm a bit confused, my package has regression algorithms (LinearRegression, ExponentialRegression, LogarithmicRegression), perhaps you we're saying Regression would be a nice addition to gonum and asking if I would be interested in helping with that?
Is it not? Can you explain what you would expect instead? According to the [Rounding article](https://en.wikipedia.org/wiki/Rounding) on Wikipedia it is rounding. Ruby's [round method](http://ruby-doc.org/core-2.1.2/Float.html#method-i-round) does the same thing. Same with Python. 
It was indeed just a typo in the comment, the code correctly returned `3.17`. I thought at first that you had a fundamentally different definition of rounding.
Yes, that's what I'm saying. The full set of possible regression algorithms is very complicated and doesn't belong in gonum/stat, but a simple linear regression like you have probably belongs, and we'd love your involvement in the project if you're willing. 
I was inspired by the same blog post! http://godoc.org/github.com/teepark/contextual http://godoc.org/github.com/teepark/contextual/middleware http://godoc.org/github.com/teepark/contextual/router
Thanks that sounds like good advice: it's good to be convinced by reason &amp; sensible suggestions. Right now we are using something similar to what you described - we have our own RequestContext object, which gets stored inside the Gorilla context, and also composes a Logger. The reason that we're using Gorilla is mainly for allocating stuff to the request in layers of middleware. Beyond that we pass the RequestContext around most places where we'd like to log. It's everywhere, which is OK for the most part, but occasionally feels cumbersome. I guess context.Context would feel less 'custom' than our own struct, too. To be fair the glc concept seems nastier each time I think about it. ThreadLocals in Java are pretty problematic, so it bears to reason that an unsupported equivalent like glc would be far worse.
Awesome. Thank you very much for your comment and to point out your lib. I think I am gonna update the blog post to reference your lib.
Hi Dalton, I updated my blog post to warn people that the samples are not fully secure and I added a link to your repo because I think you did a great job implementing those login processes. Thanks.
Hm.. so that pattern suggests creating a self-enclosed "manager" that encloses the channel and instructs producers when it's safe to send and when it's not? It's certainly more DRY than making each producer check the same "ok" channel, at least: thanks. I do feel this is a rough edge in Go, that it's so easy to check if a chan is closed by reading from it but not by sending to it. :-/
Its the same pattern for production: package main import "fmt" func produce(out chan&lt;- int, exit chan struct{}) { for i := 0; ; i++ { select { case out &lt;- i: case &lt;-exit: return } } } func main() { ints := make(chan int) exit := make(chan struct{}) go produce(ints, exit) defer close(exit) for i := range ints { fmt.Println(i) if i == 143 { break } } } You could wrap the producer / consumer in a struct with `Start` and `Stop` (or `Close`) methods and have a per-producer exit channel: type Producer struct { out chan&lt;- int exit chan struct{} } func NewProducer(out chan&lt;- int) *Producer { return &amp;Producer{ out: out, exit: make(chan struct{}), } } func (p *Producer) Start() { go func() { for i := 0; ; i++ { select { case p.out &lt;- i: case &lt;-p.exit: return } } }() } func (p *Producer) Stop() { close(p.exit) } That's a little easier to work with and you can pull out an interface which every producer and consumer implements.
You seem to be in a similar situation to this post I did a while back (in json but the ideas are similar) http://mattyjwilliams.blogspot.co.uk/2013/01/using-go-to-unmarshal-json-lists-with.html I'd try to start of with very little magic: Just turn the yaml into a map of maps and then iterate over the maps building the shapes as you
http://blog.golang.org/pipelines
Why would you use this, instead of something already established like http://nats.io/ ? What are the advantages of this vs. the existing alternatives? 
So... PyPy changes everything
Go memory usage is really that high? Yeah if you look at VSIZE it looks completely out of control, but RSS isn't bad, and RSS (on many operating systems) probably is sharing pages with RSS from other processes anyway due to COW optimizations in the kernel. Since program text pages are RO anyway, there's just one copy of those. Goroutine overheads could still be an issue (who leaks goroutines? I'm not sure I've ever committed one, but then I'm not sure I'd know how to find out either which could be part of the problem).
that is a false statement, work within the gcc project proved this not to be the case. Short story, some wanted change and others didn't, so gcc made two projects, both did their thing, more users grazed in the new than the old, the new became stable and took the reins. Golang core devs could learn something from that experience. the core lib needs an overhaul- everybody knows it. Most libs need to be kicked to /x/. The libs left need a serious rewrite. Numerous flaws in design and function have been found. The best excuses given were 'we really didn't know what we were doing when we started', 'I know it is messy and I know it doesn't make sense but use this workaround and you should be okay' and 'I know but what can we do about it now, go 1 compat'. those core devs could open a 'fix it' branch and see what happens. You, just as half the gcc camp was, would be surprised how many users will help fix those talked about flaws. The true test would be how many users graze in that repo and build from it. However, I am confident that the 'fix it' repo would become more popular and more stable than trunk. 
Goroutines are very easy to leak, especially when you are using other people's APIs (or the standard library). 
sad...
It wouldn't be so bad if the core devs just accepted a few things. 1) gorountines are too light. I'm not asking for posix.1c compat, I'm just asking for a handle returned by the go statement that allows to probe the gorountine, and possibly lightweight signalling(requests to yield or terminate). 2) add parametric polymorphism, whenever this topic is brought up the crazies come out of the shadows with insane ideas that smother the topic. Just simple syntactic level preprocessor. Doing this a syntactic level takes away many griefs, virtually all of them. The rest could be managed so as long as the crazies stay calm.
&gt; 1) gorountines are too light what exactly do you mean &gt; I'm just asking for a handle returned by the go statement that allows to probe the gorountine what exactly does that allow you to do that's not possible now &gt; and possibly lightweight signalling(requests to yield or terminate). what do you mean by *yield*? you also already have the ability to tell the goroutine to stop by communicating with it. AFAIK, there's no reasonably safe way to just stop a computation in the middle without potentially making the future operation of your program undefined. &gt; Just simple syntactic level preprocessor. you can already achieve that, in fact there are tools that have existed for years that achieve this
It depends, it could be interpreted as throwing a panic into the goroutine, so if you plan on killing a goroutine, then you should ensure the goroutine has a recover for it. Or maybe the semantics could only allow killing of a goroutine that is channel-blocked, the goroutine could interpret it as a channel closure (similar panic).
1) is explained throughout the post 2) it allows me to communicate with a goroutine. with the intention to do specifically that, nothing more. 3) enlighten me on how you communicate with between your gorountines. and then I will take it from there. I have a feeling your solution is very heavy compared to what could be done in the runtime. And I didn't say stop it, I said signalling to REQUEST to terminate or yield. 4)those tools aren't part of the standard tool chain or libraries. 
Allowing such a hook would do more harm than good I believe. Beginners would probably use that instead of sending termination signals via channels. Since Go allows for shared memory, it looks like an easy way toward memory corruption. 
170k websocket connections that was using 5.6 GB of memory in Go, used less than 2GB of memory under PyPy (~ 1.8 GB). This was before the Go 1.4 change that dropped Go's stack size down to 2kb minimum however, which of course changes things again. They're competitive with each other now memory-wise. Also on a side-note, don't use the golang websocket library, use Gorilla's. The gorilla websocket library uses less memory, and is more RFC compliant.
Hopefully this is the author admitting he's just exchanging one set of problems for another. He cherry picks a couple of flaws from one implementation and then ignores the flaws of the next implementation. While I do believe most of the criticisms are valid, I really believe someone could have written a similar presentation with as many valid arguments about switching from PyPy to Go. "Go is a game changer"
No. It's because they care about stability. You have absolutely no clue what you want.
Awesome! I didn't know you could select across sends!
I got the impression the idea came from c with errno. The idea was that functions would return an errno value and that would correspond to a list of generic errors. The practice seems to have fallen out of favor in the c community however. Perhaps because c can't return multiple values?
they can have the stability in trunk. who says the fix it branch couldn't be stable? who says anyone has to use it for production use until its stable? most of the existing branches aren't stable either, they are work in progress to merge with the stable trunk, there is no reason a fix it branch couldn't be handled in the same manner. there is absolutely no change in procedure. And if more use the fix it branch, it will show that more care about functionality than a go 1 compat promise. This is a no harm no foul solution to test the waters on a subject that has been brought up many times over and over again by a larger portion of the community. so your comment is mute. thank you. 
I thought that was a joke.
rust is mozilla sponsored language. I'd assume there will pressure on mozilla projects to use rust.
Ah I see. Yeah that would be significant. Good to hear they've made improvements on that front.
... Moot?
This presentation completely ignores the single biggest advantage to Go: static typing! Even if all else were completely equal between the two I'd still tend to use Go more often simply because the compiler helps me be more productive and have more confidence in my code. For the record, I also use type checking extensively in Python via type annotations. It's just not the same as real static typing enforced by the compiler.
I don't do ruby but I use twisted for event based programming in Python. You can just defer blocking calls to threads easily and most of the popular libraries like requests/psycopg2 etc have wrappers already on pip (txpostgres, txrequests and so on). Is that not possible with eventmachine/celluloid?
I've also made something like your tool, but instead of F5 logs it are netfilter logs (https://github.com/42wim/ulog2queue). Which can do 70k req/sec depending on number of cores ;-) Some performance tips you could find useful: * use ffjson (https://github.com/pquerna/ffjson) - makes marshall/unmarshall about 2x faster. * use LRU (https://github.com/hashicorp/golang-lru) - cache your geoip lookups * use multiple connections to ES 
Ah, apologies I thought behaviour differed based on whether an `ok` is called for. I avoid using the panic/recover system as I personally hate it, so I'd just gone on outdated docs or erroneous blogposts, there..
There's not.
Although I understand why you've put in the history/background before tackling the Go stuff, I wonder if its necessary in your post. Having said that, IANAC (I am not a copywriter) and I'm no shining example myself :) That aside, I did like how you explained your thoughts on some important things that would be useful to a newbie.
Thanks for your interest in Mailjet. I work for Mailjet, where I lead developers relations but I'll try to be as objective as possible.. Mailjet has been built for all kind of emails in mind (from transactional and marketing) from day one, and with global deliverability in mind. Our Api first approach and powerful tools enable us to provide you with all what you need to send great emails, based on a fair and flexible pricing. If you have more specific questions, I'll be more than happy to answer them!
n.b. I've not investigated Mailjet (yet), but I'm trying to dig a little more then I can through normal browsing :) This may be a dumb question/comment, but isn't every every mail sending API... API focused/API first? "here blud, send this email, plzkthx", "is my mail bouncing?" I've been looking at whats out there as of late, but they all seem the same, the biggest draw for me (as a developer) between them all has been whoever had the best Docs / Integration with my favoured language (so I'm pleased to see a Go wrapper :)) and perhaps stats second. Ensuring delivery is a must and I don't expect anyone would say they offer otherwise. I guess, I'm just having a hard time differentiating between the different options.
Of course in rust and python threads run 100% smoothly all the time so using them would always be a no-brainer. He's clearly biased coming from mozilla.
I'd be happy if you could only kill goroutines blocked on a channel, and the kill would fail if it wasn't blocked on that. Alternatively, it might be easier to avoid leaking goroutines if Go could auto-close channels where there is no other goroutine holding a reference to the channel (nor is there a reference to the channel in a shared data structure). Not sure how feasible such a feature would be for Go, but it'd sure be handy.
Nice work! Your binary doesn't work for me. Maybe you could document which architecture ans o/s it is for.
I haven't seen a py2rust program yet. But are you seriously suggesting that Pyton programmers should switch to Rust? Why not Ada? That is as alien to Python as Rust is. Or even better, just write assembly (if you can write "safe" assembly).
I didn't know Go's HTTP client did this. Is it configureable? Would much appreciate it if you could point to where this stuff is referenced in the docs.
To some extent, I agree. Rust seems quite a nice language and I do believe it'll convince developers soon enough. One of the great things about rust (also true, AFAIK, about go) is that it can be compiled as a C binary and, thus, be embedded into python apps. Seems to me a quite interesting migration path... 
Yup, its referenced in the docs when discussing keep-alive (to avoid the setup overhead of every connection). The Transport keeps the pool of connections around and handles limiting how many are open to any individual host: https://golang.org/pkg/net/http/#Transport
&gt; the core lib needs an overhaul- everybody knows it. Citation needed. You try to imply consensus where none exists. The gcc fork never broke compatibility, especially not with its interfaces, i.e. gcc extensions to the various programming languages it supports. You seem to be absolutely clueless about how compatibility works.
Whether or not the parent is suggesting it, the fact is they are, Rust is attracting users from traditional systems languages like C++ and also dynamic languages like Python &amp; Ruby, in approximately equal amounts. People from the latter group often describe it as adding a close-to-the-metal tool to their toolbox (e.g. for [embedding in](https://doc.rust-lang.org/book/rust-inside-other-languages.html) their dynamic language of choice to optimise) without having to spend the time fighting/learning the most annoying problems that a beginner has to tackle in C/C++/assembly.
Rust also has a runtime. C has a runtime. Pretty much everything has a runtime. The size might matter, but I don't think that it will deter you, if you are already using python or ruby. The go runtime is not a problem for this usecase.
/u/uriel could you get rid of this troll? 
he might just come back from the dead for it
Because only nice things about Go can be said on this sub?
&gt; This is like Rails scaffold. I really hate the idea of needing to have these "project skeleton generators" that write out a bunch of code for you, that you then edit. Go does not require such elaborate setup; a small Go project should be small, not some autogenerated vomit that only an IDE could ever love.
Using an alternative account, to get around a sub-ban, is against Reddit's rules, and is possibly detectable.
I think testing in Go might be my favorite part of the language. Its just so easy and modular i love it. Especially after using boost unit testing at work.
What's the 10kb SSL bit you mention near the end?
Hi, I'm author of gcli. I agree and like your opinion, "a small Go project should be small". But actually, gcli doesn't generate a bunch of code. It generates only minimum code what you need to write every time. 
?
This looks pretty nice, congratulations. 
I was speaking about that troll.
This is kinda funny to me because I just went from Python to Go. Then I had to start working on a project again in Python [edit: I should qualify that I am typically restricted to not being able to use Python3 for projects] and I legit can't stand writing the code any more. Maybe it is just my person style but I just love the way Go makes me approach a problem. Concurrency and unicode in Python have always been a pain in the ass to me and it seems like the language is mostly supported by libraries. I can get so much done with just vanilla Go and I love that.
&gt; If those core devs don't want to hack it then they don't have to, let others do it, there are plenty of people outside the core dev group that would be willing to accept this challenge. I strongly disagree. If anyone capable to do it and thinking it should happen would be willing to accept this challenge, it would have already happened. You need zero cooperation from the go team to do this, so just go ahead and do it.
RE: Go Routine Leakage Just make your implementation [x/net/context](https://godoc.org/golang.org/x/net/context)-safe, and move on with life. It isn't that hard.
That's not an answer to my question. Why not Ada?
It's not so over engineering. It's just generating initial codes you need. By the way, I'm also plaining to support 'pflag' :)
It's better than exceptions, it's not as good as the monadic equivalents from Scala/Haskell
Your comment was mentioning various runtimes as if only their code size differs, I was just trying to dispel that. :) &gt; The overhead is something you pay exactly once Once *per call into Go*. As I discuss at the end of my comment, this is fine for reasonably expensive functions, but is definitely not great for cheap ones, so this limits the sort of Go libraries that work well for other languages to call. &gt; you won't notice when you call go from python or ruby Depends what you're doing. As my Python example demonstrated, the overhead is still noticeable (and it's more noticeable than just naively comparing the timings suggests: the script takes ~0.09s to run if if I replace the `DoNothing()` call with `pass`, to actually do nothing). Even passing some (ignored) integer arguments like `DoNothing(0)` isn't that much more expensive: about 0.05s total time per argument. I do agree that this specific point of runtime overhead is likely to be in the noise for most instances where someone embeds things in Python. --- In any case, my comment isn't focusing on the semantic (and more important) problems with embedding large-runtime languages. One has to be careful about managing the garbage collector and how pointers can be passed around to work with the runtime, screwing up the semantics here can result in crashes and corruption, while the overhead is "just" an optimisation (which is still important of course, especially when one is embedding for improved performance). For instance, pointers must be pinned, to avoid the GC moving something in memory without updating the pointers stored externally, or even just freeing that memory completely if there's only external references to it.
I wasn't trying to answer your second question (I don't have much experience with Ada myself): your comment sounds like you don't think that a Python programmer could get anything out of Rust, even aghast at the thought that they might, so I was just offering some info about what's happening on the ground. :) (Maybe Ada is getting a lot of interest from Python programmers too, I don't know.)
I recommend you this solution: https://github.com/mtojek/dependency-injection-in-go/
I'm so happy to see that this already includes fuzzing tests :)
I had the same question of whether to keep it or not. But I thought that it might be a good idea to mention my background that was used to form those kind of thoughts. Thank you!
Whats wrong with unicode in python 3?
Why? Honest question. You prefer big giant libraries with lots of stuff that you'll never use? Should the developer wait to release this until they've come up with a bunch of similar tools that warrant being bundled together?
I've been working on http://go-modules.io which may suit your needs
Note that I'm not after real DI, I guess I should have mentioned I am after the idiomatic Go way to do this as my Go app grows larger. I thought higher order functions could come into play here, but haven't really neen any concrete examples. Will explore that further.
I'm quite intrigued by this. Could you share a bit more about your workflow? Maybe put the full dockerfiles in a gist? I'm currently trying to figure out best workflow for running grunt build without bloating my images.
&gt; go straight to Rust where you can pre-allocate all memory you'll need and avoid GC entirely. You can do this in Go as well. Does Rust make it easier or something?
Not sure it's about moving, rather than adding `http.Context` (which will be implemented by every type that implements `context.Context`), a `Context http.Context` field to `http.Request` and `http.HandleFuncContext()`.
I rather see people create and me find most of their creations unhelpful than see people not create and me have no alternative perspectives to consider. 
ah! I see you had to reimplement ARFF decoding... I did that too for the Higgs/MachineLearning challenge (from kaggle) https://github.com/sbinet/go-arff 
Nice! I wish we saw this earlier :)
I'll have to try this out on my marine GPS unit. One thing I saw browsing the code is that there is a dependency on python for a xlsx-to-csv converter. If you'd like to remove that dependency for a Go solution I can point you to https://github.com/tealeg/xlsx for the xlsx parsing. There is a working example on the README for a xlsx-to-csv converter. 
Not even once they mention the type system as something to be missing. enough said.
thanks! elixir is the next one I want to try.
What don't you like about the api?
This doesn't look deterministic to me (nor does it produce correct results in the play ground), as far as I can tell. Using sleeps as a synchronization mechanism isn't very reliable. 
This doesn't support the select statement, ie you can't do this: select { case tn.Send("something"): } The oft-forgotten select statement turns out to be one of the most critical features in the language. Here's an alternative approach: package main import ( "fmt" "sync" "time" ) func main() { var wg sync.WaitGroup c := make(chan int) done := make(chan struct{}) // start some senders for i := 0; i &lt; 10; i++ { wg.Add(1) go func() { defer wg.Done() for i := 0; ; i++ { select { case c &lt;- i: case &lt;-done: return } } }() } // we'll signal done after a bit which stops all the senders time.AfterFunc(time.Second*1, func() { close(done) }) // when they're all done close the channel to signal receivers go func() { wg.Wait() close(c) }() // now start receiving for i := range c { fmt.Println("got", i) } fmt.Println("all done") } Without generics its difficult to abstract a pattern like this into a library. Sometimes I think developers see this and think its boilerplate, but I actually think that's not really what it is. It's actually more akin to a for loop. For loops are actually pretty complex when you think about it, but once you work with them for long enough you get to be very comfortable with them. You can peer through the syntax and see what's going on.
Thanks Arnaud :)
I don't have privileges within that repo to make those decisions. very few do. 
To check that a web server is available you generally want to connect to it and then send a HTTP request to check if it returns a 200 status code.
You don't need to. Just fork it. You can do the work yourself and don't have to interfere with other people. You can convince the go team that people want the stuff you are talking about by demonstrating that they are going to use your fork (and whether they are using a different repo or just a different branch is unsubstantial for that). You can, if you want to. I simply strongly suspect that you don't really want to.
&gt; You prefer big giant libraries You got a false dichotomy there, ignored. &gt; Should the developer wait to release this until they've come up with a bunch of similar tools that warrant being bundled together? The more appropriate format for this contribution would be a blog post or a github gist.
I fully agree with your argument about the impossibility of killing goroutines safely in an imperative languages. But do you think the argument still holds if we are just talking about killing goroutines that are blocked forever, sending or receiving on a channel that is not in scope anywhere else?
Thanks, that's exactly what I need. Must have missed it somehow when I started.
If a context-based http handler was defined in the stdlib instead of my own package, I'd be so happy. https://github.com/codemodus/chain for reference.
Odd, I can only reach a running linx-server install from localhost.
Hi Cathal, I just used your package for a small miniLock QML application (Jolla SailfishOS). It works really good, however running the package on a rather limited mobile device I have one big suggestion to add encrypt and decrypt functions that process chunks of data. With the current implementation you have to process all file data in memory which will fail if the file has a huge size. Processing blocks of data would fix this issue. 
You may also want to consider C++ as an alternative. It's flexible, gives the developer fine grained control when wanted, and has a powerful, extensible type system. This stands in stark contrast to Go's lack of generics.
Awesome, can't wait to see the app; will you be putting source online anywhere? A sane way to do streaming en/decryption is definitely needed and would be the next logical feature; as an application dev who's used miniLock what sort of API would you like to see?
I like a functional DI approach, where you use first class functions and then in your test, assign a new function as a mock. Overview here: http://openmymind.net/Dependency-Injection-In-Go/ As a best practice if you pass a golang.org/x/net/context.Context around pretty much everywhere, then storing the DI containers in the context is trivial. One more thought - if you are injecting into a long running process like http handlers, keep in mind you will need to re-inject your containers at request time. In my test server I do this to re-inject every request (s.Manager is my DI container and Router is a gorilla mux Router). func (s *Server) ServeHTTP(w http.ResponseWriter, req *http.Request) { r := NewRouter(s.Manager) r.ServeHTTP(w, req) }
I agree it should have been there, but until they make the change, it's pretty straightforward to pass in your own context to handlers in the meantime, or use net/context keyed off the request. 
I think it requires expansion -- web apps != APIs. Go had no analogue to Rails, at best it has handy middlewares, routing, and terse database access. In this vein I'd compare it more closely to the NodeJS stack with heavy focus on program correctness on large codebases. You'd have to have a lot of experience under your belt to make such an inflammatory statement, and it isn't completely unfounded.
Go is fine, or rather, excellent, for creating web APIs. The standard library is more than sufficient and HTTP testing is easy (the httptest package is quite useful). The problem lies in the fact that people aren't yet used to writing web apps using APIs. The current growing trend is to have a web API and then have your frontend use the API for business logic. This is a great design, but it isn't as easy to develop on compared to traditional MVC frameworks. What is more, most of the industry isn't using this method: people still rely on Rails-like MVC frameworks where such a separation doesn't exist. In Elixir the Phoenix framework is popular and more or less works the same way, in fact, one of its developers is a core Rails contributor. To say "people want to move to Elixir" because Go isn't suited for it is, I think, a bit of a fallacy, since people will always flock to *frameworks* first. Java is popular because Spring and the likes are great systems to begin with (and the JVM is a solid piece of software engineering). Ruby wasn't really that great to begin with, Rails on the other hand, when it came out, was new and revolutionary. It wasn't the first to implement its MVC design but it made it popular. In the end, it's always a good idea to learn new languages, Elixir after all is different from Go and embraces a different concurrency model (actors).
TIL, and also my inner twelve year old giggled. So I will be using this term exclusively whenever possible.
What is missing from Golang that is stopping developers from building web applications? Are beego, revel, gin, etc not enough? Or do we need something more consistent with MVC frameworks? What about something basic like codeigniter 3 for PHP? If at a minimum something like that was ported to Go and allowed developers a base to rapidly develop from. Would this help? I wrote a huge monolithic application with CI2. I know it gets a lot of complaints, but it allowed me to forget lots of issues and concentrate on the business logic and getting the project completed. I'm considering building something akin to CI3 in terms of an MVC framework as a learning exercise. I still have a lot to learn with Go and it will be a fun project for me. Next step would be to port that monolithic app to Go. I'll then have to support just 2 languages. Golang and javascript/jquery. For me would be ideal.
It wasn't particularly obvious from the very beginning. It only looks that way in hindsight.
Why not? Any non trivial http processing requires a context to keep the state of the request. Sooner or later you wheel reinvent this wheel.
I've been building an API layer with Go and it's been extremely productive â€” especially coming from Node. As I'm building I hardly ever feel the need to go refactor or simplify in the same way I do with Javascript. The type system is really simple and eliminates common bugs at compile time. Embedding feels much more pragmatic than the OOP I'm used to with PHP and slightly more similar to Javascript (without prototype weirdness). I personally haven't considered *jumping ship* to Elixir because I feel like Go works well for me. I do think functional programming is interesting though...
Whilst I love developing in go. I'll probably be moving to react eventually.
I've never heard spring referred to as a great system before.
What's heavy about channels? What use case do you have in mind?
Yea this was my mistake. See the post edit. I don't get to work with Python3 much yet.
Go's rapid adoption is being seen as somewhat of a threat by those who've invested significant time and effort in other technologies. I wish Go had arrived aclot sooner, as it would saved me much time and effort in getting a whole class of projects off the ground.
this. also, there is always an "obligatory contrarian" who simply must show up in any discussion predicated on the supposition that a nay-sayer musdt have some insight
Makes sense, but I figured the places where you can use go are typically not the places where you are stuck with python 2.7 let alone 2.6.
I poked at it to make things deterministic (you basically wind up ditching sleeps and building a tiny clock of your own), but I feel like I started pushing the boundaries of what "no arithmetic means". Are booleans arithmetic here? An if statement? For loops..? Anyway, enjoy the gist: https://gist.github.com/Kavec/54d9c77c8dbbad346239 Edit: I did get lazy to the end after adding the boolean, which means those select statements for each fizz and buzz are just obfuscated if statements and can basically be deleted in favor of ```if fizzed { fmt.Print("Fizz") }``` Edit: Which bugged me after thinking about it for 30 seconds; if you'll admit one if statement, three is no worse. 
I don't know Go beyond the basics, but if Go has map, reduce, filter type constructs for lists I dunno why it would have to be dramatically more verbose than a dynamic language. I'm most familiar with Perl for stuff like this, and the List::Util and List::MoreUtils modules provide the meat of any kind of implementation for that sort of thing. Does Go have nothing similar?
To be fair, if your business logic houses "random objects" and arbitrary json in its definition, the language probably isn't your greatest problem. Define all your types and give them relevant methods for dealing with their content and you'll avoid having to traverse deeply nested arbitrary json. Sure, it isn't as flexible as Python or Ruby, but I see that as one of its strengths. More than once have I written Python code where I had to defensively brace for several input types because there was no formal definition of the couplings. You can pobably blame that on our process to some extent, but I've found that the team writes better software with explicit errors and types.
That does sound like a problem Go isn't ideally suited for, but it also sounds like a problem that may be more an artifact of your app design than an artifact of your underlying business requirement? For example, an array of mixed arbitrary types, while easy to do in JS, is bad practice in every case: it's not an array, you're just using an array as a numerically keyed key-value store, and probably suffering poor memory and time performance for it.
It can be short in Go too: func get(str string, n int) interface{} { obj, _ := simplejson.NewJson([]byte(str)) for _, k := range []string{"abc", "def"} { if o, ok := obj.CheckGet(k); ok { return o.GetIndex(n).GetPath("ghi", "jkl", "xyz").Interface() } } return nil } Using github.com/bitly/go-simplejson. 
The Erlang crew is fairly pissed off at Go's popularity. They feel like they've been doing it for 15+ years without anybody noticing, and along comes this upstart Go that is missing two-thirds of what makes Erlang special and steals most of their thunder. Lest I sound like I'm being too harsh on them, they're largely correct. I was using Erlang for years before Go even existed, and at the time it was something special a lot of people overlooked. A lot of the reason why it was overlooked was its syntax, which is [not Algol-derived](https://news.ycombinator.com/item?id=7277957). Elixir takes it back into a domain where, even if it has a couple of differences, looks more like a language people are used to again. That said, it does not particularly seem to me that Elixir/Erlang's and Go's web stories are all that different. My personal feeling is that the relationship between the communities ought to be a great deal more friendly. Erlang ought to see Go's existence as validation rather than competition, because there is no universe in which Erlang is lauded and loved but somehow nobody ever copies any of its features and it is forever unique. Languages showing up with similarities to it is an inevitable aspect of success, so why not interpret it as success? And there are things it could profitably learn from Go, for instance, it could really use a "channel"-like abstraction because it turns out to be impossible to write natively in Erlang. And, correspondingly, the Go community can learn things from Erlang; certain semantic differences will always stand between the two languages (preferring channels vs. preferring PIDs being a big one, they are fundamentally different things) but there's still lessons that can be learned about reliability and convenient clustering and such, and structuring large, reliable programs out of thousands of microthreads. But instead, we seem to get a lot of rancor and sneering dismissals. It's not really useful for two language communities that, however much they might like to think otherwise, are _both_ quite small compared to the Big Hitters like Java or C++ or even mature dynamic language communities like Python. It's a real waste of energy.
3 months for syntax? Are you for real?
[**@nekron\_dev**](https://twitter.com/nekron_dev/) &gt; [2015-10-18 10:02 UTC](https://twitter.com/nekron_dev/status/655685386056921088) &gt; Privacy and confidentiality is coming to \#Jolla \#SailfishOS \#Golang \#miniLock &gt;[[Attached pic]](http://pbs.twimg.com/media/CRl2YnKW0AAJsQx.jpg) [[Imgur rehost]](http://i.imgur.com/gU93sjq.jpg) ---- [**@nekron\_dev**](https://twitter.com/nekron_dev/) &gt; [2015-10-18 13:14 UTC](https://twitter.com/nekron_dev/status/655733769714974720) &gt; \#miniLock for \#Jolla \#SailfishOS will allow you to encrypt and decrypt files on your phone or \#JollaTablet \#Golang &gt;[[Attached pic]](http://pbs.twimg.com/media/CRmiY6NWsAARTOw.jpg) [[Imgur rehost]](http://i.imgur.com/zU56pvo.jpg) ---- ^This ^message ^was ^created ^by ^a ^bot [^[Contact ^creator]](http://np.reddit.com/message/compose/?to=jasie3k&amp;amp;subject=TweetsInCommentsBot)[^[Source ^code]](https://github.com/janpetryk/reddit-bot) 
This makes me happy. I just started using Go for a small project and I am quickly starting to really enjoy it. I have found it really forces you to be idiomatic in many cases. I also really love the idea of Go fmt, so that all go code looks relatively similar.
Honestly pretty much every dynamic language (python/ruby/javascript/perl/etc) is going to suffer from the problems we see here. It is really hard for these super dynamic languages to do multithreading right. That isn't to say that Go's support for concurrency isn't pretty fantastic, just that these script languages are less than fantastic. It would be interesting to see how different this would be if we talked about languages like Java, Scala, C#, F#, or Rust. Languages with slightly better concurrency guarantees.
4th episode is up! https://www.youtube.com/watch?v=6Pl5Xrrne2c
I attempted to start a business on one Go web app and I'm thinking about another in my spare time. It has fit just fine for me and I wish it had developed to this point earlier. Some of these twisted up mangled things you can do in dynamic languages just aren't good practice. I eventually learned that and its why my Go web apps work without half the problems in the end even though they might take a little more thought and planning up front. To make things more solid I often ended up skipping the benefits of the dynamic languages anyway.
How are these guys using QuickTime for GUI? Tell me pls can't get it
If you think generics are a necessity, then you need to check your OOP thinking at the door. Go is a composition-oriented language with some OO features. Generics are not necessary, as implementing the functionality of generics is trivial.
The only hook I have found with using golang for more is I don't love the database api, but it's probably mostly out of laze. Any tips for using dbs in go effectively?
Why not just use [sync.Pool](http://godoc.org/sync#Pool)?
I don't think people should be downvoting you. Most people have a clean experience, but I think it would be great to hear where others have problems. Maybe we can help or improve the existing educational materials. So... any examples you'd be willing to share (if you have the time, that is)?
Ah, I haven't read that far, apparently :)
If only we had a native go react api.
Thanks for doing the lords work
Which bits didn't you like, marshalling to objects, building queries, or something else?
How is Brian Kernaghan otherwise involved in Go?
Python was designed to be friendly, C was designed to be fast (well, "close to the hardware", I guess?), Go was designed to be both. I don't know of many languages that are friendly and fast. I do know that I would not want to maintain a web application (for which language friendliness is important) written in C.
I like it!
Whoa, I didn't realize this either. Good to know.
Maybe this is nit-picking, but DI is very common in Go, and it does not depend on reflection: `MyStruct{Dep1: Dep{Val: 1}}` ^ That's dependency injection. There are "DI frameworks" that represent that composition tree in XML, JSON, etc so a program can build the right structure dynamically, but such a framework is not needed for DI. The point is that DI is a general concept in which dependencies are injected into the object (via setters or constructor); the frameworks just automate this project from a data-representation of the dependency tree.
Thank you for a well-written post. I had just this *exact* confusion yesterday and had to experiment a bit to understand what was happening. The key I believe is that *T set of methods includes methods defined for a type T. A corollary of this is you'll get a "method redeclared" error if you try to define same method (same signature) on T and *T.
I've been using [Gorm](https://github.com/jinzhu/gorm) which definitely feels familiar to database APIs seen in larger frameworks like ActiveRecord.
The strategy I use in my MVC web applications is to create separate decoupled packages for each of my features so that they are reusable in other projects. I also use abstraction for other people's packages to ensure if they change, I don't have to rewrite code. In my main func, I configure each one so I can use them without having to pass them around. This is one example of how I utilize the recaptcha package by haisum: https://github.com/josephspurrier/gowebapp/blob/master/shared/recaptcha/recaptcha.go I configure it from my config file in the main func: https://github.com/josephspurrier/gowebapp/blob/master/gowebapp.go#L43 I then use it in my controller: https://github.com/josephspurrier/gowebapp/blob/master/controller/register.go#L50
Come to the enterprise world, gaze upon the burnt landscape with the smoking (but still kicking) corpses of spring projects. "It's so easy!", they said. And then bolted before having to maintain their atrocities. tl;dr, enterprise is why spring is a thing
No problem; I'd probably just use `sync.Pool` myself, but I figured you hadn't seen that part.
Never understood that love for stacktraces instead of nice error messages. In python-world people see them as regular 'error messages' and dump out huge stack traces just to say user 'file doesn't exist'. I hated Python programs for that :) Errors in Go are just great. Normally you use small types, carrying as little information about error as needed. They are not strings, it's misunderstanding of newbies. If you have hard-error, something that shouldn't normally appear, dump out stack yourself via panic() or via runtime.Stack(). UPD. Liked slide with 'Python Memory Use is competitive with Go or better (especially if we count goroutine leaks)'. Goroutine leak under load typically leads to fast infinite memory usage growth until out of memory state. Good for Python being that competitive :)
20 years of Perl has let me become very lazy and sloppy. Having a hard time with structs, interfaces, and types. I'm fully aware of them and their benefits but my mind keeps thinking in Perl and I have to convert to go. It's slow going but I'll get there.
An excerpt from Learn Go, a beginnerâ€™s guide to Go, that Iâ€™m writing with Manning Publications. I'm targeting people with some experience with a scripting language but fairly new to programming, while trying to keep it moving at a good pace. If that describes you, I'm very curious if it makes sense or what areas should be better explained.
In Ruby (untested). Not a single if-statement: id = json['abc'] || json['def'] &amp;&amp; json['def'][10].to_i and json['ghi'] &amp;&amp; json['ghi']['jkl'] &amp;&amp; json['ghi']['jkl']['xyz'][id] or nil 
I am not saying there is anything wrong with Go. Go is perfectly fine the way it is now. But sometimes real world isn't that perfect and nice the way we want to, and when engineers are presented with a challenge that wasn't their fault to begin with (e.g. some lame DB admins who aren't doing their job sanitizing their data), we were forced to solve problems in creative ways.
Asking this on /r/golang isn't really the best place to get a truly objective point of view. But then again, what really is objective in this industry. I've held the contrarian view for a while that Golang is on the "lower-end" of my ordered list of languages I think are suitable for productive web API development. Certainly not the worst. But, at best, average. Now, because I have voiced these opinions before and gotten terribly cookie-cutter responses, let me be perfectly clear here: The word "frustrating" is not a synonym for "impossible". Parsing user data is frustrating. The boilerplate attached to any route which converts the body of a request into some specific struct is both significant and yet unnecessary if the type system were only a little more powerful. There is no performant and typesafe way to abstract that functionality out into pre-route middleware. JSON tags on structs are also frustrating in the same way. Most structs would want to export fields, but doing so requires you to define a `json` tag on every field so that you don't start creating JSON payloads with capital first letters (which is generally accepted to be best JSON practice). This could easily be solved if they added some shortcut where I can set `encoding/json`'s rule to say, like, `default` (`MyField` -&gt; `MyField`), `CamelCase` (`MyField` -&gt; `myField`), `underscores` (`MyField` -&gt; `my_field`). Obviously there are i18n/unicode concerns with doing this automatically, but its worth exploring. And on the flip side of the stack, database access is frustrating. This is one of the few areas of Go where I feel like the golang stdlib package is grossly inadequate for normal programmer use. I've used gorp for the latest project of mine, and it works well, but obviously relies on lots of reflection and struct tags to get the job done. This hurts performance _and_ makes me less productive (than competing languages, not when compared to `database/sql`). No win at all. Finally, consider the overall performance of Go. This is one of its primarily touted benefits, yet I strongly argue that it is overblown. For web applications which **inherently** have a lot of asyncio, I've seen real world benchmarks which place Node as being faster once `cluster` is enabled (which is the only way to run a fair benchmark). Pypy is maybe 5x slower. Java is competitive. Every modern stack is within the same league as Go. When a web app is built to be horizontally scalable, the cost of deploying **1** more server might be $30/mo. Considering a developer's time is, oh, lets say $60/hr, if a language can save a developer literally **30** minutes of time every month than that language has a net higher economic value. Generally speaking, I don't have the data to suggest Go makes developers more or less productive than any competing language. I can only speak for myself, but I personally know that I have spent at least an hour a month writing `echo` middleware which `express` or `twisted` does for me, or repeating myself on four-line database functions which would be ten characters in `knex`, or hunting down goroutine leaks because everyone told me "this is how you design Go apps. dont just throw servers at it, parallelize your work on one server". And as I end these talks each time I say them: There are plenty of things Go is great at, but anything which involves communication over the wire is a pain point for me.
Unless you are using the package directly, it won't affect general performance, which is why CloudFlare forked the Go as a whole. There is hope from the author of the improvements that it makes it into Go 1.7.
Not sure I understand, when I change models queries don't have to change, just a field in the model, and a change to the model creation function from the db row, so should be a 2 line change. There are plenty of query builders and/or ORMs (I just use a query builder personally, and let the model be in charge of creating itself). 
Thanks a lot bubaflub! I just went through to modify the code according to your recommendations. Noticed I had some useless snippets I added during development that I could just remove. I appreciate a lot the feedback and I hope this tool can help others in their projects later on :)
Really nice tips you got there, I have stumbled upon ffjson before but completely forgot it existed. I have now removed the json part from the tool, but it might be useful later on. The LRU cache is also a great advice, I currently don't know how much of a performance hit it causes to look up every request, but I guess this cant hurt to push the limits a bit more. I am also curious about what you mean with using multiple connections to ES? You mean that each Worker for example opens its new connection instead of just dividing the bulks? Really interesting that your tool ulog2queue is so similar as well! :) Thanks again! 
Which new movie?
The movie is called [Dope](http://www.imdb.com/title/tt3850214/?ref_=nv_sr_1)
~~At the section you talk about the speed of light, shouldn't you declare the variable type? Or at least use := ? Here, I mean: var distance = 56000000~~ Forget it, you are right. 
Every time someone runs php / mysql on windows, I cringe. Wtf is wrong with these people...
[**@enneff**](https://twitter.com/enneff/) &gt; [2015-10-20 11:44 UTC](https://twitter.com/enneff/status/656435845679988736) &gt; Pretty funny to see my \#golang code in the movie "Dope". The screencast they took it from: https://www.youtube.com/watch?v=XCsL89YtqCs &gt;[[Attached pic]](http://pbs.twimg.com/media/CRwg6_nVEAAJWNx.png) [[Imgur rehost]](http://i.imgur.com/nXskceT.png) ---- ^This ^message ^was ^created ^by ^a ^bot [^[Contact ^creator]](http://np.reddit.com/message/compose/?to=jasie3k&amp;amp;subject=TweetsInCommentsBot)[^[Source ^code]](https://github.com/janpetryk/reddit-bot) 
Thanks. It can work for memory benchmarking, but for execution time bench, I'm afraid, it will bring an incentive to compare benchmark results obtained with different CPU load, or, even, on different machines.
Thanks Caleb. Chapter 2 is where I introduce types like int, float64 and string. This excerpt is from Chapter 1, which relies on type inference and looks a lot like a scripting language at first.
Earlier: https://www.reddit.com/r/golang/comments/3k1qqu/golang_in_the_movie_dope_2015/
Btw, Manning has a Deal of the Day for October 20: Half off Learn Go, Go in Action, and Go Web Programming. Use code dotd102015au at http://yng.mn/learngolang
&gt; The problem lies in the fact that people aren't yet used to writing web apps using APIs. The current growing trend is to have a web API and then have your frontend use the API for business logic. Forgive me for my stupidity, but I don't follow. Could you please elaborate, perhaps with an example? Are you saying there's a client and server process running for such a mobile app?
Not at the moment as far as I'm aware of, the doesn't mean someone can't make one.
I would love to work on something along those lines in go, but problem is I have little idea on how to go about it. I have no background in NLP. That is a huge bummer. I am trying to find my way around Python's NLTK and am currently doing a very elementary course on coursera for NLP. 
&gt; My goal is to make great web sites, not market them to unwary customers who don't know better. Visitors to your website only care if it loads quickly, looks nice, and gives them what they are looking for. Editors need a nice interface for managing content. The combination of tools I mentioned can fulfill all these needs. Regular people don't give a shit about your "elegant" and expensive to develop custom server-side vaporware. I say this as an individual that works on both custom web applications and regular websites on a daily basis.
Would this be a good deal for a golang beginner? I don't want to do a whole Angular v1 then it all changes in v2!
I understand these frustrations. They do exist. But there is another way of looking at it which I'm trying to exercise: - All those frustrations originate from manual code. - A typical web project does not have 1e3 models. It might have 5, 10 or 50. - You write this frustrating code **once** and it works forever. I see the salesmanship of web frameworks which are advertised as _one-liners_ as a way to get the developers into a technical debt. The truth is that programming is not easy. Any framework salesman who claims that it's easy is selling you a sub prime mortgage. Sooner or later you will have to pay the technical debt. Of course, if you are a freelancer, the debt won't be your problem. It makes sense to make more profit using those magic frameworks which save time, and let the project owner to pay the debt. But if it's your own project, why won't you sit down and type those extra characters once, and be debt free forever? Again, this is my view of looking at this problem from a different angle.
It's mostly in migrations in changing my data models (which means a DB change many times), and my query is `select id, name from users where id = ?` and `name` is now `full_name`, I have to go into any queries on the users table to change `name` to `full_name`. Granted, this is a really poor example. I just imagine this with more complicated joins and such (and a better example). Maybe I am just crazy and need to play more in the sql package to understand it better in a larger usage. 
Cool story. Love the oblivious assumptions.
&gt; JSON tags on structs are also frustrating in the same way. I don't think adding some heavy mechanism for specifying the conversion of field names to JSON keys is worth it. I mean, adding the struct tags is a single trivial operation in your text editor if you just want to lowercase the names. Is it that you worry about forgetting to add the tags? For your other points, you seem to solve them mostly by throwing libraries at it, when programming in another language. What about their code? Are they all well-maintained and offer a stable API? Or do you need to track their changes going forward? Enter technical debt, as m3wm3wm3wm already wrote about.
Very exciting to see. Makes me want to switch from nginx to caddy for my main reverse proxy on my server. Will caddy handle renewals as well?
Beyond a certain scale of application, there is an API server and an App server. The API server contains the business logic/database connections. The App server servers the front-end application, templates html pages, and routes requests from the front-end application through the API. The JavaScript frontend talks to the app server, and the app server routes requests to the various business APIs. Internet security policies prevent websites from talking to pages that aren't their origin domain, and Database/API security means not letting in arbitrary connections. Thus the app server acts as an intermediary. Of course for smaller applications, these two are often combined. If all you are doing is updating a single field in a database, anything you throw together will work fine.
Yes. Go has a compatibility promise, so everything in the book should continue to work for many years to come. https://golang.org/doc/go1compat One day there could be a Go 2.0 that changes things, but it's not even on the agenda.
Cool. Some of the acme library is a bit odd in places though, making it awkward for others to use: (https://github.com/xenolf/lego/blob/master/acme/simple_http_challenge.go#L24-L57) - any particular reason not to propagate error to the caller? And logging. Possibly the interface could be `CanSolve() (bool, error)` ?
I'm so excited Caddy is doing ACME etc and so sad I didn't get to implement it. :) How's your CLA tracking? Any hope you want to get this into the standard library at some point?
Roger that, do you have favorite packages to recommend? Thanks for the discourse :)
An interface allows multiple structs to offer the same function(s) under one name. The caller only needs to know the interface, but not the underlying implementation. In your circle-and-square example, we start with this: type Shape interface { // Area computes the 2D area of the shape. Area() float64 } Now we can have this silly function: func FindLargest(shapes []Shape) Shape { var largest Shape largestAreaSoFar := 0.0 for _, shape := range shapes { area := shape.Area() if area &gt; largestAreaSoFar { largest, largestAreaSoFar = shape, area } } return largest } To call this function: largest := FindLargest([]Shape{circle, square, rectangle}) Notice how `FindLargest` doesn't need to know about circles, squares and rectangles. It only needs the interface, which gives it access to `Area()`. Interfaces allow you to create *abstractions*. Go isn't very keen on abstractions in general, but it would be a much poorer language indeed if it didn't have interfaces. Interfaces in Go are similar to interfaces in Java, with a crucial difference: Structs don't need to declare what interface they conform to. In Java you'd say: class Circle implements Shape { ... In Go, interface implementations are inferred from which functions they implement. This can lead to some accidental behaviour, but for the most part, it works. As for `struct` â€” think of structs as (mostly) unordered groups of things: * `int`, `string`, `byte` etc. are individual things. The thing (e.g. the number 42 or the string "Hello world") doesn't have a name. * Arrays are lists of things. Each thing in the list doesn't have a name, only a position. * Maps are lookup tables of things to other things. Think of a table of contents: Each title in the table has a page number. * Structs are a bunch of things in a group, where each thing has been given a name. Think of structs as forms, where each field has a name: `dateOfBirth: 1984-07-03`, and so on. Interfaces are an abstraction of this, because an interface can represent any thing.
Preface: I don't know Go, I've briefly done the tutorial, but interfaces are interfaces no matter the language. An interface is like a contract, it makes promises about what you can do with it. You don't need to know what's behind the contract, but only there is a contract. It should make your code more generic and hopefully reusable. Let's consider a more real-world example other than shapes. Suppose you have code that's talking to a sql database, and you want to fetch a list of users. There are multiple SQL databases in existence: MySQL, Postgres, SQLite, etc. And let's say we want to support the three mentioned databases. Without generics, your code would need something like: func (db MySQL) GetUsersMySQL ([] Users) { return db.query("select * from users") } func (db Postgres) GetUsersPostgres ([] Users) { return db.query("select * from users") } func (db SQLite) GetUsersSQLite ([] Users) { return db.query("select * from users") } Then we'll need something like: if is_using_mysql: GetUsersMySQL(mysqldb) if ... This turns into a lot of code, especially if we want more functions other than GetUsers! Interfaces allow us to say "Hey, I promise to give you a function called **query**, leave it up to us to use the right thing!". Then your code becomes: func (db SomeDb) GetUsers ([] Users) { // the contract says query exists, so let's use it! return db.query("select * from users") } users = GetUsers(db) Hooray, shorter code! There are other benefits of interfaces, like making your code more easily testable. E.g. In production you want your database to a MySQL database, but during testing you may want your database to be an in-memory database. As long as it implements **query**, it will work!
It doesn't save effort on the structs themselves, it saves effort on their later composition. And for expansion into new shapes later. For example, here's a simple demo showing a function that calculates how many shapes you need to cover a given surface area: https://play.golang.org/p/L_mqlMXIke
At work, we got into the habit of prefixing branch names with our initials, grbgo was created to help me easily search and remove multiple branches at once. Would love feedback, ideas, and pull request always welcome!
Go has multiple definition for an interface, one is the interface that you speak of: the interface in OOP sense, and the other is the `interface{}` type. I will talk about the interface in OOP sense. Interface in OOP isn't strictly Go, and is a common pattern in other OOP programming languages especially like Java/C#. The point of interface is to establish a common functionality without dealing with implementation details. This is to allow extensions, or "plugins", while keeping the existing code unchanged. Given an interface with a function `Area()`, you can extend this interface to many different shapes, each with their own ways of calculating the area. Yes, you still have to define the function for each different shape. It's useful not to the shapes, but to the one that invokes `Area()`. A real life analogy would be a mailbox is an interface to send mails to. You don't have to care who's picking up the mail, or where the actual post office is, or how the mail is delivered. You don't care about the implementation details, but you want to send mail. Mailbox is the interface between you and the post office system, so you can send some mails, regardless of who picks them up, and who gets to deliver them. Likewise, the one that invokes `Area()` just want to get the area of whatever it's using. It doesn't care if it's a square, triangle, or circle. It just needs the area. 
It lets you say "anything can do or use this, as long as they satisfy the interface." Which means anyone can extend your interface as they need it, but still be compatible with any other library that implements the same interface. It really shines with the http package and frameworks built on top of it - they're all interoperable so you can compose them and just use the parts that you need. You can make more and stick them in wherever.
Disclaimer: I don't know C#. From what I've seen by skimming [these docs](https://msdn.microsoft.com/en-us/library/hh191443.aspx), the async/await mechanism basically means "promises"? The advantage of go's concurrency model is not so much, that it makes it easier, to write concurrent code, but more that it makes it mostly unnecessary. You can write your APIs blocking and completely linear and let your caller use your blocking API in a non-blocking way. It basically gives you the power of having *all* functions being marked "async", without having to write asynchronous code at all. In regards to the overhead, you should take into account not only the technical overhead, but also the cognitive. go basically trades off a small amount of memory and CPU time against a vast reduction in cognitive overhead. By not caring about being non-blocking, you free up the part of your brain that deals with "how can I make this code non-blocking". You push dealing with concurrency up the stack, so to speak. Also note, that goroutines can be used for far more powerful stuff than sync/await. For example, you can spin off a long-running goroutine that periodically does work in the background. Or fire up an asynchronous computation whose actual results aren't interesting, only it's side-effects (so there basically is no need for an "await"). As an aside: &gt; For example, awaiting 1000 async operations doesn't require allocating 2MB of stack. That seems weird to me. How is async/await implemented if not as a less powerful abstraction over the M:N threading model? I am willing to take your word for it, but I am curious.
What was your reasoning for RandInsult not just being a method?
&gt; Go has multiple definition for an interface, one is the interface that you speak of: the interface in OOP sense, and the other is the interface{} type. They are not different definitions for an interface. "interface{}" is not a special type. It's just an interface with no methods: var a interface{ Foo(); Bar() } // variable of interface type with two methods var b interface{ Foo() } // variable of interface type with one method var c interface{} // variable of interface type with no method 
&gt; I don't see how it saves work This is where beginners always go wrong with interfaces. Interfaces aren't meant to save you from typing more. So get that out of your head. &gt; If you have a square and a circle, and want to get the area for each, you still have to define the function twice How would you display the area of each? Let's start by defining our structs. type Square struct { Base float32 } func (self Square) Area() float32 { return self.Base * self.Base } type Circle struct { Radius float32 } func (self Circle) Area() float32 { return 3.14 * (self.Radius * self.Radius) } Now you need functions to display the area. You might write code like this. func PrintSquareArea(s Square) { fmt.Printf("The area is %f\n", s.Area()) } func PrintCircleArea(c Circle) { fmt.Printf("The area is %f\n", c.Area()) } I hope you see the problem with this code. Both functions do exactly the same thing. Because Go is strongly typed we need to have two functions. One to display the area of squares, and one to display the area of circles. We can't write a single function that takes _both_ a `Square` _or_ `Circle`. Or can we? This is where interfaces come into play. Notice that both print functions are calling the `Area()` method on the given object. The functions don't care if the object has other methods. It only cares that the object has an `Area()` method. So we define an interface which has that method. type Areable interface { Area() float32 } Now we can throw away our two functions and write a single function that takes an instance of `Areable`. func PrintArea(a Areable) { fmt.Printf("The area is %f\n", a.Area()) } Here's our completed code. type Areable interface { Area() float32 } type Square struct { Base float32 } func (self Square) Area() float32 { return self.Base * self.Base } type Circle struct { Radius float32 } func (self Circle) Area() float32 { return 3.14 * (self.Radius * self.Radius) } func PrintArea(a Areable) { fmt.Printf("The area is %f\n", a.Area()) } func main() { s1 := Square{Base: 6} c1 := Circle{Radius: 12} PrintArea(s1) PrintArea(c1) } With interfaces we can pass an instance of `Square` _or_ `Circle` to the `PrintArea()` function, because both the `Square` and `Circle` structs implement the `Areable` interface, which is the type `PrintArea()` expects. Note that unlike some (most) languages, your structs don't explicity declare that they implement the interface. You don't write code like this. type Square struct { implements Areable Base float32 } With Go the structs automatically implement the interface by virtue of having the same method signatures.
Hello Cathal, yes this looks very useful to me! Copyright to go-minilock has been added to miniLock help page, sourccode will be pushed to github once I cleaned up my ugly code ;-) 
To really get interfaces, I suggest writing a bit of code using TDD. You'll find that you want to stub out some of your other objects/methods, but won't know how. Then you'll remember about interfaces, realize that if you use an interface in your code instead of programming using instances of your objects, that inserting a stub version of your objects becomes super easy. Then you'll start seeing other ways that use of a more generalized interface instead of actual objects works better. And then you'll also end up being a better programmer, as you'll unknowingly have realized some higher level design concepts and why they work well. TL;DR: Try TDD
Not sure what you are trying to do here with the implicit parameter _and_ the context bound. def max[T](x: T, y: T)(implicit ord: Ordering[T]): T = if (ord.gt(x, y)) x else y 
The best example to illustrate this is the Stringer interface declared in the fmt package. Implementing the String() method of that interface lets you specify what gets printed. 
This post was about running Go in an App Service. It's a good start, no? If there is an issue with finding good SQL Server drivers for Go, that sucks, but you can use any other database product in Azure. Not sure what you mean with not supporting sharding with Go. There is a managed SQL service in Azure that has a subset of SQL Server's feature. If you're missing features there, it's not limited to Go. 
Citing a [stack overflow answer](http://stackoverflow.com/questions/26345318/how-can-i-prevent-sql-injection-attacks-in-go-while-using-database-sql): As long as you're using Prepare or Query, you're safe. // this is safe db.Query("SELECT name FROM users WHERE age=?", req.FormValue("age")) // this allows sql injection. db.Query("SELECT name FROM users WHERE age=" + req.FormValue("age")) 
 type __ *[]*__ 
You could do something like this: å‘ := fmt.Printf type é›¶ uint and work with those new identifiers instead.
&gt;Most of the examples I've seen show, "This is how Java would do the same thing.." Unfortunately, I didn't get very deep in to Java, so that's no help to me. OT - I can't complain enough about articles that give examples and use another language as a reference as if I know anything about that other language. I grew up as an electronic engineer. Assembly was my forte and I was drug, kicking and screaming, into C. I fell into web development, as a favor to someone else, and now I own my own company. So now I'm a programmer but I don't have experience with, for example, Java or Haskell or etc. Yeah, I'm a pretty good programmer in the languages I know but I'm bound by those cause I don't have time to study the rest. So quit doing that! There's something wrong if you can't explain it in the language I'm trying to learn.
Yes :-) I figured I'd call it a night before my brain started to rebel. I'd love to see the most oblique / opaque version anyone can come up with!
Typically it is, for prepared statements, the upfront cost is quite high but subsequent queries essentially just send the parameter data compared to parsing, analysing if using straight SQL.
Okay, In my case I want to reuse the statement above the abstraction layer, and it looks like a mess...
You actually convinced me that the async/await mechanism doesn't need the separate stack :) I still think the N:M threading model is superior as a programming model though (i.e. significantly less cognitive overhead). But that's okay. I can certainly agree to disagree on that :)
Maybe you should just measure it?
It's not much of an abstraction if you expose the statement... Create the api you want and keep the statements private (if you use them.)
What would be very nice. Is a library to obfuscate all the code prior to a build. I'd love to put a compiled binary on a client server and then not worry about them giving that exe/linux binary to a "for higher hacker" who will decompile and try to steal my work. Believe me, it has happened a few times already. So I would love something like this as a result of decompilation and then "hacker" is defeated as it's too much work to try and re-assemble.
I dunno, it [worked fine for me](https://play.golang.org/p/MKdcDR_0O_). Seems valid and useful enough.
you evil bastard. +1
&gt; http://pastebin.com/pvNU7nmR Playground example: http://play.golang.org/p/Kes8bA_t1w
Woops. Thanks.
Depends on the database. Preparing the query will essentially send the query to the database server once, then any subsequent invocation will only send the parameters. This saves parsing time, and a little bit of time/bandwidth spent transmitting the SQL query. However, the performance benefit is typically negligible, especially if your query isn't very complicated. PostgreSQL, for example, will not cache a query plan for a prepared statement until it has been run a certain number of times; even then, query plans usually take less than a millisecond to compute. As with anything, you should measure the actual benefit and determine if it's worth doing. As for your abstraction, the preparing should be done as an implementation detail. Your first interface is good, not the second one. The first interface can store the prepared statements as private members of its struct: type DataImpl struct { getStatement *db.Stmt insertStatement *db.Stmt // .. etc } Last point: If you care about performance, then grouping statements in a transaction is much more important. If you execute updates without a transaction, then a separate transaction will be created for each update. 
I'd love to see this implemented as an extension, something like the tools at: https://github.com/tj/git-extras For the code itself, nothing jumped out to me as awful or wrong!
Oh, I agree. I just don't want OP to get too hung up on seeing inheritance has a means to save typing and nothing else. Inheritance and interfaces _do_ save typing, but they serve a more abstract (as in abstract thinking) purpose. The real power of inheritance comes along when you start thinking about _relationships_ and created classes of objects.
You can't be defined as a slice to yourself because then your size is undefined. Pointers to self, however, have a known size and behavior.
I'm not really familiar with a lot of CS terms - this is basically writing the "reduce" part of map/reduce, with the restriction that the reduction function is associative, which enables parallelism, right? Also, I know I'd be confused as heck to see a function named `mappend` in actual code - I'd expect it to be named according to the actual operation performed, like `concatenate` or `sum`.
The title is kind of misleading. It sounds like Microsoft is going to develop Azure with Go, which is far from the case. They're just adding experimental support for Go applications.
The attack was not only discovered, it was announced both privately, publicly and even featured at conference in 2012 (https://www.youtube.com/watch?v=wGYj8fhhUVA) As they said, "... sound of Java people not giving a fuck ...".
I'm referring to managed SQL. There is a feature where you can scale out by sharing on a key in the database. For example, you may add a key "TenantId", which identifies a specific tenant/customer. Then, you can run all customers on the same managed SQL instance. How would you go about connecting to the correct database shard via Go? Is there a way?
Mostly I didn't think of it. I'm still not to a skill at programming that I'm intuiting better ways to implement stuff like that. It does make more sense for it to be that way, though, so I'll update it! Thanks for the input! UPDATE: implemented it as a method. Learn something new every day! 
This is really helpful too, seeing it in a practical sense. 
By re use the statement does multiple go routines count. In example I have a webserver and the same query is called multiple times a second but in different go routines. Does this count?
Stripping the symbols should be more then enough.
Sorry, I have no idea about the sharding :-( Not sure what your situation is, but as I said, you can run pretty much any database product in Azure in a VM. For managed solutions they have - besides SQL Server - MySQL, MongoDB, Azure Storage Tables ([REST API](https://msdn.microsoft.com/en-us/library/azure/dd179423.aspx)) and probably more.
I'm still confused why anyone cares about app servers for specific languages or frameworks? Just get a cheap base VM, install the needed stuff, and use it as a baseline VM image. It takes less than an hour to install a Golang environment.
Clear and precise, as for your implementation, it might just be what I was looking for, thank you!
This is probably related to docker support on azure. For those unaware, Microsoft has their own docker fork for windows: https://github.com/microsoft/docker
I understand and I'm aware that you can run any other solution. I personally would find great value in running a Go web tier against a managed PaaS style MS SQL Server database. The fact that they are releasing a very raw product (Go with web.config files) and no appropriate database drivers makes me concerned that they do not take this seriously. 
There's nothing stopping them from going to version 1.11 ,1.12 =). Version numbers aren't fractional divisions of a whole - they're just incrementing counters. They will just make the version numbers fit whatever their release schedule is. (As opposed to time-based releases, like say Ubuntu 15.04 - which came out in April (4th month) of 2015).
Hi Nathan - I've just bought a copy =). Super excited to see the upcoming chapters. Any idea on when the next update will be?
Why did you make cron.Job an interface instead of just a function type? Both are equivalent, but having to define a separate type+method makes this much more awkward than just passing a closure (and, if it where a function type, you could still pass it the Run method of a type or value with a specific type without problems). You can also not extend the interface in a backwards-compatible way, so the option of adding more methods in the future also makes no senseâ€¦
Except why would you have a function "concatenate" or "sum" when you're just using builtin types and "+" exists?
The difference is for Angular v1 and v2 there are some radically different changes to the language itself. Now I suspect in 5 versions there may well be a Go 2.0 version (maybe they will call it something else to avoid confusion), but unlike the Angular case, it will only be 5 version of improved on the 1.5 version and that 2.0 version will still be compatible with that earlier 1.5 version in terms of the language specification.
This depends on the database. Measure it!
Because VMs break and are tedious to configure and maintain. A managed platform means you don't do devops anymore. In theory anyway. I get that in practice they don't always work out that way - but the problem they're trying to solve is a very real one. Many developers in startups spend at least as much time managing servers as they do writing code.
They have a fork because they contribute back to the docker/docker repo. Docker on windows is the same codebase as other OSes. They don't release a special "Windows Docker".
&gt; Many developers in startups spend at least as much time managing servers as they do writing code. That's surprising.
they dont do go fmt on that code. :) 
Because a monoid is associative, you can safely break the problem down into smaller pieces, map an operation on the across multiple threads, and then reduce back to a final result without worrying about order of execution or race conditions. Identity is the "zero value" (i.e. '0' for addition, "" for string concatenation, [] for list concatenation etc. By asserting that your type has a sane zero value, you're able to ensure there's a starting point for a reduce operation. Anything meeting this criteria (can be added associatively and has a zero value) is already a monoid, and you likely use then day to day already (ever concatenated a string?) - so this isn't adding any complexity, it's just formalising laws and giving a name to the it. 
A pain is right. The build failed, when I removed 'go' from the makefile and retried it worked. Now I have to debug a build failure in GCC. FML. *edit*: As [others with more patience than I](http://www.sajalkayan.com/post/golang-openwrt-mips.html) have tried to get this working with bare success, I think I might hold out for real MIPS support in 1.6. The Black Swift supports Python (2.7, ugh) and for now that'll do, because life's too short for this crap.
A pointer is just a number so both the size and the initial state of the data is well-defined. Eventually the recursive definition will end with a nil pointer. These examples are strange, but legitimate recursive types are actually quite common. Consider a linked list: type Element struct { next, prev *Element } https://golang.org/src/container/list/list.go#L15 As for the compiler, it's things like this which make types tricky. At a recent conference Alan Donovan gave a brief introductory talk about the types package and how it works: https://docs.google.com/presentation/d/13OvHYozAUBeISPRoLgG7kMBuja1NsU1D_mMlmbaYojk/edit#slide=id.gc9e875b2c_0_130 Not sure if a video of this talk is available.
I think you ought to be careful to draw a distinction between what monoids are and can do, and what monoids can do _for Go_. Due to the lack of generic types and pretty much any other effective mechanism for doing anything like that efficiently (i.e., reflection can work but will eat your performance for breakfast on most monoid combination operations which tend to be very simple), it's not that useful of a programming abstraction for Go. While monoids are also in theory good for parallelization, it's also worth pointing out that as they lack any mechanism for generically splitting them into even pieces (because _all_ they have is the identity and combination operator), you generally need something more to actually take advantage of the parallelization possibilities. For instance, for an array, it would be nice to be able to chunk it up, and for a linked list, you basically lose (there is no practical way to parallelize that because, again, most monoidal combinators are quite simple, like "integer addition", and the memory traversal costs completely dominate the problem and can not be parallelized). This is also sort of an answer to "Why would you ever do this?" that others are asking in this thread. There are other languages that this is useful in. Monoid is an interface, basically, so you can write generic algorithms on that interface. Go's type system is not capable of expressing the interface in question, though. It's useful to understand and recognize the general concept. There's virtually no way to use this recognition in Go, though.
https://github.com/Sirupsen/logrus is pretty nice, I'd certainly recommend sticking with structured logging personally. I dislike the "hooks", just because I think it's much more elegant write to stdio and ship the logs outside of the application, but whatever works :)
I'm more of the opinion that first you build something and try to make it succeed and then, if it does, you will have the resources to move away, if it represents a serious risk to the business or substancial savings. Also assuming here that all things are not equal, meaning the lock-in as a disadvantage, brings the shorter time to market or less man-hours required as an advantage (that is my experience at least). Before enjoying a moderate success, worrying about vendor lock-in and trying to do too much yourself in terms of engineering for greater control is, in my view, premature optimization.
I'm a fan of [github.com/alexcesaro/log](https://github.com/alexcesaro/log). It's really simple and does exactly what I need. I've used it for several projects with no disappointments and the author is very responsive. I wouldn't say it's strictly _better_ than any other logging library; to me, I like that it doesn't do a lot more than what I need it to do.
I think using channels is always good since it leverages concurrency - is there such a thing as an "iterator interface" that can be for-ranged seamlessly (without relying on callbacks) ?
Many people using Azure or other PaaS are specifically took to not muck around with anything outside of the actual code.
glog
glog too
As one of the authors I am biased to [github.com/go-kit/kit/log](https://godoc.org/github.com/go-kit/kit/log). I have also made significant contributions to log15 (mentioned below) and recommend it as well. The Go kit log package was strongly influenced by log15. Go kit log takes a less is more philosophy.
Sure, why not?
The question should probably be - is it possible to write a CAD program in WebGL/HTML5? Because that's what would likely need to happen: then the setup, backend and data storage of the program could easily be provided by Go. WebGL can do complex things.. see fx: https://news.ycombinator.com/item?id=10424850
A coworker of mine wrote https://github.com/phemmer/sawmill. I couldn't imagine using anything else. It providers handlers to integrate with Splunk, Sentry, syslog, and standard streams (STDOUT/STDERR), as well as Capture (to slice) and Channel handlers that are nice for testing. It also has a pluggable handler system that makes it extensible. It spins off a goroutine for each write, so it's super quick and doesn't get in the way if the log handler is slow.
Probably a matter of taste :-) https://www.youtube.com/watch?v=3DtUzH3zoFo
So you changed the words to mandarin? You should write a program for this! Go code can be read using Notepad (well at least variables can)
Welp, so much for [my earlier comment](https://forum.golangbridge.org/t/is-golang-a-good-fit-for-robotics/1136/4?u=matt) then: &gt; Unless your robotics are, like, rockets, Go is probably a fine candidate language.
I see that a lot on reddit
This sounds interesting. What are you thinking? A straight port? Something new? Do you have any domain expertise?
There is a comment with similar question, and author has responded that, obviously there is no GC on rockets. They use Go for telemetry, and GC isn't a problem there.
glog doesn't support rotating files by time, pity.
Updates on this: apparently GothamGo is taking their sweet time. To get things rolling, best way to go is _politely_ ping some folks on Twitter. https://twitter.com/ThatMightBePaul/status/656526742715133952 :D
[**@ThatMightBePaul**](https://twitter.com/ThatMightBePaul/) &gt; [2015-10-20 17:45 UTC](https://twitter.com/ThatMightBePaul/status/656526742715133952) &gt; So @spf13 @markbates who's door should I direct the mob with torches and pitchforks to? I want access to those sweet-sweet \#gothamGo vids. ---- ^This ^message ^was ^created ^by ^a ^bot [^[Contact ^creator]](http://np.reddit.com/message/compose/?to=jasie3k&amp;amp;subject=TweetsInCommentsBot)[^[Source ^code]](https://github.com/janpetryk/reddit-bot) 
Note: Our friends at HakkaLabs recorded a video of all of the talks. Should be up within the month (hopefully sooner!).
This sounds reckless to me. The language runtime is too fresh to have a hand in life and death computing. But, if the goal of SpaceX is flying people around, the technology used must be well proven and understood over many years of use - they are stuck with the programming tools they pick now. This pressure may be exactly what Go needs to more widely compete with C++. [**edit**] In response to the number of downvotes (-11 now), I am sure there are many smart software scientists and engineers out there, and I am sure they would agree that large codebases break in strange and unexpected ways. The instability caused by a large number of people working on one set of code is a big enough problem, adding a third party (Google) without the same moral environment or history (no breaking process at Google has killed anyone yet) means a potentially higher possibility of something you care about disappearing at a bad moment. Big Disasters happen when a lot of small things break, often things that routinely break. I'd argue that the style of Go is a proper direction (minimize bug sources by keeping a simplified strong foundation), but systems requiring dangerous decision making NOW should not use a language implementation not yet proven to never break in the timeframes that matter for missions. [**edit 2**] This is why I argue for development of an idiomatic style of assertion in Go. Writing out all assumptions in a function and crashing immediately on a mismatch only in debug builds is a big step into building and maintaining robust and trusted code. // here's what I use in my current code // implementation still has formatting bugs and it doesn't do conditional compilation, // there may be a clever interface that is useful here package assert func Require(assertion bool, format string, a ...interface{})
I should add that the relevance to /r/golang is that devd is written in Go. In fact, this is the first Open Source project I've released in Go, after a long-ish career writing things in Python (e.g. [qtile](http://qtile.org) tiling window manager, [mitmproxy](http://mitmproxy.org) interception proxy, and so on). At this point, I suspect my next project will be in Go as well!
Ahh, yes, that helps a lot. Thanks. 
Telemetry is data sent from the rocket to the mission control center back on the ground. Basically it lets mission control monitor the rocket in flight. But the rocket control system actually controls the flight of the rocket. So while it would not be good if that telemetry system failed, as the rocket would then be flying blind, it would (or should) still fly. But if the rocket's control system failed, that would be catastrophic, as the rocket would crash, irrespective of whether the telemetry system was working or not. &gt; I just point out that software with major real world impacts has a much lower tolerance for bugs That is true. But some systems are more mission critical than others.
Many programmers of embedded systems come from electronic engineers with most of their careers diving in assembly programming, IÂ²C, DSP and oscilloscopes. They have little or no training/experience in large-scale software system engineering. Remember the Toyota vehicle controller firmware with more than 10K global variables? That kind of code quality is not uncommon in firmware as the people working on it typically excel at hardware troubleshooting and the domain knowledge of certain protocols/standards, rather than software designing and abstraction, which is often even discouraged. IMHO, a programming language whose design having readability, maintainability and testability in mind can outweigh the lack of mature libraries/runtimes. In many cases, those system don't even have a full-fledged C runtime built in. At least, we can be freed from witnessing those interleaved #if-#elif-#endif everywhere. That being said, I am not very confident about the usability of Golang in critical/realtime control system at this stage. It has to be proved first that it's able to implement systems like kernel-space device driver or video/audio decoders. 
At work we use (and built) [gocraft/health](https://github.com/gocraft/health) which provides tagged logging and metrics. Out of the box it can optionally send data to statsd, Bugsnag, or be polled via a JSON API. This makes it super easy to have constant metrics about your running code and alerts when there are issues. We use a [middleware](https://github.com/gocraft/web#middleware) so every web request or background job is counted, timed, and sent to statsd/Librato so we get automatic charts. It also has a tool, healthtop, which is a [New Relic type breakdown of your instrumented code.](https://camo.githubusercontent.com/0984d0789a901aab0edd5257fa06bc19666363f8/68747470733a2f2f676f63726166742e6769746875622e696f2f6865616c74682f696d616765732f6865616c7468746f702e706e67) It also compliments our other project, [dbr](https://github.com/gocraft/dbr), which will automatically log and time executed queries to a given health stream which makes tracking down inefficient queries quick and painless.
thank you! i'd like to get back to improving it soon =) huge props go to cs-guy who was instrumental in making it even better
You know that Go 1.5 has deterministic GC pauses (and those are a lot less than earlier versions in terms of duration) and those are still visibly improving, right?
That's what it means, yes. e.g. NASA has their telemetry systems written in pretty much anything - quite a few are done in Python. Normally you have a demarcation point somewhere at the ground where telemetry is presented on a (software) message bus. Everything from the rocket through the radios at both ends and until data ends up on that message bus are systems designed with the highest reliability. Then you write software to process those messages, archive them, graph them, animate them and so on - which doesn't necessarily need the same stability.
&gt; this This looks like the nicest local web server I've seen. Lots of well planned and "get out of your way" features. Kudos.
Here is my version written in Ruby. It also allows revoking keys and refreshing them. https://gist.github.com/bradfordcp/32cafe888bb7f9c88259
&gt; standard logger This piece of shit is useless and should get deleted asap. Used it, tried to change date format to ISO 8601 norm, the standard date norm, LOL NOPE HARDCODED. Delete, next.
I don't have web development experience, just desktop app development experience so any guidance in the basic methodologies I would need to learn is much appreciated. @kardianos Yes, I think it would be something similar to tinkercad but in my case the CAD app would be for Electrical Engineers. Instead of hosting the server remotely, my users should be able to run the web server locally. Since it's only 2D drawings, I don't think I need the power of webGL but maybe only HTML5. 
You should apply if you enjoy working for weeks with no days off and 12-14 hour days.
The reason I'm bringing it up is because it seems like you're iterating over the url path one character at a time, looking up the value of that character in a map. That's the exact same thing as outright using a map, except now you have additional branches. Tries usually afford a smaller memory footprint plus the ability to stop searching partway through the length of the key.
The main development efforts for tor pluggable transports has been written in go for a while already.. examples: https://gitweb.torproject.org/pluggable-transports/goptlib.git/ and https://gitweb.torproject.org/pluggable-transports/obfs4.git/ I'm building a software on top of the TOR pluggable transports right now. (placeholder readme until some milestones are reached here: https://github.com/alkasir/alkasir ). It's meant to be a way to access a certain set of sites and to some extent relies on users reporting which sites are blocked, so it naturally has a much lesser degree of anonymity than what TOR aims for. Most of lantern is also written i Go. Lantern also isn't TOR in the sense of anonymity but also in a somewhat related sphere of tools https://github.com/getlantern/lantern Right now, the future of Go in in "liberation tech" seems quite promising. 
last I checked, 0.1 + 0.2 + 0.3 isn't supposed to equal 0.6000000000000001
I'd be curious to see some benchmarks against the core library. Having at least dug around quite substantially in 1.5's XML parser I can see how libxml2 is probably more correct (not that 1.5's is "bad" necessarily but it's got some (known, bugs filed, discussions active) issues around namespaces), but bouncing in and out of C like that could be an issue.
[removed]
Hi, I am iterating per resource not per character so for a request like: /foo/bar/view There is a structure something like map[foo][bar][view], must of the docs I found iterate one character at a time, but since this is going to be an http router I though that using the full resource as a key could be more efficient. like I said I still to do some benchmark it, any help with it be appreciated.
To sum-up, it's 2D CAD in a browser using HTML5 (and SVG?) with a local web server that's the Go executable. Are you aware of https://github.com/gopherjs/gopherjs to have even more be Go?
Thank you, I was not aware of that repository. After using Linux for years and switching to a Mac recently I didn't even think about the ds store files at first.
That case you describe caused the crash of https://en.wikipedia.org/wiki/Mars_Climate_Orbiter Those parts of the telemetry system are mission critical - mistakes, glitches, crashes, bugs, at any point in the technology stack can contribute to a disaster. I just present a warning to engineers. Engineering is all about tradeoffs, and there is little or no room for error for many systems, especially in aerospace. Understanding and proving the entire technology stack is critical scientifically, ethically, and monetarily.
I wasn't aware of gopherjs. I will see if I can use it and keep as much in Go as possible. Yes, HTML5, SVG and PNG and others. What would be the best way to detect user mouse and keyboard events and provide text boxes / combo boxes for the user input? 
Isn't there any tool for this yet? 
Is the blog (scotttactical.com) running on hugo? If so, what type of droplet are you running?
I love Hugo. I've moved my site to it: http://go-beyond.org/ https://github.com/teran-mckinney/go-beyond.org https://github.com/teran-mckinney/hugo-theme-html5
That is the great thing static content. I could have hosted it on github / s3 / raspberry-pi in my living room. I see you do a bit of writing. 
So we lost the ability to produce deterministic hardware?
In some respects yes. Certainly in regard to very tight scheduling of operations.
Can you elaborate a bit? I'm really curious.
For anyone interested my hugo deploy script, everything that is in master branch gets uploaded with ftp. #!/bin/bash git clone -b master --single-branch . temp cd temp hugo cd public find . -type f -exec curl -u user:password --ftp-create-dirs -T {} ftp://ftp.server.com/www/home/{} \; cd .. cd .. rm -rf temp 
Don't forget you're not allowed lunch breaks and they pay under market because you're working for the good of humanity and at all times you are fully replaceable by more qualified people.
We typically use logrus, but also attach some custom hooks to report to Rollbar. In addition we utilize go-metrics for publishing metrics to Librato. Other folks in the company utilize l2met, which just pulls metrics data out of the logs -- this is a service run by Librato. Recently, I've been thinking about how to make this all better, and started a new lib to hopefully simplify this workflow. The basic idea is that you log key-value pairs (though anything else is supported as well) only, and attach filters to the logger, which can do things like print to standard out, or report to rollbar, or stop the filter chain and post l2met style metrics directly to Librato (instead of doing the l2met thing). I think the same thing could probably be done in logrus, but there are other little things that bug me about that library, so YOLO: https://github.com/apg/ln. Keep in mind that I've put like 2 hours into this so far and have a long way to go, and may just abandon it if it doesn't seem like it's any better than what we have...
hugo looks cool, but I feel like the wordpress plugin ecosystem isn't going anywhere anytime soon.
The comparison would be fair if my mom could use Hugo like she can use WordPress. Already took me months for her to use WordPress..!
Wordpress is huge. It's strength is also it's weakness. Why it takes 3+G to run. 
Thanks for that!
I was just flaming. I like to do that to the JS guys. A play on word with front-end/back-end paradox.
I really like where this is taking me. 
People talk about other forms of art all the time without worrying about being subjective or opinion based. Why is software different?
Tools are not art. Tools may have art incorporated into them, but the art is separate and distinct from the tool. Software is a tool, not a piece of artwork.
You might be interested in this automated setup for publishing on git commit (built on almost entirely free services - just s3 costs of $0.01s): http://loads.pickle.me.uk/2015/07/25/hugo-s3-hosting/
Tnx. My biggest thing I need right now is how to get all my pictures up and managed. Gallery tool. Prob will write one. 
We are subjective always. Even just slightly. Our past dictates our decisions. And also it's rhetorical vs analytical. This is the political side of software. It is best when people do bring it back into the pragmatic spectrum. Also If you noticed a put a header above it stating that I was flaming to keep it jovial. That helps for surfacing conversation and keeping it lively. 
&gt; https://github.com/gophercon/gc15/tree/master/docker There's our configs for GopherCon.com. It's an out-of-date version of Caddy, so configs may have changed in the interim, but it should get you started.
&gt; Those parts of the telemetry system are mission critical In the case of the orbiter, that might well be the case. But you could also argue the actual control system was at fault, since it sent the command to the orbiter (using the telemetry data) to fly into Mars. Now I have no idea how SpaceX rockets are designed, but I would assume the rocket would be autonomous. In that type of system, the control system would need input data from it's environment and like orbiter that data would be mission critical. But I would hope that data would not be in any way connected to a secondary system designed to just send data back to ground control. In other words the control system should not be getting it's data from the telemetry system and the telemetry system should not be talking to the control system to get it's data. But if ground control is playing a role in flying the rocket and the rocket is not autonomous, then of course that telemetry system would indeed be mission critical. 
If you cut your teeth on C like languages, ruby syntax is a PITA.
yes
Any reason you chose not to use https://github.com/go-fsnotify/fsnotify? 
Ah, gotcha!
Ruby is a great deal more complex than Go.
&gt; I will put some girls I know on it who are models and actresses and let you know if it succeeds. Thats a good test. If they are inexperienced/non-technical, than that's the part you should mention. Not their gender and occupationâ€¦
I use brew install fswatch fswatch-run *.go ./build.sh 
&gt; It'll be running fine for a few weeks or a couple of months and then it goes down without a warning. You should setup a monitor: http://www.montastic.com/ or https://uptimerobot.com/
Why does it need to be written in Go? How is the programming language a tool is written in relevant for the job it's doing?
I'm one of the Prometheus developers and it should support what you need. The alertmanager's generic webhook can send out alert notifications to any HTTP endpoint in JSON. I did a [demo](http://www.robustperception.io/audio-alerting-with-prometheus/) of this a month back.
How do web apps like Tinkercad detect user mouse and keyboard events and provide text boxes / combo boxes for the user input?
&gt; Do you have anything to show that Go code is more susceptible to mistakes, glitches, crashes and bugs? This was not my assertion. I am concerned about the maturity of the Go runtime (NOT about code written in Go). &gt; The latest Go release, version 1.5, is a significant release, including major architectural changes to the implementation. [Go 1.5](https://golang.org/doc/go1.5) introduced a rewritten compiler and garbage collector, three months ago. Even though the compiler rewrite was just a style of automated translation, any changes introduce risk of something breaking, as any engineer knows (i.e. always verify your changes). In aerospace we're talking risk management. Cursory, automated, or even lengthy testing is never enough to say "this will never break". Repeated use over time is the best judge of correctness, as far as we can take it. If part of the stack is still seeing major architectural or implementation changes then I wouldn't trust it anywhere near my rocket, no matter how top the designers and implementers are. An internet website? Alright, risk is acceptable. But not anywhere near something that could explode spectacularly. (the type of bug I'm thinking is something like a GC crash that happens once every 10k years of running Go code - these style of bugs have existed in the world and are more likely to have been caught in a C compiler or other place with years of stability, instead of months).
&gt; and you don't. Bold assumption indeed.
&gt; "Written in go" â‡’ "**single static binary** with reasonable performance". Which you will have to compile yourself unless you're telling me that you're trusting some random people's builds. But let's assume you're not crazy and you're building it yourself. Well, then suddenly you'll be in the dependency mess that you're taunting Ruby with. Or is Go somehow immune to that? &gt; "Written in C" â‡’ "Probable security hole if it has network access". Of course Go has like 0 flaws! And it has magic built-in that prevents every developer from shooting themselves in the foot. &gt; "Written in ruby" â‡’ "Probably some dependency problems when updating, better get used to rvm". Not sure if you knew that but people in the Go community are desperately trying to come up with a dependency management solution that doesn't suck more those of other languages. Don't know if they got there yet or if they just went back to vendoring it all. &gt; "Written in Java/Skala/Clojure/â€¦" â‡’ "Make sure you ship a JVM and have enough memory". You're kidding right? The JVM is one `apt-get install` away and hardware is usually the least of your problems. &gt; "Written in perl" â‡’ "Dear god, hopefully it does everything I want it to perfectly because I will never fix that mess". I guess I can agree with that one at least ... no, seriously, do you really think people will dive into the code of even only a moderately sized project just to debug a misbehaviour that they're observing? They either live with it and maybe wait for it to be fixed upstream or they switch products.
Btw: &gt; But let's assume you're not crazy and you're building it yourself. &gt; The JVM is one `apt-get install` away Seriously?
&gt; You grossly misunderstood my comment. **It's purpose wasn't primarily to bash on other languages**, but to illustrate how hugely important the language choice can be. But it certainly sounded like that. &gt; I do indeed trust the developers builds (which I install from signed binary packages of my distribution). Usually a package maintainer is building it then. And depending on your distribution that's not necessarily a developer of this project. But do you only use Go projects that made it into your preferred distro? &gt;&gt; Of course Go has like 0 flaws! &gt; Never claimed that. You are putting words in my mouth. I was being sarcastic. As for your other point, Go is very very young, that alone makes it immature. And with its growing popularity it's attracting a lot of people including those who don't really know what they're doing but still release software that is then used by other software and so on. Go is **not** more or less of a security risk than any other language. &gt; If I install a go program it will run in 10 years just as well, probably longer. [...] If I install a ruby program, it breaks. On every effing update. I admit the deployment of a Go program is almost a no-brainer (btw. I like Go very much myself for that reason). But lumping every Ruby program together like it's inherently the most shittiest thing in the world is just not fair to say (btw. I really really dislike Ruby for various reasons). &gt; Yes. That's just common fucking sense. Why else would you run open source anyway? [...] Using open source software and working on it (aka contributing) are two very different things. And I doubt that the majority of situations is like in your company. It's really cool that you're doing it like that, especially that you're given or taking time to do that! I appreciate it.
Trusting a random person's build is different from trusting a package that's gone through an established process of reviewing it by people that are actually known by the community surrounding it (i.e. not everyone can become a package maintainer and put their stuff in Debian).
Nice sexism baiting though. The "actors" are all women. The models are all guys. Reddit: batin' since 05 Glad the old guards are at their posts. I would post their MM accounts to prove it but not worth it. Generalization is a tool used by humans to help with the minutia of life. Generally people who are not in a technical field are non-technical. It helpful to state exceptions not delve into norms. 
Consul is a service discovery system, not a monitoring system.
Lol, I know, really good read, I liked "True calling" thing...
&gt; Go is not more or less of a security risk than any other language. It is *much* less of a security risk than C/C++ (so is *any* other memory safe language of course). Claiming otherwise is ignoring reality. There are classes of security bugs that are language independent. C/C++ have their own class and it's probably the majority of the exploits out there *by far* (I don't want to claim numbers, but the margin should be enormous). Again, to reiterate: If you think, that software written in C isn't a *huge* security risk, you have been living under a rock for at least 30 years.
Oh thank you good sir! You have righted a major wrong. I'll edit to make sure you check off your list my proof reading abilities. And I'll link to the accounts upon accomplishment.
[Here](https://goal.colegion.com/manual/run/index.html) is another tool. It is a part of my effort to develop a framework that is inspired by Revel but implemented as a set of independent tools, uses code generation instead of reflection, compatible with the standard library, modular, and fully customizable. Task runner can be used on its own without all other components. Just as reflex it isn't tied to any language or framework.
Yeah 300M for the app that size is still better than what I had. We launched a pretty sizable app on node.js. One guy was a core contributor so we had talent on board and it was still a monster. Memory was leaking everywhere and it was a nightmare for a while. The guys left when tinder started up. Hence my politics and flame. I'd agree with calebdoxsey uptimerobot saves me embarrassment. 
It's both https://www.consul.io/intro/getting-started/checks.html
As an older professional programmer, I don't disagree with any of Mr. Wisniewski's points. I also didn't find anything particularly novel in them. With all due respect to the author, how likely is it that someone would remain a professional programmer past 50 without recognizing and practicing this stuff?
I used fsnotify to build an auto-test tool: https://gist.github.com/montanaflynn/2851d82437668197444d
Hi, I would return errors instead of using log.fatal() : that would allow the user of the lib to manage the error (retry, use another logging lib...).
At a quick glance it seems overengineered. Just a function for each endpoint with the key as an argument and result, error as return values would be enough.
Golang is golang. There are more and less safe ways to do things. You can type check your interface values if you want to be safe. Or you can write type specific implementations or wrappers if you want safety and/or speed.
I think un-Go is harsh, it's a whole section in Effective Go: https://golang.org/doc/effective_go.html#interface_conversions Personally, I'm a fan of either using code-gen or wrapper types to get type specific structures. However there's really nothing wrong with using interface{} and type assertions (or even type switches) when appropriate. 
Oh, type assertions. I was thinking of [these assertions](http://stackoverflow.com/questions/1571340/what-is-the-assert-function). &gt; assert will terminate the program (usually with a message quoting the assert statement) if its argument turns out to be false. it's commonly used during debugging to make the program fail more obviously if an unexpected condition occurs.
Yep, there's no really no better way to do it in Go. Rather than thinking type safe or not, it's helpful to think of it as, "how many static safety guarantees does my language give me". At one extreme you have languages like say Python or Ruby that basically guarantee you nothing; at the other extreme, stuff like (I dunno) Agda or Haskell that give you a ton of guarantees. Go sits somewhere in the middle. It includes just enough to catch a lot of errors but still be really simple.
&gt; The key I believe is that *T set of methods includes methods defined for a type T. Yeah. However, Go will also (sometimes) happily take the address of a variable if you call its pointer method. E.g., https://play.golang.org/p/9gFySiM8Ad I believe this is covered in: https://golang.org/ref/spec#Selectors Also minux covers it in this thread: https://groups.google.com/d/msg/golang-nuts/-ZoCu5m0kJ4/4LPzq4mgTyoJ
First a nit: It's simply "go", not "golang" :) Now to your post: The go gods will tell you, that "type safe" is the wrong term to use here. `interface{}` is completely type safe. Every value has a type and you can't interpret it as a different type (except in very narrow circumstances) even by accident. That's type safety. What you are looking for is "statically type checked". And even there, people might tell you, that the inbuilt version of a linked list is indeed statically type checked. It just uses a different kind of type (namely an interface type). So the question you are looking for is "are there parameterized types in go", i.e. you want one type, that can contain arbitrary types as an element, but gives the static guarantee that you use every value always with the same type. And phrased like that, the answer is famously "no". Because that's what generics (most often) mean. And go doesn't have these. However, this shouldn't really deter you. It turns out, that this isn't really a problem in practice. If you *know* a list should only contain a certain type, you *won't* pass in other types and you can do simple type assertions (even without `, ok` idiom) to unpack it. Yes, you don't get the compiler guarantee. But even without this guarantee, it still never (up to an error of measurement) happen. Promise :)
&gt; It's basically the equivalent of using `void*` in C It's fundamentally different from `void*`, in that `interface{}` is actually type safe, while `void*` isn't :) `interface{}` carries the type of the contained value, which makes it impossible to wrongly interpret it as a different one, which is (runtime) type safety.
Yeah, you're right about the over-engineering. Since this was partly a learning exercise I took that route on purpose. But simplifying would improve readability.
Yep, this is true. Thanks for the tip :)
The problem with "monitoring" is that is has very different meanings depending on who you're talking to. One meaning is "supervisor", that it when such a check fails it'll restart the process. Consul does not provide this. Another meaning is "metrics". It is possible to pull the health data out and track it over time, but that's not part of Consul itself. What consul does have is an on-machine healthcheck for use in loadbalancing - in this case via service discovery. This is a handy way to avoid talking to servers that you can be pretty sure won't work, but you [still need to send healthchecks from your clients to catch all the potential failure modes](http://www.robustperception.io/healthchecking-is-not-transitive/).
The standard library implementation of a linked list casts any type you pass into PushBack() as the interface{} type. You are correct in that you can't do much with this type when it comes back out from Front() without using reflection, however you can implement your own Linked List that accepts a more useful interface type without using reflection. In the standard library list.go, simply define a custom interface such as: type Printer interface{ Print() } and then use this type in the Element struct: type Element struct{ Value Printer } You can now perform actions on the returned element: for e := l.Front(); e != nil; e = e.Next() { e.Value.Print(); } as e.Value is now of type Printer. You can now pass any type into PushBack() as long as that type implements Print(), otherwise the compiler will complain. As long as you are implementing the interface in your own code you know how the elements are supposed to behave when they are returned from the list. With the standard library, they have no idea how the returned elements will be used by the end user so they use the empty interface, and leave it to end user to pull out the original type using reflection.
70s hardware = big cpus (can't find the english word that describes the size of the cpu) that are unlikely to fail due to cosmic rays and are tested for decades now. A modern 14nm cpu would go nuts in the space.
Yes. A logging mechanism with hardcoded date format is shit. If that date format isn't even ISO compatible is a piece of useless shit.
&gt; Or is there something that I am missing? Yes, the meaning of the term "type safety".
See [summary of go generics](https://docs.google.com/document/d/1vrAy9gMpMoS3uaVphB32uVXX4pi-HnNjkMEgyAHX4N4/edit#). Also linked list is a bad example, because it shouldn't be used in the first place (most of the time).
I think it's too big an ask to have people go out and read an entire exercise and solve it for you. Suggestion: Try to find the exact point of confusion where you're getting stuck, and distill that into a self-contained example that, if it were solved, would help you get unstuck. Then post that as a question.
I understand that. Sorry if that wasn't very clear. :) I don't want them to solve the entire exercise!! Just give me a couple of "pointers" (pun intended). I'm lost where to put what. I don't want a complete solution. Just a nudge into *some* direction. My problem is, that I don't know exactly what my problem is, and where it is. :) 
And it works? Have you noticed any drawback or issue?
Thank you, apparenly, I need to read, not to skim. Also, it demanded ldflags next, but that problem was easier to solve.
Generics are a bit too magic-y for me, even though I work with them on a regular basis in other stacks. Frankly I hope they stay in limbo. What's next, operator and func overloading?
Well, speaking for myself personally, even reading and understanding that whole exercise was too much effort! But if you have a question that can be put in the form of a self-contained comment, I'll take a crack at answering it. :)
I do understand it and I still think it has no place in Go.
Yea and please mention the overhead added by it.
Nice to see new tools coming up! :) Is there any advantages over https://github.com/golang/tools/tree/master/cmd/gomvpkg? 
Got it! Congrats on releasing it! You probably learned a lot of things meanwhile (like go/parser, go/ast, etc..). 
https://github.com/dveeden/udf_fileexists_go/blob/master/udf_fileexists_go.go#L17 I believe that `C.CString` is a memory leak.
Why?
Thanks :) And i definitely did, it was my first time working with the cli package from codegangsta and ast tree parsing etc.
+1 for the auto rotate based on EXIF orientation. That's such an annoying problem. 
Are you trying to do something like the following? http://play.golang.org/p/DeAmSco_8o
The Go runtime is essentially a microkernel running in user space, providing services like scheduling (gorountine), memory management (GC), and IPCs (channel). The runtime code is still messy that portable and OS/architecture dependent code has not cleanly modularized yet. For critical control system like avionics, the sole runtime system must pass various certifications e.g [DO-178](https://en.wikipedia.org/wiki/DO-178B) and [IEC_61508](https://en.wikipedia.org/wiki/IEC_61508). It would be amazing if the runtime can reach that level of standard one day. But for now, it is actually not even close.
&gt; http://play.golang.org/p/DeAmSco_8o Exactly!! I was doing the same thing, though I had several other problems. :) Like, I was trying to reference an interface, rather than an struct. Also, I had a wrong linking of pointers somewhere in my code. I'm sorry guys, I know this is too complex to be a simple problem. But than again, rarely anything is simple in the world of software development. :) Thanks for the effort of helping though!!! Much appreciated!
Yup. Working with MySQL. I'm using https://github.com/go-sql-driver/mysql for the driver and https://github.com/jmoiron/sqlx for some nice helper methods.
MySQL and more recently I've also been using [gorm](https://github.com/jinzhu/gorm) to simplify building CRUD apps.
MongoDB, for simplicity, and there is a phenomenal driver for it - [mgo](https://labix.org/mgo). For me it's easier than ever to query db and marshal results into a struct. Give it a go. If you want to stick with SQL though, it doesn't really matter which one you pick, since they aare all compatible with [generic SQL interface](https://golang.org/pkg/database/sql/) in standard library. Just make sure you use [sqlx](https://github.com/jmoiron/sqlx) as a boost to that interface, it is very powerful.
Yes you are correct, I did indeed mean type assertion. I think my point still stands though, you most definitely can implement a 'type safe' linked list in Go using interfaces. 
https://github.com/boltdb/bolt is an interesting choice, especially for a small blog or something relatively simple not needing a complex SQL db. It fully implemented in go, so all you need to do is import it as a library and your set. 
&gt; Generics are a bit too magic-y for me Then why won't you read more about them? &gt; What's next, operator and func overloading? I'd be happy to see this in Go.
Check out https://github.com/geir54/ggap/ it uses gorp and postgresql
Then you should remove the comment at the top about that cause it implies it's needed.
https://github.com/go-gorp/gorp
Go does have generics, but only the built-in ones: `map[T]U`, `chan T` and `[]T`. I personally don't like how the designers of the language decided on leave user-defined generics behind, feels to me like an oversimplification, but that's only my opinion.
If you want to learn how to work with databases; start with PostgreSQL. It's the best one and it's free. But for some reason a lot of people are using MySQL. I blame PHP's early support ... and I think PHP and MySQL have quite a few things in common. 
Using ORM under GO is always weird. GORM seems the most feature complete, but it's documentation is beyond horrible (the documentation is the README.md file in their repository..., the code is largely undocumented). Simple CRUD actions are really nice in GORM, but anything with relations is awkward to use. In the end you have so many "gotchas" to look out for, that it's starting to perplex a regular developer. In the end, standard database/sql with sqlx is the best thing to use. Simple CRUD work is also incredible easy with sqlx and I think it's better to let the developers learn proper SQL than let them learn the gotchas that GORM has. sql/sqlx might result in the end in a little more code, but it's much easier to understand and maintain in the end.
I have never done a large project, but for smaller ones I tend to use sqlite (https://github.com/mattn/go-sqlite3) with the plain database/sql interface (sqlx looks good though). I would love to try bolt sometime since it's pure go, but I haven't needed a key/value store yet.
What do you mean by that?
I didn't know about sqlx... Thank you! Some coworkers have been using gorm, which I frankly think is an undocumented mess and a terrible abstraction that ends up being more complex than plain old SQL.
He's making a lame joke about 'crud' meaning crap. i.e. You said you're building 'crud' (crap) apps. He says they're not so bad (*rimshot*)
doh!
Thank you for pointing that out. I totally forgot about the fact that ast tree parser in go ignores all the comments, its a weird limitation. I will implement a way to replace the paths by parsing the strings manually instead of using ast parser, and also leave the ast parser option as a flag (something like safe mode).
A quick grep through my GOPATH shows that a lot of serialization code is going to break. &lt;dgryski@kaepora[~] \Ê•â—”Ï–â—”Ê”/ &gt; cs 'PkgPath != ""' |wc -l 110 
Much appreciatedï¼I got the idea.
it allocates memory. you need to `C.free` it. If you can use reflection to get the pointer to the byte array.
Does the download link changes every day ? Is it something you can guess without having to parse the container page ? Maybe you want to prototype it using a couple of curl commands (fetch the container page, fetch the CSV), then write down the exact steps you need to execute (you mention a "master list". Is this another CSV file, a database or what ?) and then ask how you can implement these steps in Go (the first two would be basic HTTP requests, for which you can see examples in net/http as suggested by others)
This idea has been posted before and it's not true method overriding. Given type Foo struct{ Bar } `Foo` doesn't "inherit" any of Bar's methods or properties or whatever, `Bar` simply exists inside `Foo`. That's it. With some OOP languages you can use the superclass' method (like Python's `super()`) to call the 'parent' or 'overridden' method. In order to do that in Go, you'd have to call `Foo.Bar.Method()` which is just calling a distinctly different method inside a distinctly different type living inside `Foo`. It's similar, sure, but distinctly different.
Thanks so much! Sounds like a great plan! 
channels are like buffers (arrays of *type*) for: talking asynchronously to your other threads when used correctly with select and range(mychan), its almost like reactive programming strm := make(chan string) go func worker() { // new goroutine similar to a thread for { // while(1) x := readfilechecknewcontents() if x { strm &lt;- x.newdata } // write something to strm time.Sleep(1000) } }() go func reader () { select strm { // read strm case v &lt;- strm: fmt.Println("our data reader said:", v) // read value of strm // this will fire every time the other thread writes to stream. very cool case close: fmt.Println("thread closed shutting down!"); break; } }() // keep doing stuff .. while those two always handle your data .. .. these two just loop forever and talk to each other (12 loc) and use like 0.5% cpu, in C this was a PITA.. the benefit of this is the reading data and processing data are done asynchronously. ----------- pointers pointer is a way to pass a address of a value ... so if you change the value the new value is available to the old code also a shorter way of writing code: func foo(obj bar){ obj.newvalue = 4; return obj } obj = foo(obj) shorter with pointers: func foo(obj *bar){ obj.newvalue = 4 } foo(&amp;obj) // pass the address of obj ex: no pointer: func foo(obj bar){ obj.newvalue = 4 } obj = bar{ newvalue: 0 } foo(obj) fmt.Println(obj.newvalue) // 0 ... this didnt update pointer: func foo(obj *bar){ obj.newvalue = 4 } obj = bar{ newvalue: 0 } foo(&amp;obj) fmt.Println(obj.newvalue) // 4 its also faster for big data to pass the pointer, not copying the value to the function!
I feel it's worth pointing out that just that search has a bunch of false positives, though. For example, an RPC mechanism skipping unexported *methods* looks superficially similar: https://github.com/tv42/birpc/blob/22dcbfff0024e83a23cb42c800c1523a3ba08a4c/birpc.go#L54
Hey, thanks for recommending us! What kind of generator did you write? I'm imagining SQL tables to structs? Check out our [new branch](https://github.com/gocraft/dbr/tree/postgres) which support more features, including Postgres. I'm really happy with the work [taylorchu](https://github.com/taylorchu) has done to enable multiple drivers, as well as more advance SQL features like subqueries and more complex conditionals.
From a quick read, it looks like the examples in the readme are all injecting primitives - strings, ints, etc. Is it possible to inject other types or interfaces?
Thanks Victor. Right now my plan is to have monthly updates. Chapter 3 is nearly ready, and will hopefully arrive by November 15th. I've already started working on examples for Chapter 4 as well, which will go through editing once the first draft is done. Hopefully Chapter 4 will be ready for mid-December. If you have any feedback on the first two chapters, I am always looking to improve the book. Check out the author forums on Manning's site: https://forums.manning.com/forums/learn-go
tables -&gt; structs of course. I really hope you guys don't modify the interfaces too much to follow up. :-)
How does "Perfectly fitted for Docker or Heroku." imply that Docker or Heroku are requirements? Neither is any of these listed anywhere in the "Prerequisites" :-)
He's using webpack which requires node. Once bundled I don't think you need the node dependency anymore. You could build the binary, package it with all the static assets and bundled files and then deploy that. There are a lot of tools for frontend development built in node. Although it'd be nice if those tools were written in Go, I don't think that's going to happen anytime soon.
With channels, the producer, the consumer and the error handler can be different goroutines. With a function the one caller must synchronously handle all the responsibilities.
How does it not? If it works anywhere, why doesn't it say, "Works everywhere!"?