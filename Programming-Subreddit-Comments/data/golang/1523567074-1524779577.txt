No reverse tunnelling 
Haven't HAProxy and Nginx been replaced by Envoy?
Sum-types typically have exhaustiveness checking implemented for them, allowing you to leave out a default branch and be informed that your switches don't check every member. 
So... you're complaining that the difference between your question and the duplicate is that he got his from a file and yours is a []byte and so it isn't a duplicate? Haha, I would downvote the shit out of your question too.
That is actually cool. It is arguably security by obscurity but it is so obscure it could be counted as real security!
I had to do something similar about 5 years ago (in Go) for a service that was streaming videos to phones. In general you can't simply take the first frame and use it for the thumbnail - videos usually faded in and the initial frames are usually either all black, sometimes all white. These initial fades can last up to half a second or more. My solution at the time was to extract the first few seconds of frames (using ffmpeg) , compute their luminosity and look for the *knee* in the luminosity curve across those frames to find the end of the fade. A number of frames around that point were then extracted and presented to a user who selected the appropriate *poster* frame (show them a grid of frames and let them click on the one they want). This approach was okay in my situation as there was an *editor* who had to do a final approval prior to making videos public and the poster frame selection was one part of this process. The luminosity check was quick and easy to do but it is essentially flawed but since I had a human in the loop we deferred things to them and simply gave them a tool to make the process relatively easy. 
&gt; Some points are really wrong and just show a lack of understanding of Go because of a very strong "Java mentality", for example in "zero values that panic". I read this sentence 3 times and I'm still not what you mean. Yes, there are zero values that panic in the standard library. How is that in any way related to Java or "Java mentality"?
&gt; rather than admitting that my favourite language might not be perfect You realize this exact sentence equally applies to you, me and everyone else, right?
&gt; Uh, what use is a file variable if it's not set in literally any other language? His point is not about `os.File`, that's just an example. He is saying that by not implementing language-defined constructors like other languages, methods in Go either panic or have to implement costly initialization checks at every invocation. He gave `os.File` an example of that, which is fair.
&gt;Nginx is a web server which can also be used as a **reverse proxy**, load balancer and HTTP cache. This is literally what you're asking for though.
I need a reverse **tunnel**
What makes Node good at IO in comparison to Go or other languages? I've never really heard that said about Node so I'd be interested to learn about it.
From the repo you liked: &gt;A fast **reverse proxy** to help you expose a local server behind a NAT or firewall to the internet. What exactly is your use case? SSH into a server on the LAN? Hosting a web service that needs to be exposed? RDP into a server? Nginx can forward arbitrary TCP and UDP connections, and it's really straight forward: https://docs.nginx.com/nginx/admin-guide/load-balancer/tcp-udp-load-balancer/
&gt;firewall only allows outbound connections. Giving this info up front would have helped. Either fix your firewall, or use SSH as a reverse tunnel: `ssh -R 1234:localhost:22 user@some.external.server`
Omg dude, fuck off. You think I don't know about ssh tunnels?
I don't think they meant to say that Node.js is better than Go at IO. They are implemented in the exact same way (ie. they wait on lots of sockets at once in a single thread instead of blocking in many threads), but Go can do a lot more because it isn't forced to run only one thread of business logic at a time. Most languages can be just as efficient IO wise if they use the same model, but most do not have it built in to their standard library. One of the selling points of Go is it's all done for you, automatically. Though this does mean that if you were to write all the code to do the IO for your program yourself, you could be more efficient.
You're an idiot
I recommend this https://www.toptal.com/back-end/server-side-io-performance-node-php-java-go pretty much sums up everything 
Client's firewall. They won't open the port, but apparently this is fair game ...
Exactly. Plenty of Go code will panic if you call the `String()` method of an invalid `iota` type, but of course, only at runtime. As that's a method that often gets called implicitly when formatting strings, it has even more of a whiff about it. 
Thanks for helping explain the 'how' of Golang / CI and Docker images. I'm also interested in the 'why' of it. Could someone please detail why docker is required and what benefits there are to using it?
The post seems somewhat convoluted. If you have a `Dockerfile`, I don't see why you can't just build the project using that `Dockerfile`. Below is what we do for one of our production application: ``` image: docker:latest services: - docker:dind # ... build: stage: build script: - docker build -t &lt;TAG&gt; . - docker push &lt;TAG&gt; ``` We use a multistage `Dockerfile` for our build so it looks something like: ``` FROM golang:1.10-alpine as build # Install utils, go dep, etc # Perform actual `go build` with CGO disabled FROM alpine:3.6 COPY --from=build /build/artifact /cmd/ ``` You could also go as far as copying the artifacts out or doing the above alongside https://github.com/goreleaser/goreleaser in snapshot mode (so nothing actually gets published). 
It kinda sounds like you've got everything you need figured out? You just implement a .Write method that saves the bytes to a slice until it is if a certain size, then write the file. Whether it's a good idea depends on a lot of details about the relative cost and availability of various resources. Hard to be sure without more details, and the decision tree is too big for me to serialize into a Reddit post. 
&gt; you’d use external services as containers That's hard to generalize. Much easier to keep your mocks within your service, and use dependency injection as needed. And in fact, you can find "real errors" against "real services" much faster in this manner. Integrate one service at a time, instead of all-or-none. The over-arching theme here, is to keep your tests as simple as possible. Otherwise, you'll be chasing bugs in your test, when you're looking for bugs in your service.
Holy cow, that IS fast! I'll angle toward this impl. I'm currently (as other work permits) still building out the structs for the data I'll be iterating over. Should have a v1 tonight. Go syntax is more different than I expected but not too painful!
That's all Glenford Myers talking there. You can just read chapter 1 of his book and get quite a good idea of his philosophy on test.
I'm new to golang myself (more of a java guy), but couldn't you just create a decorator function that wraps an io.Writer and os.File?then just put your logic in there. 
@jerf In the example you linked, I'm having trouble understanding how the output of cpg.next() is getting placed into res. If you have a second, can you give me a hint or two as to what is going on there? Thanks!!
I'm fairly sure this exact piece of code is not what's causing your problem, you may need to provide more context.
Sounds like a scope error. Probably DB is both a package variable and a function variable but without context that’s just a guess. 
Also interested to hear what people think of this. !RemindMe 2 days
I will be messaging you on [**2018-04-15 00:54:17 UTC**](http://www.wolframalpha.com/input/?i=2018-04-15 00:54:17 UTC To Local Time) to remind you of [**this link.**](https://www.reddit.com/r/golang/comments/8bqhv8/fast_reverse_proxy_who_uses_this/) [**CLICK THIS LINK**](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[https://www.reddit.com/r/golang/comments/8bqhv8/fast_reverse_proxy_who_uses_this/]%0A%0ARemindMe! 2 days) to send a PM to also be reminded and to reduce spam. ^(Parent commenter can ) [^(delete this message to hide from others.)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Delete Comment&amp;message=Delete! dx9wx2m) _____ |[^(FAQs)](http://np.reddit.com/r/RemindMeBot/comments/24duzp/remindmebot_info/)|[^(Custom)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[LINK INSIDE SQUARE BRACKETS else default to FAQs]%0A%0ANOTE: Don't forget to add the time options after the command.%0A%0ARemindMe!)|[^(Your Reminders)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=List Of Reminders&amp;message=MyReminders!)|[^(Feedback)](http://np.reddit.com/message/compose/?to=RemindMeBotWrangler&amp;subject=Feedback)|[^(Code)](https://github.com/SIlver--/remindmebot-reddit)|[^(Browser Extensions)](https://np.reddit.com/r/RemindMeBot/comments/4kldad/remindmebot_extensions/) |-|-|-|-|-|-|
What tutorial is telling you about `GO_WORKSPACE`? I've never heard of that variable before-- your workspace in Go is almost always your package inside of your `GOPATH`, and that's also where binaries will be installed: https://golang.org/doc/code.html#GOPATH
Or something even dumber. I cut it down to just enough code to make a database handle and run a query and now I can't reproduce it, go figure. Thanks for the help though, both of you. 
cool
Not sure how experienced you are with Go but you could write your own, use crypto/tls to secure the connection and io.Copy to copy between connections.
If you understand go and you understand docker, building it with any CI tool isn't exactly a challenge. Use a generic makefile with standard targets and use dep for vendored imports. Here's an example snippet from one of my repos: Makefile: all: clean test build-docker build: deps $(TARGET) $(BUILDDIR)/%: $(CMDDIR)/%.go CGO_ENABLED=0 GOOS=linux $(GOBUILD) $(BUILDFLAGS) -o $@ $&lt; build-docker: build $(DOCKER) $(DOCKERFLAGS) build -t ${IMAGE}:$(TAG) . publish: build-docker $(DOCKERLOGIN) \ &amp;&amp; $(DOCKER) $(DOCKERFLAGS) tag ${IMAGE}:$(TAG) $(REPO):$(TAG) \ &amp;&amp; $(DOCKER) $(DOCKERFLAGS) push $(REPO):$(TAG) test: deps $(GOTEST) clean: $(GOCLEAN) rm -f $(TARGET) deps: $(DEPENSURE)
Docker abstracts away the details of the operating system. Not only which OS and which version of the OS your application is running on, but the configuration of that OS (environment variables, files, etc.). This makes it easy to guarantee that (a) anyone can run the application and (b) that the application runs the same way on anyone's machine. In this case, the application is the set of tests. We're able to reason about how those tests run on the CI server. If developers of the application also use Docker for running tests locally, the behavior should be exactly the same.
I'm not sure what tutorial you're looking at (the 1st two hits on google for "go hello world tutorial" don't mention "pkg"), but in general only packages compile to files in `pkg/`. You're probably compiling a package named 'main', which isn't a real package, and doesn't show up in `pkg/`. 
You seem to be using data -&gt; JSON -&gt; data2 as a way of type cast fields. That works, but it's going to be slow. The only alternative I can think of is to do the casts in Go, like this: [https://play.golang.org/p/XHFTc_Pmbvm](https://play.golang.org/p/XHFTc_Pmbvm) 
You can pretty much just ignore pkg entirely. It's just a cache of compiled objects, completed binaries are put into bin.
I'm not worried about the overhead of disk I/O, I simply want to avoid I/O actions: the slow process of writing (then reading) from disk. So, I am trying to write a "smart" buffer that only writes to disk/reads from disk when it gets to large to comfortable fit in memory.
Fantastic post
Thank you so much for that explanation.
I've been liking https://drone.io
Thanks :)
If you have read the README, it stated &gt; frp is under development and you can _try_ it with latest release version. Also, you can directly ask the author on the Issue page about production use.
https://godoc.org/github.com/tgulacsi/go/temp#NewMemorySlurper is such a Writer. Doc is lacking, but the source is short and simple - good for copying :)
I've been using systemd with success, see: https://superuser.com/a/1105956/195228
I don't "geek out" about a ton, but this hit my need level and music genre at once. My first message will literally be, "Drink More Ovaltine" just so they feel that level of disappointment Ralphie did. Thinking on it quickly: if you were to use symmetric encryption on this, it'd be a pretty good tool for passing info. Like "Drink more Ovaltine".
This code can be optimized a LOT. Writing slow code (copying arrays within a tight loop??) is a bad decision in any language
&gt; I really don't get this, I have zero problems managing dependancies, in fact dependancy management nightmares are what drove me away from node and javascript in general. Uh, so what solution do you use? Dependency management in Go is worse than Javascript. At least you can lock versions+hash sum with npm. Go's way of pulling from the master branch of a github repo is a serious security concern. Manually downloading dependencies and putting them in `/vendor` works but it's not best practice for software engineering to commit third party dependencies. 
a crummy commercial?!
No problem!
Sorry, forgot to mention it! One of the reasons to use that custom UnmarshalJSON it's because I'll need to do it with many other struct. That's why I wanted to avoid the casting and use tags.
This looks more interesting... One of the reasons for the UnmarshalJSON it's because I'll need to do it for several other struct. I'll add it to the post. But this might be a good compromise.
&gt; Why should the language itself provide something like this? I think you answered your own question (emphasis mine): &gt; It is **slow** but safe. &gt; Go claims easy and **fast** concurrency.
Awesome answer.
You must have skimmed the first paragraph. If you read the article you'd see git is needed to fetch dependencies actually. The custom image is required for curl, git, make, dep, golint.
Docker-in-Docker builds and any deployment was purposely left out from this blog post. It's more about getting builds working and pulling in private repos.
Ah I see! I suppose in the case of private repos, another solution would be to commit the `vendor` directory (https://github.com/golang/dep/blob/master/docs/FAQ.md#should-i-commit-my-vendor-directory).
I am using godel instead of make with my gitlab ci stuff and I like it a lot.
A slice is a pointer to an underlying array, and a start and end index. When the slice is passed to the cpg, the slice is copied, so those three values are copied, but the underlying array is not copied. So the cpg code is writing into a shared memory buffer, which is why that then doesn't have to be passed back to the iterating printing code. This is what I mean by doing the minimal work. It doesn't manifest anything other than just the current value, over and over again into the same memory location. If you want to keep it, you'd have to copy it explicitly.
Fascinating! This is perfect for a project I've been mulling over for a while. Thank you for using the MIT License.
Well, make your case to your boss. Either you spend X amount of time developing a custom solution, you spend X amount of $$$ for ngrok or you rely on frp which is an open source solution (which is definitely auditable if that's necessary, but that also takes time/money). If your boss has a lot of ifs and buts, while still needing you to have something soon it's up to him to decide on the way forward. You have basically 3 options with different types of costs/commitment levels. In any case, ngrok is a really really nice product. https://ngrok.com 
I need something self-hosted.
why is this still on major version 0?
Do you need to be able to read and wring from the buffer at the same time?
awless is already production ready, but we still want to add many features until we reach 1.0. Mostly, 0.2 will bring better multi-region support and we're close to that; 0.3 should bring an updated template language (with support for metatemplates, loops, etc.). Once this is reached, we will be able to go towards 1.0 and consider our main work done.
Thanks for this information
Something like this https://play.golang.org/p/pl7-h_VzZIG
Currently, we are working on making the client more compatible with Go conventions. Thanks for your feedback! 
Thanks man, didn't know about their new API! Have been using their old API in the past, that they shut down ages ago. Been wanting a new one!
'pattern "./..." means start in the current directory ("./") and find all packages below that directory ("...")' (from https://golang.org/doc/articles/go_command.html). Usually, it is used to install not only [library] package itself but also related binaries.
Ah ok perfect makes complete sense. Thanks!!!
It looks like you are using [large switch statements](https://github.com/azbshiri/ramda/blob/master/slice.go) instead of proper generic reflection. This means that functions will only work for a hard-coded set of types, which is a problem if you want to use them on custom types. Try something like this instead: func Head(slice interface{}) interface{} { return reflect.ValueOf(slice).Index(0).Interface() } You can use other features of the `reflect` package to provide better error messages (e.g. `slice` is not actually a slice, or is empty/nil).
You're feeding the outputs of your functional code to functions that already accept `interface{}` in the sample code. This obscures the real pain points in using this sort of library, even if the first bit wasn't turning you off already. The problem with functional code in Go isn't that you can't write a map function at all. It's more `reflect`-based code that I can just bash out in a reddit comment, but I've done enough with reflect that I can write the implementation of `func Map(mapper interface{}, input interface{}) output interface{})` fairly easily. The primary problem is all the type casting involved in using it in real code. You can't get around that in a library. The secondary problem is that the resulting code is much slower than normal Go code, since it's basically running a dynamic language operation inside of Go. The approach you take in your NewCond function is creating an [inner platform](https://en.wikipedia.org/wiki/Inner-platform_effect) for Go, and in addition to the fact that such things are always dangerous anyhow, we have the additional fact that Go is a _really_ bad language for any sort of inner platform, at least partially by design. Completely different from something like Haskell which is a beautiful language for inner platforms because you can easily create ones where a lot of the outer platform still works even so. Not Go.
Can't force it to print landscape fixed size pdf with such CSS inlined. ``` @media print { @page { size: A4 landscape; } } ```
Good catch! The current implementation relies on wkhtmltopdf to convert HTML files to PDF. Still, you could update the current command in the configuration file like this: ```yaml port: 3000 logs: level: "INFO" format: "text" commands: markdown: timeout: 30 template: "markdown-pdf {{ .FilePath }} -o {{ .ResultFilePath }}" html: timeout: 30 # Now using the option "--orientation Landscape" template: "xvfb-run -e /dev/stdout wkhtmltopdf --orientation Landscape {{ .FilePath }} {{ .ResultFilePath }}" office: timeout: 30 template: "unoconv --format pdf --output \"{{ .ResultFilePath }}\" \"{{ .FilePath }}\"" merge: timeout: 30 template: "pdftk {{ range $filePath := .FilesPaths }} {{ $filePath }} {{ end }} cat output {{ .ResultFilePath }} ``` Now, having a docker-compose.yml like the following: ```yaml version: '3' services: gotenberg: image: thecodingmachine/gotenberg:1.0.0 ports: - "3000:3000" gotenberg-landscape: image: thecodingmachine/gotenberg:1.0.0 ports: - "3001:3000" volumes: # Overriding default configuration file - path/to/gotenberg.yml:/gotenberg/gotenberg.yml:ro ``` You may run `$ docker-compose up -d` You are now able to generate "portrait" oriented PDFs with the endpoint http://127.0.0.1:3000 or "landscape" oriented PDF with http://127.0.0.1:3001.
Sad to see the amount of interface{} because lack of generics
As others mentioned, `go get` will do what you want. `-t` flag will make it also fetch dependencies used only in tests.
"You don't need that with Go" ™ 
In your docker, wouldn't it be better to add /usr/bin to your PATH instead of symbolic linking the individual files? This app looks neat overall though. Do you have a contribution policy?
No, there's only one catch. Thanks I'll try that code.. 
It's a reflex I took when installing stuff on my own computer, but actually I have no idea if its better or not.. No special policy, PRs on `dev` branch are of course welcome :) 
This is great, thanks 
[removed]
I didn't give the full story. PyPy can be compiled with [Software Transactional Memory support](http://doc.pypy.org/en/latest/stm.html) to replace the GIL. However, it comes with a significant performance penalty, so it may never be the default.
Thank you for your work! Will be an option once I get "there".
wkhtmltopdf....ugh.
&gt; I implemented a 100% compatible, functioning mock of a Redis client If you're a engineer who's worth his weight in salt, you'll have already put a generic interface between Redis and your application. All of a sudden, your mocking work is dead simple: just open() / close() / get() / put() for most cases. What cost/benefit analysis did you do that lead you down the path of writing your own Redis? That sounds like a huge time sink with no real benefit, from my perspective. If you're worried about availability, use Redis Cluster...
Thanks for the link ;) This does what you want in particular: mem := buffer.New(32*1024) // 23 KB in memory files := buffer.NewPartition(buffer.NewFilePool(100*1024*1024, os.TempDir())) // 100 MB files buf := buffer.NewSwap(mem, files) // use memory when buf &lt; 23 KB, otherwise use files
Could you expound on that or direct me to some links to learn more? I want to find a reason to learn some assembly
You mention the version label being cool. I added it to one of our internal apps and its the best diagnostic tool. You can look through metrics and see what version of code is running on different servers. No more guessing when a deploy happened. https://github.com/prometheus/common/blob/master/version/info.go
The reason for that is that you've allocated a len 3 array to store your elements, when you pass that slice to your function and modify the elements, you're only changing what's inside of the array. When you append an element, though, Go needs to create an entirely new array of length of the old array + 1, copy the elements from your slice, and shove the new element in there. Your slice does not point to this new array. 
Yeah.. do you know a better solution?
That is really really cool, thank you for sharing! I’m going to use this everywhere :D
Is this playlist going to be updated?
Very old videos.
Headless Chrome would probably be faster with better results. A bit annoying to work with, though. I had decent success with it and wrote a small queued API to convert HTMLs to PDF in NodeJS (using Puppeteer), but I never gotten around in re-writing it in Go.. Maybe one day. 
I like pandoc. But I'm not sure if it covers the html to pdf usecase.
As requested, I have added a makefile to make building and creating projects easier https://github.com/amlwwalker/got-qt/blob/master/MAKEFILE.md
https://github.com/arachnys/athenapdf
[removed]
Here's the article I used to get it going: http://www.doxsey.net/blog/go-and-assembly The basic idea is you move the function you want to rewrite into its own file, then use the Go compiler to generate an assembly source file (to replace the original Go source), and then you keep the function boilerplate and rewrite the guts. And finally, Go will automatically compile the assembly file along with the rest of the source for the package.
Oh looks like a nice drop-in for whtmltopdf! I’ll give it a try for sure
&gt; *Key Point: we're only passing slice headers around (not expensive) * The end result is sort of true here but doesn't properly explain the underlying mechanics. Slices, just like everything else in go are passed by value. You're receiving a copy of the slice, but a slice doesn't actually contain the underlying array, it contains a pointer to the array. As long as you're performing an action that doesn't cause that pointer to change (needing to allocate a new array from exceeding it's bounds) then you have two slices pointing to the same array. Also adding to the slice *may* not grow the underlying array.
Here's a different playlist, one I've been watching. Seems okay so far, I'm new to programming and Go but using multiple sources. https://www.youtube.com/watch?v=G3PvTWRIhZA&amp;list=PLQVvvaa0QuDeF3hP0wQoSxpkqgRcgxMqX
I don't see how something that uses electron, docker, virtual X, lots of deps is better than C++ static binary that can work "headless". Anyway, both solutions are bad, surely there is a better way to build PDF from HTML in native Go then executing some external binary.
Thanks for sharing!
I think it's ironic that they used the word "Assembly", commonly associated with assembly programming, and chose to combine it with the word "Web". It's a dichotomy equally contradictory to "SoftwareHardware", "SlowFast" or "SlutNun" (not that nuns can't be slutty, but assembly can be slow too).
Heres a more advanced topics playlist https://www.youtube.com/channel/UC_BzFbxG2za3bp5NRRRXJSw/playlists
No clue
The last update was a month ago.
I really don't think you know what WebAssembly is.
whats ironic is people comment shit they have 0 knowledge about? 
As frankly horrifying as I think WebAssembly is, you gotta criticize things from a position of knowing what the hell you're talking about. WebAssembly is basically LLVM for the web: a universal assembly-ish language that runs on a virtual CPU, which can be JITed really fast on most modern computers. The basic premise is "now I can compile from _____ to WebAssembly and my high performance low level C code will work in the browser!" I'm of the opinion that that is a terrible idea, but that's because I actually have some knowledge that informs my opinions. It sounds to me like you're going on name alone, which is not only dangerous, but stupid. Also, you couldn't have picked something better than "SlutNun"?
While in theory this sounds "great" in practice I'm really skeptical about using Go for Front End . I mean seriously Go is design to be short and concise program and today it's mostly use for backend. There are some bigs limits to Go like pulling dependancy straight from github rather than local folder etc... which tends to make believe Go will never be a thing for web apps appart from back end. 
&gt; here are some bigs limits to Go like pulling dependancy straight from github rather than local folder etc... which tends to make believe Go will never be a thing for web apps appart from back end. https://github.com/golang/proposal/blob/master/design/24301-versioned-go.md "The plan, subject to proposal approval, is to release module support in Go 1.11 as an optional feature [...] In a later release (say, Go 1.12), we will declare the module support completed." Go 1.11/1.12 is hardly "never". Also I don't see why versioning would be more important for front end development than back end development.
&gt; There are some bigs limits to Go like pulling dependancy straight from github rather than local folder etc... which tends to make believe Go will never be a thing for web apps appart from back end. What makes front end dependencies different from back end dependencies? Also, versioned Go modules will probably come with Go 1.11 or 1.12 (not "never").
Have you used the templates in the std library?! They work well and can accomplish a fair amount of what a lot of people need. And not sure what you mean by pulling a a dependency from github instead of a local folder?
I think he's confused because of the folder structure of the gopath. Your go program does not pull from GitHub, it pulls from the local folder you downloaded from GitHub when your installed a dependency.
Wasm is not, strictly speaking, a front end. Although it let you interact with the dom inside a html client. It does not let you skip the fact that you still have to integrate a browser for the front end. What it does make possible(ignoring previous Go to js compilers) is to import a Go library from javascript. So you can create client side apps that uses Go code. For apps that the users install on their system, the developers already have the freedom to combine technologies. For application development which the user installs, I would only use wasm if the overhead of using wasm over natively compiled code is less than the overhead of localhost http requests to call a Go server. 
I think you have some misconceptions of package management. It will only pull from a upstream source when you ask it to, otherwise it only use what it already have. That's how all package managers work.
Out of curiosity what do you think is terrible about WASM?
Is there any reason for it not to do this?
Eyeballs.
I expect ads to start disappearing in exchange for permission to use our devices for website owners own distributed computing desires.
I think WebAssembly could challenge JVM. It's not restricted purely to the browser, someone I know is currently working on a WebAssembly runtime with cross platform options. It could very well enable a replacement for Electron apps by writing WASM apps that use Qt or GTK or the Windows UI... etc.
Also go dependencies get built into the binary. The go dependency system is irrelevant after it has been built...
No, it would be quite terrible if it actually had to download on compile. It can just be a little confusing with the way things are named in the gopath to someone new. So someone might think that import "github.com/user/repo" is actually going to http://github.com/user/repo and cloning that repo and packaging it, when it's actually just reaching into a local folder named that.
Makes sense, thanks for the response. Excuse my noobness but does go fetch the actual web resource when the local path fails to deliver? 
nice
Isn't that just a matter of time though? I'm not sure WASM can be blamed for that explicitly. There are already JS miners exploiting browsers.
No the build tools do not fetch if a dependency is unavailable. 
No, it only looks locally and tells you that it can't find the dependency.
I personally can't wait cause of that concurrency. I do however wonder how that debugging is gonna be but apple, Microsoft, Google, and Mozilla are working on it. Also, can't wait what the go team is gonna hash out. I wish it would replace js even though that's not why or how it works. I just want to write more go code and if it has less of these }): } }}); Then so be it!!
You're right. I meant that JSON and friends weren't very often seen in the MCU world. Now IOT changes this.
What's the difference between the vendor folder in go and the node_modules folder in js? Be aware that in modern front-end we transpile all dependencies and shims and whatever you need for older browsers as part of the JS building process. In Go you get a binary with everything, with JS, you get a js file with everything. No difference
Thank you for comment. I'm trying to solve exactly such case when the only inputs you have is a log file with human readable messages, and I have no other options. 
my go projects build without accessing the network, you're wrong.
I didn't mean WASM is to blame. I also don't think it's terrible. It's a web technology that enables something that we haven't necessarily considered to be a web feature (which I think is namely DOM representation / modification). **That** is what some people will think is terrible.
Great work! Wondering if it may be used for a better implementation of [STL](https://github.com/chewxy/stl). The original algorithm for STL was sped up a lot by using KD trees, but I couldn't implement a KD Tree that was efficient enough in Go to be worth it. One note on stuttering: `kdtree.New()` is nicer than `kdtree.NewTree()`
[removed]
You should *really* run go fmt automatically, because nearly everybody else does. This means that when working with others, the code formatting will be exact. Otherwise, you will get weird looking diffs when code changes between contributors. &gt; Also is there any reason why you wouldn't terminate processes outside of non-main packages? I'm not sure how to best describe it, but in my mind I think of it as: any package that isn't a main package, is a library. Libraries should not be doing things like panicking, killing the process, or anything that is going to mess the caller up. A function exported by a library should inform the caller than an error occurred, but *how* that error is handled is up to the caller (exit or try again or whatever). 
Not my project, I've just used it b/c I needed something quick that worked. There are Go library's to generate PDFs, but nothing that I've found that will take HTML as an input and produce PDF output. 
Thank you! :) I hope you can use it :) In case you miss any feature, just open an issue. Thanks for your feedback, you are completely right. I changed the name of the function to `kdtree.New`.
Why not just link to the actual issue which contains the actual information? 
[removed]
I do use Go for *_very similar_* project as you mentioned. I haven't had any issues till date (~8 projects, in a span of 3 years). Also for recommended packages and such you can refer to the official list of [packages](https://golang.org/pkg/), also there's this nice [awesome-go](https://github.com/avelino/awesome-go) community maintained list. Also [Go wiki](https://github.com/golang/go/wiki) for general info. You can also find recommended packages on the respective product websites. e.g. [Redis](https://redis.io/clients#go), [MongoDB](https://docs.mongodb.com/ecosystem/drivers/community-supported-drivers/) etc.
&gt; Interfeces are a crucial part of Go language. Itty bitty typo. :) 
I was using ql the other day and I didn't find a migration tool for it, so I decided to come up with the most minimal way to do migrations, before running a server. func executeMigrations(db *sql.DB) (err error) { println("Executing migrations") // create migration table(ID,version,created) tx, err := db.Begin() if err != nil { return err } if _, err := tx.Exec(`CREATE TABLE IF NOT EXISTS migrations( id string NOT NULL , version int NOT NULL, created time NOT NULL DEFAULT(now()) ); CREATE UNIQUE INDEX IF NOT EXISTS migrations_version ON migrations(version);`); err != nil { tx.Rollback() return err } migrations := []string{`CREATE TABLE users( id string not null , username string not null, email string not null, encryptedpassword string not null, created time not null default now(), updated time not null default now() );`, `CREATE UNIQUE INDEX users_username ON users(username); CREATE UNIQUE INDEX users_email ON users(email);`, } if len(migrations) == 0 { return nil } migration := Migration{} // select latest migration by date, get version number row := tx.QueryRow(`SELECT version FROM migrations ORDER BY migrations.created DESC LIMIT 1;`) if err := row.Scan(&amp;migration.Version); err == sql.ErrNoRows { migration.Version = -1 } else if err != nil { return err } else { println("Version found! #", migration.Version) } // if number &lt; len(migrationTable-1) if migration.Version &gt;= len(migrations)-1 { return nil } // execute remaining migrations in a transaction for i := migration.Version + 1; i &lt; len(migrations)-1; i++ { println("Executing migration #", i) if _, err := tx.Exec(migrations[i]); err != nil { tx.Rollback() return err } } // insert new migration with version == len(migrationTable)-1 if _, err := tx.Exec("INSERT INTO migrations(id,version) values($1,$2);", xid.New().String(), len(migrations)-1); err != nil { tx.Rollback() return err } return tx.Commit() } // Migration is a database migration type Migration struct { Created time.Time Version int ID string } 
Is it exactly under src? dep needs the source code to be at least one dir below that.
Gonna start using this to describe bad implementations.
The problem seem that using `fish` shell and setting a universal `GOPATH` is not picked up by go, it can be double checked if you run `go env`. I dont know exactly now what I did to get that variable working on may main machine, have to look into this, so the work around for the moment is to run this for bash.
When I was doing research on migration tools to solve this problem I came across this list https://awesome-go.com/#database. None of them let you run arbitrary go code. So I wrote another migrator. Go has no such standard that I am aware of.
Nice! 
Also https://medium.com/@dgryski/speeding-up-regexp-matching-with-ragel-4727f1c16027
Might not be related but I've had issues with dep if my GOPATH isn't located inside HOME e.g. GOPATH=$HOME/go
Gopath also hates symlinks, make sure you are in the literal directory
This is nice, though it is too simple, also store the date/time in mysql in datetime data type not in varchar. 
If you want to set it globally, you can also set it in /etc/environment
Thank you 100x!
Wow, what a gorgeously inefficient sync.Map! And starting a goroutine for each value inserted!?! Why not just a sync.Map and one goroutine with fixed eviction time (1m for example)?
There's no reason a universal viable shouldn't work, so I tried it out to make sure. Everything with as expected, you likely did not mark it as an exported universal variable. `set -xU /path/to/gopath`
There's no reason a universal viable shouldn't work, so I tried it out to make sure. Everything works as expected. You likely did not mark it as an exported universal variable. set -xU /path/to/gopath
There's no reason GOPATH has to be in $HOME. If you had difficulties trying to relocate it there was some other problem with what you were doing. Also GOPATH has defaulted to `$HOME/go` since 1.8.
Thanks! 
Thnx for the advice!!
I wrote my first distributed system. I would like to get feedback from community
is that you schoolboy Q?
lol. nope
Add unit tests and benchmarks. These are important parts of golang and will fit well with this project.
Thank you. will add it.
Hey, thanks!
Yeah I heard that half way through writing it. Thank you for the comment. 
https://stackoverflow.com/questions/38646794/implement-a-global-hotkey-in-golang?utm_medium=organic&amp;utm_source=google_rich_qa&amp;utm_campaign=google_rich_qa
Not using gui. I am just learning golang and was thinking of creating a simple daemon which plays an mp3 file whenever it detects a key stroke. I did stumble upon termbox, but it seemed like an overkill. Still, I will give it another go (pardon the pun).
Thank you, just what I was looking for, though I am using linux. I'll try searching wih keywords "global hotkey in golang" for now on.
I need mutability and ideally TTL. I really like a lot of what groupcache does though, especially the hotkey prevention.
Great timing, though Golang currently lacks a lot of the libraries that would be useful in wasm. I'm working on a game right now and one of the performance-critical parts is applying skeletal skinning to meshes and uploading them to the GPU for rendering.. It's much faster in wasm but no one has ported any libraries for it yet. Golang doesn't have such a library, as far as I'm aware. Still, it could be very good, we shall see. I'm curious how they will handle things like GC, goroutines, etc.. 
You can hack TTL support on top of group cache by appending (current time - current time % TTL) to the key. Mutability is a bit trickier though.
Awesome!
It seems like what you are really after is a UI framework that either abstracts over native apis, or at least has the same look and feel. What desktop targets do you need to hit? Just windows, or windows/linux/mac? 
While I haven't used it personally, if native ui controls is a requirement, you may want to check out the following to see if it meets your requirements: https://github.com/andlabs/ui I'm not familiar with gomatcha, but gomobile is targetting EGL and (namely) mobile, and lacking some basic functionality like keyboard input on desktop and wayland support on linux. Likewise with https://github.com/golang/exp/tree/master/shiny which doesn't have a wayland backend yet but does have more complete desktop support. Still, it's not going to provide native gui on diff platforms so check out andlabs/ui to see if it fits your needs. Otherwise I'd consider Qt/QML in a language of choice (python/go as you say). Checkout the following for Go: https://github.com/therecipe/qt
Cross platform apps are, by definition, not native.
I just found out about Iris after reading this, what's so wrong about it?
I recommend against using mongoose with Node. Your code would also be a bit cleaner (subjective I guess) if you had used Koa + async/await.
Things will be quicker go ship with React + Electron &amp; React Native. Go on mobile is possible but the the ecosystem is non-existant. Same goes for desktop apps (although there are some pretty nifty QT bindings).
If you absolutely need same code everywhere, write a performant PWA and may be wrap in Electron. If you are OK with different code on desktop at least, go with Flutter for mobile and QT/Electron on desktop. This is however the _default_ generic advice. Real advice would depend on what exactly you plan to build.
Apparently, the guy used to take a lot of code from other people and just merge it as his own. Kept messing with the github and generated a lot of toxicity. It's a shame because he looks like he was actually putting a lot of his own effort in as well. I was interested because I wanted something fast, but I ended up using FastHttp, with fasthttprouter, which aren't really maintained anymore so there's are risks involved with that. Most people would just recommend using net/http, and they're probably right.
Go? Flutter? Or did I miss something?
Windows/mac for desktop. Android/iOS for mobile. Yes, maybe it's the UI framework I am after. Little confused about the options 
I am cool with React. But a few electron apps that I have come across, I have noticed that their menu bar looks a bit foreign on a mac. Maybe I saw wrong examples? 
&gt; I'm 100% sure that my project is located in GOPATH/src And I'm 99% sure you're wrong. What is the path to your source directory? What does `go env GOPATH` output?
Seems like QT is well recommened, here and in general. I am exploring it further. thanks,
So as some others have hinted at, there is a little bit of a fundamental impossibility of being both truly 'native' and cross platform like that, but there are frameworks that get close. QT probably being your only reasonable choice if using Go, and if you are going to use QT it might be easier to just do the whole app in C++. Sadly the whole industry has kind of ignored desktop apps for 20 years because of the web so there aren't a lot of great options. There is Xamarin in the .NET world. 
What problem are you trying to solve? Why not use strong typing instead of interface{}? Why do you need plugins at all? 
No, not iris again, makes me think this is a secret post by the iris author. Sorry but this deserves a downvote, not even going to read the article because of iris, why on earth did you choose iris, are you not aware of the authors history?
If you don't code to native APIs, you're not writing a native app.
If you decide to use Qt, PySide2 is the officially supported way to write Qt apps in Python: http://blog.qt.io/blog/2018/04/13/qt-for-python-is-coming-to-a-computer-near-you/
You are right, and I also have MS Office on my mac. But I prefer Libre office, only because it is faster than MS office on mac. I feel there are a few things missing in MS OFfice, libre, and MacOS pages/numbers. I want to explore the possibilities in app dev. and see if something can be done about it. And for that reason, I am seeking native aesthetics on the app. 
Yes, I've have observed that. The emphasis seems to be only on mobile. The industry has for the most part left desktop alone, which still makes for a big market. It could be that the mobile-heavy current generation of consumers is driving the market.
It took me a few secs to realize that if it's "cross" platform, it cannot be native in its strictest sense.
Interesting. I'll keep this in mind. Thanks,
Website &gt; Desktop when comparing effort to how much better your app would be, in my humble opinion. Unless you’re building some high performance application.
there is definitely demand for a good solution, hence the popularity of electron. if someone could create an efficient solution it would be popular. 
&gt; What problem are you trying to solve? Organization, I guess. Something that could serve as a base in any project. = &gt; Why not use strong typing instead of interface{}? I was thinking that *most* of these exchanges are going to be map[string]string but the returns are going to vary a lot so I'd want each class to type assert what it's expecting. A sort-of answer to all 3 of those questions is that I'd like to be able to interface multiple applications that may previously have been isolated. = &gt; Why do you need plugins at all? Lazyiness: think about all of the boilerplate I don't have to write over time by having a folder of plugins and each plugin has some kind of pseudo-interface that is enforced with the load. And there's no linkage or other alteration, a plugin simply needs to send some args and the name of another plugin to the main class and it'll just work. Over time, some plugins might be entire applications. I like the option of being able to integrate that application into the server base just by building it as a plugin and adding those *interface* methods. = I just left a job with 30k+ line files of source code and literally over 100 lines of *import* lines. I'd like to avoid that. I know direct invocation is going to be way faster / better than the function overhead and map[string]function calls, but idk. It'd be nice if this wasn't a horrible idea. 
As someone who also came from C++, I agree, `go get` is one of my favorite features of Go too. If you have your Go package hosted on a code host like GitHub or another one, you should be able to use `go get` on it. The following document describes the process of writing some Go code to make Go packages, and then making it available for `go get`: https://golang.org/doc/code.html It describes the process from start to finish. There’s also a screencast version mentioned in the introduction. If you want more of a reference on how `go get` resolved import paths, see https://golang.org/cmd/go/#hdr-Remote_import_paths. I hope you enjoy!
This is really neat to see, thanks for sharing! It’s an unusual but interesting feeling seeing familiar Go code idioms, Gophers, etc., in between a language I don’t understand. From a brief look, it looks like some companies are making a really big use of Go (with success).
[removed]
I'll add the license. Thanks for reminding the important thing. :)
working on another Qt golang binding, https://github.com/kitech/qt.go you can try it. Qt has most support platforms IMO. 
The author of Iris has a well renowned negative reputation among Go developers because of continuous license violation. See this thread: https://github.com/julienschmidt/httprouter/issues/148. Many Go developers suggest to use middlewares. Gorilla is one of them. 
I don't, I have imports, and I go get. If I want to pin a dependancy (a super rare thing, I'd rather have the latest version and deal with bugs as they crop up then have windows xp - something that never gets updated) I fork it.
Check out Xamarin. Not Golang, but should get you close to where you want to be. Slack uses it for their mobile app.
To develop an app that truly looks and feels native to desktop (Win/Linux/Mac) and mobile (Android/Iphone) you need to write 5 native applications :( As you saw there are a lot of cross platform toolkits but by definition they have to be non-native in order to hit the 3 desktops simultaneously adding mobile to the mix adds another layer of complexity. I guess you could have something that adds a layer of abstraction over native components but to do that given how divergent the platforms are the features you will be able to build with the common capabilities will feel limited. That being said Python and Electron allow rapid development but you end up with pretty big slow apps. I think you're in a "I want to eat my cake and have it too" situation either go for hitting all of the platforms but not being native or focus on one platform and be native. 
I'm not speaking about large lines. Regular expressions has exponential complexity, so execution time will grow exponentially from line length. In my case complexity is approximately O(n*k), so I'm sure, difference factor will only increase with input length.
I guess you didn't see the bold text, in two places, that states half way through writing the article I became aware of the controversy and would recommend people do their research and not use Iris? 
I find these series to be a good starting point for people just getting their feet wet with Go. The author's approach of explaining and summarizing each episode is really nice. I hope that someday he could continue on with the series or start a new one with the same quality.
1. What global variables are we talking about? 2. what is the Mutex error? 3.This is the first version, this week I will add the opportunity to close 4. here you are right 5. The use of RWMutex will give a slight increase in the speed of obtaining data from the map, but this approach does not guarantee a 100% safe map. thanks for your reply, It will help make the library better
I believe that Chi is still maintained, and is very fast: https://github.com/go-chi/chi
Thanks!
u/ChristianLisov, would you please care to comment on this? I mean, exercising your coding skills is definitely a good thing but it's interesting what value your project may bring to those who is supposed to just use it (as a black box).
&gt; I just left a job with 30k+ line files of source code and literally over 100 lines of import lines. May I ask whether you're discussing a piece of Go code?
FYI gists won't work with a privacy enabled browser (e.g do not track turned on)
great question, that's why I wrote this post in /r/golang. mcache is currently in the testing phase, I do not force anyone to use this library in production But I want to write really reliable and fast cache on golang. This is why your constructive criticism is so important to me
Ok, here goes try 11 at responding (which really is a time sink). I really could fill a volume with this stuff, so I have to be concise as to what you're asking me. - our mock redis instance implements 38 functions, out of which some are constructors/options, but I guess about 32 are unique, - we implement incr/decr, keys, list, set, sorted set and ttl (so there's really still a great deal of redis we don't implement, like channels, various intersection functions, etc.), - https://github.com/titpetric/sortedset saved us some dev time, as it's the only non-trivial component for the redis mock, - the sorted set implementation was required by a specific microservice which we are doing, as we want to migrate *away* from redis due to performance requirements, and the nature of the service itself (push data into service, never expire data, staleness isn't an issue) - we're pushing redis keyspace to it's limits, so sharding data is our only option, while we don't have the same limitations in Go, (redis has a bucket allocator, so you have a specific bucket that holds keys), - actually way cheaper for us is to shard a few API instances with higher mem, than scale redis which is all-mem and almost zero CPU cycles. Basically the tiers are merging due to this cohabitation. In short: we had everything already built and it wasn't a huge effort or time sink for us. The functional tests have been already made for the actual Redis client, and all we needed to is provide one more instance to test against and validate. It allows us to migrate certain older microservices away from redis, as their requirements outgrow it. We did consider redis-cluster at some point, but decided to go with nutcracker (aka twemproxy). I don't remember the particular reasons, and they might not even be applicable anymore, but I seem to remember that it was one of those sorted set commands which gave us a little bit of trouble on redis-cluster, because you'd reference keys that aren't on the same instance. (aka [SORT](https://redis.io/commands/sort)). We really don't use this anymore, we use `zrange` over a sorted set, and possibly if we did still use it, maybe redis-cluster already handles this, as I don't see a footnote about any impaired use. Anyhow, it works for us, and it was basically free (not even counting positive impact later on). Anything which you can hack together in about a day is basically free. Go has a tremendous capacity to recreate some software in ridiculous timeframes. On friday, I hacked together a ssh client, with reverse tunnel functionality (a-la `ngrok`), and it took me mere two hours, and works on windows. It probably took more time to come up with a bash script that does the same with `ssh -t -t -g -R remote:port:local:port host [remote cmd]`, and the thing is usable on windows too. Two. hours. But I still wouldn't do anything remotely the same for a MySQL database, for example, that's an integration test 100%.
Well, so the question u/tgulacsi presented basically boils down to "we have `sync.Map`; have you profiled it?". So have you? ;-)
&gt; Regular expressions has exponential complexity [Not in Go](https://swtch.com/~rsc/regexp/regexp1.html).
for how much I know sync.Map solves a very specific problem - Cache contention (https://github.com/golang/go/issues/17973). I'm more inclined to use the lock-free algorithm. the first thing you need to do it to satisfy some comments /u/kapoof_euw . After I immeaiately take up the question - what better to use sync.Map or look-free
Does a makefile help? https://github.com/amlwwalker/got-qt/blob/master/MAKEFILE.md
I don't think you need such a verbose and complex architecture. Why can't handlers communicate with the database directly? I don't mean executing raw SQL from the handlers, I mean calling functions that abstract that database directly. For example, if you define UserStore: type UserStore interface { User(id int) (*User, error) UserWithPassword(username, password string) (*User, error) Save(user *User) error } From the handler, you just call: type AuthHandler struct { UserStore app.UserStore } func (h *AuthHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) { username := r.FormValue("username") password := r.FormValue("password") user, err := UserStore.UserWithPassword(username, password) if err == app.ErrNotFound { http.Error(w, "username doesn't exist or password is wrong", 400) return } if err != nil { http.Error(w, "internal", 500) return } } I recommend you to read Ben Johnson's medium posts about application layout. Start with https://medium.com/@benbjohnson/standard-package-layout-7cdbc8391fc1
rqlite is a full RDBMS application, but dqlite is a library you must link with other code. It's like the difference between MySQL and libsqlite3.so.
Ok, bookmarked PySide and Qt/QML. Thanks for the suggestion 
Learnt about something new. Adding it to the list. Thanks
Good article. Keeps it real. thanks
Can I run this tool on a local machine?
I was thinking of doing something like that as an alternative. The db plugin does have something like that. The difference is I send some text to the main server through a function that accesses a map of all registered plugins. Maybe I could instead grab plugins from the function directly. I'll have to setup both and see which is going to be easier to maintain in the future. I went as far as I could with abstraction but the setup is really similar and probably more performant if plugins access each other directly. = &gt; I recommend you to read Ben Johnson's medium posts about application layout. I have every intention of properly laying out the individual applications. Right now I am focused on architecting a server that allows applications to easily communicate as plugins that could be dropped into any similarly setup server. My inexperience with SO files, Go, and building servers is making it hard to describe the architecture and intentions properly. But really I am looking for an answer to any performance issues this may have before it is unleashed onto the open internet. The applications themselves accessed in this manner will follow best practices, plus a few standard functions for being able to communicate with the server. 
No, but fortunately others have: https://medium.com/@deckarep/the-new-kid-in-town-gos-sync-map-de24a6bf7c2c TL;DR; sync.Map is faster than a map guarded by sync.RWMutex iff GOMAXPROCS &gt; 4.
It sounds like you're almost making an application gateway with plugins - you'd probably be better off just using an application gateway than building one yourself, which could also allow you to take advantage of other things (like load balancing, circuit breaking, metrics...). If you do that, you can get some of the things that you want to do with handlers using service discovery, and you're not building something that will only work for a single node. However, as a note of caution - there are costs for going down the path of separating things so much. It can be cheaper and faster to start with a monolith that's designed to be split up when the right domain boundaries are found. Take a look at things like: API Gateways: * https://www.envoyproxy.io/ * http://www.krakend.io/ * https://traefik.io/ * https://github.com/hellofresh/janus Microservice meshes: * https://linkerd.io/
Not completely true, u can set it json style, or set them in order
Fwiw, I think there's wiggle room on being both Native and cross platform. Eg, something that effectively produced native code would still run completely native on the users system. Eg, a translation layer from Go -&gt; Swift would produce native iOS apps. The same could be done for any OS. With that said, it's definitely more rare.. I'm not aware of any, offhand. React Native is close, but the logic still runs in JS.
Sublime Text uses the same approach. It can work quite well, with sufficient optimization.
thanks, I think that your statements are true
Such wow, thank you for the link. 
This is how I've been doing it in my project; I'd be curious to find out if this is an accepted standard practice in Go or if there is a better approach.
fwiw, running the editor a few minutes, the mac os battery indicator does not flag it as an app using significant energy.
Does anyone know what he means by "scanner pattern"?
That's a good point. I think avoiding the syscall to switch into the kernel helps, as does the ability to see when a thread is waiting on an empty channel (which the OS scheduler would be unable to see) A few differences: - The kernel schedule needs to sometimes load in the entire memory state (if changing processes and not just threads) - The kernel scheduler needs to load in a much larger stack (since the kernel doesn't support dynamic stacks) - Since the Go scheduler has full control over the code that's running, it can make optimizations that the kernel can't (eg. only loading in the new stack but leaving a lot of state from another goroutine. Something like this would be invalid for the kernel to do, but since Go doesn't allow memory access to arbitrary locations, it's safe [I don't know if this is done, just a possibility])
Isn't that first Elixir example for reading a config file pretty much functionally the same (as two different languages can be) as the Golang example? It doesn't throw an exception, it handles a failure from `File.read` gracefully, and it returns a tuple of either `{:ok, deserialized_json}` or `{:error, reason}` that you can pattern match against to explicitly handle the error.
Do you debug in vim as well? If so, what are you using for that?
Strictly speaking your safemap is _not_ lock-free - the channel it uses does the locking. It's not a bad implementation, but the one-goroutine-per-item is gross. Also, I don't see why msgpack is needed at all (unneeded dependency).
I don't know that I can take on all of this at once, but: &gt; This application would probably end up on AWS at some point, but until then won't the under the hood goroutines be capable enough while the service has little to no traffic? Go itself is very performant and can handle a lot of traffic, but you talked about architecture, and from that point of view I would say that it would be best to force developers to consider scalability up front if you're ever expecting to need it. I wouldn't want to shoehorn those patterns in afterwards, or realize that you have somehow been benefiting from a global mutex etc. that is eventually not sustainable. &gt; ... plugins ... I'm not entirely sure that I totally follow, but it's fairly standard practice for various http frameworks and libraries to support chained middleware, so that's a fairly standard pattern that you can look at (eg. https://gobuffalo.io/en/docs/middleware) - it's also fine to chain or "decorate" http handler functions, for example. It's fairly standard these days to use JWT for auth (as long as you have HTTPS), in which case you can assume that a user has gone to auth somewhere, and the rest of your handlers just validate a JWT's claims against your requirements. As alternatives to your plugin ideas (maybe?), you can also internally just call out to an auth service, or send messages to an ESB / Message Queue and expect responses that tell you if the credentials were valid. I think that the example of your "auth plugin" requesting a way to get db credentials from a "db plugin" sounds overly complex - normally you would have an interface for a credential store, and at your application layer on startup, when you create your auth handler you would pass it an interface. That would be dependency injection, rather than factory pattern. 
How does this compare to `go list -f '{{join .Deps "\n"}}'`?
&gt; you can also internally just call out to an auth service, or send messages to an ESB / Message Queue That's also sort of what I'm trying to make, but without any other services needing network traffic to communicate. That's probably why I went with interface{} / map[string]string for the arguments because I figured it would be similar to a message queue without the network call so it would be less of an impact on performance. = &gt; I think that the example of your "auth plugin" requesting a way to get db credentials from a "db plugin" sounds overly complex The idea is that these things could exist as combinations of parts of an application. So 2 apps that need authentication don't need to both import authentication and database files, or 1 class that includes both, instead those applications communicate with a service that handles it. And it's done as plugins so that service isn't some additional binary living on the server and communicating with network calls. = I'm sorry that this is confusing :P I rarely have to think of architecture myself, my own projects usually get convoluted or pointlessly chase an idea to see if it's possible. Some tests show this idea works and adding new parts to the server is very easy. I made those authentication and database plugins. And then I made a thing that needed to use them. My only concern now is fundamental flaws with the architecture, like some inner working of SO files that will cause me an issue later... like 2 calls happening at once that cause 2 different instances of different plugins to access the same feature of db or auth and cause some kind of issue. That's what I really want to know. If the only real concern here is that I'm violating some common practices or I'll be having a bad time in 2 years, that's fine. The purpose of this project is to explore this sort of architecture. Just like the purpose of my last project (which was despised by the Go community) was concurrency for the sake of it. 
Acutally, when you import 'R Go-Mini-Social-Network/routes', Golang will look in $GOPATH/src/Go-Mini-Social-Network/routes and treat it as a package. So that works.
I don't tend to run debuggers very often so I have not look at integrating them into vim. Typically I find and investigate most bugs by writing and running unit tests in a terminal alongside vim using something like [watchexec](https://github.com/mattgreen/watchexec) to auto-execute commands when I save a file.
Yes, but don't do that, make your code go gettable. https://golang.org/doc/code.html
Such wow, thank you for the link.
Generally said the go runtime has more specific knowledge about how things are managed than the kernel and can thus do less/more efficient work while switching goroutines
Yes that is the intention currently as in: when you run this tool locally, it will spin up a cloud instance and run the benchmark then shut down the cloud instance. If you want to run a local benchmark then it’s just a matter of using the ‘go test’ package locally.
Ok, I'll put my architecture concerns aside. Unfortunately I don't have enough experience with Go's plugins to know of any problems, but keep in mind that you'll be on the same runtime/process - so if any of those plugins panics, it could take everything down.
Won't that only kill the goroutine that answered the http.handleFunc? I read that plugins are thread safe so I would assume a panic in 1 goroutine wouldn't cause issues for another goroutine. = I have been following best practices for (extremely verbose) error handling so I don't think I'll panic much :) If I were to panic it would be from laziness - I'd panic so I could catch the message in a deferred recover in the main thread and pass along the message to the user with a 400 or 500 status. 
Thanks for the quick response!
Some people refer to what you're talking about as broad integration tests or system tests. These are completely normal. They'll help you catch the exact issue you're worried about: "changes to the API you're not aware of". With that said, you'll want to use [build tags](https://stackoverflow.com/questions/25965584/separating-unit-tests-and-integration-tests-in-go) to separate your deterministic tests from your nondeterministic ones.
&gt; The performance improvement does not materialize from the air, it comes with code complexity increase. *wince* This is probably true in a lot of algorithm textbooks, but not nearly as true in the real world, imo. I've found complex code to often be slower than refactored, simpler code. I've seen a lot of engineers over-engineer micro-optimizations into their code without taking a step back to look at the bigger picture and ask what really needs to happen.
I make dummy API accounts, get the secrets from environment variables, and put the API calls right into my tests. I assume I will have an internet connection - I need this for so much else in my workflow that this is a safe assumption. Then I can make API calls on this dummy account without screwing up my real dev/staging/prod API creds. Just `export` your necessary env vars before tests. Like this: https://github.com/etherparty/coinpayments/blob/develop/client_test.go Then a test using that client: https://github.com/etherparty/coinpayments/blob/develop/tx_test.go 
The shell does significant work behind the scenes when you pipe things. To do that in Go, you have to replicate that. I don't think this is very easily done, especially concerning all the error handling: You have to make sure, that when any part of the pipeline dies, the rest of the pipeline is correctly aborted and all the pipes are closed correctly. The easiest way, TBH, is probably to execute a shell and pass it the pipeline you want to execute on stdin?
I believe if you look under the hood at the http.Server it catches and recovers from panics in handlers. However, if you spin off a goroutine it could bubble up to the top of that stack, at which point I believe the app will die. It's just something to be aware with in terms of that, and any process specific limits you might hit (file handles?).
There's a package for doing this: http://labix.org/pipe You can do the same thing with the `os/exec` package too, but I don't have an example.
I never exported it, that was the issue !
Thanks, I'll keep that in mind. Hopefully there aren't many built in utilities that will panic without providing potential errors as a return. I've only had my go programs crash when I explicitly called panic on errors, and I probably could do something with them if I was doing more than following tutorials to pick up the fundamentals :P
the kernels should not care if they are running in a notebook or the lab... it's just an ipython kernel
are you talking about using go's Cmd with pipes? https://golang.org/pkg/os/exec/#example_Cmd_StdinPipe
Thanks for the article! The Go community tends to get rather divided about this topic for some reason. I think there's a few other things that should be mentioned about mocking in general that gets overlooked by the community: 1.) People see examples of where you can use a real thing (like when dealing with an HTTP server, where you can spin up an actual test server) and take this to mean that you should never use a test double. On the other hand, there are clearly some things that you shouldn't mock, like a database connection, at least without good reason to do so when the integration test is really what you're after to be confident that the layer works correctly on its own. 2.) We should be precise about what kinds of tests we're trying to write and at what level things should be tested. If you're writing unit tests, by definition, the tests should be isolated in such a way that if its dependencies are broken, the tests still pass. The only way to unit test something with external dependencies is to use a test double, hand-written or otherwise. It should be emphasized that unit tests aren't sufficient to be completely confident that your code does what you think it does, which is why other forms of testing (such as integration tests) are necessary. 
^The linked tweet was tweeted by [@canadianbryan](https://twitter.com/canadianbryan) on Apr 16, 2018 21:04:32 UTC (0 Retweets | 0 Favorites) ------------------------------------------------- [@jedisct1](https://twitter.com/jedisct1) [@dgryski ](https://twitter.com/dgryski ) This from MAP\_STACK: [https://undeadly.org/cgi?action=article;sid=20180413065457](https://undeadly.org/cgi?action=article;sid=20180413065457) Go was recently fixed in -current, but as you said requires recompiling all go packages due to the use of static linking: [https://github.com/openbsd/ports/commit/b81b4b03980b0d088d5625797ac11479a68d4ffb](https://github.com/openbsd/ports/commit/b81b4b03980b0d088d5625797ac11479a68d4ffb) ------------------------------------------------- ^^• Beep boop I'm a bot • Find out more about me at /r/tweettranscriberbot/ •
What are your exact requirements? "secure and various niceties" is a little too vague to give any real direction except for obvious things like, "use HTTPS" and the like.
Thanks - I'm new to go, and was looking for something like `guard` for watching for file change notifications and running tests accordingl Can you target watchexec to only watch and run tests for files that change?
Absolutely. This is something I keep repeating in my perfbook. There's a large distance between theoretical computer science analysis and real world algorithm engineering. Performance work needs both, but frequently the shift to performance lies on simpler well understood algorithms, not fancy exotic ones with huge constants hidden in the big-O.
For example, query parameter "url" given from request URI?
That is a *lot* of words that don't really say much.
In the handler you could use the gorilla web toolkit : github.com/gorilla Then you could define your route as "/{cameraId}", then inside the handler it is as simple as follows : func restConnectToCamera(w http.ResponseWriter, r *http.Request) { vars := mux.Vars(r) cameraId := vars["cameraId"] } I think this is what you are trying to do ? Cheers and hope this helps 
Yup something like that. Hey are you the guy behind [https://github.com/mattn/go\-mjpeg](https://github.com/mattn/go-mjpeg) and the sql library? Love you stuff! I found the go\-mjpeg very useful and even contributed a little. Cheers!
On a unrelated note is there any example of doing this but with httprouter instead?
Also: https://onedrive.live.com/view.aspx?resid=CFFDB1C3A2F95F6!177069&amp;ithint=file%2cpptx&amp;app=PowerPoint&amp;authkey=!AIp8ZV5bbcm634I
 // define your route router.GET("/myfeeds/:camId", streamStuff) ... // handler func streamStuff(w http.ResponseWriter, r *http.Request, params httprouter.Params) { id := params.ByName("camId") ... }
I miss Joel writing his essays. Nothing has really replaced his writing.
Nice writeup. I wrote a [line counter qloc](https://github.com/loov/qloc) at some point as well. Works faster, however it has fewer features.
run `go build` or `go install` and copy the resulting binary to the other machine.
Yes, that's what `go build` does. It creates an executable binary from Go source code. For example, if you have a file `main.go`, and you run `go build main.go`, you will get an executable `main` that you can copy to another machine and run it there without a Go installation. If the other machine has a different OS or architecture, you'll need to set the environment variables `GOOS` or `GOARCH`. For instance, I use OSX for writing Go, but I want to create an executable that runs on Linux, so I use `GOOS=linux go build main.go`.
I agree, this does not seem possible.
Thanks. This actually helps me a lot. I'm just learning as I go along so making the distinction between deterministic and nondeterministic tests is new to me, but makes a lot of sense. 
First off, good job for isolating it as a dependency, that's a good start. What I would do is an integration test with a fake server. This will ensure that your test is fast and not reliaint on an internet connection. For a start you can use `net/http/httptest` `Server` to do this. This will let you for example set up a fake server that returns a stub bit of JSON and you can check your code calls the API with the correct params and that you can handle the responses appropiately. The next problem then can be, as you say, what if the API changes? Your tests will be green but your software wont work. I would suggest you read about *consumer driven contracts*. Basically they are a way of asserting "this is what i expect from an API" and you run that assertion against both your fake and the real server. That way if there is a divergence in the way the two behave, you will know about it. Obviously there is extra effort for this, so it depends how much confidence you need. I myself have written a tool to do this. https://github.com/quii/mockingjay-server I like to think it's pretty good! But there are other tools out there, the most famous one being Pact https://docs.pact.io/ In the wiki for mockingjay, there is a more detailed explanation. https://github.com/quii/mockingjay-server/wiki/Rationale
I like the approach with the dummy accounts specifically for the tests. Makes sure you don't do anything stupid and get an account blocked that you rely on :). 
Very nice job man! I hope this project will have quite a follow up, you deserve it :D
The standard library?
- your feedback is correct, thank - heartBeatGC removes expired keys and then clears slice-kset.Keys [:0] kset.Mutex.Lock () is needed to ensure that at the time of the expiration of the expired keys, no new keys were added to the slice, and then deleted without cleaning my English is not so much a chorus, but I hope you understand me ;)
Great tool! It might be overkill for the few endpoints I am using but seems like a great time saver for more serious work :). Plus the "flaky" options seems great for testing unexpected responses.
I'd note that article is linked to [right in the docs on the `regexp` package](https://golang.org/pkg/regexp/) ;-) You might also be interested in the whole hierarchy at https://swtch.com/~rsc/regexp/
More spam from this company 
Yes, I guess that instead of using linux commands I would have to replicate the exact thing in go. That would be in future todo. Meanwhile I want something simple as: myVar string := grep -w “200” test.txt | awk ‘{print $1}’ Would that be easily done? 
I've had some issues when upgrading to lab and running other kernels like ijavascript. I'd love to know if someone has tried it.
If you're using nothing but the standard library then the `go build` should do what you need. However if you're using a framework, it depends on the framework. If you use some lighter one, like https://echo.labstack.com/ then sure, you can create static binaries. If OTOH you're using something like Revel, then you're out of luck: https://github.com/revel/revel/issues/589 Seems like Beego is in the same boat: https://github.com/beego/bee/issues/310
https://github.com/inconshreveable/go-update
[removed]
wcharczuk/go-chart and gonum/plot work well with this. I added an example notebook. https://nbviewer.jupyter.org/github/yunabe/lgo/blob/master/examples/plot_libraries.ipynb Also, I tested lgo works with JupyterLab well. You can try lgo with JupyterLab from this URL: https://mybinder.org/v2/gh/yunabe/lgo-binder/master?urlpath=lab%2Ftree%2Fbasics.ipynb
The kernel works with JupyterLab. You can try it on your browser from https://mybinder.org/v2/gh/yunabe/lgo-binder/master?urlpath=lab%2Ftree%2Fbasics.ipynb On your computer, please run `jupyter lab` instead of `jupyter notebook`. It works out of the box. Let me know if you find a problem with JupyterLab.
This looks cool! What’s the chance of getting windows support in the future?
You can’t do it that way, but if they were a slice, you could reference them in the way you’d like to. 
I am not a gRPC expert, but it seems like for your use case an rpc framework would be over kill. RPC shines when you want to make a Service Oriented Aritecture (SOA). SOAs are great when you have a lot of traffic, and want to make a distributive system. It allows you can scale you services independent of each other. But a SOA, increases operational and development pain because you have more moving parts. Right now you have you have a fairly simple application (from an aritecture standpoint), and I think there is value in keeping it simple. All this being said, if your goal is to learn more about go development, I don't think it would be a terrible idea to try and learn to use gRPC. As for your questions, I do believe you have to use HTTP/2. The protobuf will add some development time, but I'd think that you'd want to be defining your JSON API in a similar manner already. You will not see a large performance increase on localhost. 
I've been looking at it myself. gRPC will require some additional setup to be able to access it from a browser. I haven't done it myself, but the docs say you'll have to set up a special proxy in front of your gRPC service. It has something to do with browsers not implementing the full HTTP2 spec yet (I think trailers are the issue? Pushing what I recall at this point)
and the link to the blog/article describing `duit`: - https://www.ueber.net/who/mjl/blog/p/duit-developer-ui-toolkit/ 
pretty good chances. duit relies on plan9port's devdraw for cross-platformness. neither of which have windows support. but plan9port share common history/purpose with a program called drawterm and an operating system called inferno-os, which do have windows support. so it's not an insurmountable amount of work. still work though...
If the part of the data source that is set in stone is just the JSON data, you could possibly unmarshal it differently to make it easier on yourself (example_top, for example, could be unmarshaled to a map[string]string rather than a struct, and then you could access the map by constructed field name. But if the full source is set it stone including the go struct format, and you really want to iterate this way, you might have to resort to the reflect package. 
To your title: gRPC and JSON are not mutually exclusive. The gRPC protocol allows you to use JSON for serialization, if you prefer, but protobufs are probably the easiest path forward, as being the more popular choice, there is more support. I think the main advantage, for all practical purposes, that gRPC provides is that it is RPC. You are effectively making remote operations appear as if they happen locally. This is quite a different model to what REST stands for. Given your use case, I would almost suggest that RPC is exactly what you are looking for. &gt; gRPC is faster, but on a localhost-only connection with minimal latency, this might not matter much. I don't see any real reason you couldn't build a REST service to be just as fast. The gRPC project has billed itself as using HTTP/2 to reduce latency, but you are right that you probably won't notice the effects of that in your circumstance. &gt; gRPC requires HTTP/2 (?). Not only HTTP/2, but features that are part of the HTTP/2 specification that ended up not being implemented in any major browser. However, there is [gRPC-Web](https://github.com/improbable-eng/grpc-web) to bridge the gap, including HTTP/1.1 support. &gt; Generating protocol buffers requires an extra step in the development cycle. I don't know if it is really an extra step in the end. It is a different step, but you get code generation for free. Code that you would have to write for yourself otherwise. But do note, since you are using Elm – of which I am not aware of any generator for – you're going to really miss out on where the whole thing really shines. 
These don't appear to be backed by the underlying OS widgets/windows meaning it will seem like a never-ending task just emulating all of the hotkeys, selection behavior, etc that OS's provide for their native controls. I hope for the best for the project, but beware the non-native complaints that will come in when someone's obscurely configured hotkeys or mouse gestures on their OS don't work.
The only way to do this is via [reflection](https://play.golang.org/p/OBupWWxGHVG). But if you have to resort to reflection for a type you actually know, you are likely using Go as if it was a dynamically typed language, which you shouldn't.
It seems limiting to require users install/setup their own font to program with duit. Ideally if `$font` was not set you could default to something reasonable. What reasons led to not including an open, built-in font? (If the problem was figuring out how to do it, I've done it before and can PR that change if need be)
&gt; This leads us to the second duit concept: mouse warping. Not very common in ui libraries. No. My mouse, my rules.
Service-Now is providing the data from a poorly constructed database where instead of using linked table the data is literally in multiple fields like example1disk, example1size, example1path, example2disk, example2size, example2path all the way to a rather high number, so unmarshaling differently is problematic. Hence the reason I wanted to refer to it via a variable I could iterate through. I'm guessing that I'll have to restructure the result after my inital unmarshal efforts by iterating through it, better to do it there than iterate through it later multiple times. I'll look at reflection.
This is a great suggestion to a problem that should not exist. Reluctantly, i'll be using this to solve my problem. Thank you.
[`select`](https://golang.org/ref/spec#Select_statements) and [`time.After`](https://golang.org/pkg/time/#After) could do it
Looks like you're spot on, thanks!
Another alternative is to write type RealStruct struct { // a sensibly laid-out struct here } func (bs *BadStruct) GiveMeSomethingUsable() *RealStruct { // Construct and return the RealStruct here } It's tedious, but only once. After that you get a good struct. I don't have anything quite that egregious in my code, but I have some similar constructs in various places where I just straight-up need a conversion.
If you have access to the db, you could instead use that to get a result and use the result map with strong keys. Don’t use reflection unless you have to, it’s slow and not nice to work with. 
If the field is named with a number, just construct the field name. Maybe a snippet of actual JSON would help you explain the task more clearly.
I highly doubt gRPC is much faster than HTTP/JSON over localhost. Sure, you are marshalling json with HTTP/JSON but for a single client/server that's nothing. I would go with HTTP/JSON as web client (javascript) gRPC support just isn't 100% there yet. There's still advantages to gRPC, namely client code generation. But given the fact that this all runs on localhost via a broswer I'm not sure that would help you much. Again, js support for gRPC isn't _quite_ there yet so I'd urge against it for that reason alone.
A big plus for me is that Go packages are pretty easy to read and understand. I can come back to some code I created years ago and understand how it works in no time at all. 
The success of Electron and other app toolkits that are just standalone web views should be evidence enough that the vast majority of users don't actually care about native look and feel.
Simplicity
Concurrency!
it would be great indeed to have "batteries included" fonts :) such as: - https://godoc.org/golang.org/x/image/font/gofont/goregular - https://godoc.org/golang.org/x/image/font/opentype 
Performance and simplicity. I am indifferent about the syntax.
I love the idea of mouse warping. I hate trying to get my wrist or finger into the right spot.
Back in the day I was programming CLI tools for Linux, MacOS, Windows and Solaris with Java. Java isn't a natural fit for CLI and I was about to re-learn Python for that. Go is way simpler to cross compile and deploy than Java, Python or virtually any languages there are. GOOS/GOARCH was the feature that made me curious. Then the performance (no VM bootup), first class concurrency, strong static typing, tabs over spaces (that alone let me know the language creators have their heart at the right place!) and the sum of many tiny features. 
It's a no-bullshit language with excellent documentation, good tooling, and a feature set with all the features you actually need and little more.
I have put a copy of a lib whose author chose to discontinue it on our internal GitLab and pointed dep to that "mirror". I don't like it, but it works.
Hey - he switched from Atom to VS Code - is there any word on why that switch was made? 
It doesn't let you outsmart yourself. I can't count how many bugs I've seen in JS or Python related to overriding the assignment operator, or doing dumb things with prototypes, or 50-line lodash chains relying on edge cases of obscure functions. Yes, it might take ten times as much code. Turns out, the amount of code you write doesn't really correlate with how maintainable the system is; its all about how clean, organized, and understandable the code you write is. Option 1: Catch this shit in a PR. Works 80% of the time. Option 2: Don't even allow it in the language. Works 100% of the time. 
Does anybody know if the devdraw protocol is documented anywhere? I imagine implementing it on Windows using e.g. [golang.org/x/exp/shiny](https://godoc.org/golang.org/x/exp/shiny) should be doable, but I can't seem to find any reasonable docs to estimate the needed work
It has replaced any thoughts that I would write something in Python or Java again with its clean syntax, standardised tooled formatting and especially static compilation across a number of platforms.
Yep. Including compiling into a single self contained binary. Really nice for tooling across platforms
Agreed. This is my number 1 and a whole bunch of secondary reasons touched on here. I really like how it doesn't get in the way of itself and can be really deployed across many platforms with ease
Yeah this seems like a bad idea for mouse users. It will result in having to physically reposition the mouse too much. I can see the merit for users of other pointing devices though (trackpads, trackpoints, trackballs, etc).
I love the type system.
The tour. I can’t tell you how refreshing it was to read a tutorial that didn’t start with “this is called a _variable_!” “Here’s something called a ‘for loop’”. Instead it was “here’s how for loops work in go”. It’s a good balance between accessible and useful. 
I started with go, and while I do have a hello world behind me in rust, the setup of programs, while I understand the goals they're aiming for, has soured me.. And I already have a functioning go app with significant progress into other go projects... That said I should go back and look at rust again.
Very easy to learn (fairly small language), and easy to collaborate with others (again because easy for others to learn, and opinionated formatting, etc).
Typed, performant, straightforward, built with multithreading in mind from the start, without 30 years worth of weird corner cases or you get in C++. 
For some reason in Go, I can write an entire package with postgres integration without running or testing and it works first time. Coming from a .NET and Erlang background, I always had to take time cobbling together code with test suites, and don't get me started on JS/TypeScript.
This is the right answer.
I generate static files with Go templates and use Github Pages to serve them. Why would Github care (/be able to know) how the file content was generated?
&gt; gRPC will require some additional setup to be able to access it from a browser. It really doesn’t, though. I used [grpc-gateway](https://github.com/grpc-ecosystem/grpc-gateway) and it honestly took no extra effort, and it works well for translating JSON/REST to gRPC. 
Yeah Rust is a much more ambitious language. It's trying to pay zero performance penalty vs something like C++, have no garbage collector, and yet still be memory safe. That's kind of crazy, &amp; unprecedented. So there's a new programming model &amp; complexity to pay for to get that. (It also seems like, from a distance, Rust doesn't seem to have the same culture of "ruthless simplicity" that is part of what makes Go so pleasant to work with.) But still: people are implementing things in Rust that are are setting the state of the art for speed+quality: ripgrep, fd, and (maybe someday; still too early to have reached its goals:) alacritty. Probably other stuff too. It's a very exciting language. Maybe someday we'll have a new language that implements the best of Go and Rust?
http://www.catb.org/esr/faqs/smart-questions.html
You might want to take a look at [https://github.com/djherbis/stream](https://github.com/djherbis/stream)
Yas! Exactly what I needed.
Let's not forget what Rust was originally conceived for: the Mozilla folks wanted a better C++. And it's started to come to fruition for them, too; [the latest Firefox releases are starting to integrate Rust code into the browser](https://www.howtogeek.com/332449/whats-new-in-firefox-quantum/).
The standard library
I'll have to look into this. I'm only up to having {{template header}} in index.html and {{define header}} as header.html. I thought go was required to link them?
This is a fairly common thing in certain niches. For example, many Japanese Visual Novel games will do that exact thing. It's a little jarring at first, but it's super easy to get used to and can speed up menu navigation a lot, especially with popup dialog boxes where 90% of the time you hit the 'yes'/'agree'/'ok' buttons. The only thing I would like to see done different is have the *move* the mouse with a (very quick) animation curve so it doesn't just appear somewhere.
A very agile and clean infrastructure ( I mean the entire toolchain and stdlib). The required dependencies to get it ready is very thin, which is a rare quality in 'modern' development platforms.
[https://i.imgur.com/C5UCNqB.gif](https://i.imgur.com/C5UCNqB.gif)
Surprising to see Japanese VN mentioned in /r/golang. It made me double check what subreddit I'm in, haha. Anyway, I agree with you. I experienced mouse warping in VN as well. It's a little jarring at first, but once I get used to it, it makes menu navigation faster.
Devils advocate: 10x the amount of code is 10x the surface area for bugs.
Because gopher is cute.
Single binary and simplicity
There's no magic. I can read anyone's code and understand it in pretty much one pass. That's a beautiful thing when you've been working in Python, Ruby, and JavaScript your whole life.
Consider [Twirp](https://github.com/twitchtv/twirp), which is a response to the complexity of gRPC. It does not require http/2, and it supports JSON serialization of messages in addition to binary-encoded protobuf. It's simple enough that you can form requests on the command line with `cURL`. For example: curl \ -header 'Content-Type:application/json' \ -data '{"user": "spencer", "email": "spencer@twitch.tv"}' \ http://localhost:9090/twirp/twitch.example.EmailBoss/UpdateEmail Sounds like it might be a good fit for you here.
Kind of... ironic when you figure where Windows got its name from.
I must be missing something, or mis-explaining? Or just dumb.. lol So here's my index.html: ---- &lt;!DOCTYPE HTML&gt; &lt;html&gt; {{template "header"}} &lt;body&gt; &lt;div id="main"&gt; &lt;div id="header"&gt; {{template "logo"}} {{template "navbar"}} &lt;/div&gt; &lt;div id="content_header"&gt;&lt;/div&gt; &lt;div id="site_content"&gt; &lt;div id="banner"&gt;&lt;/div&gt; &lt;div id="sidebar_container"&gt; {{template "sbfavs"}} {{template "sblinks"}} {{template "sbsmed"}} &lt;/div&gt; &lt;div id="content"&gt; {{template "dindex"}} &lt;/div&gt; &lt;/div&gt; {{template "footer"}} &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; ---- So, it's a *.html, but it won't display properly because main.go is needed to execute the template placeholders. I kind of thought you were saying I could convert my template format into standard html, but no?
[removed]
&gt; Barebones Win32 is so, so, so poorly documented. Curious, this contradicts my experience completely. Granted it's about 15-20 years since I last looked at it, so my opinion may be very dated. I consider MSDN documentation to be best in class, especially considering the sheer size of everything.
15-20 years ago is the problem. The documentation has either rotted or is buried so far beneath C# docs that any attempt to search for it comes back fruitless.
I've frequently joked about making a browser extension that could hide MSDN results from Google search results because I dislike it so strongly. I think the last two years have shown positive change in reversing that, I also don't know about win32 specifically as I am not a C++ dev, and I have only half your tenure as a developer.
I really like the GOPATH. I can't tell how much time I lost setting up dependencies in other languages. In Go, I can just run a "go get" and I'm good to go.
And it cross-compiles.
Out of curiosity, what do you love about the type system?
yeah, it's been a huge gap for go for a ridiculously long time. but the vgo stuff looks really promising!
A few things: 1. Excellent build speed 1. AST support in the standard library 1. Composition instead of inheritance 1. Most things require minimal key strokes - public vs private is a change of case 1. Unicode support built in 1. Time support built in, especially time zones and calculations 1. An excellent standard library 1. Statically linked binaries 1. Cross compile support built in 1. Performance guarantees for garbage collection 1. A concurrency implementation you can actually reason about 1. Switch case not limited to constants 1. No fall through 1. No warnings, just errors 1. Error handling that makes you think about handling errors properly 1. Microsoft not being involved in its development (tongue in cheek, but I still don't trust them not to mess up a good thing) 1. The empty interface 1. Typedefs that make more sense than in C 1. io.Reader, io.Writer and io.Closer 1. csv, xml and JSON support 1. The ability to call C libraries 1. C like syntax
Honestly, because the language is so boring, I don't have the temptation to fiddle with code, getting every little microsecond. I can spend days tweaking my Rust (and C++) code to be "elegant" and "fast". And for what? If my code will go a bit slower, who cares? There are way bigger bottlenecks than stack vs heap.
The simple syntax of Python with greater speed and easy concurrency. 
This is what I like about it. It feels like a "Programmer's programming language" It has a purpose and it does it. It doesn't try really hard to be popular or cater to newbies like other languages I can name. Also the whole godoc thing is great. (usually) Detailed explanations of functions just laid out for you, and the standard lib does a lot of stuff.
Coming from nodejs, the first thing that was appealing to me was goroutines because it was the new stuff for the "cool kids". Performances were great and dealing with concurrency is easier than other languages. I wasn't fan of the syntax at first, but then I realized it made my code less "smart" and easier to understand which is a huge plus when you work in a big team of developers. Native formatting support, good IDE integration, quality packages over quantity.
Cobra (https://github.com/spf13/cobra) is a great choice. Even big projects (kubernetes &amp; more) use it. It propose a cli app generator built in that help you bootstrap a cli project in Go.
I'm still more of a beginner but I like how far down I can go. In Java for example I always feel like I'm hitting barriers and stuff is hidden from me. Also, so far it's been easy to work with dependencies, something I currently struggle with in Ruby, for some reason... especially when trying to debug my mess.
I came for channels and goroutines and stayed for the simplicity and productivity! Also gofmt. Hallelujah
Just don't follow the examples that encourage the rampant use of globals...
Isnt it always a way how you sell it? If you worked 10 years in using a complex language that sports the same major points and features I automatically assume that you know what concurrency, parallelism and stuff like that is. I range adapation of a new language somewhere between 6-24 months at maximum. The first months are pretty worthless, but anything after that could pass a code review and can easily mind-shared/improved with others.
From my perspective, the Senior title is given to the role of the engineer, based on their total work experience and responsibility level (independently of the programming language they use). In other words, they might be completely new to Go and still have a Senior title. However some companies that care about mastery of Go, might not want to hire someone who is at a Senior level but a newbie specifically for Go (if that's what they care about). For levels of experience specifically related to a technology, I doubt someone would use the Junior/Mid/Senior classification. Instead the inexperienced/beginner/intermediate/advanced/etc classification would be more appropriate.
Language is a tool, like frameworks, libs and so on. Principles are the same **for decades.** As for me, I do not recognize myself as *Java Developer,* I prefer to recognize myself as *Software Development Engineer.* That is all. Everyday I work with Java, but from time to time I need to develop in Python, NodeJS, Bash, etc. So you need to understand principles and approaches, not have experience with a tool. CS is for **SCIENCE**, stop treating it like an experience in individual branch or PL or whatever.
nowadays you have people calling themselves senior developers with 3 years+ experience
I think that Cobra is great but it is a little bit complex for beginners. 
It reads almost like Python, but has the speed of C/C++. Compiles to binary, toolchain is pretty nice(apart from dependency management). Trade-offs are generally good. 
At the time (2009), the simplicity of the language, No hidden magic. Plus the fact that the binaries didn't need an external runtime like .NET/Mono does. It was a time where I got really fed up with the little annoyances of C#. And Go fixed all of those very nicely. Of course Go has its own little annoyances which, over the years, started to annoy me. But it's still my goto language for most work.
Wow. cool. I wonder if there is anything similar to Python Plumbum that allows to call commands and remote commands (and makes it easier to make wrappers).
I programmed primarily in PHP for 9 years before moving to go. So that might answer your question just by itself. So perhaps because it’s my introduction to static typing or the way it handles type declaration, for instance ‘type blah struct{}; type collection []blah’ makes sense to me and I find myself making far less mistakes. 
Node.js
[kingpin](https://github.com/alecthomas/kingpin) is the most capable library, imo. Cobra does weird stuff (e.g. camelCase flags like `--logFile` instead of `--log-file`). Theoretically, its integration with viper should be a killer feature, but that's been [(somewhat) broken for 18 months](https://github.com/spf13/viper/issues/276). [docopt](https://github.com/docopt/docopt.go) is good for simpler programs.
Blog, chat... REST service
I have used [cli](https://github.com/urfave/cli) with great success, its pretty simple to use and with great features.
It seems that your comment contains 1 or more links that are hard to tap for mobile users. I will extend those so they're easier for our sausage fingers to click! [Here is link number 1](https://github.com/urfave/cli) - Previous text "cli" ---- ^Please ^PM ^/u/eganwall ^with ^issues ^or ^feedback! ^| ^[Delete](https://reddit.com/message/compose/?to=FatFingerHelperBot&amp;subject=delete&amp;message=delete%20dxk5ki4) 
I have recently put up [a list of what I'm expecting a senior-level gopher to know](https://stackoverflow.com/a/49772651/720999) when they are being interviewed at my $dayjob. &gt; If you've been working with C for 8+ year's and recently started working with Go for about 2 years, would that count? In my book, definitely yes. Just observe that Go is typically used to implement high-load networked servers, and so you might be expected to possess reasonable knowledge of how HTTP stack works end-to-end (including kernel syscalls, in-kernel buffering, TCP/IP, HTTP connection reusing etc) and how to assess performance of a process running on a typical Linux-powered system (like what are RSS vs VSZ in the `top` output`, how and why they change etc; what the TCP ephemeral ports are etc etc etc). Hope this helps.
The problem is that I'm not always wanting to click inside the app. When I'm multi tasking I'm not necessarily wanting my mouse hijacked. Just change the focus, and make it visible so I can just press enter. I have a keyboard. 
Depending on the situation, when the compiler or runtime sees `len([]rune(s))` maybe it can do what `utf8.RuneCountInString` does to optimize it?
But why, when you could just use right function to begin with?
Easy to deploy. Clear error-signaling. Go fmt.
Because, I think it looks more concise and easy to use and it doesn't create a function call (_although the function probably would be inlined_).
You should check out https://learnxinyminutes.com/, it has that same way of explaining, but for almost all programming languages in existence. 
My team uses urfave as well. It's been very effective for us.
If it's a simple CLI tool just use `os.Args`, do not be fancy at the beginning. Don't even start with `flags` package. If it's more complex than check out [here](https://github.com/avelino/awesome-go#command-line).
I also like how easy it is to define command line arts that can also be ENV cars. That was weird to do in cobra/ufave. Oh and Count of args... like with “-vvv” I can set the log level +3 times for super duper verbose, or just “-v” for regular verbose. 
 &gt; 6! 6! = 720 
Compilers optimize away a lot of things that you wouldn't expect them to. Inlining functions for one example, or even skipping simple evaluations like `3+5+13` directly into `21`. The compiled output tells a story which isn't exactly the same as the AST tokens which your source code parses to.
So you expect the compiler to import the package for you because you didn't bother? This is one of those cases that just doesn't make sense to optimize. The optimization would be a very narrow peephole optimization that would only make sense if you convert a string to a rune array *only* to take the length of it, which is frankly just not a smart thing to do (worst case, you're making the string consume 4 times more space in order to count it). The compilers tries to make *good* code *better*, not *bad* code *good*. If you tell the compiler to do something stupid, it will do something stupid. The compiler is not magic, and every optimization incurs a cost to develop and maintain. The compiler developers should put their effort into actually useful optimizations.
Think of it more like a syntactic-sugar not an optimization. This is not uncommon.
With all due respect, I find your reasoning to be flawed—purely from a programmer's view standpoint. The statement `len([]rune(s))` is read by a programmer like this: * Convert string `s` to a slice of `rune`s—one rune for each Unicode code point in the string. At this point, the programmer has fully assessed what the possible runtime costs are. * Take the length of that slice. * (Throw the slice away). This line of reasoning clearly raises a red flag for a conscious programmer. On the other hand, `utf8.RuneCountInString`—as its several cousins in the `utf8` package—is specifically designed to not require *fully decoding* the string to know its length in Unicode code points—it merely decodes one rune at a time as it goes. The runtime cost, again, can be clearly assessed. Note that programming is not about writing *concise* code, it's about writing sensible code.
Yes, this was what I was trying to mean, fully agreed.
Having worked for years with Delphi/Pascal. There is some similarity in how the language "feels". I cannot explain it better. Also, Go fits with the projects I am working on.
If you read the rest of the comments i have already stated that.
This is exactly why I use it. I can from python and C/C++. Loved python and go was the natural extension of python in to a compiled language. So for me, go is as close to python as I could get in a compiled language. 
Great post. I had no idea it was this easy to setup. For what kind of projects would you recommend using AWS Lambda to say dedicated cloud servers. Last time I looked pricing tends to be quite a bit higher. 
Thanks for the thorough answer. There is a protobuf generator for Elm: https://github.com/tiziano88/elm-protobuf, but I have not tried it and don't know how good it is. After I wrote my question, it occurred to me that I heard that gRPC requires TLS. Is that true? That would probably be a "deal-breaker" on a localhost-only application as it would be a real pain to add a self-signed certificate to the mix.
&gt; go build -o go-serverless-api &amp;&amp; go run ./go-serverless-api I'm unsure how this could work 
I agree, but it seems dependency management is still a moving target. I really try not to work on two packages at once, and try to rely on tests to ensure the contract between the app and the library is correct, but I still have to do this occasionally.
Really? "Syntactic Sugar: In computer science, syntactic sugar is syntax within a programming language that is designed to make things easier to read or to express. It makes the language "sweeter" for human use: things can be expressed more clearly, more concisely, or in an alternative style that some may prefer." Ref: https://en.wikipedia.org/wiki/Syntactic_sugar Btw, yes, the compiler could make it as faster as it can like `utf8.RuneCountInString`. It doesn't have to be a syntactic sugar etc. What I mean is to making it simpler without having call to a stdlib function, only using language constructs.
This builds the binary in the calling folder and then runs it as a separate command. Not terribly different from `go run main.go` except you get the binary as an artifact in your folder. 
Can you go into more detail on number 19? I'm pretty new to Go and I'd like to learn more about why this is a good feature.
I actually like the flag package (weird, I know). I usually try to write a very short main function that just calls something to turn flags into local variables, and then calls that thing and if it returns an error exits with a non-zero error code. Here is a decent example: https://github.com/baltimore-sun-data/boreas/blob/master/main.go
I do wish that there was a little more there for dealing with required arguments, but I've used it in a number of projects without fuss.
Yes, read its source if you're interested, it explains why is that so much better. I also had checked the compiler and runtime code of []rune(s). I was expecting this result.
I usually do, but I forgot on this commit. I need to set a pre-commit hook to do it, so thanks for the reminder. Thanks for input on printResults, I'll make some changes!
ah yeah I shoulda used C++ for that example. but I get what you mean
Adding syntactic sugar implies *adding syntax* with *new meaning*. This is not syntactic sugar, as it is *existing syntax* with an *existing meaning* that gives *the exact end-goal that you intended*. What you want is for the optimizer to recognize a *pattern* that does something in a *very bad way*, and replace it with a better algorithm tailored to this *exact* use-case. What you are asking for is called a [*peephole optimization*](https://en.wikipedia.org/wiki/Peephole_optimization) (note that the wikipedia article uses assembly examples—the Go compiler would do this pass the SSA). That is, an optimization pass that would first detect this *exact* pattern in the SSA: t0 = your_string t1 = stringToRuneSlice(t0) t2 = lengthOfSlice(t1) // t1 not referenced any further Then it would throw it all over the shoulder, and instead do the *equivalent* of the following (the optimizer should not import modules, as doing so has side-effects. Thus, the functionality must be duplicated as a compiler built-in): t0 = your_string t1 = countRunesInString(t0) This is equivalent to a compiler detecting that you implemented a bubblesort, and then internally replacing it with a quicksort. Writing good code is your job, not the compiler. It would take an infinite amount of work to cover all these arbitrary cases of stupid code. However, that is not to say that this reddit post is not useful. Some may not *realize* that this is a terrible construct, so it can be a nice heads-up. However, it is exactly equivalent to telling people that bubblesort is probably a bad idea.
&gt; The statement len([]rune(s)) is read by a programmer like this: And what does the programmer read this as: mymap := make(map[string]int) data := []byte{'a', 'b', 'c', 'd'} if mymap[string(data)] &gt;= 4 { ... } 
- The Gopher - gofmt (without knobs!) - short compile times - no compiler warnings - goroutines and channels (communicating sequential processes) - readability - stability - backwards-compatibility - easy cross-compilation - readable and short language specification - net/http - low-latency GC (without knobs), sub-millisecond pauses - its creators 
&gt; This is equivalent to a compiler detecting that you implemented a bubblesort Comparing this with bubble-sort is exaggeration. It can just optimize `len([]rune(s))`. &gt; the optimizer should not import modules, as doing so has side-effects. Thus, the functionality must be duplicated as a compiler built-in Go compiler can just add a call instruction node for the stdlib function by instead of `len([]rune(s))` pattern, so, when the code is executed, it can call it instead. This won't lead to duplication. It does this in several places already as I remember.
*1-3x faster* doesn't mean anything. I mean, it could mean multiple things. Use *speedup*, which has a very specific meaning.
[removed]
- Statically linked, distributable binaries with no dependencies. - go fmt Everything else was just icing on the cake. 
I agree about the optimization being specific, but it's perfectly reasonable for the compiler to see that the allocation is never used and to eschew it as part of some more general "optimize away unused allocs" rule.
[removed]
That would be one way. The other way would be to write an elm generator for Twirp - which wouldn't be as hard as it sounds, if you can just focus on generating clients. Twirp is simple enough that most programmers can write a generator in a few hours. https://github.com/gaffneyc/protoc-gen-twirp_ruby, for example, appeared within a day of Twirp being open-sourced. I'd be happy to help through the process, if you like.
could try in comparison: func RuneCountInString(s string) int { n := 0 for range s { n++ } return n } doesnt import utf8 either and does not need to allocate a slice. Was/is considered as implementation of RuneCountInString in https://go-review.googlesource.com/c/go/+/33637
&gt; https://go-review.googlesource.com/c/go/+/33637 Thanks for that redirection. I was looking for an issue talking about this.
The standard library. It's so good and full of greatness. I wrote an IRC library and never thought I would need an external library for this or so. Using go was just a breeze 
No, it doesn't escape to heap. They're all in stack. And, as @martisch has added, there's a work going on for changing the implementation of `utf8.RuneCountInString` to the direct language construct using `range []rune{}` rather than using a special algorithm inside of it. BenchmarkCastToRuneArray16ascii ([]rune)(str) does not escape BenchmarkCastToRuneArray16multi b does not escape BenchmarkCastToRuneArray16multi ([]rune)(str) does not escape BenchmarkCastToRuneArray32ascii b does not escape BenchmarkCastToRuneArray32ascii ([]rune)(str) does not escape BenchmarkCastToRuneArray32multi b does not escape BenchmarkCastToRuneArray32multi ([]rune)(str) does not escape
I simply user flagsets for the different subcommands. So far I haven't had a case that wasn't easily solvable
Back in 2015 I was tasked with running some intensive tasks on ~400m files of our core business system. At the time a constraint, I could only work with a 2CPU 1gb RAM VM. I wrote a Python program that took over 4 days and multithreading was literally a nightmare. While I was not really on a deadline, I hated this experience and started googling 'parallelism in c++', 'java multithreading' and I don't how I landed on a video on Go concurrency. The claims being made seemed simply unbelievable and just had to try it. After less than 3 hours of copy-pasting godoc examples and I had rewritten (horribly) the program in Go, so I gave it a go. The program took less than 4 hours; so fast that I wrote a python script to cross-check the output. After a few months of learning as much as I could on Go, almost all new projects I've written are in Go. I actually rewrote one of our key public facing systems in it. I just love the language. It may not be the perfect language, nor the most modern, but for me, it simply gets things done fast and clean. I have the original source of that first Go program (as bad as it was), and I often look through it while shaking my head. It reminds me of what made me like Go. Sorry for the long story; but it was really not one specific thing about the language but my first experience using it. Now though, there's a long list of likes I have for it: simple, easy concurrency, the std lib, single binary etc, plus the fact that you can just write an entire program without having to look at the docs is underrated.
Note that the work referenced is about range s (the string itself) not range []rune{}. No rune slice is constructed when ranging over a string.
If it's not being hit constantly and requests don't take 5 minutes to return, then Lamdba is likely going to be significantly cheaper. 
Sorry, right, I mistyped it, updating.
Unless you work with other people and you want reproducible anything. Then GOPATH is the worst possible design.
If you'd like to avoid third-party dependencies, this is a simple way to add subcommands (it looks more complicated than it is): https://play.golang.org/p/R2nLi2GX1bw And running a subcommand: https://play.golang.org/p/Tp3F9ZWADD7
&gt; go build -o go-serverless-api &amp;&amp; go run ./go-serverless-api You're right, it should have been: $ go build -o go-serverless-api &amp;&amp; ./go-serverless-api I've updated the article. Thanks for pointing it out.
In C, if you have: typedef a int; typedef b int; int foo(p int); b vb; a va; vb = foo(va); //works in C However, this is often a cause of bugs because a and b might represent completely different concepts. Here's the equivalent in Go: type a int type b int func foo(int) int{} var va a var vb b vb = foo(va) //compile error because they are different types However, if the type cast actually makes sense in this context, you can allow it with: vb = b(foo(int(va))) The difference between those two lines is you stated your intention. In the first line, your intention was probably just to transform an integral value, but not to convert types in the process and the compiler stopped it from happening. In the second line, you wanted to perform a conversion and math transform of sorts between the two types. When you think about it most bugs are the result of stuff happening that the developer did not anticipate. In Go, explicit conversion between types forces you to think about whether it is what you really want and stops the bug.
I see. Thanks for the answer! I was just wondering.
The consensus seems to be that serverless is cheaper for lower traffic and more expensive for high traffic loads. But the flip side of that cost with serverless is getting scaling for free. You could even make an argument serverless actually saves you money on high traffic loads as you don't have to keep any redundant servers running to cope with spikes in traffic. It would be interesting to know if any companies are using a hybrid approach to switch to serverless at times of high or low demand or using DNS failover to serverless whilst their ASGs spin up more instances to deal with spikes in traffic. I haven't heard of any deployments like this yet but as you can see we are moving to a world where this is possible.
Just glancing at the code, I don't think that it's unicode safe - it takes the offset from the byte length, but then uses the string length as the length and later interprets that as the byte length.
I like the fact that the language comes with its own test tools and a lot of facilities for testing http servers. Which makes testing easy for the most part. While go is far from perfect as a language (no official dependency management yet, verbose error system, no solution to the generic problem, horrible struct tags feature that should be a compile time concern, lack of compile time safe synchronized maps and arrays, no official debugger and no, delve is not a good debugger....) a language project shouldn't stop to its syntax, in fact I prefer the right features and more tools. 
Right, but I can't run the program on github, so the template structure won't work out of the box (for a github pages, static site). I suppose I might be able to run it then save the webpages it displays? Idk. 
&gt; Devil's opposing counsel: The bug surface area is equal; a function that's called 10 times still causes 10 production bugs if it's incorrect. Yes but it doesn't change the fact that more code == more potential bug, especially in a (compiled) language that abuses runtime behavior and reflection for the sake of "simplicity of the compiler". 
go reflection certainly qualifies as "bullshit" to me. AST macros like in Rust is a superior solution.
I was not aware of that - wow, thanks! I'm almost amazed that I never ran into that by accident doing an indexed range on a string manually.
&gt; So you expect the compiler to import the package for you because you didn't bother The `[]rune` cast already needs to count all of the runes in the string to allocate or append them to the array, and thus is "importing the package for you". The optimization would just cut out the temporary array allocation and copy.
In the post you're replying to, I wrote &gt; while possibly allocating the backing array of the new slice in heap The language specification does not mandate nor guarantee the optimization for any particular Go compiler.
&gt; Btw, note that, nothing escapes to heap. That's not correct. It works for the particular compiler used. No generalization follows from that, specs do not even mention things like heap/escape/stack etc. &gt; A lot of people are using len([]rune(s)) in their repo on Github. Probably, the tip of the iceberg. That's comparable to the famous "100 billions of flies cannot be wrong". I for one, consider that a poor coding practice and I'd not approve it in a code review. Search the standard library and try if you can find the same approach. I guess and hope the search will show zero cases. That said, of course it's a possible hard-coded, one-of-a-kind optimization, otherwise we need to put AI in the compiler. The next question is how often this optimization will get used. IMO, zero times in good code and possibly very often in real code. Considering the pragmatism of the Go team, it may actually happen that such optimization materializes. No harm can be done by filling a proposal at the issue tracker. 
I came to the language because I like statically-typed, compiled languages, I like simple, clean code, and I like native binaries. Go ticks all the boxes. After a few years with Go though I think the big thing is speed, in all respects: Go is fast to write, fast to read, fast to test, fast to build, fast to deploy, fast to execute. Everything about it lends itself to rapid iteration and high-performance operation.
&gt; Always try to keep it simple. Well, `foo(expr)` is _simpler_ than `baz(T(expr))`.
Well then the clear simpler thing would be to use the function *specifically named to perform this task*, rather than the inefficient expression that happens to do it.
[removed]
Yeah, it's simpler than: import foo; foo.bar(expr). For example: Let's also remove index expressions etc as well and use them through `import array; array.getByIndex(arr, 10)` instead of: `arr[10]`. Simpler, yeah?
It's not simpler.
Interesting.. 
Can you tell me for which compiler does it escape to heap? Btw, I'm not recommending this approach (`len([]rune(s))`), I just think that it's simpler. It looks like I'm defending it but actually I'm not.
The spec doesn't say about it'd would escape to heap either. You said that it may escape to heap and I showed that it's not for the current and most used compiler.
I can see why you might think defining structs is just boilerplate, but I think it's _much_ less painful than jumping into code that you've never seen before and having to walk through the code to see what global variables its using. Defining dependencies and configuration in a struct just makes it really easy to glance at something and understand what the code uses. It also makes testing painful when you use global variables because you could have two tests mutating or relying on it at the same time, and in general global state can be very hard to reason about. Do you have a specific example of where you think a global variable makes more sense?
I'm writing a parser right now, so for instance, look at how many times i'm typing t. and p. (tokens and parser) func (p *parser) block() (node *a.Node) { p.expect(t.LBRACE) node = a.NewNode(a.BLOCK, "") if p.currentToken.Typ == t.NEWLINE { p.newline() } for p.tokenIs(t.IDENTIFIER, t.VARIABLE) { if p.currentToken.Typ == t.VARIABLE { node.Add(p.variableDeclaration()...) } if p.tokenIs(t.IDENTIFIER) { node.Add(p.statement()) } if p.currentToken.Typ == t.NEWLINE { p.newline() } } if p.currentToken.Typ == t.NEWLINE { p.newline() } p.expect(t.RBRACE) return node }
What if a user manages to delete the JWT token from local storage? What if someone manages to compromise a user's computer and spoof the JWT tolen? Still a very interesting concept, jusy not too sure about the security behind it.
You could always just have pure functions do the "work" of the program, and have structs that manage state and call the functions with the appropriate arguments
I mean, that's a great way to do this, but unfortunately i have a few edge cases poking holes in my ability to go that route. So i was thinking maybe a couple global variables could at least clean it up quite a bit
JWT accesstokens should be short lived just like with oauth2. When there is no access token in local storage shouldn’t the user be logged out(just as with cookies)? When a users computer is compromised should that really be your problem? I don’t believe that spoofing JWT tokens is an easy task (maybe you could provided some resources that show these problems are real and easy to recreate?)
I like this rule, tyvm
&gt; JWT accesstokens should be short lived just like with oauth2. When there is no access token in local storage shouldn’t the user be logged out(just as with cookies)? &gt; &gt; The problem is that with the token exclusively on client AFAIK the server cannot invalidate the token (unless keys are changed). Blacklisting tokens completely negates the fundamental concept of JWT. That's why personally I don't use JWT.
Don't get me wrong, I think Cobra is awesome. But for exactly 100% of my projects I'm not building something with the CLI complexity of docker or kubernetes. That's why I like kingpin. kingping seems both more "go-like" and "POSIX-like" to me. Also does good on windows cause I unfortunately support windows as a target.
&gt; But for exactly 100% of my projects I'm not building something with the CLI complexity of docker or kubernetes I honestly don't think complexity is an argument against kingpin/for cobra. The problem with cobra (along with the standard flags lib) is that they *aren't* POSIX-like. You shouldn't be able to run `prog --help` and tell immediately that `prog` is written in Go because of the non-standard option names. And as noted earlier, the integration with viper—which should be cobra's killer feature—is broken and has been for over a year.
One-time password is the way do go. Forgetting passwords is such a pain and I don't have the nerve to use password managers. You can also deliver a verification code via sms. It's good to match against the requester's device ID and maybe IP too, and store a bcrypted hash of the verification code concatenated those and a secret string. Oh and also delete the code record after one use (regardless of whether it fails or succeeds).
Francesc just did a great episode of Just For Func that teaches Cobra and how to build CLI utilities using it! https://www.youtube.com/watch?v=WvWPGVKLvR4 For OP's question of the design patterns - I really like the syntax of `kubectl`, the kubernetes command line utility. https://kubernetes.io/docs/reference/kubectl/overview/
&gt; Search the standard library and try if you can find the same approach. Don't go too far. Check out: "How to write Go code example": https://golang.org/doc/code.html#Library // Reverse returns its argument string reversed rune-wise left to right. func Reverse(s string) string { r := []rune(s) for i, j := 0, len(r)-1; i &lt; len(r)/2; i, j = i+1, j-1 { r[i], r[j] = r[j], r[i] } return string(r) }
That's what I ended up doing, more or less. I was just thinking (hoping) there was a cmd to output completed simple html or a way to leave the whole template structure alone, it really is nice for tweaking little bits across all pages. Anyway, thanks! Sorry about being a little confusing. 
Not just a Golang thing...
I personally prefer go over many other languages for production, but I don’t think go is a good language for teaching because of its relatively limited resources (compared with Java, for example). IMO java is a great language for teaching purposes because it allows beginners to practice a lot of basic concepts in CS: beginner programming, typical data structures and algorithms, basic design patterns, OO principles, and so on, in a very structured style. Plus Java has a long history, meaning that there are more Java-related documentations on the internet than Go. Go also has a few of CS concepts that requires a mid-level CS student to understand: pointer, function pointer, slice, for example. The lack of explicit inheritance and polymorphism also makes it difficult to teach OO in CS 101 or 102 classes. I would recommend The Go Programming Language as a start. It’s not a textbook per se, but it’s a great manual for Go.
Mozilla is working on [WebAuthn](https://www.w3.org/TR/webauthn/). /r/authn
I actually use docopt (well my own fixed fork) for some stuff. But I really need ENV integration for a lot of new projects I deploy, and additionally docopt got a little wonky with argument validation. I love the idea /concept though (like swagger for CLI almost). 
Thanks for the recommendation! I am a senior level college student, and I am basically just looking into adding Go as a language that I know and can use once I graduate, not so much as for teaching anyone else. 
Thank you. TIL. Though I would have let this behavior slide by and not write about it, had I been not through that painful debug. I hope you got to the end of the post.. If you know Go, how does *octal string* translate to *float64* error?
Thank you. TIL. As I mention in my other comment in this thread, this post was a result of misleading error message, and a bit time wasting debug. 
I'm using Go at work for a web project, and I really do miss true OO. But it's an awesome language to pickup due to its performance and eco system. It is fun to write in, I'll say that much. 
Part of your issue could be mitigated with better naming. For example parser is qualified in receiver, so instead of currentToken at the very least curTok would be okay. But what else does your parser have besides a cur token? A look ahead or look behind? Peek() is usually a good name for a look ahead. So if all we have on p is a current token, we don’t need to clarify this in its identifier and suddenly tok emerges as a decent yet clear name. Now I only see you reference Typ directly on p, otherwise you make a function call of p.tokenIs(t). Ignoring that predicates are usually named isThing rather than thingIs - We can ask the same question if it’s not a token what else may it be? Maybe isTok would be fair and isTyp could replace field access for curTok. I’m not saying your names are wrong since I can’t see all your code and it’s a subjective thing anyways. Just keep in mind you can always shorten names while coding and go back later and make them more clear if it’s needed. Whatever you do always avoid global state that isn’t truly global, and it almost never is. That’s just asking for unintended race conditions for consumers of your library. It would be unfortunate if assign local p =: NewParser in two separate http requests panic with oob because you didn’t want type out a word in your parser ;)
I’d recommend The go course on Udemy. It is taught by a professor and contains elements necessary for a college course. Slides, references to additional material, Assignments and student code examples. The teacher is also is not boring monotone and his left field tangents actually are effective and make the material memorable.
Umm, may I ask another question here? hehe So in pprof, we have: `cum`, `flat` ,and `sum` and what is the `sum` mean? 
The code is not doing `len([]rune(s))` is it?
&gt; You could say it's a quirk of Hugo though That's a fair point. As I mentioned in the post, I am not a Go developer. So tweaking Hugo directly using your suggestion isn't in my skill level. But I'll definitely forward your suggestion with the Hugo dev team. Thanks.
You're writing a parser. What if someone wants to parse two streams at once? Or 20? Probably best to make a parser object, and put things to track position in there. The way I look at it, like with the net/http library, there's a default client it uses \- a global variable that holds a http.client \- if you just use bare functions. That's great if you want to then do something with testing \- just replace that default client and you're golden. If there could be a situation where you need multiple versions of a thing, that thing should not be global. If you just need it once, maybe a global works. I've taken to \(at times\) declaring all of my standard errors as globals in the package, and then heavily commenting each error \- that way I can test for exactly that error, I can document in the package documentation what's causing that error, and I'll never need to change that error ever cause if I did I'll just create another.
The Go Programming Language by Donovan et. al. is probably your best bet for an academic-type book. 
I put together the [Gopher Reading List](https://github.com/enocom/gopher-reading-list) as a resource for newcomers. It has a lot of useful blog posts.
&gt; The oldest token ID in your blacklist will be slightly older than your standard TTL, meaning you cayn easily store your blacklist in a tiny in memory KV store even for sites with millions of concurrent users. It doesn't matter. It negates the point of statelessness completely. JWT was invented by people who don't understand what a cookie is and how to use it.
I think you are dramatically overstating the amount of state that a blacklist is and understating the value of having a cryptographically secure store of state that is held client side. One need not be slavishly consistent to every design ideal/principle, often the best solution in a given domain will have some domain specific compromises.
&gt; I think you are dramatically overstating the amount of state that a blacklist is and understating the value of having a cryptographically secure store of state that is held client side. &gt; &gt; So what? keeping track of tokens on a server at first place isn't that much state to begin with. Yet JWT proponents claim it is stateless when in practice it is never implemented that way for practical reasons. Why bother with JWT when a random dumb token sufficient at first place? I personally don't. Either you claim something is stateless or you don't. A blacklist on the server is not statelessness. 
Try exercism.io, the are a series of programming problems you can solve with Go asking with instruction and tips. The best part though is you can upload your code and get feedback. The community there is helpful and knowledgeable. 
&gt; Can you tell me for which compiler does it escape to heap? The point is not about a concrete example, even though older versions of the `gc` compiler are such examples. Any conforming implementation is completely free to not to implement every possible optimization. Your code should never ever rely on a particular optimization of a particular compiler. That's poor coding practice.
It seems that your definition of the word `may` maybe differs from the one I'm using.
I think this is the best guideline. Honestly, in general, 99% of the time the reason I'm annoyed with someone else's code is because it lacks tests. If code has good tests, it most likely doesn't have the inherent design flaws that make it hard to work with.
This is a well known issue when the channel times out. A similar issue is on node watch events: https://github.com/kubernetes/client-go/issues/334#issuecomment-378752777 A workaround/coding pattern is also described there. 
Email is not secure; the first person to use the link gets the access. This includes any sniffer on any server the packets pass through on the was too the destination, as well as any admin on the mail server with access to emails. How is this considered even remotely secure, much less more secure than a proper password?
I'm gonna use the following minute fantasising about a world where duit has replaced 90% of Electron apps. **mmmm**
wow didnt know this, thanks for the link.
I'm looking for a distributed memory cache that will work automatically in an auto-scaling Kubernates cluster... Any ideas?
One question. Why are you looking at the rune count in the first place? I know very few uses for it.
Pretty much every password auth mechanism uses emails to reset passwords if they're forgotten, so email is already a weakness with 'proper' passwords. This removes other weaknesses like social engineering to obtain users' passwords, and leaks of databases full of (hopefully hashed) passwords.
Go compiler puts a call for `[]rune(s)` and it does two passes. If it wasn't doing so, other operations would perform better for `foo([]rune(s))`. It doesn't have to be like: `len([]rune(s))`.
&gt; Why Actually the thing is not directly rune count. It looks like so. The problems is caused because of the conversion. `foo([]rune(s))` will all perform better when the conversion routine become more performant.
Using an access/refresh token pattern you can achieve enough statelessness to make jwts a better option then dumb tokens. Is it “really” stateless? No, not technically, but for the majority of the use cases it will be stateless enough to have an edge in many cases.
Same could be said about any authentication system that has password reset via email. Technically correct, practically irrelevant.
The compiler does not import any packages. Language functionality is "built-ins". You could add another built-in as a peephole optimization, but this is borderline silly, and a waste of compiler dev time. They have more important things to work on, such as actually useful optimizations.
Yes, that's right. Something like memcached but somehow aware of the auto-scaling events... So the cache is sharded over all the nodes in the cluster.
I know about the performance implications. I'm specifically asking about why you need to know the rune count, regardless of the method being used.
Serverless is a generic term that means different things to different people. My definition is that it means you have no servers to manage. AWS's main serverless offering, AWS Lambda, is a platform. You are free to run whatever services you like on it, be that RPC, REST or whatever.
As usual with tutorials the example was a little contrived. I wanted to keep the API code as simple as possible so I could focus on the migration part which was the main thrust of the article.
That's why I love it when people copy/paste bugs, I solve it where I find it and it still pops up 3 months later because why call a function when you can copy/paste it? Seriously, how can something like this be upvoted? How can you reliably track and fix a bug that has been copy pasted to death in a large project? 
Definitely. Mark Summerfield also wrote a good book.
This could be the perfect UI for neovim! 
&gt; But I really need ENV integration for a lot of new projects I deploy I've combined that with docopt before, but in hindsight, it would have been smarter to use a library with built-in support. 
We started our first Go project recently for a backend and in general are sticking with standard libs, however we are using chi since it is small and is not a "framework" and seems idiomatic.
so, `sum` is combination between `cum` and `falt` ? * sorry, I still don't get it hehe
&gt;…optimizations is about taking *good* constructs that implement the optimal code pattern, and ensure that the compiler output is as good as it can be. &gt; &gt;\&lt;…\&gt; &gt; &gt;What you are asking about is to take a construct that is *bad*, and make it *good*. Very well formulated; crystal\-clear. Thank you.
Go 101: https://go101.org/
Was just thinking about this exact topic, how funny! I think I come to much the same conclusion- traditional measures of code complexity don't seem quite as meaningful for idiomatic Go code as they do for e.g. Java code. The nature of Go error checking needs to be accounted for to get meaningful results.
When the type of value doesn't allow you to make it a const.
I'm not saying that it should "import the package" but the cast from `string` to `[]rune` already needs to use an identical algorithm to calculate the length of the array. The optimization here would be "don't create the temporary array".
Cyclomatic complexity also doesn't really account for the fact that in a number of languages exceptions can forge a totally invisible path through your function that's not accounted for by syntax, which is (I think) a potentially huge mental overhead if you need to make code safe. 
Ah, but the compiler doesn't know that the array is unused. The string to []rune conversion happens in runtime.stringtoslicerune. This function takes a string (and some weird tmp buffer), and returns a slice rune. The function first iterates over the string by calling runtime.decoderune ("for range := s") to count all codepoints. It then allocates an array, end iterates over the string again with runtime.decoderune to fill in the array, which it returns as a slice. From the perspective of the compiler, the slice is used, as it is returned by the function. If the function had been inlined, it could eliminate the second iteration, but now we're having a chicken and egg problem: The function is not inlined because it is too big (the compiler isn't fond of swapping 1 callq instruction for the ~100 instructions of runtime.stringtoslicerune), and the function is too big because it is not inlined (and thus does not have dead code elimination applied). There isn't a good solution to this problem. It's unfeasible to *try* to inline large functions to see if they optimize away. I would argue that you as a developer shouldn't rely on the compiler being magic. It would be neat if the compiler could realize that a later optimization would make inlining feasible, but this is not a case of code being slow because the compiler is stupid. It's a case of code being slow because it is being told to do the wrong thing.
That's a Ragel file generating Go code. Looks like the Makefile has rules to build it.
Sure, of course the answer is in the middle. This was a devil's advocacy-type discussion, don't worry.
Given: if p.tokenIs(t, u, v) { ... } You are reading it like: if car(token) is red, green blue then { ... } ...which seems better than "if is car ...", but IMO what you should have is something more like: if p.isType(t, u, v) { ... } ...and read it as: if the car(p) is the colour(type) red, green or blue then { ... }
The link will work only during the show, which will broadcast at 3pm 4/19/18 and last for roughly an hour.
Any help in translating the source comments? Looks neat.
Hi everyone, I'm the author. I'll be checking back periodically to see if there are any questions which I'll try to address. -Sean- 
"Blazing" is not a proper technical or scientific qualifier. Let's not use sensationalist wording.
I have translated all the comments to english, thanks for suggestion
[removed]
The default net/http library provides a http server that creates a goroutine for every request.
See: https://golang.org/pkg/net/http/httputil/ https://blog.golang.org/http-tracing https://golang.org/pkg/net/http/
I don't see any benefit in this over normal system (unless you are using untrusted device one time but you have logut). In normal system you pick password and 99% of users click to save the password with e-mail in their browser. Now instead they need to wait for e-mail every time they want to use the site after some time (if JWT tokens are short lived).
thats super awesome! You didn't even need to get rid of the original comments, but thanks for adding the translation. Really appreciated.
&gt; Command-line app, prints quotes from the narrator of Darkest Dungeon, written in Go
It can be done by custom operator. But writing for a vegamcache alone will be a little overhead for cluster but there will be a good improvement in performance. 
The `SyslogMessage` struct uses a lot of pointers. Some values themselves are smaller than a pointer (uint8) or are basically pointers (string, map). Unless you need a nil pointer to distinguish between "no value" and the zero value, you should probably remove that indirection.
mage. Don’t unnecessarily vendor lock Go projects to (GNU) make, coreutils, UNIX, etc.
One silly question: is devdraw (and thus duit) network transparent? Can I 'ssh -YC othermachine' and have my windows being served over the network? (I don't have 2 machines with 'devdraw' installed...) And: is conceptually possible to write a pure-Go devdraw command?
I thought that cyclomatic complexity wasn't a terrific measure of anything: https://dspace.mit.edu/bitstream/handle/1721.1/47149/cyclomaticcomple00gill.pdf I seem to recall another paper that claimed that older studies of cyclomatic complexity had completely ignored code size, and that cyclomatic complexity was proportional to lines of code, or some similar measure. Can't seem to find that one.
That is probably the problem. `for event := range hpaWatch.ResultChan()` is one correct solution. Another, if you actually want to select over different event streams, is to disable the channel by assigning it `nil`: ``` hpaC := hpaWatch.ResultChan() endlessLoop: for { select { case event, ok := &lt;- hpaC if !ok { hpaC = nil } // ... default: // ... if quit { break endlessLoop } } } ``` A closed channel never blocks. A nil channel always blocks.
Thanks for the kind words! I did miss a few things, but that's the idea behind the initial launch.
Yes, I made it so on purpose, as I find deeply nested comments confusing.
&gt; For our particular workload that we were using when testing our changes, we didn’t see much improvement with sync.Map. Does that mean there was a small improvement? In the sample code, it's using sync.Mutex, not sync.RWMutex. Any reason for that?
Yeah, typo. I meant for that to be a RWMutex. Updating that now thanks. sync.Map had a small improvement yes.
With channels and goroutines being at the core of the language, and being so *cheap* (in terms of used resources), you really don't need to think twice - if it makes sense, just use one (or ten, or a thousand). Many libraries do this for you behind the scenes already, for example there was that one SDL wrapper which just gave you a receive-only channel of events instead of exposing the "classic" polling / "wait for the next event" API. The lib just starts a goroutine in an `init` function, that wraps the low-level API and gives you something nicer. I suggest you go around and poke at some libraries, there's lots of beautiful code out there. 
Oh, you're right. I misread the article.
Could you shed some light on how does the kernel work internally? What design is it based on, how does it achieve the REPL-like behaviors? How did you overcome the usual challenges??
This would be a great feature!
Use `const` or `let` over `var` in your JS. It's silly that you use full ES2015+ features, but neglect `const` or `let`. Nice work though!
But how did you do that?
[removed]
Since you're on the topic of raymond, I made a little library a while back to use raymond with Gin. https://github.com/robvdl/ginraymond It doesn't really get much updates and isn't super popular, but it's one of those libraries that doesn't really need many updates anyway. However my other library which is similar but for adding pongo2 template support to Gin is a lot more popular: https://github.com/robvdl/pongo2gin
Replace client Transport with your own and wrap the default transport. https://golang.org/pkg/net/http/#RoundTripper log or whatever to see the raw request/response sent to and received from the underlying Transport RoundTrip
use something like Wireshark / Fiddler2?
I'm commenting to demonstrate that the fourth, reply to the rebuttal is totally useless.
How does it compare to something like libp2p? https://github.com/libp2p/go-libp2p
This'll be great once the devdraw stuff is replaced with gl, x/shiny or some such.
&gt; totally invisible path through your function that's not accounted for &gt; by syntax, which is (I think) a potentially huge mental overhead if &gt; you need to make code safe. I agree 👍. BTW, I read your post and left a comment there.
Yeap, I have the same feeling as you about it. As you are also thinking about this same topic, maybe you would like to check this thread: https://groups.google.com/forum/#!topic/golang-nuts/HNNUjE5VWos
&gt;How would I go about building a go backend with a postgres database with a react frontend? You'd build a Go backend that talks to Postgre with a React frontend. If you have any specific questions, you should probably ask those.
Yes it can. As an example, given the following declaration // C is a type alias type C = os.FileInfo Mockhiato will generate mocks for `C` with functions implementing the `os.FileInfo` interface. // NewCMock creates a new CMock func NewCMock() *CMock { return &amp;CMock{} } // CMock implements example.C type CMock struct{ mock.Mock } // IsDir implements (example.C).IsDir func (r *CMock) IsDir() bool { ret := r.Called() var ret0 bool if a := ret.Get(0); a != nil { ret0 = a.(bool) } return ret0 } // ModTime implements (example.C).ModTime func (r *CMock) ModTime() time.Time { ret := r.Called() var ret0 time.Time if a := ret.Get(0); a != nil { ret0 = a.(time.Time) } return ret0 } // Mode implements (example.C).Mode func (r *CMock) Mode() os.FileMode { ret := r.Called() var ret0 os.FileMode if a := ret.Get(0); a != nil { ret0 = a.(os.FileMode) } return ret0 } // Name implements (example.C).Name func (r *CMock) Name() string { ret := r.Called() var ret0 string if a := ret.Get(0); a != nil { ret0 = a.(string) } return ret0 } // Size implements (example.C).Size func (r *CMock) Size() int64 { ret := r.Called() var ret0 int64 if a := ret.Get(0); a != nil { ret0 = a.(int64) } return ret0 } // Sys implements (example.C).Sys func (r *CMock) Sys() interface{} { ret := r.Called() var ret0 interface{} if a := ret.Get(0); a != nil { ret0 = a.(interface{}) } return ret0 }
https://requestbin.fullcontact.com/ is also a great tool for this sort of thing.
this is like [Isso](https://posativ.org/isso/) but more resource efficent(?) Can i use it on a subaddress(e.g. blog.domain.com/comments)? Btw, a docker image based on something light would be better (alpine or scratch).
There are plenty of examples out there — [start here](https://www.google.com/search?q=react.js+%2B+golang+%2B+postgresql).
Just pointing out that the fifth layer is absolutely worthless.
map it to a bson.M
Can't be mapped to a struct? That's your issue, everything can be mapped to a struct. Try giving it an empty interface and see what it puts in. Also, we need to see an example of the unstructured data, just remove anything private.
you are embedding a sync.Mutex into the memory/redis adapters, which makes it available from the outside as API, and I don't think you are prepared to handle that and it's just there for convenience so you have to type less it is an implementation detail, the lock should not be exported as API
Libp2p is network transport and serialisation agnostic. It's also used in production.
If you end up doing that, you can either do a migration from disqus to isso and from isso to mouthful(there's a migration isso-&gt; mouthful already available). Alternatively, if you're willing to share your disquss dump with me, I could make a disqus -&gt; mouthful migration ;)
yes, six wins the day
What's the difference with go-rice or go-bindata? Does it do something more?
You are right, it is when an app compiles to an exec that you should vendor
Will it be available again?
It looks like you’re using a hash (fnv) as your cache key. Doesn’t that open up the possibility for collisions? I realize it’s not very likely, but it could be a security vulnerability if someone could manage to intentionally craft a url that collides to another, private url. I’d just use the url itself as the cache key. also, you’re ignoring the possible errors returned from gob.Encode/Decode. You might want to look into the errcheck lint tool (or gometalinter) to catch this in the future.
yep that's exactly the idea :D
it's a TTL embedded app cache (with adaptors for scaling out to shared cache). I'm not sure if Expiration in the underlying Go Http API leaves an e-tag, but I think it's standard for nocache headers (for the client to obey) https://github.com/victorspringer/http-cache/blob/4bba304c540e2040ee8459fe1da87de143dd7edb/cache.go#L112
whats the difference between projects and libraries?
Go on then. Show us all how?
Yes, it should be released today some time at gotime.fm or in your favorite podcast channel.
Could somebody make a summary ?
I think part of the success of Electron apps is the possibilty to modify the look and feel easily with widely accepted standard: css. I can imagine a non-native GUI that supports (partly) css can have a bright feature. Reminds me of react native. For branding its very important to offer your own design and experience instead of a canned OS native one.
Are there production level blockchain projects written in golang other than geth?
Great job! I see it support different v3 features like batch, ssl and on. Can I: - store and send chat history to users? - send delivery and read acknowledges? With echo-message? - guarantee message delivery? Thank you.
How does this compare to an existing solution [0) in this space? Or were you not aware of it? [0] https://github.com/gregjones/httpcache
The lock file isn't really necessary either (although it doesn't hurt), and the Gopkg.toml file should be more forgiving. Right now it's locked to exact versions for redis and msgpack which means anyone consuming the library will be forced to use exactly those versions. If they also have other dependencies that want a newer version of redis or msgpack then their vendoring process will fail and they will have to manually override it. You could instead use e.g. "\^6.10.2" to mean at least that version but not version 7. https://golang.github.io/dep/docs/Gopkg.toml.html#version
Personally, I love it. It looks clean and well-written, with few wasted lines of code. Well done. What would the performance hit be on a cache miss? I'm curious mostly because I've been thinking of using the `httptest.NewRecorder` to intercept a response and transform it, but I'm hesitant because one of the goals of my API is to make it as fast as possible. Thoughts?
In the memory adaptor you access the map without using a lock, which is racy even if you only modify the map using the lock. You probably should use `sync.RWMutex` or just `sync.Map`.
Projects are applications that run themselves, libraries are code that an application uses when they run.
&gt; Pretty much every password auth mechanism uses emails to reset passwords Um, sort of sniping from the sidelines here, but this is a pretty strong claim and really can't go unchallenged in a Go forum. What you claim may be the case in some classes of consumer or small business oriented non-critical services, but really, you're ignoring any number of actually security conscious systems that use ID tokens or two factor auth, or keep it simple but still maintain sensible security protocol... which most definitely do not email password resets. 
It's just that I've heard of people talk about a frontend "reactor" node.js server to talk with the frontend and the backend. It seems very different from the backends I've built in the past.
Why would that be? If one of the deps goes missing then this package is fairly worthless as well, no?
Useful. I would not suggest calling it an "in-memory network stack", because that has a meaning in the network world; it means a TCP stack that can be used with userspace-based networking, [like this](https://github.com/ansyun/dpdk-ans). You've got a in-memory net.Listener and net.Conn implementation. I don't have a slick name for that. For the API, I'd suggest against cloning net.Dial's multi-network support. In my implementation I gave an object back that could run the Accept call, or had a Connect call that yielded a net.Conn. Since you already can't wrap net.Dial in an interface without additional work, they already have to dependency-inject something anyhow.
I like the simplified examples that are popping up on medium for block chain programming. I already adapted the JavaScript examples into go and learned a lot from it. Thanks. :)
[removed]
[removed]
Good points, I'll fix that up! Thank you
Heroku is free and does not sleep for worker type dynos if I'm not mistaken ;)
You should let the library user decide which dependencies he wants. What if 2nd library is used between this one and the executable? It would be vendored in the lib and a different one would be vendored by the executable. The lib should specify the required version of its dependencies but not vendor them. (IMHO)
Hi /u/tv64738, In other words, when you absolutely, positively...https://youtu.be/yxQNYPYFq1c :) There's actually an additional reason to use MemConn, and I'm working on an essay about a longer topic to explain why. I just didn't want to try and cram everything into a single post.
Hi /u/dgryski, Thank you for the post! FYI, I will probably update the blog to respond to /u/tv64738 below. The additional reason, other than the essay I mentioned, is due to Go benchmarks that use TCP to quickly exhaust file descriptors, even after increasing the limit. UNIX sockets also require clean up, and failed tests don't always act as good filesystem stewards and behave correctly. `os.Exit` anyone? (I wish `defer` in a `func main()` would interrupt an `os.Exit` to run first.
So here's an example from a random pprof I have: ``` (pprof) top Showing nodes accounting for 58.53s, 97.78% of 59.86s total Dropped 139 nodes (cum &lt;= 0.30s) Showing top 10 nodes out of 90 flat flat% sum% cum cum% 42.55s 71.08% 71.08% 42.69s 71.32% syscall.Syscall 11.55s 19.30% 90.38% 11.55s 19.30% runtime.kevent 3.13s 5.23% 95.61% 3.13s 5.23% syscall.Syscall6 0.64s 1.07% 96.68% 0.64s 1.07% runtime.memclrNoHeapPointers 0.28s 0.47% 97.14% 4.32s 7.22% os.(*file).close 0.19s 0.32% 97.46% 0.45s 0.75% math/rand.read 0.07s 0.12% 97.58% 1.78s 2.97% os.Mkdir 0.05s 0.084% 97.66% 1.01s 1.69% os.rename 0.04s 0.067% 97.73% 8.18s 13.67% os.Remove 0.03s 0.05% 97.78% 0.71s 1.19% runtime.mallocgc ``` The first sum% (`71.08%`) is the same as the first flat%, the second sum% is the sum of first and second flat%, the third sum% is the sum of first through third flat%... It's basically how much has been covered up to now.
That's basically our stack! We use Go on our backend for RESTish APIs. We use github.com/mgutz/dat for postgres data mapper since we dislike ORMs. We do run an express node.js server for universal rendering which calls the Go APIs to fetch bootstrap data for react page it serves. In front of all this is nginx, acting as a reverse proxy.
Hi /u/gedw99, Thank you! The performance increase is I have to imagine similar from moving to HDD -&gt; SSD -&gt; RAM Disk. Like the latter, MemConn utilizes a purely in-memory implementation of Go's `net.Conn` interface. The reason the network type is `memu` and not `mem` or `memconn` is because I originally wrote MemConn last year, before Go 1.10. Prior to 1.10 the objects returned from `net.Pipe` did not support deadline semantics. Therefore I had reimplemented the pipe manually to do so and intended to also provide a buffered version. While I now defer to native pipe in 1.10 and copied their source for providing backwards-compatibility, I do intend to still add a buffered network called `memb` in the future.
We'll need benchies 😋
[removed]
To be fair, network connections have never been responsible for slowing down unit tests in my experience. Sure, they slow down a bit, but it's not significant compared to all the other stuff going on. This is especially true if you use a test suite (e.g. stretchr/testify#suite) and recycle the same connection. Nonetheless, this is neat and I like the cleanliness of not having to pick random ports / random paths for unix sockets to make tests run concurrently.
As they say, &gt; There are only two hard things in Computer Science: cache invalidation and naming things. So the question is, how do you (or a user of your library) invalidates the cache? I suggest providing a few built-ins (e.g. TTL) and most importantly providing a callback function in the config and passing the http request and a few other components in there (how long the entry was cached for, etc). That way your caller can provide some custom logic (e.g. if some of my internal state didn't change, then it's fine to serve the cached version). Another thing you might want to do is to provide an extra dimension for caching. The same endpoint might have different cached versions depending on external factors (e.g. user ID as decoded from the JWT token). Again, I'd provide a callback for this as well.
[removed]
Concurrent connection’s matter when you’re benchmarking in parallel. And there are also CI systems where you don’t have the luxury of increasing the descriptor limit. Besides, why rely on a finite OS resource when you don’t have to. Unless of course that’s what you’re testing.
[removed]
Sweet.
Touché. In many cases though, APIs ask you for a listening address rather than a `net.Listener`. In that case you can't really pass a zero port to let the kernel do the allocation, otherwise you won't know where to connect. That only works if you can do your own `net.Listen()` with a zero port, fetch the `.Addr()`, parse back the port and pass the listener to whatever service needs listening.
[removed]
Sure. So basically with almost any program, you're taking input, processing it through various stages and writing it out - to a network connection, a file, display, etc. and finally shutting it down. In Go, a type that implements io.Reader allows you to read from it. A type that implements io.Writer allows you to write to it. A type that implements io.Closer allows you to close it (like a network connection, a serial port, a file, etc) The standard library's memory buffer, file and network connection types (and more) all implement io.Reader and io.Writer and therefore can be used interchangeably. This means you can develop your app using simple memory buffers if you want and then swap out an in memory buffer for a file type if you want persistent storage, without affecting the behavior of your app. This is a really powerful concept, especially when the types implement the interface in line with the SOLID principles (https://dave.cheney.net/2016/08/20/solid-go-design) So with just those 3 interfaces, you have a huge amount of potential as far as writing and re-using code is concerned because most of Go's standard library allows you to start from a reader, a writer or a ReadWriteCloser (combination of all 3). That was my reason for listing them. In C++, you have the rule of 3 (now the rule of 5) just to make sure your code works with minimal gotchas. I call implementing io.Reader, io.Writer and io.Closer, Go's rule of 3. Except in Go, its not about getting your code to behave, its about enabling a huge amount of reuse and composability, which is just so much more powerful. As Rob Pike said, "Less is exponentially more"
I'm on a Macbook. It seems to be a problem with Chrome itself. Thanks for the answer.
1) No need to commit the vendor directory when using dep 2) Ignores Vary response headers 3) Consider compressing responses to save on memory and/or redis/memcahed bandwidth 4) Have a look at microcache https://github.com/httpimp/microcache
Ignore the troll, check /u/bastiaanvv's answer.
Owh okkay, Thank you, I get it now 
That would be great!
Awesome! Now does anyone know a good image processing library to use with it?
openCV
[it is](https://golang.org/pkg/crypto/elliptic/). 
I genuinely don't know what you mean. Because to me, it seems that this is at best a question of naming. You can [generate a key](https://godoc.org/crypto/elliptic#GenerateKey). And calculate the shared secret from your private and their public key by calling [Curve.ScalarMult](https://godoc.org/crypto/elliptic#Curve.ScalarMult). Those two function calls are ECDH. There are crypto protocols on top of ECDH, to deal with key derivation and that specify when to generate new, ephemeral keys, for example (as if you use it in TLS). If you need one of those, it would be helpful if you ask for the specific protocol.
Consider the ECDSA package. Everything required to implement ECDSA is contained in the package you linked. However, the ECDSA package exists and contains convenience methods that allow simple and intentional interaction. This doesn't exist for ECDH. An understanding of ECDH is required to implement it, and you've outlined yourself how trivial it is, once you have this understanding, to generate and use the keys. But eliminating the understanding part would be easy with an actual ECDH package. It would also avoid people implementing it wrong and using insecure code in production. So, let's says my question is: Why not provide a package for this algorithm that addresses potential pitfalls in understanding and implementing the algorithm yourself?
Perhaps it would be helpful if you could explain what you are trying to do or intend to use this for. It seems to me, that Diffie-Hellman (regardless of the underlying group) only makes sense in the context of a larger crypto-protocol, that specifies where the keys are coming from and what to do with the shared secret - like TLS. I don't understand what a (EC)DH package would even mean; it's not a specified protocol on its own.
I'm not trying to accomplish anything, this is for the sake of understanding a design choice. ECDH isn't a protocol, no, but it is a defined algorithm. I'm not sure if our conversation will be all that constructive for either of us. If I'm still not making myself clear to you, it might be best to ditch the communication effort :)
gocv.io is a wrapper of opencv, made by the same people of gobot.io
You can use GoCV (https://gocv.io) very easily with Gobot and Tello.
I suppose this is the answer OP was looking for.
Sorry to hear you're having issues with the IDE. Can you please ping me on Twitter/Gophers Slack (@dlsniper) or open an issue on our tracker: https://youtrack.jetbrains.com/issues/Go and attach the IDE logs (Help | Collect and Show Logs in...)? Unfortunately, your question is too broad for me to be able to help. Additionally, you may want to have a look at the instructions here: https://intellij-support.jetbrains.com/hc/en-us/articles/207241235-Reporting-performance-problems on how to generate an IDE profile report and send it to us so that we can understand what's going on. Thank you.
So, could I do something like create a application, the core of which would handle , say, database calls, but its logic part (e.g. a CRM system and the logic of creating database schemes, record validation, business logic) would be written in the scripting language?
I managed to speed up performance considerably by not indexing the GOPATH (tend to vendor everything inside each "project"). See performance section for 2018.1 release: https://blog.jetbrains.com/go/2018/03/29/go-the-distance-goland-2018-1-is-here/
This. 
Totally agreed with /u/Jeremiez, the code looks great. I like how you organize your config and defaults \(the "global" pkg\). It's something I've always struggled with, and never found something that really clicks for me \(in my short experience with Go, at least\). I'll give it a shot at that architecture. Great job!
yes, that's a possibility, i'm thinking about how i can solve it withou loosing performance i'll treat the possible errors from encode/decode, thanks for the feedback!
thanks guys, it's been fixed!
I've used Tesseract and it's actual pretty bad in real use cases, in my experience. I ended up buying some proprietary software last time I needed ocr.
Thanks, it's already changed to sync.RWMutex ;)
I wanted to do a project just like this. The syntax looks pretty reasonable. I'm going to check this out more soon. Thank you for sharing
You can do that if you require certain features that are easier to implement with nodejs and justify the additional complexity. But there's no "right answer" here, it will differ a lot based on your requirements. For a simple site with a REST API there's no need to add extra layers.
Hi /u/tv64378, For me personally one of the issues is the fact that when you’re testing things the ability to discover a port generated by the kernel may be masked or hidden behind the facade of the app you’re testing. For situations like that I personally use these helper functions I wrote: ```go const ( minTCPPort = 0 maxTCPPort = 65535 maxReservedTCPPort = 1024 maxRandTCPPort = maxTCPPort - (maxReservedTCPPort + 1) ) var ( tcpPortRand = rand.New(rand.NewSource(time.Now().UnixNano())) ) // IsTCPPortAvailable returns a flag indicating whether or not a TCP port is // available. func IsTCPPortAvailable(port int) bool { if port &lt; minTCPPort || port &gt; maxTCPPort { return false } conn, err := net.Listen("tcp", fmt.Sprintf("127.0.0.1:%d", port)) if err != nil { return false } conn.Close() return true } // RandomTCPPort gets a free, random TCP port between 1025-65535. If no free // ports are available -1 is returned. func RandomTCPPort() int { for i := maxReservedTCPPort; i &lt; maxTCPPort; i++ { p := tcpPortRand.Intn(maxRandTCPPort) + maxReservedTCPPort + 1 if IsTCPPortAvailable(p) { return p } } return -1 } ``` 
from the looks of it, yes. You can define functions and embed it into the environment of any script so you can just wrap functions for DB calls.
BSON is known to truncate huge numbers. IIRC, you have to use Unix instead of Unix Nano
compared to other IDEs i've always been impressed with Goland's performance. curious what the issues are here.
Checkout https://github.com/robertkrimen/otto It’s a s
Not necessarily what you’re looking for, but if you want more insights into what bigquery is doing under the hood you could consider adding Tracing support. That would show you all requests being made, their latences and some attributes. It only takes a few lines of coding using OpenCensus (https://github.com/census-instrumentation/opencensus-go) and the traces would show up in GCP StackDriver.
I agree with all that is said so far. One thing to add, which was touched on but this is very specific. The fact that the compiler complains about unused imports or variables. Code gets so sloppy sometimes, that mechanism really does a big part in keeping my code clean. That and go fmt. \(In C#, create a new class and visual studio adds like 4\-5 using's, none of which you use all the time. Sometimes you just use one. It's so ugly\)
Another option I see people do is convert their time value to a string before saving as BSON. I know it sounds ridiculous, but so is using MongoDB in a production environment. (Yes, that was me throwing shade.)
What's about using MongoDB in a production? (genuinely interested)
There is a directory that contains Go code (as you have identified), but you didn't give dep that path. Try `github.com/google/go-github/github`. Personally, I never use the command line to add dependencies. I find it easier to import the path somewhere in my code, then run an ensure to let dep figure out the rest.
Yep, I had tried `dep ensure -add github.com/google/go-github/github` and I got the same response `no dirs contained any Go code` oddly enough. But to be honest, that's a moot point now because your strategy of writing the import and then just running `dep ensure` seemed to work flawlessly!! Thanks so much for that tip!
The error is because you don't have any go code in the folder you're calling dep from. Just add a dummy main.go and it should work.
Gonna try them, but probably they cause at least GC overhead as they use string type for map key
Oh wow.... I misread the error message. Thanks!!
i don't have this measure yet, but i don't think httptest.NewRecorder itself would be expensive... it will depends more on the trasformation you are going to do with the response
Javascript only has floating-point numbers. They're only accurate to integer amounts up until 56 bits or so. Convert the int64s to strings.
I don't think it's a matter of 64-bin integer, but rather how `mgo` or the Golang itself marshal `time.Duration`. The value is 'correctly' stored as `NumberLong` in MongoDB. It seems like `time.Duration` is marshalled in 'second' unit instead of 'nanosecond' but when it's unmarshalled the value is read as is in 'nanosecond' so short of 6 trailing zeros...
Ah really. I can't say I've used it
from my experience with any of the Jetbrains IDEs (and Eclipse before that) it's almost always because its indexing too much / too large files. always make sure you have dirs with logs or large test fixture files on excluded. and if you use 1 big go workspace for all your projects you might want to consider seperating them so it's not indexing tons of code that isn't even relevant for the project you're working on. also; after putting stuff on excluded make sure to use he "restart and invalidate caches" option 
 b1 := []byte { 1, 2, 3 } b2 := "string" b1 = append(b1, []byte(b2)...) fmt.Println(string(b1))
you don't need to cast; you can just: b1 = append(b1, b2...)
&gt; b1 := []byte { 1, 2, 3 } &gt; b2 := "string" &gt; &gt; b1 = append(b1, []byte(b2)...) &gt; &gt; fmt.Println(string(b1)) Doh. you are absolutely right. I will change my reply.
gRPC runs on top of http2 which is TLS by defeault. You /can/ configure plaintext http2 in Go.
I myslef use netcat nc -l -p $PORT
Or just code in golang and compile to WASM. Then the WASM can run in a browser OR in Wagon server side. Much better than Otto approach any day of the week IMHO
Well, what have you tried?
I didn't review the whole code, just had a quick glance at it. It looked quite fine.. just some small things that are not typical go style: - we usually use short variable names. e.g "monteCarloTreeSearchGameNode" I would rather call mctsNode or maybe just node depending on more context. - interface naming is a little different optimally but I would not rate this very high. See [this](https://golang.org/doc/effective_go.html#interface-names) 
easiest way is `someBytes = append(someBytes, someStr...)`
you need read the documentation of MangoAPI in details.
do they use that because the official ethereum package is nodejs? if not why?
O(1). It just creates a new struct with a length, capacity, and pointer to underlying storage. No storage is copied. 
Waov. I have been thinking of 'aString...' expression like it was ranging over the characters of that variable and cast them as runes.
awesome, queue built right into the language :D
I wouldn’t use mgo, it’s been abandoned. MongoDB have been working on their own driver, I would suggest giving it a go. https://github.com/mongodb/mongo-go-driver
i like to use grpc for this.
These are historically computer science demigods who author and maintain the language, so yeah... 😎
That fucking boggles my tiny C peabrain
Think of a slice as a struct with: * A pointer to an array * Some metadata about what part of the array it is referencing, and what parts are empty/unused * Associated helper functions to interact with (add to, reslice, etc) the underlying array
To be more specific in this context, Ken Thompson designed slices.
I can understand that on some level, it just like blows my mind how simple and clean the interface and implementation are, you know? It's just cool, it's basically a "Zero-cost abstraction", which is awesome.
Agreed with you on that. Slices are neat.
i was thinking if there are some weird edge cases in which it would be O(n) instead of O(1), but my peabrain is not ready for it :(
It's not exactly zero cost. Like most things in software, there are trade-offs. Let's say you take a tiny slice of some giant array. You aren't using anything else in the rest of the array. Ideally, you'd be able to free up that unused memory, but since the slice points into the original array, the whole array is kept around. Russ mentions this fact [here](https://research.swtch.com/godata). I think Go makes the right trade-off, but it's still one you need to be aware of. Sometimes you need to explicitly copy so that it can free up the memory of the original array.
https://blog.golang.org/slices
FWIW the (concurrency-safe) queue that's built in to the language is `chan`. Using `append` and `s = s[1:]` as a FIFO queue causes a lot of garbage.
I'm sorry you don't understand my complaint. Stated as simply as I can put it: I think the idiom of using sizeof *p to avoid repetition of typing the type of *p is useful when allocating new objects, and I miss that in Go. As neither my post nor my reply made any other arguments, I'll avoid addressing the arguments I didn't make. While this particular example is more annoying to me than an encumbrance, there are things about Go that I believe qualify as cumbersome. In particular, the specification doesn't make it possible to implement many lock-free algorithms without relying on horrible hacks like using unsafe with float128 to pretend you have a pointer and generation counter, and a lack of support for DCAS in sync/atomic. Unfortunately, I am unable to share the majority of the code I write. Most of the open source Go code I have written exists in the Go repository, and you're welcome to refer to those commits. While I never argued for elision of type names in composite literals, Bryan Mills pointed out [issue 12854](https://github.com/golang/go/issues/12854) in a [thread on the ML](https://groups.google.com/forum/#!topic/golang-nuts/Asq2WfWkPc8), which is exactly what you describe. It doesn't address the whole issue, since it wouldn't reduce repetition of type names in make/new. I'd also note that Go already omits types in most assignments: you already can't tell me anything about `foo := bar` without referring to context (which may even be in a separate package). What's so different about `return &amp;{}`? I feel that would be a convenient shorthand for all the NewFoo functions I've written that simply returned a Foo initialized with zero-values. I'm sorry you don't find this idea useful. Many others do. It's okay to disagree.
I believe OP is trying to explain that the rune count (in 99% of scenarios) isn't very helpful. What you're looking for is grapheme clusters, and I don't think there's a library for it yet.
[removed]
The go project is main ethereum client. https://github.com/ethereum/go-ethereum
Adding something to a pointer and then storing that value in a new pointer (or the same one) boggles your brain? Are you sure you meant C?
Pointer arithmetic doesn't boggle my mind, but stopping the pointer from wandering off the end sure does.
I'm eagerly reading through every single article on authentication and authorization that gets posted here, there seems to be not much info on that. Does anyone have additional resources that deal with these topics?
I'll be honest it's been a month so I only vaguely remember this post. But I think you at least explained the root of your problem better as: &gt; I think the idiom of using sizeof *p to avoid repetition of typing the type of *p is useful when allocating new objects, and I miss that in Go. While I do have _very_ strong opinions around malloc for reasons I already mentioned, that statement is more subjective so I have no strong opinion formed from technical merit. &gt; While this particular example is more annoying to me than an encumbrance, there are things about Go that I believe qualify as cumbersome. In particular, the specification doesn't make it possible to implement many lock-free algorithms without relying on horrible hacks like using unsafe with float128 to pretend you have a pointer and generation counter, and a lack of support for DCAS in sync/atomic. I have [tons](https://www.reddit.com/r/golang/comments/7tbvxl/so_just_how_fast_are_channels_anyway/dtc12xm/) of [posts](https://www.reddit.com/r/golang/comments/799of8/how_to_implement_a_lock_free_array/dp0pbhv/) in my [post](https://www.reddit.com/r/golang/comments/799of8/how_to_implement_a_lock_free_array/dp21urm/) [history](https://www.reddit.com/r/golang/comments/6l6poq/a_c_developer_looks_at_go_the_programming/djs3d4g/) [about](https://www.reddit.com/r/golang/comments/6l6poq/a_c_developer_looks_at_go_the_programming/djshpoz/) lock free algorithms. To [summarize](https://www.reddit.com/r/golang/comments/6dpwyp/lockfree_mrmw_ring_buffer/di4pfs4/) I feel that even thinking about these kinds of algorithms should be avoided. Now perhaps you are consistently working in the abysmally small fraction of problems that need them, I can't argue against problems I haven't been presented with. I will continue to argue against the user of lock free algorithms in typical every day Go code the overwhelming majority of people write. &gt; While I never argued for elision of type names in composite literals, Bryan Mills pointed out issue 12854 in a thread on the ML, which is exactly what you describe. It doesn't address the whole issue, since it wouldn't reduce repetition of type names in make/new. I'd also note that Go already omits types in most assignments: you already can't tell me anything about foo := bar without referring to context (which may even be in a separate package). What's so different about return &amp;{}? I feel that would be a convenient shorthand for all the NewFoo functions I've written that simply returned a Foo initialized with zero-values. &gt; &gt; I'm sorry you don't find this idea useful. Many others do. It's okay to disagree. I honestly just threw T elision out their because I couldn't understand your malloc sentiment, wasn't meant to subscribe you to that ideal or make a serious argument for or against it, sorry. After reviewing that proposal I can't pick a position a position without seeing an example of it fully used in a very large code base, as I already mentioned readability and style are subjective. I will answer your direct question of **"What's so different about return &amp;{}?"** though: the left hand side. Type inference on variable declaration has an identifier on the left hand side and an expression on the right to serve the reader. Even if the right hand side is a qualified or named operand you still are getting some form of a name that a programmer had to give that particular thing. There is a lot of value in having a name for a thing, so I would need to carefully measure what was lost when things start getting taken away. Regardless thanks for the civil reply and sharing your thoughts even if we have some disagreement, it's refreshing. Have a good one man.
[removed]
Unfortunately that official driver is still lacking alot of features. Would be ideal to move to in thr future however. Until then, github.com/globalsign/mgo Seem to be the most popular fork of mgo
[removed]
No worries. I don't often check reddit, but I do try to reply to things that have conversational value. Regarding malloc: manual memory management is unfortunately the price for using an unmanaged language; if you've decided on that, you recognized that there was a tradeoff with managed languages and that tradeoff was untenable for your project. For lots of software, I surely agree that managed languages are a better choice. But for many embedded systems, most control systems, some games, some network services, and most operating systems software, the overhead of using or supporting a managed environment isn't worth it. I certainly wouldn't recommend C for someone's CGIs, for example. Regarding lock-freedom, it's been very useful in systems I've worked on in the past. One thing that I find unfortunate (while not implying you said this) is that much disdain for lock-freedom comes from the subtleties of actually implementing the algorithms coupled with folks wanting to use them to improve "performance." On the subtlety of implementation, I definitely agree that it takes a specialist to invent new, correct algorithms. It probably also takes another sort of specialist to implement them. The nifty thing about them, though, is once you have a correct implementation, they're actually easier to use than mutual exclusion for several reasons that I won't get into because this reply is already too long. The "performance" problem is what really bothers me, though. Lock-freedom isn't about performance, it's about predictability. I think everyone can agree that shared-nothing should be everyone's default approach to designing concurrent systems. But sometimes you really need shared mutable state, and occasionally contention is unavoidable. This was the case with the logging system at my previous job: producers of log messages would contend on a lock to publish new logs. Contention on this lock was understandably high. Since log items could occur in the fast path of a request, and because lock-based synchronization doesn't provide any progress guarantees, this system behaved unpredictably in terms of latency for requests. Switching to a lock-free producer system with a wait-free single consumer significantly increased the throughput of the system, and normalized latencies. One could look at this result and say that I solved a performance problem. But more fundamentally what was done was to introduce predictability into the system by providing a progress guarantee where previously none existed. That all said, I agree that lots of software doesn't really need to care, and I agree with avoiding unnecessary code. Most of my work over the past ~12 years has been on high throughput / low latency network servers, which I guess falls into the abysmally small fraction of problems that need them, because they sure have been super helpful :). (I guess I should also note that they're even easier to use in managed languages, because you can avoid all the additional subtleties of the SMR crap you have to do in unmanaged languages like C. Technically, I guess you also don't need the unsafe/float128/struct hack to implement most lock-free algorithms in Go, but that does mean that you're going to copy literally everything, which means tons more allocations and lots more work for the GC.) Moving on to the type inference problem, I think the reason I don't see `return &amp;{}` as very different from `foo := bar` is because the latter is often a result of an assignment from a different package. So for example, say I have package foo: package foo // Frob a foo, and return a thing func Frob() (Thing, error) { // Something useful would probably be here. return thing, nil } And then you implement a program that uses my foo frobber: package main import ( "fmt" "os" "github.com/dhobsd/frobber/foo" ) func main() { if thing, err := foo.Frob(); err != nil { fmt.Printf("Couldn't frob: %s", err) os.Exit(-1) } } Later, a third party is looking at your main package, and doesn't know anything about my foo package (other than you're obviously using it). They know How do they know that `thing` is of type `foo.Thing`? You might scroll around and see that it implements sort.Interface, but now you have to wonder what foo.Thing is a collection _of_. Or maybe it implements some other interface from a different package that isn't part of the standard library, and you're not familiar with what that interface says about the type. And what if the LHS of the assignment is called `t` instead of `thing`, as is relatively common in Go code? So the solution here is to run a local godoc server and read up, because my frobber/foo package has like 20 different files and you don't feel like grepping. You'll for sure get the information you want; it won't take too long, and the names definitely helped you do that. But the type information was never really present in the code, and you had to interrupt your focus from the editor to figure that out. In larger Go projects (certainly several of the ones I've seen in my time at Google), I find myself spending a lot of time switching context between my editor and my browser to figure out what the type of a thing is, and what I can do with it. This occasionally gets me out of Flow state (if I've managed to get there), and that's truly frustrating. I don't see `return &amp;{}` as any worse than this. Indeed, I even see it as a little better: all I have to do to figure out the type is go to the scope of the function or method of the return. I might have to page up, but I don't need to leave my editor (unless I need to learn more about the type itself, in which case it would've been nice to already know what the type was before I went looking for it). I mentioned that I'm often annoyed by Go's type inference because of the amount of extra effort I have to expend to figure out the types of things when I'm working in / with unfamiliar code. I guess the only reason I like the "anonymous" compound literal idea is because I guess if you're going to commit to type inference, you may as well go all the way :). (I've gotta rationalize away the cognitive dissonance somehow.) Thanks to you as well for taking the time to engage with me in this discussion. Hope you have a good day as well!
[removed]
I believe it’s used for the interactive, scriptable console.
It be awesome if something like this question was in the sidebar or common FAQ
after you create a Pipe, you then use https://godoc.org/labix.org/v2/mgo#Pipe.Iter and use regular go code to walk the iter and delete the documents you want 
O(1). underlying array not created.
It's cute, but it's too bad it doesn't call the language by its name.
What’s wrong with just using the entire URL for the key instead of its hash?
Great. I just stumbled through that disaster thanks to you. I think I need to lie down and dream about flamethrowers for a while...
That’s really helpful. I use Ngrok before to access my pi via internet. This maybe easier way for most people. 
In plain Go, here: https://github.com/golang/go/blob/master/src/internal/bytealg/compare_generic.go But many common architectures have specific implementations in assembly, like: https://github.com/golang/go/blob/master/src/internal/bytealg/compare_amd64.s
Three shall be the number thou shalt count, and the number of the counting shall be three. Four shalt thou not count, neither count thou two, excepting that thou then proceed to three. Five is right out.
Really curious as to why you suggest a different naming convention? Surely best practice in coding (in general, not go specific) is to make it readable? That being said, I would have preferred using packages to make the variables shorter. So have montecarlo &gt; treesearch &gt; GameNode. So it could be referred as GameNode inside the package and montecarlo.treesearch.GameNode outside of the package.... That is just a preference though.
&gt; Otherwise if rate of revocation is far below than the rate of authentication or new token creation, then a simple revocation list, that is pushed to the backend servers whenever it's updated, is enough to handle the revocation issue. No different from keeping auth tokens on the server at first place
Probably firewall, use WireShark or similar to see if your packets are leaving/arriving on each system.
If you want the ability to revoke, then you have to keep some state at somewhere. The difference between holding revocation lists and holding auth tokens is revocation list would be tiny compared to a collection of auth tokens for every user. It's highly cachable since it won't change quite often. But it's a trade-off.
The following code pipe := storage.myCollection().Pipe([]bson.M{ {"$group": []bson.M{ {"_id": bson.M{"clientid": "$clientid"}}, {"dups": bson.M{"$push": "$_id"}}, {"count": bson.M{"$sum": 1}}}}, {"$match": bson.M{"count" : bson.M{"$gt": 1}}}, }) mP := []bson.M{} err := pipe.All(&amp;mP) if err != nil { } log.println(mP) returns me empty \- \[\] pipe
cmpstring might not be used often. The compiler might do length checks then call memequal or just inline the comparison to determine if strings are equal: https://github.com/golang/go/blob/d11df8baa8c18c7cf14e7286f55ae56f4439d1cd/src/cmd/compile/internal/gc/walk.go#L1256 
What is "link checker"?
It looks like it recursively downloads pages on the same domain, parses out links, and prints out if the links are reachable.
I've been playing around with it some more and its not confined to Windows. When I use chrooted-chromebook with xenial I can send out broadcasts, but it also hangs indefinitely when trying to receive with the `ReadFromUDP`. So, still have no idea.
Parsers and template engines are opposites. One generates HTML, the takes HTML and pulls it apart. Which is it? Also, with all due respect, I'd have to warn anyone considering using this away from considering it. It completely lacks the Go template system's awareness of when to encode things properly, so using this template system will strongly encourage writing insecure templates. Unfortunately, you've traded away not just functionality for this simplicity, but also security. There's a lot of other really highly questionable things in there. I'd suggest just learning how to use html/template. It's actually one of the better templating solutions around, and hard to improve on without breaking them. The only quirky thing is how it handles multiple template files, but that can be worked thorough. And, again, I'm sorry to be so harsh, but it's important that people be told not to use code like this in their projects, because it will hurt them.
Another one: https://github.com/baltimore-sun-data/linkcheck
academical education? no
Aah, that is a shame. It'd be cool if it was more like the I &lt;3 NY shirts, using "Go" instead, like: I❤ GO
&gt; If your application has a lot of revokes going on then you might be better off without JWT. Not a lot. Maybe never. But if I need to revoke access it must work immediately. Frequency of use does not matter, reliability does.
There is no "preference" of Go vs. Golang. Golang is just plain wrong.
The change has been made. Please let me know your thoughts or any recommendations for future designs you may have!
The t shirt has changed. Please take a look and let me know your thoughts!
Thanks. I think it would be cool if the posted included a word "web" to the description they made. I, for one, take the term "link" to mean a phase of building an executable program out of source code.
&gt; If you have stronger security needs than that, I would argue that JWT is not the right approach Who doesn't? What kind of application would be ok to give additional 10 min access to a user who is supposed to be inactive or banned?
I don't understand your concern over a tiny string of the URL when you're also storing the entire response. You're also ignoring the GC cost involved in hashing the URL every time. And casting a string to a byte array is not cheap, so `[]byte(URL)` is actually making a copy of the entire URL on every request. Have you actually benchmarked this? `fnv` is a non-cryptographic hash, so it's probably not difficult to intentionally cause a collision (e.g. find a harmless url like `/home?_=asdfasdfasdf` that collides to `/admin`)
Sounds really interesting from the feature list - will have to check it out. Sounds like if it performs well, that it could make a good distributed embedded cache given the ability to specify eviction.
1. I don't think you need to bother with a mutex for the redis adapter, as redis operations are inherently safe to run concurrently. Also, you're putting a pretty big bottleneck in your cache by making is so only one redis call can happen at a time. Finally, since you didn't use `defer mutex.Unlock()`, if a panic happens in the call to redis, you're mutex will be stuck locked and the cache will be completely frozen. 2. In your memory adapter (https://github.com/victorspringer/http-cache/blob/master/adapter/memory/memory.go#L71), you're unsafely reading from the map without a lock. You should have a `a.mutex.RLock()` and `defer a.mutex.RUnlock()` in there.
thanks to both of you for your opinions :) 
I like it better -- good change!
\&gt; Strings are placed between double quotes "..." and not single quote \(*O\_o js*\). "foo" is a valid JS string literal. \&gt; Strings in Go are UTF\-8 encoded by default which makes more sense in 21st century. Go strings have no encoding, they're just a sequence of bytes. String literals in Go source code are UTF\-8 encoded, however.
[removed]
&gt; Parsers and template engines are opposites. Templates engines do parse templates though.
[https://www.reddit.com/r/golang/comments/8e9zae/strings\_in\_go/](https://www.reddit.com/r/golang/comments/8e9zae/strings_in_go/)
[removed]
I agree with the short duration token. But if i need to revoke a token (refresh token as well), from the serverside. I can't, right? 
I think “...just a sequence of bytes, *interpreted as UTF-8*” is a more accurate way of describing Go’s `string` type. Certain language constructs like range and some casts *do* interpret the raw bytes as UTF-8.
What IDE version do you have? Or Go plugin version? Can you please upgrade to the latest? Or send me the logs/upload them to an issue? Thank you! 
Fantastic, been looking for something very much like this, will spend some time testing it out. Looking forward to the LRU eviction, and maybe gc-friendlier storage (maybe look at BigCache or freecache).
These words are actually governed by personal opinion at this time. I don't think it's safe to say that you can declare this to fall into either category exclusively, because the teens are actually broad to begin with. 
If you're talking about sanitizing user input, then you're right, this tool doesn't do that. I won't add that because it doesn't belong exclusively in this library. Sanitizations for HTML should live separately. If you intend to sanitize for XSS or just malicious stuff, that should be done separately really. The existing template library will not solve for how I want workflow to happen. 
[]rune(string) is another one that assumes utf-8 encoding. Also string(int) creates a utf-8 encoding. https://golang.org/ref/spec#Conversions Section: Conversions to and from a string type 
Yup, that seems right to me. I actually ignored that when I was looking it up because I saw "gc" and assumed it was some garbage collection code, when in fact "gc" is also "Go compiler". Oops.
[removed]
[removed]
Good work
Thanks! TIL about the []rune(string) cast. That is very well in line with the `range "string"` construct. 
Basically my issue is the responsiveness of the editor or the menu. For example you click somewhere inside the editor or you move the caret around and there is always the feeling of missing milliseconds. Maybe it is my personal computer issue? 
It's not an unrelated mistake. I have come across several instances that have similar problems. All the code you need to understand it is there.
Oh wow yeah, I should've know better that it didn't work as I was imagining last night. Thanks for the reading!
&gt; Basically my issue is the responsiveness of the editor or the menu. For example you click somewhere inside the editor or you move the caret around and there is always the feeling of missing milliseconds. &gt; &gt; Maybe it is my personal computer issue? I hear you, but I can't say anything about it, unfortunately. I don't have enough data even to try and guess. That's why I'm asking you to please open an issue on the tracker and let our developers have a look at it. Thank you.
Eventually append() reaches the capacity of the current underlying array. So then it allocates a new array large enough for the live elements of the old slice, copies the live elements, and returns a slice of the new array. That allows the old array to be gc'ed. So as a quick-&amp;-dirty fifo, s=append(s,e) and s=s[1:] works like a charm.
I'm not mocking myself. I'm just pointing out a thing that repeatedly annoys me.
Pre-coffee typo. 
Could you provide an example? I'm just now coming to this thread and the original comment has sadly been deleted
Shameless plug for /r/authn - a subreddit for the new WebAuthn standard. 
Hoping for a transcript
Your playground link is just the front page of the site rather than your code.
Hi! Not sure if now is the time to mention, but you can also use single tick\(\`\) instead of double quote \("\) to declare strings, and this source supports multi\-line string. Is a string declared this way exactly the same as a string with double quotes?
 I have a private repo that performs peer discovery and uses `golang.org/x/net/ipv4` as well, though I can't seem to pinpoint why I didn't try `pkg/net` first. My peer discovery code runs 99% of the time on Windows, so I could have run into the same problem, but I don't recall struggling with it. Commenting here in hopes I'll have time to experiment with using `pkg/net` instead and see if I can help recreate the problem and find a fix.
Actually there are many repos on GitHub including some in other languages. In addition to that, several web services which does the same thing exist. But I made another one from [the feedback in another project](https://github.com/raviqqe/liche/issues/6) because they are not satisfactorily fast and not easy to be integrated into CI processes. The one I made caches connectivity check results of the same URL in order to reduce redundant HTTP requests.
Sorry for using the non-technical term. I just wanted to express my blazing emotion on this project.
[removed]
I think you already found the fix. I fixed the problem by using `golang.org/x/net/ipv4`, and now it works great between Windows and Linux. I tried it last night after seeing this ominous message in the `pkg/net` docs: ListenMulticastUDP is just for convenience of simple, small applications. There are golang.org/x/net/ipv4 and golang.org/x/net/ipv6 packages for general purpose uses. 
Yeah I agree, I I will look into it.
Oh, right on. Was this just a toy library, or did you have a purpose for it out of the gate?
I can only recomend gorm (https://github.com/jinzhu/gorm) wich has an excellent auto migration feature, as i usually just run the stdlib stack.
GORM is the one I see a lot of people mention for ORM in Go. go-swagger is a tool developed at VMware and made available for everyone. As I worked with some of those that built this, I can tell you this is pretty solid. However, I do not know if it builds a server side component or not.. but it uses SWAGGER API spec (or OpenAPI 2.0 spec) to define a server side API that is then called by a web UI like a ReactJS web client with AJAX requests. The most common server side Rest/API framework I see is GorillaMUX. It is more a router for incoming URLs, but works well with handling REST calls. It is similar to using something like Spring MVC or JAXRS on the Java server side of things. You would tie in mux handlers with GORM code to get a sort of JEE like setup, although not quite as robust but from what I have read capable enough to be used in place of Java and JEE... though it runs a lot faster and scales better at the expense of a lack of JEE like capabilities which may or may not matter anyway. 
I usually use Echo (https://echo.labstack.com). Pretty simple and covers a lot of bases. It doesn't cover ORM, and I never really use them, but I have heard of GORM (as mentioned by ozkarmg below).
Maybe if the person wants to do data science but only like python and java are supported
+1 echo
Yeah, I wanted to use it for another program I wrote: [croc, for transfering files between computers easily](https://github.com/schollz/croc#transfering-files-between-local-computers). With peer discovery I can handle a special case when transferring files between computers on a LAN network. Basically, one computer can send `croc -send X -local` and another computer just has to run `croc -local` and it will automatically discover the local machine that wants to send and receive the file using a local relay instead of the default relay in NYC.
I can lookup the content he sent later today and make a new comment, however it will be in like 10 hours
That's similar to my use case. I've written a management agent, and I use peer discovery to have the agents on a local subnet coalesce into a swarm by voting on the most eligible node. They proxy communication back to the control server through the master agent, as well as downloads from the internet. It saves a ton of outbound connections, as well as download bandwidth.
You could check mine,[WebGo](https://github.com/bnkamalesh/webgo). It sticks to standard library signature and a minimalistic framework. 
I love Changelog
[Follow-up post][1] [1]: https://scripter.co/follow-up-golang-quirk-number-strings-starting-with-0-are-octals/
That's pretty cool
[removed]
I'll PM then to you a little late today. Thank you for trying to help, really appreciate it!
I’ve been using echo for the past year and a half and it has never let me down: it strikes a good balance between simplicity and convenience.
Cool, thank you. You can also ping me on Twitter/Gophers Slack (@dlsniper) or open an issue on our tracker: https://youtrack.jetbrains.com/issues/Go and attach the IDE logs (Help | Collect and Show Logs in...), or I can send you my e-mail, whatever is easier for you.
What does premature mean in this context?
If is the keyword
I would even dare to say Typescript (i.e. Node and some Vue.js) or Clojure+Clojurescript (or re-frame library) are superior for web development as they don't divide backend and frontend.
Yeah. Go isn't a very good choice for generic web development, I do agree. 
I've been using Echo for the last month and it gives you a good framework to use when you want, and allows you to easily add custom middleware where you need it.
short and on-the-nose. I like you. Have an upvote:)
I gave up and joined the "enemy" :) https://github.com/wolfeidau/cognito-vue-bootstrap It's orders of magnitudes simpler if you do it the JS way and it just works. Maybe you can study the code in there https://github.com/wolfeidau/cognito-vue-bootstrap/blob/master/src/cognito/cognito.js and learn from the enemy ;) but I didn't bother once I got it working. Good luck!
99% of ordinary webdev is IO from browser to database and reverse. If you use Go your data structures will consist of struct tags more than 50%.
&gt; Stephen Grider's udemy course? It is good. I took the course. it is good for beginners and intermidiate levels.
https://github.com/thechangelog/transcripts/blob/master/gotime/go-time-77.md
`go fmt` ffs.
Blaze my 56k dial\-up modem.
I've started using 'aah'. Seems to tick a lot of boxes, and the dev is responsive to questions &amp; issues. It's missing a few things, websocket and sse being the main ones for me, but the dev is owrking on those for the next release. [https://aahframework.org/](https://aahframework.org/) At the very least it's worth a look.
Yes, definitely try Echo. It reduces some of the boilerplate code you have write.
Quick link to make it easier to find: https://github.com/go-chi/chi
This is cool, but Google \(et al\) is not going to like duplication of content. That's a SEO bomb.
Hey, sorry I'm not sure I'm folowing. What are you referring to?
He's saying, based on Google's analysis of the GitHub page, it will hurt the page rank on Google search. Based on the article though it sounds like this is more for your own purposes so not a huge issue?
gobuffalo's ORM requires you to have an ID column in every table (just like Django ORM). As for me it disqualifies it completely.
In my experience with web development with Go, the philosophy is to add together a few lightweight libraries that tackle a single problem really well (e.g. auth, ORM, routing) rather than using a “fat framework” doing it all (in Python terms, think of Flask rather than Django). Also, and this may or may not work for you, what works really well is to use Go to create an HTTP API and leave the rest (html templates etc) to a client-side frontend (e.g. React). That gives you the best of both worlds: a fast and lightweight backend in Go with a rich frontend in JS. There are currently two popular ways of providing an API between the backend and frontend: - REST: I personally like to use Chi (https://github.com/go-chi/chi) for routing and general structure. It provides a middleware system alongside many useful middlewares (e.g. request logging, JWT tokens, crash recovery, ...) - GraphQL: Newer technology originally created by Facebook that’s quickly building adoption. There’s a server-side implémentation for Go (https://github.com/graphql-go/graphql) and a couple of client sides implementations in JS (Apollo, Relay). I personally have had a great experience using Go for APIs. Not only it’s fast and lightweight, but it forces you to define (and type) all your inputs and outputs.
&gt; Second, and maybe this relates to the above, why choose multicast over broadcast? I'll give you a couple of of reason from a network pov. * All hosts on the subnet will process a packet with a broadcast address at a kernel level. With multicast you can use multicast addresses to target the machines you are interested in. * Multicast is routable so you can do discovery outside of the subnet if you wanted. * No broadcast in IPv6, only multicast. Please don't build new applications using broadcast or layer 2 discovery ~ Your friendly network engineer
Would be great to include it in our overview https://blog.inten.to/cloud-sentiment-analysis-vendor-overview-32d4bdaaf0c3 However, we'd love to have starting tier of ~$20 :-)
The idea is to keep the memory adapter discoupled and as fast as possible. My plan now is to improve the http middleware and it involves this hashing issue
Nice sign-up process, very nice design!
Sweet interface, this is awesome. Pretty easy sign up process. Great platform!
1. good observation, it's been fixed. Thank you! 2. it's not needed since the set/release methods already locks for both reading and writing. And "defer" costs a little bit more processing, that's why i don't use it for memory reading/writing as it's not necessary as well.
Regarding your pint 2: The lock is definitely needed here. It's not safe to read a map while another goroutine is writing it (https://stackoverflow.com/questions/36167200/how-safe-are-golang-maps-for-concurrent-read-write-operations), and your locks in set/release only prevent concurrent writes. I hear your point about avoiding defer; I'd probably write your `Get` as such: ``` // Get implements the cache Adapter interface Get method. func (a *Adapter) Get(key uint64) ([]byte, bool) { a.mutex.RLock() response, ok := a.store[key] a.mutex.RUnlock() if ok { return response, true } return nil, false } ```
Really? OOP patterns make generic web development a lot more fluid in Python or any other OOP language than Go. But I guess it's use case specific.
Really! Go has OOP, it just doesn't support inheritance. Personally even in my Python code I tend to favour composition over Inheritance, because I find composition easier to reason about as the abstractions get bigger, than Inheritance.
the deadlock is because filterLinks never finishes
i get it. Also go func\(\) in main never finishes too
I guess my Google foo is good tonight https://discordapp.com/invite/0f1SbxBZjYq9jLBk
[removed]
Consider using alternatives that aren't harmful to their users' freedom and privacy.
Pour vodka and set fire on it.
Is the gopher slack not enough? 
I've done it. I can't speak for what's happening at the kernel level but at the level where I've been able to detect packets (wireshark) they went to specific machines on the network, but I'm hesitant to say that with complete confidence because of how hardware or OS could have effected it.
What's wrong with `time.Format()`?
No it's not. Otherwise all articles from WSJ, New York Times, AP, Reuters and so on would be "SEO bombs". Duplicated content means running many copies of an article on the same site.
People dislike it because it’s different. I’ve yet to hear an actual argument for what is wrong with it other than “I like my yyyy”. 
How exactly is Discord harmful to the freedom and privacy of their users?
[removed]
Is that spaces, or tabs? The standard for Go (as produced by `gofmt`) is to use tabs for indentation, not spaces. I feel like maybe you are using the word `tab` to describe indentation, but `tab` is a character.
I pressed tab (the button) when I needed indention (like all normal people). I would press enter in Atom and it would auto-indent. 
[removed]
Does that icon belong to an nba team?
 /Users/**thuglife**/dev/parser.go:30 haha, love it
`chi` for sure! it's amazing.
I have to look up the format string pretty much every time I use it. I don't find it obvious or memorable, especially because while the month and day are 1 and 2, the year is 6? Even the ordering of the month first and then the day is pretty American, where a lot of others would put dd/mm. Why not follow ISO 8601 and do 2001-02-03 16:05:06? 
Tabs are superior to spaces for indentation, and are the standard for Go, you'll get used to it.
fwiw, https://github.com/araddon/dateparse added the ability to create a Go date format string by parsing a sample string: https://godoc.org/github.com/araddon/dateparse#ParseFormat That should allow you to specify the format string in a more intuitive way.
I find that I have to lookup the formatting rule regardless of which system I use. Go's just gives me a better idea of what the end-product looks like.
Uh, ok, I thought I was being specific. I saw a UDP broadcast, in wireshark, on the machine with the IP address that I broadcast to and no other machine. 
Yes, given the requirements, you are correct. But again as a network engineer: 1) Never assume your subnet == locality. We run a subnet per rack, so this wouldn't work outside of a rack. Your network topology should be able to change without your application changing. In fact this is a number one complain from network engineers is shitty applications that make bad assumptions about network topologies and have silly requirements like (must be on the same subnet). You can control the scope of multicast with a TTL option to control the locality if you need, you cannot extend broadcast outside of the subnet. Now the actually use case depends on your environment. You can make different assumptions depending on your network and systems so a dumb udp broadcast may be fine, just know it's limitations and why your local network engineer is cursing all the time.
Well I do use tabs since beginning, its just the way GitHub shows this code is gross
Doesn't D-M-Y have the same problem?
The content algorithm post-"Penguin" takes into account, and exempts, Associated Press content. Source: I used to work for a newspaper.
The actual size of a tab is dependent on the thing that is viewing the tab. In this case GitHub is using the *standard default tab size* which is 8 characters. For example, if you print you code it will most likely also print with that 8 character tab size as most printers define a tab as 8 charters in size.
I'm all ears if you have concrete suggestions.
Try godog https://github.com/DATA-DOG/godog/ We've been using it for the past couple of years.
[Because I've used strftime a million times before](http://fuckinggodateformat.com).
I thought lock/unlock was for both reading/writing, even because I didn't get any data race warning in tests or benchmarks. But you are right, in godoc it says it's for only writing as well. I've fixed it already!
The initial idea was to run eviction in background and it would call `Release()`, but then evertyhing changed \(capacity shouldn't be exceeded for example\) and I kept the goroutine \+ channel uselessly. Thanks for the notice!
There are certain formats that are not possible to do with `time.Format`. For example, the git storage format requires `%s %z` (unix timestamp followed by numeric timezone), which [doesn't work in Go](https://play.golang.org/p/Gnk6bBtc3jT). I stumbled over at least one more example, but I can't remember where right now. Personally, I'm still kind of shruggish about the Go way to do time formatting; I think it's probably fine having to resort to other means when it fails you. But I *do* think that the approach of heuristically trying to parse out a format from the layout string (instead of using a well-defined and unambiguous mini-dsl, like `strftime`) has real problems in that the heuristic can fail and if it fails, it produces confusing and hard to debug results.
You made mistake which is described in the 5th one in this article: https://go101.org/article/concurrent-common-mistakes.html
This is a neat idea and a very good article. Thanks for sharing. I have just one advice: You really should handle the errors more thoroughly than just printing them out and continuing. This will most certainly crash your program at one point as you are using returned values that might be invalid.
I had the same problem a while ago. The standard solution is to use *inversion tables* as a representation, though I eventually found an algorithm based on the Fisher-Yates shuffle that performed even better; the body of the loop is just a bunch of data moves with it. [The Stack Overflow post discussing the problem](https://stackoverflow.com/q/39623081/417501) [My benchmarks of various implementations](https://github.com/fuzxxl/permcode) Note that to actually get a single number out of this, you have to represent the inversion table as a single number using [factoriadics](https://en.wikipedia.org/wiki/Factorial_number_system).
yeah, we use a bounce and email verification service which seems to misfire in some cases. please DM me your email address and I can approve it on the backend so you'll have access.
Consider allowing people the freedom of choice to do as they wish
interesting. does it new a go compiler to run? i want to run a executable which reads a spec/test file
Would be much appreciated
Love it!
Maybe I'm not understanding, but my point is that D = day, M = month, and Y = year. Those abbreviations are specific to the English language.
That looks great, but my issue is that I cannot use the Javascript SDK :( I'm using Flutter to build a mobile app (which needs the authentication), and there are no Dart SDKs. The whole thing needs to be done through calls to some API. I can send my username/password to a Lambda function, which gets the token for me, but would I need to do that repeatedly to keep my user logged in? (Due to the short-lived session token).
Yea, that's my only complaint. The fact that the "1 2 3 4 5 6 7" memorization is made more difficult due to seemingly arbitrary arrangements is odd to me.
Add a .editorconfig with indent_size of 4. 
&gt; what works really well is to use Go to create an HTTP API and leave the rest (html templates etc) to a client-side frontend (e.g. React). How do you handle integration tests? I use Go with Echo for the HTTP API, Vue on the front-end, and ES for DB store. I come from Ruby on Rails land where everything is given to me, so I'm trying to figure out the best way to do testing.
You can try [http://exercism.io/](http://exercism.io/) it has many exercises for all level, and it's open source so you can contribute to add new exercises!
[removed]
…so yeah [let's use `async/await` instead](https://vorpus.org/blog/announcing-trio/).
Very fascinating read. For those who only read the title and jump straight to shitposting: It's not a critique of Go in particular, but *all* forms of threading. Go read it.
&gt; and always Wait immediately after the Go calls. No, you wouldn't have to do that. There is an example of an unbounded nursery in his text. The rule is more like you have to .Wait() in the same lexical scope that you created the errgroup in, but g := errgroup.Group{} defer g.Wait() for { socket, _ := listener.Accept() g.Go(func() { handler(socket) }) } Is perfectly legal under this scheme.
Upvote for exercism. I really love it to learn new languages. 
I didn't set a MAC address destination, because like I said I was using go's built in UDP tools. Please see https://golang.org/pkg/net/#ResolveUDPAddr. If using `255.255.255.255`, everyone gets the packet, if using a specific IP only that machine gets the packet. That's all.
I wrote a go program to test whether the second implementation is really faster, but from what I see both implementations are roughly the same.
https://golang.org/pkg/net/http/#Request.FormValue
@dgryski you're killing your own karma with these "go statement considered harmful" titles
&gt; And wrapping everything in a nursery like errgroup doesn't really remove go statements from the language either. Goto statements weren't removed from languages either. *How goto works* however, was changed significantly. And that's what *matters*. Which the article explains in depth. And calling an article that *builds upon* the original "goto statement considered harmful" like it isn't clickbaity either. …both of which the article explains. But why bother reading and understanding it when you can just be smug?
BigCache or FreeCache may become useless. Golang's built-in map seems to work fine, if you use Go 1.9+ https://github.com/allegro/bigcache/issues/59 https://golang.org/doc/go1.9#gc
Yeah, that's the actual answer: Go there, plug in your strftime string, get back a time.Format string, get on with your life.
[removed]
[removed]
[removed]
I said I used go's UDP systems to connect to individual machines or broadcast alternately, that's all. Please stop this conversation.
Very cool, thanks for sharing!
Yes, it’s the Minnesota Timberwolves
Try Gophercises [https://gophercises.com/](https://gophercises.com/) . These are "real\-world" problems with increasing level of difficulty. You can listen to an interview to the site creator at [https://changelog.com/gotime/74](https://changelog.com/gotime/74)
Oh, cool. I'll add a link to those so people can find your approach.
Actually to add additional thoughts, the channel of unbuffered channels could be potentially useful for on the fly worker scaling strategies, to know how many workers are available
I must say: the shuffle approach is brilliant.
I didn't write this article. I don't care about my karma. I generally use the post title when I submit.
Indeed it could be useful, for e.g., to pass worker information before the dispatcher assigns a job. How would you know the number of available workers though? By calling len(chan)?
I was super happy when I found it. Later on, I notice that this algorithm is just an exercise in *The Art of Computer Programming*. It wasn't even brilliant enough for Knuth to mention it beyond an exercise asking you to come up with it.
As far as I can see, this isn't a "new primitive". It's known as the fork/join model, and something that manages concurrency this way is usually called an executor or worker pool. There's no need to invent a new name like "nursery". The point about the "go" keyword not doing error propagation stands, but it is a low-level primitive. You're supposed to use WaitGroup/ErrGroup etc. as a layer on top.
A few more details about how that unbounded example would work in Trio: since Trio enforces that all tasks (= goroutines) are arranged in a tree structure, and each node of the tree can't return until all the nodes under it have returned, generally the way a program terminates is by all scopes terminating. For an infinite loop like the example in the text, this would happen via cancellation. There's no explicit passing of Context objects in the example, but that's because Trio passes them implicitly (more or less, [full details are here](https://vorpus.org/blog/timeouts-and-cancellation-for-humans/)). So instead of `errgroup.Group{}` in trio it's always `errgroup.WithContext(the_implicit_context)`, and then... I guess pretend that `listener.Accept()` has context-based cancellation support and that we pass in the errgroup's context? Something like that.
But I want to search all of github, while godoc/go guru will only work on the packages I've already downloaded to my machine.
Remote work is one of the criteria for company selection, but then you have to put in a location of where you want to work. I'd like to look in more than one location. If that's a thing that can be changed later, perhaps it could be an optional part of the sign up process, or made clear at that point. As it is, I did not complete the process.
Yeah len(chan) is what I was thinking
Good stuff. Did I miss recursive map types? :D type tree map[*node]tree
I just wonder that how you handle garbage collection with BadgerDB. It seems problematic to me: * https://github.com/dgraph-io/badger/issues/464 * https://github.com/dgraph-io/badger/issues/444 * https://github.com/dgraph-io/badger/issues/354 I have used LevelDB in one of my personal projects instead of BadgerDB due to GC design. 
It's not a good value for doing operations on because it could change immediately after reading it, but if you are only checking it to scale up or down, it would be safe to add new workers, and it would be safe to add quit command into the buffer to kill workers as well.
[removed]
Does anyone even use vanilla protobuf package for Go? gogoproto is a no-brainer.
You could probably use https://github.com/gorilla/schema
Yup, was there with LangCategory
Thank you all, guys!
I finally managed to document a bit the resputil package which I've been using for a while now. It lists some approaches to laying out code to better manage errors, or just to handle some common cases with a shorthand function. - The package is similar to errgroup, except that it's a single function (JSON) with a response writer parameter + variadic parameter for the actual response payloads or errors (first non-empty) - The variadic param can be a literal value like error/string/int/struct, or it can be a function that returns an error, skipped when empty/nil, or an interface{}+error (final return), - It formats errors into `{error:{message:"..."}}` I've listed a few examples in the readme, I welcome your thoughts/comments, especially suggestions for improvement. What might be changed in time is the "Success/OK" response payloads, as I'm not sure they are all that relevant. Maybe everything could be packaged into error, with an additional interface to break them down into info/warning/... TBD, so far it's there.
I think the context of the title makes it less likely because it doesn't include the words container type or data structure. Just my opinion, maybe unpopular.
You can also you Netlify which has Lambda support. Pretty cool for this use case
you can compile the test runner either with go test or godog (depends if you integrate it within go test command) -&gt; `godog -o binary` then you can deploy it or move elsewhere, then execute the features like `./binary -f progress path/to/features`. if that was what you asked, to compile it as test binary: `go test -o binary`. When it builds binary, it uses the go compiler and linker tools, so it must locate the **go** comand in your $PATH
my ci servers dont have go/compiler installed thats why I want an independent binary. i will play with godog binary. for each project my tests differ a lot , such as parsing xml/json files and extracting values, check web server status codes, see if files exist, run a program and get return code, etc.. 
I would just get the change the `url.Values` back to a `map[string][]string`, convert that to a `map[string]string` since you probably don't do arrays like `?name=joe&amp;name=dave` (if you do, you'll have to modify this): package main import ( "fmt" "net/url" "encoding/json" "time" ) type Example struct { Int int `json:"int,string"` Date time.Time `json:"date"` String string `json:"string"` } func main() { q, _ := url.ParseQuery("int=12&amp;date=2018-04-25T22:28:56.110Z&amp;string=it+works") // q is map[string][]string, but we probably want a map[string]string, so... values := make(map[string]string) for key, _ := range q { values[key] = q.Get(key) } // marshal it js, err := json.Marshal(values) if err != nil { panic(err) } // unmarshal it e := &amp;Example{} json.Unmarshal(js, e) fmt.Println(e) } 
&gt; First off, are you avoiding using the UDP types in net for reading and writing because using the IPv4 types had better results? I don't know what you mean by UDP types, but I haven't really tried anything else other than what you see in this library. This library worked well for me so I didn't think to try anything else, but would be interested to know what you mean! &gt; what machines have you tried this on? It worked between Windows 10 and Ubuntu 16/18 machines and also between Ubuntu machines. &gt; have you thought about how you might incorporate some kind of security No, I didn't think of that! I think that could be left up to the person using the package - they could use the payload to store a signature that then needs to be validated. I would totally open to suggestions for a general solution though (or PRs!)
I'm not suggesting using literal D-M-Y as a literal format string, just that the order of numbering used for the format string in Go is potentially counter-intuitive for a large number of people. I do generally like having a string that shows you what it's supposed to look like, but it's also nice to have other options.
3:30pm PT happens when this comment is 20 hours and 27 minutes old. You can find the live countdown here: https://countle.com/g-Z183808T --- I'm a bot, if you want to send feedback, please comment below or send a PM.
This fork is based on mdempsky/gocode, not nsf/gocode, so it's more resilant to random breakage when go git master changes. Also includes a few PRs that's been in the queue for a while. It's working fine for me (tm) with vscode right now, any PRs or issues are welcome.
Looks like a promising start! Given its usage/API, I wouldn't recommend this for "general JSON parsing" but I _would_ look into this for specific, high-performance-demanding situations (for example, dealing with huuuge JSON documents). The pointer to channel is a little weird, in the examples: `*c &lt;- obj`. I would love to hear anyone's experience using this.
If the post was titled "Granola, raisins and nuts in Trailmix." would you say that the title was bad because you thought it meant the nuts-and-bolts kind of nuts because it made no mention of fruits?
&gt; Strings in Go are UTF-8 encoded by default which makes more sense in 21st century. It also makes sense because two of the three original developers of go are also the creators of UTF-8 🤷‍♂️
Hi! Thanks for the feedback. I just updated documentation to remove the pointer to channel (which is weird), in fact it doesn't require it as long as your receiver on the `UnmarshalStream` method is not a pointer. Package is currently in version 0.9, will keep working on it (cover edge cases, tuning up and battle test it) and release v1. Contributions are welcome :)
Good job! But what about comparing it with other popular libraries such as ffjson and easyjson? Thanks! )
Damn good resource
is this faster than jsoniter?
How's this compared to jsonitor or easyjson?
There's no heuristic, it's a well-defined and unambiguous dsl. (I think it's a stupid-ass DSL, but still.)
Per their [benchmarks](https://github.com/francoispqt/gojay#benchmark-results), yes.
Per their [benchmarks](https://github.com/francoispqt/gojay#benchmark-results), yes, faster than one at least.
&gt; ffjson Will add benchmarks comparing against them as well. But for decoding it is faster for sure as JsonParser is faster and I benchmarked it against JsonParser :) will let you know when benchmarks are there.
Yeah deffo need against easyjson as that is super fast!
Except Go is a general-purpose programming language, not a specific purpose breakfast... Look you can all be upset and think you're right, or in future you could just add two more words, drop the "everyone must think like us" IDC I'm out
Your `encode_string.go` file and its functions do not seem to handle escaping at all. Does a user of your library got do that manually and if so how would one do that? Either way it should be added to the library.
Great, make sure you use the compile option in easyjson as that is the fastest
Wow, nice. Do you work with Go professionally?
&gt; There's no heuristic, it's a well-defined and unambiguous dsl. Where is it defined? Because it certainly isn't in the documentation of the time-package. It doesn't mention what the lexical tokens are, how they are interpreted or what the grammar is. The "specification" is &gt; To define your own format, write down what the reference time would look like formatted your way; see the values of constants like ANSIC, StampMicro or Kitchen for examples. That certainly doesn't qualify as a spec. `"1136239445"` is a way to "write down what the reference time would look like formatted my way", but it isn't supported and returns confusing errors. No, sorry, it may be a lot of things, but it certainly is not "well-defined and unambiguous".
Goconvey is simpler solution, works well with go tools no need to create testrunner https://github.com/smartystreets/goconvey
He didn’t ask to contribute. 
Short words: some.txt \-\&gt; some.txt.go pacakge yourPackage const = `&lt;content of the some.txt&gt;` 
example 'generate' comment: //go:generate textFileToGoConst -in=some.txt -o=some.go -c=some -p=yourPackage * in \- input file * o \- output file \(defaults to \&lt;input file\&gt;.go\) * c \- constant name \(defaults to \&lt;inputFileTxt\&gt; * p \- package name \(defaults to \&lt;autodetect\&gt;
cbro = Chris Broadfoot adg = enneff
https://www.youtube.com/watch?v=MzTcsI6tn-0
It is true both for T is pointer type or a non-pointer type. 
I know, but shouldn't it be equally irritating that the person links to the same resource ([url.URL](https://golang.org/pkg/net/url/#URL)) that I already linked in my question? Isn't it clear enough that I am aware of it, I read it, and yet it doesn't solve my problem?
&gt; Covering the cases shouldn't impact performance much. I wouldn't be so sure. String escaping being costly would not be surprising at all.
https://www.abbyy.com/en-us/ This software worked well for extracting data from forms, like with many fields and underlines and logos that would screw up Tesseract. It worked pretty well. This was a few years ago so there may be better stuff out there. I know there's a bunch of APIs for it too.
https://www.google.com/search?q=discord+selling+user+data&amp;oq=discord+selling+user+data&amp;aqs=chrome..69i57.7919j0j7&amp;sourceid=chrome&amp;ie=UTF-8 Honestly there isn't anything explicitly showing that they directly sell user data or do anything malicious with it. There is a lot of official communication saying that they explicitly do not. So I suppose it's up to how much an individual trusts discord, like any other system you're putting your information into.
Especially when troublesome usage of `unsafe` one of the other sources of its massive performance gain: https://github.com/francoispqt/gojay/issues/3 If it can soundly trounce existing decoders after it supports the full spec _and_ addresses these problems, I'll take a look, but for now this is misleading benchmark hype.
I anticipated an episode about Russ' proposal for package management. Even if it wasn't an in-depth conversation about the topic, it was great to hear Russ talk about the journey to package management and modules.
What happened to Andrew Gerrand?
Looks like a good candidate for fuzzing.
"I AM THE MACHINE!"
wut
I think you are looking for the encoding/json library, to fill out go structs with json data. Anyway it is easier for me to understand if you explain what you are trying to do at a higher level, ignoring all the technical aspects. 
It's so... soul less. It's almost a parody. In fact, I think something like this was on Silicon Valley. Can't wait for the website redesign, Go will finally have something Generics.
LONG LIVE THE GOPHER
Wow yeah bring back the Gopher already
Forget features, market share, yada yada... You know a language has truly matured/lost it/made it^* when they start talking about branding ^* *Depending on your point of view*
It looks like a logo for a takeaway restaurant 😂
Where's the gopher?
&gt; The presentations are available as Google Slides presentations. We chose Google slides as it is easy to share and maintain updates. People are welcome to port them to keynote, powerpoint, etc. What about [present](https://godoc.org/golang.org/x/tools/present)? Would seem appropriate to have the canonical Go-presentation-tool use the canonical Go branding.
I really, seriously thought this is some sort of late April fools joke or something. It's so comically... corporate, I guess.
Branding page from the design company: http://within.us/google-go/
This is exactly what I am trying to do. So lets say I have a JSON struct with key value pairs of a User object (firstname, lasname, pass, whatever) &amp;nbsp; I need to create a struct out of that and have that struct rename basic CRUD operations for Hyperledger. What it boils down to is injecting a variable from a JSON object into a function to rename that function. &amp;nbsp; Default functions are like this: &amp;nbsp; func (t *SimpleAsset) Invoke(stub shim.ChaincodeStubInterface) peer.Response { // Extract the function and args from the transaction proposal fn, args := stub.GetFunctionAndParameters() var result string var err error if fn == "set" { result, err = set(stub, args) } else { // assume 'get' even if fn is nil result, err = get(stub, args) } if err != nil { return shim.Error(err.Error()) } // Return the result as success payload return shim.Success([]byte(result)) &amp;nbsp; I just need to replace the word "asset" with whatever the name of the struct is that gets created from the JSON object.
Yuck.
Looks like we got some generics
I don’t mind he slide deck, most of the design elements seem fine. It’s mostly the logo which is dire. I can’t believe any kind of iterative process came up with that. Dull and uninspiring.
Doesn't look like they're taking the gopher away, there's a section dedicated to it in the brand book.
Little late on April fool's day, Google
&gt; Go community members are welcome to use [the Go presentation theme] for their own presentations. [...] The slide themes are licensed under a Creative Commons Attribution-ShareAlike 4.0 International License. Does this mean that if a Go community member uses the slide theme for a presentation, they must license that presentation under the same CC license?
Same as with the Go font, I disagree with the detractors. Certainly it's not a profound design, but it's two damned letters. And I think they look pleasant together. "soul less"... What the hell should be done to two simple and similar characters to add "soul"? Should they be animals or some other living thing? What would "soul" mean otherwise? Unrefined?
Jordan, Jesse ...
I think it's equally pointless to 'brand' a programming language as it is to worry about them branding the language. As long as it continues compiling and doesn't burn down production servers I really don't give a single shit either way. [*insert generics joke/dead horse beating here*]
I disagree. It's simple, yes, but it conveys "Go"-ness very well. It looks a little throwback 90s Plan 9-ish, but also like the gopher's eyes and also like an infinity sign. It's also very flexible, so you can imagine adapting to a wide variety of contexts. It's pretty much exactly what you want in a logo. 
Hi everyone, I'm the author of the post and will check comments from time to time. Happy to answer any questions I can. Part 1, if you missed it, is available at https://blog.wallaroolabs.com/2018/04/adventures-with-cgo-part-1--the-pointering/
OK, I'll stay with Java...
Ask him on the stream!
If you open the slides, you will see that gopher is still there
[removed]
I had to check it was not, in fact, April 1st. It wasn't :(. 
Hmmmm, Materially similar. As long as the Gopher remains; it's whatevs.
Unfortunately, it's scheduled a bit late for me being in Europe, I'm about to head to bed just now. Hope the stream will be archived, I loved the Hacking with Brad and Andrew videos.
[???](http://within.us/wp-content/uploads/2018/04/go-logo-maincover.jpg)
I liked that the Go logo/mascot was different, I always thought of the Gopher as an anecdote. Most of Go code runs on massive-scale cloud infrastructure etc. and it still has this cute little thingy as a mascot.