I’ve been using Python since 1994, and I would say it’s the opposite. We live in a world where Moore’s law is dead, single-core performance is advancing at a glacial pace, and apps need to be optimized for multi-core. Slow interpreted languages with deficient multithreading like Python are not a good fit for this new reality. Go’s value proposition is it has 80% the speed of C and 80% the productivity of C. 
[I mean the actual theoretical background behind it.](https://en.wikipedia.org/wiki/Turing_completeness)
&gt; What can you do with GO that you can't already do with python? With enough code, any Turing-complete language can (by definition) do anything that any other Turing-complete language can. So the question isn't so much "what this language can do" as "what this language makes easy." From my vantage point (and I'm even more of a beginner in Go than I am in Python) Go has two strengths over Python: 1) Being able to compile down to a proper .EXE 2) Setting up web services quickly using the standard library
*:gets spanked..in German:*
Only Japanese do animated ones though..
And how easily the code can be debugged and maintained :) 
Python is better in the sense that it has a longer history, therefore more libraries are built for Python than Go. The number of libraries that are available to us has nothing to do with the language itself. It sounds like you are wondering if there are GIS mapping libraries that you can easily grab and build an application with it. I suggest that you search on Github and there are probably some projects that can be useful. Like others mentioned, the performance that you can get from Go is many times of Python. The traffic on the web is only getting heavier and heavier, and it's a wise decision if you pick a language that enables your application to scale easily, so you don't have to re-write the entire thing in 3 years.
SIMD is parallelism, not concurrency.
Oof, guess I totally misunderstood the concept of Contexts then. If that's the case, how would I pass the context of the Open Tracing span over RPC? I want the new spans in the RPC call to be aware of their parent.
I attempted to copy the method they use for GRPC but for Thrift. (https://github.com/go-kit/kit/blob/37dd21e10ccb4761e161e7264a5984f770ea18a5/tracing/opentracing/grpc.go). Based on the other comment, does this mean there's no way to pass the span information over the wire via context??
As far as I understand the jargon, you can have concurrency without parallelism (e.g. asyncio), but not parallelism without concurrency. In general, I think we need a better umbrella term for this stuff because leaving SIMD out of our thinking is a mistake. There are basically four ways of doing stuff at the same time: you can have multiple CPUs/cores doing different things, you can have IO being handled by a controller of some sort, you can do matrix math in parallel on a CPU or GPU, and you can do timeslicing between tasks. The big push towards async helps with IO and timeslicing, but doesn't really do anything for using multiple cores. Go is good at distributing tasks across cores, but doesn't have much native matrix stuff. C/C++ are good at matrix stuff but kind of a nightmare in general. No one is good at everything.
For Go, the primary reason is that we have to drop support for old processors. There are tradeoffs between adding another compile time environment flag, and making the runtime dynamically detect the CPU and run different instructions. Feel free to subscribe to https://github.com/golang/go/issues/25489. 
Based on [this](https://github.com/opentracing/opentracing.io/blob/master/_docs/pages/api/cross-process-tracing.md) it seems I have to include the span context within the Thrift object itself?
Go’s value proposition is it has 80% the speed of C and 160% the productivity of C.
I use Go and Python together. If Python wasn't so old and established, all the ML/NLP would be written in Go, leaving Python with no purpose. This is Python's future.
To be honest, in most of the ways that people mean, it's neither. It's just some specialized CPU instructions that do more in one shot than other CPU instructions that run more quickly, if you can meet their requirements for execution.
There are a few parts why I think this is not the correct way. I understand that the code is for illustration purposes but I disagree with some parts. - Use of globals, especially databases as global. This is an anti pattern in my opinion. - Not abstracting the database in the handlers, this way there is a dependency between the database queries and the posts. Would love to see a more clear seperation using interfaces for interacting with posts. - Hardcoded credentials for this example this is not a problem but in general you don't want to hardcode things like credentials or database URI's - In the routers functions routes are added to the global router, afterwards this router is returned. It is not really clear why the return value is needed here if there is a global. Personally would omit the global entirely and construct the mux in the function or possibly as a parameter. - the `Logger` function also makes use of the global router, maybe I'm repeating myself now but I think it's pretty clear that these globals are causing a lot of confusions and potentially problems in the future. The `Logger` function is also not reusable. - The makefile feels a bit unnecessary, there is only one command in there which is the build + execute step. I would leave it out if possible. these improvements struck me when I quickly looked through the code, there are perhaps more things that can be improved. I would advise you to take another critical look at the code and apply changes where possible. NOTE: English is not my native language. 
You can compare any type of data using the bytes package [1]. [1] https://golang.org/pkg/bytes/
You can compare any type of data using the bytes package [1]. The origin of the data doesn't matter _(binary table, log, file, etc)_. [1] https://golang.org/pkg/bytes/
I feel like you should take everyone's advice on here with a grain of salt because we all obviously really like Go and most of us prefer Go over Python. \&gt; My main impetus for learning GO was for TensorFlow My impression was that the TensorFlow Python API was more mature than the Go API, so I'm not sure I understand this argument. \&gt; I’m coming from geology and not computer science. I guess it partly depends on what you are trying to accomplish, but if you are just doing data analysis or something, Python should be practically sufficient for all your needs. There is nothing that you can accomplish with Go that you can't with Python. Having said all of that, IMHO, Go is much more enjoyable to program in than Python if you like computer science.
&gt; libp2p, which feels oddly modular and far too verbose in all the wrong ways as though it was ripped out of IPFS. It was quite literally ripped out of IPFS. :) I'm sure the libp2p team (and I) would appreciate more specifically constructive feedback on what kinds of problems you're seeing in libp2p? What kind of actionable steps would make it better? Is it verbose in the sense that the protocol itself is too chatty? Or is the end-user API not ergonomic enough? &gt; When dealing with security and performance, Noise is opinionated in having developers work with friendly and concise abstractions over battle-tested, high performance, and secure technologies such as Ed25519 signatures, KCP, glog, and protobufs. Curious to read more justification on why these opinionated decisions are good decisions. For example, why is KCP a good thing? I've seen projects eagerly switch to KCP only to later undo all that work and switch away. Here is one example off the top of my head, but I've seen others too: https://github.com/syncthing/syncthing/issues?utf8=%E2%9C%93&amp;q=KCP
gucci
Are you talking being able to scan the body of any type of data? package main import ( "bufio" "bytes" "fmt" "io/ioutil" "net/http" "regexp" "strings" ) const Search = "Title:" const RegexPattern = `Title: (\w+)` const Test = ` Lorem ipsum dolor sit amet, consectetur adipiscing elit. Integer fringilla neque libero, quis sollicitudin mauris ornare non. Etiam dictum rhoncus dolor, id laoreet ante pulvinar et. Ut ultrices tincidunt elit, in dapibus dolor. Vestibulum luctus ultrices tellus sed malesuada. Quisque tincidunt mauris quis dui feugiat venenatis. Nullam a gravida mi, id aliquam ipsum. Cras pretium ligula odio, blandit ultrices tortor gravida in. Suspendisse dapibus imperdiet varius. Integer sed euismod massa. Maecenas et sem consectetur augue congue tempor. Pellentesque ut vehicula nulla. Pellentesque eget urna nec purus tincidunt interdum. Aliquam semper justo augue, sit amet interdum nibh hendrerit nec. Quisque porta bibendum sapien eget consequat. Quisque id dui lobortis, facilisis magna eu, molestie lorem. Vestibulum accumsan fermentum odio, nec imperdiet tortor. Suspendisse varius nec mauris sit amet ullamcorper. Suspendisse id interdum orci. Fusce aliquam imperdiet metus, vitae euismod est. Praesent mollis accumsan sollicitudin. Donec iaculis tincidunt quam, ut accumsan dui tincidunt porta. Aenean venenatis at ligula sed lacinia. Proin semper leo id enim ullamcorper, ut mattis odio dignissim. Nulla commodo libero sapien, ac scelerisque sem posuere blandit. Vestibulum commodo, risus sit amet sagittis tincidunt, dolor enim placerat diam, id maximus mauris purus non dui. Sed sit amet tortor molestie sapien laoreet tincidunt. Duis et nulla non mauris sollicitudin vehicula id quis risus. Vivamus placerat placerat est et venenatis. Vestibulum consequat, velit in sagittis dapibus, dui mauris feugiat diam, quis rhoncus risus dolor a risus. Ut feugiat aliquam vulputate. Aenean dui lacus, aliquet a tempor dictum, tempor a nulla. Pellentesque et dignissim ante. Pellentesque convallis ac tellus id faucibus. Nulla eleifend Title: MyTitle posuere ligula sed vulputate. Suspendisse sagittis sit amet nisi at feugiat. Aenean malesuada aliquet arcu eget consequat. Cras quis commodo arcu, quis ornare magna. Nullam sed fermentum mauris, et commodo nunc. Mauris sollicitudin nisl ex, et convallis ante porttitor non. Vestibulum mauris tortor, ultrices eget nulla at, aliquet gravida nisl. Phasellus posuere, elit nec porttitor rutrum, nisi purus finibus odio, ut efficitur neque ipsum eu orci. Aliquam vel magna auctor, bibendum quam interdum, ullamcorper libero. Curabitur varius nulla non augue aliquam commodo. Etiam facilisis, ante eu suscipit sagittis, metus ligula porttitor nulla, vitae aliquam nibh leo quis est. Fusce laoreet turpis leo, sit amet finibus neque sodales eget. Aliquam aliquet neque vel aliquet accumsan. Ut a elit pulvinar felis aliquam elementum tempor quis risus. Nulla eu ullamcorper erat. Sed porta ut mauris commodo dapibus. Curabitur ac sollicitudin lacus. Vestibulum ullamcorper euismod dolor sit amet ullamcorper. In dictum, lacus ac commodo mollis, sapien sapien dapibus velit, eget lacinia quam risus vitae mi. Vestibulum laoreet fermentum dui, a iaculis nisi gravida sit amet. Pellentesque elementum vestibulum risus sed sagittis. Vivamus viverra libero urna, non dignissim lectus vulputate molestie. Vivamus pretium enim nec lorem rutrum elementum. Praesent enim tellus, molestie sit amet mattis nec, maximus eget ligula. Curabitur vitae mauris varius, aliquet nunc nec, luctus odio. Aenean nec euismod nisl, nec interdum neque. Maecenas ultrices accumsan tortor eu bibendum. Aliquam at rutrum velit. Fusce euismod commodo enim, vel dignissim elit blandit in. Suspendisse ut tincidunt mi. Integer dictum imperdiet arcu, sit amet ` func FindTextInStream(res http.Response) string { reader := bufio.NewReader(res.Body) search := []byte(Search) pattern, _ := regexp.Compile(RegexPattern) for{ l, _, err := reader.ReadLine() // err does return io.EOF so in reality not all errors are equal in this case if err != nil{ break } // can't have the data we need if !bytes.Contains(l, search){ continue } result := pattern.Find(l) return string(result) } return "" } func main() { body := ioutil.NopCloser(strings.NewReader(Test)) res := http.Response{Body:body} fmt.Println(FindTextInStream(res)) }
You'll probably have to read the reader, at least partially. You can use [`bufio.Reader`](https://godoc.org/bufio#Reader) to wrap your reader, then keep [peeking](https://godoc.org/bufio#Reader.Peek) (increasing the peeking size) and match against the peeked `[]byte`, until you find a match (but since your regexp you might want to do another loop after finding a match because you might be in the middle of the match) or you reached `ErrBufferFull`. This is assuming that you still want to use the reader afterwards. If not, you can just use [`bytes.Buffer`](https://godoc.org/bytes#Buffer) and keeps reading chunks into the buffer and match against.
Hence [pflag](https://github.com/spf13/pflag), which is basically the standard Go flag library but with support for long flags.
[Current version of same standard](http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap12.html).
Wow, that is quite the application framework.
It's C, but with automatic memory management, and design elements taken from the Modula series of languages -- packages, channels, interfaces, fast compilers due to language regularity.
Glad to have minification integrated at last rather than having to run a separate pass.
I guess so. I'm glad that you seem to like it. And I am also very glad that I now know how to write reusable code in Go using reflection or interfaces. I'm going to improve my source! :D
while testing-oriented this package may be of interest: [https://godoc.org/github.com/google/go-cmp/cmp](https://godoc.org/github.com/google/go-cmp/cmp)
Does setting [AllowNativePasswords](https://godoc.org/github.com/go-sql-driver/mysql) to true also work for this?
&gt; I'm sure there's somebody smarter than me who will point at LISP or COBOL or something like that as the origin of the convoluted syntax languages Lisp is the exact opposite. Lisp has very little syntax, very simple rules. Common Lisp can get a bit complex because it adds a macro engine, but the core Lisp syntax is about as simple as you can get. (Well, except for Forth, which is even simpler.)
Now let's see a Go + GraphQL + MySQL build? 
You might have to do the work yourself, but you should be able to write whatever you need for span propagation into the thrift THeader: https://github.com/apache/thrift/blob/master/doc/specs/HeaderFormat.md and https://github.com/facebook/fbthrift/tree/master/thrift/lib/go/thrift might be worth a look
https://www.terraform.io
Holy this code scares me. Globals, init, hard-coded db access, useless returns, inidiomatic error handling, possible recourse leaks. 
I could be wrong and no doubt someone will disagree ! but... DoInt() DoFloat etc would seem to be the way, and very possibly the real world code that some other language compilers would produce given some generic source... 
Author here. Any feedback is appreciated! (:
Consider using a scanner set to split on words and skip regex entirely. [https://play.golang.org/p/74Sz3521voD](https://play.golang.org/p/74Sz3521voD) func findNextWord(r io.Reader, key string) (string, error) { sc := bufio.NewScanner(r) sc.Split(bufio.ScanWords) kbs := \[\]byte(key) for sc.Scan() { if !bytes.Equal(sc.Bytes(), kbs) { continue } if !sc.Scan() { continue } return sc.Text(), sc.Err() } if err := sc.Err(); err != nil { return "", err } return "", errDataNotFound }
So something like [this](https://play.golang.org/p/ghE41brRICC)? 
Be aware that you could have type conversion panics like [this](https://play.golang.org/p/AkqvZnMSCVE). 
Yeah it's a completely different system which a huge dependency and complex structer as opposed to this which is a really lightweight library. But yes, I'm aware of terraform. :-)
What's the actual problem?
Looks awesome! Thanks for sharing! 
Thanks for that! So I'll still have to check with a type switch beforehand also. Like [this](https://play.golang.org/p/oqxFe8QS4yM) but it's now starting to look similar to the initial #1 approach again. Unless I'm missing something
Just downloaded it - ran fine. Its has a Python REPL look-and-feel. Is there any way to undefine a variable once defined ? 
Something like this? https://play.golang.org/p/-XYGli3uel1 The only issue is that there's no generic way to add two `Doers` together. In general, that's where generic implementations in Go reach their limit, when they have to work together.
&gt; What folder do you download Go to? Anywhere, the installation path doesn't matter as long as you set the correct GOROOT and _(optionally)_ GOPATH. &gt; Where is your projects folder? In C:/Go or some separate folder? • https://golang.org/doc/code.html#GOPATH • https://github.com/golang/go/wiki/GOPATH • https://github.com/golang/go/wiki/SettingGOPATH &gt; What is a good practice to structure your folders? • https://golang.org/doc/code.html
&gt; What folder do you download Go to? It doesn't matter, as long as you set the correct GOROOT and _(optionally)_ GOPATH. &gt; Where is your projects folder? In C:/Go or some separate folder? • https://golang.org/doc/code.html#GOPATH • https://github.com/golang/go/wiki/GOPATH • https://github.com/golang/go/wiki/SettingGOPATH &gt; What is a good practice to structure your folders? • https://golang.org/doc/code.html
Thanks. I was asking more of a personal preference and philosophy. I will clarify that in OP.
1. `/usr/local` because it's the default [here](https://golang.org/doc/install#tarball) and i have no reason to change it 2. `/home/user/src` 3. https://golang.org/doc/code.html . Go is designed to not have much variation in this regard
Looks promising.
[removed]
This is un-representable in Go's type system. You're looking for parametric polymorphism. An example of this in haskell (which does support parametric polymorphism): newtype Field a = Field a do :: (Num a) =&gt; Field a -&gt; a -&gt; a do (Field a) b = a + b
I have been toying with with this for a while and it's really nice for scripting. You can use go for everything under the sun now: go itself for large/serious applications programs, gomacro for those times where you'd be tempted to use Python (from my measurements gomacro is still faster than Python, albeit two orders of magnitude slower than compiled go), and ng (https://neugram.io/) for when you wouldn't know whether to use Python or shell.
if python and c had a baby it would be go
&gt;if you want to maintain compile time type safety I was hoping to but it's sounding like that's not possible. Thank you for the knowledge!
FYI, [Frugal](https://github.com/Workiva/frugal) is an extension of Thrift that (amongst other features) adds request/response headers by standardizing how they are serialized in the payload.
that’s actually a pretty good synopsis 
do you plan to support other system than Digital Ocean to kind of compete with terraform ? I actually like the yaml syntax. Terraform have their own specific syntax which is never a good thing especially if you want to script again on top of it, example a UI that generate your configuration.
It's hard to propose something without knowing more about the rest of the code. Generally you probably want to wrap the primitives in some type that supports the operations you need, then unwrap the type at the end when it needs to be used. Something like https://play.golang.org/p/UDa5lfm8Ro3, which is a bit rough but could be improved depending on how it's used.
Span context != golang context. This is an unfortunate name given that they are both related to RPC but not the same thing.
Yeah, I think this should be in [awesome-go](https://github.com/avelino/awesome-go) listing. Maybe someone could do a pull request. haha.
are you using it in production? i just discovered about it this past few week and I was quite amazed how easy it is to setup.
… and if you put 4 white spaces in front of your code, Reddit will treat it as `&lt;pre&gt;`.
You can use this [https://golang.org/pkg/go/constant/#BinaryOp](https://golang.org/pkg/go/constant/#BinaryOp) (or look at the implementation).
https://play.golang.org/p/KvGG5Ve0fQT
Hey! Nah man. That would defeat the purpose I think. Which is being a lightweight library. Also, it would be a shitton of work for which I would need a lot of help as I'm doing this as a hobby. :-) But thanks very much. I appreciate the interest! 
Yes . I have a plan to publish my next tutorial about it. How to follow design pattren or beautiful your code. :).
From The Go Programming Language (page 46): &gt;A syntactic block is a sequence of statements enclosed in braces like those that surround the body of a function or loop. A name declared inside a syntactic block is not visible outside that block.
I want to publish step by step. This tutorial is only for beginner. I have plan more about it. 
&gt; is it a feature ? Yes. By definition, ["blocks nest and influence scoping"](https://golang.org/ref/spec#Blocks) &gt; does this have any real-life use ? I believe this question has only opinionated answers. In *my* opinion, extra scope blocks can be confusing to the reader and therefore might cause more harm than good. If you need an extra scope block within a function, your function might be too large. Refactor the block into an extra function (and give it a meaningful name).
You should keep your variable declaration and usage as close together as possible to prevent accidentally using the wrong variable - this is a pretty common mistake to make in languages like Python or Javascript where there is only function scope. Opening up a scope helps avoid this problem by preventing you from referencing variables that should no longer be in use later on in the function body. It's also a hint that maybe the code inside the scope belongs in its own function. It's pretty uncommon to see bare scopes like that in production code. In C++ you can take advantage of scopes with objects that allocate a resource on construction and deallocate on destruction which is tied to the scope the variable is declared in (aka RIAA pattern). However, Go doesn't have constructors/destructors and defer only executes when the function exits.
Thanks. I'll try.
Lemme know if you do, would love to see
&gt; each type's Do() method is slightly different I think there's your answer. Why use methods? DoFoo(a, b Foo) Foo DoBar(a, b Bar) Bar DoBaz(a, b Baz) Baz 
It looks great, but is there any use case for this tool? Why would I use it?
I never had to use it myself. I can easily imagine use-cases existing for generated code, though, where it can significantly simplify code generators if you don't have to keep track of variables to not re-declare them.
&gt;However, Go doesn't have constructors/destructors and defer only executes when the function exits. I use anonymous inline functions for this effect, within the body of another function, to make the defer and clean-ups more granular. This is the closest useful version I can think of to the original example. 
On that note... I actually already have something similar to what you are saying just in binary format and not a library called [Furnace](https://github.com/Skarlso/go-furnace) 
Being Flexible with dependencies is great and this is a relatively good example of it. Create interfaces on the calling site! But creating a dependency to become less dependent seems counter intuitive at best. And why implementing the interface yourself? This defeats the whole point. Let the implementation bring it and use embedding in structs to extend.
Hello and welcome to Go. So let's get straight to business. You do not use the global var routine at all and I am not sure what it is supposed to do. Second you don't spawn any goroutines at all or possibly an infinite amount which would just block. Third I am not sure why you are using cron-jobs as timers. Fourth your range over the channel and the program termination is not good practice. So let's fix this issues: If you want to limit the number of goroutines running a particular task use a semaphore. Dave Cheney gave a good talk about this. If you want to do N tasks a sync.Waitgroup would be better than having a 'delta' channel. The concepts are orthogonal btw. For waiting the time package is probably your best bet. Create a waiting channel in a goroutine and make it also listen for termination signals then do a graceful shutdown. So now the nitpicking: Some functions seem unnecessary and can be written in-place. The wrapper in AddFunction also serve no purpose. ranging over a channel should always be terminated from source (in a pipe chain where this is most common) Comments should have a space following '//' to avoid clashing with magic comments. Doccommentation are not '///' instead you can document anything by putting a comment immediately above its declaration. I hope it helps. If you have any further questions feel free to ask.
It is better to put the go-directory under your user. Never create create directorys at the root of the hierarchy and this also counts for Windows.
The first and most present thing on my mind is templating. When using text/template or html/template you're dealing with a meta language, which isn't like anything you might know if you're familiar with Go. The obvious pitfall is also that the meta language is untyped. You could do the following: - embed [SlinSo/egon](https://github.com/SlinSo/egon) which is an ERB (embedded-ruby) style template language using Go syntax - in fact, it processes the templates and generates Go code, - eval this go code to move it's execution into the runtime (bringing it on the same level stdlib template packages - you don't need to recompile your app for a template change), In fact I'd love some single binary template which produces some output based on a json file and a template file with egon-like syntax. Think of it as [jq](https://stedolan.github.io/jq/) but for rendering some output based on json+template input. I'd *love* if that existed. Single binary download, no expensive node_modules folder (you're saving 100Mb's here, likely), no fragmented dependencies,... I see a lot of use for it in DevOps workflows that *could* be generic between projects, but inevitably include at least the github repo name. Scripting that in bash or Makefiles or something else is, honestly, a bother. While you *can* do it for simple things, they aren't that expressive if you want to use it for something larger, like code generation based on input data. If I'm dealing with RAML or swagger or something like that, I'd prefer (based on my previous experience), to generate any code in a ERB-like template with a familiar syntax. Gomacro opens the door for that syntax to be Go, and not ruby/PHP/Javascript...
It seems that your comment contains 1 or more links that are hard to tap for mobile users. I will extend those so they're easier for our sausage fingers to click! [Here is link number 1](https://stedolan.github.io/jq/) - Previous text "jq" ---- ^Please ^PM ^/u/eganwall ^with ^issues ^or ^feedback! ^| ^[Delete](https://reddit.com/message/compose/?to=FatFingerHelperBot&amp;subject=delete&amp;message=delete%20ID_HERE) 
The first one is solely for installing the go compiler systemwide. Pls use your home directory for your source files!
You should do this probably the other way around. Create the interface 'Doer', implement Do() for every type you want to satisfy the interface.
That's exactly what they are doing.
Noob here. What is AMPQ? When would I want to use this?
Thanks for mentioning blockchain and let me know that it's more than just a p2p lib. I quickly boned up this series of new stuff: Noise -&gt; perlin-network -&gt; Avalanche consensus. Wow, now I have exactly the same feeling as you. Can't wait to see Perlin's core code.
Making a neat structure in routers can be one of the examples like so : ``` user := e.Group("/api/user") { user.Use(session.MustUser()) user.GET("", server.GetSelf) user.GET("/feed", server.GetFeed) user.GET("/repos", server.GetRepos) user.POST("/token", server.PostToken) user.DELETE("/token", server.DeleteToken) } users := e.Group("/api/users") { users.Use(session.MustAdmin()) users.GET("", server.GetUsers) users.POST("", server.PostUser) users.GET("/:login", server.GetUser) users.PATCH("/:login", server.PatchUser) users.DELETE("/:login", server.DeleteUser) } ``` [source code link](https://github.com/drone/drone/blob/master/router/router.go#L58) But its more about beautifying code and not about logic!
What he said. Literally delete every comment. Rename f to something more sensible. var x = 0 should be var x int (initializes to 0) I like the pattern where the main package’s only purpose is to name the compiled binary (maybe handle flags and arguments) and all source code is in separate packages being unit tested. I prefer log.prints over fmt.prints Seems suspicious that there isn’t one error interface but probably just coincidence 
I still don't understand why people want to use this kind of DIC, the lack of type safety is just unnecessary. You can avoid making your whole dependency graph in main quite easily by just making another type to actually make your types for you. I wrote about the pattern I typically use (it's not changed too much, and has been working well in production for a little while now) here: https://www.elliotdwright.com/2018/02/27/how-i-structure-some-of-my-projects/ It's kept main clean and focused, meant we're using constructors, and we've not had to use `interface{}` anywhere with it. There's no magic, it's just completely plain and simple Go. It's more of a pattern than anything else, so doesn't need a library either. What's more, you can have things like singleton instances of services, "factory" services, and lazy-loaded services with it really easily - again, just in plain Go.
This will still only fail at runtime though, right? I just commented on another post about this - all of these kinds of libraries are super unnecessary. You can solve this problem with simple Go, without sacrificing compile-time safety.
I use blocks for documentation mainly. Sometimes orchestrating functions (like a `main.main`, or a `http.HandleFunc`) need to call several dependencies in order to gather the data it needs to compute a value. Sometimes code might be made more readable by declaring a variable and then use a block to assign it the desired value. The reader's eye can follow the main flow of execution in the lowest indentation level of the function. It won't make your code 100% clearer for 100% of your coworkers though. Here's a simple example: ```Go func (u User) ServeHTTP(rw http.ResponseWriter, req *http.Request) { // Extract the JWT claims from the request Context, as injected by the Auth middleware var claims jwt.Claims { var ok bool claims, ok = jwt.FromContext(req.Context()) if !ok { http.Error(rw, http.StatusText(http.StatusBadRequest), http.StatusBadRequest) return } // Both `sub` and `uid` must be non-nil for our JWT to be valid (see user login flow docs) if claims.Subject.ID == uuid.Nil || claims.UserID == uuid.Nil { http.Error(rw, http.StatusText(http.StatusBadRequest), http.StatusBadRequest) return } } // Get the user from the storage, using the user ID found in the request JWT `sub` claim var user User { var err error user, err = getUserByID(req.Context(), claims.Subject.ID) if err != nil { log.Println("getting the user:", err) http.Error(rw, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError) return } } rw.Header().Set("Content-Type", "application/json") _ = json.NewEncoder(rw).Encode(struct { Sub interface{} `json:"sub"` DOB interface{} `json:"date_of_birth"` AppID interface{} `json:"app_id"` }{ Sub: user.ID, DOB: user.DOB, AppID: claims.AppID, }) } ``` 
yes exactly, wiring dependency manually by explicitly defining the dependency using constructor (to maintain consistency) is a recommended way to go. this library doesn't aim to replace that, but just be an alternative for that, that's why I'm trying to make it as strict as possible to avoid silly mistake such as forgot to add the struct tag to possible dependency field.
You can still end up with wiring issues at compile time though, right? I don't see a way around that with a library like this, without using some kind of code generation to be honest.
I didn't know that function. Really useful, thanks!
So I have a \[\]Field that get created from json. The Field can either be uint, int, or float, and everything within that Field is the same type. Currently I'm parsing the json into interface{} instead of their specific types. This is making it difficult to perform math on the Fields later on in the program, because I have type switches and casts everywhere. The code can work like this, but it's becoming hard to understand and I got the feeling there was a better way to do this. In the past I've tried not to use interface{} due to the lack of compile time type safety, and I've grown a bit of a stigma torwards it.
can you point out a specific example for it? because I haven't encounter this kind of problem yet 
* What does the JSON exactly look like? Or alternatively are the JSON formats known ahead of time? * Can you use something else than JSON? * How is the math defined? In code, from web, as command line arguments? * Does math combine different field types? * What are the performance needs? * What are the precision needs? * How often does format change? How often does the needed math change? * What is the code that you would like to write? (Even if there's no language with the syntax that you use.)
[This](https://play.golang.org/p/TEtu4oLef3-) is probably the more idiomatic way to accomplish it. The method should be doing the type checking instead of the caller to ensure more bug-free reuse. 
Seems like it should push images after building them if you want to run in anything other than minikube.
- JSON looks like this: { "Fields": [ { "Name": "blah", "Type": "float", (could also be "int" or "float") "Val": 15, "Multiplier": 0.5, }, .... // other fields ] } And the Type attribute defines the type for the value and multiplier. Later on once I've parsed the JSON into a struct I'll have to do field.Val * field.Multiplier (and in this case I'd get 7.5, which is also a float just like the rest) - The program is reading these values in as config files so they can be configurable without changing the executable. I started with JSON because it's easy to use the json.Decode, but can use any format. - Code defines the math - The math will always have the same types (float * float = float) or (uint * uint = uint) or (int * int = int) - At the moment I'd prefer readability over performance - Not sure on precision needs - Format shouldn't have to change. Needed math can change frequently - I'd like to write code I can understand in a few months.
I know this is probably not what you're looking for, but you don't have to do this conversion yourself. If you call `redis.Values` to get your array of interfaces, you can then use `redis.ScanXX` like `redis.ScanStruct` to convert that into something more meaningful.
Your question as currently written in underspecified. It is not clear exactly what you are getting back, not is it clear how you want the data converted. I suggest getting go-spew, spew.Dump()ing the output you are getting from Redis, and doing the same for a hand-constructed map that is what you want to turn the data into. Them you may get an answer. As it is now, neither your input nor your output is clear, or even particularly guessable.
Really insteresting article, thanks for sharing!
I have few ideas how to solve this... will write PoC-s later (3hours, don’t have a laptop at hand)... also, what is the intended output? A new json file, output on command line, input to another module?
http://eagain.net/articles/go-dynamic-json/ 
Yes, we mostly made it for speeding up development using any preferred local K8s (minikube, docker for mac, whatever). We code against the k8s API quite a lot and telepresence (and others) were a bit heavyweight. All devs usually test locally and we push to a cloud-based k8s through our CI system when we consider the feature ready to be integrated/tested in a larger cluster/prod-like environment.
No rush, really appreciate everything everyone has done already. After a lot of feedback I'm leaning towards using something [like this](https://play.golang.org/p/VRP8lNDPpVh) but am still open to other ways of doing it.
The pragmatic programmer. A must read
Tests, CI, and a report card are certainly things I should add. As for the structure, it’s very intentional and I don’t think it requires anything different from what I have right now (unless the package grows and the architecture changes, of course). Thanks for the feedback!
You can start with a free ec2 instance from amazon. Or open some ports on your home router and serve your app from there. I'm running www.hskhanyu.com from a chromebox under my tv and its running a go api. 
It’s a message queue protocol, the most popular implementation of which is RabbitMQ. The problem is it’s designed to cover a wide variety of use cases, with different rules and message routing patterns, which must be configured by hand. What this package does is it provides the right configuration automatically to provide work queue semantics (messages that are dropped get requeued, one message can’t be received more than once by different processes, etc).
![Demo](https://raw.githubusercontent.com/hhxsv5/go-redis-memory-analysis/master/examples/demo.png)
Regarding deployment, I’ve never dealt with anything other than VPSes, so I have no advice regarding managed services. That said, the VPS route does have the advantage of flexibility. If you choose to go that way, by far, the easiest thing to do is to put nginx in front of your web app process (which could be bare metal or inside Docker) in reverse proxy mode to handle the connections. As for scaling, it really depends on your architecture and your goals and your needs. If your app is a simple backend process that serves a frontend and connects to a database, you could just replicate it to more machines and put a load balancer in front of it, or just add different DNS entries on the same domain for each IP address.
So: m := make(map[string]string) for _, v := range values { nested, ok := v.([]interface{}) if !ok { continue } for _, v := range nested { s, ok := v.(string) if !ok { continue } m[s] = "" } } I'm not sure what the keys and values to the resulting map are, but the above will take the values in the inner array and put them as keys in the map with no value. I don't understand what's hard about this or what you're wanting to accomplish.
I'm a fan of running small apps as AWS Lambda's + API gateway. That way it's easy to scale and you don't really even have to think about the scaling. Auto Scaling Groups for EC2 instances might be an option for you, but unless you know for sure that the app is going to be used right away, I wouldn't spend my money on instances that are just sitting there. AWS ECS is an option too if you can put the app in a docker image, but you run into similar issues as the EC2 instances. Fargate make ECS easy, but is expensive in my experience. The same can be said for GCP compute clusters as well, although the GCP pricing is better, but you will still pay for a server that is just sitting there. Deploying to a GCP kubernetes cluster would allow the scaling that you want, and auto-healing that you didn't ask for. On the same note, AWS now has EKS for kubernetes, but it's a lot more expensive than the GCP option. I have negative experience with Azure, so I won't even try. If you are looking for something to host it local, I suggest a local Kubernetes cluster (use minikube if you only have one server - kops, rancher or a manual deployment if you have an actual cluster you can utilize). If you are unfamiliar with kubernetes, I suggest reading up because it really does make managing apps a whole lot easier at scale.
Here's my solution. I placed a pipe between the response body and its reader, and wrapped the reader with an `io.TeeReader` so it would write to the pipe as I read from it. I wrapped that in a `bufio.Scanner` and scanned lines. After I was done scanning lines, I was sure to consume the remainder of the body (with `io.Copy(ioutil.Discard, body)`) so that the rest of the body would be written to the pipe. if request.Body == nil { proxy(request) } // The body is *not* nil, // so we're going to process it line-by-line. bodySrc := request.Body // Original io source of the request body. pr, pw := io.Pipe() // Pipe between bodySrc and request.Body. body := io.TeeReader(bodySrc, pw) // When you read from body, it will read from bodySrc and writes to the pipe. request.Body = ioutil.NopCloser(pr) // The other end of the pipe is request.Body. That's what proxy() will read. go func() { scanner = bufio.NewScanner(body) for scanner.Scan() { x := scanner.Bytes() processLine(x) } // We're done with the body, // so consume the rest of it and close the source and the pipe. io.Copy(ioutil.Discard, body) bodySrc.Close() pw.Close() }() // As proxy reads request.Body, it's actually keeping up // with the scanning done in the above goroutine. proxy(request) Thanks everyone for the help, it was much appreciated.
I do need the reader afterwards, as I said I'm proxying the request to another server. Check out my [solution](https://www.reddit.com/r/golang/comments/8y12zk/finding_a_token_in_a_large_response_body/e297it0/).
So as I said I'm proxying the request to another server. This means I can't just leave the body empty. Check out my [solution](https://www.reddit.com/r/golang/comments/8y12zk/finding_a_token_in_a_large_response_body/e297it0/).
These options don't really give you the ability to scale like OP requested.
Issue with this (and all the other responses) is that they consume the request body. Check out my [solution](https://www.reddit.com/r/golang/comments/8y12zk/finding_a_token_in_a_large_response_body/e297it0/), it's pretty neat.
The mapstructure library may be of interest: https://github.com/mitchellh/mapstructure 
Hi! `$GOPATH` usage is a thing that confuses us all at one point or another. I’d like to clarify that the directories that live under `$GOPATH/src` are not related to one another in any way, regarding the code that’s in them. Those paths merely reflect the import path of your packages, and not any shared code (not necessarily, anyway). Think of `$GOPATH` as the “golang search path”. As for having your frontend and backend in the same place, unfortunately, the only way to do this currently, is to place your frontend code under your package directory inside your `$GOPATH`, _or_ you could use git submodules to have two independent repos merged under one parent repo, which you can place anywhere you want (but then, compilation of your Go program won’t be straightforward).
Todd is cool. 
no, this switch is to tell go whether it allows native password or not, but not to tell whether it will use it by default.
May I suggest you reevaluate your approaches? I can see you are bringing what you are familiar with in PHP and Node to Go. While I don't think doing so is necessarily "wrong", it certainly makes you fight against rules/conventions that the language already set up. To the developer and designers of Go, managing dependencies by putting everything under $GOPATH brings some advantages, but also disadvantages (or inconvenience). I think you are trying to bring conventions that you are used to from other fields and asking Go to adopt to your convention. This can add frustration and difficulty in developing Go application. Personally, I have tried to bring django and .NET MVC conventions to Go, and found .NET MVC conventions (with adjustment) works with Go better than Django. So my advice to the project structure is: be open-minded about it and learn about it. Once you understand the rules you can play around it as well (which means you can bring your PHP/Node conventions if you still want to at that point :)) Go excels at web service development. Personally, writing REST service code in Go makes me feel like having 2X-3X productivity than writing code in Java Spring, .NET, or Django. I used to use Go for server-side rendering and serving HTML + jQuery code to client, but it quickly got messy and eventually I dropped all the server-side HTML template rendering and Javascript code, and started using Angular for front-end development. My Go code typically only serves JSON data and that is pretty much it. Yes, this means that you'll have to maintain two projects, but this also means less coupling between your front-end and back-end. With this approach, you can easily develop mobile app (in the future) that uses your established services that were written in Go. As for deployment, I used to use Nginx for Go services, but also quickly dropped this approach and switched to Google Cloud (for the simplicity and ease of CI/CD).
I found it funny that all the other books are language-agnostic except the last two. 
That someone could be you.
* Using composed deserialization https://play.golang.org/p/_zFAqz6k13u (see https://medium.com/@egonelbre/specification-types-ed9ddf35ec8f) * Using reflection https://play.golang.org/p/QwO8Cvvzzwh
[removed]
Haven't used in production yet but it's a quality IAP (proxy, not manager). You'll need to hook up your own identity solution(s) though, which may or may not be what you are looking for. They're working on an identity management component, but as I understand it, a stable release is several months out at least. 
This same list, with Go programming blueprints as the last item keeps getting spammed on here
If you know how to use Docker and don't want to touch servers, there are several container management services out there. AWS Elastic Beanstalk might be the easiest to get going. But there is also Kubernetes, Mesos, Docker Compose, and a few others. If you want to have it really easy, check out Heroku. They are a bit pricey, but so easy to use.
Thank you for your reply - makes a lot sense. I too have my backends as exclusive REST API's - you're right it may not be too much trouble to keep them separate. Thank you for your info.
I see what you're saying - almost like using $GOPATH/src as my User/Documents/Code and throwing the frontend data there on a per project basis alongside the backend. I like this approach as well, as someone in the other thread had mentioned. Thank you.
With respect, this is an entire engineering subdiscipline. It's a bit like saying, "Hey I have some copy and images, how do I create a website?" That said, something like Heroku is probably your simplest, easiest way to go from zero to running service.
Can anyone here with good experience vouch for this list or is it just some Medium spam?
Is Todd's Udemy stuff different than his GreaterCommons stuff at this point? I bought 1 of his courses on his site (greater commons), but it was probably $20 extra.
[removed]
I don't think there's a syntax that allows you to do that. Ignoring concerns about optimization, you'd need to use a temporary variable to implement that, e.g. b := biome{name: f.Name()} b.temperature, b.climateZone = biomeCategorization(b.name) biomeList[b.name] = append(biomeList[b.name], b) However, the most straightforward fix here would be to make `biomeCategorization` return a `biome` type instead. It already has the values needed to fill it out. This is assuming, of course, that the real code doesn't have additional complications.
[removed]
It would be more elegant to just return a biome struct from biomeCategorization.
For every languages you can add blocks as you wish (C/C++/Java/Go/etc.), this is a feature. It's an important feature of C++ because C++ has destructors so it's useful to do cleanups (e.g. restrict the scope of a lock), kind of like `defer` in Go. But in Go `defer` works on function level, not block level, so it's less useful (it's also less useful in C/Java/etc.). In languages without destructor, it's mainly used to reuse variable names, or prevent from accidentally reusing variables.
If you haven't identified the leak using pprof have you found another way to be certain that it's a leak in the application and not the go runtime holding onto the memory for its own nefarious purposes/the OS not acting on the release? Similar [to this issue](https://github.com/cockroachdb/cockroach/issues/20078) I'd be curious if the memory get's reclaimed when the OS experiences memory pressure or using [FreeOSMemory](https://tip.golang.org/pkg/runtime/debug/#FreeOSMemory) Maybe you're luck and it just looks like a leak :)
Ok, thank you very much for the insight. Returning a biome type with those fields filled works perfectly (as suggested by [Scott\_Draper](https://www.reddit.com/user/Scott_Draper) too). I was more concerned about not knowing a proper syntax for this \^\^
I have written a lot of REST API's in go. The native http package contains all that is needed for the routing and handling different http verbs. As for ORM, there is this library GORM ( https://github.com/jinzhu/gorm ). I have never been a fan of ORM's because of magic behind the scenes. Native sql library is amazing for use. ( https://golang.org/pkg/database/sql/ )
Thnak you @babbarshaer for your quick answer. But then if you use the Native sql library you will be writing plain SQL. How do you manage to secure your query without matching over-engineering?
I've traditionally built my own ORM, using a pattern that I established back in VB6 days. I've struggled a bit reimplementing it in Go because the language lacks some of the object-oriented features that I've relied on. In Python, I decided to use Peewee, rather than SQLAlchemy, mainly because my needs were simple and SQLAlchemy had a learning curve, or so I read. I prefer keeping my business objects clean, so I don't like constructing them with any storage technology in mind. Instead, I have separate mapper objects from my business objects to the repository. This is less automated than what an ORM would provide, but not a major burden. The repository constructs the appropriate SQL.
`DigitalOcean` is my choice of cloud provider. The simplicity and ease of deployments is much better than in AWS IMO.
If I understand correctly, the main pain points would to write a mapper function which populates your struct obj everytime you fetch an row from the table. You are right that this would result in writing plain SQL statements with logic of creating the structs yourself. I personally like having this kind of code where I can just read the sql statement and understand whats happening under the hood. But there is another great package ( https://github.com/jmoiron/sqlx ) which greatly helps with this. Hope I answered your question ?
theres not nearly enough content posted here to start filtering in that way
It's not possible to assign multiple values returned from a function to struct fields. You are forced to assign them to some variables, then you can use in the struct. [https://play.golang.org/p/RpU2GfxwnKg](https://play.golang.org/p/RpU2GfxwnKg)
&gt;Ive been trying to hunt the leak down with pprof without sucess. From the text
I am not aware of what flairs stand for. Can you elaborate a bit on the issue ?
But in OP you mentioned that you are concerned about the memory consumption, and `io.Pipe` won't fix that (It will save everything you read in memory, because how can it serve the downstream reader otherwise?). With `Peek` you only need to save the part you read into memory, so if the pattern happens towards the beginning of the response body, that will actually save you significant amount of memory (it will be less significant if the pattern tends to appear towards the end of the body).
This looks pretty interessting, did not know about this issue.. I will make an attempt at this, seems to fit the issue Im experienceing! Thanks for your time! I will report asap my findings
Thank you for taking the time to answer me and for sharing all this valuable information 👍
If you're talking about securing against SQL injection attacks, then the same way that an ORM would - using bindvars: ```go tx.NamedExec("INSERT INTO person (first_name, last_name, email) VALUES (:first_name, :last_name, :email)", &amp;Person{"Jane", "Citizen", "jane.citzen@example.com"}) ``` [The relavant docs in sqlx](http://jmoiron.github.io/sqlx/#bindvars)
Thanks, Ive been trying some of these examples but this is more in depth than my tries. I will make a thourugh read and try a few examples in there that I've missed before.
Don't know what Elixir and Go are doing here 🧐
Looks like spam to me.
Sure, flairs are like tags. If you use github they are very similar to issues tag. You can apply one or more flags, sort them, remove them etc. Flags I imagine for the sub might be "Code help\\review", "Jobs", "Announcements" and similar.
I think this could be worthwhile. The flairs then could be decided by the subreddit itself right ? golang flairs could be different from AMA maybe. 
Think about what happens when you call `NewFarm()` 1000000 times in a short time. It may not a leak per se. It may just be 1000000 goroutine stacks waiting to be scheduled.
Any list without Code Complete and CLR's algorithm book, is, IMO, useless.
No need to use *[] variants. https://blog.golang.org/go-slices-usage-and-internals
As a rule of thumb: prefer non-pointer where sensible. It measurably alleviates pressure on the garbage collector. `*[]User` almost never makes sense since `[]User` is already a reference type. `[]*User` also makes little sense in terms of memory savings; it's one pointer per user more than just `[]User`. `*[]*User` lol.
I'm a fan of sqlx: https://github.com/jmoiron/sqlx Makes handling SQL tolerable, without all the bloat of common ORMs. I prefer to write my SQL manually and knowing exactly what is running in my databases.
First of all, please do not name your "getters" with "Get" in front: [https://golang.org/doc/effective\_go.html#Getters](https://golang.org/doc/effective_go.html#Getters) For the ones that return a single user it depends on the case, maybe you want to return nil in some cases, maybe you don't; maybe User has 50+ fields and is too large so you want a pointer instead of a value. For the ones that return several Users just return a slice (not an array) but never a pointer to a slice, and the content of the slice can be User or \*User, again, depends on the usage
[]User is not an array, it's a slice. A slice always has a constant size of 3 words when passed to a function or returned by a function.
I was just looking into this. I assume you want to return a *slice*, not an array. A slice can be thought of as a pointer to an underlying array so it's best to not add another layer of indirection by using pointers. When the function returns, memory will be allocated for a new slice, but not the array. So in most cases you'll want something like: func GetUsers() []User {...}
You're returning a slice, not an array: https://golang.org/doc/effective_go.html#arrays https://golang.org/doc/effective_go.html#slices which changes things a bit - read up :-) 
a slice is already a [pointer to an array](https://blog.golang.org/go-slices-usage-and-internals) so \*\[\]User as a return type is a pretty rare thing to need/use. As for \[\]\*User or \[\]User there shouldn't be any difference in the size of the value passed since you're just passing a pointer (and a couple of integers). As for \[\]\*User or \[\]User from a best practice perspective it depends on what you're going to do with the structs in the slice, if you're going to change them down the line a slice of pointers may avoid pain: ```go user := userArray[0] user.name = "james" user.name == userArray[0].name // true if []*User, false if []User ``` Otherwise passing by value is probably the way to go to avoid any foot gunning by holding refs across go-routines.
Actually I'm writing to the pipe in a separate goroutine while `proxy()` is reading from it, so the body is streamed between the two and never buffered anywhere. I've actually tested this code for my use case and it confirms this -- reading everything into a `bytes.Buffer` got memory up to about 700MB, and this approach peaks at 16MB.
Coming from ruby and using sequel there, it's one thing I miss in Go. None of the "ORM" and database access libs can even compare. 
NewFarm is only ran once, so only 1 goroutine is used. Sorry for being unclear about that. 
The thing that I will add to the other answers is that you need to be somewhat careful about slices of values. My rule of thumb is actually to use pointers to structs unless there is an overpowering reason not to. Basically, passing around values stops making sense as soon as you have a mutable type or pointer methods. It can lead to very interesting bugs if you mix pointers and values, especially when you sort or append to the slice of values. Not recommended :).
I have been using dbr which is pretty great for writing my queries: https://github.com/gocraft/dbr
Thanks a lot for this clarification!
Great article on proper error handling with context!
I'll plug my own library. One person in this thread says that no Go based ORM can come close to sequel in Ruby but I think we do pretty well balancing type safety, speed of execution and convenience. https://github.com/volatiletech/sqlboiler/tree/v3 v3 is a pre-release but it's pretty close to stable. We have semver tags as well. This cannot be used with go get since it's not the master branch just yet. 
&gt; I was wondering what is the best practice KISS. KISS is the best practice. Keep It Simple, Stupid! Don't bother with any of this. Worry about making your program work, before making it fast. Also, worry that you're [properly benchmarking your program's critical sections](https://dave.cheney.net/2013/06/30/how-to-write-benchmarks-in-go) before worrying about how to speed up code. After all, you can't improve that which you aren't measuring.
Also on KISS, and apropos to this thread: &gt; Any fool can write code that a computer can understand. Good programmers write code that humans can understand. —Martin Fowler
&gt;The flairs then could be decided by the subreddit itself right ? Yes the admins can create them. There are no "default" flairs.
A statement like this is meaningless without context. Usability, maintainability trumps elegance every time.
No problem. I don't know your individual code since you can't post it but I thought I'd offer some unsolicited advice on the `Func NewFarm() *farm{ go func(){ UpdateDatabase() }() }` pattern. What happens here if the call to `UpdateDatabase` fails? In general I try to handle calls the DB in thread with the main code path because I very rarely run into situations where it's not important to know if I managed to change the DB state properly. Obviously you might be waiting on the result of `UpdateDatabase` after doing other work you need to do so apologies if this wasn't helpful! 
I\`d like more construction like this: type User struct { Id uint Name string // etc fields...... } func (u \*User) Get(id uint) User { }
oh I overlooked that part. that makes sense.
No need to apologize and I do understand you point. Actually its my example being lacking (sorry). The program is meant to be turned on for months and never close, thats the reason for my approach. There are alot of other structs running, each connected to related Apis and databases that needs to be kept up to date. The idea is that I can initiate the Farm and never again have to remember to call UpdateDatabase. If it would fail in this case there is not many consequences so it only gets logged. The actual function is more like the below, could the channel be a cause for the heap to not release memory, the idea just struck me? However UpdateDatabase does go all the way and exits, that Im sure of. Func NewFarm(a,b,c string) *farm{ errChan = make(chan error) timer = time.NewTimer(60 * time.Second) f := &amp;farm{ A: a, B:b, C:c, } go func(){ for { select { case &lt;- timer: farm.UpdateDatabase(errChan) case err := &lt;- errChan Log(err) } } }() return f } This is exactly how my program runs ( sorry again for a bad example). Any tips you have are well recived and appritiated! So dont be afraid to blast/discuss other solutions and ideas! Again, thanks 
Note that there is also RU version available, in case you're more comfortable with it: [https://habr.com/post/416903/](https://habr.com/post/416903/) It also includes a bonus gopher image. :3 
I would do the following: 1. Setup an outer type for fields that have the same types throughout the JSON objects 2. Setup embedded types that have the correct types for the fields that will have different value types 3. Setup a specific \`Do\` method on the embedded type like: \`Do&lt;Type&gt;(&lt;Type&gt;)&lt;Type&gt;\` 4. Setup a custom Unmarshal method that unmarshals twice (once to find the type, again to unmarshal into the correct embedded type) 5. Setup a generic \`Do\` method like: \`Do(interface{})interface{}\` Then using type assertion within the generic \`Do\` method you can route it to the correct embedded specific \`Do&lt;Type&gt;\` method. Note that this could silently fail, as if your type assertion is incorrect then you'll use the incorrect zero initial value of the embedded type. This can be mitigated by using the specific method (or additional checks within the generic \`Do\` method) [https://play.golang.org/p/zBHJyBKI\_3e](https://play.golang.org/p/zBHJyBKI_3e) I didn't know if you just wanted to multiply the \`Val\` and \`Multiplier\` or if you wanted an outside value to use with the Multiplier... so I did the latter. As with any solution there are some drawbacks to this, such as the double unmarshal, and empty embedded types that seem to take up space. However I think the usage of \`Do\` and the \`Do&lt;Type&gt;\` methods is pretty straight forward though, and works well with setting this up as a \`Doer\` interface. 
What if you're just passing down the REST naming convention to your method names for an API?
Stripe just rewrote their Go library to use pointers everywhere. No more strings in arguments - it's string pointers! I suspect it's partially to decrease memory usage. However, would there be memory savings in a big struct with a lot of uninitialized fields between empty strings and nil string pointers?
Strings already are pointers.
Then that's no "getter"
[removed]
Strings are also reference types so that does not make sense.
[removed]
The example given by OP isn't a getter... It's a top level function for getting users from a database.
Is Golang 2 even an actually planned project? From the way it's been treated, it feels like almost a humorous way to define all the features which we will never have but wish we did.
The main reason I think is so the developers don't have to think about zero values vs uninitialized fields. The AWS SDK is notorious for this.
Track the progress here: https://github.com/golang/go/wiki/Go2 All issues that are labeled “Go2” can be found here: https://github.com/golang/go/labels/Go2 A tip: github is a much more reliable source of info than reddit.
This looks really easy to use while still being very powerful. I'll definitely use this for future projects that need P2P networks. Cheers!
&gt; []*User also makes little sense in terms of memory savings; it's one pointer per user more than just []User. Not in memory savings sure, but this one has legit use cases where you might want a slice to existing references you want mutate. Or if a nil value has semantic significance.
Many sdk's fall into this trap. It is nice with Typescript and Scala where you can dynamically define partial types, and it nicely solves this kind of situation.
I use blocks to make locks more visible: mutex.Lock() { ... } mutex.Unlock()
00b
In the past it was not possible to flair a post using the mobile app. Has that changed?
getter/setter is a convention regarding field access, not instance/pointer initialization. Also, it would be mostly normal for a GET request to be mapped to an http handler which might contain the name "get" (such as `handleGetResource(w,r)`) which then calls something like `NewResource(some, example, args)`. That said, I still might have doubts about some source code if I found a `GetResource` function that returned an instance or pointer.
Why do you recommend nginx reverse proxy? I've never had a problem with Go directly handling connections.
Because OP might run other services in the same box. For example, what if they’re serving their frontend from a Node server? But, mostly, it’s just force of habit, I think. You’re right, if they’re not running other services, or if their architecture is simple, there might not be a need for nginx.
Go does not have [reference types](https://dave.cheney.net/2017/04/29/there-is-no-pass-by-reference-in-go).
Pretty cool, nice write up too. Thanks.
Go does not have [reference types](https://dave.cheney.net/2017/04/29/there-is-no-pass-by-reference-in-go).
I just use the plain database/sql, or if it gets complex I may reach for sqlx. I think ORMs are more harm than good. 
Usability and maintainability all contribute to elegance.
Really sad to see someone like Sam Boyer all butthurt and semi-spamming everything related to vgo, oh well.
I'm excited to see this happening! Thanks everyone that is working on this! I haven't tried vgo/modules yet, but by reading Russ Cox thread, I have convinced myself this is the right approach for dependencies on Go
This reminds me of protobuf3.
Woot! Excited to try this out!
Not really a fan of this. I preferred the dep approach, and think this is taking away control from developers for Russ’ pet project. He had some good ideas, but I don’t think it’s the best approach. Oh well, hopefully it will work out well. 
I can't test right now but your function probably needs to return the C type directly. So return type should be `*C.char` and just return `C.CString(path)`
Whats the purpose of managing the seperate sub processes? Why not use an existing solution?
supervisor is good for this purpose
The only thing I don't like about sqlboiler is that the domain objects can execute the queries.
Thanks)
As the OP didn't provide enough information. Systemd can monitor processes and restart them. The other thing you can use is supervisord
I think it might be more valuable to explain the distinction between pointer and reference types here than to just be pedantic.
How do you handle testing applications/functions that use sqlx?
So the keys I want to get from redis is in a slice. Since the redis library accepts only an interface type, the type of the slice is also an interface. &gt; keys := []interface{} &gt; keys = append("a", "b", "c"); Now this key is send to the HMGET call to redis. When I get the result back, I want the result to be in a key value pair in a map m["a"] = "xx" m["b"] = "yy" m["c"] = "zz" &gt; I don't understand what's hard about this In client libraries in other languages, the result itself is a key value hashmap. In go, it does not look easy, so many loops, type assertions, type conversions etc. That is the hard part about this.
I hate go's way of everything to be mapped to a struct when I all need is a map.
In those cases you have no choice, so the question of what to do is moot. 
Totally understand your point, but on the other hand, there is probably no single best approach. If the module dependencies problem was easy, we would have had a sound and solid dependency management since Go 1.0. 
This is called a "supervisor" process. Many other people already wrote them, so you don't have to write another.
Go doesn't have pass-by-reference but it does have "reference types" - namely, things with an identity beyond their value that can be shared by multiple variables. Pass-by-reference is essentially where the compiler silently makes things into references (basically: pointer-to), which Go does not do, but you can still do it explicitly. For example, a map is a reference type. Even if you assign it to another variable, modifying either one will affect the other. That's quite different from how a value type, like an int or an array (not slice!) works. 
Shameless plug, I'm working on a tool to easily deploy a containerized Buffalo application to Azure. You can find it here: https://github.com/Azure/Buffalo-Azure Even if your web-app doesn't use Buffalo, you'll still be able to use the ARM template for it, which can be found here: https://aka.ms/buffalo-template It will create an instance of Web App for Containers for you, and point at whatever docker image you point it to.
If you need a production-ready solution quickly, I believe existing solutions are the best option - see /u/mvrhov's comment. If you want to write this as a personal exercise, I think you can use Start() and Wait() of the exec package as you planned, and also have a look at StartProcess() and ProcessState in the os package as an alternate approach. For even more DIY, you could also implement a "heartbeat monitor"; for example, by having the monitored process respond to specific UDP datagrams, Unix signals, or REST queries, etc., that the monitor process sends in certain intervals. If the monitored process does not respond, then it is probably quite dead. This way you can even monitor processes that are not child processes of your monitor.
You are right! Everything in Go is passed by value but some types are pointer types with 'reference semantics' like implicit dereferencing on structs. So the line get kind of blurry.
Yes, if only I included a link to an article written by a notable Golang developer explaining just that distinction, silly me.
There was a link in my original post that you should read. That article also includes more links if you aren't familiar with the concepts in the article. It would be nice if you had read that rather than restating exactly what the linked article explains is wrong.
Pointers and references are not the same, there is no blurry line. The link in my post explains it rather well, I think.
I've already read it. A long time ago. You are misunderstanding the distinction between the language feature of references that C++ has, called reference variables in the article, and the broader concept of reference types, not at issue in the article. To explain more concretely, consider Swift. Structs are value types. Classes are reference types. `inout` parameters are references/reference variables, a different concept altogether from value/reference types, and in fact applicable to either. It is a pity the terminology is so similar.
No, reference types are different from pointers, period. I think the [Wikipedia article](https://en.wikipedia.org/wiki/Reference_type) helps to clarify it too. It's important to be precise, and reference types and pointers are different, even if they solve similar problems.
Yeeeeees... You will notice my example of a reference type was a map, which is not a pointer, and similarly that the initial example of a string is *also* not a pointer, so I believe you should have noticed I don't think reference types are the same as pointers... 
If you read the original article, you would have noticed a section explaining how maps are not reference types.
Interesting. Never heard this criticism before. I think practically the difference can be hand waved away and it doesn't really create problems in reality. It's interesting to consider it though. The data access layer is what sqlboiler concerns itself with. The models it generates simply aid in persistence. The domain then is more about the functionality on top of the data. Which are typically kept in a separate package that act on the models as an argument not a receiver (functions not methods). So it's more that the persistence objects don't know anything about the domain which is the same thing just backwards. Whether one form of this isolation is better than the other is up to the scholars and/or personal preference. It's good food for thought though. Thanks for the comment :)
Hahaha, if you'd read it, you'd notice it says they aren't *references*. Here's a question for you: maps obviously behave differently from ints. What is *your* word for that, if not reference type? 
I think for the foreseeable future, the best answer is "it doesn't matter". We know at least a) the plans aren't concrete, i.e. will take a while and b) they plan to make it possible to (in one way or another) make Go1 and Go2 code to be usable in the same program. So there really is no reason at this point, to worry about it. It won't arrive any time soon, so there's no need to prepare for its changes and Go1 code won't be obsoleted by it, so there's no reason to hold off on building something with Go. If the reason someone asks is "I don't like Go without $go2_feature", IMO the only response is "don't use it then, no use holding your breath".
I'm not sure what you mean. Of course maps are different from arrays, they are different data types. Just like a log.Logger behaves differently from a os.File. Also linked in the original article is [If a map isn’t a reference variable, what is it?](https://dave.cheney.net/2017/04/30/if-a-map-isnt-a-reference-variable-what-is-it). Maybe you could restate your question after reading that?
See also: https://golang.org/cmd/cgo/#hdr-C_references_to_Go (and the notes about strings).
Which parts don't you agree with? I think the addition of modules and semantic import versioning simplify the problem space of dependency management in a way that an external tool couldn't do. It feels very "Go" to me, yes it is restrictive but in a really good way. i want to stop thinking about dependency hell tomorrow the same way I don't think about code formatting today. Most of the counter arguments I've seen are about what happens when a some dependency breaks semver rules and doesn't fix them. This is a great reason to stop using that package. I've noticed the Go community to be very picky about how libraries are developed. If a package is too bloated, doesn't have tests, has too many external dependencies they take a lot of fire. This is great, we have high standards, playing well with modules will just be another of those standards. I think we can do it and the entire Go ecosystem will be better for it. And no more GOPATH, hallelujah!
Hahaha, I'm not laughing at you, you've done nothing wrong, I'm laughing at how god-awful this terminology conflict is. It's like it's intentionally impossible to discuss. And the article writer is not really helping, even though they aren't wrong. So yeah, I'll explain what I'm asking more carefully. There are two slightly different concepts with slightly different names. One is called either "references" or "reference variables", like the Go articles you linked. The other is called "reference types", like the Wikipedia page you linked. Notice, for example, that Wikipedia says that "In C++, ... references and pointers are reference types." This is a clue that references are an example of but not the same thing as reference types. Here is what I mean by the difference between the behavior of maps and arrays: a := make(map[int]string) b := a a[0] = "hello" fmt.Println(b[0]) // hello var x [1]string y := x x[0] = "hello" fmt.Println(y[0]) // empty string Maps and slices both have this property, while arrays do not. This property is called being a "reference type", and if you don't work this way, you are a "value type". Now, we have an article saying that maps are not reference *variables*, just pointers. Indeed, maps are pointers under-the-hood, but the dereferencing of that pointer is done implicitly. Which is exactly what Wikipedia describes as a reference type: &gt; Reference types can be thought of as pointers that are implicitly dereferenced. So what is a reference/reference variable? The key distinction is what happens during *assignment*. Here is code proving maps are not references/reference variables: a := make(map[int]string) b := a a = map[int]string{0: "hello"} // above, was: a[0] = "hello" fmt.Println(b[0]) // empty string bc not a reference // would have been "hello" if a reference A reference *type* is conceptually similar to if `a` and `b` are pointers to the same thing. A reference *variable* is conceptually similar to if `a` and `b` were *literally the same variable*. Both are usually implemented as pointers behind the scenes, the difference being whether or not that point is dereferenced during assignment. // How a reference type usually works a := pointerToMapData // was: make(map[int]string) b := a (*a)[0] = "hello" // was: a[0] = "hello" fmt.Println((*b)[0]) // hello // NOT DEREFERENCING DURING ASSIGNMENT! a = pointerToOtherMapData // was: a = map[int]string{0: "goodbye"} fmt.Println((*b)[0]) // hello // How a reference variable usually works (and not how maps work) a := pointerToMapData // was: make(map[int]string) b := a (*a)[0] = "hello" // was: a[0] = "hello" fmt.Println((*b)[0]) // hello // DEREFERENCING DURING ASSIGNMENT! *a = *pointerToOtherMapData // was: a = map[int]string{0: "goodbye"} fmt.Println((*b)[0]) // goodbye Go does not have references/reference variables, which is great IMO because they are super confusing and much better done as explicit pointers. But it does have reference *types*, which is basically all of the types that are secretly pointers behind the scenes, including maps.
Have a look at https://github.com/DATA-DOG/go-sqlmock Also, good answer here: https://github.com/jmoiron/sqlx/issues/204
You can do a type switch like so: var someInterface interface{} = "example" switch v := someInterface.(type) { case int64: case string: ... } Or you can use one of the libraries that abstracts this from you. To help further, I need: - which redis library you're using - what your data looks like in Redis - how you want your data to look in Go - existing, non-working code
yeah, i'm really looking forward to the identity management component that they're working on, and I hope they would provide a guide on how to set it up (the complete ory ecosystem) in your own server, probably in docker. i like auth0 but as much as possible i don't want to depend on other services. and most of the time, I'm working offline, so cant' really use auth0 without internet. thanks buddy!
haha, right right, i'll find a time to do that.
I have a been a long time user of supervisor: http://supervisord.org/ Once installed, you write a "program" config file similar to: ` [program:beans_processor] command=bash -c '/var/beans/processor/current/beans process' directory=/var/beans/processor/current autostart=true autorestart=true stopsignal=INT stdout_logfile=/var/beans/processor/logs/stdout.log stdout_logfile_backups=5 stderr_logfile=/var/beans/processor/logs/stderr.log stderr_logfile_backups=5 [program:example] command=bash -c '/var/go/program/example' directory=/var/go/program autostart=true autorestart=true stopsignal=INT stdout_logfile=/var/go/program/logs/stdout.log stdout_logfile_backups=5 stderr_logfile=/var/go/program/stderr.log stderr_logfile_backups=5 ` I like supervisor for the extras too, in the example above you can see some settings to handle output and logging, including log rotation.
Thanks, I see what you are saying now. However, I do not see "reference type" the same way. I think of reference types like how objects work in Python and most other high level/interpreted language. When a language has objects which are conceptually inseparable from the reference and underlying value, then it is a reference type. For example, lists in Python are a reference type because it's not possible to distinguish the "reference" and the "object" proper. You can't talk about and work with list references and list objects separately. This is what I would call a reference type. A reference type is an object that is always interacted with by reference at the language level. You simply cannot store the underlying value in a variable, at the language level. On the other hand, maps as a pointer type and the underlying value can be distinguished in Go. At the standard library level, the underlying value is hidden away. However, if you look at https://golang.org/src/runtime/hashmap.go, you can see that maps are implemented as pointers to a struct value, *in Go*. That is to say, at the Go language level, you can clearly distinguish the the pointer and the value. The only reason you cannot normally store the value of a map in a variable is not because of the language, but because of package visibility (hmap is an unexported/private type in the runtime package). Thus, I would not consider it a reference type. Hopefully I have made myself clear. Since we understand each other now, we can call a truce.
Yes, we do. A rather simple setup, only users and some other entities managed and some tweaks in the layout like adding a logo. But it works well. :-)
&gt;Redis library [https://github.com/gomodule/redigo](https://github.com/gomodule/redigo) &gt; Data looks like in Redis HMSET myhash field1 "Hello" field2 "World" &gt; how you want your data to look in Go On doing HMGET myhash field1 field2, I want a map of result["field1"] = "Hello" result["field2"] = "World" &gt; existing, non-working code Not written code for that yet, looking at options avoiding using a struct. 
Structure and Interpretation of Computer Programs!
I like gopath, I hope they don't delete it as the article suggests. 
Nice article, thank you for sharing. I've started coding with Go lang for a few months now, and I quite like it. About the book "Mastering Go", is it good?
Same here, just regular SQL
I don't mind dep and if it became the standard I would be fine, but I'll happily move to vgo once it's baked in and enabled by default. 
Go get still has to install somewhere, so I don't think it will go away. I think it works fairly well in large projects where only some of the code is Go so I hope it stays as well. 
Hey @y0m, thank you for the feedback. I honestly didn't started yet. Super busy with writing Go haha but I will start this weekend and let you know!
You've never heard of Active Record vs the repository pattern? your library uses Active Record.
Doesn't matter, Go is clearly not a community driven project, the whole vgo episode demonstrated it.
For mutation, you can easily mutate the value using index notation: users\[i\].Whatever = ...
The community has an aversion to ORMs which I understand but also consider a reason why Golang will never be really productive a certain kind of exploratory development where everything is changing, and its how many devs (myself included) like to start their projects. For those, unfortunately, Python and PHP will be much more productive for those early stages.
Sure. But I meant more in cases where it’s a pointer to something you’re storing elsewhere.
Wait, this only applies for contexts where go is run outside of $GOROOT/src? How do developers version pin developer tools?
Maybe not driven by the community, but the go team has listen to the community which wanted a simple and standard solution. We cannot say the vgo is a Google workflow !
Funny enough, the same guy \[thinks its appropriate to call slices reference types\]([https://dave.cheney.net/2018/07/12/slices-from-the-ground-up](https://dave.cheney.net/2018/07/12/slices-from-the-ground-up))
[removed]
Without the time to look closer at the moment, it might help to double-check whether the C code is giving you a C string which terminates in a null byte. Since C strings are null terminated, I got tripped up on that the first time I use a library that made calls in to C code. After making sure I always trimmed that off, the mysterious errors disappeared. 😎
Pass-by-reference and referential types are two distinct concepts.
Reading plenty of code in the wild and using refactoring as an exercise are both good ways to grow in these areas. Also seeking out code reviews as much as possible and being incredibly open to the feedback you receive.
I personally disagree about the interface issue: when you refactor something like that is like breaking an api or a contract, so it's supposed to modify also stuff that satisfies it. Break an interface is a major change imho.
I've always found `dep` annoying to work with. It's super-slow and tries to be far too clever about what I want. Things like adding a new package to vendor is super-annoying as `dep ensure -add ..` will complain if the code doesn't match what I tell it to add to vendor.
I always iterate my code (write it multiple times), so that's how I try to grow by myself. Reading more "in the wild" code is a really good tip -- I once read through the Go lexer internals, and learned a lot.
yea sure, my point was that the "link" in IDE is broken. You can't navigate from interface back to struct while refactoring.
+1 one of the best features of Go. Never has my code been so well organized.
It's all about iterations, always write tests so you can refactor without concern. Also, in my opinion, in go writing good unit tests is kind of helping you realize how to abstract your code, and why using composition is something you want to do. It's not the best explanation, but as a beginner developer it will give you a grasp of how to design your application better, and later on when you will watch Uncle Bob's lectures about clean architecture, you will start to realize what is the meaning of all of this. Also you can (and should) explore go-kit package and the examples in it. It makes you understand how to utilize the fact that go has a very natural packages structure, and why you might consider to try to learn domain driven design. Hope it will help you and that I'm not waste your time...
It says that the gopath version of go get would be removed
I think everyone is assuming you're wanting a process supervisor to watch something like a web application, but I believe you're actually looking for resilience against one simple attack vector of an evil process that is trying to kill your process. Once you call Start(), the process is forked, but the child can outlive the parent. Therefore, call start twice, and exit. Both children will now be independent process trees and can't be killed as an entire tree. If one exits, the other starts two more processes and exits. There are a number of attacks and countermeasures at each step of the way, but I think this will get you going on the right track. If an attacker has root permission, you are only going to be able to play cat and mouse, but that doesn't mean certain classes of security-oriented software shouldn't attempt to win at the game. My hunch is that you'll find yourself writing some C later on to to the nature of the OS internals you'll be playing with. But I could also be assuming too much.
Do you think that changing the return type will affect the file creation function ?
Yes I read that, I found pretty much all examples I could find on the Internet, most are just copy and paste from one source and there's pretty much no examples besides returning Ints
I have the feeling that this could be my problem but even when I change all types to C.char I still have the same error
I think he's referring to where the source gets downloaded though. I meant the compiled binaries has to be installed somewhere. (I formulated it badly.) Admittedly I only skimmed the post though.
[removed]
There is nothing keeping you from structuring your code like GOPATH after GOPATH is no longer required.
[I can't help it](https://www.youtube.com/watch?v=GP2JPwbtq0g)
[removed]
Not exactly, the community came up with a workable solution and then the Go team unilaterally changed directions. I doubt we see in major community driven efforts in the Go community ever again. Google can just destroy what you've been working on, after not opting into the process for years.
Why not just use SASS/Less/SCSS/some other CSS preprocessor? They give you the ability to add `@import` statements and a bunch of other cool things like nested syntax, mixins, functions, inheritance, etc. . .
&gt; I have now an idea of the code to use. Good, I hope you get it working!
Is this a fork of Sublime editor or...?
While I preferred dep, I'm just glad we finally have settled on something. vgo works well enough!
SQL is already an abstraction, trying to write an abstraction over SQL just leaves two things to learn and debug. this.get('user').where(id, [23,51,9]).andWhere('status', 'active'); SELECT * FROM user WHERE id in (23,51,9) AND status = 'active'; This isn't even a complex example. Wait until your queries are 10-line reporting queries and the ORM doesn't support 2nd level nesting of conditionals.
I can second that writing tests in go helps isolate brittle dependencies or designs that need refactoring. The tests aren't just there to catch problems you introduce via future changes, it forces you to consume the code you wrote and use it. 
Actually I didn't even remember these patterns. I don't think sqlboiler fits in either category though since your domain logic is not part of any object but lives in a seperate package that simply uses these objects as the persistence layer as I mentioned earlier. In the active record pattern the objects would have as methods both domain logic and persistence logic right? But that's not the case here. It's also definitely not meant to abstract SQL completely, I'm of the belief that that's simply not possible and even if it is it comes with caveats so big so as to make it a futile endeavor. It's just meant to be a productive and efficient data access layer. So you're absolutely right, if someone is trying to avoid SQL then it's definitely the wrong library. I actually view this as one of its best features when compared to other similar libraries in Go haha. I also wouldn't call it a product :p I don't sell this or make money from it in any way. Would be nice to though! Thanks for making me read up on AR vs Repository, was interesting to revisit.
Merh, VSCode ftw!
I think is going to be difficult to find either solution objectively better than the other, especially after the debate became quite emotional. But vgo is simpler and at the same time encourages best practices. This is better to me.
That seems more like an IDE problem than a language problem, but obviously it is valid for your workflow.
You call struct initialization "broken encapsulation" but that is not correct, encapsulation occurs at the package level in go, not the struct. An importer of your package will neither be able to set private struct fields nor read them.
&gt; GoSublime is a Golang plugin collection for the text editor Sublime Text providing code completion and other IDE-like features. 
What really made everything click for me—and this might sound a bit cliche—was learning other languages. Specifically, F#. The reason, I suspect, is that thinking about types _first_ and designing your program around them (which is what F# advocates), naturally reveals a structure that makes sense. So my advice would be: learn other languages with other paradigms; it’ll give you a clearer picture and teach you some underlying theoretical principles that you can then apply intuitively to everything you write. Another thing that’s helped me quite a bit, is reading Structure and Interpretation of Computer Programs. It’s an amazing book. And of course, as others have already said, look at some code you admire and think is particularly clear and well-structured, and try to understand the reasoning behind that design. Hope it helps!
Go is not "community driven", but the Go team definitely listens to the community. GOPATH removal, keeping vendoring as an optional mechanism, being able to build with an "offline" mode, and many other things in vgo are the results of listening to community feedback.
If your OS uses systemd, just use that. Otherwise use something like supervisord.
I moved to VSCode sometime ago and never looked back! Its golang support is quite superb!
Have you tried Atom IDE + GoPlus? If so, how does it compare?
You're exactly right, reference types are how objects work in Python. And reference *variables* are *not* how objects work in Python. That is, the "Maps aren't reference variables" article equally applies to Python objects. So it sounds we now agree that these are two different things. As for your distinction about reference types, I do understand what you're saying. Unfortunately, it does not agree with the Wikipedia article, which lists even pointers themselves as reference types, or with how anybody else uses the word. But it's not as big a misunderstanding as what you started with, so I won't argue the point any further. 
Yeah, those are cool too. I needed something like this though, just thought I'd share it.
I have the user tagged with 'spammer' in RES. They seem to just post their own low quality articles over and over again in multiple programming subreddits. Each one of their posts is tied to the amazon affiliate account as well.
Tried to scroll down, it shot me half way down the page, left. Please remove the scroll hijacking!
&gt; Sublime Text 
&gt; fork I don't believe you can do that to proprietary software
Design patterns. Go makes it VERY EASY to implements design patterns that takes endless of Java code to implement. Clean Architecture Understanding the SOLID principle and architecture will help you understand how to design packages and interfaces.
Just a comment about interfaces, I would suspect if you need to refactor interfaces a lot they may be too large. The most powerful interfaces are single function interfaces. I’d even say try to do the thing you want without interfaces and you’ll see where you want them naturally. The standard library has a bunch of great single function examples. 
I have always just hidden the structs with required fields with an interface. The thing that sucks about this is that you have to write funcs like Thing.Field(). Honestly feedback on whether or not this is a bad idea would be appreciated type thing struct { Field string } type Thing interface { Field() string } func New(field string) Thing { return &amp;thing{Field: field} }
Thanks a lot!
Please don't go crazy with interfaces. As someone working through code that uses them everywhere (former java dev author), interface abstraction has very quickly diminishing returns. For example (grrrr), you don't need a whole wrapper class around `time.Now` just so you can modify it in your unit tests. You can just override it straight up for _, test := range tests { time.Now = func() time.Time { test.givenNow } ... }
The quote you mention comes from: ["Sure It Works, But Is It Beautiful?: The Relationship Between Software Aesthetics and Quality" by Charles Connell](http://www.chc-3.com/pub/beautifulsoftware_v10.htm) &gt;The simplicity of software also is a key metric that distinguishes programming ability. Junior programmers create simple solutions to simple problems. Senior programmers create complex solutions to complex problems. Great programmers find simple solutions to complex problems. The code written by topnotch programmers may appear obvious, once it is finished, but it is vastly more difficult to create. Just as the goal of science is to find simplicity and order in a seemingly complex universe, the goal of programming should be to find simple solutions to complex problems. The sentence after the bit about great programmers points out that a lot of work goes into writing simple code. The finished product doesn't usually reflect the false starts and dead ends that were discarded before arriving at the simple design. I was privileged enough to contribute to the [github.com/go-kit/kit/log](https://godoc.org/github.com/go-kit/kit/log) package which I feel achieves a nice level of simplicity. I believe we achieved that for a few reasons. We had experience working with similar but less simple packages before which helped us understand the problem domain. We also had collaborators that (respectfully) challenged each other to justify the need for each and every bit of the design. In case it will help you to see how this process played out, here are some links to our early design discussions as we proposed various APIs and whittled them down to something simpler: My first design proposal that we abandoned: https://github.com/go-kit/kit/pull/16 /u/peterbourgon's counter proposal which we iterated on and eventually merged: https://github.com/go-kit/kit/pull/21. The last core concept that we added to the base log package took place in this PR: https://github.com/go-kit/kit/pull/32. The package has matured since those early days, but IMHO it remains simple. I learned a lot about writing simple code from that experience. The fact that you aspire to write simple code is awesome, but it's not necessarily easy. It takes practice and experience. The fact that you are striving for simple code and eager to learn is fantastic. Keep challenging yourself, read code, try redesigning things a different way to see what works and what doesn't, use the code you write to see what the user experience is like, and look for other like minded developers that can help critique your designs, you'll both learn in the process.
You should avoid interface{} and reflection. These tend to hurt run time performance and bypass compile time type safety.
I misread the code, basically you your go function is getting passed `*C.char`, but it's expecting a go string which is `struct { uintptr; int }`. ``` func testWriter(path *C.char) *C.char { file, err := os.Create(C.GoString(path)) if err != nil { return C.CString("error") } defer file.Close() return path } ``` *should* work, again I can't test the code right now.
Looks good! I cannot comment on the biochemical part, due to severe lack of knowledge :) Tip: If you want to run tests on more then one input, have a look at [cweill/gotests](https://github.com/cweill/gotests). It may take a bit to get used to the structure of the generated template, but then you can quickly add any number of test cases to a test. As a bonus, many editors, like e.g. VSCode (with the Go extension), have built-in support for `gotests`, allowing to create test skeletons with a few clicks. 
No, it does not.
Thanks a bunch ! I’ll have a look at that, I’m using atom, and I think it’s supported. 
There's no Golang. Only darkness, hunger and politburo.
Thanks but I also tried that too. It creates a file with the same pattern I described above, an interrogation symbol followed by `invalid encoding`
The IDE helps quite a bit, you can check for implementations (Ctrl+Alt+B on Windows) and pin them for later refactoring. In my experience changing the interface causes compilation to fail anyway, but that's not true in all cases.
That code wouldn't compile. As far as I'm aware, struct methods and struct fields aren't interchangeable. The field would have to be private or named differently, then you'd have to attach a getter to the struct to satisfy the interface. 
Cool little utility library. Have you considered adding support for parsing strings via a strconv call?
as for ***[]**** User.... https://www.youtube.com/watch?v=kY-pUxKQMUE
Good point!!!!
Yeah, this is what I meant I guess I just worded it poorly and wrote it by hand `package thing` `type thing struct {` `field string` `}` `type Thing interface {` `Field() string` `}` `func New(field string) Thing {` `return &amp;thing{field: field}` `}` `func (t *thing) Field() string {` `return t.field` `}`
It might be an actual bug then, try opening a bug report on https://github.com/golang/go/issues.
Thanks for your time, will do it !
Thank god
The problem, for me, is less about the solution and more about the process, or lack of one.
I used [bench.b](https://github.com/kostya/benchmarks/blob/master/brainfuck2/bench.b) for the benchmark. It prints the alphabet in reverse order. Benchmark brainf*ck program &gt;++[&lt;+++++++++++++&gt;-]&lt;[[&gt;+&gt;+&lt;&lt;-]&gt;[&lt;+&gt;-]++++++++ [&gt;++++++++&lt;-]&gt;.[-]&lt;&lt;&gt;++++++++++[&gt;++++++++++[&gt;++ ++++++++[&gt;++++++++++[&gt;++++++++++[&gt;++++++++++[&gt;+ +++++++++[-]&lt;-]&lt;-]&lt;-]&lt;-]&lt;-]&lt;-]&lt;-]++++++++++.
Wouldn't it be easier to just: out, err := strconv.Atoi() if err != nil { } o, err := as.Int(out) Also, there is this library by spf13, but it does not check for overflows: https://github.com/spf13/cast
Sure you can. It just takes a team of exceptional reverse engineers.
Library does not handle [uint32 overflowing an int](https://github.com/lunemec/as/blob/master/int_64b.go#L32) 
It does when having 32b int: https://github.com/lunemec/as/blob/master/int_32b.go#L34
Yes you absolutely can do that. I'm just thinking of a case I've had to deal with more than a few times where I've needed to parse some output that's an empty interface and converting it into a particular numeric type.
It's re-allocated every time you call String. Specifically, each time you call String(), you're creating a new memory allocation that is stored on the heap which will have to be garbage collected.
I encourage you to read [Profiling Go Programs][pgp]. I suspect you will find that for tight loops like this, bounds checking and interface calls are the main difference. [pgp]: https://blog.golang.org/profiling-go-programs
Because it's copying a lot. Changed from range to normal for and got twice better times. I did pull request here: https://github.com/kostya/benchmarks/pull/160
You piqued my curiosity and I'm writing my own version of this from scratch from your source. Just noticed: for t.pos &gt;= len(t.tape) { t.tape = append(t.tape, 0) } This is a whacky way to ensure a minimum len! Idiomatic would be: if diff := t.pos - len(t.tape); diff &gt;=0 { t.tape = append(t.tape, make([]int, diff+1)...) } (`0` is the 'default value' for all number types incl. `int`s, so no need to ever explicitly mention it in var initializers, composite literals, appends etc.)
No it doesn't. VSCode.
VSCode is much much better
If you can find a nice way to include functionality you'd find useful into the library, I'd happily merge it :)
`range` just-over-index (instead of values) should equally help, right? Sometimes I wonder if maybe that style helps the compiler eliminate bounds-checks (either today, or potentially in the future).
Start by describing how you measure speed and what are exact results. If the time includes startup cost of the program then for such a short program the cost to just initialize Go runtime might be bigger than to run the actual logic (even if that time is, in absolute terms, very small). You can get a feel for that by measuring a no-op programs in both Go and Rust e.g. a program that just prints a message and exists. Also, see what happens when you disable garbage collector in Go.
The tape only ever grows to a length of 8 in this benchmark so this isn't much of a factor; in any case the Rust version does the same thing.
Wow. That is the one thing I did not try, I naively figured that range had to be the fastest way since it's a builtin.
Ps put the `default: continue` and it will be a bit faster.
As mentioned [below](https://www.reddit.com/r/golang/comments/8ym8lf/why_is_this_simple_benchmark_3_times_faster_in/e2c2h78/), I rewrote from your logic in "how I would attempt hi-perf in my home-grown style". Your program always takes ~4.0x secs at my end with the reverseAlphabet source, mine always takes ~2.0x secs. Enjoy digging in! https://github.com/metaleap/go-misctools/blob/master/dummy-bf/main.go
Just doubled your speed anyway, see other top-level comment
The Rust version uses a similar construct to range, `for op in program`: fn _run(program: &amp;[Op], tape: &amp;mut Tape) { for op in program { match *op { Inc(x) =&gt; tape.inc(x), Move(x) =&gt; tape.mov(x), Loop(ref program) =&gt; while tape.get() &gt; 0 { _run(program, tape); }, Print =&gt; { print!("{}", tape.getc()); io::Write::flush(&amp;mut io::stdout()).unwrap(); } } } } Yet it is fast somehow.
Except it's slow -- for times when I need to load large files, then I need two editors open :-/
Odd I can open some quite big files, when was the last time you tried it? https://code.visualstudio.com/updates/v1_15#_large-file-support
IIRC Rust compiler focuses a lot more on optimizations than Go's.. =)
I've been using xo (https://github.com/xo/xo) for my first larger project. It does code generation based the schema of an existing database. It's a nice combination of not needing to write SQL by hand for all of the basic operations and also not feeling like you are doing something unsupported when you need custom queries (which you sometimes feel when using an orm).
Whether or not this change makes sense depends on the benchmark. The vast majority of Go code I read uses range, not this mechanism. If your goal is to benchmark idiomatic Go code, rather than optimized code, this is a poor change. IMHO there are already enough "make languages go as fast as possible" benchmarks. We need more ones focusing on idiomatic code.
Thanks, I did investigate your solution too before posting
Alright, I will check this out, thanks!
Alright, thanks for the advice. I am creating an anti-malware app and want to prevent my main process from being killed by a bad process(malware). I was thinking of creating a persistence module that has 2 processes that protect each other. If main.exe is killed then persistence.exe can restart it, if persistence.exe is killed, then main.exe can restart it. I hope this is enough information for you, thanks!
Alright, a couple others have said this, gonna look into it, thanks!
Alright, thank you for the advice. You were right, I am trying to protect my process from being killed by malware and need to have persistence. If a.exe is killed, b.exe will restart and if b.exe is killed, a.exe will restart. That is what I am trying to achieve. I have heard others suggest supervisord for the process monitoring aspect of this"persistence". Thank you!
Yes, will definitely look into the production ready solutions. If they do not work for me, I will end up making my own. Thank you for the advice!
Cool, I'll give it a whirl. Another optimization is to collapse multiple +, -, &lt;, and &gt; ops to one using `v` to store the count. But one should stay with the same algorithm, since its a benchmark. Note this isn't my code, just a benchmark I was playing around with.
Yes, others have suggested this, will look into it, thanks!
Well, trying to keep as cross platform as possible, so if I can use a library (or make one) that supports multiple OS'es than that is what I will do. Thanks!
I am trying to achieve persistence. I figured the best method would be to just have a whole separate process to protect the main, and the main can protect the persistence process. Happy to use a existing solution but have not found any, and believe me, I have looked. Maybe I am searching the wrong query? Thanks!
&gt; But one should stay with the same algorithm, since its a benchmark Exactly, hence I refrained. Good thing too, as I had other plans for this Friday night! Other _coding_ plans, naturally =)
Go is a bit like Objective-C in this regard: it's basically C, with a few high-level constructs added on top. Those constructs are never faster than their lower-level counterparts, they are there for convenience. Rust on the other hand prides itself in zero-cost abstractions, i.e. high level constructs that do not incur a performance penalty. If you want fast Go, write it like you would write C. Better yet, write idiomatic Go first, then benchmark it and figure out where performance matters, then convert that part into a more C-like form.
FWIW, in the general case, I would _expect_ Rust to be 1.5-3x faster than Go. It's great that other people helped speed your issues up, but in general "Rust is 2x faster than Go on this code" is not really a mystery. This simple case may not have a lot of differences but as you crank up the complexity Rust is going to take an advantage over go.
don't disagree, but curious why.....
i/o is rather complex "no-op" :)
Go’s value proposition is it has 80&amp;#37; the speed of C and 80&amp;#37; the productivity of Python.
So we're just gonna make "elegance" mean whatever you want it to? Super helpful.
Can doesn't mean it's fast. I can casually outscroll the syntax highlighter if I open a reasonably big file.
You can? I was trying to do something similar recently. Overriding single method on a struct and it said I can't. Is it only possible with simple functions?
I see the same use case as for the Python REPL or the play.golang.org - quickly importing modules and running interactively. 
&gt; you're creating a new memory allocation for a new string that is stored on the heap To clarify your thinking, by "allocation for a new string" surely you mean the slice-like internal 'header type' (startAddr, len) pointing at the statically-known `const`-ishs `"NORTH"` or `"SOUTH"`, right? Actually asking since in the above situation I couldn't intuitively assess for sure whether these 5-byte strings get copied around when passed/returned or just the slice-ish internal header-type as one'd assume (especially given that `string`s are immutable, to boot)
I love using SublimeText, and for a long while I hung in there with GoSublime. When it started to look like it was abandoned (after little to no response on my merge requests) I also tried DamnWidget/anaconda_go. It works better when it actually works, but has its share of problem like with its flaky jsonserver process no responding. Ultimately I moved to Jetbrains for Go development and have been much more productive. And I hear great things about VSCode. So SublimeText for Go dev remains just a convenience when I need to edit files on the fly. 
&gt;zero-cost abstractions This phrase bugs me, because nothing is ever "free". Rust (and C++) usually pays for its abstractions with compilation time.
[removed]
Obviously there is a price to pay. It is a given that the zero cost abstractions in Rust incur a compilation cost, the point is to shave every last bit of performance during runtime.
What do you feel is missing? lose typing? As a Python programmer, I feel like the only thing missing from Go are some user land tools/libraries like Django Admin, Spacy.io, or CV. However, the same can be said about the libraries Python is missing compared to the batteries-included, stdlib encryption and network handling in Go.
Probably only top level funcs, not struct methods. 
Yeah. Goland can already tell you which which structs implement a given interface. Many of the refactoring tools are still coming given goland is so young.
There is one incredibly obscure use-case: The goto keyword. If you try to declare a variable in the space between a goto and the label it jumps to, the compiler will abort and report an error: goto *&lt;LABEL&gt;* jumps over declaration of *&lt;variable&gt;* If the declared variable is only needed in that local space, you can enclose it in a pair of naked braces to force it into a new scope (and back out of that scope) before the goto label is encountered. This permits compilation.
All flash no editting
Nice work! Without running it myself, I can see that the README looks great - tons of information, which is always great news for open source projects.
Yep, just range over indices. Idiomatic and faster. I usually follow this for perf tips - https://github.com/cristaloleg/go-advices. Lots of cool nuggets there.
the goto ? why does it even exist, have you ever used it ? why ?
I would imagine goes performance shines a little better with a benchmark that uses concurrency. 
It exists for the same reason any other control flow keyword exists: to help the programmer specify the logical sequencing of the algorithm. While rare, the goto keyword does see occasional use simply because it's the best suited tool for the job. There are over 150 uses of the goto keyword in the standard library. (Because the standard library is often working with low-level and performance critical code, this is probably over-representative for Go code as a whole, but the point remains.) One such example can be found in the math package's [Gamma Function](https://golang.org/pkg/math/#Gamma) (a generalization of the factorial function most programmers are already familiar with). To see how the goto keyword is used, check out the [implementation]( https://golang.org/src/math/gamma.go?s=4029:4058#L120).
For the reasons I said, though possible it got edited in after your reply. Go prioritizes several things above speed. Rust prioritizes several things that are either for speed, memory efficiency, or things like being much more careful about copying (in some sense as a side effect of their ownership semantics) that result in it going faster. Both projects are successful in achieving their goals. It would be weird if Rust wasn't faster. That said, speed is _a_ priority for Go. It blows the socks off of a dynamic scripting language, even something as optimized as a JIT'd JS interpreter. It just isn't as _high_ a priority as it is for Rust, and consequently, we have things like fast compile times whereas they have things like [automatic vectorization](https://www.reddit.com/r/rust/comments/8uccla/does_rustc_have_autovectorization/). Go could not obtain Rust's speeds without sacrificing things that Go programmers are not willing to sacrifice, so it's not like it's a challenge to Go or something that Rust is faster. As I write this, I'm no longer in the negatives on my post. Sometimes justifying such posts can save them. But while I'd say the community doesn't particularly encourage it, every language picks up some fanboys who think that the language has to be the bestest at everything, and anyone who says otherwise is totally a hater and should be smashed. But that's just fanboyness. It's much better in my opinion to have a clear view of the pros _and the cons_ of Go, in order to use it when it is truly the best choice, than to believe it has no cons. In fact I consider such fanboyism to not even be effective advocacy on its own terms; when someone asks "Is Go good for X?" and it isn't, but you say "Yes, yes, it is because it's the best at everything!" and you manage to talk them into trying, you have not won... you've lost. You've created the next Go hater, who will slag it as crap at scientific programming or creating a AAA game engine or whatever now every time the topic comes up around them. Have a clear, level view of Go, please, not a fanboy one. It's better for everybody.
Thank you for your detailed response! This was a fun to dig through the links. 
You don't handle all kinds of errors. You just handle some that you want to handle, and pass others down (or `panic`, or show to the user. it's up to you). For example, [this function](https://github.com/fishy/badcerts/blob/13384065b71a5b475aea9220eff74160030c45a6/error.go#L14) can be used to check if the error is because of self signed cert, it can be used [here](https://github.com/fishy/badcerts/blob/13384065b71a5b475aea9220eff74160030c45a6/badcerts.go#L20). In most cases there's no point to enumerate all types of errors.
&gt; Now *url.Error is actually handled by the correct case. I'm not sure why this must be done, but it works so I'm not to worried about it at the moment. `net.Error` is not a concrete type, it is an interface type like `error`. `*url.Error` happens to implement the methods of `net.Error` and as such is a `net.Error`. You would handle it as a sub-case: if ne, ok := err.(net.Error); ok { if ue, ok := ne.(*url.Error); ok { // it's a *url.Error } // it's a net.Error and possibly a *url.Error }
Yes, you are correct. I thought about this approach and it would make most of the code smaller. I'll look into changing it to be this way.
That’s why there are also typesafe implementation among generic. 
Thanks! very much appreciated
I think you can just use https://godoc.org/github.com/gomodule/redigo/redis#StringMap or another scan function.
I use sqlx to make my life easier and have a package of my own that handles my db interactions using that.
Looks really good! I'm now going to rack by brain continuously to come with some cool project to make using this.
&gt;How do developers version pin developer tools? There is a [workaround](https://github.com/golang/go/issues/24051#issuecomment-377594251) by /u/rsc... which doesn't work with /vendor :/ Let's hope that they fix it before the release.
Looks cool man! Going to take a closer look and give you some feedback
 This package exposes an interface for "normalizing" JPEG images that have their orientation EXIF encoded. This library was designed for working with images uploaded from phone cameras that usually have their orientation tagged, which results in rotated/mirrored images when using the Go image/jpeg library. Supports little-endian and big-endian EXIF encodings, as well as all possible tag transformations. 
[removed]
Cool, let me know when you have something. Would love to see what people can do with this.
Author here. Happy to answer any questions you might have :)
&gt; var errMsg = "%d (%T) overflows int16" &gt; // … &gt; err = fmt.Errorf(errMsg, n, v) IMO, such errors should be done using an error type instead of using `error.New` or `fmt.Errorf`. E.g. perhaps something like: type OverflowError struct { FromType, ToType reflect.Type Value interface{} // or perhaps a specific integer type } func (e *OverflowError) Error() string { return fmt.Sprintf("%v (%v) overflows %v", e.Value, e.FromType, e.ToType) } This allows users to test various details about the error. For other examples, see some of the error types in the standard packages such as `strconv.NumError`, `os.LinkError`, `os.PathError`, `net.OpError`, `net.ParseError`, etc.
Especially since the Rust version uses the same idiom and is still faster than the Go version. (see Rust version below)
I understand and to some extent I agree, but as I said it became too emotional. I guess we'll never know what really happened and everyone has a version of the facts. The vgo blog posts surprised many people, I am still not so sure it surprised the dep developers. I am sure that Russ warned caution to Sam on the goland-dev mailing list about the plan for/meaning of dep. Their other conversations are not public records, we cannot know first hand. My recollection/understanding of what happened is that Russ found a better solution (for some definition of better) and at that point dep became a sunk cost to his eyes. Dep was an experiment, official and community driven for sure, but an experiment nonetheless. All this of course IMHO.
StringMap is for HGETALL, not HMGET
I saw the discussion of this in HN, so I've got the answers to my questions. That said, this is really cool. I was hoping to see a legit use of gokrazy when I saw its release. I would love to see someone implement pppoe and for go to support my router architecture. Anyway, great job and I'll probably be studying the source code for this for a good long while to expand my own knowledge.
Probably the opposite. Channels have a performance cost and just about every language has locks. 
True channels use semaphores internally, but I was thinking more about the lightness of the goroutines. 
Http.get is a high-level convenience wrapper intended for simple one-shot requests. To handle different kinds of errors, you should create a new client, configure it's transport, dialer, timeouts, tls config, and then create and send a request. Each step allows you to handle more specific errors, without even checking the type.
Rust has channels too, but not sure the current state of m:n threading. It used to be used, but they switched back to system threads. Can probably do it in Rust. 
I agree, I was thinking about that yesterday and I plan to add this :)
I’m glad the source is interesting to you! Pull requests with documentation improvements are welcome, or just a pointer to where you’d like to see more documentation would also be great :)
Nice! Only important thing missing to be useful is a reimplementation of igmpproxy, as otherwise Google Home / Alexa / etc won't work. Awesome work!
I don’t use an assistant at the moment. What do they need IGMP for, out of curiosity?
For discovery mostly. Same with some apple protocols. Also a lot of internet / TV providers deliver to over multicast, such as BT in the UK. If you added this you'd pretty much upend the home router market and the shitty insecure software they install.
So do you just buy a bunch of cheap domains to host email on? This looks awesome, I'm so tired of other mail services being stupid slow. 
I played around with Go and this a bit further. It seems you can drop the Comparable interface completely and use interface{}, if you are careful with the syntax. Here is the example: [https://play.golang.org/p/5KWAJGr-37n](https://play.golang.org/p/5KWAJGr-37n) 
I am no go expert but I have been studying it for the same purpose. It is new, that’s all I think. It is very important to have lots of people providing lots of library for a language to survive and expand. Also, most companies have a code base and development teams dependent on some of the well established languages like java, c++, python etc. so it would be less effort to struggle around with the existing language they know than have to build, test, and deploy everything from scratch in a new language. one thing I learnt also is that deploying server capacity is relatively cheap. So being very fast and efficient isn’t that great of an advantage. It would be cheaper to deploy twice as much servers on aws running python than hiring a go expert for a small application. Only when the you are dealing with hundreds to thousands of servers that it would actually make a difference
"Greatness" isn't enough for a language to succeed. It's got to be enough better to make learning it a worthwhile investment. Part of that calculation is "how many other people will agree that this language is great and start using it?" Right now, I would be very hesitant to recommend Go to a new programmer simply because there are zero local jobs asking for this skill. In the meantime, there are lots of languages that can provide a REST API.
i am using golang almost 3 years, it is very easy to learn, and you can read easily someone elses code. Maybe, Golang is not popular like others, this is my opinion, but Java has jHipster, Python has Django, nodejs has *something?*... you got the point. If you want to make REST with golang, you need to strecth your fingers. No generators in golang yet. 
With some of those apu2 devices being sub-$100, I would hope on this in the blink of an eye to replace my current router. Upending the CE market is definitely doable.
&gt; It would be cheaper to deploy twice as much servers on aws running python than hiring a go expert for a small application. By this do you mean for a company with an existing infrastructure? Surely any company starting today would be better off creating a REST API using the likes of Go instead of something like PHP The cheapness of servers is something I hadn’t considered before I admit, thanks for the info 
Is it completely a "freestanding" appliance? How about live (re)configuration with de-facto standard Cisco-style shell? 
I get the TV multicast IPv4 use-case, where packets need to travel from the internet into the home network. But why do e.g. Google Home need igmpproxy, when Chromecast doesn’t?
The biggest reason is that Go is still relatively young compared to others. The others are mostly Java, PHP, JavaScript, Ruby and Python and are 20 or more years old. Funfact: Java, PHP, Ruby and JS were all made in 1995 with Python being 5 years older. And Go is already in the top 20 since a few years. 
This is one of my biggest concerns and I appreciate the honesty. There are quite a few Golang jobs in my area BUT none of them are for junior positions. Where as I can find junior PHP job listings by the dozens. I started to learn PHP because of its popularity but after doing some research it seems that PHP is only really used to keep legacy systems working. I’m not sure if it would ever be picked for a new project today. What would you recommend learning that makes efficient REST APIs and is also a promising language in terms of job prospects? (If such a thing exists)
What exactly do you mean by “freestanding”? router7 can be installed (via PXE boot) onto an apu2c4 with a blank disk, if that answers your question. There is no Cisco-style shell currently. Instead, you can use [https://github.com/gokrazy/breakglass](https://github.com/gokrazy/breakglass) to start a busybox shell via SSH when you need interactive debugging access. Of course, If you want to, you could implement a Cisco-style shell, too — I just don’t need have the need for it :)
Do you think that Go will be one of the most popular as it gets older?
You probably should take advice from people more local. I am skeptical, though, that PHP is only used for legacy systems. Whether learning it is a good career move is a different question; my understanding is that PHP pay rates are among the lowest, because they're a dime-a-dozen. A friend of mine said that the closer one's skillset is to web development, the lower the pay. Might be some truth to that. Web development is mainly about putting stuff on the screen and getting it back, which doesn't require a sophisticated Computer Science background. Career-wise, seems to me that Java is still the way to go, but it probably depends on what you want to do. I'm historically a .Net guy, so I have limited Java experience and I don't know how easy it would be to provide a REST API with it.
You should still apply. Very often companies will just as gladly hire a more junior dev who is full of energy and potential. Give them a call or email and ask if they would still interview you. 
You don’t need a go expert for a small application.
This project is really cool! DD-WRT has always been so clunky for me, to the extent that I cringe at the thought of working from home and have even considered sacrificing my current router, and all the nerd knobs that come with it, for a more consumer-friendly option. The open source router market definitely needs modern, programmable and most importantly reliable enhancements, and this project is really exciting to me for that reason. As a side note, where'd you get that USB-serial adapter in the photo of your APU?
BTW, if there are lots of Go jobs in your area and this is what you want to do, you should apply for all of them. People often want senior people, but you can't always get what you want. :-) Plus, the definition of senior is a bit fuzzy. I bet if you can check off the boxes for all of the job requirements other than time in the saddle, you might get some interviews.
Benchmarks are funny. Without context the numbers don’t mean anything. Don’t be too upset about it.
I prefer to write up to a few hundred lines of plain Go / SQL to get things going instead of committing to an ORM. It works well for me. There are less surprises, less things to learn and usually just simpler more pragmatic code. 
me too. I think SQL itself is simple enough.
I make sure my data layer can work outside of my main application. Then in unit tests I spin up a Postgres container to run tests against. Or I run them on my local machine against a temporary db. 
Clicked the link to your post with hesitation seeing "GoLang". Landed on the page and saw "GoLang" everywhere. It's not GoLang. It's Go. If you want to refer to it in a longer form, it's "Golang". Boy, bye.
Thanks! The serial adapter is a PC Engines usbcom1a: [https://pcengines.ch/usbcom1a.htm](https://pcengines.ch/usbcom1a.htm)
We had our hype. My bet is that we are now more stabilizing than growing but on a pretty high level. I don't see Gos niece - concurrent server applications - challenged but we can gain chunks of dynamic languages and Java in the future.
An actual downside... Built-in JSON parsing is "slow" :) You can replace it with fast JSON packages, but it'll be more work.
Thanks! Yes I hear managing dependencies in Go isn’t the best
I have to change to use another framework or router like Chi. It supports regexp on url.
That's one thing that will be changing, big time, in the next couple of major releases.
What kind of timeframe will that be, a couple of years or so?
1.11 is coming up extremely soon, next couple of months, maybe next month even. 1.12 should have the stable implementation and I think that'd be another 6 months after 1.11. You can see the past release dates here to see the pattern: https://golang.org/doc/devel/release.html
For a start up that hasn’t built any infrastructure yet. Go would make sense. That is why I am considering it as I fit in that category. I started my project with python and switched to node because I got better with JS. Now I realize that my app will need some real server side heavy processing, I think go may be a suitable fit and because it is just a hobby project and I am not in a hurry to meet customers needs. If you already have 10 server instances running on a cloud service like AWS and you want to double your capacity. It would cost less money and effort to just get another 10 added to the stack rather than rewriting the app in go and deal with downtime, debugging etc. however if you are a large company then doubling your capacity may require fielding another 100,000 servers which would cost millions so it would make sense to rewrite your app. 
Thanks, that makes a lot of sense! &gt; Now I realize that my app will need some real server side heavy processing What kind of heavy processing will this be if you don’t mind me asking?
The variable file you created is a slice of all the files. Len(file) will yield the slice length, hence the amount of file you have in that directory
Compilation time is effectively free when you're Google and have dedicated build servers
I meant small in terms of user numbers rather than complexity and critics use. If you are running a backend for a financial or military app even the smallest and simplest programs can be too serious to left to someone not familiar with the language security issues and common bugs 
Sadly I'm still at work but I did glance a few things that might help. The last two parts on https://gobyexample.com/json I think there is something that. enc := json.NewEncoder(os.Stdout) d := map[string]int{"apple": 5, "lettuce": 7} enc.Encode(d) But also this sorta made me think too. https://www.ardanlabs.com/blog/2018/02/focus-on-being-precise.html I think what you built is awesome and reusable. Which is hard to do but I think borrowing from the core packages can help as well. I'll try to mess with it after work. 
From memory, and it was a while ago, they used it for initial setup. I'll check tomorrow. Currently sorting out wedding stuff as I'm getting married 2 weeks today!
Exactly. So much shit on consumer routers that something modern and self contained is awesome.
Cool, thanks! And congrats on getting married :)
Thank you! Igmpproxy is awesome but it's unmaintained and in every router you buy in the shop. Just replacing that would be awesome.
I am a huge fan of spinning up containers in tests, so every test always runs against the real db. If you need to mock something out, do it at a higher level than the actual SQL queries (i.e. an interface defined by the caller you're trying to test) Check out how the tests are set up here - https://github.com/fortytw2/hydrocarbon/blob/newui/api_test.go and a small, no dependency helper lib for making this easy - https://github.com/fortytw2/dockertest
It is a bit complicated to explain, but basically I am trying to build a special kind of graph database that is optimized to building and tearing down thousands of relationships per query between some several million nodes all of which have hundreds of thousands of in and out relationships. And the results of each query comes out as complex JSONs containing data from thousands of nodes. So the reason I am looking into Go is to try to create an aerospike /neo4j hybrid where certain data will reside in memory and certain data can be written to disk. I know I don’t have the chops to write something so complex but I have been learning and eventually when my start up kicks in will hire some people who know what they are doing. But for now my goal is to write a prototype using neo4j and I thought it would be cool to see if I can start prototyping the special type of database 
Damn I wouldn’t even know where to start with that kind of thing. Good luck, I’m sure you’ll need it!
&gt; I’d like to make a REST API for a CRUD application May I humbly suggest you fully embrace the genius of HTTP and instead make it a PuGD (PUT, GET, DELETE) app instead? I think you’ll like that much better. 👍🏻 &gt; So why isn’t it used more? It’s wildly opinionated on a few fundamental issues and a lot closer to the metal than most coders have worked in for nearly 30 decades. &gt; I struggle to see why Go isn’t more popular if it’s truly as great as people say. It’s growing super fast. Rome wasn’t built in a day. 🙂 &gt; Does anyone have any idea as to why that is? Yes, I do! 🙂 Give it a try. Don’t take anyone’s word for it.
UPnP device discovery I believe.
[removed]
I was thinking more about what you said, and I'm not sure if there actually is any architecture to add later. Maybe 128b, or 16b? I'm not even sure Go will work on anything other than 32/64b which the library supports.
That's what I feared. I'm a little surprised that standard Go features would return somewhat useless errors seeing as the language seems to be geared toward handling errors well.
Thanks very much. 
Yeah I just bought a couple of cheap domains. I figure I’ll cycle them every year or so to make sure none of them get blacklisted. I was also tired of other email services. Why do I need mb’s of JS and tonnes of ads? That’s why I built this. 
Concurrency and use of channels aren't mutually inclusive.
I don’t think you’ve read my post accurately. 
AAA you totally said that in your README and I missed it! I feel silly now. Thanks for spoon feeding me anyway, haha.
&gt; Syntaxually Sorry for being pedantic but the word you want is "syntactically"
&gt; *[]User almost never makes sense since []User is already a reference type. In many cases, you want to construct the slice by appending to it and so using pointers is much more efficient for memory allocation because if the slice needs to expand, you only need more memory for the pointers.
`dep` was just too slow and buggy imo.
This has a lot more to do with popularity than effectiveness. It takes time for languages to catch on and Go is still relatively new compared to languages like Java, PHP, Ruby, and Python. From my experience, when companies start running into scalability issues and bottlenecks, Go usually comes up in the conversation.
I'm curious about gccgo in general, whether it'd compile this for examlple...
It looks awesome. Simple design and clear purpose.
I prefer to use C++ to develop Qt applications. But there are some projects out there for Go [1]. [1] https://github.com/avelino/awesome-go#gui
[removed]
Question. So does this project just contain the linux kernel and a single compiled golang binary to operate? What's the final size of the image loaded onto the hardware?
Go is designed for servers and CLIs. It's not well suited for desktop or mobile apps. I would suggest using a more suitable tool.
I have alot of python and qt experience, so I naturally wanted to reach for a Qt desktop solution. I've had a play with this binding before: https://github.com/therecipe/qt This one exists as well, but I have not tried. It https://github.com/kitech/qt.go It aims to make development easier by not needing to link to Qt at compile time. Im sure you will also get some suggestions to use a Web based app solution as well 
Certainly the Go libraries in this space aren't that mature, but I don't think Go is inherently unsuited for developing GUI apps.
Since you are passing a string in this example, it will be easier to use `.C` — which is for passing data as C data types — instead of `.Call` — which is for passing R objects. According to the docs on "Foreign Function Interface", a string is passed as `char **`, so your function will take `**C.char`: //export testWriter func testWriter(cPath **C.char) **C.char { // Convert the path to a go string path := C.GoString(*cPath) /* do stuff with path */ return cPath } *References* 1. [Foreign Function Interface @ rdocumentation.org, R v3.5.1](https://www.rdocumentation.org/packages/base/versions/3.5.1/topics/Foreign) 2. [Call External @ rdocumentation.org, R v3.5.1](https://www.rdocumentation.org/packages/base/versions/3.5.1/topics/CallExternal)
radix tree might be of help here.
why not using you go as backend and plug a separated UI using something like electron https://electronjs.org/ like that you can separate your UI and your backend. I've been working with Qt in the past and it's harder to do really nice UI than with some basic web technologies. I don't know what kind of application you want to do but if you have a big backend and just want to plug an UI on top of that separation of front and back can be a good thing ;)
[HttpRouter](https://github.com/julienschmidt/HttpRouter) uses radix tree, but has some limits in URL patterns mentioned in TinyRouter [readme](https://github.com/go101/tinyrouter). In fact, TinyRouter uses kind-of radix tree as a micro-optimization.
Almost: it contains the linux kernel and a few Go binaries. It is beneficial to use multiple processes for isolation and privilege separation. The size of the image is about 8 MB for the boot partition (kernel) and about 20 MB for the root partition (binaries). Note that the root partition is using SquashFS with zlib compression.
gccgo compiles the router7 code just fine, but there is one little issue with [github.com/mdlayher/raw](https://github.com/mdlayher/raw), which needs a patch like this: @@ -14,7 +14,7 @@ func newTimeval(timeout time.Duration) (*syscall.Timeval, error) { return nil, &amp;timeoutError{} } return &amp;syscall.Timeval{ - Sec: int64(timeout / time.Second), - Usec: int64(timeout % time.Second / time.Microsecond), + Sec: syscall.Timeval_sec_t(int64(timeout / time.Second)), + Usec: syscall.Timeval_usec_t(int64(timeout % time.Second / time.Microsecond)), }, nil }
Take a look at [jmoiron's sqlx](https://github.com/jmoiron/sqlx). It helps with a lot of the rote tasks involved in getting data into / out of structs, while not trying to be an ORM.
Ok but so when you write applications, do you have to keep updating these query strings? I'm just wishing there was a way to do SQL non verbosely. 
Actually, this looks promising: [https://github.com/volatiletech/sqlboiler](https://github.com/volatiletech/sqlboiler)
give [http://gorm.io/](http://gorm.io/) a try 
I rarely change the SQL for a CRUD app after I write it, unless I have added a new field or need to correct a bug. 
Oh that's improved a lot since I've seen it. Thanks
The goto keyword was added when the go team was converting the C Golan compiler into go. This keyword is apparently very useful in writing the Golan compiler.
I liked this talk very much, which relates to your question. It seems there is no video (yet ?). So you will have to do with the text. http://www.kytrinyx.com/talks/scandalous-story/ 
[Awesome-go has a nice list of ORM-ish packages](https://github.com/avelino/awesome-go/blob/master/README.md#orm), but I usually just create a dedicated “datastore” package that centralises the data access layer. jmoiron/sqlx is great to reduce some of the boilerplate of scanning query results into types. I found this approach works pretty well and scales just fine (or rather: great!).
Wow.. The fact that Skype, Discord and others use this technology is really impressive. Actually my web app is nothing huge, it's just a websocket chat app that is backed by a database. I created an API for it so the only thing that client has to do is to send requests, parse JSON and display it nicely in a GUI.
What is as suitable tool in this case? I really don't want to use Python for this as this has been my main language for over a year and I'd like to explore some new ones. I touched C++ and Kotlin but at this point I don't remember anything about them, making a project is the best way to practice.
This isn't a good idea really IMO. I used to think I needed these sorts of things, but then realised I didn't. You tend to need these things in places where you'd otherwise just end up having to use `interface{}`, at which point you're probably still going to have to do some weird hacks. Either that, or you just want to force an interface in there for no good reason. Can you provide a more concrete example? Maybe some more suggestions of alternatives can come out that way?
The videos appear to be down, I'm getting the following error underneath each video section: "Gallery not available". Any chance to have this up again?
Alternatively https://github.com/zserge/webview
Imgine this a few decades ago: - "I need help with this cool Emacs mode". - "Meh, Eclipse for the win! Eclipse has everything I need!"
Thanks for getting back to me! It's a very interesting project. One more question, I think i'm starting to get the picture now. Does the root partition have any non-golang precompiled linux binaries? Like, for example, would the /sbin folder have no need for a copy of the 'ip' binary?
All binaries on the root partition are written in Go. There is no /sbin directory (instead, /init starts binaries from /gokrazy and /user), and no \`ip\` binary :) Side note: the \`rtr7-recover\` tool bundles a version of e2fsprogs (to create the ext4 file system for the permanent partition) and pxelinux (to netboot the apu2). This tool is only run on your computer, and entirely independent from the device image.
Thanks for this amazing response, and especially cool that you know the source for the quote. It's quite eye-opening going through the timeline of pull requests - I never realised how in-depth those discussions were! It goes to show that good software is iterative -- even more experienced programmers than I will have at it multiple times. Thanks for your thoughts.
I always thought that tests were to ensure correctness, and so I've neglected them (since I'm not writing production code), but I never thought about the benefits of *trying my own API* through the tests themselves. That's a really good idea, cheers!
This is a great point. I only ever thought of tests as ensuring correctness, but never self-testing the simplicity of my own API. I'll definitely use this line of thinking to evaluate my stuff in the future.
That's the issue I have with Go interfaces -- when to use them? In Java, for example, I'll use them to ensure "correctness" when swapping implementations. This is a valid use-case for Go interfaces, but then there's also the general `Reader` and `Writer` interfaces, which are *much* more abstract, and yet widely used. It's this sort of insight that I find difficult.
I'm simultaneously hacking through Go and Haskell -- one (eventually) for production, and the other for personal interest (maybe it'll get deployed, but I'll take longer to get there). Although it's hard for me to apply some FP concepts directly, the general idea of purity and designing via types seems quite applicable across both paradigms. Would you recommend Structure &amp; Interpretation (and Lisp, for that matter) to someone already learning Haskell? I've picked it up previously, but didn't finish it.
Very cool. Nice work! Thanks again for answering my questions.
Can you link some article explaining the superiority of PuGD over REST?
What about swagger? [https://github.com/go-swagger/go-swagger](https://github.com/go-swagger/go-swagger)
if you want to make api documentation, go-swagger can parse details about your api and generate your api documentation. Swagger is not a API generator, it is API DOCs generator. 
PyQt for GUI should be fine.
last i checked, it is only for api docs generation. Not like complete api generation with data models, db operations, etc.. 
Take a look here: [Go GUI](https://github.com/askunk/awesome-go#gui) I would especially look at [https://github.com/asticode/go-astilectron](https://github.com/asticode/go-astilectron) 
I'm using go-pg. But it's for Postgres only.
well, if you design your code in a way where actions on persistence layer is abstract, you can use many (or any) library for ultimately talking to your infrastructure. (which in your case is the database) for instance, you can declare an interface for working with a certain storage backend: type Account struct{} type AccountRepository interface { Get(int) *Account GetAll() AccountIter } // an iterator for a list of accounts type AccountIter interface { Next() bool Iter(*Account) err } Now you can plug in any sql/mongo library, and this is not strongly tied to your code. if you're looking for an ORM, try: * [http://gorm.io/](http://gorm.io/) * [https://github.com/upper/db](https://github.com/upper/db)
In Go there are three types of inspecting errors. 1. Sentinel errors which are exported and can be compared with (like EOF) 2. Type assertion on errors to gain access to struct fields 3. And the best: Type assertion on behaviour. If you look at the net.Error type it is an Interface and falls under category three. Assert the error on Temporary or Timeout and you should get the information to handle the error. Here is a talk from Dave on this: https://www.youtube.com/watch?v=lsBF58Q-DnY
The compiler is getting a lot better about removing bounds checks with the new Prove pass.
Ok, so this makes the "official experiment" of dep cancelled? I read the entire conversation in the Google groups thread and that was the impression I got. Seems like there are a handful of concerns people have. I didn't follow it very well. Sam Boyer (of dep) called it a "sad milestone". Yikes! 
Nothing has to happen. Stability and consistency are highly important and Go is great at it. Companies are hesitant to invest in new technologies and old ones stay around for ages. C is still one of the dominant languages and is by todays standards considered ancient. There is still a good amount of COBOL around and it is 60 Years old. Give Go 5 years or maybe 15 and then judge.
And another one!
Can you link to these suggestions? 
I was (and still sort of am?) in the same boat. My best advice echos the other advice in here basically. Start thinking of testing or how you can get the best test coverage before you write the implementations. This really helps you compose the implementations in a way which is easily testable and "clean". But i'll also add like others here that you won't get it perfect on the first iteration, nor should you get too hung up on it! Get it working first, then iterate later. But don't get carried away either- my rookie mistake at first was using interfaces everywhere and mocking everything, when in reality that just adds complexity and makes your code harder to read. 
The range construct may do that, but it incurs a penalty elsewhere. My C-style loops always performed better on benchmarks than range loops.
If you are doing this to build up a resume for hiring purposes, you may be better off contributing to an existing, popular open source project on GitHub.
I could not switch (mostly due to stubbornness of not wanting to reorganize my project structure) to dep. I maintain a single repo project at work that's currently using gb and want to manage dependencies outside of src/GOPATH, There's an existing defect to support that workflow, but it was apparently non-trivial so remains unfixed. Go Modules work like gb and will be easy to switch to it. From the outside looking in (and periodically at that), there are two things: 1. Russ and Co. have declared by fiat (seemingly - there was \*some\* off line discussion between the parties) a new solution that came out of left field. 2. Sam Boyer keeps saying that dep was just an experiment but it seems to have gotten a little married to the implementation with the expectation that it would become the blessed way forward and so is a little ticked off that it did not. As a pragmatist I just want something that works with out too much work to switch too (after having implemented two other ways of maintaining dependencies). gb has worked for us for over two years (despite being abandoned!) and see no reason to switch until the dust settles (ie sometime after go1.12). I will say that as a rails shop too, that we fight with bundler every other month and so maybe Russ' approach IS better, time will tell.
An one which is both faster and flexible. At least faster than gorilla/mux and more flexible than HttpRouter. :)
First off, pick something your interested in. This helps keep you motivated, and helps you sound interested in it when you have to explain it in an interview. If you can't think of something interesting, then pick something like a Linux command line tool, or a service. Then just think out how you would build it, and what parts of go you would need. For instance, if you were to build out the top command from Linux, which shows the running processes and their usage. How would you get that information? You have to update it in real time, so you probably need to use go routines. You'd probably need a strut for processes, maybe an interface to help clean up the code. Etc etc 
Why not submit a PR? Make mux faster. Make httprouter more flexible. I’m very new to the go community, but it definitely feels fractured in the sense that everyone wants to build their own stuff. Everyone wants to build “the one”, I suppose... there’s a certain glory that comes with that. Anyway, cheers! Your contributions are more than mine, so I’ll stop talking shit. I appreciate your efforts.
Nice! What about providing type specialization along the lines of `cznic/b`?
I don't think avoiding `net/http` is the correct conclusion to reach. A better conclusion would be, to explicitly use a fully configured [http.Client](https://godoc.org/net/http#Client). Or use [ctxhttp](https://godoc.org/golang.org/x/net/context/ctxhttp).
Calm down, baby. What you have expressed shows you don't understand the situation. (Or you are not experienced programmer. Sorry it is offensive.) The main algorithm of HttoRouter determines it can't (or hard) to be flexible. The flexibility promised by mux determine it cound't be faster, as it must support regexp matching. They have their respective advantages, and have their inevitable disadvantages. No routers have all the advantages. Their disadvantages is impossible to be removed by a PR. Their algorithm determines their disadvantages. For package users, they must make a decision depending their project needs.
Most concurrency libraries seem to be built on tokio, which is a reactor/event loop. The most performant web server/framework right now is actix-web which is built off of actix, an actor framework built on tokio. It can be multithreaded with an event loop per OS thread.
Is there a text copy of that? I'm still a little unclear as to how we determine the cause of the error. It looks like he creates interface types for every possible error variant that he can get? I'm used to handling exceptions and Go's errors seem completely foreign to me.
[removed]
[removed]
[removed]
The community is really against DI libraries (rightfully so, IMO). A question that I have, is can you not define interfaces for the above types and simply mock them yourself? What does a library buy you?
That's a good idea! Although this would make the skiplist a little harder to use (instead of just plug&amp;play) with manual interface adjustments. And (at least with a normal makefile) it wouldn't be completely os independent any more. I think about it! 
It looks like, my SkipList is now the fastest SkipList implementation available in Go :)
In your case you would define an type temporaryError Interface { Error() string Temporary() bool } or just the Temporary method and then assert the error like this: err := function() if err != nil { if terr, ok := err.(temporaryError); ok &amp;&amp; terr.Temporary() { // handle temporary } // handle non-temporary error } It is not pretty either but you are fully decoupled from any package.
Also, my (sadly slightly stalled) https://github.com/dgryski/go-perfbook
Tell us , stupid grunts , to what we should switch. I just don't know now.
From my experience: high level (http, and handlers) are simple, but Everytime when i go to net.Conn layer it become hard
Just go the vgo way when 1.11 is finally out?!
Will that happen?
I actually find it the other way round. But i'm a nut for lower level networking. It is really fun to design your own tcp protocol for example.
,just now i have a lot of problem with detecting if tcp connect is alive. Can you help me with that ?
I guess you want to detect it before you write anything to the conn right ? Because if it is ok to detect it while writing, you can just use the returned error.
Yup, without writing. Just reading with scanner
&gt; Ok, so this makes the "official experiment" of dep cancelled? An experiment has to end at some point.
Hmm afaik it is not easily achievable using standard functions from the net package. I would have a look at the conn.File() function and then the doc for your target os of how the file descriptors look. Since all that the conn.Close() call does is closing the file descriptor i would look at that.
Yes, Go 1.11 will be released in August.
Ok, so that kind of makes sense. It seems clumsy to put the owners on the package user to create a method to identify errors rather than just giving the error type a means of identifying itself. For a simple project I'd have more lines describing all of the error interfaces (that are already described in their own packages) than I'd have doing the actual work. 
We use gRPC for communication between services. grpc-go includes a resolver which can do service discovery using DNS ([https://github.com/grpc/grpc-go/blob/master/naming/dns\_resolver.go](https://github.com/grpc/grpc-go/blob/master/naming/dns_resolver.go)), though you can provide a custom resolver. gRPC isn't asynchronous, but it does allow messages to be streamed from gRPC server to client and vice versa. There are a number of other benefits to gRPC, including its use of the protobuf protocol (very lightweight compared to JSON), and the ability to trace requests across gRPC calls (e.g. trace that service A calls service B which calls service C, see [https://github.com/grpc-ecosystem/grpc-opentracing/tree/master/go/otgrpc](https://github.com/grpc-ecosystem/grpc-opentracing/tree/master/go/otgrpc)).
https://github.com/yosssi/gohtml
[Sam Newman](https://www.oreilly.com/pub/au/6132)'s [Building Microservices](http://shop.oreilly.com/product/0636920033158.do) is a pretty good starting point. It covers everything you listed besides containerization IIRC. 
[https://stackoverflow.com/a/35204244/711902](https://stackoverflow.com/a/35204244/711902) {{range .foos -}} &lt;tr&gt;...&lt;/tr&gt; {{- end}}
You can use whitespace-trimming tags \`\`{{-\`\` and \`\`-}}\`\` but you can't really beautify it without piping it through something else.
I've tried both solutions and they are incredible. I can't believe I couldn't find it sooner. gohtml, while it works perfectly beautifies my code, I do have some issues with CSS, so I'll have to fix that. Meanwhile, I took upn using the trimming tags and they work beautifully too. I'm still getting the hang of indenting along with action codes. I'm getting there though. Thanks everyone!
Check out gizmo! The people at the new york times have put together an awesome microservice toolkit https://github.com/NYTimes/gizmo
Unless I'm making a new project from scratch every time like I would be if I worked for a contract agency, the data part of my application is an extremely small part of my overall time in a project. Therefore, I would much prefer the flexibility, power, and visibility of using SQL. I prefer SQLx as mentioned by tetherbot, but I've been trying out [badger](github.com/dgraph-io/badger) as a key value store and like it a lot.
Could you elaborate on your bundler issues? I've always thought, from an outsider perspective, that Ruby had dependency management down.
Now that I've looked at it a bit more, the Rust version is using pointer arithmetic in the for loop which speeds things up a lot. I created a [Go version with pointer arithmetic](https://play.golang.org/p/MdaiHHCeXH-) (I also inlined the call to tape.Move since Go wouldn't) and it is much faster: 2.2 secs vs 5 secs for the [original](https://play.golang.org/p/OZ_qpUtShrv). The Rust version is still faster at 1.8 secs. Disclaimer: I'm not suggesting this a good way to do things in Go, just trying to understand why Rust is faster.
If you are talking about web-dev specifically, I would recommend at least taking a look at the serverless framework. I've found it very easy to get setup an running!
Here's the Go code corresponding to the above Rust code: const opsize = unsafe.Sizeof(Op{}) func _run(program []Op, tape *Tape) { start := uintptr(unsafe.Pointer(&amp;program[0])) end := start + uintptr(len(program))*opsize for p := start; p &lt; end; p += opsize { op := (*Op)(unsafe.Pointer(p)) switch (*op).O { case INC: tape.Inc((*op).V) case MOVE: //tape.Move((*op).V) tape.pos += (*op).V for tape.pos &gt;= len(tape.tape) { tape.tape = append(tape.tape, 0) } case LOOP: for tape.Get() &gt; 0 { _run((*op).Loop, tape) } case PRINT: fmt.Printf("%c", tape.Get()) } } }
What are you talking about? You mean a construct like this: for i, _ := range s { s[i].doSomething() } That's not exactly idiomatic, is it? I'm sure that would eliminate both the copy and the bounds checking, but that's not how the range construct is presented or will be used by your average person. And that was my point, that range is meant for convenience not performance, wether you can achieve the best performance by bastardizing it isn't exactly relevant to it. Plus, like others mentioned, the latest compiler improvements do eliminate bounds checking on C-style loops. What is your point exactly?
To leave here at least one bit of constructive criticism is that you don't have to create a separate example folder. Instead it is better to provide an testable example with is also part of your documentation. There is a great post on the Go-blog on this topic: https://blog.golang.org/examples
[removed]
What are you using currently and is it cauing you pain? If you are currently happy, just sit back and watch Modules mature over the next 7 months and wait until 1.12. I expect the dep-&gt; modules transition to be smooth so if you currently using another package manager switching to dep now might be a good idea. If you are currently using dep it is probably best to keep using it until your dependencies start supporting modules. 
Sure, we have lots of gems in use and sometimes there are incompatibilities between them and so you have to relax or tighten the constraints so the solver can generate a solution. It's a black art that others on the team have more patience to figure out.
True, sorry for my ignorance. I kind of “upgraded” imo from sublime to vscode.
I think the common knowledge is to avoid the default HTTP client, rather than the entire net/http package. The default client doesn't have timeouts configured by default, so requests to external services can hang indefinitely. You can avoid that by defining your own http.Client.
Implement a generic min or max function.
vgo is *not* included in Go 1.11 but module support is.
A common thing in research is to create a compiler for a different language. This is not so much a real-world application but it teaches you a lot.
What is DI in this case? I'm not familiar with the abbreviation. 
Still dont understand why people dont use git submodules
Module support is the official name of what was temporarily named "vgo". Former "vgo" has been fully merged into the main repository as part of the "go" tool and will be included in 1.11.
How you store dependencies is a very small part of the problem. The hard part is around selecting the correct versions, it can get hard...like NP-complete kind of hard. The video from Titus Winters that Rus reference here does a great job talking about the issues. https://research.swtch.com/vgo-eng Another good link: http://thefeedbackloop.xyz/thoughts-on-dependency-hell-is-np-complete/
A tiny thing one could change here is first-line-of-loop into this: op := *((*Op)(unsafe.Pointer(p))) and then turn all subsequent `(*op)` into simple `op`. As you present it, you tend to dereference the pointer `op` at least 2x per iter, except for PRINT, and many times more for LOOP. Can't recall off the top of my head if Go compiler does common-subexpression-elimination and if so, how well. I generally implicitly assume an utterly-non-optimizing compiler in Go development =)
So... every Go binary now is a module? I don't get how they got from package dependency management to modules.
My toml file looks like so for the root declaration: [metadata.heroku] root-package = "github.com/maxdobeck/basic-app-api" go-version = "1.9" I vaguely remember getting this error and I believe it was aymtax related. 
I suggest learning some html/css to make your front end. Its a versitile skill with cross over to cross paltofrm frameworks and expressive way to convey UI. 
It sounds like a lot of your list is more concerned with the infra/DevOps side. A lot of companies are probably going to be doing this stuff on AWS or GCP in practice. AWS has a free tier for practising this stuff. You'd probably be interested in services like [API Gateway](https://aws.amazon.com/api-gateway/), [EKS](https://aws.amazon.com/eks/) or [ECS](https://aws.amazon.com/ecs/) (orchestration), and [CloudWatch](https://aws.amazon.com/cloudwatch/) (monitoring) among others. You can set up multi-consumer async messaging with a combination of [SNS](https://aws.amazon.com/sns/) and [SQS](https://aws.amazon.com/sqs/), but I've found there are a lot of compromises if you're aiming to get what RabbitMQ or Kafka can offer.
Hope this helps: ``` [metadata.heroku] root-package = "github.com/prhineh1/panurge" go-version = "1.10.3" ensure="true" ``` Maybe we just need to specify the `go` runtime version. I've just added the `ensure` just to install the dependencies found in your `Gopkg.toml` file. But you can remove it 
maybe [https://github.com/micro/go-micro](https://github.com/micro/go-micro) go-kit it pretty decent but I get what you're saying, there's quite a lot of parts to grasp.
PuGD is REST. CRUD is the SQL verb set and less useful IMHO. I don’t have any video links on hand, and it’s a huge discussion, but you should really avoid CRUD thinking IMHO.
Look at the source of professional pages on the internet and you’ll see no one cares what the final line breaks look like. Once the page is gzipped, the size differences are microscopic. It’s not worth worrying about. It only matters that the source code is readable, not the output. 
&gt; due to the issues with the timeout So, set a timeout? Bad idea to throw the baby out with the bath water...
Close a ticket at https://github.com/golang/go. It’s quite doable. 
In my experience, gRPC is overly complex for most tasks and can have issues related to versioning. [Twirp](https://blog.twitch.tv/twirp-a-sweet-new-rpc-framework-for-go-5f2febbf35f) is a pretty good alternative for projects that need the complex features of gRPC
That makes it slower (3.4 secs) because you are making a copy of Op.
I'm not sure what level of critiquing you're looking for, but you say you're new to programming, so that makes everything fair game. First, I wouldn't mix all the database access code in with your handlers. I know you're just playing around now, but I have to point it out. Second, you'd probably want to replace all the constants with some sort of configuration file. Third, you might consider using the Gorilla mux; it provides for url patterns that break out the variables for you in your handler. (I've never used Golang's default mux, so maybe it can do that too.)
Looks fine for something so trivial. Once you expand this, you will want to separate the database code into a repository struct and probably pull out other logic as needed
&gt; Is there a text copy of that? Not sure if this is a 1:1 text copy but this is the relevant article from Dave's blog: [Don’t just check errors, handle them gracefully | Dave Cheney](https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully)
Modules are versioned packages. You can now specify the major version in the package import name and the resolution of transitive deps is managed by the "official" go tools. 
From the readme: &gt; * Generates a server from a swagger specification &gt; * Generates a client from a swagger specification &gt; * Generates a swagger specification from annotated go code Looks like it evolved into doing more than just doc gen. 
Cool stuff! But as others have said you should follow best practices so you don't end up pulling your hair out down the road. (or ignore best practices and find out why people recommend them! :) 1) bare minimum all connection info should be accessed through an Environment Variable 2) config files are the best for accessing lots of env variables especially when deploying. This isn't a huge concern for you now but it's good to be ready 3) for the http handlers you should get used to declaring what method your http message falls under. I'd it a POST, PUT, DELETE, GET, etc... After you get the above sorted is gorilla mux. The gorilla library has a ton of useful stuff. 
Didnt test yet but i think its mock server
Nice man!
Very nice. Not ready for prod but it’s a great proof of concept. I think you’re supposed to handle rows.Error() after the loop though, or something. 
You're right. It's just a pet peeve of mine coming from the old straight-up HTML writing days how I wanted the output code to be nicely formatted. Back then there were no inspectors or developer tools, you just had to dig straight into code to find what matched with what. And it was a good practice to keep the codes nicely aligned and it also felt like a neatly organized room. Those days are long gone, but that mentality stuck with me I guess.
Its a full server. Been using it in prod for almost two years.
The first place to enable config changes should be flags and environment variable (or just environment variables passed to flags). I find config files awkward to automate deployments. I’ve never tried gorilla mux because I can usually muster the few lines of go to do whatever I need. If you’re feeling ambitious, take a look at using .proto files to define an RPC and either grpc, gogoproto, or twitch’s framework to generate client/server stubs. 
In fact, I'm preparing to improve the in-code docs and wondering how to show examples in docs. Thanks for the timely info.
Personally, I've had quite a pleasant experience with [GoQuery](https://github.com/PuerkitoBio/goquery). Once that's done, all you need to connect it to an android app is an API service. Be warned that some websites might IP ban you for scraping though.
&gt; It sounds like a lot of your list is more concerned with the infra/DevOps side That's a bit of a hasty conclusion. Some orgs won't delegate infra or ops to another team, at all. Some will, but only after everything's polished, packaged, documented and monitored. Not here to argue the merits of one or the other, but with "containerization" on OP's list, everything can be done on one laptop... though it might be a tad like having sex in a Mini Cooper...
why do you have a vendor fodler in src? dissolve the services folder, i feel like it redundant and put all the contents in /src
&gt; Thoughts? If you can't be bothered to explain yourself, I can't be bothered to click some link and guess what you mean...
I am working on a toolset for writing distributed applications following the CQRS and Event Sourcing architecture. It is still a work in progress but maybe it could help you. [https://github.com/sysco-middleware/commander](https://github.com/sysco-middleware/commander)
You can use any project structure you like. That's the best part about it :-) What you have is very different from the common project structure patterns in Go however. The 'src' directory is an anti-pattern. No idiomatic Go project uses it. Note that the Go source code happens to use it, which is a bit unfortunate and confusing to newcomers trying to figure out how to structure their code.
try [colly](http://go-colly.org/), it's the closest to python's scrapy (which became a standard for crawling over the years) and uses [goquery](https://github.com/PuerkitoBio/goquery#examples) for parsing.
Some newbie programmers always think no problems can't be resolved by PRs.
Collecting, choosing or comparing instance types offered by all major cloud providers based on their parameters and/or pricing is no easy task. Nevertheless, DevOps teams usually know the resources they’d like to start with - e.g. 32 vCPU, 128GB RAM with advanced networking and half of them on spot price. Let Telescopes turn your resource requirements into infrastructure recommendations, check their accuracy, whitelist or blacklist certain instance types and Pipeline turn these recommendations into Kunernetes clusters (and autoscale them). 
Yeah, we use dep now.
Yeah, it seems painful to me.
Try my Go playground at https://play.jsgo.io/ - has syntax highlighting, runs your code in the browser, and best of all: supports importing arbitrary packages!
Since you're using gRPC, the standard way to do "middleware" would be interceptors: * https://godoc.org/google.golang.org/grpc#WithStreamInterceptor * https://godoc.org/google.golang.org/grpc#WithUnaryInterceptor * https://godoc.org/google.golang.org/grpc#StreamInterceptor * https://godoc.org/google.golang.org/grpc#UnaryInterceptor
Can you clarify where are you seeing syntax highlighting in go tour ? Go tour uses playground itself for running examples.
Checking the link, it looks good only it's reserved exclusively for Prime members.
It's also available on the Play Store if you're not a Prime member. [Here](https://play.google.com/store/books/details?id=RDl4BgAAQBAJ). 
It’s because Rob Pike doesn’t like syntax highlighting. Seriously.
Not *just* Rob.
&gt;With Go 1.11 and modules you can write your Go modules *anywhere you like*. I just can't believe it took eight years to reach this point. EIGHT fucking years.
Well, Pike is the one being vocal about it, calling it "juvenile", so... See: [https://groups.google.com/forum/#!msg/golang-nuts/hJHCAaiL0so/kG3BHV6QFfIJ](https://groups.google.com/forum/#!msg/golang-nuts/hJHCAaiL0so/kG3BHV6QFfIJ)
Agree GoQuery is good. OP, I just used `goquery.NewDocument(url)`, `doc.Find()` to find the right parts and then `elem.Text()` to extract text as an example, for my personal project. Works well.
AFAIK, the only place it's used is in test data, and packages that directly deal with source code where it is actually an appropriate name.
It's nice as an experiment( and i will never dismiss the importance of experimenting with Go, unlike some gatekeepers here). but you just shoved a subpar dynamic language into Go at the same time. It makes very little sense here, it makes even less sense in PHP which is already a dynamic language. This is why I despise Symfony, overengineering to the maximum in the quest of justifying its own existance (and sell consulting).
Does that dude just hate developers or something? Seems like he delights in shutting on common things. 
I totally sympathize. The {{- name -}} trick can be useful in spots, but mostly you have to let it go as perfectionism. 
Some times you need something like it (and I needed such thing, so I did it). 🤗 Imagine shop admin gui, there user want to write rule for free coupons (and rules can be complicated as we have a lot of params such as item, inventory, history, geo location, marketing campaigns, etc) and such rule engine is really good helper here.
IMO a project should be one single package and therefore be one directory. If you build an executable you can separate it from the rest in a cmd subdirectory. Don't be afraid of packages with like 20 files. Give them meaningful names so you find function definitions easily. Only split of parts that are truly self contained and serve a purpose by itself.
I also made many of these tradeoffs for Go Lambdas when I built \`step\` a framework for Step Functions, here [https://github.com/coinbase/step/blob/master/handler/handler.go](https://github.com/coinbase/step/blob/master/handler/handler.go). The source code of the go-lambda SDK is super complex only because they wanted to support the multiple function signatures, only supporting one makes a lot of sense, also reimplementing their Dynamic parsing of objects, by looking at the handlers function signature was super fun as well. 
https://adhocteam.us/2017/10/09/stop-your-business-rules-engines/
It could be worse with earlier bad solution.
There's a "Syntax on/off" button in the upper right corner of the tour.
Yes, he made a comment about syntax highlighting six years ago in a thread about syntax highlighting. He's not even the only one arguing against syntax highlighting in the thread.
not surprised at all. just look at his stupid 70s glasses he always wears, guy is clearly out the touch.
&gt; Seriously, it would be so useful Seriously, that's your opinion and that's of course just fine. But it's not the only opinion out there, so not everybody would say it's useful. You can please only one group whichever option you chose.
I would suggest you provide more code to demonstrate your implementation. Conceptually, there is no problem setting a persistent flag on the root command that should propagate fine, so it is likely down to implementation. A cut-down, reproducible example, eg with a root command + subcommand that is runnable, will make it such that it is simpler to help.
Not really. You can please both by doing the same thing they do in the Go Tour by adding a Syntax on/off button. Not that hard.
I agree and think a good parallel is generated code from go generate. Don't worry about it not being super pretty. It's there to do a job for you and once the job is done, you aren't supposed to worry about it. 😎
Just an opinion. Again: some times it's needed and good to have BRE for some tasks. Use it wisely. 
I get `package github.com/snapcore/snapd/release: too many git objects (max 30000): 162773` when [testing it out with my current project](https://play.jsgo.io/c976a83ff4e1463a7f3e835bd596c88be60550fd). :-(
It's very useful, but i have one big issue with it: when visited, playground should be empty :)
I did this! [Here](https://github.com/therealfakemoot/genesis/blob/dev/cmd/root.go#L22-L29) is the relevant section of my RootCmd, and I setup my logrus in a separate [package](https://github.com/therealfakemoot/genesis/blob/dev/log/log.go). So I use PersistentPreRun because that gets called before *ANY* Cmd object does any other setup. This binds all my flag values into viper, and also toggles debug mode on or off. After that, all Cmds and subsequently imported packages are free to use an already configured `genesis.log.Term` as desired.
In between there were multiple projects like godep, glide, gb, dep etc. People who need something immediate used those tools. Most languages depend on 3rd party tools so what is the big deal?
Unfortunately, this didn't work either. I'm still getting the same error. 
Pretty much.
He's not arguing against syntax highlighting, he is single handedly dismissing it as childish, juvenile, spitzensparken blinkelichtzen with his usual condescending and arrogant tone. Remember he's one of the core designers of the language so no wonder why people sum up this issue with "because Rob Pike" said so.
Isn't that what makes you a great engineer?
Godep, glide, dep and friends were all about dependency management and still required Go code to be in the GOPATH, gb was the only one trying to get away with it. But with most (if not all) of the tooling around those third party projects \*still\* requiring the GOPATH it was an uphill battle and it never really worked, even the shell based manual solutions had obvious tooling issues. Having the GOPATH killed by the core Go team \*garantees\* that those issues will be addressed globally. So yes, that is a big deal.
As others have pointed out, [this](https://groups.google.com/forum/#!searchin/golang-nuts/syntax$20highlighting$20playground%7Csort:relevance/golang-nuts/hJHCAaiL0so/X4rKDXbuLH8J) is basically your answer. You'll also notice a distinct similarity between the playground color scheme and Acme, and this is no coincidence. 
There is [go-critic](https://github.com/go-critic/go-critic) linter that performs this kind of check: [go-critic/rangeValCopy](https://go-critic.github.io/overview#rangevalcopy). In addition to that, there is also [go-critic/rangeExprCopy](https://go-critic.github.io/overview#rangeExprCopy-ref) that detects unwanted array copies. 
Was not aware of these. This could be helpful - I am not using gRPC but [Twirp](github.com/twitchtv/twirp). I'm wondering if they have something similar available. 
Is `github.com/prhineh1/panurge` is the one you will deploy on heroku? Or is `https://github.com/prhineh1/Go-site`? Because maybe heroku doesn't see that project directory 🤔
Aah yes unfortunately if there's a big git repo in your dependency tree it'll fail. That's because it does a git clone using the github.com/src-d/go-git which is rather a memory hog. I was getting the GKE boxes crashing with out-of-memory errors until I added this limitation.
Why not use `git` itself?
A couple of years ago I created and supported a Go server application that used os/exec to run various commands including git. It had to keep tabs on the long-running git processes, cancellation was really difficult, managing the temporary files was a nightmare. Lots of mysterious crashes we never solved. Spawning sub-processes that use the filesystem just isn't something I'd want to do in a serious server application. Go-git keeps everything in-process and in a memory resident filesystem. However it has it's limitations with memory. 
Could it be the in memory resident file system? I can see the complexity involved with os/exec but why not use the file system?
config.toml in the root directory works for small/simple projects. It gets messy for more complex projects (multiple config files, config file templates, other related config components)
I believe go-git still uses lots of memory if you use the native filesystem: https://github.com/src-d/go-git/issues/447
I just had some friction with this with a partner (me prefering simplicity, and him fleshing things out a bit more), and we managed to agree on the following: - repository package (data updates and access), - service package (business logic around data), - grpc/rest/websocket packages for translating requests into service calls - types package (all the struct data types for your app) My initial intuition said that it's good to merge the repository and the service packages into one, but on some thought, I do find value in separating business concerns away from data models. If you have to update data + write an audit log from one request - this is a job for the service layer, to interact with all the required repositories. The repository layer for the data updates thus stays relatively clean. Obviously there are the usual structuring paradigms like a `cmd` and `internals`, but even after researching packages, the above seems a best bet for a larger project. Depending on the size of each of your packages, you might cheat a bit and merge some of them together, but that's about it. Regardless of which communication channel package you add on, you'll still be using the same service layer and will not duplicate any business logic.
Can you clone using [depth](https://godoc.org/gopkg.in/src-d/go-git.v4#CloneOptions)=1 in this scenario?
Can't you tell it to do a shallow clone (Depth=5 or something)?
Config files really aren't tough for automated deployments; you just have .test vs .prod versions and rename them appropriately during a copy. Personally, I find environmental variables annoying and resent when I'm forced to set them.
Unfortunately because we want to do a "git fetch" to pull the changes at a later date, we can't use "depth=1". Here's the git code: https://github.com/dave/services/blob/9e41cc58efc0f622d14e89e3502a6311d457c3ed/fetcher/gitfetcher/fetcher.go ... if you can think of any optimizations, PR's are most welcome!
Yes, that works perfectly! Thanks for helping. So I assume that if my input is an array of strings, \`func testWriter(cPath \[\]\*\*C.char) \*\*C.char {\` would not work, right ? Any suggestions on how to format it ?
Quick notes in order of reading the code: - in imports, it's good style to separate non-stdlib ones (like github.com/...) from stdlib ones with an empty line - credentials could be made into flags; be careful however if you add password, it should best not be passed via command line flags, as then other users on the machine could easily see it (env or config file are better); - as a general rule, you shouldn't declare psqlinfo as a global variable; instead, you should build it in main and pass to the subsequent functions, possibly wrapping it in a struct (or just a new type - e.g. `type db string`); that said, in this particular case, it is somewhat acceptable, given that the whole codebase is so small and it actually improves simplicity at this point. However, as an excercise, you could try wrapping it in, say `type database string`, then making the funcs be instead methods on `database`, and finally building a `db := database(...)` variable in main and calling the methods as: `HandleFunc(..., db.getNames)` - what you called `psqlinfo` is generally known as a "connection string", so your variable name should ideally reflect this; in getNames: - godoc comments should begin with entity name — e.g. `// getNames does this and that`; also, don't explain how the function is used, because this may change with time, and is not dependent on function (it's only wishful thinking in this case); instead, describe what the function does, and any extra requirements how it needs to be called ("contract" with caller); let the callers worry what use they decide to put this function to. - you should move `name` declaration as close as possible to its first use (in this case, in the line between `for...` and `rows.Scan`); you don't need it earlier insertName: - godoc: same 2 comments as above; Extra: - personally, I learnt to like to aim to structure my code "top to bottom", with high level functions first, and lower lever "helpers" later; for me it helps when reading: I start from a high level overview, then I can drill down only on the subparts I need in some particular investigation. Not sure if I'm clear here; do you think you understand what I mean, or should I try to elaborate more? Other than that, looks cool and clean on first glance. Especially your attention to handling errors is highly commendable for a newcomer.
I believe that a shallow clone prevents you from doing an incremental fetch later... (I think this is another go-git limitation).
"Resource usage" is really vague. It's pretty common to track metrics like time spent in a handler, hits / misses on caching, db request type, count and time. A metrics system like statsd is fairly common, something like tracing would take more work (since you need to propogate span information). You might be able to get some more sneaky application performance monitor that would do more for you, but you'll generally pay for them and they might bring more assumptions with them or require a bit of integration. See: NewRelic etc. You can also run pprof on another port in production, which would give you the ability to profile while live. Something like Google Stackdriver might help you with this and give you some of these other things. Lastly, note that because it wouldn't be uncommon to send different things across goroutines to get handled, it might be tricky to track where those requests came from. You would need to extend those sorts of calls, and something like context could be a reasonably nice way to pass your span / contextID / etc around. 
I found the problem. I was running the wrong command. I'm doing heroku setup on a another branch, so there isn't any Gopkg.toml on master and 'git push heroku master' would throw the error. 'Git push heroku heroku-build:master' was the command I should have been using. 
I use the [Better Go Playground](https://chrome.google.com/webstore/detail/better-go-playground/odfhkelcmblecfdnboahphiafolojmpl?hl=en) extension to add syntax highlighting. 
Please tell me it has a lock file
Do you mean you want to decorate A with B? If so you can just store A in a private variable in B and proxy the calls to it.
Go does not have inheritance. It has composition. You can accomplish what you want with interfaces: ``` package main import ( "fmt" ) type A struct { Thing string } func (a A) DoThing() { fmt.Println(a.Thing) } type B struct { A } func (b B) DoThing() { fmt.Println(b.A.Thing) } type DoesAThing interface { DoThing() } func takeA(a DoesAThing) { a.DoThing() } func main() { b := B{} b.A.Thing = "Hi" takeA(b) } ``` https://play.golang.org/p/rb2FkhiH4W4
Could you explain exactly what you're trying to accomplish? Why are you trying to call takeA with a B?
YasssNbat Can I contribute to this project?
I tend to view the opposite, as in don't be afraid to create packages. I enjoy Go's naming convention of `foo.New()`, and separating packages empowers that. Otherwise you end up with `blah.NewFoo()` and `blah.FooSubType`. Packages often shorten names substantially. There's definitely more work in packages though. If you have a handful of inter-dependent types, you end up with possible cyclic dependencies which only become apparent when you try to move things to packages as you grow. A single package both makes that easier, and potentially more costly should you back yourself into a corner for the future. It's all tradeoffs /shrug
In addition to the composition example, remember that composition doesn't require interfaces. Embedding functionality from one struct to another is a very common thing, and quite powerful. It also behaves very similar to inheritance for what people *actually* want.
Not to discourage the author here, but for custom embeddable logic, I just use Javascript, via Otto. The benefit is that front end engineers already speak JS natively.
Why are there so many competent assholes in this industry? It's so strange. 
Ah _that's_ curious! Would have thought an explicit dereferencing-assignment equivalent to the scattered inline ones, but apparently not!
Is there a way to basically have func (b B) DoThing() do the same as func (a A) DoThing() without redefining it? 
I'm trying to have Struct A with a bunch of methods and Struct B override SOME of the methods to Struct A and not All. And pass Struct B to something which takes struct A but now with partially overrode methods. 
I'm trying to have Struct A with a bunch of methods and Struct B override SOME of the methods to Struct A and not All. And pass Struct B to something which takes struct A but now with partially overrode methods. 
``` func (b B) DoThing() { b.A.DoThing() } ```
Adding on to Reduntancy\_'s comment, if I were going to try to figure out how much CPU or memory my handler was using, I would not try to "instrument" it on a running instance. I would write a test case that extracts the incoming requests of interest, and runs them under the test system and under the profiler of interest. In a shared, garbage-collected environment, it's just really hard to try to disentangle all the relevant concerns from a "real" program, so I'd use an artificial setup. To the extent your handlers are hard to test... well... _cough_ now you know why that can be a problem.... (Though do look up net/http/httptest... simply bringing up a handler is quite feasible. But if you can't cleanly submit a request to it and have it under test, you may have problems.) Some metrics, as mentioned, are easy, like execution time, but for an _individual_ request I'm not even sure there's a great way to get wait time vs. actual CPU execution time. A profiler can help in the aggregate, but then it can be difficult to figure out what is going on specifically.
Yes. It's called embedding. It's still composition and not true inheritance, but it is syntactic sugar that takes all of the boilerplate away by "promoting" all the embedded (aka parent) struct's methods onto the composing (aka child) struct. https://golang.org/doc/effective_go.html#embedding
Just had to buy this after reading the preview.
Alright, you CAN technically accomplish that, but it'll not be pretty. You can set up your inner struct with the value receiver like that: func (s struct) innerFunction1() {} Set up functions that you do not want to be promoted to your outer struct this way. For functions that you do want to get promoted use a pointer receiver: func (s *struct) innerFunction2() {} These functions will be promoted as long as long as you call your functions from a pointer to that struct: type innerStruct struct{} type outerStruct struct{ innerStruct, otherFields, } So, this setup will let you filter out inner functions. You'll be able to: c := *outerStruct{} c.innerFunction2() //but you won't be able to c.innerFunction1() Messy, but this is the way I think you'll be able to do it. I'll go and double check that now.
I mean, technically, all inner functions get promoted doing this. But they you should be able to filter out the functions by using different receivers.
+1 (Altho I have since moved across to using [goja](https://github.com/dop251/goja) for its supposed speed increase (I didnt see a huge increase but im only running simple expressions)) I built a pretty complicated bot for betting on betfair where you get to define your own rules for when bets go on/off and what price/stake. I did this by exposing heaps of the values on state of markets, your current bets and account info and you could write short snippets of js to control its action. Gave way more power then trying to hook up a set of gui controls and has worked amazingly.
This isn't needed. B will use A's method because A is composed on B.
This is possible, just not spelled like you're used to: type Whatever interface { Method1() Method2() } type A struct {} func (a *A) Method1() { ... } func (a *B) Method2() { ... } type B struct { A } func (b *B) Method2() { ... } You then take an `Whatever` argument where ever you want to take one or the other. However, while Method2() will get the B, note that B.Method1() will _still_ receive the A, and only the A. That means that if you try to call a third "overridden" method from the "base" A, you'll get the original A's method. The only way around this is to pass the original Whatever to the method, and have all the methods take "Whatever"s as separate arguments as well. There is no pretty inheritance in Go. In general, you are far better off learning to use composition natively. Often you'll find that where you are used to having a base class and inheriting various things, you can actually have three or four composed objects that don't need to be related to each other. However, if you are in the odd space where inheritance is the only real solution, Go may not be a great choice. But bear in mind that the only thing I've found on that list so far in my career is "GUI toolkits". The core insight here is to invert the "overridding" relationship. Rather than having a method set {A, B, C, D} and saying "Ah, I want to override C and D", phrase it instead as "Ah, A and B identify some subset of functionality that doesn't change". Then you create an object that does A and B, and then two objects that compose it and add the C and D of interest. You'll often find that what in inheritance-based design is a "single object" is amazingly cleanly partitionable into three or four elements for which composition is adequate.
I agree, this does seem possible.
This approach seems reasonable. Can you share what the actual directory structure would look like, or a seed git repo with this structure? My project structure is maybe using unfamiliar folder naming, but essentially, a service IS a package that could sit in its own github repo. However, at this time, I would rather avoid having a separate github repo to manage for each package in the services directory.
You're right, sorry. I wasn't thinking, pre-coffee :)
Your only real option is to follow the interface advice already given. Go is a fairly explicit language and while composition is powerful, isn't very similar to inheritance/polymorphism.
Agree, also like otto really much (and use it in my another package: https://github.com/antonmedv/xx), but in expr only restricted subset of language features is better for rules (keeps complexity low). Also in expr it's possible to check on parse what used only allowed variables and functions (you can check saved rule and notice error in it before actual run). 
Oh wow, didn't even notice that. Thanks.
Can you file an issue on github regarding this ? I am guessing there are historical reasons for this. But it would be good to have this inconsistency resolved.
Thx. Yea agree, more an IDE problem indeed. After I posted this article, I started to use the interface compile validation trick and it works for me quite well :) 
agree, good point. That gets more complicated though when working on a open source project :) 
I preminify the templates when I load them, using https://github.com/tdewolff/minify
that's a very good point! Forgot about that. Thx for mentioning!
damn frontend fancy scripts. thx for feedback.
Hey, thx for feedback. What's the problem with the scroll? 
I think it's the flip-side of same kind of extremely stubborn indivduality that makes Go great in the first place. Sometimes it's nice...sometimes, not so much!
Hi, I made some notes on this same thing as it was confusing me a little: [https://github.com/tjcain1233/go-exercises/blob/master/web-dev/Chapter-03/user-defined-types/structs.go](https://github.com/tjcain1233/go-exercises/blob/master/web-dev/Chapter-03/user-defined-types/structs.go) tl;dr ```golang // Go encourages composition over inheritance. // "Composition is a design philosophy in which smaller components are // combined into larger components." // Type embedding for composition: type Admin struct { Person // here we embed the Person type Roles []string } // The Person type is now embedded in the Admin type // so all Person fields and methods will be avaliable // However, you can overwrite methods. Now the PrintDetails() // method does not contain all of the useful information, // so it is overridden: func (a Admin) PrintDetails() { //Call person PrintDetails a.Person.PrintDetails() fmt.Println("Admin Roles:") for _, v := range a.Roles { fmt.Println(v) } } ```
Even something as simple as making a HTTP/HTTPS test of a remote site can be hard if you cover all the cases. For example if I said "Is https://example.com/ up?" you'd have to : * Lookup the IPs. * Test each one in turn. Handling IPv4 + IPv6. * Validate the SSL certificate is not expired, or incomplete. Handling timeouts, etc, etc, is also a niggle. I've written a monitoring system for testing various network services (HTTP/FTP/SSH/Finger/RSYNC/more) and most of the socket-based systems are simple: * Connect. * Read banner. * Optionally send a "quit"/"exit"/"disconnect" command. * Close. By contrast the HTTP/HTTPS test is at least 4 times more complex.
The whole design philosophy behind the Go language is "I won't let you do it because you're too dumb". Yes, Rob Pike has a pretty low opinion of other developers.
I think Go actually could be a great language for frontend apps, but it is true there are no (established enough to be used) UI frameworks designed for Go, and the bindings to existing frameworks all seem very early prototype-y. But I could definitely see this changing someday!
Sorry, what am I missing here? I'm trying to grasp composition and seem to be doing something very wrong. https://play.golang.org/p/KWgtH_Be35Z Why does B.Test not just goto A.Test? I assumed since I2.Test is from an interface it wouldn't be ambiguous.
Like every other DSL though, creating the code that executes it is only part of the whole problem - you're basically creating something like a programming language that can need to be debugged, profiled and everything else.
Seems like people are suggesting composition as a way to go. I'm gonna try it. Sorry, what am I missing here? I'm trying to grasp composition and seem to be doing something very wrong. https://play.golang.org/p/KWgtH_Be35Z Why does B.Test not just goto A.Test? I assumed since I2.Test is from an interface it wouldn't be ambiguous.
How is this different from govaluate? Seems to have all the same features. Faster? Better? Smaller? The only thing I really see is that you allow maps and govaluate does not (yet?). [https://github.com/Knetic/govaluate](https://github.com/Knetic/govaluate) Govaluate has really good docs. I'd suggest improving your docs if you want users.
Per your comment in the playground, I don't know where you got the idea that Decorator is limited to one method. I'm not saying you didn't get it from somewhere, just that none of the places I've ever seen it mentioned would include that idea. Furthermore, even if someone did write down somewhere that Decorator is limited to just one method... so what? Just do it. type X interface { Method1() Method2() } type XDecor struct { underlying X } func (x X) Method1() { // whatever x.underlying.Method1() } func (x X) Method2() { // whatever x.underlying.Method2() } No real difference from decorating a smaller interface. I write this in general; I see TheMerovius has gRPC-specific comments. I've not used that specific library or protocol. What I discuss above works in general.
So do I, and I love it.
*Generally* I'd say create a `type WrapperType struct` whose "constructor" takes _any_ `InterfaceFoo` implementation, and add all methods to said `WrapperType` to implement `InterfaceFoo`, initially by-default forwarding-args-to and relaying-returns-from the wrapped `InterfaceFoo` implementation, then once this compiles add "middleware"/intercepting logic to these method impls wherever and however desired. Would this approach not work trivially clearly and cleanly and comprehensably for all sorts of interface-driven APIs?
In most cases we put only restricted features in on such DSL. Knowing what must go there, and what must be in code is main thing indicating a good software engineer. Expr just provide a lib, it's developer responsibility to put borders. For example we use it for filter rule, an there it plays well.
[This](https://play.golang.org/p/ak_bmx2tnOh) is the way to do that.
Cool, didn't find it before creating my own. On quick look, Expr allows to check used variables on compile time, not only functions. No, I don't want "users", I'm just sharing my work with community of good intentions.
I'm curious about the statement about assertions - I've worked on projects where they were used entirely piecemeal, and the question always came up as to what the point was in code that you would write that would only be present in debug code and would break control flow. Don't assert, write. Why not write an if statement, return an error, and do so in all versions of your code. Since nobody tested debug builds, when you actually did need them you'd need to wade through a load of asserts that had been triggered since the last person ran debug.
Also govaluate vs Expr: [![Go Report Card](https://goreportcard.com/badge/github.com/Knetic/govaluate)](https://goreportcard.com/report/github.com/Knetic/govaluate) vs [![Go Report Card](https://goreportcard.com/badge/github.com/antonmedv/expr)](https://goreportcard.com/report/github.com/antonmedv/expr) 🧐
&gt;Since nobody tested debug builds, when you actually did need them you'd need to wade through a load of asserts that had been triggered since the last person ran debug. I think this is the issue in your case. Assertions/contract programming are almost useless unless you have at least two of: * unit tests * integration tests * good ol' manual testers tinkering with your program As for "just return an error", this is always a valid approach of course, but sometimes it gets tedious. By this logic, *any* method working with `*T` should return an error because the receiver can always be `nil`. (God, I *love* `nil`...)
Ok, so there are 2 different things wrong in that playground example. 1. B is embedding both the concrete "parent" struct AND the interface that you are trying to implement. You should only be embedding 1 of these two things depending on what you are trying to do. In your case (mimicking normal inheritance), we should be embedding the "parent" struct. Embedding an interface is more like inheriting from an abstract base class. So after we fix this (and remove I2 as it wasn't doing anything but adding unnecessary complexity to the example), we get https://play.golang.org/p/dg1UaBzfVx8 2. Now when we run this, we get a very useful error message prog.go:25:6: cannot use a (type B) as type Tester in argument to Test: B does not implement Tester (Test method has pointer receiver) The problem now is that since Test() was defined on *A (pointer to A) and not on A itself, and you embedded A and not *A. This caused the Test() method got promoted to *B instead of to B. In other words, currently *B implements Tester, but B does not. There are 3 ways to get this code working. - just use *B instead of B https://play.golang.org/p/0wwcu50uApZ - define Test() on A instead of *A https://play.golang.org/p/Mlk65n9M9i8 - embed *A instead of A https://play.golang.org/p/KNsZUItdRqM This isn't really an embedding problem anymore. It has become a "when do I use a pointer" question, which is usually the hardest thing for non-C programmers to learn. Each of these 3 options are totally valid, and they all have different implications on the rest of your code, so what you choose would sorta depend on the context.
Awesome!! Thank you so much!! This clears it up a whole bunch for me. 
This guy posts guides on various Go topics on r/golang all the time. One of his best is a massive series on Go Microservices: https://www.google.com/amp/ewanvalentine.io/microservices-in-golang-part-1/amp/
That was a duplication. I have removed it.
It has two.
Sure, it’s part of an ongoing open source project: https://github.com/crusttech/crust - there are also two restructure branches with individual experiments, but master is/will soon (days) be along the lines of my parent comment.
Thank you, appreciate you taking the time and even leaving the link. I'll look it up Cheers
That's true whenever you have multiple people working on a project, not just open source. I would say that Go is generally very readable, so this is generally not as much of an issue in Go. The only time I'd say this could be an issue is if someone is getting fancy with their interfaces, hence my comment about the interface sizes. If this is the case, it's likely the open source project in question isn't exactly coding in idiomatic Go, but more likely using an identical project and recoding it verbatim in Go. Honestly, this could be a good project to write an idiomatic version in Go. Just fork and away you go!
TIL, it's awesome, thank you!
There's a lot more I'd like to comment on this, but I don't have the time. The author is absolutely right that BREs are not perfect, and that using them effectively is not easy. But it's not true that BREs can always be replaced by hand rolled switches (though if they can, they probably should). I think the real conclusion here is more about _how we use_ BREs. We should _not_ decouple the use of the BRE from software engineering, and we should _not_ overly rely on them. A BRE _is_ least effective when it is given too much control over the state machine. The real value of a BRE comes from the ability to detect or disallow inconsistent rules, the ability to easily audit the rule set, and the ability to make inferences from the rules. That being said, there's not much of a reason to write a new BRE these days. Just use Prolog. (Given the XML comment, it sounds like they were using OWL or RDF. I do think that this is the wrong decision for a BRE 99% of the time.)
Looks really neat! What is the GRS score? I'm guessing 52 test sentences to evaluate parse quality? What does one do with an NLP library like this? Spark my imagination, please. :)
Could you add https://spacy.io/ (Python) to your list of comparisons? I would love to eventually have something like spaCy written in Go. However, that would also mean using a Go NN to train the tagger plus having word vectors - which is a lot *more* to add. At any rate, thank you for your work and for sharing! https://spacy.io/usage/facts-figures
thank you Local, good documentation, straight forward setup. I'll be away for a while but looking forward to play a bit more with it
[removed]
There are various ways you might handle this, here is one: ```go package main import ( "fmt" "io/ioutil" "net/http" ) func main() { urls := []string{ "https://www.google.com", "https://www.yahoo.com", "https://www.bing.com", } result := make(map[string]chan string) for _, url := range urls { result[url] = make(chan string) go fetch(url, result[url]) } for _, url := range urls { fmt.Printf("URL: %s\n", url) fmt.Printf("Length: %d\n", len(&lt;-result[url])) } } func fetch(url string, result chan string) { res, err := http.Get(url) if err != nil { panic(err) } body, err := ioutil.ReadAll(res.Body) if err != nil { panic(err) } res.Body.Close() result &lt;- string(body) } ``` Play: https://play.golang.org/p/268Jbx6MmRI
Thanks!
package main import ( "fmt" "io/ioutil" "net/http" "sync" ) func main() { urls := []string{ "https://www.google.com", "https://wwww.yahoo.com", "https://wwww.bing.com", } var wg sync.WaitGroup wg.Add(len(urls)) for _, url := range urls { go func(url string) { defer wg.Done() resp, err := http.Get(url) if err != nil { fmt.Println("Error while fetching url", err) } else { defer resp.Body.Close() text, err := ioutil.ReadAll(resp.Body) if err != nil { fmt.Println("Error while reading response body", err) } else { fmt.Println("URL: ", url) fmt.Println("Length", len(text)) } } }(url) } wg.Wait() } 
Yes, GRS (or the *Golden Rules*) are a collection of 52 sentences designed to represent edge cases of sentence segmentation. In other words, instead of testing on a large corpus mostly consisting of common sentence structures, this allows libraries to evaluate their performance on sentences like `St. Michael's Church is on 5th st. near the light.` You can read more about the [test suite here](https://github.com/diasks2/pragmatic_segmenter#the-golden-rules). As for what you can do, basic NLP (i.e., sentence segmentation and POS tagging) is the foundation of most projects related to text processing—for instance, Reddit's AutoTLDR Bot or my own [linter for prose](https://github.com/errata-ai/vale) (also written in Go). 
With regards to segmentation, spaCy's latest `en_core_web_sm` model scored 31 / 52 (0.596). However, you can pretty easily make [your own adjusts](https://spacy.io/usage/processing-pipelines#component-example1) to their segmentation component.
The en_core_web_sm doesn't have word vectors or as many words, so it's pretty limited anyway.
• Execute `stty -echo` to turn off echo • Then `stty echo` after reading the password Here is a solution using only the Go standard library [1]. [1] https://stackoverflow.com/a/37091538
_(off topic)_ You cannot format code on Reddit using backticks, you have to put 4+ spaces before every line.
Have you worked with Stanford nlp? I've been considering attempting to rewrite some of those features in go to cut down my memory costs from running java. Think it would fit well in the scope of what you're trying to do here?
btw, the map part is racy.
No it's not, the map is not allocated async.
This doesn't satisfy the condition that URLs are printed in order.
Oops missed that one.
This is actually perfect for a research project I’ve been thinking of! Thank you OP
hrm, it shows up as correctly formatted for me...
you assign map[x] then go fn(map[x]) in a loop.
Is this the format that you are expecting? [1] [1] https://i.imgur.com/KdYX5Vl.png
Хорошая статья, спасибо. 
 package main import ( "fmt" "io/ioutil" "net/http" "sync" ) type result struct { Url string Length int } func main() { urls := []string{ "https://www.google.com", "https://wwww.yahoo.com", "https://wwww.bing.com", } results := make([]result, len(urls)) var wg sync.WaitGroup wg.Add(len(urls)) for i, url := range urls { go func(url string, res *result) { defer wg.Done() resp, err := http.Get(url) if err != nil { fmt.Println("Error while fetching url", err) } else { defer resp.Body.Close() text, err := ioutil.ReadAll(resp.Body) if err != nil { fmt.Println("Error while reading response body", err) } else { res.Url = url res.Length = len(text) } } }(url, &amp;results[i]) } wg.Wait() for _, result := range results { fmt.Println(result.Url) fmt.Println(result.Length) } } This code does but I think you code it better. My code blocks till it collects all the result. Your code prints them as soon as they arrive in order. 
Not much of a NLP expert here. However, I used this library recently to develop a rather full featured search engine at a company wide hackathon in a day with Postgres as persistent store.
Ah, maybe there's a difference in rendering engine between the classic and new layouts.
The map access occurs in the loop, before the goroutine is scheduled. Feel free to check using the race detector if you'd like.
I wrote a comparison of Go and Python at fetching Github API URLs a while back: https://gist.github.com/carlmjohnson/e6384ea4c8fdc02a9191e59d19db4080
only thing I miss from *.sublime.* is the advanced search and replace magic :(
Yes, the Reddit team has paid exactly zero attention to getting consistent Markdown results. 
Sorry, I wasn't meaning to imply that by adding more methods you'd be breaking the Decorator pattern. I was meaning all decorator patterns I've seen in the wild only have a single method. The biggest of them being an `http.Client` which has its single `Do` method. In your sample code (thanks, btw) it looks like you'd need to implement the interface twice? Where in this case `XDecor` allows you to wrap the inner method as needed. What I'm wondering is a way to eliminate the `// whatever` from every method and write it once and call it once. Or is the `// whatever` logic something I need to do on every function manually? ie have (going off my example) automatically call the "middlewares" if you will as such: ``` cli := NewClient() cli.One("s") ``` I'm probably still misunderstanding your response, but is this correct?
As I've dug back into the Decorator pattern I'm realizing my question is slightly confused. I'm wanting all of methods to call a single middleware. I understand the wrapper. What I want to avoid is: ``` func (w Wrapper) Method() { MyMiddleware() w.Underlying.Method() } ``` I want to _avoid_ having to call "MyMiddleware" on every function. 
haha things are never that simple my friend but I get your point :) Thx
something is very weird with this tool, tried to follow the README: $ time amass net -addr 192.168.1.44,192.168.2.1-64 The parameters required for identifying a target were not provided Use the -h switch for help information real 0m8.515s user 0m0.036s sys 0m0.203s It took 10seconds for it to print an error about command line arguments that I copy-pasted from the README as-is?
Obviously you can !
Ok let me know whenever you have a moment :)
Oh yeah. Because _'not just Rob'_ doesn't like it, let's never make everyone happy by adding it as an _**option**_.
I'm wondering Why does he have the final word on this? - People like syntax highlighing - Go's [GitHub repository](https://github.com/golang) is named `golang`, not `robpike` - There is now 1104 people contributing to Go's project
If you persist on using no library, @unix15e8's answer is good and is totally enough for basic use cases. If you're willing to use a more involved way to enter the password (maybe even with a strength indicator), you can find an example \[here\]([https://github.com/sahib/brig/blob/master/cmd/pwd/pwd.go#L70](https://github.com/sahib/brig/blob/master/cmd/pwd/pwd.go#L70)) which uses \[chyzer/readline\]([https://github.com/chzyer/readline](https://github.com/chzyer/readline)). Using readline also has the advantage to be a bit more portable than calling \`\`/bin/stty\`\` (which will not work on windows).
So I was hoping that \`reflect\` would be able to help, but I can't seem to find a way to create an interface using a collection of methods. So the second option is \`go generate\` with [https://golang.org/pkg/go/parser/](https://golang.org/pkg/go/parser/). Then you can give it an interface, a before func and an after func and it can generate code for a struct that will satisfy the interface, but also call your methods. 
I used a structure just like the GOPATH before I started working with Go, where I'd organise repositories by hosting site, user, then repo name. You'll still be able to continue doing this regardless. One thing I've not been as much of a fan of is that I have to put my Go stuff with that structure in a different place to the rest of the repos I have on my system. Now they can be reunited at least.
There's always going to be people for and against these things. For example, I have much preferred the preview of vgo over dep. I must curse at dep at least once a day, every day for some reason. Whether it's just being slow, or trying to be too "smart" and not letting me upgrade deps when there are breaking changes, etc. To me, vgo seems to have solutions to every problem I've had with dep, and I've not found any issues with using vgo whilst testing it out extensively.
Love to hear more details about this, as I have a similar project I need to complete. 
I'm not convinced that he is, and he is not the only one who doesn't syntax highlighting. I don't know why the opt-in syntax highlighting from the Tour isn't available in the Playground, but the fact that syntax highlighting is available in the Tour clearly shows that Pike doesn't rule the project with an iron fist and bans anything he personally doesn't like. If people would actually bother to read the golang-nuts thread that was posted earlier as evidence for the "because Rob said so" claim, they would see that one of the last messages in the thread by Andrew Gerrand said this: &gt;For the record: Christoph Hack said he was going to prepare a change to restore the more sophisticated editor to the playground. This would include a syntax highlighting option that defaults to "off" (as per the tour). If this change can be made without any regressions then it will be accepted. I don't know what happened, maybe they just never got around to it. I found this ticket from last summer [x/playground: add syntax highlighting](https://github.com/golang/go/issues/21123), but the person who opened it closed it himself after a few hours with no explanation. If people want syntax highlighting in the Playground, why not open a ticket or ask to have the earlier one reopened?
&gt; In your sample code (thanks, btw) it looks like you'd need to implement the interface twice? Well, once for the decorator, once for whatever the base thing is that you'd have implemented anyhow. &gt; Where in this case XDecor allows you to wrap the inner method as needed. What I'm wondering is a way to eliminate the // whatever from every method and write it once and call it once. Yes, the "whatever" is what you are trying to factor out. I think the thing you may still be missing is that you need to do the wrapping, i.e., something like `cli = XDecor{NewClient()}`. Note that the reason you may feel like you don't have to do that in http.Handlers is that you only set it up once, but then the way they are structured they work for the requests after that without appearing to need to be set up each time. If you've got your own stuff going on, you need to somehow set the decorator chain up "each time" somehow. Of course this is code so it still ends up in one place alone.
Maybe RUN commands should be concatenated using &amp;&amp; instead of ; so that failures work the same way as multiple RUN commands. Another suggestion is to use escape to not end up with very long lines and also maybe keep empty new lines to preserve grouping
[removed]
Noice, looks good.
thanks your advice.
And no dumb off-the-cuff remark has haunted the community more.
Very cool... do you think it is possible to decrease the allocations even more?
This. At first I picked a small web server to push Proxy Auto Configuration files to my internal homelab clients. Then eventually I came up with some other ideas for some smaller projects I could do. So I decided to come up with a web app boiler plate (Using just the stdlib, and like 3 other smaller libraries.). I'm 75% done with it, still got a long ways to go till I think I can consider it ready for me to use on the other projects I have in mind. But I've learned a lot about development and how to maneuver around the Go language spec.
I guess when people like something, they get very defensive. But even beyond Pike's words, I think Go itself communicates that at every level - it offers you three generic types but does not allow you to create your own - the standard library makes heavy use of reflection and field annotations through tags, but it is discouraged to the regular user, and the compiler gives you no guarantees - the http server provides a nice model of request dispatch and fault isolation, but it is completely hidden behind the API and there is no reusable model to help in designing concurrent systems like in say Erlang - you are told to properly return errors and "not panic", when the entire standard library is full of calls that can fail silently or panic on completely common errors It is quite obvious to anyone who has experience in other languages that Go was designed with the convenience of the language creators in mind, so they could go about architecting their systems and let "lesser" developers then maintain those systems and add features without hurting themselves.
&gt; architecting their systems and let "lesser" developers then maintain those systems and add features without hurting themselves Aka the "google way".
It would be useful to know what framework you’re using. Go handles dependency injection as expected, your question does not appear to be about go itself...
I'm not using a framework, this is a question about project design/structure for any generic Go application that needs 1) to share the same copy of a dependency and 2) be able to replace it with alternative versions (such a mocks).
Needs more table of contents.
Join this open source product to bring transparency and ease of use across all cloud providers about available instance types and pricing: https://github.com/banzaicloud/productinfo
need a high contrast version or something which will work with reader-view
The language's name is Go not Golang (or GO or go). The word "Golang" is used many times in the document, in a way the implies that it is the language's name It's a small point, but I think that it's one that an FAQ should be particularly careful about.
Whats the point in minifying a human readable file in a more unreadable way? 
&gt; I can not use it as the localhost What do you mean by that? &gt; I'm trying to use: `http.Get("ds0:2022/api/blah/blah2")` Do you get an error if you do `http.Get("http://ds0:2022/api/blah/blah2")` ?
for the main.go I would recommend one pattern - you can pass struct function as a normal function: ``` ... func main() { db, err := models.NewDB("postgres://user:pass@localhost/site") s := someService{db} http.HandleFunc("/users", s.helloHandler) http.ListenAndServe(":3000", nil) } type someService struct { db models.Datastore } func (s someService) helloHandler(w http.ResponseWriter, r *http.Request) { ... users := db.GetUsers() ... } ``` and all everything looks fine :) I used similar DI pattern in my projects, and I would only recommend to keep Datastore interface small, because it will be easier to mock in the future you can also consider to make mock more customizable: ``` type mockDB struct { u []*User } func (m *mockDB) AddUser(u *User) (error) { u = append(m.u, u) return nil } func (m *mockDB) GetUsers() ([]*User, error) { return m.u, nil } ```
Hi, Well, I did **https**, I see now that **http** works just fine... Dang it... so simple. Your respond made me see the error. By the way, I meant: res, err := http.Get("ds0:2022/api/blah/blah2") if err != nil { log.Fatal(err) } defer res.Body.Close() Thank you !
To post code, instead of using three "`" (like stackoverflow/github), you can use four spaces. 
Sorry, but ... bt;dr: bad typography, didn't read.
I think this [package layout](https://medium.com/@benbjohnson/standard-package-layout-7cdbc8391fc1) is a better fit for Go. Also check out the [Code like the Go team](https://talks.bjk.fyi/bketelsen/talks?p=gcru18-best#/) talk.
This article could be at least half shorter if you'd omit all the not needed explanations. It isn't bad, it just have too much of content. For example, look at \[this\]([https://gobyexample.com/reading-files](https://gobyexample.com/reading-files)), it does explain the same thing as your tutorial, but it's much more compact.
Yes, looks like it.
Yes it is.
What this means is that after performing the active enumeration of those IP addresses, it did not discover any root domain names. That's why it took nearly 10 seconds. I'll update the error message to be more clear. Thanks!
Yes, I am getting a _"502 Server Error"_ and timeouts from multiple regions [1][2]. It loads intermittently in some computers in the office, but is definitely struggling. [1] https://performance.sucuri.net/domain/golang.org [2] https://i.imgur.com/YHzqYpv.png
[removed]
Looks like google cloud (including app engine) is struggling at the moment: https://status.cloud.google.com/ And I believe the XML error is due to google's 502 page not closing their `&lt;p&gt;` tags: ``` &lt;a href=//www.google.com/&gt;&lt;span id=logo aria-label=Google&gt;&lt;/span&gt;&lt;/a&gt; &lt;p&gt;&lt;b&gt;502.&lt;/b&gt; &lt;ins&gt;That’s an error.&lt;/ins&gt; &lt;p&gt;The server encountered a temporary error and could not complete your request.&lt;p&gt;Please try again in 30 seconds. &lt;ins&gt;That’s all we know.&lt;/ins&gt; ```
They let people run code interactively? Some dork uploaded a fork bomb. 
[golang.org](https://golang.org) is loading fine
You could use terminal.ReadPassword in package [golang.org/x/crypto/ssh/terminal](https://golang.org/x/crypto/ssh/terminal). I've used this on a couple projects and seems to work well.
I prefer to separate handler structs per REST resource (if you are using REST :)), it don't make structs too massive. For middlewares support I prefer just using chi router mechanism. This combo makes it really elagant.
Yeah, no.
This is really cool. I wish I was better at math. 
It's perfectly fine as is. [dep](https://github.com/golang/dep) is the current tool, to be replaced by vgo.
Yes, more than likely. I've not put much effort into optimisation yet.
Thank you guys for replies. It has to work on different os's so I guess I have to use another package. I'm gonna choose package one of that you mentioned.
Yup. It’s back up now. 
No difference. t[:] is just a shorthand for t[0:len(t)]. 
Delve is the prominent debugger for Go, you can find some docs on how to build a client to drive it programmatically here: https://github.com/derekparker/delve/blob/master/Documentation/api/ClientHowto.md
I tried to use it and I liked it but I didn't understand that int parameter. It works when I passed it 0,1 and 2 but other numbers didn't work. Why is that integer for.
To answer your initial question, yes this is a good approach. 
It is the file descriptor for where it’s reading the input. password, err := terminal.ReadPassword(int(os.Stdin.Fd()))
Thanks.
I've no idea how you are getting a `[]uint8` from `func ReadAll(r io.Reader) ([]byte, error)` [1] &gt; How can I parse that string to get an actual array of Maps in golang? Don't read the output using _"ioutil.ReadAll()"_, use `json.NewDecoder(resp.Body).Decode(&amp;v)` [2]. If you don't know how to create a Go _struct_ from a JSON object, use this tool [3]. [1] https://golang.org/pkg/io/ioutil/#ReadAll [2] https://pastebin.com/raw/0sbUsNbB [3] https://mholt.github.io/json-to-go/
Thank you, looking....
Sorry to bother you again... You added : v := Response{} Where does Response comes from?
From this `type Response []Title` line 9 [1]. [1] https://pastebin.com/raw/0sbUsNbB
We use this where I work and it's pretty nice. Haven't had any issues in production apps other than bugs that arose from improper calls to it. Kind of the closest thing to AR that I know of in GoLang.
Yeah I have this running for a basic API and it helps mock the server. But if you need to interact with data layers you need to inject yourself into the handlers.
.. and I totally missed it, I used the auto contract builder and trying this whole thing now. So, when I do type Response []JobsMap ( i called the struct "JobsMap" ) and when I do : v := Response{} So v is automatically an array of JobsMap? Its like a preset for vars, I can tell the script that all vars assigned to a type will get that type?
interesting! Thanks for the resource!
&gt; So v is automatically an array of JobsMap? Yes, that is correct.
Ah, there’s nothing like the sound of a nine falling off your SLA. 
My guess is that it is belt-and-suspenders for some miscalculation in the buffer size. 
Ok. Functions are passable, both as independent functions and methods on structs. So, basically, nothing special going on with respect to dependency injection.
That line waits until a value is received on the semaphore channel.
Not just structs but the rest of the built-in types too...
The disappointment some felt leaving dep confused me. It was too slow to use in workflow and contained large dependencies that couldn't have been easily replaced to make it an official tool. From early on it seemed like it was equally not helpful and lacking a long term future.
&gt;this Hi, the author here. When I wrote the post, I mostly had people new to Golang in mind, hence the explanations--often repetitive. The link you've mentioned does have a compact explanation of reading files, but it only covers one way. Also, the layout there helps: you have the program on the right, explanation on the left thus saving space. Having something like that would've certainly helped my post :D
Hi, the author here. When I wrote the post, I mostly had people new to Golang in mind, hence the explanations--often repetitive. The link you've mentioned does have a compact explanation of reading files, but it only covers one way. Also, the layout there helps: you have the program on the right, explanation on the left thus saving space. Having something like that would've certainly helped my post :D
Do you mean *not just slices*? Yes, the second example shows even functions types.
This line equals &lt;- semaphore 
I'd advise against manually creating your mocks. We just use gomock, makes it easy to quickly write tests that return arbitrary data/errors. Also if the interface for your db functionality changes you just rerun mockgen to update it, no need to manually keep a mock struct up to date.
Just to guarantee a double safeties?
Yes, I did mean slices...
for reducing the number of layers, not for to unreadable. sorry, i don't know more unreadable way.
The idea of a semaphore is to limit concurrent actions by having the channel fill and block. What’s actually in the channel doesn’t matter, so the send and receive actions are just dummy values with no receiver. 
This article would be so much better with code syntax highlighting and anchor links from the top.
But reducing the layers should not be your first goal. If you want to be efficient you should cluster which layers change often and the ones who are not, get cached. If you stuff all in one, nothing gets cached bc the one layer always gets changed. I would try to use the multistage as much i can instead of the ultimate 1 layer goal. But just my 2 cents
There might be a slight difference in efficiency because you can avoid doing the `w +=` in the line above and because `t[0:w]` needs to be bounds-checked. *Probably* doesn't matter in practice though, given the overall cost of the function (and FWIW, you can also just use `t`, which is equivalent, given that `t` is a slice).
really help full thanks for sharing it.
do not use `json.NewDecoder`: https://ahmet.im/blog/golang-json-decoder-pitfalls/
A few things I stumbled upon: - "slim binaries" not so much. Go has the biggest binaries of all languages I know of. That's because they are statcly linked so they include the GC, the runtime and the standard library. - "Virtually all types are a reference by default". All Go variables are values so this is misleading to wrong. - "machine bytecode". Pick one machinecode or bytecode. It all depends on your definition and the difference is blurry but a blob that can be executed directly by a *real* CPU I would call machinecode. A phrase I like to describe Go with is: A static language with a dynamic feel. Else: Maybe rearrange some sections. I would move some of the later ones further up. Great job so far.
Just clarifying my knowledge - this will block until they're all done because you're printing the length from a channel right (\`len(&lt;-result\[url\])\`)? 
One of the prominent examples of this is [http.HandlerFunc](https://golang.org/pkg/net/http/#HandlerFunc) function type: // The HandlerFunc type is an adapter to allow the use of // ordinary functions as HTTP handlers. If f is a function // with the appropriate signature, HandlerFunc(f) is a // Handler that calls f. type HandlerFunc func(ResponseWriter, *Request) // ServeHTTP calls f(w, r). func (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request) { f(w, r) }
If you have already declared TheirType above that goroutine, declare the receiving channel above the go routine and put the receive listener in the goroutine. Then call NonBlockingSend after the goroutine and check that the channel has the result.
 a := theirTypeVar.PublicChan go theirTypeVar.NonBlockingSend() val := &lt;- a 
I agree. The author is unresponsive. His main focus is on selling the book
I have a doubt. I always thought that send and receive are tied together, i.e., I can send only if there is someone receiving. So, how does the Nonblocking send work?
This is a rewrite of the original [tailon](https://github.com/gvalkov/tailon-legacy) project into Go and vanilla ES5 + Vue.js. There's quite a lot of work left, but I wanted to put it out there in case someone already finds it useful or is interested in helping out with development. 
Maybe: ``` go func () { theirTypeVar.NonBlockingSend() }() for { select { case a := &lt;- theirTypeVar.PublicChan: defaut: time.Sleep(time.MilliSecond) continue } break } ``` 
I think the way `TheirType` is designed it's impossible to sync with it bc as you said the send could happen before the receive, and you can't do the receive in the background and then keep retrying `NonBlockingSend()` bc it modifies its state during the call.
I'm pretty dumb, so ignore me if I'm way off. But what does this achieve vs just using goroutines+channels? Is this just intended to be some sugar on top to make doing those things a little easier? I personally am terrified of this syntax, because I recently was working on a Javascript project where the promise chain would break super easily and it's a pain to debug. The whole `.then(funcA, funcB).then(funcA2, funcB2)` is not particularly easy to read/follow. Maybe `then(funcA).then(funcA2).catch(funcB)` could be better? I don't know. While there's always a way for people do write clean implementations of this, for me I end up with code that results in me dying on the inside while I debug where someone failed to implement some tiny aspect of it properly.
So i think they way you have it now with the timeout is the only thing that works but is not too safe.
Buffered channels. You don't have to wait for the consumer to remove the message before your code can move on.
This approach is fine, but your package / type naming is a bit weird. `models.DB` is a bit weird, what is a database model? That's not what you're trying to say with that, but that's what it comes off as. If you're dealing with users, maybe make a users package instead? Then you could have `users.DB`, or better yet - since you're not making a DB, you're just accessing one, think of a name you want to use for a type that interacts with a database, like [`users.Gateway`](https://martinfowler.com/eaaCatalog/gateway.html) or something. You could call your user model `users.User` still if you wanted, but if you wanted to avoid the bit of a stutter you'd have to think of a more appropriate package name than `users` (what is this related to, maybe `auth`, i.e. `auth.User`, `auth.Gateway`? These kinds of names give a lot more context than something like `models.DB`, and I'd go as far as to say this approach is a lot more idiomatic than your current approach. With regards to your approach to DI, what you're doing is mostly right, but I'd avoid defining interfaces next to your concretions only to allow you to make a mock for it. If you have, and will only have one implementation of some type, define the interface where it is actually used - then make your mock there too (using something like gomock and mockgen). [This is one of the CodeReviewComments points](https://github.com/golang/go/wiki/CodeReviewComments#interfaces), and is good advice for many reasons.
If you can initialize the PublicChan filed of TheirType use a buffered channel with a size &gt;= 1.
Oh yes. Thanks. Could not recall that. But now, even with buffered channels, isn't there a limit to the number of such sends ( limited by buffer size). And in that case, why does execution before receive cause a problem in OP's case.
I also prefer concurrent wrapper functions. If you need extended control just use Context imo.
Yes it will but it is also by design of OPs API.
Out of curiosity, is there a reason you recommend the json decoder? I assume less in memory bytes?
Lol, he made me question my normal behavior (reading all the bytes and then unmarshalling), and now you're making me go back on that :D Appreciate the info!
&gt; models.DB? What is a database model? Actually, it is a "models database" which is perfectly logical. *The models interact with a database*. Regardless, I made a mistake making it an exported field since the `models.Datastore` is the only thing the outside world sees. &gt; define the interface where it is actually used I agree with this, but in this case, since `models.Datastore` is whole reason that the models package exists (and the only exported interface) it makes sense for it to be defined with the models. Realistically, no other package will use models without using `models.Datastore`.
Unused variables raise compiler errors, so `var db = &amp;mysqlDB{}` will fail.
It's as the comment says. This is way to ensure at compile time, that the mysqlDB type qualifies as a BookDatabase interface. It is assigned to an underscore, because the value isn't actually needed anywhere. All the author here needs is for the compiler to throw a fit when the type doesn't implement the interface properly.
Great question. This is done commonly to remind the developer if a certain concrete type (in this case the struct mysqlDB) implements an interface (in this case the interface BookDatabase). Static analysis tools will warn you if an interface method is missing from the concrete type and beyond that the code will not compile if the type doesn't fully implement the type. I find this very useful when code is under heavy development and you have multiple implementations of an interface whose methid set might have methods added to it or changed. There may be other reasons, which I'd be happy to learn about from others here. 
Is it possible to access conn from the mysqlDB struct. something like **bookDatabase.conn**? I can obviously access all the functions in the BookDatabase interface but struggling to see how to access the actually connection. Maybe a solution would be to write a Execute func in the interface that takes arguments 
I don't see a problem with the send might happen before the receive, as a send has to happen before you receive anyways. Is there some other logic not shown here that you are trying to sync with?
Prior Go 1.7.
Out of curiosity, does `var _ BookDatabase = &amp;mysqlDB{}` reserve and hold that memory in use? Or does it free it immediately? I've kept these sorts of declarations in test files to ensure there's no memory allocation. But that's just being paranoid, because I've not known.
maybe. if you are worried about memory, this way it guaranteed to not use any (but it only works with pointers): `var _ BookDatabase = (*mysqlDB)(nil)`
Interpolate 24bit values to 16bit?
I'll try giving that a go, thanks.
It kind of breaks go, isn't it? The error will be thrown (compile time) when someone will try to send it as argument to a method which expects the interface, the struct itself doesn't suppose to know which interface it implements 
The select statement means that it could attempt to send to the channel before you start listening, fail and not send anything (default case). There's a race between getting to the send and the receive.
Yup, just pop that bad boy behind a Push() or Add() or Send() method. Gives you the flexibility later on to use alternate implementations since the rest of your code is not coupled to channels.
Another option is to put your channel send in a goroutine itself.
You're right, I missed that. Then why does the code use select with default?
I would expect that this is trivial case for escape analysis to figure out, and do stack-allocation instead of heap allocation.
Wouldn’t this be better suited for a unit test?
Yes, it probably is.
You can use the conn if you're in the same package and have a concrete (non interface) type, but that doesn't have anything to do with the original question.
Indeed... see here: https://imgur.com/a/YcE1Qz1
^(Hi, I'm a bot for linking direct images of albums with only 1 image) **https://i.imgur.com/2B4fMjm.png** ^^[Source](https://github.com/AUTplayed/imguralbumbot) ^^| ^^[Why?](https://github.com/AUTplayed/imguralbumbot/blob/master/README.md) ^^| ^^[Creator](https://np.reddit.com/user/AUTplayed/) ^^| ^^[ignoreme](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=ignoreme&amp;message=ignoreme) ^^| ^^[deletthis](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=delet%20this&amp;message=delet%20this%20e2lzswd) 
You're right with that last part; the whole point of interfaces is that you can't access the implementation details, so you expose specific parts as the external interface that things are allowed to use.
Difficult to guess, but as ideas, perhaps the author felt that it was important that the code never get blocked by someone forgetting to listen, or figured that they could make listening optional through this rather than by having a nil channel.
The rule of thumb is this: • Use `json.Decoder` if your data is coming from an `io.Reader` stream • USe `json.Decoder` if you need to decode multiple values from a stream of data • Use `json.Unmarshal` if you already have the JSON data in memory While reading from an HTTP request, I use `json.Decoder` since you're obviously reading from a stream. Here's a discussion from a year ago — _"json.Decoder vs json.Unmarshal"_ [1]. [1] https://www.reddit.com/r/golang/comments/5yhfo1/a/
&gt; https://ahmet.im/blog/golang-json-decoder-pitfalls/ — It has some unexpected behaviour. The article was posted on _"28 April 2016"_, the bugs were fixed with Go 1.7. The rule of thumb is this: • Use `json.Decoder` if your data is coming from an `io.Reader` stream • USe `json.Decoder` if you need to decode multiple values from a stream of data • Use `json.Unmarshal` if you already have the JSON data in memory While reading from an HTTP request, I use `json.Decoder` since you're obviously reading from a stream.
Let us know how you tackle this
Yeah I'm trying to figure it out right now, unfortunately I'm tired and not having much luck right now
Why? Static compile time tests are generally preferable over dynamic runtime tests when possible.
I'll have to research what things in that article were bugs and which were not. The article is pretty damming on multiple fronts, I'd want to be sure they were bugs, and fixed.
There's concurrency questions, however... old := theirTypeVar.PublicChan theirTypeVar.PublicChan = make(chan int, 1) theirTypeVar.NonBlockingSend() a := &lt;- theirTypeVar.PublicChan theirTypeVar.PublicChan = old
So you are reading a 24bit https://github.com/golang/image/blob/master/bmp/reader.go#L59 and want to write a 16bit image? https://github.com/golang/image/blob/master/bmp/writer.go#L180
Yes, it is.
Yes, with no doubt [1][2]. [1] https://gobot.io [2] https://github.com/go-chat-bot/bot
use the right tool for the job, this could be Go, Python, Node.js, or something else, whichever has the tools you need.
Thanks! Well, I'm Node developer but don't know anything about Go. I don't know a single employer around who's using it, but I'm interested in a static language. Bots are only occupations I can imagine for now...
You might be able to use [https://golang.org/pkg/image/draw/#Draw](Draw) function in image/draw package to draw from the source image buffer to a 16 bit image buffer.
Yeah, the canonical example is implementing `sort.Sort` interface for a slice. type byName []Person func (bn byName) Less(i, j int) bool { return bn[i].Name &lt; bn[j].Name }
Oddly, you can do this with functions, but not with interfaces.
That's the point of doing it. It's kind of like explicitly stating that this \`implements\` that interface, like you might do in other languages.
I second this. Go is not Golang, just as Rust is not Rust-Lang and Ruby is not Ruby-Lang. It is ok to say Golang informally but an educational text should always use the proper name of the subject it is talking about. This being said, I really like this page. It is a nice, accessible, introductory FAQ on Go that is not too technical (we have the offical Go FAQ for the technical bits, right?) and may indeed help people getting a first grasp of Go. 
So bad.. like why would anyone implement non-blocking send without returning information if it was successful or dropped.
It's not because then you lose compile-time safety. The way the code is in the example will cause all compilation to fail if the `mysqlDB` type does not correctly implement the `BookDatabase` interface. Halting compilation when your types are incorrect is a good thing.
Yeah I know, just saying that it looks weird because of that, of trying to imitate other languages.
It can be useful in a lot of situations, mainly when you implement someone else's interface. And still, you have a choice to use it.. the language doesn't force you.
Soooo etcd?
What do you mean? The example posted shows the http.HandlerFunc implementing http.Handler interface. 
No, I mean type Stringer interface { String() string } func (s Stringer) WriteTo(w io.Writer) (int64, error) { n, err := w.Write([]byte(s.String())) return int64(n), err } https://play.golang.org/p/Hp6qHqEJZLv
Give it some time, it's a new language and it'll get bloated like everything else
It's not a new language. It was launched in 2009. It became famous in last few years.
Not exactly sure what you are trying to achieve there. You are mixing implementation with interface. You can simply just create `stringer` which would embed the `Stringer` interface and then you want use it like: ``` s := stringer{somethingImplementingStringer} s.WriteTo(w) ```
Another huge release. As always, thanks for all the contributors and our two main authors (u/arp242 and Billie https://twitter.com/bhcleek). This packs tons of bug fixes, improvements, etc.. Checkout the full changelog for more information: https://github.com/fatih/vim-go/blob/master/CHANGELOG.md#118---july-18-2018 
&gt; Not exactly sure what you are trying to achieve there. You are mixing implementation with interface. Right, but you're doing the same thing with `http.HandlerFunc`. In other words, function types are special cases of interface types (as evidenced by the `http.HandlerFunc` and `http.Handler` duality). It's an inconsistency that Go allows you to hang a method off of a function type but not off an interface type.
Are you familiar with GopherJS or Go/wasm — Both are ways to run Go in the browser.
like i said in more or less words, it doesn't particularly matter whose using what. use what best fits your use-case. if you're writing a bot that interacts with the net and isn't hardware locked i wouldn't think you'd need a static language tbh, but i don't know your use-case, so it's up to you what to use.
But you get that compile check _anyway_ when someone actually tries to use the \*mysqlDB as a BookDatabase somewhere.
I know but it's new in comparison to it's main comaprators such as C and Python. 9 years is still fairly new for a language considering the first release of Python 3 would have been coming out around then
I never thought of doing that. TIL. Would it be standard practice to only keep the noop declaration when you are working on the code or would you commit and ship the code with the noop statement?
Love your work!!
Yes I'm aware of them. I was actually thinking to use them in my projects. Thanks for reminding this.
Some of this content was over my head. Are their any non-obvious points to consider that he might have touched on briefly or in a cryptic way?
This could be useful as a test if it is testing against an external interface or vice versa. If you make the check compile time, it also makes the other package a compile time dependency, when the entire point of having an interface is so there is no compile time dependency.
Does the allocation get optimized out in the end? 
As others have said, this is a (rather opaque, unfortunately) way to say "this type must implement this interface". In many cases it's not necessary to do this because some other point in the code will try to assign an instance of the struct (or other) type to the a value of the interface type and the compiler will catch it there. In those situations, some developers (including me) will include a statement like this just so that there's an explicit statement of intent close to the declaration, rather than it being hidden away in one or more functions. There is a particular situation where a statement like this is very useful: the optional interface pattern. Some may consider this an *anti-*pattern, but in a lot of codebases there are functions that take an argument of a particular general interface type but whose body then uses a type switch or type assertion to detect a more specific type. This is common with errors, for example: func DoSomethingWithError(err error) { switch terr := err.(type) { case MySpecialError: // do something unusual with terr here default: // fallback behavior for other error types } } If `MySpecialError` is *also* an interface type then a type that is intentionally implementing that interface may have an unnamed variable declaration near it to assert the intent of implementing this interface, since otherwise an incorrect implementation (e.g. a mistake in the signature of one of the methods) would fail in a pretty subtle way at runtime, rather than being caught by the compiler. I've seen that some developers prefer to add the special unnamed variable in a `_test.go` file instead of in a main file, which means it'll get tested during the compilation of the tests rather than of the main package. As a matter of style, I prefer to put it in the main code adjacent to the type declaration so that the intent is explicit. However, I also tend to avoid using the optional interface pattern whereever possible since it can make things hard to follow for future readers and makes it hard to write "wrapper-type" implementations that implement an interface in terms of another wrapped implementation of that same interface. This is felt particularly hard by users of the `http` package interfaces, which have grown many optional extra interfaces over time so it's not generally safe to wrap someone else's implementation in your own.
then(funcA).then(funcA2).catch(funcB) nice idea. i am avoiding anything that needed to be closed.
Thanks again for your (and the other contributors) continued work on vim-go.
Removed rounding, should I look into using something other than floats?
Twitch uses Go for a lot of their site-wide chat-moderation tools. Go would be a fine choice. Of course, as /u/dontsyncjustride says, there are probably a lot of other fine choices, too.
Well I didn't think about that, but it's not allowed either in my actual case, where you get the value of the chan, and can't modify it to be buffered. Looks like I will rewrite the code which currently has the non-blocking send.
No reason not to leave it if you know that something should implement the interface. If you accidentally break it in the future, then you'll know right away. The discarded value shouldn't make it into the final binary.
The language is basically frozen at this point, the only changes have been implementation improvements and new tooling. The language is not going to get bloated. Also, please don't downvote people for unpopular or even stupid opinions. I think it's a valid concern even if it's an uninformed one.
Agreed. Go 1.x won't get bloated. And given the attitudes of the core developers, even if we get what we really want (for me, something that helps with writing generic data structures) for Go 2.x, it won't be bloated. 
It depends on the philosophy of the designers of the language. Go is designed by people who also implemented the C programming language and the Unix system. The Unix philosophy is all about simplicity and I don't believe that Go is going to be bloated in a few years (unless generics and stuff from Java and C# is added to Go). C has been out there for nearly 50 years, and it's still a small language. C++ has been out there for 30+ years, and it's as bloated as Java. The age of the language is not the measure. It's the philosophy of the designer that matters.
This one will blow your mind. https://medium.com/dm03514-tech-blog/you-are-going-to-need-it-using-interfaces-and-dependency-injection-to-future-proof-your-designs-2cf6f58db192
Take a look at [https://github.com/go-inf/inf](https://github.com/go-inf/inf)
I thought this was neat. https://medium.com/dm03514-tech-blog/you-are-going-to-need-it-using-interfaces-and-dependency-injection-to-future-proof-your-designs-2cf6f58db192
Two key takeaways I got where a) write barriers are expensive, so getting rid of them is great (which is why ROC didn't make it) and b) escape analysis means a lot of the GC techniques that are very useful for other languages don't matter as much (or might even hurt) for Go. Which seems obvious in hindsight, but IMO is really interesting as it both means that Go's GC can be simpler and/or that it can spend some of that complexity budget on other tricks. In a way, it validates a bunch of design decisions Go made. There's also this hash-idea which seems kinda crazy interesting, but more in the "speculative, it might become interesting in the future" kind of interesting ^^
I don't know really.
I would put this statement along with the unit tests and leave it out of the production code.
Me too dude/dudette... me too. :D
Go is great for bots. I wrote some Steam trading bots and they worked great.
Could you elaborate on why this would be useful? Sounds interesting!
I saw this on HN, really excited to kick the tires! Thanks for making this.
too bad i'm a secondrater and would never qualify :) these look like fun! 
&gt; This could be useful as a test if No, it is already useful. This is the idiomatic way to do a compile-time check. &gt; the entire point of having an interface There are many reasons for having an interface. Dependency injection is the most compelling reason for me, personally... &gt; is so there is no compile time dependency Unless we're talking about plugins, all dependencies are compile-time dependencies.
&gt; leave it out of the production code Test what you ship, ship what you test. It's a bad practice (IMO) to have code that isn't the same in vs. out of production. Opens the door to an entire class of bugs... and easily avoided.
Does it matter? It'd just be a handful of instructions run once at the start of the program. GC would probably clean up after it pretty quick, being that there's no references to it anywhere in the program.
&gt; Static compile time tests are generally preferable over dynamic runtime tests when possible The reasoning here: the earlier in one's build / test pipeline she can catch an error, the easier it is to find the exact location of that error. Instead of having to dig through the output of some test suite, a compiler will point you directly at the offending line of code.
Add tests. Other than that, great work
I failed the "Required Skill" =&gt; Emotional Intelligence. haha.
Yeah, I also hate generics &amp; love having to reinvent the wheel every time I want to do something useful.
Is working remote an option with these openings?
I've been an engineer for a very long time. Nothing gets me out of bed like golang does!
The answer is in the web page — https://i.imgur.com/tqMb393.png
Ah! I was looking through the individual postings and missed that. Thanks.
`:GoIfErr` is amazing
 func _(w myWriter) io.Writer { return w } works for non-pointers
When I try a new language one of the first things I do is go look at the Vim plugins people have made for it. `vim-go` is by far the most complete development experience I've ever experienced for a language, better than even other languages with many plugins. It really made getting into the language much easier, and it's refreshing to feel like I'm not missing out on any features by using Vim rather than caving on using an IDE.
&gt; It's not, because then you lose compile-time safety. &gt; The code in the example will cause all compilation to fail if the mysqlDB type does not correctly implement the BookDatabase interface. This is worse. The keyword is 'all'. Even if you're using the type for something unrelated to some random interface it might implement, downstream code fails to compile. If you're using it as the interface it's asserting compliance with compilation will fail regardless of whether the no-op is there. Putting it in a test allows for flexibility by users of other functionality while retaining the safety net of not breaking compatibility with the rest by package authors. In any case the test will fail to compile if there are issues, it's not like it's a runtime check just because it's in a unit test.
I'm not sure what the etiquette is, but I edited my post to increase clarity. I'll also reply here so you can see it. Say you have a package foo which implements a Foo which satisfies a Bar interface in bar. If you add a variable check as mentioned, that means everyone who imports foo must recursively import bar, even if they don't use anything in bar including the Bar interface. However, if you add a check as a test, then bar will only be a dependency for running the foo tests, not when building foo normally.
&gt;&gt; the entire point of having an interface &gt; There are many reasons for having an interface. Their point is that go interface implementations don't depend on the code that defines the interface, they are implicit by design. If you have a package `a` that exports a type that implements some interface in package `b`, `a` doesn't have to import `b`. There is no dependency (compile time or otherwise) until it's actually used as the interface, most likely in application code somewhere where the import actually makes sense. 