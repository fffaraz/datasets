Good for you dude. This looks really cool. 
Fast is awesome but the OP could use GMP which Crystal get 0.001s https://crystal-lang.org/2016/07/15/fibonacci-benchmark.html
It works great for all things JSON was reasonable for, in the first place.
[removed]
No, there are lots of times that unbuffered channels are useful.
[removed]
When I read about golang channels, yes they are powerful and at first glance easy to use, but to get the use out of them, you need to accompany their use with selectcase for more sophistication. After completing a set of tools with go, I decided to take c++17 for a spin and rewrite one of those tools with cpp tf taskflow to manage when I start each task in parallel. I'll dare to say it's actually more straightforward to use than golang channels, but it does require more lines of code to prep I must confess. https://github.com/cpp-taskflow/cpp-taskflow is worth comparing to golang channels. golang os command invocation and piping of error/output is much simpler to use and reliable. The c++ boost.process in async surprisingly behaved unreliably and needed to backtrack to c unistd system() to get reliable waiting/joining to occur. Given more debug time, I could continue using boost.process, but time is precious. golang tools took about a month(8 of them). I took 3 weeks to complete just one c++/cpp-tf-taskflow-based too. go wins for productivity, but the c++ version should be seeing shorter task completion benchmarks eventually.
I had a problem with this. My use case was that the keys I wanted to store were AWS tags, which /are/ case sensitive. So I couldn't simply range over a KV store where the key was an AWS tag. I had to use the Name: &lt;tag_name&gt;, Value: &lt;tag_value&gt; approach, which is just not as clean. 
Is this a homework assignment or an interview question?
Not exactly sure what you need help with or what you already know so made a complete list of steps: * Complete the go tour or any resource that teaches you the language: https://tour.golang.org * Learn the basics of HTTP * Learn how to encode/decode JSON: https://gobyexample.com/json * Make a HTTP hello world: https://gowebexamples.com/hello-world/ * Now combine HTTP + JSON: https://gowebexamples.com/json/ * ^now you have figured out how to accept data and respond back with the result * Learn about SQL and sqlite * Figure out the schema * Figure out how to work with sqlite in Go: https://github.com/mattn/go-sqlite3 * Now just glue everything together (storing received data in sqlite, running a sql query to compute the average, responding back with the avg.) Hopefully less lost now? 
Don't learn or use C++, use Rust
Learn Go, Rust, and/or Haskell
[removed]
Even though Goroutines and channels provide a nice stepping stones for Concurrent programming, there are still lot of things for the user to figure out. I think Erlang/OTP provides better system for concurrent programming than Go does.
They are a little more heavyweight than you may think. You will actually get better performance if you just lock everything with a mutex. What go has done is made it beautiful and allowed us to easily solve concurrent problems to where the weight of it doesn‚Äôt really matter. 
Actually, channels alone are pretty useless. "select" is the most important aspect of Go concurrency.
It should be noted that Go's concurrency comes from CSP &amp; friends as you can see in this 2012 presentation slide by Rob Pike: https://talks.golang.org/2012/concurrency.slide#9 And yes, it's impressively simple once you get the hang of it.
Damn, this is cool. How long have you been coding in Go? I'm a .NET dev trying to learn but its been a slow process so far...
Awesome that you found a reason to use Go. But out of curiosity, did you take a look at my PyLaTeX library when looking for a Python pdf library? I wrote it with the exact purpose to create pdfs easily from python. https://jeltef.github.io/PyLaTeX/current/
Tars is a fullstack of micoservices. We have a protocol named tars ,which is like protocol buffer. We also have muti-language of rpc framework , like tarscpp, tarsnodejs,tarsphp , and this tarsgo . In addition to rpc framework ,we also have a web oss, and other lots of functional characteristics just like u said: logging, metrics, tracing(opentracting + zipkin) . Tars has been used in Tencent($143 billion company) more than 10 years. So don't worry about the "obscure bugs " . In the fact , we support protocol buffer protocol too. 
You'd really like [Occam](http://wotug.org/occam/). It's a shame it's not really a thing any more.
Fair enough. In this case I should be able to understand this from the readme. A small readme and 20 commits didn't really made me want to try it. Also, something to answer the obvious question: Why would I pick this over gRPC? I don't mean to bash, just some constructive criticism in case you want some open source traction.
Package have this testdata [https://github.com/xdefrag/ska/tree/master/internal/ska/testdata/raw/ex1](https://github.com/xdefrag/ska/tree/master/internal/ska/testdata/raw/ex1) It's very simple, but gives idea how it works. But anyway I'm plan to add real world examples soon.
&lt;-time.After(10 \* time.Second) // just a moment
Thanks for ur criticism . Sure, TarsGo is new released recently , and lack of documents, specially English version. But there are more docs about tars in [https://github.com/TarsCloud/Tars](https://github.com/TarsCloud/Tars) . We will continue to improve. Still I have to sayÔºå grpc is only a rpc frameworkÔºå not a micoservice framework. Still u have to solve the name discovery, logging, metrics, tracing, and operations .etc. problem by yourself after using grpc . But Tars solve these all by framework and other basic servers and web oss. Thanks again for ur criticism , We will accpet it and impove later. &amp;#x200B;
&gt;epositories (may) share the same \*sql.DB. I've only used this patterns with a few microsevices, so your approach may have it's benefits when you have a lot of repositories, but I haven't reached that part yet, that's ehy maybe I find this approach better. Yes, separate each storer along with it's service/domain (user, blog). from main package inject the db connection into the storer into the service of each package, thus shared conn. I've used this solution quite a lot. Main ends up being a lot of constructors and injecting deps. I keep packages very isolated (a-la-microservices), and usually inspect the import statements to check any cross package deps, they should only point down not cross.
Just a few months, this is actually my first and only project made in Go right now, the project was initially made in NodeJS but I've been migrating in the past few months to benefits from: \- A fat binary that's actually easy to use for everyone and doesn't assume much (WIP as using CGO can make it hard) \- No compromise when it comes to speed 
Very cool.
I've never used OwnCloud, but am familiar with what it is. Choosing PHP for an app with heavy file management capability seems like an odd choice.
Damn, I need to pull my finger out. What resources did you use to learn?
1) I read religiously this: https://tour.golang.org/welcome/1 at least 3 times 2) Started writing code to practise 3) read code from some other project I was using before learning Golang (Mattermost, Gogs and Drone CI)
I did not. Had I come across it I would have written it off though because I didn't want to deal with an intermediary like latex.
Like OP has said, reading other people's code is a fantastic way to learn. The standard library is a particularly good source of idiomatic, readable Go code. Be critical though, there are some Go open source projects that are decidedly not idiomatic IMO, and blog posts that recommend doing things that are not a good plan. Read these things, try them out, and develop strategies and patterns that work for you - at some point it'll just click.
It's for school but not a homework assignment more like extra credit to see if we could figure it out
I was thinking of text boxes so there was a decent way to input the data 
So is this basically an index? I clicked the demo, but it wanted me to input my credentials, which is not going to fly.
It is basically like Filezilla FTP but: - instead of restricting to FTP, it lets you choose between FTP, SFTP, WebDAV, Git, S3, Minio, Dropbox, Google Drive - it is web based and look more like Dropbox than Filezilla FTP
Thanks 
I use `select` sparingly. It's great and all but channels are my bread and butter.
&gt; If you want to just give it a try, you can click the git tab and put whatever repo url you want. You will be able to look through but not save. Better than Jenkins then ;-) &lt;3, thanks for sharing.
Yes thanks so much. This is exactly what I needed
Big overkill for OPs purpose. Also suggesting gokit to a someone new to golang idk what you are thinking. And OP no frameworks or anything needed. Its not javascript. Standard library has everything you need
Wait what happened with Dropbox, did they fall out of favor with the community?
The framework: https://github.com/segmentio/orbital
&gt; because it's PHP-based. Funnily, I've stumbled upon people who wouldn't use anything that's not PHP. &gt; Can I donate to you anywhere? I've created a [Patreon](https://www.patreon.com/mickaelk) and a bitcoin wallet (3LX5KGmSmHDj5EuXrmUvcg77EJxCxmdsgW) &gt; At this rate, when does the Cordova wrapper come? To be honest I didn't thought it was possible to do it but that would be quite an interesting project. It probably won't be there until quite some time as the project rely on a few C libraries for image resizing and transcoding that are integrated with CGO and statically compiling those has proven to be a pain in the butt that I haven't managed to complete yet
&gt; Like OP has said, reading other people's code is a fantastic way to learn. It is, but you have to be at the right level. When I was first getting into programming with Python I got that advice and I just felt super lost until I got more general experience.
This is basically impossible. If you are interested in spelling errors misspell and identypo are good.
This is basically impossible as grammar is hard. If you are interested in spelling errors misspell and identypo are good.
This is a great project! How did you find the transition from NodeJS to Go? Were there any concepts that didn't really carry over from the original version you built?
I used to be one of those guys who wouldn't run anything that's not language X (the only language I knew). Now I want to run something that isn't constantly failing apart, struggling under load, and full of security holes. Usually that means PHP (Wordpress, Drupal, etc..) is not an option. &gt; the project rely on a few C libraries for image resizing and transcoding I meant wrap the client/UI react code with Cordova so we can have a mobile app.
Dropbox is a very useful service, but you have to agree to provide all your personal files to them just like Google or any other non-encrypted cloud storage. Some files I don't want floating around in multiple data centers and delivery networks (not to mention government agency copies).
Great idea! Sadly, the client is written in Javascript? That's a browser scripting language, not a desktop one. Why not at least have a command-line client in Go, and have an optional GUI thing in JS if you must.
You need a different goroutine reading from the very same channel at the same time when another one sends to an unbuffered channel. Unbuffered channel act therefore as a synchronization mechanism as this is the only point in a concurrent program where both have a predictable state. Having a buffered channel is asynchronous in contrast. Channels are not too useful in a solely sequential control flow.
&gt; I've created a Patreon and a bitcoin wallet Do you have a paypal.me page for one-time donations?
&gt; How did you find the transition from NodeJS to Go? To be honest, the first 2 weeks were frustrating as I was missing a lot of features from the language itself (things like a REPL, the lack of features to express optional parameters in functions, map,filter,reduce in slices, partial function application (Don't ask my why but I really really like this technic), method overloading, recursive functions that look good (like in all functional languages I've tried) and dependency management that's weird compared to other languages, extreme verbosity when it comes to error management that lead to in my opinion to harder to read code) and finally blog post with different opinion about everything web related (eg: findout if you should use context or not?) After that initial stage, it became butter smooth and the migration happened to take less than 2 months which was less than expected &gt; Were there any concepts that didn't really carry over from the original version you built? Not really, I've manage to get the same exact REST API (except for the testing aspect that I haven't bother much with yet). The tricky part was: - making sure the function signatures are good enough for the needs - migrate all the data transformation pipeline that was using stream in NodeJS to it's Golang counterpart
Yeah, you're right, legally they have no case. OP should still pick a less confusing name.
Stepping stone? Messaging/Actors in Go: Be sure a channel is only used by one goroutine and make it with an "infinite" buffer. CSP in Erlang is not as simple. Most of the benefit of Erlang is the functional paradigm being front and center with the resulting control flow restrictions and general purity providing "safer boundaries" for rationalizing concurrent solutions. The limitations of messages making the actor model appear simpler is not the hero.
I myself very much like Echo, however I seriously wonder about its future. There are many pull requests that are not merged, there are many questions on forum, but no answers. The chat channel is the same.. many questions, but no answers. The code is getting updates, but there does not seem to be any participation / replies on plubic forums. Most concerning is the fact that pull requests are just getting ignored. There are people trying to help the project but if their pull requests don't get reviewed, much less merged then that does not bode well for the future of that project.
&gt; I much prefer the approach of contributing back to those projects and provide sweet integration via the project than starting yet another alternative. Let me just underline that for you as to how good an idea it is. File sync is really, really, _really_ hard, harder than it looks, and when you screw it up, you destroy your user's data, which really blows for everybody. Staying as far away from that as you can is a good idea.
What does go‚Äôs in-your-face error handling have to do with this? Your suggestions arent features, they‚Äôre code smells...
Eventually! Unless requirements change. Unless the go productivity allows you to focus on algorithmic complexity as opposed to low-level optimizations.
Docker.
I can highly recommend reading the stdlib sources whenever using it. For the most part they're extremely clear, and you'll learn a lot about how to write idiomatic Go in the process
[removed]
If your channel doesn‚Äôt have a select on it, your probably handling cancellations poorly. 
Man, this is exactly what I wanted last year when I was trying to figure out parser combinators based on a bunch of cryptic Haskell and OCaml examples. I ended up coming across a bunch of the same techniques myself, but I always found the lack of generics really limiting for this use case (specifically managing the \`Result interface{}\` things). It's nice to see my intuitions affirmed, at least.
Use Go, it makes safe network programming much easier. 
did you try gophercizes that might help speed up the process? it only took me 2 days to write m first go project, its a very approachable language
also go by example and go in 5 minutes are very good
Cool project. I‚Äôd give it a spin, but I‚Äôve settled for Resilio Sync as my Dropbox replacement.
You really should give Syncthing or Resilio Sync a try. They both do the same thing. Syncthing is open source, written in go. Resilio Sync is closed source, but generally works ‚Äúbetter‚Äù. Syncthing doesn‚Äôt have an iOS client, which was a dealbreaker for me. It‚Äôs also somewhat slow to connect to peers. It does however work well when it connects. Resilio has an iOS client, and connects in a matter of seconds. It also supports sharing encrypted shares. It‚Äôs meant for backing up data with an untrusted node. The data is still readable to you, but stored encrypted on the untrusted node. I have it running on a couple of nodes, 2 at home and one remote, so my data is always available in (at least) 3 copies. The great thing is that hardware speed isn‚Äôt a big deal. Because you have multiple nodes transmitting data at the same time, your ‚Äúalways on‚Äù nodes could be a couple of Raspberry Pi computers.
Depending on the project, I'd still pretty seriously consider using Go as much as possible. Shelling out to ffmpeg or something can probably do the rest. You really, really shouldn't hook up C/C++ code to the network. (The shell to ffmpeg needs to be pretty isolated, too.)
'For a Linux user, you can already build such a system yourself quite trivially by getting an FTP account, mounting it locally with curlftpfs, and then using SVN or CVS on the mounted filesystem. From Windows or Mac, this FTP account could be accessed through built-in software.' :)
This is a school Project and we first just want to send video stream wirelessly. But later we are planning to plant camera on a drone and send the data from drone camera to PC. Would Go be too much problem for this kind of work ?
Packages that you want to import should be stored in your $GOPATH. The default $GOPATH is ~/go. When you import a local package it will search in go/src for that package. Move the router directory to go/src/ and then add "router" to your imports and reference the functions as router.GetRouter() More standard convention in go is to write all of your gocode inside of your gopath. Typically go/src is organized with git retrieval in mind. Following this convention you would want to move all of this code to ~/go/src/github.com/spaghettiCoderIT/gobankmockup. And then all of your imports will be the full path starting with github.com.
There is no language named C/C++. Which one do you mean?
You can simply assume the question as C or C++ or Golang for socket programming? Like the people above did.
&gt; [‚Ä¶] how to do it without using the GOPATH You cannot‚Ä¶ unless you are using Go Modules [1] &gt; If my project structure is not matching any conventions please let me know Here is how I would structure the project: $GOPATH ‚îú‚îÄ bin ‚îú‚îÄ pkg ‚îî‚îÄ src ‚îî‚îÄ github.com ‚îî‚îÄ spaghettiCoderIT ‚îú‚îÄ GoBankMockup ‚îÇ ‚îú‚îÄ entry.go ‚îÇ ‚îî‚îÄ main.go ‚îî‚îÄ router ‚îî‚îÄ router.go Then, inside `github.com/spaghettiCoderIT/GoBankMockup/entry.go` I would have this: package main import "github.com/spaghettiCoderIT/router" func foobar() {} And inside `github.com/spaghettiCoderIT/router/router.go` I would have htis: package router func GetRouter() *Router {} **Note:** GOPATH is being deprecated in Go v1.11 with the addition of Modules. [1] https://github.com/golang/go/wiki/Modules
[There's also no language called "Golang"](https://tip.golang.org/doc/faq#go_or_golang) as well. 
As always it depends...on the use case you did not exactly. Furthermore, for live video streaming, there are already (free) tools at your disposals that exist, it would be dumb not to use them.
Check if the list is empty before executing the template.
If you're just marshaling bytes from the camera to a network, then Go will work great. If you need to do some sort of transcoding or video compression, C may be better (although maybe /u/jerf or someone else can make the case that Go is not only safer but also more convenient?).
I use this guide to structure my Go programs: https://github.com/golang-standards/project-layout
I think that is a reasonable justification, but it isn't applied elsewhere in the language. For example, often, if you convert between types, Go has to allocate memory.
Conversions are explicit, so that sounds completely appropriate.
Unfortunately, this is not an option when using consul-template.
I think there would be additional effects on how you had to define the language. The issue that stands out to me is that what you can assign to is currently defined as addressable things plus map index expressions. If you make more things addressable, either they also become assignable (which may not be what you want) or you need a more complicated definition of what can be assigned to. For instance, is `sha1.Sum()[:5] = ....` valid? Probably it shouldn't be, but creating a rule that rules it out seems tricky. (I'm the author of the linked-to blog entry.)
You're 100% right
I'm already a heavy syncthing user \`:)\` I'm super keen on building an integration that call the syncthing API to sync new folders with a client
Whether it is C or C++, both will still use the same system interfaces (socket, bind, accept) from the kernel regardless, it only changes how you will manipulate the results from the system/kernel calls. Therefore, learning socket programming will be the same for C or C++, he didn't ask to learn C or C++ itself :-) In regards to answering the question however, if you go down the C/C++ road, prepare for more memory management and cleanup, and more room for buffer errors etc, which Go will help you a lot in not tripping over as often. It comes down to your programming experience and the depth of knowledge you want to learn socket programming, as the Go libraries hide a lot of under the cover and sometimes difficult to use system calls. Happy to elaborate further on this if you want examples of some of the things Go will make your life a lot easier with. &amp;#x200B; Anyway, just my 5 cents worth :-)
I was thinking implementing a photo mosaic algorithm with only the go image package but haven't started yet.
In that case, I would edit the post to reflect the fact that you are not using regular Go templates. /u/nsd433 has a good idea, give it a try. If that doesn't works, contact the Consul-Template authors: [1] https://github.com/hashicorp/consul-template/issues
I'd recommend against reflection and using your struct type instead of interfaces, reflection API is not developer friendly.
JSON spec does not support binary blobs, so you have to use some kind of string serialization to handle []byte anyway. Standard library just provide you with a reasonable default. It also provides json.RawMessage type to handle this manually.
[removed]
real men test in production
I second /u/mokbel's suggestion. Unless the data to process is of highly dynamic nature, there are always easier and safer ways than using reflection and empty interfaces. Regarding your current problem, my first unwashed guess is that your struct contains a \[\]string but your CSV code only handles bool, int32, and string. &amp;#x200B;
I tried adding case \[\]string, but i'm not sure what to put after that..any suggestion?
Cool thanks,but I have a question in my case $GOPATH is not a directory it's in /usr/local/bin/go. What am I doing wrong?
How about no?
try using text/template not html/template?
If you're using it to generate code, wouldn't it make more sense to use text/template which doesn't do the escaping?
I think your speculation about stack and heap is probably right. Go has tended to force the dev to specify things that other languages gloss over (error handling is the poster child for this, obviously). Forcing the dev to specify a variable in order to get the return value on the heap and therefore addressable/assignable sounds like a very idiomatic Go thing to do ;) It's safer this way - you can't accidentally assign something while chaining together a bunch of function calls to save space.
reference a sub-template that doesn't exist or hasn't been loaded. I do this all the bloody time accidentally.
No need `else` after `return` or `log.Fatal` Try this ``` func (s Site) Map() map[string]interface{} { return map[string]interface{ ‚ÄúName‚Äù: s.Name, ‚ÄúType‚Äù: s.Type, ... ‚ÄúTemplate‚Äù: s.Template, } } ``` Then you can range over it and switch on interface type. 
For non hardcore Go developers l- and rvalues are probably better terms. C has a lot if simmilar restrictions. 
That is just awesome.
Superb!
I‚Äôm (trying) to replace Resilio Sync with Syncthing for my server to server replication needs, but for my cloud needs, nothing beats Resilio Sync for me. I have no doubt the connectivity issues are down to errors I‚Äôve made during configuration of syncthing, but that still leaves me without a proper iOS client. I‚Äôm aware of, and own, fsync(), but it still takes ages to connect whenever I‚Äôm outside my home network.
Thanks in advance! haha
When mocking actual HTTP calls (or any actual TCP/IP calls) the industry name for this is ‚ÄúService Virtualization‚Äù. That includes record/playback if the same, though not all techs in that space do that. There are half a dozen vendor products on that space. Ignoring them the one I think is most general purpose is Mountebank: http://www.mbtest.org. If anyone is interested, the most well known in-process mocking technology is Mockito.
Cool, coming from a Java background I've used Mockito (and PowerMock) a lot for testing which was why when I started Go I wanted to find something that allowed me to do mocks. But from my understanding Mockito only works on JVM languages. &amp;#x200B; Also Mountebank sounds a lot like [WireMock](http://wiremock.org/) but integrates well with JUnit tests if you are running Java.
Where else can we test ?
Using the data, and the code you provided, it appears to work: [https://play.golang.org/p/tqCQ-Y5QhXh](https://play.golang.org/p/tqCQ-Y5QhXh) (provided that we change \`string\` -&gt; \`int64\` for \`analyticsVolumeResults.Key\` field). &amp;#x200B; Can you check the response body to see if it is appropriate? It may be that the response body does not conform to the expected data structure, and if so, you need to account for this, e.g. via the HTTP status code or response headers, etc. 
i like it.
Nice! how can I enable exposing the /profile endpoint in my Go apps?
Oh, for a school project, you can go ahead and use whatever the drone camera's devkit most natively supports. It'll be the easiest to get started, since their examples should work, and the easiest to get help with from other people. Just don't run the code on the Internet afterwards. School projects are too small for all but the grossest of computer language differences to manifest. At this point in my career, if I was in your shoes and was using C, I would without shame take the approach where I simply never deallocate memory. If you can afford to never deallocate, a lot of the memory management hair-pullers in C never arise. The only thing you really have to double-check there is that the part of the code where you're actually streaming bytes reuses buffers; that'll be by far the dominant memory usage.
Thank you for your comment. :) Some Haskell and OCaml programs tend to be rather short and concise instead of self-explanatory and easy to understand. Do you have a link so I can have a look, just for comparison? Yes, the lack of generics is a bit inconvenient. However, if you carefully write tests covering the type casts then you'll get a program with good quality anyway. Generics would save some time here, I think that's for sure.
No, I don't have any links. This was more than a year ago. And Haskell and OCaml programs probably are easy to understand if you're experienced with those languages and their parser combinator libraries (I still don't know what a Kleene star is, for example).
thanks thats a very cool tool
I changed that key type thanks for that, but I still get an error on decoding
https://github.com/mockito/mockito/wiki/Mockito-for-other-languages
It also depends on the language. Go is really good at this aspect, but reading C++ code, for example some boost libs, can be seriously brain damaging.
What do you mean? Rust is terrible regarding socket programing. It's too young to be very useful.
Thank i will, how should I handle it? 
I'd just print it and stick it in something like https://jsonlint.org
You're right! We got that right in the blog post but wrong in the example. Most of our tests have latencies of 1s or more which might be why we missed it. Thanks!
https://www.youtube.com/watch?v=UvoHwFvAvQE
Looking at the source code for "get" it doesn't seem there's an obvious way for you to control default behavior from the repo. What I would prefer personally when working is to have a Makefile or some other script that I can use to pull the data when I want to test a package relying on a huge test fixture. Or even just documentation on testing so I know to clone the file. Maybe in the future there can be a file you can add that the command checks before updating/cloning all submodules. Interesting scenario regardless.
I do a Black Friday sale that is usually 40% off. There is also an ebook only package and I am willing to help out if neither of those work - jon@calhoun.io
thanks alot @dark_magician2
[removed]
Ok, that make total sense. I wonder if you could simply fork it and remove the code that changes the case of the keys. 
&gt; What I would prefer personally when working is to have a Makefile or some other script that I can use to pull the data when I want to test a package relying on a huge test fixture. Or even just documentation on testing so I know to clone the file. All that and a check in `TestMain` to make sure the test data is present. Exit with a message if it isn't. 
Exit with a message, or initiate transfer? üòä
Google is the main contributor to Golang at the moment. Whether you should work on learning Golang is really dependent on what you'd like to do. If you are looking to build APIs, then Go is the language for you. Lab Stack's echo framework makes writing APIs really simple. There are some major differences between javascript and go, for example, go is statically typed where as javascript is dynamic. There's a lot of idiomatic rules that need to be followed as well. Take the tour of Go and see how quickly you can pick it up. tour.golang.org
Why no syntax highlighting?
Google; Adobe; Docker; Dropbox; eBay; Lyft; Slack; SpaceX... the list goes on. The open-source community is embracing Go, too. See Ethereum, Bitcoin LN, devIOTA.
I appreciate the feedback! I'm undecided about what to do in the next video in the series, I was thinking either playing with video streams and trying to perform realtime analysis of who's in the video with this library, or go deeper down into how dlib does it. If you think that it would be better going into the underlying algorithms then I could certainly go down that route!
Golang implementation of Pico face detection library: https://github.com/esimov/pigo
It is not always the case that one should ignore the rest of the return values on error. See io.Reader for one example of where the return values are valid and useful when an error is returned. 
What type of streaming you have in mind? Nginx can serve HLS, which is not streaming per se, but progressive download (lots of small fragmented MP4 chunks served as static files). Unless you buy a commercial plugin, you still need something to create fragments and playlists - FFmpeg is great for that. Nginx can also cache those files in memory or disk in case you want to have few levels of cache across country or the world. For HLS, Nginx would be better. For continuous stream, Nginx won't help much and Go is a good solution here. You can still have web server as reverse proxy for basic input sanitazation, routing and ACL, but it can quickly turn into a headache if the number of clients is large. There is no general answer for your question. 
The method used in this for downloading a test kernel would work: https://github.com/google/embiggen-disk/blob/master/integration_test.go https://docs.google.com/presentation/d/1rAAyOTCsB8GLbMgI0CAbn69r6EVWL8j3DPl4qc0sSlc/edit#slide=id.g410de087f7_1_31 https://www.youtube.com/watch?v=69Zy77O-BUM&amp;index=25&amp;list=PL2ntRZ1ySWBdMEZScpaoRX-vyt6pRUvfM 
Sure! 
I would also like to learn more about how exactly it works.
Thanks. that's a very nice idea. If I hadn't just found another workaround I probably would have gone with this. &amp;#x200B; What I did now is set the `lfs.fetchexclude = *` config parameter. That way Git LFS only downloads the 'references' to the files and for the actual files the user needs to do a `git lfs pull`.
I would go into a loop to iterate over the string slice and process the strings one by one.
`req.ParseForm()` and delete de json decoding stuff
[removed]
I see your poin but I don't honestly think that's a really good example. Don't you think it would be better to return an error Struct decorated with additional fields if it's necessary to return more data instead of carefully reading the documentation and check which return values are valid?
[removed]
Was wondering the same?
This URL is pretty much up to date (check the end of the article for http profile endoiints) - [https://blog.golang.org/profiling-go-programs](https://blog.golang.org/profiling-go-programs)
There's a missing link in the page for ../go-hex-arch/ that you may want to fix. 
Nice. FuncMap will let you do the same without needing to name the argument type.
There could be a case where you're processing a lot of data and the error could indicate where the data becomes erroneous if you should wish to try using the data before that point. I imagine there could be places where an error could indicate that some validation step was not possible, but it might still be necessary to use the result while documenting that it isn't validated. There are probably times when there are other ways to go about this so that you don't want to copy valid data but have some data available. A specific use case might be hard to come by, but I think the noodle is trying to make a point about absolutes not being necessarily useful. I'm sure most would say that it's almost always right to ignore the value in the event of an error, but all absolutes are dangerous--including this one.
The creator of go consider syntax highlighting juvenile, like when you learn math as kid with colors.
The contrast between the languages would be a good way to make your skillset more powerful. An officially maintained list of some users is here: https://github.com/golang/go/wiki/GoUsers but of my last three employers, 2 use Go and none are on this list.
Yep, agree with you Palu. I was just surprised that people downvoted because in majority of the cases you really want to ignore it and the developers who are responsible for working with large dataset/complicated buffers know better already those exceptions so I wanted to keep it simple and "absolute" (better would be to say, in majority of cases).
&gt; No code coloring (except comments). Is even listed as a "feature" do don't bother.
Pretty much anything you can find on the Internet regarding HLS. It is a very simple protocol, based on HTTP and MP3U8 playlist format. The hardest part really is getting the video container parameters right and that's pretty trivial. I suggest FFmpeg for file preparation (including live streams), Nginx for serving them, Varnish for cache (if needed) and Go application for management. You can find some very good HTML5 players for HLS to embed on the web page, Android also has support for it. Since HLS is from Apple, I bet there are no problems with this protocol on iOS. I don't know about Windows mobile. You can also prepare for MPEG-DASH. It is very similar to HLS, but should have better support in the near future. When MPEG finally finishes the specification that is.
I would definitely watch that.
Awesome!!
Huh, I find that weird. But who am I to judge. For me it helps a lot for quickly finding different sections of the code, so it has a practical use.
issue date... 2014. If you're going to address closed comments from 2014 I'm not sure it's a good faith conversation based on gittea from 2018. Was it perfect no, was it good, hell yeah. I remember the first OpenSource code I looked at. It takes time for things to get better.
[removed]
The usual recommendation is for the [tour of go](https://tour.golang.org) that's available on the official site. It only requires reading, and has a code window on the side to try out the language without having to install the environment.
Pickle can be a confusing name since there is a module in the Python standard library called pickle. https://docs.python.org/3/library/pickle.html Other than that looks neat!
I second this. It's how I learned the language.
You might want to specify which ORM you're using. And the error message means exactly what it says: by default, pq requires TLS protection on all connections. Either you need to disable TLS before making a connection, or you need to enable TLS on the server. Look at the sslmode parameter in the URL, [as per the docs](https://godoc.org/github.com/lib/pq).
I have SSL disabled in the connection string. I am thinking it has to do with my database set up? I've never used postgres before so I am super lost 
I don't know why you'd be getting that error, then. I've used Postgres with pq with SSL disabled and not had any problem.
Might be worth taking a look at https://github.com/fogleman/fauxgl
I mean, to each their own, but I find it useful if only because it immediately surfaces the AST of the language in a way that is easy to grok. Sometimes when I'm coding quickly I will forgot to close quotation marks or a parenthesis; if I do this, the line I'm typing won't be in the right color, and my mammalian brain immediately says "woah that should be orange, why isn't it orange, I messed something up."
I'm a newbie.. not hard at all. If you mastered Objective C, Golang will be a walk in the park.
I believe the flag is sslmode not ssl. So sslmode=disable
I know Swift. Don‚Äôt really know any objective C. Don‚Äôt know if that counts 
awesome thank you. Just have to figure out the first error. Is my flag on that one wrong? or could I be getting that because I do not have a database named default maybe?
Thank you very much. This is very helpful. We use generics in Swift. Not sure if they are similar to the ones in Go. In Swift you can build something like a generic class or function with parameters and literally just call that function populating the parameters with any type be it string, int etc 
The hardest part is finding projects with good architecture. There is a sub current in the community that essentially smacks everything together without regard to decoupling. So you may have functions and interfaces, but they are all directly called by each other. You're controllers will often have import database/package rather than having a common repository and interface that matches. How you get around this is an open question to me.
Yea.. the reason why I mentioned generics is because Go doesn't have any :P the closest thing you get to generics is passing in and returning `interface{}` which is a bit like returning `Object` in Java. So you see a lot of not-so-DRY code - you would have a library which would have `.Int()`, `.String()`, `.Float()`, or you would manually have to do `x, ok := v.(string)` and check if `ok` is `true` to see if casting is correct. Again, you will probably encounter some problems with it, but before you start cursing at your screen, take a look and understand interfaces, it will help a lot and you will see a lot of problems can be done without generics, even if it means a bit more code. Also, sometimes I was sleeping during my college lectures, so probably "cast" is not the best word, so don't quote me on that ;) and there is a chance I might spark yet another argument about the need for generics in Go. Whoops
Haha, I see, with interfaces, are they similar to the ones in java. Coz we use protocols in Swift. I understand casting atleast in Swift. I‚Äôm gonna get started straight away. Very excited to starting learning Go 
Thanks!
It‚Äôs not. Try it out. It‚Äôs awesome. 
From the little I‚Äôve seen of Swift, Go seems like a simpler language so you shouldn‚Äôt have a problem. I would recommend trying to get your hands dirty with a basic web server or some other simple project as quickly as possible. You can learn most of the concepts as you go.
Do not ignore errors! Esp. Flush, Close of file, buffer, csv writer! Add a default case into your reflect type habdling switch to log.Fatalf the unhandled element.
I also recommend starting with the tour followed by The Go Programming Language book: [https://www.gopl.io/](https://www.gopl.io/) These two books sound good but I haven't read them myself. [https://interpreterbook.com/](https://interpreterbook.com/) [https://compilerbook.com/](https://compilerbook.com/)
Super small learning curve. The Go-docs are great and websites like codesignal are useful for learning syntax. Have fun! :)
So, i tried doing that: &amp;#x200B; case []string: stringArray := ri.Field(i).Interface().([]string) for ii := 0; ii &lt; len(stringArray); ii++ { result = append(result, stringArray[ii]) } And this sorta works. It will add the data to the CSV, but after every ip address range, it adds a comma. So the CSV is overwritten if there are multiple addresses. I can't replicated this anywhere. When i run an append on Go Playground, there is no comma. I've also tried replacing the comma in \`result\` but it won't work because it's a string array.
I‚Äôm and advocate for any person wanting to program to start with Go. IMO, it needs to replace python and java as the de facto teaching language.
[removed]
Problem is, it renders into images not real-time to the screen
I wrote a doom clone, but I really just learned go for that purpose. I would usually port something I‚Äôve already written when I learn a new language (but don‚Äôt try to convert it line by line). If you want to do something new I would suggest: recreate an older arcade game you like, or make a calculator that parses complicated input (eg: (8*4/3)+1 ).
Nice! Any reason why you are not using https://github.com/miekg/dns for the protocol parts?
Extremely easy to learn. You‚Äôll take at most a week to get familiar with it. 
I suggest to actively make a point of using Go more. The next time you think of writing a new shell script or a quick test utility, do it with Go instead. Use https://play.golang.org/ as a calculator when you would otherwise reach for the Python interactive REPL. Instead of googling for "command line frobnicator client" google "golang frobnicator client". 
Have you tried one of the Go bindings to SFML?
I made a bot for Slack.
Wrote some simple restful services that exposed an API. Did a lot with the BoltDB package, too.
I wrote a Mesos framework called eremetic to run short-lived tasks.
Thank you for your feedback, appreciate it :) Yup, I have to optimize the library for sure. The bloom filter library uses murmur hash, and based on what I've used before, xxhash and fnvhash have good distribution property, hence I chose the later for implementing the Cuckoo filter. And thanks for your suggestion! Definitely would be helpful! I'll look into this for sure
Of course, the shell has the most limited functionality only. Pipes etc. are not implemented. When this is the issue, you might need a more sophisticated tutorial :)
I completely agree with this. I have grown up closely with computers and Linux from an early age. I only really started programming a few years ago with python and bash. Lately I‚Äôve had daydreams about beautiful and simple things in Unix computer systems. So I started learning go and c. I love these languages so much. Go is so flexible like python but still enforces a certain level of code quality and simplicity which is a very good thing; not to mention, you have the added benefit of compiling go programs. Python is pretty good for quick and dirty stuff but I still prefer to use shell or go or some combination most of the time. One way I love using python is as a programmable calculator. Using python interactively is a great way to do complicated calculations easily.
The io.Reader Read method returns the number of bytes read in the first return value, even when there's an error. It sounds like you don't like this design, but that does not matter. There are other methods like the io.Reader Read method in the standard library and third party packages. The blanket advice of always ignoring other return values in the case of an error is not correct.
Thanks mate 
This. Additionally I find coming from the world of OOP (C#), I find the lack of meaningful generics frustrating. Why do I need to implement multiple versions of a binary search tree, why can't I just supply one and use a type as a parameter?
My first Go project was and still is a rewrite of my snail simulation (originally written in PHP in Go). It was not a simple first thing to start with overall, but allowed me to learn bit by bit while writing the infrastructure packages I needed (eg db, auth, simple rest api).
Made a simple app to stress-test Logstash and Elasticsearch
This appears to be missing edns and other support nessecary for real world use?
Did you try using the Pixel package? https://github.com/faiface/pixel/
Thanks taht worked for me!
Followup: [Addressable values in Go (and unaddressable ones too)](https://utcc.utoronto.ca/~cks/space/blog/programming/GoAddressableValues)
Haha, supposed to be a Cuckoos bird, went more after the sound
I think you'll find the language is easy to learn, but concurrency problems are hard to solve.
[This](https://i.imgur.com/PqPo2sH_d.jpg) is a cuckoo. A cockerel, classically, goes *cock-a-doodle-do*. :D
I might be forced into changing the image! Appreciate your input :) :)
Is anyone using those jupyter notebooks ? any good ? 
I come from a research background, so I've used notebooks extensively. I'm ambivalent. On the one-hand they're very useful for storytelling with data. On the other hand, they introduce a lot of hidden global state, which is very bad. If you're going to use notebooks, keep all the actual algorithmics/analyses in a library, and only include markdown &amp; graph code in your notebook.
I used it for when I got an introduction to Python. It is easy for some analysis, like Matlab and fast to setup. Definitely recommendable. 
Python developers, amateur data scientists. This tool is the best in the world. The tool even received ACM software award for its huge contribution for the researchers.
It depends on what you mean, I've been using it for doing just that but you need to set up an image buffer to draw to.
This is awfully written and complicates some simple ideas by being needlessly jargonistic. 
I made a Gameboy emulator 
I found this really helpful. Thanks!
problem is that doesn't seem to work well larger than 320x200 (sometimes 640x480)
I did a fun video series teaching programming with Go: [https://gameswithgo.org/](https://gameswithgo.org/) &amp;#x200B; I found Go to be the easiest to learn language I've ever come across. The spec is very simple. Its like C but even easier since there are strings built in, garbage collection, and a big standard library. &amp;#x200B;
When dealing with graphic related application I seem to be at a loss. How do you know where to begin?
There's lots of articles and blog posts online about writing emulators for various systems, I just picked one that seemed simple and started reading. It doesn't take that much to get started, just need a 65536 byte array for RAM, a basic structure for your instructions, the ability to load a ROM file, and a program counter. Then you can start coding instructions, which often means you'll need to add other things like an interrupt enable flag or a stack pointer. Eventually you can use test ROMs to check if your instructions are correct. 
I call them methods
They are [methods](https://tour.golang.org/methods/1), and the special argument in parentheses before the func keyword is known as a receiver.
Awesome, thanks so much!
Noted, thank you for your time.
Was on mobile so a lazy response. Here's a better one &amp;#x200B; When you do \`(thing \*Thing) MyFunc()\` that is described as a method. It's pretty analogous to methods in OO languages like Java/C# etc. It's just in those languages the "receiver" is implicit and is always called \`this\`
Sometimes it is said that "method is a function belonging to some object". It is often used in other languages too, for example Java is purely OO language and basically every function is called method because every function belongs to some object.
Those are two different things with 2 different names. Generally speaking, functions that are attached on to other data types are called "methods", and you can learn more about multiple return values in other languages by searching for "tuples" (bunching multiple variables together) and "unpacking" (breaking them back apart). Technically, go doesn't really have tuples. Real tuples can be used anywhere and not just in function returns.
Name feedback: I really expected "gosh" to parse as "go sh", which would be a Go-based shell. The only thing preventing me from assuming that would be how stupid an idea that would be. 
As others have pointed out, the terminology you're looking for is "method" and here is a link to the definition in the spec: [https://golang.org/ref/spec#Method\_declarations](https://golang.org/ref/spec#Method_declarations) Just to clarify, a function declaration must begin with the `func` keyword and you can see the anatomy of a method declaration in the link above. Methods are still just functions and my understanding is that this particular format is just syntactic sugar. I believe that under the hood the following declarations are equivalent: `func (t *myType) myMethod(arg1 string) error` `func myMethod(t *myType, arg1 string) error` My point is that methods in Go aren't as "special" as they might be in other object oriented languages. [https://golang.org/doc/faq#Is\_Go\_an\_object-oriented\_language](https://golang.org/doc/faq#Is_Go_an_object-oriented_language) I hope you find these references helpful.
will try to rename it, thanks : )
I'd say the same as any other language. It's not an aspect of the language that keeps the code base "clean", but a development team's practices, guidelines and processes. 
Working on a large codebase that‚Äôs a few years old, as well as a brand new one, I‚Äôve seen things get messy. Will echo what‚Äôs been said about it not being any different to other languages in that regard. There is a lot of good advice out there on how to structure a project, though. Like separating main packages into a ‚Äúcmd‚Äù directory, keeping packages small (avoiding ‚Äúcommon‚Äù or ‚Äúuntil‚Äù), and the evergreeen ‚Äúaccept interfaces return structs‚Äù. For me, the biggest advantage of Go is it‚Äôs simplicity, which makes it easy to read someone else‚Äôs code. Second is opinionated tools like gofmt and vet, which remove some of the trivial arguments about style. This makes it easier to maintain your codebase, but don‚Äôt necessarily make it more maintainable without a little extra discipline.
Another good 2d graphics package for Go is Ebiten: [https://github.com/hajimehoshi/ebiten/](https://github.com/hajimehoshi/ebiten/)
So if I wanted two functions to do the same job, but on two different types of data, I could create a method and send it different receivers? Then the method could distinguish between the two with the blank `a, _ := ....‚Äô ?
This. Fantastic answer, thank you so much. Now I can read about tuples and try theme in python or Swift I suppose. 
Well seeing that those are equivalent that explains a lot actually. Thank you very much for those resources. The first was especially helpful, but I haven‚Äôt gotten to the second yet. I will look at methods more closely in Swift and Obj-C to see if it helps my understanding of how I might use them in golang.
Word. I'm on the third generation (at least) of developers working on a project that was started by a very talented developer. They left the project in good, clean shape. The people before my time tried their best, but got Shangai'd into a position they weren't ready for. A couple of months after I took over, it became clear that the only way forward was to git reset hard to a hundred commits ago and go from there. Even then the struggle to move things in a simpler and cleaner direction is real and goes on every single day.
You can have two different receiver types that implement the same methods. In fact, that's completely normal and exactly how Go's *interfaces* work. For instance, pretty much anything you can read bytes from (such as an open file, or a network socket) implements the `Reader` interface, which just means having a `Read` method defined that takes a byte slice to read into.
I think you meant to post this somewhere else, this doesn‚Äôt have anything to do with Go :p
Well technically he didn't have to risk a relapse because he could add this comment without opening the file. https://unix.stackexchange.com/a/99351
Thank you very much for your valuable feedback sir, I will try not to do it again.
Joined a company that started on Ruby on rails. They got fed up with it and halfway migrated to go. I joined a year into their migration. Now they have two bad code bases: one in RoR and one in Go. No large codebase is safe
Maybe support not only RSA but some IECESs Otherwise, IMO this is simple to use and powerful
I'd list a couple of points: - Thorough review of merge (or pull, if you want) requests. Many (esp. in the management) tend to think it's a time waster, but in my experience it provides huge pay-offs in the long run. Your team must have a policy of not allowing direct commits to whatever branch your next release will be cut from. Any change must go through a merge request with a clean "cover letter" (if you're using a turn-key solution such as GitLab, this would be a textual description of the merge request filled in in its "page") and must be reviewed by those who understand how the parts of the system this change is about to touch, work. The reviews must be unforgiving. Nothing has a right to be committed in a hurry (like in "okay, we'll fix this later" ‚Äî this won't work). Luckily, the simplicity of Go makes reviewing MRs a breeze. - Brainstorm and whiteboard before implementing a feature, if it is of the "architectural" importance (in simpler words, if you're about to add an HTTP endpoint to your RESTful service, or a few of coupled endpoints). Do not ever try to just assign someone to the task. - Have a culture of properly committing the changes. Each feature must come as a set of properly atomic Git commits‚Äîthat is, each commit must implement a single step closer to the stated goal. Make sure each commit is properly annotated, that is, its commit message states the reason for the change ("the why"), and a high-level description of how the change reaches the goal ("the how"). This appears to be a silly enough requirement but it saves your neck later when you'll be drilling down your history via `git blame` and `git log -S` / `git log -G` trying to figure out why a particular place in the code looks the way it does. It's abysmal to end up with a commit which added a hunk of code of interest, and see that commit has the message telling you "fix bug" and nothing more. ‚Ä¶and not a bit of more managerial stuff. - Have a culture of understanding the code. This, again, sounds silly, but the crux is that when a team member is assigned a task touching the parts of the code base they are not too familiar with, you must not press on that person to do _something._ Instead, make them have their time actually _understanding_ how the affected parts work, then come up with a draft solution which is then has to be discussed with the rest of the team, and only then implemented. This does waste time but prevents suboptimal solutions from being implemented. - (As a follow-up to the previous point.) Try to gradually make all the team members understand all the parts of your code base‚Äîto at least _some_ degree of familiarity. Basically, with large code bases, there is the problem of specification‚Äîwhen specific team members get experts in specific places of the code base. It's then natural to have them implement tasks touching those parts. This naturally leads to even more specification. While it saves time and leads to better implementation, it makes your team prone to the problem of people changing jobs / leaving for vacation etc. - There should be someone, or‚Äîbetter‚Äîseveral "someones" who maintain "the big picture" of the codebase in their brain. 
This depends on the architecture of the project, not the language, anyway - I‚Äôve worked on 2 years old code base with Go, and it is very easy to add new features - on the other side, I‚Äôve worked on fresh new code bases that are terrible 
Great for when you want to show research progress while documenting it, so it won't pass over your manager's head when you explain it to them
garbage in garbage out. Go is no different. 
I think any codebase can get nasty as you move forward. However once noticing this you'll notice that you should be constantly refactoring older code as the design specifications for an application a year ago could actually be significantly different than they are today. Your codebase as a whole should be moving towards a cleaner, more understandable direction all the time. Complexity over time kills that. As a result I've been spending my extra development time essentially reimplementing the In house application we have because theres so much complexity and so many innefeciences that can really be cut down on, all by simply readjusting the codebase and how its organized.
I don't think Go itself would be the reason for a code base getting messier. On the contrary, it might help keep it simpler as it often forces everyone to do things in a certain way instead of allowing everyone to go their own way and add multitude of patterns and ways of doing the same thing. People don't say it much but I personally feel Go takes Python's "There should only be one way to do it" to the next level and that helps a lot in keeping growing projects simple. That said, things can get messy if you are trying to use Go for projects it's not suitable for. For example, projects where you might need a lot of dynamic capabilities, heterogeneous collectors, very heavy FP style programming etc 
Could you provide a link to that book? A quick search of "SAM Golang book 24hr" doesn't appear to bring up one comprehensive product.
I'm looking into doing proper captions for a video course and would love to pick your brain to find out how to make it truly accessible and not just an afterthought. Any chance you'd be willing to get in touch and share some insight? jon@calhoun.io 
I think the key thing is that the captions line up with the speech, and are encoded so that it can be watched properly in any format. If you look at the way mitx does captions, its very functional. Skim a few lectures from 6.00.1x and you'll see how it can work well.
Well this is a pleasant surprise. Thanks! Glad the material has helped you out :)
Thanks, this is a useful start. &amp;#x200B; One followup questions if you don't mind - are well done captions the preferred option, or do you prefer a book if the option is available?
I recognize your attitudes as a specific developer personality type. I think every developer should take a personality test and share the results with their team to bring focus to the fact that people are different and are motivated by different things.
I don't see how this is a "Dropbox clone". It's just a web interface to different network services, without background sync, desktop client, single point authentication etc. It looks like a very useful project, but I wouldn't advertise it as Dropbox clone/replacement.
It's go, not golang :(
Best advice i can give as a Golang developer is: Follow the coding standards, and keep it simple. If your company writes alot of similar apps then consider creating packages that you're team can use, to so the mundane tasks.
Author here: a while ago I posted about the cat-o-licious game, which I wrote with my kids. The original version uses SDL and works on common desktops. Today I took the day off to learn WebAssembly from Go 1.11, and managed to port most of the game from SDL to WASM. Was relatively easy and works surprisingly well. It's lacking sound, but works in browsers: https://fiorix.github.io/cat-o-licious I have yet to add event handlers for clicks so people can play on mobile devices too. Happy with the good start. Feedback is welcome, but I have no plans to take this serious, it's just a toy game.
Messy files (if not properly split inside a package) and import cycles. Work with this in mind and you'll never have problems. Forget about import cycles and you'll have a dreadful awakening on a large project.
Migrated or ported? Because I can totally see how that could end badly if they tried porting it. You *can* rewrite OO code in Go, but that doesn't make it a good idea.
Go is probably better than Perl, C++ or PHP (hell Javascript too) as far as cleanliness is concerned but any big project can go full spaghetti after a few years. Similarly, you can use any of the "messy" languages I just mentioned and keep your codebase tidy, well-documented and compact. tl;dr the people are the mess, not the languages.
Technically it is Go, not go. =P Joking aside, I get what you mean, but given how much "golang" is used (in urls, twitter handles, web searches, etc) it is not really shocking how often it gets thrown into conversation incorrectly. If we toss in any language barriers it is pretty much inevitable that some newcomers will do it. Correcting the mistake is obviously fine, but I wouldn't get sad about it. Instead, get excited because it means we have yet another newcomer to the language :)
[removed]
Everybody's preference is different. I'm sure there are some concepts that lend themselves to a good visual representation, and for that, video is probably better. The ideal is both, and you can use whichever helps express the concepts better.
I always optimise for whoever is the primary user of the package. If 99% of people will be using the public interface and not writing implementation back ends, optimise for them.
source: [https://thenewstack.io/add-it-up-prepare-for-an-onslaught-of-go-language-serverless-functions/](https://thenewstack.io/add-it-up-prepare-for-an-onslaught-of-go-language-serverless-functions/)
General: You need the date for the stock purchase, due to stock splits. Code: Constants are untyped, but that doesn't mean you should use 1 instead of Monday for comparing values from ct.Weekday().
What personality types are you referring to? I mean, if you‚Äôre not at least whiteboarding your bigger features before someone runs off and implements them, you‚Äôre gonna end up with a lot of surprises and wasted work. Is runs-off-for-two-months-and-produces-a-mountain-of-code a specific developer personality type? Yes. Is it an effective one? Not if you‚Äôre collaborating with them on building a single system.
`i.Set(value string) error` should be `Parse(value) (i investment, err error)`
&gt; How has your experience been with large projects and on projects with multiple developers contributing to them? If I had to describe my experience, it would probably be terrible, regardless of language.
I find it very easy to keep Go codebases clean. The combination of strict package boundaries, the structural satisfaction of interfaces, and static typing, even if it's a bit on the weak side, allows me to make sweeping changes to the code base in the process of cleaning it up, and things generally work afterwards without too much hassle. ___However___... and this is a _huge_ "however"... you _must_ still put the work into it. You really ought to budget a bit of "cleanup" time. Approaching it with some good tools, like go-rename and such, helps. (I've never quite gotten the refactoring tools to work in my environment, though. Kinda wish I had "extract region as function".) This is not a vacuous post, because the largest codebase I personally manage is in Perl, and the constrast is stark. Without clean module boundaries (globals getting modified everywhere, functions popping into existence that don't literally exist in the source, etc.), without even an easy ability to know which parameters can be passed to a function ("I see this function here takes four parameters that may each be a string or a list, but is it that it is always called with either all strings or all lists, or are they freely mixed and matched in practice?"), every function that goes into the public repo basically freezes and can never be removed, and you can only add to the arguments it can take, you can never remove any, and just all kinds of other things that make it virtually impossible for me to ever go in and actually clean things up. Go has enough limits on the code that it is possible. This isn't unique to Go; most static languages that are an insane abomination to work with have this characteristic. But Go is, in my opinion, pretty far up there on the maintainability of its code. (As I've said a few times before here, don't underestimate the way interfaces can be met without the source object declaring conformance. I think that is silently a way bigger aspect of Go being nice to work with than meets the eye.)
Thanks for the great information. Is there an advantage to declaring variables as I need them? The reason I am doing it the way I am is just a personal preference. I'm very willing to change that. I'm on mobile right now but I'll take the time to respond properly to your great post when I get back behind a real keyboard. Thank you for taking the time to look at my mess.
You are missing a key fact: transactions are implicit in your design. For example, PG allows transactions across multiple tables. Mongo does not. What happens if you have to update multiple spots in the Struct chain? You need to make transactions overt. You also need to make the ability to roll back explicit. For example, if you assume updates over two or more entities, Mongo can fail halfway through. You have make it possible to rollback, ie delete the entity that successfully committed in Mongo. So now you need a Unit of Work or some such.
I like this approach! Usually working with asymmetric encryption is not that simple. Support for other encryption types would have been better.
\`dep\` drama, the best drama.
What do you mean?
You lost me at the first sentence. Designing APIs for Go and thinking of interfaces first is an anti-pattern. A great rule of thumb for Go is accept interfaces, return structs. ‚ÄìJack Lindamood SOLID principles still apply. Dave Cheney has a great blog post on it: https://dave.cheney.net/2016/08/20/solid-go-design 
I really like this project I was going to do the same thing in python
&gt;Is there an advantage to declaring variables as I need them? In Go, variables are also initialized (to zero) when declared. By delaying declaration, you might be avoiding initialization that never needs to occur; note, this is of crucial importance for some C-descended languages (like C++), and arguably less so for Go. But still worth knowing why the old C pattern of declaring at the top is not just a change of preference, but also a change of program behavior. Once you get used to it, you'll probably like it better also as a matter of style.
I think you meant to post this in /r/python, not here, don‚Äôt see what this has to do with golang 
This is great information. I was taking the complier for granted, as it did not let me declare a variable if it was not used. I'll stop declaring variables at the start from now on.
&gt;I'll stop declaring variables at the start from now on. One can arguably go overboard in the other direction as well. :) It can sometimes be used judiciously, like for variables that help document the function as a whole, perhaps playing a role in determining the returned result, etc.
Great point!
Plesse use strings.Reader or bytes.Reader instead of copying the byte skice into a bytes.Buffer just to have the Decoder read it! b, err := base64.StdEncoding.DecodeString(b64) licenseBuffer := bytes.Buffer{} licenseBuffer.Write(b) licenseDecoder := gob.NewDecoder(&amp;licenseBuffer) Should be b, err := base64.StdEncoding.DecodeString(b64) licenseDecoder := gob.NewDecoder(bytes.NewReader(b)) And you don't handle those errors! 
The cuckoo hashing data structure is actually named for the cuckoo bird's (mildly horrifying?) nesting behavior: they push out the eggs from other bird's nests to make room for their own (just like inserted elements).
Gofmt is a truly wonderful thing. No more style discussions ever again.
[https://golang.org/doc/effective\_go.html](https://golang.org/doc/effective_go.html) By maintaining a very strict style guides and boilerplates most of our code in various languages stay pretty clean. As for Go, we try to latch on to idiomatic Go principles and it has does us well. Make static analyzers part of your CI/CD pipeline. We resist hacking or cleverness, unless well documented, often the process of documenting a hack reveals a better solution.
A meta-answer to your question: although indeed a code base health is directly related to the culture and care of keeping it in such state, I think it is important to take notice on the very rich set of tools that enable entire code base refactoring with very little effort. Go tooling is top notch - and lots of them enable you to care about certain aspects in automated way (whereas in other languages it would probably be manual and error prone labor) 
Thanks. That is what the post is already following. The questions is not what package layout to follow but how to solve a specific problem that comes up when one follows this exact pattern. One difference is that the post suggests to use concrete types to define domains types instead of interfaces and use interfaces only for the "services". One can imagine the same or similar issue come up there as we most likely wouldn't want to add struct tags relevant to different implementation to the domain type. I guess the solution described to use a different type for the "model" would solve that as well and overall would probably be a better fit than when using interfaces for domain types as well.
I am not sure that I understand. I have tried the -visitor flag that does generate a &lt;grammar&gt;BaseVisitor but the implementation is incomplete. If you look at the visit method it is simply a stub that returns nil. Although, please any insight would be great.
There is always run-time cost for maintaining a project in good shape. If at some point that cost is redistributed towards new features for example, it tends to be harder to refactor later. I find that if anything, as long as there are active refactoring efforts to get rid of some engineering dead ends, that the code base noticeably improves with time. Good planning saves a lot of effort in the long run.
This is great! I've just finished the quiz game and extended it to allow for multiple answers. [Quizticle](https://gitlab.com/RichardGladman/quizticle). Next step, URL shortener. Thanks for this.
Frameworks are not needed for Golang. It has lots of builtin stuff, like template parser etc.
I wouldn't recommend any framework for Golang, the standard library is exceptionally rich and well made so a third party framework is not required. That's probably one of the biggest differences folks coming from languages like Python and Java find surprising.
I like Echo for doing HTTP backend
For batteries included, RoR-like frameworks, you can‚Äôt beat Buffalo. https://gobuffalo.io/en
What this person said. I'd add that Go gets faster "time to prod", by adding new functionalities in the standard lib every update
It seems that your comment contains 1 or more links that are hard to tap for mobile users. I will extend those so they're easier for our sausage fingers to click! [Here is link number 1](https://github.com/go-chi/chi) - Previous text "chi" ---- ^Please ^PM ^/u/eganwall ^with ^issues ^or ^feedback! ^| ^[Delete](https://reddit.com/message/compose/?to=FatFingerHelperBot&amp;subject=delete&amp;message=delete%20ID_HERE) 
I really enjoyed [gin](https://github.com/gin-gonic/gin). It's really quick and easy start and the logging package is pretty good. If I'm not wrong the middle ware can be kind of a hassle though. That's because you have to use it's type instead of something like an http.HandlerFunc
I'm doing a webserver right now only using stdlibs and I can affirm that the template parsing is easy to use and setting up routes are really easy. They even have a nice [tutorial](https://golang.org/doc/articles/wiki/)!
That‚Äôs why I liked using [go-kit](https://github.com/go-kit/kit) It‚Äôs a toolkit, not a framework. It provides some tools to add higher level microservice needs like logging and metrics. 
I would love if it had a "race" mode in which, assuming you have multiple nameservers defined, it can do either: \- immediately send the request concurrently to N of the M nameservers, use the first response that comes back (very aggressive) \- immediately send the request to one server, if the response does not arrive within e.g. 50ms send the request concurrently to the second server; use the first response that comes back (note that the interval between first and second request is not the usual DNS resolution timeout -that is typically 5s- it would be an independent interval 
There have been so many times I‚Äôve started with a framework like Echo and end up questioning the value of it, since I can do the same thing with net/http with little to no additional effort and there‚Äôs no unfamiliar framework code to read through when something doesn‚Äôt work as expected. Granted, my projects are microservices with simple APIs that don‚Äôt need the features provided by web frameworks. With larger or more complex APIs I‚Äôll use a well-tested, high performance router to simplify the configuration. For a use case where I need a self-contained full stack application, I do the same thing for the backend; make it just an API, and then use something like Packr to create a ‚Äústatic‚Äù folder to host your HTML, CSS, and JS and embed them into your binary for quick and easy distribution. Use JS to make calls into your API, and you‚Äôre free to use whatever JS framework/tools you want. In general, resist the urge abstract everything. Keep it simple. Don‚Äôt introduce dependencies or lines of code you don‚Äôt need. Spend more time writing functional code into easily consumable chunks than trying to be clever and you‚Äôll be more productive.
`net/http`
I like Gorilla Toolkit‚Äôs Mux package. It‚Äôs built on stdlib handlers but provides superior out of the box routing capabilities. Wildcards, variable path matching, specifying responses based on http methods etc. I like that it‚Äôs lightweight and doesn‚Äôt redesign the stdlib design, just adds to it 
What's wrong with sass? 
Most Gophers use a Flask-like approach. But as most of the "plumbing" is already in the standard library, that typically amounts to using a router, like Chi, and then mixing-and-matching middlewares as needed. That involves a bit more wiring things together, but on the flipside, you don't end up with layers and layers of libraries between your code and the actual HTTP/SQL stuff, which you then need to wade through when something isn't working as expected. 
Anything but iris: https://news.ycombinator.com/item?id=11976798
I'll second this. Gorilla and similar packages are not frameworks, they are helper libraries that accomplish a single task and work well with the existing standard library. This is what we look for typically.
I like it. Might use it in my current project.
It‚Äôs similar to the composition vs inheritance issue. Composition is preferred, like in this case. 
I'm a fan of Django but I've avoided most web frameworks in Go. Because the standard library is so good, I believe that we've not yet seen a framework which really captures the needs of web developers in an idiomatic way. I'd say the hardest thing currently is managing login sessions, which is why I built this: https://github.com/abraithwaite/jeff With session management out of the way I feel like I can mostly lean on the standard library for most of my needs.
Yikes. I mean, I like Go and all, but I don‚Äôt see how you win anything by using it as a proxy for CSS. 
Put it in a wrapper.
Doesn‚Äôt it help to explore the space and learn more about whether this is a good idea? It sounds like you‚Äôre already confident that this isn‚Äôt a good idea, but the project can help provide data and determine if that‚Äôs really the case.
You can do it with postgresql avg function but it depends on how many rows you plan to have in your db. It would also make sense to post database model. 
For batteries included, I think the top 2 are Buffalo and beego. But the stdlib in Go is much more powerful that the one in other languages. So most go programmers like to keep it simple and use only stdlib. Unless they need something more specific (like http routers). It's more common in Go talk about toolkits instead of frameworks because of that.
Is there an easy way to get my DB model from pgadmin? (sorry super new to postgres as whole)
https://stackoverflow.com/questions/6024108/export-a-create-script-for-a-database
Well, I can say that the shortest path between Germany and California doesn‚Äôt go through Moscow without ‚Äúexploring the space.‚Äù I can‚Äôt imagine a scenario where writing your CSS in Go makes more sense than writing it in SASS. I mean what‚Äôs the point? You still need to know CSS, the go code to generate the CSS is not as easy to read and much slower to write. This makes zero sense.. hey people are free to write what they like, but I don‚Äôt understand the itch the author is scratching here.
First use pg.Array. ``` package main import ( "fmt" "github.com/jinzhu/gorm" _ "github.com/jinzhu/gorm/dialects/postgres" "github.com/lib/pq" "reflect" ) var db *gorm.DB type Example struct { Test pq.Int64Array `gorm:"type:integer[]"` } func init() { var err error db, err = gorm.Open("postgres", "user=gorm dbname=gorm sslmode=disable") if err != nil { panic(err) } // db.LogMode(true) } func main() { db.DropTableIfExists(&amp;Example{}) db.CreateTable(&amp;Example{}) TestExample := Example{[]int64{1, 2, 3, 4}} db.Create(&amp;TestExample) var Result Example db.First(&amp;Result) if !reflect.DeepEqual(TestExample, Result) { fmt.Printf("Failure!") } } ```
Now you calculate avg in go without much of a pain.
so I switched TTS to a pq.Int64Array, and changed TTC to an integer. Now I am assuming the next step would be adding a function to my schema some how?
http://gorm.io/docs/query.html#Advanced-Query
Or you can just calculate average in go. x:= [5]float64{98, 93, 77, 82, 83} var total float64 = 0 for _, value:= range x { total += value } fmt.Println(total/float64(len(x)))
Yes i am quite surprised to see how many redditors are suggesting to use standard library.
Is not it too much bootstrapping from the scratch. I think each dev or project will have different architecture. Is there any best practices to follow.
It was this one: https://www.amazon.co.uk/Sams-Teach-Yourself-Hours-Programming/dp/0672338033 It does have its weaknesses as well, I'd maybe give it 3.5/5? Some of its explanations of programming concepts seem a little off, or poorly explained. But if you're already a programmer and just need some way to structure covering the basics of Go, I'd say it's a decent option. Although Google's own intro tutorial is also pretty decent, and free: https://tour.golang.org/welcome/1
the numbers would change in how many often and rarely be the same size. When I switched to array my data stopped going into my database for some reason
I can see a potential use case perhaps as an abstraction to some custom CSS styling for a user in the web app. Beats having to do a lot of grimey string interpolation, but that's really the only benefit I can think of for this.
https://twitter.com/joelgrus/status/1033035196428378113 I kind of agree with the guy. Notebooks are great to quickly show some PR-ready analysis or 'shiny-stuff'. They're great for messing around. But that should be it. Too many things can go wrong with these little buggers. (And I have contributed to 2 of the main Go kernels for Jupyter)
What are you trying to do here? db.Create(&amp;resource) db.Select("AVG(tts)").Update("ttc") Can you give live example of one of the rows (with numbers) and expected result? Do you want tts to be updated version of average(tts)?
I would recommend [reading through this.](https://golang.org/doc/articles/wiki/)
I would love to use Golang in place of Flask or usually when i tend to make microservices. But what if i wish to make a ecommerce + cms. Usually in python people choose additional libraries over Django Django --&gt; CMS on top of django --&gt; e-commerce on top of CMS --&gt; My work on top of that. As a base i use libraries and just do my work. So in Golang do i need to reinvent the wheel everytime?
Yes, the data are anonymized but also as it's open source / to be self hosted, data are not resell or used to create targeted advertising. I strongly believe that analytics is important for teams to understand how users interact with their products, but it should be done responsibly and not gave away freely to internet giants who do very nasty things with this data.
try something like this https://pastebin.com/x0ZBRmPE
that works perfectly but for some reason my DB isnt storing the values. I am going to try restarting it.
Thanks, I'm a jr dev so maybe I'll go with the tutorial first.
check that automigration actually updated the model.
it was not I just updated and it seems to be working! Thanks for all the help! I just need to add an update function to my handlers now. I really appreciate it!
I agree with others that this primarily depends on the developers and their practices, not the language they're using. That said, I think Go does make maintaining and refactoring large volumes of code easier (compared to what I've used in the past, primarily C++). [Upspin](https://github.com/upspin/upspin) is a good example of a large project that has been around for a while, and it's still an extremely nice codebase to look at. &gt; I have this nagging feeling at the back of my mind that this is too easy, too nice of a language and there is a cost I'm going to pay later. I wouldn't worry about it, I don't think there's anything unexpectedly bad that comes later. I've been using Go for 5 years and a lot of my Go code from 3-4 years ago is in really good shape.
But I don't see anything that's stopping companies from building an ad profile of you anyway. If you allow them to use your data in their app, then they still get hold of your data and an then build an ad profile. Also, ad profiles are built based on your actions in the apps as well, not just the content you upload. I'm also wondering how this works from a developer's viewpoint. There needs to be some kinds of entity storing the data, otherwise the apps will have to query the data from hundreds of different users pods, which will take forever and case a terrible user experience when navigating the app. Maybe I'm wrong, only time will tell. But what's the incentive for any company to use this system instead of storing the data themselves (which is where the money is)?
It's not postCSS
It's not postCSS
What are the advantages/disadvantages between this and uuid4? I don't think I understand the use cases you're targeting.
The Kleene star is the `*` operator in regular expressions.
Simple: I didn't take much time and try it but I would probably create a thread struct with one field being a slice of users who belong to that thread and then use the handler to recursively relay the messages to each of the users. \`Ps: I am getting back to you ounce I try it with more details \`
You don't need to reinvent the wheel, you just use the wheel you need, not all the car if you just need one wheel.
+1 for echo api development with it just feels fast and enjoyable. 
Echo is fantastic. I've built a few APIs using Labstack's framework and it's an extremely useful toolkit.
[removed]
I actually wrote down my favourite resources to getting started with Go http://golang.cafe/blog/my-5-favourite-online-resources-to-learn-golang-from-scratch.html
I actually wrote down my favourite resources to getting started with Go [https://golang.cafe/blog/my-5-favourite-online-resources-to-learn-golang-from-scratch.html](https://golang.cafe/blog/my-5-favourite-online-resources-to-learn-golang-from-scratch.html)
To answer your questions: 1. Buffalo would be my go to. There is also Revel. 2. This is probably where something like Gorilla Mux and Chi come in. I prefer to use Gorilla because the entire Gorilla eco system of libraries are rich and useful. Why not just use them all together as you need? They are pretty tried and true safe choices. 3. I have no idea what this means or what it's asking. As always you will get the often repeated reply saying you don't need a framework which if you read this sub a lot can get tiring to read and doesn't answer you questions (another problem entirely). And they are right, you don't, but there are caveats and context you probably want to consider. What are your requirements? What are you building? How much time do you have? Is this for an API only? Is this a full fledged web application with server side rendering etc? Is this a weekend hack / side project? I really like this talk: https://youtu.be/75NjCfLLftw
once upon a time people in the PHP world said the same thing.. you don't need a framework, PHP is the framework. But for anyone coming from a ROR or Laravel background, what's the plan? Implement you own migrations package? Implement your own ORM. For me, Buffalo shows the most promise as it's built with the same ideas as ROR and Laravel and is attempting to provide a similar workflow. It's not quite there yet.. but it's well on the way. I am certainly keeping an eye on it.
&gt; I especially like how they can return more than one type at the same time. C# public (int Id, string Name) GetIdAndName() {...
I came from a Node.js/ES6/React and 40 more frameworks stack. I think when switching to Golang something that will feel really nice is compile time error checks, the overall feel of 'its okay to write your own code, and not just use NPM instantly', the callback hell that promises create which is hard to do step-by-step debugging in is not there, testing feels like a first class concept in Go, good auto-complete that won't just suggest the "copy" or "equal" function on a object(lol). Vim/Neovim has really good support for Golang. Some of the things that i will say though, when i did node.js i had a single controller file which basically just extracted the model i was interested in from the URL and looked it up in a DB dictionary, calling GetAll, GetOne and didn't care what the underlying object was, in Golang you have to type that thing out for every model unless you wan't to return a interface{} or auto-generate code. I think in general the ORM experience you get in Node.js with something like Sequelize is non-existent in Golang, ORMs feel kind of dirty in Golang and i think most of them don't have relationships as a first class concept. This means you have to type a lot, if you get past that hurdle though, you will start to realize some of the more subtle things that could help you type less like "Generating code is actually okay, why not just generate all interfaces automatically from your structs" or "Oh these db calls takes interface{}... as argument, so instead of doing db.Insert(q, person.Name, person.Number....) for 30 fields i could maybe just import fatih/structs and do db.Insert(q, structs.Values(person)", "Golang doesn't have inheritance, but maybe embedded structs gives me all i want from inheritance w/o the inheritance hell", "initializing 30 controllers/models/repositories takes a long time to type out, especially if you wan't to Mock up 29 of those for unit tests, maybe i could just use go-cloud/wire to auto-generate all of this initializing code and then suddenly we're up and running much faster than some other languages" . Okay, i'll stop now, but i do think it is a nice language overall, and has a lot of underrated features. 
Ya, sure the web part and routing is pretty easy to use, but a lot of the "batteries included" frameworks also create models, have a CLI tool, have a default structure for where things should be. Its not just routing. Plus I despise Golangs template engine.
as the project is new, you could think about migrating to go-modules
This is the first spotify integration I've seen on Lambda, super neat! Definitely will take parts of this to create a "backup discover weekly", because I always hit myself on the head when I play a single song on repeat on Discover Weekly, just to have it cycled without saving it :'( &amp;#x200B; One minor suggestion would be look into Secrets Manager instead of s3 / env vars for both your token file and spotify secret. It's a bit excessive for someone stealing your Spotify key off a fun project, but I always get antsy when I see env vars or s3 being used to store secrets. We do encrypt those fellas at rest, but joe shmoe can see your lambda configuration if they have get-function which most have read only console access. &amp;#x200B; Instead, imagine them seeing the env-var for the \~key\~ to secrets manager! Most read only systems don't have GetSecretValue of secrets manager, except your lambda function :D \[disclaimer: work on Lambda, my own personal opinions\]
Absolutely a great start, indeed. Also very good: Go in Action.
I want to second this. This should be the first book that you read cover to cover. It is very well written and covers a lot of ground.
As I understand it from the homepage and function signature, it will get integer IDs that are unique for DB server, so it's safe to use across multiple services, whereas UUID4 gets a, well, UUID4. I assume it's intended for cases where you need/want a unique integer, or want to "reserve" an ID without inserting a row.
Looks good - nice work! &amp;#x200B;
Is it still up to date? It's almost 3 years old now.
hey, it's from golang developer
Do you know if anything has changed though? Like if the concepts/code in that book are not best practice anymore.
Someone live coding a chat service: https://www.youtube.com/watch?v=cNxfgXrHeAg
&gt; So in Golang do i need to reinvent the wheel everytime? To a certain extent, yes. But Gophers tend to come at the problem from the other direction. Rather than reinventing the wheel, you're leaving out all the crap your app doesn't need. Great big frameworks like Django are great‚Äîand very productive‚Äîas long as you do things the way the framework wants them to be done. You have to build your app around the framework, and if you violate its expectations, the framework can end up fighting you instead of helping you. 
I recommend you Iris, from the author Kataras 
Thanks for the thoughtful reply! I appreciate the suggestions on Secrets Manager, that is definitely a great solution. I've used that for larger projects and totally agree that is the way to go when you want to lock things down. For this tutorial, I decided to use S3 just to keep the example simple, but perhaps I'll swap over.
I started learning Go with Revel, coming from a Laravel background, and found it to be a pretty smooth transition. Recently been building backend APIs with Chi, which I've been enjoying a lot.
Everyone seems to say this about go. I haven‚Äôt built any web apps in go so I‚Äôm not informed. What do you do for things like dependency injection or routing? Just reimplement every time? I use spring at work and it seems to just have everything (almost to the point of being ridiculous). I use go at home fairly often but not for web based project so I haven‚Äôt even really ventured out into that stuff.
I‚Äôve been using Twirp which was built by Twitch. It‚Äôs pretty great but it‚Äôs really designed for RPC based web services. 
I personally stick with `net/http` + [chi](https://github.com/go-chi/chi) + helper functions(If I feel like I'm repeating too much). I'd say start with `net/http` then explore other options. 
No source code - just a license and a readme. At least there's no obvious bugs...
IFTTT has a discover weekly archiver
It doesn‚Äôt know about new developments like modules, but it will not teach you bad practices.
Looks interesting, but why not just use .ssh/config? Seems like that should be the source of truth and have a small cli for interacting with that config. 
You should just use `.ssh/config`, which has all of this built in with the exception of parallel connections. For parallel batch ops, I use pssh, but there are plenty of other tools (like Tentacle) that do the same thing.
Hi cafxx1985, Thank you for your feedback. &gt;\- immediately send the request concurrently to N of the M nameservers, use the first response that comes back (very aggressive) &gt; &gt;\- immediately send the request to one server, if the response does not arrive within e.g. 50ms send the request concurrently to the second server; use the first response that comes back (note that the interval between first and second request is not the usual DNS resolution timeout -that is typically 5s- it would be an independent interval That's a good idea, but given two or more name servers, I think it will cost network traffic, especially if parent name servers is not using UDP connection. When resolving domain using TCP, DNS use full connection round-trip (open, send, recv, close), that is high round trip per name server; plus each connection may require one routine to manage it. I prefer if rescached to be minimal (low resource) as possible. &gt;Another useful feature would be background revalidation: when the TTL of a cached record is about to expire, refresh it in background so that it's always in the local cache. I think it's defeat the purpose of caching. rescached does not know which record is frequently active. For example, assume that if we have record X and Y, with most frequent accessed record is Y (e.g. reddit.com); and X is only accessed on time; if X TTL is about expire, we will refresh record X that is never queried again in the future. Previous design, rescached v1, count number of accessed record and keep only the most frequent records at the top of cache list. After refactoring to v2, I think about it again, and use the last accessed time instead of counting, for simplicity.
I would like to learn more about DNS.
For an enum I'd use a custom Go type (rather than just a string or int), and define a UnmarshalJSON method on that type which does a plain unmarshal into a string or int, and the checks the validity of the value. Your custom type needs to satisfy the json.Unmarshaler interface.
hey thanks! i don't fully understand the omitempty bit, but the pointer trick definitely worked. Is this common practice when working with json apis?
Yes.
&gt; omitempty omit empty If part of the struct has the default value, it's omitted from the JSON object. Unfortunately, 0 is the default value for integers, so you've still got the same problem. But if there's a *pointer* in the struct instead of an integer (or whatever), then the default value of a pointer is nil. So if the pointer is nil, it leaves it out of the JSON. If it points to a value, it's included even if it happens to be 0. 
For more complex examples you can refer to Dave Cheney's blog [Functional options for friendly APIs](https://dave.cheney.net/2014/10/17/functional-options-for-friendly-apis). I find it really good because it goes through all the options you can use to set defaults via a function call.
I'd like to add an idea that may be outside the orig question slightly... learning about the primitives of an OS (gnu linux/unix... is my preference) that are used to accomplish the goals of some of the lang's constructs. I am learning about these now so cannot claim expertise but can say that if its internals you want, then its "how does this work" that you want, so maybe look at some things associated with this (as opposed to books directly on golang). For example, I think there is a book called "Modern Operating Systems" by Tannenbaum (? someone help me out) that I have started looking at and theres "The Linux Programming Interface" that may offer insight as well. I'd also add that I have found a doc or two written by Rob Pike about the internals (or at least proposals) that are out there. I dont know how I found them but will look for the couple I have if you message me (i have no idea where they are now or if i even still have them) of course questions on standard lib stuff like "net" can be answered elsewhere as well (TCP Illustrated) but i dont think your asking about that...
I also feel like fighting with them, but its one in hundred times. And there is always one obvious way to do it. But when i am working on a project where team member come and go, these convention also give common paradigm to follow. Whereas when i come to Flask or making mivroservices, i feel it is lacking. Thats where i started to see Golang right now.
How mature is buffalo compared to ROR?
The standard library. Maybe a lightweight mixing lib like gorilla. You don‚Äôt need a framework. Go itself is the framework. 
Store temp in Kelvin, and you know 0 is effectively the 'nil' value. Presumably this is true with humidity as well; perhaps offset them accordingly. If not possible for every value, maybe use strings instead of numbers.
We use Go headless CMS backend with Polymer Lit-Element front end. LitELement is pretty amazing together with Go, and lightning fast.
Thirded. I come back to this book for reference several times a week working on go projects. The section on goroutines and channels really helped me make good sense of those concepts which I struggled with coming from the tutorials. The one thing off the top of my head that differs today from the book is how it suggests a project structure should look. Instead, look here: https://github.com/golang-standards/project-layout
[removed]
My thought as well, why do not using something like gRPC 
&gt; Unlike Gorilla, I want each part to be able to work together or individually in a way that doesn't pressure developers to use the entire framework. Err, thats exactly how gorilla works. So I call bullshit on this. You can use gorilla sessions without using gorilla mux. You can use schema without using websockets, obviously.
Thanks 
And then at some point, like the programmer you are, you move the boiler plate into a package, and before you know it, you end up with your own "framework" just not as l thought out or hardend or as battle tested as the alternatives. Then in each project where you need features not currently available in your "framework" you spend unplanned time implementing and testing the feature before you continue with the project itself. And all this doesnt take bugs and technical debt into consideration. I've been down this route, and while it was great for learning unless the project requires it, i reach for echo or chi depending on what needs to be done.
I‚Äôm going to try this out. Thanks 
Using strings is a good idea!
I'll be fair and honest when I say I never fell into the dependency injection bandwagon, so I don't fully understand it but I have a gut feeling that the intent of dependency injection can be satisfied using the `interface` type and taking in interfaces to your functions. Regarding routing, I don't believe routing has to be that hard to need some other lib to do it for you. Either by defining your end-points and their handling functions directly, or perhaps using a generic handler to parse URL path and delegate/call an appropriate function to handle it. I'd genuinely love to hear an argument/example against these points if I'm wrong!
While it's preferred to have a struct for your JSON documents, you don't have to. You can still parse it manually: var jsonVal map[string]interface{} ... humidity, ok := jsonVal["humidity"].(float64) if ok { // update humidity here }
A scalable stream processing server app, like Kafka. It was used in production for a startup that no longer in business, ingesting about 1MB of log data per minute, with less than 1% cpu usage on t2.micro instances. Not bad for a homebrew project.
By the definition of REST, you should do (1). Even more so if you make a `PUT` request, since it should replace what's the current state of the resource with this new one, if it exists already. And this is what I prefer to do. That way the backend has little work to do figuring out what attributes changed, what didn't, and how to build a database query for it. Things get slightly complicated when you make a `PATCH` request, which allows you to update unit attributes. But prefer `PUT` to `PATCH`, and send the full representation of the resource as known to the client.
Hey, thanks for the response. I might have used the term *microservices* wrong here, these are not short lived services running in containers, but more like regular service daemons, where each handles a different part of the whole platform logic. As for 1., yeah, you get it mostly right. The `backend` thing is a hugePHP application written over 2 years by a different team, that handles basically all business logic for the whole platform. There are methods for managing subscribers, content, end devices, etc., methods for setting/getting config for various parts of the platform, etc. I have been tasked with writing a handful of small Go services that need to get configuration from one part of the API, so unfortunately I'm rather limited on my side. As for the rest, up until now I have been writing the services like this: package backend type Client struct { GetDeviceConfig(id string) (SomeConfig, err) GetProtocolList() ([]Protocols, err) ... another 10 methods I need in the various services } ---- package serviceA type BackendService interface { GetDeviceConfig(id string) (backend.SomeConfig, err) GetProtocolList() ([]backend.Protocols, err) } type Router struct { backend BackendService ... } ---- package serviceB type BackendService interface { GetProtocolList() ([]backend.Protocols, err) GetEvents(from, to int64) ([]backend.Event, err) } type Collector struct { backend BackendService }
Hey, thanks for the reply. I'm sorry, but I probably used the term *microservices* here wrong - the stuff I'm writing is not short-lived and running in containers, they're more like regular service daemons each doign some specific tasks and usually serving some small HTTP API. As for 1., yeah, you get it mostly right. The `backend` thing is a huge monolithic application that handles business logic for the whole platform - there's stuff for managing subscribers, end devices, platform config, everything. I have been tasked with writing a couple of small Go services that need to plug in to this backend, and as the backend API is written to be pretty generic, the output I'm getting needs to be usually converted to something I can work with directly. The methods I need mostly pull general configuration, or end device info. Unfortunately there is not much space for a change here, so I have to work with what I got. Here are some examples of the stuff I've been writing so far. Example of repo structure I'm working with: repo/ pkg/ backend/ config/ logging/ services/ serviceA/ cmd serviceA/ pkg serviceAstuff/ serviceB/ Example of the `backend.Client` methods and how they are used in multiple services: package backend type Client struct { GetDeviceConfig(id string) (SomeConfig, erorr) GetProtocolList() ([]Protocols, error) GetLongLivedConfig() (Config, error) GetEvents(from, to int64) ([]Event, error) ... another 10 methods I need in the various services } ---- package serviceA type BackendService interface { GetDeviceConfig(id string) (backend.SomeConfig, err) GetProtocolList() ([]backend.Protocols, err) } type Router struct { backend BackendService ... } ---- package serviceB type BackendService interface { GetProtocolList() ([]backend.Protocols, err) GetEvents(from, to int64) ([]backend.Event, err) } type Collector struct { backend BackendService } As I was writing this all out, I found out that I can divide the backend methods into those I need for every request to my service, and for those that pull long-lived config from the backend service, so I'll probably go with this: package serviceA type DeviceService interface { GetConfig(id string) (ParsedConfig, error) } type BackendService struct { client backend.Client } func (bs *BackendService) GetConfig(id string) (ParsedConfig, error) { resp, _ := bs.client.GetDeviceConfig(id) // parse resp to what I need in serviceA and return } type Router struct { device DeviceService } func (r *Router) setLongLivedConfig() {} func (r *Router) setMediumLivedConfig() {} ---- package main import serviceA import backend client := &amp;backend.Client{} router := &amp;serviceA.Router{ device: serviceA.BackendService{client} } t := time.NewTicker(time.Hour) for { select { case &lt;- t.C: newConfig := client.GetLongLivedConfig() //parse config router.setLongLivedConfig(parsedConfig) } } This seems like a good compromise to me.
Assuming that in JSON the enum is a string, I'd prefer [encoding.TextMarshaler](https://golang.org/pkg/encoding/#TextMarshaler) and [encoding.TextUnmarshaler](https://golang.org/pkg/encoding/#TextUnmarshaler) unless you're generating something that's actually JSON-specific. That way you can use the same code for other text-based marshaling forms. It also saves you from having to escape characters that have special meaning in JSON, though that shouldn't matter much in this case. If you want to use something more specialized for a specific type of marshaling you can always still implement their specific interfaces as well to do that, but the encoding.Text\* interfaces are pretty nice for baseline functionality.
That works, and would be The Solution, if we were simply talking about optional fields in records (eg. a weather station isn't equipped to measure wind velocity, so it only sends temperature and humidity, but no wind.) However, OP was talking about PARTIAL UPDATES. Partial effing updates are the devil's own work, and need proper old fashioned, god-fearing engineering to tame. :D Seriously though, this kind of stuff can really get out of hand real quick. Add concurrency, and you're up to your chin in shit water. Partial updating of records is not an API feature, it's a whole stack feature. Your data access layer needs to implement partial record updates to properly offer this functionality. On the API side, if we're speaking one notch more complex than hello world,, I'd consider using HTTP PATCH methods, with JSON Patch payloads, and limit HTTP PUT to whole record overwrites.
Strings *may* be a good idea in *some* JSON applications... Though I'd primarily go with them only where there is a strong need to reliably carry over unsigned, long integer data (due to the Javascript number type and its limitations).
The idea is to support more than just ssh and telnet, in a future release i'll add support for web shells ( c99, r57, weevely, etc ) and for custom javascript modules (in order to have "shells" with your own exploit)
The idea is to support more than just ssh and telnet, in a future release i'll add support for web shells ( c99, r57, weevely, etc ) and for custom javascript modules (in order to have "shells" with your own exploit)
You could also implement a field mask which allows you to select the fields which you would like to update
Gin is awesome! 
FWIW, a Microservice could be anything that is small and acts as a service. :) Even a daemon. Hmm, so you need to use the backend monolith code in small Go plugins? Should they be literal plugins, or just like small components that implement some sort of API of your backend? I'm a bit confused about your example. The `Client` is an `interface` not? Not a `struct`. Is there a reason for the service to be an interface though? Will something else also implement it in that service? If not, it's probably more sane to have a general service interface in the backend then implement it as multiple service structs. Also, what's router? What does it route? Is the service also a router of some kind? So, you want a service to implement something in the backend plus the availability of the backend client in the service. Sorry man, there are simply too many unknowns here. :/ 
Yep I don't like Functional options either, but the blog post is a great reference for other options.
I wouldn't call the standard library exceptionally rich regarding web dev. I mean, it's lacking most of the things you expect to find in a batteries-including web framework: internationalisation, user management, database mapping, form validation, etc. Sure, microframework users might have their needs fulfilled (although routing is pretty basic in the stdlib), but saying a RoR or a django user "you'll find everything you need in the std lib" is a bit excessive. Go is more backend-oriented than frontend-oriented ("from infrastructure management to webservers", as OP noted).
For routing, I use `httprouter`. The stdlib version of routing is very limited IMO, but httprouter always met my needs.
because that would require lots of changes in the C# code base, no?
Can you provide a go-playground example of this solution? I'm interested to see how this solution was implemented.
Can you provide a go-playground example of this solution? I'm interested to see how this solution was implemented.
Omitempty just doesn't include the field if it's nil.
Note that the runtime already maintains an internal pool of goroutines. In my experience, using a simple semaphore to bound the max no. of goroutines is good enough. Go is not C++. So you don't need a threadpool equivalent.
I find that my code remains understandable even after not looking at it for a long time because Go is so simple with few keywords. Since I'm used to C# where organization of projects is very opinionated due to all the templates and frameworks provided straight from Microsoft, I thought I would spiral a bit out of control with a large Go project, but my organization has become better as I gain experience because the compiler is powerful enough to audit my refactoring for breakages. The only place I feel like I pay a price for Go is in the strength of the tooling. Some of it, such as godoc, is uniquely powerful, but I jump back and forth between what I consider the two best options--Goland and VS Code--because until the in-progress language server and delve get a bit more work put into them, it isn't quite perfect. Almost there... üòä
If there's a library or something already available with struct definitions, then I'd say unmarshal using that. If not, and you need to define your own structs, then personally I'd use [json-to-go](https://mholt.github.io/json-to-go/) as the starting point and customise the struct afterwards. For fields that should be enums, the approach I prefer is to use a custom type with it's own unmarshal/marshal methods. This has been pretty painless for me using the [github.com/campoy/jsonenums](https://github.com/campoy/jsonenums) package, which generates those methods for you. For additional validation, there are various libraries out there that read annotations on the struct fields that define what the validation should be (eg. "not nil", "min length", etc). I've used [github.com/zencoder/gokay](https://github.com/zencoder/gokay) for this, but there are plenty of alternatives available so you might want to shop-around looking for an interface or provided validations that better match your use-case.
tour.golang.org covers all the keywords and is a great learning resource. The spec and standard library are also far more readable than you might expect due to the simplicity of Go syntax.
I‚Äôll set time aside to go through that. Thank you for the suggestion.
I'm not sure I claimed I invented anything here :). Correct me if I'm wrong, but wrapping 3-4 C# class libraries behind an RPC service would only affect the "communication" part of the solution right? In any case, I'll certainly investigate more on gRPC.
As an aside, is there a way to "overload" unmarshaling a json field that can be either a string or an int? That is, { { .. 'id' : '1' .. }, ... } { { .. 'id' : 1 .. }, ... }
You didn't claim anything. What I meant was that this concept exists already. Isn't the communication in this case the base of the article? You basically want to call method A in C# from method B in Go. Also, I didn't say gRPC, I said RPC. There are a lot of ways to do RPC, gRPC is just one of them.
"Stringly typing" data is almost never a good idea. Stick to using the correct type for things
Bingo!
This is a great blog series. Good job!
oh, I should mention that I think of https://gobyexample.com/ as the next step once you've gone through tour. I would look for examples there while coding. :)
This is interesting. How would that go? 
&gt;Stick to using the correct type for things Which in this case is an Option, which is also kludgey in Go.
So in your example, you would a thurd field called 'fieldmask' (or whatever) and its value would he the fields in the json payload which you are updating. So in tour example, you would have a third value `'fieldmask':['humidity']` and it would only update that. Normally with this kind of thing, you would update everything of no fieldmask is included 
Another possible solution would be to use mmap: func printAllMatches(r *regexp.Regexp, f *os.File) { stat, err := f.Stat() if err != nil { log.Fatal(err) } d, err := syscall.Mmap(int(f.Fd()), 0, int(stat.Size()), syscall.PROT_READ, syscall.MAP_SHARED) if err != nil { log.Fatal(err) } defer syscall.Munmap(d) i := 0 for { loc := r.FindIndex(d[i:]) if loc == nil { break } fmt.Printf("%q\n", d[i+loc[0]:i+loc[1]]) i += loc[1] } }
Oh my God, this is Hell.
gogoroutines
Is this a semaphore? https://github.com/ihsw/sotah-server/blob/master/app/util/util.go#L16 With this being an example usage: https://github.com/ihsw/sotah-server/blob/master/app/items.go#L28
Incorrect. Gorilla Toolkit `sessions` depends on their own `context` package, which uses a map keyed by pointer to request. Usage of canonical context (since Go 1.7) makes a shallow copy of request (essentially reallocating request) resulting in dysfunctional Gorilla contexts (orphaned request pointers). If you care for correctness of your code do not use Gorilla sessions. 
I like this answer in theory, and probably what I am about to say is negligible in most cases, but suppose the representation is large, to patch certain fields fields could save bandwidth and help performance. Obviously not for a two field example like the one I gave but still. 
This is a strong contender to using pointers. I always fear that type assertions might cause a drop in performance ? But I like this a lot. Have you had better success using this rather than pointers? 
Not exactly, you are just spawning a fixed no. of goroutines and waiting for all of them to stop. A counting semaphore will let you run only a fixed no. of goroutines. It is like a job queue with a fixed no. of consumers. Something like this - sema := make(chan struct{}, 10) for _, item := range items { // acquire token sema &lt;- struct{}{} go func(item Item) { // do job // release semaphone &lt;-sema }(item) } 
Thanks!
Ohh this is very interesting, I hadn't considered using channels in this manner.
Thanks for sharing! A few possible API improvements: * Use `...string` and `...interface{}` instead of slices. This makes manual passing of multiple values much cleaner and passing of a slice only slightly longer (but no less efficient) * Don't name things with Get prefixes in Go. Next might be a better prefix for these. * Instead of or in addition to the type safe record accessors, reflection based Scan functions are another idiomatic pattern that is often employed (see Example 1 below) * Instead of returning error constants, either simply return `fmt.Errorf` messages with context or make error types. Error constants are primarily useful as sentinels like `io.EOF` that don't need any context about how they occurred. Example 1: var section, counter int if err := rec.Scan(&amp;section, &amp;counter); err != { ... } Happy coding!
Thanks!
&gt; Incorrect. Gorilla Toolkit sessions depends on their own context package, which uses a map keyed by pointer to request. Correct, you don't have to use gorilla mux to use gorilla sessions. &gt; If you care for correctness of your code do not use Gorilla sessions. I'm not using gorilla sessions, I coded my own session handler, it's not complicated at all. &gt; resulting in dysfunctional Gorilla contexts (orphaned request pointers). Whoever created gorilla session isn't stupid, there is a handler you need to integrate to your middleware stack that will take care of the book keeping. 
I think it leans on the idea that explicit is better than implicit. From a client perspective, its very clear what it does. From a code-maintainer perspective, you don't need to worry anout the nounces of the language. 
No comparison, really. Rails has been around longer than even the Go language, and is up to v5. Buffalo is technically not at 1.0 yet, so if that means anything to you, it could matter. That said, buffalo is pretty robust, and is mainly just a collection of other popular libraries put together in a friendly package. Check out the documentation. https://gobuffalo.io 
Another option to `fmt.Errorf` and stiff error types is wrapping errors. https://godoc.org/github.com/pkg/errors It provide stack trace functionality, which can be very helpful.
An `Option&lt;T&gt;` or the like would be the correct type in _some_ languages. Since this is Go, the correct choice in this case would be e.g. `*float64`
Enjoy. This is a common pattern used in a lot of places throughout the standard library. For eg. when you build a Go project, it concurrently compiles multiple files using this exact approach.
Hi, some tips for improvement: - Removing the 'get' prefix from function names. Gophers tend to omit this in favour of short names. - Create the context local to avoid a global. - Omit default values in struct literals. - Don't send pointer values over channels. This leads to race conditions and in this case a value type would do as well. - The passing of a waitgroup does not seem very idiomatic as you wait on it while doing no work. You could read from the channel in a for loop that counts to two, but there you have to do some implicit book keeping which might be confusing for other readers.
One thing you could do is decode the json payload into an already existing struct containing the original data. `type Weather struct {` `Humidity float64 \`json:"humidity"\`` `Temp float64 \`json:"temp"\`` `}` &amp;#x200B; `w := Weather{Humidity: 89.7, Temp: 32.5}` `payload := []byte(\`{"humidity": 88.6}\`)` &amp;#x200B; `json.Unmarshal(payload, &amp;w)` &amp;#x200B; `// w = Weather{Humidity: 88.6, Temp: 32.5}`
It's certainly cleaner than my approach while achieving the same result.
Looks good! Very readable, good commenting, and there's even unit tests. I can't speak to whether its functionally correct as I'm unfamiliar with the protocol. &amp;#x200B; The way you handle type switching is very clever, though I would probably use an interface instead. If you don't mind me shamelessly promoting my own work, this post might be useful to you: [http://www.powerslacker.cc/interfaces-are-useless/](http://www.powerslacker.cc/interfaces-are-useless/). You'll probably be most interested in the section titled 'dynamic type handling'. &amp;#x200B; I also noticed you have a few *magic numbers* in your code, such as on line 422 of binrpc.go: `// the totalLength cannot be larger than 4 bytes // because we have 2 bits to write its "length-1" // so "4" is the largest length that we can write if sizeOfLength &gt; 4 { return nil, ErrLengthTooBig }` Rather than commenting this conditional, you may want to create a constant that refers to the max length instead of using '4' inline. This makes the code more self-documenting and easier to read. &amp;#x200B;
There are two other solutions you can consider: 1. Let compression handle it. This lets you code naturally with the best datastacture to work with at a cost of compute time. If you care about network usage, you should compress anyways. 2. Send a list of key value paires. You only send and only process the changes you need. 
Adding on to that, you can also - avoid the global client variable since you set it up and use it exclusively in `GetInfo()` - inline the call that sets up tokenService into the call for tokenClient and then inline that into `github.NewClient()` (this makes for cleaner code IMO since you avoid single-use variables without really lowering readability) - declare your own client type that wraps `github.Client`, set up one instance in `main()`, then make `GetInfo()` a method on that client - avoid the `data` struct type when really you should have two channels, one for `github.Repository`s (for workers fetching repository information) and one for `map[string]int` (for workers fetching language information) ^1 - check out and use https://godoc.org/golang.org/x/sync/errgroup for your worker goroutines (I'd probably use one group per type of worker) - have your fetching functions return the result and error like you would for a non-parallel program, then wrap those calls with waitgroup and channel logic only where you need them (makes for nicer testing of you functions and keeps the concurrency stuff mostly in one place) - avoid closing channels in the receiving function: https://golang.org/pkg/builtin/#close (one reason is that writing to a closed channel panics, but reading does not) - adopt a structure suitable for running multiple workers and collecting the results through a single channel, i.e. a funnel that merges the results into one channel you can range over (read https://blog.golang.org/pipelines) Don't worry if this sounds like quite a lot, do one thing at a time and make sure the program still runs. [1] maybe introduce an alias type `languageInfo` or something like that for that `map[string]int`
For routing I use [Chi](https://github.com/go-chi/chi), as it's compatible with stdlib but provides easier argument parsing. For dependency injection I [just do it](https://appliedgo.net/di/). You don't need a library.
Thanks a lot for your input!
That can be quite useful. It does suffer from one problem though: to update data you need to fetch the original state first. Which makes unnecessary calls to the database, and might introduce race conditions. But if you have a representation in memory, then this is the simplest option. I hadn't even considered it. Thanks!!! 
Great! Now make it handle rotation ;)
I don't know about gRPC, it feels like having the overhead of being text-based and over HTTP2 would be a bit dumb even if not done over a network.
No. Almost everything I develop is bottom up with at most a sketch top-down to make sure that it makes general sense (i.e., no data magically teleporting across the network without having been thought about). I've never participated in a top-down process that was worth much because the amount of stuff you failed to consider tends to dwarf the stuff you actually consider by several factors of magnitude, and if you actually take the time to sit down and sift through it all down to the level you can code to it, you might as well just _actually_ code it up and get real feedback instead of imagining what feedback you might have gotten. Because even after doing this stuff for 20 years, I'm not good enough for my imagination to catch anywhere near all the things I catch while actually coding things.
Never! Haha, OK, I'll add it to the to-do list.
Still doesn't work
Are you strictly looking for books? [https://gophercises.com/](https://gophercises.com/) is intended to teach basically what you are describing, but is a video series. It is free, so you are welcome to give it a shot without any commitment. *Disclaimer: I made the course, and it is not captioned if you have accessibility concerns. Someday I need to get it captioned. I promise that is on my todo list, but that list just keeps growing :(* &amp;#x200B;
This sounds like a pretty good idea, now that I'm coming back to it. Maybe I'll try implementing this as a "v2.0" of sorts. I now feel like it's not that big of a deal to have to specify states as objects outside of functions, as most times States will refer to other pieces of data that are common to the State. I'll have to re-engineer this!
Both are fine. Message me on twitter and I will give you free access to the GREATER COMMONS course https://twitter.com/Todd_McLeod
I think, it is not idiomatic. SomeDataSet() - that's what I would use. But this is just me...
Congrats! Now for anther challenge, adding free CI testing! https://docs.travis-ci.com/user/languages/go/ https://circleci.com/docs/2.0/language-go/
https://golang.org/doc/effective_go.html?#Getters "it's neither idiomatic nor necessary to put Get into the getter's name". Effective Go would recommend you just call it 'SomeDataSet'. Works better in practice with a real name like 'Customers' or something like that.
Works for me as well.
Oh I see. I am sorry if my project disappointed you. Yes, there is no support for DNSSEC yet.
Glad to hear that, please feel free to contact me when you have any questions. At the same time, welcome to help me improve this little lib.
I am a newbie and like more of a hands on approach and like solving problems in exercism (go track). It was super excited when I got feedback from mentors but quickly found out that there are a lot more students than mentors and so switched to independent mode.
AFAIR [Dave Cheney](https://dave.cheney.net/) has some benchmarks and comparisons on his site.
[removed]
Java has `Optional&lt;T&gt;` maybe golang could benefit from something similar
It looks (*Circle).IsColliding is implemented too simple to be correct for all cases.
&gt; Gogs &amp; gitea have some really nice code. Which you've expanded to mean &gt; Gogs and gittea are perfect codebases without a hint of problems faced elsewhere Why are you wasting time being pseudo-pedantic? If those issues are due to shitty code, go fix them with your excellent code. Like WTF
It sounds like you might actually be trying to unmarshal something else than the JSON you posted into app.latency. This triggers the error you get: https://play.golang.org/p/V4kKqtyAsJ8
I would say the easiest solution has [https://github.com/jinzhu/gorm](https://github.com/jinzhu/gorm) . Just build your model and then migrate it. [http://doc.gorm.io/database.html#migration](http://doc.gorm.io/database.html#migration) Highly recommend it
I see allot of people say to use standard libraries. I would recommend `go-gin` if you want to write less code. Good and really easy to use framework.
Could you explain why sending pointers causes race conditions? I agree with your other points, but this one confused me, and I'm hoping to learn something new today!
yes! I thought I would wait for the 1.0.0 release, because 0.X will have breaking changes along the way.
You could modify the data being pointed to in a goroutine in a completely different part of the program. Who would get to read and write that data first?
TL;DR: * https://golang.org/pkg/crypto/x509/#IsEncryptedPEMBlock * https://golang.org/pkg/crypto/x509/#DecryptPEMBlock
I'm actually running them all right now, from 1.2.2 to 1.11 . I'll post the raw benchmark outputs to a github repo and reply to this post when they're done. You can use benchcmp (\`go get golang.org/x/tools/cmd/benchcmp \`) and benchviz (\`go get github.com/ajstarks/svgo/benchviz \`) to compare them. &amp;#x200B; It might be a day or two before they'e all complete. They're running on a dedicated GCE instance, but they take a while.
Huh I'd expect something like this to be natively implemented in Go's compiler 
But your article says: "Here comes the base64 cannon. Another encoding scheme on top of an encoding scheme\[...\]", then Base64 is mentioned in "PEM is the fancy name for this base64 encoding", which suggest that PEM is a "fancy name" for Base64. DER encoded with Base64 is not equal to the same certificate in PEM, because it has no block delimiters. You are right. I should not use the word "encryption" for Base64. Sorry for that.
TSX isn't widespread enough yet to really replace regular mutexes, thanks to Intel insisting on making people pay a premium for it.
I'm not very familiar with Intel practices with TSX (and their practices in general), so I guess that 'paying Intel a premium' is referring to their (expensive) c compiler? If the Go runtime was able at runtime to switch and pick the best mutex implementation available, imo that would be a very great way to make it widespread 
Does golang are famous in india? 
Do you have a git repo with your doom clone? I'd love to see it! 
Dt in my opinion slow down the whole process. I just throw myself at the code and let it grow basically.. If i know the project is bigger, I create a rough model 9n paper and work along those lines.. If I would work with decision tables I would have to redo both times by times bc of implementation difficulties or edge cases. Or different implementations all together. If I really want a scaffold I write tests first and then start implementing the body. (yes I'm a test with or after implementing person)
Thank you for your feedback! &gt;Use `...string` and `...interface{}` Done! It is indeed much simpler. Now I just have one `WritePacket` method which works with any type, slice or not. &gt;Don't name things with Get prefixes in Go Right. I have renamed the method `String()`, `Int()` and `Map()` which seems more of a Golang way. &gt;Instead of or in addition to the type safe record accessors, reflection based Scan functions are another idiomatic pattern that is often employed I have added a `Scan()` function. Useful indeed. &gt;Instead of returning error constants, either simply return `fmt.Errorf` messages with context or make error types. Ok! I just kept one private error constant used internally, and I use both `fmt.Errorf` and `errors.Wrap` (as suggested in another comment) where it makes sense.
Thank you, I am now using \`errors.Wrap\` and \`errors.Wrapf\` where it makes sense.
This looks very similar to [JSON web tokens](https://jwt.io/). Why not use those?
No, TSX is a hardware feature that's only supported by a handful of expensive CPUs, they don't even ship it with all Xeons. And on half of those, it's bugged and Intel had to disable it‚Ä¶ And AMD has yet to release a CPU supporting it. &gt; Anyway, if the Go runtime was able at runtime to switch and pick the best mutex implementation available, imo that would be a very great way to make it widespread It'd help in contention heavy workloads, yes (IIRC PostgreSQL saw a 10% speedup from enabling TSX?), but it's a rather low priority given the awkward hardware support situation.
and done! https://circleci.com/gh/florentchauveau/go-kamailio-binrpc Also added the CI badge on the README 
Ohh, this is exciting.
The polluter doesn't generate the schema for a database, it's used only for seeding a database with a data.
Thank you for that. It seems very verbose to me but I guess there isn't another straightforward way especially compared to python or js. Thanks again!
I'm just wondering, does this mean anything for vim-go. Can we like modify vim-go to use sourcegraph ? *scratching-head*
What‚Äôs transactional memory I‚Äôm a newbie to this stuff but I would love to know 
You should check the distances from the circle center to all the four edges of the rectangle, if any of these distances is larger than the radius of the circle, then they are not colliding, otherwise, they collide.
!remindme 48 hours
I will be messaging you on [**2018-10-04 14:11:58 UTC**](http://www.wolframalpha.com/input/?i=2018-10-04 14:11:58 UTC To Local Time) to remind you of [**this link.**](https://www.reddit.com/r/golang/comments/9kltba/has_anyone_assembled_benchmarks_comparing/) [**CLICK THIS LINK**](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[https://www.reddit.com/r/golang/comments/9kltba/has_anyone_assembled_benchmarks_comparing/]%0A%0ARemindMe! 48 hours) to send a PM to also be reminded and to reduce spam. ^(Parent commenter can ) [^(delete this message to hide from others.)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Delete Comment&amp;message=Delete! ____id____) _____ |[^(FAQs)](http://np.reddit.com/r/RemindMeBot/comments/24duzp/remindmebot_info/)|[^(Custom)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[LINK INSIDE SQUARE BRACKETS else default to FAQs]%0A%0ANOTE: Don't forget to add the time options after the command.%0A%0ARemindMe!)|[^(Your Reminders)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=List Of Reminders&amp;message=MyReminders!)|[^(Feedback)](http://np.reddit.com/message/compose/?to=RemindMeBotWrangler&amp;subject=Feedback)|[^(Code)](https://github.com/SIlver--/remindmebot-reddit)|[^(Browser Extensions)](https://np.reddit.com/r/RemindMeBot/comments/4kldad/remindmebot_extensions/) |-|-|-|-|-|-|
No, It's not very polished as it was my first go project and I did't really finish (missing things like texture mapping and sprites). Right now I'm working on a similar project (closer to the quake engine tho) that I will probably put on GitHub.
I would say that it's more idiomatic these days to do table driven *tests*, and leave the code to be refactored by someone who is supposed to break the problem into small, readable, easily understood logic.
Nice. I wrote something like this and added unix pipe style transforms and type support for otto, doceur, and goquery. I like the semantics you went with. Although dot-chaining always feels wrong to me in go. Thanks for posting. https://github.com/emptyinterface/sq
Great idea!
That's what I do, though...?
I'm more curious if it has advantages over existing tools. I've never used it, so I can't compare. Can anyone else? Can anyone give examples on where using this would be objectively better than existing tooling? This isn't a nitpick mind you, I'm interested In it. Are the autocompletes like, better or something? I'm not exactly sure what the value prop is for editors. I get that it can be used like Github + insight, but for strictly editors, I'm trying to understand if it does thing(s) better than other tooling. Thoughts?
Your repo seems to be more multifunctional. Actually I start this repo just for improving my development efficiency, it‚Äôs rough but more suitable for me. Thanks for introducing.
Unfortunately the go plugin for Intellij is not available anymore, as JetBrains launched GoLand
[removed]
Okay so here's the jargon: `func (s stuffbefore) blah()` =&gt; This construct is called a method. It's a common term in OOP `func blah() (t1 typ1, t2 typ2)` =&gt; The concept is called "Multiple Return", although it is just a plain function using multiple return values. So to say Go uses this concept is spoken with "Go allows Multiple Return`, or if a function uses it, we say "This function has multiple return values" or even just "this function uses multiple return" I think something else that can be confusing is that "multiple return" can mean two different things. It can mean either "returning from more than one location in a function" (like returning if an error occurs) or "returning multiple values". Go actually encourages both of these practices, although first meaning is usually called "early return" in Go, and "multiple return" is used for "returning multiple values".
&gt;No, TSX is a hardware feature that's only supported by a handful of expensive CPUs, they don't even ship it with all Xeons. And on half of those, it's bugged and Intel had to disable it‚Ä¶ And AMD has yet to release a CPU supporting it. I think you are right about the older Intel CPUs and their rocky start to TSX, but I believe pretty much all CPUs Skylake (6th gen) onwards have working TSX support now. [https://ark.intel.com/products/codename/37572/Skylake](https://ark.intel.com/products/codename/37572/Skylake) It looks like there are also quite a few broadwell chips that have working TSX, also.
I‚Äôm using it. I think my struggle is two fold. Less important to me is weight. Vim is easier and more Convenient to open up when I need it. More importantly, I have labored over my vimrc and have no idea how to recreate that in Goland. I‚Äôm not giving up on Goland. I am sticking with it for a small game I‚Äôm making. 
Yeah I get that. It's not a replacement for the small tasks. I personally use sublime for that as it's so much snappier. And I'm pretty sure you can import your vimrc :) 
The function's declaration (ie `func (s receiver) funcname(p parameter) (r rettype)`) is called a "function signature", and the code that the function runs (inside the curly braces) is called the "function body". Here are the names of all of the things inside of the function signature: `func (RECEIVER) FUNCTION_NAME(PARAMETER_LIST) RETURN_TYPE or (RETURN_LIST)`
He's given too much credit for things golang is not good at. interface {} and struc{} with no generics are awkward and not clean. Dev tools are still very limited. Golang is a good lang but very lacking im some area compared to other long lived langs
I assume that this works only for memory based modifications? Could react strangely to other stuff with side-effects, therefore wouldn't be appropriate as a full replacement for a mutex?
&gt;Is there a way to replace all SystemMutex calls to yours in the entire go sourcecode? &gt; &gt;I wonder what would be performing better, channels maybe? Let's not forget that TSX sync primitives is not the end all for locks in general. Using them in the right scenario (in sparse accesses) can show massive performance gains, but using it as a lock replacement can sometimes cause extra overhead.
Python or JS give you easier JSON deserialization, however, most of the time you also get a very stupid deserialization, where you just have ints and strings and such. In Go, it's much easier to call the JSON deserializer and get _objects_ back. I actually prefer the Go way, even when it causes occasional snafus like this. (It is possible at least in Python to configure the deserializer to give you real objects, but it takes so much more work than the normal approach that I personally have neither used it, nor seen it in the wild. I'm sure someone does, though.) It's also good to learn about how Go works with JSON, because similar issues are shared by many static languages. When designing a JSON API for general Internet consumption, it's a good idea to design one that works well with static languages, as it may actually be the majority of your usage. So it's not all bad of an experience.
You've missed the opportunity to name this `smash`.
The idea behind Hardware Transactional Memory(HTM) is that you can, in similar fashion to locking/unlocking a Mutex, go into a critical section of code with the assurance that no one else will be fiddling with your variables while you work. In Intel RTM style HTM case, you hint to the CPU that you need protection and just attempt all of your operations (the transaction part) while the CPU stands guard. If the CPU sees someone else changing the values of variables you read, it undoes all of your operations and notified you.
Oh wow I'd absolutely love to see the quake project when it's ready! 
FWIW I pay yearly for the JetBrains "God License" that gives you full access to all their IDEs for one price. It's well worth it IMHO. These are the features I find most useful with IntelliJ-based IDEs in general and GoLand in particular: * Refactoring support * Built-in dep and vgo/go modules support * Test integration * Docker integration * Data Source integration * Highly configurable file watchers for things like `gofmt` and `goimports` * Built in diff/merge tool is better than pricy standalone tools that do the same thing * Support for `//go:generate ...` * Bash and Makefile integration * Much improved Delve integration and reliability * Code macros It's one of those things where you have to be comfortable with an IntelliJ environment to get the most value out of it. If you are comfortable with it, your productivity will be drastically increased. Again, all opinion on my part.
Not sure about I think I definitely read about that stuff not familiar with hardware much : (
VSCode is not even the best open source solution for Go ‚Äì my Emacs setup for Go was more advanced.
I did profile and a very significant amount of time is spent decoding things. The thing I'm unsure about is whether gob is a viable solution for these "one off" ser/deserializations? Since it's primarily meant for streams of data.
I installed it on my server and installed the Firefox extension. When I tried out I couldn't figure out what I could use it for that I can't already do in LiteIDE, VSCode, directly on GitHub or on the command line with the_silver_searcher, ripgrep and tig. Removed it from my server. Now I am left baffled.
Great, was waiting for the minor 1.11 release to switch to 1.11!
The Go gods presented a proposal (the "design draft") and asked for feedback. What do they get? Counter-proposals, and lots of them. Apparently Go programmers prefer to speak in code... Some are interesting, others strange, but presumably all count as rejections of the proposal.
Thanks for the detailed reply. I'll have to consider Goland in a few months when I'm more familiar with Go. It might be worth it if it can save me time and make the dev experience better. I do have to point out that I really like the Git tools available in VS Code though, especially with the GitLens extension. :)
Great features and changes. Thank you!
If you want someone to come up with a sane answer to your question, you should make a minimal runnable codebase that exposes the problem you are asking us to find for you.
My bad first question here, bit nervous. I am going to do just that.
Rust and Golang are about the same age, though.
Well, first stable was what.. 2015 for rust? And Go first stable was 2012? But other then that, you are right. I should have said, it's not mature enough. In any case, I've done socket programming in both and rust is just simply not ready for that. The amount of leg work I had to do was staggering. I'm not saying that it didn't perform well, I'm just saying Go will help you out MUCH better. Than again, I guess I should point out that the leader would probably be Python in holding your hand. :)
In most Go apps, locking happens in channel runtime, so is hidden from the programmer. I'd be interested to see this implemented to affect channels, and see benchmarks for various producer/consumer scenarios.
In the "code cleanliness" they mention a "triary operator". I guess they mean a ternary operator. Also, the Go code for that example always returns the same, since it's missing an else-clause. var res string if aa%2 == 0 { res = "even" } res = "odd" 
Your post will probably receive many downvotes as many, including myself, do not feel that certificates prove one's knowledge. 99% of employers wont care for your programming language certification and may hold it against you. I would.
Go has a high-quality HTTP server in its standard library, so you may not need Nginx. I serve Vue.js scripts directly from Go; it works great.
An alternative would be: var res = "odd" if aa % 2 == 0 { res = "even" }
I'm glad! Every single proposal from the core team for Go 2 is completely nonsensical, both their approach to "generics" and the check/handle mess feel like they were hacked together in the last second. Go's only selling point is that it looks back at the last 40 years of programming language design, picks the few ideas it considers are useful for maximising productivity (interfaces, coroutines, channels, dot syntax) and calls bullshit on the rest. While people can disagree on which ideas Go should have picked, it is undoubtedly its biggest strength that it's a refinement of existing ideas. Let's be honest: the Go core team has no idea how to design a programming language. Which is why they didn't: they just put a modern standard library, interfaces and a reasonable concurrency story on top of C, getting rid of most of its warts on the way. Asking them to come up with new ideas is a recipe for disaster.
Why would they? Even if it doesn‚Äôt necessarily qualify someone, it shows willingness to better themselves, surely? 
Quite a clickbiaty title but overall a reasonable write up. It just lacks depth in favour of touching a lot of topics briefly.
Agreed that check/handle is awkward -- see [Golang, how dare you handle my checks!](https://medium.com/@mnmnotmail/golang-how-dare-you-handle-my-checks-d5485f991289) But they're determined to do something about error handling, since they've heard much criticism of the `if err != nil { ... }` regime. So they need more guidance than slapdash counter-proposals...
Or a desire to take a shortcut and lack of "hacker ethos".
I saw the commit saying it was released that got merged yesterday, but I was waiting for it to show on the actual website. :P
A shortcut of studying and taking a tough exam? Like I said, I wouldn‚Äôt treat it as the only credit someone needs to be good at programming but it‚Äôs definitely not a negative 
If the test is rigorous and reflects what one may expect at a programming interview, why would they? As opposed to focusing on syntax and language features like Oracle's Java OCA exam.
Historically Go always has some significant bugs until the first point release, so it's safer to wait an extra month for the first point release.
Thank you. 
Just look around the internet for attitudes towards programming language certifications. 
I've seen them and I don't understand them. I'll be the first to admit I don't have "hacker ethos" nor am the most talented or passionate programmer. So long as kids are spending thousands upon thousands going into debt for computer "science" degrees, my feeling is that certification programs if done right are an entirely positive force. And Google could do it right.
I've not used Go's HTTP server. How well does it handle things like limiting the amount simultaneous connections?
I wish Go wasn‚Äôt dying :( it had such promise
What? Go is exploding in popularity! 
Your goroutines are writing to adjacent indexes in \`sums\`. Thus the CPU Cores are having to fight over write access to the cacheline of sums where they need to write. You're only able to run as fast as the cachelines can be shuffled around between the cores, which is slow to begin with, and doesn't scale that well. &amp;#x200B; So if you either space out the entries in \`sums\` so they are a cacheline apart (64 bytes typically for x86),or keep the partial sum in a local variable and write it back to sums once at the end of the loop, or some other way to reduce contention for the cachelines, you'll see the performance scale linearly.
One more thing, about profiling high CPU work on laptops. Laptops are easily limited by thermal characteristics. Once you get all CPU cores running long enough (just a second can do it) the CPU goes into thermal throttling, and that messes up your benchmarking results. You need to disable throttling (and just run the CPU slowly all the time) or perform a warm up to get the CPUs throttled in order to get repeatable results.
Because someone competent enough that I would want to hire would know that certifications are useless and a waste of time. Someone who doesn't know this or would waste time, money, and effort on one is likely someone I don't want to hire.
Not possible. If you could come up with a reliable and accurate way to assess programmer/software engineer skill, you could make a lot of money offering the service to every single tech company.
Combine them with OR, it should look similar to this: foo.Call(..., 0x00010000|0x00020000, ...)
Yeap as others have said, try summing into a variable and then write to `sum[i]` once at the end of each goroutine
Why is a favicon request hitting your database? Handling the root path will take care of everything that you haven't explicitly defined.
IIRC sourcegraph is using the Language Server protocol. This protocol allows you to write servers for a specific language, and then use it with any editor supporting the protocol. This means that instead of N editors supporting M languages, we just simply have N editors and M languages. There would be no need to develop language support as an editor, which should lead to more feature rich editors. Additionally, if you are making a custom language, you'd no longer need to develop support for each editor, just make one server.
THANK YOU!!!. Using a local variable worked. I've been banging my head at this problem for longer than I care to admit. I figured it had something to do with caches but I know nothing about this stuff and I couldn't figure it out by googling on my own. &amp;#x200B; So after googling for about 10 minutes just now about cachelines, my understanding of what you're saying is this: A cacheline is the smallest unit that's fetchable from memory into a processor's cache. I have 4 locations in memory sums\[0\], sums\[1\], sums\[2\], sums\[3\], but they all reside on the same cacheline. So when a processor wants to do sums\[i\] += 1 it has to read that location into its cache. When processors A and B try to update sums\[0\] and sums\[1\] respectively, they keep fetching the same cacheline, so they keep invalidating each other's cache and they have to keep re-fetching the same stuff from RAM. &amp;#x200B; Is that a good summary? &amp;#x200B;
Disable tls and test again, I see sub millisecond latencies with grpc sans tls
The compiler could also optimize a lot away of the simple single threaded code. Maybe loops get combined or skipped. Maybe adding the square could make it complex enough.
You're thinking of the logical OR ||, which is used in boolean operations. In this case, the bitwise OR | is used to combine significant bits from two bitsets. You can learn more about operators here: https://golang.org/ref/spec#Operators
Yes i do too without mtls and just tls. Put ClientAuth: tls.RequireAndVerifyClientCert to your server tls config
This is a Go2 proposal; they're not considering language changes to Go1. The `mut` keyword might be Go3! Note that the designers did consider const qualifiers, and deliberately omitted them. Mutability qualification could alternatively be provided via naming conventions (`mField`, `field_m`, etc) and a go-vet switch. That could make code clearer than new declaration keywords.
I like the current solution, so I hope they maintain backward compatibility and makes it so that libraries don¬¥t infect its client with verbose drudgery.
I'm not in favour of immutable types. Not having immutability was a conscious design decision for Go 1 and I like it very much as it makes the language a lot simpler and avoids a bunch of tricky issues with respect to const correctness. 
As you have already mention it is not \_yet\_ proposal but design draft only. I am happy that they ask for feedback on that before they shaped it into something "proposal ready". &amp;#x200B; Personally I love the way how in-depth research they do about each feature they consider to be a good value for Go2. I may not agree on every decision made, yet I can't ignore fact that it is still a good piece of engineering.
This is both, a Go 1.x and a Go 2.x proposal. The first one is fully backward-compatible and doesn't require any significant language specification changes. All Go 1.x code will continue to compile and work as expected. &amp;#x200B; Naming conventions and linters won't do the job as described in [https://github.com/romshark/Go-1-2-Proposal---Immutability#411-cant-these-problems-be-solved-by-a-linter](https://github.com/romshark/Go-1-2-Proposal---Immutability#411-cant-these-problems-be-solved-by-a-linter). Such a convention would also break any backward-compatiblity, old code could change meaning and stop compiling.
They are - but the LSP spec doesn't explicitly require _(I believe)_ full support, you can implement partial support. Furthermore, the most common LSP for Go is already made by them. So you can _(and could previously)_ run the Go LSP from Sourcegraph, without running a source graph instance. So my question is; does Sourcegraph add anything to pre-existing tooling? We already have an LSP _(by them no less lol)_, so what is added from Sourcegraph for editors I wonder? If anything.
It might make the language simpler, but it doesn't make software engineering in Go simpler. &gt;"Software ingineering is what happens to programming when you add time and other programmers." &gt; &gt;\- Russ Cox ([https://youtu.be/F8nrpe0XWRg?t=3m12s](https://youtu.be/F8nrpe0XWRg?t=3m12s)) Having mutable state all over the place is an engineering nightmare, especially in a highly concurrent language like Go! The current means (copying, getters/setters) of solving those issues aren't enough and this is all elaborated in the [design document](https://github.com/romshark/Go-1-2-Proposal---Immutability).
&gt; That's a good idea, but given two or more name servers, I think it will cost network traffic, especially if parent name servers is not using UDP connection. When resolving domain using TCP, DNS use full connection round-trip (open, send, recv, close), that is high round trip per name server; plus each connection may require one routine to manage it. I prefer if rescached to be minimal (low resource) as possible. That's why this should be an opt-in feature, as is e.g. in both unbound and knot. &gt; I think it's defeat the purpose of caching. caching has normally two purposes: avoiding load on the service being cached and/or speeding up the client during repeated reads. I don't think the purpose of this package is the former, and my suggestion would definitely help with the latter (since commonly used items would always be present/valid in the cache. &gt; For example, assume that if we have record X and Y, with most frequent accessed record is Y (e.g. reddit.com); and X is only accessed on time; if X TTL is about expire, we will refresh record X that is never queried again in the future. This is a known problem with known solutions, the simplest being: keep a count of how many times each domain is resolved and perform this "aggressive refresh" only for those that exceed a threshold
consider module support is experimental in Go 1.11, that seems fine?
&amp;#x200B; The handle proposal seems harmless enough for compatibility. (Although, it reminds me of Visual Basic OnError :-) 
Go performs escape analysis and puts the "number" on the heap. A cursory search led me to this link: [https://www.ardanlabs.com/blog/2017/05/language-mechanics-on-escape-analysis.html](https://www.ardanlabs.com/blog/2017/05/language-mechanics-on-escape-analysis.html)
Interesting. Thanks! So the compiler fixes that problem for me. I guess that is in order to prevent "dangling pointers", correct? So does this come with a performance hit? Or does it not matter? (And I'm not talking about this example specifically, but in a more general sense)
Hopefully this is what you need to change &amp;#x200B; **func** listenForConnection(arg string) net.Listener { **var** ln net.Listener **var** err error **if** arg == **"tcp"** { ln, err = net.Listen(**"tcp"**, **":8181"**) *// obviously ln is inside the if statement and can't work outside* **if** err != nil { *// handle error* fmt.Printf(**"Error : %s"**, err.Error()) } } **else if** arg == **"unix"** { ln, err = net.Listen(**"unix"**, **"/tmp/go.sock"**) *// obviously ln is inside the if statement and can't work outside* **if** err != nil { *// handle error* fmt.Printf(**"Error : %s"**, err.Error()) } } **else** { *// handle and return due to bad argument* } **for** { conn, err := ln.Accept() **if** err != nil { *// handle error* } dec := gob.NewEncoder(conn) enc := gob.NewDecoder(conn) **go** businessLogic(enc, dec) } }
to quote the Go Language Specification, Go is "strongly typed and **garbage-collected** and has explicit support for concurrent programming." Garbage collection is scheduled for storage that is no longer referenced. The "pointer" function returns a value that's assigned to a temporary, which is then passed to fmt.Println. The reference to the storage never goes out of scope, so it's not garbage-collected. I think the confusion might be related to the question of where storage is allocated (stack or heap). The first answer to the following question on stackoverflow has good explanation: [https://stackoverflow.com/questions/10866195/stack-vs-heap-allocation-of-structs-in-go-and-how-they-relate-to-garbage-collec](https://stackoverflow.com/questions/10866195/stack-vs-heap-allocation-of-structs-in-go-and-how-they-relate-to-garbage-collec) &amp;#x200B;
I'm surprised this works at all, since adding an element to a map can trigger a map resize (that requires memory allocation - that in turn can trigger GC - to allocate a bigger map and copying every item from the old map to the new map - spread over multiple map modifications). Or, even worse, what happens if \*inside\* the transactional region the go runtime decides to migrate the G to a different P? Wouldn't that potentially disrupt the operation of the runtime?
Thanks for your answer. I'll read through the SO thread. The problem is that I'm learning Rust and Go at the same time. Rust sort of teaches me to watch out for those things or at least be aware of them (Dangling pointers cannot happen in Rust) and when I work with Go I sometimes get really confused by the "magic" that goes on in the background. But I'll get used to it. And luckily there's this subreddit. I had quite a few questions like this one and they were always answered in a very concise way. So once again: Thanks!
What a perfect answer, thank you so much for breaking it down into its minute details. That really helps me understand what I‚Äôm reading out online from other lists. I‚Äôm so glad to see my question still generating useful replies even days after I posted it too. 
Just because you can't declare that the state is immutable doesn't mean that programmers mutate all the state all the time. This kind of thing is a non-issue in C and I don't quite see the problem in Go either. If you fear other programmers so much that you have to try to enforce anything with ridiculous getters and setters, you have other problems that need to be fixed first.
Are you using mux or something??? The standard use is create a template directory for for all the http request of a static file should go there, not going to your compute routes 
Yeah, when I first started writing go, this was a difficult thing to wrap my head around coming from a C/C++ background, do this in C/C++ and your history!! :-) &amp;#x200B;
derp, I'm an idiot. I was trying to use listenUnix and listenTCP separately in my initial attempt (and didn't even put it in the code here) &amp;#x200B; thank you /u/janderssen for making me notice it when looking at your example! in hindsight obvious -\_-
Fair enough, but don't get attached to it; I suspect the feedback has sunk it.
It still is available, I just verified and it has been update recently on 9/20/2018. Open Plugins &gt; Install JetBrains plugin... &gt; Search on "Go"
They aren't making more language changes in Go 1.0. Backwards compatibility doesn't matter.
Missing from your proposal are real world examples of the lack of immutable types causing problems. Eg. "There was a bug in production that cost millions of dollars. If we had immutable types, the compiler would have prevented the bug from occurring."
How you assemble your stack depends on many factors, all specific to your situation. Nginx can do things the Go HTTP server can't do. Nginx can act as a gateway to Go apps each serving their own frontend files.
Because invariably courses teach to the certification test. I actively devalue resumes with certificates listed on them.
As a hiring manager I can‚Äôt value any certification because I can‚Äôt tell the difference between one resume in which the person knows nothing but the test and another in which someone actually knows about the subject, and I don‚Äôt have time to waste bringing in potentially poor candidates.
No worries üòä The point in doing this, is also that often you find issues in other places of the code, that might trigger the problem.
Understood. But, if I'm only serving up static frontend Vue files to accompany the backend Go API, while still intending to use Traefik as a reverse proxy in front, does that seem like a smart setup? Or would it be more advisable to stick with the original plan of frontend files on Nginx and separate backend Go containers? Sorry, I know you can't answer definitively without being intimately familiar with the project. Just curious to know your gut reaction, being the far more experienced user.
Exactly. It's convenient, but a little dangerous when people come to expect this kind of magic. (Javascript does this, too)
You'll also find that gob uses more space than many other encodings when storing singular values - it's just not suited to this task.
Yes, PHP is blocking, Go handles multiple threads and doesn't block. I bet Go will compete with Node.js in terms of popularity quickly. 
I work with php and I study go. I'll be honest, I can't stand looking at those crazy ternary array of object blocks. It's just confusing and takes so much time to read. I also think a lot of people miss a main concept in go when they pick it up. That is amassing types methods into params. It just takes a while for people to understand that you don't have to do everything inside a function and just take an arrest as a param, in go you pretty much build out your methods on your params for incoming types. People also tend to not understand that a type is just a type and really it doesn't matter what's inside of it. In a sense you are abstracting names away. If any php Dev is interested. https://docs.google.com/document/d/1Zb9GCWPKeEJ4Dyn2TkT-O3wJ8AFc-IMxZzTugNCjr-8/edit?usp=drivesdk 
Totally worthy. No.1 is performance. Others are simplicity, type system, ecosystem stability for micro service architectural web applications and etc.
Check whether method is OPTIONS. Might be a CORS request.
üôÑ: üòè ü§¨: üòèüçÜ
if any are a php programmer like i used to be. you need go. 
link to proposal: https://go.googlesource.com/proposal/+/6baae2869cc86164b2aee513446bfb4940966e65/design/26903-simplify-mark-termination.md
Link to proposal: https://go.googlesource.com/proposal/+/6baae2869cc86164b2aee513446bfb4940966e65/design/26903-simplify-mark-termination.md What is it about: &gt; The current algorithm is racy and, as a result, mark termination must cope with the possibility that there may still be marking work to do. We propose a new algorithm based on distributed termination detection that both eliminates this race and replaces the existing ‚Äúmark 2‚Äù sub-phase, yielding simplifications throughout concurrent mark and mark termination.
Error handling never saw many experience reports. There was this github issue, but it was also mostly counter-proposals! [https://github.com/golang/go/issues/21161](https://github.com/golang/go/issues/21161)
As a fellow PHP'er, just having true server state is a bonus. My first code was just making a websocket for a PHP app. It worked, but the solidity and performance wowed me. Even though it's low-load, it's a highly active section (little bits hit very frequently), and it's easily the most stable part of our code base. (Actually, I should recompile one of these days.)
Yes, you've got it. It's not fetching the same cacheline per say, it's writing to the same cacheline which causes the performance hit. When multiple cores read the same cacheline they all get their own copy, so their later reads are fast. If all they do is read then there's no contention. Each write of a copied cacheline, however, requires going out to the other cores and invalidating their copies, in order to ensure that there is only one copy of the cacheline when the write happens. It's the invalidation which is expensive.
I would keep frontend files that depend on a backend API with the Go app providing the API, but there are probably situations in which that wouldn't be optimal.
&gt; Missing from your proposal are real world examples of the lack of immutable types causing problems. Eg. "There was a bug in production that cost millions of dollars. If we had immutable types, the compiler would have prevented the bug from occurring." Can you show me in each proposal of the go team where there are such examples of concrete case that mandates a specfic change in the language? What bug that cost millions of dollars mandates the additions of generics or the addition of syntax for error handling? Can you point me to each example in each proposal? thanks.
&gt; Mutability qualification could alternatively be provided via naming conventions (mField, field_m, etc) and a go-vet switch. This has to be one of the weakest rebuttal to having final variables in Go "Just use hungarian notation"., which makes me believe that you people are not speaking in good faith.
Pls elaborate on the "problem at hand". Note that Go is immensely popular without a declaration im/mutability qualifier.
I'm sad that so many misunderstood the intent of your post, simply because it sounds critical :'(
True, that is in line with what I took away from it. Thanks.
Cloudflare's DNS outage comes to mind: https://github.com/golang/proposal/blob/master/design/12914-monotonic.md#go-time
Props on writing up this detailed spec, but I'm a definite no on this change. It adds massive complexity for a benefit that few people will use. func (o *Object) MutatingMethod() const * const Object { var m const map[const Object] const Object You're turning Go into C++. 
You can explicitly create a favicon handler with something like func (s *Server) FaviconHandler(w http.ResponseWriter, r *http.Request) { http.ServeFile(w, r, "static/assets/favicon.ico") } and r := mux.NewRouter() r.HandleFunc("/favicon.ico", s.FaviconHandler) (using "github.com/gorilla/mux" for above)
No love here? Any advice on using Golang for e-commerce?
Which evidence?
[removed]
I thought they meant introduced a non keyword solution, similar to how Go exports symbols only if they are capitalised rather than using a keyword like ‚Äúpub‚Äù or ‚Äúexport‚Äù. Maybe I‚Äôm misunderstanding, but how does that not address the issue?
&gt;Or, even worse, what happens if \*inside\* the transactional region the go runtime decides to migrate the G to a different P? Wouldn't that potentially disrupt the operation of the runtime? P's are just an allocation technique to limit the number of active running goroutines. They don't map onto actual processors. Nevertheless, that does hint to an interesting situation. What would happen if the scheduler was invoked inside the transaction section? Since certain function calls can trigger it. If the scheduler was trying to context switching the M to another G and the capacity abort struck, would the original G magically regain control of the M? I'll try to invoke the scheduler directly and see what happens. Thanks cafxx1985!
Just trust the GC and focus on your actual problem
As someone doing a lot of hiring it would improve your market prospects. Kubernetes has made it a hot skill set right now.
Actually, I guess this scenario would be fine. Anything the scheduler would do pertains to memory reads/writes that can be undone by the processor. In the event of a context switch, we would most likely run into a capacity abort, which would rewind us to the original G. The original G would then execute that function again using the mutex controlled fallback path. Then the context switch would happen. Safe... I should clarify that the CPU doesn't necessarily need to undo what happened in the transaction. It's more like it never committed all of the stored memory changes. Thus, a capacity abort means that it ran out of cache to store transaction changes.
All those words and I still have no idea what this does functionally. 
I do both and feel they are really complimentary. Go is great for back end, API, bots, etc. While PHP is still very convenient for writing front ends or putting together quick stuff in a pinch.
I would give it some time, 5 years or so. Then I could see golang popularity competing with node
Bad bot
Thank you, coder543, for voting on TomBergewrong. This bot wants to find the best and worst bots on Reddit. [You can view results here](https://botrank.pastimes.eu/). *** ^(Even if I don't reply to your comment, I'm still listening for votes. Check the webpage to see if your vote registered!)
Are you sure about that? Because I am 99.92329% sure that TomBergewrong is not a bot. --- ^(I am a neural network being trained to detect spammers | Summon me with !isbot &lt;username&gt; |) ^(/r/spambotdetector |) [^(Optout)](https://www.reddit.com/message/compose?to=whynotcollegeboard&amp;subject=!optout&amp;message=!optout) ^(|) [^(Original Github)](https://github.com/SM-Wistful/BotDetection-Algorithm)
Aestheticization of violence
&gt;tv64738 Maybe I can find it before I start this repo, if there are more documents and repo-tags.
do you have any cool tutorials or examples with go generate? I'm a capable programmer, and I reviewed the docs for it some months ago, but I haven't actually encountered much in the way of practical application for it.
/u/romshark is the author
Whoops!
What do you think his intent was?
Criticize two proposals that a `lot` of others criticized, and identify a core strength of the language: it doesn't impose unproven innovations, and rejects concepts from C++ that aren't broad wins.
Thanks for sharing! It‚Äôs always great to see examples of wasm, I find it much easier than reading the docs.
Hello, the post is just an announce of new version, maybe GitHub Readme and Centrifugo documentation (https://centrifugal.github.io/centrifugo/) could give more answers? If not I am ready to fill the gap - just point me to non-obvious things. There are not so many docs currently for library but it just does what Centrifugo does and provides several more features mentioned in post like custom authentication and bidirectional messaging. In short you may need to use Centrifugo instead of just Gorilla Websocket lib for example if you want all your users to successfully connect as Websocket support in browsers still not 100%, you want scalability to many machines out of the box and you want a portable solution that can be used with projects written in any programming language. Its design also allows to introduce real-time events to application without many changes in application code. 
What gob actually wants is an io.Writer and io.Reader. Since both connections implement io.ReadWriter, that is the common denominator and therefore the type of variable you could use.
I don't think there's a good reason to do that, and there are several reasons not to (for example, the problem you're running into). You'll have similar problems with web crawlers - a 404 is almost certainly a better default handler.
We used it to generate code for an event-driven database. We wanted a typesafe API for each Kind of Element we wanted to store. That would have meant to write a lot of boilerplate. 
Just keep it simple. I am more of a React kind of guy, but i setup my blog using Vue.js, it is just a front for my mail server, completely useless website. But it does have Postgresql as a database and Vue.js on the frontend. Can see the code at: https://github.com/DenLilleMand/blog And the result is seen at [denlillemand.com](http://denlillemand.com)
The only way this will teach you a bit habit is because they've used the word "pointer", whereas in languages like Python for example almost everything is a pointer, although they're called references there. Generally, you shouldn't get confused between Go, a garbage collected language, with Rust/C/C++, languages with explicit memory management
I think the current model is fine.
Fools, trying to fix a fudamental problem, seems everyone is using a magnifiing glass, the problem is a bit bigger maybe I can put the problem as a application worflow/communication management problem. &amp;#x200B; If you've worked in other languages, ALL have problems with "error" handling, Java checked/unchecked, exceptions out of nowhere; GO no surprises in error handling, the you will find error hanbdling EVERYWHERE, still not nice. &amp;#x200B; Here's some ideas: Not using language errors per se, those should be restricted to real failures outside control of your applications, say memory failure, but in the language, processor failure. &amp;#x200B; Implement a carefull orchestration of messaging back, it's more then just "an error from down the stack", it's a commutication process from other components. &amp;#x200B; Now to be honest none the languages I've worked so far have this concept, but we can bend them to experiment. Easy experiment with a composable type. &amp;#x200B; &amp;#x200B;
I'm going for the Hyperledger Fabric certification when it is released.
So, will this be included in Go 12 or maybe Go 13? Can you provide some more context? 
And the fact that those attitudes exist toward certifications rather than 40k a year computer "science" degrees is exactly what is wrong with the western world. Ombilibable.
You should write this up on a gist in some detail with (commented) code examples and post it to the wiki page linked above! Possible food for thought: [Requirements to Consider for Go2 Error Handling](https://gist.github.com/networkimprov/961c9caa2631ad3b95413f7d44a2c98a)
Excellent Spec ! Immutability should have been considered since the beginning, now it's harder to convince everybody that it's a must nowadays. I propose to revive [https://github.com/dmiller/go-seq](https://github.com/dmiller/go-seq) in the meantime. 
Imitation is ideal, but the prevalent model for low-footprint error handling is exceptions, and they're ruled out. Is there a ready model with aspects of exceptions, less the drawbacks? If that was well-defined in another language, I think they would have proposed it! The [Requirements Section](https://github.com/golang/go/wiki/Go2ErrorHandlingFeedback#requirements) may point the way forward...
Am I the only one to like their proposal?
Bait
Why is it `const * const` instead of just `const`, or even `*const`? I don't understand the significance of the double `const` yet, and couldn't find why in the proposal. I'm for having immutability as an option in Go, I think it'd be great if we could have more safety when we want it, but I'm not sure it should be the default. Looking over the Go 2 part of the proposal that introduces the `mut` keyword you only really have 2 options; introduce sweeping changes to the entire language and ecosystem to support working with immutable data types the norm, and easier; or deal with really ugly or really verbose code. I like many of the ideas here, but I just don't think it's very "Go" - the language would be completely different as a result of this change.
Nope, it's two GET requests.
Trolling is strong in people salty that their niche language isn't popular but gophers just continue to multiply
I assume the first or second "Php client -&gt; Go Server" should be "Go Client -&gt; Php server"?
Oops, indeed, I mistyped it Fixed, thanks
I don't see this as an issue as in Go you can simply rely on value types. OK, you still have to be careful with slices and maps but everything else can be made a simple value type.
&gt; The variable number is created inside the pointer() function and should go out of scope after the function has been executed. Nowhere in the specs it's defined to be relevant. You're assuming where the variable lives (on stack), but that's not specified. Actually, last time I checked, the words stack or heap are nowhere to be seen in the specification. The only thing that specs say about the `&amp;` prefix operator is that it takes an address of something addressable. That's what's happening, rest is an implementation detail.
I don't! But this seems like a cool tutorial to write, maybe I'll make one and see how the community thinks about it.
May I ask why I'd use this over nats?
"go isn't evolving my may, go is kill" /s
&gt; PHP7 is a good language! no it's not. Adding features to a badly designed language doesn't make it good. It's a horrible language.
I'll definitely be using \`jsonenums\`. Thanks.
I hadn't heard of `json-to-go` before but I've been missing out. I'll bookmark this tool because I can see it being very useful in the future. The same can be said about `jsonenums` as well. Thanks. 
Not so much questions, but I did submit a PR for supporting context.WithDeadline and a Terminate() in addition to the existing SIGINT (some things need SIGTERM).
Error chaining would be great. https://github.com/pkg/errors
As I've already stated below: **Making the language easy doesn't make software ingineering easy**! \&gt; "Software ingineering is what happens to programming when you add time and other programmers." \- [Russ Cox](https://youtu.be/F8nrpe0XWRg?t=3m12s) Turning Go into C++ would require replacing garbage collection with RAII, replacing structs with full-blown classes, inheritance and stuff, removing goroutines alltogether etc... compared to that - immutable types are a tiny, insignificant, backward-compatible language change that would make **software ingineering in Go** much safer in the long term, because intentions would be clearer with immutable types, [which they're currently not](https://github.com/romshark/Go-1-2-Proposal---Immutability#111-ambiguous-code-and-dangerous-bugs). P.S. - I'm a programming battle-wizard, I don't have time to maintain a language fork unfortunatelly, even though it'd be fun!
There was a decent article about this in the most recent issue of ‚Äúlol no generics‚Äù magazine
One other thing to check. It _could_ be a what‚Äôs called a simple CORS request, which comes in as a GET, or possibly as whatever the regular method would be, but it also has the Origin HTTP header set in that request. I recommend dumping the request‚Äôs HTTP headers, see if one of them has the Origin header. If so, then that‚Äôs called a simple CORS request.
I'd suggest that either the Windows compilation instructions are inadequate, or you've not performed one of the previous steps correctly. Is there a reason you can't use the precompiled release?
withe "typed errors" you might as well do exceptions and have all of their benefits - which is what I suggest - but then I am a heritic &amp;#x200B; &amp;#x200B;
Chill
I'm not disagreeing. Iwish a consistent pattern of handling errors existed. ``` if err != nil { return err } ``` This is not error handling, it is error propagation.
If I try to run bettercap.exe from the precompiled download, I get the following error: "Error opening adapter: The system cannot find the device specified. (20)" Not sure why that's happening, as there isn't really an 'install' to set up what adapter is being used.
If you're not interested in actually compiling it, then I would suggest you grab a [pre-compiled version from the releases page.](https://github.com/bettercap/bettercap/releases)
Yes, winpcap was installed, and the developer's pack extracted to C:\\ like the documentation said. Winpcap installed to C:\\Program Files (x86)\\.
lol go : https://en.wikibooks.org/wiki/Ada_Style_Guide/Concurrency
GORM + Gorilla + net/http + Postgres + ( MVC + structs)
Looks like a lot of folks have similar issues with gopacket on Windows. [https://www.google.com/search?q=gopacket+pcap.h+no+such+file+or+directory&amp;oq=gopacket+pcap.h+no+such+file+or+directory](https://www.google.com/search?q=gopacket+pcap.h+no+such+file+or+directory&amp;oq=gopacket+pcap.h+no+such+file+or+directory) Double check the winpcap installation and the developers pack installation.
I would suggest making the return type of the expression `go f()` an interface with an e.g. `Cancel() error` method. This way future changes can be implemented by adding to the interface.
First off, great idea and thanks for putting an idea out there, subject to the criticism of thousands of opinions... I really like the idea of tying the idea of cancellation to go routines, and I especially like how it is an extension of the language by suggesting a cancel function for the return value of the go keyword. That being said, your suggestion could also be done in a non-cooperating way by having the cancel function mark the spawned go routine, and all other go routines spawned by that go routine as cancelled. At which point the scheduler will not run them, but clean up their respective resources. I‚Äôm not suggesting that it how it should be done, but that it is an alternative were the community to prefer non-cooperative cancellations.
Immutability is a property of variables, not types. Many languages got this wrong.
well played.
Sorry for being impatient but any updates?
Well, from what I know, people were always against just "killing" goroutines, because they might have resources, etc. they need to take care of.
Change the cancel function to instead be "chan error", closing the chan triggers child goroutine cancellation, while reading from it allows waiting for the child goroutine to complete. If the child returns without error, the goroutine returns nil. This allows a smoother select {} experience in the parent when paired with the cancel channel and a timer channel that will short circuit when the child exits quickly without error (cancel chan returns nil).
[removed]
[removed]
Or write the partial sum to a channel where YAGR (yet another goroutine) aggregates the partial sums...
Your comment cut off.
You cannot read from a closed channel.
[Go will never be able to kill goroutines](http://www.jerf.org/iri/post/2930#no_async_exceptions). It's been tried in any number of languages that are as hard as Go or easier, and it's always been backed out of the language as far as I know, because you just can't solve the issues. It's more than tricky; it's effectively impossible. I say "effectively" impossible because I'm not 100% certain that there is literally no possible combination of machine opcodes that could correctly implement it for Go, but if there is one, history suggests it is very unwise to count on being able to find it. And I really want to emphasize that while I have some thoughts on explanation, the _core_ of the argument is an observational one: Very significant amounts of resources have been expended trying to make this work, and nobody's been able to make it work. It works in Erlang because basically the entire language and runtime were bent around making it work. It's one of the truly unique offerings the Erlang/Elixir environment offers, arguably even more unique than the network transparency of sending messages to PIDs without caring whether the PID is in the current OS process.
I'm pretty sure garbage collected languages date back to at least 1985, so it's a little late to worry about the corruption of youth ;)
On Unix or Windows? Have a look at https://godoc.org/github.com/pkg/term and https://godoc.org/github.com/pkg/term/termios for Unix/Linux, and github.com/mattn/go-tty for Windows. Then have a look at: https://github.com/c-bata/go-prompt Yes, I know, this is not quite what you asked for - this is question and response. That's not what I'm getting at though - don't *use* this package, *look* at the source of this package. Even though what it does for you is not what you want, what it is *doing* to accomplish that is what you want - it is listening and responding in real time to the end-user typing, and showing tooltip-type text in terminal in response to that real-time typing. So have a look at input.go, and the pair of input_posix.go and input_windows.go to see how they talk to the terminal in real-time to get keycodes, using the first aforementioned packages.
Ok, I'll bite. Certifications for things like AWS are fine and good. Those are scope limited, product oriented things. Certifications for programming languages are generally looked down upon. Part of this is a matter of ethos part of it is practicality. Regarding the latter, the programming language itself is rarely the important point when evaluating software engineers. Knowing how to solve problems in code and knowing a particular language's syntax and constructs are not the same. In fact, about a third of the jobs I have had have used programming languages I did not have experience with. Learn as go while leaning on prior experience. Not a big deal. If I applied for a job writing Go and I said "Sure, I know Go, here is my certificate" I'm either going to be shown the door or be asked to show Go code I've actually written. If all I have is a certificate then I wont be getting the job. This is because having a certificate tells my employer nothing about my ability to use the language to solve *their* problems. As a side note: bootcamps are popular... "learn full stack javascript in three months." Trouble is, most of the people who go through this struggle to find a job. Apparently knowing a language, in and of itself, doesn't get you far. Also, comparing certificates and computer science degrees is pointless. Also also, why is do you put quotes around 'science'? I am noting what appears to be a mocking attitude towards computer science with an interest in certificates... Also, also, also. The western world has bigger problems than my thinking certificates for programming languages are worthless. If you want to prove you can competently solve problems in Go then your best bet is to actually solve problems in Go, commit the code to github and having something real to show a potential employer.
True. It just ruins the mental image of a pointer when I can destroy the thing being pointed to, and everything still works.
I don't know the internals of the Go runtime, but could the scheduler not bubble a panic asynchronously up to the goroutine if it sees that the goroutine has been flagged as terminating? This would let `defer` chains execute, and the function would just die like any function spawned with `go`. It would result in asynchronous, semi-cooperative termination ‚Äî you wouldn't be able to terminate loops that didn't contain any scheduler pre-emption points, for example, and if the goroutine trapped panics with `recover()` you could also get a stuck goroutine.
There was information about how to tag modules in multimodule repos somewhere. It was basically a prefix for the number tag that indicated which module was being tagged. Let me look it up.
I don't know, I've never been there. I do know a few Gophers who organize the study group for India. Go chat with them in #gostudygroup-india, and they should be able to answer that better than me.
In the article it says: &gt; Austin Clements plans to implement all or most of this proposal for Go 1.12. The actual implementation effort for each step is likely to be fairly small (the mark termination algorithm was implemented and debugged in under an hour).
This is the fourth episode of Go After Dark, where we code cool graphical effects in Go. In this episode we create a 3D tunnel effect using per pixel texture lookups. This is also the basis of a whole range of effects. Series Website: [https://afterdark.klauspost.com/](https://afterdark.klauspost.com/)
Ah brilliant ill get to reading! Thanks for the input! 
Here is my experiment with rendering a tunnel effect in combination with plasma: [https://github.com/peterhellberg/pixel-experiments/tree/master/tunnel](https://github.com/peterhellberg/pixel-experiments/tree/master/tunnel) ![Animation](https://cloud.githubusercontent.com/assets/565124/25528930/48bc195c-2c20-11e7-8db8-d3b01b4a8903.gif)
In this proposal it is a property of **types** and not variables and I think it'll make sense to you if you read it. This proposal is **not** about functional-style immutable objects (objects that are immutable after their creation), it's about "read-only types" which consistently work for almost everything (struct fields, methods, interfaces, arguments, package-scope globals, return values) and not just variables.
Forgot to call the deferred function üò¨
&gt;Knowing how to solve problems in code and knowing a particular language's syntax and constructs are not the same. A Golang certification would entail knowing how to solve problems in code. But sure, they're not the same. \&gt; Trouble is, most of the people who go through this struggle to find a job. Apparently knowing a language, in and of itself, doesn't get you far. Focusing on language syntax is not why bootcampers don't get jobs. \&gt; If I applied for a job writing Go Go is getting bigger in the networking and security spaces. In which writing Go is not the primary job function. \&gt; "Sure, I know Go, here is my certificate" I'm either going to be shown the door or be asked to show Go code I've actually written. Not going to give me the chance to show I can solve problems in Go? Wow. Not everyone wants to make another app. Some find it to be soul-crushing. \&gt; Also, comparing certificates and computer science degrees is pointless. Why? \&gt; The western world has bigger problems than my thinking certificates for programming languages are worthless. It's about the boomer mindset. Not the certificates. Again you missed the point. \&gt; commit the code to github and having something real to show a potential employer. Why should an employer trust it was me? Anyone can copy great code and paste it on github. And that's what you have to essentially do when starting out. &amp;#x200B;
Because [the proposed \`const\` always refers to the type on the right](https://github.com/golang/go/issues/27975#issuecomment-426730281) which makes it very easy to read, compared to, say, C-style `const`. [Section 2.9.](https://github.com/romshark/Go-1-2-Proposal---Immutability#29-immutable-reference-types) describes this in greater detail with code examples. With immutability by default Go 2.x would really be a different language in the good sense and I hope that I didn't fail to describe why (please correct me if I did).
This is now absurd. Checking out. 
It is slower to put things on the heap. For integers, it will always be faster to keep them on the stack. But it gets more complicated with larger objects. Also maybe you need the value to be mutable or something; in that case, it might make sense to have a pointer anyway. You probably should never write a function like this in real code. But you might write other functions that return pointers in this manner, and that's fine. You'll understand this better over time.
You may like it less after reading [Golang, how dare you handle my checks!](https://medium.com/@mnmnotmail/golang-how-dare-you-handle-my-checks-d5485f991289)
The animated texture definitely gives it more life - and of course panning the over-sized lookup table! Since you are storing an 2 ints per pixel you could make the animation a bit smoother by storing some extra precision in your lookups as I describe in the vid. But hey - it already looks great. I actually remember seeing your 2D raycaster when I finally decided to begin research for the series. I guess you are a little bit to blame for this :)
Well, it is all just for fun anyway :)
Context serves more purposes than cancellation. For example, propagation of tracing information uses context to help instrument code. A good example of this is opencensus[1] and opentracing[2]. You could probably use a specific trace propagation struct for this, but I think Context does a great job of facilitating this functionality without creating too much magic. [1]: https://github.com/census-instrumentation/opencensus-go [2]: https://github.com/opentracing/opentracing-go
You don't necessarily need to write a new Go program. I just use SFTP with Panic Transmit for file transfers, and Caddy's \`browse\` directive to browse them or make certain folders accessible publicly. (The rest of them are behind basicauth with HTTPS). Beyond that, you could use rclone + Minio or some other self-hosted Go file server. I've also heard great things about [Perkeep](https://perkeep.org/) (formerly Camlistore). But if you're looking for the experience of writing a Go program to do this, you would want to look at the net, net/http, and crypto/tls packages probably.
&gt; It's been tried in any number of languages that are as hard as Go or easier, Ada have the equivalent of go routines called tasks that are values. That's the solution.
You might like some of these Go projects: - https://upspin.io/ - https://ipfs.io/ - https://perkeep.org/
I like this, then we can imagine ultimately extending the returned type with other context-like things: type GoContext interface { Cancel() error Done() &lt;-chan struct{} ... } Maybe the `go` keyword can become sugar around a `runtime.Go(...) GoContext`.
Aah, that first comment you linked cleared up the `const * const` stuff dramatically. It just wasn't apparent that the point itself would need to also be explicitly immutable too - but now I've seen it it does make sense.
cool thank you! I knew there is a simple protocol i should be using.
You most certainly aren't. I think the draft itself covers a very large error handling surface quite nicely. I even wrote a feedback [gist](https://gist.github.com/urandom/6519990ef9eb7547e888a5f2da7f1a93) which I initially placed in the favor section. The only nit-pick (and it really is that) is that the rules behind the handling can be made to for a bit better within the existing grammar so as not to feel too foreign. At the end of the day, I'll welcome the draft even without any changes.
I doubt that
I fail to see how the draft would in any way hinder handling of specific errors. In fact, it seems to make the handling easier. Nothing's stopping anyone from examining the error in the handler and acting accordingly by calling another function from within.
This sounds awesome for testing client applications (as a server mock)
First, thanks for posting. Obviously this is subject to strong opinions. These are my personal opinions, my experience with Go is moderate. First, I like your blog post. The problem analysis seems sounds. In particular, the important points are: 1. Context is used almost exclusively for cancellation, but comes with other features which are error-prone. 2. Cancellation of a go-routine should be built in (rather than standard library), just like spawning one is built-in. Regarding your proposal, I see one downside compared to using context: there is no way to tell whether a function has implemented support for cancellation or not. **It moves what's currently explicit, to something implicit**. So the counter-argument goes something like this: because a started go-routine has no obligation to listen to a **cancellation request** (because that's what it is really), giving the caller a cancel() handle is spurious. It's (1) opaque and (2) doesn't promise anything and (3) it's not explicit. TL;DR Supporting cancellation requests is a feature, and features should be explicit. Thoughts?
Gotcha. Thanks.
Research bi directional streams using grpc in go. This will help you achieve what you want to do in very few lines of code (in fact I imagine some tutorials will address this directly) 
ah, thanks for the clarification. i loved their content and support their decision but am sad there is no longer a podcast dedicated to Go..afaik
[removed]
Can this send presidential alerts
Hmmm ok. This somehow sounds really uncomfortable. I'm just a hobbyist, but - as a professional developer - isn't it weird to not know what exactly is going on?
Does it teach bad habbits, from probably my background, I would say yes, but if new programmers (which there is a lot of them these days) are all using garbage collected/ARC based languages, this is a habbit they kind of don't need to worry about maybe ? not really sure? I myself personally think all programmers should do 5 years extensive C programming, to get a really good understanding of what happens under the hood, and then branch too a "nicer" language, but hey that is only my opinion, so please ignore if you don't agree, I'm cool :-)
Nice! Thanks for sharing. 
I've compiled a collection of benchmarks for all Go versions from 1.4 to 1.11 and pushed them to github. I'm currently running the benchmarks for 1.2 and 1.3 releases and they should be up soon. I'll also add 1.11.1 when they're complete. You can grab them from https://github.com/Intermernet/gobenchmarks 
There another Go podcast called package main.
Only ~~the president~~ multiple FEMA officials can send Presidential Alerts. Obviously.
I should have my first texture-less render done this weekend, I don't know too much about the how the quake engine really works, but I think mine is kind of a mix between the software render, and GLQuake. It does BSP-like things on the cpu, along with culling, and clipping, while letting the GPU fill triangles. I'll write down your username and (if I remember) send you a link.
No, I really don't.
Would you be able to provide context for those of us without presidents please.
https://www.cnn.com/2018/10/03/politics/cellphone-federal-emergency-alert-system-test/index.html
(I was making a joke)
"we can send presidential alerts but still no generics"
Yeah I crossposted in hopes that Go folks could chime in on your post. :)
I love the telegram client, but the lack of transparency around their server has kept me from using it much. Being able to host it myself would make it much more likely that I‚Äôd trust data to it. 
There are a few of these, Eg. https://github.com/rakyll/statik
The "Async &amp; parallel programming" section awards 4 to python, with no reasoning. The "Code cleanliness" part is personal opinion, at best.
How do you that when the original `error` returned was done via `fmt.Errorf`?
Nothing is stopping anyone, but nothing is enforcing it either. There is no enforcement and consistency of how errors should be handled. For example, I've seen this: ``` err := func() if strings.Contains(err.Error(), "some message") { ... } ``` Though this is user error, there's examples of it in the [standard library](https://github.com/golang/go/blob/50bd1c4d4eb4fac8ddeb5f063c099daccfb71b26/src/database/sql/driver/types.go#L69), too.
I'd like the link of that one. It could also be listed here: https://github.com/golang/go/wiki/Podcasts
Here is a working version OP [https://play.golang.org/p/jqxUSx-B2Dk](https://play.golang.org/p/jqxUSx-B2Dk) &amp;#x200B; also some notes, dont use \\n when you are using fmt.Println. &amp;#x200B; also get in to the habbit of using, %d, %v, %s in your coding when trying to print out a variable
I was sure the answer was going to be that you'd forgotten the . in the template. I do that so many times.
[removed]
[removed]
That also seems like an easy mistake to make. My problem was that I printed the todo after scanning, which produced a pointer to a struct with correct info, making me think I was passing the same data to the template. &amp;#x200B; The hardest part about pointers is thinking about them takes away from other stuff. I Would never make this mistake in node.
I wrote my own photo hosting server as a learning exercise (and also so I could keep photos on the cloud without sharing them with Google, etc). Didn't take long to write one from scratch. The https support from the acme package was unbelievably easy (but you won't need that for your version). Writing the js to send files from a browser webpage to a server took a little time, but was satisfying to get done. I even get into thumbnailing the images (using a call out to imagemagick for now, but I want to rewrite it to use the image processing packages), and fingerprinting the images using the SHA crypto packages (so if I upload a duplicate it tells me). I thoroughly recommend it as a learning/hobby project. The advantage of creating this as a website, of course, is that every machine on the network will be able to communicate with your server, automatically.
&gt;https://github.com/Intermernet/gobenchmarks 1.11.1 is running now and should be up very soon. 
Both Erik and Brian had some family stuff come up. They both want to continue with it, but they're just having trouble balancing it with everything else in their lives. Source: I asked them about it at GopherCon this year.
He releases one or two episodes per month. * [github](https://github.com/plutov/packagemain) * [channel link](http://youtubecast.madriska.com/user/UCI39wKG8GQnuzFPN5SM55qw) for your podcast app. * [youtube](https://www.youtube.com/packagemain)
[removed]
I have said it before, but I think NATS is an absolutely great piece of software: the tiny container image, the simplicity of its API, the elegance of most client libraries, the fact that guarantees can be added by using NATS Streaming which uses NATS underwater. On top of that, performance is great as well. The things I would like: more Kafka-like durability and reliability guarantees and, in general regarding messaging systems, better observability instrumentation. 
Yeap that would be quite elegant as well. I guess writing to different slots in an array is more reminiscent of languages without easy to use data structures like channels. But for go this is probably the best solution!
I have been, for 1 year. It's a solid piece of software!
Our definitions of production are very likely quite different.
How would i make my Phone use this Server if i hosted it somewhere? 
Graph data structures are very application-specific. Honestly a map or a slice will usually do the trick, it depends on what you need to do with the graph. In addition to the usual node-with-neighbor-pointers approach, there are also edge lists and adjacency matrices that are common. When you are talking about dependencies though you might be talking about a directed acyclic graph, better known as a tree, and those are super easy to represent in Go directly without needing a special purpose library.
Sounds like a simple problem with a simple solution to me. Only use one scheduler instance. 
We get millions of messages through our NATS Streaming daily, without a hickup. Sounds production to me.
Where you can don't mock out libraries, mock out network connections, for example if you talk to a http server use [httptest](https://golang.org/pkg/net/http/httptest/) package to spin up a temporary HTTP server that responds in the way you require - it is just as quick as mocking out the http library but way simpler and means you don't need to alter your API to accommodate mocking. Or for filesystem access you have [TempDir](https://golang.org/pkg/io/ioutil/#TempDir) and [TempFile](https://golang.org/pkg/io/ioutil/#TempFile). Otherwise for internal structs or for other things that you cannot mock out this way pass around interfaces instead. You are then free to pass in a mock struct that implements the same interface for unit testing. Due to Gos nature mocking frameworks are complex and don't work very well. It is best to avoid them when you can and use the primitives that the language gives you instead.
&gt; isn't it weird to not know what exactly is going on? It is, but not specifying it keeps implementations free to adjust for special/experimental cases. FTR, C does not prescribe stacks either, IIRC. It just specifies, that by default, variables declared inside a function have automatic storage. Then it says that a dereferencing pointer to an object with automatic storage that's no more in scope is UB. When a stack is not mandatory and some program happens to have an acyclic graph of calls then there's a nice opportunity to assign _fixed_ addresses to function local variables. (Seen that first in Turbo Pascal for 8-bit CP/M). If it also happens to run in a single thread, say in some micro controller, it may enable using CPU that don't even have a SP register.
I've used mock service before by using an interface for services and implementing a mock version in my test suite, the problem is the pain of passing it around that I'm trying to solve 
Please don't (repeatedly) invent new terminology. This time it's 'Type embedding'. It has no defined meaning in the language specification. What you're talking about is a different, well defined term: [`embedded field`](https://golang.org/ref/spec#Struct_types). &gt; A field declared with a type but no explicit field name is called an embedded field. An embedded field must be specified as a type name T or as a pointer to a non-interface type name *T, and T itself may not be a pointer type. The unqualified type name acts as the field name.
Try writing what you need yourself. It will be a lot of fun. Eg ``` type Node struct{ Children []*Node Parent *Node Meta map[string]interface{} } ```
Efficient Go use the terminology [https://golang.org/doc/effective\_go.html?#embedding](https://golang.org/doc/effective_go.html?#embedding)
&gt; There is also a use of "embedding" in spec. By context, it means embedding type". "embedding (a) type" in a struct has no meaning I can think of. You cannot embed a type into a struct. A struct is a value composed of a set of named fields. Fields are values. Values have types. Embedded field has a type as any other field, ie. it's a value that _has type_ therefore it's not _a type_.
btw, what does "repeatedly" mean?
I think the way that Kotlin handles all of this stuff is pretty smart: https://github.com/Kotlin/kotlinx.coroutines/blob/master/docs/cancellation-and-timeouts.md The thing with the Kotlin approach is there is a fair bit of implicit scope involved. It could be tricky to port that in a similar manner into Go. The thing is, I quite like the propagation of context now. It makes handling goroutine life-cycles very flexible. It is verbose, and infectious, but I think if we are to get away from that, we must have an equally clear solution. Context is very explicit, similar to error handling in Go. I like your proposal overall, but agree with others that killing child goroutines in "parent" goroutines would be bad idea, they're all siblings, not parents / children. I want to think about this a bit more and see if I can think of a Go API that looks similar to Kotlin's, without exceptions, and with timeouts still, and in a way that allows well... context (not as in context.Context) to still be passed to children.
You don't need a dependency injection container to use dependency injection. The two are not intrinsically linked. You could wire up everything in main if you want. I choose [a different pattern personally](https://www.elliotdwright.com/2018/02/27/how-i-structure-some-of-my-projects/). Using libraries like dig or Facebook's inject library all open you up to runtime panics, and just set you up for a more brittle codebase. Even if you generate code for your DI to avoid that problem somewhat, using plain Go code is much simpler, your IDE / text editor will be able to report problems, and your build will always report problems too.
Is there any guidelines for your project? Like requirements?
Many official Go documents have stated it clearly, the code is safe for sure. Search efficient Go: [https://golang.org/doc/effective\_go.html](https://golang.org/doc/effective_go.html) with "it's perfectly OK to return the address of a local variable". Go spec has stated it clearly that Go is language support garbage-collection, this is why the code is safe. Its safety is enforced by Go spec.
Struct (a value) and struct type are different terms. You're now talking about a different thing. Do you see how proper terminology matters? &gt; As I have said above, both terms are needed. One is not enough to explain all things. The specification both disagrees and proves otherwise.
you can check out ‚Äògo mod graph‚Äô for go 1.11.
NATS can be distributed in the sense that you can have NATS server clusters and manually partitioned clusters of clusters. I can tell from Slack activity that development is still ungoing.
It is also related to the pet project, I have no idea what to create but have a strong feeling that I can create anything. Please just write any idea that come on your mind.
I think https://github.com/google/go-cloud/tree/master/wire is what you're looking for. I use it to create a top level component with all of the dependencies in a live environment. And then i also use it in every single package to mock all of the test dependencies with something like `gomock`. It also makes my `main.go` look really neat, and i am able to construct any variation of my dependency graph. Then to auto-generate the interfaces from structs needed for DI i use `vburenin/ifacemaker`. And to mock the database connection i use data dog's go-sqlmock.
What's the benefit of using two servers, why not just one? Do the message passing in memory via channels, etc.
Oh I see! I read your comment as if it would always cause race conditions, which sounded terrifying. Thanks for clearing it up!
I get why it's useful for beginners. So they don't write go code like other languages. This has been described here. https://news.ycombinator.com/item?id=12482017 Rob Pike has tried to address the confusion. https://twitter.com/rob_pike/status/942528032887029760?s=20 https://news.ycombinator.com/item?id=3371884 https://news.ycombinator.com/item?id=4784555 It's been used in other tutorials as well. http://www.laktek.com/2012/01/27/learning-go-types/ Yeah I think a lot of new people to go don't think about a codes type and value but it's important (especially dealing with nil). People usually from c++ forget that go is able to make interfaces verbose because the type is next to the object in go. In c++ the object comes before the type. 
Consider consensus algorithm for distributed systems. A common open source one is Apache ZooKeeper and etcd. ZK uses Paxos but there are more recent ones. ZK project is highly used but gets little attention in the code base with slow releases. In my opinion there‚Äôs opportunity to improve this project by either improving on its implementation or creating a Go version with compatible apis. ZK just uses sockets so should be doable to do in Go. ORellys Apache ZK book is very good. And since the project is slow to move the book is still relevant :-) Good luck
But then when scaling out all of the instances need to communicate with the single, causing a single point of failure. 
&gt; Struct (a value) and struct type are different term I know, what's the problem here. I don't the article messed them up. The terminologies used in the article is consistent with Go spec.
you mean like, wget?
After having tried to make a small but runnable example to reproduce the issue and failed, i did further investigations and it seems to be coming from my tests. Specifically from the fact that `httptest.ResponseRecorder` seems to contain the response from any early iteration. I am using testtables where I iterate through each testcase and make a unique request and make assertions. Preview: https://gist.github.com/rugwirobaker/0064a192ad7f189efab77ce61256ba7b
Recording here https://www.youtube.com/watch?v=B5oQnECDJ8g
This is no more an acyclic graph.
Socket.io adds a lot of magic sauce, so I would say no. https://github.com/googollee/go-socket.io
that actually does look more like it, not a huge fan of code generation stuff but I guess it has its merits over reflection based, thx! 
But... Distributed! 
The README mentions [a repo](https://github.com/nebulaim/TelegramAndroid) containing the app you should use.
Go has automatic garbage collection, which means that the lifecycles of local values is not strictly scoped to function call. on a related note, 'scope' defines where an identifier can be used. golang has lexical scope, so you can only refer to an identifer declared within a function only from within that function , however the value that the identifer refers to may outlive it's identifier (return values are an example of this) and may be referred to by different identifers in different scopes. Here's an example package main import "fmt" func foo() *int { var i int i = 30 fmt.Println(&amp;i) // prints some address return &amp;i } func main() { var j *int j = foo() fmt.Println(j) // prints the same address as above } Here the identifier `i` within the function foo can only be referred to within that function; however the value that `i` points to is returned and then assigned to `j` within main, and this identifer `j` can only be referred to within main. However it holds the exact same value as the variable `i`
Thanks -- you're right of course. Not the right use case for gob.
I think the way gob works is incredibly inefficient for these one off encodings as it's just not meant for that, like almost two orders of magnitude slower than JSON or msgpack on my data. I figured it'd perform "fast enough", considering it's a much more convenient way of serializing things for me. Your suggestion of not allocating a `bytes.Buffer` was a slight improvement though!
Do you need to accomplish anything? Or just explain? If it's just explain, then why not utilize go's interfaces? Explain directly how they are being used. Here some resources https://medium.com/golangspec/interfaces-in-go-part-iii-61f5e7c52fb5 https://research.swtch.com/interfaces https://www.golang-book.com/books/intro/9 https://www.youtube.com/watch?v=83J256zByHA https://github.com/golang/go/wiki/CodeReviewComments#interfaces https://play.golang.org/p/pv7o3G32I1 https://itnext.io/interfaces-in-golang-f1aea1ba31cb 
Accessing a single data structure concurrently has never been considered a good practice but has often been thought of as unavoidable. Go Proverb #1 "Don't communicate by sharing memory, share memory by communicating." -- Rob Pike https://go-proverbs.github.io
I have mixed feelings about DI containers. They can be helpful in larger codebases. That being said I agree that they‚Äôre not necessary, and if you can‚Äôt test your structs you‚Äôre doing something wrong at a higher architectural level.
Gorilla's Websocket can be used in a Socket.IO transport, but Gorilla itself does not implement the transport or the layer above the transport. For that, you will need to seek out other package. 
What if you create a new recorder for each test?
i think the benchmark does JSON requests? maybe chi uses a faster library for JSON unmarshalling
Chi is just a router.
Duly noted, good feedback.
I thought zookeeper used atomic broadcast, or ZAB as they call it, and etcd uses raft for consensus. To my knowledge there's no widely adopted open source paxos implementation and having it available as a library would be really cool.
Not sure what you mean by not distributed? Regarding development, check out the activity on github... https://github.com/nats-io Features are in development around multi-tenancy, security, permissions of routed data in clustering, gateways between clusters, and k8s operators. These'll be announced in December at KubeCon/CloudNativeCon.
i guess some of them use intelligent caching and or multithreading techniques to achieve better performance on subsequent requests
Not bad but I believe this doesn't actually solve your problem. Your code is just a channeled reader/writer.l using the CSV read/write methods. What you should actually try doing is reading from an actual file into a concurrent solution.
I don't see how the router plays much of a role in these tests. Won't most of the time be spent on querying the database and serializing the response to JSON?
it looks like development has picked up again, but last time I checked commits seemed to have completely stopped which was around the time I saw a notification on their website saying they got bought by some company. There was more than a month of zero commits to the core project around July [https://github.com/nats-io/gnatsd/graphs/commit-activity](https://github.com/nats-io/gnatsd/graphs/commit-activity). Seeing commits completely stop when seeing an announcement that they got bought is a pretty bad sign when deciding to try out the project. Regarding not being fully distributed, that refers to NATS streaming. It relies on warm standby backups to achieve high availability, which means it has a single master ([https://github.com/nats-io/nats-general/blob/master/architecture/ARCHITECTURE.md#nats-streaming-high-availability-options](https://github.com/nats-io/nats-general/blob/master/architecture/ARCHITECTURE.md#nats-streaming-high-availability-options)). So you can only scale by partitioning channels, but this [https://github.com/nats-io/nats-streaming-server#partitioning](https://github.com/nats-io/nats-streaming-server#partitioning) says "***Note, this feature is incompatible with Clustering mode. Trying to start a server with Partitioning and Clustering enabled will result in a startup error."***
As far as I briefly checked, yes, that would be the correct procedure 
https://twitter.com/carlisia/status/1044658739834368000
So you want to criticize a super fast messaging system without supporting information.
go‚Äôs interfaces come to mind...
As opposed to you presenting the opposite? I find the level of downvoting without comments attached in this thread pretty interesting and very telling, i.e. even if I went into detail it would be for naught. Our use case is a minimum of millions of messages across dozens of clusters and exponentially more sources/consumers per day, where loss of a single message can not be tolerated and persistence is required. Streaming is not up to that task yet, at 'enterprise grade'.
Thank you for the feedback, I forgot that \`writer.Flush()\` return \`error\`, and I did not know about \`ctx.Err()\`. Yes, that's why I added the context to stop it on interrupt. do you have an idea on how should structure that code, should those functions be structs \`ChanneledReader\`, \`ChanneledWriter\` ?
Is this sensible as rows in a csv file are normally ordered so concurrency will mess this up? If it's just a database dump, then cool stuff!
Thank you, but can you explain more what you mean? right now the code does read from a reader into a channel, then I'm using that channel to feed the workers in the \`processor\` function 
Your comment came across as unfounded trolling because you provided no evidence (anecdotal or otherwise) to support your claims. Thanks for providing more information; NATS Streaming might not be good for that usecase. Good to know.
there is no go/prefork/pg test in that list, this isn't a scientific method obviously, otherwise they'd change only the framework, not the database driver. You cannot conclude anything from this, if you believe you can then you are ignorant.
Well see, I for one like the decisions they've made so far - especially the vgo stuff; which I find quite novel. I'll reserve judgement on their ability to deliver something that won't mess it up.
I second this. If you want your project to gain popularity, let visitors know what it is, what it is for, how it works, and why everybody will want to have it!
Yep. And my concern is with the feeding to the workers part. You do this via pushing to a channel. Which is not traditional to how you would us a reader and writer. I am away from my computer at the moment but I can give this a crack and show you my thoughts on how you could handle a CSV using goroutines. However, just to confirm, did you want the write part or the read part to be concurrent?
Thanks. Subscribed.
&gt; Seamless light-weight preemptive concurrency across cores I was under the impression that goroutines were still not preemptive. Has that changed?
Yes, Chi is just a router. But in this benchmark this name represents complete setup with Chi router. You can inspect source code [here](https://github.com/TechEmpower/FrameworkBenchmarks/tree/master/frameworks/Go/chi).
yes, exactly it's a database dump, so the order does not matter at all. thank you!
maybe he means preemption by the scheduler to keep many goroutines active
Man that sounds super interesting - thanks in advance for the link :) Are you learning this from any specific resources or just making it up as you go? I've always been interested in writing something similar.
awesome, I would love to see your approach. I'm new to go, so I'm not sure what's the right way of doing things. I mainly want the processing to happen concurrently. and the data to stream from the input, get processed I have to make network request for each row and wait for response so I would like to read more rows read while waiting, then stream the output to the writer. Thank you so much again &amp;#x200B;
They can totally share the same versions of their common dependencies - I'm more concerned about potentially using SomeLib in other projects and it's version might be different to that of ApiProject.
If it works in Ada, then it would be an language easier than Go to make it work in. I'm not an Ada expert, but from what I do know about it, it seems plausible. (It doesn't seem to have assembled all the pieces correctly, but it has a lot of stuff in it that presages Haskell and Erlang and some of Rust too.) It works in Haskell too, but even there it took several iterations to get there.
Source for second one on list is [this](https://github.com/TechEmpower/FrameworkBenchmarks/tree/master/frameworks/Go/chi/src/chi) I assume? It uses couple of tricks such as faster json decoding/encoding using easyjson and also uses prefork. Better off naming it "chi-easyjson-prefork" instead of just "chi". 
thank you, I haven't mentioned this in the post, but I actually have to make a request for each row and wait for the response. so you think that's a valid way of doing it? Thank you for the suggestions, I did not know that about concurrency over resources 
&gt; Making the language easy doesn't make software engineering easy! That's the exact argument that critics make against Go *as a language*. Why would you expect it to resonate with Go programmers? (I'm genuinely asking.)
ye and the default chi one uses easyjson, the other 2 use 2 other json libs, all 3 are much faster than builtin json
Why don‚Äôt you just have two repositories?
Ctrl+C, Ctrl+V instead of Type T: A little copying is better than a little dependency. Type T is way too complex for me, What with concurrency and next decade's GC. So I Ctrl+C, Ctrl+V like it's 1960, Free from theory and academic wankery.
Ctrl+C, Ctrl+V instead of Type T: A little copying is better than a little dependency. Type T is way too complex for me, What with concurrency and next decade's GC. So I Ctrl+C, Ctrl+V like it's 1960, Free from theory and academic wankery.
Any update on when the v2 release candidate will be released?
Way to necromancer a 4 month old thread. It's already released :D
Also some documentation on where it gets its blacklists and how it keeps them up to date.
Take a look at grafana for example. https://github.com/grafana/grafana They just have a "public" directory
Just to highlight real quick: &gt; We only need one response per company (or per department for larger companies). If you aren‚Äôt the right person, please forward this onto the right person at your company.
[It's not fully preemptive](https://github.com/golang/go/issues/11462) (at worst it will preempt on next function call) but in normal use it is hard to get to the case where one goroutine will block your whole program.
ZAB is the protocol. It‚Äôs contents include the transaction id, among other things. This protocol is basically the agreed upon message which each node agrees to provide one another. Paxos is the algorithm used to determine when a message is considered ‚Äúpersisted‚Äù or ‚Äúsaved‚Äù. This happens when ‚Äúquorum‚Äù (the total number of nodes in a cluster divided by two, plus one) have received the message and agree to save it. It works. Lots of critical apps depend on ZK and it‚Äôs algorithm implementation (e.g. Kafka, Solr) and those are very popular. So consider ZooKeeper to be the man-behind-the-man :-) But, in my opinion, ZKs Paxos implementation can be improved. Actually, there was an ex-NASA Engineer that did create a Go project that implemented Paxos but in a unique way, using append only logs. Can‚Äôt recall the project. Would love to see how that works and is implemented. 
And you are right about etcd using Raft. I raised in context of considering apps that use consensus algorithms. 
There as a video you may or may not have seen ([https://www.youtube.com/watch?v=HQYsFshbkYw](https://www.youtube.com/watch?v=HQYsFshbkYw)) that is interesting, you could use it as a starting point something doom-like (works more like duke-nuke tho). As for something quake-like I don't really know of any good resource. Mine is fairly originalish (I think) (I haven't seen anything that does world-space clipping) (btw: it could be easily modified to be software-only it would just be silly to not use gpu at all). I would suggest you start by writing a ray-caster (wolf3d style game) there are plenty of tutorials on how do that (here is a random one: [http://www.playfuljs.com/a-first-person-engine-in-265-lines/](http://www.playfuljs.com/a-first-person-engine-in-265-lines/)) and then work your way up. If you don't already have it you will need a extensive knowledge of Vector Math (rotation is important, so write this down: [https://www.siggraph.org/education/materials/HyperGraph/modeling/mod\_tran/2drota.htm](https://www.siggraph.org/education/materials/HyperGraph/modeling/mod_tran/2drota.htm)) And Probably some matrix math is good (matrices particularly if you want to use openGL). (btw: this is all if you want to do software rendering using old cpu methods, if you want to do a game that looks like quake or doom just learn openGL or Unity and have fun) Happy to answer any questions you have.
"This content is neither created nor endorsed by Google." üòÇ &amp;#x200B; (yeah yeah, it's the standard forms disclaimer - it's just funny that in this case the disclaimer is wrong)
`panic` needs one argument btw.. So more like `go panic(nil)`.
Yeah this is my bad. 
But its more about that you can't catch a panic with defer if it's in an other goroutine ;)
v2 has been merged into master. So yep! 
One nasty trick is `for {}`. But I doubt to see this in real code.
It‚Äôs a shame Go is on its way out :(
Does that really not switch out? I know in Java any backward branch is a potential interposition point where the runtime can stop the program and do things (like GC)
Well you can fuck up some condition inside it easily enough. But then you could argue it would be at least easier to spot while debugging. There is also option to manually yield if you really get affected by it
I did and it worked. Thanks
[I already linked that bug once but here you go](https://github.com/golang/go/issues/11462) apparently it "only" switches out on function calls. Now normally you probably won't even notice as other goroutines will just run on other core(s)
\&gt; **Making the language easy doesn't make software engineering easy**! "Easy" is the wrong way to categorize Go. Go is simple and minimal. Generally it's only as complex as the domain you're programming in (hand wave). If you look at engineering from the perspective of large teams that are constantly on-boarding new people; simplicity and minimalism become very important characteristics with respect to making the engineering effort "easier". \&gt; **intentions would be clearer with immutable types** Perhaps. This hypothesis would logically pit 'immutable types' against other solutions for declaring intention, such as using a value receiver or getter methods - which are already in the language and get you a long way when you need them. To be honest we don't have the data around immutability to determine the cost/benefit of implementing it into Go. Some say you can't live without it (ahem, Rust programmers), others are living without it just fine (most Go programmers). At the end of the day I do think we would do well to dispense with the ambiguous, mutable, terms "easy" and "hard" when talking about programming languages and engineering. They are almost meaningless adjectives in this context. Finally I appreciate the project! It generates some good discussion :) 
Go is fast enough in most cases. Worry about io and how to cache instead
&gt;In idiomatic Go programs you won't see a lot of mutexes, condition variables and critical areas protecting shared data. In fact, you probably won't see much locking at all. In any sufficiently complicated program I've found many packages that need to `import "sync"` if they want to implement goroutine-safeness in a ~~sensible~~ comprehensible way. Programs that use channels instead of mutexes (spoiler: &gt;!channels are just mutexes under the hood at the moment!&lt;) are still subject to deadlocks or runtime panics when trying to write to a closed channel or coordinate who closes it.
&gt; The fundamental issue here is that both Python and C++ try to solve this problem on a library level, when it really needs a language runtime solution. Yes, this is exactly correct. It even accounts for why JavaScript‚Äôs await is slightly less annoying than Python‚Äôs: because JS is single threaded at the language level, and there‚Äôs only one runtime event loop, you can just create a Promise in the middle of some synchronous code and the runtime will figure it out for you. It‚Äôs still not ideal, but it‚Äôs much better Python. 
I agree 100%. I can't remember who exactly said it but one of the presenters at gophercon mentioned that a sign of more advanced Go programmers is using `mutex`s where appropriate instead of using channels for everything.
[removed]
There are no strict requirements except this project has to be enough hard to be done in about 4-5 months and can be described in 30 A4 size papers(as my university demands to have a written copy of how the project has been done).
No, it's like a real-world project as the graduation work
[removed]
If I wanted to read this I would subscribe üòâ
Take look at this [https://github.com/golang-standards/project-layout](https://github.com/golang-standards/project-layout) I believe the ```Web``` directory is what you're looking for.
I did something similar with a small project I was working on. I used 3 git repository and docker to build it. * Angular frontend repo * Go backend repo * Build repo which had the other two as git submodules and the docker file and makefile You can do it without docker and just build each project and output to the correct folder. I thought it was a good approach as I could use the makefile to build different releases (dev, testing and release) easily without too much hassle.
That (generated) API is for manipulating Spreadsheets, the downloading is a separate protocol. &amp;#x200B; [https://stackoverflow.com/questions/33713084/download-link-for-google-spreadsheets-csv-export-with-multiple-sheets](https://stackoverflow.com/questions/33713084/download-link-for-google-spreadsheets-csv-export-with-multiple-sheets) &amp;#x200B; To download a specific sheet as a CSV file, replace {key} with the document's ID and {sheet\_name} with the name of the sheet to export: r/https://docs.google.com/spreadsheets/d/{key}/gviz/tq?tqx=out:csv&amp;sheet={sheet_name}
if you just want the values of the fields, you could use the REST API for google sheets and just get it in json. Otherwise the quickstart guide for the google sheets api gives you all the golang code you need to read data of a sheet, the biggest part of it is just getting access to the sheet, reading it is short. See [https://developers.google.com/sheets/api/quickstart/go](https://developers.google.com/sheets/api/quickstart/go)
:-( 
Remember the Go proverb: &gt; Channels orchestrate; mutexes serialize.
A **big** plus for mentioning essential and incidental complexity. They are mentioned way to few, yet they are at the essence of everything.
A **big** plus for mentioning essential and incidental complexity. They are mentioned way to few, yet they are at the essence of everything.
D as close Channel will return default value and false. So until the channel is closing the default will execute and on closing the wait group will be done and main routine will exit.
Excellent. üëç Indeed the break does in fact not break the loop. If a break is desired a label shloud be used. Well done. üòä
I think it should work, yes. Adding a go.mod file and then running go get in same directory should update go.mod and go.sum appropriately. That said, other commands like `go mod tidy` will remove all such dependencies from the go.mod as they aren't really imported in any go code. I think the suggested workaround is to also create a `tools.go` or `deps.go` file besides go.mod file and add unused imports there like: ``` package main import ( _ "unused-import" ) ``` That said, `go get` when run inside a module directory will not install the package to GOPATH as it used to. It'll instead download the code and store it as cache somewhere else inside GOPATH so you'll need to update your tooling to understand the new cached locations. Also, if you run `go get` from a directory with no `go.mod`, it'll download the package as go get normally would without go modules.
I have seen that video, I'll have to give it a rewatch! Definitely interested in the old methods, I've written a basic raycasting wolf clone in C# before so I think it's a good starting point - I'd just love to get my head around the old tricks that the likes of Jon Carmack implemented back in the day. Thanks again for the tips and links!
Perhaps goplugins https://golang.org/pkg/plugin/ are suitable for your use case? Unfortunately only available for linux/macOS.
You want to write the "scripts" in Go as well? &amp;#x200B; If that's the goal there's no way around compilation, since Go is not interpreted. Either you compile the "script" after writing it and build/install the binary which is then called by your core, or you compile just in time with \`exec.Cmd\` and \`go run\` as you said. &amp;#x200B; &amp;#x200B; To parse / build go without os/exec you can use the [https://golang.org/pkg/go/](https://golang.org/pkg/go/) package, but depending on your use-case that might be overkill, also I don't see how you could run the resulting binary using this package. &amp;#x200B; The closest thing I know is something I've seen in Buffalo. [https://gobuffalo.io/](https://gobuffalo.io/) supports "[grifts](https://gobuffalo.io/en/docs/tasks)" which are small go-scripts, but in their use-case that's also triggered from the command line, and involves compilation. But it could be a starter to go and check that source-code, since it's related to what you want.
I was hoping to be able to run Go-scripts, since the legacy-version of the application uses PERL. Thanks for gobuffalo's grifts, I will checkout their approach to the problem.
Used by Hashicorp: https://github.com/hashicorp/go-plugin
Nice! Besides being fast, chi is a great piece of software. It's design makes it easy to compose modular apps that need a REST interface, having something that allows me to build things and that is easy to maintain is pretty important for me.
I will check it out, thanks!
Depends what your scripts need to do, how about lua https://github.com/Shopify/go-lua
Huh. I didn't realize Awesome Go had a section for that. I'll have to see about getting [my language](https://www.github.com/DeedleFake/wdte) added to it.
This might be useful for you: [https://github.com/mattn/anko](https://github.com/mattn/anko) It's scriptable interpreter written in golang with little more lightweight syntax similar to Go. You can easily run anko scripts from runtime like this: &amp;#x200B; func main() { env := vm.NewEnv() err := env.Define("println", fmt.Println) if err != nil { log.Fatalf("Define error: %v\n", err) } script := ` println("Hello World :)") ` _, err = env.Execute(script) if err != nil { log.Fatalf("Execute error: %v\n", err) } // output: Hello World :) } &amp;#x200B;
i'm unsure what your use case is... why isn't using `os/exec` to call a subprocess a good solution? in general, if you're calling another program, that's what you'd do. the `os/exec` interface gives you plenty of control over an external program. the only problem with it is the fact that like a call to shell, the result will by stringly typed and have to be converted into whatever internal types you need.
Soon everything will have to be suitable for modules..
first you &amp;#x200B; \&gt;go get [github.com/semihalev/sdns](https://github.com/semihalev/sdns) &amp;#x200B; THEN you run go build :D
The whole idea of 'scripts' seems irrelevant here. You are simply trying to execute other programs (no difference if it is a "script" or a compiled program) from within your program. You can use the same 'exec' functionality to call external programs.
Not really, if you want you can use `interface{}` and then a type switch to iterate values A and B. You could create a named interface that holds a function common to both A and B, but as soon as you'd need fields or something like that from A or B, you're again going to have to cast back to it's concrete type.
Having `mapA, mapB` of type `map[T]U` the non-generic code is just u := map[T]U{} for k, v := range mapA { u[k] = v } for k, v := range mapB { u[k] = v } How many different map types your program needs to handle? If that's unknown in advance, you'll have to use `reflect`.
I will check it out and see how this would fit in. Thank you!
yeah, those scripting engines from awesome go have some decent options, but I was hoping to stick with go. Thanks thou!
throw them a pull request, usually awesomelist-maintainers are quick to respond.
Reflection is only one way to create universal generic function, but its signature probably will be like func MapAUnion(map1, map2 interface{}) (interface{}, errror) so you will lose type safety
Why do you need write your scripts exactly in go? &amp;#x200B; Use any embeddable language: lua, some form of lisp. For lua it would literally take couple of lines + library [https://otm.github.io/2015/07/embedding-lua-in-go/](https://otm.github.io/2015/07/embedding-lua-in-go/)
Thanks, I added a "why" to my post. It would be convenient for our customers and colleagues to not have to learn yet another programming language.
I saw the quickstart, but it assumes you know the columns/rows you want and I don't. I looked through their docs, and I didn't see anything analogous to getting the whole sheet, just like exporting does.
&gt; https://stackoverflow.com/questions/33713084/download-link-for-google-spreadsheets-csv-export-with-multiple-sheets I tried that; it doesn't seem to work with OAuth2 (I get 401 Unauthorized when I try it).
Lots of good replies, obviously it comes down to _what_ you're doing. You say customers write scripts, and now you expect them to move from writing them in PHP to Go? That's a bit switch. If they're very technical and available then it'll be fine, if they're not then you might want to keep your current approach - even their existing scripts. But of course it's hard to know what to suggest since you don't really limit the scope of the scripting. Are they gluing together input/output? Are they writing full-on pipelines? Or something else entirely?
You can take the 'serverless' approach. Pickup any serverless library implementation, define an api, have your clients upload tar archives that are run via serverless infra that talk to your core. PS use a hammer when you need to work with nails. Using something like lua/lisp is preferable over using go in this context for more reasons than one. Worst case write your own DSL in JSON.
at the beginning I try to avoid this, especially when a package is not stable yet. if we would have to rewrite produced scripts, which there are a lot of, this could be a terrible. But yeah, no body forces me to update, but if there ever is an incompatibility with go, I am screwed.
hi steve! it is a big switch from _PERL_ to _Go_, i must provide a way to still run the legacy stuff, running shell commands, so they aren't forced to but encouraged. Scope is input/output, there are some invoicing solutions processing data in the application and creating new data (namely bills) for example. I am aware that it is hard for you guys to give advice, but it already was very helpful! 
Thanks! I will think this over.
goes for both rest and the quickstart example: if you define a range you can use A:Z for example, so it should take all rows and you only have to care about the columns. If you know how the spreadsheet is structured, for example assuming you dont have hundreds of columns, it has a table with headers in row 1, you can just look at the first field of each column, if it has an entry you take it into to csv if not dropt it and all following columns. If you don't know the general structure yeah you are kind of screwed there. You can also get a row and column count by using [https://developers.google.com/sheets/api/reference/rest/v4/spreadsheets/get](https://developers.google.com/sheets/api/reference/rest/v4/spreadsheets/get) but i found that it also has the problem of including empty rows and columns on both ends.
If you're changing things right now, and you're not providing legacy compatibility it would seem like you, and your customers, will need to rewrite anything at least once! Of course it might be the pragmatic solution is to go for something less-perfect, but which would allow you to avoid any rewrites. Still you have some options to explore, and no doubt you'll quickly decide which approach is best.
Link: r/https://muzzammil.xyz/dsongo :)
Don't know about go mod, since this predates it, but https://blog.digitalocean.com/cthulhu-organizing-go-code-in-a-scalable-repo/
The app is PHP, eol ZendFramework1 which runs only on php 5.6 which is eol 2020 and dragged along by redhat till 2024. The scripting is done in PERL, expect a couple of hacks where a perl script calls some other script. When I joined the team everything was too fare gone to switch to anything but perl, but now we will at least try to offer other options.
The Internet never failes to amaze me
It seems like you're just looking for a map of interfaces, rather than concrete type A or B. Something like: [https://play.golang.org/p/ATTVAW6JJAh](https://play.golang.org/p/ATTVAW6JJAh). Ideally, types A &amp; B would satisfy some specific interface, rather than just the empty `interface{}`, like: [https://play.golang.org/p/P\_AUakjcI93](https://play.golang.org/p/P_AUakjcI93).
General tips from DevOps guy: 1. Make app instances expendable - losing one should not disrupt processing 2. Make sure app exits gracefully on SIGTERM and does this in a predictable time 3. App should have health check of some sort 4. Keep all data that requires persistence outside the app - storage, redis, DB, what have you 5. Make sure you know limits of your DB, redis etc - how many concurrent app instances they can handle
https://12factor.net
Note, of course there's the possibility that Go is holding onto `*Foo` references because it thinks something else is using that instance. If that's the case, I need to understand what that is, so I can track it down and remove it. With that said, I don't *think* that's happening.. but you never know, bugs and all.
Despite Go's garbage collector being REALLY fast, it avoids doing so as much as possible. Are you running out of memory? Are you sure there's no reference to *Foo anywhere else? A channel or goroutine perhaps. There is nice article from Cloudflare about Go's GC configuration. Perhaps it might give you some ideas: https://blog.cloudflare.com/go-dont-collect-my-garbage/ Here's a tutorial on visualizing tracer results on browser: https://blog.gopheracademy.com/advent-2017/go-execution-tracer/
Despite Go's garbage collector being REALLY fast, it avoids doing so as much as possible. Are you running out of memory? Are you sure there's no reference to *Foo anywhere else? A channel or goroutine perhaps. There is nice article from Cloudflare about Go's GC configuration. Perhaps it might give you some ideas: https://blog.cloudflare.com/go-dont-collect-my-garbage/ Here's a tutorial on visualizing tracer results on browser: https://blog.gopheracademy.com/advent-2017/go-execution-tracer/
[removed]
You can use the log package in the standard library, which logs to stderr by default. You can then redirect stderr to a file. If you don't want to log to stderr you can use log.SetOutput() and give it a \*File object as describe in Section 1 here: [https://logmatic.io/blog/our-guide-to-a-golang-logs-world/](https://logmatic.io/blog/our-guide-to-a-golang-logs-world/)
&gt; `func (c *Ctx) GET_TestTest()` serves content for `GET /test/test` I'm personally found of automagic routes based on naming conventions like that. How do you do this in Go? Do you use reflect on every request or do you scan for handlers at startup and mount them somehow? I ask because reflect is not known for being fast but I wonder if it is fast enough for most cases. I like many aspects of this solution! Thank you for sharing! 
Lol
I have worked on several seemingly similar projects in the past, using a number of different core and scripting languages with various success and many frustrations. I found that I had to answer a bunch of requirement questions before I could choose, here are a few off the top of my head - 1. What do these scripts perform like? 1. Are the short lived single task transformation jobs? 2. Do they go out and collect information from remote sources? 3. Could the be cpu intensive and require resource mgmt? 4. Can you separate them away in containers? 5. How much data goes in an ouy? 6. Do you need to control how many can run at a time? 2. How do they interact? 1. Can these scripts call back into your core? Maybe for configuration or enrichment? 2. Can these scripts call anything else? 3. Are these clients running their own scripts on their own servers or are you hosting third party code on you servers? 4. How often will these scripts need to updated? 5. Who will update / debug these scripts when changes happen? 6. Is there a set protocol for input/output from these scripts? 7. Could you just host them like cgi and use 3. How sophisticated are your clients? 1. Do they already know go? 2. Could you allow them to run these scripts in their language of choice? perl/python/node/... 4. About the execution/dev environment? 1. Is the go toolchain not available? 2. How will these scripts be developed? 3. Are you going to provide a gui for testing/editting? In my past experiences, expecting the end-clients to write python/lua/php/js rarely worked out, but our internal sales engineers could generally adapt and delivery all manner of complex custom logic as scripts, and they were very happy to. Most clients wanted to do the same things, so we provided reference apps/scripts with simple variables/config parameters. We usually ended up having to expose an api from our core to the scripts, for config, data persistence and scheduling. &amp;#x200B; &amp;#x200B; &amp;#x200B; &amp;#x200B;
Thanks, I'll investigate with those links! re: &gt; Are you running out of memory? Are you sure there's no reference to *Foo anywhere else? A channel or goroutine perhaps. I have, yes. I'm hoping those links will help me analyze how a specific reference is being used. In general I need to learn debugging techniques so I can understand the best way to design these data patterns. Especially in cases where I'm unsure if a pointer is better, vs passing by copy (non ref). I imagine with 100mb structs a pointer is simply needed, but it's not just a struct, but a struct of other structs and such. In total equaling roughly 100mb. So hundreds of structs per 100mb file, and if they're all points it's.. concerning. Hard to say, but I need to have a better understanding on the specifics here. Starting with your links. Thanks!
It's simply not possible in go unless you sacrifice type safety.
Reflection is a bad idea in normal runtime, but at startup if you're building routes once it isn't an issue.
Fully agree. This is why I avoided it in the past with Go but my mind was blown today with the idea of using reflection only at startup to mount routes. On practice, most web apps end up using reflection anyway to (un)marshal stuff. But it's good that we can avoid it for routing.
Generally I would suspect reflect on a route to mean you'd add a couple ms to something that's taking a few hundred ms, so I wouldn't be very concerned about losing some performance in this situation. As you already mentioned, if you're marshalling and unmarshalling json, you're already using it and so is most other web application.
did you request the scope you need for this? (I don't know offhand which it is, but that sounds like a potential thing to check)
Thanks!
Yeah. it's perfect match!
&gt; "cooperative with hidden yield points" that's *basically* what preemptive is... just that preemption point is forced on (usually) timer if thread takes too long, instead of waiting on the "right" one like Go. It is a bit weird that it doesn't have it especially considering low latency is what they are targeting but honestly "just bump up maxprocs and let OS handle it" is much simpler and in 99% of cases good enough solution
&gt; that preemption point is forced on (usually) timer if thread takes too long, instead of waiting on the "right" one like Go That's like saying "garbage collection is basically manual memory management, it's just that it's done automatically". The whole point of the distinction between preemptive and cooperative concurrency is that the former can be halted anywhere (except in critical sections), while the latter can *only* halt at yield points. Whether those yield points are explicit or not are only a matter of usability for the programmer, it does not change the important properties of both models. In a preemptive system a selfish thread cannot run away an monopolize system resources, in a cooperative system it can.
&gt; I think that there has to be an elegant solution and I oversee it, because I am not a go expert. No, you aren't really missing anything. There are other solutions, but it's debatable if they are more elegant. Either you throw type safety out the window, or you duplicate code. Under the hood, the C++ compiler (more or less) also just duplicates code, so in practice, doing that duplication manually with copy/paste instead of automatically with a compiler isn't all that different in practice. If you
I created this tool in order to generate Go types (structs and so forth) from JSON Schema schemas. For example, this is useful if you have a project that uses JSON or YAML to express configuration or perhaps models stored in a database. This is inspired by Kubernetes' use of JSON Schema (via Swagger/OpenAPI). For example, a schema such as: ```json { "$schema": "http://json-schema.org/draft-04/schema#", "id": "https://example.com/Example", "type": "object", "required": ["myString"], "properties": { "myString": { "type": "string" }, "myBoolean": { "type": "boolean" }, "myArray": { "type": "array", "items": { "type": "string" } } } } ``` ...will be turned into: ```go // THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. package test type Example struct { // MyBoolean corresponds to the JSON schema field "myBoolean". MyBoolean *bool `json:"myBoolean,omitempty"` // MyArray corresponds to the JSON schema field "myArray". MyArray []string `json:"myArray,omitempty"` // MyString corresponds to the JSON schema field "myString". MyString *string `json:"myString,omitempty"` } ``` The generator emits marshaling and unmarshaling code that automatically enforces schema validation. This part is a work in progress; not all validations are implemented yet. However, the basic functionality is there. 
Nice. It looks like it will be pretty solid.
How is the performance if you remove this cache? Let the operating system handle cache the read file in memory. I would work on deserialization speed if that's too slow, since that could be optimized in a number of ways.
Looks great, thanks
Perhaps you should invert your problem. Instead of trying to write a script that runs in the core process, perhaps you should offer an API that could be used by an external process. If you offer a "Go SDK" for your project, given how fast Go compiles, they can run whatever they like from an external process, and they can use real Go. It may take a bit to get going but once you get to it you'll find there's a lot of ways to offer relatively efficient API level access to a lot of things very quickly, with something like gRPC or any number of other options. The major counterindication would be if you're routinely moving gigabytes and gigabytes of stuff around. But if they're just moving this and that here and there, and absolute performance isn't the top concern, this may be the best choice.
What? It is?
When Go will release memory back to the OS is actually sort of a complicated subject, but how it does this may not show up in htop. If you can read memory statistics (and you should, perhaps through net/http/pprof), you want to look at 'HeapReleased', which is how many bytes have been released back. However, on at least Linux the memory returned to the OS this way is unlikely to reduce your process's reported virtual size (and it may or may not reduce your resident set size, depending on what else happens). In general, one thing to watch out for with memory usage is taking slices of larger objects (and sometimes pointers to fields of structures). This keeps the entire object alive. One common unfortunate pattern with parsing things is to read in big buffers or strings, parse through the buffer/string, and wind up capturing very small sub-slices and sub-strings as part of your parsed data structure. This will keep the entire original buffer/string alive, possibly much to your surprise.
&gt; In general, one thing to watch out for with memory usage is taking slices of larger objects (and sometimes pointers to fields of structures). This keeps the entire object alive. Is this a leak? Can you give me a name or a link for this for further reading? I'm not clear on why this is, based on your description at least.
I‚Äôm a big fan of Go but it has taken a huge hit in popularity over the last 18 months. Likely due to stagnating development. Google is starting to move away from it internally as well which means fewer updates in the future. It was a fun ride but Go is just not destined to be for the long term :(
You should add to the readme a succinct description, how it compares to other frameworks, and why/when someone would want to use it. 
Nice project. I‚Äôm a big fan of Go but it has taken a huge hit in popularity over the last 18 months. Likely due to stagnating development. Google is starting to move away from it internally as well which means fewer updates in the future. It was a fun ride but Go is just not destined to be for the long term :(
Wtf 
No, it is not. You still, 99.99% of time do not have to do anything to have "near-preemptive" behaviour, that's different from "I have to rememeber to yield every time. There is middle ground between "completely cooperative, you will be forever stuck" and "completely preemptive, fuck your jitter and realtime performance Also the worst case is not "it will be stuck there forever" but "it will be stuck there till next GC". IIRC there were even implementations of it, just that they decided that single digits performance degradation are not worth covering some edge case. 
that hit tho &amp;#x200B; &amp;#x200B;
When you have a thing that it makes sense to hang the method off of. 
[removed]
That's my thought too. Getting the data is only one part but what you did with it and how you store/compress/index the data is more interesting. Using that data what can you tell me about the brand perception of taco bell for instance? How fast can you make an algorithm to search through it like Google? 
good!
Wow, what the fuck just happened? So many unanswered questions...
The reason they‚Äôre elsewhere is because you only have to compile them when they‚Äôre first imported. And they‚Äôre compiled to several os/arch combinations only once. The symlinks are there mostly for the gopath/pkg dir.
AFAIK the only time it's mandatory is when you want to implement an interface. Many people like to use methods as a way of organizing code, and in Go it is also the only way to reuse a good function name. But it isn't necessary.
You are right, thanks for the input.
Ooooh thinking of it as an SDK, that's brilliant. There are actually a few usecases where we need to process a couple million of records, but for this we will likely resort to going straight to the database, and will be a separate application using the core repository. Thank you!
It depends. bufio.Writer automatically flushes when the internal buffer is full. So for throughput, you shouldn't Flush, only at the end (before Close of the file handle). If you want to minimize data loss on a crash, you should Flush periodically, with a period you don't mind to lose. And maybe call fh.Sync, to be sure. But this is against performance. 
I see. Throughput vs latency. Does this mean that you can achieve the same result by simply using a smaller buffer instead of periodically flushing?
the only problem is routing i think like parameters
Go got improvements in incremental compilation recently, that should solve your first concern. I believe it is also removing usege of gopath/pkg so that directly is useless now. If you use go mod, you can't use gopath anymore. It's a replacement. 
So many upvotes and no-one bothered to check the code? It is naive implementation and it does not work correctly. E.g. [https://github.com/darkfeline/go2-errors/blob/master/errors.go#L37](https://github.com/darkfeline/go2-errors/blob/master/errors.go#L37) \- you can't test the values like that. It makes the following code print false, where it should be true: &amp;#x200B; err1 := &amp;Error{Text: "error"} err2 := &amp;Error{Text: "error"} fmt.Println(Is(err1, err2)) &amp;#x200B; Probably the author knows this already, as everywhere in the examples no single pointer is used.
When you want to explicitly associate given functionality with a type. 
I've seen a few posts like that. It's astroturfing. Not sure who is behind it though. Reddit is full of this false-narrative stuff.
üòÇüòÇüòÇ
Why do you think your code should print true? This code prints false err1 := &amp;Error{Text: "error"} err2 := &amp;Error{Text: "error"} fmt.Print(err1 == err2) https://play.golang.org/p/IJ0Y-pRia2F Pointers are compared by pointer value, not the value of what they're pointing at. As specified, this is also how Is is supposed to behave, by shallow equality.