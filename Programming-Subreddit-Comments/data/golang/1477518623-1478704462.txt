&gt; if I where approached to write a cook book. Thankfully nobody is going to approach you to write a book with grammatical skills like that my friend.
Replying here to simplify things. I believe I sent a PM to everyone who asked for samples. PM me if I missed your post somehow.
This is a problem that I find really useful for demonstrating the power of concurrency in Go. It takes a real world problem and using concurrency it can be coded in like 50 lines of pretty easy to follow code. Your description makes it sound like you opted to not use concurrency for this. Is there any specific reason for that?
Hi Jon, this isn't my project, but one I just stumbled across.
Apologies. I was thinking you were involved since you posted it :)
Just interesting to me, that's all. :) Btw, thanks for your article I posted to from @CuratedGo earlier today.
I took the time to learn a second language and I am expressing myself in it. I consider my grammar quite good, considering.
The no-gaps rule only needs to stand if there are no crashes or issues.
Seems like a bizarre and pointless requirement but you could just use a database with an identity column. Each request does an insert to retrieve the next number. It's a terrible idea.
A similar one: https://github.com/dnaeon/go-vcr
Check out gorm. Very easy to use 
The golang one doesn't use a timer (to refill the bucket) either it also calculates on next request the only timer in the golang one is i think in the wait function 
If you're strong with SQL, this really does appear to be the way to go (no pun intended). So far I've been looking at BoltDb, but for SQL, I'd use slqx.
Makes sense. My use case has never been one where I can't afford a slight delay so it was never a large concern.
And don't forget Pandas, without a proper analog for go that's not gonna happen
Best regards. 
It would be nice if you can give further background about this requirement. I am thinking, can we come up with a composite sort of ID like server_name+timestamp which allows you to know which server it came from and at the same time indicates order. Or if you are just entering all of this data at a central DB, just use a identity column which will auto-generate increasing nos. and store them.
Hi all, I'm the author of the rate limiting code (originally written for a benchmarking utility called [yab](https://github.com/yarpc/yab)). I wanted something simple with minimal overhead introduced by the rate limiter itself, and you can see the difference in performance [here](https://gist.github.com/prashantv/26016a7dbc6fc1ec52d8c2b6591f3582). For more complex use cases, https://godoc.org/golang.org/x/time/rate is a great choice.
Go has a couple of REPLs since many years, e.g. https://github.com/motemen/gore It's even called "*Yet another* Go REPL".
Hey. I wrote this and I appreciate feedback. Both praise and criticism of course =) Or if you have any Google Cloud related questions.. I might be able to help.
For example in Java 5, "enum" became a reserved word. Therefore, there were source files that used enum as an identifier that would compile in java 1.4 that wouldn't compile in java 5.0. or higher.
Hm.. What do you mean by "no gaps" ? Does it mean that every request-id must be in-order across all the servers? So the first request to server A gets 1 and then the next request, to server B, gets id 2? If this is actually what you require I think I would just to one global counter in Redis. It's probably fast enough to touch on each request, simple to understand and implement and gives you the strongest guaranties. Only problem is that it will be a single point of failure.. Edit: Redis docs: http://redis.io/commands/incr
What's the difference with github.com/ChimeraCoder/tokenbucket which I actually use?
Communities thrive when they have effective, respectful communication between participants. This is true of the workplace, and I'd expect it is also true of free software communities. I agree with Sarah Adams' point and her action. The tone of the poster does not contribute to effective dialogue, and it speaks well of the go community that they try to promote effective dialogue. [See _Social Architecture_ by Pieter Hintjens for more detail on community building] If someone behaved like this in a workplace I'd reply to them pretty much as Sarah did: call out what they did, and then show a more effective way that they could have tactfully got to the same outcome. The post highlights the matter in discussion. This is irrelevant. The post makes a lot of what the objective truth is. This is irrelevant. These distractions highlight that the author has failed to understand the important point about tone. To reiterate: communities work effectively when people are respectful to one another. Aram needs to improve his tone out of respect to the community. The author of this complaint should revisit the thread and consider this: Sarah's feedback was an opportunity for them to improve their skills and become a more effective participant.
If someone was talking to you in broken english in real life, would you turn around to them and say, "your english is so bad I can't understand you"? If so, regardless of wether you deem them deserving of your respect, it's just rude and borderline offensive. I would hope that the people around you would say so.
sqlx might be exactly what I need. I just came across https://upper.io/db.v2/ but it only supports github.com/lib/pq
I have done a lot with BoltDB, and I find it is super useful. Where it really shined for me was with an autocomplete for cities around the world. When I initially setup my service, I used an in memory trie. It worked great on my local machine with tons of memory, but when I deployed it to a VPS, I quickly ran into the memory limits of that machine. When I switched to BoltDB it ran without issue
I agree. Although it's tempting to frame it as bad-actor vs insult to bad-actor, the real issue which I think they are trying to address is that the language used could be insulting to other people in the community. One bad deed doesn't justify lowering standards of what is and isn't acceptable. I hope the OP takes a step back and recognizes this. It's incredibly difficult trying to maintain civility in a community and often there are times when whatever is done, someone will be upset about it. Address a comment and someone is unhappy, don't address it and others will be unhappy. Whether someone would post "I'm a non-native English speaker and that comment insulted me" or not is not the point, it's whether someone might find comments that judge their language ability a factor in the value of their contributions. And to be fair to the OP, I don't think that was his intent, it was simply stating a fact but one which was less important considering what the ISIS author had been doing. He seems to be a parasite and it would be a shame if he managed to indirectly cause genuine contributors to be driven away so I hope that doesn't happen. No one likes being 'told off' but sometimes, if we leave it a day or two, we can better see the reason why, the intent behind such messages and not take it personally. Consider too the people who do the job of trying to maintain the community. It's not easy. I know, I've run a large online community for 15+ years and you sometimes get flak from all sides over the same issue. Even if we think someone has made a bad call, is it such a big bad deal that we can't look past it and think more about the intent and what they are trying to do? Using phrases like "stalking" and "thought crimes" though is pure hyperbole and is never going to help. It also does a disservice to people who've ever actually had to endure genuine stalking and harassment. This isn't anything remotely like that, by a long, long way.
I just had another question on sqlx, there is a stated requirement "if you have null fields and use SELECT *, you must use sql.Null* in your struct" Is there a cleaner way to work around this ?
It's like someone looked at SRS and thought "great, let's do the same for our programming language!". I'm glad the PHP one went nowhere. About English (I'm a non-native English speaker as well) I think this piece makes sense : http://antirez.com/news/61
Yes, I am Romanian. 
Perhaps Sarah could have toned down her message as well. It's about "language", yet it doesn't look to me as the "language" that should have been used to communicate whatever it precisely was she was trying to convey. Instead, it looks like the tersest possible template, almost set up to rub the receiver the wrong way. It's a message of condescension, ignoring the root of the problem. Ipsos custodes, if you wish. &gt; it would be a shame if he managed to indirectly cause genuine contributors to be driven away so I hope that doesn't happen. Perhaps it's not what you want to hear, but if that happens, Isis' author's actions may have been the seed, but it will have been directly caused by Sarah. Edit: perhaps Sarah should just send an apology. Sorry, message was too harsh. Please stay.
Lots of things can be "insulting to other people in the community". We all come from different backgrounds and cultures. Being part of a community is a two way street. You should be considerate of others, but you should also give people the benefit of the doubt and not look for insult when none is given, despite your interpretation of a few words. Whats more alarming is that Google and/or the Go team is trying to enforce this on something so minor.
I think I'd be a bit annoyed if I got this message from some random person on the internet based on that comment but your response is incredibly long and melodramatic. I mean... is it still a thought crime if you write it down? I guess the rationale is that as a contributor to the language maybe you could be seen as an ambassador or authority within the community and as such you need to be a bit careful about making fun of people for not speaking english well or whatever. But ultimately how many people even know you are a go contributor on reddit. My guess is very few. Seems like a non-issue.
Simple yes or no question... was the guy's english good? edit: thank you for the gold, kind stranger! edit 2: and I think I missed an apostrophe
Easiest option is to take your json and use the json to go converter to generate a struct then unmarshal ti the struct. Otherwise create a map[string]interface, unmarshal to that and then type assert shit when you need the values. Do not recommend this as it's a headache a lot of times 
I was banned from this subreddit because I stood up to the elite. They had replied rudely to my thread on the google grp when i asked feedback on my work, everyone except AG had only one message in an *insulting* tone, "the language is called Go not golang, ruby has website rubylang com yet nobody calls it rubylang. The next month the elites were referring to the language as golang on this sub reddit so i just notified them *politely* their exact words, that the language is Go not golang. They banned me for 60 days, if I use golang I'm insulted when they use it, it's fine, we aren't supposed to question it! Note: just saying, I don't harbour ill feelings towards anyone, the reddit go community has been very very helpful to me, I'm happy to be a part of it. Plus being a non-native speaker, I don't feel that projects need to be judged by their language, if anyone has a problem they can contribute! That's the beauty of open source, I've read that Linus had written less than 5% of the linux kernel!
I'm not sure the iris authors arguments would make much sense in any language. It's good to see the code of conduct is all over creating a safe space, though one would wish it had something to say about stealing other people's work as well.
I hope the downvotes are towards being disrespectful about someone being disrespectful... If the downvotes are because they think he can say whatever he wants to whom he wants, there is clearly a contradiction! 
Yippie, now golang has support for microaggressions and safe spaces edit: i a word, and in the place wrong ;)
Especially that the timer doesn't drift. It auto-corrects itself on each iteration, correct me if I'm wrong...
lol, whoever reported OP's comment is literally I a whiny bitch. PC thought police in action Edit: Thanks for the gold!
&gt; Instead, it looks like the tersest possible template, almost set up to rub the receiver the wrong way. He didn't include the entire message in his post. Remember there are at least two sides to every story.
Aside from the particulars of this scenario, respectful communication between participants is a two-way street. To the same extent you are saying people have an obligation to try not to offend people on the receiving end you have an obligation to try to not be offended. If you are so thin-skinned that you can't handle minor insults then you are a detriment to effective respectful communication because you will misinterpret things that had no ill intent as being harmful. If you then escalate such an interaction &amp; some policy punishes people for accidentally hitting your hair trigger then you have effectively chilled any communication that can happen. Codes of conduct in general fail to account for the complexity of social interactions and, typically, end up favoring people who are overly sensitive on the receiving end of communication. It can then lead to a weaponization of offense that really harms effective communication. If you say nothing you can't offend anyone so you are safe from retribution. Being afraid to speak up is not how a community works effectively. I hope you understand the point I'm making. I felt like the whole thread was very heavy on the one perspective which, I believe, fails to account for the complexities of social interactions and why it's important to accept that some people feeling offended is perfectly acceptable in certain scenarios.
&gt; rough tones have always been manageable in tech communities ... the terrible reputation that IT has suggests this is not the case. I'm glad that programming as a profession is trying to clean it's act up.
but thats not what he did. someone posted about a fight. he commented on why he couldnt understand it. no different than if someone posted obfuscated code from a third party asked your opinion of it. but to use your analogy, if someone is attempting to speak to me in my language in a way i cant understand, what is wrong with explaining to them _why_ i cant understand them? 
They both seem to be whiny. Quotes from the linked post: "stalking, thought crimes, succumbed to, !, illicit bully organization, infinite arrogance, * TRUTH * , sock puppets, silenced into political compliance, * TRUTH * , * OBJECTIVE TRUTH * , Damn right, What level of arrogance, * infractor's * , new-age practice of corporate double speak, pathetic and disgusting, refuse to kneel, coup d'état, thought police political organization vassal, pulling the strings, luring people, political correctness, propaganda machine, preaching, dark agenda of manipulation, control and deceit, fooling, controlled by a neo-puritan organization, prosecute, extrajudicial court" There's a saying in my language: "Wer schreit hat Unrecht", which roughly translates to "The louder you shout, the wronger you are."
But was it "making fun off"? I mean nowadays people get offended for everything. Where do we draw the line between a simple statement and and insult? Of the 3 short guidelines: [Treat everyone with respect and kindness. Be thoughtful in how you communicate. Don’t be destructive or inflammatory.] Which one was "violated"? It surely was not Destructive or inflammatory. Be thoughtful is very subjective. I can try all day and still some comment may be construed as alienating. Kindness and respect too are very subjective nowadays. 
~~Why did you edit out the "please" from that sentence?~~ (edit: I was mistaken, see downthread)
It's not the moderators that initiated this. It was someone else. The moderators just told Aram someone had reported his comment.
This is a **LIE**. I did not edit out anything. Look into my original post. The word "please" is there. 
Nah everyone knows that after the first warning you're sentenced to hard labor under the supervision of the SJWs that are taking over the world.
Maybe check the original message again? The sentence you quoted two posts up definitely started with "Please".
&gt; Being afraid to speak up is not how a community works effectively Exactly. And if someone isn't a native English speaker then they should not be afraid of contributing for fear that someone will jump on their language skills, nationality or color (which language _can_ be used as a proxy for).
No, it does not: http://i.imgur.com/MoyPKpg.png I will post the full message and anyone can check the DKIM signature for authenticity. 
I don't understand. Languages are just tools that solve problems. You don't expect to feel warm and fuzzy using a hammer or a toe-nail clipper do you?
Andrew Gerrand has said that Aram did not post the entirety of the message, so we don't know what else it said. We also don't know that Aram hasn't gotten previous, more friendly warnings. There's a lot we don't know.
My sincere apologies. It seems I was looking at a different draft of the message to the one that was sent out. :-(
&gt; It was just about the most bland "hey, that's not the best way to put that" warning that I've ever seen. Really? I'd have just said something like "Please don't be rude to non-native-speakers about their poor English, that's not the sort of behavior we want in the Go community". If we're talking communication, the whole "Please consider this a warning" thing makes it very ominous sounding, and pretty much guaranteed to rub people up the wrong way.
&gt; Perhaps Sarah could have toned down her message as well. What? No. It was somewhat terse and definitive, but that's because it's not an invitation to ignore the community rules (hey, look at the sidebar, they're there). Its role also isn't to educate people. Again, this is covered in CoC, and there's plenty of guides on how to behave in public groups. The message was curt, to the point, but polite and leaving options to the person who received it. It was pretty good, and a strong negative reaction to it is a good indication that the receiver is a person toxic to the community they're in. &gt; Edit: perhaps Sarah should just send an apology. As far as I'm concerned, while the list of people owing someone an apology does seem to include a new person after your post, that person still isn't Sarah. 
This whole incident is deeply regrettable. That said, I find the quote below to be the worst: &gt; Please consider this a warning from the Code of Conduct working group. I have no expectations of Aram as a member of the community. But receiving a `consider this a warning` passive aggressive bomb from someone who's supposed to represent an escalation authority rubs me the wrong way. Entirely too high-nosed of a first-level response. This — to me — casts in doubt the maturity and prudence of the working group. No offense. 
I posted the full e-mail, a screenshot is on this page. I have not received any of such warnings before. 
Sorry, I hadn't seen that yet. Thank you for posting the screen shot. It was not my intent to suggest that you were intentionally hiding anything.
Sorry, I was stuck in my reddit inbox, and hadn't seen that post yet.
Yeah, sorry, just saw that. Also, Aram has said he hasn't gotten any other warnings.
"Codes of conduct in general fail to account for the complexity of social interactions and, typically, end up favoring people who are overly sensitive on the receiving end of communication." I disagree here. Communities compete for the talent of busy people. People who have to choose where they spend their valuable time will choose nice places that are mutually respectful. We see this in the way that people choose where to live. And we see it on the internet. Before hacker news, there was a pattern of communities with the intent of hacker news being started, producing a high quality community, and then that being significantly diminished by bad atmosphere. I followed it from newsgroup to slashdot to reddit frontpage to programming reddit to hacker news. When hacker news was set up, pg was deliberate in giving it a code of conduct that aimed to keep dialogue civil. Hacker news is not perfect, but the standard of conversations are better there than on most of the internet. The hacker news code of conduct has been successful. A code of conduct sets a standard for respectful dialogue. This fosters effective+efficient communication between constructive parties. Much of the internet today is an anything-goes environment. This is a healthy baseline, because it's good for freedom. But communities that work together for creative purposes will find that they are more effective when they stick to higher levels of respect. Hence, they should choose a code of conduct. "It can then lead to a weaponization of offense that really harms effective communication" I hear you on this. We've all seen examples of people who spend more time generating comments on offense than making positive contributions. There's a toxic stereotype. However, in this case, the feedback was good feedback. Aman's comment towards grasp of English was vulgar. If I saw that exchange in a workplace I'd expect to see an efficient correction. If it was targeted at me, I'd like to think that I'd quickly thank the other person for the feedback. "Two-sided street" Yes, agree. This is an opportunity for more feedback! You could respond like this, "thanks for your feedback of me. Just to reiterate that I see what you're saying, [some development of the point that shows you're genuinely taking it on board.] To the form of your feedback, you could further strength it by [some other presentation of the point that you feel would have made it easier for you to consume]." If I'd been on the receiving end of that feedback, I'd have just been greatful for the pickup, in its current form. (I make stupid comments in writing often enough, and would value the pick-me-up without much explanation) Funny situation. In between this comment and the previous one, I took a train trip. On my carriage, some youfs with bikes were taking up several chairs with them, and walking about on the chairs. Essentially, being disrespectful to the space, and to other people in it. Thinking about this thread, I challenged them. It's disrespectful to walk on these chairs that other people sit on. After some steady prodding by me, the ring leader caved in and sat down. He did himself a favour: people who carry on like that in the world won't be able to hold down a job or build relationships with worthwhile people. This also strengthens other people in the carriage who are quiet this time but who feel the disrespect. Perhaps next time, they will feel confident to say something. Good communities are composed of people who respect one another. There is a role for feedback in "the village". 
&gt; If you are so thin-skinned that you can't handle minor insults then you are a detriment to effective respectful communication because you will misinterpret things that had no ill intent as being harmful. Uh, no. People who make it necessary to have a thick skin to survive in a community are a detriment, to both community and respectful communication. To make being "thin skinned" harmful to "respectful communication" requires quite exquisite mental gymnastics. &gt; Codes of conduct in general fail to account for the complexity You should actually try reading one before you start writing about one. Most are a result of significant amount of work, backed by both actual science and professional practice, yet somehow people feel that having an internet connection gives them the competence to say things like "codes of conduct in general fail to account for the complexity". &gt; Being afraid to speak up is not how a community works effectively. Which is the reason CoCs exist.
&gt; I have no expectations of Aram as a member of the community. But receiving a consider this a warning passive aggressive bomb "Passive aggressive" does not mean what you seem to imply it means. Yes, the expression does imply that there might be consequences for ignoring the message. What do you expect, a message implying you're free to ignore the CoC if you feel like it? &gt; No offense. See, *that's* passive-aggressive. EDIT: oh look, a mail that "casts in doubt maturity" of a group obviously working on best industry practices got gilded. This is why Reddit and IT have a bad fame, people.
Oh wow, good job for making this. I have been wanting something like this for a while since spark is killing me with how much RAM it consumes. If I may give an unsolicited feedback, don't worry too much on multiple languages support, but instead try to have these 2 sinks: HDFS and Cassandra. Because that's where a lot of big data lives.
The email as worded seems to take the position that the recipient is actively and maliciously ignoring the code of conduct. Many times we give offence without realising it. A simple email saying something can be offensive and explaining why, seems to be a much better first step than sending out tersely worded warnings.
It only has a terrible reputation because it has worked this way for decades. Had it been a real problem, the industry would have suffered and things would have changed as a result. Recently, the industry has scrambled to become more "inclusive" to attempt to counter a shortage of qualified workers. But many other industries without such a reputation face similarly skewed demographics, so I'd presume that this isn't a real barrier, only perhaps a symptom.
&gt; A simple email saying something can be offensive and explaining why, &gt; This comment goes against our community Code of Conduct, https://golang.org/conduct. The comment is not respectful, and would have been more productive just as, "I couldn't understand what was going on". Amazing, look what I found IN THE EMAIL.
Yeah, it's the next part that seems like a threat from somebody who seemingly hasn't done anything for Go other than make threats.
&gt; I could easily complain that you are violating the Go Community of Conduct because of the 'insulting' or 'demeaning' tone of this reply. You do seem pretty good with the mental gymnastics. Bye. 
i agree he overreacted. but the message he got was silly considering what he said. 
Lua is really the right tool here. You can distribute a single Lua runtime + libraries in just a few MB (even if you use the Go lib for running Lua). Any "application" code you distribute is in source form so the payload is measured in low KB. AFAIK this is how Cloudflare does some distributed log processing. 
&gt; Uh, no. People who make it necessary to have a thick skin to survive in a community are a detriment, to both community and respectful communication. To make being "thin skinned" harmful to "respectful communication" requires quite exquisite mental gymnastics. There are plenty of people that take as an offense any ounce of criticism that isn't accompanied by a small book full of compliments for their other work and with a wording so soft that pretty much encourages them to keep making the same mistake. These people are a problem. And having to walk on eggshells all around that person harms the morale of everyone around him/her, and very few people would want to contribute to an open source project when they are forced to play that kind of game. We're all adults here. The expectation is for everyone to be emotionally grown up. If you can't grow up, you shouldn't get special treatment.
It *is* a real problem. Ask anyone in tech who isn't a straight white male. The industry *has* suffered. Not being able to take advantage of the talent from the innumerable people alienated by being an atypical programmer has almost certainly retarded the progress of everything we have done.
counts the minutes until r/golang-unsafe, for golang discussions outside of safe spaces. the icon could be a mad max style gopher. edit: apologies in advance if ive offended post apocalyptic gasoline seeking gophers
This seems like an overreaction to an overreaction to me. I personally consider the wording of the "warning" as aggressive. Even if the email was worded more carefully, I still don't see what Aram has done wrong.
This is interesting :-) I never had felt the necessity to use multiple GOPATHs and I do not think that any language author is going to disallow flexibility, there might be cases where multiple GOPATHs are a necessity, who knows!
&gt; Ask anyone in tech who isn't a straight white male. What exactly should I ask them? And what makes you think straight white males are not affected by rough manners? &gt; The industry has suffered. Not being able to take advantage of the talent from the innumerable people alienated by being an atypical programmer Pure fabrication IMO, typical SJW narrative. IT is and has always been full of diverse characters, certainly not only straight white males (who, by the way, also have a soul and emotions and would likely be offended by the way they're being framed as heartless aggressors whose opinions on rough tones in the IT industry should best be ignored). Let's not drag this far too generalized OT discussion any further though. 
im enjoying the complete irony of your posts. you are the overreaction to the overreaction to the overreaction. 
Well, that was actually unexpected. Thanks for proving my point to everyone trying to form their opinion, I guess?
first they have to get support microagressions and safe spaces built directly into compiler, so it will be a few more decades. 
&gt;the whole thing started as an insult over someone's fluency But did it? &gt;and then the response is littered with incorrect usage This makes me question whether he's *really* a massive hypocrite who was trying to insult another non-native speaker, as people here seem to believe. I'm inclined to believe it implies he meant simply "the english used was so unclear he could not understand it". That's not an attack, that's a statement. Edit: My goodness. Thanks!
Reminds me of Sprint planning idiots every week, who keep blaming Engineers for their poor planning and lack of understanding of product and complexity of Engineering tasks. Something something *warning*... my ass. /Rant over.
Who is Sarah Adams? Who hired her into the Thought Police? Is she even part of the Thought Police? Who is also part of the Thought Police? Why is the Thought Police secret when every other aspect of the community is discussed in public? I want to know who are our owners.
The beef I have right now is they say on the bottom not to make comms public. It just seems a bit shifty to keep their plays quiet. Expecting that we're to blindly trust that they're only sending the appropriate messaging. I suspect the message would have been more carefully considered and tweaked for tone if these things were subject to open inspection. That said, the issue is with Iris. We know the person behind Iris to also hurl insults, attack character, and obfuscate the truth for matters of personal pride. I hope they too are being approached about their reaction to the concerns of the community. Otherwise this community standards group is just a sham PR, and cares nothing for the sanctity of the community as a whole.
@ctcherry: Thanks
&gt; Internet crusades against individuals need to stop Disagree given that the particular individual was lying and cheating. Have we really dropped so low that bringing a wrong act to light is called "crusade"?
slightly offtopic but i've read this comment in the discussion on golang-nuts &gt; Frankly /r/golang is so toxic I stopped posting there Do you perceive this subreddit as especially toxic or mean or what ever? I'm wondering, because I've always received positive or helpful feedback on my questions, comments, answers or other posts here Edit: ... and didn't stumble upon negative stuff in other threads either
Yeah, right, "the same rules as everybody else". Maybe Google will stop using Linux and supporting it given that Linus doesn't use a 'permissible language' when providing review comments. Meh.
The developers haven't provided any means of contacting them about installation issues. I tried installing it for quite a while, but no luck. It just keeps on reporting: &gt; You must create your project in $GOPATH/src I wouldn't recommend using Fragmenta
Unfortunate that you are being downvoted. For someone who speaks English at the workplace, but non-English at home, this makes perfect sense.
What's an ESL?
im honestly curious, has anyone ever empirically studied this or is this just sjw urban myth? the linux kernel seems to be a shining beacon of counter example. 
Uh, that is not what this is about at all. OP believes that the go team is the New World order because Sarah sent him a message saying that one of his messages- one that had nothing to do with the iris issue from a technical standpoint- was viewed as a violation of the code of conduct. The crusade is posting a rant that would make even sovereign citizens roll their eyes to every available, commonly used mailing list or forum, instead of handling it maturely by asking for clarification in private. Bringing a wrong act to light has nothing to do with a single message containing an insult that has the potential to affect people who read it other than the person it was in direct reply to. If you had a disagreement with a coworker, would you try to talk with them in private first, maybe involving a common superior, or would you post an emotionally charged rant containing hyperbole that is more appropriate to describe the government policies of North Korea than a loose group of individuals involved in the community of Go that help enforce some basic rules?
It looks like the working group is listed here: https://golang.org/conduct It's comprised of 1 Ardan Labs employee, 1 Stripe employee, 1 Canonical employee, 1 Clever employee, and 4 Google employees. It's not clear how or why these people were selected. But they were pre-selected for the original proposal: https://github.com/golang/proposal/commit/7e7ce02d6e9cf7dfe90d03f4fce9984f04100d0d
 *Comprised of*? Many people do not accept "comprised of" as a valid English phrase of any meaning. The argument goes that "to comprise" means to include, as in "The 9th district comprises all of Centerville and parts of Easton and Weston." Thus, "the 9th district is comprised of ..." is gibberish. The phrase apparently originated as a confusion of "to comprise" and "to be composed of", which mean about the same thing, as in "the 9th district is composed of ...". This bot was inspired by (but is in no way associated with) [this user](https://en.wikipedia.org/wiki/User:Giraffedata/comprised_of). 
Code of Conduct is a cancer. 
well that didn't take very long to invoke identity politics of gender and racism into this. 
Let's not blow it up further than it needs to be - Sarah's response was heavy-handed and bullying. Aram clearly overreacted. Sarah has already apologized. Can we shake hands, call it a day, and get back to creating cool stuff again ?
I'm skeptical. there's an entire mentality behind these cocs that leans towards being offended on other people's behalves.
&gt; there's a subtle difference between someone saying they were offended and them actually being offended. "When a person tells you that you hurt them, you don't get to decide that you didn't." -Louis C.K.
English as second language
yet you seemed to have mustered up the courage to weigh in on this arguably non go related topic.
say goodbye to any and all master/slave terminology and perhaps even the gender specific terms like actor or patriarchal terms like controller and parent
Can we get an sj compliant release of the go compiler to only tell us "I don't understand" when our go is not buildable, I'd hate for it to offer any microaggressions towards me and my native programming language. /s
Your comment hurt me deeply.
My sincere apologies.
any idea where to report this transphobia to github?
&gt; It is a real problem. Ask anyone in tech who isn't a straight white male. Or how about we ask all the Indian H1-B hires? It's interesting that most companies have no problem hiring Indian developers but you want people to believe that these same companies discriminate based on race and gender? Give me a break. &gt; certainly retarded the progress I don't appreciate this ableist language.
Life's too short to apologize to all the crazy people on the internet.
Complaints should be directed at the Go project itself. They employ her to represent the Go community and they ought to be aware of her transphobic behaviour. CoC Working Group members should be held to a higher standard. edit: Mods, if this is considered doxxing or inappropriate behaviour please remove my post immediately. I have only repeated public information that was provided in the original post.
I disagree because my intention is to ship software and /u/4ad actually contributes lots of code to the Go core. He could do a lot of things I disagree with, but that doesn't mean I would want him to leave Go because he adds lots of value. The community would certainly lose out if he left.
"give people power and they do show their true face.", famous quote but unrelated
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/drama] [\/r\/golang goes ape over CoC coup (xpost \/r\/programmingcirclejerk)](https://np.reddit.com/r/Drama/comments/59r0x7/rgolang_goes_ape_over_coc_coup_xpost/) - [/r/drama] [Go language contributor publicly complains about complaint from Go Code of Conduct enforcer](https://np.reddit.com/r/Drama/comments/59q2i1/go_language_contributor_publicly_complains_about/) - [/r/programming] [\/r\/golang beef of the year: "stalking people online for thought crimes"](https://np.reddit.com/r/programming/comments/59roft/rgolang_beef_of_the_year_stalking_people_online/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
You are trying to drum up controversy about something that is the exact opposite of reality. Sarah Adams founded Women Who Go, which is very explicitly trans-friendly -https://twitter.com/womenwhogolndn/status/788116764102103041
Agreed, SJW'ing and other affirmative action nonsense only serves to waste everybody's time and give power to pointless administrative folks that contribute controversy instead of lines of code.
this assumes that "they" actually contribute anything functional to the codebase, which has yet to be proven across a wide array of these CoC enforcers.
I don't agree with OP post about English skills of another person but it can easily be ignored. To live a life in which you have to weigh your every word and be reticent is not something what we should strive for. So I think Sahra Adams and the rest of the CoC Group if they have the same opinion should overthink there interpretation of the CoC rules. The programming community as a whole is no safe space. If you need it you can create a safe haven for those who in need of it but don't try to expand it over the whole go community. 
[Some of] The best programmers are devoid of healthy communication skills though. There is almost an inverse correlation in fact. 
[Citation needed] I think that's just an excuse that insecure and/or arrogant people with a natural aptitude for something to avoid taking responsibility for the times they throw temper tantrums.
OK, let me back up. I'm sorry, I misunderstood where you were coming from. I jumped to conclusions and thought you were just trolling. Certainly, as a cis-gendered male, I have no standing to tell someone whether or not they should be offended by a project about gender. I suggest simply talking to Sarah directly, rather than calling for her to be kicked out etc. If you do not want to talk to her directly, talking to one of the other members of the CoC group or the Go Team would certainly be a good start. This is the point of the CoC and the group that supports it. I'm sure Sarah has the best of intentions with that repo, to try to get metrics on underrepresented groups in the Go Community, but as we all know, intentions are not the same as outcomes.
&gt; Guten Abend i dont understand.
My thoughts on the matter are simple, the code of conduct committee should only step into a discussion when there is clear evidence that someone who was part of the discussion voiced concern and the behavior didn't cease. For example, if I am having a discussion with someone on here and they call me a fat bastard, then unless I, or someone else voices that they are directly bothered by it, and the the originating offender continues calling me a fat bastard, then the committee is needed. FYI, call me a fat bastard if you want.
I'm highly offended by your lack of understanding!!1elf
I need to find a way to package LuaJIT runtime and code to send it to remote machines, so that we do not require remote machines have LuaJIT and libraries installed.
&gt; The best programmers are devoid of healthy communication skills though. No. Like pretty much everything else, programming is in a large proportion a social discipline, requiring frequent communication with other people working in the same industry. As someone who has to put active effort to achieve decent communication, I would never hire someone who dismisses communication skills. Even the best theoretic skills (questionable in someone who can't talk to others about the field) aren't worth the lost work of others. EDIT: also, "we're all immature douchebags" is a pretty bad stereotype, y'know.
In general, I think this is a welcoming subreddit..... but I am also a straight white male native English speaking US citizen with a CS degree, so I'm probably not the best person to judge.
And *this* shit gets more upvotes than something actually related to Go. Think about that. PHP had the same type of COC drama... it just breaks apart the community and creates havoc. I'm personally sick of SJWs trying to find issues where there aren't any. Creating a shitstorm out of thin air is their forte.
Interesting that this thread devolved into insulting Sarah Adams, rather than constructively speaking about the place and tone of Go's Code of Conduct. Sadly, this is totally predictable behavior for most Reddit communities.
Sorry, the point wasn't that you couldn't learn to be better at communicating or that it communication isn't important. It was simply that there are a lot of great programmers who are not good at communicating.
From the [thread](https://groups.google.com/forum/#!msg/golang-nuts/MHoI64RyRdY/9TMTurTMBwAJ): &gt; code of conduct workers should work on adding generics to compilers LMFA
Getting offended because someone is trying to assume your gender by looking at your name? Get your shit together and grow up, please
Actually, [comprised of is not wrong](https://en.oxforddictionaries.com/definition/comprise). That author is just a little neurotic.
We've come full circle.
&gt; comprised of is not wrong TIL
Which posts are insulting her? It's gotten rather hard to navigate these posts.
"Is it really so bad?" I feel like there's a slippery slope on the whole SJW thing that's frighteningly reminiscent of McCarthy-ian groupthink from decades ago. Technically, being a communist or athiest wasn't illegal, but there was a very effective thought policing infrastructure in place that resulted in censure for thinking "unapproved" thoughts. Let's say there's a Go contributor who is outed as a Trump supporter (you may have seen the ridiculousness with the Peter Thiel stuff a few weeks ago). And that person's comments on official forums suddenly start being found offensive. And that person refuses to play along with the CoC team. What happens? Is that person ostracised from the project? I feel like there's a serious selection bias with a CoC enforcement team. It's naturally going to attract participants whose perspective on dongle-gate differs strongly from my own, and perhaps the perspective of the community average. If Golang wants to have a CoC and an enforcement team, there's a number of good reasons to do so. Toxic behavior does need to be dealt with or it very well could poison a community. But by accepting volunteers who may have an enforcement agenda (much like McCarthy), it creates its own toxic environment where whoever shouts "Offense, Offense" loudest is king. The enforcement team positions should be randomly assigned to core/major contributors with a rotation every year or so. It's the only way to give the team a chance at representing the norm and not the fringe. As bad as jury selection is in the justice system today, think just how horrible the judicial process and the representative "fairness" would be if jury members were volunteer positions.
You want to capture the history of your session including the stdin/stdout? There's [script(1)](https://linux.die.net/man/1/script) for that, or [asciinema](https://asciinema.org/) (which went from python-&gt;go-&gt;python).
No, there's good reasons to have one laid out. The problem is with volunteer positions for enforcement. It's the same reason why jury duty isn't volunteer.
Same here except for native English speaking US citizen. So maybe I'm not the right person to judge either. At least I wasn't blamed for my English yet. But to be honest: Even I - as a non native - think [the criticized English](https://github.com/avelino/awesome-go/pull/1137) isn't good. 
&gt; everyone except AG had only one message in an insulting tone I've always found /u/enneff to be very affable and pleasant. If you read this, you're a good dude Andrew.
As a fox, I am offended at your inclusion of food.
So asciinema uses an [asciicast](https://github.com/asciinema/asciinema/blob/master/doc/asciicast-v1.md) format which includes duration for each command. You can probably shove a start timestamp on the file itself, and you got something with the time. Anyway, if you want to do you own, go for it.
&gt;Do you perceive this subreddit as especially toxic or mean or what ever? Yes, quite. So much so that I typically don't end up commenting much if at all. The good news is that the really shitty people tend to stick to reddit (where they are at home) and have far less of an influence in...well, pretty much every other go-related group, but particularly less in IRL meetups. The mere mention of the CoC, much less the *use* of it, gets this subreddit riled up like their lives are in danger if they can't make sexist jokes without repercussion. And, as usual, transphobia is only "concerning" when it can be used to strike back against someone who hurt their feelings. Overall, this subreddit's users constitute a cesspool. But, unfortunately, it's still one of the best and most convenient places to get go-related news.
I have not posted anything on reddit. 
This is great and deserving of the gold, whoever provided it.
Sorry I dont have a more technical question yet. I am getting the following error when I try running the example after cloning https://github.com/pact-foundation/pact-go. I started the daemon, then did the following. 1. cd pact-go/examples 2. go run consumer.go ./consumer.go:52: cannot use dsl.Request literal (type dsl.Request) as type *dsl.Request in argument to pact.AddInteraction().Given("Some state").UponReceiving("Some name for the test").WithRequest ./consumer.go:60: cannot use dsl.Response literal (type dsl.Response) as type *dsl.Response in argument to pact.AddInteraction().Given("Some state").UponReceiving("Some name for the test").WithRequest(dsl.Request literal).WillRespondWith I looked at the WithRequest method and its expecting the Request object as a param. I met all the dependencies, etc, yet the example still fails. Can you help onegeek? 
&gt; proper usage since you're getting into the minutia of semantics, clearly you must have realized that "proper usage" and "good usage" ("speaks good") are interchangeable within this context, no?
Could you provide examples? Preferably not from this very controversial thread Edit: just to be clear. I'm not trying to prove a point. I'm just curious how our perception can differ so fundamentally
Definitely. I really like Guava but I couldn't find an alternative in Go so I initialized the project. I'll try my best (also issues and pull requests are always welcome). Thank you. 
Wow, I read that linked thread, and it's like 1984. Unacceptable. It should be noted that these problems don't arise in the communities of languages that support generics. We accept any and all Go refugees in /r/rust.
sure, but that statement: &gt; a straight white male native English speaking US citizen with a CS degree, so I'm probably not the best person to judge. implies that *anyone* who is a "straight white male native English speaking US citizen" isn't qualified to have an opinion. This self-deprecating guilt is unhelpful, and more often than not, disingenuous.
&gt; What do you expect, a message implying you're free to ignore the CoC if you feel like it? This brings up a good point -- what exactly would be the penalty for ignoring the CoC? I assume it means they won't accept any pull requests from "penalized" users (although I also assume they would just steal the code and check it in themselves on such an occasion).
Thank you!
The author has [now commented](https://www.reddit.com/r/golang/comments/59qwpu/future_programming_languages_intent_to_learn/d9amj7u/) with the source.
Does this comment represent an actionable [CoC](https://golang.org/conduct) violation? &gt; Discrimination based on age, disability, gender, nationality, race, religion, sexuality, or similar personal characteristic. -- &gt; There are plenty of people with the same ability to contribute to the community that don't feel the need to be middle school [age] drama queens [gender]. I feel that your comment relies on a negative stereotype of middle school girls as overly dramatic. This may result in young women aged 12-14 feeling unwelcome in the Golang community. To whom should I report this violation?
&gt; The enforcement team positions should be randomly assigned to core/major contributors with a rotation every year or so. It's the only way to give the team a chance at representing the norm and not the fringe. &gt; As bad as jury selection is in the justice system today, think just how horrible the judicial process and the representative "fairness" would be if jury members were volunteer positions. These are very good points and I hope the Go team takes a look. In addition, I think it'd be good for the community to have the unique experiences and backgrounds different people could bring to the CoC table. Plus, there are a lot of cultural barriers and issues that even the most astute social justice advocate can't comprehend or otherwise be aware of. This could only happen if the CoC team was on a random, rotating basis. 
I wish Elixir was more popular. :( And Swift might be a nice language, but the platform is terrible. Surprised so many people are interested in it.
Is this something you just need for seeing what happened in your shell? Is your shell scrollback enough, but you also want to know the branch? You could set your PS1 (shell prompt) appropriately so that it shows current time &amp; git branch.
In the exact format as we saw on golang-nuts? 
I'm talking about their politics outside official channels singling them out for greater scrutiny/targeting and recontextualizing of their comments within official channels. This is exactly the sort of thing that happens in real world embodiments of ideologically pure concepts of segregated policing. Subconscious priming affecting context sensitive interpretation is exactly why you don't collect photos with college applications.
I have no problem with it.
Reverse or forward proxy?
absolutely best thread of the year guys. thanks :) the coc group needs to disband. they are ruining the go community. no question. if the go project had any concern about their community they would have opinion polls - and i'm sure the coc would be unanimously down voted. but just like our gov't - when you give them a little bit of power they fall right into bullying others and don't really care about threads like this which show how much they are detested by the rest of the community. and no wonder why. they are crying wolf and threatening others with their rules lawyering. time to go out and find something productive to do, coc group. get a real job. take on some real responsibility like fixing or writing code. find greater meaning in your life. please. this is like the thousandth post about your ignorance. grow up, lighten up and get a clue. no one needs your phony parenting. and if someone IS truly offended - let them speak up. if it's truly offensive to many - the many NEVER have a problem with speaking up and defending themselves - as evidence in this thread - your made up authority is pissing people off. 
I don't know you, but you're a fat bastard. &gt; Inb4 no context Inb4 sjws Inb4 CoC Inb4 banned Inb4 vanned Inb4 4chan Inb4 CNN 
Someone posting to /r/Drama that is making an argument based on any kind of principles of social justice is not doing so in good faith. 
I hold you in great respect, you fatest of bastards!
&gt; the terrible reputation that IT has is imaginary and repeated only by people with an agenda. IT is and always has been one of the most inclusive professional industries in the world.
I think if someone is too timid to even report an issue they have with someone else, that is their problem. We can't just go around assuming what might offend people...
&gt; Ask anyone in tech who isn't a straight white male. Which of my coworkers shall I ask about this? My black colleague, or the woman we hired a few months back on my recommendation? I just need to know what your "acceptable diversity" threshold actually is so I know which coworker I should ask. I just hope they're "diverse" enough to count. &gt; The industry _has_ suffered. Yes. It's suffering from an infestation of irrelevant identity politics.
Feel free to ask both of them what discrimination they have faced in their careers in tech. I will be curious to hear their answers. 
Please do not talk about your inability to speak english. Consider this a warning.
There are a few people who wrote Lua VM in pure Go already, so you could provide optional Lua engines; one for convenience and one for speed.
Yeah, fuck that group, they think differently than you! Exclusionary bullshit, dismissive of an entire (large) group because they disagree with you. _This_ is what ruins communities, not imaginary or unintentional slights on mailing lists.
Aside from this problem, I wish there was a better way to deal with Iris. I have been occasionally checking his repo since he deleted my comment to make himself look better and this guy is sketchy. Pretty sure he is faking several of his donations and he constantly changes his job information to make it look like he works somewhere he doesn't (which doesn't exist). On top of that, there is a guy that will always comment on Iris criticism while calling people children because his project has **400k unique daily users**. He won't post it to the public (wants you to skype with him). Not to mention he also restored his git history from a fork to make the first glance commit history look real (it's not even the full history). Last thing is most of his *tools* are just wrappers of popular repos under his name.
It's somewhat depressing how many people take this post seriously. 
As far as I know from my experience with iris, features that its provides are not exists in other web frameworks I have ever worked with, your comment is meaningless, be careful, do not write things you don't know for sure(iris is a copyrighted project, if iris' author learns about your comment, he may asks from reddit to remove your comments, by the law) It's somewhat depressing how many people take this post seriously. 
Make sense, managing pays off.
What? How is checking and confirming that Iris' stars are legit a dick move? As far as everything else, well. It's totally your right to like Iris, if it works for you that's great. But there's no doubt--and it's well-documented--that the author stole code from other projects, it's indisputable at this point.
&gt; The programming community as a whole is no safe space. If you need it you can create a safe haven for those who in need of it but don't try to expand it over the whole go community. Your quote sums up the entire issue of CoC quite nicely. I wish I could put it as succinctly as this.
The cold hard stats and a look around most development teams say otherwise. There are way too few women in IT. Sad and ironic since many of the patterns and principles of programming were formulated by and named after the women coders who came up with them. Any organization, group or other collective that is too heavily male dominated often struggles to control abusive behaviour. Just one white-male opinion.
Mostly with respect to the walled garden Apple is trying to build. 
CoC when said phoneticallys sounds a lot like "cock". I am offended by this acronym and it's patriarchical connotations.
I use a lot of Javascript...because I have to. 
If they're allowed "safe spaces" are we allowed "unsafe" spaces? And are we allowed to exclude those weak of mind from such "unsafe" spaces? Or must we accommodate said weak-minded people even though they will accommodate us?
I wouldn't call it minutia at all. But sure.
Look at gRPC using protobufs; you'll find mapping the networking much nicer than doing it by hand; all of the connectivity, retry, etc. is rolled up for you. http://www.grpc.io/docs/quickstart/cpp.html http://www.grpc.io/docs/quickstart/go.html You can also look at using -buildmode=c-shared and using your go code on both sides; but this currently isn't supported on windows.
Go is a pretty straight-forward choice for this kind of project. Can't really say much else.
I doubt you're going to see a single huge scikit-learn package. Like so many things in go, the needs are being served with [many smaller, more specific packages](http://www.mjhall.org/golang-data-science-libraries/).
The biggest problem is code reusability between the client and the server, so basicaly if you don't write your server in c++ you will have to re-implement a lot things already working in your client. ( physics, world, logic, player ect .. ) Looking at your game it doesn't look to complicated so Go could definitly work but I don't think it's best choice here because of #1. 
The code of conduct is exists to make a happy welcoming place for people. If we didn't need it, it wouldn't exist. ..but it **does** exist, because of the people (like the ones in this thread) that historically made /r/golang and golang-nuts unwelcome, hostile places that people don't want to be a part of; and by and large, it's been uncontroversial and effective. This is just drama for drama's sake; a relatively irrelevant issue has been blown out of proportion by the horde of redditors with an anti-code-of-conduct beef. Just look at the comment history of the main participants in this thread, it's obviously been targeted by trolls. For anyone to stumbles into this thread; please don't think that this post or the noisy hostile threads on it represents the views of the /r/golang subreddit. We're better than that.
How so? You can compile on linux now that its open source.
plus one more today ;)
Yup, game is not really too complicated. The server, actually, only acts as a "relay" of controller input and pretty easy decisions (what move was executed), it doesn't need to know much about the game logic itself.
[removed]
Cool, this is exactly what I was looking for, thanks a lot ! :D BTW, what were you working on? I just realized the client logic was quite functional, and it seems like porting the server to Go will be fast. If you are interested on following or adding your feedback into the project, let me know :) This is the working prototype from few years ago. It's me playing on my computer in Taiwan, and this guy recording it from the UK on his PC and Pandora (cool handheld)! https://youtu.be/GjcJF_sK7hY?t=55s
yep
Eyeroll.js
As someone who has been in the RTB world for 3 years, this sounded interesting. However, this has to run on the clients machine and then just applies http compression (flate or snappy) to the requests before proxying them, correct? I'm not entirely sure I understand the use-case. If you can't control the client, it can't be used. If you can control the client, just enable compression on the client. Why have a proxy on the client? Also, large SSP's spin up/down their servers quite frequently, so they'd actually have to add this to their automatic deployment / scaling architecture.
Maybe, but the base is already very solid. If you want to write Elixir professionally, then you really need some kind of growth of the language for that to be viable.
Reddit users are more worried about being told to be nice than they are interested in the content they're presumably here for. Seems to me the "shitstorm" is the OP and the 200 people who think it was awful horrendous censorship to say "Hey your post was reported, be polite, here's a suggested alternate phrasing."
&gt; I'm quite offended that this code seems to be focused on assuming gender based on name. How dare anyone create a bot that presumes my current genderfluid identity. Seems like this might be a violation of the CoC. Cool story, you're really good at lying. We definitely can't tell.
&gt;here's a suggested alternate phrasing Also: "Please consider this a warning from the Code of Conduct working group." Jesus, with these standards, Linus Torvalds would get kicked out of the Linux Kernel group in 5 minutes.
Although we've never tested it officially, there should be no problems in using https://github.com/vattle/sqlboiler - although it's a newer ORM it's got a fairly unique approach than other ORM-like things out there. On the surface the only problem would be you'd need a very small wrapper to expose pgx's database connection as an boil.Executor because it's Exec() method doesn't use sql.Result interface. I can help you do this if you need :)
I have no clue who enneff is, but AG is a good dude :-) He gave me good feedback and it was the only relevant feedback I got from the core team back then, I have stopped using the Google group.
My interactions with AG have always been great. For context on /u/thewhitetulip 's woes, he submitted a book for feedback to golang-nuts. The (summarized) feedback he got was * Brad Fitz - the language is named Go, and not golang. Whenever I read a blog post with "Golang" in its title, I brace myself for an article about a user who just discovered the language last weekend and has some opinions. It may certainly be the case that Suraj knows the language well and has written a good book, but the title immediately turns me off. That was my advice. * Rob Pike - (agrees with Brad) * AG * Here are some general thoughts, based on clicking through your book and skimming sections. I'm sorry that I don't have time to give it a good read right now. * There are a lot of typos and misspellings (eg, "Sneak Peak" should be "Peek") in the text. For some people that can be a real turn-off. * On the topic of the "Sneak Peak" chapter, I think that would be pretty overwhelming to someone who hasn't seen Go before. * The chapter titles could be more descriptive. In the "Implementation" section you have "Implementation Basics" and "Basic Functionality". It's hard to discern what the difference between these might be. * I think your ratio of code to prose is a bit low. For a practically-oriented book, I'd rather see more code with less supporting text. Right now, when I dive in to any of the chapters, there is a wall of text to read. I think more small, incremental examples would help. I think this feedback was decent, especially for a first draft. Unfortunately, Suraj did not think so. He was upset that people went off on a tangent about the name of the language rather than giving him feedback. Later, Suraj corrected a mod or someone else about the "actual" name of the language and got banned for 60 days. This upset him further. Source - Suraj's [comment on HN](https://news.ycombinator.com/item?id=12208325) about this. 
Gorm gets weird around the edges. Considering you need extra struct fields and magic struct tags to do relationships. It's design starts to show it's holes the more of API surface area you touch. It's query building and struct binding also performs quite bad relative things like gorp or sqlboiler.
Wow, you took liberty of toning down the messages didn't you? Summary isn't a summary when it changes the meaning and context of the original text! &gt;This upset him further Does my HN comment sound like I am upset? :D Didn't know upset people joke about being banned, good to know! Note: I do accept that I was wrong in not mentioning about AG on that post; mistake from my part. Also, on the thread which you commented, I did mention that except AG my experience was bad.
enneff is Andrew Gerrand, the person I assumed you were referring to when you said AG :)
I copy-pasted those lines from the mailing list thread verbatim, with the addition of formatting to make it easier to read. You don't joke about being banned, rather you sound butthurt af every time you mention it. And you mention it in *every thread* I've ever seen you comment in, both on reddit and HN. Thus I concluded that you must be upset. Perhaps you were upset they didn't take time out of their busy schedule to read your book, give you constructive feedback for free. Perhaps you were upset that the told you the correct name of the language (look up any book published about it). Perhaps you were upset that AG corrected your English, rather than deep dive through the book, reviewing line by line. But upset you certainly were, or you wouldn't mention it at every opportunity. Also, you think you're being polite when you sarcastically say "my good Sir", but you're not. I suspect its comments like that which must have earned you the 60 day ban. 
&gt;everyone except AG had only one message in an insulting tone &gt;I have no clue who enneff is, but AG is a good dude :-) He gave me good feedback and it was the only relevant feedback I got from the core team back then On a comment below made approx 20 minutes before I replied to you Wow, I do sound hurt. The "verbatim" you copied would have looked like this 'First bit of advice: the language is named Go, and not golang. The domain name is golang.org and the common hashtag on twitter is #golang, but the language is still named Go. Ruby's website is https://www.ruby-lang.org/ but people don't call it rubylang.' It was after someone else commented "I find it appalling that two authors that here is a person asking for advice to advance the language material and the two replys they got from two core members were snarky. first one took a jab and the second defended that jab. pathetic." which triggered the second response you chose to summarize, which was "My advice was real. The book will look more professional if it doesn't have typos in the title.", if this was what he had said in the first comment, it would not have sounded snarky at all would it? I have no interest to take this further, because it doesn't matter if AG or RP is wrong or if I am wrong. The thing is Go is an amazing language, the reddit community is great, it was a minor brush which I don't "mention it at every opportunity", if I remember correctly this is the second time I mentioned it, do note that I didn't name anyone and I just stated it; **peace** P.S. Apologies for sounding sarcastic, I didn't know that sarcasm was banned, also I didn't mean to be insulting, it was freaky to see that you were able to locate those threads. It is like you have some special interest in the case. &gt;And you mention it in every thread I've ever seen you comment Could you please give me links to this? If I actually keep on mentioning it then I am being whiny which I'd stop immediately.
&gt; go run consumer.go Hmm something is not quite right Pratik, it feels like there might be an old library on the GOPATH / misconfiguration (WithRequest should not accept a pointer to a dsl.Request). Let's chat on the Gophers slack channel to resolve this. 
The problem with Elixir might be that this is the first time many have even heard of it. At least I haven't noticed any frontpage submissions about Elixir in ~~this subreddit~~ /r/programming.
because you can make monies
I respectfully disagree, but that's just me.
I was talking generally.
I'm rather hoping that as the number of articles on functional programming in JavaScript are growing, that its sparking an interest in a "traditional" functional language. I was dragged kicking and screaming to Gofer which was a subset of Haskell 1.2, I didn't like it at the time, but it changed the way I thought about programming techniques.
Go will shine because infrastructure will get even more complex. Bazillions of physical and virtual devices will be used and interconnected. However it will remain niche compared to C# and Java (obvious reasons and I am talking about sheer numbers). Python will remain stable not grow that much as other langs. JS will grow but will experience occasional spikes in usage (new langs transpiling to JS will popup and take marketshare). Rust will be used more and more to replace "critical" software however will not gain much love in Gaming Industry which is critical imho to attract masses. Ruby will be aching in pain as it heavily relies on Rails. Chef/Puppet will slowly be replaced by something written in Go and unless RubyMotion gains more attention I do not see Ruby to grow any further well unless it fixes GIL and concurrency. Elixir &amp; Erlang will remain niche but will be used as an alternative mainly by companies that deal with a lot of users (US,China + rest of ASIA) but will not find much love from programmers/companies in Europe + Russia &amp; friends. C# and Java will be stable. C# thanks to new Microsoft will eat a lot more marketshare from Java than many people belie is possible. Swift is a big ??? as we do not know how heavily it will be marketed and how can it be used outside of Apple ecosystem.
but it has ruby syntax
This looks quite impressive! Care to tell us some more details about the game? Is the server written fully in Go? What about the game? What other tech was used? Thank you.
Why do they always lump C and C++ together in these polls? They are distinct languages!
Definitely impressed as well, would love to hear more about the tech too!
Meh it's reddit.
And TypeScript on the backend as well, you can write a complete Express application using TypeScript (idiomatic TS -- offcourse you can also write pure ES5 or 2015 and ts compiler 'gets it').
From what I've seen Swift has serious ability to replace Rust in pretty much everything Rust is meant for, the infrastructure is not there but now that it's opensourced I fully expect a xplatform server-side and IoT oriented Swift ecosystem to "branch off" from the Apple ecosystem much like the microservice Java ecosystem "sprung off" (pun intended) from the EE ecosystem. Edit: forgot to point out that the reason I beleive this is not that Swift is somehow "better" than Rust, but it simply has more mindshare. It's pretty exactly the same thing that makes Go more sucessful than Rust, Nim etc.
For example, any usage of the word 'Golang' instead of 'Go' will get you shit on
[removed]
&gt; While I, as an *actually* genderfluid person Honestly, this is probably the most offensive and exclusive thing I've seen in this entire thread so far. &gt;(and frankly, neither I nor any of the trans, nonbinary people I know would be bothered in the least by Sarah's project) /r/asablackman
&gt; give it a rest, dude. lol give your social justice issues a rest you fuckin' SJW
People need to be able to deal with criticism of their abilities. Offense is not an appropriate reaction to criticism. If someone is harassing you, then a solution will be found. You don't need rules for that, you can use careful judgement. And you should because this should be one of the last resorts and not a tool for a war by proxy.
Just curious why you think the game industry won't adopt Rust? I don't know a lot about it, but I saw a demo last night and Rust looked exactly like what I'd want to develop a game in. The memory safety looked interesting and there's no GC. It looked pretty expressive and I've heard it's good performance-wise. 
&gt; Nah, I'm dismissing a small but very vocal part of the go community. You shouldn't be dismissing _anybody._ You don't seem interested in dismissing the "small but very vocal" group who complains about every slight, after all. &gt; This subreddit runs counter to the go community at large whenever anything social comes up. It seems like this happens because any kind of disagreement with the groupthink elsewhere is met with censorship, threats and excommunication. &gt; go has benefited quite a bit from having a more welcoming community than most languages This is ridiculous (and insulting to other languages' communities). Ruby and PHP both (famously) rejected attempts to force CoCs into their communities, yet both languages thrive and have active, productive communities regardless. &gt; That atmosphere is in spite of this subreddit, though, and not because of it. Oh sure, the sub has never contributed _anything_ of value to go. Absolutely ridiculous. This snobbery just knows no bounds, does it?
Suggestions: don't use emoji. I couldn't tell apart thumbs up and thumbs down on quick glance. Use green/red (or something appropriate for colour blind people) instead
This is what I have been doing. Excellent blend of features, community, and performance. TypeScript is a wonderful language. I love it! ❤️
Library and binding support maybe? So much of gaming is already in C++ that it's probably the path of least resistance.
As much as i disagree with the handling of the situation by the sadams and the coc working group... That is no way to effectively communicate to solve the issue
I wouldn't bet too much on it.
Yes, but my question was straight forward, would a community exist and be civil when there are no mods, take a look at any community, there are admins everywhere, do you think admins or community Mods are the part of policing? I am saying that because I want to understand how to manage online communities.
It's easy to write a server that will be a backend to your business logic server that will serve 1,2,3,.. The hard part is what to do when the server is down, unreachable, loses count (e.g. catches fire), and if you go further down that route trying to solve those issues, pretty soon you'll find yourself reimplementing a simple hacky paxos or etcd service with a fat client
&gt; Rust is too time consuming Can you explain what you mean by that?
Why not?
Have you considered what should happen if your system experiments a network partition? https://en.wikipedia.org/wiki/CAP_theorem
&gt; Well, I might have used the word incorrectly, but don't you agree that there needs to be some supervision? Absolutely not, but, then again, I value freedom of expression (free thought, free speech) above all. &gt; Communities like Twitter, where there is no predefined agenda can go racist in a day, just look at what happened to Tay. Context is important. Microsoft chummed the waters with troll bait on that one. &gt; do you differentiate between policing and having mods? I think mods should remove spam, personally identity information, credit card numbers, etc. Basically, anything that violates the letter of the law in the country that houses the servers used to host a particular community.
I used Go for the game server for our game (Assetto Corsa if you want to check it out), the game itself is C++ like yours. If I could go back in time I would use C++ for the server as well. The main reason is that you'll find yourself rewriting the same pieces of code twice quite often. You will also have to add a Go environment to your ecosystem. Yes, Go will offer some nice things from the start, such as the possibility to add a webserver to your game server with few lines of code and, of course, nice concurrency, "free" Linux version and so on.. but IMHO, as awesome as it is, it is not worth the hassle due to the points above. Hopefully one day we'll be able to write server AND client in Go, a man can dream right? 
Oddly enough, I have, and I've always had to tone down new moderators who had a god complex. Moderators *moderate*, they shouldn't really step in to curb issues that aren't there.
Is swift a good language? Yes. But I just don't see swift building a great open source community lead by Apple. In-terms of the large tech companies, Google and Facebook gets open source, even Microsoft finally open sourced many of its developer tools. Apple open sourced Swift even later when there was no reason to release it closed in the first place. I think this comes down to Apples closed garden culture. Back in university studying computer science, tech companies would send representatives and give presentations. When other companies would be happy to be talk about, the apple representative asked us not to share her talk, and said she wouldn't be able to give more presentations if we did. Outside of making iPhone apps, I have stayed far away from the Apple ecosystem.
i hope they do the same survey in the US so i can push for less 'java everything' at my workplace
I'm curious what did you do for the physic? Did you re-implement all of that in Go?
Comparisons like this often suffers from to much information. People who need these comparisons are usually newer users, who just really need to get start without being bogged down with too many choices. I want a comparison that first sort the libraries in to categories, so a user can pick a categories that fits there use case, then pick a library. Or have libraries sorted by fitness to use cases, to show the best tool for the job. Another aspect is that each library was made to fill a gap, explaining that gap and how it was fill should also help users to decide on the right library. 
Sorry, but could you explain that a bit more? I'm not sure why you don't think Rust was designed to be a backend. I follow the Rust project quite closely and they often discuss using Rust as a web backend. I've used Go professionally for ~9 months as a web backend, but I've also used Rust for a smaller backend projects. For me, the difference was that Go has an extensive standard library that's high quality thanks to the work done at Google, whereas Rust relies on its community for a lot of the same. I didn't find myself having to reinvent the wheel, since I was able to easily pull in non-stdlib dependencies. 
[golang/go#17053 - doc: add ACME (LetsEncrypt, etc) example docs to the standard library](https://github.com/golang/go/issues/17053) may be worth tracking as well.
my first and main question there is what did you use for graphics. I've heard that the opengl bindings are a bit meh at this stage still.
Yeah, total oversimplification. I wonder if that's the perception non C and C++ programmers have.
No that would be simply impossible. The server is simply a message forwarder and the car performance validation is kept to a bare minimum. 
I think most of that is due to a combination of increasing job opportunities and some hype. Of course that's over simplification, but I have a hard time understanding why someone would be genuinely interested in learning JavaScript because it is an awesome language. I think its merit is because it is the only thing that runs natively on the browser, because it is an awfully designed programming language. EDIT: Missing word.
Maybe a naive question, but why don't you minify all of the files first, before loading them in as templates? Any type of text replacement you are doing through go's text/html template libraries should work just the same whether it's been minified or not.
My assumption is that most professional C++ programmers rarely write C and professional C programmers the same with C++. I think these days most cpp stuff is related to mobile and games, where standard C is pretty much doesn't exist in either ecosystem. 
I just use command line tools to do it in advance of deploying, personally. 
I hear you. This whole occurrence is unfortunate for a community built around such a great project that is Go. But I am optimistic that the core team and the community will turn this into an improvement. After all, we all have something to learn from this.
OP is asking how to do that without the tools choking on Go templates.
There's nothing in the ecosystem that will let you keep your types simply because Go does not allow int, string, etc to be null. In sqlboiler if you have no nullable columns, your types will all be regular :)
Seeing as nobody is going to make a comment, I'll go first. I still fear first class functions.
xenolf/lego might fulfill your needs: https://github.com/xenolf/lego
Why is that?
HTML isn't typically minified. 
I have successfully used html-minifier for templates without much issue. There's some good support to prevent it from choking, too. I use Gulp as my task runner, but here's the relevant code. I hope this helps! var gulp = require("gulp") var revCollector = require("gulp-rev-collector") var minifyHTML = require("gulp-htmlmin") // Replaces static asset links with the revisioned copy for cache busting // purposes. We also minify the HTML templates, removing all comments. gulp.task("rev:templates", () =&gt; { return gulp.src(["dist/rev-manifest.json", "dist/templates/**/*.html"]) .pipe(revCollector({ replaceReved: true })) .pipe(minifyHTML({ caseSensitive: true, collapseWhitespace: true, ignoreCustomFragments: [ /{{if.*}}/, ], minifyCSS: true, minifyJS: true, removeComments: true })) .pipe(gulp.dest("dist/templates")) }) You can modify the `ignoreCustomFragments` portion to add a whitelist of sorts. That's how I got it to not choke on conditionals in HTML attributes (along with `caseSensitive`, which was required to keep it from lower-casing attributes, if memory serves).
For a moment there, I believed that Dick Cheney had taken up programming and was going to be waxing eloquent of first-class functions, and I was really impressed!
Explain.
http://gocircuit.github.io/circuit/ 
It looks to me like Linux lacks the libraries Apple provides for iOS and Mac OS X. Also X code is currently one of the worst IDEs I've ever used. I love swift, but yeesh.
https://iris-go.com/ &gt; iris-go.com uses an invalid security certificate. The certificate is only valid for the following names: *.github.com, github.com, *.github.io Error code: SSL_ERROR_BAD_CERT_DOMAIN The irony
But how do you accommodate people who are so fragile that any random sentence may offend them? Say there is a Christian who is offended by somebodies homosexuality. The COC says the Christian's offense is not valid and they can fuck off and die. OTOH if a genderfluid person feels female during the mornings and male during the evenings and somebody mistakenly refers them as a he in the morning and they get offended their offence has to be taken seriously. Whose offense counts and whose can be disregarded? 
It sounds like only the game server was in Go. The game client was probably still C++ and maybe OpenGL (or DirectX). (**Edit:** Quite likely DirectX, because the game client is Windows only at https://www.carbongames.com/airmech/download.html.) But speaking of Go and its OpenGL bindings, have you tried to use them? What about them is meh? I help maintain the bindings at https://github.com/go-gl and as far as I know they're complete without any major remaining TODOs (for many years now).
Not sure why a dislike of first class functions translated to fearing them. I certainly understand what he's advocating here but aiming for expressive over simplicity of readability at the expense of a few case clauses feels contrived. I didn't find any of the examples using this approach more readable than their more imperative counterparts. 
Protobufs + GRPC gets you kind of close. 
This comparison makes me happy because: 1. I identify echo as a great web framework as well, and echo v3 will be even awesomer 2. You intentionally left _that garbage framework_ out of the list
Depends on how you define community.
Something I've been curious about for a while, what is the amount of garbage collected in that sub-millisecond pause? Naively, I would imagine that a longer GC pause would mean more memory can be freed up; though I'm not very familiar with GC in general so I might be missing something obvious here. 
Yeah it's the frustration of having to deal with so so many programmers with no perspective that throw shitfits when told they can't do something they want to do. I thought that not having children would have made me safe from all that but it turns out that all the programmers who make fun of people who support CoCs for being hypersensitive and getting offended get *really really* offended when someone tells them they have to follow the rules. This would be a lot more amusing if I didn't have to work with so many people who get bent out of shape and cry about censorship and the death of free speech whenever someone tells them they're being a dick. This isn't the first time it's happened, or the second, it's all the time. I love programming and computer science, but the "community" here on reddit is the worst of the worst. I'm just glad that the rest of the go community pretty much just points and laughs whenever this subreddit melts down over something so trivial that it really shouldn't need to be stated. But, as this thread shows, it really does need to be stated.
The important point to remember is that since go1.5 GC is concurrent, so it happens while you're program is executing as normal. There are however some points in the GC algorithm where we must 'stop the world' (i.e. your program) entirely to do some memory management. This change is about reducing the worst case for these stop the world times.
Looks like the [visitor pattern](https://en.wikipedia.org/wiki/Visitor_pattern).
I might do this for quick implementations of an interface
&gt; Surprised so many people are interested in it. because it's not unbearable dogshit, which objective c is
&gt;I in no way claimed this was about the CoC team being ashamed. I dont know where you got that. When you said they didn't want it made public. &gt;My point was about airing dirty laundry in the form of public over reactions. Nothing wrong with that when the original assault was an overreaction. The kind of violence that the COC team used should be exposed. I mean they are very sensitive to micro aggressions but they use way worse tactics against the people they see as their enemies. &gt;Regardless of what the CoC team had said in the email, the option was always there to respond directly to them or to involve some other key people in the private discussion. I disagree. I think any infraction should be able to be made public by the defendant. I don't like secret trial and I don't think the COC goons should be able to expel people from the community in secret.
Start today: https://tour.golang.org/ 
You can send functions over the network and call them in another program?!?
I've used this a ton, I wasn't aware that it wasn't there at one point!
What you suggest is even better. I will study the extension of my handlers to enable this. Luckily the content I'm serving plays well with permissive cache controls and doesn't need invalidation. I had hoped somebody would suggest this.
somebody is already working on that: https://github.com/kniren/gota
Go is actually surprisingly easy to pick up. Do the tour, then start doing some hobby project that you don't even have to publish. Read the standard library's sources whenever you use stuff, it's (mostly) extremely readable and will give you an idea of how things are often done in Go
I hate repeating my self but whatever, I'll do it one more, this time for the mothers. I suggested the Op got caught writing some rubbish Go code and then tried blaming that rubbish on the language. Since you seem to have missed the point I'll say it again. Why not first learn the language (or any language) before blaming the language for your (i.e. the Op's) inability to write code. As they say a poor workman always blames his (or her) tools. 
The beauty of testing Go with the stdlib testing package is you don't have to learn something esoteric, you "just write Go code." We had a team with some strong Ruby programmers that started writing Go. They tried so hard, like the author of the post, to make Go tests feel like Ruby. After some experience, they have made the choice to use the stdlib. You have: Expect(ReadPersonFromS3(mockFetcher)).To(HaveLen(2)) testCall.Times(1) When writing a test, I don't want to memorize some strange syntax, odd chaining and parameters. You are not in Ruby, don't pretend to be. Dot imports, strange anonymous functions all over the place. Square peg met round hole. You can avoid all that craziness and have decent test names and, if you like, expand with `t.Log()` for describing anything: if len(ReadPersonFromS3(mockFetcher)) != 2{ t.Errorf("got %d, want 2", len(PreadPersonFromS3(mockFetcher)) } And I'd argue you likely do not need to test `testCall.Times(1)`. That is an implementation detail. As for testing your integration, I've had to test an s3 integration. I needed to make sure that retries worked, that stats were updated, and that the correct logs were created so downstream consumers of the log had a contract. How did I do that? With an interface, of course. And readable, writable, extendable tests. type Uploader interface { Upload(file io.Reader, bucket, key string) error SetUploader(*s3manager.Uploader) } With that, I set the `*s3manager.Uploader` to nil on my mock/fake struct when I start my test instance of my server. Each test spins up a server, with whatever setup that test needs. I can test any functionality I want now with something like: type mockUploader struct { failures int // or any other internal thing I want to track sync.Mutex } func (u *mockUploader) SetUploader(uploader *s3manager.Uploader) {} func (u *mockUploader) Upload(file io.Reader, bucket, key string) error { u.Lock() defer u.Unlock() // do any kind of set up or checking here. // return errors or don't. Have logic that says "after the Xth call, return an error. Or have it return an error for a given bucket. return fmt.Errorf("some s3 error") } Any Go developer can come into this project and start adding value. They don't have to be familiar with Ginkgo or GoMock. The tests don't read like a sentence, and they don't have to. They read like code because that is what they are. [edit: code formatting]
Shameless plug for https://github.com/zombiezen/go-capnproto2
JS has its share of warts due to the sins of the 90s, but nowadays it's actually a pretty nice language. It's no Python, but it's not terrible, either.
I am wondering why the PrivateMsg example at 16:45 isn't a data race. It looks like the function requests a copy of net.Conn, which it gets. Then it sends data to the net.Conn copy, but this is done off the loops goroutine. Reading the documentation of net.TCPConn, I cannot find information regarding if Write is thread-safe, so I assume it is not. I understand a copy of net.Conn is used, but this must have some form of connection with the original net.Conn, else Writes to it won't end up at the correct network. Can anyone explain?
Given there are a number of JVMs with different performance characteristics there is no easy answer to your question. 
Good to know. I ended-up using that.
Depends what level of game development. For high level work with game building, level design, etc, yes you can do very dumb things that break your performance, but if you're building a game / graphics engine for later games to be built on, that's where these GC pauses are a bigger concern.
Seasons don't fear first class functions, nor do the sun, the moon, and the rain. We can be like they are. Don't fear first class functions. 
This is good news. At least we will have a standard location for the default for default installation. However I will keep using gvm (https://github.com/moovweb/gvm) and use a different $GOPATH per project. 
&gt;&gt;I in no way claimed this was about the CoC team being ashamed. I dont know where you got that. &gt;When you said they didn't want it made public. Again, I never said they didn't want it made public. I said that I would have preferred it was resolved in a format that wasn't public overreactions. I pointed out that they offered the option for the recipient to reply and discuss. Your use of the word "violence" sums up my point perfectly. Some people love to go off the deep end and really paint a picture. Same thing happened when the CoC was being discussed. It's like watching the battle scene from Braveheart. These things can always be discussed. Everyone in the community is approachable, even those that are emailing about the CoC issues. A simple reply would have worked to be honest. We don't have to all get out our podiums every time we don't like how something is phrased. 
I am still undecided between work groups and semaphores as a means of limiting http concurrency. Both work but semaphores feel simpler to set up. 
I have seen them on [bgfx's readme](https://github.com/bkaradzic/bgfx#who-is-using-it). 
The idea won't help. The problem with the tools is not the invocation from the editor but the fact that they need to parse the source tree again and again (as well as resolve the types, make sure they can apply their logic on them and so on). Those tools will be cached in the memory of your machine as soon as you request them from the disk the first time around. So will the files that they are inspecting. In the off-chance they are removed from the cache, they'll be added again as soon as they are needed. This is one of the main advantages of IntelliJ and proper IDEs / editors, they don't need to do this, they already have all the information they need in memory to run the code checks.
I did this and I was ready to start writing code immediately. I stumbled a bit with some errors as I learned about uninitialized maps and interfaces, but it wasn't like other languages where I couldn't even figure out how to wire up the build system or import a library.
But like you said Swift is good. Better yet, it's good enough for both systems development and application development. All I'm saying is that all those IOS devs will translate into an army of people knowing Swift, many will emerge loving it or just being too lazy to learn something else, and that is what makes JavaScripts and Cs. Then you'll get people wanting to write backends, then you'll get people wanting to write Raspberry or other IoT stuff with it and soon enough no one needs Rust. The community will be built by those people and companies catering to them - not by Apple. The race for the level between C and Java/Python will settle with a tie between Swift and Go, and not too much room for Rust, Nim or any of the other contenders. 
Minecraft regularly pauses for &gt; 10 seconds at a time. Granted, Minecraft is probably not the best example of well-written Java, but Go isn't even in the same ballpark as Java at this point.
On my phone so can't test it, but would this work on functions that need a pointer receiver? For example, a buffer? Instead of accepting one-func-interfaces like `func ... (r io.Reader)` could we do `func ... (r ReadFunc)`? Edit: the checkbox example makes it appear so
http://blog.cloudera.com/blog/2014/12/tuning-java-garbage-collection-for-hbase/
This is actually buried in the [golang faq](https://golang.org/doc/faq#testing_framework) and seems to be overlooked. **Where is my favorite helper function for testing?** Go's standard testing package makes it easy to write unit tests, but it lacks features provided in other language's testing frameworks such as assertion functions. An earlier section of this document explained why Go doesn't have assertions, and the same arguments apply to the use of assert in tests. Proper error handling means letting other tests run after one has failed, so that the person debugging the failure gets a complete picture of what is wrong. It is more useful for a test to report that isPrime gives the wrong answer for 2, 3, 5, and 7 (or for 2, 4, 8, and 16) than to report that isPrime gives the wrong answer for 2 and therefore no more tests were run. The programmer who triggers the test failure may not be familiar with the code that fails. Time invested writing a good error message now pays off later when the test breaks. A related point is that testing frameworks tend to develop into mini-languages of their own, with conditionals and controls and printing mechanisms, but Go already has all those capabilities; why recreate them? We'd rather write tests in Go; it's one fewer language to learn and the approach keeps the tests straightforward and easy to understand. 
thats basically how package net/http implements http.Handle and http.HandleFunc. functions are types too and you pass a handler function with type func(http.ResponseWriter, *http.Request) to your http mux. its definitely an important construct in go.
Why are you minifying HTML etc anyway? Just gzip it. https://github.com/NYTimes/gziphandler
Your use of the word "violence" sums up my point perfectly. Some people love to go off the deep end and really paint a picture. Same thing happened when the CoC was being discussed. It's like watching the battle scene from Braveheart. I am using the COC definition of violence. &gt;These things can always be discussed. Everyone in the community is approachable, even those that are emailing about the CoC issues. I disagree. The COC cops are not approachable and they are not willing to consider other points of view. They are convinced they are absolutely right and that everybody who disagrees with them are racists, transphobic, misogynist, ableists. They feel that they alone are virtuous. 
&gt;I disagree. The COC cops are not approachable and they are not willing to consider other points of view. They are convinced they are absolutely right and that everybody who disagrees with them are racists, transphobic, misogynist, ableists. They feel that they alone are virtuous. Where do you get your material? Man, you just keep proving my point over and over. Why aren't they approachable? Have you tried contacting anyone in the CoC working group and been ignored? Have you disagreed with them and found yourself being called a racist, etc? This all sounds like the some fluffy overreaction speak that I have been reading from people freaking out about the scary CoC. Just people, my friend. Just people that can be contacted and spoken with. It's not some crazy evil plot or a secret society working in the shadows out to get you. 
Invoking a command through the shell is very fast. Both the shell and the command is likely already in memory from the last time you invoked a command and shells are very good at parsing commands. It's fast enough for UNIX, it's certainly fast enough for you.
Reason why BDD framework are there is because some set of problems is hard to express in procedural way. BDD frameworks allows you to create tree-like structure that express chain of events shorter and more readable way than stdlib. Other story is that Ginkgo and Gomega plays poorly with stdlib and go tools. I personally suggest to use http://goconvey.co for such case. Simple (one keyword to remember) and works well with go tools. It's worth to mention that most of the code should be able to be tested using table tests. Behavioral tests should be just small fraction and not every application needs that in the first place.
Very fast is a quite subjective measurement. If you start a subprocess in order to get your work done you have the overhead of starting a process, which is far from low. If you even use the shell to do it then the overhead grows to starting a `sh` process, which then again starts a process for the desired tool. Having the target process already in memory and communicating with it what you want is certainly a lot faster (again: subjective). That's also the reason why web servers have gone from the CGI model (spawning a process for each request) to having a set of prespawned processes to handling requests directly in the webserver. 
Do you know how long it takes to start a process on a modern UNIX? The latency is pretty much invisible. Even starting a (non interactive) shell and then a Go tool is too fast to see. Web servers stopped using this model because one can indeed get higher performance out of a custom-knit solution, but for something like invoking a compiler, just invoking the binary is both fast enough for all intents and purposes and much more flexible than creating a custom server and protocol. There are of course situations where the shell seriously eats performance, e.g. when executing configure scripts. You can see that by executing them with a shell like `ksh93` that has special code to avoid forking where possible; runtime drops by as much as 60% on platforms where forking is slow, like Windows. But that is certainly an extreme case.
Author here. The basic things (backup, restore, forget, prune etc) work on Windows, but some features (e.g. fuse mount) are not supported, so we don't yet advertise this platform so prominently.
I have an implementation of tinylfu here: https://github.com/dgryski/go-tinylfu
Really enjoy watching this video. Watched many times. 
I'm sorry what is a btfo?
This question is very broad. Can you be more specific about your needs? Are you looking specifically for an authentication package?
The main difference is that duplicity differentiates between "full" and "incremental" backups. For restic, that's the same: It splits files into blobs of data (based on [content defined chunking](https://restic.github.io/blog/2015-09-12/restic-foundation1-cdc)) and stores these chunks into the repository only once (-&gt; de-duplication). For directories, the metadata for the files and subdirs is stored as a JSON string, so it's extendable. An (almost) identical approach is implemented by borg (a fork of attic). This means that with restic you can use fuse to [mount a repository](https://restic.readthedocs.io/en/stable/Manual/#mount-a-repository) (even remote ones) and browse all snapshots, files and directories. The content is loaded on demand. For authenticity and secrecy, restic does the encryption/authentication process itself, whereas duplicity relies on gpg (last time I had a look). I've done a few benchmarks, and restic is MUCH faster than duplicity. This also applies to restore: restic only fetches the data that was referenced in the snapshot to restore, there's no need to fetch any previous "incremental" backups or so. Duplicity is also much older and more mature, whereas restic is only two years old.
Welcome to Golang! Start small write only what you need, in go it will be less effort and code then it looks like. 
I think you'll find lots of different approaches. I'm sure plenty of people on here have tried similar apps and will have some great opinions. I can only offer my experience. First, I think you're doing the right thing in terms of authentication. I don't recommend anyone build a username+password database. Plus using google authentication is pretty simple once you find the right pictures in the google documentation. However, we are moving towards [Auth0](https://auth0.com) to deal with other possible logins, and will identify accounts with emails. You may find it helpful to add a special "dev" mode for the server which automatically logs you in without asking google for permission. This can be really helpful when first starting out. Are you planning on using some kind of REST thing or websockets to stream events to the client? Is there any multiplayer aspect of progress quest? If not you could actually run everything on the client and then just save the progress everyonce in a while. In fact you could probably do it without a server at all by taking advantage of something like paste-bin to dump "save files", I just don't know how you get a deterministic URL from the user. That might be fun. But if there is multiplayer or you want to write all the logic on the server, then you might want to look at other databases too. It might be fun to try out a graph based solution or maybe you need something very simple like "bolt" which is great to use in Go. Or even sqlite3 which is super easy to get started.. In terms of the front end I'm definitely not an expert. But I can say that React + [storybook](https://getstorybook.io/) (which is similar to devcards for om) is great for front-end dev stuff. We personally use typescript+react+redux. It absolutely has a learning curve, but once you get going it's really nice. But you should also consider other options like Vue, I've heard great things about that too. I have never done any "streaming" things in react but I am sure there are docs about it. It sounds like a sounds project though, so keep it up!
Man. Massive thanks for this write up. Both look very intriguing, storybook AND Auth0! I gotta run right now, family calls. Thanks!!! :gold: 
No problem and thanks for the gold! Let me know if you have any other questions about our setup or things. Good luck!
If you are using Go 1.7 you might want to checkout Chi instead of httprouter as it scores a bit better here https://github.com/diyan/go-web-framework-comparsion with no thumbs-down on any points. httprouter is fine, but it doesn't really have a middleware stack, which they then suggest using gorilla/handlers for, which leads to at least 2 dependencies needed instead of 1 if using Chi, but that's just my 2c. Both should perform about the same with lots of routes, as both are based on a patricia radix trie. I'm all into libraries that don't have any external dependencies of their own, makes managing my dependencies a lot easier. Edit: For authentication, I know there is authboss which might be easiest to go with for now... Personally I have just done authentication myself using bcrypt for password hashing, Gorilla sessions for managing the session and a simple session and auth middleware of my own.
It would be nice to see a feature by feature comparison with [Borg](https://borgbackup.readthedocs.io/en/stable/). +1 for being written in Go. 
How does restic compare to [borgbackup](https://borgbackup.readthedocs.io/en/stable/)? Edit: I see /u/Marvelt asked first
In the refactoring example I would have stopped after the first step. The links look the same but they are not, they should be allowed to grow independent. One will get a target=blank and one will get a class in the next release.
The way I image this working is creating a proxy in go with the tracking/blocking features you want, and then configuring your browsers to use this proxy. Go is well suited to these kinds of networking tasks, I think it would be a good choice for your project.
Yep. Make sure not to miss https://godoc.org/net/http/httputil#ReverseProxy, it's very relevant and a good starting point.
Yum.
I was so hoping someone would make a Blue Oyster Cult reference :)
I think it's more that they're a lot more extensible, and they keep your concerns separated. Instead of having all the logic of the entire program and anything that could ever want to call the calculator inside itself.. he could externalize each piece, so they don't need to be packed next to one another. And in fact, anyone can then implement whatever calculation they want and pass it into his calculator, so it can do things he might never have thought of.
From what I could saw, it follows the open/closed principle.
&gt; Not idiomatic because they force you to embed handler to your controller struct I'm curious, who said that? P.S.: HTTP handler &amp; middleware sections look like "cars have wheels, planes have wings, people have legs" kind of comparison to me.
As a neophyte myself I read this thread and in particular your posts with my eyes wide open. I'm afraid this is going to happen to me as I begin my journey into software development and unfortunately as I read test..test..test I hear in my mind how..how..how. Do I test by trying perceived input that's likely to cause problems? Is this a manual process? Not many beginner (introductory) software books cover testing implementation. I hear buzz words "edge case" without really understanding what it means. Go is touted as having great testing framework built in but because of the previously mentioned mystery surrounding this important - plainly apparent from your very analysis - corner of the development process it eludes many amateurs. How does one as a beginner understand the cases? Without the experience do you rely on the generosity of experienced individuals like yourself? I feel the authors pain here and applaud his candid statement of embarrassment. People usually bring their egos and would never admit to having coded such an oversite. 
Honestly it really depends on your programming experience and actual interests. You can find simple CLI programs you like and try to reproduce them without looking at the source. You can try a Go(ha, pun) at using a GUI library. If you wanted to you could even create a web server (ran via Go) that serves up templates and dynamic forms connected to a database to create a little CMS or social type site. Personally I did all of the above when learning Go and I also signed up for HackerRank and started solving CS problems using Go. But no matter what you do the most important thing is that you're writing in Go.
There's plenty of other solutions too, [facebook/grace](https://github.com/facebookgo/grace).
Does this tool not parse main.go? I'm trying to analyze a project with a lot of `var x = flag.String(...)` statements in main, but when I run a toy program to list all the package's global variables it only lists the ones in other files.
Socket programming is always fun.. have you tried a chat server? IRC bot? Something puzzling that will improve your low level knowledge?
Yep, the API is just a bit tricky (or I haven't discovered a better way) with main's, I probably should have included an example for them. This is how I import mains: ctx := srcutil.FromDir("/yourgopath/github.com/username/yourmain") pkg, _ := ctx.Import(".") To have the import be relative to GOPATH, you could do: ctx := srcutil.FromDir(srcutil.DefaultContext.GOPATH + "/github.com/username/yourmain") Should probably be a cleaner API for this, like ImportMain. Have fun.
Well, actually, there are 3 reasons: 1. `goimports` gets hiccups and takes more than 3 seconds (according to GoSublime plugin) to finish its job. The project I'm working on is slightly bigger than average :). Machine specs are: 2,5Ghz i5, 8Gb RAM, SSD, OSX. 2. I was looking for a cool idea to hack into, so decided to go and ask community first :)
Thanks for providing these details. Just to help me understand, in what way is doing encryption itself better than relying on gpg? After all, gpg is a long-existing standard, tested and proven.
There might be situations where you want to hide the implementation detail of your thing only being an int. You might want to disallow the usual arithmetic operations if they do not make sense for your type. If your struct T represents a "house number", perhaps you don't want or need people to add or divide house numers. Otherwise, you are probably better off doing just type T int
Indeed it is, but interfacing with GPG from the perspective of a program which uses GPG as a component to handle the encryption is very hard and error-prone. On the other hand all the required functions are available in the Go standard library. Also, restic encrypts (and authenticates) each blob separately, so there would be A LOT of GPG processes. One of the project goals for restic is that is should be very fast (so that you're not tempted to skip backup because it takes so long). Encrypting data directly in Go without calling GPG is a good idea in this case.
Hi there, not sure how ya came about this post it's a bit old. There are a few questions here, I think I can narrow it down since you seem to understand already that security and general bugs are a natural part of software engineering. So how do you develop software **responsibility**? Since all we can do is be responsible through diligent attention to detail and not breaking away from our most recently established best practices. Even when the task at hand is mundane, the development equivalent of washing your dishes and doing laundry.. sometimes for hours. Not breaking away from *your* established best practices is what allows you to code responsibly. It allows you to comfortably claim ignorance rather than negligence for your mistakes. Leaving you consistently troubleshooting bugs that out skilled you, rather than chasing down an oversight that you learn nothing from. It will keep you from getting defensive when your more senior developers call out your mistakes because you won't feel like you did anything wrong. When they do their tone will be set by your ignorance or negligence, they will know which one you were guilty of! They want to spend their time with you filling your ignorance, not scolding your (or watching you deny) negligence. I know this is not advice directly about how to test a piece of software, or more broadly speaking how to define your best practices. But it is the best advice I could give you. Now let's talk best practices, I can't dive this to deep right now but if you want reply and I'll circle back around. Me personally I develop using a pattern similar to TDD, I make sure that I am always open to integrating small changes in my development processes to become more efficient. I want to spend as much time as possible in my problem domains, not trouble shooting tooling, build systems, etc. This is why I like Go, not because I enjoy writing it.. but I spend less time reading it thanks to its rigid constraints. Moral of story is keep your tooling simple, strip out as much as the noise as you can and stay close to the metal so you can really learn how software works. I typically develop with 3 focus areas, my most direct line of sight has my most complicated problem in front of it which is almost always library code. Though occasionally some more complex unit test or initial setup of some test structures will take that real estate. To the left I have my unit tests that are associated to whatever library code I have in my main screen, to the right of where tests are being ran each time I save a file. My work flow is to decide in my unit test how I want the library to look from the users perspective and write a test defining it. This lets me catch design oddities or impractical usage that is hard to see from within your library. It's more important to me than anything that my API's make sense because it's where I and my peers will spend all their time after I write it. So once I write the code from the users perspective and it looks clean I now can focus on implementation and won't get side tracked refactoring as an ugly API exposes itself part way through. Now as I implement I can slowly see more of the tests pass proving implementation is corrrect. It also means if I follow this pattern diligently than I am less likely to cause regressions or introduce new issues because the past behavior is defined and can be easily tested. What works for me may not work for you, but this is what I do. Work efficiently and responsibly and you will spend more time learning. The more time you spend learning the more efficient you will work, and so on. Have fun and.. test test test, efficiently! 
Check for redirections.
I've used https://github.com/jinzhu/gorm quite a bit and loving it (with Postgres)
Given all "microservices" are close to each other in network topology, network latency is neglible compared to GC STW. I work in a firm, where microservices are implemented in C/C++, so no GC pause at all. And most servers are in one datacenter, so no remarkable network latency observed. In fact, GC STW were one of reasons I didn't convinced my team to switch to Go several years ago (at the time of Go 1.1). There were other reasons also (I spent too much time to build prototype, cause I was perfectionist, and I tried to gain as much performance as it were possible with Go 1.1 (so cause of it, prototype were too complex)). It is really hard to compete against C :-(
borg developer here, some more factlets: * borg encryption is optional, but on-by-default since 1.0. thanks to openssl, we have hw acceleration for crypto, if cpu supports it (most recent intel/amd cpus do, except the very cheap ones). * before the fork, attic had ~5y history, the borg fork exists since mid 2015. * borg has simple sparse file support at extract time - this is **essential** for VM disk files, otherwise you'll have a very bad day when your VM disks won't fit on your hw any more when you extract them from backup. * borg supports xattrs and ACLs * borg supports lz4 (super fast, low), zlib (medium) and lzma (high, but slow) compression * borg supports linux, mac os x, freebsd, netbsd, openbsd (all these are regularly tested via vagrant, some on travis-ci). it should work also on windows/cygwin, but this is less tested. there is an ongoing native windows porting effort in the "windows" repo branch. borg supports big-endian and little-endian platforms, intel/amd x86/x64, arm, powerpc, ... * sharing a repo is currently only possible in a sequential manner with borg * i don't have a perf comparison for FUSE, but yes, borg preloads data if you mount a single archive with it. if you mount a complete repo with it, it will delay an archive's preload until you cd into subdirectory associated with that archive. i'ld imagine that while preloading adds a bit of startup time, it might be faster later because all essential metadata is in memory. * borg targets 2MiB chunk size by default since 1.0. attic and early borg targetted 64kiB chunksize, but that led to excessive resource usage if one has a lot of data. the chunker is configurable, so you can use what you want. * yes, borg gives quite some options to tweak. if possible, there is a useful default. * borg does not (yet?) support amazon/google/... cloud storage (there is rsync.net and they support borg, though). borg does either use a locally mounted filesystem (including network filesystems) or talks to a remote borg process via ssh. Not sure about whether these ones are supported / how far they are developped in restic: * borg fully supports hardlinks * borg uses some local caches to avoid network roundtrips, if possible (e.g. a chunks index, a known-files index) * when doing a backup, borg checkpoints every 5 mins (default), so if it gets interrupted, it does not need to retransmit all the data. the checkpoint archive is a valid archive, it just does not have all the files, but only all up to the checkpoint time. * borg check has some means to detect (and in some cases fix) damaged repos / archives / files. it can also verify that all data in the repo is valid.
I am interested in this subject as well. I am considering using Go for a new project and I am evaluating what to use for database access. Postgres will probably be the database. I am considering std library vs some kind of orm library. May I ask how come you decided to go for an orm library vs the std lib?
Thanks.
Looks great. Really pleased that there is no mention of rewriting import statements, or package paths in project source code!
borgbackup (attic fork) developer here. Just wanted to say that I have looked at quite some backup software design documents recently (and sometimes also code, not in the case of restic, though) - mostly to gather ideas for borgbackup. :) restic's design is quite impressive: simple, elegant, secure (AFAICS). although it is young software, it is definitely worth considering. tarsnap seems also be very well designed, but it is not free software (as in FOSS). when i discovered attic about 2y ago, it seemed to me the best FOSS deduplicating, compressing, encrypting, authenticating backup software. i liked it that much that (after trying to contribute to it, which didn't work too well) i finally forked it to borgbackup. since then we have fixed a ton of small (and also a few big) issues and added some features, but the overall design of attic was also impressively good. now we have the luxury of having multiple, somehow similar, but independently designed FOSS backup softwares - good for exchanging design and implementation ideas. \o/
But no generics, eh? 
I've had a lot of fun making a neural network that plays tic tac toe. It really pushes go's goroutines to the point where you can start to see the overhead of the context switching between go routines. Having every node of your neural network in it's own go-routine, listening on it's input channels, doing it's calculations, and sending to the next layer on an output channel makes you feel bad-ass!
Without time to test this morning, I wondered about the 'A' as well.
delicious! Once a gopher, just chill, relax the Go team got you covered. 
I'm so sorry, just fixed it, thanks for letting me know
These all seem like much worse options.
&gt; Pretty much everything you suggest would significantly complicate the parser and spec. I see your point of being okay with the current syntax. But the "would complicate the parser" part is kind of strange to me, because that's an argument against every change.
No, it is equivalent to `struct{int int}` because type `int` has neither fields nor methods. (Of course, `struct{int}` and `struct{int int}` are distinct types.)
Allow me to begin by thanking you for your time with such a lengthy reply. In my limited understanding of TDD it's acceptable procedure that writing the test for functionality or feature of the software may come before the feature is coded. The developers task is to then write code which passes said test / tests and then refactor and repeat. In your reply you talk about approaching the API from the users perspective. To make clear from your statement do you imagine that as a user you expect a function - for example - that colors a shape to accept a shape(reference), and the color, and return error if unsuccessful. Then code a test which passes shapes with valid and invalid field data along with color data both valid and invalid. Next, implement the ColorShape function so that it colors the shape - it's primary purpose - and returns error on invalid input without crashing the application. Am I on the right track or waiting for a train that's not going to arrive? My interest and questions above result from your test of someone else's code. It may be too much to ask. But, I believe an explanation in how you tested this code would add value in better understanding the process - even if it's a process unique to you. It's evident that you have skills forged from experience and understanding. "The main thing I would take away here is the importance of testing. This bug would have surfaced very little if you tested FolderOf with a basic set of file system inputs! Test test test :-)" 
Lambda
&gt; But the "would complicate the parser" part is kind of strange to me, because that's an argument against every change. a) That's not true, there is the possibility to simplify the parser with a change. b) Even if it where true, not every change complicates it *significantly*. You are suggesting removing a bunch of keywords from certain parts of the language, which means the parser now needs to infer from the context what was meant, by looking at more tokens and add a bunch of extra logic. Keywords serve an important purpose in the language, as they can remove context-sensitivity from the language. c) And lastly, yes, it is an argument against most changes. Meaning, every change needs to have benefits that outweigh this argument against them.
I've found that a static website generator is a good start. It will familiarize you with the standard library, and it's conceptually simple (just converting markdown to HTML). This will cover file/IO, directory traversal, and templating. You'll have to use a 3rd party library like http://github.com/russross/blackfriday for the markdown support, which will also introduce you to dependency management. Depending on your prior experience, this might be a bit advanced.
Great talk. But since I started to use SOLID principles in my development, I do not have most of the problems about which she talk. If you will stick to SOLID, you will have modules with loose coupling that easy to test and refactor. This is 101 for programmers. It is shame that I do not see a lot of talks on this topic.
I've been playing Airmech on and off for years. I had no idea the server was written in Go. Huh. As long as I seem to have stumbled across a developer, I have a question: Was any of the gane's direction inspired by an old freeware game called Rapid Aerial Deployment? I first started playing Airmech because it reminded me of it.
You are on the right fact as far as TDD goes. Now to be honest about the bug, if i recall correctly I was reading his github while my car was being washed. No special process or anything on my side. It wasn't something I needed to test for, that's a nice side effect of Go having a limited (but still powerful) syntax and feature set is it's easy to decompose. So to answer directly I think this big was found mostly by experience from my part, certain functions are more dangerous than others, such as removeAll, so I just focused on its possible inputs by observing its callers and call sites. I said he would have found it with unit tests because he would have been thinking about the inputs to provide it from the perspective of FolderOf directly. He likely tested it by calling the highest entry point of the API, like running his command against a URL. This obfuscation took the focus of individual inputs of a security sensitive standard library function and made input permutations harder to test for. 
I'm using golang.org/x/crypto/acme/autocert successfully in a production project. As for rate limits, as far as you use the cert cache and a Manager.HostPolicy on the Manager configuration, you should be OK. The certificate request will be only done the first time and then when it's about to expire. About the comment for the Manager.HostPolicy, it's certainly recommendable to use one. For me, i needed to allow *.domain.com domains, which is not supported by HostWhitelist(), but is realy easy to get a HostPolicy for that: // ... HostPolicy: func(_ context.Context, host string) error { if !strings.HasSuffix(host, "domain.com") { return errors.New("Host not allowed") } return nil }, // ... You can easily implement a HostPolicy that meets to your needs. 
www.projecteuler.net is where I first learned to code with compiled code, just using the exercises there. It's a little different from the more recent coding quiz websites in that it just checks that you know the answer, so there's no fiddling with making your code match their input or outputs.
&gt; certain functions are more dangerous than others, such as removeAll, so I just focused on its possible inputs by observing its callers and call sites. Profoundly simple and true. I think that statement sums up a starting point for me. Thanks so much for your insight. 
Does this mean Go will be as cool as Node.js (npm) in 2017? 
I strongly recommend watching Rob Pike's talk [Simplicity is Complicated](https://www.youtube.com/watch?v=rFejpH_tAHM). The whole thing is worth watching but [this part](https://youtu.be/rFejpH_tAHM?t=311) in particular is the main reason go doesn't have 2 different ways to declare functions (or do much else for that matter). Anonymous function declarations look almost exactly like normal function declarations. No special "-&gt;" or "/" lambda syntax. No implicit dedicated variables like "it". It's just the same boring syntax you use everywhere else but without the function name. Not having 2 different ways to do everything is why we love this language. We wont change that to save a few keystrokes.
-&gt; Bearer &lt;ACCESS TOKE&gt; &lt;- HTTP 420
there's another ORM called SQLBoiler: https://github.com/vattle/sqlboiler This ORM is tailored to your database schema instead of the classic "code-first" approach like gorm\gorp\xorm
Vendor folder, git submodule. Solves your use case.
I hope not.
&gt; Bonus: easier to type. The harder it is to add another dependency to a project the better.
Superb, does the OSX port require Accessibility permissions to do its thing? Good luck with the maturation of this project, I believe ui level automation in cross platform way to be massively important and (due to difficulty involved in doing it right) under served area in computing in general.
sounds like a job for https://github.com/nvbn/thefuck
[This approach](http://www.keybr.com) might be more pragmatic than trying to change the go syntax :)
Not a fan of "SemVer" :( or version ranges.
What's the difference between this and the previous discussion? Same article, nothing new.
I would counter that with a few points. Programs written using JS or C are not all by choose. JS is used because that's what all the browsers support. C for existing code, availability of compilers, and because C code can be embedded by many higher level languages. I also believe most programmers who write primarily in JS or C are also polyglots. For JS it is a server side language (at least before node, but its a fad I tell you); and for C it is C++, other high level languages, or for those who likes lower, assembly. Walled gardens don't leak, look at all the Microsoft programing languages, from Visual Basic to C#. You just don't see them used outside workshops targeting Windows development. More to the point, learning another language is easy, and greatly satisfactory to a curious mind. There is also institutional resistance to switching languages, so the existing languages won't go away, creating more diversity over time.
Could you expand that a bit more? What nodes? And what does each node do? What are the layers and the calculations? Is it AI vs AI? Sounds very interesting but I can't imagine anything tangible in my mind.
Project Euler is pure math after a few (20+, maybe 40+) questions after that you can only succeed if you have a scientific background in math .... 
Well, I've solved 103 and have no scientific background in math. I wouldn't say problems until after 100 require it, and then there are references you can find online to help you out. I agree at some point they do become a lot of 'do you know this random math sequence' type question, though.
You're trying to be funny AND clever right?
I personally think that blindly adding dependencies like they do in RoR, nodejs and possibly other ecosystems is very harmful.
Set is probably not a good candidate because it is the word in the English language with the most definitions, and thus the most ambiguous.
&gt; Why a Manifest file instead of appending version info to the "import" statement? import "github.com/some/pkg@4.x" Two files in the same package import the same dep at different versions. What do you do? Do you mandate the same version suffix for all import statements? Good luck getting that to compose nicely with tooling! No, this approach is superficially appealing, but quickly falls apart on scrutiny.
I can currently extract every anonymous function into a function or method pretty much with a few small changes to the signature only. What you propose is just more work down the road for a few saved keystrokes. Imho you should learn more about the editor you are using and find out how you can do that with it.
Why? (Personally I'm a big fan)
Is there Wayland support in Linux?
It's looking a lot like glide. I'm ok with that.
Yes, but any dep tool must collapse all transient Manifests (and concomitant vendored deps) to the root, including resolving conflicts.
Thanks, Damian. I'm writing more benchmarks before adapting your implementation.
I may be missing something, but it looks like hijacked connections are just removed from the tracked connections and if I'm not mistaken WebSockets hijack the connection; so my question is, with this change how would one ensure graceful shutdown of connections including WebSockets? it appears that they would be interrupted after all idle connections are done. update: asked this question in issue itself hoping to get an answer https://github.com/golang/go/issues/4674#issuecomment-257549871
I used to use https://bitbucket.org/liamstask/goose to apply sql files, but goose has some bugs. So, I created https://github.com/eure/kamimai, which supports only MySQL driver now. May you want other drivers?
 \n or on windows systems: \r\n you could do output := strings.Replace(input, "|", "\n", -1) windows: output := strings.Replace(input, "|", "\r\n", -1)
No, yarn. 
Maybe a bit of an over engineered example but this would allow you to wrap your os.File(or any other io.Writer) with an io.Writer to allow streaming data while replacing '|' with either '\n' or '\r\n' https://play.golang.org/p/zOriezNUn7
Yep,The global event listener need Enable Access for Assistive Devices
Use x11 in Linux, maybe support Wayland in Future.
mattes/migrate's last commit was in march. It's got a bunch of PRs that aren't being merged. Although there was a fork that's aiming to take over development, I ended up having to create my own library as getting it to support embedded migrations would basically require a rewrite. Goose was last updated in January 2015 and there are also heaps of unmerged PRs. Unfortunately, there doesn't appear to be a fork that's under development.
I'm not sure if it's realistic for the entire system (i.e. including kernel), but most everything else would fit. A fair bit of C code in Plan 9 uses CSP constructs, which are implemented as a library. Many utilities like Acme were written in Alef in 2nd Ed, and there are versions of Acme and Sam for Inferno written in Limbo; Go is related to both languages. Rewriting Acme or Sam in Go for either Plan 9 or P9P would be useful and educational. 
Things coming with 1.8 * HTTP/2 push https://twitter.com/DasSurma/status/793117186529329152 * Sub ms pauses https://groups.google.com/forum/m/#!topic/golang-dev/Ab1sFeoZg_8 * Graceful http shutdown https://github.com/golang/go/issues/4674#issuecomment-257161323 * SSA for more architectures more at https://github.com/golang/go/milestone/38
 * sort.Slice: https://tip.golang.org/pkg/sort/#Slice * Default GOPATH for beginners * Plugins: https://tip.golang.org/pkg/plugin/ * Alias declarations for refactorings of packages
Because it is related to vendoring and belongs together with other files related to vendoring. Is there a compelling technical reason for why the root directory of a project should be filled with anything else but the files that are of the main interest (the sources files) and subdirectories containing less interesting information (related to vendoring, documentation, etc)?
I'm offended by non-assertive statements like the one you just made!
I'm offended by your comparison with jury duty. It's not at all comparable.
Now I'm curious about this too.
Are we going to see an experimental Go compiler back-end for WA any soon?
No thanks. But we probably won't since WA won't let custom runtimes in yet.
I'm more or less sure that's not coming yet. WA is too limited (if compared to say, x86 assembly) and doesn't support hardware parallelism either. ... unless Go team pushes it to the point major vendors add specific instructions or whatever.
I really appreciate the clarity of the way it is now. To me, having alternate context based syntax is more cognitive load. I prefer the smaller language and the consistency. A function always reads as a function. 
There is a sub dedicated to Go game development, but it's not very active as of yet: https://www.reddit.com/r/gogamedev/ Looking at github, there seems to be a lot of game framework/projects in development, an example: https://github.com/EngoEngine/engo
Sub ms pauses for stop the world. Not every thread, there it can be much longer. Also 1 frame is huge. So no.
Without being a game dev or having time to look at the Go Game Dev subreddit below, I'd guess that for games Go can't be any better than C# or Java (which at least includes Unity and Android games between the two) simply because eventually anything that's not written in C or C++ will need to make calls to OpenGL (or a wrapper), so you'll have opportunity for many genres, but we'll remain far away from porting most complex stuff to something that isn't C or C++ for our foreseeable future.
I really want to agree with you because a sparse root feels good, but when I think of C#, Node and Python, I see that sort of file in the root rather than packages, node_modules, or the venv, so I feel like root is more consistent. Perhaps that decision was made by someone who felt it was one of the most important files in a project, and that seems reasonable to me. I do see where you're coming from though.
Even though the STW is now typically below a millisecond, what can be expected to be the overall CPU increase? It is my understanding that while the STW is reduced, the tasks it used to perform in the STW are now concurrent with the actual program, thus incurring a slight performance degradation in the program. This sounds like the overall performance impact (over longer periods of time) is on average unchanged. Is this true? Besides, is there a detailed performance analysis of GC and non-GC languages? GC time consumption can be readily measured, however non-GC language users often think they have zero overhead, while in reality they keep track and free memory themselves which is time consuming of it self. This is not easily measurable though, as memory bookkeeping is often subtle (eg. increase the reference count) and happens anywhere in the code.
I don't think there are major issues implementing go in wasm. We have a go implementation in js after all, so parallelism clearly isn't necessary. Furthermore, there's a go llvm frontend and a wasm llvm backend so…
C#, Node and Python all have a less clean build-system and packaging methodology than Go, though. Go is already better than all three, when it comes to keeping projects clean and simple. I see absolutely no reason to use C#, Node and Python as "role models" for how Go should become. All have more cumbersome build systems and dependency systems than for instance "go build" and the "glide" utility (which places glide.yml in the root directory, so that's an argument in favor of your point of view).
Afaik Nginx supports it. Context: Im currently looking at replacing Apache Trafficserver + HAproxy with Nginx.
Because the 100us Pause is for STW, each thread can have much longer GC pauses.
How so? Jury duty exists to prevent fringe participants on a volunteer basis skewing the justice system. The issue that constantly comes up with CoC enforcement is overzealous participants with attitudes more representative of the fringe than the center/average demanding the community shift to their position. If the only people that enforce a CoC are volunteers, then the enforcement team is likely to have an enforcement agenda, and look for excuses to enforce (like in OP's case). Having rules written down is generally a good idea in advance of needing them (why having a CoC is a decent idea). But enforcement should be more like jury duty, where it's assigned to core participants on a random and rotating basis (to capture the norm, not the fringe). The way it is now is a situation that's a bit of a ticking time bomb, as the polarized enforcement team finds itself (and its perspective on where the line is drawn) at odds with the community at large. 
Why does calling into OpenGL concern you? How would this affect Go more than C# or Java?
Enough of this microviolence against people that do not think the situation is comparable to jury duty! I feel opressed and offended. Quickly, someone use the CoC and intervene! We need a safe space, without undue comparisons with jury duty.
I don't think it would affect us more than it does C# or Java. I'm just sad some billionaire with a love for Go hasn't promised to port all OpenGL to Go because then it could replace C and C++ in game dev instead of being on a similar level to Java and C#. ;)
http://i.imgur.com/xp9sE9Z.jpg
Right, but this time shouldn't affect the game loop provided you have multiple cores, no?
The cleanliness and simplicity of Go is fantastic, and I'm not sure how the packaging will change that, but I'm guessing most projects will still work like they do now and only complex projects with a specific need for a manifest file will actually use it. If a manifest file isn't common, then that adds to the reasoning for showing it off in the root directory. C# is a good example where I love how Nuget is able to build a very complex app with a million dependencies. BUT, this leads to what I also hate the most about C#: it's so complex! And making a Nuget spec file takes a fair bit of reading the first few times.
Presumably if your GC is pausing for this long, it's either horribly inefficient or you're actually generating so much garbage that an equivalent malloc/free program would suffer the same performance.
Does anybody know videos/channels with code reviews in other languages?
 func main() { go server() client() } You have a note about applications avoiding a race condition in a real application, but a simple time.Sleep of a couple of seconds would solve your problem for your demo program.
I hope I get the chance to stop using javascript to develop for the web. It's not cool at all. Crossing my fingers to be possible, at some point, to compile go to WA.
At this point tools are likely to have so little impact on your overall performance that I wouldn't worry too much about them, but here are a few that I know some people use: - https://www.jetbrains.com/webstorm/ - sublime text 3 + the gosublime package - atom + go packages (forget the names) Both atom and sublime have a lot of great packages you can add to them that are useful. Not all are go specific. You can unit test via the command line for sure and I would probably start there. Having a rough understanding of how to run tests and do other tasks with go via the command line is useful.
I primarily use atom with go-plus. I would also recommend vscode with the go extension. (I have visual debugging working great on linux, I am not sure of the state of the windows debugger) 
Exclusively vim with vim-go nowadays. Before I used liteide (a bit weird to setup but good completion) and long before that the intellij plugin.
haha if everyone was using SOLID perhaps there will be no material to do talks about
could elaborate how you are using this on chromeOS.
The proposal for this doc listed two phases of changes. The first set being STW reduction as we are seeing. The second set coming in 1.9 and beyond are the removal of unnecessary checks that were required for the old style of write blocks as well as potential SSA improvements (if I recall the proposal correctly). Even if we break even now, we should see improvements in the next cycle. And in the mean time we can still enjoy much better delivery garuntees for anything already intended to be close to real-time. 
For windows, I would recommend vscode. Especially to get the Visual studio kinda feel. It supports step-by-step debugging through delve. You can integrate unit testing too. Ref - https://github.com/Microsoft/vscode-go#commands
I'm using the go plugin with webstorm and it works really well. I'd imagine it works just as well on intellij
Also, defer will be 2x faster.
liteide works great for me
Webstorm isn't free though right? All the jetbrains IDEs use the same platform. The paid ones have more. I personally use PHPStorm, as I normally work with PHP, but the Golang plugin lets me work with it as well which is sweet. Don't need to learn a new IDE plus I have DB controls built in.
I use visual studio code.
Likewise.
The reason I ask is because this same exchange came up on the #vendor slack chat. It went like this: **Zach Gershman** &gt; hey @sdboyer saw your comment about where these files go and I wanted to respectfully disagree. I also thought dismissing the concern out of hand as bikesheddy was a tad bit harsh &gt; &gt; and I get that you all are getting a lot of comments about this proposal - so I don’t want my comment to come off in the wrong way. &gt; &gt; The vendor folder isn’t just an abstraction it is actually the standard (for now). Totally open to having that morph into something different at somepoint but I do believe that all things dependency related should be kept in the ⁠⁠⁠⁠vendor ⁠⁠⁠⁠ directory. &gt; &gt; and I also want to state that I understand that this is a small detail in the grand scheme of the whole spec. I don’t think it is totally crazy to at least stick to the vendor standard that just got fully established in this go release. &gt; **Peter Bourgon** &gt; @zachgersh: keeping Manifest/Lockfile at the root allows users to more easily gitignore the vendor dir. it also isn't obviously worse than putting them in the vendor dir. (shrug) we had to make a decision and that was it, absent some compelling technical argument otherwise it's pure bikeshedding to revisit it &gt; that said if you have compelling technical arguments please raise them :)
I mainly use Mousepad, xfce's plain text editor.
It was my pleasure.
I'm using atom with go-plus, but sometimes switch to IntelliJ Idea with hers go plugin
There is a user space project at https://github.com/mortdeus/goblin
Any C call via CGO has 100+ns overhead, put few thousand OpenGL calls in a game loop and things become unusable. Not a GC issue, but stack switching if I understand it right.
LiteIDE FTW all the way.
I'm surprised nobody mentioned Intellij here. I used it so far with no problems. It's there any reason why it's not popular with go?
What do you mean by security issues? You can encrypt your chroot, but I don't because once I broke it once and wanted to edit some files directly from ChromeOS' shell. I did set up a dev-password for the chrome shell, and I think that's good enough for most things. But I still try to avoid leaving my laptop alone in a public space.
[acme](http://research.swtch.com/acme)
vscode + go extension + delve on both OSX and Ubuntu
Pretty sad that the vendor team doesn't seem to care so much to preserve the simplicity and cleaniness of Go aka needing no configuration. On the other hand maybe it's not possible. The problem they are trying to solve is not simple. But we haven't seen any innovation either. Just a tool with the only advantage vs existing solutions is that it's going to be the "standard". I don't want to sound too negative. This is just a first draft so I am keeping my fingers crossed.
I just use Sublime Text 3.
Intellij with the go plugin.
Maybe you should try to do this with Rust? 
For most basic simple things yes, for anything serious no. Scene graph with few thousands visible elements may call minimum x3 number of OpenGL calls (MultMatrix, CallList etc). As scene grows past certain limit budget is gone. Without code hacking (moving calls to C code, then calling it only once per loop) it can't be used as with C++ or any other language which has no overhead.
I'm curious, given many people in this thread use VSCode. Doesn't it lag? I'm on a 3.4GHz machine with 32GB of RAM (and a gtx 960) and it friggin lags to high heaven. Ubuntu tho. Atom's even worse.
This is my first small Go project. I'd appreciate some feedback from more experienced Go developers.
Cool, it should go without saying, but you might want to annotate that this should only be ran supervised from a sandbox environment under restricted cgroup. This could be used for a denial of service from a network perspective or just completely exhaust the target machines memory. Also aside from that keep in mind all of the logins are just bots probing for insecure machines, by granting a successful login you may get promoted to be on a malicious groups radar for a more thorough scan. Could be free penetration testing, could be the start of emails to all your customers that you leaked PII data :-) - food for thought from security perspective. Still a cool idea and good execution though, good job.
Client was written in C++ (graphics library was bgfx: https://github.com/bkaradzic/bgfx#bgfx---cross-platform-rendering-library), just backend was written in Go.
ahh ok, I read the above post as the whole thing was rewritten in go
I do agree that Go, like any language, has a finite upper bound on the number of OpenGL calls it can make between frames. I also agree that it's less than C or C++. The real question is whether or not profitable games can reasonably be made within this boundary, especially when you factor in the cost savings from developing in Go rather than C or C++.
vim-go
&gt; If your physics + audio + AI loop (each in a separate thread) has 10ms GC pause 3 times a second then this won't end well. But it doesn't. There is no such pause, especially not for 10ms. And you don't schedule things on threads in Go.
Perhaps its size. It's too big and complex. Atom and VSCode have made Go development way easier.
I agree with [Dave Cheney's opinion](https://groups.google.com/d/msg/golang-dev/OmjsXkyOQpQ/EkERNkTeAgAJ) on this; this whole thing smells like quid pro quo for Google. All the justification for aliases in that thread are about how Google's mono repo for all the code in the company makes it difficult to refactor things without breaking other stuff. What they *actually* have is a dependency versioning problem, but since their code organization is The One True Way™, the problem is somehow a deficiency of the language. Both in that thread and [the issue](https://github.com/golang/go/issues/16339) on Github, the vast majority of non-Google feedback was negative yet they are still going through with it. A lot of people are naturally concerned. That said, **I fully accept it's their language to change**. I just wish they would admit to violating their own "KISS principles" for a Google-internal problem. **EDIT**: Here's a direct quote from Rob Pike: &gt; The alias feature is directed at [...] refactoring a package in an environment too large or complex to update all the dependents of a package at once. This problem is often seen as a versioning problem, but in monorepos versioning doesn't help, while aliases do.
Actually, I'm a big fan of monorepos. I just don't think aliases are the correct solution to this problem.
&gt; With aliasing I could have completed that thankless yak shaving in one day instead and incrementally worked with the long-tail of integrators instead of approaching the problem as all-or-nothing. But isn't that precisely the point here? That you are advocating for a language change to fix a Google-only problem? ~~Also, I don't think Kubernetes is helping your argument here as it also originates from Google.~~ (Redacted, see below). So far, all I've seen from *the community* is that this feature can and will be abused and it goes against Go's "principles". I have no doubt aliases would have made *your* life easier at Google, I just don't see why that means a language change for a public programming language.
Aliasing is a tractable compromise that can be achieved without waiting for Go 2.0 to provide an alternative. As for Kubernetes, I would take a closer look at its governance structure and what it's moving toward before drawing too much of an ownership inference.
How would you handle this — specifically given the problem space I described? Really open to constructive ideas. :-)
No offense, but I don't think your comment is constructive. There is not a single word in your post that address the issue being discussed here; namely, adding aliases to Go. Why do you think adding aliases is a good thing? Why would it make Go a better language? What are the points you disagree on with others on [this thread](https://groups.google.com/forum/#!topic/golang-dev/OmjsXkyOQpQ) and [this issue](https://github.com/golang/go/issues/16339)? Anything beyond "I like Google" is appreciated.
This article from Rob Pike lays out some of the historical motivations for the Go Programming Language and decisions around it (spoiler alert: problems at Google-scale were the impetus, in part): https://talks.golang.org/2012/splash.article. Without those challenges and the determination to remedy them, would we have Go today? &gt; The goals of the Go project were to eliminate the slowness and clumsiness of software development at Google, and thereby to make the process more productive and scalable. The language was designed by and for people who write—and read and debug and maintain—large software systems. &gt; Go's purpose is therefore not to do research into programming language design; it is to improve the working environment for its designers and their coworkers. Go is more about software engineering than programming language research. Or to rephrase, it is about language design in the service of software engineering
This is quite interesting. I think the world could use a modern implementation of a new operating system with ideas taken from Plan9. Not entirely sure about re-writing Plan9 as it is but it would be quite fitting if it was re-written in pure Go. Is this an open source project?
Well, the definition of *real discussion* is a matter of personal preference, innit? I'm glad you pointed it out though, we deffo need more people able to tell silly business apart from *real discussions* here.
Thanks for the quote, it's certainly explains a lot of the Googler opinions in golang-dev. I'll refrain from commenting further on that.
I don't buy this myself, come back and remove it later..? Why doesn't Go allow unused variables then, they could always be removed later. I really thing this proposal is just awkward in every quantifiable way. It even looks unpleasant syntactically next to the rest of the language. The reason I have a post history full of good things to say is because I enjoy reading Go. My immediate intuition says this is going to make reading it more difficult and be misused outside Google. It's going to end up being all over the place because.. you can. People are going to put less thought in API design because it will lose that rigid and immortalized feeling when you commit something for use. I can't thank the Go team enough for bringing me my favorite language in years, but Google should have implemented this in an internal fork. A clean implementation wouldn't be hard to internalize you are big, right? You have done this model before and it should have been done here. That's where I believe it should live forever, but if you insisted on giving users a gun facing their foot at least let it bake internally to get a real understanding of the changes. See how quickly your most junior engineers catch up code pointing to aliases. Then multiply that by dozens to Inf for how long it will take everyone else. That all said my opinion of Go remains mostly unswayed. I won't re-evaluate my position until I see first hand a negative impact from it. We will see after a year of aliases being available and how much of the time I save reading Go over other languages is saved. Maybe very little is lost, maybe a lot. Go isn't always pleasant to write, but it is always at least "fine" to read, vs the "worst nightmare" level that can be achieve in other languages.
All the pros and cons discussion for the spec is [here](https://groups.google.com/forum/#!topic/golang-dev/OmjsXkyOQpQ) and [here](https://github.com/golang/go/issues/16339) (especially the latter).
&gt; Well, the definition of real discussion is a matter of personal preference, innit? Yes, obviously. I agree with your post by the way, I have no doubt the people who decided to push this feature through are competent developers for driving the language. I - and apparently most non-googlers on those threads - simply think they are wrong *in this occasion* to solve a Google problem with a language change. Anyway, even *that* discussion is moot at this point since the CL was merged and we'll only know if it was a good or bad decision in the next few years once aliases start appearing in non-Google Go code. Time will tell :)
Maybe. We Gophers are an opinionated bunch. :-) I hope and expect we will exercise restraint and issue sufficient critique as a community if we see aliasing misused. Plus, a reasonably seasoned Gopher can smell a bad package immediately upon opening it. We seem to have no problem self-policing at our current size.
&gt; The goal is that you eventually remove the alias definition Heh, I think we know where this ultimately leads to.
You making the admittedly laborious changes you've also enumerated is also a tractable compromise, which doesn't affect the language design...
I think the real discussion is both, in the since they are tied together. The article subtitle is "Language design echo chambers" and I worry Google's magnified influence of Go's deficiencies and strengths is working against Go's stated goal.
I do think it's a shame that Go as a trademark is controlled by Google and not by a hypothetical Go Software Foundation. I think that if Russ Cox et al. were laid off by Google, they'd probably just do the Plan 9 thing and keep Go going as well as they can without the backing of their corporation (Lucent/AT&amp;T in the case of Plan 9), but it would be at a much reduced rate. Unlike Plan 9, Go is a modest success, so it has better prospects absent Google's support, but it would still be tough, and they'd need a new trademark. 
A feature suggestion: aggregate requests into a digest that is sent to an email address once every day or so. Basically that will allow a way to make rules to ban IP addresses from the router. Also possibly make a fail2ban filter for processing the logs of this. Cool project!
Why can't you write the kernel in go? It's completely possible. I know because I've done it.
I totally side with Dave.
What a heated discussion. I hope the community ends up gaining with this experience, even though the icons of the language are disagreeing at what seems to be a 50/50 rate.
Did you look at the other honeypots in Go? https://github.com/traetox/sshForShits and others https://github.com/search?l=Go&amp;q=honeypot
I starting to lean towards his side as well. I came to go because it was a great tool for my small projects and problems (compared to projects at scale that Google faces). But now I'm starting to realize what Go really is: a programming language focused on solving problems at scale. This philosophy will be a priority on all of Go's decisions. I'm not going to stop using it because type alias will be added. But I agree with Dave that to some extent it "breaks my heart".
VSCode. I use VIM or Sublime for just about everything. VSCode integration worked out of the box and had a few more really useful features. I'm sure the other tooling will catch up but you might as well use it for awhile until then.
Sadly if you are over the age of 35, I doubt this is happening in your career. WA is still being developed and you can realistically expect a few more years before it is unleashed. Once complete, you then have the issue of waiting for WA to be hit some reasonable saturation point in the market for browsers...this is exactly why JS coders can't fully exploit ES6 etc...they don't want to strand the holdouts, of which there are many. And expect even more holdouts. People are holding on to devices like phones, tablets and PCs longer and longer now that upgrade cycles are less compelling. Indeed, as PCs hit the "good enough" phase for most users, expect to see more peculiar cases like people happy with twenty year old PCs and ten year old phones. My TVs are both nearly ten years old and I don't feel remotely "behind"...PCs are going to see the same type of consumer behavior Your only hope would be some sort of controlled distribution channel where you can dictate to users what client they run...but by time that happens it is unlikely the web will be much of a focus of cutting-edge development anyway, likely some VR/AR/smellovision thing
Maybe. If they found a sponsor to continue paying them what they're used to. Many gophers do this as their day job. (And night job)
Thanks for the reply. I don't agree with the points, but it's good to get another perspective. For (2) specifically, it's my understanding that https://github.com/golang/proposal is the authoritative source for what makes it into Go. Do you have a different interpretation of that document, or another more authoritative source? Also, which feature in which language behaves like the vendor feature in Go for absolute import paths?
I've been enjoying Visual Studio Code
Aliases (vomit).
I didn't think you were arguing. What's the most impressive game you could make with CGo? What does the upper bound look like here?
Thanks for posting this! Migrations are important. It sounds like there is a lot of interest in this thread to fork and maintain a tool. Maybe you could consolidate efforts?
Russ' comment - &gt; We all have a natural bias to see "different" as "unreadable". has some value. I remember when Ubuntu's Unity interface came out, there has a huge outcry. People were pissed off and complained that it was unusable. I thought the same too. But after a year or two, it seems okay now. Sorry, that analogy has nothing to do with the problem at hand. But it's only natural that there WILL be disagreements on topics and there WILL be cases where the language creators will add features they think better for the language. Now, is that something purely for the sake of the language or just to solve a google problem, is something time will tell. Unless we have tried the feature out in the wild, nothing can be said for sure. 
To me this feels like, "Whoops, we blew it with versioning/vendoring packages, and we don't feel like investing in refactoring." When I change my Go APIs, I have to refactor dependent projects. That tends to make me really consider my interfaces before I release them. Same with error handling. If they go down the road with this alias cheat, the Go developers negate every argument for Go they've ever made. 
&gt; I don't buy this myself, come back and remove it later..? Why doesn't Go allow unused variables then, they could always be removed later Because there is no demonstrable *need* for them. Unused variables inherently are about a single package, under the control of a single organization. Aliases inherently are about multiple packages, in use by a very wide range of organizations. &gt; People are going to put less thought in API design because it will lose that rigid and immortalized feeling when you commit something for use. This "stability over everything" is such a hurtful meme. It's the waterfall model of API design: If you just think enough, you'll come up with a perfect API that you never have to change again. Well, guess what, in reality, software evolves, the best way to do things evolves and tomorrow you will have more experience and knowledge than you had today. Being this change-averse means, *you can never correct your mistakes*. Even the go stdlib, showing exemplary API design and foresight, is full of old cruft that you'd want to change, because when go1 came out a lot of the needs of the community and a lot of ways that go would evolve couldn't have been foreseen. With this "stability over everything" approach, you end up with abysmal horrors like (La)TeX: Unreplaceable, best at it's job, but also clearly a relic from a past century in dire need of a complete rewrite to make it keep up with how hardware has evolved over the last 20 years. Stability over all is the path to obsolescence. &gt; but Google should have implemented this in an internal fork. I really, really wish this "this is only good for Google" meme would die too, while we're at it. Google has solutions for this. Using the Google monorepo and tools for it is a pain, but it's *possible*. The open source community has *no* way to deal with this. It's literally impossible to even attempt this. And we are paying the price for this *right now*, where the world is getting fractured into two distinct ones, one is using `context` and one is using `x/net/context`. This is a blessing for the community, it's a minor convenience for Google.
&gt; Perhaps I'm naive, but why does vendoring not solve the problem of large scale refactoring? Because it leads to divergent code-bases. You want your code-bases to converge instead. Look at Perlythonubyscript: Everyone and their mother uses a different version of each package. Stuff constantly breaks because of that.
Really? I was thinking I should save it for an April Fool's joke on our security team.
There are many levels of proposals. I've made several, some accepted, some debated. This is a language change. It won't go in without approval be the language core designers, just like the rest of the language. It is a much higher bar then adg or rsc deciding. Other langs don't use paths like go, but not with nestable vendor is really close. Others too. I'm the author of govendor and an advisor to that committee; I've read the proposal and used it in tip. I've been around for over 5 years. Back in 2011, people didn't understand channels and embedding and used them way too much. Like those alias is a tool, not sugar. Learning when (not) to uae it will have a cost. But those same people will benefit from consuming better APIs and fewer odd compile errors, even if they don't use it themselves. Regarding Google, there once was a farmer who had a goose that layed golden eggs...
&gt; Because it leads to divergent code-bases. You want your code-bases to converge instead. Vendoring doesn't preclude convergence. Not _completing_ a large-scale refactor precludes convergence.
I fail to see how the use of aliases in their proposed form have more than a negligible effect on readability. In fact, I think they will be a huge benefit to the language. It's not like it's a feature you MUST use. You can write Go code without them just as you did before 1.8, but I promise you that situations will creep up where you will say, "Maybe I should use them after all..."
&gt; Also, which feature in which language behaves like the vendor feature in Go for absolute import paths? All of them. When a node-developer says "leftpad", it's literally the same as when a go developer says "github.com/randomdev/leftpad". It's just that go doesn't have a centrally mediated namespace as other languages, but instead uses the DNS to disambiguate it and create consensus. But "github.com/randomdev/leftpad" is *the name of the package*. The name is not "leftpad". Once you stop with the false assumption that "github.com/randomdev/leftpad" and "github.com/forker/leftpad" is supposed to be the same package (they are not. They are very different packages, like "leftpad" and "better-leftpad" might be in node), the equivalency should become obvious.
Google needs this. And as you see, despite the outrageous community feedback, Google boys don't really care. As it seems to me, some form of "discussion" is going to take place and in the end it most certainly will end up the Google way. IMHO !RemindMe 1 year "Make sure to check up on Go aliases"
&gt; The argument is that Google's size allows it to better anticipate future need of the industry and the open source community. Source? I don't remember any of the Googlers on that thread saying anything like that; they just said it's a problem with their fast moving mono repo and this is their solution.
IntelliJ. https://github.com/k0kubun/pp is good. It works like spew with coloring.
Interestingly, nothing in this post was meant condescending. Or directed at you specifically, but at those two memes that I refer to. I am sorry that I wasn't more careful in my phrasing. &gt; Are you trying to change my position through meaningful debate? Yes. Please re-read my comment, keeping this in mind, that I was, in fact, debating and not attacking. And then address the points I'm making, in content, if not in tone.
I don't have a public written source, sorry.
&gt; But now I'm starting to realize what Go really is: a programming language focused on solving problems at scale. The scale (in SLOC and contributors) of open source dwarfs even the scale of Google. Most people just don't realize it. As such, this change should also be understood to solve problems [the open source community as a whole has](https://github.com/grpc/grpc-go/issues/711).
I think you might underestimate things a bit. Also it's about the size of the project not all projects vs one project. 
&gt; Now, is that something purely for the sake of the language or just to solve a google problem, is something time will tell. [s/will tell/has told/](https://github.com/grpc/grpc-go/issues/711)
[Only](https://github.com/grpc/grpc-go/issues/711) [Google](https://github.com/asteris-llc/converge/pull/433) [needs](https://github.com/docker/containerd/pull/338) aliases… /s
I can assure you, I'm not ;) &gt; Also it's about the size of the project not all projects vs one project. a) In this discussion, the fact that Google is one organization and one ~~project~~repository actually *helps* it. Because, at least in theory, there *can* be a top-down decision on what the right choice is and there *can* be an atomic global commit. And b) imagining Google as "one project" is severely misunderstanding how it works. In fact, when I describe how it is to work at Google, I usually do it as "imagine a separate, hermetic open source universe with fewer a**holes".
Using it on a mac is a breeze. Tried it on my monster desktop Ubuntu machine as well. Find most programs not run as smooth, but just guessed it to being the window manager and /or program not being as polished. Haven't dug into any settings in the OS however. I've however seen problems with running it with the virtual box guest addition gpu driver in a. Ubuntu vbox machine. 
To validate what people apparently disagree with: Compare [these numbers](https://youtu.be/W71BTkUbdqE?t=3m34s) to [those numbers](https://cloud.google.com/bigquery/public-data/github). The Google repository is larger in disk-size (because they have a larger proportion of committed binary data, I assume), but github *alone* (leaving aside the myriad of open source projects that are not on github) has * ~20x as many files * ~100x as many contributors (I'm largely guessing here, from the general size of Engineering at Google. I'm not going to be off by more than an order of magnitude, though) * ~4x as many total commits The summary doesn't mention SLOC and I don't have BigQuery quota to run the query, but I'm sure the difference will be similar.
My plan is to keep it running in a non-production sandbox environment and implement "popular" commands as time goes by.
When I identified the team I was just pointing out a public team that appears to have a use case, that isn't just an internal problem. Secondly I was making clear my own lack of understanding of the issue, and leaving it up to the reader to make a judgement. Your tone came off condescending and was a little unnecessary, when I wasn't being dismissive in anyway.
&gt; All the justification for aliases in that thread are about how Google's mono repo for all the code in the company makes it difficult to refactor things without breaking other stuff [Factually false](https://groups.google.com/d/msg/golang-dev/OmjsXkyOQpQ/3y6lRwISAwAJ). ~~Apart, of course, from being inflammatory~~[edit](apologies)[/edit]. &gt; EDIT: Here's a direct quote from Rob Pike: I would add to this "but versioning doesn't actually help and in a lot of instances actively hurts". Aliases create the possibility to refactor things *without* needing to breaking anything and *without* requiring everyone to do a change at the same time. Think about it for a second; what environment is better described than github as "an environment too large or complex to update all the dependents of a package at once"?
My preferred way of doing this is by using [some simple slicing](https://youtu.be/yi5A3cK1LNA?t=14m22s). This has the advantage of using zero dependencies but you have to write 2-3 lines of "boring" code.
Because the actually solid examples given so far apply almost exclusively to monorepos @ google scale 
Both this and vendoring smells to me. A lot. Does Rust/Cargo do anything like this? I would assume no. Would google have trouble using Rust as it looks today? I would like to know.
https://doc.rust-lang.org/book/type-aliases.html 
Well, you can do anything you want, but I certainly wouldn't recommend it. Most Go features would be unavailable (goroutines, anyone?) unless you wrote a large enough shim to satisfy the runtime, which would be big enough to, well, be an OS kernel running a single process. And when done, I doubt the runtime would be well suited for implementing various kernel features. I don't think the runtime would like dealing with things like fault handlers, kernel/user-mode transitions, memory mapping, etc... But, you're the one that tried it, not me. How did it go? (pun very much intended)
&gt; Factually false. Apart, of course, from being inflammatory. Hmm, the x/net/context example does make sense, point taken. But I don't understand what exactly is inflammatory in the sentence you quoted? English isn't my primary language, so maybe I'm missing something.
You may enjoy this article if you haven't seen it yet: https://medium.com/swlh/ssh-how-does-it-even-9e43586e4ffc
The link contains a well thought out piece on why by a respected member of the community, which is further complemented by posts in the thread. There is also another piece on the /r/golang front page about the same issue, you might find more info there https://www.reddit.com/r/golang/comments/5alxa3/gos_alias_proposal_and_all_my_concerns_of_google/.
`fmt.Fprintln(buf, "my line")`
If you follow that discussion, you can see that Google is just an example of who needs it. GRPC is a widely used project now and they need it. Apparently so does docker. Those are just 2 examples I found (being stuck in the x/net/context instead of /context for the lack of an effective refactor way) but this case is generic enough to represent this type of technical necessity. Now on one hand we have a clear technical need and on the other we have a very subjective readability issue. All the other negative comments seem to come from some dislike of Google controlling the project -&gt; it would have been the same in any case. there is always someones need being met that makes someone else unhappy. 
no dependencies &gt; Chi router
Nah. Go's stdlib routing capabilities blow. I know a lot of you have a hard on for the no dependency dream, but it's pointless when you have to write a ton of boilerplate regardless. Just use a damn third party library and get on with it. The wheel does not need to be reinvented every time you start a new project.
Thanks! That answers that... :) 
"Think about it for a second; what environment is better described than github as "an environment too large or complex to update all the dependents of a package at once"?" I don't agree with this at all. Github is not a monorepo, which means you do not need to update all deps at once? You can have an entire tree of versions of a single module, and projects can use any one of those. Now, if we are talking about the diamond dependency problem its gets a bit hairier, but that depends on language/packaging. In some cases you can rename/alias entire packages instead to keep multiple versions in the same binary. 
The abstractions provided by a good router dependency are something you would write anyway if you didn't want your app to be a pile of shit. Route paths and keys should be decoupled from handlers, and keys should be passed using the context object. Not only is that code in the wrong place, but it only handles one use case. What if the key is in the middle of the path? What if you have multiple keys? So yeah, it's easy to do really basic shit using stdlib, but most people need more than just really basic shit, and the abstractions make the code a lot easier to work with and read. But hey, if you want to write a ton of boilerplate then be my guest, I'm not going to stop you, it'd just be nice if you didn't have an elitist attitude when the "no dependency" perspective has no solid rationale. 
Yet you ignored the bigger part of OP's comment. He doesn't agree that this new feature will hurt readability, and so far I tend to agree with him as well.
I use PyCharm with the go plugin. Works like a charm.
&gt; What if you have 5 keys and 100 routes to check against ? I've never seen an API that needs 5 keys. That is bad design as far as I am concerned. If it is such a special case, then it's gonna need special code. As for the 100 routes, you can always place the code it in a function or middleware. &gt; you know that solution is indefensible garbage. I never said or implied that it is a generic solution that can be applied to any number of keys. Apologies if I wasn't clear enough.
The difference there is that you could opt out of it and still use the latest greatest Ubuntu. I still use gnome over unity on Ubuntu. Not the greatest analogy, but the point is there probably needs to be more discussion before any decision is made, especially if it is a unilateral one by Google.
&gt; It doesn't matter,"I've never seen this" doesn't solve a specific problem. Hacking a stupid solution with slicing to avoid "unecessary dependency" doesn't solve the problem at hand. As far as I am concerned it is a simple and pragmatic solution that solves a very specific problem. Too specific in fact. If you only need 1 line with slicing to solve 70-80% of your use cases that have 1 key then that is a very big win in my book. Solve the rest of the cases with a few extra lines and you have just avoided importing an external dependency with god knows how many lines which could also have more dependencies itself. Remember: ["A little copying is better than a little dependency."](https://youtu.be/PAAkCSZUG1c?t=9m28s)
Again this thread here? I think we all should stop beating this dead horse in reddit and focus on golang-dev. 
So I've found the discussion on divergence/convergence unconvincing and a distraction as to why vendoring/versioning cannot achieve the same result as type aliasing. But I have come to the conclusion that vendoring is insufficient for an automatic (or large scale) refactor. Suppose you have a package P used by package C (consumer). Furthermore, P is vendored/versioned, e.g. P.1, P.2, ... 1. C is pinned to P.1. 2. P.2 introduces breaking changes. 3. C moves to P.2. Compilation fails. Manual fixes required. I think step (3) above is the definite reason why vendoring is not tenable since you're not automatically refactoring. In a type-aliased world we could have: 1. C is pinned to P.1. 2. P.2 introduces significant changes uses type aliases as a facade to tie over adoption to new interfaces based on new packages. 3. C switches to P.2 and compiles fine. Now refactoring isn't complete at (3) until C switches to using the new packages. However because the entire path can still be parsed/built (since symbols resolve), it opens up a pathway to now automatically refactor. If you can further measure all possible consumers of the package (which is straightforward in Go), then you can converge your codebase without having required any manual intervention.
You're missing the point.
&gt; and solve way more use cases than you admit as interfaces wouldn't be bound to names but the actual interface of a type. I understand how it's supposed to work. It just doesn't solve the actual issues well (if at all). &gt; It would encourage go developers to expose interfaces instead of concrete types. No, it would *require* to *only* expose interfaces and builtin types, if you think you might ever, ever want to support refactorings of such kind. That includes using third-party non-interface types in signatures of any method, of course, because they might move it around at some point. This is just not a reasonable world to live in. It would also not be idiomatic go code. And it would slow down development significantly. Just because it's currently the only way to do something like this doesn't mean, it's a good idea. Indeed, the fact that it's possible but not happening means, that gophers don't want to pay that cost for the price, making it a non-solution.
This Chi thing smells of what Martini was a few years ago.
&gt; But you are not solving the OP's problem The OP doesn't have a problem nor a question. The OP simply created this threat to show us their own solution to the stackoverflow question. &gt; who needs to match against a pattern at first place with this one line. I suspect you still haven't watched the part of the video that explains that. If you have trouble finding it, [here you go](https://youtu.be/yi5A3cK1LNA?t=13m14s). &gt; This crap is insignificant and I don't take it as the gospel. I don't care about Go proverbs which are stupid. Go proverbs are not an authority , Of course they are not authority. They are called Go proverbs after all! :) But I wouldn't go as far as to call them insignificant or stupid. &gt; it's random rambling not even backed by experience or hard facts. Well I suspect that since the person that thought of these proverbs, is one the Go creators, author of many books, inventor of different languages and programmer with many years of experience, he should know what he is talking about. But in the end I cannot speak for /u/robpike.
It is like taking a dump on a something beatiful. "Aliases" is really bad idea - makes code unreadable and can introduce bugs that will be hard to find. Just like #define TRUE FALSE :)
&gt; But that's already the case today isn't it ? In the sense of "today, such refactorings aren't possible", yes. In the sense of &gt; most libraries out there are not compatible because of Go type system, the only way to make them composable with others is to only expose interfaces and builtin types. then no. The vast majority of libraries out there use structs, func types, new types with underlying type `int`……… and compose just fine. But yes. A move of an identifier in that world is not possible. Which is what this feature is about: Giving a way to enable it. Another way would be to use interfaces exclusively, but that's not viable. &gt; today if I want to make my lib compatible with http.Handler I need to import http, I shouldn't have to do that. I don't particularly agree that it's a bad thing in this *specific* case. But yeah, all things being equal, you should prefer exposing and using interfaces and yes, as I mentioned, I agree that covariant interfaces would help decouple. But in 99.9% of cases, not all things *are* equal and thus I don't think it's reasonable to *require* exposing and using only interfaces. There are a lot of cases where it just doesn't make sense, makes code unreadable and also uncomfortable to use. For example, every instance of using a `type X int` as an enum-like construct. It's bonkers to use interfaces for that. Not to mention that we'd end up in java world, memory-layout wise. That is decidedly non-go-ish.
Although there are no rules forbidding other language than English, I believe we should thrive to have open and wide communication, which in the case of this subreddit is only possible with English. 
Graphic wise, Go isn't handicapped, it uses same OpenGL lib as any other language. Engine wise, this hybrid approach would probably require more thinking and designing, but I don't think final product would lag behind other languages. So basically, low level rendering stuff (maybe audio too?) would be C lib called via CGO, middleware (logic/AI, network, physics etc.) could be written in Go. Performance and results would be same or very similar to C/C++. Go is faster than scripting languages if one would use it instead of eg. Lua, so that there is even ahead of competition. You could make commercial grade games with it as far as programming is concerned. That is my impression, but I never reached even close to those requirements so I don't know if there are some hidden limitations far down the road (should not be a problem if one is skilled with C).
I wrote very carefully to avoid calling new, other than that, it wasn't that bad. The biggest reasons I abandoned the project was the build system and a desire to be cross platform. Essentially, I had to write in a subset of Go: no allocations, no concurrency, but interfaces were still available. And of course the pretty syntax.
I think you misunderstood my question, so let me rephrase: could you make "commercial grade games" using the bare OpenGL bindings? What kinds of games *couldn't* you make this way? I'm trying to understand what the upper bound looks like for OpenGL CGo bindings.
In what way?
Very clever to remove your disparaging comment and insert this so cute as a button comment after my comment, now I'm the only one who looks like a dick. Well played you hairy little gopher.
Hype.
It's not about having to write one line of code. It's about knowing that the code will work, has been thought through, and has been thoroughly tested. In many cases, a library can provide those guarantees better than I can. Maybe you think you can do better, but you're wrong.
You're the reason I hate the go community. 
&gt; Surely I know better than a library that has seen extensive testing and usage by many developers! You are misunderstanding the point. All I am saying is that if you can do your job by writing a few lines by yourself, then a dependency that offers a generic solution with hundreds, even thousand lines of code might not worth to be included in the project. Obviously you always need to carefully analyze the trade offs for your particular case. &gt; This is such an insane mentality. I have no idea what Chi is but the notion that any dependency is automatically worse than no dependencies is absurd. Nobody said that. As I mentioned, it's always about the trade offs. The problem is that a lot of developers do not think about the cost of dependencies. If they can avoid writing a few lines of "boring" code, they will gladly import a 2k loc dependency that might even depend on other things. [Rob Pike does a much better job explaining what I am trying to say](https://youtu.be/PAAkCSZUG1c?t=9m28s). &gt; What do you do when you need encryption? The standard library has very good encryption packages. If those are not enough then external packages can be considered but they have to provide enough benefits to justify their cost. &gt; What about your dependencies on stdlib? Do those not count for some reason? That depends on your specific case. If you know that you might later need to swap a specific part of the standard library to plug in something else, then you have to write your code appropriately. Personally I never had to do this for the standard library but this was discussed recently in this [excellent article by Ben Johnson](https://medium.com/@benbjohnson/standard-package-layout-7cdbc8391fc1#e53f). 
I agree with all of your points here. What I disagree with is your initial message: "no dependencies &gt; Chi". That kind of remark is pretty emblematic of the kind of thing you can expect if you try to discuss the value of a library or package within the go community. My point is that the go community has an absolutely hostile attitude towards dependencies and they're taking it to a thoughtless, fanatical level. It's not helpful and it makes attempting to contribute libraries to golang aggressively painful. Some dependencies are good, some dependencies are bad, but "all dependencies are bad, look these one liners are so much easier" is a really unhelpful attitude.
130ns * X = ? where X is number of CGO C calls (of any type, not only OpenGL) and ? is max amount of time you can afford from 16ms frame budget. Number of C calls depend on game and how you make it so I can't help you with. Simplest games yes but commercial? Doubtful.
To be fair, it's not a democracy. They saw the community feedback, weighed the costs and benefits, and decided to go with it.
Patreon?
100s of answers that tell you how to manage Heroku, AWS, App Engine, Docker, Clouds, Swarms and whatnot, most of which hide the actual process of compiling and just seeing and "playing" with your resulting binary.
You build GOOS=linux GOARCH=amd64 go build myapp.go Then you copy the result that is just one file to your server. Required libraries are statically linked. 
Here's a really great talk about deploying Go, but short answer, no, you don't - https://www.youtube.com/watch?v=I-8PfC6dZe4
&gt; It's not like it's a feature you MUST use I don't have a dog in this fight, but I do imagine this rationale is how C++ happened...
What are aliases exactly, and what are the use cases? Specifically, what (if any) use cases couldn't be handled without them?
Solving problems at scale was one of Go's main goals from day one. This shouldn't come as news to anyone. 
&gt; It's illiterate code. By conveying mechanism but not meaning it makes itself unmaintainable. It's more work for a reader, more work if you ever want to change anything, encourages special-snowflake-cases and accreted crud, and does it for reasons that I don't find convincing at all. It's okay for solo code, but as a team lead I would definitely suggest writing things in a way that shows a bit more consideration. If this one line is illiterate and unmaintainable then I am very curious to see your counter proposal.
IMHO if we had proper package management from day 1 then we wouldnt be having this conversation right now
Some suggestions: &gt; Do you add numbers to the end of the variable names (like days2)? Or you just name them whatever, and I am worrying too much about this thing. In Go we favor short names for very short lived variables. For example you could have: d := diff / 86400 diff = diff - (d * 86400) h := (diff / 3600) diff = diff - h*3600 m := diff / 60 diff = diff - m*60 s := diff days = fmt.Sprintf("%v", d) hours = prefixNumber(h) minutes = prefixNumber(m) seconds = prefixNumber(s) Notice that instead of `days`, `days2` or `rdays`, someone could go for `d` and `days`, since `d` only lives in this short function. Something else that could help you is [named result parameters and naked return](https://golang.org/doc/effective_go.html#named-results). This is something that we usually avoid but it is very helpful for short functions when it benefits clarity. For example, seeing a function that returns `(string, string, string, string)` is not very clear what each string is. You could instead make it: func calculate(...) (days, hours, minutes, seconds string) { This is much more readable as you can easily see that the function returns days, hours, minutes and seconds which are all of type string. When you use named result parameters, those names are already defined as variables in the function so you do not need to redefine them with `:=`. Also in the end you can simply write `return` which will simply return those named result parameters (and that's a naked return). *EDIT: I want to emphasize that this is a special case where named result parameters seem to benefit the clarity of the code as they act as documentation. Unless you have a similar case, you should avoid using them. This also goes for "naked" returns.* Another suggestion is instead of doing all this manual work of parsing the string date yourself, make your function accept `time.Time` and use `time.Parse`in your main to parse the date instead. Also notice that in Go we use camelCase so you should change variables like `final_time` to `finalTime` or maybe to something even shorter. By combining these suggestions, I changed the code to this: https://play.golang.org/p/XYYrFjKPEJ You can probably make this code even better (for example by using `time.Duration`) but it looks fine for now.
How does go gen create fragmentation?
I never got it to work on Windows. I use PyCharm for Python, but nothing I researched seemed to help with Go. Was it complex for you to set up? Are you on Windows or Linux?
While there were a number of steps to set up Delve (for step debugging), the steps worked without any issue, and I've been using VS Code ever since for Go. It's very nice.
Personally, I am not as sensitive to lag and only ever get annoyed by lag in Visual Studio and PyCharm but I do notice how VS Code is faster than Atom and I like the speed. If I wanted more, I'd probably try Sublime, but I always feel like the developer is one step away from abandoning it.
That's much better. Thank you! So the big picture advice I'd give you is that in all strictly typed languages (including go), you're encouraged to **convert any input to its actual type as soon as possible** and then **keep variables as their actual type until the last possible moment**. By "actual type", I mean the type they represent conceptually and not the type they happen to be at the moment. In simple cases like this, it means treating these values like ints for just a little longer than you did. Here's a pretty small change to your code that converts right at the end and fixes the problem. I also simplified your prefixNumber function. https://play.golang.org/p/uO8rY7D8Di That code will do just fine in a pinch, but in a more complex codebase I'd recommend a more objected oriented approach. Make and use datatypes that represents concepts instead of just data. Notice that each row is essentially a time.Time and apply the same rule of *converting input to its actual types as soon as possible* to the rows as well. That means turning your calculate function into one that just converts a row to a time.Time. Then make a class that represents the time difference you're trying to represent. Putting it all together gives you something like https://play.golang.org/p/7MChjkR0R9 (edit: swapped start/end) It added 10 lines of code, but the separation of concerns makes it more maintainable and reusable going forward IMO. *P.S. The clock thing is just a quirk of the playground. You can read more about it at https://blog.golang.org/playground if you're really curious, but it's not important.* 
If you don't want to help then don't try. All you have to say is "the binary that go build produces is all that's needed to run."
Almost unbearable to read, sorry.
I've had a pretty good time with Delve. I'm not sure there is much you can do to make concurrency debugging better. There really isn't a language where it's easy.
&gt; layered object oriented design approach This structure and naming looks almost exactly like my first Go application (I have Java background). While this structure works, it's really not ideal for Go. Please read Ben Jonhson's article about [standard package layout](https://medium.com/@benbjohnson/standard-package-layout-7cdbc8391fc1).
Thanks. I'll check this out later tonight.
I've also passed from this phase when writing my first Go code. Please read [my answer on a similar question](https://www.reddit.com/r/golang/comments/56wk4v/structuring_go_api/d8n4axl/) as I have assembled quite a few resources that you might find useful. 
In what way is vs code better than lite ide
Why not give feedback that is helpful? If you can't, what is the point of your message?
Nice talk, thanks.
Sorry, I couldn't help it: https://play.golang.org/p/oXt1l0vgLx
By indicating a symbol is owned by this package through a normal type definition but is actually defined somewhere else in a way the programmer and compiler can understand without adding explicit memory management "features" I'd guess makes the code more readable in some cases.
I don't think that it will happen anytime soon (thankfully I'm not even close to 35), but I hope it happens at some point. However if I had to make a intranet system, for example, where I would have control over the clients, I could choose to get rid of javascript in that case.
Btw, the real trick to not needing these temp variables is do to all your conversions at function boundaries instead of in the middle of functions. When you do this, you can re-use your variable names because each version is in its own separate function, and the variable never has 2 different types in the same scope. This tends to happen automatically when you follow the 2 rules I listed above about converting only at the edges of your program. Here's a really basic example that shows the broader concept. https://play.golang.org/p/dHBypPj5Ss 
Nice, will have to try it, have yet to find anything even close to liteide
I think this example is a design flaw of the language because it goes against the spirits of interfaces. I think that separate packages with named interfaces should be usable interchangeably as long as the interfaces have identical methods and names (do not fully qualify by package name). One could argue that in the full spirit of Go it might even make sense to lift the naming requirements. This thing is able to do this set of things, so I can use it here. This would have made a much weaker case for aliases and been a higher quality of life change in my opinion despite mentioned caveats. [Discussion here](https://github.com/golang/go/issues/8082) if you are interested.
Ubuntu here. It all worked for me with no trouble.
So it's like an alternative to using an interface? Say I have twenty packages that all want: type Point struct { x,y float64 } And they want to pass these points between eachother-- Before, either one package would need to be the owner of the struct and all the other packages would have owner.Point Or you'd define an interface for the same purpose in each package? type Pointing interface { X() float64 Y() float64 } But for high performance applications, that function call would add unwanted overhead. So now we can define some aliasing file which just holds Point =&gt; owner.Point in all the packages? That seems reasonable. It makes code less verbose in exchange for demanding that the structs being used wouldn't be interpreted to mean different things in different packages. Given that it has some usefulness, it seems okay. I might even use them for a couple things. 
haha good one also https://play.golang.org/p/DDcXa_cG6O
Because Rob Pike wants you to take your juvenile syntax highlighting and get off his lawn. /sarcasm, [kinda](https://groups.google.com/forum/#!msg/golang-nuts/hJHCAaiL0so/kG3BHV6QFfIJ)
I repeated (a lot) that I would be happy with covariant interfaces, but that they don't actually address the same needs as aliases do. For example, once an interface contains any named, not builtin type, the same problems arise again *even in a world of covariant interfaces*. To actually address the need, you'd need to make go's type system either purely structural or purely nominal. Both suck. I mostly agree that interfaces should be covariant. But this is irrelevant to this discussion, because even then, they wouldn't cover the same need.
Thanks :) I suspected something to do with slices. I'm quite new to Go, and don't properly understand the differences / different uses of arrays and slices. Would you happen to have any good material that I could study?
I preferred [httprouter](https://github.com/julienschmidt/httprouter) until I realized that its _(current)_ implementation doesn't plays well with other middlewares because it requires an additional _(non-exported)_ parameter in the handler. I decided to create [my own](https://github.com/cixtor/middleware) using the context package, it doesn't supports 100% what httprouter offers but at least I can attach other 3rd-party libraries without breaking the default _"http.HandlerFunc"_. Someone created a PR to change the parameters to context: https://github.com/julienschmidt/httprouter/pull/147
[Effective Go](https://golang.org/doc/effective_go.html#arrays) section on arrays and slices gives a good overview. Note the last example in the 'Slices' section. [Go Slices blog post](https://blog.golang.org/go-slices-usage-and-internals) goes into more depth on their usage. 
You can opt out of using type aliases. Google's not going to come in and convert your code to use them.
Wondering if the go code of conduct was in effect back then...
&gt; Required libraries are statically linked. unless you are using something that uses cgo. Then you need go build --ldflags '-extldflags "-static"' 
I used to ask that myself all the time. But reading this thread I can't help but to want to try programming in Go with syntax highlighting turned off now, just to see how it goes. I realize now that I've trained myself to recognize colors rather than tokens and keywords... I need to correct that.
The point of syntax highlighting IMO is not to make code *understandable*, but to make it faster and easier to understand. It's a visual aid to comprehension, like quotation marks in a novel. Given that humans have remarkably advanced facilities to recognize visual cues, it's a shame to force people to read and process token-by-token, and build up a mental structure when the computer could instead trick your brain into doing part of that work. For newbies, good highlighting also gives valuable clues about the syntactic structure of the language: which of these things I'm looking at are keywords, and which are arbitrarily chosen by the sample code? You can get a fair idea at a glance. Again, careful construction of sample code and careful reading could probably accomplish the same thing, but why not use shortcuts when you have them and they cost very little to employ?
(**Note:** not **sarcasm**) I *wish* ordinary **communication** *had* SYNTAX **highlighting**, for **example**, all **nouns** BOLDED, all **verbs** ITALICIZED, and all **adjectives** CAPITALIZED.
I'll try it out for a week and see for myself whether the cost pays any benefits.
Each of the messages carried a condescending tone. The author hurt you with his words, you lashed back. I don't condemn you, you are only human, just like the person you attacked is only human, so too do not condemn me brad, for I, too, am only human too.
I just linked my post explaining why assertion libs are not needed :D but particularly with reference to unit test helpers. I quite like your no-op build flag approach however in that post I also link to: https://golang.org/doc/faq#assertions I suppose you don't fully subscribe to the points in the FAQ. 
A case against syntax highlighting: http://www.linusakesson.net/programming/syntaxhighlighting/
Clearly because the **authors** do not **value it**. Perhaps because **syntax highlighting** has the effect of leading one to conclusions about what **is important** in the reading. While I have learned to use this as a crutch in someways and rely upon it syntax **highlighting** can be an impediment to not only the **comprehension of** the code but also an interruption in composition of **the code**.
I came from a time where most computer displays were monochromatic - so no syntax highlighting. I used syntax highlight for a period of time. The truth is that my brain works best without highlight, not because they aren't useful - they are - but because you do not restrict the meaning of a symbol by the color. It is tricky to realize this. Just to give a glimpse what I mean: in Go you may declare a variable to hold a function as a value. Of course the highlight will color it as the variable it is. It turns out that our notion of variable is dramatically different than of a function (after all variables don't run anything). Without highlight, the meaning is the name. With highlight the meaning is a mix of name and color, which creates a small brain overload. In a more intuitive approach, think of that case in which people are asked to tell the color of a word that does not match the printed color (a word "red" printed in blue for instance) - similar phenomenon happens when you use highlight when coding. Beautiful. Feels good. But it backfires in subtle ways. YMMV, but the number of bugs in my code dropped immediately after I stopped using highlight. I do not think it is a coincidence. 
Like you, I lost the battle to stick with stdlib, so we're working with testify now. I don't hate it. But I also find it a bit pointless, and even though I use it at work daily, I remain unconvinced I'd ever add it to one of my own projects. I think the point about API surface is valid, and one of my biggest criticisms. I'd rather write more boilerplate than make testing less approachable to a newcomer. Look at ruby, for all it's focus on testing, learning the testing ecosystem is almost as hard as the language itself. One thing I do want to point out though is that even though we're using the assertion libraries, we're also taking advantage of table tests and using t.Run in our code, so the test code doesn't look too different from normal go. 
Very interesting. I think I am dependent on syntax highlighting as of right now, to the point I can't easily understand a piece of code that doesn't use it. I wonder if I'll be able to understand code better if I'm forced to parse the keywords and tokens by what they are rather than by what color they have. I'm going to try it right away, for a couple of weeks, and see where it goes...
Creating the simplest example of a problem you are hitting on play.golang.org and posting a link to it is the fastest way to get help.
Maybe because deciding what color scheme to use would cause a civil war.
Color and line weight are different, but they are also both scalars that your visual cortex shortcuts and processes before you reason about them.
I couldn't find a way to prevent GC from linking the runtime, so I had to use gccgo. I'm not sure if using go build would provide the control necessary for kernel development, so I just used a Makefile, which I'm too lazy to learn how to use properly.
That might work. The sample you sent seems to piggyback off of go build where as I was invoking x86_64-elf-gccgo directly.
&gt; I can't really think of a reason not to have it. I personally find it distracting.
The **rule** *is* only **heads** of NOUN **phrases** *get* BOLDED.
German kind of does this. Nouns are always capitalized, whether they are at the Beginning of a Sentence, in the Middle, or at the End. It's actually pretty helpful for learning the Language in my Opinion.
It doesn't, it gets it from the context, where your eminently sensible dispatcher left it after it parsed it out for you.
Apologies but it seems by the time I finished writing this, you had deleted your question: &gt; So I was just reviewing some of Ben's coding examples when I noticed that his UserService is essentially a Repository by a different name: &gt; https://gist.github.com/benbjohnson/996a88d5af97f5f1c40c7386f8ba863a#file-myapp-go &gt; https://lostechies.com/jimmybogard/2009/09/03/ddd-repository-implementation-patterns/ &gt; In his example the UserService does not actually serve to Encapsulate the model. &gt; Rather, it's being used to expose a set of CRUD operations which act on an Aggregate (User). &gt; He even introduced a caching layer by using class decorators: &gt; https://gist.github.com/benbjohnson/ffed98c3be896af58c5d74dd52cf0234#file-cache-go &gt; This is a fairly common strategy with Repositories so why has he instead chosen to call it a Service? I do not think the name matters matters that much. Let me explain. When writing enterprise Java code, you will see the repository pattern a lot as it provides tremendous benefits for keeping the code base testable, flexible and more. For example It is very common to have: * `class User` * `interface UserService` * `interface UserRepository` The `UserRepository` is essentially a service which is (usually) responsible for abstracting your interactions with the database (for the `User` entity). One of the reasons we are calling it a repository is to make that part more obvious. The `UserService` abstracts all operations that the `User` will need essentially creating a "public API" for the `User` entity. It's also very common that the `UserService` will use the `UserRepository` via injection. In the end, the final user/client of your code, will only ever have to use `User` and `UserService` since `UserService` essentially can do what `UserRepository` does and usually much more. (For example, maybe `UserSevice` includes more functionality by injecting `FooRepository` or even another `BarService`.) This creates deeper layers of abstraction. If you ever want to jump to where the pure database code lives from the initial function call (let's call it `UserService.GetUser(...)`), it will first lead you to `UserRepository.GetUser(...)` and then to the actual database code. This is a common pattern in enterprise Java code as it is considered best practice to keep the "technical" code as deep and lower in your layers and keep your business layer thinner. (It's probably going to have domain specific complexity of it's own, so why keep the boring, technical database code there, right?) This especially shines, if you use something like Spring, where if you make your UserRepository implement a "magic" Spring interface, then you don't even need to write database code! Now let's go back to Go. Go is not Java. Go is a very different language with different strengths (and weaknesses). Design patterns are very helpful but when you try to implement a design pattern in Go, (which pattern might have been created to solve the shortcomings of a different language) then it's extremely important to adjust it for Go and not blindly follow it. Otherwise, you are not writing idiomatic Go code. You write Java (or any other language) with the syntax of Go. Any strengths that Go might have will not be shine in your code. Assuming a design pattern X. What problem exactly does X try to solve? Was X maybe invented to solve the shortcomings of a certain language? Does Go have certain attributes that could maybe eliminate the need for X? And if not, how can I adjust X to work the best with the tools and strengths that Go provides? These are all questions you need to ask yourself when you attempt implement a design pattern for Go (or any other language for that matter). Now more specifically for our case. Do we need 2 layers of abstractions in our Go code? Maybe we do but maybe we don't. I've found that there's really no need to have a `UserService` which calls a `UserRepository` in Go especially at the start. Why not keep them as one? In the end they are more or less the same thing. At it's essence, the design pattern is about using an interface to abstract and keep our code testable and flexible. Obviously, you can always adjust later if needed. Now do you want to name it `UserRepository` instead of `UserService`? That is up to you. I've even seen Go code where they name their service `UserStore`. `¯\_(ツ)_/¯` In the end it doesn't really matter as long as you have a clear understand of what is going on. If you are interested in a deeper understanding of the "Go philosophy" I can recommend you a few talks: * [Public static void](https://www.youtube.com/watch?v=5kj5ApnhPAE) * [Simplicity is complicated](https://www.youtube.com/watch?v=rFejpH_tAHM) * [Go Proverbs](https://www.youtube.com/watch?v=PAAkCSZUG1c) 
I understand that this is a divisive issue. I'm surprised, but I understand it. Shouldn't be too hard to give the user the ability to toggle syntax highlighting on/off, no? Then, everybody's happy. Or, at least, we find something new to bitch about :D 
I'm with testify too, but I really just use it because it allows every assertion to fit on a single line. It's prettier, period.
macros rock!
To do pagination, you could create a function in your service to interact with the database, something like: `GetContents(limit, offset int)`. Which will run an SQL like this: `select * from contents limit ? offset ?` This is not specific to Go: https://www.petefreitag.com/item/451.cfm Of course in order to make the pages appear in your templates you will also need something like `select count(*) from contents`
Based off some really quick skimming, it seems like some of the main arguments are: 1. Aliases "hurt readability" and 2. Google shouldn't control Go. Both seem subjective and not really an argument against aliases. Not sure how we're losing readability. If you're not sure what the definition of something is, then hit Goto definition in your editor. Oh, look it's an alias. Goto definition on the alias. Done? It doesn't seem any different than what I normally do to jump around a codebase. Also, I'm pretty sure eventually, we'll just get used to it and it'll be normal, readable, syntax. Google controlling Go is another issue altogether and not even an argument against aliases. Facilitating migrations to newer APIs seems like a good idea to me? Ironically, the customer/cart examples from this post kinda pushed me towards that thinking. https://medium.com/@cep21/gos-alias-proposal-and-all-my-concerns-of-google-controlling-go-a39f6c6046aa#.fh0i5ne5r Can someone give me a concrete example of why this is bad?
This is...this is absolutely incredible. This is a borderline gamechanger for me.
Well, it's all fun and games to lok down on ES/JS and people using it -- but as much as you'd want node.js to be a fad -- numbers in the wild paint a different picture. Last I've seen in terms of stats is that, while node.js can't touch the top tier of web backends: PHP, ASP and Java (in that order -- PHP is the undisputed king of that market regardless of whether someone likes it or not), it comes as a distinct 4th and has overrun some serious contenders -- Ruby, Perl, and Python, and the trend of it's rise shows no intention to stop. My own experience with how I've come to use node is quite aligned to the trend. While I desperately wanted to use Python for that particular app, Django REST was quirky and poorly documented, and Flask was new and even more poorly documented. Express, OTOH, was seemingly everywhere and everyone and their dog had written an article on how to bootstrap it. When it became clear I'd need to have realtime functionality, I came across Sails.js which solved *all* my problems with a very simple stroke. Now, there is this horrible unstability about ever evolving world of JavaScript that might put people off, but on the flip side -- it simply delivers. My choice had nothing to do with me having to write JS on the front end, and same is true for a lot of people. But it *was* something that pushed many people towards node.js, hence the "Express everywhere" I experienced back then. I expect that Swift will have similar future, and at some point there will be a "killer app" framework that will get people onboard on pure merit, rather than them just being used to write iOS apps in it. Another thing you're getting quite wrong IMO is C#. It's quite visible how the community has started brewing the second Microsoft open sourced Core. The technology in itself was always years ahead of Java but it's poor choice of platform to run on ;) and the fact that Mono was always playing catch up was a showstopper for many people. This is changing rapidly, right now, and hopefully in a year or two we will see where it gets to. Edit: And it's opensourcing didn't get people developing Core itself. That's the beauty of it. It just meant that people now trust it to not go away, and it's technical advantages can be used without fear of a vendor lock-in. There is a vocal minority in open-source that's always doomy, gloomy and naysaying, but majority of people are serious about their work -- if it works, and we can't see *how* they can screw us over, then they probably can't, and we go with it. I don't see Oracle v. Google putting any dents in Java usage, and I expect ASP/C# to solidify it's position now that it can be packaged and deployed in cheap, simple Linux containers.
vim-go
I disagree with you but my editor looks like a toddler spewed up on a tennis court (most tennis courts in my country being asphalt).
how do I use it i.e. in Chrome? Edit: Tampermonkey FTW. Thanks for the script!
I don't really have that issue in Go though I can't imagine to work without autocomplete and highlighting in javascript.
I disagree. If you read the announcements wasm will shipped in Q1 2017(enabled by default in major browsers). There is a polyfill so browsers without wasm enabled(most likely Safari) will still work (though quite slow). I see a bright future for WebAssembly but if Go misses the boat chances are that others will eat its lunch(i.e. Rust, Swift or whatever language will be first to compile to wasm) VR/AR/smellovision can happen on the web too once wasm is available in browsers.
... But please don't rely on goreportcards scores to judge a project. It only runs a bunch of vetters and linters, with every line of output decrementing the score. It doesn't say anything about the code as a whole, and sometimes, having a perfect golint score can result in much more annoying code...
I'm not sure that covariant interfaces will be more readable than aliases... Embedding interfaces is more readable (for me), and i see aliases like this. 
I realize this is an English subreddit but I think there are so many Italian programmers that read this subreddit to get information, I think they could use some italian information as well while they strive to grasp the English information correctly. I did not mean to create miscommunication.
Seems like people are not liking the title of the post. The question was more to do with available tools and frameworks rather than the languages themselves.
Thanks, checkout the updated question for more info.
I updated the question.
I am a big fan of stdlib-only testing. At work, we use gocheck, and I'm not a fan. The real problem with gocheck is that it adds test suites and suite startup/teardown test startup teardown functionality, which just encourages more complicated tests, and hides away a lot of what the test is actually doing. even just the assertions I don't really like. As the article says, they're not type checked at compile time, and they often give a less useful failure message than they would if you hand crafted the message. Plus, they make it so easy to write your own DSL that going into the tests for a new package is like diving into a completely different codebase. Just write the if statements. They're clear, they're simple, and they won't confuse you later on down the road. My mantra with testing is that DRY is an anti-pattern in testing. Everything should be repeated. Everything should be obvious and in your face, because you don't write tests for your tests, so the only way you can know they're correct is by reading them, and so you need every bit of context you can get.
This code would be more equivalent to what most languages are doing in those examples: package main import ( "fmt" ) func main() { var n int fmt.Scanf("%d", &amp;n) for i := 0; i &lt; n; i++ { fmt.Println("hello world") } }
As I clarified in the comments I was mostly referring to available tools and frameworks not the languages themselves.
vscode is best. i basically never choose vim/emacs for development. at first, i tried intellij idea. it is not bad. but almost editors need annoying golang setup. vscode has automatic setup. you can just need install golang plugin only. then this ide will popup for some useful golang tool install. auto linker, auto import, auto formatter and so on. so smart. i recommend vscode to beginers and all users.
It seems to me that Go should have an official syntax highlighting scheme. After all, they have official formatting, error checking, and all sorts of other top down guidelines. Syntax highlighting seems like a natural additional this kit.
You will be more productive with Django based on your description. I don't know of any widely used Go CMS. Beego might be an option in Go. But, I still believe Django, Rails is the right tool for web based applications when you want an admin and just want to get stuff done. We use Go exclusively on the back end for our APIs. Our application front end is React. We use Wordpress for static content so business folks can update that whenever they want without depending on devs.
You need to figure out what 3rd party lib you can leverage . Gorilla toolkit can help for a few stuffs ( sessions, forms, ... ) http://www.gorillatoolkit.org/ Be sure to use check this namespace, a lot of useful stuff like bcrypt for password hashing, ect ... https://godoc.org/?q=golang.org You can leverage libraries from other languages like PHP (doctrine, symfony, laravel ,...) in order to figure out how to write some stuff. But porting takes time. in general , PHP libs translate well in Go code since both lack of generics (unlike Java) and don't rely too heavily on meta programming like Ruby or Python. And do your thing. What suits somebody else, even Rob Pike, might not suit your own requirements. Don't be afraid to opt out the type system if needed otherwise you'll write a lot of boilerplate. As long as it doesn't panic and you understand the performance cost, that's ok.
Why? this is a tiny program: if it can't read an integer, it dies. Keep it simple.
In my example it simply doesn't print anything because n == 0 and then exists. Seems like exactly what you would want from a simple app :) EDIT: this response was supposed to be 'i agree with you about the keep it simple'
Where there's a will, there's a way. * Hosting: You cannot use shared hosting, so you need to pay VMs or container or something along that lines. * You will be building a lot of CMS features yourself. Are you cool with that? Stdlib can solve all your problems if you build yourself. * Come to think of it, this is just websites for random people right? With little interactivity? If so, just use Hugo, man. And host the static files somewhere cheap like AWS S3.
Great info. Yep, it's mostly static sites with content and occasionally some eCommerce. Also, could you elaborate a bit on the hosting? Why wouldn't I be able to use shared hosting?
Constantly flipping between Dark color schemes and a web browser/docs (light bg) is super fatiguing. Also, dark text on light bg is objectively optimal for readability (specifically character recognition, edge sharpness) since your iris will narrow due to the brighter bg. http://ux.stackexchange.com/a/53268 At first, light color schemes seem to be more "straining" to those accustomed to the dark side. I too used to code in the dark, but once I switched to light, my hacking comfort has noticeably improved with way less fatigue. Give it a week or two.
https://play.golang.org/p/Mu8kt1pA25
Is there any particular reason why you can't use VSCode within the VM itself?
&gt; It doesn't particularly matter. Could be any of several good ones. Could not be an external package at all. In that case, please give me a list of the names of the good ones. I am not familiar with any.
I like it, good job
If you are building mostly static websites, then you could even use [Hugo](https://gohugo.io/). If you need eCommerce specifically then you'll probably need something less static.
I've been playing around with https://fragmenta.eu/ a little bit and enjoyed what I've seen so far. I'm not much of a front end guy so take my opinion with some salt but happy with what I've seen sofar. edit: typos. everywhere....
You're welcome! :)
Never mind, I just read the homepage seems interesting.
I think it would be better than GopherJS in terms of dev experience, payload and performance.
Thanks for the link, this answers the question. I am also curious as other commenter: https://www.reddit.com/r/golang/comments/5at003/why_official_docs_dont_use_syntax_highlighting/d9jf8y1/ How did you get the link? Do you consider/use Go since then? Was it accidentally? Did you re-read some past threads because of personal interest? 
Interesting opinion. I have been never thinking that it can be distracting. At first i saw it in go examples i was like "wat? how do they make people learn it?"
thanks for the link, meanwhile i now want to try to learn it in the way they propose - i do respect user-scripts, so i bookmarked your
&gt; But most of the time spent was actually reimplementing from scratch things that can be found in Python,Ruby or PHP packages That's where I fail to understand why people say all you need is the stdlib.
&gt; Dark is considered more comfortable for long work Than you for expanded comment. I understand and argee your point. Also if you use dark color scheme, then i encourage you to try light one. Darked may be good when you are sitting in the editor 8 hour per day, but usually it's constant switching between dark editor and white web-page (if you work as web developer). Once i switched to light color schemes i became to feel much better in the end of day.
&gt; That's where I fail to understand why people say all you need is the stdlib. Many people have turned to Go because their working hours have been made miserable by the usage of complex frameworks in other languages while the languages themselves do not help. Go itself was partly created because their creators hated writing C++. Naturally gophers are being very careful when they evaluate external packages in Go. That doesn't mean that they will not use a 3rd party package that brings real value in the project but it has to first prove that it outweighs the dependency cost. Personally I see this as a very good sign. It's what keeps Go codebases simple and readable. If we lose that, we might end up with projects that look like Ruby on Rails or Nodejs (in terms of number of dependencies).
Interesting idea, but i am afraid they already sold it as it is now :) 
My guess is that the Rob-Pike-Syntax-Highlighting drama is just a known story in the gopher community.
&gt; What languages you are coding with no highlighing? All of them. &gt; How do you consider someone else's code? Is it harder to read than your own? I am not sure if I understand what you meant. When I open the code the highlight is already gone. So I don't think it influences me reading someone else's code.
I'm a bit curious as to why it would matter if the package you're writing code with doesn't have the headers for your OS. the Intellisense/autocomplete (minus compiler errors of course) built into vscode-go is based off of go tools analyzing the source of the packages. While you may be able to compile, the intellisense/autocomplete should work since the source is there, right?
These point are good, but perhaps too general. I was not able to take away anything concrete which would help me write a Go _web_ app. Web apps have a lot in common, they are a single type of application, a single design pattern should fit most of Go web apps. I don't know why it does not exist in Go.
Godoc can give you a rough-ish idea: https://godoc.org/github.com/gernest/utron?importers https://godoc.org/github.com/pkg/errors?importers
A lot of folks use github stars as bookmarks of interest.
Sure, other process managers exist, even the 12factor.net sites mentions some (Upstart, Foreman, i also know of PM2). The choice of Docker is mainly a comfort zone, as the true test of a 12FA is scaling beyond just a few hosts to hundreds or thousands of instances. Apart from Docker, I'm open to suggestions what can replace the scaling aspects of it. It's also the obvious choice given a selection of commercial PaaS providers that are Docker-enabled. As for the title, I believe it stands - the application would be developed in Go, and Docker is external tooling (even if used extensively to cover several requirements of 12FA), in theory (as per your implication), it can be replaced and is not a requirement of building 12FA.
Shared hosting uses common infrastructure that you don't control. That common thing is usually a managed Apache with GUI for loading modules such as PHP. When running Go, you are running your own web server + your own app logic embedded inside that web server. 
Never have been. Did anybody think they were?
it's probably only me, but I tend to avoid all these awesome-* curated list of great unicorn github repos, even if a project has lots of stars doesn't mean it's good code
If you are doing CMS type work, for the moment, stick with php/python/ruby. If you want a truly static site you might look at [Hugo](https://gohugo.io/) (a go project). If you are doing anything else, you might evaluate go as a possible implementation language. I am working on a web based multiplayer game and it fits the bill perfectly. In my case I chose it because: It's a great server language with good concurrency support. It is more mature than some other very tempting choices which I actually prefer as languages (Rust/Pony). It has static typing and small fast little binaries which makes the deployment story very nice. My advice is, start learning it in your spare time. It is small and easy to learn and at some point you will surely have a use for it, especially given the tech agnosticism of your clients.
12 is too many.
English also used to capitalize nouns until a few hundred years ago, and Dutch also until 50 years ago. They both got rid of it for some reason.
First, utron is way older than 1 month, first commit is september 2015. Second, to evaluate Go projects you do it like any sane person, you look at the API exposed and maybe the code, then you test it. Relying on download counters is just as stupid as relying on stars, it gives you no indication whatsoever on the quality of a project.
Thanks, corrected. Download counts in central package managers are proportional to the number of other packages using this package. Not ideal, but you cannot find many quantitative metrics.
After some research I came across these hosting solutions: * Google App Engine * Heroku * Any hosting company with VPS hosting or dedicated server * Personal server (hardware) 
Didn't know that, thanks for sharing. Edit: After further thought, I think a browser extension/userscript showing the number of importers on the github page would be really nice. Maybe I'll give it a try later.
I'm guilty of this as well. Does GitHub have a book mark system I'm unaware of? Maybe I'll start trying to put all repositories I'm interested in checking out later when I have time in Org.
Thanks. I'm going to trial this and see how I like it. Do you use vim? If so, any tips on a distraction-free setup?
Go lets you make a type out of a function signature, not just a struct/class like other languages. Because of that, an anonymous function that matches the HandlerFunc signature can be promoted to satisfy the Handler interface which is what net/http wants its servers to satisfy. 
Ok that explains why http.HandlerFunc is in there and the main source of confusion. Thanks
I just happened to remember your username. You responded to a question on this sub with a google link.
What's wrong with the first result in Google for "vulkan golang"? Is it broken?
&gt;Thank you for telling me what is of value or not while taking a stab at academics in the whole process. Saying "overly academic" is quite specific, and is in no way an attack on academics. It would be quite ridiculous to describe academics as "overly academic". To make this even clearer I allude to a particular context with (the less specific): "in daily practice". The intention here was to was place the message in the context of commercial product/solution delivery. The continuation: &gt;to focus on improving the tools, speed, reliability and pure pleasure in delivering and running things of value. ...does not prescribe what value is in any way. I think you misread. What I am saying is that our end goal is to deliver and run "things of value" (you or your clients/customers/users decide what *value* is). Go helps us do that in the good ways I list. Regarding: &gt; Not elitist at all. I don't agree that it is elitist so say "... tends to demand a greater underlying computer science knowledge than many other languages may expect.". It was made shortly after and in contrast to the "overly academic" point. I think it also stands on its own, and it is true that Go hides fewer implementation details than typically slightly higher level languages particularly those that are another level of indirection from the hardware. I am not saying anyone is better thn anyone else. I am saying some aspects of becoming effective with Go *tends* to expect some fundamental computer science knowledge that is quite unnecessary in *some* other languages. For example struct size and packing can have a direct effect on L(1,2) cache performance, this knowledge is rendered utterly insignificant in some vm's, interpreters, and other execution engines. &gt; This is folklore. Curly brace positioning is discussed today, it is not some tale from the past. Shortly after I wrote this an annoying click bait LinkedIn poll thing ("Which one are you, only developers will understand") fluttered across my stream on exactly this, with a flurry of comments. A quick search in the last week unearths this long conversation from 3 days ago... http://workplace.stackexchange.com/questions/78768/coding-standard-haphazard-application/78775 &gt; teams do in fact agree on a coding style. Of course they do - but they have something to have to agree on. It has to be written down, or otherwise explicitly communicated, there is often an associated discussion, there is often a few engineers who are a bit miffed about the consensus. &gt; there are tools for this. Yes, they are many and varied, and often need to be configured to match your particular previously agreed conventions. Many of the things that require some agreement are removed from the debate in Go &gt; Yes, in Go you just code and it brings value in the real world. This is in reply to my comment that Go does not include an iterator in the core language, and that this does cause some cost, but not much, and that cost is outweighed by the value of removing some complexity. I am unsure how the point you make through this sarcastic remark relates. I don't feel that at any point I have said just writing code creates value, or that Go in particular is more likely to create value. 
Since the OP seems to have an open issue logged there which is older than this thread, I assume they have seen it. They might have read, "...you'd need a device with the native Vulkan API support. Major platforms like Windows and Linux are too clumsy..." as well as the short description which calls it a work in progress. The OP's open issue on that project is related to Windows support, by the way. Regardless, I find people making your "just Google it!" category of comment far more annoying because it's way too common that the top result for something these days winds up being a question where the only answer is someone telling the OP to "just Google it!" Just in case the search algorithms or world of available material shifts, one may go to https://github.com/vulkan-go/vulkan to locate the library being referenced. I do agree that the OP might have helped the conversation move past this type of comment by mentioning that they already found this project.
/u/xlab_is has a Vulkan bindings library.
&lt;troll&gt; I was thinking this post would have talked about Iris web framework &lt;/troll&gt; I do agree that a central package manager would be really awesome with mirrors around the world. Working with Go from china is a huge pain in the ass if you don't have vpn.
The current syntax is clear. Out of all of them it is the only one that is explict. Your example of a single func returning the func makes the link between whats being returned and the declared return type more obvious. In many situations this is not the case and spelling out the `return func(a, b int) int {` tells you exactly what is going on.
I'll admit I'm a bit dense about this and I'd appreciate if someone can someone explain to me why "unidiomatic" code is bad? Is there a performance or security risk in it being "unidiomatic" or is it purely a style thing? From what I've seen online it suggests to me it's more the latter, but if that's the case I don't understand what the big deal is..
Unity still has the same problems it always had, it's just that people gave up fighting them. I've been using it for years, and I'd still call it badly designed and annoying to use.
Development at Google is different than development in open source (monorepo). And stuff like the lack of vendoring support until 1.5 shows what it was designed for.
Hey! Thanks for taking a look!! Oh yeah, the db stuff is something I was playing around with, but going to remove. Though you did bring an idea to my attention. The fact, that eventually, I'm moving on with this project, in which case, my post will get outdated. And eventually, I'm going to replace everything with a neat library. So, what I'm going to do is, replace this project with a sample and a tweak it a bit here, and there, so it gets a better front-end. And, of course, write some tests!! Thanks buddy!
It is a pain to have bookmarks in the browser, do you have a nice browser extension for managing bookmarks?
Uh, my browser does a Perry good job. To save a bookmark, I click the star. To find a bookmark, I hit ctrl-b and start typing. It's really not complicated. I like using my "watch" method better because it reminds me occasionally about a project. I don't read my feed that often on github, so it works for me. I really wish stars were used for marking worthwhile repositories, because then seeing that number would actually mean something. Right now, it only means that some number of people found it relevant to a problem they were having, which isn't nearly as useful.
A [comment on the prior post](https://www.reddit.com/r/golang/comments/59ak1g/pdf_fencing_off_go_liveness_and_safety_for/d97lsxv/) by /u/nickng/ mentions two sources - https://github.com/nickng/dingo-hunter and https://github.com/nickng/gong 
Where do you work that you have so many Acme users?
It depends. A low quality and activity project won't have many issues and a high activity high quality project won't have many issues either.
Many of us follow Go since its announcement, and when a programmer celebrity makes a funny, interesting or insightful remark like this you add a bookmark.
For simple environment variable based configuration kelseyhightower/envconfig is also nice. viper might be widely used, but it also pulls in a lot of dependencies and envconfig has none.
no more? never have been
Ugh, Iris. https://www.reddit.com/r/golang/comments/57w79c/why_you_really_should_stop_using_iris/ https://www.reddit.com/r/golang/comments/57tmp1/why_you_should_not_use_iris_for_your_go_projects/
The framework in question is mentioned in the title and put alongside other Go frameworks. The point here might be that this framework should not be considered "equal" to other frameworks, as there's some fishy history behind it.
Featuring him in the README will lead some people to consider it a good framework by association (same as some do, by the amount of stars he botted). That in turn, will lead to people (especially newcomers to the language) wasting time on it. There are enough good web frameworks out there that you could have used in the README instead to show of that it works with any.
&gt; I have a suspicion that the guy behind the project is an excellent marketer, with a crappy product. He goes to conferences, gives talks, collects github stars, you get the idea. Nope, he's just an young Tanzanian developer. :) Have a look at [this thread](https://www.reddit.com/r/golang/comments/3yxx34/helping_out_a_fellow_gopher_ugernest/).
https://www.youtube.com/watch?v=NNAuJqV-n9g
But a low quality project will have some very old open issues.
There are very fundamental differences between unused variables and imports and aliases. Namely, that the former by definition only affects one package that you have complete control over, whereas the latter by definition affects many packages, most of which you won't have any control over. Please don't use false equivalencies, they undermine your point.
Thank you, I'll add it to the list &amp; consider including it. In terms of microservices simple environment config *should* be enough, but eventually there's the issue that the complete environment config should exist. I'm struggling if I should add something like `consul` to the list... I mean, the point is to have a KISS/microservice approach when developing such apps, but they do have a tendency to fan-out. Hard to pick a solution fitting all the use cases.
I've seen very old open issues on good quality projects, sometimes resolved, sometimes dropped because outdated, it happens. It's not a good and failfree indicator either. Looking only at issues is a bad way to value a project, look at issues **and** other things that give you an idea of the projects nature and ecosystem.
lol generics, over engineered and useless
Yep, thanks - I got that, hence &gt; but particularly with reference to unit test helpers I think they share enough similarities that some of the pros and cons overlap. For example the design requires a debug build, which is most likely to be deployed in a QA environment, before being disabled in the production build. So these runtime assertions are quite likely to be most used during a testing phase. So for similar reasons that I would avoid an assertion lib for unit testing I would also not use this runtime assertion lib during other types of test. But the truth is that I was surprised by the timely coincidence, hence my somewhat vacuous comment :|
Don’t be heartbroken. If thousands like your package, you are obviously doing something useful. For non-idiomatic code: I poked around, couldn’t find anything that caught my eye as terrible. Something I personally would refactor: 1. I would create sub-packages, e.g. instead of calling utron.NewModel() or utron.NewModelWithConfig() I would put the model into its own package (sub-package of utron) and call it with models.New() and models.NewWithConfig(). 2. I don’t see a reason why App.Set should accept an interface. I could pass anything into it but internally it only accepts certain types and throws anything else away silently. Yes, the doc comment makes it clear what it accepts but it doesn’t prevent the programmer from making a mistake. SetModel, SetController etc. is more meaningful and the compiler can catch errors early. I think you should ask the author to point out what he thinks is your egregious non-idiomatic Go code.
IMHO unidiomatic code is: https://github.com/gernest/utron/blob/master/config.go#L66 JSON, TOML, YAML, HCL: Too many imported packages where maybe only one gets used. Let the developer register its decoder by fulfilling an interface or outsource those case statements into its own separate packages. https://github.com/gernest/utron/blob/master/config.go#L106 No need to use reflect here. There are some packages who do the same for the ENV as for a file. Same pattern as above but now include maybe an order how multiple decoders gets processed to overwrite variables. https://github.com/gernest/utron/blob/master/context.go#L133 https://github.com/gernest/utron/blob/master/utron.go#L185 Empty interface in argument only for encoding/decoding https://github.com/gernest/utron/blob/master/models.go#L9 The developer can import the SQL driver ... just let it panic if s/he forgets it. https://github.com/gernest/utron/blob/master/utron.go#L12 I'm not a fan of package globals. The developer can instantiate itself the app. https://github.com/gernest/utron/blob/master/view.go#L21 Should be an interface to use any rendering engine but use html/template as the default one if none has been set during init. So far my advice. Take that with a grain of salt .... I can also be horribly wrong about my view of idiomatic Go code. 
My point has nothing to do with the details of the proposal. I'm pointing out the pattern among some Alt-Right Gophers of using a reasonable sounding but ultimately superficial argument to deflect or shut down discussion of a language change only to ignore that same argument when it suits their own agenda. (Note that I did unfairly associate one group of Go folks with the Alt-Right to create a false equivalence. That may or may not undermine my comment depending on whether you fall into the Alt-Right or not.) *(And again there! Meta-slam ;-)* 
In my honest opinion, people like to open source what they are working on, and 90% of the time, it's just means to learning. If some package/library gets some traction, so be it. And you, and everybody else, who notices non-idiomatic code that could be improved, make a pull request. That's what open source is for. For everyone to contribute. That would in fact make the popular project better, and then the start count would make sense. Witch hunting and claiming "stars aren't valid metric" is not helping. Just my two cents.
&gt; Because I don't think this is true. or false? &gt; If someone puts that in their code How would you know? 
I don't think it's about the code being unidiomatic. It's about envy. Everybody nowadays has their own Go framework. And, of course, everybody is sure theirs is the most idiomatic, truly conventional, and the best of the best. But not everybody's framework has GH ~~karma~~ stars. I think, somewhere deep deep in subconsciousness I am envy, too. At least I was for sure. P.S.: Let's look at the number of downvotes I'd get. All of those are the envy people I'm talking about.
Not a problem :D Thank you for the assistance! I managed to get it working, eventually. Got a stdin loop, appending the inputted byte to a string and re-drawing the views after each iteration. Looks brilliant :D
You know when you say a word so much that you suddenly don't recognise it anymore? That's me and "idiomatic" with how much it's slung around every Go community.
Part of sharing your work publicly is implicitly opening it up to criticism. This is true of anything you decide to share with the world whether it's a blog, a tweet, art, a company, code, etc. Everyone has their own opinion and there's no way you can make everyone's opinion of your work positive. Don't worry about it. Hey, if that person hadn't linked to your project I never would have even heard about it!
I did not read. But maybe add "what it is not" to the readme, so people don't confuse it for something it is not.
I'm not qualified enough to say what idiomatic go is but I love the fact that you overcame the fear and pain to share your feelings and ask for help despite the negativity thrown your way. We often ignore the fact that the programmer on the other end is a person with feelings, good on you to speak up and ask for help. And If you're not already, you will definitely become a good programmer with this attitude. Cheers.
&gt; using a reasonable sounding but ultimately superficial argument to deflect or shut down discussion of a language change only to ignore that same argument when it suits their own agenda. It is not the same argument. Which is *my* point. And you are being immature, trolling and not at all productive here. But you know that.
You are really undermining your argument (and, consequently, the whole set of people opposing this) by being childish and non-constructive. It seems, there aren't any serious arguments against aliases after all.
Now you've made me sad too :'( Since the guy in the other post didn't even mention *why* he thought it was un-idiomatic, it's probably just jealousy. This is *my* take on what people generally mean when they think of idiomatic Go: - Use gofmt, no exceptions. - Avoid using `interface{}` and reflection. - Stick to what's available in the standard library as much as possible. - Create small interfaces, like `io.Writer` and `io.Reader`. They're basically the best thing since sliced bread. But perhaps more important. If you ask 10 different people what idiomatic Go is, you'll get 10 different answers. So don't beat yourself up over it!
It's easier to come and bitch on reddit with a self found sense of superiority than to read your code. Or god forbid, create something of value and share it with the world for free. Don't sweat it. You're doing alright. 
Sadly not yet available for Windows tho... :/
I wouldn't sweat it too much. That post represents the opinion of its author only, and I have no reason to believe he is any more an authority on Go and its idioms than you or I.
lol no generics. 
The best way to find out is to ask /u/m3wm3wm3wm.
&gt; P.S.: Let's look at the number of downvotes I'd get. All of those are the envy people I'm talking about. I was going to upvote you but now I feel like you are trying to reverse psychology me into it.
I'm not going to comment on the code. Looks like other people have done a nice job of that already :) To me, the take away is--with more visibility comes higher levels of criticism. That is, this is the price you have to pay for having 1500+ Github stars. DHH wrote Rails, which has deliveres $MM of value to companies, allowed quicker prototyping, and provided an easier onramp for 1,000s of new developers. People *love* to tell him how slow and shitty it is--every day for over a decade. Taylor Swift writes music that makes people happy, and thousands of people just fucking hate her. Last example, this is one of my favorite tweets: https://twitter.com/jashkenas/status/684399026939260929. Literally hate mail, for putting so many hours into open source. It will always be the loud minority vs the silent majority. I'd try not to be heartbroken. And if that doesn't work, I wouldn't share you code. This problem isn't going away and only gets worse with scale. Good luck out there!
You're giving up compiler safety
That's what I don't understand. The point was a general one, an interesting one even. OP didn't need to shame a specific repo to illustrate the point.
I would say that is more idiomatic than a 'magical set all function'
[Does not look like it, for now...](https://github.com/golang/go/issues/11058) 
&gt; If thousands like your package, you are obviously doing something useful. That's arguable. Iris has thousands of stars but nearly no one uses it (according to imports and vendors) and the author steals code. I'm not sure if the same could be said for utron but it doesn't look like bad code. 
Aliases... god, that blows.
Good article. I wrote an example that expands on the interface section that helped me understand it a bit. [Playground link](https://play.golang.org/p/Ce3SNREHzV) for those interested. 
I think in this case its the 'more verbose sometimes makes code more clear' type of situation.
Looks like a job for `map[string]YourStruct`. https://github.com/mohae/json2go for the lazy.
A big issue for me is that frameworks like Django and 3rd party libraries around it are always changing and usually they tend to be breaking changes. At work, we have sometimes spent weeks upgrading a complex Django project to a new OS and Django version where practically every package that we were using: Django, TastyPie, Celery, etc. had breaking changes. Then to make things worse with Django releases coming out faster now than ever it is extremely frustrating to keep on top of this. Go allowed me to go back to basics and avoid all this "madness", after using frameworks for so long this is a breath of fresh air really. Slightly OT but we've also started using Pyramid more at work for this exact reason, less breaking changes than Django and a simpler framework. We don't use Go at work... yet.
Agreed.
Nice! Thanks.
The latter. The purpose of the example was to illustrate how goroutine1 can slow down goroutine2 and how we can later see the line of code where it is happening.
I've tried and tried without success to get our team to switch to Go, it makes me a little sad, but we still do some cool stuff in both Django and Pyramid. It seems people in the team are generally keen to learn Go, but we've just never made that step as a team. I use Go a lot myself at home so I do talk about it a bit, but I don't think I have enough pull to get us to switch to Go just yet. I think the biggest issue is that we are essentially a Python shop, well not entirely true we also do PHP, Perl, Java and some Node, but as far as I am aware no team in the company has used Go for a project yet.
`${parameter%word}` is in dash, so it's most likely in POSIX (too lazy; didn't check).
`GOPATH=$HOME/go` because `~/bin` is something else.
We see quite a lot of people having their first encounter with environment variables because of Go, including not knowing how to set one for future sessions. I think that's a major source of complaints about `GOPATH` being hard.
Download count and import count are in fact terrible metrics. Download count means things that are imported a lot have a higher rating than that which imports them. A tiny library that happens to be crap, but gets used by two really amazing libraries ends up with at least as many downloads as the two really amazing libraries. An amazing command-line tool will never be imported because it's not a library. You have to use critical thinking, not downloads or imports. Stars at least give you an initial idea of what others see as useful or interesting.
Is kde supported? I run go test and nothing happens
I'm new to go but I don't see anything wrong with the code. OP sounds like they're just spreading FUD. There was no cohesive argument against go or utron in OPs post imo. 
&gt; there constructive criticism and slandering. Yep, and publicly sharing work opens yourself up to both. Other thread guy has an opinion and shared it. The fact that the opinion wasn't a very nice one doesn't matter.
Good question. I tried many different tools for drawing, and the best experience (i.e. less time spent and more intuitively) was doing those drawing in the Keynote (MacOS X presentations app). This post was originally a talk for the Go Barcelona meetup, so for the pictures I simply made a screenshots of the slides. If you can suggest really good modern tool for creating SVG diagrams/drawings (maybe even with animation?) - I would be more than happy.
These features are great, especially the plugins! I would love to see generics in 1.9
Not gonna happen for some time I think... Too hard to get it right on the first try (which they need to accomplish due to the compatibility promise)
Ah, thank you. I avoid using the empty interface, so I didn't think about that.
Don't let him get to you. It's unfair to pick out a single author like this, and does not strengthen his point. I haven't read all the utron source code, but skimmed through a couple of files and it looked alright to me. Criticism can be valuable, but non-constructive criticism is trash and can usually be disregarded.
Don't let the trolls get you down /u/bradfitz.
Now might be a great time to consider moving to vim-go. 
doesn't say it will never come back, but kudos to the team for at least understanding that there needs to be more thought on this props to the core team for listening, this could have gone south easily
More as a result of the ambiguities of the concept than proper compromise to community outcry 
`go libpath` would work on non-POSIX platforms like Windows. `${parameter%word}` doesn't. It's not portable. POSIX =/= Portability.
Also, I think that the go team deserves real credit for making this decision. Everyone was complaining that they push this against feedback, but when real technical issues where uncovered, they didn't hesitate to roll it back to have more time. I hope, in the future, people will be more careful about calling the end of days.
Aliases where removed because some serious technical concerns were found with the current implementation, not because some people in the community complained about the concept. 
and i thought *I* was the karma vacuum!
I'm biased toward [Inkscape](https://inkscape.org/en/) myself. I find it very intuitive to learn and it's perfect for producing diagrams like yours. Press Ctrl+Shift+A for the alignment menu; it's very useful.
&gt; Inkscape I used it when was on Linux, but on MacOS X all X11 apps are real pain to use. As for alignment, in many native MacOS X apps, you have smart alight line guides, that try to guess your alignment by analyzing objects' sizes/positions around - it's super intuitive, no need for menus or hotkeys. But thanks for the suggestion, I'll give it a try again anyway. 
Thanks, I just made my own for IntelliJ and it was tedious af.
I have _tried_ to use vim multiple times in the past and never have I found it to be particularly appealing. Maybe it's because I didn't stick with it long enough or maybe it's because I couldn't find the right setup for me (I too this day don't fully understand how people can use any of those tab / filemanager addons for VIM for working on multi-file projects efficiently). But, to be honest, if you (or some other kind person on this thread) has any suggestions how to turn vim into a better go editor than VSCode, I'd gladly give it another shot.
Thanks, no problem :) I use the playground skin myself now...
So, after just one workday with no syntax highlighting, I managed to fix 2 long standing bugs and implement 2 features with ease. That's was in Java "where everything is bigger" (to quote Mr Pike). I think is was refreshing to work that way, don't know exactly why. But it was nice to read my code as one thing rather than a sea of colors.
And how exactly is the rest of the shell scripting experience compatible, then? The context is Makefiles.
That's what he just said.
 The idiomatic argument is just an excuse for mad people to be mad. For every person who is busy being "hurt" about what you are doing, many more normal people are appreciating the effort of someone who shares a common interest with them. I don't care what your Go code looks like, I will read it. I will read it within the same time give or take as some uptight mad dudes idiomatic code. Go doesn't let you send me into a black hole by design. My most starred repo was something I made two years ago to play with Go generate, it's full of giant switch statements and is the least idiomatic thing ever made. You wanna know what I say about that? Lollllllllllllll Don't care. Code, have fun, get better, share, learn. Don't take criticism to heart, take it to the bank, get better and just keep accumulating all the experience. Your project is awesome and you should keep working at it. Haters gonna hate, man.
Would it be accepted as implementation code in the standard library by the Go maintainers?
Semantic satiation
The community will have a solution by then, it will be called package management.
All I can say is that this looks like normal Go code and it is much more readable especially compared to the previous Java-esque version. So basically from now on, most of the things you will see in this thread are probably nitpicks. Awesome job! I am a little confused by your `satori` package. This looks like an external dependency to me since it imports `github.com/satori/go.uuid`. If that is the case then you *might have to consider vendoring it*. You can first start doing vendoring by hand to learn the procedure and once you are tired of it, you can use any of the available tools to do it easier. My personal favorite is [gvt](https://github.com/FiloSottile/gvt) but there are many others. We will also hopefully get an official tool for this job. There is a team working on this. In short, the folder `vendor` in your project is treated as special. Everything you place under it, you can import in your project AS IF you had done `go get github.com/satori` and placed this external package under `$GOPATH/src/github.com/satori`. You can try this right away if you use Go 1.6+ (if my memory serves correct). Copy all the source files from `$GOPATH/src/github.com/satori` and place them under `$GOPATH/src/github.com/Schweppesale/todo/vendor`. So the final path is gonna look like this: `$GOPATH/src/github.com/Schweppesale/todo/vendor/github.com/satori`. You can freely delete `$GOPATH/src/github.com/satori` now. If did you did everything correctly then your project should be compiling just fine. Why do all this trouble? The source of `github.com/satori` basically lives in your project and will always be the same code you just vendored (unless you update it). Now if I want to use your package I can be sure that, no matter what, it's gonna work. Consider the alternative (aka no vendoring), then I might try to use your package and `github.com/satori` decided to do a breaking change in their code. So as soon as I `go get github.com/satori` (go get always brings the latest version) then I won't be able to use your project unless I fix the breaking change error that `github.com/satori` introduced in their codebase. That said, you do not *have* to do vendoring. If your project is small and/or you are sure the package you are importing is very stable, you could just keep things simple. (In Google they use a monorepo, which is the logic behind $GOPATH/src but for the rest of us, it doesn't always work). It also depends on how you deploy and distribute your project. If you only deploy/share a single binary then you might not need vendoring but you also need to consider what other developers have to do to be able to use your project in case they want to contribute. My point is that, in the end, vendoring comes down to choice but it is something you have to learn to do at some point if you want to work with important Go projects. This is summarized very well in Peter Bourgon's [article](https://peter.bourgon.org/go-in-production/#dependency-management). EDIT: About Peter Bourgon's article, ignore the table with `_vendor`. This is an old article and things have changed since then but the first table is still very accurate. I might find more nitpicks later but at first glance things look pretty good. You are improving at a *very* fast pace! 
I'm genuinely confused by this. Go: `fmt.Println("missing quote)` JS: `console.log("missing quote)` What's the difference? Why would it be a problem in JS but not in Go? Note: I am not the person who downvoted you. I think your comment is quite constructive, personally.
In the countries surrounding Germany, of course. But elsewhere, people learn German later in life through language institutes and self study. So perhaps I shouldn't have written "at school" but "while still at school".
&gt; Hey, sorry about that. I didn't want to sound as though I had dismissed the author's article over naming conventions. It was a good read though. No need to apologize. On the contrary you did exactly what you had to do. It is good to take what you read with a grain of salt and do your own research on how effective a proposed solution is. While Ben Johnson's articles are probably some of the best resources you can find right now, he is still learning himself (as we all do). If you follow the comments on the article carefully, you will see that many people were confused about a few of his choices. The truth is, the Go community still hasn't ended up in one sure/official/"best practice" way when it comes to web applications. The latest official resource we had about this subject (if I am not mistaken) is https://golang.org/doc/articles/wiki/ which can only get you so far. As a result, there are many different opinions on how to do things and in the end it might come down to what works best for you, your team and your project. We are all learning and improving every day and constructive discussions like these benefit the whole community greatly.
Aren't language institutes schools? Perhaps we are speaking the same thoughts with different words.
We currently use Electron (with html, css an js fir the frontend) with a go service as backend
Colloquially, school means the institute you visit as a child, age 6 - 18 or so. Sometimes it refers to other institutions, but they are usually marked. When someone says "I went to school with Jenny" and doesn't provide more information, you can infer that person knew Jenny during childhood. At least, that's how it works for me, and I think it works like that for other people too.
Perhaps this is a regional difference. Where I'm from "school" just means any place where you learn something. University/college, trade school, primary school, whatever, all school.
We'll see. I'm not optimistic, but ready to be surprised.
Thanks for constructive suggestions. Username/name is different then on most sites, the reasoning was that name can be just a pseudonym just to have one for communication, username could be just as useful, but I did not want to force a unique username as it is not publicly visible, just when using teams. If you would like, feel free to create a github issue or elaborate about fallback paths, it seems as a nice improvement.
Hi PWN1109, PaluMacil and mixedCase_, the author of bindings is here. Answering to the OP's question, the working bindings are located there: https://github.com/vulkan-go/vulkan and they come with Android demos located there: https://github.com/vulkan-go/demos. Yet it's true that currently you can't use them out of the box for Windows and Linux platforms, for several reasons. The first reason is that because at the moment I was doing it, the only Vulkan implementation that was easy to get was in NVIDIA Shield tablet. I decided to stick to the Android platform and finally get things working. The reason why there's still no Linux/Windows support is that because I have no enough time today to implement it by myself. And what's really important, as I mentioned in both issues: * https://github.com/vulkan-go/demos/issues/1 * https://github.com/vulkan-go/vulkan/issues/1 , there is no any complication that would require something like a "special hacking skill" that only I could use. Anyone can just go ahead and add support of Windows and Linux, especially Linux, where people got 2-3 backends working and for each of them there should be a standalone wrapper. From the the documentation of vulkan-go (the right part, not that about "clumsy" systems): &gt; I'm hoping for pull-requests from the community so we'd be able to run this on Windows and Linux too, since AFAIK, there is no limitations at all. In fact, I cannot recall if there was any hacks involved while I was doing my experiments. This thing just works in a very idiomatic way, meeting all the common Vulkan guidelines. Please remember that Vulkan API has very steep entry level, even if I'll add the support of Linux/Windows drivers by myself, you still will be required to know and learn the internals of Vulkan and especially its C semantics. Good luck. 
Let's put it straight, when you say "some people in the community", do you mean Dave Cheney, 163 issue downvoters (3x) on GitHub and lots of others on this subreddit who were against alias declarations per se?
Pkg management solves a different problem. They are orthogonal.
Yes. But a) [name dropping is not an argument](https://yourlogicalfallacyis.com/appeal-to-authority), b) don't ignore all the high-profile names that came out in favor of the proposal and c) you can not simply vote on technical arguments, democracy isn't particularly suited to solve technical problems.
The basic idea of a fallback package would be that if the target DNS of the package goes down, the service automatically uses some other repository and website as alternative. A full HTTP check is possible too, but it's also a bit slow and needs some clever caching to now cause outages itself. A simple method to implement would be to use 1 additional field, package-defer that tells the service to refer to the data of another registered package if the current one is not available. One use case would be to utilize my private git server for packages and if it's down, use a mirror on a bigger site to provide a fallback. This way nobody that depends on my package will experience issues. Or the other way round, if Github is down, I can use a bitbucket repository as fallback. --- As another question, how do you plan to monetize/finance your service?
But to have both on the same release will be beautiful !
Thanks. This sounds very lovely. &lt;3
Brad, nominate me for a /r/golang mod.
Yet if you spend the time to understand `append`, you'll see that it's not *forced* to allocate anything. The caller can do smart &amp; efficient things with it; the opposite of `shuffleB`.
the solution was specific to a monorepo. The solution provided was a google-specific solution.
Yes, it may not always be nice when somebody bashes your work. But I've found that when someone completely destroys my arguments or points out significant flaws -- I end up learning much more than just building things casually... so in the end I've come to enjoy the process, there's always something you can learn from those situations. Now to the subject matter: whether something is idiomatic is definitely less important than whether it's valuable. If people get good value from it, great, you've done something more useful than many other projects. For example martini project was unidiomatic, something that the author realized himself, but people did build cool stuff with it nevertheless. Now, whether projects are idiomatic/unidiomatic are not necessarily a good/bad thing. For example I wouldn't want to write "idiomatic" code in Java, because the common idioms are often way too verbose. I would also use more inner classes and larger files; than is recommended. "Unidiomatic" means it's more difficult to read for usual users... There's also the other aspect, whether the "idiomatic style" results in good architecture and code. From personal experience I would say that the Go "idiomatic style" definitely has this property. It heavily leans into readable and understandable code -- but not necessarily concision. I'll try to condense "idiomatic Go" to a few ideas (of course people may agree/disagree with my list): 1. No stutter. 2. No ambiguous words. (`models` as the top-level package says nothing useful) 3. Clear value. 4. Concrete over abstract. 5. Depend on interfaces, return structs. 6. Make hard decisions. Don't have 100 ways of doing something. 7. gofmt, golint. 8. And more https://go-proverbs.github.io/ For further reading on structuring applications: * https://codegangsta.io/blog/2014/05/19/my-thoughts-on-martini/ * https://github.com/marcusolsson/goddd (and the associated blog posts) * https://medium.com/@benbjohnson/standard-package-layout-7cdbc8391fc1#.uec37ltci * https://forum.golangbridge.org/t/comparing-the-structure-of-web-applications/1198 * https://groups.google.com/forum/#!msg/golang-nuts/1z5kL5FCDdU/--Iox7PSAwAJ Unfortunately a full review of `utron` would take too much time, so I'm going to give the general impression I got. The top-level looks overly generic -- it is unclear what is the win over other projects (points 3, 4). The example application uses generic top-level packages (points 2, 3, 4). There is only one example, and that itself is trivial -- show also business logic (e.g. https://revel.github.io/samples/booking.html, I'm not saying I like the code, but I do like the example).
Neat! This one seems much more fully-featured, giving you the ability to set hints and to see which capabilities the notification server supports. If you want to do anything beyond a simple "title + body + icon" notification, this seems like the best option.
Overall it looks a lot more idiomatic. There is still some 'stuttery' names such as the TaskRepository interface has methods like FindTasks() GetTasksByUniqueID(). Since all it deals with are tasks, I'd consider renaming them without Tasks, so Find(), GetByUniqueID(), etc. Looking at the logic of Find there might be a better name, since it doesn't actually filter anything, just returns them all. https://github.com/Schweppesale/todo/blob/refactored/infrastructure/memory/repositories.go#L31 There is an if/else statement with returns in both sections, you could remove the else clause (but keep the 2nd return statement). In /infrastructure/repositories/memory/memory.go I think you could get rid of the keys field and just use a range statement on the tasks map when you want to call FindAll Should use the mutex around the FindAll logic I don't think you need an interface for the UUID generator 
http://dave.cheney.net/2013/04/30/curious-channels http://dave.cheney.net/2014/03/19/channel-axioms
Also related: http://blog.sgmansfield.com/2016/06/how-to-block-forever-in-go/
I took a quick glance at the analytics.go file, it looked pretty solid. I'll take a better look at it later when I'm in front of a computer.
For posterity, here is the follow up discussion: https://groups.google.com/forum/#!topic/pact-support/ob90CUGUaww
I'm sure the won't turn down patches to clean up the generated code.
Oh, I'm sure, I just wanted to clarify what they were talking about.
I will also take a proper look later. My first thought is that the README could do with showing the results of the example code. This may then need a little explanation too, covering what is analysed and why.
Some of those examples given are extra complicated for the joy of it. Reading from a nil channel is sufficient. The exact type of the channel won't matter. `bool` is quick to type. So: &lt;-(chan bool)(nil) 
I think you need to study the Oberon OS. They managed to create an almost entire GC OS. Essentially there are a couple of issues that need to be solved, the rest is rather dull (and the C code translation could be automated). These issues are: GC at OS level instead of language level, each package is the compilation unit (no big statically compiled binaries), each module is loaded only once and unloaded when not used. Which means developing a Go variant, a compiler and a module interface definition.
I haven't touched graphics either but it's a good idea. I'll keep working on it.
&gt; In Go, there are value types, reference types, and pointers. References types are slices, maps, and channels. All the rest are value types, but have the ability "to be referenced" with pointers. The most practical difference to remember between references and pointers, is that while you can use both to mutate the underlaying value (when it is mutable), with pointers you can also reassign it. Go spec has removed the concept of "reference type" three years ago. [There Is No Reference Types in Golang](http://www.tapirgames.com/blog/golang-has-no-reference-values).
Use glide or godep. Vendor becomes part of your `GOPATH/src` when you build, so you'd probably have something like `vendor/github.com/aws/aws-sdk-go`. Really, use glide or godep -- you shouldn't manage vendored dependencies by hand.
Check out this post where I explain [how to vendor](https://www.reddit.com/r/golang/comments/5b8cct/request_for_code_review_2/d9mn8ao/) for a specific project case.
Thanks! updating original post, 1 moment
Thanks! updating original post, 1 moment...
Here's a read-only, disk-based radix tree: github.com/sermodigital/drt regardless of the route you go, mmap is your friend.
And yeah...(after I actually bother to read...) you only need to upload your binary file to your EC instance. Unless you're going to use a EC instance as a remote build machine, then it doesn't matter what version of Go it supports. *there are some cases where your OS environment might matter, but by and large, copy over the binary and run it. Good to Go
Looks pretty cool! Is there a way to make the pipeline not auto-evaluate everything you type, and only do it on some keypress? I worry about running a destructive command because it happens to be a typo or prefix of another command. (Say, `rm` instead of `rmiregistry`). It also looks like you're reading in the whole input, and I can't start filtering until that's completed. I'm testing with a 900M gzipped file, and there's significant delay between typing each letter and being able to type the next. Even on typing stuff that I know won't affect the output (a space after the command), it takes the time to run the whole command again. It's also using about 50GB of RAM by the time I finished typing `zcat`. This is a pretty cool project, gonna keep my eye on it. `^_^`
&gt; Don't like most functions in Golang, callings of the above three functions will be always evaluated at compile time, instead of run time. Translation?
They're equivalent to calls like `sizeof(int)` in C, which the _compiler_ will replace with an integer value. So where you might have foo := unsafe.Sizeof(myUint) in your source, on a 64 bit machine that would be compiled in your binary as (the equivalent of) foo := uintptr(8) rather than the Sizeof function actually being called while the program is running.
I prefer to return errors, rather than panicking. I leave panics for errors that are quite terminal and won't allow the app to proceed and where recovering from the underlying cause of the issue would require a real human to step in and mess about with the computer.
I think it depends on the complexity in your domain. If damage is always straight forward then you could expose the actual field as you would only modify a primitive datatype. However if you consider some sort of shield that absorbs x% of the damage you get a calculation that should be internal to the unit taking damage.
For someone who's a newbie to parser generators, what'd be an ELI5 of differences between using https://golang.org/cmd/yacc/ vs. antlr4's Go language target?
In the case of complexity around Health logic, that's precisely why I would prefer to have that complexity on the Health struct itself and just embed it, or in another function entirely. If Health included all the fields and methods for calculating damage done, then any unit with a Health field could take damage accurately. In other words, I'd like to be able to properly mix-in structs to compose larger structs, but I feel the only thing missing is access to the embedded struct itself without exposing it via a method. For example if I define, `type Tower struct { Position; Mesh }`, it would be nice if the Rendering system could accept any struct with a Mesh and Position, but a DistanceBetween function could accept any two structs with Position fields. 
Don't like --&gt; Unlike
Yes, and having a []*Tower would be ideal. However, other units have Health fields, so a []Healther slice would be even nicer.
fwiw you can run grpc-gateway int the same process
That's a better alternative, thanks for the suggestion! I was actually just thinking about other ways of doing the invulnerability timer.
I've had good success with govendor even with all the gymanstics around protobuf + grpc.
I'm surprised there were no issues. I made the binary with 1.7.3 and amazon is running 1.5. Though maybe once it's an executable binary that doesn't matter? idk... do you think I'll run into any issues? Since I'm using it as the server I already have most of the functionality I want.
Not to say that this is a great presentation, it still may help someone dive in. http://talks.godoc.org/github.com/euggo/meetup/talks/go_rpc_with_grpc/go_rpc_with_grpc.slide
One big gotcha with custom error types: func Foo() error { var err MyCustomErrType return err } func main(){ fmt.Println(Foo() != nil) // true???? } Even though err is nil as `MyCustomErrType`, the caller will see a non-nil `error`. This has bit me enough that I now know how to avoid it, but it sure seems odd if you are not aware of that behaviour. Its not specific to error types, but comes up there more often than in other places I have seen.
 BenchmarkMonadic/Int/FnUniverse-24 2000000000 0.42 ns/op BenchmarkMonadic/Int/MethodUniverse-24 2000000000 0.41 ns/op BenchmarkMonadic/Int/MethodCallerUniverse-24 300000000 4.23 ns/op BenchmarkMonadic/Int/FnParent-24 500000000 2.58 ns/op BenchmarkMonadic/Int/FnLocal-24 500000000 2.61 ns/op BenchmarkMonadic/Interface/FnUniverse-24 200000000 8.40 ns/op BenchmarkMonadic/Interface/MethodUniverse-24 100000000 10.0 ns/op BenchmarkMonadic/Interface/MethodCallerUniverse-24 20000000 58.2 ns/op BenchmarkMonadic/Interface/FnParent-24 20000000 58.0 ns/op BenchmarkMonadic/Interface/FnLocal-24 20000000 59.9 ns/op BenchmarkVariadic/Int/FnUniverse-24 500000000 2.93 ns/op BenchmarkVariadic/Int/MethodUniverse-24 300000000 3.62 ns/op BenchmarkVariadic/Int/MethodCallerUniverse-24 20000000 51.8 ns/op BenchmarkVariadic/Int/FnParent-24 30000000 43.4 ns/op BenchmarkVariadic/Int/FnLocal-24 50000000 42.9 ns/op BenchmarkVariadic/Interface/FnUniverse-24 100000000 10.8 ns/op BenchmarkVariadic/Interface/MethodUniverse-24 100000000 10.6 ns/op BenchmarkVariadic/Interface/MethodCallerUniverse-24 10000000 135 ns/op BenchmarkVariadic/Interface/FnParent-24 10000000 131 ns/op BenchmarkVariadic/Interface/FnLocal-24 10000000 131 ns/op The asm generated with go tool compile is gigantic, but It looks like it is making heap allocations for calls to the Interface and variadic methods, but only when the call site is not in the universe scope. I have no idea what the slowdown is though, if anyone has a quick lead I would appreciate it.. this just sparked my interest is all.
stdout and stderr are noisy and can be redirected godknowswhere. q will always output to $TMPDIR/q. Think of $TMPDIR/q as a quiet place where you can listen to one little part of your program.
Yep. That!!! One time, I thought I could use my server's logging object. LOL! That was a mistake because I needed to turn on like 10 different switches to make that work. Another time, I thought I could just use `fmt.Println` to debug. HA! Little did I know, this program's stdout/stderr was being redirected to some other processing unit somewhere else, so my output was always altered. The video in the readme explains this—and is funny too!
This is a bit farther from a direct answer but in game design I like to have Attributes as a general representation of a Entities persistent mutable values like health, mana, strength, gold, etc. So for Go I would probably have a type Attributer interface Set Sub Div Mul, anything else convenient Then I would implement it with a type attribute *int. Then I would create my various actors types define attributes, like a tower Health() Attribute Cost() Attribute Then tower can easily implement Attribute with a new(attribute) in his init. Not 100% sure I would use a interface to start would probably let it prove it was needed first. I would create a struct to group common sets of attributes and embed it for concrete actors. Just food for thought have fun man. 
I got it, Took a little bit but i figured it out code playground; https://play.golang.org/p/evMpVaqu8F
HTTP2 is not meant to be used without TLS, and it's absolutely understandable that the Go implementation (along with most others afaik) doesn't work without it 
&gt; BenchmarkMonadic/Int/FnUniverse-24 2000000000 0.42 ns/op &gt; BenchmarkMonadic/Int/MethodUniverse-24 2000000000 0.41 ns/op Those numbers generally mean "benchmark removed by optimizer". The compiler could see that no work was being performed, and so benchmarked an empty loop instead. 
How does it compare to https://github.com/fatih/color?
Maybe [BoltDB](https://github.com/boltdb/bolt) might be applicable here too. You can build hierarchies using buckets. The database file is mmap()'d to memory.
the scrolling on this site is fucking me up.
This starts to sound like C++ Boost, Java Spring etc. I hope it won't catch on otherwise we are doomed to relive the nightmares of other language ecosystems. We do not need to start shoving "enterprise" in the Go ecosystem. The big advantage of Go is simplicity. And I would argue that Go is already more pragmatic and "enterprise" than many existing solutions.
`var &lt;name&gt; &lt;type&gt;` initializes to the [zero value](https://golang.org/ref/spec#The_zero_value). The zero value for structs is the struct with all its fields initialized with their own zero values. If you want the behaviour you expect, use func Foo() error { var err error if something { err = MyCustomErrType{} } return err } Interface variables can be `nil`, `struct` variables can not. Only pointer to struct can be `nil`.
Is this anything more than an enterprise support plan for the go toolchain? 
I prefer to use interfaces to detect type of error. Like in this blog entry 'Assert errors for behaviour, not type' http://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully type temporary interface { Temporary() bool } // IsTemporary returns true if err is temporary. func IsTemporary(err error) bool { te, ok := err.(temporary) return ok &amp;&amp; te.Temporary() } Big plus with this you don't need to import package defining error type.
This seems like spam. Every single "product" on their site says coming soon. And they all basically say the same thing. Seems like vaporware or just some dressed up SLA.
The main feature is `Printf` support. Feel free to choose format you want fmt.Printf("amount %+3d, Pi: %+1.4e\n", Green(2), Cyan(math.Pi)) fmt.Printf("amount %03d, Pi: %1.2f\n", Green(2), Cyan(math.Pi)) The code above is equal to amount := Green(2) pi := Cyan(math.Pi) fmt.Printf("amount %+3d, Pi: %+1.4e\n", amount, pi) fmt.Printf("amount %03d, Pi: %1.2f\n", amount, pi) But I designed it to use for logs. This way I create Aurora instance depending configs (with or without colors). And use the instance. Checkout project readme for examples.
That logo is amazing.
 #cgo pkg-config: portaudio-2.0 remove that from the portaudio wrapper and replace it with: #cgo LDFLAGS: -lportaudio that might work, however you might have to add the path to the library via -L on the LDFLAGS
My fast compare ([color](https://github.com/fatih/color), [ansi](https://github.com/mgutz/ansi), [aurora](https://github.com/logrusorgru/aurora)) on Windows machine. [Code](https://play.golang.org/p/broAhzcfRZ). [Result](http://i.imgur.com/PBcyH5A.png). IMO conclusion: * 'color': * from aliens to aliens * 'ansi': * pros: best colorpick approach * cons: "everything is a string" * 'aurora': * pros: hooks, interfaces * cons: inability to handle color codes (like 'ansi') 
I use Linux as my development environment and if you're going to be compiling software the best solution I've found is to install a stable Linux distro (like Ubuntu) and then install LXC, and then create a gentoo container using LXC. Gentoo is a distribution where all software is compiled by the package manager. Even when some packages aren't included in portage, because gentoo has most of the tools needed to compiles packages, it hardly ever has any issues when you need to compile manually. I still use Windows on my gaming rig, but Linux is just the superior option when it comes to dev environments unless you want to jump through hoops all day on Windows. Even Microsoft has admitted than Linux is a better development environment than Windows, which is why they now ship with a Linux compatibility layer (which is still pretty buggy btw). 
ActivateState just repackages open source programming languages, slaps a bunch of buzzwords on them, and sells them to unsuspecting enterprise (mostly Windows) dev shops that are scared of open source and think if they're paying for it that it must be better. Adding in prepackaged packages just fits the narrative of not trusting open source - if they're preinstalled they're "obviously" safe and licensed and better than something you just downloaded off github.
&gt; In nodejs, when a developer writes require('leftpad'), what they mean is "require the version of leftpad that is listed in my package.json file". If a go developer (in a world with the vendor dir feature) writes `import "github.com/foo/bar"`, what they mean is "import the version of `github.com/foo/bar` that is in my vendor/ directory. &gt; In the package.json, the developer could have specified that leftpad further resolves to an arbitrary git repository, filepath, npm repo, or so on. Interesting. I wasn't aware that npm supports not using the npm repository. It's not material though. The go tool doesn't care where the code in `vendor/github.com/foo/bar` comes from, so this is also the same as with the go vendoring feature; the vendored package could come from a github repo, a bitbucket repo, a tarball, a VFS or whatever you want. &gt; The most important distinction here is that the vendor feature stands alone as a hellish bundle of files a user may distribute or not which has elaborate impacts on name resolution... while every other sane language (bundler, npm, cargo, mvn, etc) just has a simple file with a name =&gt; source mapping. I don't understand what point you are trying to make here, to be honest. &gt; In go, the import path is both of those and is controlled by a third party typically. That is the default way the specific download tool `go get` works, when you are *not* using the vendor-feature. I.e. a) you are ignoring the specific question of how the vendor-feature compares to other languages and b) you are restricting yourself to go-get (which has zero integration for that anyway). &gt; No, that's not true. If the contents of that repo are a file with "package asdf" then you'll have to refer to the contents of the repo with "asdf". The name of the package is totally unrelated to its import path (other than by convention). What is a "name of a package", if not it's unique identifier? `asdf` is *not* the name. e.g. what is the package `draw`? Is it `draw`, or is it `golang.org/x/image/draw`? According to your logic, they are the same package? Or just have the same name? The fact is, the compiler treats the import path as the identifier and name of a package. All the code uses the import path as the name of the package, to determine if packages are different or not. In any sensible interpretation of the term `name`, the name is the complete import path. Confusing that is the reason, why so many newcomers don't understand how they can contribute to go software; they think, their fork of a package is the same package, but it unequivocally *is not*. And that's a *good* thing, because both packages might contain very different code and it's important to refer to whose code you are referring to. &gt; Secondly, if the contents of that repo are a go file with package asdf // import npm.io/leftpad then you'll have to import it by that (totally un-go-gettable) url to build. Yes, meaning it's name/import-path is `npm.io/leftpad`. The import path/package name is different from the location of where to get it *that is the whole point*. That is, why `go get` implements a package discovery mechanism to map from an import path to the fetch-location. You are making my point for me. &gt; A given import path which is a git server You are contradicting yourself. The import path is, what I write into my code to import a package. But In the sentence before you where pointing out how *that can be different from the fetch-location of the code*. &gt; I can't think of any other language that is this fucked. All of them are. Unequivocally. You are just (understandably) mixing up what the things are. You are confusing repositories with import paths and base(importpath) with the name of the package. If you do not insist on that false interpretation, everything will make more sense, trust me.
Delve is going to be **the** golang debugger, but it's still pre-1.0 and there are times when you don't need a full debugger session. You just want to print a quick var. q and Delve complement each other.
I think we need to contribute to the database drivers as soon as possible if we want this ! An issue was opened on all drivers i think.
I'd been using https://github.com/davecgh/go-spew till now, tried `q` briefly and I think I may be an instant convert. Nice.
Hey what about evaluating only when there is a trailing ';'? Then you can go back and edit args with realtime output.
You say it like it's something bad. I am not their target audience. But if there are people who are willing to pay for what they offer, why not?
pp and go-goon * output to stdout * pp.Print and goon.Dump are more typing than q.Q (or qq if you use a snippet) * have knobs q exports one function with no knobs.
It's pretty much a "Public Domain" type of license.
Unfortunately being simple to us is irrelevant when we work for companies large enough to have legal teams and policies around open source project usage and contribution. Honestly I wouldn't use it in a project I intended to sell under a one man LLC because it's too risky to use a non-circulated license that hasn't had legal prcedence put in place. Licenses you adopt are licenses that you must defend if another portion of your software becomes a target of litigation- it lowers the resilience of your software as a whole indirectly by having no precedence you could be the one whom has to spend the resources to set it. That said, perhaps the license is perfectly written and may be defended.. or there is legal precedence already set. A company can not have it's corporate attorneys spending time researching these things for one-off licenses so a pre-approved list is usually set as a mandate. Just a little insight on the under-the-hood of licenses, I know it's silly.. but it exists.
I understand it in spirit of course, unfortunately I'm not sure corporate attorneys would. Just was trying to point out without legal precedence it's too risk to use for non personal use. I elaborated more above this post.
Clients are almost almost going to be faster than APIs. Twitter and FBs APIs are painfully slow hence the invention of Message Queuing/Message brokering middle-ware.
If you read the paper, they had to modify Linux kernel to support their collector and it only works on x86. So for the purpose of a language like Go, that has to work on unmodified Linux/Mac/Windows kernel and on variety of processors (x86, arm, mips, sparc), this is unsolved problem.
Yup, I have read the paper and I'm familiar with the limitations of how their barrier works both on their cpus as well as on vms. The choice they made does not make the statement "Real Time GC current, potentially unsolvable problem" true. It also doesn't exclude the possibility of a similar design using a different barrier mechanism. In particular golang has the advantage of control of the compiler, so they could use a barrier technique that requires changing the output code at every memory access if they needed/wanted. Note also that there are other gc's considered real time, such as IBM's Metronome. With the latest changes golang's gc is in the same rough ballpark. It would not surprise me in the slightest if given a year or two more contributions as smart as we've seen the last year, go gets to a real time gc. I'm unaware of anything that excludes the possibility of go getting a fully pauseless gc as well, though I think that's going to be more difficult to make efficient enough vs a very short duration and frequency hard bounded pause.
yeah, I'd prefer to not `.`. And typing the full package name is kinda ick. Maybe just alias it to `c` or `clr`?
On a side note they are included in our all inclusive Docker image (130mb): https://hub.docker.com/r/znly/protoc/
I've seen one on a former coworker's desk. It's the only one I've ever seen -- I think they may be pretty rare.
Every now and then they'll pop up in the Google Store; however, usually they are handed out at conferences (I got mine at GopherCon this year)
[Image](http://imgs.xkcd.com/comics/git_commit.png) [Mobile](https://m.xkcd.com/1296/) **Title:** Git Commit **Title-text:** Merge branch 'asdfasjkfdlas\/alkdjf' into sdkjfls\-final [Comic Explanation](https://www.explainxkcd.com/wiki/index.php/1296#Explanation) **Stats:** This comic has been referenced 140 times, representing 0.1041% of referenced xkcds. --- ^[xkcd.com](https://www.xkcd.com) ^| ^[xkcd sub](https://www.reddit.com/r/xkcd/) ^| ^[Problems/Bugs?](https://www.reddit.com/r/xkcd_transcriber/) ^| ^[Statistics](http://xkcdref.info/statistics/) ^| ^[Stop Replying](https://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=ignore%20me&amp;message=ignore%20me) ^| ^[Delete](https://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=delete&amp;message=delete%20t1_d9qp4zo)
Multi-licensing would probably help. CC0 isn't bad, but it may be good to have a more conventional license like BSD. See http://www.rants.org/2011/04/open-source-license-flowchart/ for a more humorous take. Usual disclaimer about not getting legal advice from the internet. ;)
Looks like gommit does not follow the xkcd commit message rules. Un-be-lievable!! I'll raise an issue. Immediately. 
The Go team and/or some other gophers at Google should create an open-source Go web app that sells official gopher figures and which apart from providing us with our beloved gophers plushies, it would also serve as a perfect example of how to write Go web apps.
I can't believe I managed to lose my vinyl one back to 2012...
You refer to "a language like Go". The Java language (among others) runs on the JVM across all those kernels and architectures among others. Not sure how the language is relevant, it's the runtime that matters. Yes, Azul is unique in that it messes with the kernel, it could do the same for a Go runtime too. It's a solved problem on a single architecture and OS for one particular runtime. Nothing language specific about it. 
You should make a Gopher shipping service. :) It's quite hard to get one, especially in Europe.
Have a look at this link and it should be more clear what i'm talking about. http://neuralnetworksanddeeplearning.com/chap1.html be careful, learning about neural networks and genetic algorithms it's a rabbit hole with no end. A fun one though :) pmed you github package
https://www.gnu.org/software/stow/
Fair enough! I cobbled the documentation together last night while I was half asleep. I have a simple example in the readme, but I need to do the following: - Add more examples showing off all the use cases - Actually integrate some examples within the GoDoc (so I'm not just limited to the readme)
It's cool, the only problem that I found is you need convert everything, because the "channel" is interface{}, but is not your fault...
I have a couple of questions - 1. What are the guarantees this package makes about the order which data is distributed to listeners, if any? 2. Does the package provide a mechanism for an unbounded mailbox? 3. Does a mailbox drain once closed? Overall I like the package. I can definitely see myself using it in the future, once the behavior becomes more concretely documented.
Darn lack of generics :P. I was thinking of generating some code for common types. Just depends on if there is any demand for it.
This is what I immediately thought of with the name stow
Is there a reason you use goto and labels rather than defer statements and a return to ensure the unlock of the mux? As in here: https://github.com/itsmontoya/mailbox/commit/6c50b85fae3ad0b050c6b0b86816eea1a9f91561
defer has different semantics (which justify the overhead). If you write mxt.Lock() defer mtv.Unlock() // code then you know that, no matter what `&lt;code&gt;` does, the mutex will get unlocked eventually. However, if you do mtx.Lock() // code mtx.Unlock() then `&lt;code&gt;` might `panic` (or call `runtime.Goexit()`), leaving the mutex locked, leading to a potential deadlock. Now, in the face of a panic, you should consider the state of your program invalid anyway and immediately crash but a) this doesn't always happen (e.g. panics in an http Handler will be recovered) and b) it still means there is a semantic difference :) As to performance: It really shouldn't matter in practice. Unless you have specific use cases for which you can show that the defer is a problem, you should use defer iff you want the semantics of defer.
Cool and all, but the benchmark isn't really accurate because you are also sending interfaces through the channels. I would change the channels to int types and update with those numbers. Also you don't need a wait group for channels because the sender may signal the close. You are also creating much more contention for the channels because you run the channel test under benchmark parallel while running the mailbox in two Go routines. I would be curious to see numbers after those changes. I tested it real quick, it's a little bit faster :) BenchmarkMailbox-24 3000000 489 ns/op 8 B/op 1 allocs/op BenchmarkChannel-24 3000000 437 ns/op 0 B/op 0 allocs/op using: https://gist.github.com/cstockton/6059674b7afae5a1dba6bf9ddde56871
I'll add in a typed version for channels. It will make channels faster, but not 2x faster
I've written quite a few high performance low-level libraries for our internal use. As of now, I can definitely say that defer is a performance hit. Once defer is faster, I'll be using it more on my low level libs. Additionally, for all my code which is not performance critical, defer is used :)
I'm pretty sure it would make it close to the same since you would avoid an allocation and type assertion for the channel. Maybe i'll try this evening since I'm curious.
Note how we both were very particular in how we phrased things :) I said, it shouldn't matter in practice. You said there is a performance hit ;) I didn't deny there to be a performance hit, I just don't believe it will actually end up being the thing that makes your software slow. But anyway. ¯\\_(ツ)_/¯
Implemented a generic version of this container https://github.com/itsmontoya/mailbox/pull/1 
Any production-grade usecases?
Nice! I'll check out the pull request later. Looking forward to integrating native types
[fogleman/ln](https://github.com/fogleman/ln) has a pretty nice basic 3D rendering engine for line art.
In my generics generation scenario benchmarks are actually better for Mailbox when type is int, see pull request.
Nice try, but it actually should be much more $ pkg-config --cflags portaudio-2.0 -mthreads -IC:/MinGW/msys/1.0/local/include $ pkg-config --libs portaudio-2.0 -LC:/MinGW/msys/1.0/local/lib -lportaudio -lwinmm -lm -lole32 -luuid 
&gt; "Close doesn't cause send's loop to break. You should check isClosed like you do in receive, and panic if so." Instead of a panic, my original intent was to return a "state code". In the situation of a sender being closed, StateClosed would be returned. I do check for isClosed at the beginning of the send. I'll do some perf comparisons for checking the closed state during the loop. &gt; "Calling arbitrary client code (Listen's fn) while holding the mutex lock is a recipe for deadlock." Please show me an example where this deadlocks. I'll gladly fix it if the issue is reproducible. &gt; "There's no reason to use goto here; for loops are more readable." Per another request, I am going to try this out and see if there are any performance hits. If the performance is the same (or better), I'll utilize the loop. If not, the goto's will remain.
are there any decent gui frameworks for go? 
May I have your opinion? How would you feel about interfacing with a library which returned status codes instead of errors? if sc := mb.Send(); sc != StatusOK { // Do stuff }
neat. thanks!
I thought it didn't matter since context.Context is an interface, so they're basically inter-changable. Is there something I'm missing.
&gt; Update 5 June 2016: You can FINALLY go get this package! nice
I believe they are $18 so that pls a big envelope in shipping.
In my own research for a email package w/o using auth to Gmail SMTP server or a 3rd party email service, I saw numerous people asking how to do this so their app can send simple account recovery / forgot password emails, et al. This was built to satisfy my extremely basic use case, but would be grateful to get community PRs to add functionality. 
Writing a generator based on the original code is trivial. It's like Ctrl+H.
Follow up, /u/xlab_is created a pull request with generated generics. I'm seeing about 40-50% speed increase on my local benchmarks. :)
There is a huge difference actually. With status codes, your allocation and return is always 8 bytes with no GC pointer overhead. 
Fair enough, I'll take that idea into consideration
Example of deadlocking code: func main() { mb := New(32) go func() { mb.Send("Hello world!") mb.Close() }() mb.Listen(func(msg interface{}) (end bool) { mb.Send(msg) fmt.Println(msg) return }) }
 keepCalm() for popcorn := range &lt;-popcorn_supply { consume(popcorn) }
Try adding some examples to the README and the godoc. As it stand I can't make heads nor tails out of this.
Yeah, added that issue 4 days ago https://github.com/pipes-and-filters/filters/issues/2 The tests do show how to use it though. https://github.com/pipes-and-filters/filters/blob/master/filters_test.go
The big email providers also operate with IP whitelists, so you really should not do this.
Ah this looks awesome. I started working on my own solution to this problem last week. Stow seems like it could be great and excited to see how it matures! For those interested in checking out a vastly inferior package, my contribution: https://github.com/hugorut/gofile (WIP) 
I wrote something similar for relay host users, by user case it was for sending mail from containers. It could use the addition of SMTP authentication, but for IP based relays it's good to go. https://github.com/squash/gosendmail 
A conditional goto is the same as a for loop, both in semantics and in emitted code. If the goto is faster, you need to file a bug report over bad code generation. :) I don't dislike goto, but it does seem silly to manually implement a for loop with it.
&gt; defer has different semantics And in particular, `Mailbox.Listen` has dangerous/unsafe/wrong semantics due to this. `Listen` calls a user provided function while holding the lock and doesn't attempt to unlock if the called function does anything unexpected. At first glance it would appear to me that this is one of several places where this code puts speed/optimization before correctness. Personally, I don't care how much faster something is if it isn't correct.