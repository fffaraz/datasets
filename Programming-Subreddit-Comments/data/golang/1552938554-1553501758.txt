Thank you and GentlemenTechs response. So my problem is that I have done the monolith a few times now and without fail it becomes a mess in short order. Partly because the code is still broken up in "modules" to help organize the code, e.g. the individual domains usually get their own package in each layer (api, services, db). Like you mentioned, documentation is never kept up to date, regardless of attempts to enforce it, usually due to time sensitive features that the upper management require to be done yesterday. Also, as this is my own project I am doing alone right now, I wanted to try to learn how the whole microservices architecture comes together, so that I have a better understanding of both sides of the fence. So, I think what may work is a combo of both approaches. That is to say, I could put all the API calls in one code base. Those would handle the one to one or one to many (e.g. multiple different services to complete one task) aggregate service calls. A message bus or grpc would be used between the API tier and the service tier. Initially, the back end tier could also be one code base as well. In this way, I have at least separate public facing API, from the back end bit, via MB/grpc. The one bit that I find hard to figure out how best to optimize is each back end service (when broken out into separate services) having their own DB. In monolith apps, you usually have queries that have DB table relations. For example, a user is tied to an order, and email sent out on behalf of a user for an order is tied to both as well. I am wondering how big of a performance hit an application built in this way takes when the query is now spread across multiple service calls instead of a single SQL query, since the different bits of data reside in different DBs tied to their respective services. Is there a solution to this? Some way where by some services would share a DB to provide much faster db queries? Per your last paragraph, I have also been wondering how best to approach the concept of the API being more like an SDK, e.g. one call does a series of things... or a 1:1 Rest API where you have to make multiple API requests. I struggle with this, because I want to be Rest based... e.g. a good Rest implementation, not half baked Http RCP style APIs... but to be more GraphQL like where by the consumer can make a single call that results in a string of back end services being executed to return the desired result, per business needs, seems to make sense too. 
Not really the way I interpreted that presentation at all. He was justifying why he made an open source web framework and he also iterated several of the problems that you need to solve when you’re making a web framework. It’s true that if you ask on reddit “what framework should I use”, redditors will almost always answer net/http. It’s also true that you likely need cookies, databases, database migrations, route parameters, configuration variables, test setup/tear down which includes database, etc. Some of the conveniences I really like from gobuffalo that I’m sure you can get from other frameworks too, but not from net/http: - live reload on save - static assets like HTML/js embedded in the Golang binary. One static binary has everything I need for deployment - Testing: fixtures, setup and tear down that prepares my database before each test - database migrations
8 months? What took him so long? Deploying the stack is easy and can be done in a couple of hours. All you need to do then is start pumping logs into it. On small scale it should work out of the box.
logic/logic.go:43 panic("Draw, Starting a new round!") I would not recommend using panics for flow control. logic/logic.go:57 path := "/api/v1/orderBook/L2?symbol=" + asset + "&amp;depth=" + convert.IntToString(central.Depth()) Using [https://golang.org/pkg/net/url/#example\_Values](https://golang.org/pkg/net/url/#example_Values) you can construct URLs and be sure the values are escaped. central/bones.go:94 return conf.Candle * 6 A magic number. Either explain it in the comments, or make it a named const. So the config helper functions prevent easy testing. func endpoint() string { conf := configReader() return conf.Endpoint } So the only way to test any function that uses `endpoint` (like `ClientRobot`) would be to create a test config. There is no way to create different configs for testing quickly. If you either inject the config as a parameter or define ClientRobot as a function on a struct that has the config, then it is easy to test. The function `configReader` also re-reads the config each time. Create a function GetConfig that uses [https://golang.org/pkg/sync/#Once](https://golang.org/pkg/sync/#Once) to only load the config one from disk. 
If you are new to Go, have you read: https://github.com/golang/go/wiki/CodeReviewComments ? You can use this to do a self review. This has a lot of the common "mistakes" that people make when using Go; and it comes straight from the Go Crew themselves.
Why would you ever have any code that's unformatted? Format on save is invaluable...
I absolutely do... for my things. I don't have (yet) access to my co-workers machines to do that for them though.
fasthttp doesn't implement the http spec, it implements a subset of it which the author has decided was important. If correctness matters less to you than speed, go for it; I can't imagine many situations where that is true, outside of benchmark games.
PRs shall not be merged unless `gofmt` is a no-op. Easy enough to set an integration for that, or a failing step in your CI.
unfortunately people have opinions that are more solid than concrete now or this would be easy to do retro-actively - but yes of course that is where projects should start - not after the fact when it is much more difficult to get buy-in
I'm at work so I can't watch right now but just based on the title it sounds awesome. I love using Golang and Gin I just wish there were more in-depth tutorials.
wow. He actually deleted his reddit and github accounts.
I also have a formatting hook, but it ignores merge commits and vendored files: git rev-parse -q --verify MERGE_HEAD &amp;&amp; exit 0 gofiles=$(git diff --cached --name-only --diff-filter=ACM | grep -v '^vendor/' | grep '\.go$') ... 
Thanks for the comment! Let me know your thoughts when you get around to watching it. I touch on testing in this video, testing a package and
Can you explain what this command does? I'd consider myself relatively Git-savvy, but it's not intuitive what this does or it's relative pros/cons vs a commit hook.
&gt; And because of the lack of configurability, I can't turn those parts off and so I just never run it. This is a design issue. Having a single standardised way of formatting code is much more beneficial than some tool randomly distributed with a bunch of options for everyone's super important preference. 
[removed]
The other way around. First regain sanity, then work on the thing.
Cool! I was wondering if such a guide existed.
&gt; When learning a new language, learning the culture is probably just as important as learning the syntax. Always. Programming language or natural language.
A compilation of the [best Golang books](https://reactdom.com/go)
I'm starting my first golang rest API and I'm curious why you picked gin over chi or gorilla. 
&gt; what kind of backwards savage thinks like that. Are you brain damaged? When a male gives birth to a baby and breast feeds it, please, let me know. &amp;#x200B; Anyway, on to the actual discussion: &gt; They are for totally different things. Such as? Both native compiled, type safe languages that attempt to fill the whole of C/C++. Please, tell me, what do you think they are each for? Rust is ONLY for systems programming and Go is ONLY for CLI/Web Servers? Because they both have entire frameworks dedicated to both. I hate people parroting the "use the right tool for the job!". Most of the time, there is a legitimate reason one is better than the other. &amp;#x200B; I agree, they are two different approaches, but in absolutely no way are they meant for different things. Hence, why a comparison between these two languages makes more sense than most other two languages.
Cyclomatic complexity isn't some sort of physical law. It doesn't cover all sorts of things, like the fact that it's calculated using keywords in most languages, but in some of those languages exceptions are commonly used and provide a different path through the code that may not be visible though keywords and are not added in. See https://en.wikipedia.org/wiki/Cyclomatic_complexity for a discussion of the test cases needed (simply as a consequence, not baked into the definition). Make your own formula, convince people it's better or just use it yourself. Not sure what you want?
This is the correct answer.
I learned last week that when a Go repository adds a go.mod file that specifies the module path, it becomes possible to use a module proxy to easily figure out the canonical import path of said repository.
Embedding an interface is extremely useful to decorate instances of an interface with things like logging, metrics timers, caching etc.
The 1.xx version of Go allows the type to be omitted, so I'd expect Go 2.0 to retain the feature. https://play.golang.org/p/-fgrU-Ur2UU
Well sure, but a PR titled "gofmt" that's just `find . -name '*.go' | xargs gofmt -w` would be totally straightforward. Anyone arguing that Go code explicitly _shouldn't_ be gofmt'd is... well, I mean, I can't think of a better word than "wrong", that's just not how it's done.
Got it. So even the ampersand is not needed.
Wow, what a lesson! Thank you very much! I'm already trying to deploy these tips! You do not know how you helped me :)
I did not know these tips, I'll start reading immediately Thank you!
Use [pages](https://github.com/rivo/tview/wiki/Pages) and associated functions (\`ShowPage()\`) to switch between different components.
I don't use go fmt. I use vet and deps, but not fmt. If I have a variable JobId or WebApi, go fmt complains it should be JobID and WebAPI. If I use protobuf, it requires names like JobId and WebApi. Maybe if the Go people would be on the same page I would use it. As it is it's problematic. 
Learned to write unit tests for my http handlers. I love unit tests but was always hesitant in this strange land called Golang. Next is to figure out how to unit test expected time delays without actually waiting. 
Why?
I really like Chi, and I might do a follow-up video using it. I suspect testing might be simpler with Chi. My justification for using Gin isn't strong but it's simply that I like the look of the default Gin logs. Ultimately the router itself doesn't matter too much. All it does it provide an entry point to the platform logic. Use whatever you feel is more ergonomic.
Wait...are we not golinting anymore? 
Good job man. I enjoyed your book about using Ethereum with Golang, I will read this guide for sure since I am currently developing node js applications but want to get exposure to Golang :P
Will definitely give it a try and probably adopt it :) thank you very much for releasing this tool suite !
You're not the first to suggest using git hooks for something like this but I've never seen how to enforce this for a team. I don't need this as vim-go runs these for me when I save. ¯\\\_(ツ)\_/¯
We should have hooks like this, irrespective of language.
What makes you say that? My shop is made up of turbonerds who configure their own esoteric editors, and we all independently arrived at integrating goimports into our editors.
&gt; I don't like tools that tell me how to spell my variables. I'd like you introduce you to a guy named Uncle Bob.
People shouldn't be using git hooks for this kind of thing. It's way too late in the process to be catching code problems. Your editor should either fix the problem or give you immediate feedback.
On the other hand, you could try not caring about formatting unless it actually hinders your ability to understand the code. Because amazingly, humans can read code even if it's not formatted according to some rigid rules, and computers can too. So caring about formatting *when it doesn't actively hinder understanding* is just pointless.
Running fmt is a convention that is universal across Go codebases. Personally, I think it is good to be consistent rather than not using fmt just because you want to name your variables the way you want. And protobufs are specifically an exception. They have it documented on the site.
Why would you want that though? Takes away the strong typing you get with Go
It doesn't. The type is inferred by the compiler, from the map declaration. There's no loss of safety/strictness, just a reduction in typing.
in `logic.go` ``` if countBuy &gt; countSell { result = "Buy" } else if countSell &gt; countBuy { result = "Sell" } else if countSell == countBuy { result = "Draw" } else { result = "Error" fmt.Println("Api result noting working! Buy: ", countBuy, " Sell: ", countSell) } ``` It's better not to mix your output (var `result` in this case) with error. In Go it's idiomatic to return `error` as the last returned value. Also I think it's better if you provide constants for `Buy`, `Sell` and `Draw` In `bones.go` ``` Speed := Speed() apiresponse := APIResponseComplex{} qtyOrerFloat := convert.IntToString(hand()) ``` These variables have inconsistent naming It's better to have a logger package to handle logging output, and remove the check for `VerboseMode()` every time you need to log something
Hi, thank you for playing! Daigo, the scenario writer and the game designer, would be happy for your comment.
I've switched jobs 2 times so far, and every time I did, I got a huge raise. I thought it's just a personal matter. But reading your comments made me realize it's the same for us. I wonder if other people in other professions experience the same issue.
What do we know about things that might or might not happen in 10 or 20 years. Stop speculating about Go 2.0.
I do that, and yet doing things like using SetInputCapture on a per page basis it seems I have to manually manage that. I also hit issues where removing pages made the program completely unresponsive. That's why I was looking for others to compare to.
go fmt doesn't correct your spelling. 
I was initially puzzled why it was not legal to say x := &amp;5 to declare x as a pointer to an int and initialize it to 5. And I was expecting that x := &amp;MyStruct{ f1: "blah } would declare x as a pointer to MyStruct, etc. But you must actually say something like y := MyStruct{ f1: "blah" } x := &amp;y And the explanation I made up is that the allowed version does not have any hint of taking the address of a literal value. It seems possible that the disallowed (more "direct") declaration has a possible mis-reading of allocating pointers that all point to a single, shared location. Forcing this kind of thing into 2 declarations makes totally clear "we're allocating a new variable, and then taking the address of that new variable." Dunno for sure if that was the reasoning, but that's what I tell myself so that I don't get annoyed by it. (sorry if this is not relevant to the original post)
Thank you! 
Sorry to disappoint you, but this wasn't about Cyclomatic complexity. That's another complexity factor altogether. Been there too in the past, but it wasn't correct to begin with. Cognitive complexity is much more closer to human experience and yet, because of my sons question, I began to question that too.
Just use a good editor that will help you and guide you. Even give you hints in what to improve, and type-hinting. Than you will never have the "trap" where this is all about. Be professional and use something good. (and it doesn't have to cost money)
If a so called professional does this, you can ask yourself if the professional is really a pro. A pro would never do that, because his (configured) tools won't let him. Of course you can force tools on them, hooks, whatever, but they still can do it their way. How about : do it the company way, or leave?
Why would you do that on the client side and not just fail tests in the CI pipeline? If you can’t trust people to just do it in their editor why trust them to add the git hook?
x := &amp;5 why would you want this? 5 is a constant, but it needs to be stored in memory first. So this would work ``` nr := 5 x:= &amp;nr ``` you can only have a pointer when the pointer points to something that is stored into memory ``` y := MyStruct{ f1: "blah" } ``` does this.
Nice work Might be off topic, but I wonder how do you scan via them for possible vulnerabilities ?? Something I like about **bundler** in ruby which help these kinda auditing easy : *bundle outdated gives details on those old gems.* 
A lot of Go developers are fairly purist.. I mean one of the core devs on the language said that syntax highlighting was for children(or something along those lines).. So yeah
The router used by Gin is hopeless though. Its very simple and it can't be used for many patterns.
hmm... I think this falls under the "not everyone is like you" thing. Like you, I don't understand why the Kardashians are famous. But that's my problem, not theirs - they're very rich and successful, and they have a vast worldwide following of people who clearly get something (I have no idea what) from following them. I often refer to my "Kardashian problem" - that I don't understand the mass market well enough to launch a successful mass-market product. The vast majority of people are not like me, and I don't understand why they're like that. But again, my problem, not theirs. Same with tech choices. I know smart people who think Docker is the best thing since sliced bread. They're really happy with the technology, they understand it, know how to use it, and it gives them a perceived benefit. I don't get it. But that's my problem, not theirs. They're happy with their tech choices, while I'm the one slightly bemused as to why everyone likes this thing that just adds another layer of complexity and failure to the stack, as far as I can see. I could, like you, assume that they're all idiot sheep following the herd, and that if they thought about it properly, like I do, they wouldn't be like this. But that's not useful, because it's not going to happen. They do what they do for what appears to them to be good reasons. I need to understand that so I can relate to them. 
Mock the clock
You're right. You have to really fight it to get it working with single page applications
Both Puppeteer and chromedp work the same way: they launch chrome in headless mode and talk to it via dev tools protocol. The difference is that Puppeteer is up-to-date library actively maintained by Google and chromedp has pretty basic bugs that haven't been fixed in a year (https://github.com/chromedp/chromedp/issues/168). I haven't used it myself but for Go you can also try https://github.com/mafredri/cdp, which looks more actively maintained than chromedp 
Awesome, I will give a try to cdp! Thanks for your help!
Yes these are definitely good examples of using Go for IoT. We were a little cramped on the word count but yes these are great examples and warrant a detailed write up. We hope to be able to come up with something like that soon. Thanks for the womderful suggestion.
How are you sending the file? It sounds like you're maybe using the wrong protocol in your client. I tried your code and everything works using curl. Also what Go version are you using? With Go 1.12 sending plain HTTP request to a server that expects HTTPS should result in the server responding with a 400 Bad Request and the message "Client sent an HTTP request to an HTTPS server."
Golang 1.11, humm not receiving any error message. But I was using http in curl so that makes sense :D Thanks! 
Why do you need the map values to be a pointer? A value type would be more performant in the example you posted. If the value is nil then just don't set the key in the map. 
I just love traefik 
:[ What did most of the freelance work you saw consist of?
i was mistaken. I do use go fmt, not go lint.
Mostly Javascript and Node jobs. Which is fine I'm a Node dev but Go is a new language to me and I'd like to use it more. Even the projects which didn't care what language you wrote the bot in were more time efficient to bash out in node puppeteer &amp;#x200B;
I'd personally keep it all in one place. Another option you might consider is using an off-the-shelf solution, like Keycloak. The company I work at was considering rolling our own auth, and we came across Keyclock and it's actually really good. If you're learning, or need something Keycloak doesn't provide, or can't afford to run a JVM application, then by all means continue - in which case, as above, I'd put it in the user service and just keep it all in one place. Auth encompasses that user part. Quite often these kinds of services will handle authentication and authorisation, and it makes sense if you ask me. You don't need to have nano-services.
What are some better options from your perspective? I've not really looked too hard to see what else is out there recently (played with the likes of Drone and Concourse, both pretty good really, but neither perfect).
Not all of them: https://i.imgur.com/cEynmR7.png We're currently using gqlgen there (99designs'). You just return nil from a resolver, and you'll get null back.
Version in the URI, controlled by a proxy that points to a different application in the background.
&gt;Some of the conveniences I really like from gobuffalo that I’m sure you can get from other frameworks too, but not from net/http: I do not understand why you are comparing a library with a full blown framework.
Write a black-box test using the external package technique thing \`package mypackage\_test\` &amp;#x200B; Ask yourself &amp;#x200B; How easy was it to use my package? Is the test messy? \*Would the helper I'm thinking of make this test read better?\* &amp;#x200B; By taking this approach you can validate your idea with some real code that you can actually see working
Cool, I never saw https://github.com/golang/go/wiki/SuccessStories before. I like that.
When the struct is serialized, it will receive the xml tag "animal". [https://golang.org/pkg/encoding/xml/#Marshal](https://golang.org/pkg/encoding/xml/#Marshal)
Sorry, it’s explained in many places such as https://stackoverflow.com/questions/10858787/what-are-the-uses-for-tags-in-go.
https://stackoverflow.com/a/30889373/4871041
I recently switched to Go from Python and have had similar experiences. Project layout I'm still trying to get used to now that I've moved on from projects that are suitable for a monolithic file. Especially in the web app world where there are a lot of ingrained MVC philosophies, there seem to be a lot of differing opinions on how to lay out a Go web app. Static typing I've fully embraced. I hated it for two days but after the short adjustment period I find it's saving me a lot of time by thinking carefully about types ahead of time instead of after something breaks. Concurrency problems are what made me decide to start using Go to begin with. After wrestling for literally weeks with asyncio and Twisted in Python, it took me a few hours to solve the problem in Go with no prior knowledge of the language. JSON becomes a huge pain in the ass when you're working with nested JSON you don't control. Like reverse-engineering a client for an undocumented API. That was really difficult to make it through. I got frustrated and threw every best practice out of the window by just using a bunch of interfaces and declaring the type upon accessing the struct. [This article](https://eagain.net/articles/go-dynamic-json/) really helped me tune my approach to handling JSON in an environment where I don't control the source. And oddly counter to what is supposed to be the case, I find Go more readable than Python.
That is not what I meant ;) gqlgen does not distinguish between null and the variable not being there in a mutation. Both of them return nil which is wrong.
Matt Holt's JSON to Go page is great for quickly making a deeply nested struct for some JSON. https://mholt.github.io/json-to-go/
My STL package has helpers in addition to funcs that handle general io.Reader/io.Writer. Maybe it'll be something you can work from for your package: https://gitlab.com/russoj88/stl I found the test package system a very useful exercise. An added benefit is example code for end users.
[removed]
Because it doesn’t know whether you want to init a slice or an array. Slice being []int{} and array being [...]int{}. While you have to specify int because it doesn’t know whether you want to use byte, int, uint, int64 or some other similar type. That’s the main difference between statically and dynamically typed languages - you have to tell the type explicitly.
The problem with the distributed services is that you loose the convenience from combining information at the database level and also somewhat transaction safety, unless you manage to develop an overall saga for transaction management. However, this often leads to a better separation of the services and if you actually get performance problems, there are multiple options to build up caches to improve query performance. Another option is to use a CQRS pattern ([https://martinfowler.com/bliki/CQRS.html](https://martinfowler.com/bliki/CQRS.html)) where writing and reading is implementend in separate services. You might even have an additional service with an aggregated copy of the data to allow for fast queries spanning multiple domains. 
Very good resources!
I don't know a standardized spec of cognitive complexity, as far as I'm aware, it's just Sonar? - https://www.sonarsource.com/docs/CognitiveComplexity.pdf It doesn't differ too much from the base of cyclomatic complexity, and the base of your argument is still the same - that it ignores serial code length. You can make a good argument that long functions are harder to maintain. You could add extra points for variables that are defined a certain number of lines above their last usage, or nested blocks that extend beyond a certain number of lines from their condition / loop etc. Still trying to understand what your goal is? You want random programmers on the internet to agree that an intentionally simplistic measure could be more representative? Ultimately, I'd say it's often used to point to code that's more likely to be problematic, so you could ditch the definitions overall and just train an AI to identify areas most likely to give rise to bugs: https://variety.com/2019/gaming/news/ubisoft-and-mozilla-announce-clever-commit-1203137446/ 
It's called a struct tag - it's basically almost like a comment (but not a comment), which go code can read using reflection and do \*things\* with. In this case, it tells the xml package that this field in the struct should be serialized into xml as &lt;animal&gt;&lt;/animal&gt; (instead of &lt;Animals&gt;&lt;/Animals&gt;).
Better metrics and documentation of them. The Traefik metrics were really lacking compared to some things like the linkerd endpoint telemetry.
Very useful list!
Holy moly, could you not have shared this like 2 days ago? Hahaha
I forgot to mention that you could even do testable examples and then they'll appear in go doc https://blog.golang.org/examples
The real reason is that the operand (constant expression) `5` to `&amp;` (unary = take address) is not [addressable](https://golang.org/ref/spec#Address_operators). &gt; The operand must be addressable, that is, either a variable, pointer indirection, or slice indexing operation; or a field selector of an addressable struct operand; or an array indexing operation of an addressable array. As an exception to the addressability requirement, x may also be a (possibly parenthesized) composite literal. 
Thanks! So right now we don't. The scanning part would probably be outside of Prometheus. Although you could expose outdated package version to Prometheus and cross correlate. I think no one is actually doing scanning now as `debug.ReadBuildInfo` API was exposed in https://blog.golang.org/go1.12, which was just released. That said there might be some solutions that look at your go.mod file 
&gt; reduction in typing *Keyboard* typing.
I always separate out authentication from the user service. But you can really do it however you want. Just like a monolith is much easier to deal with, it’s also easier to just cram authentication in with the user service. 
It could also be of type `struct{a,b,c,d,e int}`. Just because this looks like an int array to you does not mean it looks like an int array to everybody.
https://github.com/strukturag/spreed-webrtc is a very advanced all-in-one server that has been out for several years now.
Yes. Go is strictly no-nonsense. If it is hard to generate the input to your functions you should have code to do this.
&gt; But that's my problem, not theirs Yes and no: The way I see it is like managing bad bacteria in your body. They're always there and you can never get rid of 100% of them. But that does not mean that your body should not manage it. When you have too much of Kardashians effect who numb people about you do not need to have a hard working life to be successful, you'll get a President like Trump. And guess what, now that IS your problem. Because it directly affects your life. The same is happening in tech. When the herd chooses a technology based on which one of their 'rockstar' developers tweeted it, when it gets big enough and out of control, then something which is not technologically superior but has a better hype machine becomes the de facto, it dominates the job market, it dries up the chance of other small libraries and frameworks to grow a community. And guess what, now that IS your problem. You will have to learn it, because that's how you can make money. As an example, here is a small Javascript library that handles both client side and server side rendering without requiring Node, it is small and it requires a lot less memory than React based libraries, which means more mobile engagement: https://melody.js.org/ . I bet &gt; 99% of the community here never heard of that.
Ha! I totally missed the ambiguity. Thank you!
Have you found a work-around for this issue? We just had this manifest in one of our production systems.
Is there a special 'NotFoundHandler'? Other frameworks have sth. like that. It's triggered on every 404.
If the question is really about Go, I'd say you may look at &lt;https://restic.net/&gt;
It's farther down in that page: app.ErrorHandlers[422] = func(status int, err error, c buffalo.Context) error { res := c.Response() res.WriteHeader(422) res.Write([]byte(fmt.Sprintf("Oops!! There was an error %s", err.Error()))) return nil } Except you want to handle 404's and not 422's. 
Yeah tried it. I get the `Oops!! There was an error %s` displaying fine. The problem is changing that to render a 404.html custom page instead.
Did you get some sort of error when doing the Render call or it just render's nothing?
Renders a blank page.
Just read the error... if there’s another program that is editing .profile, save and close it or continue from there. Otherwise just delete the swap file and edit .profile. If you’re not used to vim maybe it would be better to use another editor.
This is a vim thing. When you open a file with vim, a buffer file is created (/var/tmp/.profile.swp here). If the vim process ends unexpectedly, like if you just close your terminal without exiting vim, or if the file is still open in another terminal, then you will see this error. To fix it: &amp;#x200B; \- Check to see that you are not editing this file in vim in another terminal window \- Make a backup of the existing .profile file -&gt; .profile.bak \- Open the file in vim again \- Hit the (R) key as indicated to recover the changes \- Write and quit :wq \- See the differences between the files (can be done visually in the editor, but this way doesn't miss anything: diff .profile .profile.bak \- Delete the swap file /var/tmp/.profile \- If you are happy with the changes, remove .profile.bak \- If you are not, remove the .profile file and restore .profile.bak -&gt; .profile \- Vim should work smoothly again &amp;#x200B; Note: this procedure works for any file. If you are sure that you don't need the changes, then you can usually just delete the swap file and move on. Be very careful with things like .profile, .bashrc, .ssh/config, and other dotfiles that have the potential to lock you out of your system or otherwise nerf your environment. &amp;#x200B; &lt;&lt; Insert Spiderman Uncle Ben speech here &gt;&gt; 
I'm not that familiar with Buffalo, so I'm not sure if that context doesn't render if it's coming back from an error state. You can try it like the example does with explicitly loading the html file and writing it to the response. 
This has nothing to do with Go I think. This is just Vim saying that you have a swap file of .profile which means either that you have another vim with this file open or that you did not close vim properly last time that this file was opened. I would press R for Recover then save this to a different file with ":w filename" and then close with ":q!" so that you can compare. I am also not sure why you have a .profile in /usr/local/go/bin. Shouldn't this be in your home folder?
&gt; explicitly loading the html file and writing it to the response This is what I was looking for. Do you know where I can see examples of this being done? How do I write this: `return c.Render(404, r.HTML("404.html"))` to the Response?
Thanks! Filters look interesting, I'll have to look into them more. &gt; Pro: A computer can do it, so a computer should do it, and not just order the human around. &gt; &gt; Con: A computer is bloody stubborn about doing it always. Sorry, I don't follow how these are pros/cons of filters vs commit hooks. Commit hooks are performed by the computer too. Do you mean how commit hooks can be skip with --no-verify? Or maybe that hooks tend to just check for proper formatting rather than automatically rewriting them? &gt; Working with people who don't gofmt is more painful (you end up disabling the option in repository-local config; looking at you go.git) Do you mean the main Go repository? If so, I'm curious what you find painful about it. It's important that tools correctly handle non-formatted and invalid Go source files, so there are a bunch of those in the test and testdata directories. But regular Go source files should use standard gofmt formatting.
 res := c.Response() b, err := ioutil.ReadFile("404.html") // TODO: Check the error res.WriteHeader(404) res.Write(b) The path for the 404.html might need to be specified. Also, with the render call you have there, you might be getting an error back that's preventing it from being rendered and I think it might get swallowed. 
&gt; So caring about formatting when it doesn't actively hinder understanding is just pointless. Irregularly formatted code is very distracting. It also leads to misunderstanding of code; e.g., the famous "goto fail" bug. If your position is that people shouldn't care about formatting, then the simpler solution is that people should just embrace the standard formatting conventions.
I'll try it thanks and get back to you.
Sometimes vim/vi will leave remnants of swaps if the terminal is closed, so swap is left with probably latest changes. You can exit and do a "vimdiff" between the two files and see the differences, you can then merge them together and then either remove the swap by doing "rm" or confirming here to "D" delete or you can even "R"-cover it. 
I'm not sure it is a good idea to suggest that Node-&gt;Go developers imitate Nodes promises / async / await in Go. Sure it works short-term on single person projects, but it will lead to a lot of impedance long-term or with teams that use idiomatic go.
Need code.
So it's a standalone VM to run WASM? What's the use case for something like this? It's like XULRunner but for machine code? That kind of sidesteps the point of using a compiled language to begin with does it not?
TCP support? This changes everything!
ermahgerd thank you
It's unclear where you want to store the files. I assume in some online service. For me, the biggest factor is the price. I have a list comparing different services for storage and bandwidth price (https://blog.kowalczyk.info/article/f3dfcf36fb46412980b8efa4336c0ea5/online-storage-comparison.html). Personally, I use Digital Ocean spaces, BackBlaze is also good. S3, Google Cloud Storage and Azure are also great, but they charge a lot for bandwidth so not great if you download the files a lot. As far as encryption, they all have strong policies of not looking at peoples files so my first thought is that you shouldn't worry about it. If you do want to encrypt, you should do it yourself. I simplify but you can treat all well-known encryption algorithms as equally secure. Similarly, CPU and memory use are also not a factor and depend more on how much effort someone put into optimizing the implementation than the properties of the algorithm. Again, I simplify. Go with something well known, like AES, which is implemented in standard library (https://www.programming-books.io/essential/go/474ffe54eb92473b908b5ef162789cad-encryption-and-decryption-with-aes-gcm for an example of how to encrypt / decrypt files).
updated with code
Have you seen the go generator from https://app.quicktype.io/?
I've discovered this issue which is for v1.11 but it is exactly what I'm seeing (I'm using v1.12.1) [https://github.com/golang/go/issues/26382](https://github.com/golang/go/issues/26382)
I'd keep them separate, as they're handling different use cases. The User service handles containing information about your user, possibly settings as well? Whereas the Auth service handles giving someone access to your platform. The Auth service can refer to the same User by ID of course. It's just more future-proof if you keep separate use cases apart from each other. Per the SOLID principle (https://stackify.com/solid-design-principles/) --&gt; Single Responsibility Principle
Great article. As someone who's been developing for a long time, I recently switched my process up last year. I've done everything from C, to Python, to Ruby, to Java, PHP, JavaScript and so fourth. I usually gravitated to the "beauty" languages such as Ruby and Python in my day to day, but the past two years made me move into JavaScript/Node to support a lot of frontend systems. Typescript, ultimately is what lead me to Go. Typescript is something I've been using daily for two years now and the benefits of typing and knowing to expect around your code grew on me, and I wanted this for the backend as well, but I wanted something with a good balance of readability, and sanity.. which lead me to Go. Now, I can't imagine using a language without such features to help produce clean, typo/error-free code. The ability to compile Go to support different platforms easily is also great, deploying a single binary somewhere is easy. There seems to be a great set of features coming from 2.0 as well. As a fellow noob to Go, the only issue I have is the lack of vendored dependencies. Dep seems to globally pull in a dependency, I worry this will be an issue if we build a tool and some other developer on the team has a clash with a dependency being too new? Is there any guides on this? I know vgo is in the works as well..
I assume from the way you have your imports listed that you decided to use a go.mod rather than vendoring the dependency for subpub? You have to do one or the other for the cloud function environment to find them, you can't just do an import and expect it to work. [https://cloud.google.com/functions/docs/writing/specifying-dependencies-go](https://cloud.google.com/functions/docs/writing/specifying-dependencies-go)
I assume the point is to run untrusted code in a Go backend without having to worry about isolation. For example, you could conceivably implement a serverless platform based on WebAssembly, where ~arbitrarily many users can be colocated in the same process (thus saving resources).
Thanks for your complete response. All the files will be stored in private (I own them physically) servers.
that's a fair point, will make sure to update the examples to make them idiomatic go
Issue #10 was finally tackled! Yaaaaasssssssss!!!!!!!!!!!! Also, TCP + HTTP + SNI all on the same port hurts my brain to think about.
yes, I thought in that when I saw this repo.
Have you considered encrypting storage at the OS level as opposed to re-inventing the wheel? Encrypt the storage volume of your choice and then you can structure your data however best makes sense for your application without having to worry about attempting to implement encryption with appropriate levels of safety and performance. 
So this looks really cool! But the documentation mentions the library sometimes panics. What are some cases where that might happen?
Disclaimer: I only skimmed the article. I agree docker compose is a super useful tool for integration testing, and allows incredible flexibility in setting up an integration test environment. I balk at it having anything to do with Go or any other language, however, since the very idea of an integration test supposed integration between a two or more “black boxes” - the language in which any given component of the system is written should be irrelevant. 
I need to send back to the client the encrypted file, and each file may have a different encryption key. I also need to change the encryption key from time to time, programmatically. I am not aware of any os-level encryption that offers this kind of control.
The code above will use loads amounts of memory, you'll want to use io.Copy to a file instead directly, instead of a buffer. io.Copy will do the buffering by itself. this will stream the upload to file using minimal memory. If you want to provide a buffer yourself, use io.CopyBuffer. ioutil.WriteFile should only be used for small files I'd say.
You can use net/http standard library to deal with the cookies, [see here](https://golang.org/pkg/net/http/#SetCookie). Your middleware can then pull it out with [this](https://golang.org/pkg/net/http/#Request.Cookie). 
I’m using the net/http library to set cookies on the response but they’re not being sent back. I’m using http.SetCookie. After reading a few articles I’m thinking maybe to use Auth0? Instead of reinventing the wheel 
After reading your comment down below I guess I have a couple questions. You state the customer will be able to change the key. How is the customer sending you files? Are they being uploaded to a website? And you want encryption on the backend. Or is the customer using some other client that you are supplying them with. Last question is with encryption who are you protecting the data from. This will greatly change the answer. &amp;#x200B; If the customer is making is so you can't see the data then you need to a solution where you do not keep the keys. This can be done with pre internet encryption where you never have the key, and the file is transfered to you encrypted. This should also be done with a security appliance as well. We implemented the vormetric solution but it is expensive. &amp;#x200B; If the idea is not hiding the data from you then the solution becomes much easier because you can hold the keys. Any encryption standard could be used that is secure of course. 
If they are not being sent back, then it's not really a go issue. Could be some security setting or domain of the cookie is invalid. If you're making calls via Javascript in the browser, some client libraries have setting that you have to turn on for the cookies to be sent with requests. You can see all that in the network tab of the chrome debugger (presumably other browser dev tools too). I've never used Auth0, but using some one else's verified implementation of authentication is probably not a bad idea, there are lots of ways to screw it up doing it yourself. 
Is anyone using KSQL with golang? I'm interested in seeing how it works.
Oh-- it makes more sense to me now. Thanks for replying.
I needed to encrypt large files in a way that didn't require loading the whole thing into memory. I used AES-CTR + SHA512 HMAC. If Go supported a streaming GCM encryption I would have used that instead. (https://github.com/Xeoncross/go-aesctr-with-hmac) There is also the DARE project https://github.com/minio/sio which handles streaming encryption.
I have now. Thanks.
Personally I often find needing to distinguish between not supplied and nil a bit of a code smell in mutation design. That said, there is a [lot of discussion here](https://github.com/99designs/gqlgen/issues/505) and this is planned to be addressed at some point.
Could you store it in a database? MySQL can handle large binaries if you set the table up right. Could have a field for storing the keys etc, too
Yes, but ISOBMFF muxer is pure Go though :P
Can you share the part where you set it? I just did the same with chi and it works fine. I’d try to get it to work instead of using authy which is maybe even more complicated.
About the same as that, except Python had been my weapon of choice for 15+ years. I've more or less ditched it for Go now. I waited for nearly 10 years for them to fix Python 3, but they never did. So now I use Go instead. Its standard library is much better (more modern), I don't have to dick about with virtualenvs, it's profoundly faster than Python (especially because it supports real parallelism), and generally fits [the Zen of Python](https://www.python.org/dev/peps/pep-0020/#id3) better than Python does these days. Surrogate escapes, FFS. They're worse than the problem they were supposed to solve. Py3 is a shitshow.
I'm relatively new as well, but I've had great success at my work with [Go Modules](https://github.com/golang/go/wiki/Modules) for dependency management without vendoring dependencies. Cached dependencies are tied to the version and a calculated hash so to guarantee everyone is using the same version, while not having to re-download copies of dependencies used by multiple projects. It's also made updating to the latest tagged release, pinning to a specific commit, or overriding the dependency with a local version very easy. And downloading all the necessary dependencies happens when I run `go build` so there's no extra step or error message if I don't already have the correct dependency downloaded. Relevant Just for Func videos: https://www.youtube.com/watch?v=aeF3l-zmPsY https://www.youtube.com/watch?v=H_4eRD8aegk
&gt; there seem to be a lot of differing opinions on how to lay out a Go web app. They're all good, tbh. In Python, the structure is largely imposed by the framework you're using, and web frameworks aren't really a thing in Go. I don't buy the common "just use the standard library" line, though. People who say that aren't writing complete webapps, they're writing backend apps that spit out JSON, making cookies, sessions, forms etc. a frontend problem. &gt; After wrestling for literally weeks with asyncio and Twisted Both overly complex and poorly documented. Even then, async IO is only useful for some very specific use cases. Goroutines shit all over async IO, especially because Go doesn't have a GIL and can do real parallelism. &gt; And oddly counter to what is supposed to be the case, I find Go more readable than Python To be fair, Python is a lot more complex a language than Go. Python has always encouraged you to write readable code, but its "we're all grown-ups here" attitude leaves a lot of latitude for non-grown-ups to do awful things. 
&gt; That’s the main difference between statically and dynamically typed languages - you have to tell the type explicitly. No, it is not. Some statically typed languages can infer the type. Go does that for some types. I was wondering if Go can do that for arrays too. For example, Scala can infer that `Array(1, 2, 3)` holds integers: scala&gt; val a1 = Array(1, 2, 3) a1: Array[Int] = Array(1, 2, 3) Or OCaml can infer the type of `[2; 1; 0]` as a list of ints. Or Haskell can automatically infer the type of list of numbers: let lostNumbers = [4,8,15,16,23,42] 
The question you're skating around is actually a design question: should you abstract away the details of your database? The answer is "of course!" When you pass your DB object as a parameter, you're [tightly coupling](https://stackoverflow.com/questions/2832017/what-is-the-difference-between-loose-coupling-and-tight-coupling-in-the-object-o/37993102) the code that's consuming the DB's data with the implementation of the DB itself. This is bad for a couple reasons: 1) you won't be able to unit-test the consumer code very easily and 2) you're stuck with the DB you started with... maybe even the schema you started with. When you implement accessor methods on top of your DB object (such as GetUsers), you're abstracting away the details necessary for getting that data, effectively decoupling the DB from the consumer code. Much better! Even better, decouple the data from the DB from the consumer code: implement a package that does nothing but model the data in your DB. Use that as the return value for your DB accessor functions. Now you're neither coupled to your DB's schema or implementation! Unit tests become much less fragile.
I can’t say for ocaml as not an expert of any sorts. But comparing Scala to Go is not correct at all. To understand why one needs to think HOW they are executed. Scala runs on JVM and is NOT a compiled language. It simply transpiles code to JVM code. And JVM knows everything about types it needs to operate with. Go on the other hand is compiled language. Which means it runs directly on CPU and code is being compiled into executable format (suitable for the current OS). CPU has no idea about all your types. All it knows is how to do operations on bytes. Hence the correct comparison pair should be with another compiled language such as C/C++ for example. And those languages do not allow such “assumptions” either.
Also remember one of Go’s fundamentals- “explicit better than implicit”
I think what it breaks down to is that if you have say a 1000 line function with no flow controls. Your function is simply mutating data with function calls. When your walking through the function, you dont have to think about what happened on line 100 when you're on line 900. That's because you only have to think about what your data looks like on line 900 because its already been mutated. Where as if you have flow controls, you now have to think about all the different paths your code can take.
I’m not sold on WASM. Seems awfully clunky from the code examples I worked thru.
This has nothing to do with the runtime environment, but the compiler and the syntax of the language. As you mentioned earlier, in Go it is not possible to just look at `{1, 2, 3, 4}` and infer if it is an array or a slice. In languages that `{1, 2, 3, 4}` can only mean one thing, be it an array, list, or something else, the compiler can infer its type. Also: http://www.scala-native.org/en/v0.3.8/
What do you mean by fixing python3? Can you explain more deeply? 
Why not rewrite it in rust for fearless concurrency and memory safety?
Is Linux malware common?
Oh man deeply nested JSON with unpredictable types is really challenging in Go. I found that JSON.rawmessage is a super life saver in those cases
Makes a lot of sense! I'm putting these tips together in my next commit! Thank you very much for the help and time dedicated! This is amazing!
One thing to consider is that methods are how types satisfy interfaces, so if the function you're considering making a method could conceivably be part of an interface used elsewhere in your program, that might be good signal that it makes sense.
I can't say I'm sold either but I'm trying to put together a small project to give it a shot. I think the appeal is the ability to use one language for both the client and server side. More than that though I've seen some interesting projects that use WASM as a way of delivering applications that can be run in isolation from the rest of the system. 
So instead of the RPCServer taking a storage implementation - have it take a interface that abstracts all that away. type MygRPCServer struct { store ItemStore } type ItemStore interface { GetItems() {} SetItem() {} GetItem() {} } type MySQLItemStore struct { db *sql.DB } func (m *MySQLItemStore) GetItems()/SetItem()/GetItem()/etc...
Much thanks for my future
I also noticed that the Zen of Python fit Go at least as well if not better than Python itself does. It was a funny realization as I have been a Python fanatic for years.
I am new to Go and appreciate every nugget of help and advice thrown at me. :) &gt; “explicit better than implicit” Well, GoLand advises to use `x := 1` instead of `var x int = 1`. :)
True, but GoLand is not made by Go developers (as in core team) so they can set whatever rules they want. 
If you're looking for a library, [secretbox](https://godoc.org/golang.org/x/crypto/nacl/secretbox) is the best answer (chunked to an appropriate size like 16kb mentioned in the docs). But I suspect you would be better served by a cloud storage service like S3 plus server-side encryption.
It would be true for all typed languages 
Use Waitgroup [https://nathanleclaire.com/blog/2014/02/15/how-to-wait-for-all-goroutines-to-finish-executing-before-continuing/](https://nathanleclaire.com/blog/2014/02/15/how-to-wait-for-all-goroutines-to-finish-executing-before-continuing/)
Make use of Channels or Waitgroup in Golang.
For this specified case, use `selext{}`: func main() { go httpServer("/path1", ":7070") go httpServer("/path2",":7171") select{} }
Would this be helpful [https://github.com/elgs/gojq](https://github.com/elgs/gojq)?
In which way you handle the creation of user. Do you handle it on auth service and then make synchronous call to User service or maybe asynchronous call using queue or pub/sub?
Same question here. How you handle the creation of the user? Do you handle it at first in your Auth service and then make synchronous/asynchronous call to User service or vise versa?
I don’t keep user into in the auto service; only their password and user id and maybe email if they authenticate that way. Usually tho, I use Facebook authentication so the user just hands me an opaque token that verifies if they’re a user, then I do an upsert on the user service. 
I'm using [scs session manager](https://github.com/alexedwards/scs) for managing cookies with chi
Now if only https would work on all network interfaces. Not just the one.
It includes language specific tokenization. Given the following text: `Hey you, what's up?` The slice should be: `[]string{"Hey", "you", "what's", "up"}`
GnuPG ?
Would I also use a WaitGroup for let's say one or two go routines I have to wait for? Or what would be the most idiomatic/smart way?
I try to think like this: If a function is not working with some mutable data - is a pure function, for the same input there will always be the same outcome - then it should not be a method, it should be a function. If a function is working with some mutable data - is not a pure function, for the same input you might get different outcomes because it depends on some state of information - then it should be a method attached to data (struct) that holds that immutable information. Of course, there are exceptions because sometimes you will make pure function a method just for design sake, to indicate that function is executed in the context of some data, even though it might not necessarily mutate it. And in the end, under the hood, a pure function with a pointer parameter is the same thing as a method attached to the same pointer. It really is just a code design choice. You can go for more functional (functions) or object-oriented (methods) approach.
If you want clean code, you can add shutdown functionality in your code. Don't run http.ListenAndServe right off the bat. Use a server object instead, as you can shut that down. As program closure, you can listen for the system shutdown calls and have that block your main thread until something externally asks your program to stop. Have a look here: https://medium.com/@kpbird/golang-gracefully-stop-application-23c2390bb212
&gt; P.S: is there a reddit chatroom for this subreddit? No, but there is a Slack group [1] with 37,941+ registered Go developers. [1] https://invite.slack.golangbridge.org/
Waitgroup are a good way, as is just letting one block, as others have said. But I think it’s worthwhile explaining why it’s happening. The main function is effectively the master goroutine. When it finishes, the program terminates. So if you spawn other goroutines, those don’t block anything. That means you need to block the main goroutine to keep the program running. A waitgroup will block until it’s released from other goroutines. A nil select just has it block forever, but it’s not necessarily the best. Channels are good depending what you want to do. I usually create a server and hold them in the main, then just start them (ListenAndServe) in the goroutine. I then watch for system signals, and then gracefully stop the http servers if that comes in. It’s just a cleaner way to deal with it overall. 
Citing the specification does not explain how the specification was chosen. The specification is the result of a design/decision process. The designers of the language could have made it do the confusing things that I tried, but decided not to.
You create a third service that handles the "creating a new user" use case. It calls both the User service and Auth service to init everything. I don't think you want a dependency between your User service and Auth service, as they have nothing to do with each other?
Sorry, not sure I follow your point. The language could have been made to handle y := &amp;MyStruct{ f1: "blah" } This obviously (to me) means "y is a pointer to a MyStruct. Allocate some space and initialize it with `f1: "blah"`, then set `y` to point to it." But the language designers did not do this. Why not?
Hope for fastCGI next.
Could you elaborate please? Lately I've been thinking about rust over go. Didn't know go had memory safety issues? 
\&gt; rust for fearless concurrency, memory safety maybe &amp;#x200B; productivity is the same like go 
`func (rs *Resource) signin(w http.ResponseWriter, r *http.Request) {` `ctx := r.Context()` `creds := &amp;credentials{}` `if err := render.Bind(r, creds); err != nil {` `log(r).WithField("email", creds.Email).Warn(err)` `render.Render(w, r, ErrInvalidRequest(err))` `return` `}` `// CHECK USER EXISTS GOES HERE` `//CHECK PASSWORD GOES HERE` `// Create a new random session token` `sessionToken := uuid.NewV4().String()` `// Store in redis` `_, err = cache.Do("SETEX", sessionToken, "120", creds.Email)` `if err != nil {` `w.WriteHeader(http.StatusInternalServerError)` `return` `}` `http.SetCookie(w, &amp;http.Cookie{` `Name: "session-token",` `Value: sessionToken,` `Expires: time.Now().Add(120 * time.Second),` `HttpOnly: false,` `})` `}`
Code above. I'm trying to figure this out for learning purposes but will be using the GOTH library I think after some research.
Thanks man, very useful!
Disclaimer: I'm working on restic. While restic is primarily a backup program, it can probably be used here. You'll also get the ability to fetch and decrypt data on demand by mounting the repo via fuse. Let me know if you have any questions, or head over to our (excellent!) community forum: https://forum.restic.net
A wait group is the right answer independently of the number of go routines. That said, if you only had one you could probably build a simpler mechanism using a channel of struct {} and closing the channel to signal completion. The moment you have two or more go routines it makes sense to use a wait group because waiting on a bunch of channels in a loop gets ugly pretty quickly. Check [this article](https://www.ardanlabs.com/blog/2017/10/the-behavior-of-channels.html) for a good description on using channels to communicate between go roiutines. The section called “Scenario 2 - Wait For Result” describes the mechanism I mentioned (using make(chan struct {}) has the advantage of making the smallest possible channel).
Yeah. Instead of just flipping a switch and making Unicode default, the core devs absolutely gutted Py3’s byte-handling capabilities. They’ve slowly added bits back, but not all of it. “All text is Unicode” is a lie. That isn’t the world we live in. Early versions of Py3 ignored things it couldn’t decode (e.g. `os.listdir()` didn’t return all files). Later they added surrogate escapes. So in the end, they replaced exploding bytestrings in Py2 with exploding Unicode strings in Py3. But at least `str` and `unicode` are different classes in Py2. Strings containing surrogate escapes aren’t marked at all in Py3. They just explode when you try to encode them. The solution is worse than the problem. Don’t get me wrong: Py3 is a much better language for apps, which was the stated goal. The devs of the framework you’re using have done all the nasty crap for you. But it kinda sucks for coding at IO boundaries and POSIX-y stuff (it’s all bytes, yo). Especially if you’re trying to write code that’s 2/3 compatible. Even in 2008, it was clear that “UTF-8 everywhere” was the right text model, but the Python devs didn’t just ignore that, they had Py3 default to ASCII for a further decade, meaning Py3 programs had a nasty tendency to die in flames when run via `cron` and pals.
Op, I don't think this is the right board to post this. unless you want to hire someone.
&gt;When you pass your DB object as a parameter, you're [tightly coupling](https://stackoverflow.com/questions/2832017/what-is-the-difference-between-loose-coupling-and-tight-coupling-in-the-object-o/37993102) the code Because you need to use interfaces not implementations. And there's no really difference between passing implementation by first parameter or hide it in object.
I can't speak for the designers but here's a thought; no constant is addressable (e.g. `s := &amp;"hello"` is equally illegal). In this case, the string `"hello"` would live in the binary's `.rodata` segment (in ELF speak) -- a memory segment that is readonly. If you then attempted to `*s = "goodbye"`, you'd get a segfault. Doing it in two steps makes a copy of `"hello"` on the heap (read/write memory) and gives you a pointer to that.
For example: awesome-go sorted by stars for each category https://gist.github.com/kvnxiao/cb432fca8cd9b59e325286b8f33cf53d
This post is generic ! Its about Golang Specialized company that we have. So the presence about golang can spread more and people who want to know more about golang or who want to hire go expert or people who want to work in this particular field will get some help.
Thanks for the great answer but I think I'm already doing that. `mydomain.DB` is actually an interface that gets implemented by another package. In my executable packages, when I initialize my gRPC server, I can decide wich `mydomain.DB` implementation to pass. This is what you were suggesting in the fourth paragraph if I'm not mistaken. I'm sorry if the post or the example weren't clear enough. I just took some code that I'm working on and stripped it down to the essentials for demonstration purposes because I thought that would make it clear enough what my doubt was without dumbing it down too much.
Can you make it even better?
Well, there's egg and bacon; egg sausage and bacon; egg and spam; egg bacon and spam; egg bacon sausage and spam; spam bacon sausage and spam; spam egg spam spam bacon and spam; spam sausage spam spam bacon spam tomato and spam;
So what you say it, that a function without flow control with just one line is equality complex for a human as a function with 1000 lines? I think I disagree with you. Imagine a simple function which would do some math calculations that adds, divides, multiplies each of the underlying functions work with the outcome of the previous. Then you have to know the function and the order the understand why the outcome is what it is.moving one line up or down can bring a totally different outcome. This is just 3 lines... imagine what a 1000 line function would do to a human brain ;-) I think my son has a good point. he even brought up that the number of var's going into a function, or going out can make stuff more complex. And since he's a beginning developer, I love him for this insights what I've lost over the years. His brain is probably more human than mine :-) 
GPG is a proven solution. If you can solve the key distribution and want Go, then Keybase's saltpack.org (https://github.com/keybase/saltpack) is a great modern solution.
i was looking for idiomatic go code, to make my code more idiomatic. Thank you man.
Tanks !
Do you know if you ever get any errors here during Do or ReadAll? if so the Body is never closed. Consider doing `defer res.Body.Close()` right before the ReadAll operation. You also have an infite loop going on inside the go routine (so that's 500 go routines with infinite connection http request calls), was that on purpose?
Using interfaces for just testing can lead to "interfaceitus", where everting is an interface and you have no idea what code you're actually running any more. Instead use the `httptest` package to mock out the real service. The article already mentions that in the third section, but you can use it to test external services just as well as testing your own handlers. The same applies to other external dependencies, by the way, not just HTTP APIs. Also the errors used in this article are not very good. `Expected: %s, Received: %s` can make it hard to see what's different as it's not aligned, and trailing/leading/non-printable characters won't show up. `if err != nil { t.Fatal("runMethod failed") }` is just worthless. To shamelessly promote my own website: [Go testing style guide](https://arp242.net/weblog/go-testing-style.html) and [Testing isn’t everything](https://arp242.net/weblog/testing.html). I should probably write another one about interfaceitus and how to avoid it.
For real this was one of my the side project idea I have in my to do list lol. Great job, this def helps
The whole program will terminate in any error scenario, that's why I used \`log.Fatal()\`. Yep, the intent is to let the code run indefinitely to test if \`MaxConnsPerHost\` really works under long heavy load.
You should read this particular section of this excellent guide by [https://dave.cheney.net/practical-go/presentations/qcon-china.html#\_never\_start\_a\_goroutine\_without\_knowning\_when\_it\_will\_stop](https://dave.cheney.net/practical-go/presentations/qcon-china.html#_never_start_a_goroutine_without_knowning_when_it_will_stop)
Expected quality form this company: The same as the quality of spelling the programming language name. Reporting as spam.
If I may ask something related in the thread: I was looking for a low maintenance low setup simple solution to the problem of getting some events/logs from my coworker's computer as he executes my Go app (its a server but in desktop mode, lets say). I even contemplated sending something via email (mailgun). I'm trying [https://bugsnag.com](https://bugsnag.com/) but wonder if there is anything else? Maybe log to a file and send via email every hour/day ?
Oh great! I just needed to add GO111MODULE to my env vars, seems to be working well.
Swift and Rust are looking great...
That defer would be useless, because the code is running in a loop. Deferred statements execute after a function completes, but a infinite loop won't complete, so it just queues thousands of defers, but never executes them
sync.WaitGroup generally
This is a neat project. &gt;In practice, the message latency would be around 20s to 40s, depending on security parameters and the number of users connected to the system. To clarify, "message latency" means 40 seconds transit time for a single message? Is this partly to obscure calculating distances between users? 
ಠ_ಠ
Traditional viruses, not really. Without all the special magic exceptions, Linux doesn't have nearly the places to hide code, and weird bugs that Windows has. For a while, there were a lot of network worms (about 2003), but none as annoying as, say, Slammer or Nimda or Code Red. &amp;#x200B; Due to the use of Linux to host WordPress installations, there's an [unbelievable amount of PHP malware](https://github.com/bediger4000/php-malware-analysis) that kind of relies on Linux - a small amount of PHP malware knows about file path separators (/ vs \\), but most just assumes its run on Linux. Perl IRC bots usually run on Linux, too. They can be problematic, even thought they're usually insanely buggy.
Thanks for the comments. I have noticed that using interfaces for these kinds of dependencies has many advantages. For eg, if we switch the external service, for eg, a payment gateway, the switch can happen easily without changing the design. The idea is that if methods accepts interfaces instead of say struct values, it makes the code more testable. http request was only an example. I agree about the error part, I usually use the testify assertions, and didnt want to use that for the article. I will remove that. Cool website. Will definitely take a look.
I totally “didn’t” setup a key logger that counted the number of times my coworker used the return key; and then had the computer say “Moo”, and reset its counter to a new random number.
Don't "go" the second call to httpServer. 
With all due respect Go is the worst imaginable choice for WASM, any garbage collected languages are horrible because it has to compile the whole garbage collector to WASM too. The ONLY choice for WASM is Rust + this https://rustwasm.github.io/2018/09/26/announcing-web-sys.html
The language is called Go. There is a standard library package called `log`. I suggest reading some beginner tutorials on writing webapps in Go, using the standard library. Avoid frameworks until you have a concrete need for one.
Just be careful that `mydomain.DB` doesn't leak out implementation details. For example, returning `sql` package error types or transactions. One tip I've learned over time: implement a functional fake for your DB package early, for example using in-memory maps as the backing datastore. This lets you implement working tests for other packages that use the DB package much more easily.
This is very helpful.
You are probably looking for middleware or something like it. [Examples for gin](https://sosedoff.com/2014/12/21/gin-middleware.html)
So helpful!
Go is not an intrinsically memory safe language. If you follow it's idioms carefully and well, it'll tend to guide you in a safer direction than older languages, but it's only a tendency, not a compiler-given iron-clad guarantee. Nothing stops you from writing your code entirely in terms of locks, and getting into every bit as much trouble as you would have in 1990s-era C++.
&gt;github.com/vuvuze... \`40s\` is a very long time 
[removed]
I'm the author of the repository, sorry for posting a non-English documented repository, but the name of the methods should tell what it does, I think it's somehow readable. The library helps you to modify the colors easily like Lighten, Darken, Grayscale... things I copied from Sass. You can also use the \`Foreground\` to get the text color based on the background color.
[removed]
That’s pretty cool. I like the fonts. 
Check the source code of collection.go, all the operations actually check/verify/create a session and use this session for corresponding operation. So, it is handled implicitly if reusing collection variable. You also can mange them yourself.
Likely because you’re using HTTP/1.1. Add SSL to automatically get HTTP/2 with much better connection pooling. There are ways to enable h2 without SSL but I’m not sure how. While I don’t know for sure, it’s likely that there’s some issue when using the older HTTP/1.1 protocol that doesn’t obey the connection pooling settings under high load. 
Maybe you've run into https://github.com/golang/go/issues/29889
[removed]
A struct here isn’t a constant where the other examples you gave are. You also cannot do &amp;map[..]foo either. 
They're not really comparable by default, though, as the Go one implements a custom marshaler and includes the calling code. Set the Go option "Plain types only" and it's as easy as the Swift code. On the other hand, look at the Java or JavaScript code...
Seems so trivial while you write that. But you're right. That's something that wasn't in my mind. I'll go and search for this kind of library. Thanks for your input.
It's better to set httponly to true for session cookies. Do you make this request with Ajax? And if you check the headers you get back from the request in the network tab? What if you first make sure that it's set for a week to see if it is something with the date?
The implementation for detecting categories is a bit wonky at the moment and can be improved upon. Anything else you meant by "better"?
It's great that they've finally put out a blog post about this! :)
Great work! We really need to get these lists to run this fairly often. I basically have to command+click every link to see which projects are established. Maybe you could add some other "life pulse" numbers also? - Stars (check) - Last Commit / Archived? - Contributor Count (Is this Iris?) 
That sounds like an interesting addition that I can implement. The only thing is I'd like to avoid making things too noisy with all the extra meta info.
Pick a project and work on it :-)
Is that example supposed to be accurate of a recent run? I noticed it reports the Buffalo web framework as 0 stars. Didn't think that could be right and I looked it up as having over 4100 stars. 
One topic that I rarely see covered in blog posts about modules is managing multiple "submodules" within the same source repository. A large codebase typically has many packages, and it may be prudent to turn some (or all) of those packages into their own modules and version them independently. But modules rely on commit tags for versioning, and commit tags are per-repo, not per-package. So how do you assign separate version tags to each submodule? The only document I found that discusses this is [this one](https://github.com/go-modules-by-example/index/blob/master/009_submodules/README.md) from "Go modules By example," which says that you can use `path/to/submodule/v1.2.3` as your tag name. That's great, but it's strange to me that this feature isn't mentioned more often. I imagine it will come up a lot as larger projects start migrating to modules.
I would assume starts + contributor count would be the most important. Since this is HTML, there could be a hover with more information using `&lt;abbr&gt;`, a full tooltip, or a simple `title="..."` attribute.
I wonder, when using modules, what happened to the go install command? Does it still work the same way? Does it still have a use case, especially when you don't have a GOPATH set?
One thing I don't understand is: If I want to distribute my module called "mymodule" do I have to host a web server which serves the files of a git repository on the path "myurl.com/mymodule" to make it "go gettable" ? 
I prefer to not work in my $GOPATH, so go modules were much appreciated for that fact alone.
The limitation is that this currently only supports processing the markdown file for the links. This means that it's expecting a github.io or a github.com link, and not a unique website of its own. Buffalo links to its own website without any reference to the github repo in the markdown file.
Are you new to programming as well? 
First do the tour: https://tour.golang.org/ Second, read Effective Go: https://golang.org/doc/effective_go.html Third, reference this often to avoid common “mistakes“: https://github.com/golang/go/wiki/CommitMessage 
If you want your own URL, yes. Otherwise, you can put it on GitHub or any other public repository and your module will be at github.com/yourname/mymodule or similar.
Nice post, thank you. It’s slightly misleading as you are benchmarking byte slices not byte arrays: would be interested to see if a byte array changes performance.
I don't want it to be public. I hope go command knows basic authentication ..
It doesn’t yet. There’s ongoing discussion on that in an issue. On a phone right now, so I can’t look it up easil, but I’ll edit this later to include the issue link.
It probably slows things down arrays are passed by value and so copied.
But will be allocated on the stack and not the heap, so I think it would depend on the length of the array. You may be right, but still would be interesting.
Set to HTTP only cookies and the headers I get back are: 1. `Access-Control-Allow-Credentials: true` 2. `Access-Control-Allow-Origin: http://localhost:3000` 3. `Access-Control-Expose-Headers: Link` 4. `Content-Length: 0` 5. `Date: Wed, 20 Mar 2019 19:51:10 GMT` 6. `Vary: Origin` &amp;#x200B; Thats all as of yet. I've just set the expiry date to a week and still nothing -\_\_-
Just a thought. As my GO is a headless api will that block cookies being sent back to my Vue client which is on a different domain?
[removed]
It works pretty much like it always did. &gt; especially when you don't have a GOPATH set? That just means it uses the default value. `go env GOPATH`.
[removed]
I think now I'm low skill. I don't know how to understand " I'm ready or no"
Ye,I think that I'm new to programming.I have some experience with R, but it was need for study
If none of the work you need to do is blocking, then concurrency will never help you. Concurrency helps when there's things you need to wait for in the background, in which case you gain the time you would've spent waiting around. If everything in the program has to be done by the program itself, then concurrency can only hurt you. It's a fairly simple concept and I find it confusing that people try and push concurrency as this thing that is totally distinct from parallelism. Concurrency is only good when you know that you'll have to wait for someone else to do something In Parallel to you (not "concurrently"!).
Thank you, bro. I'm realyy grateful for your tips. Do you know maybe some good books with Go for beginners? If you know, can you write it it is possible) Again thanks for your help and sorry for my English)
Wow, that tag name convention is odd. After reading that linked discussion, I was able to find details in the official Go wiki: [https://github.com/golang/go/wiki/Modules#what-are-multi-module-repositories](https://github.com/golang/go/wiki/Modules#what-are-multi-module-repositories)
One option is to use a goproxy that can map import paths to modules. That way you can use modules like "[example.com/mymodule](https://example.com/mymodule)" which normally cannot exist ([example.com](https://example.com) is a reserved hostname). In that case you could do something like: `GOPROXY=myproxy.com:8080 go get example.com/mymodule`
Okay, hmm. Have you done something like rock, paper, scissor through a console interface? Shouldn't be too hard for a beginner, it was one of the first things I did when I started out. A calculator is a pretty standard thing as well but comes a little further on. To find out what project to do next think about something you want to learn more about and design a simple application for it. So say you made the rock paper scissor game, but it ran through the console so you wanna add an interface. Then that's the next project. Do this enough times and when you feel like you got a grasp of how the basic mechanics work you can broaden your scope and start with more interesting stuff.
I was always hoping there would be no dependency on any server. At work our git server gives really strange go import paths. So a long time ago I just decided have them in my GOPATH and get them that way. I was hoping go modules could understand URLs with the file scheme or something like that. I realize that’s not ideal for sharing code with people but I just writing tools for myself anyway. 
Ye I made like a calculator with basic functions) Rock, papaer,scissor game is a really good idea. Thank you for your advice. I will try) And I have a question.Is try to study with book usefull? Or for first, I need try to do something like rock,paper,scissor game myself without books or some tutorials like that?
You often learn best by doing but sometimes you can't figure out how to do stuff or you want to know how to to it better and for that books and such can help. I've read bits and pieces of a bunch of books as well as looked at tutorials and asked people Online. Try to do it by yourself first but if you get stuck or want to improve, well then you know what to do. 
“The Go Programming Language” by Alan Donavan and Brian Kernighan, is the best. It’s the only book that has been written and edited by people on the Go team at Google.
Ps. Got my last link wrong; updated. Here again for reference: https://github.com/golang/go/wiki/CodeReviewComments
Here is an example of a multimodule repository. https://github.com/sotah-inc/server/tree/master/app Yes it is self referential. Check the fn and ng directories.
&gt;ಠ\_ಠ Eh, the idea was just to see what he was doing wrong before he even complained by Whatapp. He's doing the React app and I'm writing the backend. Anyway, moved to EC2 now...
Hello! I recently wrote [https://github.com/golang/go/wiki/Modules#what-are-multi-module-repositories](https://github.com/golang/go/wiki/Modules#what-are-multi-module-repositories), which is a good place to get started. Please let me know if there's more we can add to it. I'll also be talking about this subject at [dotGo.eu](https://dotGo.eu) next week (which should find its way to youtube, I think?), FWIW.
I dont personaly work on go at work, it's mostly personal projects, but i would say go is good for networking batch operayions and cuncurrent computing. Plus the stl is good enouph to cover a lot of use cases with no external dependencies
Micro-services 
its pretty general purpose. anything you do with python you can do with go but it will execute faster and you made find static types make thing easier eventually. 
Github recently made free accounts able to have unlimited private repositories. If you don't want to use Github, I'd be surprised if it didn't work with, say, Gitlab. Assuming you have git itself configured properly for authentication, go get will work just fine.
Does it still have a use case? I imagine it's still handy when you want to install global binaries.
Go can be thought of as a modern version of C with better data structures, better types, automatic memory management and really great concurrency primitives. You can build anything with it, like C, but where the standard library really shines (as opposed to the language, per se) is network services. Think web APIs that emit JSON, for example.
I wrote a blog post on supporting custom Go module URLs with serverless AWS. https://www.andrewpage.me/infrastructure/2019/02/14/go-package-vanity-urls.html
I mean basic authentication has been around for 20 years, what's so hard in supporting it as an alternative, but suuuuurrrere let's wait a decade more.
I am not sure that array vs. slice makes a difference. For example, in this little program, `x` does not escape to the heap: func main() { x := make([]byte, 12) copy(x, "Hello world\n") os.Stdout.Write(x) } I assume size and how it's used is at least far more important for whether or not something escapes than array vs. slice.
As the developer for [http://github.com/chrislusf/seaweedfs](http://github.com/chrislusf/seaweedfs), I recommend you customize it and add an encrypt/decrypt layer. &amp;#x200B; Specifically, just encrypt/decrypt the file chunk when writing/reading. Your customization effort will be another layer of difficulty in addition to whatever encryption algorithm you choose.
This is pretty nice. &amp;#x200B; My only suggestion is to use 'ff' or 'flatfile' in place of 'ffp' in the tags just because other tags which describe how to encode or decode a field into/from a protocol are named after the protocol rather than the decoder. For example 'json', 'xml' and 'protobuf'. The same tags are read by multiple packages.
Can you expand on the executing faster part? I've always been told that Python can be pretty slow, but I've worked with it pretty extensively the past few months (do lotsa Django) and I've never had problems with it. Granted, my scope is very limited cuz I'm still a nub, but I'd love to hear about the detriments of a particular language like python. 
Good point. I hadn't given it a lot of thought before now. I think I'll change it to 'flatfile' to stick with the trend of the other encoding packages. Thanks for the feedback, I appreciate it.
The "see license" link is a 404. And I'm not sure the license is correct, anyway. The original gopher is licensed under the Creative Commons Attribution 3.0 license. Correct me if I am wrong, but some of those assets are the originals from Renee French, aren't they? They'd require attribution. Apart from the legal nonsense this is a cool project :)
I want to know what would happen in this scenario: I have a module that has multiple packages that use different dependencies. For example let’s say I have a library package that uses AWS and a command line utility package that uses Cobra. If someone else depends on my library, will they end up having my transitive dependencies affect them even if they don’t import the package that uses it? Again for example they import my library but not my command line utility. If they want to use Cobra are they going to be locked into my preferred version of Cobra?
computers are very very fast now, so even when a language makes some things 10x or 50x slower than it needs to be, it can still be instant. Also a lot of python libraries have fast implementations behind the scenes written in C. like alphago was written in python, but the neural net it was orchestrating was not, and that was doing the real computation. but performance can quickly become relevant, if you start dealing with larger amounts of data, more requests per second, or want a snappy command line tool, or need to render 100 frames per second, or your program runs on slower hardware like a cheap phone, etc. 
its great because if you point out anything you don’t like somebody tells you to shut the hell up.
[removed]
You could use a declarative style where rules can live in JSON. This is ideal for several reasons, including simplicity for those building/writing the customizations but primarily in that it doesn’t increase your exposure to additional security risks of running third-party code. It sounds like you want to allow a more complete level of customization, which means either a plug-in or embedded scripting language. With [Go plugins](https://golang.org/pkg/plugin/) you can (basically) have your main program load and call functions in other programs at runtime. Note that this is currently only supported on Linux and macOS. The last option that comes to mind is to embed a [scripting language](https://github.com/golang/go/wiki/Projects#virtual-machines-and-languages) into your program. Then, instead of someone providing a compiled plugin, they would provide the script that your program would execute.
Cool bro 
This answers the question. Thanks brochacho!
[removed]
Play stupid games, win stupid prices.
\&gt; There is a solution to every problem: simple, quick, and wrong &amp;#x200B; No need to be sarcastic about it, I assure you it's more complex than you think and there are solutions being developed.
Many people recommended to use Waitgroup. However it is a bad idea for this specified example. It is best to let the program exist when either of the two service goroutines returns. In other words, just letting the second service run in main goroutine is the best choice for this specified example.
Okey. Thank you again. I'm very glad that you helped me. I will try to do as you say. I can't normalle express my gratitude coz my English is bad) God Bless You &lt;3
thanks man.I'm really appreciate it)
How do you type with nubs?
cool. I really could not even imagine about books for Go. Thanks you &lt;3
Because I want it to be a binary. The link with the example code is my current fallback approach that is less desirable, but it works
Thanks for the suggestions. I haven't heard of go plugins, it sounds promising and I'll have to look into it. Not quite sure I'm following on your 2nd suggestion.
Is this same as npm install? 
With much difficulty 
I love using it for CLI tools via github.com/spf13/cobra, APIs (not with UIs) using Echo, and network services such as ospf testers, SCP replacements, etc due to its incredibly rich networking libraries within the standard library. 
[removed]
[removed]
Handlers. No.
[removed]
[removed]
/u/indxxxd after tinkering a bit, plugins seem like it will do the trick! thanks for pointing me in the right direction
When i see go, i think of the cloud and cloud native stuff. The best cloud computing projects are all written in go! Ease of use and concurrency!!
This is similar to https://gopherize.me/
No, I think it predates HTTP2 multiplexing. I always thought it was named ServeMux because it multiplexes many http.Handlers into one http.Server, chosing the handler based on the request URL it's mapped to.
I’ll help you troubleshoot this, but I have two questions: - What GTK package do I need to download and install to run your code? - Replace all the `foo, _ := bar()` with `foo, err := bar()` and print the errors
The important part: &gt; If more than 256 GiB of keystream is generated, or if the counter otherwise grows greater than 32 bits, the amd64 implementation will first generate incorrect output, and then cycle back to previously generated keystream. Repeated keystream bytes can lead to loss of confidentiality in encryption applications, or to predictability in CSPRNG applications. Your small hobbyist apps are probably not going to hit these conditions, but it is important to note at scale.
productivity is worse. Otherwise and their dog everyone would be writing servers in rust instead of Go.
productivity is worse. Otherwise everyone and their dog would be writing servers in rust instead of Go.
Too much fun. Thanks!
To be clear, in most scenarios, you should not make multi-module repositories. You should definitely not just make a module for each package. If a codebase worked well in GOPATH mode, it’s unlikely it needs to be broken up for modules. In particular, dependency management scales extremely well, as the go tool does not look at all your code every time it builds a portion, and as with proxies it can fetch just the go.mod file of dependencies it’s not building.
Where dem Generics at shun shun?
Amazon RDS for your Postgres, Ec2 for computing S3 for you asset/file storing Don‘t know if you can spawn a project with Beanstalk that has all those components. But I can watch when I‘m in the office
I wish this was in always like Rust has cargo. We need a very wide adoption. Anyone who remembers old hekad building way will know the pain :)
You don't know. It's just a leap of faith. That's all it is. When we are starting some new language, we cover basics and jump straight to the project to learn more. You will learn more when you are building projects. Just go for it. 
S3: large object storage, is you can store and serve large assets/files from it ECS/Fargate: on demand containers that you pay only for what you use. Lambda: servers functions that you only pay per call/CPU time. You will need to split up/change your application to fit into it but this can be the cheapest approach (has a free limit you might be able to stay under for smaller applications). API gateway: ingress to other services such as serving files from S3, ECS or Lambda. RDS: managed progress. EC2: a VPS, you pay for uptime, more expensive than the above for low usage as it does not matter how busy the node is, you pay for how long it is running. This is also the least managed and most flexible of the other services are not suitable. You might want to try [this tutorial](https://aws.amazon.com/getting-started/projects/build-serverless-web-app-lambda-apigateway-s3-dynamodb-cognito/) to introduce yourself to how you can build a serverless application.
It's not "better C" because it doesn't even compete in that realm. It competes in the realm along with languages like C#. 
They are based on the original artworks, so the license needs some improvements since this is derivative work. Added the note on readme for now and fixed the license link. I'll fix the license itself as soon as I'll now which one is fitting.
Try adding MaxIdleConnsPerHost (non zero - recommended 100) to your clients transport.
Well to be fair the community can get a bit toxic. That's common for languages with low barrier of entry (php, JS etc). Go shares this trait. Now that doesnt imply that language is bad by any stretch, but that also means that a lot of folk really lack humble attitude.
&gt; they both have entire frameworks dedicated to both. Great news I'll build a framework so I can ride my cat to work. That is literally what a spazoid you sound like parroting that people have built frameworks for a language so it must be a semi-rational choice for {X}. &gt; I hate people parroting the "use the right tool for the job!". I bet you do. I bet people are all like /u/Dispersia "Why are you using a language with GC to allocate billions of short-lived objects?" "Why are you shaving with a chainsaw?" "Why are you hammering screws into the wall?" I bet you'd answer "Because I can and you can't stop me." or "It's as good a tool as any". To some extent I buy the argument when people don't know better. It doesn't mean their solution is any less shitty, but if they are willing to admit it was because it was all they could do I'd be fine. That's not the same as advocating others do {X}. This is like the people that build emulators in PHP. Sure you can, but why the fuck would you? (people do) Someone made a browser JS powered VM that can run DOS games. Doesn't make it a good idea. Hey 1990's can I take your viruses and run them OS independently via browser? Sure
Exactly. A crucial thing to note is that `http.ServeMux` implements the `http.Handler` interface, and so it's possible to form "trees" of `http.ServeMux` instances—chained together through the `Handle` methods of each instance's parent node. That's why it's "server multiplexer". OTOH, multiplexing in HTTP 2 is about the possibility to maintain several logically distinct data channels in a single HTTP 2 physical network connection (HTTP 1 had a stab at the same target through it's "request pipelining" but I'm not sure this was ever used in production). 
This. Modules are units of distribution. If you're going to make multiple modules in one repository, that means you're going to distribute and version each of them separately right? Which means each of those should be in separate repositories so you can actually check them out separately.
Anyone can explain to me why in the blog, the first \`go test\` command get the \`[golang.org/x/text\`](https://golang.org/x/text`) package at this commit \`v0.0.0-20170915032832-14c0d48ead0c\`. Why doesn't it get the latest tag release of that package, which is 0.3.0?
?
So readability is not on the top 5 for them
&gt;If the struct you’re defining the method on is very large, copying it would be far too expensive than using a value receiver. I've never seen anyone comment on exactly how large the struct has to be in order for it to be "too expensive" to use a value receiver. Wondering people's thoughts about this.
I'd tend to think exactly in the opposite way. &amp;#x200B; In the context of file encryption, hobbyist apps will not bother doing something more complicated if a single function call does the job. 
DynamoDB now has on demand usage too.
Go is nice for command-line programs that you want to distribute to multiple machines with all the dependencies built in (as opposed to dealing with handling this sort of thing yourself with Python). For example, [ipic](https://github.com/drdrang/ipic) depends on Requests, which wasn't easily available without some sort of env-based baloney. I just wanted to drop a file into ~/bin, so I rewrote the program in Go. The new program compiles into a binary I can drop into ~/bin and copy over to my laptop's ~/bin as well. I'd also like to chime in to say that Go is a reasonable contender for a project if you require neither a native GUI\* nor (soft) real-time processing. \* for my purposes here, "run a web server that exposes a web UI on `localhost:8888`" doesn't count as a native GUI.
just when you think you know a language .. (I somehow missed the details of the go import path)
[Reposurgeon’s Excellent Journey and the Waning of Python](http://esr.ibiblio.org/?p=8161) describes the author's attempts to convert the entire [emacs](https://en.wikipedia.org/wiki/Emacs) repository to a modern version control system. The author does not have a common workload, but it does go into some of the problems with using Python for large CPU-bound problems that the global interpreter lock (GIL) is liable to sandbag.
Unless you are working with value types you are almost always better off passing a pointer. &amp;#x200B; Value-type include mathematical objects, tuples, etc. Even then it really depends on the application.
&gt; Value receivers are concurrency safe, while pointer receivers are not concurrency safe. I don't see how you can make this kind of statement. If the value receiver has pointer fields, the value receiver is not concurrency safe.
What is with all the garbage spam in this sub lately?
Does it have to be AWS? if you want to get something cheap then you could just use Digital Ocean or something where you can get a 5$ droplet that you can use for your small Go app. Then you can either use their postgres service for 15$/month or set up postgres on a droplet yourself to save some more $ &amp;#x200B; &amp;#x200B;
I’m sorry but this isn’t a job board and I really don’t think this sort of content belongs in this sub. 
Well, isn't it quite "simple"? If you need to modify the origin -&gt; pass by reference, if you don't -&gt; pass by value. If it's a "large" struct (whatever that means" -&gt; pass by reference. Isn't passing by value more GC friendly? I remember reading something.....
Many people have posted jobs in the past, and there are no rules against it - and I'd never seen people complain about it in the past. I didn't think it'd be a problem. The roles are absolutely primarily Go roles. I mentioned a lot of other tech, but it's because we use it all in our infrastructure - that's just what we interact with from our Go code. I wanted to give an idea of how we work a bit more (i.e. that we do have things like metrics and tracing, and deploy on Kubernetes). When I look for a job I like to know what tech I'd be working with from the language I'd be using.
As far as I know the pointer size depends on your OS, so it's probably 64bit for you. Unfortunately it doesn't seem to work out that simply in reality and there's a lot more involved under the hood. Your best bet is to benchmark your code yourself if you really really need that extra performance boost. 
how to best manage memory is a very deep topic and there aren’t any simple rules you can just follow because so much depends on other context. a rule of thumb you can use though is around 12 to 16 bytes it may be better to pass pointers around than values. 
Perhaps the direct dependency has specified the exact same version
can elaborate? quite interested in why go for microservices
&gt; Value receivers are concurrency safe, How accurate is this? I always operated under the assumption that nothing was concurrency safe. Can't a struct still be copied mid-write?
Go’s concurrency model enables extremely fast and scalable services
It’s not against the rules, I didn’t report this post or anything, I just don’t like job postings here because it’s not what I think this community should be used for and was expressing that opinion. The community can vote on this post like any other /shrug
Yeah, and that's totally fine (and there's obviously nothing I could do to stop it anyway) - I'm only expressing my opinion on it too, and my reasoning behind the post. If I'd seen other posts in the past and that people had complained, etc. then I wouldn't have posted it and would just go to a job board of some kind. The consensus so far does seem to be for downvoting this post, but as with all things on Reddit, it's all about timing, and a bit of luck, and I seem to have just have just had bad luck this time.
Nice :-)
To be honest, I **always** use pointers when I can and never modify arguments.
I'm missing to find one thing about modules. Consider this scenario. I have a 2 repositories, library and examples of usage of my library. With GOPATH, it was very easy to mess up with library and write example in second project. Now with modules, I have library linked to exact version/commit and I can't work on example without committing the change. Is that correct? Is there any way how to work on 2 dependent modules in parallel without need of committing the changes every time?
I also miss the part when you decided to have the main package in a subdirectory, then the build command is not a simple go build. (would be easy to add this informations for new go users)
Hey! Where did my afternoon go!
Errgh erm Leeds though... What salary / benefits are you offering? Would there be an option to go remote after say 3 - 6 months?
It's true as long as no one uses a pointer to the value elsewhere. Since a value receiver is copied, no other routine can do anything with it. The trouble would be if something had a pointer to the original, then you could have an unsynchronized copy. But if there are no pointers at all, you're fine.
Awesome! 
This. If you don't know what you're doing, you can easily rack up a bill in AWS in the hundreds a month
I would start to rebuild something you've made in another language. You will find out soon enough what makes Go shine for you :-)
The article misses an important use case: when your type is a "reference type" (really just a type with a hidden pointer in it), you should probably just use a value receiver. E.g. type Set map[string]bool func (s Set) Add(val string) { s[val] = true } func (s Set) Contains(val string) bool { _, ok := s[val] return ok } Since a map is already a pointer behind the scenes, using another pointer would be pointless.
Haha, Leeds is a great city! Salary would be based on experience, I can tell you more about that through PMs if you're interested. Benefits are a bit... complex right now admittedly. Most common things people use a things like health insurance, the ride to work scheme, you can buy extra holiday, etc. The less clear parts are changing soon I hear, but I'll try to find out more about that.
FYI, it looks like you posted this from an alt account.
I've noticed this too. I don't want to print the entire community with one brush but based on my experience in person, Go seems to attract people transitioning from novice to senior skillsets, and some of them treat it like an untouchable holy grail.
There's Go Codec, which implements various codecs and supports encoding/decoding using reflection and using code generation methods, including JSON. Here's the link to the project: https://github.com/ugorji/go
I'm using this one [https://github.com/mailru/easyjson](https://github.com/mailru/easyjson) fully generated methods
OO ok let me try this out i figured since i was building it in the GCP environment and deploying from there, there deploy process would pull in what i needed. Thanks for the reply i will let you know how it goes!
I don't think that's a good rule of thumb. You'll be at 16 bytes with just 2 64bit pointers ...
While this is correct i guess what that should have said is: The receiver is not going to be changed by another go routine. The values pointed to by members of the receiver can still be changed by other go routines
Is it an paradox though? When all instances of the struct are passing by value, it means you don't need to edit the struct directly, therefore, even if it's passing by reference, concurrency wouldn't be an issue (no variable change in middle of operation) When some are passing by reference and the struct changes at times, even passing be value isn't safe. So it doesn't matter if you pass by value or reference? Wouldn't the solution then be always to use passing by reference (for performance), while making sure the code logic is written as concurrency safe?
This sub starts turning into job board. Don't like it personally.
Reddit is definitely fickle, you aren’t wrong there. I think the clever play to get this message across while still providing somewhat interesting content for the sub as a whole is to write a blog post about how your company uses Go, with a “btw we’re hiring!” bit at the end, and post that blog here. That way people thousands of miles from Leeds can still get something out of it, and it also gets the word out to job seeking Gophers in your area. 
Hi, I'm the publisher of which you speak :-) You are certainly correct that I run a "professional" publishing company, but I am, however, also a long-time, experienced software developer. I review every item that goes into our newsletters and write the majority of summaries from scratch - this is not a copy and paste operation at all, and quite often items we have surfaced (or which have been sent into us, as is common now) end up here *after* we publish. I am not really convinced you have read our newsletters on a regular basis given your opinions. I am intrigued, however, why you are against anyone earning money for publishing. The fact that we are now at issue 253 and spend several hours each week putting it together may demonstrate the value of being a business, as many other such attempts sadly fizzle out after a year or two.
Passing by reference doesn't guarantee better performance. For example, it could prevent stack allocation by tripping up the escape analysis. 
Ah I see. That's a very crucial detail.
Thanks for the feedback. I can understand it's not for everyone but 2 companies recently made hires on our platform on the back of reddit posts so for some people it is working. I wonder if people would be interested in a Golang Jobs sub to keep things separate? Do you think that would be a good idea?
That's a great idea, I had looked into setting up a blog recently, and we're looking to open source some of our internal libraries, and some are quite relevant to current discourse on the subreddit (e.g. we have a library for error handling).
[removed]
I'm the publisher of https://golangweekly.com/ and appreciate your support, of sorts, in this thread. As a weekly publication, we indeed can't always be cutting edge (as in up to the day) but we try our best for the majority of things we link to to have been or become relevant in the week or two prior to publication. Sometimes we have to push things back a week or two due to a larger number of more timely items.
&gt; poorly curated (from Reddit copy-pasted) content I'm intrigued how you feel it is poorly curated and appreciate any guidance on this matter. "from Reddit copy-pasted" is nonsense, however. The majority of our summaries are written by either me or Glenn Goodrich (https://twitter.com/ruprict) freshly each week.
[removed]
[removed]
Its this one: [https://github.com/gotk3/gotk3](https://github.com/gotk3/gotk3) I figured it out, apparently I have to use CellRendererTextNew to crete a new CellRenderer, I cant just pass in a string to a row. I had always wondering why Electron was so popular, I think I'm starting to understand why. 
[removed]
I vote for "same thing", although I suppose some pundit could try to draw a distinction in order to sound profound.
Odds on it's using Kubernetes, so yes.
Have you looked at the newsletter you linked to? 4 of the top 5 items' summaries are just copy/pasted from the original content. At least at Golang Weekly I read every item, understand it, and then write my own, original summary.
Millions of simultaneous IO operations. Web services, game servers, etc.
[removed]
[removed]
I would recommend looking at https://github.com/apex/apex-go for your HTTP server/API instead of EC2 boxes if you don't want to mess with scaling. AWS Lambda provides 1 million free requests with some restrictions (Google Cloud Functions offers 2.5 million). AWS DynamoDB is also an interesting NoSQL database that works well with Lambda and provides a free-forever tier of data/requests also. https://www.youtube.com/watch?v=HaEPXoXVf2k
Once you start designing more things around dependency injected resources, the first signal becomes "does this function need something dependency injected". A contrived and slightly incorrect example: ``` func PutData(s3svc *s3.S3, id string, firstName io.Reader) error { _, err := s3svc.PutObject(s3.PutObjectInput{ Body: firstName, Bucket: "my-bucket", Key: fmt.Sprintf("people/%v/firstName", id), }) return err } ``` This works, but it complicates the function signature because you're passing in both "things which exist at startup and are DI'd" (s3svc) and "things which differ on every call" (id, firstName). ``` type S3DataPutter struct { s3svc *s3.S3 } func (d S3DataPutter) PutData(id string, firstName io.Reader) error { _, err := d.s3svc.PutObject(s3.PutObjectInput{ Body: firstName, Bucket: "my-bucket", Key: fmt.Sprintf("people/%v/firstName", id), }) return err } ``` This is better. You should switch to using `s3iface.S3API` and maybe even making the interface more specific, but that's a topic for DI, not choosing whether to make it a method or not. The other situation is "do I expect this method *will be used* for DI". Structures can be consumed via an interface; typical functions cannot. So, for the last example, its easy to imagine a generic interface: ``` type DataPutter interface { PutData(id string, firstName io.Reader) error } func handler(d DataPutter) http.HandlerFunc { return func HandleRequest(w http.ResponseWriter, r *http.Request) { d.PutData(r.Param.Get("id"), ... ) w.Write(`{"ok": true }`) } } ``` Those are the two signals I use, totally revolving around dependency injection: Will this function need resources dependency injected, and will this function eventually be used for dependency injection? 
Forgive my ignorance, but how is it indicative that if it's using Kubernetes, it must have Golang code in it? Sincere question, I'd really like to know.
I would say yes 
kubernetes was made w/ go, question was if their toolchain involved go, not that it was developed with it
If it's using Kubernetes and it most likely is, and Kubernetes is written in Golang then Stadia is using Golang. 
Do you mean borg? Was borg written in go?
I think parent is just pointing out that large poritions of Kubernetes and Docker are written in Go. Not that underlying Stadia services are written in Go (that we know of)
https://github.com/kubernetes/kubernetes is 89.9% Go at the time of this port. Go is big a part of almost every stack in Google Cloud's offerings.
If it uses Kubernetes or some fork of it for their containers, then Go plays a very significant part, since Kubernetes was made with Go. Knowing Google it's almost definitely using Kubernetes.
I don't think Borg would be appropriate here?
I've had many problems with 0.9.X releases. So I downgraded to latest 0.8, much more stable for me. Try it maybe it solves (some of) your problems.
Yes sir!
I'm on 1.32.3, not sure if I wanna downgrade that far lol.
Any definition won’t be entirely consistent, but the way I always used it is kind of like strategy versus tactics. Architecture is the large scale design. So design at the system level. Design at the component level isn’t architecture. A good example is inside a processor. The instruction set, data bus, cache, and how they fit together, that’s architecture. How the ALU is implemented, that’s design. 
If you never take the address of the struct, pass by value keeps all your allocations on the stack.
A lot of the go tools won't play well if your package isn't in your GOPATH, also, you can't rename anything (or use a lot of features of the tools) while your package is in a non-compiling state.
&gt;you can't rename anything (or use a lot of features of the tools) while your package is in a non-compiling state. Why? That kinda renders TDD useless. For ex, if I'm typing out the method to an interface that doesn't yet exist, reference it a few times, realize I Don't like the name, then finally go create it, etc.
I added a hopefully more clear explanation of what I meant to the OP. Apologies for not being super clear.
Borg is what google uses internally. It predates Kubernetes. I don’t think it was written in go. https://kubernetes.io/blog/2015/04/borg-predecessor-to-kubernetes/
Are you in the know? Please share a bit more if so, without getting into problems of course.
I understood /u/yojustprogram to mean that Go replaces a lot of the typical use-cases of C. Look at Apache HTTP Server for instance. If that was written today, it would be in Go rather than C. Binary size and speed don't matter as much as a robust concurrency model and keeping your source code readable and maintainable. Regarding Rust, it is really more of a replacement for C++ by the same token, although with a distinct emphasis on safety.
&gt;A lot of the go tools won't play well if your package isn't in your GOPATH All of my projects have to be in my gopath? Unless I'm misunderstanding that, that seems really unusual. I guess I don't understand why I need a separate tool to just refactor a variable/method name. That should be part of the IDE. 
Yes, or should I say, most probably. Judging from this Google job listing: &gt; Engineering Manager, Stadia: Build and grow a team of software engineers working in a mix of C++, C#, Go, and Java in Linux and Windows. https://careers.google.com/jobs/results/114927208104895174-engineering-manager-stadia/
&gt;Isn't passing by value more GC friendly? I remember reading something..... Yes. Well, first (to get a semantic issue out of the day), keep in mind that Go only passes by value. Even using a pointer as your argument, the pointer itself is "passed by value", although that pointer references data elsewhere. You have stack and heap allocations, where heap allocations are much more expensive in terms of time requirements. If I remember correctly, each allocation is about 2000 ns (assuming a \~3GHz core), where stack allocations take significantly less. One of your goals in writing efficient Go code is to reduce the number of allocations. Of course, you're going to have allocations in most "real" programs, but there's a huge difference between 1 allocation before you start a loop and n allocations because you include it inside a loop. &gt;Well, isn't it quite "simple"? If you need to modify the origin -&gt; pass by reference, if you don't -&gt; pass by value. The rule of thumb (i.e. not always applicable) that I was introduced to: * Use Value Receivers if modifying the object turns it into a completely different object. Consider a type representing the time. Take "12:00am" and add 3 hours; the resulting "3:00am" *is not the same time as its original value*, so value receivers are more relevant. * Use Pointer Receivers if modifying the object means its still the same object. Having a stopwatch and pressing start and stop will change the value of the its internal time, but *it's not like you threw away the stopwatch and purchased another.* So pointer receivers are more relevant.
I know (vaguely) what Borg is, I just don't know how appropriate it is for running AAA games that weren't designed for it.
Yes, the Stadia services layer is what I meant (launched on top of whatever).
Yep, that's the way it is. I believe you can get around that with the recent addition of Go modules, but haven't looked into it yet. Ultimately, VSCode isn't an IDE, it's a text editor where Go doesn't have first class support. The Go plugin leverages tools that already exist in the Go ecosystem to provide some functionality. If you want more of an IDE experience you can check out JetBrains' gogland IDE.
I had updated my OP to add a clarification. It's still not with certainty that Go is used in the Stadia services. But that's a clever way of finding tooling involvement. And possibly what Google (or any other big player) is up to in the future.
That's exactly what reddit is. It's a news / content aggregator where the content is largely posted by someone who is not the original creator of the content. They probably make tons more money off others content than the publisher of golang weekly. Strange to make an argument degrading one business on another that is practically the same business. 
Golang weekly is useful. The summaries are useful. Even the ads are sometimes useful. Work goes into it and it's not spammy at all. It looks clean and I look forward to every issue. Honestly if you want an email newsletter like this, someone has to take the time to put it together. 
I mean, from that part of the job description it seems pretty clear to me that Go is or will be used in Stadia. I'm struggling to find different interpretations for \`"software engineers working in a mix of C++, C#, Go, and Java"\`.
About $50k/year. Maybe more.
Even so, why would we not subscribe to it? They help people who occasionally browse Reddit and they do it in a very consistent manner. Do you think it is easy to run a consistent newsletter without a degradation in its content or publishing time? It doesn't matter whether they are copy-pastes content or not, the fact is that they created a service which satisfy a very specific demand, and for that they earned their earning. 
Not sure where the hate is coming from, but I've been a happy subscriber to golang weekly and ruby weekly for a long time -- and I've discovered a lot of great projects through both. Sometimes there's content I've already seen elsewhere, and in those cases *I'm still glad it's in the newsletter.* When I'm trying to find the article later to share with someone, I usually do so by searching my email for it. &amp;#x200B; Anyway, to each their own, but mine is a vote in favor.
While sometimes we'll quote the article in our descriptions to give more context within the letter, the vast majority of the blurbs come from our heads. I hope there's value in us going through as many Go-related articles as possible (we read a lot) and publishing the ones we think are important/useful/valuable. It is a challenge each week to select the best articles and then make a description that helps the reader decide if that article is valuable to *them*. FWIW, we've had many, many folks thanks us for finding and including their content in the newsletter. They write posts to share knowledge and exposure in the newsletter gets them more readers. I have written blogs posts that have been linked to by others and always appreciated the traffic. I do not know of a single instance of a content creator being upset about us linking to their content. I have been a subscriber to Peter's newsletters for much longer than I've been a contributor, and I became the latter because of how much I valued the former. I appreciate the free value to the community and I know others do as well. After all, they have to choose to get the newsletter. As far as you ethics jibes, I'll just point to justinbabino's answer about what reddit is. 
Don't assume everyone uses Reddit or gets their tech news every day of the week. Some people prefer the weekly format. I've been migrating my news consumption from attention-sucking websites like Reddit to more aggregated newsletters, and Golang Weekly perfectly encapsulates what I need as far as Go news. 
Just chiming in to say I really appreciate the work you do for "[Golang Weekly](https://golangweekly.com/)". Sure, there are lots of places to find Go articles, news, reviews, and job listings, but I don't believe there are any left that aggregate them into a useful summary like GoLang Weekly. Actually, I rarely come to Reddit for information on Go (or much else) because I hate having to wade through time-wasting rants, debates and discussions like this one. Keep up the good work. If people don't like it, they don't have to subscribe. And those that can't bear the idea of someone earning some money for their efforts can start their own, ad-free publication and let the public decide which to follow. 
Something that would go a long way to mitigate some of this criticism is to make yourself and your company more available for people to actually submit content. I've heard from others that it's difficult to get ahold of anyone at to actually submit new content before it gets submitted to other aggregators. So I can sympathize with people holding the stance that you're just grabbing other's headlines and making money off it. 
I derive a lot of value from golang weekly and appreciate the curation time that is poured into it. Many thanks to the editor and to every individual who has contributed. Occasionally I have time to search and crawl through the comments and banter on Reddit, but most of the time not. I appreciate we have both a curated option for new information and back-and-forth discussion, and acknowledge that one or the other--or both may be valuable to different individuals. You're also free on the Internet to throw poop at things you don't like--cough--provide needed criticism and feedback. You're also free to give credit when credit is due. Which is what I'm trying to do here. Golang weekly is awesome! Keep up the good work.
Hey Peter, I appreciate the newsletter and read it when it comes up to get a better understanding of the go ecosystem. I appreciate all the hard work yall put into it and think the criticisms mentioned above aren't really valid. That said, in my view it's a little "petty" (for lack of a better word) to have a call to action to defend the newsletter in a reddit thread, especially considering the person criticizing you has no posts in his history besides what's in this thread. Don't let one guy's opinion and 15 upvotes get to your head. Regardless, keep up the good work!
I find your newsletter to be the best way to consume Go-related information. Thank you! &amp;#x200B; Hopefully you don't let anything limit you, but keep evaluating material regardless of where you discover it. &amp;#x200B;
A few things - a) who cares how they make their money, b) it's not their content so of course it's going to be copy/paste, and c) previously released stuff is, by definition, old. Go home troll, you're drunk.
It doesn't make it clear what part exactly that Go is used for.
When you reslice the array like that your slice will no longer point to the beginning of the array. The available capacity will be only from the beginning of the slice to the end of the array.
Go ecosystem is transitioning from dep/go get to modules. This affects tools that VSCode use. Some amazing people are working hard to make things smooth again: see: https://github.com/golang/go/issues/24661
I just was pointed out to the Stadia developer website. And on [the about page](https://stadia.dev/about/) it has a link named "See Developer Tools". Clicking it reveals Unreal Engine, Unity, Custom tools, and Industry tools. Under Industry tools LLVM is mentioned, which is the closest it gets to Go I guess. \[google-stadia-developer-tools-20190321-174318.png\]([https://postimg.cc/nsQ887Kt](https://postimg.cc/nsQ887Kt))
You make some fair comments! &gt; I've heard from others that it's difficult to get ahold of anyone at to actually submit new content before it gets submitted to other aggregators. The main approach people take is to hit reply to the emails. Admittedly we do not push this very hard in the issues themselves, and perhaps we should. A real person sees every response. Usually me. Not *every* single response gets a reply, though most do. Every submissions goes into a queue where multiple people (which includes Go developers) review and promote things to be written up for the next week or not. &gt; to add, calling out a single critical comment in a reddit thread in your newsletter seems pretty unprofessional and immature. Feels like a witch hunt. Also a fair comment, even if I disagree! I'd prefer "lie" hunt, though.
You make some good points and I respect you taking the time to reply. &gt; especially considering the person criticizing you has no posts in his history besides what's in this thread Don't you think that's a bit suspicious in itself? Especially given the two accounts involved here were both created on the same day 🙄 &gt; Don't let one guy's opinion and 15 upvotes get to your head. Usually I wouldn't, but the upvotes here got me thinking there is a point to be made, and if this thread acts as grist for the mill in defining what we stand for, it's an (imperfect) opportunity to do so.
I think creating a golang specific jobs sub is a great idea. I agree with u/kskolimowski 
I use “Glade — GTK UI Designer” to build interfaces. [1] https://glade.gnome.org/
I suggest you to read this discussion [1] from 3+ months ago about the same topic. [1] https://www.reddit.com/r/golang/comments/a3lojm/is_mvc_a_good_pattern_in_go/
Excellent! Glad to help. For the other option, I was thinking that you could embed a scripting engine inside your program. Imagine that instead of your program loading a Go plugin and calling a function, it reads a script (eg JavaScript or Forth) and runs the script (and retrieves the script output much like calling a plugin function) inside your Go program. There are several scripting language engines that have been written to run inside a Go program. That all said, it’s great that plugins works since that a much simpler and cleaner option.
Wow. That is some sad, zero-sum-game kind of thinking. It is almost as if subscribing to email newsletters was extremely expensive so that most people could only afford to subscribe to one? But there does not need to be this level of animosity in the Go community. Go needs all the "press" it can get — professional with paid advertising or otherwise — the more the merrier I say as a rising tide floats all boats. Maybe if and when Go has the installed base and mindshare of Java we can start in-fighting. But today, let us unify. P.S. I love Golang Weekly. Both it and Go/libs.garden are emails I am excited to see and usually open and read immediately. &amp;#x200B;
I've been a subscriber to GoLang Weekly since the beginning, and Ruby Weekly since 2011. The work you do is very much appreciated, every week I find at least one useful article, usually more. Keep up the good work /u/petercooper! 
&gt; using another pointer would be pointless Heh
I was just getting into Golang and subscribed to the newsletter as soon as I heard about it. Please ignore the pessimists. 
\#jmtcw but I support @petercooper drawing attention to this critical comment, especially when it appears to be astroturfing. As they say *"one bad apple can spoil the bunch"* so having a profile here go on a tirade against a community actor for specious reasons who by all other accounts appears to be doing good things deserves to be answered by those who do support the brand. Given that today's world of social media torches and pitchforks catalyzed by one bad actor can destroy reputations in the blink of an eye I applaud Peter for drawing attention to this thread in his newsletter. But again, #jmtcw
I personally don’t care. I have an RSS notifier for this subreddit, and I can tell you that job posts are so unfrequent that I can barely notice them. I am more annoyed by the low quality _—easy to Google—_ questions that are frequently asked by young programmers or people new to the community. That being said, if either OP or anyone is interested to post jobs or is looking for one, I encourage you to [join the Golang Slack group](https://invite.slack.golangbridge.org/), there’s a #jobs and #remote-jobs channel that you all can benefit from. There’s also [Golang Projects](https://www.golangprojects.com/), [We Love Golang](https://www.welovegolang.com/), [Golang Cafe](https://golang.cafe/), among other job boards that I think have a more consistent audience than Reddit.
I'll put this here as tangentially related. Due to the issues your raised, plus having to polyglot program, I sprung for the IDE bundle from IntelliJ. Goland is nice. Handles a monorepo fine. Integrates with dep. Supposedly works well with modules. Kind of a suck from having to pay money, but I get to keep my current license forever. I don't have to upgrade if I don't want. Since I use it in a professional manner, its a valid expense. &amp;#x200B;
Since when does a weekly newsletter have to contain 100% new news? The point of it is to curate a list of content for folks who don't spend time reading posts on Reddit and on other sources, to save time for them. Your argument that it contains old news doesn't make sense to me.
Thank you so much, will do!
What an incredibly facile comment. You clearly haven't done any research otherwise you would know you are talking out of your arse. Grow up.
[removed]
Use langserver and most (all?) of those things will be handled. I personally prefer [bingo](https://github.com/saibing/bingo/wiki/Install), my current settings for it: "go.alternateTools": { "go-langserver": "bingo" }, "go.useLanguageServer": true, "go.languageServerFlags": ["-enhance-signature-help"], "go.languageServerExperimentalFeatures": { "format": true, "autoComplete": true, "rename": true, "goToDefinition": true, "hover": true, "signatureHelp": true, "goToTypeDefinition": true, "goToImplementation": true, "documentSymbols": true, "workspaceSymbols": true, "findReferences": true }, 
You sound incredibly jealous that you didn't think of it.
Honestly, stop talking. You are spewing vomit out of your arse.
It seems to just be developers in general are highly sceptical of anything commercial.. despite the only reason they can feed themselves is because of the commercial businesses they work for. I can't even comprehend the level of irony. It's quite sickening.
You make the most relevant point; do these developers who complain about commercial endeavors also complain when their employers engage in commerce too?
Get back in your box.
One of the few exceptions to this for me is if the type is just a dumb data struct, and it's got a method like `String()` or something.
The only reason I know about certain great writers and blogs and sites and whatever else in the Go community is due to that newsletter. I'm not sure how that isn't payment enough considering the newsletter is having a direct effect on subscribers of the sites you link. It's sad that this has snowballed into something even worth mentioning because an insignificant squirt of a person decided to make a big noise about a non-issue. Keep it up Peter! I subscribe to other niche newsletters and much prefer them than overwhelming myself with content on Reddit or other sites.
&gt;Just chiming in to say I really appreciate the work you do for "Golang Weekly". Sure, there are lots of places to find Go articles, news, reviews, and job listings, but I don't believe there are any left that aggregate them into a useful summary like GoLang Weekly. ditto
Who cares what you call it? If you don't like it don't subscribe. The rest of us can make our own evaluations and decisions thanks very much.
I'm happy that I have such kind of aggregation a newsletter provides. I guess running a newsletter costs time and money, so I have no problem with advertisements as long as it is declared as such. 
Hey everyone, Lately I’ve been working with developers on various OS’s with various experiences. One of the issues I run into is that such differing experiences and tool sets leads to a near for a large gitignore file, full of many different types of ignores. As such, github’s gitignore repository has been what I’ve found to be the best source of quality gitignore files. As such, I made this to simplify the process of creating a full gitignore file composed of multiple remotely available files. I chose to leverage fully remote versions so that this won’t use up any of your local hard drive space on caches and to avoid the dependency on Git so that you can use it anywhere. Anyway, hope you enjoy and it helps you as much as it helps me, feedback, issues or pull requests are certainly welcome!
Thanks for that nice link list, appreciate your effort. Feels like I could use it as a additional wiki, beside official docu. 
Two cases that come to my mind: 1. you have a limited amount of RAM within the context of the job (e.g. web server needs to serve X users on machine with Y RAM) 2. your data structures exceed the stack size - I think the Go runtime provides something like 4-8KB for each goroutine's stack. If you exceed the stack size, the runtime will need to pause and copy the existing stack to a new stack of twice the size. This takes time and uses memory.
Borg is a scheduler so that wouldn't have any bearing on what's "designed" for it.
This is the correct answer.
Few thoughts here: 1. I don't have the time or desire to aggregate all of the relevant programming news that happens each week in all the languages I follow/work with, which is why I subscribe to these sort of newsletters 2. I know for a fact not all of the articles in the newsletter are C&amp;P from Reddit. 3. I doubt the publisher is making a killing doing this, and even if they were I'm not mad at someone getting paid for a service that I receive for free. 4. Further down you comment on the "news" aspect of "newsletter". This is just an aggregation of stories from around the web, not investigative journalism so I'm not sure why you're hung up on that.
I am so happy with this newsletter
I was going to reply this exact answer - excellent explanation!!!
I like the idea of the clean separation of defining the cli interface from having to tag the structs. The current flag package that I use gives me a mix of options of being able to apply some of it through struct field tags and also looking up the flags and setting things via the api. Once question... Your 3 examples are roughly the same in showing how to define a set of bool sub-commands. But none of them show much more than the parse and bind. How would one go about having per command flags and args as would be common to those actual examples? 
It seems odd to have a 1.0 release when one open issue is that the demo in the readme example crashes upon a keystroke in Windows. The bug is tagged for 1.1, so I guess it's being worked on, but I don't like when early projects claim to be 1.0+
&gt;why did you feel the need to create your own? Well, I need the stack. It is most important cause. And I need a stack of errors that can have multiple causes (errors caused the next error). So, the difference of my implementation of multi-err is that it combines errors that can be printed in a stack with its causes and so on. In plans is to add a func to restore the error from the raw stack to be able to restore errors fast to be able continue the fails chain in a multi-server perspective. For example: service prints the stack which starts in another service on an another server.
One of the most common bugs I introduce into Go code is using a value receiver when I really needed a pointer. My tactic for avoiding this is to always used pointer receivers unless there is a good reason why I shouldn't.
There is a very small amount of specific language support in VS Code. Mostly languages are supported through extensions that either talk to the language service or they use a variety of tools. In the case of Go, the extension uses a lot of various projects and compiles them for usage. The rename is touchy to get working because it needs to be able to compile everything to walk the ast, I think, and that means it rarely works for me. I still like VS Code, but for Go I tend to use Goland more than VS Code--though I will tend to have VS Code open at the same time for UI.
There is not that good English I speak ) So, you can ask anything you want to ensure that we understand each other
Yes. And as you point out, that's accurate only to a very limited context. Web servers and networking. Where as you mention the benefits of such languages aren't required as much. That's where Go shines. It's high level programming language, providing just a bit more control, yet not sacrificing productivity, ease of use and maintaining low level of entry. And you simply cannot have a GC, rely on runtime reflection, lack of static dispatch / function inlining, have fat std lib, green thread implementation runtime which you can't turn off and expect it to go where C++ can. There is no cake and eating it at the same time. I can go list real life examples and business use-cases if that's a requirement. But I'm baffled how some people continue to insist that Go is systems programming language and compare it to C / C ++ or Rust. Go is simply not in the same club. It's just too fat and too slow to fit. And not by 10 or 20% but by around 3x times. Even if you remove GC, Go will lag behind due to lack of static dispatch and inlining.
Ah. I see. That makes sense as well. 
Thanks for the great newsletter and the discoverable archives. The newsletter brought me to Reddit. So now I have the best of both worlds. Discussions on Reddit, and a curated list where I can “binge read “.
Well, let me point to a couple of things: \- It's a win-win situation for the Golang community we have multiple newsletters to choose from. It's better than a monopoly, like for example a lifetime long reign for... let me check... Cooper Press. \- I'm just a content consumer within this whole. The thing with consumers is that they can have strong opinions and can bash every brand they like, if they feel it's justified and think another one is doing a better job. \- From a 'branding' perspective, it's not that nice if a publisher is trying to bash another one. Not only by trying to bring down Golang Ninjas newsletter (and its curator) in this thread here, but also as I noticed, by stirring up the customers from your weekly to protest against the 'outrageous' things said here. You probably never heard about a gentlemen's agreement on vendor level. Maybe you don't know because you are used to a monopoly situation. But I can tell you that it would be pretty weird to see Microsoft sending people to the streets to oppose to Apple-fanboys. \- Although I'm not quite convinced, I like to believe you when you say you copy the URL's from the original blogs. And holy moly, you say you always create your own written descriptions when introducing a blog. Wow! Pullitzer prize stuff, that is. But in the meantime you seem to miss most of the quality content out there. Well sorry, I'm speaking like a consumer. I shouldn't do that, because otherwise the one and only Peter Cooper, with its developer media conglomerate, will come after you.
I totally agree, keep going golang weekly 
I remember reading that Kubernetes is not as powerful as their internal system Borg. It used ideas from that to create Kubernetes but is not on the same scale. I would imagine that bits are go, bits are c++ and probably other languages too.
Followup question- can anyone eli5 why Scanf and friends are slow?
What do you want to do with scanf? I don't think I've ever actually used it.
This. VS Code is not an IDE. It's a text editor that supports extensions. Specifically, it's a fork of Atom. The Go extension doesn't make it a Go IDE. It adds some very useful functionality, and adds integration with the existing, command line tools, but that's it. As far as needing to be in GOPATH goes, that's how Go worked period until a few months ago with the addition of modules. It's just taking a little time for all the third party tools to catch up.
In competitive programming you often have to extract values from a string with a pattern known in advance. e.g. `1 a 2 b 2 c` could easily be read with ``` var i, j, k int var s1, s2, s3 int fmt.Sscanf(str, "%s%d%s%d%s%d", &amp;i, &amp;s1, &amp;j, &amp;s2, &amp;k, &amp;s3) ```
Thanks for the link, is it easy to hook into your interface from the code?
1.0 could be to indicate that the API is stable.
You bring up one of the areas I am not quite clear on. How do you handle the equivalent of a DB table referencing another domain/service model? E.g. Orders service has to tie an order to the user that submitted it. How does the Order service store the User ID in the table while remaining decoupled? Is there a generic "id" type used across all services, and the Order service is just written to know that that ID that comes in always refers to a User in the User service? That still means its coupled to the User service. Is it against the law (so to speak) for one service to be aware of another? Or is it more common that Orders would use the User model (e.g. duplicate the code) in its service implementation, and NEVER call out/use the User service itself? If that is the case, then that means SOMETHING has to logically call the Order and User service. Something has to aggregate the two services (couple them) without the services themselves being aware of or coupled, right? I would guess then that either the public API service "has the glue" to aggregate multiple service calls, and possibly its own database to maintain the relationships? That is what confuses me.. what keeps track of relationships across services on par with what a monolithic app would do with references (UUID/ID) between tables (1 to many, many to many, 1 to 1)? I cant imagine that a product like Amazon could be a microservices architecture without some way to maintain the relationship between a user and their orders, and other bits of data. So how is this done in a microservices architecture? &amp;#x200B;
i've used golangprojects and welovegolang before for locating jobs. you might want to give them a try.
Have a browse through the issues. They're missing some basics, like drag &amp; drop. Definitely not a 1.0.
Well, let me point to a couple of things: \- It's a win-win situation for the Golang community we have multiple newsletters to choose from. It's better than a monopoly, like for example a lifetime long reign for... let me check... Cooper Press. \- I'm just a content consumer within this whole. The thing with consumers is that they can have strong opinions and can bash every brand they like, if they feel it's justified and think another one is doing a better job. \- From a 'branding' perspective, it's not that nice if a publisher is trying to bash another one. Not only by trying to bring down Golang Ninjas newsletter (and its curator) in this thread here, but also as I noticed, by stirring up the customers from your weekly to protest against the 'outrageous' things said here. You probably never heard about a gentlemen's agreement on vendor level. Maybe you don't know because you are used to a monopoly situation. But I can tell you that it would be pretty weird to see Microsoft sending people to the streets to oppose to Apple-fanboys. Or better said, Microsoft sending people to oppose to Linux, because Golang Ninja is non-profit. \- Although I'm not quite convinced, I like to believe you when you say you copy the URL's from the original blogs. And holy moly, you say you always create your own written descriptions when introducing a blog. Wow! Pullitzer prize stuff, that is. But in the meantime you seem to miss most of the quality content out there. Well sorry, I'm speaking like a consumer again. I shouldn't do that, because otherwise the one and only Peter Cooper, with its developer media conglomerate, will come after you. &amp;#x200B; \*\* NB: I'm not a conspiracy theorist, but my original Reddit account seems to shadow banned (my reply above is not shown in the thread with my previous account) after my apparent outrageous claim \*\*
It isn't actually a fork of Atom (which is why it isn't a craptastic as Atom and never was). It's built on electron shell like Atom, but is a completely different editor that does things in a completely different way
Thank you ! I understand now
Fair point. It's the same goal starting with the same framework but definitely a better execution. I'm not sure I'd say it does things in a completely different way, though. The text editor component is different, but the UX hews extremely closely to the path laid out by Atom.
Some people are meant to be completely ignored dude. Don't even waste your time answering garbage talks. Sadly the Go community is kind of occupied by close mindedness which I found extremely unhealthy. Don't mind them. Keep up the good work.
In my experience, the UX is almost completely different. The only features that can be seen on both are common traits like ctrl+shift+p, which are actually borrowed from Sublime Text. They both are pretty heavily influenced by Sublime Text and some popular IDEs. Execution is mostly different in how everything works under the hood. VSCode has a far more efficient rendering model, for instance. Most operations are faster and can handle larger amounts of data than Atom can. Atom is what happens when someone builds an editor and writes everything the naive way and hopes the people using it have monster machines that can chug through the unoptimized mess
I've followed @petercooper's various projects since first reading his book on Ruby many years ago. Very nice person and he puts the time and care into his newsletters. I support Golang Weekly.
You should read some of Google's books on SRE for insight into how they develop services.
The question is already answered, but may I add a link to an article of mine: https://appliedgo.net/slices It features some interactive animations that shall help understanding slices better.
In relation to what?
It is easy for me, but “easy” is relative. I don’t know what would you consider easy. With Glade, you basically build the UI using the interface designer, it could be as complex as you want, and have as many sub-windows as your application requires. Glade generates an XML file that you can load with Go using the GTK package. The rest is just you hooking up the functions with the names defined inside the XML file. Here’s an example: https://github.com/mrccnt/gotk3-glade-example
Awesome, thanks very much for the help.
Looks like old fashioned front-end. It's cool but I'm not sure there is a big market for that. 
I don't pay a cent for this newsletter to have the best of reddit and maybe more in my inbox ready to serve, every week. I'm glad the editor can earn money doing this so he can continue with his great work. Thanks mate!
Thanks. I just encountered the same problem. Why the hell would google make this inconsistent?! 
How is it not a 1.0? 1.0 doesn't mean everything is finished/perfect. It just means the current public interface has reached a stable point. &amp;#x200B; [https://semver.org/#spec-item-4](https://semver.org/#spec-item-4) [https://semver.org/#how-do-i-know-when-to-release-100](https://semver.org/#how-do-i-know-when-to-release-100)
This seems interesting. Are you aware if there is a way to dump all the generated methods into a single file if all the structs are spread across N files? &amp;#x200B; Or any projects that uses easyjson as a dependency?
read the linked post
I'm not aware that Scanf is slow, perhaps I'm wrong, but what certainly can be slow is when you use it to read from the default, unbuffered STDIN (i.e. by using `fmt.Scanf`). That's because each `fmt.Scanf` call will call to the operating system requesting more input, and for some reason that might be slow. So the first thing you want to do to read input fast it to buffer it. To do that, first wrap `os.Stdin` with `bufio.Reader` like this: ```go package main import ( "bufio" "fmt" "os" ) func main() { in := bufio.NewReader(os.Stdin) } ``` To use the buffering, you need to read from the newly created buffered reader: ```go func main() { in := bufio.NewReader(os.Stdin) var x, y, z int fmt.Fscanf(in, "%d %d %d", &amp;x, &amp;y, &amp;z) // or use this // fmt.Fscan(in, &amp;x, &amp;y, &amp;z) } ``` This time, when calling `fmt.Fscanf(in, ...)`, the buffered reader reads more bytes than necessary and saves them for later scans. This way it minimizes IO calls to the OS. You can do the same for the output if you have a lot of it. In case this is slow as well (which I doubt it will, but perhaps Scanf is the bottleneck instead of the IO calls, I don't know), try using `in.ReadString` (where `in` is your `bufio.Reader`).
Afaik yes for single file which has the filename of the package. 
Are you referring to this specific comment thread: https://www.reddit.com/r/golang/comments/b1uo8a/26_quality_go_blogs_of_the_past_week_that_werent/eiopj30/ 
Cheers for the recommendations - I'll give them a look!
First time I've heard of this, sounds nice! https://i.imgur.com/cXmLtgo.gif So are these just user settings for vscode? I install the bingo, add these, and good to go, or are there other settings? Just asking because I tried doing that, and it's not working like I'd think. But I also have the entire go tool suite installed, so I'm thinking there's another setting enabled that I have to remove to get this to respond as intended. 
Yeah those are user settings for vscode, you will just need to add them somewhere (if you add it to the end of the settings file, remove the last `,`).
Not sure why you are getting down voted. Calling Go a "better C" shows a lack of understanding of C or Go or both. Historically, Go was presented as a modern systems programming language. That wasn't quite true and that description was abandoned.
I'll take a stab. Go is a relatively simple language. It does not offer you much in terms of abstractive power. This is fine so far the problem your solving doesn't require much in the way of abstraction. IMHO Go is a terrible choice when your application has a rich domain (think of modeling something like AirBNB vs the internals of docker).
&gt;If someone else depends on my library, will they end up having my transitive dependencies affect them even if they don’t import the package that uses it? Yes. &amp;#x200B; &gt;If they want to use Cobra are they going to be locked into my preferred version of Cobra? No - your version of Cobra becomes a (as in, one of possible many) minimum version of Cobra for the user (within the major version of Cobra you're using). That is, if you're depending on Cobra 1.7.2, the user won't be able to use anything less than 1.7.2, but they can use any 1.y.z above that, or any x.y.z for any value of x greater than 1 (v2, v3, etc have import paths that end in /v2, /v3, etc so they're effectively different modules). &amp;#x200B;
Yes, you're correct. Sorry, I use IDE like second nature. I mean to imply that the golang extension should handle this like any other language that's used within. But I'm learning a lot. Like the extension uses the golang ecosystem of tools (that I didn't know existed until learning this language) as the method for its madness. So things need to compile before you refactor/rename, etc. Which is a LOT different from what I'm used to in other languages where I can structure my tests, redline the interfaces, then implement them once things look good. For ex: this method doesn't exist yet, but I'm going to structure it around these two variables, and expect this output, now... right click and implement. Magic happens, happy land, etc. I was building a Rest API in go, implementing the functions for the router handling before they existed, and surprised to see there's no "Generate method" option in VSCode. So was kinda taking my past experience and assuming this works the same.
Me too. Saves me time.. I slowly learn about what's going on in the community.. I don't think I would that heavily follow reddit anyway.
\&gt; Since a map is already a pointer behind the scenes, using another pointer would be pointless. I know this to be true, but where in the world is it stated in the Go specifications that maps/hashtables are pointers, and copied as pointers, as opposed to copied value by value as an array is. Anyone?
Strange, I didn't know that. Looks like even something with nearly no features could be considered v1.0.0 as long as any future changes are backwards compatible.
&gt;You have stack and heap allocations, where heap allocations are much more expensive in terms of time requirements. If I remember correctly, each allocation is about 2000 ns (assuming a \~3GHz core), where stack allocations take significantly less. &gt; &gt;One of your goals in writing efficient Go code is to reduce the number of allocations. Of course, you're going to have allocations in most "real" programs, but there's a huge difference between 1 allocation before you start a loop and n allocations because you include it inside a loop To expand on that, it's not just creating the allocations which is expensive, but each allocation needs to be traced and eventually freed and these also contribute to generally worse performance than working with stack allocated data (note that you can pass by pointer without heap allocating data, but the stack analyzer is pretty bad at its job so things do end up getting heap allocated quite often).
The trick is knowing all of the times when the address is implicitly taken, like when you use a method that has a pointer receiver, or when you pass the data in an interface. Pretty sure you can define value-receiver methods for your interface implementation and end up with worse performance if you're passing your value to a function that takes an interface--each call to that function will copy your value onto the heap which can be expensive in a tight loop.
More specifically, it's true as long as no one uses a pointer to the original value elsewhere \*during the time of the copy\*. Afterwards they're free to use/mutate that value. But yes, share-nothing is the ideal concurrency scenario.
I don't know how much this matters, but I'm pretty sure this kills escape analysis if I'm using your library. IIRC, when the compiler compiles my module, it assumes your function will modify the pointee.
This is surprising. In my experience accidentally mutating the wrong thing is both more common and hard to debug than accidentally not mutating the thing I intended to mutate (especially in the presence of concurrency). I prefer the rule of thumb that you pass by value unless you need to mutate--I find this to be very easy and I run into far fewer bugs, especially race conditions.
Almost italicized it but I thought the Reddit crowd would get it anyway. 
Concurrency. It's best feature is easy to implement concurrency.
What's wrong with the good ol email list? I find [Golang Weekly](https://golangweekly.com/) to be a great snapshot view of the week. It saves me time having to constantly refresh forums and threads (looks at [Hacker News](https://news.ycombinator.com)). I greatly appreciate the effort [petercooper](https://www.reddit.com/user/petercooper) puts in.
That's literally the point of semver
Borg is written in C or C++ and predates even go
The intention of Kubernetes was never to replace Borg but rather open up the ideas of Borg. The gap in Google-specific features and optimizations between Borg and Kubernetes makes it quite unlikely for the latter to be adopted internally. https://www.quora.com/How-are-Borg-and-Kubernetes-different/answer/Onufry-Wojtaszczyk 
That's not accurate, the publisher Peter Cooper has been doing newsletters for years, in many subjects, they are very relevant and helpful to the community, he's certainly not a lazy professional and the content is not copy and pastes, it's actually curated content.
We try to follow this at work https://github.com/golang-standards/project-layout We usually have a pkg/types/ that is shared among all other packages. 
Old fashioned as in native vs Electron? That would be a good thing in a lot of peoples books.
The best answer that makes sense!
golang weekly subscriber here, I love it. Often share the article I find there with my company. I rarely spend time on Reddit. 
&gt;Calling @petercooper a "lazy progessional" whithout knowing him or his practice is plain rude. As developers we need to stay on top of tech, so we are continuously researching. Peter's newsletters like Golang Weekly, Postgres Weekly, etc are top notch and make this research much easier because the content is relevant. The articles are almost always valuable! &amp;#x200B;
okey, bro. Thank you for giving some honor) I was afraid to start some project because I had big doubts about my skill, but now I think that I became litle braver of your advice. Thank you &lt;3 
Since switching to go modules I’ve struggled to get a good editor setup with auto completion and live errors. I’ve tried bingo and other tools and they have been quite slow (8 seconds on i9 MacBook) and also buggy (edger you fix a compile error it won’t clear it so you have to close and reopen the file) I switched to [gopls](https://github.com/golang/go/wiki/gopls) tonight and it’s working great in both vim and vscode. Fast too (sub second). Here is the config they recommend which I’m using for vscode: "go.useLanguageServer": true, "go.alternateTools": { "go-langserver": "gopls" }, "go.languageServerExperimentalFeatures": { "format": true, "autoComplete": true, "goToDefinition": true, "hover": true, "signatureHelp": true, "goToTypeDefinition": true }, "go.buildOnSave": "off", "go.vetOnSave": "off", "editor.formatOnSave": true, "editor.codeActionsOnSave": { "source.organizeImports": true },
https://github.com/golang/go/blob/master/src/runtime/map.go but I don’t know if it’s in the spec exactly. 
Honestly, this newsletter is one of the best things I get in my inbox. I always forget about it each week until I get the notification and it absolutely makes my day. Love the content, love the articles - keep 'em coming, please!
Could you give me a description of concurrency? I've never encountered that term before. 
LLVM itself is written in C++ mostly. But if your talking frontend, essentially any language could be used for LLVM, as long as it can interface with the backend (C API, iirc).
You're absolutely right. You can take a look this [image](https://i.stack.imgur.com/6S35J.png)
I typically \*abhor\* email newsletters. 99% of them I sign up for I end up just bulk deleting every couple of months via subject filter query. Then I have to go in and clean them up later and start unsubscribing. &amp;#x200B; Golang Weekly is one of the few mailing list newsletters I actually read. It is super useful and I often click thru to the articles, b/c they are good....and I'm def not a fan of newsletters. &amp;#x200B; I don't get the hate.
“types” is a pretty terrible package name. 
If it's slow, it's because if you look at the signature: `func Sscanf(str string, format string, a ...interface{}) (n int, err error)` it ends with a list of interface{}. This is where each `var x int` or `var y string` goes in via pointer. This means that in order to set these values, it will have to use reflection (runtime type determination stuff) instead of at compile time. There's some overhead with this, but I wouldn't worry unless for some strange reason you're writing performance sensitive code. In general write it first, and profile after. If this is your bottleneck, then you've probably got a bad design.
[removed]
I was concentrating on the Industry tools. I meant the front end llgo. And I wrote “... which is the closest it gets to Go I guess”.
Why all this retarded downvoting? I’m removing this post.
Why all this retarded downvoting? I’m removing this post.
Yeah, in the frameworks I have used in the past this component is called a router. Thanks for the clarification.
It just takes practice and some general learning of the fundamentals (not Go specific). There are concepts in Go that may currently sound very foreign to you. But eventually it should start to click, so don't give up. There are all kinds of problems to solve, for backend, front, and DevOps. Sometimes you can use a ready-made high level solution. Sometimes you need to write some real custom code. It will seem more daunting if you try to think of it at that scale. Just start simple, practice the concepts, read tutorials and other project source code. Your skills will improve over time. 
These UI elements are not more native than what it offered by Electron. More lightweight, sure. Native is UWP on Windows, Cocoa on Mac, Android's material design or Android, GTK on a Gnome GNU/Linux...
Thanks for the reply. Was not planning to quit but feel a bit down since all the reading and study for golang from docs and youtube for the past 5/6 days doesnt help me at all. I feel so stupid staring at the code for few minutes trying to solve inside my head lol. Well atleast now I know what experienced programmers doing everyday. Using open source framework was quite easy, just knowing what to put the argument in the function and train-test the ML model. and using bootstrap ease the whole flow of designing my front page website
I used to not understand OOP at all, then one day I sat down and it was second nature.
I'd add that you shouldn't expect things to happen over night - this is a field (like many others) that takes *years* to build competency in. So a few days is nothing, you just need to keep at it. You also shouldn't expect to walk out of a course into a high paying job, or even into a job in the field you think you want to work in (also, choose a field by interest, not by salary - if you're not interested in your job you'll never be really good at it). There's no substitute for time and effort, but experience in general troubleshooting will help in your ability to construct logic in programming, so don't be afraid to take work in vaguely related fields either.
&gt;this is a field (like many others) that takes years to build competency in. yes, I completely understand this. Probably I was just too stressed out. I would've guess I can solve atleast one question exercise after few days of studying through the basics and syntax of golang. I guess theres a lot more for me to learn lol
You haven't mentioned what kind of program you are graduating from but I assume it is Computer Science, or something closely related. If that is so, then you would have taken courses on Algorithms, Data Structures and other CS fundamentals. If you are graduating from some other kind of course, that's where you should start. &amp;#x200B; The reason I mention this is because I want to highlight a key point in programming, as applied to the real world. There is a fine difference between learning the syntax and standard library of a language and writing that down as code, and applying algorithms and design patterns to come up with solutions to problems. Although these 2 are closely interlinked, there is a distinction between them. &amp;#x200B; As I understand it, you are currently doing the first (learning a new language), while feeling upset about not being able to do the second. When learning a new programming language, professional programmers use their existing knowledge of a previously learnt language and apply that to the new language. They do this until they start "thinking" in the new language, that is, they can solve problems using the new language directly, without having to first solve it in the language they are familiar with and then translating it to the new one. &amp;#x200B; So my guess is that you are either having a hard time understanding the syntax and idioms of Go or you are having a hard time with solving the 'logic' part of the exercises. If it's the second one, then I recommend you solve the exercise first using a language you are familiar with. You can use pseudocode too! After that, check the solution to see how the same problem was solved using Go and how does it differ from your solution. &amp;#x200B; Hope that helps!
I hope I would be an expert using golang and other programming languages as well :)
the language doesn't matter, what matters is the problem that the language solves. Scala is a language that can easily manipulate state data without many lines of code, while C++ allows you to peek and poke hardware. It really just comes down to "do you get it?" I decided to learn how to build software before graduating but I am also pretty old, so it's different when you are younger. freecodecamp.com There is something called React in there, you will get to it, but if you could work through most of that material then you will have no problem finding a job.
My first thought was cool, that's something i have been missing: a Go desktop UI. A was searching for a good Go GUI library, but i still consider Go still has not a well established GUI library, which can be considered a de-facto one. Which are the options at the moment? Which one is considered the best. I'm not interested in Electron bindings, since Electron is eating a lot of resources. Until now Lorca seems to be the best option, however i haven't tried it. [https://github.com/zserge/lorca](https://github.com/zserge/lorca). Any other GUI-s?
Can you help me figure out what exactly you mean ? &amp;#x200B;
&gt; Still cashing advertisement money for poorly curated (from Reddit copy-pasted) content, doesn't justify advertisement income in my opinion. Only if it would be given back to the true authors, the bloggers that are now providing somebody money that otherwise would have to seek another job FWIW, as someone who got featured on the newsletter a couple times, I couldn't care less. I put my content out for free, for everyone to enjoy. If someone found a way to make some money with that, good for them :) They provide proper attribution and link back to me - so as far as I'm concerned they are fulfilling their ethical obligations. The rest is simply what the web is for and if I wouldn't want that, I wouldn't put out content openly.
Programming is all about problem solving. Doesn't matter if you aim to be devops or backend or frontend, all good programmers are really good problem solvers. Golang isn't a terrible language to start with as a beginner. Patterns that you learn with golang can be applied with many other languages as well. And 5 days is nothing. Most programmers sit in front of the screen for years. What you need to do is to just keep at it until it finally click and then it will just be a matter of accumulating experience.
electronic engineering. Learnt C during my foundation years, didnt like it, didnt pay attention in class. during my degree, learn more on microprocessor, also, didnt like it. for my mini project last sem I did the machine learning mini project, which actually get my interest on 'using' programming language (more like framework i guess at this point). My lecturer suggest use the matlab, but looking at few articles online suggesting the benefits on using open source, faster updated, easier to access online (get from github), etc. &gt;my guess is that you are either having a hard time understanding the syntax and idioms of Go or you are having a hard time with solving the 'logic' part of the exercises. probably bit of both lol. shoudl i actually start on dig down more on the golang documentation or watching some data structure/algorithm course on udemy? Does data structure/algorithm and solving those kind of exercise benefits me when im using go for backend/devops? thank you so much on the advice and kind words! 
Is competitive programming a sport?
&gt; There is something called React in there Isnt Javascript framework is more for frontend? There few articles I've read on the lack of performance in javascript in backend. Hence, one of the reason I look into using golang
The most important thing about learning a programming language isn't learning the language. It's learning how to solve problem computer, it's much more about the method rather than the language. I would say the best practice is forget about doing "quiz" because those don't help you. Software company don't pay people who are good at answering quiz. They hire people who are good at delivering result. Instead of doing quizzes or following tutorials to build a "thing". Try to think of a project that you personally feel interested in developing regardless if it's already been done in some shape or form commercially, and use the knowledge you learned from seeing those quizzes and doing all those tutorials to build your own project. You will learn faster this way than any amount of quizzes can help you.
How do you sync this between projects? git and tagging?
I don't mind what happens. I've seen plenty of blogs explaining the same stuff over and over again (in more or less the same form). I teach Go in the company I work for, and I think finding information on a subject is good, no matter where it was published before. Just access to information is the most important for Gophers to grow into more knowledge. &amp;#x200B; Do you think I teach based only on the information I all "invented" myself? You already know the answer. &amp;#x200B; For the part where a blogger get paid for a piece of work, I'll hope they get paid in front, and not based on the number of visitors that might come by. You might even think, why a publisher wants to "share" the knowledge in the first place? To spread the word, or just to earn money? If it is the last option, they should have done it behind a subscription kind of solution, so you know that people actually pay for it.
The go tour is not meant to teach you to program, it is meant to teach programmers the go syntax. Syntax of a language is the easy part of learning to program. The hard part is learning to solve problems. I recommend reading [how to think like a programmer](https://www.amazon.co.uk/Think-Like-Programmer-Introduction-Creative/dp/1593274246/ref=sr_1_1?ie=UTF8&amp;qid=1553240390&amp;sr=8-1&amp;keywords=think+like+a+programmer) which better teaches this side of programming. Then to further practice these skills try doing some katas for the language you are interested in. There are a few good sites for this such as [exersism](https://exercism.io/) or [hackerrank](https://www.hackerrank.com/).
There is so much more to learn it’s beyond understanding. Just take it a step at a time. When I was learning Golang I wrote my own versions of Linux core utils (ls, cut, tr, cat, ...) to learn the basics. Pick something small and just don’t stop until you have it, then do it again.
If this is working for you, then that's fine. But, I would suggest to anyone embarking on a new project to ignore these "standards" - they neither standard nor official, and needlessly complicated for anything other than very large projects. And even for large projects, some of the suggested concepts - such as the "types" package - I would strongly discouraged unless you've exhausted all other better alternatives. Define types next to the code that should "own" that type; e.g. if you have a function that looks up a user in a database, then define the User struct right there in that package.
 [https://www.reddit.com/r/GolangJobOfferings](https://www.reddit.com/r/GolangJobOfferings) I've started playing around with this one. Will try and get it all up and running over the weekend 
This really depends on what else shares the 'common' types. I'd usually look at trying to break the dependency by having renderer.RenderInstructions take an interface rather than a concrete type, and then the type returned from parse.ParseContents can implement that (with the Instruction type living in parser), but without seeing any real signatures it's hard to say for sure. &amp;#x200B; I don't like either the 'common' package name or having main.go in any package that isn't main, but that's personal taste really.
Assuming you meant those `s` variables to be `string`
This
github.com/amlwwalker/got-qt I've been using this as the basis for all my go guis and have come to love qt and go working together. Works on mobile and desktop
I seem to like `russ` apology ... very matured. 
NodeJS is usually the javascript which is run as a backend server. I have experience with both NodeJS and Golang. and I suggest that you pick golang over nodejs if you are learning new language. NodeJS uses libuv and event loop mechanism to achieve IO requests. And it works pretty well. If we talk about benchmarks of IO server performance, Golang and NodeJS are very close performance wise. But there is one area where NodeJS does not shine as much as golang or java do - that is raw performance. Hence if you need to write some cloud service to do CPU intensive work, its better off to use Golang or Java. If you are just writing a realtime web app, then the NodeJS is good to go. Since golang is good for both, Realtime IO and CPU intensive work, I will suggest Golang.
Could you expand further? For example, if I create a new pointer in a function, but that pointer never escapes the function (neither by returning it, nor setting global state), then the analyzer might still determine to heap allocate it?
Versioning is about backwards compatibility, not "worthiness" or whatever. 
I just default to using pointer receivers [unless I have a strong reason to do otherwise](https://dave.cheney.net/tag/receivers).
I subscribed to r/golang just to left my comment for **Golang Weekly** support. r/golang should thank to *Peter Cooper* for promote their content. I believe there are lots of people, who appreciate *Peter's* great job, but doesn't want to create an account here. **Golang Weekly** was useful for me more than one year. A subscription only to one source helped me to be up to date with golang news. You always can found more info, it you're interested in something. But this subscription was a perfect choice, because it's well constructed, short enough, not annoying, doesn't require an account, registration, etc. Thank you, *Peter Cooper !* You are doing a great job!
Thank you so much ! The website is awesome. I'll be referring it a lot :) &amp;#x200B;
I subscribed to [r/golang](https://www.reddit.com/r/golang) just to left my comment for **Golang Weekly** support. [r/golang](https://www.reddit.com/r/golang) should thank to *Peter Cooper* for promote their content. I believe there are lots of people, who appreciate **Golang Weekly** newsletters, but doesn't want to create an account here. **Golang Weekly** was useful for me more than one year. A subscription only to one source helped me to be up to date with the golang news. You always can found more info, if you're interested in something. But this subscription was a perfect choice, because it's well constructed, short enough, not annoying, doesn't require an account, choosing from 100 topics what is gonna be useful for you etc. The same simple and productive as golang itself. You are doing a great job guys!
You need more perseverance. I can't tell you how many problems I've had to overcome over the years. Sometimes days spent on issues or trying to figure out something. Most times as I reach the point of giving up I find the issue.
Normally it means you are starting at the wrong level. I always "zoom out" on things I don't understand so I can get a better general understanding of things and then work my way back down into the detail. Start with something like hackerrank 30 days of code.
Well rust or ada
&gt; Im planning to become a backend/system/devops Understood. &gt; (mostly the salary is a bit higher here than other software eng) That’s a terrible reason. Choose a career you love, and money will chase you.
I receive many of Peter Cooper's newsletters since years, including Golang Weekly and I think they provide real value. Best newsletters for developers in my opinion.
It sounds like you prefer data analysis to programming.
💯
I really like golang weekly. I don't know if he's doing money or not, and how much, but I don't care. What I know is that it's a great source of info about golang and I can use it for free, which is great. &amp;#x200B; Long life to golang weekly!
My thinking was that if your demo in the readme doesn't even work, chances are there are going to be parts of the api not well thought out either.
Doesn't a stable public interface somewhat conflict with the notion of lots of incomplete functionality?
A lot of people use Semver to think about versioning, and I'm a big fan. Before 1.0 you can break most things. Once you stop breaking things and can use a project in production, it is ready for 1.0. See [semver](https://semver.org/#how-do-i-know-when-to-release-100): &gt; If your software is being used in production, it should probably already be 1.0.0. If you have a stable API on which users have come to depend, you should be 1.0.0. If you’re worrying a lot about backwards compatibility, you should probably already be 1.0.0. In this case, they aren't worrying about backwards compatibility or using it in production if one of the supported operating systems is unusable. If they specified Windows as being on a roadmap or a future feature, then it might make more sense, but the early stage of the project would also make it reasonable to think there could be additional redesign needed before the API is stable.
Not disparaging, but curious: What use case does this solve that Cobra doesn’t already handle, that would justify losing all the nice type safety and self-documentation that Cobra provides? Either way, thanks for sharing!
The web version is missing this piece in the email: &gt;😕 We've [**faced some unusual criticism**](https://golangweekly.com/link/61016/87c988174d) on Reddit this week suggesting that running a newsletter like this as a professional operation is unethical and that we "copy-paste" from Reddit - both things are untrue. &gt; &gt;*Golang Weekly* is now 254 issues old (thanks to you!), our summaries are written manually after reviewing the content, many of our items are direct submissions (from you!) and end up on Reddit *after* we link to them, and the commercial approach we've taken enables us to be able to keep publishing for at least 254 more :-) &gt; &gt;While I don't expect it, if you are a particular superfan of the newsletter, I would appreciate any support to counteract the mistruths on [**this thread,**](https://golangweekly.com/link/61016/87c988174d) but otherwise enjoy this truly hand-curated, ethically produced issue 😄 *— Peter Cooper, your editor* &amp;#x200B; Dear Golang Weekly editor, Please don't let a few bad apples on this sub discourage you from running a great service. I enjoy reading this newsletter and I don't mind if you distribute material you see here on Reddit, in fact I expect you to. The idea is that this newsletter is an aggregate of everything seen on the web compiled into one convenient location. If I spend most of my time on Hacker News, then seeing posts copied from Reddit actually serves me well (especially since there are a lot of crap posts in this sub you need to wade through). If you really care that people are still giving you shit about this, maybe start putting badges on links to show where the link was originally discovered? Or maybe sub-links that show the discussions around that article (reddit/HN/lobsters/wherever). I don't think that really matters, but maybe that will silence the haters. Keep up the good work!
I don't remember ever doing that on a \*method\*. Languages like C# don't have an explicitly declared receiver, so the "this" variable is always a pointer.
Yes their are many as the likes of 000webhost, firebase, heroku etc. You can easily test your app on any of the platform as they are considered among the best free web hosting options.
Without understanding your problem it’s difficult to answer your question, but here’s my feeeback: You appear to be attempting to implement some of the functionality of an OS in your application. I’d recommend taking your foot off the abstraction pedal a bit. Pass the data to be operated upon, perhaps with methods attached to the data that implement interfaces, to goroutines that perform the processing. Let the language and OS “worry” about blocking.
What? That seems totally valid. Imagine if you do a query, you would expect the number of matches to return. Sometimes you can have no matches, and that is not an error. So something being nil when error is nil, is not a bug.
Similarly, why this and not docopt, given that there's a Go version of docopt?
Not quite. I'm using Gopherlua which isn't thread safe, and am automatically exposing many functions which may or may not call back into Lua at some point. The requirement is that all lua code is executed on a single thread. If that code is non-blocking then great, but a lot of it is run blocking. 
The only way to do this (which is also the way `go test` does it) is to parse the source code and generate a source file containing references to all the functions - and then compile it together with the packages under test into a new binary. There is no stable way to enumerate or call functions by name. There *are* unstable and unportable ways. Under Linux, for example, you can read in `/proc/self/exe`, parse it as an ELF file and find the defined functions as exported symbols. By combining the resulting info with `/proc/self/maps` you can get pointers to the entry points of those functions and then manually construct `func`-values using `unsafe` and using undocumented internal calling conventions of the Go runtime. Of course, this is incredibly brittle, will only provide a solution under Linux, every operating system will require its own solution and workarounds for its own idiosyncrasies and any update of Go might break it. As an alternative, I would point out that you can provide a function for users to register their own functions. This would only marginally increase required effort on the part of your users, while providing a portable, simple and stable solution.
i’m reasonably certain nothing you’ve said refutes my answer except that given your constraints, you may only have one goroutine processing requests.
[`runtime.LockOSThread`](https://golang.org/pkg/runtime/#LockOSThread)?
Nice!
My concern is with deadlocks. As an example, lua might invoke a Click method, which then goes into my event system and trigger handler methods. Some of those methods may be Lua functions which need to be executed on the lua thread. If it enqueues the function and waits, then a deadlock will be triggered. The code invoking Click is waiting on the handler method, whilst the handler method is in a queue that's currently waiting for the Click code to finish. Currently I'm checking goroutine ID and if it's the scripting goroutine it doesn't enqueue, it just executes, but this is using string operations on debug information, which isn't ideal.
This is a nice method that I didn't know existed, but Gopherlua is a pure Go library. I only need to limit access to a single goroutine without encountering deadlocks on a queue.
I should have googled harder, go generate is the way. It is out of question to go parse the ELF :-) having the user register their function can work, but I'd like to make it as painful as possible. Thanks for your feedback
Put everything in one file until it's too much. After it's too much, split it up into different files. After you have too many files, split it up into different packages (directories.) After you have too many packages (directories), split it up into different repositories.
I personally dislike Go devs touting their horn and saying that Go doesn't have classes. Structs with methods on them, while written ever so slightly different from C++, is EXACTLY what c++ is compiled into. It comes off as extremely pedantic. (Though yes, it's not OOP)
Just to clarify, apart from the main point. I write Go code, I am not a Go developer, I am a developer. I consider "Go Developer" to be a close minded subset of "Developer".
Thanks for bringing that up, I didnt want to crush anyone, but objects are not generated in Go. DA POINTERS AINT EVEN REAL POINTERS!!! C++ is the best first language, then Java.
no, it is compiler reduction magic. there are a few other the-compiler-does-this-for-you-gotchas that trip newcomers.
What i meant was: all members of the receiver will not be Changed. Only the values pointed to by these members can be changed by other goroutines.
&gt; C++ is the best first language, then Java. On that point I'd disagree though.. it's very contextual. I'd never write a game engine in Java, nor a webservice in C++. Could be exceptions to the rule, but each dominate a certain domain of use cases and problems to solve.
Awesome. There is also huge community with jobs on Slack. gophers.slack.com I recommend joining. 
&gt; This week the tree will open only for significant changes that need to be made early in the cycle, in relative quiet. Right now, these changes include the Go 2 [number literals](https://golang.org/design/19308-number-literals), [error values](https://golang.org/design/29934-error-values), and [signed shift counts](https://go.googlesource.com/proposal/+/master/design/19113-signed-shift-counts.md). Releasing new features in small backwards-compatible increments. Awesome!
&gt; This week the tree will open only for significant changes that need to be made early in the cycle, in relative quiet. Right now, these changes include the Go 2 [number literals](https://golang.org/design/19308-number-literals), [error values](https://golang.org/design/29934-error-values), and [signed shift counts](https://go.googlesource.com/proposal/+/master/design/19113-signed-shift-counts.md). Releasing new features in small backwards-compatible increments. Awesome! From these 3, the error augmentation capabilities have most of my attention since it will standardize what libs like http://github.com/pkg/errors do.
Thank you! 🙏
Been a subscriber for a few years and I find Golang Weekly an excellent source of what is happening in the Go community. Keep up the good work.
Perhaps my testing \`len(something)\` wasn't the best example, but I can't see how this should be considered valid code. I've found a significant number of bugs where the code should have been creating a new error but instead the existing \`err\` is being used. &amp;#x200B; In the event you're wanting to return \`nil\` when \`len(something) == 0\` then why not just \`return nil\`? It makes zero sense to give the sense that the \`if\` block could sometimes return an error. Like: something, err := doSomething() if err != nil { return errors.Wrap(err, "when doing something") } if len(something) == 0 { return nil } In the event you're wanting to return an error when \`len(something) == 0\` then you should be creating a new error, like: something, err := doSomething() if err != nil { return errors.Wrap(err, "when doing something") } if len(something) == 0 { return errors.New("something has zero length") } Can you help me understand how my original code doesn't have a superfluous \`errors.Wrap\`? &amp;#x200B;
The advice from /u/ihsw is good, but I'll include some more details about what to do when you hit the "split it into different packages" phase. &amp;#x200B; Here are a couple links to some well-liked community sources on package design: [https://medium.com/@benbjohnson/standard-package-layout-7cdbc8391fc1](https://medium.com/@benbjohnson/standard-package-layout-7cdbc8391fc1) [https://www.ardanlabs.com/blog/2017/02/package-oriented-design.html](https://www.ardanlabs.com/blog/2017/02/package-oriented-design.html) &amp;#x200B; &gt;a package "model" where I have all the model corresponding to the database tables The Go way would be to have specific packages (think article, user, ...) instead of generic packages like models/handlers/controllers. The linked articles do a reasonable job of explaining why and some specific ways to break up handlers/models/etc.
Just ignore the project altogether, doesn’t worth the effort.
Not based off net/http == cannot be considered a web framework? What interesting mental gymnastics. This man keeps giving reasons why not to use iris
This was my reply, I wasn't able to send it before the issue had been deleted lol: &amp;#x200B; \`The current github's README shows exactly the same information. \` No. No it does not. It clearly shows that fasthttprouter is faster. &amp;#x200B; \`Your screenshot shows exactly the same thing, Iris is the fastest web framework written in Go. \` No, again. It is not. Changing the title of my issue does not support that idea. This is taken from the repository named "web-frameworks". Naming it a router only signifies the purpose, it does not exclude it from being a framework. Framework exists to simplify our lives as programmers, so be it a router, a library, etc. It is still in the category of a framework. See here for more: [https://stackoverflow.com/questions/2964140/what-is-a-software-framework](https://stackoverflow.com/questions/2964140/what-is-a-software-framework) &amp;#x200B; \`Muxie (created by me as well it's router, and fasthttprouter is a router based on fasthttp, not net/http so these two are not considered as web frameworks).\` Again, that does not really matter. And even if it did, it does not define whether or not is a framework. Seriously. &amp;#x200B; \`Please try to put your hate somewhere else, you are not missleading developers like this, we can see the picture :)\` If that is the case, why did you just manipulate my title and try to subside my proof? You seem to write what you want people to think, instead of letting them judge the numbers and data for themselves. Is Iris fast? sure. Is it the fastest? If yes, please provide the data. Cause from the benchmarks it is not. &amp;#x200B; It is not hate. At least, not yet. It's me just hoping larger projects can be less biased.
Thank you! Good to hear that you like my blog. I *do* have to write another post at some time...
I hadn't heard of the project until you mentioned it. Drama like this is antithetical to the Go Community Code of Conduct. Let's just not, please?
I agree it is dramatic. But is it better to be silent about it?
This could be a good start : https://github.com/golang-standards/project-layout
How about returning two values - one for the expected case, and one error value. This is a classic pattern in Go. func f() (string, error) { something, err := doSomething() if err != nil { return "", errors.Wrap(err, "when doing something") } if len(something) == 0 { return "", nil } return something, nil } (In this particular case, you can of course omit the second if block completely, because `return something, nil` already covers the case of an empty `something` string.)
The Iris owner is a known hack. He ripped off httprouter (and violated the copyright) and ofter rewrites git history to take contributors work as his own.
I agree that they don't seem like they won't break the API, but I think we should give them the benefit of the doubt. Let's all let them release 1.1 before complaining about not respecting semver, ok?
S3 bucket, CloudFront distro, SSL cert, and DNS record? Not that complex.
Sure, absolutely. I think I'm just horribly describing the situation that I'm trying to fix. Instead of focusing on the positive case where \`len(something) == 0\` is acceptable -- how would you re-write your suggestion if an empty list was a case which should produce an error?
Treat Kataras, his countless alts and his projects like the plague. Avoid at all costs.
name and shame is moral and you did good OP
Community seems to disagree
not this clown again ...
&gt; Not based off net/http == cannot be considered a web framework? What interesting mental gymnastics Neither is Iris, is it? IIRC, one of the things he got crap for before was [using julienschmidt/httprouter](https://github.com/julienschmidt/httprouter/issues/148) and playing it off like it was his code. 
There are probably better uses of your time than arguing about claims like this. Even for the benchmark in general, it's an interesting datapoint, but I wouldn't put too much meaning in a simple test like how fast it can return a fixed string.
I kind of see what you are trying to get at - what this hypothetical linter would do is something like: &gt; if a users code imports `pkg/errors` and wraps the same error for more than a single exit path from a function then emit a warning to make sure this is intended. That might be a hard one for a linter to detect as it is likely heavily dependent on the context and semantics of the called function as well as only applying for people using `pkg/errors`, but I do agree that in most cases that I can think of it could be mildly confusing for the caller to wrap the same original error twice rather than return some new error from a second or third failure 
Thanks for this, started using it today and it is so much faster then the default language server when using it in projects with go modules, amazing! 
This is more about his behavior/attitude and how he treats contributors. And I don't mind the 15min too much. &amp;#x200B; And it's not really about returning a string, it's about the delay between sending, processing the request and sending a response. If I'm not mistaken?
Could very well be the case, but i wouldn't expect him to think that far ahead
Compres is a different compression algorithm than zlib
If it's provable that he's violated the copyrights of others, or is intentionally misrepresenting others, how does his account still exist? Both of those are violations of the Github TOS...
The Go author's are really trail blazing in how well they've handled the upgrade to v2. Go continues to get better and better without adding additional cruft. It still feels precisely engineered like a fine Swiss watch made by a true master craftsman. Each component is lovingly crafted based on years of experience and observation of the subtlest details, intuitive reverberations, and then fitted in such that the whole is more than the sum of its parts every time. Nothing is every cheapened. &amp;#x200B; I just can't wait to see what delights await us yet.
This project is a legal liability to absolutely everyone using it... We absolutely should continue to call it out if even just to save others within the community some heartbreak.
Sorry, I got confused. I meant [valyala/fasthttp](github.com/valyala/fasthttp), not httprouter, which would be a `net/http` equivalent. I have no idea if he's since removed that code, though, because I really could not care less about the petty-minded twerp. 
Hugo use [chroma](https://github.com/alecthomas/chroma), I hope this helps.
I'll try that right away, thanks!
See the last link in my post
Github generally does not get involved without lawyers and lawyers cost money. To some people, it's not worth pursuing a costly legal remedy which compels one open source project to abide by the license of another FOSS project. It's the unfortunate downside of FOSS: you get no money to defend yourself. 
[https://github.com/julienschmidt/httprouter/issues/148](https://github.com/julienschmidt/httprouter/issues/148) He deleted his original account, deleted all issues and everything that slightly mentioned his shitty behaviour.
&gt; We absolutely should continue to call it out You're assuming that people can't do their own due diligence on whether or not to use a 3rd party's code in their own project. You're also assuming your "call out" carries some weight, even though the people here are completely anonymous and this "call out" comes off as Internet drama. Pull all the judgmental language and melodrama out of this post, make it a statement of facts and nothing more, and I'd take it a lot more seriously...
Sorry, are you the spokesman for this "community"? Who is this "community" exactly? I'm simply referring to the link in the sidebar...
I'm confused. 1 day ago you posted this same thing and I asked a question. Then you deleted the post and reposted it here, 8 hours ago? Here was my original reply: I like the idea of the clean separation of defining the cli interface from having to tag the structs. The current flag package that I use gives me a mix of options of being able to apply some of it through struct field tags and also looking up the flags and setting things via the api. One question... Your 3 examples are roughly the same in showing how to define a set of bool sub-commands. But none of them show much more than the parse and bind. How would one go about having per command flags and args as would be common to those actual examples? 
This isn't a dichotomy. Make a statement of facts, let the facts speak for themselves. Drama is off-putting. Drama makes facts seem cheap. No need for any of it.
Look at the downvotes on your comments. That's the community
A couple dozen people clicked a nondescript button on a website. And you claim you know why those people did so. And you also claim that couple dozen clicks comprises the uniform voice of a community of tens of thousands of users. How many different fallacies are you trying to pack in a single post?
&gt; I can't fathom how this project has +14k stars on GitHub. Just like social media likes, there are places that sell those. It's apparently a pretty problematic phenomenon in the China that's generated a lot of backlash in the Chinese github community: (links in Chinese) https://www.pingwest.com/a/177413 https://www.zhihu.com/question/66587533 If you google translate, you might come across a weird term "brush stars" which basically means growing the # of star through non-organic means like buying.
anders fylling is my real name. Same on github, instagram, etc. So I don't really agree that the people here are completely anonymous. &amp;#x200B; I've listed facts in my post; if you want a summary it's essentially that the owner is a hustler, and there is absolutely no need for everyone else to experience the same bad treatment. We're a community, we should look out for each other. &amp;#x200B; He has even broken the license of projects. Again that is referenced in my post, I just haven't gone in depth about what the articles contain, just merely showing that there's more to this than me going on a rant.
Architecture is about how many *components* do you choose application/project. e.g: microservices architecture with a Mysql DB. Design is about the inner aspects of that compontents: e.g: language, MVC, one-to-many relationshipts. &amp;#x200B; In other words, architecture is about the components proposal and design the more detailed decisions about how use or configure that components.
I used chroma over blackfriday using [bfchroma](https://github.com/Depado/bfchroma/), it does a wonderful job!
Am I the only one seeing "ghost" instead of kataras?
Nope. Shining the spotlight on bad citizens in open source is the implicit duty of anyone who uses or contributes to open source. To ignore bad actors is to legitimize their behavior. This isn’t a go thing, it’s a common decency thing, and kataras has proven time and again he lacks the decency to be the maintainer of a plastic cactus, let alone an open source community. 
To be fair: He's technically right. There's a spectrum of libraries that occupy this category, from a fully-functional and opinionated "web framework" like Rails (of which Go really has none) down to something like net/http, and even LOWER (net/http can do some path-based muxing, that's pretty high level!) Muxie and FastHTTP are not, by any definition, web frameworks. Iris probably isn't either, but its definitely closer than those two, and is among the most feature-filled web libraries on Go. And to be clear; kataras is a sociopathic, manipulative asshole. I would avoid any code he's had any sort of control over. I wouldn't trust or use Iris if it were the only web library available for Go. His history is far far worse than renaming an issue in bad taste. An issue which, frankly, would come off as a little asshole'ish if it were submitted to any other project. Pretend he doesn't exist. Until someone else doesn't, then share what you know and go back to your life. 
Yeah, I realize now it was a bit of targeted frustration with a library not everyone uses. Not everyone can guess \`errors.Wrap(err, "something")\` will return \`nil\` if \`err == nil\`. I didn't the first 100 times I used it! &amp;#x200B; Wouldn't it be safe to say that past any \`if err != nil\` branch which includes an unconditional return that \`err\` shouldn't be used again? &amp;#x200B;
I only consider gin if we talk about web framework in go. 
Stop being so dramatic.
There may be no solution. Trying to compose unthreadsafe code together will eventually result in unthreadsafe code. You may have to fundamentally rethink your architecture to ensure a clean encapsulation between the threaded code and unthreadsafe code.
I currently have "a" solution, I'm just not happy with it because of how hacky it is but also that it may or may not become unsafe under certain circumstances, as you say. I'm not in the slightest concerned with my async queue method, but the blocking method is currently really hacky. https://puu.sh/D3Tx2/822be47e4f.png security.Id() method: https://puu.sh/D3Ty2/a4ab181b75.png It's parsing string debug information. The slow speed of such a task is the least of my worries, and it's so hacky it's making my skin crawl but for the life of me *I can't think of a suitable alternative*.
Oh hey PHP dev who furiously defends iris 🤣 This was just posted and it reminded me of you 😍 [https://old.reddit.com/r/golang/comments/b481q7/a\_warning\_about\_githubcomkatarasiris/](https://old.reddit.com/r/golang/comments/b481q7/a_warning_about_githubcomkatarasiris/) Leaving this here in case a sensible dev finds this post looking to migrate from Symfony to Go.
Welcome to the club. I'm also banned from that repo and had my issue deleted. He made us both a favor to be fair. It's just sad that the community can't see all the wrongdoings that happen in that repository just by taking a glance at it since any hint is promptly deleted or edited. Wasting so many people's time by baiting them in investing their time in a project doomed to fail.
Gotcha. I'm thinking specifically of repos that contain multiple binaries or multiple APIs, e.g. a monorepo. I agree that "one module per repo" is almost always the right choice.
that moment when you think you just heard of a cool new library you want to star and you realize you've already starred it :)
Well it depends, do you want to be a Computer Scientist or do you want to be a Software Engineer? True, these are not mutually exclusive sets; however, things like AI and building business logic applications are completely seperate from understanding what the computer is doing while compiling and running the program. Go routines? those things are super random and I think if you print out all the element if a map it comes out in a random order. This could make a newbie think that computers are just random machines that do crazy things and it is all about the syntax. C++ shows you what passing by reference is which is the only language that truly operates like that. Lack of control of the mutability of passed params seems to be a large deficit when you actually start building software. In regards to business? they want a C C++ guy and they will train you in Go. Java can't transpose to that language, C# is in the same arena. Therefore. C++ allows us to move to any language afterwords and easily gaining command over the philosophy behind Python, Javascript, Go etc. If someone doesnt know how the basics of a language then how could they ever effectively write web services? If people aren't willing to go to school for CS then I tell them PHP, so I am kot against Go at all, but if you have never learned a language then it is a confusing funnel to fall down. It's a procedural language, without objects, and focused on concurrency. At the end of the day the language do all of the same things but Go is definitely a network programming language and unless that person was a network admin wanting to write code, I don't see how having something like net/http is an advantage if that is the point being argued. 
&gt; My concern is with deadlocks. One goroutine processing lua requests equals no deadlocks.
What a douchebag. 
GitHub replaces accounts with "Ghost" if people delete their account or if they get banned.
I'm not asking when. I'm asking how
&gt; The Go way would be to have specific packages (think article, user, ...) instead of generic packages like models/handlers/controllers. No. The article tells the opposite
I skimmed But I think the take away is use the git protocol thingy url I instead of the http one
Found Kataris.
Maybe this is just me, but in all my years of programming in Go, I've never, not once, sat back in my chair in frustration and said "Man, I wish we had some decent number literals!" The signed shift counts I guess will help with math/big optimizations? So that's neat. But these are as exciting and ground-breaking to me as a new way to do comments or something - most likely inconsequential for 99/100 Go programmers. Maybe I'm just misunderstanding them completely? The more standardized "rich errors" is definitely a nice addition, but I don't quite see why it's bundled in the "Go 2" fanfare - from what I can tell, it's just another package that could've been done 4-5 years ago? Fully backwards compatible, etc. I guess I'm kind of missing the big, sexy, selling point to these and to Go2, especially after Rob Pike's luke-warm (at best) appraisal of the current proposals for the Big Elephant in the Room (*cough* parametric polymorphism *cough*) 
You’re brave. Last time I praised GoLand, some rabid VsCode fanboy almost chewed my face off in these forums. I think paying a few hundred bucks for something that saves you time and frustration is worth it. I’m really sad that people not only expect to pay $0, but want perfection and everything working all the time. If you’re a professional, paying a few hundred bucks is *nothing* in the long run compared to the productivity gains and lack of stress when stuff just ... *works* Why is it bad to reward and keep in business those who do this for us? 
The denial is strong in you lmao
I kinda agree with him - it's his project, he's not forcing anyone to use/comment/contribute. If he wants to be a dick he has 100% right to do so. He already has a bit of a mass of users so I doubt that project is ever going to disappear, but I also think it's pretty common knowledge that the project and the creator are kinda ridiculous so it's not like other projects lose out here. Anyhow, really like others said not even worth your time. Let's be honest - you just got upset cause he bruised your ego, but seriously just move on and you'll be much better off.
Here's an example of what it can do: [https://i.imgur.com/4UrnJlK.gif](https://i.imgur.com/4UrnJlK.gif)
Why this guy still is still around is beyond me. https://www.quora.com/Why-do-so-many-Go-developers-hate-the-IRIS-web-framework http://www.florinpatan.ro/2016/10/why-you-should-not-use-iris-for-your-go.html https://github.com/avelino/awesome-go/pull/1137 https://news.ycombinator.com/item?id=17528793 https://www.reddit.com/r/golang/comments/57w79c/why_you_really_should_stop_using_iris/
&gt;Iris is the fastest community-driven web framework on (THIS) Earth I think this means that any benchmarks have been limited to this earth and doesn't account for other earths.
This is not a good start. Despite the name, this project structure is neither official nor "standard". And unless you're embarking on a very large project, anything like this is completely unnecessary. And even in large projects, some of the practices it encourages I would generously describe as "questionable". I wish people would stop posting and recommending it.
Yeh, not much to say it's just all in one type statement instead of two. For docs. maybe: https://golang.org/doc/effective_go.html#slices
&gt;I have a web app. In it I have a package "model" where I have all the model corresponding to the database tables and "handler" where I keep controllers for each type of a resources: article, commentary, user, etc. Don't do this. &gt;I was told that I should better structure it such a way that I have a package "article" where I keep the model "Article" and the controller "Article". And package "User" and I have all related to User - the model and controller, helpers, etc. And so on, on so forth. This is the right idea, but probably too granular. You should split your packages on a feature or business logic level. So in your case, an Article and User are concepts of the business logic, but a "model" or a "handler" is not. In short, you should aim to make packages encapsulate particular parts of your business logic, and name them accordingly. Exactly how you decide to split your packages is a different story, however. Automatically splitting each type into its own package is not the best way - so having an "article" package that contains the "Article" type and related functions may be too granular - it may be more appropriate to have a "content" package which contains Article and Post together, for example.
You're confusing me for OP. See above: &gt; Honestly, I didn't believe it was that serious. Even if I had no reason to doubt the people I heard it from. It felt kinda crazy, that someone acts this way.
&gt; he lacks the decency to be the maintainer of a plastic cactus, let alone an open source community. How's this in line with the code of conduct? "Be thoughtful in how you communicate. Don't be destructive or inflammatory." You can shine a light on the issue without all the melodrama, is what I'm saying.
&gt; I've listed facts in my post I'm talking about the melodrama that's been added in addition to the facts, ex.: &gt; Honestly, I didn't believe it was that serious. Even if I had no reason to doubt the people I heard it from. It felt kinda crazy, that someone acts this way. Adding such dramatic flair to the story turns this from a serious issue into a soap opera. And I can't take a soap opera seriously.
In one case (pointer receiver) it will affect the value pointed to. And in the other it will affect the copy you made. You seems to get that part. But when storing the method you also store the receiver. So in one case the pointer is stored and in the other the copy to the value under the pointer is. Here another way of writing your snippet, which make the copy part clearer. https://play.golang.org/p/RR1Y_0-rXTI
\&gt; Maybe this is just me, but in all my years of programming in Go I've never ... wish had some decent number literals &amp;#x200B; Have you ever had them before? I had them in Perl when I was using that 20+ years ago and I've missed them in every language I've used since then.
Please don't agree with the part where he steals code.
[removed]
We can ignore it, but the problem is it that its target is not us, it's the newbie coming to Go, seeing that big number of github stars which gives them that (fake) sense of trust to invest in it. So it is taking victims this way and IMO the GO community should not ignore this and take action. Just curious, does this qualify for being reported to github to take the repo down? Building up another repo with all those stars will be a pain in the butt for the author. Where is the github repo report button?
some of the teeth options look like nutsacks
&gt; How does one deal with people like this? Don’t. Pretty simple.
What terms has the person violated? GitHub isn’t going to take something down because someone disagreed with and then blocked you.
Stealing the work of others.
It's ok to disagree and it's ok to say you don't like it and that you prefer something else. It does capture many common project structure patterns. It's kind of hard to argue with that ;-) 
If it’s not a violation of license, you can clone a repo and rewrite the entire history as you please as far as I know. Where in the terms do you see it? https://help.github.com/en/articles/github-terms-of-service#c-acceptable-use
Are those tags used for anything other than serializing/deserializing? I mean, I've seen such annotation used to marshal and unmarshal both JSON and YAML. Does anything else use them?
Github you said? The company that was bought by MS?
We’re talking about GitHub, yes. What does MS have to do with it?
If you are finding alternative, I recommend [Gin](https://github.com/gin-gonic/gin) or [Echo](https://github.com/labstack/echo), or if you prefer MVC web framework instead of RESTful, try [Beego](https://github.com/astaxie/beego).
Thanks guys. Those are good but I’m really looking for cheapest AWS services for my purpose 
It’s not like your project is going to lose million dollars! Hobby projects are what they are, hobbies. It gets you thinking right, outright everything you learned into a product that amuses/helps you! Never be scared of any programming languages. Get your feet dirty, things are meant to be broken at times. That how you learn! Good luck.
I did not know you could change the titles and history, this is pretty bad.
&gt;The Iris owner is a known hack. Not to the eyes of his potential employers and the rest of the world.
&gt;It’s scummy, but it’s not a violation. &amp;#x200B;
You think Microsoft's acquisition of Github is scummy? Is that your point? I literally do not know what you're trying to say.
I agree with Jack's explanation. If it doesn't make enough sense, here's how I'd explain it: The misunderstanding is in the function pointers. These aren't ordinary function pointers. They are [method values](https://golang.org/ref/spec#Method_values). At the target of the pointer router.Func\[AE\] are (often dynamically allocated) little (function,arg) pairs which restore the saved target (the \[\*\]ServerAPI) of the method value and call the method. In other words these are closures, closing over the \[\*\]ServerAPI object. In truth, go 1.12.1 is taking my example code and constructing a "-fm" variant of the methods specifically to call them as closures. That might be a compiler optimizations since the methods are so short, I don't know. Here's a simpler example which shows this. [https://play.golang.org/p/GESPbawTVKI](https://play.golang.org/p/GESPbawTVKI) (ignore the \`go vet\` warning. In this case I do intend to print the function pointer). If you can read assembly, try the output of the go compiler (\`go build -gcflags=-S ...) or the output of \`objdump -d -S\` and look at what the function pointers end up calling. 
Are you trying to meme or is this really how you think?
Oh, that explains why I'm not blocked on github now
A lot of people never need them, so many will not care, but it also doesn't increase the complexity of syntax, so for those that use them, they get a great benefit while others get no burden from it. To me, anything to invite in more types of specialists without losing anything is a fantastic gain. Fanfare is being avoided because we want Go to be better without breaking code, so this error approach is great too. Generics are exactly that--an elephant. That discussion is bigger than this thread and certainly bigger than 1.13.
I made an issue explaining how his benchmarks were fakes a year+ ago because he was force caching the benchmarks and got blocked. 
I have [modified your example to use explicit reciever currying](https://play.golang.org/p/XgYQLfuC9-D). This might clear things up.
... why would I not? Go is extremely well engineered, and Ken is a personal hero of mine who literally created the C family (pretty much every heavily used language) and Unix (Linux, MacOS, the BSDs... the list goes on literally forever) families. He literally won the nobel prize of computer science. Go is clearly a reflection of the Unix philosophy of well crafted, focused tools. It's the hacker mindset incarnate. The only issue I have with Go is that I'm too dumb to ever appreciate all it has to offer. &amp;#x200B; So yes, I do feel that way about Go. The upgrade to Go 2 just illustrates once again that Go detractors have no idea what they're talking about. Go is already a near perfect language, and it's slowly getting even better.
Good manual. But skipped the way via '.netrc' with http credentials
Kataras is that you?
Well, let me point to a couple of things: \- It's a win-win situation for the Golang community we have multiple newsletters to choose from. It's better than a monopoly, like for example a lifetime long reign for... let me check... Cooper Press. \- I'm just a content consumer within this whole. The thing with consumers is that they can have strong opinions and can bash every brand they like, if they feel it's justified and think another one is doing a better job. \- From a 'branding' perspective, it's not that nice if a publisher is trying to bash another one. Not only by trying to bring down Golang Ninjas newsletter (and its curator) in this thread here, but also as I noticed, by stirring up the customers from your weekly to protest against the 'outrageous' things said here. You probably never heard about a gentlemen's agreement on vendor level. Maybe you don't know because you are used to a monopoly situation. But I can tell you that it would be pretty weird to see Microsoft sending people to the streets to oppose to Apple-fanboys. Or better said, Microsoft sending people to oppose to Linux, because Golang Ninja is non-profit. \- Although I'm not quite convinced, I like to believe you when you say you copy the URL's from the original blogs. And holy moly, you say you always create your own written descriptions when introducing a blog. Wow! Pullitzer prize stuff, that is. But in the meantime you seem to miss most of the quality content out there. Well sorry, I'm speaking like a consumer again. I shouldn't do that, because otherwise the one and only Peter Cooper, with its developer media conglomerate, will come after you.
I reply myself, if someone find it useful. It's solved with replace directive in go.mod file. It can replace module dependency with local filesystem path. Source here: [https://github.com/golang/go/wiki/Modules#when-should-i-use-the-replace-directive](https://github.com/golang/go/wiki/Modules#when-should-i-use-the-replace-directive)
r/foundthekataras
Well, it is a violation of his license it seems. Having said that, all the drama about it seems very exaggerated.
Since there is no actual rule, people can say whatever they like, and that is the same for you. You should split things up the way you feel comfortable with. Since the human brain needs to categorize, we need structure, and as long as your structure provides that, it's okay. I like mine ;-) and it's perhaps useful for you too. I have datalayer as a root package, where inside you will find models, repositories, queries and more that connects the application to the database. I use models instead of model, since models hold more than one model. Of course you can design a completely different structure, and as long as it is a understandable one, everybody is happy. (more roads lead to Rome)
I don't know if it is a lot of code, but you good make an ast visitor walker, look inside the body of an if-statement to see if there is an error-wrap inside. if so, check if the if statement is not a err related check. those situations are the one you need to investigate by hand.
I wish I had that kind of git skills... I barely know more than the basics
It captures *some* common practices, but a lot of the things it recommends are not common, and therefore not "standard". And it's still massive overkill for anything other than very large projects (many of which are often split into multiple repos anyway). So my point is that it's a bad place to start - it encourages an unnecessarily complicated directory structure from the outset, and many of things it recommends are not "common" or "standard", and some of them are just plain bad. And judging by how many times I find myself writing comments similar to this, clearly the "standard-golang" name is making people take a lot more notice in it than they should.
When, or when not. There is no how. Much to learn you have, ready to face Vader, you are not.
Yes
Are you not writing bug free software?
Features (Alpha v0.0.0) * Search movies from IMDB and RottenTomatoes (without API key) * Search magnet links from 1337.x. [LEGAL\_DISCLAIMER](https://github.com/Dentrax/GMDB/blob/master/LEGAL_DISCLAIMER.md) * Watch the movie Trailers with MPV that fetched from IMDB * Play the torrent magnet links directly (peerflix) (via MPD deamon) * Take the personal notes for the movies * Personal movie list (Watch Later, Movies Like) * AI Learning for your Movies list (SOON) * Terminal compatible colorful output * Import your movie data from your Netflix data [Learn More](https://www.netflix.com/viewingactivity) * Store your datas in SQLite Database * Local Movie Database with SQLite Demo: [https://asciinema.org/a/tm0T7fssB8XCSal9ll3YdoVtw](https://asciinema.org/a/tm0T7fssB8XCSal9ll3YdoVtw) P.S: I don't know if it's legal to do Torrent site scraper or not. Is there any information on this torrent site scaper topic? In that case I can remove the torrent search &amp; instant watch feature
Awesome.
Ty, nice to hear!
Re-read my question
It's not hard. Once you have the proper permissions, you can do anything easily.
I agree. Newbie can choice based on stars. 
Really cool !
What did it say? The fact that it was deleted says a lot already but im curious
"Still have no idea who you are, sorry." Do you even know what anonymity means?
It’s poor English with bad punctuation but he actually means that because they are just routers, they aren’t web frameworks, which is a fair statement. Routers aren’t what your average DEV would consider a full fledged web framework, but just a single component of one.
https://de.wikipedia.org/wiki/Streisand-Effekt
What does it do? Nobody is going to click the link, so tell us what you're looking for. 
&gt; Go is extremely well engineered lol no generics
Since it looks pretty official, I kind of wonder if there are plans to use it for google cloud build. One of the complaints I have about cloud build is that pulling custom build steps takes way more time than they execute (sometimes).
My bad, I want this https://github.com/fkling/JSNetworkX type package if available in golang
Not just titles and history, on github the repo owner can even change the content of issue messages. Which he has done on several occasions in the past to spin a story a different way.
I’d be a bit concerned if this behavior happened when someone tried to report a vulnerability. 
Looks great! Also the main function appears to be missing its closing bracket.
Very nice! I like it is a combination of several modules. Nice job! Regarding your scraping question I guess it could depend on country but from my knowledge it is perfectly legal to scan public websites. Search engines do the same. I looked a bit at your scraper and I would suggest to use some library or webdriver for selecting the elements. It is more maintainable to use XPath than direct Descendents of HTML elements and also makes your code way shorter and more readable. I built scraper ( and downloader) only in Java, but it is interesting project that I may try in Go too. Btw if you create common interface for all scrapers essentially IMDB or rotten tomatoes will work same as torrent one or even file server search with download. Something for future development maybe. :-) 
This is awesome! Congrats to David and Kate! I might use this for my wedding invites....
You mean like nginx, traefik, contour, a dozen others? Can you explain why none of the existing projects are adequate, and what sets this one apart?
Might want to link to the english version xD
Let me explain better what I was trying to say. Those projects are amazing, they're solving real problems, are scalable, fast and so on. The thing is, there is very few collaboration between then. Most of these servers are config based, so, you can do as much as the config enables you to do, but what if you need something different? The whole idea of PipeHub is to enable this kind of scenarios. For example, with PipeHub you could implement a channel that processes a stream of IP or CIDR, whenever something goes into the channel you can automatically start to block those requests. That channel can be anything, like a Kafka, Redis or even an in-memory implementation. I don't know deeply traefik, haproxy, and the others, but usually, this kind of change is not possible. There are cases when these features can be programmable, Nginx is an example. You can extend it with Lua, but have you worked with complex Nginx config files? It's kinda hard to maintain after a while and even harder to test it. Talking about tests bring us to another topic, unit testing and collaboration. Pipe is the thing used to do these customizations at PipeHub, it's a plain Go project. And being a Go project enable much more things like all the linter, fuzzers and unit testing tools available to test the pipe before it gets into production, and enable more collaboration from the dev team as it's a tool they are familiarized with, the Go language. Speed is a very good topic too. HAProxy, Nginx and Varnish are blazing fast, they really are. But the overhead of parsing the HTTP request over and over again isn't low. HAProxy receives the request, does all the parsing and send it to Nginx, that does the same thing and send it to Varnish, that does the same thing and hit the origin server. If everything was at the same process, all this parsing wouldn't be needed, the request is parsed just one time and after that is plain Go code doing everything. Also, there are several deployment layouts for PipeHub. It could be deployed as a sidecar augmenting the real service by providing other features like authentication and cache. It can be deployed in front of all your servers to do load balance, doing shadow traffic, analyzing the traffic at the background and choosing actions to take. Have I answered your question?
 type Thing []struct {...} creates a named type Thing to be a slice of anonymous structs type Thing struct {...} type ThingSlice []Thing creates a named type Thing as a struct and named type ThingSlice as a slice of Things type Thing struct {...} var thing []Thing creates named type Thing as a struct and allocates thing as a slice containing structs of type Thing 
Thank you for your feed-back. Regarding torrent scraping question, I thought so, too. But I'm still thinking of preparing a disclaimer file. Currently, I am using [goquery](https://github.com/PuerkitoBio/goquery). I didn't have any problems about goquery, works perfectly. Actually, this is my first scraper project. I have never heard of that XPath. I didn't think so much because this project is free-time fast project. I could recommend it to you. It can be fun to fetch anything from a website. Maybe its scraping fetishsm. Thanks for the idea. ;) &amp;#x200B; &amp;#x200B;
Thank you!
&gt; But why we need to run all these servers? To keep the code simple. &gt; Wouldn't be better having all this logic into a single server? No.
No? Why? It helps if you can argue for your viewpoint so others can make an opinion on it as well. Could make an interesting discussion and people could perhaps learn something ^^,
I think it 8s being developed for the Go builders used by the Go project itself. It's a very recent idea/creation so I don't think it is being used anywhere as yet.
Thanks for assuming I'm dumber than a rock, really helpful. As if it matters if your name were Anders or John Jacob Jingelheimerschmidt.
Cool project! I'm curious how the number changes if you use pipelining, like -P 8, as option in the benchmark. It is vital to many Redis apps to use pipelining to get the max per core. Another Q, Is also kache using a single CPU core in your benchmarks? With what persistence options? Thanks and have fun with your project, IMHO rewriting an existing tool is one of the best ways to master a new language, learn and invent new things.
I'd go with [this](https://www.google.com/search?q=golang+graphviz) then.
goddamn it...never thought you would reply :o 
I feel like I'm dreaming...thank you for kind response. &amp;#x200B; I've not tested about single CPU core. I just ran it normally on every setup.
Cool project,how did you learn go lang?
take a look at [https://github.com/MontFerret/ferret](https://github.com/MontFerret/ferret)
iirc it's due to fmt not using buffering: [https://groups.google.com/forum/#!msg/golang-nuts/dAfCb2ybxJs/Twzfh\_sjIX4J](https://groups.google.com/forum/#!msg/golang-nuts/dAfCb2ybxJs/Twzfh_sjIX4J)
Hi I tried it with -P 8 and results were like follows(tested on Ubuntu 18.04, amd64, i7 7th gen, 16GiB) &amp;#x200B; For redis =&gt; `redis-benchmark -t ping,incr,decr,set,get --csv -P 8` "PING\_INLINE","328947.38" "PING\_BULK","854700.88" "SET","793650.75" "GET","892857.12" "INCR","862069.00" &amp;#x200B; For kache =&gt; `redis-benchmark -t ping,incr,decr,set,get --csv -P 8 -p 7088` "PING\_INLINE","227790.42" "PING\_BULK","381679.41" "SET","330033.00" "GET","371747.22" "INCR","309597.50" &amp;#x200B; It seems when pipelined kache reaches a huge performance hit. &amp;#x200B; Yes I started kache to learn golang :) and learnt a lot about developing this far
Is this the Go version of pyenv? Just getting started with Go after years of Python. Hope Go does good with Web and one off scripts alike.
Thanks, exactly what I wanted
Thanks for that project, but it looks like a bit complex for than goquery, isn't that? :)
Thanks! It's a bit odd both the implementations have this big drop for the inline ping. I'll give it a look. With pipelining basically a lot less time is spent in the syscalls doing an advantage to the implementation that is faster at manipulating the data structures, yet kache numbers looks good enough to me. Thanks!
And from browsing some of the comments on that forum, golang leans heavily on reflections to ensure that you're parsing what you're expecting to parse, which is far slower than the way that the c version of the scan\* functions worked (they just assumed you were getting what you asked for) but doesn't lead to segfaults when the data doesn't match your expectations.
where can i learn more about pipelining? I would like give a try implementing that on kache :) &amp;#x200B; Also thanks for replying , I am really happy about that :) and I'm still surprised :) &amp;#x200B; &amp;#x200B;
I think you already support pipelining because of the way your server is written! And that's good. Google for "Redis pipelining" and you'll find immediately the relevant documents. Happy to reply :-) have fun coding Kache.
It would be great if i could get more advice from you :) &amp;#x200B;
Initially started with tour of go :)
What's that? XD
I don't fully understand the example in the readme. It'd probably make more sense to the reader with real code that actually compiles. 
At first I thought this was silly. Actually looking at it, probably be pretty useful. I like that you close over t. I had that about require.Equal(t,....).
I like the idea and can see it working in modern deployment scenarios. It definitely takes away a lot of overhead but it must still be hard to outperform a similar haproxy-varnish-nginx chain (assuming feature and stability parity).
Reading the other comment threads I now understand that the issue is about errors.Wrap(err, ...), which reads `err` although `err` is not used in the `if` condition. I now understand your initial question (sorry, the question could have been obvious to me as I use pkg/errors quite a lot), and yes, it would be nice if a linter checks for coding glitches of this kind. Put into informal words, the linter could check this: "If the `if` condition does not refer to any variable of type `error`, the code inside the `if` block should not access any existing variable of type `error`." I cannot tell if there is already a linter that does such a check (BTW, a good starting point for searching for linters is the [list of supported linters for golangci-lint](https://github.com/golangci/golangci-lint#supported-linters)), but an experienced linter author should have no problems implementing this.
The legal disclaimer link is 404'ing
[removed]
Because small, narrowly focused code bases tend to perform better, remain secure, and asymptotically approach stability. The ONLY advantage in a single code base handling multiple functions (in this context) is additional CPU and request latency caused by multiple parsing and validations of the HTTP requests. But CPU capacity is incredibly plentiful and, therefore, incredibly inexpensive and the additional request latency is minimal compared to typical internet propagation latency — particularly so if the chain of servers reside on each server or instance, entirely eliminating today’s (admittedly) minimal physical network latencies. Finally, a system like this is necessarily going to limit your choice dramatically at each layer. HTTP(S) is built atop the internet messaging protocol (RFC 759) and, as such, is an tremendous boon to interoperability. What OP is proposing is abandoning a massive advantage for dubious benefit, IMHO. 
Its the file extension. You used my when it is MD, besides that the actual document is blank
Why have the pool? Grpc connections are http2 based and can have multiple requests going over them concurrently. If you do want a pool you should implement it in the grpc resolver/picker components and that would probably be a bit faster than grabbing a connection from the pool each time. (it holds a slice with pointers to each connector and picks which one to use based on internal stuff.) &amp;#x200B; Have you got pprof turned on and done a trace while doing your performance test?
If you’re talking about github.com/stretchr/testify/require, you can do: require := require.New(t) require.Equal(“foo”, “bar”)
what's it got over `gocheck`?
Fixed, actually there is no *legal disclaimer*. Currently its a temp file. I'll update it as soon as possible.
If you can find the page via a search engine and you're not disrupting access or control of the site or it's parts then you should be fine. 
Nothing "over", it's just way simpler and sufficient for my use case.
Wow, I think I need to write regexes to do this. I hate the ts.
This can help if you want to do something like that across a large codebase: https://github.com/facebook/codemod I’m currently working on some to replace common `t.Fatalf` patterns with testify.
Thanks, I changed that!
Above arguments aside. This is awesome. I work with these types of appliances a lot and I know how work this must have taken. Fucking +1 I also will be trying this out 
Much clearer to me now, thanks
I didn’t know that. Thank you. 
Also one thing I think would be invaluable is a visual diagram of like traffic flows through pipehub.vs anything else. I am a network infrastructure guy by day and the most valuable thing to me is a visual understanding when I do bake offs with vendors and their advantages vs disadvantages. 
Since German and English are foreign languages for me, sometimes I can't realize. Thank you for the information. 
Thanks :) Yes, it gonna be pretty hard, but it's possible with the community help. The first thing I'll be doing after the core is stable enough is to create a package to do HTTP cache. The package gonna expose options to change the storage and the cache behavior, something like the Varnish VCL. After that gonna go after the others: load balancer, routing, etc...
Thanks. If you have any doubt with the project, let me know.
Running in the same process doesn't make the code bigger or unsafer, is how you organize the code that does it. And this is what I'm pretending to do, create small and contained packages that do only one thing and do it very well. Take Varnish as an example, all that logic could be abstracted into a package, the same applies to HAProxy and others. I'm not minimizing what others accomplished, just trying to view the situation from a new perspective. Also, in a microservice environment, latency is a very important metric. When you have a mesh of services calling each other and all going through central servers like Nginx or a Kong gateway, all those overhead milliseconds count at the user-perceived latency. And you're forgetting the programmability of the solution, that is the biggest bonus of this project. You can have your infrastructure running and when you detect that the servers are getting overwhelmed, you can dynamically change the load balance policy to send bot requests to a dedicated cluster so real users are not affected by the extra traffic. This is just an example that I thought now. And I'm not moving anything against HTTP principles, is everything the same, just breaking up with service boundary and bringing programmability into the solution. Anyway, thanks for your comment, I'm really looking for opinions.
Indeed is ver important, gonna do it soon.
Us emacs users just sit back in the rocking chair and chuckle while puffing on our pipes.
That's a really straightforward and simple code, easy to follow, nice formatting. Unfortunately a draw doesn't end the program, even if there's no cell left. Also, if there's no way to win anymore, the program should exit. Unit tests would also be nice for exactly this case :)
Ohh, you are right, Thanks for the note, somehow I completely overlooked the `draw` case. I am already thinking of the best way to check if there's no way to win anymore. I will add some unit tests :)
How does this compare to caddy?
I'm a huge fan of ginkgo and gomega, but I liked this lib a lot! Congrats on the team (or person) maintaining it...
"Micro$soft bad. Micro$soft evil". Party like it's 2003 🎉🥳
That's a good question. Caddy may be the server that PipeHub looks the most. For me, the main difference is how they are positioned. Caddy took an Nginx like approach, so it has the same "problems" that Nginx has. When you have a very large Nginx/Caddy config file, you ended up with two main problems. First, you're limited by that the config file can provide, more complex cases can't be covered. Second, it's hard to validate that the config file is correct. With PipeHub all the traffic goes into a pipe, that is a Go-based code that you control. Anything can be done, including behavior like Caddy/Nginx, you have the choice to choose the best approach for your project. By no means, I'm saying that PipeHub absolutely better then this other server, it's just an alternative for those who need something more customizable.
&gt; Running in the same process doesn't make the code bigger or unsafer I didn’t say it did. Single responsibility principle.
It was never just about the history rewriting. I don't know what the current state is, but certainly in the past Iris included code from many different projects. Nothing wrong with that as such, but it was mentioned nowhere, and for all intents and purposes it seemed like the Iris author had written it. This is a clear violation of pretty much all open source licenses, as they all require you to retain the original copyright notice and a copy of the license text. It is both unethical and illegal to copy the code of others and pretend you wrote it. At first I thought it might be plausible that the author was naïve and did so by accident, but after it was pointed out that this was a license violation the author became extremely defensive and rude. A cursory glance at their router seems like it's no longer based on httprouter, or at least has changed significantly since then, but it's still claimed that there is only one author in the LICENSE and AUTHORS file. Perhaps it's true now – I do not care enough to investigate in-depth right now – but it certainly wasn't in the past. The git rewriting is annoying, weird, unethical, and *maybe* illegal, but was never the essence of the problem.
 log.Fatalf("%v: should have different values (value: '%v')\n", t.Test.Name(), s) It seems to be that adding the test name is rather redundant? go test will already do that for you. Furthermore, it's not all that helpful in actually diagnosing the issue if you can't see what the actual output was, and `%v` will hide certain stuff like unprintable characters. I'm a big fan of aligning output: t.Errorf("wrong output\ngot: %q\nwant: %q", got, want) Which makes it so much easier to see the problem once tests start failing. I'm also not sure if I understand why you're using `log.Fatal()` instead of `t.Fatal()` or `t.Error()` from `testing.T`?
For what reason do you need a legal disclaimer? What could it possibly tell you that you don't know? You clearly seem to understand the dubious legality of torrenting so what, you're just trying to nitpick for the sake of nitpicking? I'm sure you're fun at parties. Very cool project OP, sorry people like this get hung up on bullshit like this instead of just looking at it for what it is, a cool hobby project. 
In case you’re curious to compare to another implementation of tic-tac-toe in Go, see https://github.com/shurcooL/tic-tac-toe.
&gt; With PipeHub all the traffic goes into a pipe, that is a Go-based code that you control. Anything can be done, including behavior like Caddy/Nginx, you have the choice to choose the best approach for your project. Caddy has [plugins to do this](https://github.com/mholt/caddy/wiki/Extending-Caddy). You have to compile them into the server though. Does PipeHub use runtime plugins or something different?
The project seems awesome. Congrats! Will be installing it later. A subtitles feature.would be a great addition.
&gt;I guess I'm kind of missing the big, sexy, selling point to these and to Go2 Languages designers should not optimize for "sexy." Go is already very good; it will continue to be refined, but it doesn't need an overhaul.
As I understand it, everything inside `golang.org/x/tools/cmd/...` is experimental. &gt; Package godoc is a work-in-progress (2013-07-17) package to begin splitting up the godoc binary into multiple pieces. This package comment will evolve over time as this package splits into smaller pieces. Ref: https://godoc.org/golang.org/x/tools/godoc If the experiment succeeds _(aka. the community accepts it)_ it **could** get merged into the `go` tool as a subcommand. However, as senior developer would immediately understand the important of _“separation of concerns”_. Why merge a _—possibly—_ big, complex, or irrelevant piece of code into a much bigger project if it works okay as a standalone tool? Also read **“go doc vs. godoc, by Rob Pike”** [1]. And this Reddit post from Mar 13, 2018 [2] asking a similar question. [1] https://groups.google.com/forum/#!topic/golang-dev/tqsatm29V9E [2] https://www.reddit.com/r/golang/comments/845ncx/go_doc_vs_godoc/
Haha, you are amazing) Cool words. Thanks you, I will try my best
Simple and efficient. Random thing I noticed looking at the code: t.board[i] = append(t.board[i], make([]int8, t.size)...) Can just be t.board[i] = make([]int8, t.size)
No, things in x/exp are expiramental. 
I think the x is "extra", rather than "experimental".
I don't understand your point. For things like `go fmt` and `go build` etc, go is the name of the binary, and `fmt` or `build` is the argument. `godoc` is the name of the binary itself. What is inconsistent here ? You want the binary name itself to have a space ? 
0/10 if you aren't going to hardcode every case then why even bother
There not all experimental; Good example is the bcrypt package, which was in the main package pre Go 1. It's in x/ so they can easily make changes (maybe for security patches) without being forced to be backward compatible with Go 1. Everything in the x sub-repository are just developed under looser compatibility requirements.
Hi. How you doin, thanks for being a flaming cunt. For your information am I a fellow developer and was merely informing the OP, another developer if you haven't realized, that a link that he has posted is broken. I never mentioned that he needed it, just that the one that he has linked is broken and blank. I honestly don't give two shits if he actually populates it with anything. &amp;#x200B; Thanks, Come again mate, cheers
Nice, well just letting you know that it was broken. Sweet app btw, I don't know if Ill get around to using it....but if I ever do Ill give feedback if possible
Couple of things right of the bat. 1. Tell us what it does. There is literally no context, and I doubt many people are particularly interested in finding out on their own. 2. Link to it. A title in a reddit self post is not an adequate link. Right now you have to type or copy paste at best to get to the code.
Unfortunately for your argument, not everyone and their dog is "writing servers" in Go either.
&gt; I like caddy the software but I don't like the developer. Go on... I'm listening.
Thanks for the notes! It's so easy for me to get lost in the details on solo endeavours like this, and lose perspective on what (if any) context is available/apparent when looking in from the outside. I've linked the repo itself and the documentation file that will accompany the API, and I hope that helps. 
Tis a form of copyright infringement
Thank you! I will definitely check it out today :)
Cool project, really. I tweeted on @golangch
Right, good catch. Thank you for the note :)
What is “poorly”? 
I heard you eat babies.
Thanks for the feedback: I'll update to use \`t.Error/Fatal\` and use alignment. I like to have the test name printed on the same line, it makes it easier to parse for my mind :) &amp;#x200B;
Thank you. ❤️
I will be waiting for your feedback. :)
That idea came to my friend's mind after I finished the project. But I am busy these days, but I will add that feature as soon as possible. 
Hello! I think testing is what you are looking for. How much pointless or annoying it is to copy paste request or response that will change depends on how mature and stable is the API you depends from. I find myself comfortable to use the httptest package [https://golang.org/pkg/net/http/httptest/](https://golang.org/pkg/net/http/httptest/) to mock an http server. It makes me faster developing my application because I can test the manipulation the client does just running test cases. More important to guarantee that client and server still agree on the same interface are integration tests. There are various way to do it. If you have a staging environment you can replace the httptest mock and point your tests to a staging environment. Even better you can spin up runtime a clean server for every test and runs your assertion on a clean environment. To do that I uses a library that leverage docker containers [https://github.com/testcontainers/testcontainer-go](https://github.com/testcontainers/testcontainer-go) . &amp;#x200B; In any case, it can look useless or not cost effective to do it but when a server will unexpectedly break compatibility by mistake or by purpose a red test that will show you where it broke won't be pointless at all!
you can have a subpackage named main to use your main package, and probably gitignore it. 
You could write up a sample program that utilizes the library code. When you compile that and you have errors in your library code the compiler will log errors of the library code. This also allows you to know what usage code would look like so you can design your library to be as usable as possible. You could also just write some bunk test that just verifies you get anything at all. Then t.Logf some stuff you would want to inspect. Biggest suggestion is don't try to go with an opinion ated way about it. My suggestion is to just not worry and go with the flow. Be mindful of whether stuff is working out and don't stress. You're smart enough
There's a convention in go's community to have a 'cmd' directory for all your main packages. I say packages in plural form because in this directory you could have various sub-directories for different variants of builds (e.g. production, testing, development, etc.). root/ \- cmd/ \- - production/ \- - - main.go \- - testing/ \- - - main.go \- your-lib \- - etc. 
Nice, hope someone recreates beanstalkd one of these days. As simple, yeah more QoL. Might try doing it myself one day.
How is it holding up memory-wise? Redis is quite amazing in that regard, aside from being very fast. And what are your thoughts on lua scripting? Something that can be very useful in Redis.
if you're interested in this stuff - you should check out bit-boards, it's a neat way of representing simple boards, but it has it's limits [https://en.wikipedia.org/wiki/Bitboard](https://en.wikipedia.org/wiki/Bitboard)
Does it support `bash`/`zsh` autocomplete?
It currently uses a map data structure to hold data. I think to add some improvements on it. You can find relevant files [here](https://github.com/kasvith/kache/blob/master/internal/db) &amp;#x200B; I would love to add lua scripting, But we have a long way to go before that :) &amp;#x200B; Thanks for feedback :)
It's a great exp :)
I think the last part about the ability to attach functions on the slice type is something that can be pretty cool. I made a small playground example for anybody who wants a small executable example: [https://play.golang.org/p/j2TivDg6uM-](https://play.golang.org/p/j2TivDg6uM-)
I had a brain cramp, thanks for responding :)
thanks for the links and information!
https://github.com/gocolly/colly
Yep, that's the point, if you look closer, it's really a middleware, even the way it was programmed. But so are the others, HAProxy, Nginx, everything is a middleware. Single responsibility principle doesn't impose any rule of how your program need's to be. I'm not proposing anything new, just moving from a config oriented paradigm to program based paradigm which allows more integration between the parts.
PipeHub plugins are compiled with the application too. With Caddy you need to edit a file and add your import path, a init function on your code will do the rest of the integration. With PipeHub, this is done with templates that generate the code needed to do the integration. About the Caddy plugins, I think is possible to create a plugin that does the same thing as I'm trying to do with PipeHub. But I still keep my point that Caddy is positioned to "compete" with Nginx like applications. I'm proposing an alternative that focuses itself on the programmability of the stack for solutions that need this kind of requirement. And don't say that about Matt, he looks like a very good person. For sure I'll be using his project certmagic with PipeHub.
From \`internal/srv/tcp.go\` it seems like unlike the original redis, kache is not mono-threaded? That's a major enhancement!
redis uses an event loop. kache uses goroutines :) 
In each iteration of he loop you're creating a new function handler. However they all acesss one `route` variable. It's value is different in each call to `HandleFunc`, so you generate two different routes. However the handlers all see the last value of the variable. One way to do what you were trying to is: for _, route := range []string{"/", "/test"} { route := route http.HandleFunc(route, func(w http.ResponseWriter, r *http.Request) { fmt.Fprint(w, "Hello World from "+route) }) }
Thanks! However, I'm now facing another issue, the handler is called once and then the 1st handler that was is called again. That happens each request. I'm digging, is this something common? I found it only happens in TLS. &amp;#x200B; http.HandleFunc("/", func(w http.ResponseWriter, req *http.Request) { fmt.Printf("Handling /\n") fmt.Fprintf(w, "/") }) http.HandleFunc("/about", func(w http.ResponseWriter, req *http.Request) { fmt.Printf("Handling /about\n") fmt.Fprintf(w, "/about") }) http.ListenAndServeTLS(":8080", "C:/Cervol/certificate/server.cert", "C:/Cervol/certificate/server.key", nil) When I visit /about I get: &amp;#x200B; Handling /about Handling /
Here's the tour of Go section for concurrency. It's threading, but easy-mode. :) https://tour.golang.org/concurrency/1
The simpler explanation is that typing \`if err != nil\` over and over is that particular malware dev's sexual fetish.
I'm not sure what's going on in this case. Are you sure you've only visited one of the routes? Also: your code blocks in your comment/post look broken. Not sure why that happens, but I think having a four-space indent before each line should make that look fine for everyone.
Can you try that out please? [https://codeshare.io/G6MxyY](https://codeshare.io/G6MxyY) &amp;#x200B; I am really having some pain with it. Visiting any route prints 2 lines. 1 with the correct handler and the other with the / handler (i guess it's because it was the first added...) &amp;#x200B; Try visiting [https://localhost:8080/about](https://localhost:8080/about) 
What I was aiming at specifically, is how does it do RAM-wise after handling a lot of transactions/commands? Go isn't always the greatest with handling garbage collection. By the way, is is possible your SetExpire method doesn't entirely do what it should do? seems like it always returns "false".
Yes i had the same question about garbage collection. As for now maps does not release memory as I remember. We will have to create a custom map structure or similar to tackle the problem. &amp;#x200B; Ah you spotted a bug, thanks. It would be awesome if you could raise an issue and PR if you can :) Recently changed the command execution workflow and these were the stuffs I missed during the transition :)
So aparently, using port 8080 causes this. Changing port makes it work. Do you think it's a windows issue or what? that is strange af.
Also worth pointing out it’s how to make a slice of structs sortable https://golang.org/pkg/sort/#Interface But luckily not the only way.
Very comprehensive! Did you consider embedding the `sync.RWMutex` like so? type ItemQueue struct { items []Item sync.RWMutex } This makes it possible to access the lock and unlock methods directly on `ItemQueue`, at which point it implements all of the same interfaces
maybe they just really hate generics 
Did some memory evaluation modifying some existing script [https://play.golang.org/p/QmPBbePGnE9](https://play.golang.org/p/QmPBbePGnE9) &amp;#x200B; As we can see, runtime.GC does the job. But we can't free memory as redis do using free(\*ptr) What we can do is following two strategies * Active cleaning : When kache knows that around 1000 keys were deleted it will schedule a garbage collection in background * Passive cleaning: Kache normally free memory from system per 5min(we need to do some research about optimal time)
100% agree with this post. Creating test files gives you a clear idea of how your package's API works, and it can also be used to test coverage of your edge-cases or error handling.
&gt; Unfortunately for your argument, not everyone and their dog is "writing servers" in Go either. /u/raze4daze ahh the smell of pcjs [triggered](https://old.reddit.com/r/programmingcirclejerk/comments/b4rcvc/even_this_malware_dev_prefer_gos_productivity/) by the aforementioned pedantry when faced with a mere hyperbole. Seasonally flocking from basement whenever someone is [wrong](https://xkcd.com/386/) on the internet. You're special one aren't you? Your 1st and 5th most used words on reddit are `people` and `shit`. Some pearls among your most downvoted comments: - **-11** I have a bigger chest than her.... Of course, that might be because I bench 450lbs for 60 reps in under half a minute. http://archive.fo/4SjOo - **-61** Shut the hell up. Don't act all tough, you dumb motherfucker. http://archive.fo/47vWy - **-27** I'm here to fap, not for this. http://archive.fo/YPMpi What surprises me is that managed to get [downvoted in pcj](http://archive.fo/ZuLuc). Quite the achievement. Perhaps not to someone who also frequents subs like [CelebrityFeet](http://archive.fo/WWs7J) and [celebritylegs](http://archive.fo/KRJRo).
hey @limdi, not yet, it will be added but there are some more important features that will come first, like the possibility to add subcommands.
Both libs were created to help Go developers to write command-line interfaces but in different ways. Using Cobra API's you get to define the usage, commands, and flags, and with those, it will generate a fixed help message (and that's it, 0 flexibility). In the other hand, Docli parses a doc string (that you write following some basic rules) into an AST, that it's used to be bind with struct fields - that flexibility comes with a cost, which is losing the type safety.
Gotcha. Thanks!
Gotcha. A long way to go then. Do you make this for vanity or is there an actual need, a pain point behind it which is not solved by cobra? If it's just one or two missing features it might be easier to make a PR for cobra or sth.
Hey, sorry for deleting the original post, I did that so I could publish it again in the morning. &amp;#x200B; Good question! Docli doesn't allow per command flags and args currently, but the next release will add this feature (I'm already working on it), something that right now is a definite disadvantage of Docli if compared with other Go libraries like Cobra. The reason that this feature was kept out of the v1 is the difficulty that was facing to keep the API simple and allow per command flags and args.
I'm so triggered right now. (Bit rich coming from you considering you have negative karma and only two comments. Stop deleting negative comments, it's just Reddit)
Golang Weekly is one of those few newsletters that I always read end-to-end. They are relevant, short and informative, and of high quality, ie. it's obvious that they took the time to write relevant summaries. Good work, and keep it coming! :-)
Recovering deleted post… --- &gt; anyone know how to build this git repo https://github.com/emersion/hydroxide? when I try to build it I get the errors `smtp/smtp.go:352:54: undefined: smtp.User smtp/smtp.go:373:38: undefined: smtp.User` &gt; &gt; submitted by /u/flamethrower20 --- That’s interesting, because `smtp.User` is defined here [1] in the same “smtp” package. 352: func (be *backend) Login(username, password string) (smtp.User, error) { ~~~: […] 370: return &amp;user{c, u, privateKeys, addrs}, nil 371: } Did you clone the repository, and then tried to build it? Or did you execute the recommended command from here [2]? [1] https://github.com/emersion/hydroxide/blob/e6f8149/smtp/smtp.go#L40-L45 [2] https://github.com/emersion/hydroxide/blob/e6f8149/README.md#setup
Have not used Redis (yet), but in terms of resources consumed, performance, etc, how does Kache compare at this point? Would you say you could use this in production instead of Redis at this juncture, or is there a lot more going on with the contributors to enhance it further?
Yes, definitely a long way. I’m not a big fan of the verbosity and boilerplate involved when using Cobra, and I also like Docopt’s idea, the way that you get to define the CLI (through a help message) is really amazing, but Docopt is pretty much death and the code is not really the forkable IMO - that was the perfect excuse to start Docli.
Would the map be able to release the memory if it was storing a pointer to the data instead of the data? That way the pointer could be set to nil and then GC would pick it up 
need to delete it from the map using delete(map, key) In that way the key is properly removed from the map and GC will pick it up on schedule :) You can check [https://www.reddit.com/r/golang/comments/b4ubj6/kache\_v100\_released/ej9s2sg/](https://www.reddit.com/r/golang/comments/b4ubj6/kache_v100_released/ej9s2sg/) comment in above thread for real evaluation on playground
in term of performance you can see my benchmark with redis in [here](https://www.reddit.com/r/golang/comments/b4hau9/benchmarking_kache_a_redis_compatible_inmemory/) It can be used for simple operations like implementing a page counter etc. &amp;#x200B; But it needs a lot of improvements to be used in production.
I got it to work using my usual git clone method and then building instead of using the recommended go get method which did not work but now I am getting this issue https://github.com/emersion/hydroxide/issues/46
Thanks for the reply. I will check back on the project from time to time. Like other replies have said, bit of work ahead before it is a viable replacement for existing options. It would need flag parsing feature parity with other popular flag packages. And it will be interesting to see how you handle the subcommand definitions in this approach. 
[removed]
&gt; I didn't know what my issue here??! &gt; Probably that there isn't enough information here for someone to help. You didn't give any details about your implementation. 
How naive of you thinking educated people care about reddit karma, or the site at all. I'd be more concerned about the contents of what I write if they were this sad. Wrong focus buddy.
Nice tip! thanks for sharing!
It's verbose, maybe. I find usability more interesting.
It’s verbose, that’s a fact, and this fact doesn’t decrease its usability, it’s just one of the reasons behind the decision of creating something new. Don’t you think it’s always good to have more than one choice? 
Did you try reading through [RateLimiting](https://github.com/golang/go/wiki/RateLimiting)? I think using the [rate](https://godoc.org/golang.org/x/time/rate) package might make the code simpler / more perf. Also, I might have tried to design the wrapper types to maintain their original signatures (still be an io.Reader or io.Writer) as that let's you compose them more times. If you didn't want to compose them that way, I might have considered implementing[io.ReaderFrom](https://golang.org/pkg/io/#ReaderFrom) / [io.WriterTo](https://golang.org/pkg/io/#WriterTo) instead, since your current code feels more like it rate-limits 'copying'. Just my 2c though, hope you're having fun with Go!
The throttling isn‘t doing what you intend to do properly. If you read 1000byte and sleep for a second you’ll end up at a timing above 1second. For a small amount it doesn’t matter but if I you want to read 50mb a second you won’t have to sleep for second after the r/w operation because the r/w operation consumes time. A proper way of throttling would be to measuring the time difference and sleep the for the rest of the second.
I had not seen this wiki post or the rate package, I will likely try and refactor the package to implement one of the interfaces you mentioned, I'm aware this isn't quite the best solution to the problem, but I figured I would post my efforts on here to get input. Thanks for the advice!
Great point, I hadn't thought of higher throughput loads and I will be refactoring the package to try and function as you've described. Thanks for the advice!
Nice, I'm working on a "repeat" command that repeats the nth line in the "history" command. For ex you type history, see the command you want to repeat is in 25th line, you do "repeat 25" and it repeats the 25th command you typed.
Great way to get to know the language! Really like the idea!
What is the competition on, usability? It will probably take a long time till it even gets to be an option. It's your time. :)
lmao you sound really mad. I'm just gonna let you be, man. Don't take things so seriously though. It's just Reddit.
Reverse-i-search!
channels?
i dunno, looks like you're the one taking things to serious on the internet from your comment history
I may be missing something... this looks like a blog about data structures in golang... where is the PHP connection?
The problem, as stated, is slightly unclear and could be interpreted a couple different ways. One way of interpreting this is, "how can the called handle() function access data from the entity that set it up". The answer for this would be to use a closure. On mobile, so im not typing one out. The caller can pass an internally defined function that can access insurance variables. 
I just tested the exact same code _(but different SSL certificate)_ and it works just fine. Here’s the output from the web server: $ go run . Starting server at port 8080 Handle for / Handle for /hello Handle for /another And here’s the output of the three HTTP requests: $ curl -i "https://consoletvs.test:8080/" HTTP/2 200 content-type: text/plain; charset=utf-8 content-length: 6 date: Sun, 24 Mar 2019 23:23:59 GMT / Page $ curl -i "https://consoletvs.test:8080/hello" HTTP/2 200 content-type: text/plain; charset=utf-8 content-length: 11 date: Sun, 24 Mar 2019 23:24:04 GMT /hello Page $ curl -i "https://consoletvs.test:8080/another" HTTP/2 200 content-type: text/plain; charset=utf-8 content-length: 13 date: Sun, 24 Mar 2019 23:24:09 GMT /another Page Maybe if you share both “server.crt” and “server.key” I can reproduce the bug.
Sounds interesting. I know this is just an exercise but this can also be done in bash with `!123` where 123 is the line number that history outputs.
I ended up using another mux and worked with the same cert. &amp;#x200B; Files: [https://ufile.io/wlpw1](https://ufile.io/wlpw1) and [https://ufile.io/aco8p](https://ufile.io/aco8p)
If you are just playing around, feel free to learn how you want. But if you want to move forward toward the goal you should look at: https://github.com/ericlagergren/go-coreutils
Might as well take a look at this: [https://repo.cat-v.org/goblin/](https://repo.cat-v.org/goblin/)
That's a genius approach to learning a new language.
Actual git repo. is: https://github.com/uriel/goblin
Nice, this is pretty cute. It's a good exercise for you if you're looking to practice your skills. The project layout is a little annoying IMO, why did you choose that layout? I think a more Go idiomatic approach would be something like: ➜ GoUnix tree . ├── LICENSE ├── README.md └── cmd ├── cat │ └── main.go ├── whoami │ └── main.go └── yes └── main.go 4 directories, 5 files
I did the same thing to learn Go, it was very instructive, I should revisit and see if I can improve them a bit and I’ll take a look at yours OP. https://github.com/peacefixation/go-exercises
[removed]
[removed]
[removed]
Is this what a redditor's comeback looks like? 🤢🤢🤢
I see that this writes every document to a file and also writes on every query. For what size projects would you recommend this as a good candidate vs not? What is the performance like when querying document field values when it has to iterate over large numbers of row value files? 
Check the dec tools in browser for a second request. Most browser will check for a fav icon that may be invoking the handle a second time, and it will be / because it’s the catchall. Hope that helps.
RIP Uriel
I started something similar a while back myself, called it `slimbox` (busy box + go super 'small' binaries). I wanted a single binary though; and was working up to a super minimal shell. I never got too far with it but I've been meaning to get back to it. It was a fantastic learning device. I'd start from scratch though; I've learned so much since I started
Oh, I love to use Go for embedded stuff. but I prefer Periph instead of Gobot. With Perith I could male a simple toy project to control the LED matrix on the Sense Hat. Check this out. https://github.com/bus710/matrix 
That is a good question. It does write once per query so that we can maintain consistent keys if records are deleted. The performance for querying on a single exact value is a O(1) lookup of the hashed value. It then reads the lines of that file as a row key. Per key it has to read a row file. The complexity comes from the result size. I plan to add more complex querying which will do a lot of the reduction. I feel this solution is very good for storing json objects on disc meaning you can save them, start your application two days later and the data will queryable. That you need to do exact match queries on. 
I can perform queries on data sets of the 100,000(s) and have results in less than a second, which I think is pretty good. 
I am so sorry about that, I just update the URL :D
Hey, from the description you gave this sounds very similar to the adc protocol, would be cool if your client was compatible with multiple sharing protocols, that follow the same basic paradigms :)
Thanks for the info. I would love to see how this benchmarks against an embedded store like badger or bolt which can also support json to bytes as key/value. Seems you would have to do the same thing to query with non-id filtering since toy have to scan the entire value set. But I imagine it would be far less syscalls. 
you are sooo cool
You are right, it's quite similar as of now. But the idea is to get rid of the tracker and have a pretty much bare minimum version of it using DHTs etc.
Here you go — https://play.golang.org/p/pu1UEG3IMgO
I did some quick and simple refactoring. Whether that fits your need or not is up to you. Important are two things in this code sample, I think: - Clients must call resp.Body.Close when finished reading resp.Body - Split code between handling HTTP requests and the "business logic" which is in this case making an HTTP request to a 3rd party ``` type httpError struct { wrappedError error statusCode int } func (h *httpError) Error() string { return fmt.Sprintf("error %s: %s", h.statusCode, h.wrappedError) } var ( non200Error = errors.New("response status code not 200") ) func fetchData() ([]byte, httpError) { resp, err := http.Get("http://www.mocky.io/v2/5c9879d42f00006e009f3037") if err != nil { return httpError{err, http.StatusInternalServerError} } defer resp.Body.Close() body, err := ioutil.ReadAll(resp.Body) if err != nil { return httpError{err, http.StatusInternalServerError} } if resp.StatusCode != http.StatusOK { return httpError{non200Error, http.StatusBadGateway} } } mux.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) { data, err := fetchData() if err != nil { http.Error(w, err.Error(), err.statusCode) return } if _, err := fmt.Fprint(w, body); err != nil { log.Println("Could not write response body", err.Error()) return } }) ```
You return a custom type when you want to return structured data. Your example is too simple, and that’s probably why you don’t understand the advantage of `struct`. Take this (better?) example, and see if it makes sense to you: type Contact struct { Name string `json:"name"` Phone string `json:"phone"` Address string `json:"address"` Married bool `json:"married"` Age int `json:"age"` } func search(name string) (*Contact, error) { var err error var c *Contact if c, err = searchNameInDatabase(name); err != nil { return nil, fmt.Errorf("contact not found: %s", err) } return c, nil }
You return a custom type when you want to return structured data. Your example is too simple, and that’s probably why you don’t understand the advantage of `struct`. Take this (better?) example, and see if it makes sense to you: type Contacts []Contact type Contact struct { Name string `json:"name"` Phone string `json:"phone"` Address string `json:"address"` Married bool `json:"married"` Age int `json:"age"` } func searchAll(limit int) (Contacts, error) { var err error var con Contact var lst Contacts for i := 0; i &lt; limit; i++ { if con, err = searchContactByID(i); err != nil { fmt.Println("searchContactByID", err) continue } lst = append(lst, con) } return lst, nil }
how about moving res.Body.Close() upper
Thanks, this makes sense to me. Does that mean I should never define a type for a primitive? Go itself has runes as "custom type", for example.
You return a custom type when you want to return structured data. Your example is too simple, and that’s probably why you don’t understand the advantage of `struct`. Take this (better?) example, and see if it makes sense to you: type Contacts []Contact type Contact struct { Name string `json:"name"` Phone string `json:"phone"` Address string `json:"address"` Married bool `json:"married"` Age int `json:"age"` } func searchAll(limit int) (Contacts, error) { var err error var con Contact var lst Contacts for i := 0; i &lt; limit; i++ { if con, err = searchContactByID(i); err != nil { fmt.Println("searchContactByID", err) continue } lst = append(lst, con) } return lst, nil } Playground: https://play.golang.org/p/v81HCpIbHnp
You return a custom type when you want to return structured data. Your example is too simple, and that’s probably why you don’t understand the advantage of `struct`. Take this (better?) example, and see if it makes sense to you: https://play.golang.org/p/v81HCpIbHnp
&gt; how about moving res.Body.Close() upper If you do that, the program will not compile.