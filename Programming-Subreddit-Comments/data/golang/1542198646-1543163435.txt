Nothing at all shows up there in a browser with cookies disabled. Bad design.
What I liked most about this was his discussion on the "levels" of parametric polymorphism. I feel strongly in the power on small iterations of software so it would be somewhat exciting if they released *just* that version. Yes it doesn't give you *everything* but it does give you a lot and seems to be a lot simpler to understand. That's not to say no to contracts, but just to release an improvement in the language like that would be huge in itself. I guess the tricky thing for the language designers is that obviously once it's out, its out and its hard to change it. 
To continue on one of the questions in the video about integrating delve into the standard go tools. Why make the distinction on delve being a community/echosystem project and not vgo?
Hi, I also stumble into the same issue not quiet long. When I searched, I saw this article [https://itnext.io/structuring-a-production-grade-rest-api-in-golang-c0229b3feedc](https://itnext.io/structuring-a-production-grade-rest-api-in-golang-c0229b3feedc). It may provide guidance. &amp;#x200B; The project you pointed to looks way too cumbersome to even start something meaningful with, I prefer my codebase growing as the project needs instead of having 20 folders with one or two routes. Meanwhile, you can just start small and abstract as you move on. but for every case, make sure you follow best practices. for example, use connection pool with mysql, don't create a new connection with each request etc. &amp;#x200B; Cheers..
Thanks! I startes working on the problem last night and got most of it working, but still find 12 million rows to be a bit tedious so I‚Äôll read up on your article when I have some free time
[removed]
[removed]
Once it is out it is out forever. Just look at ruby and eg. hash syntax. I would kinda skip on generics even but I like the new errors.
I don't think you know what the word "fascist" means. Just like most Americans do not know what the word "socialism means". Interesting project, but a license which is seemingly written by a 14-year old(or, one with critical thinking abilities of one) is an immediate no-no. 
thanks, seems like good starting point for small project. But In my case, I am trying to convert the project already in production size server.. I have to handle quite many connections to other external services ( mysql, redis, openstack(gophercloud), and so on..) &amp;#x200B; I still don't get the point I am confused..
Oops.... sorry for the mixup. I haven‚Äôt gotten to that point with golang just yet. This could get frustrating as there are no laid down standard to these things. Hopefully, someone will come and shed more light on this soon.
&gt; https://forum.golangbridge.org/ This is for Gopher Sauce related bugs.
I have had to deal with processing similar data from printed reports, captured as text files from Windows generic/text only printers, as the only way to obtain data from ancient DOS based systems. &amp;#x200B; I do this in SQL after bringing it in, but the general principle is simple: Roll down the data, then filter out the headers. &amp;#x200B; Should be in principle simple to do the same in Go; first, look at the columns and mark with ones are 'header data', and which are 'detail data'. The detail you will never copy down, the headers you will copy down. Read it in, line by line; capturing all the columns. Always retain the previous line (i.e. hold two lines in memory, the current one, and the one before it). If the Header columns are filled, continue to the next line. If the header columns are blank, copy them from the previous line you have stored. Example: [https://play.golang.org/p/Y3XSPKMOOa-](https://play.golang.org/p/Y3XSPKMOOa-) &amp;#x200B;
Using a different debugger doesn't affect the code you're collaborating on, whereas fragmentation in package managers probably does.
This is familiar to me...upwork?
To be honest if they never touched it before then maybe just a code example of go's strengths. 1. Using reader/writer interface/io package 2. Using types to create new objects based only on methods. 3. Get a server going/have two files talk to each other. 4. Some goroutines
lol "go generate" isn't a type system. Using macro is the real horror.
I'm not quite sure what exactly do you mean by the word "API", as it's quite a broad term, but I hope the answer is yes. You create a Go library with exported types and functions (API), run \`gomobile bind\`, add the resulting aar file to your Android project and can call those functions and use those types from your project easily. It's really simple, quite well tested, in 99% of cases "it just works" and there are many projects in store that use Go in their mobile apps.
Like someone below mentioned, check out [https://github.com/libp2p/go-libp2p](https://github.com/libp2p/go-libp2p). They have implemented discovery as well as NAT traversal/hole punching that I mentioned.
It's hard to help without more information, but I'm guessing you just need to spend some time learning about concurrency and parallelism so you know how to apply goroutines and channels properly (and so you can understand code that uses them).
[removed]
Author here. Any feedback is appreciated! (: &amp;#x200B; By the way, the router is super fast too, because it uses [httprouter](https://github.com/julienschmidt/httprouter) underneath.
[removed]
After spending a couple hours trying to piece together how to make it work, I got it working... wow... this is just awesome really. I essentially just got the "hello.go" file from gomobile working. This is extremely useful, as I have a bunch of crypto functions I don't want to have to remake in multiple languages. :D
If you consume the request body, there is no request body left to proxy. You'll need to read it into memory (or such) and use something like `bytes.NewReader`. 
What is the main difference from the other http routers available? 
Good question. I wrote this because I was unhappy with the other frameworks/routers; I think most of them are either too bloated, or too bare-bones. The ones that aren't, force you to adopt their custom types and idiosyncrasies, isolating you to their own middleware ecosystem, etc. `min` is minimal enough to not get in your way, but useful and "vanilla" enough to compose well and scale. This is mostly due to the fact that it builds on standard library types, and `context`.
I call it a framework because it's not just a router. It enables route composition and middleware chaining. Sure, it doesn't include stuff like an ORM or stuff like that, but that's not the Go way anyway. A _plain router_ on the other hand, IMHO, would be `httprouter`, for example (which this framework builds upon).
Another setting of little concern is `Server.MaxHeaderBytes` which defaults to 1MB but could possibly be decreased in extreme cases where your server was getting oversized requests as part of a DoS.
Kelsey Hightower made a [intro-to-go workshop](https://github.com/kelseyhightower/intro-to-go-workshop) which is a nice little entry into Go with some fun labs. I forked this and fixed a few rendering issues and some other bugs, found [here](https://github.com/kelseyhightower/intro-to-go-workshop). Hope that helps a bit.
In the list of inspirational projects on your README file, I see chi. This one doesn't have any of issues you just mentioned - i.e., no custom types, no they own middleware ecosystem and not even external dependencies (yours depends on httprouter). Chi provides composable‚Äã routes as well with mount, group and so on. Is there a good reason to use yours instead of chi? Is it adressing ‚Äãany issue someone may have with chi? If so, what exactly? 
You say something about me and my political knowledges in base on a license that i have not even written, ok. Sounds a little weird that you only can comment about the license, but thanks for your comment aa well!
tbqh, I originally wrote this two years ago, and at the time, my only gripe with chi was API ergonomics, but I don't quite remember what it was, exactly. I think it amounted to route composition + grouping + middleware declaration verbosity/inflexibility.
\&gt; It enables route composition and middleware chaining Well yeah, that is kind of what a router does isn't it? I mean middleware is literally just a function wrapping another function, this is all very basic routing stuff. &amp;#x200B; And i would argue that it is a very bare-bones router actually, it doesn't support data-binding (to parse a http request in json/xml format to a struct) It doesn't seem to support data rendering (to output json / xml etc) nor does it give you http2 or tls (as far as i can see) &amp;#x200B; If this is a framework, then you can call everything a framework tbh
https://github.com/dhax/go-base this may be helpful to you? It‚Äôs helped me out a little! 
All generics and macros are on top of a compiler like `go generate`.
Why would you need that for?
I just mean "I want generics in Go" is "I want Rob Pike to do generics for me".
I think if you build your app around it and it helps with structure then it‚Äôs a framework by definition.
We've been copy and pasting the same SNS handler code between services for a while and figured it was time to consolidate it and open source it. I'm hoping this saves folks some time and the annoying task of writing the same boilerplate that we've had to do.
I‚Äôve been shopping around for a package like this to use with a new personal project using Google‚Äôs App Engine. I‚Äôll give this a spin, thanks for sharing!
Thank _you_ for deciding to try it! If you run into any inconveniences, please let me know :)
Lots of features left to implement, but that's quite an interesting project. Is it me, or is tikv/tidb the first major open source cloud native project coming out of China? Like, maybe I didn't look hard enough, but it seems like most other cncf projects came from Western companies
Sorry if I reply after a few weeks, by the way you are right, honestly this thread was meant to "check the territory", I want to switch to another language at a later stage and one good language I'm considering is Golang :)
Stop arguing semantics.
It‚Äôs sad that there are social viruses like this which can infect the whole system. You worked so hard on this lib and it‚Äôs for nothing because of `TROJAN_ANTIFA_HERO.dll`
I don't think so, and i posted this here for technical feedback. If you are not interested in it, its simple: do not comment. Save your time!
It's like saying Express or Flask are frameworks. They are not frameworks. Spring is, Rails is, Symfony is, your library isn't a framework.
If you go to the Express or Flask homepages, you'll find that they describe themselves as frameworks as well. And, quite frankly, with all due respect, I think this conversation is about splitting hairs, rather than meaningful or constructive discussion.
See, the thing is, HTTP/2 or TLS support is not in scope for frameworks in the Go ecosystem, generally. That's stuff for the transport. From your username, I understand you come from a PHP background, and if that's the case, I'd like to clarify that the Go community tends to favor small packages that Do One Thing Well, and that compose well together. The other thing is that "data binding" and output rendering are things you can get with the standard library. Part of the reason Go is great, is that it has an incredible standard library. I appreciate you commenting on this, but quite honestly, I don't see this as being very constructive.
Seems this new one is not a general Go forum but rather a forum for the users of Gophersauce.
Hey thank you for your ideas! Will definitely keep those topics in mind as well as having one main point. It's really great help
Awesome, I think this will be a huge inspiration for us.. I appreciate the effort kind internet stranger!
Good find!
goroutine leak detector in the stdlib(kind of): https://github.com/golang/go/blob/d82e51a11973714708ddc7f9f055ae8ea3d509f1/src/net/http/main\_test.go#L30-L141
Why not goquery? https://github.com/PuerkitoBio/goquery
BeautifulGoup. Missed naming opportunity!
Thanks for the detailed answer, this clarifies a lot for me.
So now there are 3(?) implementations of Lua in Go. One's from Spotify...
For auth [https://github.com/volatiletech/authboss](https://github.com/volatiletech/authboss)
You haven't been following the news. Everyone outside the socialist left is a "fascist" now. Moderate Republicans, libertarians (like myself), everyone.
Are you sure it's not Shopify? Also, IIRC, they target different versions of LUA (which have pretty dramatic differences). Gopher LUA targets LUA 5.1 Shopify targets LUA 5.2 Azure targets LUA 5.3 (which includes 32/64 bit platform support, bitwise operations, and UTF-8) 
go + goquery + cookie + css selector 
I'm really happy about Pike's conservative view on adding features to Go. This is something generally perceived for quite a while now and is reflected in the language itself. Regardless, it's always reassuring to hear that features will only be added if they fit well AND are pertinent to a considerable subset of the problems that Go aims to tackle.
In a world were language authors shove in features without much consideration it's reassuring to hear that in Go features will only be added if they fit well AND are pertinent to a considerable subset of the problems that Go aims to tackle.
Just so we're clear here... Microsoft released a version of Lua written in Go... And my head just exploded.
What are the other ones? Is there one that has a JIT?
Can someone explain this to me like I'm five? I think that this is something that will allow for interpretation of Lua syntax via a golang-based interpreter of sorts . . . is that correct? Why would this be useful? For speeding up programs written in Lua? For example, Prosody is a Jabber server written in Lua . . . would this project be relevant to Prosody developers in any way? How / why would this benefit them (or not benefit them)?
Excellent! Thank you.
[https://kocircuit.github.io/index.html](https://kocircuit.github.io/index.html)
It's Shopify, I went to their Golang meetup where they talked about it. One of their use case was running load test scripts written Lua but executed by Go because reasons I don't remember right now.
&gt; I think that this is something that will allow for interpretation of Lua syntax via a golang-based interpreter of sorts . . . is that correct? Pretty much yeah. &gt; Why would this be useful? Running Lua code within your Go code mostly. So for example, an app with a plugin system using Lua or something like that. &gt; For speeding up programs written in Lua? This seems to be pretty early stages, so it's hard to tell. I don't think there's an implementation of Lua in Go that's actually faster than other implementations, especially JIT ones. Could be wrong. &gt; Prosody is a Jabber server written in Lua . . . would this project be relevant to Prosody developers in any way? Probably not, at least not right now. They'd have to port the C-based libraries they're currently using for networking and such to Go or create bindings for them in Go, which would probably be a lot of work for little gain at the moment. It may have more to gain for them in the future, but I wouldn't bet money on it.
Thanks for the helpful reply. : ) 
So the Recursive Circuits model was designed specifically for Ko?
Looks a lot like a regular dataflow model.
I wrote this a few weeks ago, it's the basis for how I structure my own apps, and so far it's worked out pretty well for me at least: https://github.com/dougbarrett/example-golang-app I've been using that structure for probably a year now and have been working to rewrite old codebases to use this structure.
Not a big fam of the proposal, but hey if it works, I'm using it - can't be worse than no support now
Because of excitement or because of "WTF happens here"?
Title is misleading. It's just the parser and AST printer. Like about 1% of implementing generics.
https://github.com/yuin/gopher-lua https://github.com/zxh0/lua.go https://github.com/Shopify/go-lua
I wonder if this is for helm.
ioutil.readall on body and use it however
&amp;#x200B;
`C:\Users\parapand&gt;git config --unset https.proxy` `fatal: not in a git directory` &amp;#x200B;
Looks this min use the context-aware version httprouter. The efficiencies of the context-aware version and chi router are almost the same.
Is there anything that you find difficult when using Chi? What features do you wish min had that Chi doesn‚Äôt?
I haven't used both. I just viewed their docs. It is just that Chi is a little more feature richer.
httprouter supports two types of handler functions, httprouter.Handle and http.HandlerFunc. The latter one, mix uses, is context aware.
You‚Äôre absolutely right. My mistake. I don‚Äôt remember seeing that in the documentation when I wrote this. Perhaps I missed it or it‚Äôs a new addition. Either way, it seems to do exactly the same thing I‚Äôm doing, so perhaps my context layer is unnecessary.
&gt;Implementing a scripting language purely in Go offers several advantages over binding a C implementation. First, we can leverage Go‚Äôs garbage collector and use Go‚Äôs heap for the embedded language‚Äôs objects. This gives us benefits like zero-overhead sharing of strings between the two languages, as an example. Second, the overhead of creating an execution context for the embedded language is minimal - little more than the lua.State struct, a couple of maps, and a small stack. This is important in a load generation process with thousands of goroutines, each with its own Lua state. Third, concurrency and error handling semantics are easier to map between the two languages. &amp;#x200B; Source: [https://engineering.shopify.com/blogs/engineering/announcing-go-lua](https://engineering.shopify.com/blogs/engineering/announcing-go-lua)
Cool! For now i'm using [my own scaffold framework](https://github.com/hazcod/mini) but might get some inspiration from you.
So you're throwing in three assumptions: 1. GNU 2. nscd 3. nsswitch.conf I.e. these two statements are by itself false: "libc caches DNS" and "the OS caches DNS". In modern containerized environments, there is nothing else than your application and the Linux kernel. Often the libc is muslc (which I discourage, but it is popular.) Now imagine you have to support a PHP app (sigh) with a couple thousand requests. PHP, as stupid as it is, creates one connection to, say, three services (SQL, NoSQL and microservice x; and yes, people love to use SQL and NoSQL in tandem). Thats make three DNS requests time 2000 requests, right? You're in a container, everything you see is what you bring and a kernel. No nscd. But wasn't there something like IPv6? Oh yeah, PHP+libc will try to resolve both. Separately. Add to that you use Kubernetes which has the stupid default of \`ndots:5\`, which effectively means, your libc will treat your FQDN as a non-FQDN and will first resolve useless suffices, which adds 5 useless requests (depends on the environment). So here we are with 3\*2\*6\*2000 = 72000 DNS requests. Per second. What if I told you that each of these requests have to be conntracked, because overlay network? You're putting 72000 tupels into that tiny hash table in the kernel. Oh wait, there is more. The Linux kernel has. a. chain. of. race. conditions. in that conntrack table since like 10 years or something. A collision is triggered if some library code tries to concurrently send UDP packets (it's a little more complicted than that) to the same destination. The packet that loses that race, is dropped. Meet the 5 second DNS resolve timeout. Boom! You're offline! You can imagine that I've heard "but the OS caches DNS, right?" from PHP developers. There are a few solutions to the problem with PHP, Kubernetes and high load. None of them is elegant, none of them singularly suffice. OP's lib can be part of solving complex scenarios. Dismissing it like "Don‚Äôt do this. There is already plenty of caching built into the DNS system" is outrageously stupid. 
What's the use of this at Microsoft?
Cute
Thank you very much
Yes, this will hurt performance. Especially if A is larger than a word (it won't fit inside the interface directly, so each copy will require an allocation). I also question how it is useful to let your function accept something arbitrary when it is going to panic if not passed the exact type it was expecting.
you may want to give a try to the Apache Arrow based CSV reader: - https://godoc.org/github.com/apache/arrow/go/arrow/csv#example-package right now, it's using `encoding/csv` to parse CSV files, line by line. but, in the future, it should be able to read batches of lines (to reduce pressure on various things), and, maybe, have a pluggable `encoding/csv`-like CSV reader backend.
We do most of the project in GoLang. visit us at [www.kindkonnect.co](https://www.kindkonnect.co). we have team of 20 GoLang developers. send your resume at kumar@kindkonnect.co
Try this, made exactly for your use case: https://github.com/ribice/gorsk
Because I‚Äôm old and still have trouble understanding that Microsoft no longer has NIH syndrome. Half of me still thinks all of Microsoft‚Äôs moves of the last ten years are some sort of EEE power play, but I think it‚Äôs more likely just the result of a more loosely controlled organization.
This is the opening line of the article :) &gt; TL;DR &gt; You can now run a server that stores all your Go dependencies and be confident that they will be &gt; available whenever you need them, whether on your machine or during your CI/CD builds. **More information** https://open.microsoft.com/2018/08/28/announcing-project-athens-gophersource-go-community/ 
[removed]
[removed]
Pure Go library (no cgo) with a very simple API üòç
I'm conflicted. This is a proxy that stores cached versions of go repositories and acts as a pure passthrough as long as connection can be done? Even if it is, my concerns are: \- How is remote invalidation handled if our client uses this and we revoke access to our repository? \- Its a single point of credential storage. If you gain access to the proxy, you gain access to all code parts (its basically a plain text mitm storage of all source code) that are cached locally without any further security layer? As for open source dependencies, why not just use ./vendors, also better for code and security reviews? 
Thank you for answer and complete example! But fill lines with headers not exactly what i need. I need to make JSON from this lines i suppose there need to use recursion or stack to collect nested objects
&gt; Pure Go library (no cgo) with a very simple API üòç Basic example on Windows: https://i.imgur.com/MlXgA9K.png Thank you Serge! This looks even better than your previous lib webview.
I've got to agree with /u/php_questions here - this isn't a framework, it's a router. Chi is a router too, it handles route grouping, and middleware too. httprouter is just a bit more barebones. It's fine that what you've made is a router though, don't get me wrong. You say it enables a certain paradigm for building apps, but you can do the same with other routers, and you could use yours in many different ways. That sounds very much like a library to me. You can see this pretty clearly when you look at the usage: func main() { m := min.New(nil) m.Get("/", helloWorld) http.ListenAndServe(":8080", m) } This doesn't differ from most other routers offered in the Go ecosystem. Just compare the featureset here with Chi: https://github.com/go-chi/chi - and note that they call themselves a router, which is most definitely what it is. &gt; See, the thing is, HTTP/2 or TLS support is not in scope for frameworks in the Go ecosystem, generally. I'd argue against that, if you're going to call something a framework, even in Go, it's still got to provide boilerplate for you. HTTP/2 and TLS are things that other frameworks do provide, on top of other basic things like configuration, logging, tracing, metrics, etc. Frameworks also generally dictate the folder structure you use too - and people use them for these kinds of reasons, it's more opinionated, and makes them have to think about less, which can make some people's lives easier. In Go, we generally prefer to compose libraries, much like your router, along with other libraries to avoid bringing in a bunch of functionality that's not necessary. I think to close; I personally think that calling this a framework actually detracts from it's attractiveness. I never use frameworks in Go, I haven't done in the several years I've developed web services with Go. I compose libraries, and if I hadn't come in to the comments here, I'd have glossed over this post as just another framework I'll never use. The functionality you've layered on top here seems good, just to be clear, I'm only criticising the fact you've called this a framework, and laid out my reasoning why it's simply not one.
Thanks!
internet
&gt; Unlike Electron it doesn't bundle Chrome into the app package, but rather reuses the one that is already installed. How can you ensure that the user has the correct chrome version then? Also, could you technically use a framework like Vue for the frontend?
Will it work without chrome installed?
`go.sum` will ensure that you get the exact copy of a dependency. If the proxy is corrupted you will know it.
You might be interested in the work Petar did on gocircuit while researching at Tumblr some years ago: https://youtu.be/i2VaXnRhob0 http://gocircuit.github.io/circuit/
Maybe it would be a good idea to add a screenshot of an example application (preferably something that looks good) to the readme?
Agreed, for a GUI library a shiny screenshot always helps. It will probably come with time. Maybe earlier if someone send a PR after suggesting that in an issue.
Nothing fits in an interface directly except a pointer.
Nice program, by the way papis does have support for biblatex ;)
The library checks for the most common installation paths etc (much like Puppeteer does). If it doesn't find chrome - it asks user if he wants to install it, and opens a download page. That's the best I could do for now. &amp;#x200B; And yes, for frontend you may use any framework, React, Vue, doesn't matter. As long as it works in Chrome - it will work in Lorca.
The Go Programming Language (Addison-Wesley Professional Computing Series) https://www.amazon.com/dp/0134190440/ref=cm_sw_r_cp_apa_D9y7BbQRNKRQS
To add to that. It is possible to detect if Chrome couldn't be opened. I created a fresh Windows 10 VM and ran: func main() { ui, err := lorca.New("", "", 480, 320) if execErr, ok := err.(*exec.Error); ok { log.Fatalf("\nChrome could not be started. Do you have Chrome installed? %s\n", execErr) } else if err != nil { log.Fatalf("\nOps. Something went wrong while starting the application: %s", err) } } Which printed: `Chrome could not be started. Do you have Chrome installed? exec: "C:/Program Files (x86)/Google/Chrome/Application/chrome.exe": file does not exist`
Not sure if I did something wrong or if this is a planned feature. But on a fresh Windows 10 machine I couldn't see the dialog. `lorca.New()` just returned an os.exec.Error: exec: "C:/Program Files (x86)/Google/Chrome/Application/chrome.exe": file does not exist
Ok. I was unclear. You can show the dialog with lorca.PromptDownload() if lorca.ChromeExecutable() returns and empty string.
This is a good read. I purchased this book for a distributed systems class I took in college.
Works. Thank you. https://i.imgur.com/7Bi6T9n.png
kafka isn't pub sub? I'm fairly sure it is.
Really amazing, great work. Could change the way people think about golang gui.
&gt;\- Its a single point of credential storage. If you gain access to the proxy, you gain access to all code parts (its basically a plain text mitm storage of all source code) that are cached locally without any further security layer? The box that builds your source code \*already requires\* access to your private source code, including all dependencies. Maybe if you build one app per build server, then this setup is less secure because the proxy could give access to OTHER dependencies. But in the normal case, (where all apps are built by one server) this service is not really adding any new security vulnerabilities. &gt;As for open source dependencies, why not just use ./vendors, &amp;#x200B; 1) It bloats up your git repo, slowing down git. 2) It bloats up your disk with multiple copies of a library. 3) You never know if ./vendor has local modifications or not. 4) It versions something that is already versioned. &amp;#x200B; Don't get me wrong, I'm glad ./vendor exists, but it should only be used in exceptional cases. \&gt; also better for code and security reviews? This is a tooling issue. There is no reason the tool couldn't show you changes to your deps.
https://github.com/golang/go/wiki Basically shows everything to get you started
Thanks for your work! The streaming part is still far, is it? Any plans? (Can‚Äôt help right now but wouldn‚Äôt mind as soon as I have some free time back)
How does this differ from https://github.com/goproxyio/goproxy?
Great work! I would highly recommend to learn how to write unit tests as well :)
I'm not sure that this pattern is always applicable. For example, off hand I think there can be a few exceptions like: - a database client (jmoiron/sqlx for example), - a http client with it's internals like http.Request which aren't exposed In the first case, there is a lot of out of band information which may or may not be available for logging. An example for that would be the generated ID for a database row, for which you have to know that 1) a query is of a particular type (insert), and that 2) the query actually generates an ID. You could add logging around sqlx.DB, but you'd get an incomplete picture (only fn inputs and returns, causal information is relevant higher up in your own app code). Similarly, an API client may have something like a `func (s *Session) Request(method string, url string) (*http.Response, error) {` (a real world example). In this function there's a particular http.Request object which isn't reachable outside of this API. Even if you'd refactor that into it's own `session.NewRequest` function, there's next to zero chance, you'd be able to add the instrumentation here without having some split responsibility. Go relies on composition, so unfortunately you can't just overload something like `type MySession extends Session` and re-implement just that particular NewRequest function, and use Request as-is. The second thing can be solved somewhat if you implement your functions as struct fields. While this is a reasonable approach for unit tests, there's pretty much no API that is written like that that I know of. Not that there would be something really bad with it, it's just going into "I'll write my own OOP patterns" territory, which isn't a good thing.
`.ko` file extension is already used for kernel objects (modules).
You mean the Arrow RPC protocol? I don't think it will be that hard to implement (famous last words :P) Go has good support for flatbuffers. So it's just a matter of reading the C++ code and translating it to nice, idiomatic, Go. Easy :)
Prolly parts of the language you use the most. Error handling, io package, handlers, interfaces. I know you wanna hit those 6 letter words but the point of go is simplicity and readability. 
* Your comments doesn't seem very idiomatic. Check out https://blog.golang.org/godoc-documenting-go-code * Consider keeping the IP address results in a `map[string]struct{}` so you don't have to search through the entire slice every time to check for duplicates * Consider passing the `http.Response.Body` directly into `json.NewDecoder` - it is an `io.Reader`. The extra buffering is unnecessary. * Remember to check all errors * I think you could optimize the execution time and design by doing DNS and API lookups concurrently. Consider having a channel feeding inputs to the DNS resolver which in turn feeds IP addresses directly to the ipinfo API client instead of buffering them into a slice. 
Thank you for your feedback. I appreciate you sharing your experience. I am not expert on patterns really. I found out that this approach is called `proxy` pattern after the fact, so I used the term to better communicate what is going on. Let me double check my assumptions, and get back to you. I just wanted to give you the due gratitude now, and detail my thoughts as I get to look into the legitimate examples you have mentioned.
The first thing many will mention is ignored errors. In main you ignore the error returned from `flag.Parse` and the same goes for the float parsing in `latlon2coord`. This will eventually cause confusing / hidden errors. I always start looking at a project by looking at the dependencies. I note that you use a library for Vincenty distance, which is extremely accurate, but it is also computationally expensive. The location of an IP address is already approximate--as rough as a few hundred miles sometimes. For example, I am in Grand Rapids Michigan, but IP location libraries tend to show me as Lansing, MI or Toledo, Ohio. A very tiny inaccuracy (a few miles given a distance of many thousands) is probably not relevant, especially at greater computational cost to something like haversine. In that case, you won't need a dependency: https://gist.github.com/cdipaolo/d3f8db3848278b49db68 I like the ASCII table. I am a minimalist and might have avoided a dependency on this, but then I would have an ulgier tool than yours. `convertArgs` isn't a bad name, but when you see "convert", "clean", etc, you don't know what it actually does unless you document with a comment. You have great comments, so it's fine really, but you could consider calling this `truncateArgParts` to indicate more specifically what is being converted (all the parts of the slice are being truncated when appropriate). This whole paragraph is probably something too unimportant to worry about when it's not even an exported function, but I figured I'd mention this since the code is so short. I took too long already, so I'll look back at the important things (channels and such) later today and reply if others haven't already.
This is a young project and there are many features planning to implement. It aims to be used in the production environment and can be a Redis alternative in some cases. It supplies full distributed transaction across several storage nodes and can be scaled out easily. It is fully compatible with Redis protocol and works as a single Redis with a huge storage capacity behind.
In a few months. Probably late February.
I wouldn't have any questions specific to Go, since it isn't a language that is tricky to learn. I would assume any good programmer could pick it up and be productive quickly. &amp;#x200B; I would be wary of subjective questions about particular programming doctrines. Suppose a programmer had just been recently involved in a complex, successful project that was not object oriented, and so she doesn't remember what SOLID is, why do you care? You could still discuss those ideas in my general form though. Or maybe her project depended on loose coupling, not tight coupling? &amp;#x200B; I would try to frame questions about any kind of development rule of thumbs in a form where they feel free to discuss the pros and cons of that rule of thumb. "The DRY principle is "Do not repeat yourself" Why might that be a good idea? And why might it be bad to stick to it too dogmatically?" &amp;#x200B; I just imagine someone like Sean Barret going in for an interview and being asked about SOLID and him saying "never heard of it sounds like some OOP bs" and then not getting hired and you missed out on the best programmer you were ever going to get :) &amp;#x200B; &amp;#x200B;
Very useful. When it comes to adding scriptability to your Go application there were 4 choices in the past: Python, Lua, Lisp, JavaScript. Python is too difficult to integrate proper. There are a few Lisp implementations in pure Go but I'd consider it a niche choice. That leaves JS and Lua integrations, both thorough, and I like to have a choice. 
My initial thoughts on this however, is that if external dependencies depend on business abstractions, there should be an interface that returns a business struct, which in turn depends on the http request. In that case, the approach suggested might be valuable. Because `func (s *Session) Request(method string, url string)` will be converted at some point, hopefully closer to that call to something in the lines of `func (c *Client) Request(userId string) (User, error)`, that in turn would call the appropriate HTTP request or database request and return a result. Then one can instrument or log that call.
Actually, it‚Äôs a function accept proto.message interface as one of the parameters. I was thinking that if I share this function for different messages.
Yep, that's what I meant with the A) case ("relevant higher up in your own app code"). It's definitely a good pattern! I loved this example from a few weeks ago: [instrment your code with opentracing, prometheus, etc.](https://www.reddit.com/r/golang/comments/9schnz/instrument_your_code_with_opentracing_prometheus/) which uses the same pattern to wrap an interface with add on functionality like you suggest (same pattern, but with code generation).
"...we're going to be writing Go outside of GOPATH" ^(^at ^~[8m25s](https://www.youtube.com/watch?v=aeF3l-zmPsY&amp;feature=youtu.be&amp;t=527)^) That's heresy! (‚ïØ¬∞‚ñ°¬∞Ôºâ‚ïØÔ∏µ ‚îª‚îÅ‚îª
What have you tried so far? It looks like you could parse out that version with a regular expression and then use something like [`github.com/blang/semver`](https://github.com/blang/semver) to compare it against the version in `/tmp`.
That is a a very good observation regarding haversine vs vincenty wrt to accuracy vs speed. This dependency is not really an issue since I also ported / wrote the vincenty code - so it is just another one of my repos. I also like the idea about renaming the functions to something more specific. Thanks for spending the time reviewing my code and look forward to any more comments you may have.
You have made some excellent suggestions. I did mean to add in more error checking, but just forgot. I am going to create a dev branch that will include your ideas. I really appreciate your time spent reviewing my code 
What are the use cases of titan? Any improvements over Redis? 
&gt; In main you ignore the error returned from flag.Parse How can I check for errors? I am not seeing anything obvious in the `flag` package.
Also https://github.com/google/starlark-go , the configuration language for Google's Bazel build system.
repository :(
That's good to know! It may not have the buffer sizes you'd want though.
Rob Pike answers that exact question during the Q&amp;A after the talk. Basically, he says it was tried and it didn't work. Full answser in the video :-)
Can someone tell me if this tutorial is reliable? I want to learn about go modules and need to know if it's the ways it's done nowadays. Thanks 
If you pass `bufio.NewReader` an instance of `bufio.Reader` who's default size is greater than or equal to the default, it won't wrap it.
It is, but I'm biased
Yes it is reliable and correct. Modules are quite new to Go but his approach is consistent with best practices we've seen so far.
&gt; nowadays I know things move fast in Go, but this isn‚Äôt JS. Given it was released just a few months ago, things aren‚Äôt out of date *quite* yet...
The call \`modify(s)\` cannot modify variable \`s\`. Either write the function to accept a pointer as in \`modify(&amp;s)\` or to return a value as in \`s = modify(s)\`.
The if doesn't do anything. A string is already a pointer under the hood. The last two lines of modify are all you need. If you would pass a nil to modify you couldn't do anything at all. If a function takes a pointer 'modifying the pointer' will not affect the calling function only modifying the pointed to data will have an effect. There are no uninitialised pointer in Go, just nil pointers. If you want to change them your function has to take pointers to pointers.
Isn't there an optimization for cases where you have a value type smaller or equal to word-size that wraps the value in the interface instead of allocating it on the heap?
Microsoft probably wants to embed lua in their Go code? MS is a huge organization, so I'm sure they have a fair bit of code in Go, especially for their Azure business.
Three posts about Titan in a week?
uh, I meant I had a brain fart. Stealth edited that out! it does not return an error...
Haskell has issues with large, long-lived objects in the heap as well. It results in extremely long GC pauses. In Go's case, it seems like heap usage spirals out of control if I'm understanding this post correctly? And given that the Go team prioritizes minimizing pause time, this makes sense as a result. But I'm not GC expert so I could be speaking out of turn there :) Anyway, Haskell's solution is "compact regions." Basically, you can take a Haskell object and `compact` it, which moves it to a compact region. Objects in a compact region cannot point back into the main heap, so during GC, the compact region is treated as one object, regardless of how large it is. If the main heap doesn't have a pointer to the compact region, that entire big object is collected. With this, you can keep your main heap small and GC performance happy even if you want to hold many large objects in-memory. Details for those interested: * [`Data.Compact` documentation](http://hackage.haskell.org/package/compact-0.1.0.1/docs/Data-Compact.html). The API is very simple. * [Pusher's blog that made this problem popularly known.](https://making.pusher.com/latency-working-set-ghc-gc-pick-two/) Interestingly, they switched to Go to get lower GC latency in the face of large heaps. Compact regions were not created at the time of the blog post. * [Replicating Pusher's use-case with compact regions](https://meta.tn/a/7e44bfe847ebaea028cf7544b6747e92d5f6362b3426defe269fc5a9a3c82115). The tl;dr is that compact regions pushed latency to sub-10ms (and oftentimes sub 5ms and beyond) at the cost of a 2-3x throughput hit. Throughtput vs latency is a fundamental tradeoff so this makes sense. * This is a mirror of the [original post](http://fuuzetsu.co.uk/blog/posts/2018-03-03-GHC-compact-regions-for-improved-latency.html) which seems to be down.
I watched to the end, I still don't really understand though.
Yup, I hate reading C++ though... A few months ago I wanted to see if I could plug Go into Spark similar to how Python uses Arrow for data transfer, creating a "GoArrowExec" kind of Spark plan node (not for anything in particular, just because I haven't written much Go lately and it sounded like fun) but Go-Arrow was missing pieces. Let's see if Christmas brings some free time as a gift!
So you mean the official go mod vendor does not work?
There is experimental work on a generational GC, using page hashes rather then read barriers. This would also likely solve it, but without modifying any code to take advantage of it. The problem isn't that it has to scan the heap, but it has to keep scanning the heap.
Will this just work if I have dependencies that are in a private github enterprise repo instead of public github? Do these dependencies all need to have had go mod init run on them first? What happens if a dependency doesn't have a go.mod file?
&gt; Isn't there an optimization for cases where you have a value type smaller or equal to word-size that wraps the value in the interface instead of allocating it on the heap? That optimization is gone since the conservative GC was replaced by the precise one.
I did not know this channel existed, but I'm so happy I've found it now. Video was great! Immediately subscribed.
üéâ
`rpm -Uvh` will do nothing if the existing package is newer. Check for that condition via an error code and parsing stderr.
You should check out the episode on fractals and the runtime tracer! It goes over the limits of concurrency in a very cool way showing the impact of channels buffered and unbuffered too. Did you watch it?
You should check out the episode on fractals and the runtime tracer! It goes over the limits of concurrency in a very cool way showing the impact of channels buffered and unbuffered too. Did you watch it?
What titan relates with Redis is it says the Redis Protocol(RESP). Except that, Titan is a completely different thing from Redis. They solve problems in different use cases. * Titan is distributed, you can scale the cluster with no pain. * Titan stores the data on disk, this suits for storing TB or PB data * Titan runs on Raft, which supplies high availability with strong consistency * Titan cannot perform like Redis for its distributed and on-disk property. Titan is a distributed NoSQL database, it uses Redis protocol for the popularity of Redis. It is not a replacement for Redis.
Yeah, Titan is on active development now. I submit two posts about Titan. The first is the announce open source of Titan, the other is this post, supplies the benchmark of Titan. We build titan for fun and are very excited to share it with the world, however, it misses a lot of documents including an introduction, our design ideas, the deployment ... So we will improve and share the documents continuously. I am very sorry if this disturbs you.
I was looking at Arrow a few months back and was thinking first class Go support would be great. Thanks for working on this :-)
oh yes , I think this can be a good solution.
Exactly what I've been looking for over the past week. Was just about to settle for something that would've been way more hacky and heavy. Thanks for sharing!
To be honest, this is one of the stupidest comments I've ever read on this sub.
[removed]
[removed]
What's the advantage of it? Why is it better than RocksDB, BoltDB?
So addition is bad because sometimes doing lots of addition by using multiplication is a better choice?
the main issue of "generics" w/o contracts is that this prevents from writing robust, well understood (in terms of requirements), generic code. with contracts, one can carefully lay out what are the requirements that a type `T` must fulfill before one can "instantiate" some generic code with that type `T`. w/o contracts, some generic code can implicitly rely on `T` satisfying some condition for version 1 of the code, and then modify the internals of that piece of code for version 2, breaking a bunch of 3rd party code: it's in effect enabling some very long range (multi-package long) non-local effect. contracts are an attempt at preventing the kind of sub-par user experience C++ developers/users have had for the longest time with C++ templates. (presumably, C++20 may fix this with "concepts".) contracts should enable the compiler to tell the generic code writer that they break their promise (of _e.g._ only requiring a set of conditions such as `&gt;`, `convertible to float64`, ... on some type `T`) before shipping the code to users (and have them discover something broke deep into the bowels of a multi-hop dependency, 42 packages apart.) contracts should allow the compiler to tell the generic code writer (or the user trying to write some piece of code using 3rd party generics code) that something is amiss, in a clear, articulate way, instead of vomiting 100s of lines of template instantiation errors. (anybody who tried to use `boost.spirit` circa 2005 might know what I am talking about.)
feel free to drop a line on the arrow mailing list if you hit a snag. I am sure I could give a hand!
Arrow can be seen as a data conduit between multiple number crunching libraries. as pitched in the arrow.apache.org website, the idea is that instead of having to write an insane amount of (exponentially exploding number of) conversion code between `N` libraries that deal with data in some way (storing, computing some stuff on it, massaging it in some way, connecting it to some dedicated hardware), you only write the conversion code (or handling code) between library `L` and Arrow, and you're done. you can then have access to all the Arrow-based or Arrow-compatible ecosystem from within your library _e.g._ you can create an Arrow connector for your database, and, w/o much performance impact, expose it directly to your infiniband connected data processing pipeline (that is also Arrow aware.) my vested interest in Arrow is to be able to expose a high energy physics file format as an Arrow table to connect it to other already existing C++ and python-based (numpy/scipy) data processing pipeline. so my Go code can be seamlessly integrated with that code. (and eventually, replace all the pieces that make sense in Go for my own sanity.)
AFAIK, there aren't yet many Go-based stuff in Arrow. (that's quite understandable as it's still very much a WIP.) if you can read C++, there's this piece of code: - https://github.com/root-project/root/blob/master/tree/dataframe/inc/ROOT/RArrowDS.hxx - https://github.com/root-project/root/blob/master/tree/dataframe/src/RArrowDS.cxx together with these tutorials: - https://github.com/root-project/root/blob/master/tutorials/dataframe/index.md that should give an idea on how one can connect some already existing code that deals with "dataframe" like data and connect it with Arrow.
No thanks needed. Godspeed ;)
&gt; Sean Barret To be honest my point was to figure things out about the applicants thought process and developer dogma if you will (and not quiz him about SOLID), so I'd know if he's somebody who figures things out and has a passion for it, not necessarily that he knows head first design patterns book by heart (but, it doesn't hurt if he/she would, to be honest). The more you know, right? ;)
As someone new to go can someone tell me what large is in this case? I am writing a game server in go, and will be keeping world state in memory.
Well‚Ä¶ at least it's not another HTTP router.
Awesome! Will definitely check this out...
Thank you for pasting the readme.md here
Well, look at the code. It's very little code. Haha. It's just a file based key value store. Not a good one. 
Almost certainly negligible in this case, but localizing initial time measurement is a good best practice, so it‚Äôs still useful feedback.
if you use VSCode - beware
I am not familiar with C#, but does it not have something like C++'s 'std::any', which is in many ways a better, safer, void*?
Huh. Is it a joke?
For me I use a mix of both.. &amp;#x200B; I still `GO111MODULE=off go get everything` then start VSCode with `GO111MODULE=off code .` But then I use modules to manage my vendor directory with `GO111MODULE=on go get|mod tidy|mod vendor` &amp;#x200B; I am still between 2 chairs right now.. &amp;#x200B; EDIT: formatting
It has a boxed type called "object", but I haven't actually used modern c++ std::any. So I don't know what it does, and personally couldn't compare it.
You could do this in go using `exec.Command`. The result will contain a reference to the executed process and its stdin/stdout/stderr. Code would be something like: ``` p, _ := exec.Command("./yourcommand") fmt.Fprintf(p.Stdin, "stuff you want to go to std in") ```
no, it doesn't. if the go process reads from stdin, this will work fine. e.g. package main import ( "fmt" "io/ioutil" "os" ) func main() { content, _ := ioutil.ReadAll(os.Stdin) fmt.Println(string(content)) } bash: for i in foo bar baz; do echo -n $i | ./main; done result: foo bar baz
1. How much are your services? 2. Are you willing to go through a silly test just because we heard Google does it? I expect that nobody makes it to three.
Nice video as always, I hope go mod sees bigger adoption, because people break still SemVer and fixing building conflicts is boring. But I would like a second episode about fixing building conflicts to get more people adopt go mod.
Might as well just use Dgraph at this point
I did with the "yes" command. Thanks
Seems like this will be for helm: https://twitter.com/jdolitsky/status/1063148508662902786
Failure to do this has killed many real-world projects.
[Link to proposal](https://github.com/golang/go/issues/28412)
What is the problem of another HTTp router? Can't any improvements be made on the current ones?
Oh there are so many other red flags when interviewing from both sides of the table. Some employers demand psych evaluations before hiring. Some people looking for a job immediately start with price negotiations (how about qualifying first?). The guy who was interviewed for 3-4 hours already decided that he doesn't want to work there, the quote thing there just sealed the deal. It's funny how that happens ;)
And if you're feeling lazy, chi provides a stdlib-compatible router with good performance and a few bells and whistles for easier coding.
HTTP routers are the Hello World of Go programming. It's a good exercise for yourself, but for the love of god stop publishing them.
&gt; Some people looking for a job immediately start with price negotiations (how about qualifying first?). No, price really does need to come first. If you cannot reach an agreement on price, there is absolutely no point in wasting any more time. Yours or theirs. That is why it needs to be question one. Imagine if people walked into McDoanlds and interviewed the fry cook for four hours, only to find out that the burger they wanted is too expensive. There is a very good reason why the price of that burger is published for you to see the minute you walk in the door. &gt; The guy who was interviewed for 3-4 hours already decided that he doesn't want to work there Which is why question two is to evaluate if the interviewee even wants to subject themselves to a silly test. 3-4 hours and be upset about the process enough to know you want to walk away is a horrible waste of time. There is no question three, as everyone will have walked away before it comes up.
&gt; across many languages Only supports go and node
The article mentions 22g of data, which is pretty ambitious for any single machine imo.
Thank you! You are the author of papis, right? Papis was the inspiration for this program :) I tried parsing some patents, as supported by biblatex, with papis, but it defaulted to misc type, and I could only find bibtex export from the documentation. How do you export with biblatex types?
&gt; Quick now - what is the value of n here? Compiler error on if statement: n declared and not used. You do not have a problem with short declarations, you have a problem with variable shadowing and scoping. There are probably lints that can help.
You only use short declarations where the variables are close and aren't shared outside the declaring scope. You are also encouraged to be as verbose as you need to be regardless of locality. My rule of thumb is if the scope is on the same screen then I tend to be terse. If the scope is on the same screen but there is a high probability for error due to the logic I expand on the verbosity and also add comments for clarity. There is also tooling to find where you are shadowing variables that I run on every save or build in VSCode to address this weakness. I agree with this general standard. This isn't a problem with Go. It is a problem with coding standards and enforcement of them.
awesome, literally was just as easy as doing go mod init, go get and go build and voila, I can be freed of GOPATH. Now just need to figure out how to change my docker build process (I guess just remove vendor dir and add a go get?)
Good point, yeah! Make sure you keep go.sum too üòâ
Been using it in a few apps and so far it works pretty good, at least once you get over the hassle of seabolt and cgo.
For questions like this, it's always best to DYOR, not ask Redditors. I can see from the comments more unhelpful answers than helpful. If you're curious you should really read the docs. Here is the link to Golang FAQ. You can read specifically where they discuss their overall intentions for the language and more details on the specifics @ [https://golang.org/doc/faq#Origins](https://golang.org/doc/faq#Origins) &amp;#x200B; Helpful excerpt: "Go was born out of frustration with existing languages and environments for the work we were doing at Google. Programming had become too difficult and the choice of languages was partly to blame. One had to choose either efficient compilation, efficient execution, or ease of programming; all three were not available in the same mainstream language. Programmers who could were choosing ease over safety and efficiency by moving to dynamically typed languages such as Python and JavaScript rather than C++ or, to a lesser extent, Java." &amp;#x200B; Since you asked, I'll give you my personal opinion: If performance is your top priority, use C++. If you want clarity and ease of development but willing to accept slight performance tradeoff, you can use Go. Most low level server side software at Google is written in C++. 
package main &amp;#x200B; import "fmt" &amp;#x200B; func SomeVals(x, y int) (int, int) { return x + 1, y + 1 } &amp;#x200B; func main() { n := 3 for { n = 7 if n, m := SomeVals(n, n); m &gt; 10 { fmt.Println(5) } n += 3 break } // Quick now - what is the value of n here? fmt.Println(n) } &amp;#x200B; i think you don;t understand the code. In start n contain 3, then in for now n contain 7 . now function return two values which also update both n and m , if m &gt; 10 then condition true , but why condition at end ? because first both variables update then m compare , you ask why different answers because n,m := SomeValue(n,n) is not a condition that and if statement demand condition &amp;#x200B; n, m := SomeVals(n, n) if m &gt; 10 { fmt.Println(n) } now the answer remain same
Does it really say "Unknown error" or does it display `Failed to continue: Check the debug console for details.` ? You should get some details if there are any. I usually get this error when the `main.go` isn't in the top directory I opened, but somewhere else (e.g. `src/main.go`. You can fix this by opening `.vscode/launch.json` (there should be a messagebox with the option `open launch.json`) and editing the `program` field to `${workspaceFolder}/src/main.go`. This will tell VSCode to start `src/main.go` from the project directory when you start debugging. 
Fine, I've made the obvious change to avoid the compiler error. This would not be a problem either without short declarations or if short declarations required that all variables be new variables. To give a rather more common and less contrived example, suppose you had this code: var x string x, y, _ := SomeFuncReturningStringIntErr() SomeOtherThing(x, y) Then you go and add error checking: var x string if x, y, err := SomeFuncReturningStringErr(); err != nil { log.Printf("Error: %v %v: %v", x, y, err) } SomeOtherThing(x, y) You have just broken your code in very subtle and hard-to-detect ways.
I refer you to my example above, where adding error checking after the fact completely changes the meaning of the code. All the variables are used within three to four lines of each other; it still breaks in really evil ways.
You may want to try using OpenAPI Generator (a community-driven version of Swagger Codegen) to generate the Go SDK as we've made many enhancements to the Go generator, which may have fixed the issue you mentioned: https://github.com/OpenAPITools/openapi-generator/pulls?utf8=%E2%9C%93&amp;q=is%3Amerged+is%3Apr+label%3A%22Client%3A+Go%22+ For more information about OpenAPI Generator, please refer to the project's README and the Q&amp;A: https://github.com/OpenAPITools/openapi-generator/blob/master/docs/qna.md
no, because everyone knows that if starts a new scope. It's obvious and non-confusing 
&gt; Someone writing almost any of these is going to expect the behaviour of the last one in every case (if they don't then they're intentionally reusing variable names in inner scopes and deserve everything they get). I don't understand what you're trying to say here. ISTM that intentionally reusing variable names and getting what you expect is‚Ä¶ a good thing?
let me tldr: - the author circumvented the GC and Go's memory allocation by allocating memory directly in CGO - that didn't work - they want to allocate ~50Gb of memory and Go's GC appears to not be fantastically performant at that scale - if you want GC to be performant at that scale, don't use pointers good to know :) 
Dgraph and Cayley are fairly different at its core as Cayley is more of a layer you could put on top of your existing database and Dgraph is a standalone solution. So if you already have a database like Postgres or Bolt you could use Cayley on top of it so you would be able to treat your db more like a graph. Dgraph on the other hand is a true distributed graph database and can be used on its own. Also, based on [these benchmarks](https://github.com/ankurayadav/graphdb-benchmarks/blob/master/README.md) Drgraph is about x37 faster than BoltDB+Cayley 
This is a problem with shadowing in general. In this case specifically, it's also a problem with twisty assignments. ``` if x := foo(); x { } ``` The thing you have to remember is that *any time* you see `:=` in an `if` statement, it's creating a *new* variable scoped to the if statement (also in `for` loops and other similar constructs). Ok, so not any time, because if you have two assignments, it'll only create the variables that don't exist yet. Yes, this is minorly confusing at first, and ideally it would be more obvious... but after a while you get used to using := and examining exactly what it'll do each time. As a side note... your example does a lot of twisty stuff with the one variable. If this were real code, I'd ask you to rename some of the variables to be different, because you're reusing this one in a bunch of places. Maybe if it were real code, it would be more obvious what you were trying to do, rather than randomly modifying an almost unnamed int.
Zero One Many
What are you using?
[removed]
[removed]
Ehrmm... I would venture to suggest that you are solving the wrong problem. Don't write your program to output directly to [seashells.io](https://seashells.io). You output to Stdout, and that is fine. Just catch that output and pipe it to [seashell.io](https://seashell.io) with a netcat. &amp;#x200B; goprogram **|** tee **&gt;(**nc seashells.io 1337**)** 
Seashells provides me with a URL which I have to store in DB whenever I dial it. That's why I first considered finding a way out in language level as I can simply read a line using `bufio`'s scanner and insert it to the DB.
 I think that you'll need to write both to the connection and to stdout. You'll propably want to use [`fmt.Fprint`](https://godoc.org/fmt#Fprint) to write a string to the connection (io.Writer). There is also a [seashells client on GitHub](https://github.com/hans-strudle/seashells) that seems to implement some important things such as reading the returned server url. It also [implements an io.MultiWriter](https://github.com/hans-strudle/seashells/blob/master/seashells.go#L43) which seems to be what you want to do.
Maybe I should have clarified further. The guy who was interviewing for a position pretty much immediately threw out a number that was about 1.5x of the best salary in the whole company. Sure money is important, that‚Äôs why you get the pay range *before* the interview. It‚Äôs basic info. I don‚Äôt need to imagine your scenarios as I often advocate for transparency in this sort of areas in our local meetup groups. That being said, any hiring has a pay range to negotiate. As an employer I want to give as much as possible and obviously want to get as much as possible in return as well. The four hour interviews, psych tests and god knows what else you may go through is a bit of a golden cuffs problem. Nobody would go through that without being financially significantly better off on the other side. Of course money is just part of the deal (hygiene basically), so you still need to have overlap here in terms of what makes you happy etcetera... it‚Äôs always a valid discussion, we‚Äôre just straying off topic a bit. Thank you for your comment. 
You may find this interesting: [http://jepsen.io/analyses/dgraph-1-0-2](http://jepsen.io/analyses/dgraph-1-0-2) &amp;#x200B;
`os.Pipe` will give you a read/write pair of `File`s -- you can use the write end as your `os.Stdout` and set up a goroutine to copy data from the read end to your socket.
Adding to the good resources provided you can also check out Jon Calhoun's stuff on YouTube for some alternative training materials. Cheers. 
"src" is a weird directory name there. Apart from typos, it seems to work just fine. `git clone https://github.com/ousbots/goModules &amp;&amp; cd goModules &amp;&amp; go build ./src/printHiApp &amp;&amp; ./printHiApp`. Are you inside your GOPATH? As of go1.11, module code isn't active in that scenario.
If you're looking for a fast-paced intro to GoLang (i.e., you already know Java/C++/etc) then I would recommend checking out this ASAP learning go course [https://exlskills.com/learn-en/courses/aap-learn-go-golang--learn\_golang\_asap](https://exlskills.com/learn-en/courses/aap-learn-go-golang--learn_golang_asap)
[removed]
[removed]
Check out the [TCPConn.File()](https://golang.org/pkg/net/#TCPConn.File) function. [Here's an example](https://play.golang.org/p/AIzmq-F1T0t) of how you could use this. It doesn't run in the playground because it disallows external network connections, but it works locally. It only does `Stdout` as a proof of concept, but adding `Stderr` should be trivial. 
What is the Go-ish directory name for the applications? It looks like I did not realize the paths had to be relative. After looking into this a little more, what I really wanted was: &gt; go build ... Thanks for helping me figure this out!
There are several reasons: * some of them don‚Äôt have iterator * some of them are not thread safe for reading * my package has ability to find record lazily (https://github.com/alldroll/cdb/blob/master/reader.go#L204) * it is not necessary to use my package, it was just a challenge for me and I would like to share my experience 
[removed]
[removed]
10?
I don't know man. Is there the possibility that all of these people who write lots of Go every day know a thing or two more than you, a newbie?
It turns out releasing software with someone else's code it in causes lots of shit to get thrown.
One word. Bukkit.
Suppose you have a list of numbers. You can tell how long the list is, without looking at what numbers are in the list. Suppose you have a list of puppies. You can tell how long the list is, without looking at what puppies are in the list. The idea of "list length" does not care about what kind of items are in the list. It only cares that there *is* a list. There are a lot of concepts about lists (and other data structures) that do not care what type the items are. *Type checking* is the idea that the language should be able to tell you if you're asking to do something on the wrong type of data. For instance, lists have a well-defined length, but network sockets do not. If your code tries to take the length of a network socket, that should be an error that the compiler tells you about. Go does that already. (Unlike Python or Ruby, which do not.) Slightly more complicated: For any type T, there is a set of operations that can be done on values of that type. If you have two different types T and U that both support the same operation, then it would be nice to be able to write a function that takes either a *list-of-T* or a *list-of-U* and performs that operation on each item of the list. Go's concept of *interfaces* supports this partway. However, if you look at code that uses interfaces, you will often see functions that take or return the type `interface{}`. This basically throws out all the type checking that the language could do. It would be nice if there were a way in Go to deal with these sort of situations without using something as wide-open as `interface{}`.
ZOMG COLLECTIONS ARE HAAAAARDDDD. THE FUCK IS LIST&lt;&gt;, AND HOW THE FUCK DOES GROCERYLIST&lt;VEGI&gt; HAVE CUCUMBERS?!???
A young pretty princess tried to get to a ball. She drove in her carriage to the big green castle, where small yellow soldier stopped her and said - "I'm sorry young pretty princess. Only bald men over 30 are allowed to enter". Young pretty princess wasn't happy. "Why can't I dance at the ball? Why you not let me in, small yellow soldier?". "The Big Bad Dragon told me to only pass bald men over 30. You should ask him". Young pretty princess went to The Big Bad Dragon, where she also met flour covered baker. "He won't let me in" - he cried - "I'm bald, but only 23 years old. I was practising dance moves this whole afternoon, but have to wait 7 years now". Young pretty princess decided it was not fair to limit access so cruelly, so she asked The Big Bad Dragon "Why are you so mean? What is so special about bald men over 30?". The Big Bad Dragon looked around in fear, then whispered "It's The Witch. She threw a spell on me. To the end of my days I have to decide what kind of people can enter my ball and cannot allow anyone else. The choice of bald men over 30 was just as good as any else. Don't be mad at me. I can't help it". Young, pretty princess thought about it for a moment, then came up with an idea. "Why don't you just tell the small yellow soldier to allow persons?". "Persons?" asked The Big Bad Dragon, "That's a great idea! I shall tell that to Bob right away!". "That's fantastic!" said happily young pretty princess. "Who's Bob?" asked flour covered baker and they both went to the door, where small yellow soldier Bob allowed them to enter with many other people from the Town, that came in the meantime. The ball was boring, so young pretty princess killed and ate all persons and The Big Bad Dragon. She was hungry and there was no food on the tables, because strict diet was very popular among bald men over 30.
Maybe try unmarshaling into a `map[string]interface{}` instead?
I use the Go and Python versions enough that I wrote a Ruby port called [qq](https://github.com/techspaceco/qq) a couple years back.
I'm having problems running it. I compiled from source (i'm on Linux Mint 19). I get this strange error while running the example snipped code they have. I'm not sure why it's not working. The credentials are correct. It seems like the call signature is wrong? I installed Seabolt 1.7 from source as well. &amp;#x200B; &amp;#x200B; \# github.com/neo4j-drivers/gobolt /home/calvin/go/src/github.com/neo4j-drivers/gobolt/connector.go:125:43: not enough arguments in call to \_Cfunc\_BoltConnector\_acquire have (\*\_Ctype\_struct\_BoltConnector, \_Ctype\_int) want (\*\_Ctype\_struct\_BoltConnector, \_Ctype\_int, \*\_Ctype\_struct\_BoltStatus) /home/calvin/go/src/github.com/neo4j-drivers/gobolt/connector.go:126:12: cResult.connection undefined (type \*\_Ctype\_struct\_BoltConnection has no field or method connection) /home/calvin/go/src/github.com/neo4j-drivers/gobolt/connector.go:127:70: cResult.connection\_error undefined (type \*\_Ctype\_struct\_BoltConnection has no field or method connection\_error) /home/calvin/go/src/github.com/neo4j-drivers/gobolt/connector.go:128:39: cResult.connection\_error\_ctx undefined (type \*\_Ctype\_struct\_BoltConnection has no field or method connection\_error\_ctx) /home/calvin/go/src/github.com/neo4j-drivers/gobolt/connector.go:130:44: cResult.connection\_status undefined (type \*\_Ctype\_struct\_BoltConnection has no field or method connection\_status) /home/calvin/go/src/github.com/neo4j-drivers/gobolt/connector.go:130:76: cResult.connection\_error undefined (type \*\_Ctype\_struct\_BoltConnection has no field or method connection\_error) /home/calvin/go/src/github.com/neo4j-drivers/gobolt/connector.go:133:61: cResult.connection undefined (type \*\_Ctype\_struct\_BoltConnection has no field or method connection) /home/calvin/go/src/github.com/neo4j-drivers/gobolt/connector.go:175:233: cannot use \_Ctype\_int(certsBuf.Len()) (type \_Ctype\_int) as type \_Ctype\_ulong in argument to func literal /home/calvin/go/src/github.com/neo4j-drivers/gobolt/logging.go:88:146: cannot use \_Ctype\_int(key) (type \_Ctype\_int) as type unsafe.Pointer in argument to func literal /home/calvin/go/src/github.com/neo4j-drivers/gobolt/resolver.go:69:198: cannot use \_Ctype\_int(key) (type \_Ctype\_int) as type unsafe.Pointer in argument to func literal /home/calvin/go/src/github.com/neo4j-drivers/gobolt/resolver.go:69:198: too many errors 
Today we need an add() for each type of variable: func addInts(a int, b int) int { return a + b } func addFloats(a float64, b float64) float64 { return a + b } With generics we could have a single add() function that could be used by ints and floats: func add(a T, b T) T { return a + b } It might sound like an obvious feature that every language should have. But there are valid arguments both ways.
Well, at least is faster than bogosort ...
interface asserted to pointer and pointer assigned to interface are both optimized by gc. For other kinds of types other than pointer, the larger size their values, the slower in assertions and assignments.
`os.Stdout` is of type `*os.File` so you can't just stuff an arbitrary `Writer` there, as OP found out. `Pipe` returns `*os.File` types so you can use it there.
That wasn't due to a library though, that was due to a contributor retracting the rights to their commits and DMCAing it because they didn't like that it was secretly owned by Mojang and wanted to burn it as a result.
i really like this
That would be my guess. The compiler has gotten much smarter since 1.4. Your best bet is probably to inspect the asm and see what instructions are actually being executed.
Impressive. Can GC do that even when behind a map[string]interface{} like this? https://play.golang.org/p/Jb8i3gSAVlG
I wouldn't worry about this unless it came up in a profile. There is so much other work processing an HTTP request that it's unlikely to matter. (For an inner loop, it's different.)
Looks really good. I'm going to have to try it out.
Gophercises.com if you like the tutorial format. JC does a great job
A few notes: - once go knows the type of something, it can generate optimal machine code for that type; it doesn't matter if the type was computed using type assertions or if it always had that type - computing the type of something using a type assert involves at least one "if" statement, but "if" statements are not really slow (unless you're causing a lot of mispredictions) - if it's an interface type, go can use virtual method calls, which are a little bit slower (a few extra instructions) but most of the time you shouldn't care - if it's a concrete type, go just makes a regular function call, it can be inlined, etc - if it isn't a pointer or interface, it might need to be copied, which could add overhead - but nothing unusual for value types Type assertions are not actually as tricky as you might think for the compiler. I suspect if you see performance improvements, it's due to either bad benchmarking or other optimizations that also improve all go code. In real code, type assertion overhead will not show up (unless you're doing it in a loop 100,000 times per request or something) You may be thinking more of reflection, which will always be slow but can work with any type because go does not generate machine code at runtime.
Type switch/assertion is very cheap. Just a few instructions. You can see that using godbolt: https://godbolt.org/z/2X2-u_ It used to be more expensive in 1.4: https://godbolt.org/z/xB-kjr because it involved a function call. 
by passing them as parameters to any functions that need them?
Some key difference between Titan and Tidis https://github.com/meitu/titan/issues/4
Thanks for the tip, I might give this ago.
Having two functions quickly grows out of control when you have a library that needs to support every number type int16, int32, int64, uint16, etc... The current proposal allows for a contract to say the type T must support addition or other expressions so it will only work for those types. 
Go can do a better job than the OS because it has more information. It's really just because of how Unix and Windows are designed. It isn't a problem inherent in all operating systems. When the OS switches between tasks, it has to use the most generic method possible, accounting for any possible differences between threads or processes, and enforcing security, and that ends up adding a lot of overhead. Go, on the other hand, knows exactly what the differences between threads are, so it can do much less work when switching.
This goes to show just how damn close Go is to proper sum types + pattern matching. You can just piggyback on interface representation with an extra check for exhaustivity!
Hmm what are you referring to with the cannibalistic princess, the programmer?
https://github.com/sanity-io/litter
Generics are only for languages with types. Let's start with types. Types are things that say what you can or can't do. Most languages have them. Assembly lets you do everything, but it crashes if you do it wrong. So every language has some kind of checks. Some checks are at runtime, like bounds checking on an array. Some checks are at compile time in some languages. No language does it the same. A type is usually something that says you can do a thing. An integer type usually lets you do math. A string type usually lets you do concatenation. A generic type is then a type of types. It's all types that do a certain thing like addition. So instead of having all of the integer operations, you specify just the ones you need. Who knows, maybe your language uses `+` to concatenate and your function works with strings too. That's specific to the language. So why do you want it? Because a type instead of a generic type is too specific. You don't just want to add integers. Sometimes you just want to add anything that supports it. But if you don't say anything, you're going to get an error if you use something that you can't add. A type is too specific, no type is not specific enough.
Oh, I see! You are very kind, thank you for the information! :) So far my writing workflow has become more comfortable, and I am adding features to `scholar` as I feel the need to improve something on that flow. Thank you for the encouragement and for making `papis`. I am learning a lot by looking at how `papis` tackles things.
Nothing. Every kids story should have a happy ending. 
wish it would write to stdout :(
&gt; I think I like the first approach with 2 functions better because I know exactly my input and expected output types. What? With generics you also know your input type - it's T. And you also know expected output type - it's the same type as input - T. 
&gt; Sort of defeats the premise of strong typing if you ask me Yes, because creating a generic instance with type A let's you pass params of type B top that instance, because strong typing is defeated....
Probably not since the finalizer on the `*os.File` would do that anyway once it gets garbage collected, but it seemed cleaner not to rely on that failsafe mechanism. However, if you're still using an old copy of `os.Stdout` somewhere you should skip this step.
I got it. By the way, what do you think about my answer?: https://www.reddit.com/r/golang/comments/9xp3ca/how_to_use_a_netconn_instead_of_osstdout/e9vdfw5/
Actually, if you're on a Unix-like system an even better option might be to use something like // Untested f := conn.(*net.TCPConn).File() syscall.Dup2(int(os.Stdout.Fd()), int(f.Fd())) syscall.Dup2(int(os.Stderr.Fd()), int(f.Fd())) runtime.KeepAlive(f) // Prevent f being prematurely closed by the GC. instead of closing and replacing `os.Stdout` and `os.Stderr`. This isn't portable, but should replace the underlying file descriptors so that even C-style prints to stdout and stderr (and places that have old copies of `os.Stdout` and `os.Stderr`) are captured. I also didn't check whether the old method would capture things like panic stack traces from the runtime but it probably won't because the runtime uses direct syscalls. This method should fix that.
Didn't see that before writing [this reply](https://www.reddit.com/r/golang/comments/9xp3ca/how_to_use_a_netconn_instead_of_osstdout/e9vjaxt/). But yeah, if you're comfortable not supporting Windows that should be fine.
How did you think of making use of `runtime.KeepAlive`. When do you call it? When it is necessary to do so? Why in my case it's used?
&gt; you need to add the values to the dict later There are dictionary initializers and .ToDictionary for building dicts from collections. 
First, some background info: when you create an `*os.File`, `os.NewFile()` calls [`runtime.SetFinalizer()`](https://golang.org/pkg/runtime/#SetFinalizer) to ensure that `f.close()` is called when that file is garbage collected, closing the file descriptor. When you call `f.Close()`, that finalizer is removed again because it's no longer necessary. And from [the `TCPConn.File()` documentation](https://golang.org/pkg/net/#TCPConn.File): &gt; File returns a copy of the underlying os.File It is the caller's responsibility to close f when finished. Closing c does not affect f, and closing f does not affect c. &gt; The returned os.File's file descriptor is different from the connection's. Attempting to change properties of the original using this duplicate may or may not have the desired effect. Which I read to mean that the returned `*os.File` is completely new, and therefore the only thing preventing its finalizer from being called is the fact that the returned pointer (`f`) is keeping it alive. Now, when you call that last `Dup2`, the variable `f` is no longer needed once that `f.Fd()` in the second argument has been called, so if `runtime.KeepAlive(f)` weren't used the garbage collector might decide to clean up `f` before `Dup2` returns. If it does so, that could close the OS file descriptor associated with it before the `dup2` syscall is called, which would break things because you're duplicating a closed file descriptor. `runtime.KeepAlive(f)` is a way to tell the garbage collector "actually, I need this `f` to stay alive a while longer so please don't GC it until after this call`".
the code for a generic Linked List or binary is generally exactly the same for all data types. You can take a peek at the List&lt;T&gt; and other collections in the C# source code. There is nothing weird about them. &amp;#x200B; When you use a generic function you annotate it with the types you are going to use, so you still know. &amp;#x200B; Like a Dictionary that takes keys of type A and returns data of type B you could create like so: var dict = new Dictionary&lt;int,string&gt;(); &amp;#x200B; Having used generics mostly in C# I don't understand most of the objections to them. I feel like templates in C++ have given people a bad taste for them, as those have worse error messages, more ways to be abused in weird ways, and more impact on compile times. &amp;#x200B; &amp;#x200B; &amp;#x200B; &amp;#x200B; &amp;#x200B; &amp;#x200B;
A generic function like "add" which uses the + operator, would either automatically constrain the allowed types to things that support the + operator (F# does this), or you would have to specify that constraint manually or get a compiler error, or it wouldn't let you write that generic function at all (C# is like this) &amp;#x200B; &amp;#x200B;
Nobody ever said it was slow. Go Reflection on the other hand...
Go is popularly used in cloud infrastructure development, tool programs development, block chain development, networking related area and database development. &amp;#x200B; You can also find some AI and GUI related Go projects, though such kinds of projects are not as many as above mentioned ones. &amp;#x200B; It is very helpful to learn (and to master) Go if you have both Java and C experiences. Go is not hard language to learn. If you have already some other language programming experiences, Go is quite easy to pick up. &amp;#x200B; However, if you want to master Go programming, in the process of learning Go, you should emphasize on basic concepts and terminologies in Go, so that you can understand many rule details in Go. Go is a language with simple syntax but full of all kinds of details.
&gt; EDIT: Though now that I think about it, replacing it with f.Close() is probably better... So that the compiler will say, "`Close` method of `f` is present in a defer statement. So I can't purge it because it will have to be run when the surrounding function returns." Is my inference correct?
A lot of opportunities. Try doing some job searches and see what turns up. Go is being deployed by companies of all sizes for projects of all kinds - pretty much everything but desktop GUI apps and games.
My take? Learn everything you can, polyglot programmers generally come up with better solutions (regardless of language actually used) in implementation. 
[removed]
About the long function thing.... There is just one command so I didn't feel the need to split up. But yeah, will try to refractor. I literally am a student learning c at school :) But is there something in particular I need to change so that it looks like Go
Do you have more notes on the algorithm or the implementation?
When wrote this code I wasn‚Äôt aware of the pcapgo implementation from gopacket, I thought their pcap package using C bindings was the only option. The pcapgo package looks really well implemented, they support gzipped PCAPs and pcapng. I will further evaluate their implementation before continuing to work on this one - Let‚Äôs treat this as an experiment for now. 
Because of your upcoming bank internship, I would learn something like Kotlin instead. Something that shares things in common with what you‚Äôre going to use at your internship. Go is a great language and I love it, but it‚Äôs small enough that you can always learn it later, when you‚Äôre more likely to apply what you‚Äôve learned. 
Thank you! That makes a lot of sense. 
The link: https://github.com/edwingeng/doublejump
very few people in the community at large have bothered to read all of the counter proposals. I quickly glanced through to find one that expresses basically my view: https://gist.github.com/zenhack/ad508d08c72fce6df945a49945ad826d the contract system is overly complicated, when interfaces can be extended to provide what is needed.
I have forked this some time ago for my own usage just to add stdout output (the author of original one declined my feature request) but now I must admit that more and more often I prefer go-spew instead of this.
There are many ways to expose an API on AWS (or other platform). Look up guides that talk about how to build a REST API for example. Couple of options: - run it on an instance with a public ip: you will need to take of proper sec group setup and you‚Äôll want to use https which might be tricky to set up (you should probably run something like nginx at the front to handle that) - you can do the same but use an ELB for loadbalancing and TLS (https) termination - you can also use ECS if you have your service dockerized (which is a good idea regardless) - Elastic Beanstalk can also be an option It all depends on what your requirements are regarding cost, reliabity, simplicity, etc. or what exactly you would like to learn from this project. Not sure how this is a golang question though. Maybe better suited to r/learnprogramming
I suggest adding `b.ReportAllocs()` to your benchmark and work on minimizing that. I can't benchmark it myself right now, but I can see a few areas that could be improved: - Instead of using `strings.Builder` + `strconv.Itoa`, allocate fixed-sized buffers and use `strconv.AppendInt`. - Instead of doing the final concatenation with `strings.Builder`, use another buffer. (Your `[]byte(b.String())` requires an extra allocation.) - You don't need to create the extra `out` slice; just pass the return value of `md5.Sum` directly to `hex.EncodeToString`. - On that note, typically a hash function should return a raw byte array, not a hex-encoded string. I suggest having separate functions for returning the hex string, the raw hash bytes, and the pre-hash bytes. - Lastly, md5 is nearly always the wrong choice these days. Why is Salesforce using a broken hash function?
Awesome, thanks for the tips! Will do another iteration later. Regarding the choice of md5, they explained it in their blog post for HASSH: https://engineering.salesforce.com/open-sourcing-hassh-abed3ae5044c Quote: ‚ÄöWhy was MD5 used, and not a stronger hash? Of all things, this had us torn. The notion of using a digest algorithm that is long known to have collisions seemed wrong. For this reason, we changed to the more robust SHA-256 for a short time; however during analysis the 64 character length of the SHA-256 was just too long, particularly when looking for many at once, or on a dashboard. It seemed the longer length was adding complexity when we were aiming for simplicity, and wasn‚Äôt solving a real problem in return. In the end, we made an assessment that MD5 hash collisions with this data type are not a real concern, so we made an about-turn and opted for the more compact 32 character MD5 hash. Time will tell !‚Äò
The lack of testing and long functions go hand in hand. Short functions that do less are easier to test 
100% agree with this; the contract stuff is just unnecessary. We could really just have operator overloading for the built-in symbols for things like `.Add`, `.Subtract`, etc.
I've been using https://github.com/sanity-io/litter and didn't know about https://github.com/davecgh/go-spew. I wonder if any of those has some clear advantage.
Make sure to have proper authentication. You can do this by exchanging TLS certificates, which will ensure the channel is secure. Also look into maintaining sessions in RESTful API. That ought to be a good start. 
Not exactly an answer to your question but maybe an alternative: [flosch/pongo2](https://github.com/flosch/pongo2) exists. It happily just eats those Jinja templates and you don't have to convert them‚Ä¶
So this: user, ok := userVar.(*UserStruct) Gets compiled very very roughly to: if userVar.iface.tab._type == UserStruct._type { return (userVar.iface.data as UserStruct), true } return nil, false Is that it? If so, that details a bit better what /u/soapysops meant with `computing the type of something using a type assert involves at least one "if" statement`.
I think a lot of game developers and analytics work would love basic operator overloading.
[mine](https://blog.merovius.de/2018/09/05/scrapping_contracts.html) ;) Though to be clear, there are a couple modifications that came up in the meantime: * I'd probably stay away from the pseudo-interface thing for now and instead forego operators in generic functions. * If I'd add pseudo-interfaces, I'd do it as a separate declarations (akin to contracts, but probably called "constraints")¬π and allow the identifier in type-parameters to refer either to an interface, or a constraint-declaration. This is to prevent the problem of having to explain what a pseudo-interface means when used on it's own (e.g. having `func foo(x arith)`, what would `foo(nil)` mean?). By introducing a separate constraint-declaration, this is circumvented, as constraints aren't valid type-names. With these modifications, however, I'm still pretty convinced that it would provide most if not all of the same power that generics bring without the complexity of the "function body as contracts" idea. [1] The same effect could be achieved by having a `constraint` kind of type, i.e. taking the role of `interface` instead of `type`. But I think a new declaration would express the spirit better.
Go is useful when: 1. Half a millisecond here or there doesn't matter that much in terms of performance. 2. Your application has a supported operating system underneath it 3. You will be dealing with all or one of: dates, Unicode, concurrency, networking 4. Maintainability is extremely important You'll find those points actually cover a really large portion on the programming space. Another way to think about it is, use Go where you might use C\# or Java but want better guarantees around runtime performance in additional to less complexity with regard to runtime dependencies. Especially if your C\# or Java code doesn't use generics. Yet another way to think about it: C and C++ will give you amazing performance at the cost of build time and maintenance complexity. If you don't really need the performance and could use the build time speed up, Go might be worth a look, particularly if you have a supported OS underneath.
The thing is, that operator overloading is fundamentally separate from generics. You can have one without the other - and no sane proposal for either of the two would prevent the other from working. I think it's better to view them as different - in particular, there was [a previous proposal for generics]( https://go.googlesource.com/proposal/+/master/design/go2draft-generics-overview.md#type-functions_june-2010) that is mostly identical to the current one (at least in semantics and power) - except that it *also* looped in operator overloading with generics. IMO, if you want either of the two, it's strategically better to talk about them separately, as solving them together is just too hard.
That is broadly it, but there aren't any actual function calls. It's more like this: ok := userVar.tab._type == &lt;_type for *UserStruct&gt; if ok { UserStructPtr = userVar.data } if ok { &lt;your actual if code here&gt; } (In practice the compiler may merge the two `if ok {...}` bits together.) Your UserVar here (the result from `ctx.Value("user")`) doesn't contain an `iface`; instead it is an `iface`, so the compiler directly uses the fields here. (Apparently Go 1.4 used to do part of this as an actual function call, which is one reason it's now faster.)
&gt; it's my first website. Oh wow! You‚Äôve got a lot to learn then‚Ä¶ **Background:** I‚Äôve recently started using AWS after joining a company as a DevOps Engineer, this is after 10+ years doing software development in companies with their own system administrators. It took me 1-2 weeks to understand the AWS ‚Äúway of things‚Äù, but this was only possible because I already had experience configuring, managing and deploying servers by hand before. **The Good:** AWS documentation is very clear and concise. **The Bad:** You‚Äôll need to learn a ton of new concepts. AWS is on itself, along with other similar platforms, just an interface with options to allow you to do things that otherwise you‚Äôd need to do in a command line interface directly on each server. Which means, many of the things that you‚Äôll learn is ‚Äúhow to translate this operation that I would normally do by hand, into a list of clicks and selections in the AWS interface‚Äù. First things first‚Ä¶ Read about [AWS Pricing](https://aws.amazon.com/pricing/) to understand how much money you‚Äôll have to pay. I‚Äôve read several articles from startups who happily start using the platform and later freak out with the huge bills after the auto-scaling kicks in. So unless you want to see your bank account deplete in big chunks of money, be sure to understand the cost of all the features that you‚Äôll be using. Then go through this small list of concepts: - How to set up the IAM User? _(and the account permissions)_ - What‚Äôs a SSH key pair? _(and how to use it to access the servers)_ - What‚Äôs a VPC? _(and how to layout a network map for your services)_ - What‚Äôs an EC2 instance? _(and how to choose the correct settings)_ - What‚Äôs an ELB? _(and how to use it along with your EC2 instances)_ - What‚Äôs a Security Group? _(and what settings work for your project)_ - What‚Äôs the ACM? _(and how to generate SSL certificates for your API)_ - What‚Äôs S3? _(and how to use it without exposing sensitive information)_ - What‚Äôs an RDS? _(and how to write when the instances are distributed)_ - How to use Route53? _(and how to deal with the traffic and failovers)_ - What are Regions and Availability Zones? _(and how to choose them)_ These are high level questions that will get you through the most basic concepts of the interface, and the more you read the more deeper you‚Äôll get into the AWS platform. You‚Äôll find yourself frequently switching from one page to another, clicking a lot of buttons, following many step-by-steps, and [referencing the AWS documentation](https://docs.aws.amazon.com/) for things that you‚Äôll only see once or twice during the whole process. Be sure to also read about: - How to properly deploy a project to an EC2 instance? - How to keep a process running with ‚Äúrunit‚Äù and ‚Äúsystemd‚Äù? - Do you need system logs? Read about ‚ÄúELB Access Logs + S3‚Äù - Will you be using a RDS? Distributed or localized? - How to design a proper backup and restore strategy? - How to maintain your EC2 instance in production mode? - How to deal with a compromised server and/or SSH key pair? - How to gracefully disable and delete EC2, ELB, VPC, etc‚Ä¶ - Learn how to use the health-check and monitors All of this is going to take time and effort, but all in all, you‚Äôll definitely learn a lot and the experience will help you with future opportunities, either by finding a new job or launching your own startup. Be sure to stay calm when bad things happen. Good luck üôÇ
&gt; it's my first website. Oh wow! You‚Äôve got a lot to learn then‚Ä¶ **Background:** I‚Äôve recently started using AWS after joining a company as a DevOps Engineer, this is after 10+ years doing software development in companies with their own system administrators. It took me 1-2 weeks to understand the AWS ‚Äúway of things‚Äù, but this was only possible because I already had experience configuring, managing and deploying servers by hand before. **The Good:** AWS documentation is very clear and concise. **The Bad:** You‚Äôll need to learn a ton of new concepts. AWS is on itself, along with other similar platforms, just an interface with options to allow you to do things that otherwise you‚Äôd need to do in a command line interface directly on each server. Which means, many of the things that you‚Äôll learn is ‚Äúhow to translate this operation that I would normally do by hand, into a list of clicks and selections in the AWS interface‚Äù. **First things first‚Ä¶** Read about [AWS Pricing](https://aws.amazon.com/pricing/) to understand how much money you‚Äôll have to pay. I‚Äôve read several articles from startups who happily start using the platform and later freak out with the huge bills after the auto-scaling kicks in. So unless you want to see your bank account deplete in big chunks of money, be sure to understand the cost of all the features that you‚Äôll be using. **Then go through this small list of concepts:** - How to set up the IAM User? _(and the account permissions)_ - What‚Äôs a SSH key pair? _(and how to use it to access the servers)_ - What‚Äôs a VPC? _(and how to layout a network map for your services)_ - What‚Äôs an EC2 instance? _(and how to choose the correct settings)_ - What‚Äôs an ELB? _(and how to use it along with your EC2 instances)_ - What‚Äôs a Security Group? _(and what settings work for your project)_ - What‚Äôs the ACM? _(and how to generate SSL certificates for your API)_ - What‚Äôs S3? _(and how to use it without exposing sensitive information)_ - What‚Äôs an RDS? _(and how to write when the instances are distributed)_ - How to use Route53? _(and how to deal with the traffic and failovers)_ - What are Regions and Availability Zones? _(and how to choose them)_ These are high level questions that will get you through the most basic concepts of the interface, and the more you read the more deeper you‚Äôll get into the AWS platform. You‚Äôll find yourself frequently switching from one page to another, clicking a lot of buttons, following many step-by-steps, and [referencing the AWS documentation](https://docs.aws.amazon.com/) for things that you‚Äôll only see once or twice during the whole process. **Be sure to also read about:** - How to properly deploy a project to an EC2 instance? - How to keep a process running with ‚Äúrunit‚Äù and ‚Äúsystemd‚Äù? - Do you need system logs? Read about ‚ÄúELB Access Logs + S3‚Äù - Will you be using a RDS? Distributed or localized? - How to design a proper backup and restore strategy? - How to maintain your EC2 instance in production mode? - How to deal with a compromised server and/or SSH key pair? - How to gracefully disable and delete EC2, ELB, VPC, etc‚Ä¶ - Learn how to use the health-check and monitors All of this is going to take time and effort, but all in all, you‚Äôll definitely learn a lot and the experience will help you with future opportunities, either by finding a new job or launching your own startup. Be sure to stay calm when bad things happen. Good luck üôÇ
This guy expresses my view the best: https://gist.github.com/hantuo/574aeda064c18eb69aa6806fbb259510 Generics should just be another type and his design supports union type. 
You're code got me interested in https://github.com/gocolly/colly so thank you. From now on I'll use Go to scrape stuff instead of Python.
I think overloading introduces unnecessary ambiguity in what is an extremely simple syntax. With a method call, you can tell "what goes into what", and the name is self-documenting, which helps if you need to do things other than add in the `Add` call for a complex container type. `a += b` implies that the underlying operation is doing a single thing; it implies that no conversion or assertion needs to be done. An overloaded operator can do weird stuff completely transparently, which I feel goes against Go's "simplicity" philosophy.
They're orthogonal concepts, but the fact that primitives and their operators cannot be described by interfaces limits what you can do with generics, unless you invent something like contracts that relies on expression validity testing. The [linked proposal](https://gist.github.com/zenhack/ad508d08c72fce6df945a49945ad826d) shows this: If you have a typeclass-style interface `Ordered` (as described [here](https://gist.github.com/zenhack/ad508d08c72fce6df945a49945ad826d#implications)) that defines a `Less(other T) bool`, then the only way to use it with primitives like ints and floats is to write a wrapper that adds a `Less` for each type. If all the built-in types had corresponding interfaces for their operators, then this wouldn't be necessary. Rust actually does this. Rust doesn't have operator overloading as seen in languages like C++, but many of the operators map directly to standard traits. For example, `a &lt; b` is effectively an alias for `a.partial_cmp(b)` if `a` implements the `std::cmp::PartialOrd` trait. Since all the built-in primitives implement `PartialOrd`, you can pass primitives to a function that takes a `PartialOrd`.
I agree üíØ
Default parameters are the Devil.
Thank you for the link :)
Nice! I remember having issues and spending a while getting the artist's name. Was reading this [https://www.reddit.com/r/golang/comments/81bj2z/scraping\_the\_web\_with\_colly\_and\_goquery/](https://www.reddit.com/r/golang/comments/81bj2z/scraping_the_web_with_colly_and_goquery/) &amp;#x200B;
I‚Äôm a Go programmer and love Go, but if you are early in a career and asking this question you should be looking into different language types. Java is object oriented, Go is procedural, JavaScript is obviously a scripting language. So take a look at a Functional language: Clojure or Elixir would be my suggestions. However if you find you love C or are interested in systems work, dive into Go. But I suggest expanding and finding what you like first then deep dive.
Go like C++, it is used to create something that other languages like php, JavaScript can't do, it's not just for web, basically if you use Go on web development, rest api dev that nodejs and php can handle in a simple way, you are wasting the power of Go, just imagine how many startups nowadays use C++ as backend? I don't know how Go is used in other regions, I know Go is widely used on SDN in mainland China... I love Go, because It makes me jump out the circle of web development... You see, web applications are simply CRUD applications on repeat until the cows come home. Everyone knows how to do CRUD, but then you have to learn how to do it the React way, the MERN stack way‚Ä¶ the vue way, there are so many different tools to solve the same exact simple, boring problems. Unless I am building some sort of HD streaming service, I am probably building a CRUD app.
The paper: [https://arxiv.org/pdf/1406.2294.pdf](https://arxiv.org/pdf/1406.2294.pdf)
I'm aware of the Jump Hash paper. I implemented it and referenced in my post on consistent hashing algorithm trade-offs (https://medium.com/@dgryski/consistent-hashing-algorithmic-tradeoffs-ef6b8e2fcae8). Looking at your code, you're using my implementation of it. My question was about how your variation worked.
&gt;the contract system is overly complicated, when interfaces can be extended to provide what is needed. I wonder why they didn't extend the `interface` syntax then. Maybe it's because `interface` and `contract` works internally different?
Plenty of use cases where default parameters are useful...
Why the downvotes? That's a legit opinion, and I support that too, adding generics to Go takes away some of it's beauty that was initially there.
Indeed. Once generics have been introduced to a language, the entire style in which people write code changes. I don't want to deal with that.
Ah, that's nice to read. I'm a go newb, (not a development newb) and this proposal matches what I imagined after thinking about generics in go for a while. Nice to have a bit of confirmation once in a while.
I dont see the ambiguity in a + b ==== a.Add(b)
I've been doing work lately with social network analysis, handling graphs with tens of millions of nodes and billions of edges. I have always run up against the limit of my RAM (32 GB) or algorithm-based limits before the GC ever becomes a problem. That said, it's really difficult to predict how a particular case will behave because it's not just the size of the memory or the number of objects but the patterns of usage.
This also fits within a RESTful specification with out breaking any rules.
Does Colly seem sufficiently good at scraping to replace beautifulsoup and python? I haven't used BS but I've used R packages meant to work like it, and it's quite nice.
Thanks. That just works
Everything becomes definite / literal at some point. Not providing defaults can lead to overly verbose interfaces and burdensome to users. I had some neurotic fixation with not making decisions for people for a while. (Not saying that poster engaging in that. ) People need to understand what there doing right? It lead to some obtuse tools that I hope are now obviated. 
This quickly becomes a rabbit hole when you try to do higher order matrix multiplications. 
This is a really fun article! &gt; It also checks the call depth (currently maximum 1000), to avoid a panic in case of unbounded recursion. Did you actually encounter this? Because Go stacks [could resize to as large as necessary](https://dave.cheney.net/2013/06/02/why-is-a-goroutines-stack-infinite), within the bounds of how much RAM the computer has... but, these days the stack is [limited to 1GB.](https://golang.org/src/runtime/proc.go#L117) Which is still a lot more than 1000 recursions, typically. It would be fun if `runtime.maxstacksize` could be adjusted, but I don't see any exposed way to do that besides building your own modified compiler.
Investigating the GitHub issues, it looks like only 2 out of 23 discovered issues remain unfixed. Dgraph has come a long way in a very short time.
&gt; They're orthogonal concepts, but the fact that primitives and their operators cannot be described by interfaces limits what you can do with generics I'm well aware. Bundling them is still strategically bad. Most of the downsides of the contracts proposal are coming from the requirement to support operators. And yet, the result *still* doesn't allow you to write a generic function that you can use both with operators and with interfaces (thus, you won't be able to have, say, a generic `Max` that works both with `int` and with `*big.Int`). If you drop the consideration for operators completely from the consideration of generics, you get *far* simpler and better designs. And if you consider operator overloading on its own, it will then naturally extend to generic code anyway. By bundling the ideas, we are ending up with *neither* a good generics design *nor* actual operator overloading.
My favorite example of this is that e.g. in Python, `a += b` and `a = a + b` are different things. And that's not even "bad design", but a natural consequence of wanting a) operator overloading and b) efficiency. Because to get efficiency, you need both a mutating and a non-mutating definition of `Add`. But if you want operators to be a user-defined concept, the compiler can't automatically transform one into the other as it can with builtin operators - because it can't know how.
Contracts allow you to require relations between types, whereas interfaces only allow you to require stuff about individual types.
LOL I had a big in a tail recursion implementation once. I first noticed something was wrong when the mouse cursor was really sluggish. This was early go 1 days. Fun times!
Thanks, now I know how to use the awk.
The way I see it is that default parameters and overloading go directly against readability at the call site, it's impossible to know which exact function and which arguments are being passed without analyzing the (potentially complicated) set of names in scope. Tooling can of course help but I prefer it as it is. &amp;#x200B; There are ways of simulating default parameters if you really really want and I'm not sure any studies have been done on the benefits to future modification to APIs (would love to see some!) &amp;#x200B; Optional declared implementation is interesting but not sure what it really adds since you can always do var \_ Interface = (\*MyType)(nil) as an assert. &amp;#x200B;
Yes, doublejump is based on your implementation. Thank you for your work. doublejump maintains 2 arrays inside. The 1st one is loose and the 2nd one is compact. When removing a node, the loose array sets the corresponding position to nil while the compact array move the tail node to the empty position. When hashing, doublejump tries to get a node with the loose array first. If nil is hit, it turns to get a node with the compact array. The variation is not perfect. The more nodes are removed, the more nodes are affected when REMOVING an additional node.
Good Job üëç I‚Äòm also working on a scrape for an affiliate website. Those are fun little projects.
I originally favoured your counterproposal (and great writeups and defenses on golang-nuts :) ) and as a minimal addition option I still do, however after extensively studying the contracts and the C++ (and related) concepts ideas I think Go has a real opportunity to do something really good in that space. 
Great explanation on a relevant and actual topic, well done!
I'm sure Beautifulsoup is more mature. But for the simple scrapping I usually do, Colly seems fine. Also I prefer Colly's event driven approach [like in this example](https://github.com/gocolly/colly/blob/master/_examples/basic/basic.go): func main() { c := colly.NewCollector(colly.AllowedDomains("hackerspaces.org", "wiki.hackerspaces.org")) // Whenever we find a link c.OnHTML("a[href]", func(e *colly.HTMLElement) { link := e.Attr("href") fmt.Printf("Link found: %q -&gt; %s\n", e.Text, link) // Visit link, but only if in AllowedDomains c.Visit(e.Request.AbsoluteURL(link)) }) // Before making a request print "Visiting ..." c.OnRequest(func(r *colly.Request) { fmt.Println("Visiting", r.URL.String()) }) // Start scraping on https://hackerspaces.org c.Visit("https://hackerspaces.org/") } Also Python's GIL weights in this decision.
Recommend some error handling. For example, in the stack example, if the stack is at capacity, the push method silently returns with no indication that the push failed. Or if the stack is empty, why return MinInt? that number wasn't on the stack; should return an error. &amp;#x200B; Compare with a similar repo [here](https://github.com/floyernick/Data-Structures-and-Algorithms/blob/master/Stack(Array)/Stack.go).
Oh, you are right. I'll check it out as soon as possible. This repo is my first Go lang implemention for Data Structures. :) Also thanks for reference.
There are a number of articles on hand-building recursive descent parsers in Go. The Gopher Academy blog series has had a few. You can also go the yacc route and there are tutorials for that too.
Your
Am I the only one who got the feeling that Rob Pike is stepping away from the development of the language?
Fixed, thanks!
For what?
Great stuff, liked the linked post a lot as well.
People pick languages based on their requirements. I'm currently open source deving with go because it's a convenient between C/Python solution for some low level stuff. I didn't set out to develop in go, the project came first.
That question is a bit strange as the time and effort to learn Go is pretty low and while the benefits are high. Like with most things the question is less about good/bad or should/should not but is it worth it? It will cost you 4 weeks of a few hours per day or 3 months with a few hours per week and you will know something knew. Contrast this with learning HoTT, Haskell, the Violin or Mandarin.
Good writeup. Thanks. In particular the "how to Daemonize" your server was very useful.
It's for a blockchain interoperability project to connect all the smart contract networks, and build integrated decentralized applications.
Was there a specific website you checked to find out your first open source projects to contribute by any chance? I'm gonna work on creating a website layout for the open source dev community &amp; rewards, currently reading a bunch of materials : ) 
I just hate how builtin types have different capabilities from user defined types. Native ints ? Sure a+b. Library defined bigints? a.Add(b)
https://blog.gopheracademy.com/advent-2014/parsers-lexers/
I somewhat had the same impression, for example, attendance at GopherCon may serve as an indicator. I think he's investing time in other projects like Upspin and might view Go as more or less "done". One should not underestimate he's of the creative hacker sorts who needs a new BHAG challenge now and then and I suppose every decade or so he'd re-focus (e.g., Plan 9, Unicode, Go, ?).
[removed]
No, I needed to solve a problem. I contributed to other projects because I found a bunch of bugs in library software.
Example shows how you can build Android apk from your Go-SDL2 project easily with new `-tags static` feature (updated to latest 2.0.9 version).
I see no need to complicate a language founded on simplicity by adding functionality that can be achieved using interfaces as-is.
All of which are trivially covered by a wrapper function to supply the defaults in an explicit manner. Bugs typically hide under assumptions.
Unlike /u/poy_ I'm surprised how positive he is about some of these drafts - even talking about the need for polymorphism. He is very much from the cathedral-style of software development. You get a few clever people together and create something awesome (unix, C, plan 9) - then others can take it or leave it. Letting Go must be difficult for Rob Pike - I don't think he trusts the community not to ruin it.
There's actually an open source bridge doing just that written in Go! They even have it running on the Goerli testnet right now! https://github.com/ChainSafeSystems/ChainBridge 
Honestly I don't think I noticed until now because I would rarely care about the order. I'm not surprised JSON doesn't require that.
https://stackoverflow.com/jobs/developer-jobs-using-golang has a bunch and some interesting filters like salary and remote. /r/golang also sometimes has "Who is hiring" threads, and there is a jobs channel in the https://invite.slack.golangbridge.org gophers slack.
This can be extremely important. Canonical json is necessary for doing things like generating a hash of the object consistently.
Maybe remoteok.io as well? What about angel.co ? 
I don‚Äôt see a whole lot of jobs looking for Go
Thanks for the shout out :) 
path is only for forward slashes, as in URLs https://godoc.org/path
Looking at some of the issues that get raised on the GitHub I can sympathise with that
just got the book - looks great. Thanks.
Repost of: https://www.reddit.com/r/golang/comments/9y5b4x/sydney_golang_meetup_rob_pike_go_2_draft/
&gt; Letting Go ...
About 2/3 the jobs in he Gophers slack's #jobs channel are in Europe, so that might be a good resource.
If you are decoding and then re-encoding a JSON object for signature verification, you are doing it wrong. The signature must be sent as a separate field/parameter and you verify the hash when the JSON object is still just a string.
That's code that interfaces can *already* do, something that makes generics different is you can specify that two parameters have the *same* type T, which satisfies some interface. So if you had a generic function func GetOrDefault(theMap map[K] V, key K, defaultValue V) V; You want to be able to specify that the V you're passing in is the same concrete type as the V it's returning, but in their proposal, the input V could be int, float, or string, and the result can independently be int, float, or string. 
I'm not sure what you mean can be achieved by interfaces. A usual case of using default parameters are combined functions like Split/SplitN ... where you can just have n=-1 as a default parameter and don't need the second function. And although I somewhat agree about simplicity, that's a different argument than "Default parameters are the Devil"
&gt; In order to hash, you have to have a consistent order. No, you don't. You json encode your map (in whatever order) and get a string. *Then* you generate the hash. You send both the string and the hash to the receiver, who then validates the hash without caring at all about the json key order because there is no json, only a string. &gt; Json.Marshal already canonicalizes it making such a scenario possible. json.Marshal is a single implementation of a json encoder for a single programming language. The fact that it object keys is an implementation detail outside the spec, so it shouldn't be relied upon for anything, much less signature validation.
[removed]
My comment on interfaces was not about default parameters, it was about generics. Default parameters **are** the devil because they turn an explicit decision into an implicit assumption about the receiver in that they become an implicit part of the contract with the function. Code is hard to read. It's really hard to read when it's not explicit as hell. Default parameters are all about the perceived benefits of more easily writing code. But ease of writing is, IMHO, always superseded by ease of maintaining the code in the future. So, rather than have a doSomething() function with default parameters, I'd far prefer a doSomething() function with no default parameters, and a doSomethingWithDefaults() function with no default parameters. Now you have the best of both worlds.
How did you make your API? You might be able to get more throughput by using channels?
What‚Äôs your level of experience with the language?
I'm not taking one side but something that came to my mind while reading this was that if the consistent order wasn't there 2 json.Marshals of the same struct could result in a different hash which could be a pain in the ass in some cases so it may be useful that it is sorted so you get a deterministic output if the data is still the same.
"I think it would be great if this syntax looked and behaved exactly like &lt;insert language&gt;" "Okay and why is that?" "Because &lt;insert language&gt; is better" Or my other favourite is when people say they implemented a really inefficient algorithm so it should be made part of standard lob so it becomes more efficient... Like the algorithm has the same complexity either way buddy. I think the maintainers do a good job of keeping everything in check though.
&gt; JSON objects are unordered and if you are relying on the order, you are just being lucky with that particular implementation. It's OK as long as you know that you are depending on details of a particular implementation. Preferably documenting it as such. I've got a place where I have a "canonicalize" function, which simply decodes the JSON into an `interface{}` and re-encodes it with the Go JSON encoder. I have no delusions that this is universally available, but I don't need it to be, in this particular place. 
That's also true for sure. There are better ways to consistently hash a structure than encoding it to json and then hashing it. Sorry for not understanding the discussion correctly
Much appreciated!
LinkedIn search is pretty decent too
&gt; On a second read, I think we are talking about different things ... you are talking about an object consistently hashing to the same key Yes, matt could probably have worded it better (but I understood immediately ... so *shrugs*) but it's more generic than "an object" it's any single block of JSON, if the JSON is always encoded consistently then it always hashes to the same value and it allows you to do a lot of useful things. Also, IMNSHO, this applies more generally too, it's worth a significant amount of code/effort to make it so your output is identical given the same semantic input.
I see a significant section on overloading but not on primitives having methods, which are not the same. But yes, it would clearly be a language change, and would break compatibility. And no, it would not be difficult to determine how it should work, because you can already add methods to custom primitives and it would work exactly like that. 
A single host should be able to handle thousands to hundreds of thousands of connections - I'm confused by what exactly the problem is.
I've been able to debug gin projects pretty deep down the call stack with VSCode and delve. I just click to set the breakpoint. It can even be in a lib file. Tab back to main.go and press F5. Could you provide more information about the error? Perhaps a screenshot.
New to go: The documentation shows 2 ways to parse through json. 1) Unmarshal into either structs (if the data is consistent and structured) or to byte arrays (if the data is unstructured or inconsistent; throwing in interfaces if necessary https://attilaolah.eu/2013/11/29/json-decoding-in-go/) 2) Using a decoder via json.NewDecoder() Which of these 2 methods is recommended to use?
I see, do you just go to github for that?
Great luck in your endeavors too guys! 
Not byte arrays, `[]interface{}`s. As for which one to use, it depends on what you're doing. Unmarshal if you want to decode the entire thing into some type. Use a decoder if you want to "stream" it, decoding one thing at a time as they comes in. Generally, you should probably use Unmarshal.
&gt; In order to hash, you have to have a consistent order. You should not use a hashing strategies for Maps that relies on key order. 
`bytes.Buffer` is a great type, I use it all the time. The `Next` method is especially useful. But you still need to be careful when using it if you want to avoid allocating, and it doesn't play well with `Append`-style functions like `strconv.AppendInt`, so in OP's case I'd stick with raw `[]byte` buffers.
That's only the map iteration order, which has to be random. But they are actually adding a requirement for a formatted map to have sorted keys: https://go-review.googlesource.com/c/go/+/142737/
We are waiting for generics...
Very cool, I didn't know that was coming.
How is no error return convenient?
I would be interested in your thoughts on applying this pattern to doing FSMs in go: [https://medium.com/@mark.truluck/the-machine-in-the-ghost-46f856f94ed2](https://medium.com/@mark.truluck/the-machine-in-the-ghost-46f856f94ed2) &amp;#x200B; The Frame Machine Notation is intended to be a very concise way to specifiy an FSM and then defines a reference implementation approach. I'd be interested if you thought the proprosed reference mechanism was very "go" like.
It's not about host. I'm resource-limited on hardware in definite numbers and I want all user to benefit equally from the shared service. Guarenteeing that nobody overkills the resources more than anyone else.
Why the downvoting? Does the truth hurt too much?
Yeah idk. I like Go, I‚Äôd love to get paid for it. 
&gt; I'm limited on resources in definite numbers How/why exactly is this the case?
Indeed!
I am not really sold on go. I am currently getting paid using it, but it really doesn‚Äôt seem like it is a mature enough ecosystem to be worth it. Dependency management seems to be a total afterthought that still isn‚Äôt settled. In my org at least, builds seem to be super fragile. Different parts of even single projects require different GOPATHs, magefiles and makefiles are used randomly and they are always broken. Maybe my company is just a huge dumpster fire, but people chasing the shiny thing seems to be the cause of a lot of our issues.
As I've stated in the main post, it's due to infra provider, which is Heroku in my case. It has hard limits on the maximum simultaneously running one-off dyno number. https://devcenter.heroku.com/articles/dyno-types#concurrent-one-off-dyno-limits 
&gt; It has hard limits on the maximum simultaneously running one-off dyno number. And obviously I spawn one on each request sent by users It is not obvious to me why you would do this. Just run server(s) that can handle requests from multiple clients.
Until where can I run multiple servers? That's my I'm trying to make it do with less number and set dynamic constraints.
Sounds like your company is a dumpster fire and it would be in bad shape no matter what language you used. We primarily use Node, Go, PHP and by far the most reliable builds are Go. Note, we use vendoring for Go since most Go services require so few dependencies making it reasonable to include in the repo (unlike Node and PHP). I'm super happy with not needing to have repos in GOPATH with 1.11 modules and haven't had any problems on the team.
I will have a look at FaaS platforms. But your idea on handling multiple requests in a single container is no go. Because I'm consuming egress bandwidth heavily and this'd prolong the time to complete tasks.
Upside: you don't have to write code to handle an error Downside: you have to rely on a linter to check correctness
\`url.Encode()\` will also sort alphabetically. This took a long time to debug - turns out the api I was using required query parameters to be in a very specific order.
It wouldn't break go1 compatibility. Adding methods is explicitly excluded from this. To quote: &gt;Methods. As with struct fields, it may be necessary to add methods to types. Under some circumstances, such as when the type is embedded in a struct along with another type, the addition of the new method may break the struct by creating a conflict with an existing method of the other embedded type. We cannot protect against this rare case and do not guarantee compatibility should it arise. 
Yeah, my current company is going to burn. If we used a different language, it would still be on fire. The half that uses node is apparently worse than what I am dealing with, which doesn‚Äôt sound possible, but apparently it is true. However, you mention that not having 1.11 stuff being good seems to confirm what I have observed. Go isn‚Äôt fully baked. Maybe I am just jaded due to living in a dumpster fire, but I think Go itself isn‚Äôt quite ready for prime time.
Pretty good example of complete solution! Looking forward for WASM example ;)
Yes usually
Gopher Slack #jobs channel pinned items. I post in there at least once a month.
Well, [parsing JSON is a minefield](http://seriot.ch/parsing_json.php).
Vgo / "go mod" is the way to go. Look into it it works very well.
Thanks for all the replies! I'll look into all the proposed sites... :)
There is a lot of jobs in London for go programmers. I am getting emails from Linkedin recruiters at least once a week about a golang job
Kubƒô is good.
*beep beep* Hi, I'm JobsHelperBot, your friendly neighborhood jobs helper bot! My job in life is to help you with your job search but I'm just 427.4 days old and I'm still learning, so please tell me if I screw up. *boop* It looks like you're asking about job search advice. But, I'm only ~28% sure of this. Let me know if I'm wrong! Have you checked out Forbes, LiveCareer, TalentWorks? They've got some great resources: * https://www.forbes.com/sites/karstenstrauss/2017/03/07/job-hunting-tips-for-2017/#794febea5c12 * https://www.livecareer.com/quintessential/15-job-hunting-tips * https://talent.works/automate-your-job-search
Old repo. Nowadays maintained fork is at grumpyhome/. 
Now I don‚Äôt believe we‚Äôll ever get generics ;(
Look at your room, it's full of toys. Model trains, toy cars, stuffed animals, dolls, and so on. Your room is chaos, and you want to organize your stuff. You want some boxes to put your toys in. One box is for toy cars, one is for stuffed animals, one is for dolls, one is for model trains. You want to label each box so that you know where to find what. You have to make those boxes yourself. The store doesn't have any. But you have lots of cardboard. So you figure out how to cut and glue together the cardboard to make a box. Because you're a very smart kid, you create a paper blueprint that shows you how to make boxes easily. You make a few boxes, each of them open at the top, so you can put anything inside. You label them for the different toys, and put your toys in. But by accident, you put your favorite doll in the cars box. The next day, you look for your doll in the dolls box, but you can't find it. You cry. The day after, your friend comes over, and you want to show him your cool toy cars. You take the toy car box, reach inside, and pull out the doll. Your friend thinks you're stupid because you gave him a doll and said it was a car. You cry again. You decide to make sure this can't happen to you again. You get your parents to give you four cats and put them in the boxes. The cats love boxes. You train each cat to only allow a specific kind of toy in the box, and complain otherwise. Now when you try to put the doll in the box, the cat won't let you and scratches your hand. You succeeded in not having the toys in the wrong boxes, but your hand hurts. Also, you have to spend some time every day feeding your cats instead of playing. You have a better idea. You will make boxes where you can only put the right toy inside, because their opening won't allow anything else. So you make a box that can only hold toy cars. But your blueprint doesn't work for that, so you have to draw a new blueprint. You make a toy car box from that. Then you want to make a doll box, but your toy car blueprint doesn't work for that, so you have to draw another blueprint. You can look at the toy car blueprint for most of the design, but the cover needs to be different. It's a lot of work, but you eventually have blueprints and boxes for every kind of toy you need. You put in your toys, but then you realize that you made a mistake, and your boxes don't have a bottom, so the toys simply fall out. Because you copied the mistake from the toy car box to all other blueprints, you have to fix every blueprint separately. You are very annoyed. But your toys are sorted, and your hand is unscratched. You keep the cats around because you are not a monster. Then your parents show you a trick. If you use a bit of adhesive tape, you can have a blueprint for most of the box, and hold a separate blueprint for the cover in the right place just long enough to make a box for the right kind of toy. Then you can remove the cover blueprint and put a different cover blueprint there, and make another box. If you made a mistake in the main part of the box, you just have to change that one blueprint. You are amazed. You decide that when you grow up, you will use adhesive tape too. And that's what generics in programming languages are all about. Explanation if it wasn't obvious: The boxes are a data structure. Open boxes use interface{}. The cats are dynamic checking of the types; runtime discovery of bugs is no fun, so I used the scratched hand metaphor for this. The boxes with specific covers means copy-paste re-implementing the data structure for every specific type (like strings, integer, floats, ...), and the missing bottom is what happens when you have a bug in such a data structure. The modular blueprints are generics, with the cover being the type parameter.
sorry, that I was unaware about --comply flag. check this out https://github.com/therecipe/qt/issues/259#issuecomment-438007743
do you know about --comply flag. check this out https://github.com/therecipe/qt/issues/259#issuecomment-438007743
I did not until recently. However, it‚Äôs still not ideal in that it reveals a bunch more of your src if you weren‚Äôt intending for it to be open. 
Ha, good question! I didn't encounter it in real code, but the fuzzer found it. Basically it had tried calling a function `function f() { f() }`. So I put an arbitrary limit on it. Probably 1,000,000 would have been fine too, but I went for 1000 as 1) it's the same as Python's call stack limit, and 2) I figured this is generally a bug so it's better to catch it early, before you've used 1GB of RAM.
For this reason I tend to use something like `limits -S -w 1g -v 4g go-fuzz ‚Ä¶`.
Another way to do it is contribute to kubernetes and become a member. Then jobs may find you
I once worked with an API that required HTTP headers to be lowercase because it was written by the devil. It was very difficult to find an HTTP client that didn't canonicalize headers.
This has been [an issue](https://github.com/golang/go/issues/6853) for 5 years now. For every version they try to reduce or at least not grow the size, but it always ends up being the opposite. A binary from Go 1.11 is bigger than one from 1.10, which was bigger than 1.9 and so on.
Instead of "/create" you could use a POST method on /contests, which would slightly more RESTful (for whatever it's worth) and wouldn't create a conflict between /:slug and /create See also: * https://github.com/gin-gonic/gin/issues/388 * https://github.com/julienschmidt/httprouter/issues/73 Another alternative if you really want the routes the way you described would to be put in a handler under /contests that handled "create" specially and then hands off to another router group if it isn't covered by that.
It is true that Rust is probably better for lower level programming while Go is better for server-side programming, its standard libs are very well suited for that (although I think Go could be very good at ML/AI stuff with its speed - much much faster than Python)... I don't think it will completely replace Java, it will probably replace Python and Node based backends (at least I hope so :-D )
Very cool, after work i will watch
Does it actually check for the licence file or just the metadata (e.g. package.json)?
My company doesn't advertise Go jobs. But there's a few dozen of us using Go almost exclusively. The projects are mostly internal, network service, "glue" type stuff, not customer facing products that are always exclusively in Java (kill me now). We advertise C++/Java/Python positions, but once you're "in", you can definitely find a few Go projects you could work on. I have a feeling a lot of medium-to-large companies are similar. I would definitely avoid financial institutions (super conservative), PHP/Web-shit "design" shops (dumpster fires), Medical field, or other "heavy", "enterprise"-y shops. Realize one truth - Go is a tool. Is it the "best" tool? No. No single language is. But it's a *great* tool for lots of scenarios. So find a company, small-to-medium, that is in Go's "problem space" so to speak, and apply. Even if they don't use Go *yet* - maybe not a problem? Nothing wrong with being the first one to introduce it and show how kick-ass it is, right? 
https://github.com/grumpyhome/grumpy
[removed]
This is super cool! I'm super excited for web assembly to be the main target for development. My personal game project is going to be unity + go backend. One thing I'm tempted to do though is still output unity to webassembly then run it within go. I then get to use go for plumbing and networking but the server and client share the same physics and game logic.
I would imagine the whole standard library is whitelisted, yes. It's hard to imagine that not being the case.
Appengine has its own implementation of the runtime and large parts of the standard library - including `sync/atomic`. So, yes, in that way, it's pretty much specifically whitelisted (as, presumably, most of the standard library). Note, however, that the new Appengine runtime won't restrict you from using unsafe anymore anyway :)
This flag has been removed for 1.12: https://github.com/golang/go/commit/5185744962d402df083d118036f9bef8c2e2d3b6
I think that this function is not needed, because the Go program is directly compiled into machine code and executes natively, without any virtual machine.
&gt; If anything I feel like the important part of go generate is the explicit blessing of the Go team Think "self contained" and "cross-plattform". No external tools needed (bash, grep, cut), hence no limitation to Linux and similar Unixes only.
C'moooon, give 'em a chaaaance :-)
I think you may be confused about the distinction between JIT and AOT. Go is AOT compiled, but it could equally be JIT compiled. My questions were about whether it would be advantageous to do so. Also, JIT compilation isn't necessary for interpreted or VM languages--for example, the reference implementations for Python and Ruby aren't JIT compiled, and for a long time no major JavaScript implementation was JIT compiled.
I'm with the others on this, it looks like you've chosen a really odd architectural solution that is just making your life harder in other areas. Starting up whole servers per job should really not be needed, when you ought to be able to do it with a persistent work queue.
I think I got it. What I need is a queue or a FaaS solution as you say.
There is an example at [https://github.com/go-ole/go-ole/blob/master/example/winsock/winsock.go](https://github.com/go-ole/go-ole/blob/master/example/winsock/winsock.go) See how the EventReceiver is created. A lot of unsafe.Pointer stuff there I would not touch myself.
I believe the new go1.11 runtime allows the unsafe package now: https://cloud.google.com/appengine/docs/standard/go111/runtime
Thanks. 
Wow really cool! Are you maintaining the Go binding for Qt? Do you think they'd be usable in a production environment in the future? Keep up the good work! 
Indeed. I want parametric polymorphism. I don't want operator overloading. I don't want default values for method arguments.
Hey, yeah I'm maintaining it. And yes, actually it should already be ready for production. These two web targets are however still experimental. It may not make the impression because it's not properly branded yet ... but the binding itself should be ready already. Also for eveyone reading, I will be away for the next few hours but will be back later to answer questions if there are any.
&gt; I'm pretty sure the devirtualization is really light if there is any at all Assuming you mean dynamic dispatch of interface functions, I'd say there is little value since to make that dispatch static, you'd have to keep track of frequent impls of the interface at invocation time. The type check happens at a separate place than the invocation, so I figure it's the equivalent of a function pointer. &gt; is there a good path forward here for AOT? I'd say not really, you are asking to dispatch to unknown implementations at runtime when using interfaces which means you accept the abstraction cost.
Go + fsnotify is perfect. A couple of years ago I made an application to automatically backup certain types of files and it's working faultlessly from day one. 
I should have been more clear. Regarding devirtualization (perhaps this is the wrong term), I would expect that this optimization would eliminate even the cost of the function pointer. If the compiler can prove to itself that there is only ever one implementation for a function pointer call site (including interface dispatch), it would treat it as a static dispatch site.
&gt; But why do you want to import unsafe? Never said I did. I was simply curious how `atomic.Value`, which uses unsafe, was available in appengine while unsafe itself wasn't.
Look into a cli library. 
&gt; If the compiler can prove to itself that there is only ever one implementation I would assume this is too rare to build infrastructure around. By "proving" you either mean statically (which could be done at whole-program compile/link time but again too rare to deserve the effort) or dynamically based on what is seen which even then has to prepare for the rare case it's another instance.
I wonder. I don't think it's uncommon to use an interface to wrap a single type to make testing easier, so there's a second implementation in the test but of course not in the real program. I'm not sure the speedup would be that dramatic though - I've never seen it be problematic and if it was you'd presumably do the same by hand, and it might well not be worth the effort to implement.
this runtime error looks, your reinstallation attempt was good but not perfectly executed \^\^ purge go und than reinstall it. You can easly see that your local go version is buggy, by setting up a through away docker like docker run -it --rm --no-cache golang:1.11 inside the container: apt-get update &amp;&amp; apt-get install git -y git clone your repo
This devirtualization has been brought up as an optimization, and it is a key part of some of the 'generics as interfaces' ideas - but I've definitely seen (at least) Ian Taylor say that he didn't think the use cases were sufficient to warrant the infrastructure required but was willing to consider any studies done. It might also allow some extra opportunites for inlining which I don't think are possible at the moment. Then again people don't write code that would rely on such an optimization so it's a bit circular. &amp;#x200B; Perhaps someone could write a tool to analyze some larger code bases for opportunities where this would apply.
First of all, you could do it within each compilation unit, but you get more gains from doing it as a whole program optimization. Secondly, given that WPO is an entire class of optimizations, I'm skeptical of the "too rare" claim. I would guess the best reason not to do it would be that WPOs \_as a class\_ are too computationally intensive to justify their inclusion in the compiler, but I don't know how we could really make that claim without testing (maybe you could look at improvements from other languages that have attempted and project those improvements on Go?).
&gt; I think a better example would be a single AOT compiler that compiles in a JITing runtime. A better example? That *is* my example.
Here's some discussion from 3 months ago: &amp;#x200B; [https://www.reddit.com/r/golang/comments/946ooi/anyone\_have\_experience\_with\_grumpy/](https://www.reddit.com/r/golang/comments/946ooi/anyone_have_experience_with_grumpy/)
\&gt; I'm not sure the speedup would be that dramatic though - I've never seen it be problematic and if it was you'd presumably do the same by hand, and it might well not be worth the effort to implement. Consider the \`sort.Interface\` which has to do O(n) dynamic dispatches. I imagine the speedup is considerable (10% conservatively). "You can rewrite it by hand if it's too slow" applies to any optimization, so it's not an argument against any particular optimization in an optimizing compiler--the salient point is that it may not be worth the effort to implement. This optimization would probably make things like parsers and regexp engines much easier to write and maintain, not to mention generic algorithms like sort.
Accessing a function through a function-pointer, yes, is slower but only marginally. C++ is a good example here as it uses this a lot (for all virtual) functions and is still very fast. Yeah, JITing could inline those calls at runtime and a I think Go could be more aggressive about inlining (especially map access) the results affect primarily benchmarks and 'real' code only very little. I think the Go developers care a lot more about consistent performance rather than straight performance as seen by the GC implementation.
Would that optimisation apply to those cases though? Being able to prove that there's only one implementation at each call site seems unlikely - it will fail for `sort` as soon as there are two calls to it anywhere.
[removed]
If you are still looking for an example of a data-race, here is an mwe package main import "fmt" var evilGlobal = map[string]int{"race": 1} func main() { fmt.Println(evilGlobal["race"]) go writeGlobal() for { fmt.Println(evilGlobal["race"]) } } func writeGlobal() { for { evilGlobal["race"]++ } } A couple of notes here: First you have to run it on a multi core machine. This will not cause a panic in the playground as it uses a single thread. You should see a panic otherwise as maps have a build-in data-race detection. Even running the Go race detector will not guarantee you that your application is race free. Be very careful when sharing pointer, maps or slices with multiple goroutines and be conservative with globals. Pony as to my knowledge is completely race free while you can cause data races in unsafe Rust code. Ponys type system is actually pretty interesting and you can learn a lot about the semantics of race-free code.
You are a madman. I love it. I take it that CGo+wasm works then?
This looks suspiciously like SEO spam. I'm giving you the benifit of doubt and don't assume you intend that way, but you might want to take it as feedback.
Huh, not sure what to do with that, but I'll keep it in mind! :)
Sadly no, but you can simply use emscripten's embind to export functions from c/c++. And on the go side either gopherjs/js or syscall/js to make them accessible to c/c++. Then you should be able to call your functions like any other js function.
[removed]
[removed]
Hi! I've tested with OpenAPI generator. Same issue with decode method. I wrote test and it also failed with `json: cannot unmarshal object into Go value of type string`. [Test repo](https://github.com/danikarik/clicksend-go/blob/master/api_account_test.go#L20)
Thanks for testing with openapi-generator. Please open an issue with details for tracking and we'll look into that.
https://cloud.google.com/appengine/docs/standard/appengine-generation is probably the best.
No complex routing requirements. Maybe if/when I start serving up data to anyone else. Doesn't seem likely in the near-to-mid term. For graceful restarts I've got a package that I built that handles the server. Probably sniped the essential design from Stack Overflow. Good points.
Funny how Windows-style scrolling on a trackpad feels "wrong" when you are used to natural scrolling (ie, like on a smartphone - push fingers up, page scrolls up, pull fingers down, page scrolls down). Is this a general limitation of QT or is there a setting to flip the scrolling direction?
We‚Äôve got about 15 go-micro based microservices in production and I highly recommend it. Out of the box it will help you deal with service discovery, service to service communication and it‚Äôs easy to add pub-sub features. The plugin ecosystem is very rich and easy to work with. Finally the author is very responsive and has been really helpful.
I don't think JIT is a good option for farther optimization of run time speed. The only case where JIT out performs is optimizing code according to runtime profiling, which is information that is only available during run time. However, such profiling is more useful for dynamic languages, and could be introduced to an AOT compiler by manually feeding it profiling data from previous runs. I don't think anyone have demonstrated using runtime profiling to improve speed of statically typed compiled code significantly. The real reason JIT is used for languages such as JS and Java is that optimized compilation is slow. JIT uses profiling information to find hot path that takes most of the time to run and only optimize those as needed. The Go compiler on the other hand has incremental compilation to only compile code that's changed, and compiled binaries delivered to users so there is zero compilation overhead when running the program. On how you are structuring your code. Without looking at your code, I'm fairly certain it has no measurable impact. Interfaces are used allover the standard library. If you want to know the impact, profile your code is the only way.
You have missed the destination path argument in you tar command (-C /usr/local). Read the instructions again. https://golang.org/doc/install#install
Follow mksheres advice and uninstall what you broke with apt first.
Thanks awesome samples like that will help me to get a better understanding of data-races in Go. I'm already learning Pony because of the type system and I think it's actor-based approach is interesting. I'm currently trying to get started with https://github.com/nfuhs/ponybyexample but I'm currently stuck at writing an lexer file for Pony so I can use with my fork of chroma [https://github.com/nfuhs/chroma/blob/master/lexers/p/pony.go](https://github.com/nfuhs/chroma/blob/master/lexers/p/pony.go) which will take a little while since I need to implement all keywords and reference capabilities in it. When I's done I think this will be a great learning experience for me building an complete website using Go templates.. and the website maybe helpful for others who would like to learn Pony.. again thanks a lot for this great explanation.
You‚Äôre right. The code I was referring to was to check stdin if no args were found 
See the example above, where adding error checking breaks the code.
in europe? theres a lot of go jobs in london &amp;#x200B;
&gt;everyone knows that if starts a new scope... ...outside of the scope delimeters. Slow clap for the language designers there. &amp;#x200B;
Sorry, actually I need to rant more about this design decision. It produces perverse, ugly, hard-to-read code. Short statements and are supposed to produce easier to read code, but because the short statement in an if construct starts a new scope, what could have been written like this: ``` if x, err := SomeFunc(); err != nil { ... handle the error case here ... return err } DomeSomethingWith(x) ``` Instead has to be rewritten, either with an excess variable declaration: ``` var x some_type // Note I now have to know how to say the type if x, err := SomeFunc(); err != nil { ``` Or by turning the logic around: ``` if x, err := SomeFunc(); err == nil { DoSomethingwith(x) } else { ... handle the error case here ... return err } ``` I hope I don't have to point out which one is more readable in anything beyond the most trivial case.
I've been dealing with difference scenarios.. I encountered hundreds of tables and also many different kinds of database. Believe me, i'm no stranger to your issues. All languages have the issues, all platforms has that issues. It's everywhere. It all comes down to discipline and coding techniques. I was able to come up with coding techniques exclusive to our company just to handle different kinds of tables into simplified form of programming with less hassle. So far so good, it's been good to us, our system is running for many years without changing our programming "techniques". 
Just a general thought. Why not just use kubernetes as the glue to wire up all the 'dumb' services. What advantage is there to choosing one of these frameworks.
The comment about defer close(...) seems misleading. In Tour of Go it specifically says that closing channels is unnecessary and should never be done by the receiver.
Don't get off put by the snark of the other comments. I really enjoyed working with https://github.com/labstack/echo when i got started. These frameworks are a great start for people that don't need to dig deep in the inner workings of a language / framework / lib. Or people who wants to start off from a familiar starting point when trying a new language.
My team has Go code sitting in numerous places, performing various tasks, from APIs to data science. Our products are often chosen because they outperform rival products developed in Java or C#. At no point have we started a project lamenting the lack of generics/contracts in the Go language (nor have we ever had issues with error handling - but that's a different argument). I just don't understand why this is seen as such a vital addition to the standard library? I've always considered Go to be a lean language, with a lot of it's appeal coming from the features it didn't have.
Those 60 ns still have no sense in the context of unit tests optimizations and overall those 60 ns don't excuse premature optimizations overall, imo.
Have you ever used the `interface{}` type in Go? Especially with `reflect`? When you do, at those points Go *de facto* stops being statically typed language and becomes dynamically typed, like JavaScript (meaning that some types are checked only at runtime, not at compile time). Adding "generics" to Go would allow bringing back the benefits of static (i.e. compile time) typechecking. (I'm not sure if I used the static/dynamic terms correctly, but what I mean is run time vs. compile time.)
the apt is installing go in /usr/bin, while the oficial instructions are using /usr/local/bin shells prefer /usr/bin on default settings you need to remove the apt version of golang first
&gt; that are be queried in real-time to investigate the file-systems, network state, memory or configuration of endpoints. &gt; It's an army of Sherlock Holmes, ready to interrogate duh
Could you elaborate a little on this? I thought it a pretty decent, concise article.
done, thanks!
i've already added this, but thank you! i wasnt sure i did it right so good to clarify :)
ah ok that makes sense, thank you!
Very interesting idea! I hadn't heard of doing anything like this before. Including out of order starting for the receiver was a great idea 
Thanks for the info :) There is an open bug report for the copy and past issue, and the menu on the scrollbars probably just needs thread support to work. Both issue should be fixed within the next 6 month in Qt itself. After that I will probably just need to recompile it to make it work.
The UI looks slick! 
That is really, really cool! What a fun weekend project! I wonder if the data doesn't have to be complete immediately if you could increase chunk size and/or FPS and have the receiver just cache the frames and hopefully get all good frames through 3-4 loops for offline processing. 
My whole point is you should not ignore errors. Ignoring errors is not convenient that‚Äôs just masking the problems
Yeah, it's all still really experimental at this point and I honestly didn't make the slightest effort to reduce the size. I also wouldn't recommend to use the QtWidgets module for B2C apps, but rather for inhouse stuff and maybe if you are adventurous for B2B SaaS or for an online demo of your native application. I will create another playground next month with QML which is a much better way to create modern B2C apps, and I will also try to reduce the size as much as possible for this one. But it's somewhat still of an waiting game for all the browsers to have proper thread support and also for Qt to fix basic issues such as to make copy and past work, of even make text input work on mobile.
In that case, if you still getting the wrong version it means either you did not update your environment after the change or there is other directory in $PATH before your installation path. Type `echo $PATH` to verify. Go 1.11 bin directory must be at the beginning.
Thanks for your response! You touched on JIT vs profile-guided AOT and how the latter is (likely) better for statically typed languages (although this is somewhat confusing, because Java and C# are statically typed and both use JITs presumably for good reason?); however, it's unclear whether or not you believe profile-guided-optimization would make sense for Go?
There is an open issue to detect natural scrolling afaik, and there is probably also a setting to set it manually. Scrolling is still somewhat choppy for me on macOS as well, so I guess it's just one of these many small annoyances that they still need to get right before you can really start using this for anything serious.
Not necessarily--it could compile into the resultant binary two distinct implementations for the function and probably inline the methods (the typical sort.Interface methods are super-simple). This seems like it could lead to code bloat, but I believe Rust manages it (specialized codegen per generic implementation).
That's cool. In theory it should be possible to use two phones with front-facing cameras and do frame-based networking (i.e. ethernet) over this - each QR code being one frame. This would then enable you to use regular TCP for data transfer and have it take care of retransmission of missed frames and traffic congestion control, so you could even have FPS/quality auto-adapt‚Ä¶ Plus, there are no loops, but instead a continuous stream with re-transmission of missed frames - so in general, there should be less waiting around. I'm not sure I consider this useful enough for that effort, but it would certainly be awesome =D
&gt; It's pretty standard for the process of AOT compiling languages to involve an intermediate representation. So what is the point of your invoking the idea of "a different language?" That's actually the norm. There's nothing special about going from HLL-&gt;ILL-&gt;LLL; it's just two AOTs back-to-back. There's also nothing special about going from HLL-&gt;bytecode which is interpreted by a JITing runtime; it's just AOT followed by an interpreter which does JIT, and thus this doesn't disprove the dichotomy between AOT and JIT. I'm not familiar with smalltalk, but it seems like you were describing this AOT-&gt;JIT (this is the common approach for things like Java and .Net and other JITing VMs). The thing which _does_ disprove the dichotomy is an AOT compiler which produces a program that JITs itself--this isn't really that remarkable when you consider that it's satisfied by compiling a JITing interpreter into the final binary, but it disproves the dichotomy nevertheless.
Sorry, I meant profile guided compilations (either JIT or AOT) is more important for dynamic languages. To elaborate, compilers do a terrible job of compiling code without being able to statically infer type information. I'm not well learned of C# internals so I will comment just on Java, although I believe the situation is identical. The problem with AOT is that it takes time. A large C++ code based can take hours to comple fully. Java did away with this compilation and had slower runtime speed, JIT is brought in later to make Java run faster. There also exists AOT compilers for Java that work at installation time (or existed, I haven't experienced one since JIT became good enough). Other big benefits of the Java model is the same binary release can run on any supported platform; shared user managed runtime that saves memory and can be updated independently. Those are really important things if you are targeting the web, which we can use with wasm now. So, if you want to JIT your Go, target wasm.
how to re-enable? Bluetooth, WiFi, nfc, memory card
I personally use (gvm)[https://github.com/moovweb/gvm] and it seems much easier that installing using official tarballs, repointing symlinks etc.
Type assertions and type switches are safe and work very well with interface{} Yes, the behavior is dynamic. I don't know if generics performance would be a significant improvement. We'll see.
Thanks! Well, looping works only when time for each loop iteration is relatively small. For larger files it'll require either very performant scanner (i.e. 120fps, modern smartphones/tables can probably allow this, and custom highly optimized visual recognition software should be written) or very patient person :)
Thank you. Yes, I was considering such bi-directional way of communication, but it's probably not very practical. But it's relatively easy to implement, so maybe it's a job for another weekend :)
Is the intent that multiple devices be receiving at once in the general case? Certainly it's possible (a billboard being a good example) but if the typical situation is say small devices talking then you might be able to allow the receiver to request a "start from the beginning" type message.
`package main` `import (` `"bufio"` `"os"` `)` `func main() {` `scanner := bufio.NewScanner(os.Stdin)` `for {` `if scanner.Scan() {` `switch scanner.Text() {` `case "hi":` `println("hello")` `case "exit":` `os.Exit(0)` `}` `}` `}` `}`
&gt; it's just AOT followed by an interpreter which does JIT An "interpreter which does JIT" -- Better be careful. Some Rubyists might get salty on you. (They distinguish VMs from interpreters as a part of their defensiveness about performance. This is meaningless and hazy, but they pretend it's a hard technical distinction.) &gt; The thing which does disprove the dichotomy is an AOT compiler which produces a program that JITs itself Any Smalltalk JIT already contains a full VM for itself which is JIT-ed by the VM, because that's how the debugger works! (You can actually run one Smalltalk inside another Smalltalk this way, which has been done.) In that case, there are two VMs involved, so the VM isn't jitting itself. It's jitting another VM, which is often running application code in debug mode. Smalltalk Agents used to go a long ways towards JIT-ing its own compiled VM. The developer made it a priority for the JIT to be so good, there was no need for "primitives" written in C or other ways of using code written in C. I'm not sure it could go all the way, but I wouldn't be surprised if it could. Squeak Smalltalk had a Smalltalk subset it used to specify itself, which would result in generated C code which would compile its own native code VM. Smalltalk MT would compile Smalltalk apps into DLLs on Windows which were indistinguishable from DLLs written in C++. Really, the interpreter/VM distinction is meaningless. Some Rubyists try to say that interpreters traverse the AST. However, there were Smalltalkers in conferences talking about doing everything from the AST, including JIT-ing code. It's really a meaningless distinction. An AST is just another binary format for the implementation, just like bytecodes or source code.
No, the use case is two people next to each other. So do you mean you can just ask the sender person to restart long running loop? It might work, yes :)
That's exactly what I'm thinking. Would definitely help for large data transfers.
Java could improve because it was slower than C++, Go is already compiled and have similar speed to C++ already so it has much less room to improve with JIT if at all possible. Another thing to add is that Go has a statically linked runtime, so adding JIT to it is much more expensive in code size. This might help, but wasm runtimes can do whatever they want as long as it produces the correct result. http://fitzgeraldnick.com/2018/04/26/how-does-dynamic-dispatch-work-in-wasm.html It's not a naive question, but it's not an important question either. I would never choose a language or coding style based of this kind of implementation detail. 
Do you support timeular? [https://timeular.com/?v=dd65ef9a5579](https://timeular.com/?v=dd65ef9a5579) 
ooh this is neat, thank you!
All my golang flags and environmental variables are the defaults, still not working
&gt; I would never choose a language or coding style based of this kind of implementation detail. Agreed, this was all a theoretical question to improve my understanding. I didn't mean to suggest that JIT vs AOT was a criteria for choosing a language.
&gt; the interpreter/VM distinction is meaningless I completley agree. The only plausible distinctions I can imagine are: 1. Interpreters are a strict superset of VMs that also include hardware interpreters (processors). Since a VM is by definition a software interpreter running atop at least a hardware interpreter (and possibly 0-N software interpreters in between). 2. VMs only run "bytecode" and they run it in a software interpreter (per 1.); the extent to which a bytecode is distinct from other languages is probably not well defined, however (one could imagine distinguishing between the two based on whether or not that AST is flat or tree-like [never mind that flat is formally a subset of tree-like], but such a distinction isn't particularly useful).
I like it too. The things to keep in mind are 1. You might want to add the flag to install via binary for the first one. 2. When you use the use command, add the default flag to make it stick.
As for 1), it seems like you've defined some processors as interpreters. I'm not sure this structure of definitions is really useful. Actually, that also points to the haziness of the "interpreter" concept. &gt; one could imagine distinguishing between the two based on whether or not that AST is flat or tree-like...such a distinction isn't particularly useful Exactly. A text file can contain s-expressions or XML, which can embody a hierarchical structure. However a text file is also 'flat.' I guess you can say that a VM is a software implemented processor. Then again, RISC and VLSI architectures basically farm out a part of the instruction decoding and scheduling task to the compiler. Also, there are processors which use microcode and processors which have an entire OS embedded inside them for management purposes, which can alter the operation of the processor to some extent. Really, it's just engineering conventions with some borrowing from math, all the way down. 
&gt; As for 1), it seems like you've defined some processors as interpreters. I'm not sure this structure of definitions is really useful. Actually, that also points to the haziness of the "interpreter" concept. I have defined _all processors_ (assuming 'processor' isn't also hazily defined) as interpreters. They all interpret their own machine code. I don't think it's especially useful for conventional software development, but if you're a PLT researcher, it's probably useful to think of your software stack as a tower of interpreters (borrowing the term from at least one research paper with which I'm familiar) that goes all the way down to your CPU. AOT compilation (maybe also JIT compilation, but I don't feel like thinking about that right now) reduces the number of interpreters in your tower by 1 compared with interpreting it (since every compiled language can be interpreted). &gt; Exactly. A text file can contain s-expressions or XML, which can embody a hierarchical structure. However a text file is also 'flat.' That isn't actually what I meant, but rather that the ast for bytecode doesn't have a very tall structure unlike the asts of other languages; however, short/flat trees are a strict subset of all trees. I was not referring to the fact that textual languages are serialized into a single dimensional stream which is fairly unrelated to the points we're discussing as far as I can tell. &gt; I guess you can say that a VM is a software implemented processor. Yeah, that's exactly what the name "virtual machine" implies. It's not a hardware machine like a CPU (although like you mention, "CPU" is probably not exactly where the "hardware" line begins these days), but a software machine.
It will be fun to ‚Äúgo get‚Äù this package through a corporate firewall.
I'm going to try to implement this today. 
Are u using echo for your microservices?
Yeah, I don't think the naming is going to help adoption.
HTTPS? Or do they MTM everything?
this assumes you can locate and decode QR codes 30 or 60 times per second. I think it's certainly possible with modern phone hardware, but it seems like it usually takes more than one frame for QR decoders to lock onto the QR code.
Case in point lol
You can do it at 30fps for sure. 60fps, maybe not
This was interesting, thanks for sharing.
What are the advantages to kubernetes?
Could you elaborate on service discovery and service to service communication? Is there a plugin you'd recommend looking at to see the value?
Likewise in vim. Literally :Sex
I'm fairly certain Javascript sorts keys in objects. Perhaps this is why we see this behavior?
Done! Good luck.
Done. You owe me a beer
&gt; Blb assumes that it's running in a protected network and currently does no authentication of network requests. Data is not encrypted on disk. (Future plans include encrypting data on disk and managing encryption keys in the curator.) Aaaaand there goes my plans
That sounds like you'd have to solve the Byzantine Generals problem to solve. Have you thought about a distributed ledger :troll:
I participated. Good luck!
Just say no to named returns! They‚Äôre particularly vicious with error types. ... Anyone know of a linter that warns on use of named returns in Go source?
done, good luck
I do have to admit that I don't use this syntax at all, partly because of this flaw of having to pre-declare the return value. But also, because the longer syntax `if err != nil {` is so automatic now, I don't notice it at all, either reading or writing.
Well, instead of peeking at the generated assembly one could have read the specification...
Prepare an image with your app/program and utilities. For managing a set of images (app, database etc) use docker-compose. 
Sorry, could you clarify a bit? Docker-compose would be to set up the database, other services, etc but the go server image itself, would it be multistage or one stage?
Too many to list off the top of my head. I only just started to learn it so I cant really explain it concisely. it seems like it handles orchestrating microservices without having to embed all the plumbing within a framework specific to the language. 
Correct, my question was more like, if I have singlestage image size is very big, but with multistage I don't have hotreload. What's the optimal solution out of these two, or would an in-between solution such as Dev the first way and Prod the second way be the best?
Why not ceph?
/r/ipfs
I personally using two docker files. One for development with hot reload and docker-compose (need some stuff like Redis and RabbitMQ). And second one for deployment (with two stage build and binary compressing).
Compose will let you target a stage in your Dockerfile. I take advantage of this by making the final stage a simple copy of the binary from the dev image that's running in compose with all the niceties (even debugger). (Note that compose is only used during dev and the Dockerfile image is deployed to k8s.) https://docs.docker.com/compose/compose-file/#target
No, strictly stdlib and gorilla/mux now.
I would guess your survey has been more successful than you anticipated... I would be curious to know how many submissions you received!
I know it's slightly off topic due to shiny tech - but the project has a nice layout. Looking at various main.go files, that's exactly what I want to see there. A good example project if somebody was ever looking for one.
done
You can still use docker to run your external things like Redis and Postgres and develop your Go program locally. Just add the -p flag when running it and the docker container will be available locally. 
[https://github.com/golang-standards/project-layout](https://github.com/golang-standards/project-layout)
I think some questions are a little odd. Like why to choose Golang over another Language. Every programmer will pull out the "hammer and nails" metaphor and so should you. In conclusion this question is unnecessary and could even let you look like you have no clue. Anyway good luck! 
Likewise! Or at least the results of the survey
Good luck with your essay!
In legacy GAE, the modified runtime would have had it's own version sync/atomic I guess. But, there are no more restriction. GAE standard is now using [gVisor](https://github.com/google/gvisor) to sandbox your application instead of sanboxing the language runtime. For Go &gt;= 1.11, GAE will use a stock Go version to build your app. See [App Engine Standard Environment Runtimes](https://cloud.google.com/appengine/docs/standard/appengine-generation)
Photoprism. https://github.com/photoprism/photoprism
I would do the development in a single stage image with all the twinkly and sparkly you get. Then I would deploy it as slim as it gets which would mean multi-stage in your case. After the development you should not make use of something like hot loading to make changes to your production code. You should then develop updates in the one-stage build and once they are tested and everything you go and update your production build. &amp;#x200B;
Awesome project, thank you!
&gt; Although Blb is not being actively developed as a production system, its authors plan to continue improving the system in their spare time as an educational project. Meh.
I personally use [this](https://github.com/radovskyb/watcher).
Hi! Right now we don't have integration with this service, but it's a cool idea :) We're self-funded, and keep microservice alive costs not so big amount of money, so we just spent our own money and looking for our product market fit.
Is this still on the go?
Makes perfect sense, thanks. Was unsure if it's bad to have two different build methods between production and dev, but I guess if you run everything on some staging server in between and that works fine then you're good to go :D
I see, so single stage for dev, and the prod one just do the same thing (with the niceties disabled) but pull the binary off onto a clean image. Makes sense, thank you
The same can be done on Rust! 
Does it sound like ipfs?
As an author of this library it's pretty exciting for me to see it here :D
You can't join an IPFS Cluster to donate storage without gaining write permission
You can't join an IPFS Cluster to donate storage without gaining write permission
&gt; donate storage without gaining write permission I don't understand why you're asking for that. If I run an ipfs node, I can and will influence what's being stored on it, e.g. by pinning, and by not banning object hashes. That's the whole incentive of running such a node. Why would I want to run read-only infrastructure for some third parties? 
Yeah, I though it was more complex on Rust, but actually there is an easy way to install other toolchains using rustup, which I was not aware of!
Ok, so it's not unreasonable to do that. Thank you :)
Ok thanks :)
&gt; and people could hop in and donate Why would they? It would seem to be easier to ask for donations, and rent hardware to deploy ceph/rook stuff to. &gt; a set amount of storage, like 10 GB Small increments of unreliable storage (yoyo) are more a problem than a solution to a problem. It's easier to maintain a small fleet of reliable ~Tbyte nodes rather than a flea circus of end users popping up and going. 
your gopath till go/ is enough. Inside you have your bin, pkg and src. Src contains your source code. so you need to provide path till /go so that runtime can find everything it needs to run. GOPATH is essentially the go folder right? where the runtime enviroment finds everything it needs to ....... run. correct!
This is all too verbose and crowded. As the article states: &gt; There is no automatic way to put the context into an HTTP request or vice versa. There is also no way to dump the entire context given you cannot iterate context values. It's unfortunate that, despite being a map implemented as a linked list, context offers no API to iterate it.
Cool thanks!
&gt;https://github.com/labstack/echo It is clear they need help. So if there's a Golang dev out there with enough time to contribute and help, that will be great. However I agree with your comment, there's no future for a project that has no participation in forums and PRs that are not getting closed.
If you're using 1.11 or higher, just skip the gopath entirely. It'll use the module system automatically which is a much nicer experience.
You can also use `go build` and cgo to cross compile some C libraries into your go binary. It depends on the C library, obviously, but it has proven very useful for my hobby project. We (a coworker and myself) did this for the ws281x Go package that wraps a corresponding C library to be run on a raspberry pi (ARMv6). Using go build with some env variables and ldflags set (and the arm-gcc toolkit installed), from my Linux amd64 box, I get an ARMv6 go binary with an embedded C library. Much faster than trying to build it on the Pi itself. 
Gizmo has some of this baked into it's [pubsub package](https://github.com/NYTimes/gizmo/tree/master/pubsub). It doesn't support built-in channels but that's better off being handled with standard language tools, imo. 
ah, I see. The devil is always in the details, as usual :)
Well, docker and kubernetes are used in microservices in the orchestration layer, but on top of that you have your application layer where either u can use any framework for your service or do custom anyway.
I tried goland and to my surprise I could not debug out of the box tests, I would get some error that directory type testing can't be compile.. 
&gt; Why would they? There's r/IPFS_Hashes where people pin other people's content and r/DataHoarder with people that love hosting content. Why wouldn't a community-supported cluster work? &gt; Small increments of unreliable storage (yoyo) are more a problem than a solution to a problem. This can be mitigated by using IPFS. IPFS Cluster will take care of this using a replication factor and will self-heal using data that's on IPFS at large, not just in the cluster, making it suitable for use with unreliable storage.
Here's a sneak peek of /r/IPFS_Hashes using the [top posts](https://np.reddit.com/r/IPFS_Hashes/top/?sort=top&amp;t=year) of the year! \#1: [Project Gutenberg Hash and Instructions](https://np.reddit.com/r/ipfs/comments/86q5p9/project_gutenberg_hash_and_instructions/) | [0 comments](https://np.reddit.com/r/IPFS_Hashes/comments/8716n2/project_gutenberg_hash_and_instructions/) \#2: [a lot of IT ebooks](https://np.reddit.com/r/IPFS_Hashes/comments/9f7rwa/a_lot_of_it_ebooks/) \#3: [Download Ubuntu 18.04 LTS via IPFS](https://ipfs.io/ipfs/QmYT2RNgqSDXtGDPE9ZPYqh6f2YVJtUM2xbyrVf7wNWvH3) | [0 comments](https://np.reddit.com/r/IPFS_Hashes/comments/8lnqx2/download_ubuntu_1804_lts_via_ipfs/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| ^^Downvote ^^to ^^remove ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/) ^^| [^^Opt-out](https://np.reddit.com/r/sneakpeekbot/comments/8wfgsm/blacklist/)
&gt; directory type testing Not sure what that means, can you share an example?
&gt; This can be mitigated by using IPFS. In theory. In practice, you'll notice DHT has scaling limits, and unreliable nodes are worse than no nodes. A mature distributed storage application would keep track of node reputation, which automatically prefers stable high-performance nodes and penalizes anything new.
when you setup up a run configuration if you choose gotest framework then you get to choose a directory, works if you run the tests but if you want to debug you get some error "cannot compile on directory" or so. 
Ah, you mean the `directory`test kind. What's the use casing for debugging multiple tests at once? You don't even get ordering guarantees. To debug individual tests, just click the [triangle icon next to the test](https://i.imgur.com/GPIeHFi.png) and choose debug. You don't even need to configure anything, it creates a run configuration for you.
Man, I wish I had a faster laptop. Compared to VSCode, I just can't deal with the heat coming from the keyboard when I have GoLand open.
It'd be definitely interesting to see it in action. I would love to actually test it and see the impact of unreliable end-users.
Is there any boiler plate that I need to do that? I kind of like keeping everything in one place. It‚Äôs simple for me but I get the point of not having to need that. 
I see, I didn't knew you can debug per test instead, the error message wasn't descriptive and a google search returned nothing, I think you can assure ordering by using time.Sleep(), but per test debug should suffice. 
It should settle down if you let it finish indexing - if not, there's problem something else that's gone wrong. I'm on a laptop now using Golang, CPU is at a cool 35C.
You need to use the hostname in stead of the IP address. Like https://hostnamr.tld Or, you can send the "Host" request header with your request.
I have to send requests using the server IP. And I already send "Host" header in the request but it fails due to IP not being present in Subject Alternative Name.
Ah, you use header.set. In my scripts I use: req.Host = "example.com"
I did solved in some way. Found this in my notes: https://github.com/golang/go/issues/22704 To bad I can't access my code at the moment.
Hi, i use go call js function like result := [js.Global](https://js.Global)().Call("getDatabaseData", "-1"), but the js function getDatabaseData is a Promise result, how to get the real result?
Just wanted to say thank you to everyone who responded the survey, I never expected to get so many responses in such a short period of time so I'm really happy with this. I'll be implementing the survey into my essay soon but I'm still taking responses, the more the better. And thank you to everyone who wished me good luck, I appreciate it. As for the essay it will be made publicly available some time after the presentation which is next month, but keep in mind that it's in Portuguese, only the survey was made in English because there aren't many forums or even communities for Go here in Brazil so I figured this was the best place to ask. &amp;#x200B; Here are the survey responses [https://docs.google.com/spreadsheets/d/1H1bP-MC3adRiQAtn\_gdjzFHIP9vmHFbC9mQKHUT3LVg/edit#gid=7918552](https://docs.google.com/spreadsheets/d/1H1bP-MC3adRiQAtn_gdjzFHIP9vmHFbC9mQKHUT3LVg/edit#gid=7918552) 
Setting ServerName field? It mustn't be hardcoded as I'm going to use the same client for multiple hosts.
[removed]
A *small* binary? That seems unlikely. :)
A *small* binary? That seems unlikely. :)
You know what would be almost perfect for that? Torrents and an RSS feed. I expect you could do something similar by only downloading torrents with fewer than a certain amount of seeders.
This event driven pattern is not even needed for Go. One can easily implement it with routine and channels
I have an idea and I'm starting to code it, actually. I'll scan the download page, extract the URL for each builds, then add it to IPFS using [URLStore](https://github.com/ipfs/go-ipfs/blob/master/docs/experimental-features.md#ipfs-urlstore) so I won't have to actually store the builds themselves. This way, I would extend the lifetime of builds by providing hashes to the files, and when it disappears from LineageOS' website, all what would remain is the hash and the hope that someone, somewhere, decided to pin it. Unreliable as fuck, but hey, they could have done exactly the same by using [FileStore](https://github.com/ipfs/go-ipfs/blob/master/docs/experimental-features.md#ipfs-filestore) and the visibility of it would make it much, much more reliable.
Why you should really ~~stop~~ never be using Iris [1][2]. &gt; I am very new to go [‚Ä¶] &gt; I am not a professional dev [‚Ä¶] Considering these two sentences, you may not care about the politics behind the Iris framework, so go for it if that‚Äôs the thing that you want to use for your project. I personally wouldn‚Äôt risk building something, even small, with a framework _‚Äîthat we don‚Äôt even need‚Äî_ that‚Äôs being run by someone unprofessional like Iris‚Äô author. [1] https://www.reddit.com/r/golang/comments/57w79c/a/ [2] http://www.florinpatan.ro/2016/10/why-you-should-not-use-iris-for-your-go.html
Why you should really stop using Iris [1][2]. &gt; I am very new to go [‚Ä¶] &gt; I am not a professional dev [‚Ä¶] Considering these two sentences, you may not care about the politics behind the Iris framework, so go for it if that‚Äôs the thing that you want to use for your project. I personally wouldn‚Äôt risk building something, even small, with a framework _‚Äîthat we don‚Äôt even need‚Äî_ that‚Äôs being run by someone unprofessional like Iris‚Äô author. [1] https://www.reddit.com/r/golang/comments/57w79c/a/ [2] http://www.florinpatan.ro/2016/10/why-you-should-not-use-iris-for-your-go.html
&gt; I have tried a few things [‚Ä¶] like replacing `\n` with `&lt;br&gt;` &gt; I'm assuming because the template engine is trying to keep things "safe" There‚Äôs nothing unsafe about printing new lines or HTML break tags. Even the official documentation uses HTML break tags in their examples [1]. Can you show us the code that you are sending to the template and the raw output? [1] https://golang.org/doc/articles/wiki/#tmp_5
if you want to learn about deep learning, I'm of the personal opinion that Gorgonia (https://gorgonia.org/gorgonia) is far superior to TF. But bear in mind I'm quite biased about it (I wrote Gorgonia). If you want to learn TF, I highly suggest learning and doing it in Python. The Go bindings are not yet stable I believe
Seriously, you really don't need a framework to make a web service in go. Just use "net/http" from the standard library. Maybe pair it with https://github.com/gorilla/mux if you need a more advanced router. If you insist on using a framework, use anything other than Iris. https://gobuffalo.io or https://echo.labstack.com are both better choices.
&gt; "CPU" is probably not exactly where the "hardware" line begins these days), but a software machine. There's a rumor that AMD is going to use Epyc 2 to include FPGA units inside CPUs. That blurs the line even more.
None that I know of. But I think it's a good idea to keep it separate because *all function anywhere that take a string argument* would make a very crowded auto complete list.
There's an option to limit indexing to specific paths, if you search for scopes
Eventually goland will just write the program for me and I‚Äôll be out of a job. Thanks a lotüòí Just kidding of course. I‚Äôve been happy with goland and pycharm for a long time.
No matter what, but referrer links always have a bad aftertaste. And this post has little real content.
I try to avoid most of the Jetbrains IDEs for programming languages that have just as good of an editor (VS Code for me). Even though I have a fast machine, Jetbrains IDEs just don't feel as responsive. Syncing settings across machines and between Jetbrains IDEs is also a huge pain (even with a Settings Repository). I would love a single Jetbrains IDEs with plugins for languages instead of a million different IDEs.
&gt; Syncing settings across machines and between Jetbrains IDEs is also a huge pain (even with a Settings Repository). File -&gt; IDE Settings Sync -&gt; Sync Silently There, done. I don't know what "huge pain" you are having, but this is as simple as it gets. &gt; I would love a single Jetbrains IDEs with plugins for languages instead of a million different IDEs. This is already the case. Just use Intellij IDEA and all the other languages are literally [a one click install](https://i.imgur.com/5HgS8xz.png).
Either edit your etc/hosts file or set InsecureSkipVerified to true in the TLS config. Sorry I am on mobile and can't verify the exact name of the field
Hi, I'm looking for contributors to improves this collection of patterns and I will start to concept and implemented new patterns in a few days 
I did notice that the guy seems a bit full of himself and overly in love with his own creation. I guess I will try with just go and see how it goes 
I will try that, I have seen this advice repeatedly. When I was starting to learn the same stuff in python then in node, the process of building a web server was just so complicated compared to using flask or express. But I do understand that Go was designed primarily for backend servers so I guess will try to see how that goes 
Using IntelliJ IDEA doesn‚Äôt give you the same functionality. For example: Android Studio.
I try to avoid docker for local development because I've had countless problems with it and it's just not worth it to spend any effort and fight docker to make it do what I want. The juice is not worth the squeeze. So what if I need to also have a database? Just set it up on your dev machine the old fashioned way.
Here's the code that I tried to use to insert breaks: `func (p *Page) save() error {` `filename := "wikiEntries/" + p.Title + ".txt"` `p.Body = []byte(strings.Replace(string(p.Body), "\n", "&lt;br&gt;", -1)) //I also tried \`&lt;br&gt;\`` `return ioutil.WriteFile(filename, p.Body, 0600)` `}` &amp;#x200B; And here was the output after saving a file with two newlines: `&lt;h1&gt;test&lt;/h1&gt;` `&lt;p&gt;[&lt;a href="`[`/edit/test`](http://localhost:8080/edit/test)`"&gt;edit&lt;/a&gt;]&lt;/p&gt;` `&lt;div&gt;This is a sample Page.&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;This is a newline.&lt;/div&gt;` &amp;#x200B; I can't figure out how to escape the &lt; and &gt; so the template engine doesn't change their encoding.
I wouldn't recommend anyone to buy it until the course it at least 90% done, regardless of how good it is. Right now it doesn't offer anything more advanced than the concept of looping as far as I can see. ALSO: It's cheaper right now without the coupon due to black friday.
Android Studio is not a [Jetbrains product](https://www.jetbrains.com/products.html), for every Jetbrains product, you can simply use the plugin instead of language specific builds.
Yes it does, go indeed handles concurrency in my opinion excellently. But when working with multiple services and instances in for example a ‚Äúmicro service‚Äù or event driven architecture do you a lot of times need a lot more then just go routines. That is why projects like Kafka exist. Kafka is an distributed event log which is excellent to use for for example event driven architectures.
50 billion bits is pretty small for 2018
Just off the top my head: You can iterate `verifiedChains` in `verifyPeerCert` and if you see the host you are looking for, return `nil` instead of doing validation. In all other cases, forward it to whatever the default value of `tls.Config.VerifyPeerCertificate` is.
Cool project, quick question I noticed that when processing a message you are able to return a message to be produced. How are you handling an plausible error that could be returned when writing the returned message?
One way to make the list less crowded would be to offer a cut down version of this that's enabled by default. Primitive types like string don't have any methods at all, but they tend to have a package of functions that would be methods in any other language. So, for the string type, pressing period could include functions from the strings package. Just a whitelisted selection of primitive types + relevant package would be great, especially for beginners who are expecting to find Contains or Split as methods on the string type, or sqrt as a method on a numeric type. The len() function is one that should be whitelisted for slices, maps, and strings too, since many people would expect that to be a method as well. This would definitely take more effort to implement, but it might be more satisfactory! People can always do ctrl + space + space when they need all suggestions!
These days SSD and 16gb+ ram is almost necessary for development, but it totally pays off in the time I save
"The tractserver is designed to have low memory and CPU requirements \[...\] In our environment we observed it using 50-60MB per 4TB disk under moderate load." Ceph does eat up a lot of memory, so it is way harder to do if you have a dozen of drives per machine or need to co-host ceph with other services.
Done! Good luck.
I wrote a sexp package a long time ago, and recently rediscovered it via googling: https://github.com/chewxy/sexp . There's no link in that article, though I'd love to see other peoples' implementations
I'm making online game and Goland is the Best IDE so far. I have js / typescript and go in one IDE wich is very convenient. As a plus plugins for json protobuf yaml etc. 
I know what you mean, at one stage I started writing an Interface into my app information store (knowledge base on definitions on my business objects and processes and gui's). I spent so much time in their java sdk that it was a pita. Need to rethink it and come at it a different way. But in the end I really like the IDE from a overall project point of view. Only time I use Vscode is for very small code slabs. 
Huh, TIL. Why would anyone buy all the products instead of just intellij IDEA in that case? PS: what theme is that? :)
Everytime I add a new package into \`go.mod\` , GoLand did not see it, I need to disable &amp; enable back Go module support in project setting to fix it
Is there an extension for VS Code that does the same by any chance?
Thanks!
+1 update JRE and your java app crashes. 
Not likely. I mean, that's the point of a commercial product like GoLand: they pay developers to sit there and write better features than anyone else has. Someone could develop it, and now that the idea is out there, I think it's more likely than ever.
&gt; I would love a single Jetbrains IDEs with plugins for languages instead of a million different IDEs. GoLand has more features (such as, better debugging) than Intellij + Go Plugin. However, it's fine for my job which is mostly java micro services and a few small Go ones. Personally, I have the Ultimate pack and use Webstorm, Intellij, GoLand with each separate project 
Don't forget about Java web start! :D
&gt; If everything is 'X' then is 'X' at all useful as a categorization Simpler is better. The goal isn't to have as many categories as possible. If you can reduce to category, all the better.
I understand what you‚Äôre saying now‚Ä¶ ‚Ä¢ Here‚Äôs the code with escaped `&lt;br&gt;` [1] ‚Ä¢ Here‚Äôs the code without escaped `&lt;br&gt;` [2] The only different is the imported package: ‚Ä¢ With escaping uses `html/template` ‚Ä¢ Without escaping uses `text/template` [1] https://play.golang.org/p/DmVqtfKWLQQ [2] https://play.golang.org/p/PW0aWr9nz4J
I understand what you‚Äôre saying now‚Ä¶ ‚Ä¢ Here‚Äôs the code **with** escaped `&lt;br&gt;` [1] ‚Ä¢ Here‚Äôs the code **without** escaped `&lt;br&gt;` [2] The only different is the imported package: ‚Ä¢ **With** escaping uses `html/template` ‚Ä¢ **Without** escaping uses `text/template` [1] https://play.golang.org/p/DmVqtfKWLQQ [2] https://play.golang.org/p/PW0aWr9nz4J
\&gt; Why would anyone buy all the products instead of just intellij IDEA in that case? There's a pretty massive price difference, particularly in enterprise cases. It also makes marketing to users of specific languages easier I guess. I got the All Products Pack on a deal when I renewed my IntelliJ license, but I only ever use IntelliJ. &amp;#x200B; \&gt; what theme is that? Looks like the Material Theme plugin. I didn't like it personally, and I ended up having to wipe all my config files to get rid of it, so I'd back up before you install it. [https://plugins.jetbrains.com/plugin/8006-material-theme-ui](https://plugins.jetbrains.com/plugin/8006-material-theme-ui)
Can you give a specific example? I've never seen coworkers do anything I can't do with IntelliJ, and the change list for the Go plugin today seemed to cover everything in the GoLand release. 
Awesome! Thanks.
When you run something, there's usually some collapsed text like `&lt;3 go setup calls&gt;` in the console. If you expand that you can see what commands are being executed and debug more easily. 
I dunno if it'll help on your machine, but if you click `Help &gt; Edit Custom VM Options`, you can customize the JVM settings. Increasing `Xmx` for more heap memory might help if the GC is behind the CPU usage. Excluding useless directories with right-click can help as well.
Agreed. I use goland myself as I have the all products pack, but that's mostly for convenience. I have colleagues using the plugin instead and nothing seems to be missing. 
Why is gorgonia better than TF?
I prefer the feel of the IDE focused just on my language. The pro version of each has the features from both Data Grip and Webstorm, btw, so you aren't jumping between IDEs 
Large applications end up much smaller than any that are done in scripting languages
That is indeed a major advantage.
Nah, indexing does turn my fans on, but the issue is the graphical rendering performance. I use an external 4k display scaled to look like 2560x1440p (muh pixel density) which looks great, but having the IDE larger than 1/4th of the screen slows it down. Next year I‚Äôll get a 15‚Äù MBP with discreet graphics and that should help a lot. 
There's no error to ignore. `fmt.Sprint` does not return an error, because there is no failure condition. No matter what you throw at it, `fmt.Sprint` will find a way to print it.
Ah, fair enough. What hardware have you got now, out of interest?
The 2016 13" MacBook Pro w/Touch Bar.
Thanks for your reply. Currently am working as software developer I want to learn AWS in that what I want to choose that's my confusion.
If you are a developer then you should do certification of AWS Developer. Goes by the name 'AWS certified developer' 
Great idea.
I think we'll have the first smoke test when there's a full js-ipfs node capability present in each browser, which would scale to many millions of instances, most of them ephemeral. I would think at this stage we'll see the need to track node reputation, and penalize new nodes. Unrelated to ipfs, we have definitely DHT-related cjdns routing scaling issues, though these are potentially addressed in the experimental mesh overlay network Yggdrasil https://yggdrasil-network.github.io/
Thanks abscrete.
&gt; Thanks. What about DevOps?! It is related to Developer?! With all due respect, you can Google this stuff üòï [1] [1] https://en.wikipedia.org/wiki/DevOps
There are two definitions of DevOps running, one what it actually is and another what it has become. 1. What it is - DevOps is a culture in an organization, where Developers know about how operations work and Operations team know how developers work. Developers do their best to produce the end product in a way that it becomes easier for operations to deploy and maintain the app. And operations team do their best to make deployment of applications easy for Devlopers and testers such that they can test their new feature asap and get a feedback internally. For eg : Dev starts using Docker so that the operation team does not have to worry about the env setup. Operations will know that what is given to them will work for sure. Similarly, operations starts creating CICD pipeline such the dev can build and test their work asap. There is a lot more to it, but i can't type that much. But that's the gist of it. Dev and ops team helping each other. 2. What it has become - A position. Such that the employers can demand more money from Clients. In the name of DevOps ppl are still doing manual tasks, doing monitoring and outdated operations task. If u ever want to be a DevOps engineer, the goal has to be automating your infrastructure and it's maintenance, application as CICD and it's maintenance ( you do. Not require CD everywhere - at least not to production) as much as possible. Building tools around what would would aid your infrastructure in cost cutting, being robust and all such thing. Read more about CICD, somehow DevOps is revolving mostly around it.
Huh, that's quite surprising then. At home I use a mid-2014 15" rMBP without a discrete GPU, just the Intel Iris Pro and it's totally fine with the JetBrains IDEs - and yours should be way more powerful in terms of graphics compared to that. I've not actually seen any benchmarks comparing the Intel GPUs though, so maybe the Iris Pro is more powerful :S The machine I use at work is a lot more modern though, it's a Dell XPS 9560, but I have the GTX 1050 disabled to save battery life (running Linux).
Just try using a \`io.Writer\` for \`os.Stdout\`, then respond. Second, why should I ask to Stack Overflow?
The problem is the scaling. Because it‚Äôs driving an external 4k monitor scaled to 1440p ala Mac OS scaling, it‚Äôs essentially drawing a 5210x2880 picture, and for some reason JetBrains doesn‚Äôt like big windows, apparently There‚Äôs a big thread on it: https://intellij-support.jetbrains.com/hc/en-us/community/posts/115000693290-Extreme-lag-and-high-CPU-usage-on-OSX-High-Sierra?page=3 Running GoLand or IDEA on my laptop‚Äôs native display doesn‚Äôt have the same issues. VSCode with the Go plugin is pretty great - and other than JetBrains pretty amazing refactoring there is not *that* much that I miss. 
I'd use `type Stack []int` rather than a struct if there's nothing else in the struct. The "generic" implementation isn't generic - it's an implementation for type `interface{}`. While interface{} can be converted to/from any type, that's not the same as a true generic. I'd be wary of naming it as generic. the routines not safe for concurrent use - if one routine tries to pop while another routine is in the middle of a push, the whole thing will panic. I would use a mutex to lock the struct during changes. Otherwise, seems OK to me...
good explanation. In our organization, our DevOPs are quite good programmers (shell, python and now go) and have in-depth knowledge of the infrastructure. The interact very closely with the business and divide work to operations along with developers. 
This is the right answer. why downvote a valid suggestion? 
Unix Sockets may be more preferable than TCP on localhost. Is External intended for running on remote servers on a network? 
Screenshots please.
Just `go mod init` to get started and then `go mod tidy` every time your dependency needs change. No more `GOPATH` or `go get` necessary!
thats not a referral link. If you know Udemy, there is no referral system. Im not earning anything from this post, except helping the Author get more students.
Guess I'm going to triple down now. I just flat out disagree. (Think you might like where I go with this though.) The people of Wikipedia once spent weeks arguing about a picture of a cow... https://en.wikipedia.org/wiki/Cow_tipping I've been in classes (like one for IC3 certification that said SCSI was pronounced "suzzie" [it's not... and I knew better]) that the people designing the certification classes didn't fact check themselves very well... but somehow these things got published and consumed by massive governmental agencies, colleges, and unwitting US citizens nation wide. My computer science courses in college were taught by a guy that wrote code on a chalk board (his X's look like greek symbols) and thought PEP8 assembly was okay for teaching the other entry-level students... (no, just teach them x86 ffs)... oh and the dude had no idea what linux was, so I had to go out of my way to use outdated build tools for an antiquated version of C/C++ that he was using to ensure he could compile my code. I have more examples to push for quadrupling, quintupling, sextupling, septupling, octupling, and so on down... however I think I'll end on some things I think we can agree on at least. :) Language evolves so to say any one definition is true, is a fleeting wish, so it doesn't matter. (See the word Literally and Figuratively for a recent example of redefinition). Also people can be wrong. Who's wrong here? Who cares? lol
Unspellable. 
It is not specially intended, but may be used for running on remote servers.
Yeah just run this binary from this random Russian guy. Mmm... no.
[`os.Stderr` is an `*os.File`](https://golang.org/pkg/os/#pkg-variables), as OP stated in the original post. It can‚Äôt be replaced with an `io.Writer`. It can only be replaced with another `*os.File`. Unfortunately even replacing `os.Stderr` won‚Äôt help here, since panics don‚Äôt read that variable and that‚Äôs a [WONTFIX issue](https://github.com/golang/go/issues/325). One idea would be to make a UNIX pipe, arrange for the write end of that pipe to be the process‚Äôs FD 2 _and_ `os.Stderr`, and have a goroutine read the pipe, censor, and forward to the original stderr. This is of course platform specific, fragile, and gross ‚Äî but it‚Äôs a valid answer to the question, whereas ‚Äúmake an `io.Writer`‚Äù is not.
Couple of them you will find here: [https://habr.com/post/427429/](https://habr.com/post/427429/) The article itself is on Russian, but screenshots are screenshots. In a few days I'll write here about a first small application with External, there will be more screenshots.
Fellow Golang newb, could you expand on this a little bit?
Thank you for the correction! Very important.
 &amp;(egui.Widget{X: 100, Y: 100, W: 400, H: 140, Title: "My GUI app"}) Those parens look weird.
[removed]
\[go-micro\]([https://github.com/micro/go-micro](https://github.com/micro/go-micro)) already provides this functionality in a pluggable manner. A broker is pluggable, the client and server handle encoding on top of it. Examples for the \[broker\]([https://github.com/micro/examples/tree/master/broker](https://github.com/micro/examples/tree/master/broker)) and higher level \[pubsub\]([https://github.com/micro/examples/tree/master/pubsub](https://github.com/micro/examples/tree/master/pubsub))
You are right. I'm a novice in Go. Will remove them all tomorrow.
One reason would be that Gorgonia does learning and probing, while TF for Go supports only probing. &amp;#x200B;
Write synchronous APIs and let your users make them work concurrently. Eg Go‚Äôs native map type is not thread safe, which is good because it gives you better performance if you‚Äôre handling the concurrency by [sharing memory by communicating](https://blog.carlmjohnson.net/post/share-memory-by-communicating/).
Here is a good starting point: * https://github.com/golang/go/issues/21900#issuecomment-364984930 
I'm glad that was useful. I was a little worried that the tone sounded condescending after I posted it.
I like FSMs, I am using a hand rolled one in one of my projects: [https://github.com/jhillyerd/inbucket/pkg/server/smtp/handler.go](https://github.com/jhillyerd/inbucket/blob/62406f05e821b6e68495a55e5a70b7890250211e/pkg/server/smtp/handler.go) &amp;#x200B; One thing I don't like with your FSM is how everything is defined in a single function - in my case it would be 400+ lines long: difficult to navigate and test. I assume it would be easy to move the event handlers funcs defs outside newWireTransfer()? &amp;#x200B; I'd argue that your project is more of an actor than just a FSM, given it's use of goroutines &amp; channels. You might be interested to see another way to model that, where you actually send the handler funcs *over* the channel: (I can't take credit for that, but I forget where I learned it...) [https://github.com/jhillyerd/inbucket/pkg/msghub/hub.go](https://github.com/jhillyerd/inbucket/blob/62406f05e821b6e68495a55e5a70b7890250211e/pkg/msghub/hub.go) &amp;#x200B; I like this because it makes it very clear what actions my external API are taking on the data held by the actor. &amp;#x200B; There was an FSM in the golang source itself somewhere that was also interesting, but I'm having trouble finding it.
None at all. If ever in doubt that tone sounds condescending or not , just put a :) at the end. 
Yep but not with wayland if am Not mistaken 
Found it: using function pointers to hold the current state [https://github.com/golang/go/src/text/template/parse/lex.go#L105](https://github.com/golang/go/blob/6d5caf38e37bf9aeba3291f1f0b0081f934b1187/src/text/template/parse/lex.go#L105) &amp;#x200B; I used that as a template for lexing MIME headers in enmime until Go's own header parser got good enough we didn't need it anymore.
Because you‚Äôre not the only person who asks programming questions in the world and there‚Äôs a site for that. Rest assured, someone already asked it. https://stackoverflow.com/questions/10473800/in-go-how-do-i-capture-stdout-of-a-function-into-a-string You need to use os.Pipe() which returns you *os.File that you can assign back to os.Stdout. 
I am not sure whether this is the right subreddit for discriminating people solely based on their country of origin. 
https://github.com/gtank/cryptopasta
Go is very strictly typed so it is impossible to set a function `func(int) string` to a variable of type `func(int) interface`. In some other languages this is possible and called covariant return types. To circumvent this you can simply wrap your original function to fit the types. I'm afraid to say that what you want is not possible in a static language even with generics. You either have to type assert the function or the return type. Rethinking your design is probably your best option. Some questions that may help you to come up with a new design and formulate an intend. - Functions already have names. So why do you use anonymous ones and associate them with a string key in a map? - If you need to pass them around sometimes defining a stateless type to implement an interface works. This also allows dynamic changing them (pass a different interface implementation). A struct with function pointer fields works as well. - Use the greatest common denominator. For e.g. you can use a string to encode an integer or float if you also need to return a string.
They "crypto" package
reflect. ValueOf(retVal).Kind() and reflect.ValueOf(retVal).Type() 
I've used (and forked, for several reasons) this one a long time ago: https://github.com/harlow/kinesis-consumer It worked decently well for me, and has seen _a lot_ of work since, so I'd assume it's a lot better now. I had to research it recently, so these were the alternatives I stumbled upon, but I haven't tried any of them: * https://github.com/twitchscience/kinsumer (this is probably the closest to official, since it's twitch/owned by amazon) * https://github.com/Clever/amazon-kinesis-client-go
Well that's added to my $PATH. I've got a bunch of other weird stuff in there, and this will fit right in.
I feel like someone had to ask the question. What the fuck are you trying to do?
Related, https://www.reddit.com/r/golang/comments/9xhdn2/official_neo4j_go_driver/e9tr0ld/
Nice! Good thing Joshua didn't guess 00000000
Windows is a terrible environment for building mission critical systems. Learn to code for Linux, BSD, AIX, Solaris...anything other than Windows
[removed]
It is not about building for Windows. It is about being able to install the kafka dependency to be able to compile the go code for Linux. My dev env is Windows, just like many companies provide you with.
Just use sarama. It is more performant and no cgo head aches. 
Don't forget x/crypto. For example I've used [https://godoc.org/golang.org/x/crypto/nacl](https://godoc.org/golang.org/x/crypto/nacl) to communicate with other software which is using libsodium. This nacl package is compatible with libsodium at least to a large degree. There's a number of goodies available here [https://godoc.org/golang.org/x/crypto](https://godoc.org/golang.org/x/crypto)
Soend 5 bucks a month for a Digital Ocean droplet and saver yourself the pain. Better still, install Linux as a VM pm your Windoze machine.
Do you have a link? Googled but no hits in first page. Not sure if it will be option due too need for enterprise support. That's why I am looking at confluent.
White people taking last names and turning them into girl‚Äôs names has claimed many victims. Halley, McKenzie, Madison, Hilary, ‚Ä¶
If you have docker installed you can build for Linux in that without cross compiling. I‚Äôm not sure I‚Äôd want to tackle building something in windows using a C lib so that I can cross compile for linux. I have an alpine based multi-stage docker build for confluent. Let me know if you want it.
github.com/Shopify/sarama
Thanks only now realize I made a typo üòÖ looks good this shopify thingy.
&gt; More performance on windows or in general? In general. Did a bench that I showed to Confluent, and they were surprised. (Probably has got to do with cgo overhead + other design decisions.) &gt; then found I had to use another package which wraps Sarama for rebalance support. Well that has changed now: https://godoc.org/github.com/Shopify/sarama#ConsumerGroup
okay
okay
Take a look on this ugly example i quickly created on the ipad. Hope this may help. [ugly example](https://play.golang.org/p/fgMt5cjqL0U) 
Without Gophers it wouldn't be the same.
Nice, thanks for the example!
This looks good. I'll give it a try. Thanks a lot!
Teach her coding! 
Maybe she already codes.
Hopefully go! :)
+1 for the very clean and readable code!
The thing is, I still have to take care of key-stretching on my own. I could send it through SHA-256, but wouldn't using something like bcrypt preferable? And I can't use that, since bcrypt uses a random salt, which obviously wouldn't work here.
[golang.org/x/crypto/openpgp](https://godoc.org/golang.org/x/crypto/openpgp#SymmetricallyEncrypt) has a SymmetricallyEncrypt function its essentially the same as calling ‚Äògpg -c‚Äô.
Zero-padding keys is generally considered okay, doing anything else is just security through obscurity.
Gopher? I hardly know her!
e-x-p-r-e-s-s-i-o-n e-n-g-i-n-e
well, Golang does not support true generic as of yet. So I will have to settle for empty interface to do the job. However, there is a proposal for generic support in Golang 2. Link: https://blog.golang.org/go2draft
All I was saying is that the name "generic" has a specific meaning, that this isn't, so maybe be aware of that. I would avoid the label "generic" until/unless it actually is a generic.
yeah good point. Though maps not being concurrent has bitten a lot of golang newbs, so maybe not the best example to follow ;)
&gt; some variables are in the proper (inner) scope, some in the function scope instead - len(arr) is used as-is in all functions except the last Please elaborate.
Got it. In stack implementation or any other data structure for that matter, should we implement it with interface{} or with the actual type we will be working on?
I looked at all the 3rd party options a few months ago and they're variously terrible. Using the official KCL other than with java means using the multilangdaemon, which also sucks. Use the vmware one. That was released after i did my research and looks promising.
The SDK just gives you the building blocks to talk to kinesis. The KCL (kinesis client library) builds on those to give you a usable base to build a scalable stream processor. It's not that the sdk is bad, it's just that kinesis has so many edges to it that it's not really feasible to manage a cluster of consumers without using the KCL (or an alternative).
Is your girlfriend Ashley M?
go upgrade(relationship.level)
you guys, luckly
Bad title, and yet another example of "calculator" evaluator, but still a good read. 
Kinsumer is great, but unfortunately it's not well maintained and has [a data race](https://github.com/twitchscience/kinsumer/pull/20), [an inefficient startup](https://github.com/twitchscience/kinsumer/pull/18) and a [small missing functionality](https://github.com/twitchscience/kinsumer/pull/16). I've opened pull requests for all of those so I'd like to recommend my fork with those patches applies: https://github.com/dcelasun/kinsumer/tree/both-fixes
&gt; that would make multi-consumer scenarios in an event-driven system pretty difficult to implement Not really, you just add more shards to handle higher throughput.
You can inject \`kafkaConfigOverwrite kafka.ConfigMap\` to the Publisher and Subscriber constructor to set stuff like max message size, compression, acks, SSL etc. :) For now we are using sync producer to avoid these errors. Maybe we will try to implement async producer in some way in the future. For now we assume that you can still produce messages in separated goroutines - but it is still slower thant async producer (but consistence is more important).
It's [documented](https://github.com/VictoriaMetrics/fastcache#limitations) though: &gt; Summary size of a (key, value) entry cannot exceed 64KB.
I thought it was going to say if err != nil { makeCoffee(); }
Oh yeah these are totally in `func main() {}`like you said. I‚Äôm not at my computer now so let me think for a minute. I could move them to an init function like I had hoped to do eventually anyway, or change main to return an error like `func main(error) {}` ? No that seems weird... hm. Is the issue that my main function doesn‚Äôt handle errors or that the golang main function doesn‚Äôt handle errors and thus those things should be pushed to an init function?
what do you mean `refresh`? my problem is not about GoLand did not see new content of the file, problem is GoLand did not apply new library into index, so it did not recognize new library in import.
Where did she get it? Congrats!
Have you benchmarked the sync producer though? Stating your package can deal with hundreds of thousands of messages per second can be a bit disappointing if a sync producer would only hold up to a fraction of that. Just better to be safe in these parts.
This is probably more religion than solid arguments - but ive gotten so tired of C#, less of the language, but the whole payload around it with .NET of megabytes and gigabytes of stuff needed to run something simple, the visual studio enviroment especially when passing code from one place to another, and theres some code structuring in general that i end up getting really tired of ( classic OOP ) Note : for some projects, especially when its ex proof of concept code for things like rest api's. 
yes that was abit what i hoped for maybe that someone here had been through and could recommend which path to take.
It looks neat! How does fastcache utilizes off-heap memory? It allocates byte slices via built-in make function. I don't get the trick. 
Hi I do. I wrote a small app that speaks to a MS-SQL Database to generate permissions for my works main c# project. I used go-mssqldb as the library and it works fine. It has prepared statements. which is all you really need. You can take a look here https://github.com/camccar/createPermission It reads connection details from a json object. 
Yup, this is it. You are trying to return an error from a function (main in this case) that hasn't got an error in its return signature. The other problem I commonly see when people are using errors with the err variable is they use := to do assignment and declaration at once, but err was already declared elsewhere.
Happy anniversary! It looks awesome! Last summer for my birthday, my girlfriend ordered a [surprise cake](https://i.imgur.com/2ua8EQU.jpg) for me, with a gopher on it :) she was really mad that they couldn't make it round, like [the "spec"](https://blog.golang.org/gopher/header.jpg), and also got the keyboard on backwards, but I was extra happy nonetheless. 
Option 2 is used across std library so for example your "MyServer" struct maybe will reside in "server" package, constructing something will more likely look like "server.NewMyServer()" in your case, but for more better approach it should be "server.New()". If the case is that you have more struct inside that package that doesn't share logical name. Lets say that you have structs Socket and Server, and they are both in "server" package, you can't use just keyword "New" for signature, there comes descriptive signature which can be "server.NewSocket()" and "server.NewServer()".
That‚Äôs essentially true with Visual Studio. With .NET Core other developers just need the SDK (same with go) and then type dotnet run to compile and run it. If you‚Äôre distributing it then you‚Äôd build it into a self contained deployment (dotnet publish -r win-x64/linux-x64/osx-x64) and there‚Äôs nothing extra the end user would install. I also use vscode + dotnet script to do some quick one-off things, and those can also be published. Core is much smaller and more cli friendly than the Framework. Anyway, this is a go subreddit so I‚Äôll stop going on about .NET. Go is plenty awesome and meets the same requirements you‚Äôre looking for.
I am actually leaning towards option 2. And yes, the reason why the name of the constructor is \`NewMyServer\` is because there are other structs in the same package that have constructors. How do you manage constructors with many arguments? Functions with more than five arguments seems uneasy to read.
Thanks alot !
I'd go for option 2. First off you can easily transform one into the other via closure or method expression. I like to think of Alan Kays object definition: Do you send a message "NewMyServer" to an object of type Config or do you just have a function with takes it as an argument. In this case the latter sounds more right to me. But by all means if you prefer a OO heavy style go with option 1.
As you look like on constructor that build some object, usually it will build it up from some configuration or take information from some other structs, passing one by one is ok if you have 4,5 tops, but at some point you should think of interfaces. Looking at your example constructor should receive essential data for example some shared config, but should build everything inside something like [here](https://github.com/kilgaloon/leprechaun/blob/master/agent/main.go#L162), im not passing already built structs as arguments, i'm creating them inside constructor.
We actually use this at work. But we realized that on almost all our use cases, all options should be "settable" in the config file. Hence, the resulting code does not really use the config options as "optional". Another thing is that this is for optional arguments, we want to be clear in the function signature which dependencies are mandatory. And the same problem arises, what if we have more than 5 mandatory dependencies/arguments? Anyway, this is really cool but not for our use cases.
Yup! We construct objects that we can build inside the constructor. And we create interfaces only when they are necessary. However, we end up with the same question, what if we have more than 5 arguments? We are arguing that letting the caller setup the dependency chain is not the right thing to do since they might miss something that will not work if they are \`nil\`. We are torn between safety + explicit code vs ugly function signatures. Your "agent config" code looks neat though. I'll mention this to my coworkers. Thanks!
I'm leaning towards option 2. It looks more natural to me. I just need a more compelling reason to tell my teammates that it is better. But I guess they can't argue with Alan Kay! Thanks!
I agree that calling it "off-heap" is a bit misleading: fastcache does not utilize off-heap memory. It does, however, avoid having a GC-ed pointer for every key or value being stored. This way, GC impact is constant for a given cache size, and does not depend on the number of keys or values stored. 
Go uses this order; 1. Initialise packages (go through this list for each package this package depends on). 2. Initialise variables in the global scope. 3. Call init() 4. Call main() You can see it in action here: [https://play.golang.org/p/gPAKG2XT9Yu](https://play.golang.org/p/gPAKG2XT9Yu)
thank you very much
If you have the option, I would suggest using an "function options" ellipses for optional params along with the option 2. Example. https://github.com/tmrts/go-patterns/blob/master/idiom/functional-options.md
You could build a custom protocol using the net package by ehtier using a TCP or UDP connection. 
So one of the options functions might be \`WithConfigFile()\`?
Why C#? It's just an SQL DB that happens to be created by Microsoft.
We are actually using this as also recommended by [superchalupa](https://www.reddit.com/user/superchalupa). But this seems to not fit well with what we are trying to achieve -&gt; [see here](https://www.reddit.com/r/golang/comments/9zoa38/constructor_function_signature/eaavbs1/) &amp;#x200B; &amp;#x200B;
Level 3 on the [Rusty Scale](https://ozlabs.org/~rusty/index.cgi/tech/2008-03-30.html) is nothing to be proud of.
It still doesn't solve the issue of the remaining dependencies which could be more than 5. And functions with a lot of mandatory arguments are ugly IMO but they are very explicit and that is what we like about them.
https://golang.org/ref/spec#Program_initialization_and_execution
You are looking with wrong keywords. P2P is not a thing, it is just a network connection. P2P is only a valid context in the presence of web products as they bring the default of central servers. UDP, TCP are your keywords
[This is the relevant Spec section](https://golang.org/ref/spec#Package_initialization) :)
P2P involves either udp hole punching or uPnP for devices behind NAT. Take a look at \[this library\]([https://github.com/libp2p/go-libp2p](https://github.com/libp2p/go-libp2p)). This should get you started.
Thanks
Latest commit: 13 Jun 2016, no issues updated after 2016 - looks like this project is unmaintained.
I'm not trying to convince anyone to call anyone anything. Just observing that CPUs interpret machine code and in that sense, they are interpreters.
Indeed. Odd submission.
Thank you, that's actually surprisingly readable. 
Never leave her
Do you mean, the difference between optional and non-optional values in the config struct? Because someone could leave out a non-optional value? Practically speaking, separating the fields into required and optional and commenting the two sections should communicate that information, and that's what I do. If you still don't like that, perhaps having two separate structs (like Deps and Options) would work for you.
[removed]
[removed]
Thank you Guys. This one really made my day
[removed]
&gt; So basically, it's just 'machines.' Some of those machines are 'virtual' to some extent, in that the implementation is in software. This is what I've been saying all along. (Which gets Rubyists up in arms.) Software interpreters are just virtual machines. Right, I've been agreeing with you all along. :)
Looks pretty slick. As a network guy I am super interested in this. Thanks for sharing!
This is deliberate design decision - do not cache big entries. The API could be complicated by returning `error` from [Cache.Set](https://godoc.org/github.com/VictoriaMetrics/fastcache#Cache.Set) on big values, so users had to write something like: if err := cache.Set(k, v); err != nil { handle big (k, v) entries here } instead of just simple `fire-and-forget` code: cache.Set(k, v) 
Sorry for bad wording. `Off-heap` means that individual cache entries do not result in distinct heap objects as @pgregory mentioned below.
fastcache has the following advantages comparing to bigcache and freecache: * It is faster. See [benchmarks](https://github.com/VictoriaMetrics/fastcache#benchmarks) * It has simpler API * It uses less memory on huge multi-GB caches thanks to lower memory fragmentation. Added [the corresponding entry](https://github.com/VictoriaMetrics/fastcache#what-is-the-difference-between-fastcache-and-other-similar-caches-like-bigcache-or-freecache) to the FAQ.
I dont like its reliance on code generation. Its generates a lot of redundant code. Abstraction way used by `rs/rest-layer` is better i think. The problem with `rs/rest-layer` is that its incompleted. 
I've only been working with Go for about a year now and am still discovering a lot with regards to testing after spending over 12 years doing TDD in Ruby. In my experience a lot of the *seams* have to be created when writing Go code. I have found that using [function types](https://medium.com/@kandros/go-function-type-reusable-function-signatures-2389f6bdd4f6) is a really low-cost way to create seams in certain areas, while others require stepping up to interfaces. In some cases full-blown wrappers that allow for injection of mock implementations can become necessary, but I try to avoid that when possible. I have found that many OOP concepts translate just fine into Golang, they just have to be slightly adapted. The key adaptation that I've noticed is regarding the fact that Go has an impure struct concept (they're not just a bag of data) instead of full-fledged objects (containers of data &amp; behavior).
One resource that could be helpful is a tutorial session by Luciano Ramalho: "A gentle introduction to TDD in Go." It was delivered at OSCON earlier this year.
Thanks! Payment is Stripe Elements (see https://stripe.com/payments/elements) and then a little bit of backend code in Go.
Really cool. Thank you for sharing!
It could be done simpler with even one interface that has process. It takes message or raw string and outputs string. While this is simple everything that implements this interface will work fine. If the message is json and it is structured so you know it, you can have types and try to pass in as types but I would probably start with something simple. 
Thanks! 
[https://github.com/pions/webrtc](https://github.com/pions/webrtc) &amp;#x200B; its a pure golang implementation of webrtc :). You can use data channels to do p2p. 80% of connections work once each gets their IP's exchanged via the STUN / TURN server. That 80% is according to some google research. The other 20% need traffic to be relayed between the public relay server. &amp;#x200B; &amp;#x200B;
Since this is using TAP I assume Linux and Mac only?
Does your code need to be portable? 1. Changing encodings means it will only deal with that language. 2. You can also alter the response by changing environment variables during runtime (\`os.SetEnv\`), however this will not work on windows and MacOSX (I think) e.g: \`\`\` **LC\_ALL** is used to override every LC\_\* and LANG and LANGUAGE . It should not be set in a normal user environment, but can be useful when you are writing a script that depend on the precise output of an internationalized command. \`\`\` &amp;#x200B; [https://superuser.com/questions/392439/lang-and-language-environment-variable-in-debian-based-systems](https://superuser.com/questions/392439/lang-and-language-environment-variable-in-debian-based-systems)
[removed]
Then it should probably panic on invalid use.
Book title: Go Design Patterns About: Learn idiomatic, eÔ¨Écient, clean, and extensible Go design and concurrency patterns by using TDD Author: Mario Castro Contreras I'm finish this book, it covers a lot of TDD with go. You can also check the book's github repository. [https://github.com/PacktPublishing/Go-Design-Patterns](https://github.com/PacktPublishing/Go-Design-Patterns) &amp;#x200B; &amp;#x200B;
Any of those endpoints in a pure RESTful API still are paths that are registered to a handler that‚Äôs doing something (returning information, etc). That handler is a function so technically you‚Äôre still making a remote procedure call. That‚Äôs my simplistic understanding of this talking, but I‚Äôm sure that I‚Äôm looking at it too literally at that point. On a high level, I‚Äôm not so confused. But when I think about it deeper, I trip myself up. 
[removed]
I recall Windows supports TAP but not sure about effort needed to make this work ü§î 
if your struct fields are exported, then why even have a constructor? Just set the struct fields explicitly. if your struct fields are unexported, how do you feel about another struct which encapsulates the constructor's params? For example: &amp;#x200B; \`\`\` type MyNewServerParams struct { Db \*sql.DB Cache \*redis.Client ... }\`\`\` &amp;#x200B; Then your constructor would be: &amp;#x200B; \`func NewMyServer(params MyNewServerParams) (\*MyServer, error){...}\` &amp;#x200B; In this way, everything is implicitly optional. For anything that you don't want to be optional, you just put that logic in your constructor.
I see what you mean. Go is arguably easier to deploy and was designed keeping that in mind. But I can tell you from first hand experience (I used to work there), that Go clients don't get as much love as their ADO.NET equivalents. So, perhaps do your due diligence before using it in production but you should probably be okay with prototype/throw-away use.
I‚Äôm getting redirected to https://giftlettertemplateit.icu/us_facebookbox_walmart1000_hearoriginal_ms/index.html?trackid=
Weird they swapped the dashes to the otherside. It looks awkward and doesn't give the feeling of movement that the original gives. If you're going to steal, don't ruin it!
Grpc tends to be a way to with proto buffers a way to auto generate apis or rather their handlers from one server to another. You can do them to a page and back but the point of grpc is to use bidirectional streaming, in an auto generated way, to simplify communication in microservices. This also lends the ability to mix languages through proto buffer files. You can literally generate handlers with the same .proto file or mix and match "messages" and "services". This also lends itself the ability to decouple apis because they are not couple to your model. This also creates a streamlined way to auto generate apis for many microservices. So if you have a lot and if need be, in different languages, and you don't want to worry as much about connections to your server/database, this is a good solution. In restful you tend to couple connections to your server and database. You don't have to but... Most people do for one reason or another. This has a giant issue if Jim creates apis on the server and Jill needs some of them and add to her own, then Jack wants some of both of their and all of a sudden you used up all your connections. Being able to mix microservices and languages and utilize bidirectional streaming, is just balls especially with goroutines. Now you start to see why doing a great many microservices in go starts to make a lot of sense. I'm guessing however most companies prolly utilize both because of freedom and well not everyone knows grpc and not all the services are going to be in php. Grpc is still new as well and has some nuances. But what it tends to kill of mostly is the whole my language is better then yours stick, and monoliths are the only way to be really productive in the beginning. As well as microservices are nearly impossible to maintain but now they really aren't. So it took this evolution from templating to rest to grpc to finally allow for all of this and they all aren't perfect but some lead to coupling a lot more then others. I work at a company that takes down their server almost every other week with a giant monolith. I know coupling and db connection limits. They wanted to do a rewrite just for rest....OMG üôÑ
For now I don't need it to be able to be portable between languages, but I can definitely add that with a flag and setting EnvVars in runtime.
Awesome stuff! Not buying though, I would if there were some more *cute* gophers in the package.
I've not measured it to be honest. I've been running SSH across the VPN, which is is fine, and I don't see any obvious slowdown when I switched to using this as transport for PSQL (instead of firewall hole + public IPs). Obviously there is overhead, but I can't guess how much. I'll file an issue to do brief network I/O tests.
Yup, wait until you use concurrency and find out that if you kill the parent the child routine will still live. It is a good practice to use pprof. Also there a lot of articles on the topic of http.
Yeah and just to clarify - there is no memory leak here. Some buffering is required due to how HTTP works. You need to minimize the amount of stuff you store in memory per request. Let `net/http` do the hard work of figuring out how to write data in the most compatible manner and don't try to manage connection states yourself.
This will only solve the optional parameters which we actually put in the `Config` struct. However the function signature grows when the mandatory dependencies also grows. I guess we can just create another struct for the mandatory dependencies and check for uninitialized fields. However, we will miss the explicitness when the arguments are defined in the function signature.
Thanks for the shout out The GitHub has all the resources, including e-pub https://github.com/quii/learn-go-with-tests
Simulating cluster failure via go routines seems more difficult and too synthetic of a test framework. I would recommend instead building a test lab using docker (via docker compose or docker swarm), systemd nspawn (https://www.freedesktop.org/software/systemd/man/systemd-nspawn.html ), or directly using namespaces https://unix.stackexchange.com/a/396193/8692 Even just having multiple instances of your service process running on the same system and binding to different ports or even different localhost IPs (ex 127.0.100.1 127.0.101.1 127.0.102.1 ...) would be much closer to a real cluster. Using something like systemd template unit files and restart rules (see https://www.digitalocean.com/community/tutorials/understanding-systemd-units-and-unit-files ) means you could then test failures by just killing a process and watching what happens when it restarts. 
cool! I love this API. question: is scanner the fastest method here? each resonse is only like 500 lines so it doesn't really matter, just curious.
It's a super cool API! I really like being able to get occurrences without having to send the complete password or password hash like you had to do with the V1 API. I'm not totally sure if `bufio.Scanner` is the fastest approach to this... I would think it's faster than using `strings.Split` or something, but I might have to write some benchmarks. Since it takes a decent chunk of time to call out to the API, and to hash the password, I'm sure that the actual scanning time is pretty much negligible, regardless (to a point) or the approach.
You need to close all the tcp connections yourself, in your stop server function. Also, server crash is just one very limited failure scenario. Two more extensive and easier monkey tests are adding random network failures and random sleeps. 
Workwise we do c# only and windows only and while i do recognize microsoft really are being innovate and moving in the right direction i am for some reason so fed up by it all - i envy python developers and people who can be on linux environments alot. But go for me is also more of a prototyping language, python has the disadvatage for me that it requires a few steps more to run so its not as easy as go when it comes to deployment. Core though is close and also what i tell my developers to try to focus on at the moment
Why not fork the process and randomly kill those? Seems like it will achieve the same thing.
Go can be faster than Java so it's a pretty reasonable choice. If you're doing a lot of number crunching you might look into gonum or other GPU numeric computing libraries. There's not really any drawbacks compared to .net and Java in terms of the core language. Depending on what you're doing there may be specific libraries you need only in certain language, but there's nothing in the language you should really be worried about
Yes it is. Even more so if you can use concurrent algorithms. 
Simulate a server failure then. Use docker containers and stop them
Thanks for your advise :)
the 2nd and 3rd steps are sub-steps of the 1st step.
Go works well for CPU intensive tasks. &amp;#x200B; On the opposite end of the spectrum, I have a small Go web server that rarely uses more resources (CPU &amp; Memory) than systemd.
I don't know what this means. Did you have something specific in mind?
That one was fun to make. I used an 8bit Gopher by Egon Elbre and enlarged it using Go code to retain the 8-bit feel. Probably could have enlarged it some other way but it was more fun writing the code myself. I believe I talked with Egon a good bit that night as well getting ideas. 
Latency doesn't seem to be impacted significantly, but the overhead is approximately 50%: * https://github.com/skx/simple-vpn/issues/9
Java crap has never been responsive indeed, but VSCode is not responsive in any means as well, especially considering it does much less than Goland.
Go is great for computation. The only thing holding it back compared to the champions C/C++/D/Rust/Fortran are the more expensive function calls (due to more reliance on the stack), the lack of aggressive inlining and that the GC is latency oriented rather than throughput. Go really shines when you can effectively parallelize a task.
This so much! I took over technical leadership at a company that has legacy platform built entirely in node and Postgres. All of my devs are node focused (I'm an old java guy). We chose go as our other "approved" language. It helped us seriously reduce our memory footprint seriously sped up some CPU (signal processing, etc) intensive parts of our application. While at the same time keeping the dev team happy. We haven't done a completer replacement yet, but as we update the platform, I expect go to organically replace a lot of our legacy code especially where Promises are being mixed with DB access.
It's usually better to use `[http.ServeContent](https://golang.org/pkg/net/http/#ServeContent)` in place of `io.Copy` when you have (or can make) an `io.ReadSeeker`.
I'd use wait group or some other data structure for coordinating these goroutines, but the playground should illustrate what you are asking for. [https://play.golang.org/p/2naDSCT33-3](https://play.golang.org/p/2naDSCT33-3)
Thanks!
Unfortunately, it's a bit hard to parse this wall of text. If I understand correctly, the simplest approach is not to deal with blocking of the signalling goroutines at the point where the signal is received ‚Äî the `select` statement in the `worker` goroutine ‚Äî but rather deal with it at the _sending_ points. Consider: eventCh := make(chan struct{}) func worker() { defer close(done) // chan struct{} for { select { case &lt;-stopping: action() return case &lt;-eventCh: action() } } } for i := 0; i &lt; 100; i++ { go func() { for { time.Sleep(time.Duration(rand.Intn(5)) * time.Second) select { case eventCh &lt;- struct{}{}: default: // Do nothing if `worker` is not executing `select` ATM. } } }() } Look closely at the `select` statement in the sending goroutines: when the runtime executes it, the sole `case` branch is only taken when the code in the `worker` goroutine is 1) executing `select` and 2) the `stopping` channel is not ready or it is but the runtime decides to execute the receive from `eventCh` this time. Hence if `worker` is not ready ‚Äî executing `action()`, as there is no other code to execute ‚Äî all executions of `select` in the sending goroutines will take the `default` branch. ---- If, instead, you somehow need to register (count, for instance) or otherwise process all the _attempts_ to signal `worker` about an event, you can spawn a helper goroutine off `worker` which would look like events := make([]event) for { select { case event := &lt;-eventCh: events = append(events, event) case workerEventsCh &lt;- events: events = make([]event) } } Here, the helper goroutine accumulates the events sent over `eventCh` and tries to send the current "batch" of them via another channel ‚Äî being monitored in `worker`. As soon as the send of the current batch succeeds, the batch is recreated (as the former one is now owned by `worker`). 
Just curious is node bad for db access when a promise is used ?
I'm in a similar situation. My company uses Fortify SSC which is a nightmare of false positives for languages it does handle so I'm not holding my breath. 
I recommend several simple pieces: 1) get message 2) deserialize in unstructured way 3) choose type 4) deserialize into structure 5) invoke a per-type validator 6) process request
It's not necessarily bad, but if you're not very careful you can get yourself into trouble with async query execution if you need things to happen in a guaranteed order. In our case this was further complicated by the use of an ORM and general inexperience on the team's part with SQL and relational databases.
If you don't care about each invocation, and only that `action` isn't called simultaneously, and doesn't skip an invocation, then I'd avoid channels. They're a waste of memory for this, and Go has perfectly capable primitives in `sync`: https://play.golang.org/p/k6T6aeUhJNK This runs the action if the caller requests it, and also waits for `loopAction` to terminate before ending the program.
This is often true if you work on a line of business application in an IT department, but if you work for a software company, you'll be much more likely to need an orm so that you can support multiple types of databases. Companies that use SQL Server won't use a product that only runs on Oracle or Postgres, and a small company might want MySQL. Each type has different syntax for date operations, some variation on things like string concatenation, widely different syntax for window functions, and some variation in data types as well. In these cases, a team that knows SQL extremely well might not want to spend time developing and dealing with so much near-duplicate SQL.
According to [https://stackoverflow.com/questions/1259084/what-encoding-code-page-is-cmd-exe-using](https://stackoverflow.com/questions/1259084/what-encoding-code-page-is-cmd-exe-using) you can try to mess with chcp ([https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/chcp](https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/chcp)), or not mess, just get the current active code page and decode output of the command with that information.
Hmm, so given the choice between sticking to the official error handling conventions and failing silently you chose to fail silently? https://blog.golang.org/error-handling-and-go
??? Why would the same team be writing code for multiple databases? I can see in a big company there might be a lot of databases, but each will be used by a different team with different business goals. There‚Äôs not a ton of chance for meaningful overlap with queries. 
I did read about that, but from what I read, it's terminal/process specific, and the console Golang runs it's own process and I don't think I can change the cp for that one.
Earthboundkid, thanks for engaging below this topic. And I think it‚Äôs always good to discuss ‚Äòspam‚Äô. Do you think the people that post a blog/github repo every week or two weeks and plug this, are spammers? From your perspective, this seems the case. You say ‚Äòif your newsletter is good once a quarter and ‚Äòwe' can decide whether to subscribe.‚Äô At the moment I‚Äôm typing this I see that from the 58.5k r/golang subscribers only 477 are online. This means that if you post it once a quarter, there‚Äôs no way you get a balanced opinion about whether ‚Äòwe the people‚Äô decide to subscribe or not. Actually you can only reach a tiny fraction, taking into account that most subscribers miss most of the weekly contributions. You are probably one of the few that checks very regularly. This also effects by the way the way you perceive something like spam or not. 
Yes, makes sense for CRM, ERP or other enterprise product. In fact, I think that's the only case where an ORM is worth the trouble and performance hit.
He's talking about enterprise product companies that often can't choose the flavor of DB that their application is run on. 
Blah blah blah. Stop submitting your site every week. It‚Äôs spam to submit the same page over and over. Yes, ICYMI is a thing. No, submitting every week does not count as ICYMI. 
Hi @earthboundkid. I respect your high karma, it gives me the impression you are somebody that takes the time to give a thorough reply. In this very case, by responding with ‚Äòbla, bla, bla‚Äô, without even taking the time to respond to my arguments, it looks like you are a guy of very strict principles that is not open to another kind of view of media consumption. I could distill a bit of additional input in your latest reply, namely posting the same ‚Äòpage‚Äô. First of all, Getrevue is a terrific place where you can find numerous personal hand-crafted newsletters (real craft, no automation). I just have one page that is always the same at Getrevue, and it shows the overview of all my newsletter. But the funny thing is that I never ever have shared this page. Every single week I share a unique page providing unique content. Have you already by the way read my advice of just scrolling/hovering down?
Just ordered! Hope you can deliver to Brazil! :D
For instance if you are a company that sells an ERP or accounting system. These often come with multimillion dollar licenses and implementation fees. If you're trying to sell to a large company, there's a good chance they've gravitated towards one DB like Oracle, SQL Server, or (shudder) DB2. They've already made a significant investment in their DB and will be much less inclined to buy your multimillion dollar product if it doesn't work on their DB platform. So, you can either use an ORM to abstract as much of the DB away as possible or you can artificially limit your market. As for the part about firing your client because you can't choose the DB, I spent years in consulting doing custom software dev and never once was able to choose the DB I was working with. As long as the client payed their bills, I'd never pass up an opportunity for a fat commission check just because a client was using a DB I didn't like. That said, I still hate ORMs with a white hot passion and believe that their use in most cases is unwarranted. 
Missing a license
Thanks
Thanks for clearing up the use of goroutines. I'm pretty new at go still and for some reason it didn't occur to me that they would be that different than threads.
I work on a security product used by significant portion of Fortune 500 companies. Those companies tend to be fine being forced to use SQL Server for my team's product. Another team at my company has a product used by a much wider variety of companies. It is not always tenable for them to tell small companies to just use SQL Server, and large companies will often show bias against MySQL. There are places where SQL is used, but an ORM is also very helpful to that team. This is not an uncommon situation to be in if you are a product company.
These are all very good examples. One example I can think of from past work is Hyland's OnBase. It is a document management system supporting both Oracle and SQL Server. Doing contract work or working on a product for a single client is one thing, but a product with hundreds or even tens of thousands of clients changes the math on reusable code and integration with other databases pretty rapidly.
I've done work with 2 hospital chains that would only consider products that ran on SQL Server. I also did work for a health insurance company that would only consider products that ran on Oracle. It is not ridiculous to think that I could conceive a product that could sell to all three companies for millions of dollars apiece and would be able to afford the downsides of an ORM instead of not selling to the third company.
Though this is my least important point, I have seen that internal IT departments tend to love writing ridiculous disgusting applications that reach into the databases of other applications instead of APIs. I think people working at these companies are less vocal because they are embarrassed by their IT practices, but from what I've seen personally, I would be more surprised if this wasn't the norm. Besides having DBAs who know how to maintain a specific type of database (and might only have one of these DBAs), they might also be addicted to terrifying applications that dip into each other in ways you really shouldn't.
https://github.com/bunji2/nncls
We have created this library due to the lack of maintenance we saw in the GraphiQL libraries for Golang. We have also wanted one step further and turn it into an application that can be launched from the console, so that we can use it independently of our GraphQL server. &amp;#x200B; Any constructive criticism will be very welcome :)
In my experience this has a lot to do with the level of talent that your average enterprise can attract and more importantly retain. Since most of the fortune 1000 (at the executive level) view developers as replaceable widgets that can be off-shored, easily replaced, etc. So they put very little thought into retaining good talent. OTOH most of the really talented devs I've worked also have a very low bullshit threshold and are easily bored so would rarely stick around in your average big company (unless the pay was ridiculous). Between those two factors you often have inexperienced or disengaged devs doing work where "results" are all that matter and long term maintainability isn't rewarded so it falls by the way side. This is the primary reason I stuck with custom dev consulting for so long and now only work with adolescent start ups. Less BS and red-tape and I have the experience to see things going south way before they get really bad and start planning my exit.
Thanks for your kind feedback.
Thats great. Will surely checkout gonum. Thanks for the feedback.
`signalProvider` looks like it leaks goroutines for a start, since you create one in the first scanner case, but then potentially throw away the associated channel without closing it if you've already seen the outputId. There may be other issues, but that's the first thing that jumps out.
I'm not 100% certain but I don't think you can loop over every circuit at the end and pull a value. Is every channel in the circuit map guaranteed to produce a value? Some are inputs and some are outputs and I assume they are passing values between them. 
Custom dev is a single client. I'm not suggesting working in one of these environments. If you have a product that you sell to 4,000 customers, you might want to also sell to the 2,000 potential customers like what I described.
Understood. I was responding to your comment about the quality of work done by internal IT departments. 
People use random logos on weird stuff: https://preview.redd.it/amsb1olnvscx.jpg?width=960&amp;crop=smart&amp;auto=webp&amp;s=131f122d32d8385be8b4b175527d9abb05c00977 https://skinwalker.files.wordpress.com/2012/12/freebsd_condoms.jpg?w=593
Also consider whether you want to queue up another invocation of `action()` if one is currently running when another attempt to send to `eventch`. If you want it to run again after the current one completes, make `evench` have a length of 1. If you don't care, you can make it have a length of 0 and the send will be dropped.
I bought one because the gophers looks so damn cool, but I have to get more proficient in the Go language before I can stick one on my laptop. Got some weeks to do it before they arrive!
Split your CGO project into a C project and a tiny Go shim. Then you can statically analyze the C portion and the Go portion independently.
It primarily allows for two things: a server can use it to authenticate a user, and a server can rely on a third party to authenticate a user on their behalf.
To be more specific, my assumption is that you would only want to read from the leaf components in the circuit since they have no other components pulling as an input. 
I can only think of [this issue](https://github.com/golang/go/issues/18597) which might interfere with number crunching performance.
Here is a useful Go idiom that may help. Send to a buffered channel of size one, but also with a default clause: var actionRequestCh = make(chan bool, 1) // note the buffered channel // allows background requests for action(), but requests never block func requestAction() { select { case actionRequestCh &lt;- true: default: } } ?something? in worker would then be case &lt;-actionRequestCh Notice: a) If there is already a request queued on actionRequestCh, then the duplicate request will be discarded. b) requestAction() won't block even if worker has already exited/shutdown.
Now this is interesting. REPL for a language that needs pre-runtime compiling. Anyone tried this?
Oh, she already knew before being my girlfriend
Thank you very much, that cake looks tasty and that gopher looks really cool!
Well good luck to ya. As someone who used to work on Sql DB and now switched to a company that runs on an open source stack and primarily uses Go and Python, I'll tell you the grass always seems greener on the other side. That being said, the amount of support and community available is way bigger.
Sorry, over the period i have seen a lot of gophers e.g. on Dep. I don't have anything specific in mind, just meant Gopher doing various things
Yes you are probably right :) but python and go does sound like the ultimate dream at the moment though !
I agree with people not liking lists to aggregated news since there isn't much discussion to be had over them, but this post is better than most since it's clear from the title that it is aggregated content. What I dislike is news aggregation where the link seems to make it sound like a number of technologies we're discussed together, only for me to click and realize that the link was referencing three articles which I've already heard of.
Thats a stripe thing I thing. I'm using stripe elements for the form, and they say yes/no to cards. Not really sure why it is doing that :(
I use https://github.com/securego/gosec. Not sure about cgo support though. It can be run independently or via a meta linter like https://github.com/golangci/golangci-lint (which is how I run it). 
Huh. My initial thought was that this must be incorrect. Surely there's a more idiomatic way to POST a multipart file? But no, the APIs are incompatible: `CreateFormFile` creates a writer, but `http.Post` expects a reader, so your only option is to use an `io.Pipe` and a goroutine. Gross.
Thank you for your very helpful reply. It took me a day of reading some documentation and playing with examples in the playground but I think, tentatively, that I understand what went wrong now in a programming sense rather than in an academic sense. I ended up fixing the ramen example as follows: package main import ( "fmt" "os" "github.com/BigJk/ramen/console" "github.com/BigJk/ramen/font" ) func run() error { font, err := font.New("fonts/terminus-11x11.png", 11, 11) if err != nil { return fmt.Errorf("Could not load font: %v", err) } console, err := console.New(50, 50, font, "Wuxia Rl") if err != nil { return fmt.Errorf("could not create console: %v", err) } console.Print(10, 10, "@") console.Start(1) return err } func main() { if err := run(); err != nil { fmt.Fprintf(os.Stderr, "%v", err) os.Exit(2) } } My thought process was, by allowing the run function to manage the errors, the main function could be freed to just collapse an destroy the instance in the event of a serious total error that inhibits the program from initializing. If there were an error to be reported, run could do that and main wouldn't have to be bothered with it all. The term box example is being handled in a similar fashion, though I am missing something in my code in that it runs but it doesn't display the window long enough for me to see if it is there or not. Still learning how to use term box. TL;DR: Is this an acceptable solution? (Yes this reply was copied from he above post because I wanted to be sure you saw it also since your explanation was particularly helpful.)
Your GitHub profile icon is cool!
True that, not sure why CreateFormFile designed to return a writer
I looked at it but it feels like the author forces OOP patterns on the language like singleton as a package
Thanks PaluMacil for the positive words. In an attempt to make it even more clear upfront that these are newsletter issues, I‚Äôll literally include ‚Äònewsletter‚Äô in the title. Even more clear for the r/golang followers that don‚Äôt like newsletter issues to avoid it.
Could not agree more. I‚Äôd much prefer to see interfaces extended to support generics.
I'm using [h2non/imaginary](https://github.com/h2non/imaginary) in production over a year now, it seems to have a comparably better api (resizing, cropping, and about 20 other bullet points). Putting it here for somebody who needs something with a bit more features ;)
Thank you so much for your comment!!! :)
And iirc the new Java, and also python
Oh thanks. I wrote my service just because I didn‚Äôt find anything ready for my use case. Your solution seems more production ready so I definitely use it in my project and recommend instead of my micro service 
That address editor is a great idea, never seen that anywhere before!
ha! thanks for locating that sweet spot on NewRequest, also maybe unclear but what I meant in the blog post is that net/http has covered that encoding and length quite nicely for me, wouldn't want to set that or the length manually.
OP get someone to edit your writing, it‚Äôs super distracting.
I think OP might prefer to hear why you think that and some specific points to improve :)
I assume you don't want the actual answer, but rather learn how to figure these things out on your own. 1. Make the test case significantly smaller. Ideally something less than 10 lines. 2. Visualize the data as a graph.
Not interested: I‚Äôm just a critic not an editor.
Link to the GitHub repository: [https://github.com/westerndigitalcorporation/blb](https://github.com/westerndigitalcorporation/blb)
Awesome. This is exactly what I was looking for.
Yeah, this isn't about the answer. This is strictly a curiosity thing about channels, because from a birds eye view, they seem to be perfectly suited to emulate circuitry. I have approached the problem in other ways, but this is the most interesting one imo.
My idea was to "flood" the circuit through the signal provider, which will just continually push the same value onto a channel. That way, at least in theory, all wires would wind up with a value in the end. I am assuming some things though; no cycles and that all nodes are "reachable".
I consider it a spam. I have no idea why I should care about any Go newsletter whatsoever. (Ful time Go programmer since 2010 here). But maybe I'm mistaken. Can you explain in _one short sentence_ why should I care?
How to send a small text file with high memory usage and large amounts of bloat with HTTP: medium
I appreciate it you give me your private stage to pitch my newsletters, but by clicking on the discussion you yourself already show you apparently have interest in this newsletter issue (as shown in the title). I do not care that you still state you do not care, that‚Äôs up to you. Whether it‚Äôs a shopping street and you pass by stores you don‚Äôt like, look around at Airbnb and ignore the offerings that do not appeal to you, or are zapping from one tv channel and passing by some before you choose the next, I really do not care. 
[removed]
Ok, from now on I'm reporting your posts mentioning your newsletter as spam.
If that makes you feel well, you should do that
yea who doesn't love typing verbose as shit java code into a REPL
[removed]
[removed]
i mean netflix still stream their video over http if we use browser :P
Go contracts is a terrible idea.
I didn't realize this before but now I agree that Go 2 contracts can be severely abused in a hack-style clever way.