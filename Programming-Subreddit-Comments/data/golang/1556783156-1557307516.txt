This. Nginx with rtmp module and ffmpeg installed on a server is all you need. It's a tiny implementation but you can then build a go server on top of, reverse proxied to nginx. https://hub.docker.com/search?q=Nginx%20rtmp&amp;type=image will get you started.
[https://golang.org/pkg/encoding/json/#Unmarshal](https://golang.org/pkg/encoding/json/#Unmarshal) Probably Unmarshal would be better way to do this.
Nothing that would cross compile easily
Why don't just making an alias like `git branch --merged | egrep -v "(^\*|master)" | xargs git branch -d` to cleanup? See https://stackoverflow.com/a/6127884
Assuming Disconnected returns a channel that will be closed on disconnect and a new not closed channel after reconnect, this would be equivalent: ``` go func() { for { &lt;-conn.Disconnected() if err := conn.Reconnect(); err != nil { time.Sleep(1*time.Second) } } } ```
Unfortunately this doesn't remove local branches that are not one the remote anymore and have *not* been merged into master. However git offers a prune-mechanism for that. I wonder if this gitclean script just combines these two git commands.
[removed]
Thanks ! Great tips!
Agree on that, usually people come to Go from different programming languages, most likely with a senior experience already. But hey senior is just a label. Work hard and you‚Äôll get there buddy
What's wrong with that JSON? I'm not seeing it...
[removed]
I think because the last attributes have commas.
Thanks! Really appreciate the feedback.
[removed]
The 2 are not mutually exclusive! üè¥Û†ÅßÛ†Å¢Û†Å∑Û†Å¨Û†Å≥Û†Åø
That sounds cool! The frontend part of Wails is generally hot-swappable. About 6 months ago I had 3 different templates, 2 of which weren't Vue. It would be entirely possible to add a jet template if you wanted. Best of luck.
Thanks! I think I know how to do this by now, create one worker goroutine, lock it to the os thread, and send jobs to it. Only the nested requirement might be a bit tricky and will probably require synchronization. Since some people have asked, I need this for an implementation of nested transactions on a database. If transactions are nested from different treads, this would lead to all kinds of badness. So the idea was to run every transaction in the same goroutine sequentially, and the locking to the OS thread is an additional safeguard to prevent issues with the underlying database. I'm no longer sure it's that easy, though, because I also need to prevent transactions from overlapping. I have to think about this a bit more.
But do you neccessarily need it?
ye most of twitch is written in Go, they use rtmp &amp; go for live video
You cannot just write such things even if they are true... Reddit does not like statements that attack parts of the redditors religion and IDE talks are religious arguments since emacs vs vim.
DarkBASIC. It‚Äôs free and open source and I remember it being low poly af
...in Go.
Lmao didn‚Äôt realize what sub we were in sorry ü§£
I don't think it's completely necessary to take a deep dive into data structures and algorithms if you're strictly doing things like web development (making REST APIs and such). Data structures can be very language dependent when it comes to their usefulness. However, if you'd still like to broaden your knowledge, (which is always a good thing) I suggest going for Harvard's [CS50](https://www.edx.org/course/cs50s-introduction-to-computer-science). It's not going to be in Go, but I argue that's a good thing because you'll soon see why programming in Go is so much nicer. I went through the whole course before learning Go and it really helped me learn some fundamental CS concepts that have helped me in the long run. (Computational complexity probably being the most useful)
That behavior is explained here: https://github.com/golang/go/wiki/Modules#can-a-module-consume-a-package-that-has-not-opted-in-to-modules tl;dr it can handle dependencies that don't have a go.mod but either do or don't use semver tags, with different outcomes being logged in the mod and sum files.
Refactoring go code in vscode is painful. I am considering picking up jetbrains tool for this purpose.
Go offers a way to serialize and deserialize but you need a structure. Mobile so hang with me. You shouldn't need to write any custom unmarshaller. struct U { ID `json:"id"` Name `json:"name"` } Struct UserAssets { Checking `json:"checking"` } Struct User { UserMeta U `json:"u"` Status 'json:"status"` Assets UserAssets `json:"assets"` Purchased bool `json:"purchased"` } Struct UserList { Users `json:"users"` } body, err := ioutil.ReadAll(resp.Body) if err != nil { log.Println("failed to read response body") } func main() { // Logic to get body here userList := UserList{} err = json.Unmarshal(body, &amp;userList) if err != nil { log.Println("failed to unmarshal profile json") } fmt.Println(userList) } I've done this extensively in this project you can use as a reference: https://github.com/LaughingCabbage/fortnite-tracker/tree/master/v1
Yeah I think so too but you never know when you might require them. Also, for some reason, Data structures and algo problems are hugely popular with interviewers. Does the course you mentioned not require any coding?
https://mholt.github.io/json-to-go/ will give you an idea how to create the struct with the correct JSON tags that can be used by the json.Unmarshaler interface. As others have pointed out your JSON is invalid, so here's a valid version: ``` { "users": [ { "u": { "id": 42, "name": "Foo Bar" }, "status": "single", "assets": { "checking": 42 }, "purchased": false } ] } ``` Lastly, have a read of https://blog.golang.org/json-and-go - linked from the [encoding/json package documentation](https://golang.org/pkg/encoding/json/).
¬´Grokking Algorithms¬ª will be great to start. Also you can try ¬´Introduction to algorithms¬ª by Cormen and co.
It's Harvard's introduction to computer science, definitely requires coding. It's primarily assignment based, so you will have to do coding exercises each week. You'll be using command line tools to submit your exercises for grading, which happens instantly. There's easier and harder versions of the assignments, do both if you want to get the most out of it. Depending on your starting skill level, you might skip the first week where they use scratch to introduce programming to people who haven't really encountered it. I still recommend watching the lecture though. They dive right into C right after though, so expect to be challenged. You can also pay for a certificate at the end of the course that's valid college credit if you want.
For a complete beginner I would recommend a book: `"Grokking Algorithms: An Illustrated Guide for Programmers and Other" by Aditya Y. Bhargava` It depends on your preferences, but things like algorithms and design patterns often need to be revisited and finding a page in a book is faster than re-watching a video. And I wouldn't worry about the programming language. Those are universal/mathematical concepts.
But i don't want to delve into other back-end languages right now. Do you think it would be easy to translate these codes to some other languages like JS or Golang?
Thanks a lot .. i'll check this out
I don't quite agree with data structures being very language dependent. A large part of "algorithms" is thinking in efficiency. How many actions does your code perform to achieve some goal. This is precisely why various data structures exist: different use cases have different optimal solutions. For example, if you have a large data set that you want to expose through an API you can have 2 completely different use cases: 1. You want to allow searching the data set one 1 specific field. 2. You want to allow quick look-ups based on an ID. For use case 1 you'll prefer an array where your data is sorted. Searching a sorted list is quite efficient, granted that you can look up items at specific indices in the sorted list. For use case 2 however you'll prefer a hashmap/dictionary as those are focused on providing fast single item look-ups. Hashmaps are not that great however for iterating over the full data set, nor do they provide linear indexing where you can e.g. ask it for item 342 of the 1000 stored items. These ideas and solutions return in a lot of programming languages. Granted some languages have a more extensive built-in set of data structures, while others stick to the basics. Aside from data structures, generally reflecting on your code and how (in)efficiently it performs a task is quite valuable. Especially if you're writing code that's going to be used in higher performance environments (e.g. lots of calls per minute to your API). Analysing/studying algorithms and how data structures are implemented teaches you how to think and break down your code, and understand where bottlenecks lie. After a while this becomes second nature and your code will naturally be a bit better equipped and more efficient. So it makes sense that job interviewers see this as a valuable skill. ------ On topic: I don't have suggestions for online courses sadly. Everything I've learned was through university and they stuck to teacher-written course material.
I don‚Äôt think learning a little java will hurt you. May I ask why you seem to think that?
I believe that currently modules simply impute the module contents after they download the repository into the $GOPATH/pkg/mod folder, same as though you ran \`go mod init\` and \`go mod tidy\` I'm not sold on modules as they are implemented currently. I am always having problems with the disjoint between \*specifically\* this automatic module processing and repositories I am working on in parallel together. With GOPATH, this is never a problem. With modules, it can really be pig-headed about the current latest tip of the master branch, even though in my local, module-enabled dependent package it also has been module-ized and it should be syncing that state with the module cache. &amp;#x200B; But it doesn't, and I always so far have ended up turning off modules because changes I make in GOPATH packages instantly compile correctly from the current state of the repo. &amp;#x200B; I think the module spec will need to be updated to automate the synchronisation such that it looks to the local version before it goes to the network to get the 'latest', which will be out of date compared to the local version. At this point, modules are quite nice for working on one repository, but if you have more than one to work on at a time, you are probably better off using git submodules or just reverting to GOPATH so there is no sync problem.
The problem is that Go is a relatively new language so it's harder to find resources taught solely in Go. Aside from that, I think you need to take a step back and think about your original question. Data structures and algorithms are language agnostic. You can implement them in nearly every language. This makes it a general computer science subject, but there are other important subject as well. The course I recommended does not aim to teach you C, Python, or Javascript. It's aim is to arm you with the knowledge to complete a task using any of those languages. If you have never taken a computer science course and would like to broaden your knowledge to learn about data structures, algorithms, and computational complexity, I would go with my suggestion. Once you complete the course, translate all the programs to Go programs and you'll start to realize how much you've learned. However, if you'd like to just make REST APIs in Go, you don't really have to go very far in depth to do something like that. You could skip all this and just learn how to use the http package. In the end, the choice is up to you.
Take a look at [https://goa.design/](https://goa.design/)
Just the time-constraint, i wouldn't wanna much time learning about Java. The question is how little would i need to learn. In the end i would have to translate those codes/programs to language of my choice.
To be honest my current aim with Golang is exactly what you mentioned (REST APIs), but i can't help but come across data structures and algorithm concepts during my everyday work (through peers or sometimes in online forums). There's no doubt that these are important to learn to become a good back-end engineer so i want to start learning these as well.
I don't think we disagree, I said the can be, not that they absolutely are dependent. For example, a linked list in Rust being an absolute nightmare. This is mostly due to language implementation warts and shouldn't deter anyone from learning about data structures. They are a general CS concept that have use cases just about everywhere.
For best results, I would suggest learning a wee bit of Java; the minimum required to understand these courses and translate the code snippets from Java to Go.
This link contains more links into it... I've been trying to follow this as much as I can. I hope you enjoy! ‚ÄúClean Architecture using Golang‚Äù by Elton Minetto https://link.medium.com/aNYX4dvymW
G3n appears to be rather easy to get started with. https://github.com/g3n/engine
THERE IS ONLY MY INFINITE DESIRE ü§ñ
we are switching from PHP and ColdFusion to Go, so any of those will help, but as long as you have some experience, I can turn you into a Go developer :-) (And yes, we hire Junior Developers too.)
There is a plugin package in the standard library, but trust me, you don't want to use it. Go doesn't really support in-process plugins the way some other languages do. You are much better off going with an out of process RPC plugin solution like https://github.com/hashicorp/go-plugin.
I think I mistook you for the parent post saying go is ‚Äúhard mode‚Äù.
We're using it in my company internally. I've done a POC: https://github.com/tehcyx/cloud-build-poc/blob/master/prod.cloudbuild.yaml and started using it for my private Github repos as well. Deployment works really good, if you just need to do that. In the POC I build a golang app and then deploy it to a GCP cluster. The linked code is a little outdated, as we've learned a bit more since October last year. For us it was a welcome change away from Jenkins to Google Cloud Build.
define enterprise
I did, see the list of requirements. That's what I consider as enterprise
The `go-plugin` project from Hashicorp is a reliable way and gRPC is awesome, but if you like to keep is smaller you could simply define an interface (or multiple ones) that a plugin must implement and then document how to compile your project. So in short: Let users implement and compile their own plugins right into your project. That of course assumes your project is not closed source!
The biggest offender was always for loops. I'd write "fo" and see that a for loop was in autocomplete so I'd pick it, but it wasn't actually for, it was one of it's templates to make some certain kind of for loop that I don't need at the moment. Stuff like that just started happening too often for me. Didn't happen as much in GoLand as it did in IntelliJ working on Java stuff since there's all kinds of weird templates it has for Java.
Can I apply?
[39](https://github.com/golang/go/blob/09a930c0918ba72d66bd83c7fc090c3c92e6384a/AUTHORS)
To be honest, that might not be the best approach. All Languages have their strengths and weaknesses. Typically, one isn't better than another without considering the goal of your project. I'll give you an example: At my job, we use golang for backend development and node/react for the front end. Would anyone on the frontend team recommend we use golang for frontend development? Probably not because while it does create smaller, fast runtimes writing go code is more time consuming than other langs. I'm on the backend team, and I wouldn't recommend we switch to node/react because it's built for fast prototyping/framework development which the front end developers need, but we won't get far with the bloated executables you get from it. Java is better at something than other languages, and you should know what that is. Go is better at something than other languages as well, but it isn't going to be right for all situations. That's why most of these x lang is better than y lang talks are in a way pointless without the context of the project you're working on, and that's why exposure to many languages is a good thing. Also, You won't actually lose time studying Java. What you learn about Java will carry over into go. I know the syntax is different, but those answers are just a google search away.
Thank you!
&gt; but those answers are just a google search away That's fine with me.I'm ready to give in that much effort. Just don't want to start learning a new course due to this.
It can't start without a handler, that should be in the constructor, not in the interface. Also, I question whether it needs an interface at all, or more exactly, that looks like a generic handler type, except for the port query method. And the port query I question whether it should have it anyway because that should be set by the caller, though if the idea is opening session specific connections then I can see the logic of that, then you do need at least one function or accessible variable to see it. I'd suggest you have a look through the stdlib interface types already existing. You might find it more or less already exists, and all you have to do is add that port query, and make the start function noop if the handler hasn't been assigned.
[removed]
Interfaces, imho, are of dubious functional value to programs, and their whole purpose has to do with creating common denominator types that allow significant abstraction. &amp;#x200B; You can do the same thing with closures, but closures have a lower overhead since they won't be dealing with interface variables and type assertions. It's not huge overhead, but I'm sure an interface costs maybe close to twice the time to process it. My suggestion is, define fields in the primary data structure that are equivalent to interface methods you would otherwise use, and you gain the extra benefit of a clear and simple way to chain handlers and whatnot, which has to be done with closures even when you wrap it in an interface.
Looks cool. Is there any reason you focused on Twirp versus just supporting broader gRPC implementations?
I've seen the horrors of php 4.x and am glad I got out when I could. Many people nowadays say PHP is not what is used to be since 7.x and laravel, but even the 'artisans' in my inner cirle are still complaining. Seems like the nightmare really can't be fixed. Good time to switch to Go though ;-)
Thank you! I'm anxiously awaiting my beta approval. :-)
Nice idea ! I wanted to adapt GitKraken in terminal in Golang but that project could be the base of a GOtkraken? I find GitKraken as all electron apps too heavy
I don't necessarily view 'and it's a JVM language' as a *good* thing, but Kotlin has a much nicer syntax indeed. &amp;#x200B; rotfl @ NYC Library, love this.
&gt;Go can‚Äôt beat Laravel + Nginx + composer. yet ;-)
I'd some checks on the lower and upper bound like : if uidx &gt; len(slc) || lidx &lt; 0 { return \[\]byte{} // en error would be better }
Github has a number of projects for this - https://github.com/tayllan/awesome-algorithms - https://github.com/floyernick/Data-Structures-and-Algorithms (Go) - https://github.com/arnauddri/algorithms (Go) - https://github.com/0xAX/go-algorithms (Go)
I cannot speak for GitHub actions, as I've not tested that personally yet. We got it on the company account but, but I just haven't gotten around doing anything with it. It looks very promising and supporting though. Not to dampen your hopes, but I have been signed up for GitHub actions beta since announcement and haven't gotten in yet with my personal account. If you're considering cloud build, start doing a poc, 120 (build) minutes a month are free for you to use. What you'll have to pay for is storage of containers, secrets and so on. Documentation on cloud build is also pretty good as far as I'm concerned, for the general use case. For things like slack/email integration to get build notifications they even have some description on how to get that done via their pubsub service.
I've been doing back end web development for a decade in a wide variety of languages, and have never really needed any formal training or knowledge of data structures / algorithms to be effective in my job. On the other hand, I've spent this last year diving into embedded C programming in my spare time, where I've found these things a lot more necessary.
It could just be because the author didn't want to use in chapter 9, something that he would be explained in chapter 10. If you understood that he could have used the pattern of chapter 10 in chapter 9, you fully mastered the concepts.
Not OP, but I could see this being very useful in environments that don't support HTTP2 / TCP. I work often in FaaS and other "serverless" backends that can't handle native gRPC.
Hey guys, sharing with you something I crafted yesterday. A CLI tool for generating a __typed__ version of the Go `sync.Map`. It works and tested on versions `1.11.x`, `1.12.x` and `tip/master`. Checkout [these examples](https://github.com/a8m/syncmap/blob/master/testdata/gen.go) Of course, you can read more about the implementation [here](https://github.com/a8m/syncmap#how-does-it-work).
why not sending this as a PR for testify?
The ramp ingest server is go yes. It is a fork of [https://github.com/yutopp/go-rtmp](https://github.com/yutopp/go-rtmp) IIRC. Form there the video was streamed to a c++ transcoding system that did all of the video decoding, scaling. encoding, etc, and signaled the manifest creation system which was written in go. The coordination of all the was written in python, and is/was begin swapped out with more go. &amp;#x200B; Source: I wrote the c++ parts.
With Gorilla, I use the following to write a message: c.SetWriteDeadline(time.Now().Add(timeout)) err := c.WriteMessage(websocket.TextMessage, data) if err != nil { // handle error } To use this package, it looks like I need to do the following: ctx, cancel := context.WithTimeout(context.Background, timeout) w, err := c.Writer(ctx, websocket.MessageText) if err != nil { cancel() // handle error } err, _ := w.Write(data) if errClose := w.Close(); err == nil { err = errClose } cancel() if err != nil { // handle error } Do I have this right, or is there a simpler way to write the code? The call context.WithTimeout creates a timer and does some other stuff. That's a lot of work for passing a deadline down to the network connection.
üëçüèª
Full disclosure, I work at [Mux](https://mux.com), so I'm obviously biased in this opinion. &amp;#x200B; I would *highly* suggest you not start off with building your own end-to-end video pipeline. It's a rat's nest of ingrained knowledge and industry buzzwords, and especially if you're not already knowledgeable re: video, you're going to have a pretty serious learning curve to deal with before you ever accept your first live stream. I'd suggest starting off building on top of a platform that will take in RTMP or WebRTC and at least handle the processing bits there. If folks like the service and you feel like you're starting to get a little traction, by all means go back and work on your own streaming infrastructure if it makes business sense. Some services that could be useful on that end would be [Mux](https://mux.com/for/go), [Wowza](https://wowza.com), [Zencoder](https://zencoder.com), [Red5](http://red5.org/), etc. Some of these do more than others (Mux, for example, will let you create RTMP endpoints, then handle encoding, out to streaming via HLS, others might just handle ingest or processing, not the CDN, etc). &amp;#x200B; That being said, if you *do* really want to go down the video rabbit hole, you've got some options: \- The [Demuxed YouTube channel](https://www.youtube.com/channel/UCIc_DkRxo9UgUSTvWVNCmpA/videos) has quite a few resources. \- Here's a [fantastic tutorial/primer on FFmpeg/libav](https://github.com/leandromoreira/ffmpeg-libav-tutorial). \- Someone else mentioned [Pions](https://github.com/pion/webrtc) in the thread, but it's definitely worth a look if you need WebRTC ingest &amp;#x200B; Feel free to shoot me a DM if you run into issues down the road. I can help with the video part of things more than Go, but we write a lot of Go internally so I'm sure if I can't help I can find someone that can :) &amp;#x200B; Good luck!
Your last two choices are almost the same. &amp;#x200B; For my projects I've mostly gone the first route; the extension scripts are easy to share, don't require users to know about compilation or worry about compiler/runtime-versions, and can be shared across platforms. &amp;#x200B; If you're doing "maths stuff" it will require more up-front work from you to think of how you want the extension to work - for example if you implement \`sin()\` and \`cos()\` but expect them to implement \`tan\` how would that work? Would you expect the user to write this function? function tan(x) return( sin(x) / cos(x) ) end If so how do you make \`tan\` available? Do you have them fill out an "extension" table, and make functions there callable? Lots of interesting choices, but that's part of the fun. &amp;#x200B; (My idea of fun was writing a compiler that converted "maths" to assembly language - [https://github.com/skx/math-compiler/](https://github.com/skx/math-compiler/) )
Plugins are hard to due in the scripting Javascript/PHP/Python way. Personally, I've not seen much success with Lua plugins in the little I've seen them, seems people would rather `go build` than write the plugin in Lua. Thinking outside the box, one possible approach is to allow users to create additional HTTP gRPC / REST services that you can submit payloads too for additional processing. These can be localhost only or public facing ports.
I honestly can't imagine NOT using a full blown IDE for a large project, I would love the lightweightedness of a text editor but even with all the plugins and whatnot it just doesn't compare IMO
Goland, based on JetBrains main IntelliJ SDK, provides way more advanced features since it is built on top of the most advanced IDE SDK at all. You'll get intelligent auto-completions for **all** packages/modules you're importing, over 4000 intentions for possible bugs, performance boosts and general code improvements. To get a deeper look about Goland's real power check out the [feature showcase page](https://www.jetbrains.com/go/features). VS Code is a great IDE for web related projects I use for JS/React/CSS/HTML/..., but when it comes to static/native development I wouldn't rely on it. In the end it only runs a [language server](https://langserver.org) that only knows a small portion of the language it tries to support. Also in the current time I think RAM is one of the least problem one should think about. Anyway, if you look closer you'll see that VS Code eats way more RAM than a simple JVM. I don't use Goland directly but IntelliJ Ultimate with the official Go plugin that provides **all features of Goland** (since Goland is a stripped down version of IntelliJ) and even with 100+ other plugins enabled it only uses ~900MB to 1GB RAM (JVM + file watcher process). In comparison **only the main process of VS Code uses 890MB when idle** while it spwans more than 8 child processes (GPU renderer, file watcher, TSServer, ...) which again adds more than 900MB. So in the end VS Code eats almost 2GB. Why? It's a electron app. Deal with it :D
Love this reply üòç
VSCode is free and Goland is very expensive. Goland's problem is java.
You can [replace](https://github.com/golang/go/wiki/Modules#when-should-i-use-the-replace-directive) imports, if that helps. But the module path should correspond to the URL, this is not Java.
Always worth mentioning, JetBrains gives out free licenses for students and some open source developers as well afaik.
[removed]
[removed]
Technically, it can take any Go interface (defined by a protobuf "service") and it should work as well.
I'm not student anymore. Not in a startup, not in a business. Work in a research lab. I do mainly open source development. I wasn't aware of the free licence. When I saw the price, I concluded it was not for me.
Right, that's one of the biggest reasons I prefer Twirp over gRPC, amongst others :)
Sorry- I should have used ‚Äúone‚Äù rather than ‚Äúyou‚Äù I didn‚Äôt meant to attack you specifically... but hopefully you can qualify for the open source license? I don‚Äôt have experience with that one, only the education and work ones, but it‚Äôs an option if you want to give it another shot. https://www.jetbrains.com/buy/opensource/
I recomment to look at a \[Server from net/http/httptest package\]([https://golang.org/pkg/net/http/httptest/#Server](https://golang.org/pkg/net/http/httptest/#Server)). It looks like what you need, especially since you mention that intended usage is for testing.
Minor point, naming your project folder "platform" causes goimports and other tooling to confuse which version of "platform" you want want import in other packages. I stopped calling it "platform" or "domain" and started naming it a/the project name instead. That way I never have the wrong `platform.User` entity showing up in my subpackages. "forumfive.User" or "alphashift.User` are clearly spelled out.
What happens if you just type ‚Äúgit‚Äù and press enter?
[Obligatory watch](https://www.youtube.com/watch?v=C1EtfDnsdDs) when to and when not to use `sync.Map` by the person who implemented it (tl;dr: You probably don't want to use it).
Nice approach! You may like [autoflags package](https://godoc.org/github.com/artyom/autoflags) which is similar but works in runtime without the need for code generation.
I just use it when I feel lazy to do synchronisation myself
c:\&gt;git 'git' is not recognized as an internal or external command, operable program or batch file. Not sure how to setup W7 variables. Git has 1 entry in the 'System variables': Git_SSH Nothing in 'user variables for Owner'
The only thing I don‚Äôt like about this is if it fails to reconnect I would be returning a new Disconnect channel which seems non-obvious. I would only expect to read from Disconnected if there was an established connection.
https://github.com/avelino/awesome-go
So it‚Äôs not a go problem. To be honest I don‚Äôt run Windows, but IIRC: set path=%path%;C:\where\is\git\git.exe should do the trick. (Note that this is not permanent)
The gRPC is for data transferring only. We initially intend to wrap up some metadata about the video slices along with their bytes, and we need to use it to define our other procedure calls to draw stuff on the client. gRPC is built on top of HTTP/2, so I'm pretty sure that concern you mentioned is covered up. There are two major things going on: the live video and a live dashboard about the video. We want to explore how well using a HTTP/2 based protocol that is made on top of protobuf - which is allegedly more efficient than transferring a plain BSON for drawing the dashboard on the client - can outperform, or not, conventional HTTP approaches. And, on top of that, we'll have a platform for streaming autonomous robot soccer matches, in case you are wondering (: Thanks for the awesome reply!
Thanks! Really helpful reply
The problem is that you can use a `string` as an `interface{}`, but you cannot use a `[]string` as a `[]interface{}`.
 That didn't work either. I know Linux when it comes to this, but never did anything with path in Windows. I think that I am going to reinstall git. There were several question it asked and I probably got something wrong. Thanks
Okay, so what's the solution if I don't know the length of `cols` at compile time? I did find something that works: ``` names := make([]interface{}, len(cols)) for i, v := range cols { names[i] = v } tab.AddHeaders(names...) ``` But this is so ridiculously contorted I refuse to believe it's the correct solution.
Nope, that‚Äôs it
I agree that `sync.Map` is not a replacement for `map + sync.RWMutex`, but it's useful (and sometimes needed) in some cases (like mentioned in the video). Also, with code generation, type-safety and `interface{}` are not problems.
Given how it works, how much effort is it to extend this for some of: https://github.com/emirpasic/gods ?
It‚Äôs difficult to figure out your bottlenecks without more details. But here‚Äôs something to keep in mind regarding interfaces: - They are ‚Äúfat pointers‚Äù, or a pair of a data pointer and a type pointer. So a collection of interfaces will be twice the size of a collection of concrete types. - Method calls on interfaces are a little more expensive than method calls on concrete types (which are essentially static function calls), but not that much. - Converting between different interfaces, using complex interface combinations, and asserting to a concrete type from an interface can be expensive operations. So my general advice would be stick to keep your data in concretely typed containers and pass individual elements to functions that accept simple, flat interface arguments and return concrete types.
This is very cool I was looking for something like this. Could I also ask at a high level what the steps are for implementing a code generator for type-specific collections like this? I was thinking of doing something similar for a few design patterns like a producer / consumer pattern.
Then it's almost guaranteed to be counterproductive
Sure :) I do believe people should consider it carefully though :)
Further along, it gets worse. I need to call `rows.Scan(dest ...interface{})`, and again, if I know the required length of `dest` at compile time, all is fine. I just call it as: ``` err = rows.Scan(&amp;v1, &amp;v2) ``` or whatever number is needed. But what if I don't know?
The database APIs were designed with the idea you'd deserialize the your query results into concrete structs, because you know what you're asking. Any type of dynamic handling of db results will require you to do the kind of dance you posted above. You can try using 3rd party libraries if that really annoys you.
Do you know of any 3rd party library worth recommending?
great resources! commenting so I can always find the links.
Vscode supports pretty much all the same features. And it doesn't use language server, not by default at least. It relies on a bunch of Go tools. Don't know what you meant by a small portion of the language. The tooling understands every line of your code.
I had similar experience with goland. Just way too much going on, felt heavy. Used it for a few weeks or so and then went with ST2. But someone recommended me to just disable everything in goland and add stuff as you go, as you need it. Might try that at some point...
It depends on a lot of things, but here's some ideas: Lift up the operation you're doing to your data structures, instead of your elements. Instead of: type Element1 { } type Element2 { } // (DoIt for each type) type ElementDo interface { DoIt() } consider type Element1Collection []Element1 type Element2Collection []Element2 // (DoIt implementations that loop over the elements, calling // DoIt) type CollectionDo interface { DoIt() } A call to "do it" on a collection will pass through an interface, but each individual call will be static. You could also do something like type AllTheThings struct { Ones []Element1 Twos []Element2 Threes []Element3 } func (att *AllTheThings) SomeOperation(...) { for _, element := range att.Ones { element.DoIt() } // and so on } All of these may also result in inlining; check the rules for that if you're interested, there's other posts on /r/golang for instance. But it'll definitely at least be a static call. Also, a simulation may be the rare time you may want true Go arrays; for instance, xyz dimensions can be stored in a [3]int, and that [3]int can avoid incurring slice overhead and end up inlined into structs or other arrays, etc. This can help with memory locality, too; [][]int means you have contiguous slice headers, but the slices themselves can be all over the place. [][3]int will be a contiguous array of [3]ints, with all the ints in a single place.
There's basically "for" and "forr" templates, the latter being "for range". I actually thought the other day that it's a quiet elegant template trigger.
Thanks, that's a good idea. I've opened an issue.
This. Someone already did the hard work for you, OP.
With Gorilla, I use the following to write a message: c.SetWriteDeadline(time.Now().Add(timeout)) err := c.WriteMessage(websocket.TextMessage, data) if err != nil { // handle error } To use this package, it looks like I need to do the following: ctx, cancel := context.WithTimeout(context.Background, timeout) w, err := c.Writer(ctx, websocket.MessageText) if err != nil { cancel() // handle error } err, _ := w.Write(data) if errClose := w.Close(); err == nil { err = errClose } cancel() if err != nil { // handle error } Do I have this right, or is there a simpler way to write the code? The call context.WithTimeout creates a timer and does some other stuff. That's a lot of work for passing a deadline down to the network connection.
Unfortunately no. In your above code, you'd want to put it all into a function, defer the context cancellation, and also handle the error from w.Write. You'd want to use the \`wsjson\` or \`wspb\` subpackages to simplify writing/reading or write your own if you're not using json or protobufs. &amp;#x200B; It's pretty easy: [https://github.com/nhooyr/websocket/blob/master/wsjson/wsjson.go](https://github.com/nhooyr/websocket/blob/master/wsjson/wsjson.go) &amp;#x200B; The reason its more complicated than gorilla/websocket is really just to not expose two different APIs that do the exact same thing, writing bytes to a connection. There is an open issue regarding this: [https://github.com/nhooyr/websocket/issues/62](https://github.com/nhooyr/websocket/issues/62)
Seems like this wouldn‚Äôt be too hard to generalize to any structure you don‚Äôt like the types of.
Most of the useful types are going to end up containing pointers (eg strings) or at least being as large as an interface (two words), so I wonder how much performance this buys in the real world. Sure, there‚Äôs also type safety but you can get that by just writing a super simple wrapper type.
Thank you guys! Since I am trying to write everything my own without 3rd party, I guess I will try RPC for now. Just wondering... I was told sublime was written in C but uses Python inside to control and also for plugins. Do you know how dods Python can connect to C?
Thanks I love that repo too it‚Äôs not hard work at all it‚Äôs just the links and resources I and others come across throughout the research I do whenever haha. Doesn‚Äôt hurt to have another with some other resources it‚Äôs not like I set aside time to build the list I literally just paste things in as I find them
Thank you I hope you enjoy add something and share with a friend who can maybe add something too best of luck in your journey
sqlx has been sufficient for all my needs: [http://jmoiron.github.io/sqlx/](http://jmoiron.github.io/sqlx/) [https://github.com/jmoiron/sqlx/](https://github.com/jmoiron/sqlx/) From the docs: type Place struct { Country string City sql.NullString TelephoneCode int `db:"telcode"` } rows, err := db.Queryx("SELECT * FROM place") for rows.Next() { var p Place err = rows.StructScan(&amp;p) }
Branche's that the user selects. I included an env that will allow user to specify branch names they never want as an option.
Wanted to select each branches specifically. I modeled the method on the \`git add -p\`
It's contorted for good reason. Conversion from `[]string` to `[]interface{}` takes O(n) memory and O(n) time. In general, `[]T` and `[]U` may have different memory layouts, and so the only way to convert from `[]T` to `[]U` is to allocate `len([]T) * sizeof(U)` memory, then copy and convert each `T` to a `U`. That's rather expensive, and so Go makes you be explicit about it. To alleviate this, some APIs will allow you to pass in a slice as one of the arguments, and they'll do the conversion on their end. In your example, that would look like this: ``` tab.AddHeaders(cols) ``` And the AddHeaders does some reflection legwork. You won't see the standard library doing that, again, because it's a non-obvious expense.
If your company buys into "agile" at all, just suggest some [changes](http://www.paulgraham.com/makersschedule.html) at your retrospective meeting. If you can get all the programmers on board, they can easily convince your manager to start "running interference" for you. (That's their job. Source: was a manager for software engineers.) "Having too many meetings" isn't a disease -- it's a symptom. It shows that you aren't efficiently capturing requirements/changes/progress in your other systems. &amp;#x200B; Ideas: * Ask to do stand-ups on Slack. Your manager will feel a loss of control and not want to do it. But in the spirit of agile, ask to try it anyway. Set a slack reminder every day. * Task your manager with understanding the purpose of all these meetings, where they come from, and how they can be eliminated. Have all the devs keep records. Especially note if there is no/unclear agenda, and if any body is tracking action items for followups. * Be strict about Agile. You do the work assigned for that sprint, and only emergencies are allowed to change that. If there is an emergency every other sprint, your biz people are broken. * Pick a day (or half day, such as Thursday afternoon) for meetings. * Meetings may be a sign you need a cross-functional org. If the devs need to talk to UI people, they should to be directly on the team, sitting next to them, available for questions at any time. If there are extra people (i.e. not enough to complete a full team), have them work long-term projects like refactoring the code, or researching tools. There is nothing more soul-sapping than being tasked with a full project, but not given the full resources to get there. The higher-ups need to understand that the whole project needs to be scheduled at once. Pretending that people can bounce between teams means they have no priorities, and end up blocking everyone at once. (Read The Phoenix Project for more about eliminating bottlenecks/latency.)
Note that the code snippet above does handle the error returned from Write. &amp;#x200B; I am sorry to hear that ease of use takes a backseat to a small API. I think I'll continue using the Gorilla. &amp;#x200B; Thank you for answering.
Don't know. I can tell you that Super Graph is MIT licensed and written in GoLang. It's very performant and produces a highly optimized SQL query from your GrapahQL query. It's also heavily fuzz tested to ensure its quite secure. And finally it's designed to work out of the box with Rails apps and Postgres. It can even read and decode Rails cookies.
Latest updates 1. Heavy fuzz testing to ensure it's secure 2. Full text search query support
The author means _‚Äúconverting a numeric type (int, float, etc) to another numeric type always works, there will never be an error at runtime. The same way, converting a string into []byte or vice versa will always work, there will never be an error at runtime.‚Äù_ That‚Äôs it, I‚Äôm not sure what‚Äôs confusing about that. Are you asking this question because you don‚Äôt know what ‚Äúconversion‚Äù is? Or are you asking because the wording used by the author is confusing?
When the number you are converting from are actually out of the range of the other number type you are converting to, the runtime/language can choose just "works", or cause a runtime error. Go chose to make it just "works". https://play.golang.com/p/s2_TbrH0emf is an example to demonstrate how it works.
They're both interfaces, so the implementation decides what the "data stream" is. For example, if you obtained your reader/writer from opening a file, the data stream is that file. If you obtained it from opening a socket, the network is your data stream. And so on...
Ahhhh okay, I think this is the answer I was looking for. Thanks alot ma dude,
Oh no it was not about the conversion, just didn't know why the author said "a conversion never fails at run time". However I think I understand now from the answer from @rangeCheck. I appreciate probing more into my question @unix15e8 and thank you for help.
I feel like this should be in the docs.
That. The purpose of the interfaces defined in the io package to define an interface for lots of different sources of streaming data. In addition to files, mentioned above, tcp connections are io.ReaderWriters as are the in memory buffers, bytes.Buffer. There are many other examples as this is a powerful interface. The benefit is that other libraries can provide tools for interacting with data streams without needing to know the specifics of those streams.
Another benefit is that the interface is easy to compose. For example, you might wrap a file or network stream in a bufio.Reader to peek at the first few bytes. There are many great examples of composition in the io package: TeeReader, LimitReader, etc. If you want to see some other great examples of io.Reader/Writer composition, read the source of the http package.
Can you please mention some implementations of the io.Reader and io.Writer in the standard library? Thanks
Well, this is one of the areas where Go is sorta lacking, in my opinion. Unlike, say, Java, you don‚Äôt have to explicitly declare that you implement an interface in order to implement it, your concrete type just has to declare methods with the same name and signature. So it‚Äôs not easy to just rattle off all the types that ‚Äúimplement‚Äù an interface (and Go tooling/docs certainly don‚Äôt do the work of identifying implementing types). That said, one example is os.File. But really any code you write that accepts io.Reader or up.Writer doesn‚Äôt have to care what the concrete type is.
Please take a look at EDIT2. this summarizes my doubt about streams in golang. Thanks :)
https://gokit.io/examples/ provides a couple of examples implementing onion architecture. You don't necessarily need to use Gokit, the examples could be implemented with any framework in my opinion. https://github.com/katzien/go-structure-examples provides examples on the hexagonal architecture. You should also checkout her presentations on the topic, it really helps me a lot
Wouldn't it be better to contribute to an already well known source? Not hating on you here, just seems more benefitial. Always sucks to find these things out later.
No. Distributed information consumed concurrently is better
os.File, net.TCPConn, gzip.Reader, gzip.Writer
What are u talking about? Just clone it, and its distributedüòÇ
I am not familiar with streams in nodejs, but from your description I would say they're not the same. If you want to achieve the same in Go, you'd have to use Goroutines with Channels or shared data with mutexes to synchronize. A *data stream* from my understanding is just an abstraction to a data source/sink. You can treat it as a continuous stream of data you can read from/write to (e.g. a network connection), but it this is not necessarily the case and depends on the underlying implementing type (the actual data source/sink). The chunks you're referring to in your EDIT2 are the byte slices you pass to Read or Write. See the doc on io.Read for instance: &gt;Read reads up to len(p) bytes into p. It returns the number of bytes read (0 &lt;= n &lt;= len(p)) and any error encountered. [...] If some data is available but not len(p) bytes, Read conventionally returns what is available instead of waiting for more. That's pretty general and is what you can expect from implementing types. The exact behavior regarding blocking or not, depends on the underlying data stream. Reading from memory (e.g. bytes.Buffer, strings.Reader) basically returns the data instantly. For a network connection (net.Conn) the Read call would block until some data is available which is then returned. However, reading some data, then doing something with it while more data is read concurrently, is not what it says, and to achieve that, you would have to use Goroutines. Having one to read, one to write and one to coordinate.
Just what I wanted to clarify. This is like a false friend ( if you are interested in learning human languages, u will be familiar with the term). I was trying to apply the knowledge about the streams in nodejs to golang, which obviously was wrong
Isn't awesome-go more about packages and tools? The OP's list OTOH files blogs and articles and learning resources. I think the two lists complement each other quite well. BTW thank you /u/findingjake for including AppliedGo.net! :-) Glad to see you like it.
But I want two, each with different links and contributions
For VSCode, you should count the memory used by all the Electron sub-processes, not just the launcher one. And then count the memory used by all the tools when you perform any action or save a file. Please come back with the results then.
What benefits are you expecting?ü§®
It is also worth pointing out that this: u64 := uint64(math.MaxUint32) + 2 var u32 uint32 = u64 does not **compile**. So, it never would come to a **run time**, as the compiler rejects your code. The conversion uint32(u64) makes your intent clear to the compiler. Go's static type system ensures that such explicit conversions, however, are only ever allowed between similar types (e.g. you cannot convert a string to number with *always works at run time* guarantee). In such a case, there are no runtime dependent unknowns to deal with, but a clear path for conversion, and thus, &gt; never fails at run time
Python is easy to embed in C, for example this is a good starting point: https://docs.python.org/3/extending/embedding.html (The same is true of a lot of "scripting" languages, which are written in C. I've embedded Perl, Lua, and other languages inside C &amp; C++ applications over the years. Lua is obviously designed for this, but it is still possible for Perl, Python, and even Ruby if you're interested in doing that.)
Last week while walking home from work I was thinking about how generics might be easy to implement with a similar mechanism. For any function, say `Foo(p1 int, p2 float)`, it should be possible to instruct a tool to generate a version, say `FooString = Foo(string, float)` and all it needs to do is take Foo and rewrite it so that the first parameter is a string instead of an int.
Cool.. thank you!!
Not too hard, I already did similar thing to the standard `container/heap` and `container/list`packages (didn't open source it yet).
Sure thanks for the additional info will try and let you know
For producer/consumer code, or any other code-generation that is not part of standard library, I'm taking a different approach, using the `template/text. Do you want me to elaborate on this?
&gt; I wonder how much performance this buys in the real world Here's the standard library benchmark tests result (on my computer): ``` BenchmarkLoadMostlyHits/*main.DeepCopyMap-8 100000000 12.7 ns/op 7 B/op 0 allocs/op BenchmarkLoadMostlyHits/*main.RWMutexMap-8 30000000 53.6 ns/op 7 B/op 0 allocs/op BenchmarkLoadMostlyHits/*sync.Map-8 100000000 16.3 ns/op 7 B/op 0 allocs/op BenchmarkLoadMostlyHits/*main.IntMap-8 200000000 6.02 ns/op 0 B/op 0 allocs/op BenchmarkLoadMostlyMisses/*main.DeepCopyMap-8 200000000 7.99 ns/op 7 B/op 0 allocs/op BenchmarkLoadMostlyMisses/*main.RWMutexMap-8 30000000 52.6 ns/op 7 B/op 0 allocs/op BenchmarkLoadMostlyMisses/*sync.Map-8 200000000 8.87 ns/op 7 B/op 0 allocs/op BenchmarkLoadMostlyMisses/*main.IntMap-8 1000000000 2.88 ns/op 0 B/op 0 allocs/op BenchmarkLoadOrStoreBalanced/*main.RWMutexMap-8 3000000 357 ns/op 71 B/op 2 allocs/op BenchmarkLoadOrStoreBalanced/*sync.Map-8 3000000 417 ns/op 70 B/op 3 allocs/op BenchmarkLoadOrStoreBalanced/*main.IntMap-8 5000000 202 ns/op 42 B/op 1 allocs/op BenchmarkLoadOrStoreUnique/*main.RWMutexMap-8 2000000 648 ns/op 178 B/op 2 allocs/op BenchmarkLoadOrStoreUnique/*sync.Map-8 2000000 745 ns/op 163 B/op 4 allocs/op BenchmarkLoadOrStoreUnique/*main.IntMap-8 3000000 368 ns/op 74 B/op 2 allocs/op BenchmarkLoadOrStoreCollision/*main.DeepCopyMap-8 300000000 5.90 ns/op 0 B/op 0 allocs/op BenchmarkLoadOrStoreCollision/*main.RWMutexMap-8 20000000 94.5 ns/op 0 B/op 0 allocs/op BenchmarkLoadOrStoreCollision/*sync.Map-8 200000000 7.55 ns/op 0 B/op 0 allocs/op BenchmarkLoadOrStoreCollision/*main.IntMap-8 1000000000 2.68 ns/op 0 B/op 0 allocs/op BenchmarkRange/*main.DeepCopyMap-8 500000 3376 ns/op 0 B/op 0 allocs/op BenchmarkRange/*main.RWMutexMap-8 30000 56675 ns/op 16384 B/op 1 allocs/op BenchmarkRange/*sync.Map-8 500000 3587 ns/op 0 B/op 0 allocs/op BenchmarkRange/*main.IntMap-8 2000000000 1.75 ns/op 0 B/op 0 allocs/op BenchmarkAdversarialAlloc/*main.DeepCopyMap-8 2000000 761 ns/op 535 B/op 1 allocs/op BenchmarkAdversarialAlloc/*main.RWMutexMap-8 20000000 67.9 ns/op 8 B/op 1 allocs/op BenchmarkAdversarialAlloc/*sync.Map-8 5000000 264 ns/op 51 B/op 1 allocs/op BenchmarkAdversarialAlloc/*main.IntMap-8 10000000 176 ns/op 28 B/op 0 allocs/op BenchmarkAdversarialDelete/*main.DeepCopyMap-8 10000000 194 ns/op 168 B/op 1 allocs/op BenchmarkAdversarialDelete/*main.RWMutexMap-8 20000000 76.9 ns/op 25 B/op 1 allocs/op BenchmarkAdversarialDelete/*sync.Map-8 20000000 60.8 ns/op 18 B/op 1 allocs/op BenchmarkAdversarialDelete/*main.IntMap-8 100000000 13.1 ns/op 0 B/op 0 allocs/op ```
My limitation is running the ide in 7 year old Mac book air, the test I did was based on the old machine which kicked off the fans to crazy when I tried to open simple main file with no packages other than fmt,os,os/users and the root of the project is /GitHub.com folder in go path where all my packages are installed , I do agree with your comment on in built features when setting up the use it picked up automatically the dep pkg mgmt and other setup which I had done earlier via command line. Will definitely give a go and monitor other threads kicked off by VS code thanks for the information.
So gitclean just shows me all branches except the one from my env?
You could look into programmer/developer flow state, how long it takes you to get into them and how distractions get you out.
check out [maker vs manager schedule](http://www.paulgraham.com/makersschedule.html). I think there are many more articles on the web. Developers usually need a few hours (like 3-4 at least) of uninterrupted focus time.
They‚Äôre both interfaces. ‚ÄúStream‚Äù doesn‚Äôt refer to anything in particular so much as describe how the Reader/Writer will be used and how they should behave (e.g. the `Read()` and `Write()` methods may be called multiple times).
As others point out, it's hard to say without knowing specifics, but if some of those internal structures are generic collections, you can try this approach: [https://adrummond.net/posts/gogenerics](https://adrummond.net/posts/gogenerics)
The JS world is unfortunately very fond of making up new terms for existing things. This happens a lot.
The point is that you don't know, and you don't actually care, where the data is coming from. It can be main memory, hard disk, network, anything. It's an abstraction that just says "it's some struct that has this method implemented." You also usually don't call the Read method directly yourself. However, if you were to call it, the 1KB buffer you provide is exactly just that: a buffer where the "data stream" can store \*up to\* 1KB worth of data that's being read. The method will return exactly how many bytes it stored (or an error if something went wrong: You can read more here: [https://golang.org/pkg/io/#Reader](https://golang.org/pkg/io/#Reader)). If you want to read the remainder of the data you would just call Read again (and maybe reuse the same buffer, if you are done with the data that's been read so far and you don't want to allocate more memory). Here is some code that might clear things up a bit. I just turned a string into an io.Reader and then called Read on it three times: [https://play.golang.org/p/1dS8bfo6vC2](https://play.golang.org/p/1dS8bfo6vC2) Usually, you pass it to something else that requires an io.Reader, like, say, ioutil.ReadAll or bufio.Scanner. ioutil.ReadAll will keep calling Read until it gets an io.EOF error and then it concatenates everything it read and returns it as a single byte slice (or an error if it encountered error). The whole 20MB file, for example, would be returned if you passed a \*file.File to ioutil.ReadAll. bufio.Scanner reads bytes until it encounters a newline (or some other delimiter) and returns it when it has a single line's worth of bytes. This way, you can start processing your data before needing to read everything. Anyway, I hope this clears things up. Feel free to ask questions if anything doesn't make sense.
That's not what's happening here. Node streams are very close to streams in other languages
Yes, so if you don't care where random strangers are going through your traffic, you can run a node choosing "All traffic" option. If you care about your node being used in a bad way, you can choose "Mysterium verified traffic" which will be used by our company for development purposes. Later on, there will be multi-hopping implemented, and with a payment system, there will come a new security level, so as a VPN provider, our number one priority is privacy and security and we won't be offering anything, that could harm anyone.
Truly :)
No, sorry, we don't
FYI; Reddit has a bookmarking feature - you can save posts. It will put them in their own place then too so you don't have to sift through loads of comments to find a post you wanted to keep track of. Also, if you have Reddit Enhancement Suite, you can categorise them. But that won't work on mobile I don't think.
I think it would be better to use a channel closer in the blocking function that you wait on, and put the error after a channel unload after the call. If the channel is closed at the end of the function the subsequent call will happen, triggering the error conditioon.
Ah, could you show me? I'm new to Go. Not sure exactly how to put what you said into code. func TestSomething(t *testing.T) { assert := assert.New(t) ch := make(chan int) go func() { myBlocker() close(ch) assert.Fail("should not finish") }() }
https://stackoverflow.com/a/34767523
Fine but anyone can run a node? And if my traffic exits through that node, then they can look at any of my traffic that isn't encrypted through SSL or something like that. It's the reason no one with half a brain uses free VPNs, only trusted VPNs provided through established companies.
have you had any issues lately with the go extension for VS code not working? I just got a new computer and despite installing the extension, and separately installing all the tools its dependent on, nothing seems to work. I also tried fiddling with the settings.json
Replace the `&lt;-ch` With: time.Sleep(...) select { case &lt;-ch: // fail default: // success } Bear in mind this test is very fragile, your are not testing that your function return, but if it does not return after x second. Should your function finish in x second + 1, you have a false negative. Your problem made me think of the https://en.m.wikipedia.org/wiki/Halting_problem
Desktop link: https://en.wikipedia.org/wiki/Halting_problem *** ^^/r/HelperBot_ ^^Downvote ^^to ^^remove. ^^Counter: ^^255236
Great explanation. Thanks.
The fact that we need to generate this is ridiculous
That benchmarks int, which I was saying is unrealistic.
I never got this... it would make sense to automatically implement interfaces if the function signature said everything possible about the semantics of the function but that‚Äôs obviously not true in all cases
You basically can't. It's probably better to test that it becomes unblocked when it is supposed to. What exactly is this function? In general you don't have to test basic functionality of the language or runtime itself. You can take as a given that a select that is never sent anything or a semaphore that is locked and never unlocked or that a read that never had anything to read or whatever will block. It's not really something you generally need to test. If things were that fundamentally broken, Go wouldn't have passed it's own tests on release.
Heh. For 3 consecutive days now I've been thinking about giving Elm a try, sitting on the fence making up excuses. I think this subjectively extremely well-timed article will finally tip me over! :)
Yes, it iterates through allows to to mark ‚Äòy‚Äô or ‚Äòn‚Äô for each one. Gives a confirmation prompt, then deletes the selected ones.
This is a classic Reader/Writer chain. Have you read Effective Go?
Sleeping in tests is a very serious anti-pattern. Sleeps may introduce non-determinism and thus inconsistent \[e.g. flaky\] test results. Moreover, ever sleep calls delays the test suite. Imagine a code base with 300 test cases that sleep for 3 seconds, that adds up to 900 seconds \[5 minutes\] of latency every time a developer runs the suite. &amp;#x200B; Don't call time.Sleep in your test. Don't even invoke non-test code which calls time.Sleep. \[If the code under test needs to "Sleep", you should pass in a fake clock through your test cases \[[https://godoc.org/github.com/facebookgo/clock](https://godoc.org/github.com/facebookgo/clock)\]. &amp;#x200B; There are very few times when you do need to call Sleep from within a test case \[for example, if you're testing Sleep itself\]. &amp;#x200B; To answer your question: There are a number of approaches you can take to test code like this with varying degrees of test coverage. &amp;#x200B; The simplest approach would just test the affirmative condition \[e.g. set whatever condition myBlocker waits for to unblock\]. A more complication approach that offers more coverage: You can re-write your your code under test to emit some kind of signal when it's started blocking \[e..g. take in a waitgroup, or use a channel\]. Then structure your test to wait for the 'blocking' stage, update the waiting condition, then verify the function finished. [https://golang.org/src/sync/waitgroup.go](https://golang.org/src/sync/waitgroup.go)
Converting hex (string) to base64 doesn‚Äôt make sense, so just convert the original text to base64.
&gt;will keep calling Read until it gets an io.EOF error and then it concatenates everything it read and returns it as a single byte slice Where are the intermediate "Read results" stored until they are concatenated?? Your answer cleared up most of my misunderstanding
i had used the delve debugging pkg in VSCode , dep dependency mgmt as well in go using VSCode, have a Docker setup for Go using Arch docker file managed via VSCode. i mean to say all these bells and whistles are required to be in place for VSCode to pick up and work as full fledged IDE. Used to be VIM loyalist did not use VIM for GO as the vim-go plugin was not working for autocomplete as i expected. Was fascinated by features mentioned in home page for IDE as this might help me to learn some NODE and other Javascript based languages.
[removed]
If it's an exercise for a course, I don't think op has a choice.
At the end of day this is mostly all a preference. But I remember how excited I was when starting with Go, and still are today. Elm feels similar so far simple, just works, move slowly. But backward compatibility is a huge diff between the two ;).
I'm always up for new things, but frontend often SO much more dependency heavy than backend that I don't like to stray much from what I consider the most traveled path right now (Angular, TypeScript, NPM, following the Angular style guide and using bootstrap 4 and font awesome). If I were a better designer, I would probably make more of my own things, but you only get so much time to hone design skills when working on admin ui for enterprise software. How does Elm fare with inter-connectivity to existing libraries and such? Specifically, can you use Angular, React, or Vue? ...Now I've skimmed your link to see if it answers more. Elm looks functional, and my only attempt to learn functional was F#--it went badly because we had so much confusing tie-in to oo concepts like functional code that had to inherit from a C# class, etc. Perhaps Elm will be an interesting way to look at functional code again.
I'm also looking into Elm for my next frontend project. I went through the beginning of the guided tour and found the the functional aspect of the language was tripping me up a bit. It's definitely different than Go in that respect. Having a compiler and types is nice, but there's Typescript for that. My gripe with TS is that it's a big language that gets bigger every day. Do you have any experience with Javascript interop in Elm? That looked like another pain point.
So what's the point to gzip it later ? :)
https://github.com/carlmjohnson/decoder-ring
What's FE?
 r := gzip.NewWriter(base64.NewEncoder(base64.StdEncoding, hex.NewEncoder(os.Stdout))) r.Write([]byte(`asasdsfdfasdf`)) r.Close()
Frontend.
We tried Elm in three projects. With two experienced Elm developers. The language is nice, type safe and the error messages are superb. &amp;#x200B; The big problem is the acceptance of it. Elm is forcing you to propagate all information from parent to children, even trivial stuff. It is verbose and this is something a lot of people dislike about it. Also it is hard to learn. &amp;#x200B; We are using Elixir in the Backend mostly but Elm wasn't accepted by the people. Also it was voted this year as a language you should not learn (just a statistics I saw some weeks ago) &amp;#x200B; I love Elm, especially the Elm Architecture (have a look at it!). I would say ReasonML or F# in combination with Fable would be interested alternatives. &amp;#x200B; Cheers!
Even worse, so yeah, I give up here üòÑ
I love how clean this task is in Go.
Useful, but not really what OP was asking for.
Front End
No, you're completely correct. Node streams are indeed abstract interfaces to streaming data such as files and sockets. OP is simply wrong here. My point stands though; the JS community have created new names for most parts of a compiler and a lot of data structures. That makes interop very annoying.
After looking at the node documentation, the concept of a stream describes exactly the same thing as in Go. It's callback-centered, of course, but the functionality is basically mirroring Go's.
&gt; My point stands though; the JS community have created new names for most parts of a compiler and a lot of data structures. Give me some examples? Because, honestly, this _still_ sounds like JS hate circlejerking instead of an actual argument. There's lots wrong with both the ecosystem and the language, but this really doesn't ring true, *especially* considering JS isn't even compiled.
Your link above does not work. The one on Github does work, however, search requests fail: The Same Origin Policy disallows reading the remote resource at https://nwl5p78d8f.execute-api.us-east-1.amazonaws.com/prod/issues?lang=Golang&amp;min_stars=&amp;days_old=. (Reason: CORS header ‚ÄòAccess-Control-Allow-Origin‚Äô missing)
I gave it a go a while back but ended up deciding it wasn‚Äôt for me when it‚Äôs handling of json was a bit icky. This may have changed now but I wanted something simple that just interacted with a basic json api so ended up deciding against it. Will probably give it another go someday as it has some great upsides.
What is it you're getting out of testing if it blocks? That isn't testing the logic or functionality of your function, just a side-effect of whatever your function is doing. Focus on testing the logic instead.
\&gt; I am sorry to hear that ease of use takes a backseat to a small API. I think I'll continue using the Gorilla. &amp;#x200B; It's more nuanced than that. The common case is addressed by the wsjson and wspb sub packages. Thus, the API is in fact very easy to use, but also very small. I don't want to add another API that lets you write a \[\]byte to the connection when the streaming style API suffices for both.
Think about what it is you really want to test. It's not just that a function is "blocking", it's that it blocks until some condition is satisfied. So you might have a test that causes the condition to be satisfied but only after some other stuff happens (e.g. a timer but see other people's cautions against waiting in test suites). Otherwise you're just testing that a function never returns, which you can approximate with a timeout, but it seems a little silly.
The one that led me to make the comment is "tree-shaking", which is JS lingo for dead code elimination. Why they do not call it dead code elimination I do not know. The tooling for JS is usually an impressive amount of steps considering it's not compiled, with analogies of linkers and assemblers merging and transpiling files. But they're not called that. As a systems developer, whenever I try to write something quick in JS the terminology changes make things take a lot longer than needed, and usually end in me writing things by hand that I would use tooling for in other languages.
Yeah until you need a date picker (‚ïØ¬∞‚ñ°¬∞Ôºâ‚ïØÔ∏µ ‚îª‚îÅ‚îª
There are also rand.Readers, so the source doesn't even have to be something stored as data somehow.
I hear you. But this is exactly why I fall for Elm. I mean I've built decently sized frontend app with React, and I've been a backend developer, but having worked at smaller companies or building my own SaaS, you kind of have no choice but to dip into the frontend space at sometime. And so far, nothing gave me that "backend" sense of flow than Elm.
I've been doing .NET from 2001 to 2014 and I'm still doing it today via consulting work. I cannot stand the .NET framework anymore nor Visual Studio ;) but that's another story. I hear you regarding Elm is not for everyone. And so far I've not felt that verbosity, because let's be frank, Go is also extremely verbose, which I've learned to like.
I know, I am just terrible about following up. I will look at it in every six months or so and wonder why I bookmarked something.
TypeScript is fine, but at the end it's still JavaScript. The interop with JS from Elm is OK you define input and output and react to them either from Elm side or JS side. It's similar to message passing in Erlang "vaguely". Maybe that's why I find Elm so refreshing, I've done way too much .NET and JavaScript/TypeScript in the last 18 years, I'm personally fully ready for functional programming, it's not for everyone for sure YMMV.
I see the JSON decoder/encoder a bit like doing sorting in Go or any kind of slice manipulation. Always needing to use a for loop. Some aspect of Elm and Go are in fact not optimal compare to other. But once you pass those you stay for the languages strengths :)
Can you give a link on that ‚Äúlanguage not to learn‚Äù part? Sounds like a good read
haha possibly very true. I've done limited date manipulation so far via Time.Posix but Go's also felt short in that department when I started, especially compare to C# DateTime ;)
I see your view completely and usually I would agree but this started as something I just made for myself kind of and so I had my own Repo already and turned it into this community thing because I enjoy the idea of it. It's just personal preference homie use it if you want or don't :)
[removed]
I think the parent's point is about documentation. In java docs you can see what classes implement interfaceA, but, in godoc.org this information is not available. Not sure whether go doc command line tool will be able to give reverse mappings.
Elm is amazing, especially if you go all the way and use elm-ui
Thanks, I have replaced the link in the post with a working one. You can only enter integers into the maximum project stars and minimum days old issue places. I might really change what is possible to enter into this form.
Elm is not hard to learn at all, it is so simple. This comes from a developer with no functional background. Sure it can be a bit difficult to grasp at first but learning new languages, not to mention new paradigms, is usually not that easy anyways.
Please don't see my comment as an attack on Elm. It is just the experience my company gathered with this technology. I must clarify that most of the developers who are refusing it are functional backend developers.
I admit that this is more convenient than the pure terminal. However marking merged or local-only branches might be a handy functionality and I would love to see these features in gitclean :)
I'm married to Angular to be honest.
thank you! appriciate it :)
No havent read it yet? do you know where I can read it?
I think they are just trying to make us more familiar with golang i guess \^\^
true but i appriciate that you guys are answearing, thank you \^\^
Yeah that is true also. I just struggle to see the motivation for not making it explicit!
Mh. I'm more intrigued with Dart (Flutter, AngularDart)
Im curious there all these poor developers come from to whom 60-100 $ a year is such a huge expenditure that they are more willing to waste their time instead. $5 a month is pocket change. It's like 2 cans of beer. And people are willing to spend time with lackluster goto definitions, no proper sql client, prototype in absence of local history cache, fight with git conflicts with some abysmal 3rd party clients and no code shelving, crappy lexical scope autocomplete white noise, no find usages etc. Is your time really that cheap?
The problem with elm is, that you can't integrate it in anything apart from REST apis right. We had a project where a developer wrote a markdown parser/renderer in elm and it just blew up when we tried to integrate the elm stuff into the existing web application. We ended up writing a glue server in nodejs just to get it stick together somehow. &amp;#x200B; For me, it feels like typescript is the much better approach here.
I think he was referring to the recent stack overflow developer survey where Elm was a language dreaded by developers.
With that username, you have to be a backend dev.
That's certainly what it stands for. But, "front end" really is actually very vague.
I think this is what they were referring to: https://golang.org/doc/effective_go.html#generality This section talks about interfaces that are designed for chaining.
&gt; I love Elm, especially the Elm Architecture (have a look at it!). I would say ReasonML or F# in combination with Fable would be interested alternatives. I'm in the same boat, and even though I enjoy writing Elm, in the end I'd rather write reasonml code for a single reason, interop. Elm is nice and type safe, but when you need a rich text editor, for example, you need to work with ports, which means that you need to write a ton of back and forth javascript to work with it in Elm and doing so lose a lot of the perks and safety that Elm provides. With ReasonML you just write a few bindings and go for it, if you REALLY need something fast and can't or don't know how to do your bindings correctly, you can simply use a @bs.raw and write javascript in the source file (losing safety, obviously) and that's it, it works. As for F#, I will learn it someday, it seems a nice language, but as dar as I remember, bucklescript (the reasonml compiler) still generates smaller code than fable, so it looks like they have some catch up to do. Another recomendation for functional programming for frontend would be clojurescript if you enjoy lisps. Also, I'm using ReasonReact, but there's an Elm architecture implementation in Reason, [bs-tea](https://github.com/OvermindDL1/bucklescript-tea).
1. Financial value is relative to your earnings, don't assume people have as much money as you to spend 2. goland prices make sense when we have a solid positive return on investment, not the case of everybody 3. if parents or family payed it to you, you are wasted because you don't know that people don't give the same value to 600$. If you could afford it, good for you. Don't be disdainful toward people who can't
This is the big thing that keeps me leaning towards react/typescript over Elm. Not date pickers in particular so much as little edge cases that should be straightforward which just took out to be here undertakings. Meanwhile, in react land, someone has already solved that problem and published a component.
Tree shaking is a term used by some Lisp systems way back in the 90s. It has a specific meaning and it's applied correctly in JS-land; just because you don't know what it means doesn't mean it's incorrect. Your complaints about the build processes are just as weird: it's not compilation, you just don't know what's going on and you assume that the problem is with the process, not you
I don't know what requirements AWS lambda has, but a couple things jump out for me about your imports. First, the paths aren't go gettable since they don't have the repo as part of the module names. This would require cloning into the base of the go path. Making it go gettable and having it in longer path would be one recommendation, but now that `go mod` is supported, I would strongly encourage looking into it since it lets you clone this anywhere you want. I avoid uppercase in package names so that I don't make a typo later that makes me wonder for 20 minutes why I can't import something when it looks right. Are functionality comments helpful too? I imagine you might already have a million ideas, and maybe this is against your request for no frontend comments (apologies if so) but... What if I want max stars? Sometimes more stars means it's harder stuff it more mature projects, and I might not want to feel good solving a number of easy problems in small projects. If you do add an option to reverse that, the option to ignore forks might be nice (currently that option probably doesn't make sense because more stars for a fork probably means the original is dead). Randomizing the order of items returned might be a nice option. If you show all the tags of the returned results in a tag cloud where they are all selected, people could then deselect tags to remove those types of repos (unless other tags still met the criteria). Since tags overlap sometimes, you might find that doesn't make sense. Instead you could have none selected and if someone clicked just one tag in the tag cloud, it would filter to only repos with that one tag... I think I like that second idea better.
If you have the option to use W10, fire up debian in a Windows Linux Subsystem (WLS). The most rewarding windows experience ever ever.
Use a wait group to synchronize and add a test timeout
I think it's a tradeoff. Goland is definitely heavier/clunkier but much more powerful. I'm now used to VSCode and like how light it feels, but occasionally on larger projects I miss the typical Jetbrains refactoring features that Goland offers.
Post more The Chonk updates!!!
[https://github.com/MCBrandenburg/gitclean/issues/9](https://github.com/MCBrandenburg/gitclean/issues/9) I may just add this functionality with the flag, I like cycling through all branch functionality.
Right now!!
I can see why, it‚Äôs functional AND javascript AND front end, like a full house of tech buzzword bingo all on its own. Also I‚Äôve still not seen a real world in production solution made with it. Definitely next one for me to try out on a weekend project though just to see what I‚Äôm missing (or not)
Upvoting! I'm familiar with nodejs streams and Go io.Reader an io.Writer. They are very the same, and are used exactly for the same use cases. If you create a class that implements node's Readable Stream, in order to port it to Go, you should create a struct that implements Go's io.Reader. This is because they both come from the same underlying framework - the UNIX file system abstraction. In unix, a network socket, a file and a human input stream are all abstracted as "file descriptors" - a simple integer. You pass that integer to any C function that can handle a file: mainly `fgets` for Reading and `fputs` for Writing: https://www.tutorialspoint.com/cprogramming/c_file_io.htm Under the hood, driver manufacturers of network sockects, file systems and interactive terminals (like bash) were required to implement two C functions in their driver. `read` and `write` that are internally called when calling `fgets` and `fputs` respectively. Regarding your request to give concrete examples - No. Read the standard library like the rest of us.
I am completely a dinosaur when it comes to the frontend and know next to nothing. I noticed you also authored a book about using React. Is Elm a suitable replacement for React, supplemental, and do you also get all the portability and widespread community and support (or near)? I have decided to kickoff a prototype project as a hobby and actually decided to forego go because I could get something going faster using python+graphql+react but my real decision was react and graphql and probably rewriting the backend services if the project ever took off in go.
\&gt; My gripe with TS is that it's a big language that gets bigger every day. Most of these things are typing sugar that they're adding to support common frontend patterns in React, Angular, Redux, GraphQL, etc. 95% of the time you don't need to interact with these kinds of things unless you're doing platform/framework type work. If you're looking at a web project, checkout Next.js, Nuxt.js, or Sapper.
I‚Äôm full stack, stack to mouth if you will
Nice, really appreciate this :)
\`Bad Requestmessage -&gt; parameter \`min\_stars\` has to be an integer\`
https://svelte.dev
this is a waste of effort. any company that is seriously interested in adopting Golang realizes the issue is with hiring and language knowledge in the market.
bro Lil B aka the Based God himself is following Go on twitter lmao
I authored a book, but it was on building SaaS in Go. I've used React exclusively from 2014 to 2018 with Go as backend. I must admit that to me they cannot really be compared. I personally does not see Elm in the JavaScript frameworks category, it's a totally different language, flow and concept. Regarding community, so far I found the Elm community inclusive and very friendly, I can speak a lot about the #beginner on their Slack community, it was very helpful to me I must say. I don't think Elm is for everyone and that's why I talk in the article about how one could start by simply creating the most complicated page of their app only and see for themselves how it goes.
Yea, definitely the counter-gripe is that you only need to use want you want out of TS. Interesting suggestions btw, I never heard of Sapper before (or Svelte), it looks really interesting!
Well, Goland wouldn't give you these features you mentioned out of the box also. Dep is an external tool that has nothing to do with IDE. Docker requires separate plugin in both. Both goland and vscode use delve for debugging. All that's different is that, as far as I understand, Goland implements language features by itself without using separate tooling. Go plugin in Vscode uses various Go tools for all its features. For me it's not a problem and is testament to Go design with that kind of tooling in mind. Actually it's a feature in some cases. Like when some tool was broken. I got my PR merged, updated the tool through vscode and it was fixed. Arguably, I'm on iMac and don't struggle with RAM and CPU, so the experience might be different for you. And in general, plugins in vscode is what makes it such a beast. I did use JetBrains IDE with Go before that but once I tried vscode I never switched back. Faster, lighter, much nicer and better ecosystem, tons of features with every release etc etc etc. Don't see any reason to go back and spend money on goland.
The 3rd party support is the caveat I tell everyone in my org when the decision to consider go for a new team is proposed. My team loves it, but we do systems work where other languages are already slim on support anyway, so building APIs or clients in house isnt a huge deal. But for our production facing services I warn them to make sure Go has a heavily supported replacement for any third party libraries your service will need. Most of the time we have found those missing.
My new cto is an ex-microsoft guy and hates all things microsoft so we are switching everything from .net core to go, also ditching our win 10 workstations and getting mac books. There are zero technical reasons for the switch. It's purely from ms hate.
Interesting decision. &amp;#x200B; I can't say that ditching win10 workstations for macs is better. &amp;#x200B; Neither that .Net to Go is a reasonable switch. I would've expected Java since it's a 1:1 OOP language swap. &amp;#x200B; As you say, "zero technical reasons" puts any questions to bed :D
As other people have pointed out, there's not looking for Senior Golang Developers, but more likely for Senior SWE to happen to be able to write Golang. &amp;#x200B; It's mostly people that are in the spectrum of: &amp;#x200B; * infrastructure/platform tooling * networking services * APIs * etc
feedback is warmly welcomed! :)
&gt; enterprise toolchain support This is the big one. I can spend months hacking my go.vim to work like I want, and I can spend months figuring out the right combination of go test to xUnit parsers or whatever. But that's because I work at a startup. Getting 200+ engineers of various quality and drive to be productive in go would be difficult.
This is a new library I've been working on lately. It is a Cairo alternative that uses vector drawing instructions to construct images that can be exported as SVG, PDF, EPS or as a rasterized images such as PNG, JPG, ... There is a fairly complete set of functionality for path manipulation and text drawing. It is quite similar to [github.com/llgcode/draw2d](https://github.com/llgcode/draw2d), but internally has a little more math-heavy implementation such as for stroking and flattening. It also works differently with fonts and text and it has a built-in LaTeX pipeline. Anyways, it's a fun project that might be of use to fellow gophers ;-). Let me know what you think!
You should provide some specific code snippet. To me it sounds like you are mixing some things up here. If you are talking about http.ListenAndServe then err := http.ListenAndServe(...) just means that if ListenAndServe fails for whatever reason it will return an error and assign it to err.
Yeah - finding people with Go on their resume is the pretty much the only thing that scares the client I‚Äôm currently working at. They see the technical appeal, they‚Äôre scared what the long term maintenance cost would be like. NodeJS devs are easier to find and cheaper.
One example is an app that I want to close open and close the server cleanly. ` s: http.Server{ Addr: parsedEndpoint, Handler: handlerFunc, } if err := s.ListenAndServe(); err != nil &amp;&amp; err != http.ErrServerClosed { log.Fatal(err) } ` When you call s.Shutdown, it throws http.ErrServerClosed, so this will let me close cleanly without getting that error. I have a couple things that are hosting multiple endpoints that have different life cycles or endpoints.
As long as you fleece investors, right?
What do you mean `:=` is just an assignation and the right part can be either some literal, variable or function. Can you post some code? A like like err := h.ListenAndServe() will execute the http server function then return in two cases: * Some error happened and the http server cannot be initialized. * Returned normally by a call to `h.Shutdown()` so `err` will by `nil`.
That looks reversed. I think the request was for gzip(base64(hex("text"))). This is hex(base64(gzip("text"))).
Yeah I just added the example I totally thought I pasted that in there lol I'm sorry. I guess I was just confused because of the declaration of err. I feel like I usually see err, x and x would be the return value of whatever function was assigned there but I guess in this case I only need err because if there is no err then the function doesn't need to return anything that I have to save to a variable and so I only need to declare err right? Im sorry if this is confusing I might honestly understand it and just be over thinking it.
Nope, it actually returns: http.ErrServerClosed . So es bad.
Sorry I thought I pasted the code in there originally. Yeah so I guess I was just confused because there would usually be err, x := .... and so whatever the function would do it would return an error or some value and you would store the value in x or the err in err. In the case of this function it only returns an err so there is no second variable needed to store anything and then err is just set to nil and the program continues. right?
My team is just now going to start prototyping our build tools around this new VSCode feature: [https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.remote-containers](https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.remote-containers) VSCode in general has been pretty good for getting new devs off the ground. Way better than the setup for our Ruby, Java, and C# friends at least. Adding in development inside a container means it might be even easier to make sure our engineers are developing against the same version of GO and on the same operating system as production deployed application. The junit conversion is also done in a controlled docker container and combined with a make script which has made it easier to get any dev up to speed with their devenv. It's not perfect and we are still evolving, but our experience has been better for new devs than our other language counterparts.
???
I can tell you in my org with 100K+ employees...it's whoever has the best pitch on the golf course.
cpu pixel shaders benefit from simd a lot, which is hard but not impossible to do in go, you have to use go assembler. but you can get 4x to 8x speedup
The tooling around Go is not up to par with the tooling around Java or C#. It's simply not true. Even something as simple as autocompletion is a hot mess right now in Go. Once the new language server stabilizes, this problem will be solved. But it is absolutely not solved right now.
 ListenAndServe always returns a non-nil error. After Shutdown or Close, the returned error is ErrServerClosed. &gt;[Sauce](https://golang.org/pkg/net/http/#Server.ListenAndServe)
Correct.
Wait actually?
[yea ahahah](https://i.imgur.com/fqvhVLP.png)
I was more speaking towards the setup of the environment itself. Go has embedded tools and VSCode, as an example, installs everything for you automatically. The C# and Java tools have more hoops to jump through. We've been able to train new Go devs extremely quick in comparison. My experience with the language server has been pretty good, but I haven't been a primary Java developer in over 6 years so can't compare modern toolchains there. I'm curious if you have more specific examples.
This is probably the article you are thinking about which mentions Elm as the number one language not to learn in 2019. [https://fossbytes.com/worst-programming-languages-to-learn-in-2019/](https://fossbytes.com/worst-programming-languages-to-learn-in-2019/)
Thanks that's a good starting point i'll let you know if I have further questions. great work.
Have you thought about writing tests?
Yes, you are right, checked the code and it never tries to return `nil`.
Dependency vulnerability analysis is another. Static analysis is another. Finding memory leaks is very difficult in go. Adding opinionated linter rules is difficult. You usually have to code them yourself. I could go on.
Not a big company but a small startup. Go is benchmarked against Java and it often loses on engineering talent and support for common javaesque things like error handling and generics. We still used it but now we face pushback from management because Java is better.
Awesome I think I just needed to try and explain my own confusion and I ended up answering my own question
r/cre_ker sorry i did not downvote your comment if that question is for me.I too agree with your comment above related to list of features, they are external to GoLand as well. With respect to memory usage the initial memory usage was too much for Goland and once is settles down the amount of RAM and CPU matches with VSCode as clarified by r/dlsniper. I find the shortcuts a bit un familiar when compared to VSCode , Related to VSCode plugins and shortcuts agree the same again. Came from Vim to VSCode and find it ease and clean to use.Have everything i require for my work at the moment. If in case i require additional features will try GOland in future.
I understand the functionality of this tool, but even after reading the documented workflow I am confused about the application of this tool to a concrete workflow. Do people usually work in a way where a particular pull request is expected to become a release, as opposed to a collection of issues? Is this related to some other workflow I am not thinking of, maybe involving a release branch that is collecting other merges and uniquely expects to become the next minor when merged? Can someone explain how to use this tool in a way that people really manage their projects? I'm usually tagging issues to bucket them in expected release versions or tagging them just before a release. I've not had a situation where each issue should become a new patch or minor.
FYI, here's the talk Abstract Go was designed with Google's needs in mind, and when you're running software at the scale that Google does robustness is of prime importance. In this talk we will cover what design decisions of Go help building robust programs, but also those parts of the language can cause problems that one needs to be aware and what techniques to apply to avoid risks. We will also compare Go robustness to Erlang, probably the most robust runtime out there, and see how its "let it crash" principle can be brought into Go.
Good thing I‚Äôve been golfing since I was a child!
I plan to add something to create a release from a collection of pull requests.
Excuse me I am learning English why use at at the end ' course at' maybe be on isn't?
No love for the other follower that you know in that screenshot?
Thanks for the reply! I can certainly understand that from a scoping perspective. I'll have to give this a go on some protobuf services I've setup and give some actual feedback.
[removed]
Professional software developers are reasonably well off, even in developing economies as the compete in global market. I could name very few countries which commonly competes in global market (or their employers) whom could not afford JetBrain at reasonable price. Which leads us to your second point. This leads me to make a reasonable guess that people who are complaining in such way are not professional software developers to begin with. Perhaps they are people who are learning to code and are yet hoping to become one, perhaps these are hobbysts who do some coding to make their own drone work perhaps these are students who's university haven't bothered to request a free license from jetbrain. That points to one thing, these people are generally not qualified to make an conclusive judgement which tool is better overall. Perhaps it's good enough within the boundaries of their needs and therefor it's "optimal" in a way. However, that doesn't address the fact that VSCode severly lacks a lot of features and quality of existing features which are present in JetBrain provided tools which make the tool itself more capable regardless if use user leverages those capabilities or doesn't. And thanks for being interested in my particular financial situation. I've been paying for JetBrain tools relevant to my specialization ever since I've finished a bootcamp. And in past few years, it's been on prepetual license since my employer buys it for me, because it recognizes the obvious benefits the tooling has for companies overall productivity. Bottom line "it's too expensive" tells more about the qualification and professional position of the person making the claim rather than about the tool pricing policy given the circumstances. While I can understand arguments out of principle like, use open source over propriatry, even though following arguments about supposed "it's just as good" are demonstrable falsehoods, I can sympathise with the sentiment. This position you're proposing is just a lie.
But have you been pitching too?
Nah. My experience on the course with people I work with has been more about people health and overarching issues. How to keep people happy, general things going on in lives, etc.
Not at 1k yet, but PCI compliance and auditing rules my world. [proxy.golang.com](https://proxy.golang.com) \+ modules will fix most of my problems with security review. Adding functionality similar to npm audit would be even better.
I‚Äôd be ok with that. Not that it is necessarily the best idea, I just prefer working on a MacBook with Go. Not sure I could ever go back to using a windows machine
I would find that more useful in my known workflows. Thanks for the update.
Hello! Demo project link is broken: https://github.com/go-gilbert/demo-go-plugins
Which library did you use for the UI bits?
You said that, not me ‚Äî and I didn‚Äôt suggest it, either.
Please do!
I feel like the defaults for go.vim are good, I don't think I have changed a ton of them, but I also think part of the reason I like Go is because it doesn't make me feel as tool-dependent. VS Code is also an option that's a little quicker to configure, and it has vim extensions (though I don't know how good they are).
I need to know the reason for this
This is very cool! Are you holding this project on github somewhere or similar Id love to see it. I personally have been involved with [https://github.com/faiface/pixel](https://github.com/faiface/pixel) which is opengl/gpu based (I implemented the GPU shader system) if you havnt seen this yet. But great job!
I
Compare to https://magefile.org/ and https://taskfile.dev/ to explain why yours is different/better.
Companies with 1000+ employees will typically have knowledge sharing developer communities. That‚Äôs where the technology stack decisions typically come from.
I made my workplace buy me a Linux laptop after I got fed up with macOS after 4-5 months. Things have been massively better for me personally since then. I have no issues with Go or Goland on my Windows 10 PC at home, but it'd probably be marginally more annoying running all of the dependencies we have at work on Windows than a *nix (though WSL would probably make that a lot easier).
We use it at the startup I work at. It's great when you are working on something small or pretty normal (rest API targeting json or something) but really lacks the quality libraries compared to the jvm ecosystem when it comes to doing anything either a) old or b) targeting some data format not natively supported by go stl. Go needs an Apache or Spring. I have a collection of things that gets me through my day (I consider myself a bit of a build engineer), but it's hardly something ideal and relies heavily on docker to make up for a lot of the shortcomings in either standard lib or cloud-native tooling. Luckily, go dockerizes very well so it beats java in that respect, at least. And in a lot of ways, that's better-- use the real command line version of a tool vs some port or strange jvm variant. You can do some crazy polyglot stuff with go, and that's a great thing. But adding a feature in spring can be as easy as importing a dependency to your classpath and having everything autoload purely on the existence of that library. Go doesn't have strong di ecosystem to support anything close to that. You have to hook up things a bit more, and that's fine but adds code to your repos, which has to be explained and maintained. I'd rather program in go most of the time, but java is a more productive language and is (frankly) a bit easier. I think go has a lot of potential and I'm looking forward to seeing what comes out of the community over the next decade or so. I think the standard library is actually quite good, but there are still gaps or weird implementations of certain things (for a c like language,) but not any worse than java. Source: golang for almost exactly one year as my daily driver, java for previous decade, mostly dynamic languages like php and perl prior.
Gross.
I run tech and research for a large security company and we have multiple ways that languages are chosen. From ecosystem compatibility/convenience (Go is so easy in Kubernetes to build really cool apps), to certifications (I.e. - OpenSSL is in C and comes with many years of rigorous breaking and fixing, and is a common approach to standard crypto). Happy to have a chat about it sometime, but in general it depends on the business case often as well.
Yes I have seen this a lot in industry
Not saying you're wrong, but anyone can learn Go in a day and be proficient in a month. If they can't, then you don't want to hire them for any dev work period.
I appreciate you not outright calling me wrong, and I am sorry to do this to you, but saying anyone can learn go in a day and you wouldn‚Äôt want to hire them for anything if they don‚Äôt prove it in a month is pretty misguided and very arrogant.
Java is disgusting, go isnt great but in some ways its better, but Kotlin is tops for getting it done and Clojure is just plain fun.
What happened to this community? I thought name calling other languages reflects poorly on us as a community. &amp;#x200B; Every language has its warts and shares of issues but disgusting? Java is far from it.
If you only have a background in object oriented programming language like Java it can be very difficult. This is a large chunk of developers out there who probably learned Java in college and have never used anything else.
&gt;Even experienced devs can struggle with simple things. I can believe that, but not the talented part. There are tons of candidates whenever we do interviews with years of experience who cannot do fizzbuzz ([this](https://blog.codinghorror.com/why-cant-programmers-program/) is still very relevant). These are the people who can't get through A Tour Of Go in a day and yeah, I wouldn't hire them.
https://golang.org/doc/faq#convert_slice_of_interface
Welcome aboard! I recommend these fine introductory documents: https://tour.golang.org/ https://golang.org/doc/code.html https://golang.org/doc/effective_go.html https://golang.org/doc/faq
What does `ShowMessage(data)` do in your other languages? Are you referring to logging with the ability to enable all of your debug/trace output with a single flag/config/env?
Would you please tell us what are you seeing as "serious performance issues when using interface methods in the profilings"? How are you sure the problem is about interface, not methods underneath itself?
Elm is a superb language. It is a bit too verbose at times, but then it's much easier to learn than say Purescript which is literally Haskell for the web. That said I do miss some Haskell concepts like Type class and Higher Kinded Types, especially once you are beyond the prototyping stage.
There‚Äôs absolutely a way to test the type. Definitely do not emulate try-catch. See `switch thing.(type) {` or `reflect.TypeOf()`
Ahhhhh... so one does not need to worry about conversion failing at run time because the compiler will already reject illegal conversion during compile time. Got it, thanks a lot.
Thanks! One thing is that here the type is initially an interface, which needs casting. Is there a way to test the possible types that I can cast the interface?
Yep. This is exactly what reflection is for. You‚Äôll want to _assert_ the actual type the interface holds, then you can _cast_ or convert to the type you want.
Could you have a new row in the database for every line? If so you could use something like Logrus with the MySQL adapter. You can still have a unique ID for the job it self if required.
i just use windows api (win32) to open a window and simply i blit my image into it
I'm not going to get into specifics of hiring strategies with you. I find the most success interviewing, including any code challenges, in the manner you'd expect them to work a day to day job. Everyone hates an interview gauntlet, whiteboarding under pressure sucks, and too many hiring managers use recruiting as an excuse to show off their own talent one way or another. For what it's worth, you have gone from "learn go in a day" to "be proficient in a month" to "get through a Tour of Go in a day". I have no idea what benchmark you mean, and frankly I don't think you do either.
This is exactly what the switch will allow you to do. You can have a case for each of your possible types. There's also this syntax: concrete, ok := iface.(ConcreteType) ok will be true without panicking if the interface is actually of the type. It's useful for one-offs
Thought about, but the logs are just too big. For example, the job I ran for testing contained 48K lines. So the question also becomes should this be stored in the DB at all. Ideally not, but most jobs would not generate this much data. So I am thinking now to grab the first little bit of the text and tell the user that it is too big to display and be done with it. Not a MySQL expert so I have to find out how to do this. Ideas are more than welcome!
How is the job run?
That logic is a little off though, no? Any developer with some experience should be and to be productive in go within a couple weeks. And beyond, by using go, you'll be able to attract more qualified hires for the team
Shelled out to. It's an rsync job, with an itemized log output. For MySQL, this can work: `select SUBSTRING_INDEX(log,'\n',3) from data;` Displays first 3 lines.
You could pipe output to logstash, which can parse and send to Elasticsearch and you can then visualise it in Kibana or query it directly from Elasticsearch.
May I ask what IDE you are using ?
We use Splunk, but the idea is the same. Unfortunately, the user expects to see what files were published over rsync. I guess I need to implement a loader/spinner and pagination for the column so I don't see all the data to the webpage in one go. This would cover 99% of the cases, so there's where I am right now.
I get the point
Yeah I should write some, but I had difficulties mocking the API locally on my laptop. Will get to it probably at some point x\_x Thanks!
You are absolutely right about the whole packages thing, will get to it when I can. And thanks for suggesting the additional features! I am more than happy to get new ideas, what I ment is that the code itself in react is kinda shitty, and will probably stay that way for a long time, so there is no reason to comment about it. &amp;#x200B; I will most definitely execute some of your suggestions. Thanks for the review!
In Go, errors are just structs that implement the Error interface. The err variable is just called err for consistency. In practice, you could call it anything you want. (But please don't) When a function doesn't return anything except an error, you still need to assign the value of the error, because else you would throw that value away.
reflect.TypeOf() will tell you the type. You only specify two (3 incl. interface) types. This is just a two clause type switch. I'm not sure why this kind of pattern is normal in languages with exceptions but it seems retarded to me. Error values are the main way to deal with error conditions in Go. Go has interfaces and type switches. Type switches are not casts. Go interface values are implemented as a struct with a type ID and pointer to the value. Switching on them is not as expensive as inspecting the binary file's symbol table, as used in Reflect.
As far as mascots are concerned, I can't think of another language's mascot with as much personality as the go gopher. Maybe that's it?
 switch varname.(type) { case value := []byte: ...(value now can be used) case value := string ...(value in here is the string from the interface default: ...THIS is where you might return an error value, unhandled, or whatever } Go has a reputation for being verbose... But I'll take that verbose any day over cryptic and excessively redundannt.
There is the comma, OK pattern: value, ok := interfacevariable.(typename) if ok { ...use value }
Is it possible to implement by Rust?
Go doesn't use assertions in this way. The testing framework has a heap of functions you can access from that parameter `t` there. t.Log() t.FailNow() and a heap of other similar things. The assert stuff will be replaced with just something like `t.Fatal("blocker was unblocked")` or something similar.
yes i have it on github [https://github.com/MoustaphaSaad/goui](https://github.com/MoustaphaSaad/goui) pixel looks great, by the way cool shaders in your goshaders repo yes i'm working on a C++ Medical Imagining software which targets Windows, i did take a look and did some edits and submitted a pull request check it out [https://github.com/thegtproject/grog/pull/2](https://github.com/thegtproject/grog/pull/2)
i think it can be done in rust, but rust is too complicated for my taste
Another tool in the same field is Shuttle by Lunar Way: https://github.com/lunarway/shuttle
yup, will try to find some simd library in go, you did one in rust right?
He said Goland (the IDE by jetbrains)
Pretty sure channels create one goroutine each, and waitgroups also create a goroutine. So I can easily account for 53 right there.
"Link to your GitHub profile (optional):" I don't have a Github accout. Hey Google, have you heard about the alternatives? (I'm on GitLab, for example.)
Simplified your example a bit: https://play.golang.org/p/glMRt1qq6IO My guess would be that something (e.g. channel) cerates new go routines.
&gt;Even something as simple as autocompletion is a hot mess right now in Go. Golang is very good. Autocompletion and refactoring works very well and many improvements are made, if not every month, at least every quarter.
Gilbert is more similar to Shuttle but provides a bit more features. You can run not just command-line scripts but also a program your custom actions (like in Magefile) or install a third-party plugin. &amp;#x200B; Also it supports graceful shutdown (for ex: you can implement rollback logic), async tasks and you can define task deadline. &amp;#x200B; I recommend to check out [documentation page](https://go-gilbert.github.io/gilbert/docs/) for more info.
&gt; Pretty sure channels create one goroutine each No.
A single Hello World program runs in a single goroutine. However, additionally to that the runtime can and does create more goroutines for its needs. The concurrent GC is a prime example.
That‚Äôs awesome tool! I‚Äôve just been searching something like that! Thanx
Tell that to HR or management that has to keep budget and available talent pool in mind. They only see ‚Äúexperience with ...‚Äù - and people with Go experience are more expensive. And having people learn stuff on the job means they will make mistakes there, which would also cost them. It‚Äôs not because the language is relatively easy to learn that they immediately understand and apply best practices, standardised ways of working and project organisation.
Thanks!
This Kubernetes example doesn't really do the same as BEAM. To take one aspect, with BEAM languages when you "let is crash" that is done at a much more finely grained level than a whole container and however many say web requests that is handling. On that alone I would not want to "let it crash" in the same way in Go as I would in Elixir/Erlang. And yes it is nothing new, but not even to just BEAM, sure the total combination and how well it does those things is unique to BEAM, but a lot of those things exist elsewhere to, even in unfashionable languages like PHP...
You have to remember to add the correct tag for every commit, it's seems hard not to mess up. Generally, you think of a fix or a feature per pull request, not per commit, you need a bunch of commit to implement something.
You are a saint (msvc is so complex, I am only a hobbyist programmer so far) thank you very much! And I will definitely check out your goui when I wake up a bit more this morning :)
If you want to mock out github when running tests you can use something like [apitest](https://github.com/steinfletcher/apitest). See this example [https://github.com/steinfletcher/apitest/blob/master/examples/mocks/api\_test.go](https://github.com/steinfletcher/apitest/blob/master/examples/mocks/api_test.go)
Opinionated linter rules? Lmao do you actually use go or just shilling for google competitors in the enterprise space, because we all read the news. Memory leaks: pprof etc. Imo the tooling around go is excellent. Go autocomplete etc has been working perfectly for years. Regarding dependency management they are introducing stuff ( modules) now, but i found myself fucking around with dependency shit in any language over the years ( dependency hell with java projects anyone?) Valid concern is finding/training devs. It's a simple language true but becoming really proficient takes time, i think it is easier for c developers to get into than purely object oriented people. And most devs are coming from OO background. The first thing they do is whine about generics probably üò¥
yes, don‚Äôt know if go can have a simd library though. probably have to do go assembler by hand
hahahahha what's up bro
We should party some time.
[removed]
What ShowMessage(data) does is simply pop up a message box that contains the contents od the field call data, in this example.
The department I work in at my company uses nothing but Go. I really like it to be honest. It's pretty rare that I can't find a good third party library for whatever I want to do. Plus with being able to view the source it makes it relatively easy to modify things however we need. I despised it in the beginning, but now I honestly don't think I'll switch back to .net core for much.
What is being used here: https://i.stack.imgur.com/uXBqY.png Is this a compiler shell that you can run go code in?
\&gt; Is there any reason for this? The standard library uses goroutines, just like any code. All three of them terminated before your program deadlocked, I guess. E.g. if I remove the "fmt" import, there is one goroutine less being created. That seems to be because of the "os" package. I didn't trace it further.
Thank you very much. With the D programming language, the compiler based on LLVM produced a significantly faster code. Is this the case with Go too ? Or could it be the case ? LLVM is apparently good for optimizing code. Is there any hope in that direction ?
Thanks. I'll look into it
Judging from the article, it doesn't look like Elm has much to offer to modern Frontend. What frontend needs is the ability to create components which can be combined and reused across different projects. A component must encapsulate its functionality, expose an API and provide a default look and feel which ideally should be customizable. Also when adding that component to a project, its CSS should not affect any other component of the project. That's why I believe the only sane solution for long term frontend is [web components](https://www.polymer-project.org/blog/2019-02-05-lit-element-and-lit-html-release).
You can use a github org (or similar) for your projects, or use a [vanity domain](https://golang.org/doc/go1.4#canonicalimports) to point to the repo, but these are both decisions you need to make at project creation time. Alternatively, you can just add the new maintainer as a collaborator on the original repo.
Look at http://llvm.org/svn/llvm-project/llgo/trunk/README.TXT
What should I see ? I don't see anything about performance.
That's interesting. It can be used in some customized CI pipelines.
I'd suggest reviewing: * [go tour](https://tour.golang.org/) * [rob pike talk: concurrency is not parallelism](https://blog.golang.org/concurrency-is-not-parallelism) What school is teaching go to undergrads?
Do you have a time machine? It will take at least a week and about 1000 lines of prototype code to master it.
Thanks! This is what I went with. I appreciate everyone's help!
This is cool, I want to do something similar in the future that pings a text to speech mp3 to a chromecast, had it working in node but I prefer the idea of having it in Go so it's easy to port without dependencies.
The vulnerability analysis the OP has a point. Our org, which uses go, is having issues tracking down open vulnerabilities for Go. This is because so many tools are just tiny open source projects that you import from. That casts a ***huge*** net to be sure you don't have a security vulnerable package. Our Maven artifacts, in contrast, are all very easy to vet because the amount of work it takes to publish artifacts to maven central. Meaning there aren't as many repos to monitor ***or*** find out have no security vetting at all. Go modules is a good step. And once it's implemented by all repos we can start enforcing that all external dependencies ***must*** have a module version and not be tied to a git commit. But right now we are flying a little blind there.
It's actually also similar to [https://github.com/srwiley/rasterx](https://github.com/srwiley/rasterx) which is quite complete w.r.t. path manipulation, stroking etc. I think where I want to steer to is native support for elliptical arcs (mostly implemented) as well as quadratic and cubic Bezi√©rs. This means you don't have to flatten paths to stroke them, which for rasterization won't make a large difference (as is the case with rasterx), but can significantly increase precision and result in smaller path sizes for vector targets. In short, half an ellipse can be written as one path command (the ArcTo), and when stroked (with ButtCapper) will result in two ArcTo commands and two LineTo commands. Other libraries would likely result in a large number of LineTo commands.
&gt; I have a go lang lab exam tomorrow Yeah, you're fucked.
If I don't do either at creation time then the only option for me is to add the new maintainer as collaborator, right? And if I add the new maintainer as collaborator then I won't be able to delete my account or that repo, correct?
Github will do some redirection for transferred repos, but this is host-specific, and I'm not sure this should be relied upon. Otherwise, you're correct.
You can transfer repositories to new owners on github. GH will then forward requests for the old location to the new. BUT I don't know if Go will follow those redirect requests.
Thanks. Have already reviewed them.
I have been practicing for two weeks.
That was fascinating. I'm interested to hear about their findings in Rust too.
Was that a custom built laptop or something like Thinkpad with pre-installed Ubunutu?
If you don't know anything about goroutines, I suggest you google it and read and practice all night until your exam.
Without reading the article properly first I would say that yes, it's easy to make mistakes regardless of concurrency model but it's way easier to identify bugs using channels and the additional race detector and built in profiling in Go makes such debugging easier as well.
Have practiced but need to practice more.
How are your peers doing? Does anyone in your class have the same problem? I mean is it a shitty school or just you?
Just a Dell XPS 13 Developer Edition, spec'd comparably to the MacBook Pros.
Idk I've never used that key combo but I definitely have templates, it might be a newer feature to disable them by default. I've considered going back to JB products because they're really nice, but sometimes they're just a bit too "aggressive" for my taste. They also just tend to feel a lot heavier than something like VSCode. VSCode to me feels like it's a text editor with extra features rather than an IDE, which I really like since I tend to work on a lot of different projects
The string formatting functions are already clever with the %v and automagical interface{} arguments.. I don't see a big problem adding a %w for this use case as long as the errors package gets the proper low level support.
This is indeed a good way of learning! It happened to me more than once that after writing down a problem as a well-formulated question, the answer suddenly appeared.
I am always suspicious when I see a shortened URL. Luckily, there are more than enough online URL "unshorteners" around. Here is the original URL: https://www.gowitek.com/analytics/golang-for-data-analytics To the OP, you do not need to shorten URL's here. You have plenty of room available in your post. And a pro tip: avoid referring to the language as "Golang". People might think that if you even don't know the name of the language, then you don't know the language itself very well.
I like the idea and concept.
Thanks I will take a look at it, but what I ment was mocking the AWS Lambda API. Didn't gave it yet the time it deserves, but if you know of a way, will be great if you can point it out.
Thank you!
I would really love to see a llvm backend in the go compiler. It shouldn't be that hard to put it behind the sso part in the compiler and just reuse the rest of the go infrastructure. Similar to how we just got the wasm arch. I would imagine it to apply a lot more optimizations to the generated byte code than the normal compiler and amd64 backend does.
Sure , especially the go module index in the pipeline should help with that. I agree regarding vulnerabilities and tracking thereof the older and enterprise accepted languages have an advantage (not surprising really). Not to mention the fact that JVM( java)and CLR (.net) are extra security measures in and of itself.
Since the language studied was only Go, it makes sense to me there would be more errors per capita for message passing, because it is sort of the default paradigm. When shared memory is used, much more attention is paid to its use because of its spotty history (and many of the reasons the authors expect it to be worse initially). It would be interesting to see a comparison between languages in which the preferred mechanism is message passing vs shared memory as well.
1000 lol
HAHAHAHAHAHAHA
[removed]
Fair point, but it is still a different thing. All formatting magic currently is just that: formatting. It changes how the string is built. %w on the other hand will change the behavior of the resulting object. This is something no other %-rule will do.
happy to help, don't hesitate to ask if you need help
Appreciate it! On a separate note, if you're curious, your cpu based goui runs flawlessly on my computer. Very smooth!
Well yeah... a sociology student with a 6 week boot camp can write NodeJS on the resume, but not Go..
Go needs Apache or Spring? Go needs bloated beasts? Yeah no. Go is good at a lot of things. Bloated enterprisy domain heavy applications won‚Äôt be one of them.
Where do u go to school that they teach golang?
As an elm dev and a maintainer of several libraries, it should be important to not that if your app wants to go mobile, shared code dart with flutter is also a very viable option, and preferable to elm in many respects.
I forked it - you've got my interest. :)
This post is devoid of substance. The truth is that, as far as I have been able to ascertain, tools for data analysis and visualization in Go are severely lacking. The linked page does not offer IMHO any interesting examples. For instance, of a total of three actual projects mentioned, one (dashing-go) hasn't had a commit for three years, and its demo site is down. Another, (gonum/plot) displays on its [examples page](https://github.com/gonum/plot/wiki/Example-plots) just a few sample plots which frankly, are far from impressive by today's standards, nor does the code needed to achieve them strike me as especially easy or convenient. Please prove me wrong.
Can confirm, Flutter makes you just WANT to do SOMETHING with it.
[removed]
i think he means something like this: https://github.com/google/go-cloud
Did you come to a conclusion regarding this? I am looking for something similar I could host in Docker, which includes smart cropping functionality and hopefully face/text detection as well. I played around with Thumbor but it is way too complex for my needs (tailoring images for my personal media server).
[removed]
[removed]
[removed]
[https://github.com/CurrySoftware/elm-datepicker](https://github.com/CurrySoftware/elm-datepicker) What about this?
It's hard to stomach that people could see java as a better language.
Have you tried this: `q.Columns(DefaultConfig.Columns...)`
That solved it... \^\^\^ those 3 dots have never had so much meaning in my life.
Writing it as a logo-type ‚â°ùôÇùôä would make ‚â°ùôÇùôä stand out more in writing, and teach everyone about the wonders of UTF-8, and the limitations of their keyboard :-)
The error message is pretty clear, I'm not sure why you were expecting this to work in the first place.
 https://blog.golang.org/advanced-go-concurrency-patterns Advanced Go Concurrency Patterns - The Go Blog
Should've probably named it something other than beam Initially was confused as to how Go and Erlang are related.
I mean similar organizations that have processes and resources to push library development forward in opinionated ways separate from the core language group or just small smatterings of individuals. Go is already taking some steps re: go modules to facilitate code sharing in a better way. Diversity in stewardship is always a good thing.
My understanding is that When you put defer anywhere it automatically execute the deferred line at the end of that function just like it it was put at the very end of that function
While Go's compiler messages are clear once you know enough to interpret them properly, they are a barrier for some newbies. Not everyone knows the things they are assumed to know.
It's specifically when the scope of that function ends. Not if you make another nested function call in that function, or not when the runtime sees that the file object is no longer in use. Specifically, when the function scope of the defer ends. So you need to make sure you aren't sharing that file reference with another function that could use it after your defer has run and closed it.
Well for one, the example in the video of using channels is just dumb. Channels internally provide all the locking that's needed for that scenario. If you read even the most basic Go documentation, you wouldn't try something like that.
It is explained here, and had the same meaning as the related Print and Fprint: https://godoc.org/fmt#hdr-Scanning It's the different between how newlines are interpreted, and whether it is scanning based on a format.
This should help: https://tour.golang.org/flowcontrol/12
Because your relative path is wrong. Either put your code at `~/go/src/cube` or import `github.com/jakescript/rubix`
you can't have files belonging to different packages in the same folder. put cube in a subfolder or in a different project altogether.
Lol... my first thought when I saw the words "Beam" and "Go" together was Apache Beam. Naming collisions are an unfortunate consequence of valuing memorability over uniqueness.
Already tried putting it in a sub folder in my project too and it didn‚Äôt work
this seems like a rehash of his older talk and does injustice to BEAM BEAM does let it crash on much more granular level which i dont think any other platform can do
alright so I'm just going to start fresh from the src folder. So in src I make the projects directory "rubix" inside that directory I have my main.go file and a new folder called cube with a file called cube.go part of the package cube. So in my main file what would I put to link the package cube with my package main. I have no idea why this is such an annoying concept right now lol.
Example, I started looking at go about 3 weeks ago. :) and I am NOT a developer. I didn't even know the ... existed in the first place.
If your `cube` package is now in `~/go/src/rubix/cube`, then your import path becomes `rubix/cube` - import paths are fully qualified. You almost certainly want to use the full repo path though (ie - `~/go/src/github.com/jakescript/rubix/cube` which is imported as `import github.com/jakescript/rubix/cube`, otherwise you (and anyone else) won't be able to import/build the package via `go get`.
&gt; VSCode severly lacks a lot of features and quality of existing features May I ask what are those features? Specifically for Go. The list of features you mentioned is all there either through Go plugin or out of the box. If you want SQL client then there're plugins for that also. Or use proper tool like MySQL workbench or something. JetBrains or not, integrated IDE clients are all crap in comparison.
Thanks a lot dude I used the full import statement to keep up with tradition and it's working now I have been researching as I want for people to respond and it works now and I think I understand why so again thanks a lot
GOROOT is where you installed go, and it is only relevant if you installed it in a non standard location. The environment variable GOPATH is the one you have to set and it points to where the code you want to compile lives eg a directory with src/, pkg/, bin/ directories. the import path is the directory path relative to src, so if you have a folder 'myproject' in src with package myfolder you just 'import myfolder', the github path is a bunch of nested folders eg mypackage inside myusrname inside 'github.com'. Now in your case you either create a folder rubix in src with a go file with package main and a subfolder 'anothername' with a go file 'package anothername' and then you can 'import rubix/anothername' in the main package in the parent folder for example. Or you create a folder 'myproject' in src with a go file package main, create another folder in src with a package rubix, then you can 'import rubix' in the myproject package. In the first case you have a project with a subpackage, in the second you have 2 different projects that collaborate. For packages that you intend to reuse in other projects the second option is of course the way to go.
ahh holy s**** that makes it so much clearer thank you!
&amp;#x200B; &gt;lackluster goto definitions, no proper sql client, prototype in absence of local history cache, fight with git conflicts with some abysmal 3rd party clients and no code shelving, crappy lexical scope autocomplete white noise, no find usages I use both, vs code and jetbrain, and every time I have to use vscode (my 10 years old laptop) it really feels like a downgrade. &gt;JetBrains or not, integrated IDE clients are all crap, by definition. I wouldn't call it a "client", but a tool on it's own. JetBrain DataGrip, which GoLand includes is the best SQL tool out there I've ever used. And before I became professional developer I've used quite a few tools. As for git integration, the IDE integration is exactly what you want. As you can edit the code to fix the conflicts directly having the remote version, local version, resulting version all marked out. JetBrain really makes it a breeze. I also find that open source plugins are usually of low quality, as mentioned above, marely including language server only provides absolute minimum in terms of intellisense. I'm not sure why exactly that the case, perhaps the platform is simply to limited as a lot of generic jank get's in the way.
Right. Not to detract from the awesome work people are doing, but, IMO, code generation just highlights a shortcoming in the language.
much appreciated thank you!
I think that this is what tinygo is doing, https://github.com/tinygo-org/tinygo/blob/master/README.md
From the above link, this pkg is reported to being the fastest: [https://github.com/qri-io/jsonschema](https://github.com/qri-io/jsonschema) &amp;#x200B; I'm also using is a project right now where speed of validation is very important and its working fine for my needs. However all projects non-functional-requirements are different so you would really need to test it out. :)
how does this compare to something like [Jeffail/benthos](https://github.com/Jeffail/benthos)?
Well in my experience of working as a software engineer for quite a long time now. (Worked with Ruby, Python, Node, &amp; C) I have personally found go to be the best language and eco system to work with to date. The go toolchain is so simple and most of the time I only really work with the standard libraries and have no need to find a 3rd party package and therefore not even worry about dependencies. I found that in the node world I was always using dependency to help me get the job done and then would have this massive and very hard to manage dependency trees. Which was a big issue when I starting building tech that had very high security requirements. The languages is also super easy to learn and work with and as what I personally believe is far less WTF is that happening for moments. ps I'm not a fan of the node event/callback soup model and you also don't need to have a stack of build toolchain tools ie webpack -&gt; babel/ts to get your system to run. Personally switching to golang has been so refreshing for me. A lot of the pkgs that I do need from the community are very well maintained and there is a real build 'stable' tools/pkg mentally that are simple and clear. I now find myself spending most of my time building solutions for the 'real' problem at hand and not debug the language/toolchain/packages as I have had to do with other languages. oh and its super fast too. Anyway just my 2cents.
I work as a nodejs + typescript developer. I think that go is superior. It‚Äôs type system is much cleaner, and go code is just easier to maintain. The learning curve is a little bump at first but after that the language is very simple and productive. That being said, nodejs has one advantage. Prototyping and fast iterations. Modules for everything. The learning curve is different for JavaScript, easy to start but takes a long time before people are comfortable with callbacks, and async code principles. To sum it up, i would prefer go. But if you want quick and dirty I would use nodejs. Also this might just be me, but I would drop typescript. If I want static typing I use go.
Since you are choosing between those two, and you are willing to learn: Go. Go. Go. Typescript is a massive mess in comparison. The tools is a pita (npm‚Ä¶), and everything feels like a house of cards the more you add. And it‚Äôs not exactly lightning in a bottle. Learning new languages is good, and it gets easier each time because most of the time it‚Äôs not actually new, just a new set of features and syntax from the past. Word of advice when learning go. Don‚Äôt get clever, don‚Äôt try to code as if it was another language. Simple is better, and do things yourself as much as is practical. If you like feeling clever and always looks for new libraries to use, go isn‚Äôt for you. If you want to write software, go is great. Of 10 odd languages I‚Äôve gotten paid to code in, go is in my top 2.
Go for backend every day of the week. Typescript with Vue/your favorite framework as a frontend works just great.
With how `defer` works explained, I would like to add that do NOT use `defer` to close a file unless you are sure to ignore the (possible) error returned by `file.Close()`. It might take you hours if not days to debug when an error happens in defer (and you did not handle it).
Cool :)
What's your first?
Dang, didn't know about it :) Looks very cool. There are similarities for sure. That reminds a bit of Kafka Connect. Aims at streaming/processing data (file, DB connectors, various processors etc). Mesh is just for messaging. Also, it supports scripting.
Try it. Not trying to be rude, at all, but it's a lot faster to throw into your editor than to ask. At first glance, that seems perfectly valid
Node does not require nginx proxy to run on multiple cores, you can use use the "cluster" module. But you probably want to terminate SSL before node.js, so there is still value in using nginx in front of node (among other reasons). Both scale horizontally basically the same, but Go has an edge for scaling vertically. Your threshold for scaling horizontally is probably lower with Node.js. In the long term, you can save a money with Go, but it's unlikely to make a huge difference (this is especially true if you are using something like AWS lambdas and not not using cgo). The Go package ecosystem is fine and getting better. It's not quite to the level of Node.js where a package literally exists for everything you might want to do. This is because 1.) the standard library for Go is really good 2.) there are less go developers 3.) The dependency philosophy of the community is basically polar opposite of the Node.js community. APIs in Go is kind of a sweet spot (along with command line utilities -- why anybody writes these in Node is beyond me). However, I've always found working with SQL databases in Go kind of lacking. You either use one of the ORMs which use interface{} and have a performance penalty or you write SQL yourself. I've found using sqlx or upper/db to be the best solutions though. With TypeScript you have TypeORM, which is a little nicer than the Go options, in my opinion. The tooling for TypeScript requires a bit of work to set up the first time, but it's no big deal after that. You can always use ts-node and save yourself some transpiliation tooling setup. The only issue you might have is if you use a package that is not popular and there is no type definitions, or the type definitions are wrong. TypeScript simply has a better type system. If you just want to ship code quickly and you're the only developer working on it, I'd probably go with TypeScript (w/ ts-node). If you think you might be pulling in more developers or have interesting CPU bound requirements, I might consider Go.
Yeah dude this works and is common. Even the built-in csv parsing returns a [][]string.
I'm working on a personal project right now using Typescript/Angular on the front end and a REST API in Go in the backend, and it's been a real treat. Go is amazing. Simple, fast, and manageable. Working in it is an absolute treat. Typescript is good, I guess. Better than JS, but still a bit hard to keep structured if you're not working in a framework. Not many other options for the front-end, though. TS/Angular is the best you can get if you're looking at a browser-based front end, tho.
If you use Mongo, you will want to use JS. As much as I love go right now, it doesn't really have the same flexibility to work with documents as JS. The official Mongo driver has you use the bson library, which isn't particularly portable. If you are concerned with scaling, You would scale node the same was as go. Dockerize it and use a proxy (like HAProxy). However with your idea of user generated content, it probably would be easier to manage if you used a traditional database (like postgres or MariaDB). In this case I would use go. The http library has some weirdness, but it's pretty easy to use once you get used to it. The language itself works great for prototyping too so I don't think speed would be an issue. Authentication will be interesting. Generally you wouldn't actually want to put your authentication in the application itself, but use a gateway that manages that (e.g. lock down routes based on claims before it gets to your API). There is an official package though https://github.com/golang/oauth2. When dealing with my own APIs, I have only had to reach out to third-parties for database connections. There is a bunch of stuff out there, and the new module way of handling dependencies adds consistency to your builds. I would try and build your api to not need to share state. A database is one thing, but try not to use sessions. Input validation can probably be built using struct tags. I'm not sure if there is a package out there already, but that's how I would do it. At the end of the day, since It's a side project, you need to ask yourself a question. Do you believe doing this project in go will benefit you in anyway? If you think it will, then do it in go, if you don't, then do it in JS. Learning a new language, especially one like go, is a process. There will be ups, and downs. Some stuff will frustrate the shit out of you, and other stuff will make you rethink how you used to program. It's a trip, and one that you need to decide if it's worth it.
You don't gotta be a dick dude, this is literally someone wanting to learn what the error means...
I've worked a lot with Go and JavaScript (including Node and a little bit of TypeScript). The two languages require different styles of programming and I would say that it is a personal choice as to which I prefer. You can certainly get the job done in either and given your background TypeScript may be the better choice. However, learning Go and using it for a cloud service is well worth the investment of learning the language and it's toolchain (many times over). In terms of scaling and cloud management Go is very well suited; did you know Kubernetes is written Go? Applications are built as a static binary and can typically be copied into to a docker image based from `scratch`, resulting in very small image sizes (roughly a dozen Mb). &gt; How's the ecosystem of Go for more API related development? The story is very good here, Go has pioneered tech like Protobuf and gRPC. &gt; How easy is to rely on third party libraries with Go modules now? Gomodules are great, there's really no reason to complain about packaging and dependency management anymore. &gt; How's the database story with Go currently, any productive abstractions which are accepted as common way of doing things? I think the story's not as good here... It seems to me that most people like writing SQL (myself included) and it works fine. On the other hand working with JSON is great. The standard encoding/json package is both simple and powerful, so working with Mongo should be easy. I currently use Postgres with a few jsonb columns and one also has a GraphQL layer on top, it fits very nicely. &gt; I've red [sic] through some posts regarding migration from node to Go Is that what you are doing or starting something new? I think there are probably lots of good reasons to do this but doing a rewrite for the sake of a rewrite usually ends in tears...
The answer that is missing here is YES try-catch is BAD style
Is it faster than Dgraph?
[removed]
Be aware that you can still handle errors from the deferred function. To quote [a go blog](https://blog.golang.org/defer-panic-and-recover): &gt; Deferred functions may read and assign to the returning function's named return values. This means that if your function has a named `err` return value, e.g. ``` func foo() (err error) { file := ... defer func() { // code }() ... return } ``` Then inside defer you can do this `err = file.Close()` and the foo function will return the result of the Close. But you more likely want to do this: ``` defer func() { err = multierr.Append(err, file.Close()) }() ``` Which uses Append from the go.uber.org/multierr package.
If you want fast iteration. I cannot recommend Ruby On Rails highly enough. Everything everyone says about its downsides is accurate but IMHO there is no faster web framework in terms of developer hours per iteration. No language/framework I have worked in is even close.
It‚Äôs all good, people get cranky sometimes. Don‚Äôt let it get you down!
The biggest difference IMO is that Go has real concurrency. If you need concurrency, you don't really have a choice. TypeScript is nice, but can feel klugey at times. I'm not sure I'd want to start a potentially big codebase in TS unless I had to. Also, Go is great in terms of performance.
The project exists and you can try it out and see. No real conclusions can be drawn but at least it's there.
It possible, but imagine, it's a chessboard. There is no guarantee that the board will have an 8 x 8 layout within your slice, because slices are dynamic. In that case you'd better get yourself a map, which can handle the same stuff but with a predefined size.
This does not get enough credit. If you want to ship a product NOW. Nothing really competes with the standard, no configuration of Ruby + Ruby on Rails. My team of 3 moves faster, and with more changes in Rails than we have ever done with Node or PHP. There are people building 12 semi-complex apps in 12 months using it and the reason is iteration and speed of development. There are some annoyances where Rails May help too much, but once you get over those it‚Äôs awesome. If your idea gains traction and takes off, then start moving parts over to Go Lang. This has worked very well for my team at least. That all being said, if you want to learn Go Lang and ship a product those IMO are two separate goals. If your goal is to ship, ship early and use whatever language you already know.
Also, you can find a good use-case example in [this demo project](https://github.com/go-gilbert/demo-go-plugins). does not work?
must it be one function that: shows the data and/or write data to a file? Or is it possible to split the 2 up? If it's just a file write function, you can do something like: ``` func WriteDataToFile(data, fileName string) error { _, err = io.Copy(fo, strings.NewReader(data)) if err != nil { return err } return nil ``` for the other thing: show data: it depends where you want to show it. Console / web / ??? sometimes a simple println(data) can do the trick, or the more advanced fmt.Printf("%v\n", data) But you have to make us really clear about what you want, because, unclear questions gives you probably unusable answers :-)
It might also help you to know that defer instructions are stacked and executed in reverse order when the function returns. func foo() { defer A() defer B() ... } In the above example, B() will be executed before A() when the function returns.
I would name our favorite language Go instead of Golang, and what I dislike from the interface is that I have to put in all the data, or else it won't work, where you could have put in the default of 1 day and 1 star, or make it clear to the user, that you have to enter values.
I love to read informative pieces about Go, but.... this wasn't one of them. This was just a semi-commercial message where the company just happen to use Go to do IoT stuff. And we know (as we use Go) that Go is capable of doing almost everything. So I expected a more in-depth piece of information, not a text filled with the right buzzwords to attract new customers. Your boss must be proud you wrote this, while we think you're somehow a ..... Fill in any nasty word.
I am sure it will be php.
It's not a good idea to put the source code of your package inside GOROOT. When you change go version, you replace GOROOT. You will have to move your packages, which is not convenient. I suggest to add this in your .bashrc or .bash_aliases file # -- GOLANG -- export GOROOT="/usr/local/go" export GOPATH="$HOME/go" mkdir -p "$GOPATH/src" "$GOPATH/pkg" "$GOPATH/bin" export PATH=$PATH:$GOROOT/bin:$GOPATH/bin and put your package in $GOPATH/src. Change the value of GOPATH if you prefer another location. If you intend to publish and share your package with github, move your github.com directory from $GOROOT to $GOPATH/src and set the import path to "github.com/..../cube" not simply "cube".
I think so since Go is related
This is an addition to the other answers using an embedded type to transparently "skip" the "u" part and map ID and Name directly onto the user type: [https://play.golang.org/p/SuM-qGlNFsE](https://play.golang.org/p/SuM-qGlNFsE) ``` type UserID struct { ID int64 `json:"id"` Name string } payload := struct { Users []struct { UserID `json:"u"` State string Locked bool Income int64 } `json:"users"` }{} err := json.Unmarshal([]byte(body), &amp;payload) // payload.users[0].Name ```
I suspect maps are slower and require more memory than a 2D slice. What keys would you use ? It's also inconvenient when one needs to iterate over entries in a predefined order (e.g. order of keys). A 2D slice need to be constructed. If we want an 8x8 slice, here is how to construct it: b := make([][]int, 8) // create table of columns for i := range b { b[i] = make([]int, 8) // create a column } You can then access element (x,y) of the matrix with b[x][y] because data is stored by columns.
In go projects, once the project gets bigger you end of reinventing a lot of stuffs without even realizing you did that. It's fun to write go code though.
Seconded. I was implementing an OAuth2 OpenID connect client. There's no library out there that's OIDC certified, and the implementations out there aren't great. Made my own.
What I personally like about JavaScript/typescript is that it runs everywhere. It feels like the language that actually fulfilled the java of "write once run everywhere". Also, in recent times, the language has gotten a looot better. But if you already know JavaScript from other work experiences it might be fun to learn something new and Go is a super fine language!
I'm not super experienced with tulypescript, but coming from python ice found sql boiler to be a very nice orm model. It's abstract enough to work without productively but without the performance penalty of rwflextions
Thanks for your input. Word migrations maybe was a big misleading. I've just noticed that quite a bit of node developers moved to Go. Which I referred as "migration". In this case, of professionals from one stack to another.
Go is a great get-shit-done-quick language for me largely because I don't spend a lot of time pondering whether to write a piece of functionality myself or use a package, then twice as much time deciding which package (cough cough Node.js) but instead, I'm usually comfortable writing everything myself, even as a relatively inexperienced dev. The strict type safety can be annoying at first if you're not used to it, but the number of bugs it avoids before runtime feels like a luxury when I go back to writing PHP and JavaScript for work.
Anyone else find this disturbing from an ethics point of view? It seems like ebay wants to learn more about their customers if the sample data is anything to go by &gt; some areas of the code base are inherited from Beam's earlier prototype days and still need attention. In other places, some functionality is lacking before Beam could be used as a critical production data store, including deletion of facts, backup/restore, and automated cluster management.
I hear you here. I do believe Rails is great for rapid development. And I know a lot of start ups also pick Rails for building MVP for this reason. But for some reason I'm just not interested in language. Same way I'm not interested in Java, C# or even Python. Maybe that's a childish reason, probably it is, but I would preferably use the language I feel some joy working with. I also believe that's important to maintain motivation for self driven projects.
"don't be clever" is great advice for any language. I work with a guy who proudly writes PHP "the way he writes C" which apparently means illegible and unmaintainable. One reason I love the Go community is their respect for writing readable programs. Idiomatic Go is simple, explicit, clean code. I started teaching myself Go and was able to read standard library source code within a few weeks - this is a testament to the power of convention and sticking to it.
Well, the simple is a bit subjective. I personally find that using functional patterns is a lot more readable and concise. I'm fully aware, however, that not all people find this to be the case. But for me something like items.map(item =&gt; // logic); A lot more readable and concise than using language flow control. // declare something to be mutated by control flow here for condition, sometimes with sentry { // logic, also keep track of sentry. }
No of course. Goes without saying. Good work. Mockery is also good work. But still...
Beware of Go. Go is indeed superior. But not many developers know Go and master it properly. If you plan to employ people later, it will be much easier to find Typescript devs than Go devs. Plus Typescript devs can probably do both backend and frontend. On the other hand, someone mastering Go will likely be senior and a great programmer, but will be harder to find.
Unfortunately, go can be excessively verbose in certain areas, like functional programming. That and the lack of generics are the only things I don‚Äôt like.
Unless you‚Äôre using an esoteric OS or processor architecture, Go runs everywhere. You just have to ‚ÄúGOOS=&lt;os&gt; GOARCH=&lt;arch&gt; go build‚Äù.
I am thinking more about use cases like: vs code extensions, browser extensions, sketch plugins, adobe xd plugins, google doc scripts, mobile apps with react native. It is not necessarily that JavaScript is more well suited for these things but it has a community and a lot of people know enough of it to be productive.
I switched from Node to Go primarily because I was finding simple things like file processing much cleaner in Go. I also couldn't get rid of the anxiety of using JS for critical server side code. Although I'm sure that's just me. Go just fitted my background better and I wouldn't switch back.
Go scales using the standard library.
Try Go‚Äôs streams (reader/writer) and you‚Äôll probably start to see how much nicer it is than Node, TS or not.
I have ported Node.JS to Go. What you will be amazed to find is just how much more efficient Go is compared to Node.
Aside the langage debate I would focus on the ¬´ product ¬ª aspect of your request. A langage does not make a product a user will, one day, pay for. From day one to your first paying customer there is a gigantic load of stuff to handle. The langage must not be in the way. Keep the one you are familiar with, not the one that seems right. At least for a POC. And, one day, with a good monthly recurring revenue from you good product, rewrite in Go.
I've coded in both Go and Node, and love coding in both, for different reasons. If you're up against a deadline and basically need to slap together a thing for a client quickly, and you're not that fussed about performance or maintainability, then I'd say Node. If you're able to devote a bit more time, and this is a longer-term project which you will be coming back to, or iterating on, then I'd say Go. Write more of the code yourself, use less third-party libraries, and fit the architecture to the domain. This is not a criticism of either language. They're just suited for different things, and Node's \*vast\* ecosystem of (often dodgy) packages means it's much quicker in the short term, but more likely to cause grief in the long term.
If the package is fit for purpose then import it.
did you share it on github? Would love to test it because I haven't found a good one either. Thank you =)
[removed]
Hey sure, it's feature incomplete and simply achieved the requirements of the task I was working on. It grabs \`offline\_access\` and an id\_token. I had ambitions to write tests and get it certified eventually, but life went on and it was a buried project. Sorry about the lack of documentation - haha [https://github.com/qkgo/openid-client](https://github.com/qkgo/openid-client) &amp;#x200B; Useage: \`\`\` p := openidClient.NewProvider( "idp url", "client name", "client secret" ) func LoginHandler(w http.ResponseWriter, r \*http.Request) { url := p. GenerateLoginURL("state") http.Redirect(w, r, url, 302) } func CallbackHandler(w http.ResponseWriter, r \*http.Request) { session := [p.Exchange](https://p.Exchange)("code") session. AccessToken session.IDToken session.RefreshToken ... } \`\`\`
Imo all three ways are legit.
It's very easy to rely on Go modules and the dependency tree doesn't grow as madly as Node does. It's very easy to scale applications, especially if you're going for a microservice architecture. The database situation is OK; I use GORM for most things though. I've only used Mongo once with Go and my opinion of it was "meh, it's ok". Nothing special, just what you'd expect from a mongo driver. &amp;#x200B; As for the multithreading that's where Go is a beast. Go, like Node, has very good and easy to use async IO. Unlike Node, it's not running on an event loop. Go makes full use of any cores available to it, and automatically distributes goroutines across them. You don't have to do that reverse proxy hack. If you want to use a single server to host from, there will be no extra effort. If you load balance, obviously, you will need some way of syncing state across nodes. Depending on your project, an encrypted and signed cookie may be suitable (as long as replay attacks don't pose a threat) to remove the need for state synchronizing.
We use protobuf to describe our data. This takes care of generating the Go code, we also have code generators for our CRUD functions to the database and a system that non-destructively reconciles the database schema to the proto descriptors (instead of migration scripts). I find that using the protobuf in a 'desired state system' is a lot easier to deal with than hand writing migration scripts. Working with protobuf also encourages you to keep everything backwards compatible too.
Imo all three ways are legit: 1. Using external modules might grow your executable, especially if those modules use a lot of external modules themselves. Sometimes is better (and even easier) to write implementation yourself. 2. When module provides a lot of stuff you don't need but bits of what suits your project 100% you can copy those bits... Although I personally prefer to form the module and strip it down to leave only the things I need. this way it could be used by other people as well + free updates from upstream + occasional PR to upstream if you found a bug. 3. The easiest way possible, depends on your needs
I tend to keep the database schema as a series of SQL migrations, stored as \`.sql\` files in a \`sql\` or migrations directory. The initial version of the database schema is defined by the first SQL migration. From time to time, you can prune the migrations directory, by consolidating old migrations in one .sql file. &amp;#x200B; StackOverflow does something similar: [https://nickcraver.com/blog/2016/05/03/stack-overflow-how-we-do-deployment-2016-edition/#database-migrations](https://nickcraver.com/blog/2016/05/03/stack-overflow-how-we-do-deployment-2016-edition/#database-migrations) (read the comments where I have asked about this). Regarding Go structs, you can generate them automatically from the database schema, by using an existing tool or writing your own.
Regarding database access (for SQL databases), my personal preference is auto-generated code to handle the standard creation of structs along with functions to map fetching and other basic database tasks, and then supplement that with your own custom code/plain old SQL (helped with something like [sqlx](https://github.com/jmoiron/sqlx) and maybe a query builder) as needed. [A recent discussion here on reddit](https://www.reddit.com/r/golang/comments/bcj0tm/database_access_in_golang_seems_a_bit_tedious/) covered a variety of people's approaches, all the way from plain SQL to a full ORM (with my preference being more towards the plain SQL end of the spectrum).
I have an idea, you can add the new maintainer as collaborator and than remove yourself from a collaborator's repository. I didn't test, but maybe it will work.
I'd like to hear more about your use of an API gateway. Do you have particular projects or approaches that you find work well with Go?
I'm feeling the same way in go, after years with JS/TS. I got used to the concise and declarative functional style of JS/TS, and I'm missing it in go. Still brand new to the go language though, so I'm trying not to force my opinions on it, and do things "the go way" as much as possible. FWIW, I loved TS. All the complaints about tool chains and dependency hell are totally valid, but it's a really neat language to work with.
I created a model for [Simulation of Restaurant](https://github.com/soldatov-s/go-gpss#example-4). The model allow to test work restaurant and get a report with information about results if simulation.
Not being willing or able to use dependencies is more a pathology than a reason to use a language.
I think Go is more mature and has higher performance and productivity characteristics. The ORM story seems a bit weak compared to other languages but I think that's in part because of what a lot of people say here: the language is so productive that people prefer hacking together a crappy solution over collaborating on proper frameworks.
Write a small portion of functionality in both and see what works for you
That's definitely fair and if a language doesn't tickle you than no matter how well suited it is you won't make progress.
I am a js developer... I didn't give a shit about go.. but my experience with go is it shines mostly in architecture level. So I think seeking for senior developer who knows go is the basic idea. But I don't think they are seeking for senior golang developer. They are seeking senior developers who also knows go...
That's awesome, way to be the solution you wanted to see in the world. :) Please add a license so other people can use it! I suggest MIT, if you don't have any preferences.
Did you try Vue/Typescript or React/Typescript? Or why not Angular/Dart? All this options are great for frontend :D Flutter for web is coming.
Many reasons mentioned, so I won't repeat. Well experienced with both. Drop that TS bullshit, and choose go for good. It's best out there rn
Yes, you are right. I meant to say handle errors in defer, not avoid defer. (But somehow some of gophers consider named return a bad practise.)
What is unethical about that? Users give them data and they're trying to utilize it instead of waste it.
At work we primarily use AWS. So we use custom authorizers with AWS Api Gateway for this purpose (these are not written in go). We are looking to add Istio to our systems, which has the same capabilities to use openid connect during ingress. Istio also happens to be written in go https://github.com/istio/istio. Though that's not the reason we are looking to use it.
Depends how complicated the tool is. You mention parsing JSON data. If that‚Äôs all it is, then use the standard library as it has a very robust parser that‚Äôs really easy to use. If it‚Äôs something pretty complex that would be rather fiddle to write, and there is a well maintained library that does it, then use an external library. But if you‚Äôre just looking for a small, simple fix for something, copy paste is your friend. Last thing you need is someone updating a phone number parsing library and breaking your entire codebase.
I‚Äôm finding that using TypeScript on the backend is in many ways better than Rails. TypeORM is often more enjoyable than ActiveRecord, which I never thought I‚Äôd say. I‚Äôm able to move faster because the compiler catches a lot of the dumb errors that Ruby makes possible. There are a lot of things I miss: the repl, the great deployments, sidekiq, rspec... But it‚Äôs still so good that I hope to stick with it.
There is a work-in-progress LLVM backend at [https://go.googlesource.com/gollvm/](https://go.googlesource.com/gollvm/)
But that's not what I mean. This would need to reimplement the complete go language, maybe some parts of the standard library, etc. I would like to see llvm just as the final step in the mainline compiler, like the wasm target. We wouldn't have a wasm target if it would have required to rewrite the complete compiler.
This seems like it might be a cool website, but I don't disable HTTPS Everywhere for anything, so I'll never know.
I love typescript and i love go, but if i had to choose for a project like this- go. Node, to me, slows things down too much (in terms of finding what i need/etc) Go's package system is simple, search github, and go get :)
&gt; Opinionated linter rules? Lmao do you actually use go Alright, show me how to set up a linter that enforces "negative condition and return" instead of "positive condition and nested logic". golint/govet/metalinter enforces *google's* opinion, but I don't get much say. &gt; Go autocomplete etc has been working perfectly for years. Then why are there 3 forks of gocode and why are all of them being deprecated in favor of a language server? You really just have no clue about this stuff and your caustic attitude doesn't help.
Exactly, it's literally so easy to configure
Exactly, it's so easy to configure, they really should have it enabled
Oh, I didn't realize Dart would transpile to js. May look at AngularDart for my next project - Dart looks like it's a treat to work with. Looked at react and vue, but really loved the structure that angular enforces. The 2-way binding is kinda sexy, too. Landed on TS by default once I decided on Angular Also, I trust Google about 100000x more than I trust Facebook. Don't really want Facebook /anything/ anywhere near me. Zuck creeps me the fuck out.
So we have the freedom to change it later. Like we're doing in Go 1.13.
`atomic.StoreInt64(&amp;id, id+1)` is the wrong usage. Use `atomic.AddInt64(&amp;id, 1)` instead (which also returns the final value of `id` for you).
That's the idea. Programming language is just a tool.
Why does using a struct give you more freedom than `String` above? One thing I can think of is that eg. `&amp;String("bla")` would be illegal since literals aren't addressable, so that places some limits on what you can do with it.
Users are largely ignorant around storage and use of data.
I answer this question [in this related reddit thread](https://www.reddit.com/r/golang/comments/bgg4zs/dotgo_2019_dave_cheney_constant_time/elkuppg/). The tldr is: Because you want the identity of an error to be determined its point of declaration, not by its text.
An important feature of `errors.New()` is that each value returned is unique: `errors.New("foo") != errors.New("foo")`. Your proposal does not have this feature.
LUMS
[The Go Blog Godoc: documenting Go code](https://blog.golang.org/godoc-documenting-go-code)
Ah, that's a really good point, although I'm not sure how much of a problem that would be in practice. Definitely a gotcha in any case
Great answer. I hadn't even though about the comparison problem
In practice, it's important that documented unique values are unique.
You mean like http://contribsys.com/faktory/?
That's a bit of a tautology? I mean, I'm not saying you're wrong, but just that saying it's important doesn't really give any sort of idea as to where `errors.New("foo") == errors.New("foo")` being `true` would _actually_ be a problem. Comparing sentinel errors from two packages that happen to use the same literal doesn't sound like it'd crop up a lot
Are you able to explain why the atomic Load methods are needed? Why the atomic Store methods cannot do all the work? Thank you.
Not all strings are errors. :)
The problem may not crop up a lot, but it's possible. The designers of the library preferred to implement the feature in a way that works all of the time.
Looks cool! But doesn't seem to have DAG facility for the opensource edition.
Ah, you said for enterprise, didn't realize you wanted something like that for free.
Watch out looping through large file sets though in one function though. You can run out of file handles. In that case, either move the file open into a function inside the loop (so the deferred close happens inside the loop when that function exits) or explicitly close the file inline in the loop to ensure you don't accumulate open file handles until the function containing the loop ends.
yeah, if i had to spend money I would use Autosys.
Ha, true! Although wouldn't that only be a problem when comparing a string literal (eg. `"foo" == String("foo")` is legal and gives `true`) due to assignability rules as comparing variables doesn't even [compile](https://play.golang.org/p/qwCRGx6GurG)? Still, good point.
OT, but as the author of software that I'm trying to sell to enterprises, I am curious: why is it you need enterprise features but are not willing to pay for them?
 just DAG for now. I would be willing to pay for support! Right now, I am just evaluating
Oh yeah, no argument here; there's quite a few gotchas with the `String` type as you and others have noted, this is more me thinking out loud than anything
Designing these things are fiendishly difficult. My own personal experience is that simple and explicit is better on average. Who knows what Go 3 ends up looking like:)
Can you post your code using `atomic.Load*` that doesn't work? The only code you posted are `atomic.StoreInt64` and `if id&gt;0 { ... }`
There's more things. string-types are convertible into each other, they can be indexed, sliced, ranged over, added‚Ä¶ All of these are not possible with pointers to opaque structs (not that I think this is truly a good reason though).
It sounds like you believe everything in the parenthesis is called with some sort of lock held. That's not true and there's no lock; only the named operation ("Store") is atomic. Your code is equivalent to: n:=id+1 atomic.StoreInt64(&amp;id, n) Where the load and increment are calculated non-atomically. If you want an increment to happen atomically, you have to use `atomic.AddInt64()`. Using the atomic operators is very limiting. If you want more complex operations, you probably want sync.Mutex instead, at a higher overhead.
Not a good idea if your project is supposed to still work in a few years.
I'd say you should try to keep your dependencies down to few well-maintained packages. Every dependency adds extra burden to your project in that you need to keep track of its development process, it's license, and API breakages. Only add a new dependency if that burden is contrasted with a sufficient benefit for your project.
Maybe you must consider the hijacking your http request and make your own http request/response. [https://golang.org/pkg/net/http/#Hijacker](https://golang.org/pkg/net/http/#Hijacker)
Yes. It's code. 100% certainty is 100000% better than 99.99% certainty. Especially considering it's not harder to do so.
Flutter is very similar to React. I think this is the future of doing things. I do a lot of React Native developmend and it's just the time to switch to Google's Flutter. I don't like Facebook, I don't Apple. Facebook does a really good job on their open source projects.
You nailed it!
I have both. The main reasons to learn Go: 1. Performance 2. Ready for Microservices 3. Go positions pay more Read more at [https://stackshare.io/stackups/go-vs-typescript](https://stackshare.io/stackups/go-vs-typescript)
No issues with what you are saying. What I am trying to understand is this: Doc: "StoreInt64 atomically stores val into *addr" If it works atomically, then why is a read-API even needed? Is updating an integer not something the CPU can do in 1 op? Why is StoreInt64() unable to prevent concurrent code from reading an integer that is only partly updated? If StoreInt64() would work atomically, then doing this should cause no issues: n:=id*10 atomic.StoreInt64(&amp;id, n)
You‚Äôll find no shortage of people who‚Äôve built huge, wonderful things with both languages and are extremely happy. You‚Äôll find an equal number of them who will tell you why their language is 100% better than the other. Forget all of that. If you don‚Äôt mind taking your time and aren‚Äôt afraid of a little struggle, use the one that sounds more interesting. Worst comes to worst, you‚Äôll realize you hate it and rebuild in the other but you‚Äôll be armed with new perspective. A v2 of any project is always better than the v1. Hell, if you‚Äôve got the time, build a quick MVP (heavy on the M) in each and see which feels better. If you‚Äôre trying to be as productive as possible and ship as quickly as possible, use the one that leverages the most of what you already know. Sounds like that‚Äôd be TypeScript. Scalability issues caused by technology (‚Äúwe‚Äôve made it as fast and efficient as possible but you can only do so much with X!‚Äù) are a privilege of success. You need a good product and a lot of luck before you get there, so I suggest you optimize for your own productivity now. All that said, I was recently faced with a similar question. Armed with a very positive recent experience with Go, I tried to build a new API with it and hated it. As far as I‚Äôm concerned, dealing with databases and JSON highlights the shortcomings of Go‚Äôs type system spectacularly. It‚Äôs likely that with more time, I could have tracked down some patterns for dealing with those things that didn‚Äôt feel like unsafe hacks but that was not an option. I went back to TypeScript and banged out a shippable version in a couple days.
I've been importing packages for years and my projects still work...
I'm reading your post and I think it's the most sincere advice I got here. Not to demean anyone else who contributed though, I well appreciate everyone's comments and input, some insights were very useful indeed. But now with your post I've noticed that I'm being stricken by choice paralysis. And you've managed to pick on just the right words to snap me out of it. Thanks!
It also means that you can define your own error types that implement the interface but also add extra data. So you might have, for example, an extra field of an error code or things like that.
I would be willing to pay almost anything ‚Äî after I‚Äôve validated I get value from it via the free version. That‚Äôs why they often given you a free integration period for big ticket software
So glad to offer something of consequence! There are lots of great replies here. If nothing else, they all demonstrate that you can use Go to do what you‚Äôre trying to do and be perfectly happy. I‚Äôd bet anything you‚Äôd see similar excitement in /r/TypeScript.
[removed]
Store is only guaranteed to be atomic if you only read via the Load function. It's not necessarily atomic from the cpus perspective.
Because when you do `id*10` you are reading `id` without any sort of synchronization. `Store*` operation is atomic only in regards to the provided destination address, not the source from which it reads. That's why you need `Load`. Imagine that instead of `id` you would access some other variable. In that case the resulting code has to atomicaly read and update from two district places. There is also question of semantics - without explicitly locking memory using mutexes or atomics compiler is free to assume that this code is single threaded and optimize as it pleases. The cpu is free to assume this too and may not expunge and reload L1 cache too. I highly recommend reading [this](https://software.intel.com/en-us/blogs/2013/01/06/benign-data-races-what-could-possibly-go-wrong) article. It will explain a lot.
[removed]
[removed]
Unfortunately it's really hard to generate proper LLVM IR. This is one of the reasons Rust is stuck with LLVM for now - too much effort is already spent on generating proper IR.
\`\`\` func (c \*FailAwareHTTPClient) Do(originalReq \*http.Request) (\*http.Response, error) { originalBody, err := readBody(originalReq.Body) \`\`\` Assuming that you can keep the entire request body in memory is kind of a big assumption to make. &amp;#x200B; It either needs a way to signal that it wants to reset the body for a retry, or it needs a caveat in the library that it will fully read the body.
Dgraph is in Go?
Although obvious...good question!
Yeah true, but they are getting smarter. They used to be scared to buy plane tickets online. Hell, they didn‚Äôt know how to type that long ago. The big question here though is do we as consumers want personalization? I believe we do and tech like this help makes it possible. Is there a line? Yeah sure...help us define it and take it to your congress!!!
you're assuming that id was safely read in a fully written state in the first line, and that nothing wrote to id between the first line and the second line. You *could* implement that using a Load then a CompareAndSwap&lt;x&gt; using the value you read using the load. At that point, you would need to check if the compare and swap succeeded, or if something else got in there first, and decide if you need to keep trying until it works or give up. This assumes that as long as id is equal to what you first read, the result is still valid (it could easily have been incremented and decremented between)
I'm not sure we're talking about the same thing here. `errorString` is just the "default" stdlib implementation of the `error` interface. Being able to define your own error types doesn't really have anything to do with it
This seems like an advertisement for a solution in search of a problem. &gt; When the number of packages and responsibilities of the project is increasing, it is possible messing up while communicating between other packages. Do packages "communicate" with each other? I've always seen packages in a different light: as libraries with functions and types. Packages are not services - they don't communicate with each other (why force a 3rd party package to "communicate" with your arbitrary "message bus" package?). Packages should rarely (if ever) have internal state. They're collections of functions and types. This message bus / event sourcing paradigm is better suited at the microservice level, not at the package / library level. That's just my $0.02.
Thanks @pnea for the comment. Yup, it is how I promote what I do. The promotion is not hidden in the content but comes with the idea. I recommend checking out the sample project for better context. Happy hear more...
With a struct, you can add additional member variable to it like a stack trace at location of error.
[DiscordGo](https://github.com/bwmarrin/discordgo) has a State! I'm not very familiar with how those APIs are supposed to be done, but this one seems right to me!
Sample code: https://textuploader.com/1dtnj You can c&amp;p this into: https://play.golang.org/ and play with it. Attached below you see my console prints after running the code several times. Note that the printouts are kind of random, which is expected. Notes: 1) I think you agree that everything is alright with f1() and f2(). There is a potential "risk" that the two places where I modify "id" will run exactly in parallel. But atomic.StoreInt64() will take care of this. No danger here at all. 2) Method show() has two time.Sleep() methods. It runs before and after f1() and f2(). And potentially also at the exact same time. In show() I am NOT using atomic.LoadInt64(). I just read-access the global variable "id" directly. **My crucial point:** if atomic.StoreInt64() works truly atomic and if "id" is only ever modified with atomic.StoreInt64(), then read-accessing "id" directly should be totally harmless. No? Running it with -race still dumps a DATA RACE warning in the fmt.Printf() line. I still think there is: A) no risk of this code crashing, when it reads "id". And B) there is also no risk of ever seeing anything other that 0, ff or ff00 as printed values. (Never ffff or anything similar.) Console: dave@hexa:~/code/concur$ go run main.go A 0 B ff00 C ff00 dave@hexa:~/code/concur$ go run main.go A 0 B 0 C 0 dave@hexa:~/code/concur$ go run main.go A 0 B ff00 C ff00 dave@hexa:~/code/concur$ go run main.go A 0 B 0 C 0 dave@hexa:~/code/concur$ go run main.go A 0 B ff C ff
Try setting header to deflate or * ``` client := &amp;http.Client{} req, _ := http.NewRequest("GET", url, nil) req.Header.Set("Accept-Encoding", "deflate") res, _ := client.Do(req) ```
The article you have linked to has a definition for atomic: "An operation acting on shared memory is atomic if it completes in a single step relative to other threads." Does atomic.StoreInt64() complete in a single step relative to other goroutines? And if it does, what risk exactly is there when reading a global shared memory integer variable that is otherwise only modified by atomic.StoreInt64()? See my sample code posted on top. Thanks.
Thanks @pnea for the comment. Communication with a message bus is a design/architecture, it is not coupled to language. And the solution is not promoting the microservice communication but it is promoting usage of message bus for internal communication. If you can‚Äôt find a use case, I recommend checking out the sample project for better context. Happy to hear more...
&gt; // DisableCompression, if true, prevents the Transport from // requesting compression with an "Accept-Encoding: gzip" // request header when the Request contains no existing // Accept-Encoding value. If the Transport requests gzip on // its own and gets a gzipped response, it's transparently // decoded in the Response.Body. However, if the user // explicitly requested gzip it is not automatically // uncompressed. DisableCompression bool
It's also answered in the article, not all reads are done in a single operation, so there is a possibility of torn reads.
DisableCompression is already set to true, yet it is still adding the Accept-Encoding value unless I‚Äôm misunderstanding your response.
If you can see it on the address bar (as in, `https://example.com/foo?code=1234`) then it‚Äôs a url parameter, not a form value. Use `r.URL.Query()[‚Äúcode‚Äù]`.
Interesting. I don't think I have an 64-bit alignment issue. But thank you for pointing this out.
... or just call r.FormValue() because that method returns query parameters.
Hmm, wasn‚Äôt aware. Thanks for the info.
Zing! I didn't think of torn reads of a 64bit variable on 32bit CPUs. Hmm... I definitely have to use the atomic.Read methods then. Thank you for pointing this out :) I still have to figure out why atomic.ReadInt64 was giving me issues on ARM, but not on x64. It would be good to have an article like this (preshing.com) explicitly for Go.
I'm not sure from the amount of code I see here. I use oauth via Google for the login on my personal site. I handle the [two steps of the auth flow in flow.go](https://github.com/PaluMacil/dwn/blob/master/module/oauth/api/flow.go) and I do more with oauth and oidc in my day job (mostly C# now), so I'm somewhat familiar with where people get tripped up. Make sure your client secret and id are correct. Make sure the path you're redirecting to, the yoursite.com//pages/auth-accepted.html is in the config of your oath provider exactly. You can't put in just your domain. It must match. Also, make sure in the step before what you showed that you're asking for the code auth flow. There is an implicit and hybrid flow too. (I might be mixing up oidc and oauth terms because I do both and they are similar, but if you have more questions, let me know and I'll refresh myself and look back.) Finally, if you aren't using a library (you probably should be unless you have very specific needs) like I did to build the url for Google's code flow endpoint, make sure you know how to make the redirect query params. Later, if you aren't using a library to get the token, make sure it's requested with `Content-Type: application/x-www-form-urlencoded` but you aren't there yet, and the oauth stuff I used just had an exchange method. to deal with that.
For oauth, it will be in the form, so I'm assuming an error of another type, but I don't know what since most errors would be displayed when he was redirected to the auth provider.
What‚Äôs the value? It‚Äôs gotta be being set somewhere.
The title could have been better.
Does printing r.Form after r.ParseForm() show anything?
Unfortunately the the remote service does not support the ‚ÄúAccept-Encoding‚Äù header at all.
Also try post on the golang #jobs slack channel (https://invite.slack.golangbridge.org)
Question from a nosy NZ developer - can you say anything about the client? I‚Äôm curious about who is using Go and how they‚Äôre using it
 http.HandleFunc("/pages/auth-accepted.html", func (w http.ResponseWriter, r *http.Request) { if err := r.ParseForm(); err != nil { http.Error(w, err.Error(), http.StatusBadRequest) return } fmt.Printf("Code: %d\n", r.FormValue("code")) })
DisableCompression: true Unfortunately because of NDA of project, I cannot post any real code snippets and have to be super vague. The only headers I add are content-type and authentication.
The parser and standard library are not the difficult part. gollvm reuses the gccgo parser/frontend and can use the Go standard library as-is that's written in Go. &amp;#x200B; LLVM isn't just an IR/SSA representation, it includes calling conventions and memory layout assumptions. Much of the work that is going into gollvm is in reconciling the LLVM data model with the Go data model: this is the fundamental hard work. This hard work would be the same as if LLVM was a target for the gc toolchain. Having gollvm in C++ makes it easier to integrate more directly with LLVM and write custom passes.
&gt;Hi gloang community, &gt; &gt;Im not sure if this is against the posting rules but I am looking for senior GO developers who would consider moving to NZ to live. We have senior and team lead positions in Auckland city and we can help assist in the immigration process... basically once you have a job offer (which you can get before you come) you will almost all the time be granted a work visa (assuming you pass standard security checks like any country has) &gt; &gt;Thanks &gt; &gt;Brandon Gallagher &gt; &gt;Director @ www.gtsnz.co.nz ok thanks Ill do that
Hey - there are a few now that use it and more coming on board but tits still a very small number compared to other languages. Are you looking for a new opportunity or just interested in the companies who use it?
&gt; Recently he was the very first to discover an interesting paper ???
True, and unfortunately, non-uniqueness can even hamper memorability if everyone associates something different with the name.
To save readers some clicks, "proxy" in this context means "Anonymous Open Proxy server" - that kind of HTTP proxy server that shall help hiding a user's IP address from the web server they are visiting.
Do you thinks it's a good idea to change the readme to make that clarification?
Have a look at https://argoproj.github.io/
Hey OP, would you mind elaborating on the job description?
Sure, why not? "Proxy" can mean a whole lot of different things, depending on the context. (For repo readmes in general, I always prefer to err on the side of being too verbose rather than too terse.)
are you open to remote workers if they're in a similar time zone?
Do you have a suggestion? I'm open for a better name?
Yes, this is something I have to work on!
Print the entire request object (url, body) and see if you can find the problem.
ü§¶üèª‚Äç‚ôÇÔ∏è
# ü§¶üèª‚Äç‚ôÇÔ∏è
Everyone knows Go is big. There's no need to flex. Go is well suited for devops, yes. Take a look here: https://blog.gopheracademy.com/advent-2018/go-devops/
Where's the sauce tho?
Broken link, I'll fix it. Meanwhile, here is a correct link - https://github.com/x1unix/demo-go-plugins
Are you open to remote workers in Eastern Aus?
Fixed the link
1. Refactoring is language specific and implemented for some of them. It's a first class feature for Vscode. Including Go (variable and function extraction, renaming) but for now as a separate command instead of being integrated into vscode. 2. Mediocre requires some proof. Nothing is mediocre about vscode as an editor right now. And it becomes fully fledged IDE with help of plugins. There's a reason why vscode dominates on the market according to recent stackoverflow survey. And I personally see nothing that would bring me back to something like Goland.
I work at Vend in Auckland. We're not the company hiring in this post, but we use Go and we are [also hiring](https://www.vendhq.com/careers). The majority of our backend services are written in Go. Movio is the other main company in Auckland hiring Go developers, but there are some other smaller ones. (Maybe new ones I don't know about yet too.)
Good you didn't bet your hand on that statement because now, well... You wouldn't have a hand. Channels do not create own goroutines. Channels are basically a pointers to buffered synchronized structures that multiple goroutines write/read to.
No - on re-reading the original post I realise you're right. Guess that's why you shouldn't comment when tired :(
Yep, you cite that very well. Actually, a lot of times scientific papers are never discovered, because people don't notice them. Dozens of scientific papers are never noticed and share on the socials. I could make a list of relevant Golang related papers that are never mentioned in socials (whether or not they could contain misjudgements) while poor quality Golang blogs are. u/tv64738
Are you sure that your package is looking for a proxy? And does not it load them from specific sites? The package name is misleading.
Thx for good link, may be somebody knows some similar job channels regarding Python or C++?
&gt; I just read-access the global variable "id" directly. My crucial point: if atomic.StoreInt64() works truly atomic and if "id" is only ever modified with atomic.StoreInt64(), then read-accessing "id" directly should be totally harmless. No? No!!! Atomic operations should be on both sides: write *and* read. Your example does not expose bad behaviour cause of two reasons: 1. You touch only lower 32 bits of 64bit value. ARM performs 32bit store atomically, therefore you could not catch non-atomical behavior with storing 0xff00 and 0x00ff. You should try 0xff00000000 and 0xff. 2. Perhaps ARM64 performs atomic operations on 64bit values as well (as x86_64). But atomic operations are not just about reading/writting one variable. It is about ordering of other non-atomic reads before and after reading/writting. `atomic.Load/atomic.Store` operations in Go are full memory barriers: https://dave.cheney.net/2018/01/06/if-aligned-memory-writes-are-atomic-why-do-we-need-the-sync-atomic-package &gt; In terms of Go, read and write memory barrier operations are handled by the sync/atomic package, specifically the family of atomic.Load and atomic.Store functions respectively. Without memory barrier, logic that depends on value of variable you had to read with atomic.Load but read without instead could easilly read older values than you expects. If you found that atomic.Load is buggy, you should write bug report. But it is more probably that your code is buggy.
The package finds/scrapes proxies from different proxy websites and compiles them into a list. It also adds method for filtering them.
Shortly: read about memory barriers and operation ordering in multithreaded programming. Most probably you will find this information in touch with C or C++, but it all applies to Go as well. atomic.Load/atomic.Store are full memory barriers. If you use atomic.Store, but doesn't use atomic.Load, you doesn't have ordering. You program will (probably) work on x86_64 at the moment. But since Go compiler accepts more and more optimizations, once in a future it will reorder some operations, and program will start to behave insanely: once in a day it will read wrong associated value and will strangelly crash (in a good case) or silently make wrong things (in a bad case).
Again: atomic operation it self doesn't matter much (unless you use it as a simple counter for statistic). Even in that case, lets study scenarios: thread A: does non-atomic read of variable V thread B: does atomic write of variable V variable V: contains 0xff before scenarious thread A: reads low 32bits of V: 0x000000ff thread B: stores atomically 0x000000ff00000000 thread A: reads high 32bits of V: 0x000000ff Vuala: thread A read 0x000000ff000000ff I really think ARM64 performs 64bit aligned read atomically this days. But it is bad practice to rely on it.
Typescript is a nice language but the toolchain is terrible. I don't mean the typescript compiler. I mean the whole thing: npm, transpiling/compiling. Bundling. Deploying. It's layers upon layers of tools and abstractions and it's all so fragile. I use it for the frontend because there's no other way. I would prefer if I could completely avoid it (npm). Go as a language is decent but leaves some things to be desired. The tooling around Go is very good though: the compiler is relatively fast. It can cross compile to other operating systems (I can build a linux binary on my Macbook (running macos, of course)).
Training engineers in Go is such a breeze in comparison with many other languages though.
I want to know that too
Raspbian is still running in 32bit mode to provide compatibility with all older RPi's. So I am using the armv6l variant of Go, not arm64.
Make sure its not a fragment instead of a query param. Implicit grant uses a fragment. &amp;#x200B; [https://stackoverflow.com/questions/7522831/what-is-the-purpose-of-the-implicit-grant-authorization-type-in-oauth-2](https://stackoverflow.com/questions/7522831/what-is-the-purpose-of-the-implicit-grant-authorization-type-in-oauth-2) has some details. Fragments will not be passed to the backend. Theres usually some security implication behind this, but its kinda easy to circumvent with single page apps (if u know what you are doing).
&gt; The big question here though is do we as consumers want personalization? We don't know what we want, but all the bells and whistles added sure aren't delivering it, whatever it is. &gt; Yeah true, but they are getting smarter. They used to be scared to buy plane tickets online. Hell, they didn‚Äôt know how to type that long ago. Is this referring to AI or people. It's funny either way, but genuinely interested to know which "they" this referred to &gt; I believe we do and tech like this help makes it possible. In some way I agree it could be used for that. Doorstop thinking though, there are many more possibilities for abuse than the thin edge of helping. I do write to my representatives a lot. Bastard seems to be replying with automation. If it's AI the i is small because it just infuriates me
This Dave Cheney article answers the important atomic related questions. Thank you for posting it. I am switching back to atomic.Load now. Will take a little time till completed... Unfortunately, the atomic methods masacer your source code. Optics wise. I still wish someone would pop up here and claim to have atomic.LoadInt64 working well on armv6l (aka Raspberry) in a heavily threaded context.
Ha, I know that feeling. Coffee time
This complaint can, and absolutely should be, lodged at every single programming language out there. Working on code these days means working in teams, most of the time. Something you write today is going to be picked up by someone you don't even know, half a year further. If you left behind something unreadable or unclear in construction, that slows down further development as the new developer has to spend way more time figuring it out than even moderately necessary. It's frustrating, it wastes the time of other developers and ultimately it wastes time of the product. And if not open source, then likely also the time and money of the company.
what oses do you need to support?
For runtime dynamic plugin load/unload something like [https://github.com/hashicorp/go-plugin](https://github.com/hashicorp/go-plugin) will be sufficient. For compile time plugins it's even easier, wildly used example is database/sql standard lib packet and tons of 3rd party database drivers for it.
Ideally all (at least for dev), but I guess it's ok if everything runs just on Linux as that's the target to run in prod anyway,
Is grpc fast enough to act as a plugin in a webapp? Won't all that serialization/deserialization affect performance and the nr of req/s you can handle if you have to pass data between multiple plugins trough grpc?
https://golang.org/pkg/plugin/ iirc you can also load windows dlls too via a different method.
When people think of plugins, they generally think in-process, no?
Let's say so: it's way better then nothing :D protobuf marshaling is fast enough and protobuf IDL can provide clean interface for plugin writers. &amp;#x200B; There is [https://golang.org/pkg/plugin/](https://golang.org/pkg/plugin/) but it had issues since the beginning an I wouldn't recommend it (and it can't unload).
That's just a default assumption, multi-process plugins also has place under the sun. See terraform for example. It has tons of provider plugins, everything works perfectly fine.
These article describes godoc‚Äôs approach to documentation and explains how you can use our conventions and tools to write good documentation for your own projects. [https://www.ardanlabs.com/blog/2013/06/documenting-go-code-with-godoc.html](https://www.ardanlabs.com/blog/2013/06/documenting-go-code-with-godoc.html) [https://itnext.io/documenting-go-code-with-gonotes-68422ddcf7ad](https://itnext.io/documenting-go-code-with-gonotes-68422ddcf7ad) (Also see the Go team‚Äôs official blog post on documentation) [https://blog.golang.org/godoc-documenting-go-code](https://blog.golang.org/godoc-documenting-go-code)
It's ok if it can't unload as restarting the app each time a new plugin is added/removed is totally fine. Problem is you're saying you wouldn't recommend it. Why? Any idea what the issues were/are? Is it not stable? Any idea if anyone uses this in prod?
I need kubernetes for this? thats overkill.
https://scotch.io/tutorials/moving-from-nodejs-to-go
Excellent it!
If you're working on a complicated problem, you need a hard-to-hire expert regardless. If you're doing a bunch of line of business type applications, I don't think it's hard to hire for a Go team. The time I was involved in the hiring process for Go devs (I'm usually on a C#-centric team), we had no problem hiring Python or C# devs and simply told them they'd be learning Go too. Hiring was no trouble at all from those two huge pools, and those devs did just fine with Go and it didn't matter that they didn't already know Go since it can be picked up so quickly. I found it annoying that Go was never listed in the job postings since I know some people would probably really enjoy finding a junior or mid level Go position, but that wasn't in my control. Enterprise toolchain support with Go has been fantastic for me. I've worked with Google APIs, Active Directory, databases, and oauth.
Probably related to conventional commits? https://www.conventionalcommits.org/en/v1.0.0-beta.3/
what do you mean k8s is overkill :) yes its designed specifically to run in that, works great but not feasibly if you are not running in that already.
I've had great success with vuepress.
Under the hood, it uses a project similar to Selenium (https://agouti.org/). Kosher merges Agouti with GoDog (a Gherkin script runner) and a large collection of pre-written Gherkin Step Definitions to allow you to automate your browser and testing with Gherkin scripts.
Thank you very much! Will be saving these
No joke. Kosher uses IZPack to create a universal, Java-based installer. As with many installers, the tool requires admin rights. For instance, on Windows and Linux, it needs the ability to add the main kosher executable to your PATH. On Windows, it also requires the ability to add an entry to the Registry to enable automated testing with IE (there's a quirk with the IE web driver that prevents it from maintaining session unless a registry entry is added -- see "Required Configuration" at https://github.com/SeleniumHQ/selenium/wiki/InternetExplorerDriver).
"failawarehttp - drop-in replacement for net/http client with built-in retry mechanism" something like that?
The project itself is pure Go. I used a Java based tool called IZPack to create a universal installer. Under the hood, Kosher uses a tool similar to Capybara called Agouti. Check it out :-) https://agouti.org/
I don't remember the source of the quote, but it goes something like: "You need to be 5x cleverer to debug code than to write it. So if you write the cleverest code you possibly can, you are by definition unqualified to debug it."
It‚Äôs a Brian Kernighan quote from The Elements of Programming Style
Most of the time the other programmer down the road is me after some time has passed and the problem domain is no longer something I am familiar with. So I always write code for me 6 months from now.
What is distraction if it is part of the job to have certain meetings? If you have meetings inside a sprint that doesn't really add value (in your opinion), you could always mention this to the scrum master as an impediment. If you gain valuable information in some "on the fly meeting" and get you to gain insight information when refinement is done, it still can be ok. But of course, you can also ask: do I need to prepare something for this meeting, what is the time-box, what is the expected outcome of the meeting, will someone make notes; and more like those, so the organizer will learn from your questions as well (hopefully). But then again, you can always be a truck-driver. They have the same kind of problems but in truck-driver situations ;-)
You could easily get that library in your mod-file by: go get the-url-where-it-lives or you just put it somewhere (because perhaps you need to develop in that package too) and add some extra stuff inside the go.mod file (something like this:) ``` require ( MyCompanyLibrary v0.0.0 ) replace MyCompanyLibrary =&gt; ../the-location-where-you-put-the-library ```
Usually, I'm giving this warning in the opposite direction, as people wonder why parallelizing "adding two integers together" with a goroutine per addition isn't faster than just doing the addition. But, remember that in the benchmark you're benchmarking something trivial, so that benchmark is a *worst case* scenario. If your pipeline components are doing something that takes much longer than 5 microseconds, then the performance loss is negligible. And since in general the bar for worker pools is already at 1microsecond, it's actually a relatively narrow window where this approach is too slow, but the native approach is fast enough.
Overnight I think I've started to suspect that this is probably the OP's most likely issue. Good call. I always use code flow, but when I was learning, the biggest thing to confuse me was that there were different flows to choose from, so I'd look things up and wind up with a non-functional mix of things.
I'd look at generating SVG, with either CSS or JS for the animation.
Not even `Accept-Encoding: *` or `Accept-Encoding: identity`?
"Everyone knows that debugging is twice as hard as writing a program in the first place. So if you're as clever as you can be when you write it, how will you ever debug it?" -Brian Kernighan, "The Elements of Programming Style," 2nd ed., chapter 2
That is a very good point. I did keep the benchmark trivial on purpose but maybe I should have been more fair to myself by adding another that is more complex. Thanks for taking the time to read the article, Cheers!
That is a very good point. I did keep the benchmark trivial on purpose but maybe I should have been more fair to myself by adding another that is more complex. Thanks for taking the time to read the article, Cheers!
Mini-book review: I bought it because BWK is a great writer and that‚Äôs a killer quote. The basic ideas of the book are good but because it mostly focuses on FORTRAN and COBOL, the examples are hard to read and a lot of the principles argued for are now just common sense. I‚Äôd recommend it to a lover of CS history but there‚Äôs not enough in it to recommend to an average programmer. OTOH, I would recommend BWK+Rob Pike‚Äôs The Practice of Programming to anyone. It‚Äôs still relevant and basically teaches everything I learned from a CS major in one book.
I mean the value of the outgoing Accept-Encoding header.
So the developer of the remote service decided to add a required header that wasn‚Äôt documented anywhere so now that‚Äôs added everything works!
Everyone agrees with the title, but nobody agrees on what "clear" is. Many people find map and filter far clearer than for loops with mutating variables, but the Go team does not.
I work at Aeroqual in Auckland. We use Go in addition to C,C++ and C\# and are always [looking for good talent](https://www.aeroqual.com/company/careers).
[removed]
Just to follow up, I renamed to git-tidy and am much happier. This was great advice.
We use a very young yet promising newsletter tool of our close startup friends from [getrevue.co](https://getrevue.co). Https for an added custom domain name is on their roadmap. Want to be completely safe and sure? Here you have your HTTPS link directing you to the same weekly, including form: [https://www.getrevue.co/profile/golang-jexia](https://www.getrevue.co/profile/golang-jexia)
Nice, saved for later
You could create a struct that hides a value inside it and exposes get, set, cas and increment functions.
We use a very young yet promising newsletter tool of our close startup friends from [getrevue.co](https://getrevue.co/). Https for an added custom domain name is on their roadmap. Want to be completely safe and sure? Here you have your HTTPS link directing you to the same weekly, including form: [https://www.getrevue.co/profile/golang-jexia](https://www.getrevue.co/profile/golang-jexia)
Lol that profile pic is funny
[removed]
[removed]
[removed]
[removed]
[removed]
[removed]
On that vein this one is also great: &gt; Simplicity is a great virtue but it requires hard work to achieve it and education to appreciate it. And to make matters worse: complexity sells better. - Djkstra
Sane usage of .map() tends to be cleaner. The problem is that .map() and friends are easy to abuse. Like they say: this is why we can't have nice things.
&gt; It's a side project which I will work on my free so I want a productive language which would allow me to iterate fast. ... &gt; it in terms of how easy is to scale and manage the application on the cloud Those are two \*very\* different design goals. &amp;#x200B; Let's see if I can break it down... If you're making a website type thing, stay with php. I would choose laravel, but YMMV. You could also go with something like django or rails if high productivity is a main goal. The scaling story for these three is about the same, but php is \*far\* faster than python and ruby. &amp;#x200B; As for scaling, you can handle a lot more traffic on a single go instance than for php/django/rails. I would from experience that typescript is somewhere between PHP and python/ruby. &amp;#x200B; As for programming comfort, go and typescript are both pretty nice. Typescript let's you get straight to the point, but sometimes gets very painful when you don't want to deal with asynchronicity (you \*have\* to). For instance if you want to render templates server-side like in Handlebars, you will soon find yourself tearing your hair out.
I would say your first step would be to modify the code in downloadSegment. Currently, it takes a filename (fn), and writes to it. Replace this with an io.Writer. This then makes buffering it trivial. See bytes.Buffer. Next, have a look at https://github.com/avelino/awesome-go#audio-and-music to find a means of playing this. Which you'll want will depend on what platforms you want to target, and what sort of control you need over the audio output device. Finally, to examine the frequencies, you need to do some math to the signals, as the samples are simply volume at a specific instant of time. If you only need to recognize a particular frequency of beep, look into Goertzel filters; if you need more than one frequency at one, you need to look into Fast Fourier Transforms. mjibson/go-dsp might help there, but caveat emptor - I've not tried it. If Goertzel will do, you can try to crib my filter from here https://github.com/TheGrum/rosarygen/blob/master/processor.go or have a look at https://github.com/joaocarvalhoopen/Goertzel_algorithm or https://github.com/sveljko/goertzel Hope some of that helps! Howard
Thank you! I will take a look. As for the frequencies, basically this is for a radio broadcast system and we send subaudible tones (25Hz, 35Hz and 25/35 Combo tones) to initiate automation controls. I just need to be able to detect the presence of these tones. Which do you suggest?
Thanks a lot :)
You have to both set disable compression and delete header. client := http.Client{Transport: &amp;http.Transport{ DisableCompression: true, }} req.Header.Del("Accept-Encoding")
As someone who needs to make this decision, my preference is always: 1. Open Source and free. 2. Open Source and free with a bit of extra work to fill in missing gaps. 3. Open source and paid with upfront pricing. 4. Paid with upfront pricing. 5. Paid with "enterprise" pricing (e.g. call us and we'll talk). Basically, enterprise software is my last choice and I'll only take it if its a ton of work do develop in house and there are no open source options. This is because open source means we can always modify things if we run into something we can't work around and can't wait for to be delivered by the vendor/maintainer. Open source also means we can contribute back. And finally, although open source + extra dev work is initially more expensive, long term it's probably much cheaper than the ever escalating enterprise licenses.
Thanks, this is interesting. How big is the company you make decisions for?
I once saw some numbers that 75% of the cost of software engineering was in maintaining what you built. If you're going to spend 3x more time maintaining your code than writing it, you should probably write it for that version of you than the one right now who wants to do something fancy and clever.
[removed]
https://medium.com/@amsokol.com/new-official-mongodb-go-driver-and-google-protobuf-making-them-work-together-6357b0118f3f
Sorry, I'm just seeing this :) You can read the code for how it's implemented exactly, but it's basically just a `*bytes.Buffer` which allocates more memory and copies all the data it had when it needs to if it doesn't have enough. This is probably the part of the code you care about: ```// ReadFrom reads data from r until EOF and appends it to the buffer, growing // the buffer as needed. The return value n is the number of bytes read. Any // error except io.EOF encountered during the read is also returned. If the // buffer becomes too large, ReadFrom will panic with ErrTooLarge. func (b *Buffer) ReadFrom(r io.Reader) (n int64, err error) { b.lastRead = opInvalid for { i := b.grow(MinRead) b.buf = b.buf[:i] m, e := r.Read(b.buf[i:cap(b.buf)]) if m &lt; 0 { panic(errNegativeRead) } b.buf = b.buf[:i+m] n += int64(m) if e == io.EOF { return n, nil // e is EOF, so return nil explicitly } if e != nil { return n, e } } }```
Could you add to the sample to show how you consume data from the events?
Here is a sample project: https://github.com/mustafaturan/bus-sample-project Let me know if you need help.
Please re-read my comment, I'm asking you to add something to this.
If you are asking adding to readme of sample project, sure, I can add its readme too. Let me know if this is what you need or something else
Super excited about gopls. I was a bit worried that the most popular editors (vscode, vim, goland) would control the Go experience too much. Allowing smaller editors to have the same fire power is great for keeping Go inclusive and extensible.
sorry we are looking for people who want to move to NZ
sorry we are looking for people who want to move to NZ
150-200
Nodejs is a scripting language, Go/Golang is a full programming language. Since one of the makers of C helped make Go, you may see some similarities there. You probably won't find a Nodejs to Go tutorial due to how different they are. However, Go/Golang is very well documented online. I'm not as familiar with Dataflow and BigQueries, but I was able to find information for them with Go at the following: [https://cloud.google.com/bigquery/docs/reference/libraries](https://cloud.google.com/bigquery/docs/reference/libraries) [https://godoc.org/google.golang.org/api/dataflow/v1b3](https://godoc.org/google.golang.org/api/dataflow/v1b3)
It's encouraging to see the Go tools team has such a clear idea of what's wrong with the current state of tooling in the ecosystem. I've been using gopls for a few weeks now and I have to say it provides a very good user experience even in its alpha state. I would definitely encourage everyone who uses an LSP-compatible editor to try it out!
Gang gang
I was able to solve my atomic.Load related issues on ARM. Yeah! OP updated accordingly. Not sure I'm a fan of added custom abstraction for this purpose. I would prefer a little language syntax for this. Maybe a ¬ß character before the variable? Just making this up. But this would pull much less attention away from what the code is actually trying to do. Are you aware of a way to access global booleans atomically? Looks like this is missing?? What do you mean by "cas"?
This approach seems very straightforward though it seems like it could be tedious to create so many functions by hand. It seems the gist of this approach is to write the entire dependency graph with functions that close over the context for each layer of the application. This context would be any dependencies or other data passed into a given function for a particular application layer. &amp;#x200B; The main unexplored questions I have regarding this approach include how to handle lazy initialization of dependencies as well as whether code generation would be a better approach to making updates to the dependency graph when there are a large number of components using a particular provided component. &amp;#x200B; Higher order functions seem to provide a straightforward pathway for mocking during tests.
We're based in Christchurch. Our backup application is primarily written in Go.
We're based in Christchurch. Our backup application is primarily written in Go.
&gt;We don't know what we want, but all the bells and whistles added sure aren't delivering it, whatever it is. I get the point but we need to ease up a bit on that whole we are ignorant therefore need others to show us the way. That shit gets scary! :-) &gt;Is this referring to AI or people. It's funny either way, but genuinely interested to know which "they" this referred to Ha! How many scared robots have you encountered? Please send a link of a frightened robot or a robot on airplane if you have one handy but until then I am only referring to humans. &gt;In some way I agree it could be used for that. Doorstop thinking though, there are many more possibilities for abuse than the thin edge of helping. Yeah, I think we would all be hard pressed to find a major website / service that hasn't been using graph databases for this stuff for years. They have like a mini version of all of us right now! There is a line but we need to be able to decide who gets to utilize this data IMHO. &gt; &gt; &gt;I do write to my representatives a lot. Bastard seems to be replying with automation. If it's AI the i is small because it just infuriates me Ok, how about we write a bot that automatically responds to the autoresponders and just sends them another email? I will donate to anyone that wants to write this code / figure out how it should work. :)
How much does it pay and what is the cost of living? Sorry to be that asshole but that's the first thing people look at so you can save a lot of time by giving at least rough figures for both
can we download this in mobi (kindle) format ? Thanks again
I like using goose for migration files in sql [https://github.com/pressly/goose](https://github.com/pressly/goose) and then manually edit the Go code/structs to suit. I don't like ORM or auto generated code but there are solutions to do that too.
Don't understand me wrong. I value very much when someone shares a paper they found. I am only confused by the claim to have been the "very first" (how can you know? Hundreds can have downloaded and read the paper already before), as well as the notion of having "discovered" the paper as if it was hidden under a rock all the time. Just because a paper is not shared in social media does not mean nobody has seen it before.
They reply by snail-mail (real post). I'll be honest I actually make letter writing (mailmerge) software for SaaS apps. But I charge a non-trivial amount because I don't like spam
All of this sounds perfect. Our representatives definitely deserve an increase in auto snail mail responses to their auto responses. Every time make you send one out make the font bigger, brighter and bolder. They may get the point.
Off brand. The way to do it is to make the font smaller and the language ever more like the 16th century monarchs English
Great, thanks - it's a good example.
Therefore not using atomic.LoadInt64 is clear bug in your code.
Maybe post this when not every second paragraph is a todo?
https://github.com/golang/go/issues?q=milestone%3AGo1.12.5
Looks interesting. Gunna give this a try! Also I like the project name.
**Everything you need to know about Go Modules** (and other GoLang topics) is available on [Medium](https://medium.com/rungo/anatomy-of-modules-in-go-c8274d215c16).
Since you are writing a package that others will use, then do your colleagues a favor and keep your dependencies to a minimum. Ideally a good package should have zero dependencies. So my answer is, provided there's time, stick to 1 and 2. If you ever have seconds thoughts (especially about copy and pasting) then remember that this method is one of the mantra of the language: [A little copying is better than a little dependency.](https://www.youtube.com/watch?v=PAAkCSZUG1c&amp;t=9m28s)
This one is interesting: https://github.com/golang/go/issues/31678 &gt; runtime: high-percentile latency of memory allocations has regressed significantly Performance degradation in Go? Not on my watch! said https://github.com/mborsz üëçüèª
We will never know lol
Will this address issues with compiler?
Agree. But I have it working now. (See OP.) Do you happen to know why no Load/StoreBoolean() methods exist in atomic package? Because there is only one significant bit? Race detector is still complaining about direct access to booleans.
why do you want to include imports that doesn't do anything?
This is intentional.
Great article, Data Mining techniques are useful since we are handling really large codebases, it‚Äôs easy to imagine training a model with trillions of lines of code.
Atlassian starts trembling in fear.
if you use VSC and not use gopls you can auto-fix them on save. just select goimports at the format tool (inside the extension : Go Configuration)
Look at anonymous imports
You are trying to serve static content from \`./client/build\` but you are adding the React app into \`./app\` in your image. As a tip, try to minimize the amount of directives in your \`Dockerfile\`, makes for faster build (less layers) and for the love of god name your \`Dockerfile\` just that, not \`docker.txt\`
Double check that are setting your GOPATH correctly.
Never seen so much commented code... and just skimming it, I already found Code duplications... can someone please review this before releasing it?
I forked the original goss project ([https://github.com/aelsabbahy/goss](https://github.com/aelsabbahy/goss)) because the author is not very active and is not very interested in finding other maintainers. For now I rewrote the integration tests, fixed some bugs and added some more features to the dns resource. Anyway, the author did a great job with this tool and find it heavily useful for testing my servers which were automatically provisioned by puppet or ansible, validating docker images or serving k8s healthpoints.
I haven't updated go since 1.9 because of a bug that was introduced to dynamic linking. They simply don't seem to care enough to fix it
As a single dev commented code doesn't seem such a bad thing when fixing and reminding myself what I was doing. At this stage it's PoC until it's validated, as mentioned in readme Yes I agree there is code duplication, and I agree I should refactor that, and will. No argument there, I decided to release to look for feedback on the concept and based on that I will get to work on a refactor. It's a balancing act tbh between writing completed code that no one wants/has a use for, looking for people who may want this kind of thing, and potentially getting feedback on the concept. Thanks for ur points, all help appreciated
It's not a "fix". But yes you can suppress the unused error with gcflags="-warnunused" at build time
Which bug is that?
Be careful not to mention the bug to keep its chances to be addressed near to zero.
Looks like you have a capitol 'G' in the file suffix? Try renaming from `.Go` to `.go`.
Honestly I'm so fucking triggered on that I might go develop a cocaine habit.
This is a problem about \`$GOPATH\`. What version of Go are you running? You can check the go version by running \`go version\`. If you are running Go above \`1.11\` you can set your environment variable to enable go modules. &amp;#x200B; You can add this: \`export GO111MODULE=off\` to your \`\~/.bashrc\`, \`\~/.bash\_profile\` or \`\~/.zshrc\` if you are using \`zshell\`. Then in your current project, execute \`go mod init\`. You check the go modules here [Go Modules](https://blog.golang.org/using-go-modules)
This is a problem about `$GOPATH`. What version of Go are you running? You can check the go version by running `go version`. If you are running Go above `1.11` you can set your environment variable to enable go modules. You can add this: `export GO111MODULE=on` to your `~/.bashrc`, `~/.bash_profile\` or `~/.zshrc` if you are using `zshell`. Then in your current project, execute `go mod init`. You check more about go modules [here](https://blog.golang.org/using-go-modules).
The name Rosie [is in use](https://rosie-lang.org).
Some bug after 1.9 that is.
Didn‚Äôt read the readme, I assumed it was prod code, since it already has a website. IMO even as a single dev, you shouldn‚Äôt commit commented code. Make the design before you code. Helps a lot. Take some paper and scribble possible packages, package relationships, communication flows etc... As long as you can follow the sketches and diagrams, you should be fine.
I mean I do agree, I'll go in and removed the commented code, was probs feeling slightly lazy at the time. It's a work in progress, but ye, discipline is good too... Thx!
Thank you my friend, but sadly it is much dumber than that. I had a capital G in my file extension....
Thank you very much for your suggestion!
I think it would be nice to expose the goss http handler from within my own apps. I.e. run goss.Serve within a goroutine before starting my own app's server. It would mean constructing a cli.App, which would be a pain. It also looks painful to refactor the cli dependency out; cli.Context basically represents a giant blob of global state. Do you think having a reusable goss.Serve has some merits?
Sorry about the title. I'm one of the owners of Gopher Guides (https://www.gopherguides.com). We are doing an entire series of introductory articles for Digital Ocean. These last two we posted the title got messed up for some reason and we didn't notice it. We'll be sure to pay closer attention moving forward. As far as relevance, they are intentionally geared towards new and beginning developers, where as the tour is not. This is why even fundamental programing concepts explained. We try to leave very little assumptions on purpose. Based on feedback we get, many people do find value in these introductory articles. Clearly, if you are an advanced Go developer, you likely won't find value, but maybe you know a budding developer you want to pass it on to. I look forward to hearing back from you. I appreciate any constructive feedback. Feel free to contact me directly as well at cory@gopherguides.com.
I posted this in another thread as well. Apparently the titles got messed up on two posts for some reason and we didn't notice it: ---------------------------------- Sorry about the title. I'm one of the owners of Gopher Guides (https://www.gopherguides.com). We are doing an entire series of introductory articles for Digital Ocean. These last two we posted the title got messed up for some reason and we didn't notice it. We'll be sure to pay closer attention moving forward. As far as relevance, they are intentionally geared towards new and beginning developers, where as the tour is not. This is why even fundamental programing concepts explained. We try to leave very little assumptions on purpose. Based on feedback we get, many people do find value in these introductory articles. Clearly, if you are an advanced Go developer, you likely won't find value, but maybe you know a budding developer you want to pass it on to. I look forward to hearing back from you. I appreciate any constructive feedback. Feel free to contact me directly as well at cory@gopherguides.com.
I appreciate the polite professional response.
Do you care enough to mention the issue number in a place where there might be people qualified to fix it? (That's right here.)
It is midnight here in Australia I am going to try to find the issue number but if I can't I need to change the version tomorrow morning and build the code base to reproduce the bug and find the issue number based on the error message.
fair enough. Sleep well :)
Quick update: Wails is now in [awesome-go](https://awesome-go.com/#gui)
The bug has already been reported and has a reference number for a few years now.
That's amazing! Thanks for submitting it!
My advice is: * Use the [os/exec package](https://golang.org/pkg/os/exec/) to call your command-line programs. (Bear in mind you'll need to split your arguments; you don't call "`kubectl apply -f all.yml"`, you call with `[]string{"kubectl", "apply", "-f", "all.yml"}`. * Once you've used it two or three times, or maybe a few more, you can optionally use refactoring to extract out the commonalities. I tend to recommend avoiding trying to pick up somebody else's wrapper around this library. Much like the HTTP client library, the library is the way it is for good reasons, and "simplifications" arise generally because the simplifier didn't understand all the use cases the original library is covering, and they generally simplify it incorrectly, and introduce patterns that entice you to write bugs. Develop your own based on your own usage; are you piping things to it? Setting up pipelines? Factor those out in local code. (The simplifications are not *always* wrong, but based on what I've seen, it's generally pretty likely.) If you have specific questions about how to accomplish something, you can ask. I don't know if there's a "recipe book" for it out there, but you can pretty much do anything with what is there.
I would love that too and wanted to try to add the possibility to use goss without a cli app. And yes, the cli.Context is a huge mess... :( The reason why I rewrote the integration tests was to go with a bigger refactoring of the app. I have a few ideas for the refactoring, i.e. to make it easier to add custom resources.
FailFish &amp;#x200B; thanks alot
I don't really have time to pour over all that, but I'd recommend not trying too hard to do it yourself and using something like [certstrap](https://github.com/square/certstrap) to do the certificate management. If you do that, and you still have trouble validating certificates in the way you'd expect, I'd recommend either replying or posting a new post, with the exact sequence of commands you used to generate all the certs with that tool (minus any personal information you may have put in it). I've been doing a lot with SSL over the past couple of years, and I think the best way to understand what you're doing with it is actually to sort of back into it, by using progressively lower level tools as you need them over time. Trying to start by generating your own CA directly with raw APIs and signing certs with it and then validating them is a lot to bite off and chew. If you're having trouble, I'd recommend using a tool to do everything except the validation, then you can just focus on that more easily if you still have troubles.
Because many platforms (and ARM as well) doesn't provide memory barriers around accessing one byte of memory. That means, while you can safely read/write boolean value itself, you cannot rely on its value to make decision about reading other variables.
Well, strictly speaking, there is no "lightweight" memory barriers for 1 byte in ARM. Although you can always use explicit full memory barrier, but it very expensive. And Go doesn't gives you access for it.
I found this https://github.com/golang/go/issues/24034 it doesn't fully explain the bug but it is another aspect of the same bug. the original bug report talks characterises it as performance issue but in reality is more than that. As you see someone a little bit down the page mentions it as a permission issue too. For us what is happening is that since go 1.10 when we use -linkshared the resulted .so packages are ignored later on and any -buildmode=shared builds fails to find them and instead statically links to the library. For our product and in order to keep the size of the binaries small we use -linkshared not only for std but on all our own libraries and then build the rest of the code using buildmode=shared. What we end up having this way is very small binaries and a bunch of common library files. We then deploy the so files and our binaries separately to the end user. Since 1.10, despite the fact that linkshared generates the libraries, go builder never links to those libraries (so files). It seems as if go does not check the dynamic linked library paths or if it does for some reason it can't find those files. I am more than happy to provide more in-depth info but as you can see in the same github issue, it is mentioned that the part of the code relating to dynamic linking is so messy that no one wants to touch it.
A channel is an exactly-once, typed message bus. It is suitable for use in Go all over the place, so it's deeper than "microservices". The whole CSP-inspired design is based on that, and one of the nice things about testing Go code is when you have a piece of code that communicates over channels, you can write tests that drive just the channel/message bus directly and ensure correct behavior. I will agree that event sourcing is a bad fit for Go right now because without generics it's hard to work with. You have to have a use case where it's very important to you to make it worth the pain of implementing. (Event sourcing has very similar problems to providing a library that helps you set up channel networks.)
Ah I did notice that as well, however gave Go the benefit of the doubt and didn‚Äôt mention anything. I‚Äôm glad you have the issue resolved now :)
I work for a bank. It's all about cutting costs. Certain high level directors made the decision to use Java as first choice when it comes to greenfield projects. Essentially, you must use all things Java unless you give a very good reason to use another technology. &amp;#x200B; The higher ups logic is this. You can find Java devs everywhere. If not, just get some H1Bs. &amp;#x200B; The only redeeming quality about working in fintech is that it paids very well.
Stopped reading at string based events. Strings like that are undiscoverable. Provide proper types, string typing is terrible
Ha! That'll teach you to over estimate me!
Haha it was actually Go that I overestimated:) I don‚Äôt know you, therefor I have zero ability to judge lol
Ah, fair. I misread your comment.
Sounds like an extreme corner case considering you're choosing to deploy in a way directly contrary to the core Go design of static binaries.
Do not take it too much at heart either, comment it as you feel confortable. Do it your own way, improve it when you feel it's problematic, or see a better pattern in someone else code.
Oh I'm not don't worry! But thanks!!! I think it's a spectrum of the lean philosophy over to perfect engineering! The art is finding the balance in the middle! I'm proud is not perfect when I released it. It's all too easy to sit and write code and find excuses on things to change without getting feedback...
CAS is compare and swap, where the swap will only happen if the current value is equal to the test value. The test and assignment happen atomically together, and it will fail if it doesn't match.
I just did this at my work, calling ansible + aws cli commands. As /u/jerf mentioned, it's easiest to just use the os/exec package to actually execute. As far as running them, I found it easier to write structures to abstract different types of commands for what I needed.
I understand this is a controversial design decision and I may retract it if people really don't like it. However, there are some benefits, namely: 1. You can pattern match on a prefix of an event. This is useful to filter out a whole category of events. 2. They aren't discoverable, but can be described in a few lines. Compared to event types that pollute the API. But give it a shot anyway, I may get persuated to change this decision :)
\* The caveat is that if you don't want to have to copy-paste a five line `grow` function, I have a reflection-based version you can use, so that has an `interface{}`, but I think it's a testament to how much you can do with just slices and lateral thinking.
Why is a larger binary a problem?
What if I want to use it later?
Check https://github.com/argoproj/argo
In projects I develop, I always have `main.go` files that will generate binaries in their own folder (with the same name as the binary the `main.go` in it will produce), under a `cmd` folder. I don't have `main.go` at the top level of my projects. i.e. cmd/ binary1/ main.go binary2/ main.go README.md If those binaries are complex, maybe I'd make a package named after them to flesh it out more, but that `cmd` folder wouldn't change.
[removed]
Couldn't you take the middle route and keep the string matching but offer a set of constants which would then offer discoverability? This way you keep the pattern matching but you can document and expose the functionality
Hm. Trying this build, I get this error : ``` bash: /data/data/com.termux/files/home/Applications/go/bin/go: No such file or directory ```
You can still do the first point with type matching and then filters on the data inside. And the second point makes no sense. Polluting the api? Your api IS the types. As it stands you have no api, you have magic strings. This would never fly in any serious repo. I hate to be harsh but I am sick of seeing libraries like this, especially in the go ecosystem
That would be a valid concern if Go didn't automatically import them when you press `CTRL` + `S`.
[removed]
[removed]
This is not a bug and unlikely to change as it is a feature of the language. Quoting the [The Go Programming Language Specification](https://golang.org/ref/spec): "It is illegal for a package ... to directly import a package without referring to any of its exported identifiers."
Alright alright, I will make it types, don't worry ;)
Use net/http.
Thanks. It's what I used.
Embedded system is my guess. Not everyone has GBs of space.
Pretty neat. &amp;#x200B; (Also, the images for the X-Y tables are all the same)
For scanning just a specific pair of tones, a Goertzel filter is probably your best bet. You can use io.MultiWriter to pass the sample data simultaneously to your output and to your filter. If you build the filter on the Writer interface, you should be able to fit it into your pattern fairly smoothly. As indicated by the number of implementations I linked above, a Goertzel filter is fairly simple to implement from scratch. As I stated in the source, I based my implementation on https://netwerkt.wordpress.com/2011/08/25/goertzel-filter/
Perhaps... I'm thinking about how to solve this.
fasthttp doesn't actually implement HTTP, you shouldn't use it unless you can explicitly justify why your performance needs outweigh the cost of using a nonstandard broken HTTP implementation.
Thank you so much. This has gotten me started. I will update as I progress through my project.
absolutely. the times i've seen fasthttp used it was because someone saw, "fast" and equated that with well written, standards compliant http server, that is fast. `fasthttp` is just fast. it is neither well written nor is it standards compliant.
I currently just have 1.25 Is it worth the upgrade?
Go isn't a good fit for embedded either way.
Well said. Some of my first Go code interfaced with command-line packages and I can attest to what /u/jerf is saying. Exit status codes? Text? Buffering? Streaming responses? Input?
&gt; group := Group("build") &gt; group.Beginning(). &gt; Then(Cmd("go-list", "go", "list", "-f", `"{{.ImportPath}}%{{.Name}}"`, "./cmd/...")). &gt; Then(Transform("filter", filterPackages)). &gt; Then(ForEach("go-build", func(name string) Attacher { &gt; return Env(Cmd(name, "go", "build", "-ldflags", formatLDFlags(), "-a", "-o", "./bin/[[ .Result.Value.Name ]]", "./cmd/[[ .Result.Value.Name ]]"), bo.env()...) &gt; })) I'm personally not a fan of this style.
Close, Go tooling itself does not do this but your IDE tooling is.
I'll follow this project. I find it very interesting. Good job.
Nice article there
as "new" to golang as you said, use net/http is good choice. net/http inside go "standard lib" is fast enough. &amp;#x200B; Regarding the conclusion that fasthttp is not "standards compliant", it is just some words to listen, don't take it too seriously. &amp;#x200B; Especially in a future business scenario, when you really need an ultra-high performance http implementation, you will evaluate the "standard" net/http and "fasthttp", and others similar implementations. &amp;#x200B; Just like chrome implements a non-standard http call "quic" , now , maybe it's be call "http3". &amp;#x200B; Fasthttp implements the standard http protocol, but different from go's net/http lib.
The path of `goimports` is literally [golang.org/x/tools/cmd/goimports](https://godoc.org/golang.org/x/tools/cmd/goimports). You can't be more "the Go tooling itself" than that.
Send me an email and I can help! todd@greatercommons.com Sincerely, Todd
:)
It is a fantastic project! It seems like both Argo and Rosie should work very well with each other as both are focused on different things. Rosie being low level-level and Argo a high-level solution.
 I really enjoyed the article on Home automation with Golang and IKEA Tr√•dfri, It's nice to see fun projects as well. Glad that I have subscribed to Go Weekly.
Just to add to this, it's very likely that in a real situation something other than the HTTP server itself would be your bottleneck. JSON marshaling is a possibility, but DB and other network calls are up there. Just designing APIs so that you can have high volume requests be based on public information to allow some CDN caching with a low TTL could be a bigger win than a thousand requests per second per machine.
Probably want tot try /r/GolangJobOfferings
Thanks. I went with just using net/http after reading up, it seems like the consensus choice and with good reason.
Full stack non-junior dev for 85k/yr? What made you set that price range?
Thanks for sharing. Like that you wrote a flow chart and spelled out the functions of each encryption file. I've thought about a similar service with a dumb server API which simply SET/GET the encrypted payload on S3/B2 for clients.
Use a goroutine and push keyboard inputs through a channel...
What about it do you find that is not well written?
All is good now. Thank you very much for your support.
You are not wrong in that is is located there, however it is not part of the standard command line tooling provided by \`go &lt;command&gt;\`. Unless of course this has been added in the last few releases and I was not aware.
I used this for a project a while ago and it did the job https://github.com/jroimartin/gocui
&gt; The way the examples are written Which examples? The ones in the README, or the ones in the examples folder? The ones in the README are solely for the simplicity of explanation, but I believe the ones in the examples folder show definite benefits. &gt; Closing the channel from env.Draw() makes concurrent use trickier. It seems like the "blinker" mux example is racy; run can close the channel while Blinker sleeps and draws. It is not racy. The Envs created by a Mux don't send and receive directly from the channels of the original Env. There's some orchestration going on. Also, closing the Draw() channel of the master Env of the Mux doesn't close the Draw() channels of the rest of the Envs. Their draw calls will simply get ignored until they shut themselves. &gt; That sounds scary. Backpressure is usually a desirable property. It usually is, but I believe events are a different case. That's why I quite lenghtily explained in the docs: https://godoc.org/github.com/faiface/gui#MakeEventsChan. In short, production of events in infrequent and irregular and should never out run their consumption in the long run. However, it can outrun their consumption temporarily and that's why the unlimited channel is useful here. &gt; Every widget having to filter which clicks belong to it seems less than ideal. There is nothing preventing a creation of layout systems that do that for you and I want them to happen. &gt; I question the sanity and readability of func literals returning func literals. You can make a global function if that's unreadable. Do you have a different solution? &gt; There's probably a lot of lessons from 8¬Ω and /dev/draw to be applied here, http://doc.cat-v.org/bell_labs/concurrent_window_system/ et al. That's a lot for this, I was searching for this document and couldn't find it. Will definitely read!
For a very simple solution, you could set up a scanner on stdin and scan in a loop, e.g.: \`\`\` package main &amp;#x200B; import ( "bufio" "fmt" "os" ) &amp;#x200B; func main() { scanner := bufio.NewScanner(os.Stdin) for scanner.Scan() { fmt.Println(scanner.Text()) } &amp;#x200B; if scanner.Err() != nil { // handle error } } \`\`\`
Thank you!
well -- there was some really misguided coarse timer code that left it broken for a really long time. i think it has since been removed but it caused all sorts of odd and broken behavior and the bug that was opened for it languished for over a year.
65-85k lol
This is trivially solvable by making your custom types satisfy the Stringer interface, which gives your users the best of both worlds.
Someone just recently posted this in another thread and it looks really neat for composing complex command pipeline logic: https://github.com/travelaudience/rosie
Cool. Thanks for the heads up. I didn't know about it and I didn't look to see if it already existed. I've been learning the reflection package and getting into code generation. Do you have any feedback on the package/code? Anything I could change or do better?
What aspect of the API you have in mind and how would you do it differently?
So that's how it began. Its just a text formatting program, NOT an operating system :)
Think they now work together for part of the year. Brian is now part time at Google is my understanding.
rob pike owns the website [robpike.io](https://robpike.io), he uses it for his Go libraries including \[ivy\](https://robpike.io/ivy)
A (not so new) overview is here: https://appliedgo.net/tui/
This is a very neat idea! Have my upvote. Is this concept used in any popular package?
That would neat!
Permissions looks weird ( 700 ).
85
Not yet because I wrote it this week.
I love pixel and am looking forward to trying this, good work on everything
Would it be better to say it was not maintained? I don't concern myself too much about a bug in and of itself, but I definitely agree with you if it is a persistent and languishing issue.
double the salary
The salary is very low for a mid level golang engineer. You make more than that as an entry level employee even outside of engineering.
Parser generators.
What is the ideal point at which to start using Dihedral? From the earlier Reddit discussion [here](https://www.reddit.com/r/golang/comments/9ofrjl/dependency_injection_wire/) it appears that even using Wire is overkill for smaller projects. At what point does the cost of using Dihedral exceed the benefit as compared to writing your own constructor functions and wiring everything up some place such as **func main()?** Also, if you have used Wire before when would it make sense to choose Dihedral over Wire? Alternatively, what are the main use cases for Dihedral?
I really appreciate the writer being completely honest about the current state of Tensorflow in Go. Just because we can do something in Go doesn't always mean we should! I suspect that Python will be the language of choice for machine learning in the near future. That sort of orchestrative task is exactly where Python excels.
It's an X.509 certificate, not an "SSL" certificate. SSL isn't even used anymore. It's insecure and was replaced by TLS over 20 years ago.
I've used this, it's pretty simple to use.github.com/nsf/termbox-go
I am the only person that hasn't contributed to that issue report and as I can see there are many people who do that, how did you come up with that conclusion that our company is the only one in the world that has that problem? Why do you think that is then against the core design of Go? Why is something that has been officially a part of Go since 1.5 and is still a part of official go documentation against core go principal? How can you be so illogical yet so sure about yourself?
It's a work-in-progress. The content I've written so far I think is pretty good, but obviously there's a lot more I need to add.
But that's what I look like :(
You can probably use pandoc to do this, but I haven't played with it.
*bows*
### To answer your primary question specifically: Go has a much nicer \_deployment story\_. You compile a single static executable, and copy it to a server to run it. That's all. Your servers don't have to pull in framework dependencies and keep them updated. Moreover Go supports a lot of compile targets Go has better \_concurrency\_. The language primitive for running things in parallel is simple and effective in Go, allowing you to split execution over many cores of a CPU readily. Go has higher \_throughput\_ in [common web framework benchmark scenarios](https://www.techempower.com/benchmarks/#section=data-r17&amp;hw=ph&amp;test=fortune&amp;l=zijo5b-1). Go has an [enforced common style and syntax](https://golang.org/cmd/gofmt/) which can lower style friction especially in larger teams. No more arguments about newlines for function arguments or not! ### However... If I may guess at the question behind your question; unless you are working on a project that already has pain points or scaling issues with any of the above, you don't really have to find "THE BEST" language + framework. You need one you or your team can use readily. As Ruby fans correctly point out, even though Ruby is a slow language, it is generally "fast enough". If a project gets very large and/or under high load, it can be migrated then. So the relevant question may really be "Which language best suits me or my team?", not "Which language is technically more run-time efficient?"
&gt; to me this sounds like Go is better at running multiple for loops at once vs. Node.js single-threaded nature Not mainly. It *is* a consideration, but it can be counteracted by running multiple node-processes. It's more that Go's deeply integrated runtime and language mean that you can write code that runs efficiently without adding significant complexity to the code. A Go http handler that just synchronously reads files or does backend-requests will still benefit from asynchronous IO and use the available compute resources efficiently. Because Javascript *as a language* doesn't have first-class concurrency-support, this has to be done by chaining callbacks and/or using promises or other constructs in node. i.e. sequential logic in Go looks sequential, even if it is asynchronous under the hood - whereas in node, even sequential logic always *looks* asynchronous, to run efficiently. &gt; they'll both have to wait that same 100ms-500ms for the request/db/response roundtrip, won't they? This is true. But in-between IO, there still needs to be some computation happening and in node, that is fundamentally limited to one thread per process - whereas in Go, you can have as many parallel users of the CPU as you have cores, even in a single process. That being said, I wouldn't put too much stakes into performance comparisons - among other things, node has a pretty performant runtime and given that it can use JIT, it can theoretically optimize code better. There probably are cases where one or the other will perform better. I would put more thought into how the languages compare when developing.
We have around 100 different binaries and the final package size this way is dramatically smaller. Another thing that we experienced is that this way the memory footprint is much lower and we can have our servers run on smaller VPS.
You're bound to get issues with Tensorflow. Just use [Gorgonia](https://gorgonia.org) :P
From your username, are you in China? They block Golang.org, see https://golang.google.cn which is available. Otherwise, I would expect it to be only temporary.
`Scanf` is very user unfriendly. I wouldn't really recommend using it. Try https://godoc.org/github.com/manifoldco/promptui or https://github.com/gdamore/tcell depending on what you're trying to do.
not in china. in california. i figured its a temporary outage but still confused.
Yea you‚Äôve clearly never used `pprof`
Would a custom `gofmt -s` not do the trick? Honestly not sure w this one.
thanks r/jerf. I am using just stdlib and trying to avoid other libries. But I was just not confident that I was doing it right way. Thank you for great advice.
Thank you. Informative. I'm newbie, moving from python. Great news that we are able to run (sure debug as well) individual test case. Impressed
It's cool! That said generics would be useful so that your library could also encapsulate the storage.
The problem of case based testing is that you can only prove that your code works in some situations. Actually, I think in many cases \[Property base testing\]Ôºà[https://hypothesis.works/articles/what-is-property-based-testing/Ôºâis](https://hypothesis.works/articles/what-is-property-based-testing/Ôºâis) even better than table driven tests. It not only give you more confidence that the code is properly tested, but also forces you to think the invariant of your code.
what does running `ldd` on it say? Not sure about Macs, but on linux you can get this error if a shared library or the loader does not exist.
Got it. Thank you.
Has anyone got it to work on Windows yet? I error out everytime trying to create a project. [https://github.com/wailsapp/wails/issues/77](https://github.com/wailsapp/wails/issues/77)
`objdump: 'a.out': No such file` I'm not sure how I feel about that
Node handles concurrency as well. It handles it by switching only once a callback is completed. It‚Äôs a runloop, or event machine. Go handles concurrency with parallelism. It spawns threads that use cooperative multi tasking, but also rely on the kernels preemptive scheduler. This means it can be responding to multiple requests at the same time, and not sequentially. Since it handles many requests at the same time, it doesn‚Äôt need to rely on tricks like node does since the kernel scheduler already does a great job of this (within the context of goroutine cooperative multi tasking). You can use multiple processes for node to add a sort of parallelization , but if any one of them ends up being CPU bound, it will cause a significant delay for requests that have had the misfortune of landing on the same process. Go is also compiled as others have mentioned. That makes startup times much faster. Javascript has a JIT compiler which makes it faster than it has any business to be, but that‚Äôs still not the same as being proper compiled. It‚Äôs also fully Type safe. You have to do nasty things to make go break types, so it makes code a lot safer. I remember the first time I build a go program, and once it compiled, it sat there running for a year without crashing. As long as my logic was correct I wasn‚Äôt worrying about some strange object getting into weird places. So the long and the short of it, is go handles concurrency under a much better paradigm. This was a solved issue long before javascript was even a thing, and they tried to be clever and solve it in a language that is inherently single threaded by using some clever hacks. They did a good job making it work as well as they have, but it‚Äôs naturally limited because of that.
Question: Has anyone got it to work on Windows yet? I error out every time trying to create a project. [https://github.com/wailsapp/wails/issues/77](https://github.com/wailsapp/wails/issues/77)
just a heads up that python's pytest supports test tables via `pytest.mark.parametrize`
Did you download the exe or use go get?
If a software project was a glaring bug that went unacknowledged for a long period of time, what would you call it other than poorly written? If that is not the case, then any poorly written program could be considered a merely poorly maintained one with some eventual fix? Sorry if it seems like I'm focusing on semantics here but I'd like to equate poorly written and poorly maintained. I'm open to the fact that I could be wrong, I think I understand your point, and respect your opinion.
Docker has made the deployment story for Node easy. Just build an image with the dependencies and deploy that image to all servers. That flow can be used for any language (including Go).
I'm not entirely sure I understand the question, but I hope this helps. We create a goroutine which will continuously capture stdin and print it back to stdout. Meanwhile, our main function continues with an endless `for` loop, printing out '...' every 5 seconds just to prove that the stdin scanner is not halting the rest of the program. Goroutines are super important and it's definitely worth devoting time to learning how to use them. package main import ( "bufio" "fmt" "os" "time" ) func main() { go func() { fmt.Println("Type whatever you want!") scanner := bufio.NewScanner(os.Stdin) for scanner.Scan() { fmt.Printf("You typed: %s\n", scanner.Text()) } }() for { &lt;-time.After(time.Second * 5) fmt.Println("...") } }
&gt; This means each time we run go test, our tests are going to be potentially run in a different order. \* As long as you remember to add `-count=1` to your cli flags to `go test`, since Go now caches test results.
go get
The [intro to Hypothesis](https://hypothesis.works/articles/getting-started-with-hypothesis/) did a far better job explaining to me what "property based testing" is. I think table-driven and property-based seem like they test two very different aspects of a function. The former ensures that your algorithm is correct and works how you want it. The latter seems like it'd be great for catching edge cases that were forgotten. I might have to dig around to find a property-based testing library for Golang to add into my workflow.
This. As a software security engineer, in my experience developers are good at writing tests for the expected ‚Äúhappy path‚Äù use cases, but often struggle with testing for the unexpected _misuse_ or _abuse_ cases (if they test for these at all). IMO, property based testing, especially when done with the assistance of generators like hypothesis provides, makes it easier for developers to write tests that catch these negative edge cases since the generators can provide some of those cases automatically
\&gt; bigger win than a thousand requests per second per machine I did some benchmark the other day for the sake of having an idea how much the my http server could handle, a few thousands per seconds no problem: [https://github.com/mickael-kerjean/filestash/wiki/Benchmark](https://github.com/mickael-kerjean/filestash/wiki/Benchmark)
So i like the General concept but the 'returns -1' reminds me of c style error reporting. Is there a reason not to use errors?
I might be wrong on this, because I'm a fairly new gopher, but I'm pretty sure the '^' operator is a bitwise XOR (Exclusive Or). Bitwise logical operands compare strings of strings of binary bit by bit and and output a new string of binary that is comprised of the results of each logical operation.
https://golang.org/ref/spec#Arithmetic_operators It‚Äôs a bitwise XOR.
hey, curious, which image are you using to build go? I have some problems when using golang docker because it's default workdir is not in GOPATH
Poorly written and poorly maintained are definitively distinct issues, both equally bad. The best written code in the world can still be unmaintained and the worst code in the world can be patched and fixed.
this is not Vim, this is spacevim which is running on top of NeoVim and modeled after spacemacs vim-go is pretty much all you need for Go developement
&gt; they'll both have to wait that same 100ms-500ms for the request/db/response roundtrip, won't they? We target single- to low-double-digit millisecond in-server request/responses latency and frequently see sub-millisecond for very simple operations.
Easy, but not light-weight... Our containers are frequently less than 10 MB!
If all you need is powers of 2, just use bit shifts: ``` 2 &lt;&lt; 9 ```
[Text version](https://dev.to/plutov/building-desktop-app-in-go-using-wails-1poh)
Alpine images can help but can't really compare an entire operating system with raw code bundled inside to a single executable. Can still build images under 100 MB. Disk space is cheap anyways.
yeah spacevim is a config for vim and neovim. use same idea as spacemacs: manager plugins within layers. the go layer inclued vim-go plugins and some other config.
&gt; I tend to prefer going with `T.Errorf`, which (unlike Fatalf) continues test execution and can gather up additional failures You should use `Fatalf` when testing for eg. a precondition error that makes running further tests pointless.
Returning an error would make typical usage of this library much more laborious. slice[dequeue.PushHead()] = "foo" vs i, err := dequeue.PushHead() if err != nil { return err } slice[i] = "foo"
Awesome article, it makes me want to use Go instantly!
I use [nvi](https://en.wikipedia.org/wiki/Nvi) for my Go programming.
When using cmp (or any diff package) you should include a key, like "output differs: (-got +want)" to make it clear, otherwise this can have the same problem as many expect libraries where you just know "3 != 4" but not which one was correct. I also prefer the stdlib's ["got before want"][1] pattern with failures being written like "Foo(inputs) = g, got w" [1]: https://github.com/golang/go/wiki/CodeReviewComments#useful-test-failures
I see, but if you use your library like that it will panic if you didnt make sure there is still an element in the deque right?
Take a look here: https://stackoverflow.com/a/43766155
I think it depends on what you want to do. You should find the programming language that match your application's domain, not pick one tool and use it everywhere. If all you have is a hammer, everything looks like a nail.
What you're looking for is probably a `factory` that is capable of constructing a reader for a given URI. Using a function as a factory is an ok approach, but you may want to use an interface instead. For instance ``` type ProtocolHandler interface { ReaderFor(scheme, uri string) (io.ReadCloser, error) } type ProtocolRegistry struct { Handlers map[string]func(string) (io.ReadCloser, error) } func (reg *ProtocolRegistry) Register(scheme string, handler func(string) (io.ReadCloser, error)) { reg.Handlers[scheme] = handler } func (reg *ProtocolRegistry) ReaderFor(scheme, uri string) (io.ReadCloser, error) { return reg.Handlers[scheme](uri) } ``` I've omitted some error handling, but that should be trivial to take care of. You can use this pattern to define and register different handlers and then pass this to your encoder/decoder instead of the callback. (Also note callback here doesn't make sense. Callbacks are functions that are called for returning a result, not foe decoupling components, like you are doing here)
The standard library has `testing/quick`
Thanks!
First shot for replacing the cli.Context: [https://github.com/SimonBaeumer/goss/pull/55/files](https://github.com/SimonBaeumer/goss/pull/55/files) At the moment only created a custom cliContext which is a little bit easier. I will try to move the context out completely step-by-step. :)
This is the kind of answer I was looking for, thanks!
[removed]
I'll use the opportunity to plug the [rapid](https://github.com/flyingmutant/rapid) library I've been developing. It is heavily inspired by Hypothesis and tries to retain everything that makes Hypothesis IMO the best property-testing library available, while integrating with familiar `go test` / `*testing.T` workflow. Rapid is currently in alpha: while core features are quite solid (except for the quality of floating-point generators), documentation is almost entirely missing and examples are few. However, I'll strongly advice against using `testing/quick`, which is totally inadequate for real-world property testing.