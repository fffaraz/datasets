I do both. Usually I have to start the project today, so no time for #2. While working on the project, I become more knowledgeable and will go back and update things depending on what I've learned.
&gt; The idea that a try/catch block requires "looking in a million places" is absurd on its face. It's not absurd at all. The other day I spent way too long looking for an error in Magento 2, and the problem was an exception that someone added, that wasn't being passed upwards in any way and was wrong to be an exception to start with. Result: I now have to have edited code in the core files.
Depends on what it is really. When I first learnt Docker, I only had tools like Vagrant to compare it against. I was relatively new to operations in general. I looked at tutorials, and docs, and just specifically set out to learn how to use Docker to containerise things I'd already built. If it's a language, generally I try make pet projects with it. If it's something I have to learn on the job, and there's no time for that, I'll just Google how to do specific tasks. Working with most languages involves similar things; dependency management, common libraries, building / testing / deploying, etc. I rarely buy books anymore. I have in the past, and some have been great, but the ones that have been good haven't been about specific tech or languages, they've been about how to think and act as a good developer (e.g. The Pragmatic Programmer). For learning tech, I tend to use documentation, and focused blog articles. There are exceptions to how I approach this stuff though. I'd compare the experience I had learning Scala vs. learning Go. I did actually try take a course of Scala (the Coursera one by the language's main creator) - I spent about a year with Scala overall and spent a lot of learning and not really building anything useful with it. For Go I just followed the tour, and then dove into building stuff.
You can become pretty good at a thing in about 20 hours. But it's going to take you 5000 to become an expert.
How would someone get started in something like this? Any resources?
I second this. This is how I learned Go, or any programming language/paradigm. I started hacking together the functionality i wanted, and gradually go-ified as I read books/blogs etc.
For Docker? Docker communicates via Rest internally, have a look at the calls and it‚Äôs engine's api
You are going to find template languages used for pretty much every framework in every language (C#, Python, C++, Node, etc) when designing a website UI except for when you're writing a SPA app (Angular, React, Vue, etc--since these provide the template concept for you). PHP started long ago as only a template language and became full featured and then limped towards modernization later, which hurt some things such as consistency and cemented some bad practices for some people. There isn't anything wrong with templates. HTML itself isn't typed, so people have put a lot of work into making it easier for you to develop a web UI without resorting to making your own functioned to concatenate strings. **Does anyone?** Probably. :) There are enough of us that someone does just about everything! **One binary:** If you're shipping a product you plan to support and update, at some point you'll make a mistake that you can correct via shipping a new template file to the one or two customers affected by that bug while others wait for the normal update process. If you want to ship all the templates the binary anyway, then I'd just bundle them into the exe before shipping with one of the many tools available. If you build everything in strings and functions, you'll eventually run into more and more media formats and other files that are annoying to manually include in your .go files. **Performance:** Probably not. If some html is a string in the binary, then it is loaded from disk at launch. When I use templates I usually load them from disk at launch. If I'm developing, I usually add a flag to reload the template every render so that it's fast to develop and performant to serve the production file. You could get more custom and complex too, of course. **Type safety:** Maybe, but you're also relying on your own code instead to looking to the work of a large, skilled community that built the template library for you, so I'd anticipate you'd have a higher bug count, and you might fin d a lot of inconsistency as you iterate towards finding the best approach. I would also assume that the solution you develop would wind up being about the same except with large strings in your source code instead of other files. One final note is that I recommend you look at Goland. I think that IDE now examines the templates and gives you some more safety on the IDE level. I could be wrong as I mostly use Angular instead of the Go template, but I think I saw that in a release note.
for a JS VM? -- I know docker pretty well, not referring to OP's post
Play with it. Mess around with the options. See what doing things does to your system. Understand the side effects of your tools.
https://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf This is the specification pdf
Kinda off topic-ish but I Wish there was some way to get APM metrics from code without explicitly having to define where the spans start / end ..
Great overview üëå
Hey, you need to escape special Markdown characters, because currently it looks like you are screaming.
I agree, I‚Äôm the exact same way. You and I understand ‚Äúcapable‚Äù but there are people who are not ‚Äúcapable.‚Äù
Sorry. How do I do that?
For the vast majority of errors, a stacktrace is exactly what is needed. An error that should be supplemented with additional information is rare. Either way, a stack trace should be the minimum standard for error output, and like I said, anyone in an ops position who can't read one is woefully unqualified.
For how everyone says checking an error is ugly, doing a defer on the error value is vastly worse.
I believe it‚Äôs going to happen. It‚Äôs in a sort of ‚Äútesting‚Äù mode, where they‚Äôre monitoring how many people use it. So many people don‚Äôt even know about it yet tho.
Someone in the future might have the same problem, so that future person will be very disappointed if they read this whole thread and you never mention your fix. ;)
Eh, no. A stack trace is useful for developers, but not for users or sysadmins. They‚Äôre not going to get neck deep in code to figure out what‚Äôs going on. They want a descriptive error saying what‚Äôs happening. What line the error happened in the file it‚Äôs trying to parse is useful. An error saying function ‚Äúparseline‚Äù failed, is not.
I personally learn best by experimenting. I try to build something using the thing I'm trying to learn, lightly skimming any combination of docs, recipes, blogs, etc only when I get blocked. I don't dig deeper into learning best practices until after I'm able to build something functional with the tools, I find that helps add context to why those practices are "best".
Original Post, courtesy of removeddit: &gt; Rob Pike will betray his original intentions for the language by making changes to this construct. &gt;The key point here is our programmers are Googlers, they‚Äôre not researchers. They‚Äôre typically, fairly young, fresh out of school, probably learned Java, maybe learned C or C++, probably learned Python. They‚Äôre not capable of understanding a brilliant language but we want to use them to build good software. So, the language that we give them has to be easy for them to understand and easy to adopt. ‚Äì Rob Pike
I'm the author of this article and maintainer of SourceHut, if you have any questions. Hope it's okay to post this here. I was really pleasantly surprised by how easy this was to put together for Go. The language tooling in the stdlib is *really* top-notch.
Your scenario doesn't really lend itself to learning something "deeply." If I have to use something for a project at work, I need "minimum viable competence," not "deep knowledge." For example, a while ago I had to quick-learn up React and Redux. I was adding features to an existing project that had already been in use for a couple of years, and the turnaround on the features I was adding needed to be measured in days, not months. To get myself up to speed, I followed a handful of "hello world" type React tutorials, and one where I built a game of tic-tac-toe. This gave me familiarity with the overarching concepts of React. After that, I dove into the code and started looking at places that were already doing something similar to what I needed to accomplish, and modified those examples to do what I needed. There was some trial and error, but really, programming is programming. I might not know React as well as I know backend programming, and I'm sure the code I turned out wasn't idiomatic React, but it worked, all my integration tests passed, and the customer rep signed off on the features. So I "know" React now, but I don't *know* React, not like someone who's used it every day for years. Because *that* is how you learn something deeply. Constant use. Grease the groove. Use it over and over and over again until it's muscle memory. Make mistakes, and keep making mistakes until you learn to see the traps before you step on them. And that, coincidentally, is how I describe a senior engineer: someone who has learned from enough mistakes to be better than the guy she sits next to.
* would start the concept in paper for the work. * Watch some tutorials &amp; blog with regards to basic * Perform some trivial task . * Start actual work, try to learn how to use the documentation in the mean time. * learn as you build approach. this is the approach i follow for learning.
I find just starting risky, learning first good but I wouldnt expect to then just be able to start the project and go. &amp;#x200B; I would add a 3rd option of prototyping. In fact its a great accompiant to reading about a tech as learn by doing is really how you build up the experience to tackle something. &amp;#x200B; So protoype a section of the project, or even make up a very simple project or projects of your own to explore the relevant area(s) of the tech. Coupled with some reading you may be able to prototye some of the key areas of the project or even make a proof of concept which will make writing the thing much quicker so its not exactly wasted time.
It's both unnecessarily noisy *and* easy to not do. There are better ways to handle errors than a magical two-tuple that doesn't actually enforce anything.
How does Go actually make anything safer? We still have the same ridiculous bugs from jamming data through ~void *~Interface{}, reusing pointers after they shouldn't be anymore, sharing mutable state, etc. Goroutines are fun but it's not like you don't end up with the same buggy, deadlocked code that we get in every other language. Reusing "for" to mean "while" and having the entire world reimplement ‚Äùmax()‚Äù doesn't make your code better.
Avoid the allure of forklifting code, or even writing new code until you truly understand it. That road is paved with suffering. Instead: Pick a high level mechanic that is part of your decision (i.e *why* do you need to use go, or rust, etc...), then read specific writings on exactly how Go implements that. Basically, its a hybrid: 1) Identify important mechanic. 2) Do enough of a deep dive that the *purpose* and *use* of that mechanic is clear to you. 3) Write basic implementation of mechanic. 4) Write unit tests. 5) No, really: Write unit tests. There is NO better way to learn how a thing works than to figure out how to unit test it. The time you put into getting your stubs/fakes/mocks working will pay off. 6) Seek peer review once your tests pass. 7) Rinse, repeat.
Doesn‚Äôt that then give you the freedom to enforce it then? Don‚Äôt get me wrong I love try except when I work in python, but this method in go has also felt fine to me, but it may also be because I write a lot of small lambda stuff, and not a big project to feel the effects of this
I know there is options like `godotenv` and Environment Variables and Run configuration for each Go build/Run but its not as intuitive as what we can do in Android Studio with the gradle files
Literally any approach to anything is good enough for small projects.
I have edited the answer to include my solution
[removed]
[removed]
Oh man I missed your terrible username too
&gt; I began with the C annotator, because I knew it would be the most difficult. Normally people start with the easy thing, then work their way to the hard thing!
Any plans to add annotations automatically to supported repositories ?
[removed]
[removed]
[removed]
perfect!
Looks suitably satanic ü§òüèº
I'd like to do this at some point, we'll see.
Do you have the STL?
I sure wish Go never looks like either one of those.
Haha love the name! Coz who needs celery.
I got it as a gift. I can definitely ask for it !! Will update when I get access to it.
[removed]
Certain things you can learn via method 1 and others you should try to use method 2. I know that's a vague answer but one can take a long time trying to fully understand things when the necessary knowledge to get it working is all you might need. For example, the documentation on docker can take a long time to get through and comprehend every component when you might just need an example of a dockerfile to figure out what you need for your project and extend it as you see fit. &gt; Also, can you tell me what is the best way to learn in depth or deeply so that I won't stumble on errors and looking for solutions online? I don't believe there is a way around stumbling on errors. Failure is one of the greatest teachers when it comes to programming. A method recommended to me a few years ago by a colleague I really looked up to was that if you find yourself using a library/package often take the time to go through their code, not just their documentation. Using this technique I have drastically grown as a developer and it's definitely shown on my coding style and code quality.
thank you!
Yes, go for it. The only thing that's changed since then in Go world that affects most codebases is the "context" package, which defines a pattern for coordinating hierarchies of concurrent operarions and has been widely adopted. But it doesn't invalidate anything in the book. Just keep it in mind, you can learn that later.
Because it‚Äôs designed by arrogant dinosaurs for morons. Case in point, people here are too brain dead to understand generics.
&gt; want's What the hell makes you think there's supposed to be an apostrophe there?
That‚Äôs funny, I have never had an issue understanding genetics. I should read this subreddit more often. The simplicity zealots always make me feel better about myself.
If you give clever people generics and other tools they might, gasp, use them!
Then maybe rob pike should just retire, he sounds like a miserable old man. Go eat at fancy restaurants and blow up at the waiter for being a complete idiot because you asked for no onions.
It‚Äôs exactly what he‚Äôs saying.
I get the impression he‚Äôs just an arrogant ass.
Except the alternative to go is most frequently Java. C++ is a monster of a language.
It‚Äôs incredibly condescending and arrogant.
Nah, still sounds stupid as ever.
I wonder if any old fossils called him a moron.
Because deep down people know it‚Äôs stupid, that language has its share of warts, and know that it should evolve. But they don‚Äôt like that so they just pretend generics are hard instead. Thus becoming exactly the type of person Pike describes.
So use go and ensure you never have to learn anything!
Try catch blocks are so complex they make my tiny brain explode and I have to pray to cmdr pike to return me to a language my weak brain can understand.
The book is well worth it. Also, regarding the versions, the current version of Go is 1.12.5 not 12.5. Go 1 spec guarantees compatibility of Go 1.x releases (see [https://golang.org/doc/go1compat](https://golang.org/doc/go1compat))
In my opinion you have to go the way that better fits you! Also it depends of how much time do you have ofc.
If it's the first language you write large code in large code bases (100k+ loc) it's probably way easier to start with something where you don't have to think about how the language is constructed and instead focus on your own code. Different languages are good att different things, you have to think regardless what you choose.
Except if you have worked with c# it‚Äôs probably destroyed your brain with its evil generics and error handling and features. Your warped mind will never comprehend the wonder of error handling in go.
your deferred calls are never run. try this: \`\`\` package main &amp;#x200B; import ( "archive/tar" "bytes" "compress/gzip" "fmt" "io" "io/ioutil" "log" "os" "path/filepath" ) &amp;#x200B; func main() { modemBinDir := "bin" f, err := os.Create("test-file-handle.tar.gz") if err != nil { panic(err) } &amp;#x200B; buff := new(bytes.Buffer) func() { mw := io.MultiWriter(buff, f) // gzw := gzip.NewWriter(buff) gzw := gzip.NewWriter(mw) defer gzw.Close() &amp;#x200B; tw := tar.NewWriter(gzw) defer tw.Close() if err := filepath.Walk(modemBinDir, func(path string, info os.FileInfo, err error) error { if err != nil { return err } &amp;#x200B; header, err := tar.FileInfoHeader(info, path) if err != nil { return err } &amp;#x200B; [header.Name](https://header.Name) = path fmt.Println("Header name:", [header.Name](https://header.Name)) if err := tw.WriteHeader(header); err != nil { return err } &amp;#x200B; //Can't write folders, only their paths if !info.Mode().IsRegular() { return nil } &amp;#x200B; f, err := [os.Open](https://os.Open)(path) if err != nil { return err } &amp;#x200B; if n, err := io.Copy(tw, f); err != nil { return err } else { fmt.Println("Wrote", n, "bytes to tar archive") } &amp;#x200B; f.Close() return nil }); err != nil { panic(err) } &amp;#x200B; log.Printf("len(buff.Bytes() = %d", len(buff.Bytes())) }() &amp;#x200B; ioutil.WriteFile("test-buffer.tar.gz", buff.Bytes(), 0644) } \`\`\`
Based on outside observation the community could exist of Turing award PL researchers and the core team would still ignore them.
apparently fileio is not buffered but maybe writes to your bytes.Buffer{} are? i'm not sure. either way, this fixes it.
wow.. seriously downvoted this comment many times when the above one is upvoted. üëé
I feel like I‚Äôm in an impossible to escape dungeon of complexity and it‚Äôs all your fault!
it is the best book on the subject.
All of what you mentioned helps, some more than others depending on how you learn, but I don't think your end goal is possible. The way you really master something is exactly what you mentioned--trying, learning, stumbling over yourself, and getting better. To some extent, failure \*is\* the process. I have a lot of interests and I can't think of a single thing I've learned without having performed sub-par in the past. That said, for learning a new programming language, I'd start off with the koans. This will cover basic syntax and familiarize you with the language idioms. From there, look for "cookbook" or design patterns, like you mentioned, which will help you understand common language idioms and the overall way of thinking in the language. Here are a couple of good resources for Go. [https://github.com/cdarwin/go-koans](https://github.com/cdarwin/go-koans) [https://github.com/tmrts/go-patterns](https://github.com/tmrts/go-patterns)
C is more verbose to write especially for giving instructions to the toolchain. Emscripten is by far the most primitive and the best toolchain but you need configure a lot
package main &amp;#x200B; import ( "flag" "fmt" ) &amp;#x200B; func main() { &amp;#x200B; pVal := flag.String("optional", "defaultval", "an optional value with a default of 'defaultval'") flag.Parse() &amp;#x200B; fmt.Println("the optional value is", \*pVal) }
There's a few on thingiverse, I've been printing some lately myself.
Of the errors I've cared about, much less than 1 percent were of the nature of a failure parsing a file. Like I said, the vast majority of errors require a stack trace to debug, and those stack traces are more valuable to the ops professional than to the developer because they point us directly to where in the code the problem is happening. A developer is much more likely to already be familiar with the codebase and be able to quickly find the relevant code based on a "descriptive error" than we are.
Mostly #1, for a couple reasons: 1. It minimizes the time between the start of the project to working useful thing, increasing the chances that I‚Äôll stay motivated to finish the project. 2. It allows me to evaluate the new tool I‚Äôm using without sinking too much time into learning all the ins and outs. If there‚Äôs something fundamentally ‚Äúwrong‚Äù about the tool and I don‚Äôt want to use it again, it‚Äôs much easier to cut my losses if I didn‚Äôt spend time reading every bit of documentation and every blog post. If I get through to completion with the new tool and decide that I like it, I‚Äôll go back and do some #2 so I can use it more effectively on the next project. After a few projects using it, I‚Äôll have learned just about everything there is to know.
Links added to the slides https://speakerdeck.com/campoy/an-introduction-to-go-cern
https://www.thingiverse.com/thing:1349398 This was the one
So you mean you always know every type, interface, protocol, etc specified for generic functions and can easily follow it? Not talking about trivial examples here. Go take a look Apple‚Äôs new SwiftUI and it‚Äôs use of generics. It‚Äôs far from easy to follow. Or C++, Elixir, or Haskell. All three hard to follow. It‚Äôs not that I can‚Äôt learn to use it, because I have several times. It‚Äôs that the amount of energy and time you have to put into it to not have to look things up constantly isn‚Äôt worth it at all. I‚Äôm still convinced that it‚Äôs mostly for people that only care about the theory of programming or simply loves to show off and belittle others.
Hey, glad to meet you. This is me waving my arms https://photos.app.goo.gl/hsVbAczbNk3GPesZ7
No, he starts by qualifying that he specifically is talking about people who are fresh out of school and he never says they are stupid. That information is not contained in that quote.
He thinks they are fucking idiots. Clearly. How can anyone read that and not get that he thinks these people are brain dead morons.
Very cool.
Ever heard of the K&amp;R Bible for C? gopl.io is gonna have a similar eternal role to play for Go. It's the D&amp;K Bible.
Surely this should be a git extension not it's own thing?
[removed]
[removed]
Golang has basically no undefined behavior. Golang has garbage collection, so no use-after-free/use-before-construction bugs. Golang has the concept of threading built into the language. This means that for multithreaded coding, Golang is much safer than C++ because programs can't data race (in the C++ undefined behavior sense), invalid casts from interface{} will crash immediately, and programs can't use uninitialized memory. This avoids multiple classes of security vulnerabilities. I say this as someone who has written a bunch of both C++ and Golang. Disclosure: I work at Google; opinions are my own.
[removed]
Still the best book for Go, IMHO.
Ohhh he's observing `buff` before the defers trigger, and thus not seeing the final data there. The defers still trigger, just no in time.
Oh, that reminds me of a Go question I've been meaning to ask. Is there a way to capture casting errors instead of panicking?
Thank you. That makes sense. I'm glad I'm not going crazy.
Do Type Assertions work? https://golang.org/ref/spec#Type_assertions
Wow you're green ! Are you feeling alrite ? JK. Nice to meet you fellow gopher üëã
I personally feel that func f(a, b, c int) (foo, bar int) is more *readable* than func f(a int, b int, c int) (foo int, bar int) The repetition of ints can be a bit tedious to read IMHO. Both forms however are unambiguous and hence *clear* enough to see what's going on.
Thank you!
The best, and will remain the classic. Keep it on your shelf afterwards.
You can use interceptors in the routing layer.
[removed]
Distributed and simple are usually a contradiction.. Is exactly-once execution of tasks guaranteed?
Well... You still may be crazy.
Remote option available?
&gt;if err != nil is a breath of fresh air. Increasing complexity and typing a little less just doesn't seem like a good trade for being dummy-proof and flexible. Try doesn't remove any flexibility because it doesn't stop you from using the old construct when justified. "Typing less" is also not the primary reason for it. It makes a function more concise and thus quicker and easier to understand by eliminating the overhead of a lot of boilerplate for the common case. It's ridiculous to read a go function where half to 2/3rds of it is boilerplate handling that just does what is the default behavior in a language with exceptions. It obscures the actual important parts of the function. &gt;There are things that I hate about Go, error handling is not one of them. Error handling in Go is horrible. Having to clutter up Go code with a bunch of error handlers for the common case that do what other languages do by default is bad. Having errors basically have to be treated as strings because error only has Error() string is bad. It makes wrapping errors a constant necessity because you can't rely on having a stack trace. There's also no reliable and sane way to handle a specific type of error except maybe in close proximity to its origin. Some packages provide constant errors you can compare to, but if the error has been wrapped, that won't work.
The key is that in a generic type, *you don't care about the type parameter at write time*. You want a list of Integers? Have a List&lt;Integer&gt;. You want a list of Strings? List&lt;String&gt;. List of DatabaseEntities? List&lt;DatabaseEntity&gt;. The List methods will work without regard to the list's contents (well, sort() may need you to define a comparator if you're using your own type, but that's on you to do that). Why is that so hard for Go programmers to understand?
A thoughtful article, as always. Just a small aside: &gt; Readability is nit picking about line length and variable names. Readability is holy wars about brace position. Readability is the hand to hand combat of style guides and code review guidelines that regulate the use of whitespace. I tend to kindly disagree. These are but the extremes that the struggle for readability can lead to. A certain level of readability is never wrong, and is always a good basis for achieving... clarity.
I agree with you. Readability is important, but as a baseline. You need should always (IMO) strive for a bare minimum level of readability that supports clarity. I'd always rather have clear+legible, than clear+illegible.
&gt; It was sometime after that presentation that I finally realized the obvious: Code is not literature. We don‚Äôt read code, we decode it. Well, Don Knuth begs to differ.
Python is leaking
Yeah, computers decide it but humans read it. Code is meant to be read so it should be clear... for a human
I can understand that simplicity is one of the guiding principles. But I'm still surprised how clarity goes together with lack of any const/final modifiers. After all to ensure (or understand) that something is not modified I have to read the whole relevant implementation. Or avoid using pointers, slices and maps.
Mines actually a good username. The fuck is a Moxuz?
In my engineering class, the teacher 3d printed a whole bunch of them and changes them daily.
You‚Äôre just re-slicing the underlying array. It‚Äôs not allocating or de-allocating anything. They‚Äôre both just as fast.
üëπüòà
Passing functions around doesn't smell right. If you're worried about large data being copied why not just pass a pointer to the data over the channel?
Thanks, it's one of those questions that I just needed someone else to comment on and there's no one around me IRL who would know. Did I pick up passing functions from C or something? Or perhaps JavaScript callbacks have left a mark....
No worries, happy to rubber duck. Another thought, why not just put the goroutine reading the file in charge of writing it to the database?
I don't disagree with what I think his overall points are, but perhaps he should spend some time on clarify with his blog articles :p
Hmmm I have thought about that and have avoided it current as the routing is part of a package that I didn't want to know about the database. Just manages everything to do with the file changes. I have a manager that handles all the sticky taping of parts together....
No, 105 lines of code to *create* the error types in `os` (all three of them). I don't want to *use* PathError, it pertains to things that have nothing to do with anything that exists in my application. But if I want to follow the same pattern (which is what I assume you mean by "doing it right") for things that *are* relevant, that's what I would have to duplicate ad nauseam.
ah! good catch. was trying to understand this behavior.
These sound like configuration parameters to me, typically they should be provided in the environment, or a configuration file, or possibly command-line arguments (if they're non-sensitive).
If you are using go modules this should not be the case. Dependencies should be put in `$GOPATH/mod`. Also, using go modules should give you a go.mod and go.sum to store dependencies and versions.
Do you have more information about this?
I completely agree with the principle, but there's a lot more Go could do to support clarity. Mostly better support for abstraction. Go tends to be verbose. It is readable, but too much code is also the enemy of clarity. Looking forward to some of the upcoming improvements as the language matures.
You can also use the older vendoring technique. There are still reasons to do this (privately hosted dependencies, but deploying to Google Cloud Functions, for one example). I tend to submodule them when using git, single source of truth, but specifically versioned at a hash of your choosing. Modules seem to be the way to go if your workflow allows it and you are on a recent version of Go.
Care to elaborate why? I'm willing to keep an open mind to other perspectives, but for the record I think both are equally terrible, though one allows me to see error handling at the head of the function when organized properly, and the other forces me to weed through a plethora of branching. If you have experience with languages where you have well-built exception handlers, golang is one of the most annoying languages. I get the goal is to be as explicit as possible, but equating this with "easy to use" is one of the things that baffles me the most. I'd actually say error handling in golang is a textbook example of when "simple" is not "easy". \`try\` sets us up to more easily perform call nesting to clean up code as well, which I'd argue is much more of a benefit. It's not like you can't use the current way of checking errors, and arguing over an extra feature like this is imo like saying "Why have if-else if-else if you have switch?" I really don't understand the blowback over this proposal. As is, golang is a solid 3/10 for error handling, right down there with C
I just upload my go.mod and then when someone builds it just downloads all the dependencies for them.
The major changes from 1.5 to 1.12 (where I'm defining "major" as meriting mention in the book): - 1.7 added the `"context"` to the standard library (previously was `"golang.org/x/net/context"`. New APIs should make use of contexts. - 1.11 added "modules" as an alternative to setting up a workspace (a "GOPATH"). This is a tooling change, and shouldn't affect the written code.
So, having error handing so far away from the specific thing that‚Äôs producing the error is the problem. It‚Äôs why Go doesn‚Äôt have exceptions, for example. It‚Äôs not integrated with the flow. I would agree that it‚Äôs bad to look into deep branching, but I would also argue that you shouldn‚Äôt have deep branching. In Go, instead of entering a block on success, you usually break out of a flow if there‚Äôs an exception. Hence why using the defer or exception is really broken for Go.
Instead of using a global, create a struct that contains the values then send a copy to anything dependent on it. [https://goplay.space/#k\_VkL6FkEX6](https://goplay.space/#k_VkL6FkEX6)
no remote option, apologies
it‚Äôs completely dependent on experience
So generally when that‚Äôs true, you give a range. If you don‚Äôt post a range. It‚Äôs just not worth investigating. If you were posting a car for sale, you‚Äôd give a price. And in this economy, you‚Äôre selling this job.
I read a book on COBOL and FORTRAN in 2017 because it was from Kernighan. His work holds up.
Every word, Every sentence worth reading. I was so impressed with the book.
I don't know about Atom but I'm able to do this in VSCode. I just follow the function to the file, add the breakpoint and it breaks on it when I debug.
Yea I know it works well with vs code and goland. I was mainly curious about through terminal and atom.
I mean wouldn't the second technically be slightly slower due to the calling the len() function?
I suppose that _technically_ the second _could_ be done in fewer instructions than the first, as the first needs to both modify the pointer and the length while the second can just modify the length. I'm not sure how it's actually implemented, though. That being said, if you're worrying about the difference between the two in terms of an actual attempt to optimize something, you probably should be writing whatever you're working on in assembly. This is not something you should basically ever have to care about in actual code.
I mean I would just say use VSCode then. However since you probably want a real answer I would try opening up the file that you want the breakpoint in (even if its not your package) and add runtime.Breakpoint() where you want to break, then running delve should break at that point. Once you are done you will want to revert your changes so the other package can be updated in the future.
And reading the implementation has additional problems because an object might be the type of a certain interface but you don't know what the concrete implementation is until you find out where it is initialized.
PathError is 15 lines of code, with documentation and whitespace. Almost everything there *says something* about the error; the three inspectable fields, the Unwrap method for xerrors-style inspection, even the awkward delegation of Timeout. None of that would be there for a stringly wrapped error. I don't know what you're complaining about. Computers, in general, need to be told what to do; we use source code for that.
[removed]
!!! thank you
[removed]
Learn from someone who does. I thankfully work at a large company with experts on pretty much any technical topic I could imagine. Talking, listening, reading is the way to master anything.
You are right about terminology! Here is one example that I really love asking during the interviews, despite the fact that I consider it to be a really hard question. I have to mention that I've found this smart and elegant question/solution googling for Go language interview questions, but I cannot indicate where, because I can't remember. Having a HTTP route that accepts JSON payloads, provide a solution for decoding those payloads to multiple structs. Solving this would be a matter of completing the `decodeMyPet` function, as seen below. Expected code would look like: ```go import ( "encoding/json" "fmt" "reflect" ) type Dog struct { BarkingDecibels int `json:"barking_db"` } type Cat struct { ScratchingTendency int `json:"scratching_tendency"` } func decodeMyPet(jsonPet string) interface{} { type pet struct { *Cat *Dog } p := pet{} err := json.Unmarshal([]byte(jsonPet), &amp;p) if err != nil { panic(err) } if p.Cat != nil { return *p.Cat } else { return *p.Dog } } func main() { dogJson := `{"barking_db": 75}` catJson := `{"scratching_tendency": 20}` fmt.Println(reflect.TypeOf(decodeMyPet(dogJson))) fmt.Println(reflect.TypeOf(decodeMyPet(catJson))) } ```
Point taken
I bet the opposite. len is not a real function but a built in and is inlined. But the first one needs most probably a bounds check and the second does not.
Simplicity and compile times are prios imho.
The Go++ thing is a joke of sorts... which I'm not quite sure the Slashdot article picked up... Anyways for the record Matt Klein is the lead dev on the Envoy Proxy which is written in C++. He's very well known in some dev communities (kubernetes, istio, envoy of course).
`len()` is an O(1) operation on Go slices as it does no more than reading the current length from the slice header. (The slice header stores length, capacity, and a pointer to the first element.) Increasing a pointer is also an O(1) operation. As a result, both slice operations have a time complexity of O(1), hence they are "equally fast" in terms of [time complexity](https://appliedgo.net/big-o). Whether one of two given O(1) operations takes more steps than the other does not really matter in, say, 99,9% of all real-world scenarios.
In an attempt to better acquaint myself with the Go compiler and maybe find purpose for [github.com/ccbrown/wasm-go-playground](https://github.com/ccbrown/wasm-go-playground), I created a fork of Go with an implementation of the [try proposal possibly being included in Go 1.14](https://github.com/golang/go/issues/32437) and uploaded that implementation to a WASM playground. Enjoy!
Awesome work! I‚Äôm always impressed by what the community is doing with WebAssembly.
[removed]
&gt; So, having error handing so far away from the specific thing that‚Äôs producing the error is the problem This is only a problem in languages that don't allow for proper exceptions. Otherwise I would say it's poor exception handling (or in the other extreme, poor choice of what to handle). Properly-made exceptions also make it very clear what exactly occurred when uncaught. And since most exceptions in modern languages carry the unwound stack information, this is easy to debug with in either caught or uncaught cases. Original context all the way from the top of the stack upward, as it should be. I think the problem with Go's style of error handling is it actually hides true error location a lot of the time, especially when you are using third-party libs for instance. Sure, you might get an error that says something happened, but unfortunately current practices and idiomatic code for golang promotes just passing errors along which, without a panic trace, makes things unfortunately very difficult to debug (did it happen in this function really? was it passed along from about 5 calls deep? is it truly the original error returned? you don't know), hence our current mess. This is why exceptions are actually pretty useful. Just some counter thoughts to something I think deserves more thought. &gt; In Go, instead of entering a block on success, you usually break out of a flow if there‚Äôs an exception Try is just syntactic sugar for triggering early exit, i.e. a break out of the current code path. Deferred functions will be called whether there is a return from an if-statement or by `try` so I don't see how there is a breakage in Go's style. And if the argument is just that you should just exit and return the error when it is detected, that is what `try` does. It might return junk values for other params, but it's also outside of best practice to create parent functions that expect valid return values when there is also a returned error. If you truly need specific values, use the if statement, but again this would be very smelly code to expect valid results while an error occurred. I don't really see the issue here.
&gt; and the second does not. It does exactly the same bounds check (`len(a) &gt; 0`), as slicing with negative indices is forbidden.
Go modules ensure reproducible builds by pinning dependency versions, and the Go proxy concept ensures availability of dependencies even if the source vanishes. This duo should therefore be able to replace vendoring in most cases. But you are right, existing workflows, the inability (for whatever reasons) of using an up-to-date Go version, and other factors can prevent using modules and proxying in the short run. For one possible solution, see [this story about how Dgraph switched from Go dep to Go modules without affecting package clients too much](https://discuss.dgraph.io/t/go-modules-on-badger-and-dgraph/4662)
I've been wanting to ask, what does this book *not* teach you about Go?
I agree with the configuration comments. If you must have global constants, place them nearby their usage and avoid exporting them if possible. Shared global state is a code smell, do not group by type, group by domain.
Hello, Can you help us understand why the Run Configurations are not enough? Also, what is the problem you are trying to solve using the IDE? That would help us provide a solution for you. Thank you.
I am kind of on board with where he is going but I think emphasizing clarity too much can lead to implementations that look simple and clear for one person, but are a nightmare to follow and understand for someone else. Case in point is the switch statement function used as an example in the post. I find that the switch statement is less obvious _to me_ that the dangling return 0. Why? Because in the switch, I still have to parse each of the conditions that leads out to a result. And I just personally find the dialect for spelling out those conditions more comfortable with the if/else/return than a switch statement. Who is right about what is easier to understand? I don't think any engineer intentionally writes hard to follow code. Even excruciatingly complicated abstractions in Java are "clear" for people who are used to that dialect and ate often considered best practice. I like the idea of bringing simplicity into the equation. However, "simple is better than complicated" has been a mantra for Python for years and there is still mountains of complex Python code.
Yes, these repetitions and verbosity get into conflict with readability. I'm sure that this would (or will) be improved significantly with generics.
That's what FUZxxl means. I think (s)he refers to https://en.wikipedia.org/wiki/Literate_programming
IMO \`try\` is harder to read that \`if err\`.
Imagine how I felt lol
I sense `gzip.Close` writes data. I was reading the buffer before this call. I re-wrote this all into a main to test this as this is a component from elsewhere, so I probably did it poorly but still these are good points you raise. Why shouldn't I call close on a file I just created? Or am I doing it too early? I figured it was the same kind of handle as `os.Open` The leaking file handles is a good point. I didn't defer those because I wanted to close them once I was finished, as opposed to queuing them behind the function in a defer stack.
This is a neat and succinct explanation
Yes, that was a typo! Thanks for pointing out. Now I have to ask, since the compatibility is guaranteed for 1.x, will be the same from 1.x to 2? Any news?
This is the kind of answer I was aiming for, thanks very much for pointing out the differences. I'm going to put your answer on the top of my questions.
But the good kind. Not the paste-eating kind
Does the wrapping function is expected to return an error? What's the function signature?
Quite elegant! I assume it does not work for consts though? Also, does the go build fail if the variable is unset or does it panic at runtime? &amp;#x200B; We generate a simple go file with a `const version = "‚Ä¶"` in our CI pipeline. This has the advantage of failing during the build if the generated file does not exist.
it's guaranteed by the underlying broker, it uses BRPOP/BLPOP from Redis.
Noted. Thanks!
Go Modules made their debut in Go 1.11 and are on their way to be come the default dependency management system in 1.14 with the deprecation of GOPATH. After a (very) brief reminder of what Go Modules are this talk will relate the (ongoing) migration of some projects towards them. We'll explore what happens when you have a larger number of dependencies and extract the practical considerations to keep in mind when managing your own project in the era of Go Modules.
Good short writeup on this. I usually prefer mage to make for Go projects though. One thing that keeps haunting me is that a couple of weeks ago, someone posted a link to a repo where they solved it differently. Basically, they used Go generate comments to have the correct variables generated in a normal build, which (at least in my opinion) is a far nicer way of achieving this. Sadly I'm not a smart man, so I lost the link to the repo. I wish they'd made a short post going into more depth explaining all the parts.
Don't use `log.Fatalln`, use `log.Println`. `Fatalln` will stop the application from running.
While that may be true, this is not a discussion about try, this is someone who made something very cool. If you made something cool yourself, it would be pretty frustrating to see a comment that doesn't really talk about the thing you made.
The godoc link is broken and there is no example of how to use it in the Readme on github.
 var timingDefinitionInt int timingDefinitionInt, err = strconv.Atoi("2") if err != nil { log.Fatalln("file format is incorrect!", err) } errors are just being logged using log.Fatalln(). Instead, just return the error.
I want to return error ...not using log.Fatalln/Println. var timingDefinitionInt int timingDefinitionInt, err = strconv.Atoi("2") if err != nil { log.Fatalln("file format is incorrect!", err) } errors are just being logged using log.Fatalln(). Instead, just return the error.
For me it's sum types. Sometimes I don't need full-scale generic types system, I just want to make it clear that this foo can only have those three types. I use the interface-with-an-unexported-method idiom, but I wish I could express the intent more clearly (heh) and have more compile-time safety.
 timingDefinitionInt, err = strconv.Atoi(rate) if err != nil { fmt.Println(timingDefinitionInt) } Is it satisify to return error using Println()?
Then just return the error if you don't need to do anything else.
For more in-depth info, you may browse [here](https://golang.org/doc/devel/release.html) and see what happened in each major release. Note that one of the strengths of Go is that [its authors take compatibility seriously](https://golang.org/doc/go1compat) so The Book will only be obsolete once Go 2 will have been released. (And even then it will unlikely to be _radically_ different language.)
Hi, I use a single struct called viewData, in which in put my information for all templates. (Both the structure for the information and the values).
Thanks, I already had this set but I using fmt.Printf(flag) Instead of fmt.Printf("%v", flag)
Thanks
The differences between the two specific statements have already been covered but there is a difference depending on how/why you're doing this statement that I haven't seen mentioned. Often these statements are used to implement a FIFO or LIFO and there will also be `a = append(a, item)` statements as well. If the algorithm being implemented is correct for either, then the a LIFO pulling from the end of the slice can be better. The reason is that it will minimise allocations in the `append`.
What book?
If using modules most of this information is already available. See [`rsc.io/goversion`](http://rsc.io/goversion) with the `-v -m` flags (I believe in Go 1.13 that you will be able to get the same information via [`go version`](https://tip.golang.org/cmd/go/#hdr-Print_Go_version)). E.g.: `goversion -v -m $GOPATH/bin/aligncheck` gives: /home/dchapes/go/bin/aligncheck go1.12.6 path gitlab.com/opennota/check/cmd/aligncheck mod gitlab.com/opennota/check v0.0.0-20181224073239-ccaba434e62a dep golang.org/x/tools v0.0.0-20190625160430-252024b82959
&gt; I assume it does not work for consts though? No, it doesn't. The linker can set the value of a variable, but it won't override a constant. &gt; Also, does the go build fail if the variable is unset or does it panic at runtime? I don't understand this question. If what variable is unset? In the example, he's using the git revision of HEAD. That will always exist (unless your project isn't under git control).
&gt; the standard practice across the community is to use make. Really? That's news to me and almost all the package dependencies I use.
What is the difference between these? func main() { err := sendRequest() if err != nil { // deal with it somehow } } func sendRequest() error { err := doSomething() if err != nil { return errors.New("couldn't do that something") } return nil } and func main() { try { sendRequest() } catch error { // deal with it somehow } } func sendRequest() { doSomething() } The "Try approach" lets you bubble up errors (and be lazy about them), because you can just ignore everything and let the tiniest little thing downstream bubble up. There is no transparency to what exceptions is the function dealing with (type safety), and generally less readable. I get it that dealing with errors in Go could be a pain for newcomers, but dealing with errors when and where they happened lets you think about your business logic a bit more... like maybe try calling it again if it fails? or you can actually continue because this condition leg is not crucial for the program flow etc.
I think what you're looking for in your `Recovery` tag is something like the following: type Person struct { Name string `db:"name"` Verification token `db:"verification"` Recovery token `db:""` } This way the values of `token` and `expires_at` are pulled from the table and assigned to those specific ones in `token`. [For reference](https://github.com/jmoiron/sqlx/blob/master/reflectx/reflect_test.go#L38)
As u/_supernoob said, we need the function signature. The function that the code you showed is running in. That function needs to have an error as one of it's return values in order for you to be able to return the err. I think this is what you want: https://play.golang.org/p/N2yWZgcgY3y Try replacing the "123" in line 10, and see what happens. As an aside, I would probably not log inside of that function. Just return the error, and log it from the calling function. That function has more context about what's happening, and can give a better log message.
I agree that some parts of Go tend to be a bit too verbose. Clarity and explicitness are great. Unnecessary verbosity is not.
&gt; go1.12.7 (released 2019/07/08) includes fixes to cgo, the compiler, and the linker. See the [Go 1.12.7 milestone](https://github.com/golang/go/issues?q=milestone%3AGo1.12.7) on our issue tracker for details.
Possibly this post? https://www.reddit.com/r/golang/comments/byfxi8/i_wrote_up_how_i_automatically_embed_version/?utm_medium=android_app&amp;utm_source=share
Is there any issue with just using a call out to the `lsof` command or reading `/proc/self/fd` (Linux solutions)? Maybe not if you are listing C# references and are on Windows.
It really is tho. If building is more complex then "go build" Makefiles are used. Just look at these go projects: - https://github.com/prometheus/prometheus - https://github.com/mattermost/mattermost-server - https://github.com/moby/moby - https://github.com/fatih/vim-go All of them use Makefiles
Did you consider just using [nsq](https://nsq.io/) or something like that? No offense, but with only 15 commits, I wouldn't trust this in my code base. It's not "battle tested" or hardened. Message queues are hard to get 100% right. The happy path is usually pretty straight forward. * But what happens when a consumer fails in the middle of processing a message? Do you just throw that message away? Do you put it back on the queue? * How about a network blip while sending the message from redis to the client? How is that treated? There are dozens of small corner cases that need to be addressed. NOTE: I didn't read your source code. You may very well be covering these and more. But being so new, I doubt it. &amp;nbsp; All that said, you should continue with the project. Competition is good. This could being a great tool. Good luck.
I'm not on Windows (however I do want an OS agnostic solution if I can) - the C# reference came as a result of hunting around for a solution and that came up as the first thing I found where there seemed to be an "in code" solution to the problem as opposed to calling out to the system directly. I was hoping there would be a library that someone knew of that did this kind of thing - I haven't yet found one
This is a nice approach, the only thing I do differently, is to `GIT_TAG := $(shell git describe --tags)` rather than the SHA. If you tag your work as you work with version numbers then this will give you a version based on the tag. For instance the project I am currently working on, the above gives me v0.1.1-3-g13f8fd5 - the `v0.1.1` is the tag version, the `-3-` is how many commits I am ahead of the tag, and the g13f8fd5 is some git magic (aka I don't know...). Whats nice is you can check this out with `git checkout tags/v0.1.1-3-g13f8fd5`. Its a bit nicer to read than a SHA and you can tell roughly where you are in your code base by the version. If you just want the last tag that was available you can even just use `git describe --tags --abbrev=0` which will give you (in my case) `v0.1.1`.
I use something quite similar Makefile DATE ?= $(shell date +%FT%T%z) VERSION ?= $(shell git describe --tags $(shell git rev-list --tags --max-count=1)) HASH ?= $(shell git rev-parse HEAD) LDFLAGS += -X "main.buildVersion=${VERSION}" LDFLAGS += -X "main.buildHash=${HASH}" LDFLAGS += -X "main.buildDate=${DATE}" main.go var ( buildVersion string buildHash string buildDate string Version *version ) // NEVER use this info in code type version struct { Version string Hash string Date string } func init() { Version = &amp;version{ Version: buildVersion, Hash: buildHash, Date: buildDate, } }
If they are all very similar a struct is probably the way to go. If they are not they maybe use anonymous structs. From https://talks.golang.org/2012/10things.slide#1 data := struct { Title string Users []*User }{ title, users, } err := tmpl.Execute(w, data) (Cheaper and safer than using map[string]interface{}.)
&gt; and the `g13f8fd5` is some git magic Less magical that it seems - observationally it's `g` + first 7 of the SHA.
I typically do one struct per template, however I also make use of extensibility as golang templates can contain sub-templates. Say for example that I have a base page template that contains some content that's the same across all pages, say a menu and the name of the currently signed in user. I might have a struct. type BaseData struct { FirstName string } Then for each page type HomePage struct { BaseData MoreContent string }
I beg you pardon, I can't watch the video right now, but what exactly the rainbow flag has to do with it?
Probably "Elements of Programming Style", it' PL/I though, not COBOL. And the fortran is 66 i think, certainly not 77.
It's really not the standard at all. It is popular, indeed, but the majority of projects don't use make
What if one does go build instead of make? Then the variable is unset.
I would assume (but haven't tested it), that the goVersion variable will still have it's default value - "".
We created a special logo to honour the fact that in July will see London celebrating 50 years of Pride.
What do you mean by `NEVER use this info in code` for the version struct?
Unless I'm missing something, that looks like it's only giving the version of go that was used to build the app, and the dependency versions, not the version of the actual binary - aligncheck in this case. Also, it's another dependency that you'd have to install on your production servers. Having it built into the binary is nice.
Thank you for the explanation.
Ahh yes, stupid me. I was looking at this current hash not the hash that was tagged... And obviously that was three hashes ago... Very nice.
Ah. Generate sounds like a good solution. If the only reason you‚Äôre using a make file is to inject the version then generate could remove the dependency on make. Very nice. Too bad we have no example of how that‚Äôs done.
Not using generate.
You can try it for yourself! I'll grab me coat.
Friendly suggestion. You may find an answer to your question by looking on https://security.stackexchange.com/
It's just a comment for my coworkers to never use this version info to make any coding decisions. This could easily be abused as if Version.Version == "3.5.0" { // do something } If you need behaviour like this in your code use a feature flag system. To reiterate: This struct should only provide build info and should not be used as a lightweight feature flag system
Found references on some answers there to https://blog.angular-university.io/angular-jwt-authentication/#step3sendingajwtbacktotheclient which basically only deals with CSRF by storing the JWT in localStorage. Unfortunately, no mention of how to protect against Javascript access is given.
that seems super over the top? If you "NEVER use this info in code" you might as well just: \`\`\` var ( buildVersion string buildHash string buildDate string ) \`\`\` and be done with it, the rest is superfluous.
&gt;I completely agree with the principle, but there's a lot more Go could do to support clarity. Mostly better support for abstraction. Go tends to be verbose. It is readable, but too much code is also the enemy of clarity. Looking forward to some of the upcoming improvements as the language matures. High abstraction makes your code unreadable and create more complexity. Go isn't Java. It's subjective to define what clarity is, which feature to be adopted ...
Yeah, that makes sense. The version struct is only for _display_.
Maybe this? https://www.google.com/amp/s/adrianhesketh.com/2016/09/04/adding-a-version-number-to-go-packages-with-go-generate/amp/ However the author updated his demo repo (https://github.com/a-h/version/blob/master/README.md), which recommend using `ldflags` instead of `go:generate`: https://www.atatus.com/blog/golang-auto-build-versioning/
The version on the `mod` line is the version of the module that the command is in.
How about cloning it in /home/reik/go/src ?
sure you could just use `buildVersion, buildHash, buildDate `. I just copy pasted this code from a project I'm currently working on and I rather not go into detail but the `version` struct is an abstraction layer as my Makefile isn't the only source which is able to inject a version.
Yes, something you‚Äôve never used before is going to be harder to read than something you use everyday.
godoc link fixed. There is a basic example in the wiki showing how to use CompressedStream (essentially it is just ReadCloser/WriteCloser).
It may be not *the* standard but it is the de facto standard. More examples of popular go projects using Makefiles: - https://github.com/influxdata/influxdb - https://github.com/etcd-io/etcd - https://github.com/deis/deis - https://github.com/kubernetes/kubernetes - https://github.com/hashicorp/consul - https://github.com/golang/protobuf - https://github.com/ory/hydra - https://github.com/hashicorp/terraform - https://github.com/coredns/coredns - https://github.com/letsencrypt/boulder
There are Go bindings for tensorflow.
For neural nets of any kind of scale you want GPU computation. Your only options afaik is [https://github.com/gorgonia/gorgonia](https://github.com/gorgonia/gorgonia) or the Tensorflow bindings.
Default in Go 1.13, right?
https://github.com/go-ldap/ldap/issues/95 Give the libary a try. ;)
https://groups.google.com/forum/m/#!topic/golang-nuts/enOfd9HY4uo On Unix this is quite easy. On Windows you might need to call the win api.
If I understand you correctly, you're looking to embed HTML into your binary? If so, [https://github.com/gobuffalo/packr](https://github.com/gobuffalo/packr) is your savior.
I really like the [Feature Comparison Chart](https://github.com/cockroachdb/errors#features) I really wish people entering an existing library space would compare their project in this way. Much faster than digging around in the codebase.
 https://blog.golang.org/go2draft
If the point of code were to tell the computer what to do, we would be coding in machine language. The point of code is to tell your team mates, (and yourself, 3 weeks from now, when you go back and try to debug what you wrote, and forgot) - what you want the computer to do.
Sure, there's definitely a balance. Java is a great example of abstraction causing painful verbosity. I hate Java. Rust, Haskell, and OCaml are probably better examples. None of them are perfect general purpose languages, and the code can definitely be obscure if you're not careful, but in comparison Go's type system is missing basic functionality. Sure, it's subjective--I prefer OCaml type classes over interface{}, but I can adjust. Beneath the subjectivity, Go just doesn't have a way to abstract a function over different primitive types without crippling the type system. Look at something like zerlog. It's a great library, but you shouldn't have to have log.Debug().Str, .Int, .Int64, and so on. Generics, data types, or whatever version of polymorphism is a solved problem in programming. I appreciate that the Go team took their time to see how the language is actually being used and are gathering community feedback, and I appreciate that Go is a language that takes no time at all to learn. I'm not really complaining or disagreeing with you--I like Go. I'm just saying that it's time to fix this now. The language is mature enough--let's address this and make it better.
That's a big one for me too. I pivoted into Go after just learning OCaml/Reason and there was a lot of "wait... there's no way to do that at all?"
Thanks! Very cool. I will check it out!
Hmm it seems inconclusive that article? The file.Open approach seemed good except it requires the CREATE flag set on it?
I really hope they're planning to update it when the time comes.
I won't be able to help you with exact Go implementations, however the first thing I do with every existing codebase I start working on is run a pretty thin manual security audit. I'll test inputs, bogus query/body params, headers, etc. In your particular situation is sounds like you're trying to prevent the standard CSRF attack. I like to start at the server level and work my way to the front by doing the following: - Setup nginx/whatever http service I'm using to have the proper x-frame-options/all the other security headers. - Make sure my HTTP service is properly sanitizing and validating all client inputs (headers, query params, body values). - Make sure my client's input values are also being validated before being send off to the server. - Make sure I'm not directly writing any response values to the DOM - no "{{{ raw html }}}" stuff allowed if I'm using a frontend framework with a templating engine that supports it. OWASP has a pretty nice [XSS Cheat Sheet](https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet) that outlines a number of both common and uncommon XSS payloads that have been proven to work under specific environmental conditions. Because OWASP is a total bro, they also provide an [XSS Prevention Cheatsheet](https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.md). For what its worth it's pretty hard to leverage an XSS against a pure Vue/React/Angular frontend. Most of the successful payloads I've found have been persisted (and therefore bypass Chrome's XSS filter) in forms - usually "view/edit profile" forms, but sometimes I'm able to leverage a clever one in a search form that accepts multiple parameters and also renders the payload to the page directly with minimal processing. My loose rule is so long as you're using a modern, battle-tested frontend framework and not directly rendering user inputs then you're mostly fine as the framework tends to take care of the sanitization for you. The only XSS exploits that I've ever personally gotten to work on these frameworks have been URL-related - ie: document.location='javascript:alert(123);' - or there will be a dynamic href somewhere that takes in the "?redirect=http://example.com/" value and renders it which is 100% a user-created vulnerability. Avoid doing stuff like that. Aside from that stuff, just make sure the other apps on your domain and associated subdomains are clean and XSS-free. Use the X-XSS-Protection/all of the other security headers to prevent people from iframing your site and issuing CSRF attacks, and make sure you filter your CORS whitelist to org-owned properties. In regards to the "best practices" bit, it's kind of all over the place based on my observations. Instagram uses CRSF on their apps but they rarely actually change the CRSF value. At my old employer we'd use a dedicated CSRF endpoint to generate a new token, update the users' session to hold that token for comparison, and return said token to the client so they could send it in a header. We'd have the client ping the CSRF endpoint before they made any request at all instead of just returning it as a header or a cookie for any of the other requests, which caused a bit of a slowdown in terms of performance just due to the network latency. It's worth noting that I didn't design said flow lol. TL;DR: I think in your situation you could get away with just using a nonce and validating that, or just sign your requests so that way exploiting your app would need to be done with an XSS which is going to be considerably harder to leverage than a simple CSRF. Add an additional layer of protection by using [Security Headers](https://www.owasp.org/index.php/OWASP_Secure_Headers_Project#tab=Headers). Keep your CORS whitelist short and secure.
Another quick note is that for our payment processing apps, we invalidate sessions if the client ip associated with the session changes, We've had like two people on mobile between two towers complain about it as they network-swap, but it's been fine.
We do this for our apps (mostly REST servers, but also a few CLIs). We have an small internal library called `buildversion`, so every project doesn't have to add and maintain the same fields and can just import git.x.y/group/buildversion, and use buildversion.Get() to get a struct with all the version info when needed. The only trick to this is the ldflags need the full-import path to buildversion for each field and thus become quite long ``` -ldflags "-X git.x.y/group/buildversion.pipeID=$(CI_PIPELINE_ID) -X git.x.y/group/buildversion.commit=$(shell git rev-parse --short HEAD) -X git.x.y/group/buildversion.version=$(shell git describe --tags 2&gt;/dev/null) -X git.x.y/group/buildversion.buildDate=$(shell date -Iseconds) ... ``` Currently we track application version (e.g. v1.2.3), commit, build date, and ci pipeline id using ldflags, and GoVersion, GOOS, and GOARCH from the runtime package. We also do some Makefile hackery with the include directive so we don't have to update every project's Makefile for changes to our common build process (including the ldflags), but that's a whole other story about CI/CD.
This last data point is interesting as I've often wondered how much IP-based behavior watching effects users. You don't really go into deal about the size of your application, but not a lot of companies talk about this so I guess most have to metrics to see for their particular userbase.
Default in Go 1.14, per dom_green's summary. Source: https://github.com/golang/go/issues/31857#issuecomment-489678807
Thanks for sharing, I enjoyed reading. &gt; To create 4 you do not do IIII, instead you do IV. That is what I thought too, but it does not explain [the clock](http://tuscantraveler.com/wordpress/wp-content/uploads/2008/11/orologio-del-duomo.jpg) in Florence's Il Duomo. I was very confused to see so many 4's written as IIII
Yeah if there's one thing I learned doing this is that the system has a lot of different changes and rules over the years. &amp;#x200B; I think the main thing is TDD-ing through \_some\_ set of requirements, even if it maybe doesn't satisfy every version :)
I don‚Äôt know in your specific situation, but there are usually a lot of factors you need to consider. If all you want is speed, then often writing your own that only does exactly what you need will run the fastest. If you need advanced functionality while also being tuned, then there are good libraries. But you may want long term support, where you know it‚Äôs not going to be abandoned, so finding a more active and mature library will help in the long term. Maybe you can‚Äôt find some functionality in one, so finding one with an active open source community will let you make that contribution. Unless it‚Äôs a pretty well established niche, often there are a few alternatives, and it becomes a bit of a crap shoot on which will win.
Examples? I don't completely understand what do you mean.
Go is opinionated. It‚Äôs defiantly more verbose, and works in a more raw way under the hood. Thats why a lot of us like it. We have more control over it, and it subsequently gives us more performance. It also has a lot of design decisions that make it less compact than python, but I consider that a good thing. I often see a line of python where o have to spend a minute or two just trying to parse out what the hell its doing. Go doesn‚Äôt have that issue. It forces you to be straight forward.
&gt; I pivoted into Go after just learning OCaml (‚Ä¶) I love Go with all my heart, but I feel like you are about to experience serious suffering.
Spend our energy elsewhere.
Let's get into the gin/tree.go module ([Link](https://github.com/gin-gonic/gin/blob/master/tree.go#L37)). I picked randomly one function. func (ps Params) ByName(name string) (va string) { va, _ = ps.Get(name) return } &amp;#x200B; In this example the function ByName was bind to Params. It's "convention" that the variable for the binding is done with the least amount of letters which you can imagine, what is horrible. Also there are a lot of variable names in Golang code, like in this example "va" which is totally not self-explaining.
I like Golang, the language is really fast and it has a lot of really cool ways to implement smth. but why the hell Go coders name their variables like hell :'(
I kinda like the standard variable names. I‚Äôve never really cared much for worrying about naming things. I often use short names for things, although I draw the line at one character variable names except in very very short functions.
[https://github.com/skx/implant](https://github.com/skx/implant) is another alternative; it seems many people write their own. &amp;#x200B; I prefer explicit operation to the "magic" wrapping of the packr tool.
So I am not a very opinionated developer, so keep that in mind while I ask this question. What is wrong with naming method (self) variables with a simple one or two characters? I mean has it ever bitten you in practice? Or is it just theoretically wrong?
Doesn't look random. You picked pretty much the single function in that file that has those kind of names. Everything else is named pretty decently. &amp;#x200B; As for convention. The receiver name is what you will probably use very often in the function body. It's a good practice to use shorter name. Everything else should and is named properly but not over the top like Java.
My subjective and highly opinionated take on this: in the "after 90s" epoch, programming gradually became "learning patterns and guessing which one to use" thing and many new paradigms (including abovementioned Clean Code and DDD) are optimized for that. Programming in the "90s" was more like pure mapping ‚Äì you understand the problem domain, you have building blocks to encode it in code, you write code. &amp;#x200B; Go brings back programming to that mapping land. It gives you minimum but sufficient set of "building blocks" which you use to build anything. That requires good understanding of the problem domain you work with in the first place, which might be uncomfortable for some. But that's what makes programming fun and interesting ‚Äì it's all about discovery, research, building maps process. Programming language is just a tool to do it, not the replacement of the process.
verbose variable names are a convention intended to overcome a trend of increasingly opaque code. Clear, simple code - like this - doesn't particularly need a verbose variable name. Even seeing this function in isolation, it's obvious to me what is va is. If I were going to object, it'd be to suppressing the error.
In my opinion there should be a global awareness of all Golang developer to use proper variable names. I rather use a proper variable name than abbreviate a variable to one or two letters. When I am reading code, I want to look inside of a function and know what objects are really used. Example: &amp;#x200B; func (f *Foo) DoBar(ff *FooFoo) {...} So when one will programm variable names like this, you have to look inside the function defintion and everytime you read "f" or "ff" you have to think about it: "what was f and ff again?" &amp;#x200B; func (foo *Foo) DoBar(fooFoo *FooFoo) {...} Would be more self-explaining. Oh and the way how in Golang a private or public methods, variables and (with upper or lowercase first-letter) are specified is awful.
If you are looking at something between DB scaffolding and manually creating all the endpoints you might like to look at a library I've been working on to create endpoints for business logic instead of just SQL CRUD: https://github.com/Xeoncross/servicehandler
It‚Äôs by convention, and very deliberate. Read Effective Go.
Yup. `err != nil` is just fine as it is. The error wrapping utility would be nice, but it's straightforward to write one's own, given the simplicity of the error interface. Don't see a need to do anything...
&gt;Programming language is just a tool to do it, not the replacement of the process. Thats totally correct but when the tool rather decelerate than accelerate the process, this is not really nice. I'm programming for about 15 years now and again: I am not **against** Golang, I am against the conventions which are broadly in the community
&gt; High abstraction makes your code unreadable and create more complexity And yet whole software industry is built on abstractions, all the way down to the silicon.
I used NSQ a while back, it's a complete other broker mechanism, it's funny the initial implementation of bokchoy was implemented with it in Python: [https://github.com/ulule/bokchoy](https://github.com/ulule/bokchoy) :) Don't judge the 15 commits, it has been in production in a side project since 6 months with a Redis cluster, if the message fails, the client implements the rerouting and can handle it using a recover middleware or the tracer implementation. You are right, the project is still young but I wanted something simple like python-rq without the fully battery included of celery with a friendly API. &amp;#x200B; Thank you for your comment!
I agree with your example. In practice, I prefer a hybrid approach, using short and sweet for self identifiers, and descriptive for local and parameter variables. func (f *Foo) DoBar (fooFoo *FooFoo) {...} But... I would never allow convention to pollute my code. If I was dealing with so many "f"'s I would consider breaking convention for simplicity.
I think this example is not so bad. If you check the comment above the function (as a gin dev) or check the [docs](https://godoc.org/github.com/gin-gonic/gin#Params.ByName) (if you're an end user), you will understand pretty fast what is this function is doing and that is the most imporant part. Yes, the naming is poor and I'm not a fan of 2 character variable names either. I copied the same function but with comment below for comparison: // ByName returns the value of the first Param which key matches the given name. // If no matching Param is found, an empty string is returned. func (ps Params) ByName(name string) (va string) { va, _ = ps.Get(name) return } Go is inspired by C (and other laguages), which tends to have short/obfuscated names for functions, types and similar. This is why functions as `fmt.Sprintf()` are not called `fmt.FormatString()` for example. I am not saying it's justified to write *new* code with short/obfuscated identifiers. On the contrary, I am frequently fighting this at work, and this does affect maintainability of code. If a library has very long variable names, code gets hard to read as well. Yes, I'm also fighting this at work almost daily. The trick is to find a balance, which is as we can both agree, not currently found in this particular piece of code. Since this is open-source, if you think you can improve it, you can make an issue on github and see if the maintainers agree with you. Then you could make a PR and improve the readability. Similar applies for other open source projects.
It's really irritating to see from outside that a competing product developer talks trash and disappears. If someone forks (which wasn't even true), you call it a bullshit, nonsense and are super mad at it? What the hell is your point?
And I wonder if it works on network mounts like NFS. Because otherwise it's back to the similar problem of not being a flexible/portable solution.
Hmmm good point, I'm feeling that feeling when you are making life hard for yourself...... perhaps keeping the cache in memory isn't so bad after all.... My UI can just allow the user to tell the watcher to stop watching, perhaps for MKI that's an OK solution....
&gt; Would be more self-explaining. It's worse. The argument should have name reflecting its purpose. The receiver's purpose is being exactly that, receiver/this/self, so you can name it as such or as a couple of letters and it will be clearly visible in the code. Everything else in your code has a proper name, so there usually no confusion between them. &amp;#x200B; &gt; Oh and the way how in Golang a private or public methods, variables and (with upper or lowercase first-letter) are specified is awful. And what's the alternative? public/private keywords? The way Go does it is actually better. There's no confusion as to which is which and no arguing about naming convention. No need for underscores or prefixes the permeate other languages.
Read https://research.swtch.com/names And the language's name is Go.
What is va? Please clarify. Neither the name of the function, parameters or return type, nor the function body give me a glimpse of what it should be. Also the package or file name. Still agree that this would look horrible in Java and I can hear the discussions about variable names that would be going on.
This is very cool, although the interface is very large for an error library. The simpler the interface, the easier it is to re-implement, add wrappers, switch out for something later on, etc..
Agree. The one side has to understand that we're not limited to 80 char lines anymore and the other has to see that it's hard to find good, long names all the time and often a slightly off name leads to more confusion.
`va` is declared as the return value. It is the string being returned, logically the value of the parameter in `ps` with the name `name`. If you don't know enough about the context to make these inferences - what `Params` are, or what `ByName` will do - then more verbosity in this function's internal variable names isn't likely to help, is it?
IV was a later addition iirc, so the old-style is to use IIII, also there's an argument about which one is more aesthetically pleasing
Different philosophies, that's all :)
Needs more gophers.
No more easy to click navigation buttons! No more function over form! No more directly accessible licensing information in the footer (but hey, isn't [https://golang.org/doc/copyright.html](https://golang.org/doc/copyright.html) beautiful \[and also mislabeled\])! I can't wait for the redesign to hit the playground. &amp;#x200B; But hey, we do have a "Google" logo on the front page now, I guess Go is finally a project that Google is proud of?
It'd be really cool and useful if while browsing the docs an animated cartoon gophy popped it's head out from the corner of the page and asked if you needed help. Also would be cool if there was no way to turn this off so that it happened every time you visit the site.
This would be a great April 1 improvement to the site.
I read the title like "golang.orgi", and for a second I was like "who is the genious behind that"
My auto-correct kept changing the address to [golfing.org](https://golfing.org) and I contemplated leaving the typo for giggles.
Found a typo whoopsie: &gt; [So a rule with Roman Numerals is you cant have the same character repeated 3 times in a row.](https://github.com/quii/learn-go-with-tests/blob/master/roman-numerals.md#the-romans-were-into-dry-too) *more* than 3 times in a row. Am off the read the rest of the article now. Very interesting!
Python is a great language, but this eloquently explains why I tend to prefer Go over Python (and Python over everything else).
But this would only work for 'Recovery' field? My desired result is to have the tags of 'Verification' and 'Recovery' fields to be prefixed to the 'token' fields' tags (e.g. 'recovery\_token', 'verification\_token', 'recovery\_expires\_at', 'verification\_expires\_at'). Since token type is used by both Verification/Recovery I seek for a flexible solution.
Looks better, but is still missing a dark mode switch. I almost burned my eyeballs, when I turned off Dark Reader extension
Use %q instead of '%s' in formatted printing
I‚Äôd been doing something similar but it was driving me crazy that the git describe format is not correctly SemVer 2.0 compliant, so I made a `git semver-describe` tool that is basically identical to git describe (with a few nice extras) but returns a proper semver compliant version string. This post influenced me to make it public today for discussion. Lots more discussion in the README: https://github.com/mroth/semverdesc.
Go finally made Google proud ü•∫. Remember, "Google" without "Go" is just an "ogle", and that's not a good thing.
I've been building my REST API's on a project using mostly my own code. Been using Gorilla/Mux for my router and the MondoDB driver. For me I prefer to be able to know the code and customize it to my exact specifications. Also, I feel like I am learning a bunch more by doing it myself which should help in the long run. In conclusion, its probably a matter of use case/preference.
[And another](https://github.com/quii/learn-go-with-tests/blob/master/roman-numerals.md#refactor-5): {"50 gets converted to XLIX", 50, "L"},
I also prefer building them myself, I've been using mux as my router and pq drivers for PostgreSQL, along with gorm as an ORM.
I'll be sure to take a look
I think I'll stuck with writing my own, for now. To be honest I find pREST a little overwhelming.
This is a really interesting design, I always assumed JWT in local storage was insecure because it can be grabbed by XSS and used to query the API, so I came up with an implementation that uses http only JWT, but it makes the refresh token completely useless as it can't be used by JavaScript to grab it and request a new JWT from the server. And I feel like storing the refresh token in local storage but not the actual token totally negates the point of making the token http only as it means a fresh token can still be obtained through XSS.
Before using a library like this, ask yourself: do you actually need all of the features listed in the feature chart? For most projects the answer is definitely "no."
That yellow was pretty bad. Had a very late 90‚Äôs feel to it
&gt; This site can‚Äôt be reached Ah, the good ol' reddit hug of death
I started learning Go only weeks ago, so now hopefully I can be one of those guys going "I knew Go even before they redesigned the website". That's a valid job credential, right?
I suck! Thanks all, will make the corrections tomorrow
I love it. This was needed for a long time
Still no download link in the navbar.
You dare dis the Acme color scheme?
[removed]
[removed]
Fantastic! With a bit of luck, we'll have Material Design, several megabytes of JS, and surveillance out the arse soon, too.
Google was proud of Go when they used it for k8s and when it was used in Docker, projects that kinda changed industry
Absolutely. Half the gophers I know will brag about how they started using Go since version 1.X, or pre 1.0, or during the Makefile era. Today's hip young Gophers can now brag about using it since before modules, before try, and now before Go 2.0 branding.
There's gigantic "Download Go" in the middle of the page.
:(
Another blog about adding version info: https://blog.carlmjohnson.net/post/2016-11-27-how-to-use-go-generate/
‚ÄúDe facto‚Äù means a majority IMO. The majority use nothing but the Go tool. Make is the second most popular, not the most popular, and certainly not a majority.
I just experienced clippy PTSD
Yes but that‚Äôs every Reddit comment section.
clippy gopher
"It looks like you're writing an HTTP Middleware. Would you like some assistance?"
The reason is that maps don't work here. URL parameters can have multiple values with the same key.
But....but....the sidebar....no download button in the sidebar. Ok, no. Honestly, that had to be a fake complaint... there's no way that person was seriously complaining about a download button missing in the sidebar.
Yes. Source of the quote: &gt; Everyone knows that debugging is twice as hard as writing a program in the first place. So if you're as clever as you can be when you write it, how will you ever debug it?
JWT for sessions: http://cryto.net/%7Ejoepie91/blog/2016/06/19/stop-using-jwt-for-sessions-part-2-why-your-solution-doesnt-work/
What, exactly, is hard about clicking on the new navigation links? Is it that there isn't a big blue box surrounding each link? Honestly, I'm curious to know why you think the new style makes it any harder.
Gosh, this post has 62 upvotes, I would hope the website for a language used to write web servers would be able to handle that kind of traffic
&gt;No more directly accessible licensing information in the footer What an enormous inconvenience
[Have a read of this.](https://dave.cheney.net/practical-go/presentations/gophercon-singapore-2019.html)
Previously, the entire big blue box was clickable. Now, only the actual text is. That is a much smaller surface to click, thus easier to miss. That is especially the case when using less precise (to some, anyway) input methods like touchpads. I expect it's also problematic for people with certain disabilities. It seems like the small device/mobile view, with the dropdown menu, suffers from the same issue: only the actual text is clickable (touchable?). &amp;#x200B; When looking at other popular websites, you will find that they all have navigations that are similar to the old [golang.org](https://golang.org) design, surrounding the text part of the navigation with a larger element. &amp;#x200B; Even if all that just read as "muh links are harder to click now", it's simply not aesthetically pleasing, either. There's just a bunch of free-standing text now, with very little ‚Äì if anything ‚Äì combining them to the design element that is the navigation bar. And they offer very little in interactivity, visually speaking.
Now officially we can confirm, that Go looses it's hipster like status and became a blue collar business product. The next step to eliminate completely any funny characters, no more funny gophers, no more hand drawn logos etc. Go will became a crude enterprise product used by enterprise companies. I'm just wondering what Rob Pike's attitude towards this move?
Seems some people weren't a fan of the ([acme](http://acme.cat-v.org/), anyone?) yellow but still, this somehow seems less legible to me.
I'd wait until the very next version of Google Chrome ships with `prefers-color-scheme` support. Then ask someone nicely to update the golang.org stylesheet with a dark-mode version.
You don't. &amp;#x200B; If you're given data as a \`\[\]interface{}\`, you type-assert it out. If you're given data as TestStruct, you cast in. &amp;#x200B; See [https://stackoverflow.com/questions/50710160/how-to-unmarshal-json-in-to-array-of-interface-and-use](https://stackoverflow.com/questions/50710160/how-to-unmarshal-json-in-to-array-of-interface-and-use).
I looked really briefly for this but couldn‚Äôt find it. I‚Äôll switch to using it if I have any problems with the other approach. Thanks.
Are you looking for something more magical than https://play.golang.org/p/y9I4CzRuNKM ?
That‚Äôs basically what I was going for, but using the official golang.org/dl/go1.x installers.
1. Put a comma between " foo" and \[\]interface. 2. [https://play.golang.com/p/P8Kzait3pjr](https://play.golang.com/p/P8Kzait3pjr)
It specifically installs the latest stable versions of Go, but yes you do need a working Go install to bootstrap that essentially. I‚Äôm using it to automatically update Go whenever new versions are released.
omgosh lol it feels like stranger things 3 80s styled colors :P
&gt;before try Why such bad outlooks at morning?
Still got blogs in old one
&gt;several megabytes of JS Harsh! Maybe it's smaller now.
That's not where you look first on desktop. There's no link to download it if you're not on the homepage.
I'll use it tomorrow ü§ò
Old version [https://web.archive.org/web/20190708090851/https://golang.org/](https://web.archive.org/web/20190708090851/https://golang.org/) if someone was wondering what changed.
I‚Äôm still using a makefile...
and good news is today (or tomorrow), golgi will be pushed out (at least a skeleton)...
Old go site: https://web.archive.org/web/20190101103002/https://golang.org/
I remember `panicln()`.
golang.orgy
This is some prime cynicism in need of focus.
I don‚Äôt know about VSCode, but GoLand certainly handles imports for you automatically.
I still use EDLIN as my IDE
Love it. Keep making things public. Will update to this.
What do you use instead of Makefiles?
Even within the world of microservices, there are a wide variety of purposes to satisfy. I would encourage the use of the standard library until your use case requires more power. Then pull in a library that does one job and does it well. Avoid frameworks in general. they tend to provide unnecessary features at the cost of limitations. Lastly, familiarize yourself with the context package and leverage it throughout your systems.
ok that is a plus to Goland
before type aliases, before concurrent gc, before context, before vendor, before the compiler was written in Go... damn I feel old now :-)
Are there better alternatives to Makefiles? I'd love to know, but yeah, we still use..
Legacy build pipeline or just stubbornness?
As a visually impaired person, I liked the contrast the yellow gave on the white background. That is now gone :(
Yeah I understand that, that's why you're told to use JWT *with session tokens*, they're not a replacement for session tokens but they can help facilitate sessions. But tbf I've not seen a secure implementation of JWT yet, not even in production systems I've tested.
I like. Got a copy paste error in a comment in scrypt.go though.
And in vim-go it's GoImport, GoImportAs and GoDrop.
Go comes from plan9 and is a successor of C, where everything is minimalist. Emphasis is on simplicity (as in frugality). Here we care about having a lightweight software stack, a small language specification, a maintainable implementation. It's also clean code, just another definition of clean code. The syntax of a language is one thing, but how a language compiles, manages memory, uses the machine multiple processors, is another thing. Go does a pretty good job at these things, while enforcing readability and manage to give the high productivity feel of python with a decent speed (in the range of Java/C#). The language intentionally ignores decades of programming language evolution. Still, we're able to be productive with it, which is a proof that these evolutions were not that valuable.
And as far as I remember in VSCode ctrl+shit+p has to have some helpers too.
Ah? Where!?
Line 92 I think... not sure, but you‚Äôre referencing argon there in commented code
Ah yes, old copy paste comment, removed, thx, probably some cleanup of other commented stuff i left, i‚Äôll clean up a bit more before 0.1.3.
I liked the yellow color
Nobody replied to \`I'm not interested in that and It's not about that. Just if you claim something, back it up by data.\` Why should I reply to anything else? Maybe metrics isn't a fork in a "copy paste" sense, but it is as it's alternative implementation in the same thing. Anyway, I think we should stop fighting here and just move on with our lives. It looks like Victoria metrics folks has started to contribute a bit more to Prometheus ecosystem so I think everything is going into right direction and I'm happy with them :)
I liked the old one way better.
The closest library I‚Äôve seen to do this is mapstructure - https://github.com/mitchellh/mapstructure However, the slice of empty interfaces may not work as a map of strings to empty interfaces is expected. The interesting bit here is the struct field names are unused in favor of the struct field positions, they map to the element position of the slice. This mapping could be done in a ‚Äúgeneric‚Äù way with reflection but it‚Äôs going to be painful. The key is to map the elements of the slice (source) to the struct field position (destination) as you integrate through. I‚Äôm curious how you ended up with the slice of empty interfaces, if you can change that to a map of strings to empty interfaces, take a look at using the mapstructure library.
VSC can handle that too. Just goto Preferences &gt; Settings and type : go: format tool Change it to goimports and it will help you to auto-manage the imports.
[https://blog.golang.org/](https://blog.golang.org/) has old layout ;D
If you're used to blade (or twig) you could look at cloudykit/jet which has a similar kind of approach and is easily extendible.
&gt; Go type system is an advanced tool Huh? Seems pretty basic type system. Care to elaborate?
The elaboration took place right in the same sentence you cited and the very next one. Care to read?
&gt; compile time value and type checking If that's advanced... Simple tools attract simple minds, I'm outta here.
Farewell, KISS!
Generally practice for me. Whatever the problem or project is I'll see how much I can accomplish reasonably by whatever I know or can get by with for books and online text. More specifically with programming or systems pick out whatever the things are I really don't get and find a way to implement them. I suppose for example when learning about concurrency patterns, channels, and goroutines I was working on a project that made heavy use of them. It was new to me at the time so I wrote a small command runner pipeline. Since the project itself was another problem space I had to focus on being able to split the problems out into smaller chunks let me pay more attention to smaller pieces. Realistically though the best way I felt I've most efficiently learned something is by pairing with someone who knows the subject. Being able to either ask questions or actually pair program in the definition sense has a really tight feedback loop. Instead of boat loads of printfs I can ask questions when I'm feeling lost.
That is pretty much always true, especially with package managers, but the implementation in this case is extremely easy to put in afterwards, judging by the documentation.
[removed]
&gt; acme still here https://play.golang.org/p/MbPUiI4y-IE
Using it to quickly compile go in development
You need to give us a bit more than that to help you out.
Hi kindly give more Info
The caller of this function should wrap its writer in a \`bufio.Writer\`. And don't forget to \`Flush\` afterwards.
FYI, your code block shows up as single un-readable line on old.reddit.com.
I skimmed through your comments and it looks like you're nitpicking on naming and syntactic choices and use very subjective reasoning ("is awful"). It's not awful, it's just different from your expectations.
I would imagine any popular IDE with Go support has integration with the goimports command. I use Goland, but it also worked fine back when I used SublimeText and had a custom on save format command.
wait, is there an option to Makefile?
You could set up a custom writer that injects newlines into byte stream before writing to the underlining writer like: [https://play.golang.org/p/Tzy-m6Cm\_1r](https://play.golang.org/p/Tzy-m6Cm_1r)
at this points we're just splitting hairs here. your definition of "de facto" is wrong &gt; A de facto standard is a custom or convention that has achieved a *dominant position* by public acceptance or market forces. [wikipedia.org/wiki/De_facto_standard](https://en.wikipedia.org/wiki/De_facto_standard) You cannot compare the go tools to make as it's not the same use case. Alternatives to make are cmake, maven, bazel, grunt, gulp, meson, ninja to just name a few. Non of those are nearly as popular as make in the go community thus making `make` the de facto standard. I've been coding go professionally for more then 5 years and this is just my experience mate.
Thanks, that's a good idea. I have just done some experiments with it and results so far are much better: ``` name old time/op new time/op delta _wrap-32 9.50ms ¬± 5% 2.45ms ¬± 6% -74.20% (p=0.000 n=10+9) ```
Sorry to hear that, any advice about how to make it readable with old reddit?
This is really interesting! What sorts of things might it be used for?
A bit late to the party, but I think it mostly depends on: &amp;#x200B; 1. What your intentions are (do you want a fun project to use as basis for learning a language?) 2. What kind of game engine (is it running performance critical code?) 3. What kind of os/hardware is the intended runtime. &amp;#x200B; Some thoughts on each: 1. Intentions, if you you're doing it for learning, then anything goes. If it's for actual games, then 2. and 3. are quite important. 2. Regarding type of game/engine. If it's performance critical code, typically more performant languages are used (C/C++). In addition you want predictable execution time to get steady fps. Having gc jobs trigger at random is not a good property. 3. Regarding os/hardware, keep in mind that if you want to target phone OS you are going from not-yet-mature, to not-yet-fully-born.
For the last time, YES.
Or a custom reader. [To the OP:] Making a custom `io.Reader` or `io.Writer` is almost always a better API then something that takes both and does some kind of copy. There are a plethora of examples in the standard packages (e.g. [`zip.NewReader`/`zip.NewWriter`](https://golang.org/pkg/archive/zip#NewReader), [`flate.NewReader`/`flate.NewWriter`](https://golang.org/pkg.compress/flate#NewReader), [`hex.NewDecoder`/`hex.NewEncoder`](https://golang.org/pkg/encoding/hex#NewDecoder), [`http.MaxBytesReader`](https://golang.org/pkg/net/http#MaxBytesReader). [`iotest.NewReadLogger`](https://golang.org/pkg/testing/iotest), etc, etc). Doing a copy of some kind using any such filter is trivial for the caller to do (possibly as simple as `io.Copy(SomeWrapper(dst), src)` but using a copy-style API such as yours with other filters can be annoyingly difficult.
As /u/nikajon_es said, using a custom `io.Reader` or `io.Writer` is almost always a better API then something that takes both and does some kind of copy. There are a plethora of examples in the standard packages (e.g. [`zip.NewReader`/`zip.NewWriter`](https://golang.org/pkg/archive/zip#NewReader), [`flate.NewReader`/`flate.NewWriter`](https://golang.org/pkg/compress/flate#NewReader), [`hex.NewDecoder`/`hex.NewEncoder`](https://golang.org/pkg/encoding/hex#NewDecoder), [`http.MaxBytesReader`](https://golang.org/pkg/net/http#MaxBytesReader), [`iotest.NewReadLogger`](https://golang.org/pkg/testing/iotest), etc, etc). Doing a copy of some kind using any such filter is trivial for the caller to do (possibly as simple as `io.Copy(SomeWrapper(dst), src)` but using a copy-style API such as yours with other filters can be annoyingly difficult. (E.g. if someone wants to process the result of your "copy" line by line they can't just use a `bufio.Scanner` without something like an `io.Pipe` and a goroutine).
magefile.org
Apparently a lot of people are triggered by things that look like Post-It notes.
It's worth noting that sessions also have many of the problems identified in that article. It's basically written by someone who hates JWT, and wants people to use PASETO instead, and has let that distort their argument.
That looks great! I have never written my own writer, but this definitely looks really good. Benchmark of my ugly integration of your writer ``` name old time/op new time/op delta _wrap-32 9.50ms ¬± 5% 0.92ms ¬±13% -90.27% (p=0.000 n=10+9) name old alloc/op new alloc/op delta _wrap-32 2.94MB ¬± 0% 4.02MB ¬± 0% +36.84% (p=0.001 n=8+6) name old allocs/op new allocs/op delta _wrap-32 15.7k ¬± 0% 0.0k ¬± 0% -99.75% (p=0.000 n=10+10) ``` Thanks.
I recommend taking a look at https://github.com/apex/up
They are not "de facto" as that would mean that they are accepted by the majority, which, as I said, they are not. Just because you point out popular examples of projects that use it, it doesn't mean that the input data is valid. I did an analysis on this and I can tell you that the data above is biased and does not reflect the reality when analizing beyond those repositories.
There is no such package `strv` but if you intended to use `strconv`, there is a function `Atoi`, which converts a string to an integer, and it indeed returns an error. If you want to ignore this error, use `i, err := strconv.Atoi("12")`
VSCode does also, if the go extension is installed. Maybe also have a look at https://github.com/golang/go/wiki/gopls
Does goimports work with modules again? I like goreturns, especially because of import grouping. Alternatively, just gopls for everything.
Help I put in my tracking number but it just keeps telling me "can't load package: package main: "
Is this your same question as https://www.reddit.com/r/golang/comments/caxjmf/return_err_on_sting_conversion/ except with fewer details?
I remember someone saying somewhere that when users have to iterate over a map or slice manually, it makes them see that this is an expensive operation, whereas in Java you would use a big stream online expression and you‚Äôre done. I also like this very much.
I too use gopls but unfurtunately it's not that stable.(So in that case, gopls will handle the formatting and stuff like imports sorting/removing) I hope they (Rebecca and others) will fix the quirky stuff for go 1.13 because I have too close VSC far too often :-(
I disagree with your first part, Go is not object oriented, and thus this/self is factually wrong IMO/AFAIK (i don‚Äôt know the language specs to be 100% sure). I very much agree with the second part though! You have to get used to it, and changing is hell, especially with gorename not working with modules, but as you said, very simple and keeps names clean.
lol golang was funded by google and powers Kubernetes, it‚Äôs as corpo as it gets.
I dislike the way that function is written, and if I would see this in a CR, I would strike it immediately just because this looks like an error is being ignored. Also, `Get` isn‚Äôt a self explaining name, so it should be changed, and if it comes from an embedded struct, the struct should be named, because the function delegations clearly don‚Äôt match.
If you are writing SMTP/MIME bodies (76 bytes) then you probably want to look at https://golang.org/pkg/net/textproto/#NewWriter If you need more control, then the talented emersion has a library for that: https://github.com/emersion/go-textwrapper/ (he also has a dozen of the highest-quality email-related libraries)
Even if I generally prefer this new look, I agree with your remark about the smaller clickable surface of navigation links. It would nice to increase, while keeping the same design.
Gross.
This looks really cool, I will be trying this out!
Yeah same... fortunately it only takes 2 seconds
Goland, VSCode, Atom, SublimeText, Vim, etc.. all handle adding/removing imports as you write them (assuming you have those packages in your module/GOPATH).
I was using `io.Pipe` to pass encoded output to wrap function. Now I can pass customer writer directly to my encoder which again speeds everything up. If anybody is interested here is benchstat (old - with `io.Pipe` and goroutine, new - custom writer passed to encoder function directly) ``` name old time/op new time/op delta _Encode64-32 5.45ms ¬±12% 2.51ms ¬±18% -54.01% (p=0.000 n=10+10) name old alloc/op new alloc/op delta _Encode64-32 6.72MB ¬± 0% 6.69MB ¬± 0% -0.50% (p=0.000 n=9+9) name old allocs/op new allocs/op delta _Encode64-32 1.58k ¬± 0% 1.56k ¬± 0% -0.76% (p=0.000 n=10+10) ``` Life is beautiful.
lol generic
Web servers, web services, microservices, command line tools, anything that requires lightweight but high concurreny (like web services), a JavaScript VM, Docker, Kubernetes, DroneCI etc. &amp;#x200B; Go allows you to write native code in Assembler (differentiation between archs is done i.e. via file names, like \`service\_windows.go\`, \`service\_darwin.go\` (there is a more tunable variant via comments, look up \`build tags\`)), and also allows you to bind C libraries or implement certain functions in C (keyword \`CGo\`, I don't recommend it). Generally speaking, Go is cross-platform, but on the lower levels, you have to handle it yourself (obviously). &amp;#x200B; You can basically do anything in Go, except GUIs... that is literally hell, and you can't do it without external dependencies (like OpenGL etc.).
Microservices
I don't think try is bad, I'm just saying that it defines a new era of Go.
Pfft, `echo` should be enough for everyone.
nobody needs it these days but I started writing a FLOSS CDDA ripper (like EAC and CueRipper). It uses libgio and libcdio underneath. So yeah, I'm utilising CGO which I find surprisingly unpainful. Maybe someday it will get to the state where it autofetches track metadata from Discogs, maybe even fetches the ODD sample offset, and rips the CD into separate or single FLAC files, checks the result against the AccurateRip DB and lastly produces an EAC like log file. I'll probably use the IUP GUI framework (written in C) which supports Linux, mac (I think) and windows.
Especially these days
Hitting [ataris](https://en.m.wikipedia.org/wiki/List_of_Go_terms#Atari) every day
Also check out Micro - [https://github.com/micro/go-micro](https://github.com/micro/go-micro)
I am talking to a 16x16 array of LEDs connected to my Raspberry PI. It was trivial to get it to read images, resize them and display them. So then I moved on to displaying a live webcam. Works great. Development was really fast, since I could develop and debug on my desktop. I used the build feature so I had "screen.go" for my desktop and "screen\_arm.go" for the PI, only used when cross compiling with GOARCH=arm.
I'm making the backend for a website that serves user-generated content. I'm trying to use only the Golang standard HTTP library, so far it's working. SQL with Golang has been a breeze.
Graphics, sounds, amateur games, math experinents, a programming language :)
Should I make web services?
Goin to attempt some kind of data storage on the frontend with gowasm. Just want some kind of persistence.
Cookies? :D How would you do that?
\&gt;except GUIs... that is literally hell, and you can't do it without external dependencies I would argue that web GUIs today are a perfectly great form of GUI, and one that Go is well-designed for without external dependencies. It's cross-platform, and exemplified by its own tools (godoc/guru). A web browser is no more or less an external dependency than a modern OS. Some famous file sharing programs use web GUIs. (Deluge, NZBGet, Freenet). As a non-professional, I think this is actually an awesome, "futuristic" aspect of Go. [https://www.reddit.com/r/golang/comments/5vhvbc/confused\_as\_to\_what\_go\_is\_actually\_used\_for/de3we23/](https://www.reddit.com/r/golang/comments/5vhvbc/confused_as_to_what_go_is_actually_used_for/de3we23/)
But you need front end code (don‚Äôt know much about WASM, but I don‚Äôt think it is easy to do), and then it is essentially a web service, isn‚Äôt it?
I'm interested in the idea, do you have a repo? :)
Mostly small and fun TUI programs
I'm working on a back end for a SPA.
I'm an atypical Go user, because I'm currently writing a large, sqlite-backed multi-platform desktop application with all the bells &amp; whistles you'd expect from one.
No idea yet but just any storage is what will be the first project and then complex. With gowasm now optimized to 16kb, it's finally in reach. It would also help serverless
Yet another repost
Yet another needlessly negative attitude, following with a downvote. I looked for this before posting it but I couldn't see the original reddit post. I searched with different keywords and now it's showing up. I'll delete this, so it won't a repost anymore but please feel free to work on your attitude to save this subreddit from the usual reddit toxicity.
It's pretty easy to write full stack websites in go. You don't need a front end framework.
An Enterprise Web application. Fullstack go with templates/gorm and a bit of js
... that scale
Nice, I see the Go zealots brought their A game. ‚ÄúGo is perfect for GU.... fucking no. Neither is Rust and neither was C. Let it go.
Web servers (public and private), CLI's, and a lot of stuff I would have previously wrote in batch/bash scripts. I work in a 50/50 Windows/Linux world. Some of the Windows stuff is still 32-bit. Cross-compilation, a dependency free binary, and a single code base (for the most part) makes wrangling all these different environments a breeze with Go.
microservices! (Rest APIs)
Lots of microservices backing a large well known site...
Can somebody please ban this fucking bot?
I wouldn‚Äôt expect a different reply in a go subreddit, but this reply is idiotic.
Don't be fooled. Go Playground still has the cigarette-stain yellow background.
GUI programming? What's best? C++ and Python?
I try to write all my command-line tools in C and use Go if those tools need to touch the web at all.
Most things nowadays, though mostly services and terminal apps, but I've also ported a bunch of code from ThreeJS so that I could run a server side simulation for a network game.
ok :] but mind you I'm a total noob in everything (I'd like to be a non-web dev 1 day) and so far only a very small wrapper to the 2 libs has been written (disc eject/close event callbacks, track listing+time, emphasis &amp; copy flags..) https://github.com/engineeror/BloodyRipper
I learned Go in order to write backend services for an Unreal game that integrated with a web page and Twitch. If the game was being played by someone streaming on Twitch, the audience could interact with the game via our web page, allowing the entire audience to vote and make changes to the game as it was being played. The Go service would also connect to the streamer's chat to post updates and listen for commands. These days I mostly use it for command line tools, both at work and for personal projects.
You can't return an error in the `main` function.
In my experience, it works just fine. The Gtk and Qt bindings are practically complete.
What is a TUI program?
What search terms have you tried?
On GUIs, using Qt with Go isn't so bad. I quite enjoyed it last time I used it.
Terminal User Interface, programs like ranger, ncmpcpp, htop, etc
Ooh, got it. I wasn't aware of that abbreviation, for some reason.
APIs for web and mobile applications
web scale?
I love that yellow.
Deploying deep learning models without fuss
&gt; What is wrong with naming receiver (self) variables with a simple one or two characters? In my opinion the receiver syntax design choice is particularly bad because it just adds confusion in that every function is free to name the receiver arugment whatever it feels like, but there's no benefit at all. I mean is it really that bad to have to type `self` or `this`? Or at least make the receiver argument agreed-upon. If it were so, reading member functions would be easier - you could more readily see where and how it acts on the receiver. It's not something that would bite me in the ass _too_ much (although it does a little), but I dislike the decision in particular because apparently it's just for the sake of being different / rebellious against other languages rather than something that makes some practical sense. The private/public field naming is a similarly dumb edgy-teenager-rebellious type of thing. They could at least made it such that lowercase = public, that would make much more sense for JSON serialization for example. But nooooo, they _had_ to be different, and so now you either have to annotate fields for JSON with the same field name with lowercase letter, or have uppercase JSON field names, which is not idiomatic for JSON. TL;DR being different for the sake of being different is dumb (in the context of programming languages obviously, I'm not talking hairstyles or something).
Galaxy scale hypercloud.
Just build a simple go webserver, dockerize and deploy it. When you're there you'll stumble upon enough topics to learn to get where you wanna be some day.
Restful APIs (big monolithic bastards too, get out of here with your microservices), bare metal server installers, CDN management systems, software deployment pipelines, command line apps, etc. Pretty much 90% Go these days, with a bit of Python to keep things interesting.
Huuuge microserives. :(
&gt;https://www.reddit.com/r/golang/comments/5vhvbc/confused\_as\_to\_what\_go\_is\_actually\_used\_for/de3we23/ What are you using for the GUI?
Gtk3: [https://github.com/gotk3/gotk3](https://github.com/gotk3/gotk3)
There is already a big [tool](https://monday.com/) out there called monday. I am not into Kubernetes, but it seems your code has no unittests, how do you know it works?
I use anonymous structs - just tmpl.Execute(w, struct { A string B int C []string }{A: "a", B:7, C:aListOfStrings})
Currently implementing serverless api using aws api gateway, aws lambda written in golang. Works great.
Hi, I know this company but well, this is just a small open source project at the moment, and the name fits perfectly with the tool utility. About unit tests you‚Äôre right, I am using the tool so I know it‚Äôs working but this is what I have to focus now to ensure code is tested and I don‚Äôt break anything on further features. Thanks for your feedback!
Cool!!!, thanks
Just build a simple go webserver, dockerize and deploy it. When you're there you'll stumble upon enough topics to learn to get where you wanna be some day.
Streaming data pipeline micro services
Would you care to elaborate more? What exactly have you been building with Go related to microservices? I'm asking because, after 7 years working with js/ruby on the web, I'm studying systems/networking (and Go obviously!) and really considering to focus on these. Thanks!
Write `if err != nil` the whole time...
Backend API in gRPC for an embedded motor control system.
purchase automation bots.
I concur, the stdlib is more than adequate to start building your microservices.
What library are you using for the LEDs? Most go libraries I've seen are incomplete. (I have a SenseHat with an 8x8)
Ayy, thanks :D u literally gave me an interesting challenge to do in go, gonna try to make a live webcam display asap :)
Why would you write rest these days? When i got into back-end web dev, i first learned rest, then i moved to graphql and now i realized why should i never code REST again. Also i started discovering a RPC protocol and gRPC framework for go.
not just web scale... but MongoDB web scale: [https://www.youtube.com/watch?v=b2F-DItXtZs](https://www.youtube.com/watch?v=b2F-DItXtZs)
Not Go specific but this (free) book is good for learning about distributed systems: https://www.distributed-systems.net/index.php/books/distributed-systems-3rd-edition-2017/
Do share your github
Hi how easy it is to generate desktop app for different os. Do you have idea about electron ? I am more confused now to choose between electron and go. There are some example where we can even integrate go with electron but not sure about scalability
Could you share some examples
Lol I enjoyed this. It hurts because we all have designed beautiful little microservices that have ballooned into massive apis.
[removed]
no idea what might have happened... tell me, did you update to go1.12.7 recently?
[removed]
Hey, your friendly neighborhood cloud developer here, writing the backend services you know and love. I have a few words of advice.. 1) The cloud is huge. You‚Äôll get nowhere trying to swallow it whole. 2) The cloud is made of billions of connecting parts. You‚Äôll never get any traction trying to master any specific component. 3) Asking the community for where to start will either get you a vast array of project ideas, or seasoned greybeards who are pissed at you for not looking into things even at a basic, minimal level yourself. The balance is somewhere in the middle. Go do some stupid easy stuff, then over engineer the hell out of it. Then scale it. Fix all the things you missed. Do it a dozen or more times. Manage all of it. Then, you‚Äôve scratched the surface. It‚Äôs hard, and you have to know enough about *everything* to piece together a feature or story or RCA, Working in the cloud is hard, but not impossible. If you have years, start from the bottom like I did. Literally build a CPU, and be a data center tech. Then work your way up. You‚Äôll be one of the most solid engineers out there, if you do that.
I wrote a horizontally scalable eventually consistent key value store.
Fun project, and I totally subscribe to the mental model of ‚Äúbuild it‚Äù even if it‚Äôs been done, especially if it‚Äôs for learning. Have you played with prometheus and node exporter? You can see how they did it. I stand by that toolset to the ends of the earth.
Wrote a chatbot for discord/irc that parses chat for errors in logs and sentences. It pulls from haste/paste bin sites and others it's configured for. I added OCR so it can read screenshots of errors and it's got a probably 70% read rate. So fairly good I think. I was tired of getting asked to read logs that the people submitting them weren't reading themselves. It has cut back on the most common errors and it is fairly easy to update the config to add new errors we start seeing more. Currently it runs on a discord server with 2k+ people parsing 4 different chat rooms.
Are you using any external libraries for the webcam streaming?
Thank youüôè , I‚Äôll have a look at it
Thank you üôè , I‚Äôll have a go at it (pun intended)
Thank you üôè, I‚Äôll have a go at it (pun intended)
Thanks so much, i pretty much have tons of it which is why I actually want to get out there and do something, I‚Äôve pretty much always been amused at the concept of cloud computing but I‚Äôve never really known where to start. Oh and Thanks again, this is really helpful
New objective, I have a couple projects I‚Äôve considered deploying... guess I‚Äôll start there, thanks
Sure, [here](https://github.com/gorgonia/agogo)'s my reimplementation of AlphaGo, in Go
Couple of month ago I tried by calling the .so C lib using cgo, I didn't went too far because it's actually a lot of work to do anything, was trying to probe my usb sensor.
I thought the question was about learning about pointers (to memory).
Just about anything that doesn't need a GUI.
 Hi, We‚Äôre in the last 9 hours of our Kickstarter about the Go Gopher! (I promise this is the last post about it I‚Äôll make! :D) We have unlocked 7 out of 8 designs, with only Sherlock Gopher to go! You can back today only at [https://www.kickstarter.com/projects/thegrumpyunicornco/greg-the-go-gopher?ref=6oe485](https://www.kickstarter.com/projects/thegrumpyunicornco/greg-the-go-gopher?ref=6oe485)! \-Fynn
I use Go for almost everything in my job, which mostly consist of creating webserver, CLI and GUI app. For GUI I uses Go + QML, which is nice since I can separate logic and view easily.
Including all the business logics?
Thanks much
Has anyone tried GO with Graphql?
Everything (almost) from webapps to data processing (maths)
Glue code. So much glue code. But it's *well-typed* and *fast* glue code.
Have a look at [https://fyne.io/](https://fyne.io/) for GUI. It looks promising. OpenGL is a case that Go needs to improve dynamic loading/dynamic linking support. Most applications I work with are not bothered by the runtime overhead of CGO. But I don't like that I have to have a C compiler alongside to build a Go project.
... if your project did warrant a front-end framework, there is [Vecty](https://github.com/gopherjs/vecty) (basically React but in Go) (disclosure: I am the author)
I did! But I uninstalled it and tried 1.11.6 (the 1.11.x available from `brew`) has the same issue, but not with 1.10.8 (the 1.10.x from `brew`). So it does seem to be dependent on the version of Go ü§î
At [Sourcegraph](http://sourcegraph.com) we use nearly 100% Go for all of our backend services. In particular for: - The core of the application, bridging everything together (GraphQL API, mingling between services, etc). - Our search platform which allows complex regexp search over thousands of repositories. - Our repository management system, which syncs repositories down from all major code hosts (GitHub, GitLab, Bitbucket, Gitolite, etc.) - Our git service, which basically just runs get commands in repositories. - Lots of other random things I am forgetting. Outside work, I also use Go for hobby projects ranging from game development to more recently (and more seriously) frontend development with [Vecty](https://github.com/gopherjs/vecty).
You either die a microservice, or live long enough to see yourself become a monolith.
Yo this is amazing. Great stuff and loved the talk!
"Look at that subtle colouring. The tasteful thickness. Oh my god.. it even has a gopher!"
In mobile the padding is clickable.
I swear this is older than the internet but that would mean it was prophetic rather than pathetic.
It definitely is not for me. In fact, there is no padding on the `a` elements, there is merely a `ul` with `align-items: center`. For me, this is the extent of the link: https://imgur.com/a/xddCx0K
^(Hi, I'm a bot for linking direct images of albums with only 1 image) **https://i.imgur.com/LNSxbLS.png** ^^[Source](https://github.com/AUTplayed/imguralbumbot) ^^| ^^[Why?](https://github.com/AUTplayed/imguralbumbot/blob/master/README.md) ^^| ^^[Creator](https://np.reddit.com/user/AUTplayed/) ^^| ^^[ignoreme](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=ignoreme&amp;message=ignoreme)^^| ^^[deletthis](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=delet%20this&amp;message=delet%20this%20ethec4k)
You're right there is no padding, it was just the mobile browser automatically clicking the nearest element when i tapped near it. Still works pretty well for me.
Programming isn‚Äôt my primary function, but I am working on some simple command line tools to extract data from protocols and to communicate with embedded systems via serial, UDP, and TCP.
This is the first post I saw, this looks awesome! Just backed it!
There is no "best" GUI programming. That's why everyone who is building UI apps these days uses Electron or some other web framework.
Especially these days
Hehe, big tool.
Good luck with that. I wonder how did you, in 2019, reinvent the authentication ü§¶‚Äç‚ôÄÔ∏è
I remember seeing that error before. I seem to recall it was a mismatch between the Go version and the version of XCode (more likely, some library installed by XCode). I solved it temporarily by downgrading Go, then eventually updated both MacOS and XCode to the latest version and then newest Go version worked fine. Is your XCode or MacOS a bit behind?
I have the Sherlock Gopher shirt! It's always a hit at meetups! XD
I and my team were developed a huge API based on microservices for large Europian E-commerce platform with more than 100k customers per day.
Mad scientist gopher is my pick
Very cool project.
What library do you use?
Amazing.
I am going to get this on a mug buddy.
I know fyne, and if you‚Äôve never worked with OpenGL (like me), I find it hard to work out. Not the api, but getting it to work... I actually like fyne and was impressed when I saw it, but couldn‚Äôt quite get it to work
Good for you. Some of us have to interact with stuff that's over ten years old.
Just had a look at it... I'm impressed. Maybe I'll use it someday.
Is the go source code in your GOPATH?
I just found it days ago. Maybe you were testing an older version? I tested it on Windows and macOS and both worked. I even cross built a Windows binary from Linux using the Mingw GCC shipped by Ubuntu. I am waiting for it implementing an Open File widget so that I can use it with less effort for something useful beyond the demos.
I don't have a C compiler installed, and I neither have the time nor the motivation to get these external dependencies worked out... tried the default install methods that they were suggesting, didn't work, stopped right there... I don't have a need for GUIs with Go, and when I do, I use the Web-Stack (latest project of mine uses Angular, and the server is really easy with Go). I am also not a friend of CGo at all, and I don't feel the need to get experience with it.
Yes, the API consumers are usually are React front-ends or mobile apps
goimports is no match for Gland assisting imports.
Control the security system at a 300mn facility. And provide a way for employees to get some info from it, especially where specific coworkers are (it‚Äôs a big place).
I would say ‚ÄúJust do it‚Äù There‚Äôs nothing that super special about a monolith vs a micro service. Just look at the things your monolith does and categorize them into certain responsibilities that can be kept isolated from one another. Then just split the monolithic binary into a bunch of smaller binaries that can live alone. Then it‚Äôs really just about making your smaller binaries talk to one another via RPC or HTTP. I‚Äôd recommend protobuf. Some use cases are communicated better via Kafka, i.e. you have some sort of producer-subscriber pattern. then depending on your requirements maybe you need to get a lossless Kafka service up and running (or pay out the ass for a managed one). Keep in mind that a distributed micro service architecture comes with different problems than a monolith and isn‚Äôt necessarily the answer to all questions.
Any good library for this, other than robotgo
Is it open source?
I try to be at the request level whenever I can.
I see, thanks for the tip.
Thank you for your comment. I created this library for 2 purposes. * Detect memory leak. For example, injecting logging as a hook, and if logs are written many times, we can notice memory leak is happening * Sometimes we want to use custom data structure (e.g. \*Tree, \*Table, ring or so on). Using this library, we don't need to set a maximum size for them and can explicitly free the memory slot that is allocated but unused at every gc run. &amp;#x200B; By the way, I will append these use cases on README with example code
Further context, we found ourselves gluing pieces of serverless and cloud tech together, and found that things were getting messy and the interactions needed abstracting and standardising. Which grew from a service discovery abstraction, into an abstraction for common cloud concepts. It's been written with cloud agnosticism and modularity in mind. Although, it's still currently very AWS centric. I'd love people's thoughts and feedback!
It's cookie based authentication, it didn't took that much time. The most frustrating part is using an orm, but I decided to just move forward and not look for other frameworks/stacks...
delete all binaries that were produced by the previous version. That should solve your problem. &amp;#x200B; If not, do \`go env\` and post it here please
Totally off-topic but thought this is a opportunity: Why do some poeple (including you) add a new line before a function body (like here: https://github.com/joe-elliott/go-rev-proxy/blob/master/proxy/transport.go#L35)?
Those are awesome! You've got my backing. üëçüòÅüçª
When do I get to pick the ones that I want? Didn‚Äôt get the option when I‚Äôm pledging.
After searching through my browsing history on my work laptop, I've found it again: https://git.coolaj86.com/coolaj86/go-watchdog/commit/5c432b5c2b08b53a9fc6267f9ef2a9d61163654c This is pretty much all that was posted. No extra explanation, just this link and them saying they solved it a different way. Perhaps /u/coolaj86 could explain more, but that account seems to have been inactive for the past year.
My brain does this idk why but it says it‚Äôs easier to read and cleaner.
Moss is nice but I find the detective to be the most desirable of these And I guess it hasn't made it The Detective is a great pin for devs who are reviewing a lot
I would define the `model` besides the `app` and define a `db` interface which returns objects from the `model` package. Then write db implementations for the `db` interface. A factory you write which imports `db` and all the `db-implementations` takes all the parameters you get from `spf13/cobra` (the user) and constructs the chosen `db`-implementation and returns it. On creation the `app` takes the `db`-interface to use. You can wire it together in `main` or wherever else apprioriate.
When needing plugable database backends I use the Repository Pattern. This article would give you and idea [https://medium.com/@eminetto/clean-architecture-using-golang-b63587aa5e3f](https://medium.com/@eminetto/clean-architecture-using-golang-b63587aa5e3f)
For multiline functions I find it easier to read, but I think it's mostly just habit. &amp;#x200B; When I first started writing software curly braces on newlines was the standard format and it took me awhile to convert to inline curlies. At first it looked cluttered, but after doing it for awhile it started to look natural. Also it saves so much vertical space I could never go back at this point. &amp;#x200B; If I started forcing myself to leave out that newline at the beginning of the function I have a feeling it would be a similar transition.
I think I figured out (TIL this was possible in sqlx): package tests import ( "testing" "github.com/DATA-DOG/go-sqlmock" "github.com/jmoiron/sqlx" "github.com/stretchr/testify/assert" ) type B struct { Name string `db:"name"` Age int `db:"age"` } type A struct { B *B `db:"b"` Name string `db:"name"` } func TestNested(t *testing.T) { mdb, mock, err := sqlmock.New() assert.NoError(t, err) defer mdb.Close() db := sqlx.NewDb(mdb, "sqlmock") // rows := sqlmock.NewRows([]string{"b.name", "b.age", "name"}). AddRow("Heisenberg", 55, "John") mock.ExpectQuery("SELECT b_name AS 'b.name', b_age AS 'b.age', name FROM temp LIMIT 1").WillReturnRows(rows) // aa := &amp;A{} assert.NoError(t, db.Get(aa, "SELECT b_name AS 'b.name', b_age AS 'b.age', name FROM temp LIMIT 1")) assert.NotNil(t, aa.B) assert.Equal(t, "John", aa.Name) assert.Equal(t, "Heisenberg", aa.B.Name) assert.Equal(t, 55, aa.B.Age) }
Cool! Thanks for the explanations :)
I'm personally a big fan of naming packages by domain. This makes code easier to find, and allows your code to "scale" more easily (i.e. as your application grows more complex, you don't end up with mammoth nondescript packages like "models"), and it has the advantage of making your code read better (e.g. models.FlightProvider vs `flight.Provider`). If you have app-wide types (see projects like [upspin](https://github.com/upspin/upspin)) then I'd make a package named after your project (e.g. `upspin.Location`). As for `api`, again it's quite nondescript and doesn't scale well if you want to grow it. It doesn't tell you what kind of API it is. I normally have domain packages, and then within them a package called either `grpc` or `http` usually. A project could have neither, one, or both of those things, and it is able to follow that convention the whole time. For example: products/ http/ handler.go (maybe you choose to split this into multiple files) As for allowing different database drivers, you just want to provide an abstraction over how you interact with your data. A good solution for this is to make an interface with methods defined to interact with that type of data, wherever it is stored - then just make multiple implementations of that interface, and based on the user's choice use that interface at runtime. I'd recommend poking around in upspin to get a feel for how they've laid out their project. There are a few things to think about when organising packages, the most common things I think about are; how it's going to read elsewhere in my code, and f the way I'm structuring this cause circular dependencies.
So, if I understand it correctly, you want your app to support multiple types of databases. If so, what you need to create an interface for database access. For example, say you have a contact app with the ability to create, update and delete a contact inside the specified database. And, in this case you want your app to support several type of databases, e.g. SQLite and MongoDB. First, you need to create an interface for database access : File *database.go* : ```go type Database interface { InsertContact(model.Contact) error EditContact(model.Contact) error DeleteContact(id int) error } ``` Next, create struct `SQLiteDatabase` which implement our interface : File *database-sqlite.go* : ```go import "database/sql" type SQLiteDatabase struct { sql.DB } func OpenSQLiteDatabase(path string) (*SQLiteDatabase, error) { // Code for opening SQLite database } func (db *SQLiteDatabase) InsertContact(contact model.Contact) error { // SQLite specific code for inserting contact } func (db *SQLiteDatabase) EditContact(contact model.Contact) error { // SQLite specific code for editing contact } func (db *SQLiteDatabase) DeleteContact(id int) error { // SQLite specific code for deleting } ``` Do the same for our MongoDB : File *database-mongodb.go* : ```go import "database/sql" type MongoDatabase struct { sql.DB } func OpenMongoDatabase() (*MongoDatabase, error) { // Code for opening MongoDB } func (db *MongoDatabase) InsertContact(contact model.Contact) error { // MongoDB specific code for inserting contact } func (db *MongoDatabase) EditContact(contact model.Contact) error { // MongoDB specific code for editing contact } func (db *MongoDatabase) DeleteContact(id int) error { // MongoDB specific code for deleting } ``` Now, in your main file, check which type of database that user wants and open it : File *main.go* : ```go package main import ( "fmt" ) func main() { var db Database var databaseType string // TODO: receive which database type that user wants // Open the database switch databaseType { case "sqlite": db = OpenSQLiteDatabase("path/to/db") case "mongodb": db = OpenMongoDatabase() default: panic(fmt.Errorf("Unknown database type")) } // Send the database to your api controller controller.DB = db } ``` Now your API controller can access the database by using the interface without worrying which kind of DBMS that used by user.
\`types\` package defines all the structs that you want to have in/out of the db \`db\` package defines all the interface methods that CRUD the structs from \`types\` \`mongo\` package implements MongoDB version of db interface methods \`mysql\` package implements MySQL version of db interface methods and so on.
Aw, missed it :-(
A survey will be sent out - I assume we provide our choices, plus shipping information, via that. (The Kickstarter page says the survey is due by late July...)
Coming from C++ where I was constantly doing new-line brackets my boss got very annoyed with me doing it in Go. Took a while to break the habit. :P
GraphQL is horrible for Go, using reflections, because of the statically typed nature of Go. gRPC is good where the consumer is not a browser.
Tried a couple of months ago, libraries were still horrible for GraphQL, and I think this will remain as-is, because with GraphQL you're essentially trying to cram a dynamic data model into a statically typed language
Hi, Goch is a live-chat server written in Go, using NATS-Streaming, Redis and Websockets for communication. You can read more about it [HERE](https://www.ribice.ba/goch/). Alongside Goch I released [MSV](https://github.com/ribice/msv), A minimal http server. Quite often I start working on a new project, I find myself writing things from scratch like middleware, graceful shutdown. MSV wraps these things up in a small package with sensible and minimal dependencies.
Frick I missed it :( any chance there's a way to jump on after the fact?
Which browser is that? Mobile Chrome on Android isn't doing that for me. Maybe it's a setting‚Ä¶
Could be a truth, forgot to mentoin that im writing graphql apis in nodejs, not in goüòÇ
data processing on mass spectrometry data
Just checked, up to date on both MacOS and XCode :/
Any chance this will get recorded? I really want to go, but I won't be able to make it.
For typical go projects? Make is adding additional complexity for almost no benefit (especially if the team isn't already very familiar with makefiles). Just type \`go build\`. For complex cross-language or cross-compiled projects? Some people like Mage better (especially people who like the concept of makefiles but don't have decades of experience making them super familiar with the syntax), but for the most part Go hasn't done anything to replace make in those scenarios.
Hmm, makefiles can do much more than just building stuff. We do fairly complex things with it - setting up development environments, calling some bash scripts etc. if we didn‚Äôt have it, it‚Äôd be a bunch of sticky bash scripts instead.
Use a a repository adapter using the hexagonal (ports and adapters) architecture. - internal/userRepoPSQL - internal/userRepoMongo - internal/user userRepo := userRepoPSQL.New() user := user.New(userRepo) user.GetBy(id string)
You might also be interested in [https://github.com/google/go-cloud](https://github.com/google/go-cloud)
Like everyone else, lots of API servers (both REST and gRPC). But, the interesting work I'm doing is in Machine Learning. We are using some existing projects (gonum being a big one), but we are also implementing a lot of algo's ourselves. I'm trying to get the OK to open source some of them.
Mostly API work. GRPC/protobufs stuff.
We have node and python services, too. This library has a corresponding Node/Python version, so we needed parity with those really, and not just a Go based solution. I have looked at Go Cloud a while back, looks really cool!
any shot you'll do more orders later? just missed it
These are a few of the things available in the latest beta release, to be out as stable in a few weeks: - [Debugger Improvements](https://blog.jetbrains.com/go/2019/07/11/goland-2019-2-beta/#debugger_improvements) (including function call support, better debugger representation of values, hiding uninitialized values, etc.) - [Improved Default &amp; Darcula color schemes](https://blog.jetbrains.com/go/2019/07/11/goland-2019-2-beta/#improved_default_darcula_color_schemes) - [Support for Go 1.13 features](https://blog.jetbrains.com/go/2019/07/11/goland-2019-2-beta/#support_for_go_features) - [Custom Postfix Completion and .aappend templates](https://blog.jetbrains.com/go/2019/07/11/goland-2019-2-beta/#custom_postfix_completion_and_aappend_templates) - [Quick-fixes based on Change Signature](https://blog.jetbrains.com/go/2019/07/11/goland-2019-2-beta/#quick_fixes_based_on_change_signature) - [Extract Method with returns](https://blog.jetbrains.com/go/2019/07/11/goland-2019-2-beta/#extract_method_with_returns) - [Code Completion](https://blog.jetbrains.com/go/2019/07/11/goland-2019-2-beta/#code_completion) - [Cleverer Go Modules and dep integration](https://blog.jetbrains.com/go/2019/07/11/goland-2019-2-beta/#cleverer_go_modules_and_dep_integration) - [Code Inspections](https://blog.jetbrains.com/go/2019/07/11/goland-2019-2-beta/#code_inspections) - [Code Editing](https://blog.jetbrains.com/go/2019/07/11/goland-2019-2-beta/#code_editing) - [UI Enhancements](https://blog.jetbrains.com/go/2019/07/11/goland-2019-2-beta/#ui_enhancements) - [Other handy updates](https://blog.jetbrains.com/go/2019/07/11/goland-2019-2-beta/#other_handy_updates) - [Version Control](https://blog.jetbrains.com/go/2019/07/11/goland-2019-2-beta/#version_control) - [Kubernetes](https://blog.jetbrains.com/go/2019/07/11/goland-2019-2-beta/#kubernetes) - [Shell Script support](https://blog.jetbrains.com/go/2019/07/11/goland-2019-2-beta/#shell_script_support)
There is one for rest
Put some test cases.
I'll be interested to see if with the module support improvements it supports sub-modules (ie. a second module file in a sub-directory to exclude it from the main modules or version dependencies separately). I had a issues on the current version with anything other than the root module.
Tcell and tview
One thing to remember about microservices is that it doesn‚Äôt actually help the technology scale, or make it faster to develop. It almost always hinders both of those. But it does help make the company scale easier. It‚Äôs a technical solution to a non-technical problem.
Well darn... also missed it!
Code formatting is off. Could be because I opened in phone. It's way too off.
Hm, then again, it might be that the Go binary was compiled against an *old* version of XCode. I'd say to stick with the release that works unless you *absolutely* need anything from the newest release, until the issue is fixed. Hopefully your actual build environment is a bit more stable (Docker or a build server).
Just a callout - reader and writer work in bytes. If your "text" is actually unicode and has multi-byte characters, then it's not safe to insert splits at a particular byte position without more checks about it falling on a character boundary. Unicode also specifies a number of code blocks for characters that modify other characters, so even a character boundary isn't ideal.
Can you describe the use-case and how to reproduce the problem? I'm not sure if I recall any bugs opened against our tracker and if we don't know about issues it's likely they won't be fixed. Trying the IDE and giving us feedback is one of best things to do right now.
&gt; I wish to develop this application with the ability to use either a RDBMS (eg Postgres or Sqlite), or a NoSQL style database (eg ArangoDB). Don't do this. Never do this.
Oh, thanks for explaining that! Ill keep that in mind. I am actually just a curious student and wanted to try out microservices because i have been hearing a lot about it easily.
Curious, why are you porting a bunch of code from python to go? What is the primary driver?
That's not the answer i expected xD but yeah sounds like a good idea. Thanks for the advice!
I see that the mock columns you define are with a dot (e.g. 'b.name') where as SQL query uses underscore with an alias that includes dot symbol. Shouldn't this be the other way around? My rewrite: ... rows := sqlmock.NewRows([]string{"b_name", "b_age", "name"}). // here AddRow("Heisenberg", 55, "John") mock.ExpectQuery("SELECT b_name AS 'b.name', b_age AS 'b.age', name FROM temp LIMIT 1").WillReturnRows(rows) // aa := &amp;A{} assert.NoError(t, db.Get(aa, "SELECT b_name AS 'b.name', b_age AS 'b.age', name FROM temp LIMIT 1")) ...
It would be great to see the actual sitename or any indication where I am being led to. Regarding the site, as already said codeformating is now so great, at least on mobile. Cheers.
Have you tried [golang.org/x/text][1]? [1]: https://godoc.org/golang.org/x/text
NP, and if you get stuck, the best thing is now you might hopefully have a more concrete ask / question. it‚Äôll be easier to google and get help for. And if google fails you then you can even ask the question yourself, on tons of different forums and even chat channels!
x/text is certainly an option. Have you seen a good tutorial for it? One requirement we ultimately need to support is being able to hook into some of our existing translation tooling (right now we send .pot files to CrowdIn where translators do their thing). It seemed less clear how we'd support this with x/text. Is it working well for you?
That's something of a long story. I should write a blog post about that some time. I think the short summary would be: * Need to move off of Python 2 * Because of other changes to the cloud environment and our frontends, we need to make more changes than just Python 2-&gt;3 * Go's performance will be a big cost win for us
To be honest I only recently has discovered it, so, can't help you much, sorry.
The b_name is just the name the column would have in the table "temp" (as temp.b_name). Just an example. The only annoying thing is that you have to always pass an alias, so the column name includes the dot. This way sqlx knows how to map it back to the nested struct. I didn't dig enough into sqlx, so maybe you can overwrite the dot char.
I know I'm feeding the troll, but... The point of Go's error handling is exactly because too many exception-based languages just didn't. It's endemic to have a single try clause at the top level and let everything bubble up to that.
Having written services in both languages, there's a myriad of reasons I've found why python is a terrible language for production. Python's duck typing makes for very rude surprises that only pop up during execution, where golang finds them during compilation. Also golang makes it quite easy to avoid panics, where Python loves to crash and burn...
I've had loads of problems with Goland. Soo slow. And buggy. Have you guys fixed the excessive slowness when working with large projects? seems like it takes forever to do anything.
Works like a charm for all my team members. What os do you use?
I put the wrong date whoops. It's actually next week!
Windows 10 and fedora 30. Sucks on both.
‚ûú api git:(dev) cloc . --exclude-dir=vendor,.idea 1135 text files. 1102 unique files. 66 files ignored. github.com/AlDanial/cloc v 1.82 T=2.51 s (430.6 files/s, 135426.4 lines/s) ------------------------------------------------------------------------------- Language files blank comment code ------------------------------------------------------------------------------- Go 905 40703 8383 280699 Lua 14 857 1146 2853 SQL 26 115 0 1107 Protocol Buffers 36 212 40 886 Markdown 24 261 0 815 JSON 5 0 0 508 TOML 39 13 6 243 RAML 1 0 1 133 Bourne Shell 12 38 5 75 make 6 21 7 49 YAML 2 0 4 47 HTML 3 2 0 47 Dockerfile 5 21 0 38 R 1 1 0 13 ------------------------------------------------------------------------------- SUM: 1079 42244 9592 287513 ------------------------------------------------------------------------------- Works very fast for me, except when I clear it's cache and it has to rebuild index.
sed/awk
I never investigated enough to file a decent bug report, and previous issues were put off because the module support and spec wasn't finalized. If module support is in a place now where everything should work, I'll try and find some time to reproduce it and build a minimal test case. The short version is that the spec supports multiple go.mod files in sub folders, with the stated goal of being able to exclude folders from the module or maybe manage the dependencies separately. My use case was investigating not including the dependencies for tools into the main module for a codebase, but when I added a module in a tool subfolder, I couldn't select any other module in the "build" dropdown, and it ended up with strange dependency failures that did not happen when I ran go build manually.
Nice! Just starred to check it later, good job!
I can't get into GoLand. The UI screams I'm not native to your platform (worse than VSCode)
There might be some corner cases we don't support yet, that's why I asked on how to reproduce the issue, we can do the investigation if we have a way to replicate the issue. I think I understand the use-case now and I'll see if I can replicate it, then either file an issue or ask you for more details. Thank you!
Sorry to hear. It would be helpful if you could file issues for these problems so that we can fix them. We treat performance problems very seriously, like any other issues affecting the productivity of our users. So please, if you have issues, either open an issue on our tracker at https://youtrack.jetbrains.com/issues/Go, send me a mail "florin at jetbrains com", or ping me on twitter/Gophers Slack with `@dlsniper`. Also, give the Beta version a try as our team spent a lot of time optimizing the IDE and underlying platform so maybe the issues you encountered were fixed along the way. If not, that's what the Beta release is for, to help us find and fix such bugs _before_ a major release. Thank you and looking forward to hear from you.
There's definitely a matter of taste. Personally, I keep my IDE instance out of the way as much as possible, and there are many other things to make it look and feel native if you want. In fact, the UI was been improved overtime to make it better integrated with the OS and there are native themes for both Windows and Mac. We'd love to hear from you where we fall short to improve in this area. Btw, here's how I keep my IDE: [like this](https://i.imgur.com/jUMeK8F.png)
There is a remote sdk in paid version of JetBrains IDEA and PyCharm for python, but I don't see same feature for go root
Hugo uses go-i18n. [https://gohugo.io/functions/i18n/](https://gohugo.io/functions/i18n/) So it's probably the best solution.
So happy about the cleverer go module support. That's basically been my only complaint recently.
This is how I‚Äôve done it in the past.
Instead of replacing the paths with absolute paths, have you considered the myriad of env variables for Go which can define pretty much where everything is? If you‚Äôre using make to build (which I HIGHLY recommend), there‚Äôs even more you can do. See https://golang.org/cmd/go/ for details. üòÅ
pkg/errors is nice
Make sure you are using Go &gt;= 1.11 on the new machine
Agreed. It's written in Java. Garbage at it's core.
It was I who opened the tickets for better time.Time display in the debugger and showing the .String() of a struct in the debugger! Praise me ye fools who know not how to open a ticket on youtrack!
It‚Äôs the least buggy, most fully featured ide on the market. If you can‚Äôt get over aesthetics, then you can go enjoy having Xcode run 20 infinite loops for no reason on your own time üòÇüòÇüòÇ
Goland has excellent language support and tooling. Seriously, any perceived warts, customizable or otherwise pale in comparison to the utility it offers me. Please keep it up.
Making something like this is the coding challenge my employer gives to applicants... Are you joining my team?
I appreciate you asking for feedback. I'm sorry if this is too blunt. Downloaded it again. First dialog ("Import GoLand Settings From..." has radio buttons that do not look like macOS UI. There is a second ring around the radio button in GoLand, macOS UI controls do not. Your radio button doesn't dim when placed in the background and it stays active, which is also against the HIG. Also, the dialog font isn't using the system UI font, which feels a little off. Aside from the rest of the IDE looking off in a number of places, menus are slow responding the first couple of times. It's weird. I could go on, but bottom line: I use a Mac because I like using the Mac user interface and GoLand feels like someone trying to fake it and sluggish. (To be fair, VSCode has the shittiest popup menus on the platform, so my disdain for non-native editors isn't just reserved for GoLand.)
Maybe, if it's remote friendly ^^
Thank you, I had no idea I installed an outdated version
Buffalo is bad at being a Go library, and is bad at being Rails.
Of course, it's a matter of taste, but I prefer theming support over native look. I like to change themes often just for the fresh feelings and apps that look native often don't have this.
I don't know if the app I wrote with buffalo is a bad buffalo app or if buffalo itself is bad but either way the app is bad.
I got most of the way through a Buffalo app before I scrapped it. Trying to do Rails magic while also having static typing is silly. Buffalo drops into interface type too much for me to think it's a good idea. It made me feel especially silly since it is just an objectively worse version of Rails. If you like that style of dev, no shame, but choose Rails then.
GoLand is a bit of sunshine in my day. I've been an IntelliJ user for a long time. I use go exclusively besides occasional configuration language use. GoLand is so good at what it does, and debugging has become more features and usable. Good job, JetBrains!
Just give me gorilla/mux and I‚Äôm good to Go.
Not any worse than JS crap ;)
You must be accustomed to slowness working with Electron abomination ;)
A framework is very useful when you need to scale, even if just a simple one. Helps maintaining consistency for example
I didn't say that using a framework was bad. However, I have written many monoliths and microservices with and without the use of a framework, and over the years of my professional career I've grown to dislike using large frameworks and prefer working with smaller components.
Yeah I am not a big fan of large frameworks. I tried Buffalo but clearly didn‚Äôt work out :) but you always do need a framework - even if you don‚Äôt use one, you almost always end up ‚Äúwriting your own‚Äù anyways
Unfortunately not
Having worked with PHP and Go. I can't deny that for small applications PHP does offer lower barrier to entry.
Go isn‚Äôt very good at websites. It‚Äôs great at webservices. Stick with those for Go. Use something else for full stack stuff.
Agreed. Go isn't a web dev language. Not in the sense that PHP is atleast. Go has a place in the web, but it isn't in building DOM. It's in supplying data to front end consumers.
Hoping to see a remote server feature like vscode's remote development suite in Goland, in the future. Love Golang but it's the only missing feature that prevents me from moving to Goland from VSCode at my job.
It is...
Not sure about GoLand, but you can do remote ssh in PyCharm. Unfortunately you have to pay for it as it's not in the community edition. Also they don't support remote WSL. VS Code is pulling ahead for me thanks to these features. Jetbrains need to drop their prices.
Saying that you "always" need a framework would depend upon how generalized your definition of "framework" is. A library full of useful functions could be considered a framework. Generally, when I hear the term "framework" I think of OOP and its many patterns with classes and interfaces meant to be extended within user-written code.
I am riding on a license from a previous gig. Probably gonna expire soon. So yea I feel your pain.
github.com/blackjack/webcam
The one in periph.io. periph.io/x/periph/conn/spi
&gt; form validation For simple cases's gin's gin#Context#Bind has been helpful. For more complex cases you'll have to augment. Generally, I don't agree. I find PHP brittle. Error handling is a mess (json_last_error). "Errors" are important. We should think about every error our applications may encounter.
I think, these days, the closest I get to a framework is using echo - just depends on how lazy I'm being. &amp;#x200B; A year ago we started a company around a microservices framework, that's just created headaches. Seems that's how it goes every time we use frameworks.
Ah, yes. So implement a common db api like I was thinking, but initialise and pass around a particular db object in the app. This is the bit I was missing. Thanks.
You make some good points. I will take a look at the upspin project. I was considering doing `api/rest`, but then would I need `api/db`? Your suggestions would not need an answer to that question.
Go is a decent alternative to C (not that there is anything wrong with C). PHP is great for making dynamic web pages, and while it can certainly do more, I don‚Äôt think it would be my first choice for anything else. While Go has some great abstractions for the web in its standard library, I don‚Äôt consider web development to be its core strength. I think Go‚Äôs real strength is concurrent processing.
Go really excels at backend services, bridge apps, and async processors. It can be used for even more than that but those are where I think it really excels.
Yah don‚Äôt think go should go any further than offering an end point
It's more of a Jetbrains theme than an OS-Theme... I see how using your first Jetbrains IDE might seen weird but once you get used to them you'll actually appreciate the homogeneity across all platforms As a guy who uses Mac for 50% and a PC due to raw horsepower for the other 50% I'd have my issues with OS-specific designs in my IDEs Apple generally tends to present you with fewer data per screen and generally favors cleanliness over dashboard-like efficiency As a dev you'll need to bear quite some cognitive load anyway and having more stuff crammed in your screenspace isn't that bad if it removes interactions that would otherwise take time
Do you have a reason to *not* use a HTTP POST?
Do check https://awesome-go.com/
[removed]
Nope.
I found golinting very slow in vscode
For backend in nodejs, it is easier to use framework like express or nestjs. In go, do we need some framework? Or do go already has built-in module to do that?
Have you looked at "os/exec", specifically creating an "exec.Command"? You can delay the call to Start and hook into the stderr/stdout of the subprocess.
I‚Äôm interested in community opinions on this, as I‚Äôm between the two myself.
I've heard of Prometheus but haven't dug into it I may take a look.
I went to a seminar thing on Buffalo at GopherCon and was super disappointed. We're using Go because we're tired of Rails and all of its magical bullshit...
A few months ago I liked VSCode more than Goland because with all the plugins and tools it was really easy to work with and Goland still didn't feel mature, but I'm also working a lot with Pycharm and IMHO there are no better python IDEs, so I just couldn't handle all the shortcuts and tricks for both and decided to go with Goland also. After a few months Goland started feeling really better and it's my go-to tool right now. I'm only using VSCode for fast editing files now.
1. Apache connections 2. Putting arrays into arrays and what could go wrong? 3. All the 3rd party tools you have to buy in PHP is just a shame. 4. Context in the server or servers is terrible in PHP. 5. Monolithic OOP enough said 6. Mixing frameworks, cause a dynamic language just never is productive enough 7. A file for every class, what a great idea years in. 8. Not being able to uncouple or reuse code...... Actual reusable code 9. ::Self 10. Updating old code and paradigms 11. Updating versions 12. No one uses templating unless you have a one off app or an extremely expensive AWS server (Notice the scaling issues?) 13. -&gt; cause you just can't have one 14. No thank you ``` 14. 0 =&gt; { A =&gt; 22 B=&gt; 44 C=&gt; { E =&gt; 66 F=&gt; 88 } ``` 15. Stating types is a new feature.... In a dynamic language...... 16. Composer: cause let's put that dependency anywhere 17. Caching in Apache.... Love it at scale 18. Reuse this array_push($hex, strtoupper(dechex(bcmod($number, '16')))); 19. Read this ```` if($step&lt;=$digits[$chars[$i]]){ $step=$digits[$chars[$i]]; $retval+=$digits[$chars[$i]]; } else{ $retval-=$digits[$chars[$i]]; } } return $retval; } ```` 20. &lt;?php include("menu.php"); ?&gt; Some random file in some folder that now there is many of 21. You can never have enough folders and files. Never ever never 22. Inheritance of giant god objects. Why would this be bad over time?? 23. Separate repos in a monolithic with a limited amount of connections does wonders 24. The million different ways of writing most anything is just so much fun to read and understand in a couple year code base. 25. Facebook dropped it for many big reasons https://hhvm.com/blog/2018/09/12/end-of-php-support-future-of-hack.html 26. Scaling... Did I mention scaling??? Wow I could go on.
https://blog.jetbrains.com/go/2019/02/06/debugging-with-goland-getting-started/#debugging-a-running-application-on-a-remote-machine
I like Goland as VSCodes interface lags horribly in my virtual machine environment... like what kind of company builds an IDE in Electron? Java is bad enough. Anyhow my opinion and others who post is really the Go version of EMACS vs Vim editor war ;)
I found that VS Code linting wasn't near as reliable as it is in Goland. Goland also handles modules and dependencies far better than VS Code does, especially if you're deving outside of your Gopath. Finally, stepping through functions and getting function and type signatures is amazing in Goland. That command + click is an amazing feature.
Used Webstorm with the Go plugin (before spun-off into it's own Goland product), and the initial Goland early versions. I love them. Then I got a job where they forced all devs to use vsCode. I'm pretty "anti-Microsoft", even though vsCode is open source... so I struggled. I tried it, and after a month or two... absolutely loved it. That was almost two years ago. Today, I'm now looking at Goland... because I'm absolutely tired of fighting vsCode (even with language server configurations, etc.) to behave nicely with Go modules. Tired of intellisense breaking, and having to 'rig' up configurations for things to play properly. My job now doesn't have IDE requirements, and most use Goland. After talking with a co-worker, seeing where Goland has become, and the issues I'm dealing with literally every day with vsCode now... I'm making the change back to Goland.
I'm very used to the JetBrains IDEs and favor Goland over VSCode. VSCode needed a lot more plugin wiring and configuring for go development, while Goland has most everything I need right out of the box. I feel like JetBrains stays pretty well on top of language features. Goland and the plugins I use (namely editorconfig, protobuf, toml, swagger, and cucumber support) see pretty regular updates. The big thing that stands out to me in VSCode is their pretty awesome live editing, terminal, and network port sharing with peers feature. I wish Goland had something like that. In the end use whichever is most comfortable and gets the job done. To me that's Goland, but for many it's VSCode. I've got a coworker who writes go in vim because that's what he's most familiar with. Since you've already got the license give it a try for a week and see how you feel. Both are great editors, and there ain't no shame in switching around.
For a while, over ten years ago, I was building apps (in PHP) and I wasn't using any framework because I didn't like the options at the time (Laravel and other cooler things weren't there). I realized at the end I had just created my own framework and I was re-using it for all the apps. So yes, you always use a framework, or you build your own. Unless your app has a single route, maybe.
He Is right on this part. The session management in not supported nicely out of the box. (with sth like [github.com/alexedwards/scs](https://github.com/alexedwards/scs)) it becomes manageable, but still far cry from what you get in PHP Templating sucks even if you use something like [github.com/CloudyKit/jet](https://github.com/CloudyKit/jet) comparing it to something like twig. Form manangement &amp; validation is better with something like [github.com/mholt/binding](https://github.com/mholt/binding)
&gt; I have never in more than 20 years of web development in PHP used a framework, I have always only used libraries with useful reusable code for the stuff you do regularly. You're really missing out. The big PHP frameworks are broken into components, so you can pick and choose what you like from each instead of loading the whole magilla. I'm partial to Symfony's console library and Laravel's support library for their excellent collections. (okay back to talking about go now)
Oh I thought you meant moving away from Buffalo, NY - And wondered why you needed to write app for that.
Gateways, proxies, basic API abstractions, extremely fast key value stores, chat servers. Basically anything that is IO bound.
Buffalo NY is frigid but is it a mess tho?
I think most of your frustrations come from trying to build web sites as if you were using PHP. Many modern sites pair a JS-based frontend (with the help of something like React or Vue) with a backend written in X language, and this approach works well with Go handling the backend side.
GoLand &amp; vim are my go to‚Äôs!
I use both but prefer goland for writing go
Goland has a much better debugger IMO and extremely robust support for testing and complex build configurations out of the box which is a huge win
Hey - not being snarky, but what does this solution give you that isn't covered by using a dotfiles repository? Like this: [https://www.atlassian.com/git/tutorials/dotfiles](https://www.atlassian.com/git/tutorials/dotfiles)
homebrew?
Even on physical hosts with nvme drives, 32gb of ram, and 8 core intel boxes vscode lags. I have on the other hand ran goland on my quad core laptop and even then had a much better experience than on a desktop with vscode.
VS Code Pros: \+ Lightweight compared to GoLand \+ Free \+ Switching to other languages is really simple \+ Code validation/linting works quite well \+ Sufficient for most use cases \+ Consistent Look &amp; Feel across languages GoLand Pros: \+ Code Suggestions are a bit more intelligent \+ Code validation/linting works even better and faster \+ Can handle large code bases \+ Knows your code better than VS Code My personal conclusion is that VS Code will fit perfectly for beginners since it is simple to use, works out of the box and will be sufficient for any smaller to mid-size project. However, if you're a more experienced developer working on larger code bases with a more complex architecture and more dependencies, GoLand will make your life easier.
I like the idea, and I think that the \`settings.json\` is the most interesting part, especially if let's say the apps were to be built-in and you could pick from a predefined list. Regarding your code style: you never pass any errors back to the caller function so there is some optimizations to be done there. Good luck!
Nothing beats IntellIJ
I found that [go-cmd](https://github.com/go-cmd/cmd) works quite well. And should be more reliable than using bare stdlib.
(as said dotfiles exist...) Still I find the style decent. You don't handle filewrite errors and use different ways of writing. Variables depending on distance of use can be less verbose. &gt; func createSettingsFile Could be written closer to the happyline, `ok == true`.
Use parser to rewrite the import nodes.
so gay
Goland is my saviour. If you can not buy for some reason, U can use goland eap which is kinda stable for me and it's free
Looks interesting, but is the project still active? Last commit was 7 months ago, and there are exactly 0 issues (whether open or closed).
if you inverted this statement it would be true.
the problem is go does not have generic. i was part of the orm contributor and realise its getting really difficult to maintain due to interface and magic going on. its not type safe alike rust
Thanks. But it seems like it's remote debugging only. Do you know if there is also a way to build and execute the compiled binary in the remote vm?
Do you mean the `gometalinters` or the ones enabled by default?
You could do a grep on relative path's like " import ./", store the result in a file. then sort unique, then you have all unique relative dependencies. If it is a couple, you could replace-all them by hand, or write a small program to do this You could use this: [http://blog.ralch.com/tutorial/golang-tools-refactoring/](http://blog.ralch.com/tutorial/golang-tools-refactoring/) or look at gorename: [https://github.com/golang/tools/blob/master/refactor/rename/rename.go](https://github.com/golang/tools/blob/master/refactor/rename/rename.go)
You should probably file a bug. if the process has already ended, Wait should return immediately.
I can do in Go in a day, what I can do in PHP in a day :-) (But then again, I'm the Go trainer in our company.) Perhaps, in the beginning things are not that fast, but you gain knowledge along the way, and learn new tricks too. Go is by far superior, so if it is not the speed of development, it for sure is worth to rebuild stuff. Btw there is php2go, which will help you a lot (if you want to keep php memories): [https://github.com/syyongx/php2go](https://github.com/syyongx/php2go) Go is good in websites and superfast. (I render webpages in microseconds, which can never be achieved in PHP), and without apache or nginx or... (done with a template engine comparable to twig) We do various stuff with Go, webdev being one of them. Don't listen to "the others", they obviously have no professional experience with PHP and Go.
Seriously, what's wrong with Go's native http server? I feel people need to use a framework to make them feel secure, like, I'm good, because I'm protected by this framework. Frameworks have a lot of magics inside. How can you build your project on top of something you don't know what they are doing. It's all about you get a JSON, and you do something with that JSON, and send a JSON back, simple as it is. I built all my projects like this and I couldn't be happier.
Look at the Repository pattern. A repository is the only thing in your application that connects the application to a datasource. It could be cvs, xls, database,api. The repo is your "data-agent". If you configure a data-agent to a a specific datasource, the rest of your application doesn't need to know where the data comes from (it comes from the repo, that's all they know).
That's the biggest lie that you don't realize. Framework will not help you scale or maintain consistency. They are all your jobs. You need a framework because you have no clue how all things work and you don't want to investigate and you just blindly depend on the magic that frameworks promise you. Usually your projects will get doomed as frameworks upgraded their major version numbers.
you might wanna have a look at [https://github.com/mxcl/Workbench](https://github.com/mxcl/Workbench)
PHP is getting better at it, with an exception thrown on decoding invalid jsons at 7.4. Generally I find the error handling pretty good, with multiple catches and stuff.
I'm waiting for the sequel: "I rewrote my JSON REST service to remove the framework because it's unnecessary and slows everything down"
While I like the convenience of the try() approach, I don't want to have to ignore the visual of a `try()` in front of function calls. It's cognitive effort, just like trying to ignore 3 lines of: `if err != nil {` `return` `}` &amp;#x200B; The intention of `try()` is fine, but it's not a good look, in my opinion. In C code I have followed this pattern:- 1. The line following each function call has a line which checks the returned error condition. 2. If it requires some elaboration, an error message is constructed on the fly. 3. if the error message is good enough as it is (most cases), it's left untouched. 4. The error handling line after the function call is a `goto` to a Rollback: label at the end of the function which closes any open files, calls `free()` on any allocated memory, then handballs the error code and message up to the calling function. The benefits are:- 1. In most cases the line after the function call is a single line: `goto Rollback`. 2. If an elaboration of the error message is needed, it is done in an `if` statement which then does the `goto Rollback`, which does the rest. 3. It is as visually unobtrusive as it can be (a single line of code in most cases). 4. It's clear to anyone reading the code what is going on. 5. The `Rollback:` label code is at the end of the function and does not visually interrupt the flow of logic when reading the code. (I'm not advocating the use of `goto` in Go, or claiming I have the best error handling for C. I got this idea from some Oracle source code.) I wonder if some kind of default error handling logic could be implemented which goes something like this: &amp;#x200B; ‚Äã`result, err := callTheFunction()` `handleErrors()` with the default behaviour of `handleErrors()` being: check the error and return a zero-value result and the error, if there has been an error. A local (at the end of the function?) handleErrors() function could do some finalising work if needed. I wondered if a local function would do the trick, but it has to be defined before it's used, resulting in distraction at the beginning of the function. So, `try()` is a good start, but surely there's a better way of doing it.
WSL is supported in PyCharm. If you want remote WSL (from remote machine) you should probably run ssh server in WSL as using it as "normal" remote SSH interpreter. &amp;#x200B; [https://www.jetbrains.com/help/pycharm/using-wsl-as-a-remote-interpreter.html](https://www.jetbrains.com/help/pycharm/using-wsl-as-a-remote-interpreter.html) &amp;#x200B; Not sure about GoLand, but docker is supported here so probably building/running/debug on docker is possible
That's my opinion too. It's also easy to extend by importing or writing just the features you need.
Just waiting on the GoDoc redesign now!
not a solution now but the author did say something about changing their username [https://groups.google.com/d/msg/golang-dev/TDYBsmPB\_e0/9VkTifcVAgAJ](https://groups.google.com/d/msg/golang-dev/TDYBsmPB_e0/9VkTifcVAgAJ)
Thank you.
Go has a very functional net library and can run as a production grade server. The choice to use a framework is just dependant on the needs of your project.
Yea... I use GoLand only because I get the student discount on it. However I do find it an overall better development experience.
Showing String() was not possible until recent changes in delve.
Use SAM like the Go creators. Or of you're a mere mortal, I prefer GoLand, especially if you can get it from your Co or on student discount.
I was wondering the same thing. Seems like we can achieve what the author is saying by simply committing our setup into a dotfiles repo.
vim
"only using VSCode for fast editing files now"?‚Ä¶ I would use vim or Sublime Text for "fast file editing", not VSCode. Does it mean that GoLand is slower to start than VSCode?
For personal projects, I rely on the hashes most of the the time, since it would spare me having to create specific deployment tags every time, come up with complex versioning, etc. Using the SHA, I usually check which feature branch(es) the SHA belongs to using something like this: &amp;#x200B; `git branch --contains SHA_HASH` once I have it, I can also quickly inspect what the changes in this particular commit are: `git show SHA_HASH` &amp;#x200B; Again, this serves me well up to a certain scale. You guys are totally right that a more comprehensive versioning approach would make more sense for larger ones.
At the moment we don't have anything that is similar to PyCharm's remote development support. We planned to do this for 2019.2 but we run into additional complexity and we think the feature is not ready yet, even as an early technical preview. Hopefully, this will be available in 2019.3, but I cannot guarantee this. Meanwhile, you can use the `Remote hosts` plugin to achieve a partial setup for this. You'll need to have Go and the sources installed on your system, but then you can synchronize them with the remote host and make the compilation there using the builtin Terminal, or if possible, use the cross-platform compilation feature of Go from the Run Configuration and sync just the binary after that. You can read more about the `Remote hosts` plugin here: https://www.jetbrains.com/help/go/remote-host-tool-window.html and if you need more details on this, please let me know and I'll be happy to help out.
I disagree. Go has done very well job for me at providing all required frontend features for sites like [https://newreleases.io](https://newreleases.io), [https://www.pravnisavet.net](https://www.pravnisavet.net)... and for their more complex admin sites. It is just how you structure the code, with or without js frameworks on top. Actually this sites are much easier to manage and operate, something like how [https://gopherpit.com](https://gopherpit.com) is, then to deal with all the runtime quirks of interpreted languages. It is just how your abstractions fit your needs, nothing more, just like for any other problem.
Another vote for Goland, I keep trying VS Code for other things every now and again, but Goland is just excellent.
[removed]
Frameworks wars aside; you could have sped up the Go Modules downloading by using a modules proxy, like the official one, or if you needed it to support private repositories there's Athens. We've found it makes downloading dependencies in our CI basically instantaneous (because the proxy is hosted in the same VPC as the CI server - if the modules are cached, they are transferred over a low-latency 10Gbit connection).
Second to this. If for fast editing, vim is a better choice from terminal. VsCode is an Electron app btw.
Had tried VS code and goland both ,Goland is quiet powerful and VSCode is more simpler and easier if you happen to use multi disciplinary development; Finally based on the machine needs (old one) to extend the life of existing system i switched to Vim +tmux+vim-go+surround+ultisnips+git gutter+git +ctags. quiet less memory consumption and efficient workflow. bit of learning curve involved once you reach intermediate level in how to read help on vim and use plugin help docs you are good to customise and reap benefits.
I personally prefer Goland, but it's really the small and cool features that make me prefer that over VS Code. If I wasn't able to get it for free, I probably would have gone for VS Code. I think the thing that made me fall in love with it was that I could push to my repo with a single button. It's a trivial feature which I'm sure is available for VS Code either natively or with an addon, but I noticed it in Goland first and it just stuck.
I can only count two advantages VSCode has now: * Startup time ‚Äì this is not really important * Better themes. Remember though is all about general feeling, because syntax highlighting is pretty much retarded in VSCode, Goland is leagues ahead and this is clearly visible in upcoming 2019.2. I was using Emacs with go-mode before Goland and I found VSCode lacking even against Emacs. What the Goland is better in: * "Typing" ‚Äì postfix templates are really neat. * Completion is on its own level * Refactorings * Inspections are somewhat lacking in certain areas (they are mostly stylistic things that are missed compared to community linters. But there's no analogue for nilness analyzer in Goland and this thing really works) * etc
Which doesn't matter if the app starts instantly. Most heavy operations are done within native code btw.
this is funny because I've had VSCode work flawlessly on 2 core, 2gb ram VMs, it might be an electron app but it's one of the nicest, on my actual PC it starts instantly and I've never had issues with it being slow or laggy
this is the correct answer
Nice tutorial. Unfortunately, I get an error: \`WebAssembly.instantiate(): Import #0 module="go" error: module is not an object or function\` Do I have a bad \`wasm\_exec.js\` file? I got it from [https://github.com/tinygo-org/tinygo/blob/master/targets/wasm\_exec.js](https://github.com/tinygo-org/tinygo/blob/master/targets/wasm_exec.js) If that's the wrong one, can you please link me the correct one? Thanks in advance good sir.
Sublime may be slower or less functional than VScode (hello "new version available" popup). Vim is great and all but it's a matter of preference and productivity after all. GoLand is big real IDE, it takes time to start even on a fast machine. Once it's up you could use it for a quick edit just as well.
Interesting. I published a book last September and preferred to have the reader build their own reusable "web engine" on top of net/http. &gt; As for the high-profile gophers who were strongly advocating for Buffalo: I spoke with a couple while writing this article, and they told me they‚Äôve changed their mind themselves. I'm a bit surprised that you got recommendation to use Buffalo, especially since it was your first Go web application.
Or rcm for more advanced management with tagging, etc.
I try vscode from time to time. What I don't like about vscode, when you didn't import something and try to autocomplete something it won't work. So I have to type the package + function and then save, then it appears Goland will autocomplete (can fuzzy search my function too) and add the import for you.
VSCode beats Jetbrains at every thing.
Yep, since he is making the transition, the new app doesn't necessarily have to be as "backend heavy" as the last one. The "frontend heavy" is becoming the norm as you said with libraries like react, angular and material-ui gaining steam more and more these days.
Especially these days
I wonder, do you build and restart your Go Server automatically on file save? Because I think that's the first thing you want to do so you have a tighter feedback loop.
Go can make an excellent rest API server though, especially with its ace in performance. Since modern web apps are all about front-end heavy components like react, angular and material-ui, etc. go can complement that with its C-like performance.
i will do it
I appreciate your feedback
&gt;https://www.pravnisavet.net Would you mind telling me which css framework you used for this site? or did you put it together your self? &amp;#x200B; Thanks
Not at all. I used https://tailwindcss.com/. Actually, this simple site was a nice fit to get familiar with it. Tailwind is utility first, so, until you get basic concepts how you want, it is a bit of a struggle, but after, it is a joy working with it, something like Go and web development. :)
You should include go.sum for reproducible builds, yes. Just add it to git alongside your go.mod.
That is also how I interpreted the headline.
How do you manage things like authentication and authorization? Asking because these are common painpoints I‚Äôve encountered in the past and I haven‚Äôt found a good answer.
Go sum is used in defining the import versions of your go program. It's not required for executing a go program.
Does that imply that it's not needed to be deployed to cloud function?
&gt; 500 &gt; We encountered an error &gt; &gt; Oh no! Our server encountered an internal error. Please try again later. We're terribly sorry for the inconvenience.
You can reuse components and never build a framework.
&gt; Go sum is used in defining the import versions No, that's what `go.mod` does. The `go.sum` file is for verifying that the module bits fetched (or cached if `go mod verify` is used) are exactly as expected and haven't been modified in any way.
I gave it a try. Looks good! Coincidentally I'm busy preparing a gateway server for a lan party and this will come in handy to test DNS and HTTP(S) requests :) Thanks!
Middleware my good sir.
Ignore advices like all you need is gorilla/mux or the standard lib. Almost always, these comment do not give you the context. /u/xortar when you say 'Just give me gorilla/mux and I‚Äôm good to Go.', do you mean when you write a little microservice, or when you write a full stack web app like Reddit? If it's the latter, would you please share your code with us? People who are interested in solutions like Buffalo want to write full stack web apps, I want to know how you do that with just gorilla/mux.
It's because there is no good answer that you cannot address this by one unique solution.
I find vs code works great for have languages, but not Go yet. GoLand works way better for me. Good intellisense, downloads dependencies added to go.mod for me, no need to restart it with "reload window" when the language features randomly stop working, etc.
I use gin which is perfect for that
Or you write a very small web app and you don't need a framework, or you write a very big web app and a framework will never be exactly what you need. And again, you don't use a framework but you still can reuse components as you need. And maybe yes we need more reusable components like mux. gorilla/securecookie gorilla/sessions jmoiron/sqlx...
Yes you should! go.sum contains the cryptographic signatures of all your dependencies and is a security feature, not a NPM style lockfile. This means that while go.sum does not actually ‚Äúdo anything‚Äù to determine which modules and which versions, it can protect from attacks where someone with access to a dependency changes what the code does and replaces an existing version. This is a huge nightmare for companies because if I ‚Äúpack‚Äù a common package, I can walk into anyone‚Äôs production infrastructure when they pull my malicious dependency (generally when they build in CI), assuming they have failed to maintain or use go.sum. If they had used go.sum their build would fail with a checksum mismatch and (hopefully) they would investigate to see why and what changed.
Go is a statically compiled language so there are no* runtime dependencies so no you do not need it for deployment but as other have stated you should include it with your source code.
I didn't know about dotfiles solution when I started developing this package. So I had no intention on creating a tool that offered more functionality than the dotfiles repo. &amp;#x200B; However, can you track something like all pip3 packages installed in your system using the dotfiles repository? Because from what I read from the link you need to have a file which you can track. My package also allows you to execute something like `pip3 freeze` which lists up all your pip3 packages installed and back it up too.
homebrew as in? If you are asking if it is available on homebrew then yes it is. Check out the readme.
Play wonderwall
Brilliant.
Thank you
Thanks to you! I hope I can finally be of help to you
Have you done these sites in pure Go, or have you used third party frameworking all the way? Also it's a shame how little functionality that is actually working without JS.
I disagree. Even when you pick and choose there is so much interdependency still that scaling and performance goes right out the window :) It's just added complexity IMHO.
I agree, but I would never go this route. The "modern" approach of heavy usage of JS on the frontend is just awful from so many perspectives IMHO. We need to stop doing this.
I'm primarily a Java/Kotlin developer, so I use IntelliJ IDEA with a corresponding plugin. It works great for me. I would definitely choose GoLand otherwise.
Pretty cool! Just fyi, you have a typo smack in the middle of your personal site.
I tried your code locally and there are many race conditions. You should try to run it with build -race.
True story
Wow, thank you so much! I'll correct it as soon as I can
Was it the ability to call a method?
You got it dude. Good luck on your journey.
&gt; not a NPM style lockfile. What do they actually do, then?
In my experience Python was super simple when you start easing into it and oh my is it smooth to ease into! Then you suddenly find yourself solving everything by passing lambdas around, overwriting \_\_getattr\_\_, and trying to save lines of code through dict comprehension. At this point Go becomes a calm harbour in a storm of crazy, and no matter how much your crazy side kicks and screams you just can't, which is a blessing because you shouldn't.
I write Python code at work. So when I'm writing Golang most probably I'm working on my hobby project. Hobbies are relaxing.
Same! I've just started learning but I totally understand. Most of my previous programming has been C# and some PHP for simple web things. Whenever you google something complicated in C# you get some crazy syntactical sugar that doesn't fit with my other code, so I end up having to decipher their code and put it in my "style". PHP will make you do this too much ¬Ø\\\_(„ÉÑ)\_/¬Ø. Go is juuuust right for me so far, granted I haven't coded in it as much as the others. =)
No frameworks are used, only gorilla mux for routing. Because it looks like that it does little, that is good. It does things to provide support for some more modern js techniques (also for easier js development), optimizations as html and assets minification, higher security standards... I do not think that, for example, handling form submissions with pure html is acceptable this days on modern websites. It can be even easier done then with js, but js provides much more interactivity, and new possibilities. Good luck finding a frontend developer who want to handle form natively.
Why?
You're referring to ["mount stupid."](http://www.smbc-comics.com/?id=2475) If you spend any time at all building experience and learning how to write decent software, you will eventually come down from there. Go has it to. All you folks doing ridiculous Interface{} hacks to convince yourselves that generics are unnecessary are high atop mount stupid as well.
Tongue &amp; cheek guys &amp; gals.
Yea I tend to agree here.
Why not go platform-native?
&gt;cloud function [https://cloud.google.com/functions/docs/concepts/go-runtime](https://cloud.google.com/functions/docs/concepts/go-runtime) Interestingly, if you assume that this is for Google cloud functions, it seems the unit of deployment is code, not binary.
/u/kingofthecream, I could write either a microservice or a monolith with or without gorilla/mux. However, I enjoy using small, focused libraries where necessary, and prefer not to use large frameworks like Buffalo or Gin. Your comment makes it sound like this is some infeasible task. If you are relying on frameworks because they fill vast knowledge gaps for you, I would encourage you to learn how to develop applications without the use of frameworks. This would be of great benefit to you as a developer. As I stated before, when I think of a framework, I think of OOP and very large libraries of classes and interfaces meant to be used together in a very specific way. If you have never experienced functional programming or even straight structured programming, I would also encourage you to look into those paradigms.
I realized that I didn't need a "web framework" I needed a way to expose business logic (my domain concepts) to the outside world in a safe way taking input from CLI, HTTP, SMTP, etc... endpoints and running my logic. I wrote something to bypass the whole website framework idea and I'm currently looking for feedback on this uncommon approach: https://github.com/Xeoncross/servicehandler
Someone very well-known in the Go community was recommending Buffalo over and over, months ago. I remembered his advice and tried that. In the first draft of this blog post, I even embedded one of his tweets. Then sent the draft to him for review. He told me he is not recommending nor using Buffalo himself anymore and could agree with my reasonings. So I dropped his tweet to make sure it doesn‚Äôt look like he‚Äôs still recommending it :)
Might have something which OP needs already available. It's a decent list of resources
Hmm.. quite possible
That thing is indeed a framework however. See my point above (which apparently people didn‚Äôt like): you always use a sort of framework, or end up writing your own (by combining multiple libraries). For an app with more than one route, there are no exceptions, or you‚Äôd just write ‚Äúspaghetti code‚Äù.
Hmmm I would put it another way that is, perhaps not as insulting or insinuating. All of us when learning a new language, or even when learning programming period, tend to try to exercise some "clever" tricks to push boundaries of the tools we work with. In python you see this, in C you see this, and of course as you said even in golang you see this. It's a natural part of progression. Some people are comfortable with the fun hacks of a certain language. None of us can say whether OP isn't doing things like overusing interface{}, for example, only that they are comfortable with the language. As we all get experience though, I believe we do tend to stop abusing clever tricks. However it's not something that influences comfort imo which is largely subjective
I'm referring to my personal experience with Python, and Go, and having a bit of fun with it. Not everything has to be so serious, it's Friday over here :)
As stated above, they are a security feature which ensures that versioned dependencies do not change after being integrated with an application. You can read more here: [https://github.com/golang/go/wiki/Modules#is-gosum-a-lock-file-why-does-gosum-include-information-for-module-versions-i-am-no-longer-using](https://github.com/golang/go/wiki/Modules#is-gosum-a-lock-file-why-does-gosum-include-information-for-module-versions-i-am-no-longer-using) &amp;#x200B; If you are writing secure code, you will want to review all of your dependencies extensively when you add or upgrade them. This ensures that once you have reviewed and approved a dependency, it doesn't change or it will break the build.
I have the same feeling also when writing Elm. I've started writing an Elm-ish language that transpile to Go actually, that to me would be my dream backend language and all the Go concurrency, tooling and single binary joy.
I‚Äôm well aware of Athens (I helped the team with launching it :) ), but that would require maintaining more infrastructure. For an open source project, I didn‚Äôt want to commit the time or the resources. And my CI is azure Pipelines. It‚Äôs not a VPC by default unless I use a self-hosted agent. But the Microsoft-hosted agents are free since the project is open source.
&gt; they are a security feature which ensures that versioned dependencies do not change after being integrated with an application I mean NPM lockfiles. I know what go.sum is for, and if NPM lockfiles don't serve the same purpose, what *are* they for?
&gt; Goland still didn't feel mature This is interesting. I've been using Goland for quite a while now (I started when it was still in EAP), and I have seen it mature a lot. Early on, I would totally agree with this sentiment, but I don't think it accurately describes Goland now. Do you mind explaining this some?
[removed]
Did you look at fbender? https://github.com/facebookincubator/fbender
&gt; I‚Äôm well aware of Athens (I helped the team with launching it :) ), but that would require maintaining more infrastructure. For an open source project, I didn‚Äôt want to commit the time or the resources. Congrats! Like I'd mentioned then, for an open source project you probably wouldn't need to host Athens then, you might just be able to use the one hosted by the Go team: https://proxy.golang.org/ - that will likely be far quicker than using Git, and it's not any infrastructure you need to host yourself. &gt; And my CI is azure Pipelines. It‚Äôs not a VPC by default unless I use a self-hosted agent. But the Microsoft-hosted agents are free since the project is open source. I'd imagine that Azure Pipelines are still hosted alongside your apps, so even if they're not in the same VPC, they'll have a solid, low-latency connection to whatever you host yourself in your own VPCs. Anyway, glad you found a solution regardless!
We use it internally for most of our end to end tests, so in that sense, yes. Plenty of useful libraries aren't getting weekly commits ;-)
Use middleware. Depending on your hosting environment you can offload some of the work to your infrastructure. For example, where I work we actually use Chi most commonly, and we host our apps in Kubernetes with Istio. Istio handles communicating with Keycloak (our auth server) and validating JWTs, and it'll reject requests with invalid tokens. Then all we do in the apps in decode the JWT and use the data in it.
I'm totally in the Goland camp. Some reasons why. * Code navigation is so much better than VSCode in a large project. * Debugging is simple and has no surprises. * Run tests inside the IDE. You can run all tests, all tests in a package, a single file or just a single test - all with just a mouse click or two. * The CPU/Memory profiler is pretty good, and so convenient to use that I make use of it a LOT. * Code completion is much better than VSCode. * Refactoring support is pretty good, but not perfect (extracting to a method from a chunk of code that has a return in it still doesn't work, but I think it's in the next beta). There are downsides. * Cost is nothing to sneeze at for many developers. (although I'd argue that if you are a professional developer, you should invest in tools that make your work easier and better.) * Startup time. If you jump in and out of projects constantly, this will get old quickly. * System resources. I typically have 2-3 instances of Goland open at a time, and it can be a little draining on the system.
why are you like this on a go subreddit?
How can a transpiled language be a dream? haha. By definition it admits "we didn't do this right the first time"
It's a sub about Go. Not a safe space for cheerleaders or a circlejerk. Criticising Go's problems are reasonable. Traversing mount stupid is a necessity, not an insult.
&gt; I'd imagine that Azure Pipelines are still hosted alongside your apps, so even if they're not in the same VPC, they'll have a solid, low-latency connection to whatever you host yourself in your own VPCs. Azure Pipelines offers 2 kinds of agents: Microsoft-hosted, which are like "SaaS" and are in a VPC Microsoft controls (and are free for open source projects and partly for private ones too), and self-hosted, which can be put in a VPC but require you to run your own VM. Regardless, even MS-hosted agents are still on the cloud, in Azure, so technically you could create a VM in Azure and the link would be low-latency and fast. But it's still over a public IP, which makes things more complicated. And good suggestion about the proxy.golang.org!
"Extract Method with returns" WOOT! This is quite an annoyance for me personally. Glad it's finally fixed.
Go wasn't created to fit your idea of design, not even to solve your problems; you're free to bake your programming language and put all the shits into it, eventually you'll, maybe, realize that drawbacks are one of the direct consequences of making deals somewhere else. The philosophy behind the language is not related to bad design but to a design that had to be this way, if you can't accept it, just move back to the smartness of other programming languages, that hides troublesome and overwhelming complexity in many terms, under the hood. Oh, and relax.
No, not really. I discovered Noisy thanks to a of Null Byte video ([https://www.youtube.com/watch?v=iCKj0La4Grg](https://www.youtube.com/watch?v=iCKj0La4Grg)) and I thought I could do something like that at Go. I hadn't really even thought of its usefulness as load testing tool until I published this post.
[/u/coderlaunda](/u/coderlaunda), open sourced this a couple days ago. [listmonk](http://github.com/knadh/listmonk), mailing list manager written in Go with a React frontend (Ant design for UI).
What does this package do? Would [go-yaml/yaml](https://github.com/go-yaml/yaml) be a suitable alternative?
Gin is crap as well
I don't remember from who and where it come but we should first agree about what is a framework : "you call a library, but frameworks call you"
I still regrets to spend time learning on how to use a txt editor, but can you tell me why should I do that?
It does now, I'm using it since it was on EAP too. That's probably why in the beginning it didn't feel as smooth as just using VSCode which is mostly powered by other applications widely used already before by go developers.
with a good computer you really don't feel VSCode loading. Jetbrains IDEs in the other hand...
I agree that my library could be seen framework. However, it is not one of those carry-over Web/MVC frameworks from PHP/Ruby/Node (hence the quotes around "web framework"). &gt; app with more than one route This is the concept I am looking to automate. Instead of thinking about API "routes", think about functionality and business logic and let the server generate the routes and encode/decode logic (gRPC is an example).
Good point, at my current job Go is the language to use, so whenever I can program in Python I find it enjoyable. IMO with type annotations in Python there's nothing that I'm missing from Go.
But... but... Go Has No Classes(TM)!?
You can't like... own a language maaang.
I'd love a Ruby-like language that transpiles to go (or for Crystal to suddenly be mature and have Go's ecosystem....). Expressive language with Go's simple concurrency and parallelism.
Hahaha Oracle would disagree.
We've just finished the form handling for the current project using only the Go standard library. It turned out to be much less of a struggle as soon as I got a custom error handler setup so that Go wouldn't just panic on template problems. My frustrations yesterday was not fully justified. We don't hire frontend developers who can't do this stuff native no matter what project and language we're working on. We have a binding requirement for all our projects to be properly designed and coded so people with disabilities can use them 100%. We only rarely use JavaScript on the frontend, but when we do it's never a requirement for the site to work.
We don't rely on the function call support feature in Delve for this. And as a small side-note, we had the two issues created by two different users, I'm just saying :)
- How do you know a blue personality has entered the thread? - Nobody is smiling anymore.
I never wrote one must use a framework when building a web app. I asked you how would go about making a full stack web app like Reddit without a framework in Go, and without reinventing all those wheels that exist in a framework?
Thank you for your feedback. I'll relay this to the development team and we'll see if we can adjust the theme engine to support even more advanced themes that will fully resemble the native of the OS.
Application software for embedded devices in the IoT and Industry 4.0 contexts, as well as software for POCT devices (in a research context). Loving the painless cross-compilation to ARM and resulting standalone binary.
Can you elaborate a bit on the complex build configs and testing? I am still new to Golang in general, so not sure what this might entail.
I‚Äôm using C++ in production, and Go for my own tools/little projects. And after seeing some weird hacks, tones of code styles, and other C++ stuff, Go programming is so relaxing for me, mostly 95% of others people code is understandable and language is kinda easy by itself. Freaking love it, even if there still enough problems :3
Interesting. I happened to have played around with the code editor Monaco and intellisense, and found the Golang support for it, and man there was a LOT of code behind it.
Going to disagree with you here. I run both IDEA (for Java/Go) and VSCode in my VMware workstation VM with Ubuntu and it runs just fine. I give it 4 cores, 16GB RAM, and the VM files sit on an SSD, and I see almost no difference in starting up as well as editing then running it native on Windows or Mac.
I miss performance, channels, goroutines, defer, etc in Python. Type annotations are nice, but they don't solve everything, especially for my projects (mostly networking).
Really? As I replied above, I run it on a VMware Workstation VM, and it runs just fine. No lag at all.
Same.. though I do a bit of nodejs/react as well, which is why I have been using VSCode lately. I wasnt feeling IDEA supports React/Nodejs as well. I work in that as well as Java and Go (learning it), hence why I spent the money last year on the IDEA license and ultimately wanted to stick to it. But VSCode just seems to work better for nodejs/react development. I dont want to switch between two IDEs, and it seemed that VSCode had good Java support and decent Go support as well. Definitely seems like IDEA is making a big effort with Java/Kotlin/Goland.
Good info. Why 2 to 3 instances? Cant you just project switch in the one instance?
Bill Gates?
I looked at it. Very interesting software. But you see my package is different (correct me if I am wrong). You can track almost anything (keep track of normal files, apps installed in your Macbook, brew packgaes, atom packgaes, atom keybindings) - not just your dotfiles. You can see it in your own github rather than storing it into somebody else's iCloud. You can share it with someone else you want by just giving access to your github repo. You can set up any x number of machines using it etc.
Are you using modules, or a large project? I am using vscode daily, but my experience hasn't been great :/ Did you do anything to make it work well?
For anyone interested in PlantUML: There is a PlantUML renderer/viewer plugin available for IntelliJ with auto reload which comes in really handy.
Go is wonderful. It's a similar feeling I had in Android development after switching from Java (ugh.... gross!) to Kotlin.
Yeah, it is pretty cool and very fast.
Heard about kotlin, have not tried it
That's why this project is magical. LOL.
ADHD :-) I have a few semi-related microservices that share a package. I often need to make changes in the package, then update the microservices that use it. I could do it separately, but I find it easier to change the caller and the library at (roughly) the same time. The change and reason for the change are fresh in my brain.
Where applicable, I use small libraries that satisfy the needs of cross-cutting concerns. Most cross-cutting concerns are satisfied by Go's standard library and generally only need augmenting. I must ask though, what is so wrong about reinventing the wheel? It is both how we learn, and how we improve upon existing solutions. You ask how one would go about making a website like Reddit without a framework. One would simply write the required code. Perhaps we are at odds with how we define a 'framework'. To me, a random inclusion of specialized libraries into a project does not constitute a framework. A framework is a single, monolithic library attempting to satisfy all cross-cutting concerns and force implementation patterns through the extension of its entities.
Although Go is developed and maintained by Google, it's released under a [BSD-equivalent license](https://golang.org/LICENSE) with [associated patent grants](https://golang.org/PATENTS) in perpetuity. So even if for some crazy reason they wanted to in the future, Google can't legally charge money for Go or restrict access to Go or Go applications. &amp;#x200B; You're good.
more like Oracle would sue
It‚Äôs owned by the core team who all work for Google. It was created for Google‚Äôs needs.
GoLand
doesn‚Äôt compile to go, but you might like elixir.
&gt; I must ask though, what is so wrong about reinventing the wheel? 1. Time: Writing code is fun, but my life and resources are limited. I do not wish to keep implementing the same form validation logics for every client. 2. Complexity: Some stuff like authentication are not meant to be reinvented. I do not want to deal with session based cookie authentications and all its security concerns. I want to delegate that to a community watched project. In fact, it is bad practice to reinvent authentication systems. And no, you cannot just drop an authentication library as a component into your app, it just does not work that way and they always happened to be frameworks.
The compiler is correct (lol) - this line is wrong: ``` return fmt.Errorf("User Still Exists", rs.Primary.ID) ``` you need a verb in your error message, e.g. ``` fmt.Errorf("User %d Still Exists", rs.Primary.ID) ```
It means the fmt.Errorf is missing format for the output Ex fmt.Errorf(‚ÄúError occurred :%s‚Äù,err) The above uses %s which is string format Please refer to the fmt package documentation in golang.org
This worked. Thank you so much I just completed and finished my first function in my first test!
Last time i seen uml diagrams was 12 years ago, when i was doping my CS.
I used https://github.com/lra/mackup/ sine time ago
&gt; We only rarely use JavaScript on the frontend, but when we do it's never a requirement for the site to work. I do not say that developers do not know how to handle the form natively, but that now JavaScript is the standard, not extra. Frontend developer who works without JavaScript is missing quite a lot. It's 2019, much after 2006. Even without JavaScript, rendering HTML with Go templates is not difficult. Go templating library differs from what people are used in other languages. It just needs some imagination, and you can have very nice things, like one codebase that produces everything, and I mean everything (persistence with embedded k/v store, embedded templates...) in one binary file that can be built on mac for linux server or for friend's windows pc to try it locally just for fun, without installing anything. Well, that was of the track, but sometimes a few bumps in the road can distract from the beauty of the trip.
VSCode crashes on me in virtualized Linux at leas a 5 times a day. Debugging with it is like pulling your teeth out slow as hell and painful. After two years the search and replace in selection still works so weird that I need at least 4 trys before I'm successful. So Goland is worth every ‚Ç¨.
it's just that to me writing this: add : a -&gt; a -&gt; a add x y = x + y Or even List.map (\x -&gt; x + 1) myListHere Is way more fun than Go's repetitive code. Don't get me wrong, I absolutely love Go's, but sometimes it gets a bit repetitive and the more I'm doing functional programming the more I miss lots of expressiveness in Go. That's what I'm playing with, a way to get a much expressive syntax but that at the end can transpiled to repetitive functions. Anyway it's not like if I'm thinking I can write this thing anyway, I'm just "dreaming" here I guess. What Elixir did with Erlang is ~kind of the same, but since Go compiles to native code my thinking is that like Elm transpile to JavaScript, an Elm-ish language could also transpile to Go "hypothetically speaking".
It's been a while since I did UML, but if I remember correctly a "class" in UML is just a collection of properties, and Go does have that in the form of structs.
&lt;kneel&gt;
Well, you are incorrect about authentication libraries. Contrary to your belief, libraries that work with specific authentication protocols do exist, such as for OAuth2 and mutual TLS authentication. There are also libraries to work with JWTs, and encryption/decryption. I've written my own library for a custom authentication protocol as well. As for form validation.... sounds like I could use a library for that.
Ig guess its a bit better than transpiling to JS because it would actually go dream\_language -&gt; go -&gt; binary. Still you have the dependency and potential bugs that go along with going through an entire other language, but I see what you mean.
Network utils, data processing, API endpoints, servres, system programming
Also thanks for the simplicity and lightness of the language and the std lib it should not be impossible to maintain a community fork if needed. Is it ?
&gt; The compiler keeps telling Just to be pedantic, it's not the compiler complaining but `go vet`. Since Go 1.10 `go test` has run a sub-set of vet's tests to identify significant problems.
What are you coding? I had been working on complex programs written in Go and it really gave me headaches to understand the code
Yes, it is very rare, at least for me, to see developers do UML before their code. However, I find it extremely helpful every time I see one.
Go modules use a deterministic dependency resolution algorithm, which is minimal version selection. From a single set of constraints in your go.mods across dependencies, things will always resolve to the same version in the end. Most other package managers, like NPM, grab the latest versions of dependencies that meet a constraint. It's non-deterministic for that and sometimes other reasons. So if you say "at least 1.2.3", you might get 1.2.3 today and 1.2.4 tomorrow. A lock file records what the dependencies resolved to when the lock file was generated, so you can install the exact same versions of all your dependencies without having to "pin" every dependency in your constraints file (package.json).
Well done
I miss them, too, but I don't miss defer, because I can use python context managers (a.k.a. with statement).
That works for some things, but defer works on _any_ function, not just the one `with` is aware of. That being said, I don't particularly miss `defer` in Rust because the Drop trait works pretty well, which is a similar argument to using `with`, though there are still times when it would be convenient.
Got it. Thanks very much!
I dunno if this is what you have in mind, but we could really use some help building integrations of [Caddy](https://github.com/caddyserver/caddy) into cloud services like AWS, making and maintaining an official container, and distributing it through package managers like apt and brew. You would learn how to package and distribute Go applications for cloud services, containers, and Linux distros and other package managers. I'm just so time-constrained that I can't do it all myself. Anyway, something to consider, if you're serious about it and if this sounds appealing to you. We're looking for community members who are committed to giving their best back to the community. More info: https://caddyserver.com/blog/caddy-2-ready-for-developers
I feel the same. I think the reason is that i never feel like i'm fighting the language, just the problem at hand. And more often than not, i feel like the language also helps me with the problem by influencing my thought in a right direction. Go encourages little functions and gives you total liberty on the files you create, it's not like python where each file is a module and god forbid you name a file the same as a module on the stdlib! Or like in java where each file is a class. That liberty may seem a small thing, but i think it's one of the reasons i feel coding in Go is so enjoyable and relaxing. Concurrency is also a great part of it. The fact it is so easy allows you to think of problems on a different way and almost always makes the solutions simpler.
Maybe you can't address every auth use case with a single solution, but there are solutions for other languages that let you address a few common use cases easily and many of these are pluggable/extensible such that you can support many more. As far as I've found, Go lacks either of these.
Large project.. very large. Though I only edit a few files at a time. My host is a Windows 10 OS with 32GB or 64GB RAM (depending on laptop or desktop), NVMe SSDs, 6core on laptop, 16core on desktop. Runs smooth on both systems. I think I have the VM set to use GPU acceleration, but thats about it. I also avoid 4K resolution in the VM, use HD. Nothing fancy otherwise.
Well, Python context managers work on any function, too, and actually more feature rich and expressive than Go defer. Just Python ExitStack callback in contextlib is equivalent to that.
`You can rename the `test_files` to `testdata` which is the default name for it. You should close this, no? func fileExists(name string) bool { _, err := os.Open(name) if err != nil { return false } return true } I think you can test this with _, err := os.Stat(path) return err == nil This can fail: json.Unmarshal(byteValue, &amp;config) Does this work without adding recipients? If not you can exit from here I guess. fmt.Println("You have not added any mail addresss") The regex is quite fuzzy, dunno the English term. Why not simply check whether the file with the-body-as-name exists or not? func isBodyFile(s string) bool { Some things to do :-). You did open an issue to write more tests. What tests do you want to write? That gomail is called correctly via mocking, whether the user interface stays the same by printing to a buffer, or end-to-end? that an email got sent with given inputs?
I use both. I always prefer Goland for pointing out problems better, showing variables during debugging a little more human-friendly, etc. As odd as it sounds, I use VS Code when I'm refactoring massive numbers of files at once across a project. It's just a bit faster and easier to jump between files in VS code, and when you refactor something in Goland like moving a package from one area to another, it does not refactor the imports correctly and you wind up with a big mess. I need to figure out how to make the time to write out a thoughtful bug report for that. One negative I'm hoping Goland fixes is that it's hard to use other keybindings. I like VS Code bindings (because I also code in lots of other languages), and they have them... but the setting reverts every time I exit. I'll file an issue when I have time to search for whether there is an existing one. If a certain dlsniper reads this, I apologize for not having looked into reporting these bugs yet. I'll try to get to it. :)
Bad bot
Oddly I dont find python easy to learn or fun. Golang on the other hand is just all around more satisfying to me. I think part of it stems coming from Java, wanting to find something to nicely replace Java on the server side, that can handle large scale volume should the need arise, and just seems to sit well with the notion of microservices, threads, and APIs. I realize just about every language in one way or another meets these goals, but Golang just for some reason hits those sweet spots better than any other language, and mind you I am a total noob with it still. Have yet to build anything other than simple apps that I started on learning and had to cut short due to other demands.
Be curious to understand why.. was the code maintained poorly or written poorly? I am totally new but most of what I read or those I talk to doing it typically say Go is all about clean good code quality and usually easy to maintain and read other developers code.
I mean, I enjoy Java still, and havent tried Kotlin, but I dont think Java is too bad. That said, Go just seems to be a lot less verbose and thus results in cleaner code and less of it, from what I have gathered, and sits really well with APIs and microservices style of programs.
I just think defer is simpler than Python's context managers.
Very interesting indeed. Is there a repo open to look by any chance. I think this is something good to experiment. Like typescript for JavaScript.
K8s, treafik, hashicorp projects
I write in Go &amp; Java at work and I have a hobby project written in Python. Sometimes when I don't work on the hobby project for a while when I get back to it I feel like I'm "living dangerously".
Now this is pretty much what I was looking for - I know Caddy and I'm going to check out how much experience is needed to dig into the project.
I think that relaxation comes from the amount of thought put into the language to keep things simple. As Rob Pike put it, "simplicity is complicated, but the clarity is worth the fight" I suspect the relaxation comes from the ability to just focus on the problem you're solving without worrying about the supporting code. The closest parallel I can draw is using a screwdriver - you just use it. Go feels very similar to me. It's a set of tools that combine in very obvious ways to solve the problem at hand. Or as Rob Pike would put it, the orthogonality in Go's feature set.
I don‚Äôt know if it is the same for you, but I find learning a new programming language relaxing because you spend several weeks just thinking about how to express something you already understand in code, and have only questions that already have easy to find answers. When you‚Äôre coding in your main language, how to express something in code isn‚Äôt an issue and instead you worry about evolving specs, hard to replicate production bugs, technical debt or performance issues. The former is much less intellectually taxing, and gives a satisfying sense of steady progress, because you‚Äôre not doing the same thing with your new tool.
Cool, let me know if you have any questions! You can also find me on our forums.
Because it's an edgy, cool answer. Nothing more. There are far better tools available these days, but people gotta be edgy and superior.
Oh, yes! We, software engineers, know how to live on the edge.
I honestly don't know anyone using interface{} style code. I would be hard-pressed to approve a PR using it.
I think Go could actually cure depression. Take any library, for example, open it up and be amazed at the expertly typed comments, thoughtful naming, and useful examples. I haven't found any language besides Go that makes me \_really\_ enjoy typing code on a computer.
A transpiled language is a type of compilation. Elm isn't saying "JS didn't do this right" so much as "we can make this better." It's the same sort of dynamic as using a language like C instead of writing machine code. As a better example, consider Nim using C as a "compilation" target. Using C as a target isn't a criticism of C, but an opportunity to piggyback on all the great work that's already been invested into the VMs, ecosystems, etc while bringing the language up to a higher level. Not to mention that modern JS almost universally uses Babel or the like, so real world JS as used by its primary user base is a transpiled language.
I learned on Python and frankly I find Go easier. I'm not a talented programmer by any stretch. I'm just a guy who has software problems to solve. Go made me "click" with a lot of programming concepts.
In general Go code uses interface{} when the function can handle any type at all (e.g. fmt.Print). Whenever you can handle a subset of types you use restrictive interfaces. This handles most cases of generics. Not that this argument has any foundation since Go is probably going to be getting generics soon. I would be interested to know which of the following are "mount stupid" statements, in your view: * concurrency is a better structure than OOP hierarchies * simple is better than complex * "A programming language that doesn't have everything is easier to program in then some that do." I mean, couldn't you say that the whole idea of Unix is "mount stupid" material? You could say that fork() is an ineficient hack; that IO redirection and pipes are hacks that lead to errors and headaches; that formatles files are bad, error-prone, and are harder for the user to understand and edit (see the mother of all demos); and so on. You could say that the other operating systems of the time were written by more experienced people, who had gotten past "mount stupid"; who had rejected the ideas used in Unix. And yet we use Unix systems (the only other one left in wide usage is Windows, which is more Unix-y than not), and we program in languages closer to C than to Lisp.
Finally support for function execution during debugging, probably the most helpful feature mentioned here üòé
I paid for goland myself and I'm glad I did. I'm not a software engineer but managing a ton of small to medium-sized projects has been so easy in goland. Truth be told if I'm on my work machine oddly enough I use vs code, so I'm the opposite I guess. I thoroughly enjoy them both, and I have been a jetbrains fan ever since I got hooked on Pycharm and DotNetPeek. It is annoying having separate IDEs though, so VS Code wins there. The pro for all things JB on the other hand is the "out of the box" / "it just works" that you get for using a single-purpose ide (though VS Code is so easy to set up it's basically a non-issue).
Switching editors is definitely the biggest downside of Goland. Especially when working in JavaScript. Jet Brains doesn‚Äôt (to my knowledge) have something that works super well in JS and VS Code is just so good with Node / React / What have you.
Without any framework, it is very functional. But there are several really good API frameworks that range from simple and lightweight to kitchen sink.
Don't fall off, we can't afford to lose another one
I used to manually grab some of the emojis from Twitter for using in Slack. Mainly the MCU ones. Then I recently found out how to grab all of them and there are a lot (over 640 active ones as of right now).
Go is much more verbose than Java IMO. Java development with libraries like Spring generate the bulk of the code for you at runtime or compile time via AOP. You're usually just writing POJOs and Interfaces then annotating them in JAVA. If you get Kotlin involve you're basically using DSL with most libraries which is even less code.
Well nothing to complex i guess. I work in a cyber security startup, so i just write some threat feed integration, correlation and alerting program that works with ELK and rocketchat
Before trying to access it is there a command you can run to check if the drive exists
You can't multiply two different numeric types together. Case t to time.Duration, or time.Second to an int, depending on what you wanted t2 to be (probably the former).
Both TypeOf calls show the same type but are not the same thing. One is a variable and the other is a constant, the compiler understands the constants based on the context they're used in.
Thanks, both of you. Those are both very helpful answers.
O/T but I really like the flat directory approach for the JS (I do the same thing). It drives me absolutely insane to look at frontend projects where every component file is in it's own directory with an additional index.js, sometimes nested arbitrarily deep. I just can't comprehend it.
there is actually a `continue` keyword.
True. I'm subscribed even though I code Go out of necessity at work because it is a good tool for the job. I don't enjoy it much though. I keep an eye on techniques and workarounds on this subreddit.
I think this is the method of visual programming most likely to succeed in the near term. Instead of using a UI to assemble your application you write your code like normal but generate abstracted views to help diagnose logic flow issues, quickly refresh on a new (or old code base), etc.
Ironically, the people atop "mount stupid" in this sub are more frequently those who make statements like yours.
My Python hobby project had no tests in it, so I _know_ I'm living dangerously üòÅ
If you build something like Reddit do you seriously think you haven't customized the framework to the point is not recognizable? .Net has extremely robust libraries already available in ASP.net including fantastic identity management, but I have never worked on a huge project that hasn't already made it extremely unique. If my application is simple then I might as well not overcomplicate it. Once it's complicated, it's just going to be a complicated unicorn.
Well that's the issue I'm facing, the drive may or may not exist. Since they're attached to a RAID controller, I don't think they're listed under /dev/ and parsing text with golang seems to be a bit more difficult than it is in shell.
If that‚Äôs the case (and all the drives you need are listed under `dev/` why not remove elements from the slice that arent listed
I figured that may be useful, but I'm not sure regarding how/where to implement it. Would it would be something like func checkPhysicalStatus() { for _, physicalDriveNumber := range []string{"[252:0]", "[252:1]", "[252:2]", "[252:3]", "[252:4]", "[252:5]"} { **other stuff** if err !=nil { fmt.Println("drive doesn't exist") continue } } }
That's it:
I couldn't agree more. We chose Go as our primary language at work for new project, previously using node we still use it in some projects. While writing Go, it feels so good and productive. It has very rare combination like, performance, simplicity and availability of libraries.
Thanks. I'd looked at some popular React projects to figure out the best practices, but as you said, the structures were hard to comprehend.
[removed]
&gt;That's all I wanted to say. I don't know why, i wrote code in C and python. I understand why coding in C can be frustating, but python is simple. Should not it be more relaxing? And yet you don't have generics in Go. You don't even have a preprocessor. You have some ridiculously hacked gogen which is as good as a few shell scripts on top of a basic parser.
I attempted that while waiting for a response and it does give me more output but still crashes with the same error [root@hyp12 tmp]$ ./go-check.git megacli -physical Adapter 0: Device at Enclosure - 252, Slot - 0 is not found. Exit Code: 0x00 Enclosure - 252, panic: runtime error: index out of range This may not actually be the megacli command crashing upon further inspection, but the append function failing since it has nothing to append... This chunk is immediately following the command execution result := strings.Fields(out.String()) //storing each space delimited field into a variable (strips tabular format) slot := []string{} //creates an empty slice slot = append(slot, result[4]) //"Slot" slot = append(slot, result[5]) //"Number:" slot = append(slot, result[6]) //0 or 1 slotNumber := strings.Join(slot, " ") //joins the appended strings together with a space fmt.Println(slotNumber) //prints "Slot Number: #"
They aren't listed under /dev/ and I was thinking about doing that but we need to know when drives don't exist so removing the elements that don't exist wouldn't help us. Something may have 4 missing drives out of 6 and we would never know since it's happily checking and reporting on the two present drives.
They won't be notified of your response. You have to click the "reply" link below their comments. And uh, quarks are subatomic particles.
I'm sympathetic to that view but I would definitely say it depends. Using a JS heavy app for a site that is largely static or primarily displays data is usually unwarranted. But web apps with a lot of user interaction and a lot of state can be simpler to build and faster/more pleasant to use when built with a frontend framework.
It certainly is, but I believe that for productivity, the Custom Postfix Completion, improved Extract Method, and certainly the quickfixes based on the Change Signature refactoring will be the ones that feel the most. I'm looking forward to hear how others use this new version.
Use 'continue'
It's quite hard to tell the difference until you start working your way down the other side.
Yep, I figured that out. Someone had recommended it before but I didn't understand it. I just had to name the loop. Thanks.
Thank you very much for feedback. 1. Yep i guess without closing i just stack memory? 2. I used before os.Stat(path), but on linux this fun returend me false even when file existed. Now i wrote some test scenarios so i would test more behavior with os.Stat ``` var isBodyFileTestScenarios = []struct { in string out bool }{ {"&lt;br&gt;", false}, {"/c/s/d.txt", false}, {"test_files/test1.txt", true}, {"%#a", false}, {"test_files/dir2/test1 copy.txt", true}, {os.Getenv("mail_log"), true}, {os.Getenv("mail_config"), true}, {"$", false}, } func TestIsBodyFile(t *testing.T) { for _, tt := range isBodyFileTestScenarios { t.Run(tt.in, func(t *testing.T) { s := isBodyFile(tt.in) if s != tt.out { t.Errorf("got %t, want %t", s, tt.out) } }) } } ``` 3. Why json.Unmarshal can fail? 4. Yep you are right os.Exit and this print would be better way. 5. I created this regex, because when user write &lt;br&gt; as body. There was an error like "this is not valid path" 6. Yep i want to test if all configuration i want send to gomail (dial func) is right. Also this is my first "serious" project with go, and github. And I want to test pull reqests, issues etc. Just learned what "fix #4" in commit message do, and linking to issues :) Thank you one more time for feedback :)
&gt;In general Go code uses interface{} when the function can handle any type at all (e.g. fmt.Print). Except that often people then try to cast back to some other type and hope for the best. This undermines everything and is basically a big backdoor in the type system when you can't express what you actually want. &gt; Whenever you can handle a subset of types you use restrictive interfaces. This handles most cases of generics. It really doesn't though. There are a zillion blogs detailing why and, as you point out, the language is working on incorporating them. &gt;I would be interested to know which of the following are "mount stupid" statements, in your view: &gt; &gt;* concurrency is a better structure than OOP hierarchies Well, concurrency isn't a "structure" it's a property of the execution model. These are independent concepts. You can program in an object oriented style with or without concurrency just like you can program in functional or procedural style with or without concurrency. Maybe you meant concurrency implemented via message passing vs shared memory instead of "concurrency vs oop?" If so, that would be the kind of statement that is characteristic of mount stupid. It's not supposed to be an insult. It's unfortunate that SMBC called it "mount stupid" instead of something less triggering. &gt;* simple is better than complex This statement itself is an interesting case study, since it doesn't mention anything else about the context of the trade off and leaves no wiggle room. The "*all else being equal*" part was omitted (perhaps for simplicity?) and now it's imprecise and much less useful. The sentiment is actually "Keep things as simple as you can, but no simpler," but that's lost here. It's a more complex idea, yes, but it's also much more useful. &gt;* "A programming language that doesn't have everything is easier to program in then some that do." No argument here. This statement is so broad that it's hard to disagree. :) &gt; You could say that the other operating systems of the time were written by more experienced people, who had gotten past "mount stupid"; who had rejected the ideas used in Unix. That might be the case? I'm not really qualified to comment on how naive Unix and Minix and Linux were at the time of their creation. I think it's important to make the distinction between trying new things and retrying old things because we don't know any better yet; or misapplying something we do know. The latter is mount stupid, right? "Ill write an OS too try my novel idea. &gt;And yet we use Unix systems (the only other one left in wide usage is Windows, which is more Unix-y than not), and we program in languages closer to C than to Lisp. Algol-family languages and lisps don't offer the same features. It isn't surprising to me that they aren't used equally. I don't consider uses of one or the other to be inherently atop "mount stupid." A mount stupid perspective might be that Windows has no useful place in the world, for example.
How else do you implement functions that take any type? I'm not a Go expert by any stretch, but it seems like empty Interface plus switch on .(type) afterwards is the best you can do. No?
Definitely check out [Nakama](https://github.com/heroiclabs/nakama). It handles multiple top 30 games on the App Store running on the system now, as well as having a unique concept for powering authoritative real-time multiplayer games. Would be great to see community contribution on handling EC2, Azure, Digital Ocean etc deployment topologies!
Honestly, just grepped on one of my projects with 17KLOC, and I have zero `.(type)` switchs, and only 12 occurrences of `interface{}`, half of them for js/wasm backend interaction (not sure generics would have helped here), and the rest is priority queue and logging stuff. So in some applications, `interface{}` style code use seems to be quite small (I haven't even thought of making any efforts to avoid it, I could probably reduce 12 to less than that with some wrapping functions).
you don't have to name the loop if it's only one
It's more useful as a tool that can group types into containers that's more human readable. You tried running it on a bigger codebase or the standard library? The way it's worded, it sounds like you're selling uml diagrams, but there's more value than that
&gt; Except that often people then try to cast back to some other type and hope for the best. This undermines everything and is basically a big backdoor in the type system when you can't express what you actually want. I think a less pessimistic way of viewing this is the following : less than or around 1% of the code uses Python-like dynamic typing (but with explicitly stated casting), and the rest is strongly-typed code.