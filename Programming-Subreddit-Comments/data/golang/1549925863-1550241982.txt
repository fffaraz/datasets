Go is big on "ease of programming" I was at a tech recruiting event recently and one of the recruiters was like: "I keep hearing about Go, but I don't know that many companies that want Go." And other recruiters didn't even know what Go was. And from what I'm seeing, it's like the older, more experienced developers that are learning Go, and of course, we're paid more because we've more years under our belt. I like it though, learning a language before it becomes very mainstream! &amp;#x200B; &amp;#x200B; &amp;#x200B; &amp;#x200B;
Simple selection-bias. Go is mostly used at companies like Google that are already high paying.
They could tick the box to say traffic was encrypted. It was easy for them, they just shifted the work onto vendors and the inconvenience onto users. Nobody who mattered in the box ticking process cared that everyone ignoring certificate errors was no better than using http instead of https. 
Also in the code you posted https://gist.github.com/funny-falcon/f69ee71c55bbf12340e2c1dbad55e3d1#file-greeter_client-go-L46, you seem to be sharing the stream between the goroutines. Was that intentional? Not sure what the sweet spot there is, but separate connections might help.
But the data is still encrypted with https, you just haven‚Äôt verified identity. So https with private certs is still better than http.
But the data is still encrypted with https, you just haven‚Äôt verified identity. So https with private certs is still better than http.
I think I found your problem. greeter_client/main.go. conn, err := grpc.Dial(address, grpc.WithInsecure()) Add certificates, otherwise the base level HTTP libraries won't kick in HTTP/2, and you'll be stuck opening new TCP connections for most new connections. Adding SSL allows it to upgrade to HTTP/2, since HTTP/2 is TLS only. I know there are ways to run HTTP/2 on non-tls, but it's non-standard. You may actually get a pretty big bump in performance by enabling TLS. 
People that don't know about go are living under a rock. Language designed by Ken Thompson and Rob Pike, under Google's roof. You could only say you were "learning it before mainstream" around like 2014/2015. At this point it's most certainly a part of the discussion, and any engineer should know it exists. Sure some recruiter may not know, but do they even know the difference between Java and JS?
&gt; Go was designed at Google in 2007 to improve programming productivity in an era of multicore, networked machines and extremely large codebases.[22] The designers wanted to address criticism of other languages in use at Google, while retaining their useful characteristics:[23] &gt; * Static typing and run-time efficiency (like C++ or Java) &gt; * Readability and usability (like Python or JavaScript)[24] &gt; * High-performance networking and multiprocessing &gt; The designers were primarily motivated by their shared dislike of C++.[25][26][27]
This! Hurray for shitty wifi lowering expectations, bless their hearts :P
Build to a Linux binary then simply cf push to cloud foundry
What's new?
[https://tip.golang.org/doc/go1.12](https://tip.golang.org/doc/go1.12)
[https://tip.golang.org/doc/go1.12](https://tip.golang.org/doc/go1.12) The two things I'm most excited about are: * \[modules\] \`go\` commands that download and extract modules are now safe to invoke concurrently. * \[fmt\] Maps are now printed in key-sorted order to ease testing
&gt; you didn't read question carefully You could say that, or you could realize you're not presenting your question in such a way to be easily consumed. Again, the link I shared would clue you in to a better way to present your question. &gt; Billion of requests per day is just You're assuming there's no internal fanout of requests across multiple services. Just a small peek: we need to manage access control, payment information, gather metadata for compliance, guard against abuse, manage physical and virtual resources, and much more. Some of these actions are synchronous, others are asynchronous, yet all replies need to make it back to our users. There's about 6MM lines of golang and 55k lines of protobuf in our repo. And that's just for our backend. But, sure, it's a trivial problem. &gt; As well as plain HTTP + XML. gRPC employs protobuf support, which is essential for ensuring two services can abide by the exact same interface, including the proper serialization of various data types. gRPC lets us easily glue together code for service discovery, load balancing and tracing. We've extended it to also provide authentication, encryption and metrics. HTTP + XML offers none of that. Good luck with your problem.
I don‚Äôt understand what this package does.
 .My guess is that the first case will be faster due to having only a single map lookup and not branch inside the loop. However, please test your hypothesis with the built-in benchmarking tools. There are many factors that could affect performance here. If you're really interested in performance optimization, may I recommend https://github.com/dgryski/go-perfbook
What kind of hardware did they use to achieve this?
which one? `httpsproxy` adds a self-signed cert to your cert pool and creates a http client that uses that cert pool, so you can use that cert without using `InsecureSkipVerify: true`. (it also does other things but if you are not running a https proxy you only need the http client part). `badcert` does similar thing with a different approach: it does normal http client first (without `InsecureSkipVerify: true`), if that failed, it does http request again with `InsecureSkipVerify: true`, then checks if the cert is whitelisted (by supply cert fingerprint to the args), and reject the request if it's not a whitelisted cert. That way it allows whitelisted certs or any other good certs that your system already trusted, and nothing more.
Yeah, I figured. Been there too...
Thanks for the explanation. That‚Äôs good to know.
It's really not though. There are remarkably few scenarios where someone is able to observe network traffic without being able to tamper with it. Training your users to click through security warnings is almost certainly does more harm than you prevent by using https without authenticating the server. 
I would recommend that https://github.com/ztrue/tracerr/ look at extending/replicating the API of the excellent https://github.com/pkg/errors to provide simple source code snippets inside the [Format() function](https://github.com/pkg/errors/blob/ffb6e22f01932bf7ac35e0bad9be11f01d1c8685/stack.go#L64)
&gt;In essence, we don‚Äôt intend to re-write the spec, but instead, fill in holes in the spec, find out where our implementations differ, and unify all of our implementations as much as is feasible. We believe that this will not only help all of us, but also help new tools as well. Being compatible with each other is an important part of the value of these tools. Looks like it's not about changing things. It's about bringing the tools together making sure they behave in the same way according to the spec.
Yassss, TLS 1.3!
[Scapy](https://scapy.readthedocs.io/en/latest/usage.html#stacking-layers) using the \_\_div\_\_ \`/\` operator to do encapsulation. It's really just defining it's own DSL inside python. &amp;#x200B;
idk man I got better things to do than searching random peoples' codebases on github for APIs I don't like
Yeah, use gofmt and get rid of those trailing semicolons! 
Huh, I saw the title and image together, so it wasn't clickbaity, since the content was part of the card and the "title" was merely the commentary that sparks the discussion.
I agree, but I think the needs for this are quite wildly varied and the version isn‚Äôt really the place for this. This is exactly why, as you mention, package managers usually have other metadata to handle this. It seems weird to try to encode that into version information, why not instead layer instead of adding a lot of non-version information into the version. Use Name Version Release (NVR). Standardize on more than just the version, but allow the basic project versioning release process remain mostly agnostic of package versioning concerns. 
I'm transcoding them to JSON using [https://godoc.org/github.com/golang/protobuf/jsonpb](jsonpb) and then storing them in Postgres using JSONB column type.
It should be OK to share the streams as GRPC will manage those itself. If there are too many streams inside a single connection, it will open an entirely new connection behind the scenes. It looks like a single TCP dialer, but theres some voodoo going on behind the scenes. 
More details about this from 2017 by the creators of the Tiny Websocket library used in the code. *https://medium.freecodecamp.org/million-websockets-and-go-cc58418460bb*
[removed]
don't copy paste comments.
Maybe you are implicitly making the argument that when it was added to Go 1.7, they could have renamed them to follow standard convention. Maybe you are right, but it seems like if we are going to have a single standard context package, not changing it makes it a whole lot easier to migrate for people using the old package instead of having separate pretty closely related packages.
That's a fair point. My examples were limited to platform related things, but other important data can be encoded there - the existence of debug symbols, who built it, anything really. Right now it's just a text blob with some (imo) stupid character restrictions. It would be nice to be able to embed some key value pairs for describing attributes of the build in a standardized format. 
Thanks! I get your point but this was one of the initial projects I developed with Go and wanted to directly use mostly everything offered by the SDK itself rather than going for the vendor packages. 
With the code from the gist above. Locally, like the OP.
&gt; does anyone know the reasoning why it was pushed back to March? There were issues discovered that needed to be resolved before a new release could be made. It took some time to resolve them all, hence the delay.
Wow, I misread that image. You are totally correct.
I'm not defending the practice of ignoring certificate validation, but using TLS without cert validation at least protects against passive traffic collection.
Did you start with the tour and it's interactive examples? https://tour.golang.org/welcome/1
Why? I know plenty of people that have never heard of Go. Just because I love it doesn't mean everyone else has to know about it. There are already plenty of established web frameworks out there, [asp.net](https://asp.net) core, django, node, spring, etc... that are more popular that people recommend (due to their popularity, more resources aka easier to learn), so it doesn't surprise me at all it's not more popular. &amp;#x200B; Take Dart, it's a fantastic language that was completely ignored until Flutter, a revolutionary framework, came out, that is really the first to succeed in its area. Go was not the first to succeed, and even though it does a lot of things great, it's a high competitive area. I didn't know about Go until just a few months ago (ok, I had heard the name, but literally nothing about it or what it was used for) when in the C# sub someone had compared CoreRT to Go (and how Go is doing it much better), and I am on programming subs and go to conventions all the time.
Thanks, very helpful. Here is another implementation of mine. [https://gist.github.com/williamzion/a4531c9d9bea4acea5d2868b3e367313](https://gist.github.com/williamzion/a4531c9d9bea4acea5d2868b3e367313)
&gt; I know there are ways to run HTTP/2 on non-tls, but it's non-standard. Http/2 does not require tls: ### [Does HTTP/2 require encryption? No. After extensive discussion, the Working Group did not have consensus to require the use of encryption (e.g., TLS) for the new protocol.](https://http2.github.io/faq/) however no browser supports using http/2 without tls, it will just fall back.
Can confirm, it's ridiculously expensive here.
Use `$n` for backrefs in Golang/re2 (ie - `$1`), and try enclosing your regexp string in backticks to avoid having to double-escape your back-slashes, eg: re := regexp.MustCompile("/::my_tag123\((\s+)\)/") Docs are: https://golang.org/pkg/regexp/ https://github.com/google/re2/wiki/Syntax
Why? Given numbers, it's one of the most popular and fastest growing languages on Github. By your answer, it sounds like you spend most of your time designing front-end systems, so sure, I suppose you have a point. Golang is still _10 years_ old, and the benefits built into the language have existed for the same amount of time. I guess if you're the type of engineer who relies on frameworks to get their job done, I suppose Golang may not be your go-to, but not knowing about one of the most influential languages in the last decade is pretty sad
But not by default: [https://github.com/golang/go/issues/30055](https://github.com/golang/go/issues/30055)
We can deal with that. It'll be default in Caddy.
I currently use pkg/errors in several projects, but initially, I found several reasons not to extend it: 1. It will add logrusorgru/aurora as a dependency for pkg/errors, which I'm not sure most of pkg/errors users needed. 2. pkg/errors has different behaviour when wrapping the same error again, which I'm not happy with ‚Äì it removes previous stack trace and replaces with new one, while ztrue/tracerr will not change stack trace if it's already added. In my opinion, it useful when you don't know if the error has or has no stack trace already. 3. pkg/errors requires to provide a message on every wrapping, which I'm not happy with as well, cause I prefer simplicity over complexity and didn't find it useful for me, but it adds a little code writing/reading overhead.
Yea, I didn‚Äôt mean non-standard as against spec, just against the norm. Still, it should be used. Also, one can enable compression on gRPC to help with performance a bit. 
I can't wait for SemVer XP 2020 (TM). /S &amp;#x200B; Seriously -- Getting everybody to agree on all the corner cases would be great.
&gt; When GO111MODULE is set to on, the go command now supports module-aware operations outside of a module directory, provided that those operations do not need to resolve import paths relative to the current directory or explicitly edit the go.mod file. Commands such as go get, go list, and go mod download behave as if in a module with initially-empty requirements. In this mode, go env GOMOD reports the system's null device (/dev/null or NUL). One thing I do currently to install and build a package and have the binary available is the classic ‚Äúgo get‚Äù, but it sounds like it‚Äôs use as a way of globally building and installing binaries is being phased out. Or am I misinterpreting this?
Cheers to Go team for keeping the backwards compatibility promise and still making Go incrementally better. Can't wait for generic in Go 2.0 though.
90k is quite slow to me, because I know that simple RPC is capable for 1M.
1. set the color of a line: `import "image/color"` `import "`[`gonum.org/v1/plot/plotter`](https://gonum.org/v1/plot/plotter)`"` `...` `l, err := plotter.NewLine(pts)` `if err != nil {` `panic(err)` `}` `l.LineStyle.Color = color.RGBA{G: 200, R: 10, B: 20, A: 255}` `myplot.Add(l)` &amp;#x200B; 2. flatten: myplot.Save() out to a "out.png" file instead of "out.svg". The ".png" suffix will make it rasterize (flatten) to a png file.
I'm pretty confident there was single connection established between client and server, because I did `strace` on both (during other run).
That is intentional. Using single connection is faster for almost every RPC system I know.
Gotcha. Not sure then. It‚Äôs kinda the fastest part of most stacks tho because it‚Äôs never an idealized deploy. While it‚Äôs nice to shave off a little time, the reality is, your database is going to be io bound anyways so the speed of the individual connections is less important. I also don‚Äôt know anything about SimpleRPC but I don‚Äôt know if it handles all the extra stuff that gRPC does. Either way, you‚Äôre free to use whatever system you wish between them. 
Aren‚Äôt all companied today multinational?
I agree that operator overloading in a number of languages that have it usually results in people using it for dumb stuff, like `&lt;&lt;` in C++. However, sometimes it is useful to have custom semantics for equality and ordering, and for certain domains overloading math operators can result in cleaner code. So maybe a solution could be allowing overloads for only a handful of predefined operators. This already exists in the language, e.g. math operators are defined for all integer and floating point types (with plus being defined for strings as well), and we avoid the ASCII salad of `&lt;&amp;&gt;` and `!=&gt;` and whatnot.
Sure, but how does that make the language ‚Äúobjectively worse‚Äù?
Nice! Thanks for this. I like how you're reusing the same file for all the work, and I see that I technically got the deferred removal and closure of the file in the wrong order, though I guess unlinking from the filesystem just leaves the file-handle open until it's closed. I had multiple files in there so you can in theory do something else with them like moving them somewhere. No need to defer the Truncate at the end of the function since it's going to run right when it exits. You could at the beginning, which would make sense if you put a return in right after catching the io.Copy error (which I forgot as well) ;) I like the use of proper http status codes from the package, my motivation for not directly writing the err.Error() back to the client was that I'd rather them not know *exactly* what's gone wrong. But I guess that's security by obscurity. The reason I used an 'uploaded' bool was to avoid using breaks. Years ago I a professor teaching me C taught me: "If you're using breaks, you're being lazy and there's a better way to do it". Which I guess always stuck with me.
I though like you until I realized that is not really the truth. Major, minor, revision exists since a long time but where used inndifferent policy. For instance, the linux kernel used odd minor version for unstable release. Major number could be reserved for a complete rewrite if the software but breaking change woukd not have be explicit but implicit. This is the intention if semver.
As a former engineer in aerospace, I can confirm Go devs make more. Regarding surgeons, a senior software engineer at a FAANG company can make more than a typical surgeon ($300-400k).
This isn't an answer to your question, but related to managing binaries; I recently discovered [gobin](https://github.com/myitcv/gobin), which looks like a good way to manage binaries within modules. I hope this comes to the Go toolchain in some form. I also use go get to install stuff (not just Go related tools), so I hope there's some out if modules ever default to on.
There is a difference between a convention (which should be applied whenever it makes sense) and a hard rule/law (which must be followed). Go does not use Systems Hungarian (for good reason!) so the recommended "Err" prefix for error values is _not_ a type indicator. If the value is not an "error" there is no need to prefix it with "Err". The state of "Canceled" is not an error, it is just returned in a variabel of error type. Not Hungarian and not an error: No Err prefix. Readability and common sense over mindless application of rules and conventions. Simple. Isn't it?
Just because some projects use other conventions doesn't mean that the convention in general wasn't well understood.
There is already an experimental implementation golang.org/x/exp/xerrors
Do you need a cookie? You sound like you need a cookie.
I think you want to know the number of runes in a string. See [here](https://stackoverflow.com/questions/12668681/how-to-get-the-number-of-characters-in-a-string).
At least you spelled my name correctly.
If you look at the internal of bytes.Buffer, you will see that it contains a []byte. Which is a strict containing a pointer to an array, the capacity of it and the current length. When you copy a bytes.Buffer you copy the pointer to the underlying array. So it is working as expected. What you could do to copy would be: // b is the bytes.Buffer you want to copy newB := bytes.NewBuffer(append([]bytes{},b.Bytes()...)) This will leave the current Buffer untouched.
never asked for full answer. i have tried and even provided what i have done so far , i was stuck on part where i asked for help . 
&gt;&gt;&gt; I help build and test systems that run billions of gRPC calls a day &gt;&gt; Billion of requests per day is just &gt; You're assuming there's no internal fanout of requests across multiple services I just read as you wrote it.
It's seems to be a bug. The last version of go does not have this bug.
I'd wish this applied to Denmark as well.
It is not deep copy. They still share same slice address. You can check how to clone objects witth https://github.com/ulule/deepcopier
It is because that `bytes.Buffer` used to has a bootstrap, which is an `array` (not a `slice`). When `bytes.Buffer` is used to contain a small buffer, it uses the bootstrap array to avoid allocation. And thus, when you run `var b bytes.Buffer = a`, `b.buf` is sliced on `a.bootstrap`, which is cleared when `a = bytes.Buffer{}` . This is "fixed" in 1.12, where bytes.Buffer.bootstrap is gone. &amp;#x200B; See: [https://github.com/golang/go/issues/26462](https://github.com/golang/go/issues/26462)
``` $ gorename -from '"context".Cacneled' -to ErrCanceled ``` Did you mean an import renaming is less trivial and easy then a variable renaming? The command above can rename a variable, but it can't rename an import. I am so pleased with the subreddit community‚Äôs attempt to protect this outright mess.
Hello fellow danish developer. I know M√¶rsk, Grundfoss, Vivino, Uber Danmark, Center for Cybersikkerhed og Peytz &amp; Co are using Golang and those guys are big guns and probably pays really good! I think Golang is slowly replacing PHP/ASP/.Net in Denmark for backend. M√¶rsk also held a Golang meetup last year. 
no, the number of characters, which is different from runes data = "√©" fmt.Println(len(data)) // output: 3 fmt.Println(utf8.RuneCountInString(data)) // output: 2 len, \_ := glyphSmart(data) fmt.Println(len) // output: 1
Usually I decorate plain functions. Decorating interfaces is ofc extremely useful too, just think about gzip.Reader/Writer. And `http.HandlerFunc` is actually a function type not an interface (`func(ResponseWriter, *Request)`). Decorating functions is just a lot easier in my experience.
yes, check https://golang.org/pkg/net/http/#Client.Post and https://golang.org/pkg/compress/gzip/#example__writerReader you should be able to tie it together quite easily. I've done something similar when I wanted an endpoint to zip several files on the fly and send it over the line to the client.
Here I am having to use a buffer to store the compressed file which gets too large gradually. How can I overcome this?
Private certs are fine and IMO often even better than public ones. Not verifying the certificate is not fine because you could be talking to somebody completely else than you think you're talking to.
The naming convention is very concrete in this matter. And it doesn't contain anything about "not a real error". But, anyway, thank you for your opinion.
Thanks for your review.
I'm skeptical that Go pays more than any other language once you normalize for things like other expertise required. Many Go jobs also require knowledge of cryptocurrency or machine learning or distributed systems, etc.
next level: make the dockerfile cache the `go mod download` step so that it doesn't need to run each time there's a code change if the dependencies don't change. also, i've never had to do a `chmod +x` on go executables. i believe the flag is there already.
Thanks for your advice..caching `go mod download` part makes sense. I am trying to implement it. Because sometimes Jenkins build stucks during the build stage. Caching might help to pass this part easily.
by using readers and writers as shown in the writerReader example. the io.Copy is buffered (which does not buffer the whole file/stream, but just chunks).
How can I read on other side at the time of writing?
Nice work! I will use this today =)
I get output: 1 for fmt.Println(utf8.RuneCountInString(data))
RuneCount should return 1 since it returns number of valid utf decoded characters. Atleast works for me with "√∂" "√§" "√©"
Presumably this means they are remote-friendly. 
The joy of having to deal with corporate environments.
I see you don't get the grasp of the io.Reader and io.Writer interfaces yet, which is totally understandable for someone new to Go, but once you understand how it works, it'll level up your skill for sure. Maybe read up on it, e.g. [https://medium.com/@xeodou/understanding-golang-reader-writer-2c855eae0a94](Understanding golang Reader/Writer). For your usecase, I think of it like this: 1) start GET request to source server. you now have a *http.Request which contains an io.Reader, getRequest.Body 2) start PUT request to destination server. and there's Write method *http.Request, putRequest.Write(io.Writer) 3) create a buffer (32k sounds nice) 4) create a gzip writer that writes to the buffer, gzip.NewWriter(&amp;buf) 5) read from getRequest into buffer 6) write buffer to gzipwriter into buffer 7) write buffer to putRequest 8) repeat till err == io.EOF not sure if you need 2 buffers for this, but still, should work I think.
I would love to see generics in Go, but I really do not like the draft. Why do we need these redundant contracts? I understand the need of providing a mechanism to let some types be used with binary operators (&gt;,&lt;, == and etc), but it could be done in a way more elegant way. Why don‚Äôt they just introduce runtime specific interfaces like it‚Äôs done in Rust (Eq trait, for example)? The contracts seem to me ugly and very counter intuitive. Go deserves a better solution.
I agree that contracts seem very unintuitive, and I actually mentioned Haskell typeclasses and rust traits during my talk. So yeah, you're not alone!
I get the output length 2 with the data = "√©" variant. The normalization I knew, but mine is about a couple of times faster. So the question is: am I missing something? &amp;#x200B;
In C++ I imagine you could provide template specializations and/or conditional tests based on the type such as std::is_pod etc.
Exactly, operators through interfaces. That could eliminate the need of genetics at all.
Does your version return the same number for both these letter which look the same? https://de.wikipedia.org/wiki/Normalisierung_(Unicode)#/media/File:Composicion_nh.svg
I've recently come across this same problem, and in fact it's very complex to figure out which runes correspond to visible glyphs. For example there are Unicode code points that are invisible and serve only to modify the display of preceding ones (they're called Variation Selectors). It's even more complex trying to figure out which glypns are "wide" and consume more than one fixed-width terminal cell (many Asian characters and certain emojis are like this). I found this library for the width problem: [https://github.com/mattn/go-runewidth](https://github.com/mattn/go-runewidth) However for counting visible glyphs, the only way I can see it being possible is by checking each rune with [Is](https://golang.org/pkg/unicode/#Is) against known Unicode range tables, but even that's probably not good enough.
Oh gosh, thank you :) It feels that Go team intentionally doesn‚Äôt want to borrow some good ideas from other languages.
The speaker's laptop; ThinkPad, I think.
[removed]
Because the mutexes are locked twice, the scheduler needs to do more work to manage the goroutines. The channel being buffered on the other hand means that all of the goroutines immediately can execute all of their code and terminate. 
Good question. It means that the expectations you have learned about reading and writing code are changed. Without documentations reading a scapy code is confusing. Why am I dividing these objects? One thing that Go has done is to not include things like properties or classmethods. When you call a function it is done the same and there are no tricks to hiding. ``` foo.Bar # field foo.Bar() # method `` At a glance I know exactly what is happening here. With other languages you have no idea. This could be viewed as a plus or minus, but for writing and reading code fast I prefer the explicitness of Go vs the flexibility to redefine the language (and thus break peoples existing knowledge)
Right. That protects *the company*. &amp;#x200B; But I'll bet they trained the workers "it's OK to click thru that complicated/scary warning" but didn't bother training them on when it's NOT OK to click that, nor why this is all happening. So now *the workers* are less secure.
Thanks for your reply but I'm not sure I follow. I don't believe the channels are buffered. I'm using `make(chan bool)` for each channel. In addition, I'm calling `wg.Done()` after the receive completes so the goroutine can't finish until after `done[i] &lt;- true` is called for it's channel. And the test won't complete until all goroutines complete due to the `wg.Wait()` at the end. It's true that `Lock()` is called twice, but I presume that must be true for a channel as well. How does the channel perform synchronization if it isn't using a mutex?
It hadn't been able to be programmatically embedded into package managers until it was standardized
I do recognise the need for a specification, but I am annoyed by the author's hybris of claiming that they had this great new idea. Be a bit humble and understand that this is just a formal write-up of what has been best practice in the industry for decades.
Oh, I misread, you're correct the channels are not buffered.
Having read stevens thoughts on semver a few times now I don't see what you do. He is not exuding hubris. He is writing matter of factly because it's from the perspective of package manager maintainers. Nobody thinks they came up with the concept nor are they misleading anyone into believing that. It may not have been written quite as carefully as you prefer but tbh I think that would be over the top and lose its succinctness
seems nobody is risking his reddit account for saying anything, golang community is known for its Nazi-tier hostility
Sure you did.
I'm not quite sure - to figure this out, you could try and use the runtime tracer. My suspicion is, that it's down to contention. The mutex code calls `Lock` twice in succession (from different goroutines). The first runs into the mutex fast-path, whereas the second sees that the mutex is locked and actually needs to call into the runtime, synchronize and go to sleep and everything. In the channel-case, I'd assume that both loops can run into the fast-path. I'm a bit fuzzy on the channel-implementation (should rewatch [this talk](https://www.youtube.com/watch?v=KBZlN0izeiY), it's great :) ), but I think if you read from it and there are no writers yet, no synchronization needs to happen. As I said, I'm a bit fuzzy on the details and the runtime tracer should help. But I'm pretty sure you can't view the code as equivalent.
&gt; How does the channel perform synchronization if it isn't using a mutex? The channel does use a mutex. But in the channel-code, that mutex is uncontended (only one goroutine tries to access the channel at a time), whereas in the mutex code, it's contended (you have two goroutines who trying to lock it concurrently).
Google calls it Go, or The Go Programming language where there may be ambiguity. Although there may be a sample size issue. If everyone else calls it Go, and one person making $132,827 calls it Golang, then that one person is going to rise to the top not having everyone else to bring down the average. This probably also explains how a technology that didn't even make the list at all last year is suddenly in first place.
Interesting. I tried refactoring the code so that both benchmarks spawn the same number of goroutines, since it's possible that the relative performance of mutxes vs. channels depending on how many goroutines the scheduler is dealing with. With 10 goroutines, mutexes are 3x faster. With 100 goroutines, performance is almost identical. With 1000, channels are 7% faster. With 10000, channels are 12% faster. So it appears that mutexes are faster (*much* faster) for small N, but channels eventually outperform them for large N.
One thing I'm excited about is the new [extended-precision arithmetic in `math/bits`](https://tip.golang.org/pkg/math/bits/#Add). They're implemented with intrinsics where available, so they'll be very fast. This will make it much easier to implement your own (e.g.) 128-bit numbers without resorting to something as full-featured as `big.Int`.
)Swagger 2.0? `swagger generate model --spec={spec}` [Source](https://goswagger.io/#generate-a-data-model
If you like gobin, check out [vfsgen](https://github.com/shurcooL/vfsgen). It's a similar idea, but with an implementation that aligns better with some other standard interfaces.
There‚Äôs no good way to count ‚Äúcharacters‚Äù in the sense that you‚Äôre talking about because of combining glyphs and what‚Äôs more there aren‚Äôt actually cases where you need to count characters in that sense anyway. What you really want to know is how much horizontal width the letters take up, but l is thinner than m, so counting ‚Äúcharacters‚Äù won‚Äôt help. 
You rock! Will definitely give this a try. Not sure how I overlooked that, as I've been on that source page a few times. Appreciate it!
Wow! Mind blown. Thank you, that link clears it up. If I understand that talk correctly, the channel implementation manipulates the goroutine scheduler directly and the result is that the channel reader doesn't actually need to acquire the lock! (The writer also reaches out of it's own "memory space" and writes directly into the reader thread! Mind blown again!) So in fact the channel code acquires at most one lock per thread where the the Mutex code acquires two. That aligns well with the approximate x2 performance factor.
I refactored your code a bit and this is the result (The ones with -Reset, so channels are still faster, but not 50% faster): ``` $ go test -bench . goos: linux goarch: amd64 BenchmarkStopByMutex-4 1000000 2631 ns/op BenchmarkStopByChan-4 2000000 1058 ns/op BenchmarkStopByMutexReset-4 2000000 878 ns/op BenchmarkStopByChanReset-4 3000000 563 ns/op PASS ``` This is the refactored code: ``` func BenchmarkStopByMutexReset(b *testing.B) { wg := new(sync.WaitGroup) wg.Add(b.N) m := make([]*sync.Mutex, b.N) for i := 0; i &lt; b.N; i++ { m[i] = new(sync.Mutex) m[i].Lock() } b.ResetTimer() for i := 0; i &lt; b.N; i++ { go func(m *sync.Mutex) { m.Lock() wg.Done() }(m[i]) } for i := 0; i &lt; b.N; i++ { m[i].Unlock() } wg.Wait() } func BenchmarkStopByChanReset(b *testing.B) { wg := new(sync.WaitGroup) wg.Add(b.N) done := make([]chan bool, b.N) for i := 0; i &lt; b.N; i++ { done[i] = make(chan bool) } b.ResetTimer() for i := 0; i &lt; b.N; i++ { go func(done chan bool) { &lt;-done wg.Done() }(done[i]) } for i := 0; i &lt; b.N; i++ { done[i] &lt;- true } wg.Wait() } ``` As to why channels are faster than mutexes, others already explained it.
Do you actually need the extended features from Perl's regular expressions? Can you simplify it? &amp;#x200B; (I'm going to plug [http://www.complang.org/ragel/](http://www.complang.org/ragel/) here because I love it, but I understand rewriting regular expressions is a fraught endeavour...)
In general, PCRE and Perl having small differences is to be expected. PCRE is not exactly identical to Perl. If you need help specific to the expression in question, this isn't necessarily the best place to put it, but I don't know where to take PCRE questions in particular. If you do want to try here, try to either {post an example RE with the relevant difference, the input that has different results between the two engines and what those are, and the desired result with PCRE, all as minimized as possible} or {post the input and the desired output with PCRE}. The latter is a bit more practical, probably. And I don't guarantee any responses from /r/golang. :)
PCRE is PCRE, Perl is Perl. They were never *exactly* the same, and each one has picked up unique features in the past 20 years. You'll probably just have to read the docs and tweak the regex to suit.
It protects the company until someone uses this to mount a phishing attack against them. The company is only no more safe as their users are.
let me godoc it for you :) - https://godoc.org/?q=snmp
Ooooh you are sooo good with searching i‚Äôam so stupid ... Please if you are so good my master tell me Which one of this support SNMP ‚Äî‚Äî&gt;SERVER &lt;‚Äî‚Äî not agent/Client trap receiver but Server and it‚Äôs workig implementation not some POC and one more think Please give me this secret knowledge how to Find user experience in brains of people who use and inplement it 
Just checked your post history and it seems like you try to stir up a lot of drama in this subreddit claiming the Golang community is hostile. I don't know how you expect a meaningful discussion with such a foul attitude.
I am sometimes confused about which types satisfy which interfaces (the cost of not having to declare this, like some other languages). 
Could you use a gist or play.golang.org to show this code? Its very hard to read as it is.
&gt; ‚Ä¢ [fmt] Maps are now printed in key-sorted order to ease testing I was just asking about this in IRC! This is great news for my use case. üòÉ
&gt; seems nobody is risking his reddit account for saying anything, &gt; golang community is known for its Nazi-tier hostility towards any criticism Winning over Reddit will not get you anywhere. &gt; The Go project's development process is design-driven. Significant changes to the language, libraries, or tools must be first discussed, and sometimes formally documented, before they can be implemented. &gt; &gt; Ref: https://github.com/golang/proposal People who don‚Äôt like or are missing something from the language can submit a proposal to add, modify, or remove it, this allows the rest of the community to give opinions, have a fair discussion, and maybe change your mind if what you are proposing is not beneficial.
for a code block: use 4 spaces at the beginning of each line of code.
Previously: [https://www.reddit.com/r/golang/comments/9r051l/why\_golangs\_community\_is\_so\_hostile\_to\_any\_kind/](https://www.reddit.com/r/golang/comments/9r051l/why_golangs_community_is_so_hostile_to_any_kind/) &amp;#x200B; &amp;#x200B;
I fixed your comment to format your code. Please be aware that many people dislike the new Reddit UI, so many of us are using old.reddit.com which doesn‚Äôt supports code formatting using backticks. If you prefix every line with four white spaces, the code will look fine in both interfaces (old Reddit + new Reddit) but if you use backticks, it will only look fine in the new Reddit, but mangled in the old interface. --- I refactored your code a bit and this is the result (The ones with -Reset, so channels are still faster, but not 50% faster): $ go test -bench . goos: linux goarch: amd64 BenchmarkStopByMutex-4 1000000 2631 ns/op BenchmarkStopByChan-4 2000000 1058 ns/op BenchmarkStopByMutexReset-4 2000000 878 ns/op BenchmarkStopByChanReset-4 3000000 563 ns/op PASS This is the refactored code: package main import ( "sync" "testing" ) func BenchmarkStopByMutexReset(b testing.B) { wg := new(sync.WaitGroup) wg.Add(b.N) m := make([]sync.Mutex, b.N) for i := 0; i &lt; b.N; i++ { m[i] = new(sync.Mutex) m[i].Lock() } b.ResetTimer() for i := 0; i &lt; b.N; i++ { go func(m *sync.Mutex) { m.Lock() wg.Done() }(m[i]) } for i := 0; i &lt; b.N; i++ { m[i].Unlock() } wg.Wait() } func BenchmarkStopByChanReset(b *testing.B) { wg := new(sync.WaitGroup) wg.Add(b.N) done := make([]chan bool, b.N) for i := 0; i &lt; b.N; i++ { done[i] = make(chan bool) } b.ResetTimer() for i := 0; i &lt; b.N; i++ { go func(done chan bool) { &lt;-done wg.Done() }(done[i]) } for i := 0; i &lt; b.N; i++ { done[i] &lt;- true } wg.Wait() } As to why channels are faster than mutexes, others already explained it.
`GOPATH`
The pattern for shutting down goroutines is actually closing one channel that many could listen on, and the version for locks would be to use a sync.Cond. I don't have a computer in front of me or I'd try this myself, it's a fascinating bit of micro-optimization.
Nice. It reminds me of this other snippet I wrote some years ago :) here: http://www.gofragments.net/client/blog/netweb/2016/01/04/httpUploadManyFiles/index.html
* People who say "Golang" instead of "Go" for any purpose besides use as a search engine keyword. * The belief that "language simplicity" is a valid reason to encourage copy-paste code. * The general bondage-and-discipline attitude.
Slides : https://speakerdeck.com/eranyanay/going-infinite-handling-1m-websockets-connections-in-go
"invalid memory address or nil pointer dereference"
Badly maintained libraries (only using the master branch or a low amount of activity). The lack of generics. Mediocre debugging experience. 
context implementation
Go's abstractions save me time, but when I need to actually make something really fast it is difficult. Also, a lot of the code in the standard library is hideous and difficult to learn from, because it has so many special cases for efficiency. Go is not targeted for people who do things like that so I think it's okay, but it is something to be aware of, and it's something that Go could be better at.
- Big binaries - Many things are based on reflection - No cross platform dynamic library loader without use of gccgo 
no generics
if err != nil 
GOPATH is gone, as far as my daily usage is concerned. People starting on 1.11 or 1.12 may not even know what it is.
[removed]
No, just that the snapd daemon is in Go and it's the vulnerable application. Not all security issues are solved by a memory-safe language.
Logging.
The ‚Äúnet/url‚Äù package name 
A [type assertion](https://tour.golang.org/methods/15) should clear that confusion right up, no? The Goland IDE will also navigate interface definitions for you. Just another option...
I love Golang. I don't like that people are trying to make it more complex for version 2. If go will reach version 2, I wish it to remove things instead. [Things in Go I Never Use by Mat Ryer](https://www.youtube.com/watch?v=5DVV36uqQ4E)
Checking a pointer for nil before using it has been a best practice as long as pointers have been a thing...
...is a great idiom because there's no need to guess where an error occurred. Set up a keyboard macro to add that boilerplate and Bob's your uncle.
Doing arithmetic that requires floats and ints to be used rapidly becomes a big mess of type casts. A short example from an implementation of Gibbs sampling for a model of count data, where a probability needs to be calculated that depends on the counts (integers) and real functions of them. ``` score *= (float64(z.TknCts[d.TknIDs[i]]+j-1) + m.Beta) / (float64(z.NTkn+j+ct-1) + float64(m.Corpus.V)*m.Beta) ``` Compare to ``` score *= (z.TknCts[d.TknIDs[i]] + j - 1 + m.Beta) / (z.NTkn + j + ct - 1 + m.Corpus.V * m.Beta) ``` The latter is certainly more readable, and when dealing with hundreds of lines of this, trying to see the actual logic through all the casting becomes difficult. It's not the biggest issue but when relevant it can make writing code very tedious and difficult to maintain or change. If any one of those types changes, that ends up requiring editing a lot of code. Now I definitely prefer that Go doesn't have implicit casting in the general case, and so I would like the alternative even less, but I wish this were less clumsy.
\+1 the only thing certain about ORM's is that'll get in your way at some point. It's your call and "depends" what you need to do with the data. Hopefully, your SQL results are static and don't have users entering dynamic statements.
err checking. 
If you're routinely checking pointers aren't nil, you're doing it wrong. The right thing to do is check error values.
Having two different variable declaration/assignment syntaxes, and having to use both of them.
That's interesting. In hind-sight I should have started with that approach. I rearranged my code as you describe and the results can be seen here: [https://imgur.com/a/wqyUHjw](https://imgur.com/a/wqyUHjw) (is there a way to show the image inline?) I don't get quite the same numbers the general trend is the same. In my case the break-even point was around 1000 goroutines. Mutex's outperform channels up to about 1000 goroutines then channels take the lead. The difference is significant for large numbers of goroutines. I don't know how useful these results are but it was a great learning exercise. Thanks for everyone's input! Here is the updated code: package stop import ( "sync" "testing" ) func StopByMutex(threadCount int, b *testing.B) { for n := 0; n &lt; b.N; n++ { b.StopTimer() wg := new(sync.WaitGroup) wg.Add(threadCount) m := make([]*sync.Mutex, threadCount) for i := 0; i &lt; threadCount; i++ { m[i] = new(sync.Mutex) m[i].Lock() go func(m *sync.Mutex) { m.Lock() wg.Done() }(m[i]) } b.StartTimer() for i := 0; i &lt; threadCount; i++ { m[i].Unlock() } wg.Wait() } } func StopByChan(threadCount int, b *testing.B) { for n := 0; n &lt; b.N; n++ { b.StopTimer() wg := new(sync.WaitGroup) wg.Add(threadCount) done := make([]chan bool, threadCount) for i := 0; i &lt; threadCount; i++ { done[i] = make(chan bool) go func(done chan bool) { &lt;-done wg.Done() }(done[i]) } b.StartTimer() for i := 0; i &lt; threadCount; i++ { done[i] &lt;- true } wg.Wait() } } And the driver code: package stop import ( "fmt" "testing" ) var threadCounts = []int{8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, 131072, 262144, 524288, 1048576} func BenchmarkStop(b *testing.B) { for _, threadCount := range threadCounts { b.Run(fmt.Sprintf("StopByMutex_%d", threadCount), func(b *testing.B) { StopByMutex(threadCount, b) }) b.Run(fmt.Sprintf("StopByChannel_%d", threadCount), func(b *testing.B) { StopByChan(threadCount, b) }) } } &amp;#x200B;
^(Hi, I'm a bot for linking direct images of albums with only 1 image) **https://i.imgur.com/dYz7uYY.png** ^^[Source](https://github.com/AUTplayed/imguralbumbot) ^^| ^^[Why?](https://github.com/AUTplayed/imguralbumbot/blob/master/README.md) ^^| ^^[Creator](https://np.reddit.com/user/AUTplayed/) ^^| ^^[ignoreme](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=ignoreme&amp;message=ignoreme) ^^| ^^[deletthis](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=delet%20this&amp;message=delet%20this%20egcakik) 
I'll take that over "Segmentation fault" any day. It even comes with a stack trace!
That's fine as long as I don't have to look at them.
Gee, I love the GOPATH... I put \*all\* my dev work in it now.
Highly unlikely to be the case once people start using it. 
A segv is just about as good. It's silent memory corruption that really sucks.
&gt; you're doing it wrong Thanks for sharing your opinion, tho it would be nice to hear your rationale. I prefer code that never panics. So I'll check for nil where appropriate.
I like most of it. Short thread about what I'd change: https://twitter.com/purpleidea/status/1095351276316045313
I'm sure there's an emmet plugin, or something like it, to do this for you.
'this might be a pointer or reference, but it's NOT null' encoded into the type system: F#'s maybes.
I came up with the following optimization: func BenchmarkStopByMutexInt(b *testing.B) { wg := sync.WaitGroup{} wg.Add(b.N) m := make([]sync.Mutex, b.N) for i := 0; i &lt; b.N; i++ { m[i].Lock() go func(i int) { m[i].Lock() wg.Done() }(i) } for i := 0; i &lt; b.N; i++ { m[i].Unlock() } wg.Wait() } Several runs in a row, I got the following: ``` BenchmarkStopByMutex-4 3171 ns/op 2852 ns/op 3046 ns/op 3171 ns/op 2 allocs/op BenchmarkStopByMutexInt-4 1284 ns/op 1229 ns/op 1323 ns/op 1302 ns/op 1 allocs/op BenchmarkStopByChan-4 1320 ns/op 1883 ns/op 1010 ns/op 1171 ns/op 1 allocs/op ``` --- These tests are not testing "How fast is a mutex/channel?". The question being tested is "How fast is a **Goroutine running a mutex/channel**?" Part of the slowdown with the mutex is the additional allocation necessary to pass the mutex as a parameter into the function. To address this, I changed the concurrent function to use an int as its parameter. I actually did the same for the channel version, which helped a bit, but it still had that one allocation, so there wasn't much of an improvement (maybe 100ms, but I didn't save those results). I'm still new to this type of profiling, so I'm likely missing something. 
&gt; Not all security issues are solved by a memory-safe language. Does anybody think this?
Has nothing to do with memory safe or Go at all. I'm not sure how it applies. It's simply a logic error plain and simple. This could have been Python, C or Bash.
neat, I always like the math-trick code.. from the arxive link: On common processors, integer multiplication is many times faster than integer division. Dividing a numerator n by a divisor d is mathematically equivalent to multiplication by the inverse of the divisor (n / d = n x 1/d). If the divisor is known in advance---or if repeated integer divisions will be performed with the same divisor---it can be beneficial to substitute a less costly multiplication for an expensive division. Currently, the remainder of the division by a constant is computed from the quotient by a multiplication and a subtraction. But if just the remainder is desired and the quotient is unneeded, this may be suboptimal. We present a generally applicable algorithm to compute the remainder more directly. Specifically, we use the fractional portion of the product of the numerator and the inverse of the divisor. On this basis, we also present a new, simpler divisibility algorithm to detect nonzero remainders. We also derive new tight bounds on the precision required when representing the inverse of the divisor. Furthermore, we present simple C implementations that beat the optimized code produced by state-of-art C compilers on recent x64 processors (e.g., Intel Skylake and AMD Ryzen), sometimes by more than 25%. On all tested platforms including 64-bit ARM and POWER8, our divisibility-test functions are faster than state-of-the-art Granlund-Montgomery divisibility-test functions, sometimes by more than 50%. 
Definitely this. The lack of a debugger is troublesome.
What about Delve? I've not used it much, but I've heard good things about it, curious to get others' take on it.
I agree as far as simplifying the language, however I do not agree with removing functionality as this breaks backwards compatibility. 
As I said, there are very few scenarios where someone has the opportunity to passively collect data without having the opportunity to to tamper with it. Training your users to click through certificate warnings creates a much more tangible risk. 
I wasn't passing a mutex in my first example but rather a pointer to the mutex which I wouldn't expect to be any different than passing an int. I did try changing my [latest version](https://www.reddit.com/r/golang/comments/apv6gj/why_is_a_channel_faster_than_a_mutex_in_this_test/egcak41) but there was no appreciable difference. I'm surprised it made such a big difference for you.
Yeah, this was a bit facetious. But if you don't present what you've already tried before asking for help, you don't help us helping you. (The first link, coming from influxdb, probably is quite reliable.)
While it's true that it's made in Go, I'm pretty sure no one actually believes that all security issues are solved by a memory-safe language. You can fuck up in any language! 
I frequently see claims that switching to Rust solves the security issues presented by C and C++, but rather it just solves the (granted a large percentage [https://www.zdnet.com/article/microsoft-70-percent-of-all-security-bugs-are-memory-safety-issues/](https://www.zdnet.com/article/microsoft-70-percent-of-all-security-bugs-are-memory-safety-issues/)) memory-safety ones. Same goes for Go.
[removed]
[removed]
this. Having to use := on the first `err := doTheThing()` and not any subsequent ones, so if I remove the first call I have to change the second one too. I'd love it if we just used `:=` for all assignments and the compiler worked out that if the variable name is the same then it doesn't actually need to allocate a new variable.
There are functions that are guarantee never to return a nil pointer. Checking for nil in those situations is just noise. 
I did this once and had an argument with folks over at the google group. I objected to using comments to drive code generation (I still think it's a stupid idea, but as I never use code generation I'm not so annoyed by it). It came down to one of the Go devs saying "you're wrong, using comments is really elegant, end of discussion". I'm not saying that's not the best way of doing it; I think design-by-committee usually produces crap, and having someone make those design decisions is great (even if I disagree with some of them). But the idea that Go is a democracy is not so close to the actual truth.
Syntax.
(1) The billion-dollar mistake (nil pointers). I'd like to see any putative "new" language fix these things (I know Go isn't exactly new, but it's in that position). Haskell is a good example of how this can work. (2) Excessive concurrency Concurrency is a useful tool, but most programmers don't adequately understand it. Forcing every little problem to be solved with goroutines as the standard library does (e.g. all IO blocks) and then making clean-up hard (how do you clean up a goroutine blocking on IO that will never happen?) is bound to lead to problems. (3) Not-quite-memory-safety. Go purports to be memory-safe, but this is in fact not true around race conditions. Since Go uses threading everywhere, and most programmers don't understand concurrent evaluation, is it really going to end up much safer?
People complaining about it not having generics, the way error handling is done, or other not having feature "x" as some other language does. Golang needs to stick with the Golang way and not try an satisfy everyones issues with the language, if you don't like it then use another language, the ones who do like it will naturally come together and form a great community. This will keep things clean an simple with no BS and academic masturbation.
I miss async/await and Promises from JS. But also all the other stuff already mentioned: no generics, error handling boilerplate, debuggers sucking.
Whats wrong with logging? There are more loggers than one could be bothered to test; [https://godoc.org/?q=log](https://godoc.org/?q=logger)
&gt; There are functions that are guarantee never to return a nil pointer And there are functions that don't. So check those. What's the confusion?
Yeah, that is what a major version is. But that's just an IF.
Standard logger is not structured. Which shouldn't be an issue of course, because third party packages wouldn't ever do logging, right?
&gt; Does anybody think this? https://www.reddit.com/r/programming/comments/apm5g6/microsoft_70_percent_of_all_security_bugs_are/eg9mrzx/
Manifestly untrue, given what we know about mass surveillance and the capabilities of actors who would love to collect your network traffic but who don't have the resources to manually target every individual. Also the fact that many, many people run their systems on hardware and networks they don't own (ie, public cloud), it makes sense to encrypt the data. Now obviously an internal CA is the way to go, but it's simply untrue to say that encrypting but not validating certs is no better than plain HTTP. It's just not and it's dishonest to say otherwise.
Yeah, we did a dumb.
Not sure what you mean about guessing where an error occurred. Go errors don't have stack traces. Languages that use exceptions (often?) do. There are libs for creating errors with stack traces but it seems tedious to hook those up everywhere, and it won't actually have the original stack frames where they occurred when they're coming from library code. Also, a lot of the time if an error occurs I just want the program or execution context (i.e. at the request handler level) to just blow up. I prefer the default equivalent of `if err != nil { panic(err) }` for unhandled errors that other languages have.
I'm not OP but, A simple example would be GetUser() (*User, error) It is rational to assume that \*User is not nil if the error was nil checking if the pointer is nil is a great if you like defensive programming, but go is not mean to be used with defensive programming, at least that is my opinion. One example for this is a simple struct with a map type Simple struct { data map[string]string } func NewSimple() Simple { return Simple{} } func (s Simple) AddData(name string) { s.data[name] = "value" } As an author you **assume** that the user will call the New method for your struct, but you have no way to enforce this, other languages at least have constructors that enforce this but go doesn't. But even then you can not be sure that the author initialized their struct correctly, the above code still panics even if you call NewSimple and then access the AddData method, because the initialization code is incorrect. The point is that you have to trust someone at some point that they are doing things correctly. Defensive programming basically assumes that you are an idiot and you don't know what you are doing. You end up with 3X as much code to guard your code against.. well yourself.. &amp;#x200B; &amp;#x200B; &amp;#x200B; &amp;#x200B; &amp;#x200B;
What's the newer practice?
go modules. your projects can live anywhere, just like any normal programming language.
What? Debugging Go code is a pleasure compared to debugging async javascript code. 
Do you have an example of one in the stdlib? 
The obvious one: lack of parametric polymorphism (aka generics).
It's better than nothing, but I have complaints from using it with vscode: * sometimes breakpoints don't work on certain lines * can't use it with any code that uses plugins, even if no plugins are actually loaded * useless blank wrappers appear around values/fields * can't call functions * no rewind * logpoints don't work * conditional breakpoints might not work? (not sure I recall correctly) I'm sure go itself and the vscode-go extension are responsible for some of these though.
Which inherently means 30% of security have nothing to do with the type of language 
You're really stretching the meaning of that article. 
Maybe someone knows a work around for these: * Temporarily comment a block of code; therefore, I have to also comment variable definitions because they are not used anymore * Temporarily comment a block of code; therefore, I have to also have to comment imports, even though I will be using it again. In either case, the compiler returns an error about this. 
This changes everything..
How would you go about this? Very curious and would love to implement into my dockerfiles. 
\+1
Freaking tabs!
Major version is guaranteed not to break backwards conpatibility. 
For the second case, you could configure your editor to run goimports on the buffer before saving. Saves you the hassle of typing the imports yourself.
Nowadays the only thing that gets to bother me is how big the binaries are. Just wrote a 60 line program which ended up at 1.8 MB. o.o Generics would be nice, but I never actually needed them in go, and I know they're on the grill for version 2.
&gt; in the stdlib? It's open source, you can check for yourself. Tho I dunno why you bring up stdlib... I never implied that. I still don't understand the confusion here.
&gt; go is not mean to be used with defensive programming Any language that allows nil pointers / references should be treated with defensive programming. Period. &gt; Defensive programming basically assumes that you are an idiot That's a very pessimistic take on the practice. I prefer the stance that I'd like my code not to explode in production, so I program defensively. It's not a lot of extra work -- by the programmer or the CPU -- to do so. Cheap insurance. Why not? &gt; to guard your code against.. well yourself.. I'm not the only person writing software. My unit tests aren't perfect. There are many vectors through which bugs can be introduced. As I said, it's cheap insurance to check your pointers...
Languages that use exceptions don't often include a usable stack trace, in that the programmer can't easily decipher and/or annotate the trace. The burden is placed on a human to read the stack trace... this doesn't work with automated / remote logging facilities. &gt; I just want the program ... to just blow up That's not an option for production software. Thankfully go gives us the option.
Me too. But this is because there is simply no choice if you want to work without pain in the ass. For many years, this "internal rebellion" has not passed. It remains some kind of prison that cannot be left without crutches and suffering. –°onsidering it all I'm very excited about new modules.
Yeap. But we still have to wait for them to be enabled by default.
&gt;and the compiler worked out that if the variable name is the same then it doesn't actually need to allocate a new variable. this implicit behavior would be difficult to debug. When you think you've created a new variable, but actually you've just shadowed
yep but then you have to give up vendoring because go modules will always download shit :|
My point is that it‚Äôs not necessary with idiomatic code. 
that's not true. `go mod vendor` downloads everything `go build -mod=vendor` builds using what was previously downloaded, forever, without downloading anything.
There is the go race detector. 
Threads like this?
&gt;Languages that use exceptions don't often include a ***usable*** stack trace See Java stack traces. Near impossible to decipher without substantial effort and knowing the system in detail.
Requiring the "," for the last item of an Object
I really like this. Have you continued to work / improve on this to completion since your post? I am not sure who downvoted you but this is precisely the maturity I rebooted a project I was working on and looks like I was mostly steering your direction: https://github.com/johnwyles/vrddt-reboot
May I ask what editor you are using?
Or mangled C++ stack traces. Might as well be written in Klingon.
You're assuming every coder involved in the project, and every 3rd party library used in the project, is coded perfectly and idiomatically. That's not a safe assumption to make with production code. Even with unit, integration and e2e tests, bugs still appear and will cause panics if nil checks are omitted.
How projects my projects have to live in $GOPATH/src/thing.com/path It's really a love hate relationship because I have live projects for production projects there, but I need to work against Dev packages as well. 
I'm in the habit of declaring my vars at the top if it's a sufficiently large function. That and creating a new scope with {... do some stuff with variables which don't pertain to the outer scope ...}
`go mod vendor` is fine but having to manually append a `-mod=vendor` for every build command you want to do is a bit stupid when it could easily just see the vendor file there and check to see if it's valid. Last i saw they were still debating if they even needed to firm up how it should work any further.
Making people do slice of bytes like it's the 80's. For reading files and collections. I understand the authors were the ones who came up with these concepts and made them twice. But some of us don't know this low level in our sleep like they do. Would be nice to have an array method or two. I know they have addressed this many of times but I just think it's a bit of a blind spot in the core API to have to go down to this level.
We must assume good will here and not malicious intent. He's totally trying to steal our credit card info through man in the middle proxies. 
That‚Äôs nice that you hate the current vendor interface, but it doesn't make your original statement correct, and your opinion on the interface is not relevant in this discussion. I don't like it either, but it is certainly a real option that doesn't require continuous network access like you previously claimed.
... Am I the only one who thinks two weeks from being put in a bug tracker to being announced with full details of how to exploit it and running code examples is the precise opposite of "responsible disclosure"? The updated packages weren't even released until less than 12 hours ago, so presumably anyone with access to an Ubuntu system that isn't running `apt update &amp;&amp; apt upgrade -y` in a `for {}` loop has a serious back door problem they will be scrambling to fix when they wake up tomorrow?
I use VS code, it uses igomports by default
Doesn't context make more sense for something like this? func StopByContext(threadCount int, b *testing.B) { wg := new(sync.WaitGroup) wg.Add(b.N) ctx, cancel := context.WithCancel(context.Background()) b.ResetTimer() for i := 0; i &lt; b.N; i++ { go func(ctx context.Context) { &lt;-ctx.Done() wg.Done() }(ctx) } cancel() wg.Wait() }
I almost get along with these except for damn variable shadowing (especially in nested blocks) getting in the way. If shadowing was gone, two types of assignments would be more consistent. 
Do you also defer/recover everywhere? You never know if those third party libs are going to panic.
I think you can alias `type f64 = float64` and shorten the thing a bit (Rust style?) This is just a thought popping out, I haven't actually tested.
Yes since the OP named it "stop". For a way to know that it's time to stop, context is more useful. channels can be used to do more things, though, like passing data into/out of the workers. But mutex doesn't have that ability normally.
A third party package should just define log.logger which you can pass in a Type implementing io.Writer that wraps your preferred application logger, ie: the way its done in the net/http package with ErrorLog. Also the standard logger can be structured, you can structure the text output then parse with a regex before inserting into the centralised logging server, there are also tools like Logstash to make it easier. That is the way its been done for years before the serialized JSON logging approach came about. This issue also re-enforces why the if err != nil idiom is important by returning errors in your packages so you can do more granular logging in the application side. &amp;#x200B;
In my benchmarks it comes out faster than channels most of the time too.
Because it's an unfair comparison to the channel implementation here. You only have a single context. If you also create `b.N` contexts with cancel functions, the performance should be similar to the channel implementation.
Not sure it's unfair if it achieves the same results with no downsides. I guess either way it's unrelated to the question in the OP's subject which has already been answered.
I really like this feature. I use it for seeing important vs junk variables. The same idea as `private()` vs `Public()` I pre-define every single variable in my go code (often in the function signature). I use `v := 0` for when the variable is temporary and only for that block scope.
Garbage Collection
Garage Collection
This was in my mind too. It makes declaration more clear. Worth the extra effort.
The default option will download and check the go.mod files at every run. There is limited communication of this behaviour change. you will only see it if you're wondering why it is taking so long to build. it will also not use vendored packages. While I agree after rethinking it saying always was wrong. it is certainly a new default behaviour that is vastly different from earlier behaviours of go build. 
How verbose my code is. I started out as a C/C++ programmer so I‚Äôm used to rigid types and the verbosity of imperative languages. But over the last 10 years I‚Äôve worked with Scala, Ruby and Clojure and love how I can chain expressions together to express what i want very succinctly. With Go I haven‚Äôt found that with its explicit error handling and so on. For example functions that return two results cannot be composed together like they can in more functional languages. 
Time formatting. I get the reasoning behind it and I'm not sure I think the traditional "YYYY-MM-DD" formatting was necessarily better (more like I've just being doing it that way for a long time and I got used to it), but I **always** have to look up the reference date string and screw around with it for longer than I feel like I should to get it working.
Structure is as you find it: https://brandur.org/logfmt
They are enabled by default as long as your project lives outside of `GOPATH`.
I have different dislike that you guys may never heard, * Efficient file descriptor select-like behaviour. This is for listening many sockets at once without creating one connection-one routine. * Mediocre stdlib performance. You name it, there is other package out there that claim they were faster than stdlib.
Yeah the first one is annoying. Sometimes I am testing code and I comment out a block of code, finding out I also have to change all the used variables to '\_' ...
collections and workspaces
No ternary operator.
I think I heard somewhere that if you need a variable/function public to test it, you probably need to have it public anyway. Myself, I like putting mocks in each subpackage instead of in a outside dir. I use separate dirs/package only when doing extra end to end or stress testing. I do mocks as I try to have each part of the system should be substitutable. Then I am not mocking to test, I am mocking so each 1 little function is kind of easy to plug in if need be with data. I would suggest trying to break things down behaviorally, or dependency based. And lifting the dependency calls as high as possible.
This is not true at all
I've never once used that flag and never had this happen. I think you are mistaken.
Thanks for your input. I should have been more clear. The dependency I'm implementing would never be used by anything else. In short, it connects to a Kubernetes API server and returns some very specific data.
github.com/willf/bitset github.com/willf/bloom github.com/nightlyone/lockfile
Gofmt uses one format and one format only. If I could configure that one feature, life would be so much simpler for me. I really don't like tabs in my code.
while i'm not familiar with vgo, with dep you would do something like FROM golang:latest AS build-env WORKDIR /go/src/whatever... # resolve deps ADD Gopkg.toml . ADD Gopkg.lock . RUN dep ensure -vendor-only # copy code ADD . . # build RUN CGO_ENABLED=0 GOOS=linux go build -o ... i'm sure the idea is the same in vgo. the idea being, copying over only the files which define the dependencies, and resolving them before copying the rest of the code.
Actually I tested it and single context (your implementation) are not faster than channels, and `b.N` contexts are even slower than mutexes: $ go test -bench . goos: linux goarch: amd64 BenchmarkStopByMutex-4 1000000 2720 ns/op BenchmarkStopByChan-4 2000000 1058 ns/op BenchmarkStopByMutexReset-4 2000000 877 ns/op BenchmarkStopByChanReset-4 3000000 567 ns/op BenchmarkStopByContextReset-4 3000000 1026 ns/op BenchmarkStopBySingleContextReset-4 2000000 598 ns/op PASS Looking at the source code, both [`Done()`](https://go.googlesource.com/go/+/go1.11.5/src/context/context.go#325) and [`cancel()`](https://go.googlesource.com/go/+/go1.11.5/src/context/context.go#348) are implemented with mutex lock and unlock operations, so it's actually understandable result.
&gt; Everyone seems to suggest just using stdlib for Golang web apps Always ask those everyone to show you the full sack web app they they built 'using stdlib only'.
I don't like that we can do multiple declarations of import ( ... ), var ( ... ), const ( ... ), type ( ... ), but not func ( ... ). I don't like the ability to name returning vars in func declarations (it feels odd and adds up to unreadability). I don't appreciate the lack of functional features like map, fold etc. I don't think recursion is hard to read and miss tail call optimizations much. I don't like godoc style and can't read it more than a minute. play.golang.org is unusable to me (sometimes I just want to check something fast) due to it's 2005 design decisions and lack of common online code executors features. Neither do I like golang.org.
Can you elaborate when bin size really is a problem? 
https://golang.org/doc/faq#Does_Go_have_a_ternary_form
You're not wrong, but I could also argue that math like this will never be easy to understand just by looking at it. I've had some of this (less than you, I'd bet) and found it necessary to make a bunch of helper functions with good names to help me follow the logic. Then I can use comments in the functions to explain the details, and keep my main function less cluttered. 
&gt; I did that and couldn‚Äôt be happier, it works great and doesn‚Äôt require almost any set up What did you build with just the stdlib? A small API, or a full stack web app?
When using on embedded.
Web app with react front end, static file serving in addition to about 30 routes serving and receiving different components with different data in JSON. User authentication with Bcrypt and interaction with ArangoDB and redis. That being said I am a hobbyist not a professional, I haven‚Äôt tried deploying to production yet, so I can‚Äôt comment on the challenges there I basically followed the go web app tutorial from Udemy. It is $10 and covers all the basics, including even building your own session manager 
&gt;Web app with react front end Many people who ask about Go web frameworks, mean for building server rendered apps. &amp;#x200B; Many use cases, such as Reddit, are not suitable for this mushroom growing client side rendered apps. That is the reason so many users are unhappy about the new Reddit performance.
Wish vs code would catch up to go land. Guess I should contribute, wish I had time...
It doesnt allow passing pointer to large objects guaranteed to remain unchanged. For example: func (p * const sometype) print() { ... } 
That's minor version.... Major is literally for breaking changes.
One to many broadcasting with channels can be depressingly messy and requires a surprising amount of boilerplate for something that seems to be so common.
Having to do this func main() { // Code } Instead of this func main() { // Code }
May I ask what is the problem with tabs? 
car parks itself back in your garage
I think it's pronounced "gah" "raw" "ja"
That is what I am using it for, but go std library also has a templating engine 
there is an open issue on the matter right now. https://github.com/golang/go/issues/27227 
GitHub.com/brianvoe/gofakeit
Yes, especially because the date format over here is DD-MM-YYYY, which results in some illogical numbering sequence. I wish that system was less akward.
I'm not talking about js because I don't think that's a competitor. I'm comparing it to e.g. modern C++ IDEs and .NET languages. 
 I mean, for the most part. There are plenty of tools that still require you to be in GOPATH, basically anything that relies on the [loader](https://godoc.org/golang.org/x/tools/go/loader) package (so, most generators), as it also does not support modules yet.
Many programming languages uses evrionment variable controlled paths for includes and linking which works like GOPATH: PYTHONPATH, LIBRARY_PATH, LD_LIBRARY_PATH and others.. 
I‚Äôve only just recently gotten into Go (loving it) but it‚Äôs mainly having to type ‚Äúgolang‚Äù constantly for searches and ‚Äúgo‚Äù in the cli. My potato brain struggles to keep it all in order 
if that's what you think, then you don't understand GOPATH. GOPATH required your project to be in that same directory, not just your dependencies.
You can have multiple entries in GOPATH
so you're suggesting that the first step in creating a new project is to create a new GOPATH folder containing bin, pkg, and src directories, as well as your project's path inside the src directory? No. This is not how normal programming languages work. Go modules is so much better than GOPATH.
I'm not suggesting anytning, I just said that essentially GOPATH is the same as PYTHONPATH or corresponding functionality in other languages.. It just bootstraps a little bit different.. Before \`vendor/\` and/or the vendoring tools was a thing in go most of my projects contained 2 GOPATH's, One for the appliction sources and one for the vendored sources.. It worked well but modules is in most cases better.
That's the main problem. There isn't a really good stand out solution so every library uses something different. My project is large with 100s of dependencies; mostly they don't log because it makes it hard to import them from a project that uses something different but some do log, using a different logging library to our main codebase. The common choices I've seen don't log line numbers and filenames, both of which I find very useful when debugging. I think the reasoning behind no line numbers/filename is to encourage logging that is more meaningful but IME that's wishful thinking.
The number of hoops we need to jump through since we don‚Äôt have generics. This is especially obvious when working[ JSON data which uses an envelope](http://eagain.net/articles/go-dynamic-json). This is super obvious coming from Swift with codable and generics where I can handle making an API request to an endpoint which uses envelopes with `func makeAPICall&lt;ExpectedPayloadType:Codable&gt;(...)` And then to actually decode: `JSONDecoder.init().decode(Message&lt;ExpectedPayloadType&gt;.self, from: data!)` It‚Äôs two lines and you don‚Äôt need to deal with multilayered decoding 
I like that switch between POST and GET. Nowadays I use the httprouter to write different handlers for them, but I've always liked how neat switches are. For writing the files I typically don't let clients dictate the real filename on storage so they don't overwrite each others files. By the way, in your code I think the defer file.Close() before handeling the error Create might have returned could break things. Not sure, but I think the filehandler might be nil in case Create fails, and calling Close() on nil barfs ^_^
One way of remembering it is that it is 1-2-3-4-5-6 with 3 being 3pm, therefore 15 if you want it to be 24hr. 2006-01-02 15:04:05
That part is optional as of 1.11 and gone in 1.13. 
That seems to be a very nice tool, thanks! I did it more for learning purpose, first Golang proper project :)
Generics ( I love using sed for polymorphism), error handling, context, pedantic tools ( unused variable? Oh my god! ). That said I still like the tools a lot, but I rather write Python. 
I didn't even know about that site until now. Reminds me of gowalker.org
For the first one, create a if false {} block around the code you want to "comment". Its not detected as dead code and maintains variables and imports
[https://github.com/maxatome/go-testdeep](https://github.com/maxatome/go-testdeep) :)
This. Kudos for trying something new, but it didn‚Äôt work out. ü§∑‚Äç‚ôÇÔ∏è
Responsible disclosure, at a basic level, only requires that you wait for the vendor to have a fix available, you do not wait until every system is patched. Some researchers or vendors might decide to wait a bit for automated processes that will pick up a fix to do so, but in general (for open source software in particular) you have to assume that anyone scrutinizing your releases and repositories will see the fix, and if they're a bad actor they could begin exploiting immediately. So, you go public at the same time so that the word gets out and both the good and bad actors have access at the same time. All that being said though, depending on the vulnerability, the disclosure might look different. For example, if you find a vulnerability in AWS itself, you may well wait for Amazon to have the patch fully deployed before you disclose because there is only one affected customer and waiting is more feasible.
Yes I pretty much just wrote a little rfc3339 package that can parse and generate rfc3339 timestamps.
[removed]
+1 also
Agreed. Especially if I add code above that uses an err or other variable. Becomes very tedious.
&gt; to express what i want very impenatrably FTFY üòé
I'm torn over inheritance. I like it and miss it when doing some stuff but I also hate it when overused so probably best left out. 
This is basically saying you don‚Äôt like the responsibility of passing in good data. Might as well complain about the need to breathe regularly for your entire life.
Named returns
The fact that the designers and maintainers of Go listen to the vocal minority that post complaints to Twitter, Reddit and other social media platforms. It's lazy feedback monitoring that doesn't reflect the opinions of the wider, saner and less inherently negative community.
Perhaps I don't understand what you mean, but the √ë and √± count as 1 in my example program. I have to admit, I have a second routine that does it in the way mentioned in the stackoverflow (with the var ia norm.Iter) and it shows the same outcome, only very fast compared to that
I mean I get that it‚Äôs a safety thing, but I‚Äôve been using Python quite a bit the last 5 years and can‚Äôt remember a single time that implicit declaration caused me debugging trouble. For me, the `:=` causes trouble debugging because it‚Äôs too visually similar to `=`. 
When using wasm.
https://libs.garden/go?sort=popular
Sorry for taking so long to reply. Had to carefully read your message because this seemed like a good learning opportunity. &amp;#x200B; Thanks for carefully reviewing all the details regarding the task at hands. It seems I have to re-think this project before proceeding!
I come from a php background, and spaces are king in all our standards. Got used to them.
First off you need detailed requirements or if you going for the agile route user stories. I don't think Go is any different from any other programming language when it comes to planning projects. You also have to ask yourself some other basic questions: - Make sure you understand the problem you are trying to solve. What are the most complex parts? - Is Go the only option? Make sure it fits the problem and be open to any language. In what aspects Go helps me solve this problem better? - Does software already exists that solves my problem? If yes, do I need to adjust it? Do I need professional support? If no, can I alter similar software? What do I want to make different than existing solutions? - Do I need to hire new staff or can I teach existing? Do I need to hire an expert in a certain field? There are lots of other questions some more general and some more specific. Please don't listen too closely to what I have said, I have no idea of management and have never planed any nontrivial project.
The [FFI overhead](https://github.com/dyu/ffi-overhead)
No, Go 2 is guaranteed to be interoperable with no breaking changes. https://github.com/golang/go/wiki/Go2
That I don't have a job working with Golang and have to use Java instead :(
More an esoteric issue: I did't find a way to compile the complete toolchain(not just the bootstrap compiler) for a (tbh really old) Pentium II machine. Building it there crashes largely due to its memory consumption. Then I found new Debian backports version of go1.11 and my problem was solved.
Whooops! README.txt?
Well, that's a bit different from what you originally described. If you want to use a vendor folder, and have started using a vendor folder with modules, and you want to continue using a vendor folder, then you will have the issue you've mentioned. If you use the default functionality of modules, then it doesn't download dependencies every time, it just uses the default location. Unless you're committing your dependencies there's not really any difference either. As an alternative to committing a vendor folder, you can always use a proxy too, which would also speed up clean builds.
I quite like it too. Prior to using Go, before even knowing about the GOPATH structure I was already organising my code by repository location, e.g. `~/git/github.com/seeruk/i3x3` etc. so it was just a case of putting a `src/` at the top for me - it just makes it easier to navigate.
&gt; We do not want to break the ecosystem. Go 1 and Go 2 code must be able to interoperate in programs with ease. I think this is saying something more along the lines of "we'd prefer not to break anything, but if we do it _must_ be easy to update the code. AKA, we don't want another Python 3 on our hands.
The plugin for Sublime also allows using goimports as the formatter.
Last time I checked, Delve didn't support function evaluation. Like, that's one of the basic things that modern debugger should support.
Put your implementation into its own package is the best way to go IMO.
- Lock contention - Mutex causes cpu to switch threads to other processes
Nice
There's a big difference between revealing the vulnerability and providing a proof of concept that any script kiddy can use. It's similar to showing the picture of a master key that opens all car doors, versus being able to pick a copy up at Timpsons.
The same like you would calculate the cost if you would have to build it in Java or Haskel or C# ?
Your problem can be solved by declaring your teat file to be in package service_testing.
Dude. Error is an *interface*.
Is that your repo? I'd be interested if anything has changed on newer Go versions?
&gt; but then you have to give up vendoring because go modules will by default download shit unless you append -mod=vendor every time you go build Not necessary every time. Just do `GOFLAGS=-mod=vendor` once.
I'll give you the only true and tested way to accomplish this. Estimate how much you think it will cost, multiply by 4.
README
Documentation?
MoSCoW the requirements. Make a detailed estimate of the work effort for the Must &amp; Should requirements. Calculate the number of days and you will have a least worse price. Add 20% contingency. Do you feel that its worth your time and effort for the Risk vs Reward for this price? If not, how much would it be? Give a rough estimate of the work effort for the Could requirements - don't spend much time on these as these \*will\* change, and over estimate the work effort. Propose a phased delivery of the Must requirements on a T&amp;M basis. Review feedback on each delivery phase, adjust timing and cost estimates based on this and inform the Customer ("You do realise that this change will end up costing this amount?")
Lack of SIMD intrinsics or auto-vectorization. Not complaining particularly as can be worked around with asm or something like [https://github.com/mmcloughlin/avo](https://github.com/mmcloughlin/avo) but it would be really nice to be able to write complex loops/logic including simd optimizations.
Java stacktraces are easy. Your IDE will even usually highlight the points that exist in your own code with little clickable links (in blue if it's yours, in grey if it's some third party lib) that take you straight to it.
Sorry, that's not my repo. There may have been a very negligible improvements with Go 1.10 as far as I remember.
added readme. 
added readme. 
I thought that was a feature
added readme.
No, it means that 30% of security bugs don't have to do with memory issues. There are other types of bug which the choice of language also affects.
Nah, there's also a possibility of having an Option type in a language. This can help in reducing the number of nil pointer exceptions. (Please note I'm not actually complaining here, just wanted to clarify that I believe something like this could actually mitigate OP's stated complaint.)
I bought this training on Oct 25th last year. But I haven‚Äôt started learning yet though. The issue is that there is always something or someone demanding my time. And usually after, I‚Äôve lost the will to start the the training. Right now it‚Äôs a 6 month training given by one of my clients to all new hires (temp, freelance, or perm. Do you guys have any trick(s) to fit in frequent training in between ?
See also a related proposal I registered for Go2: https://github.com/golang/go/issues/25572 
A simple hello world is indeed already about 1.8MB. But that is the default environment. You can do loads with that, without it really growing. The reason it is so big, is because everything Go needs to run is in there, so user level threading and all.
By documentation, I meant documenting the code.
&gt; * sometimes breakpoints don't work on certain lines &gt; * logpoints don't work &gt; * conditional breakpoints might not work? (not sure I recall correctly) I hope one day you get around to filing a bug about these. &gt; can't use it with any code that uses plugins, even if no plugins are actually loaded This will be fixed in Go 1.12 and debugging plugins themselves [is](https://github.com/go-delve/delve/pull/1413) [coming](https://github.com/go-delve/delve/pull/1414) too. &gt; useless blank wrappers appear around values/fields such as? &gt; can't call functions Was added this summer. &gt; no rewind it's been there for almost two years. &gt; variables sometimes get garbage collected before they go out of scope the alternative would be higher memory use right?
I‚Äôm a big fan of clarity, too, and being able to follow other people‚Äôs code (and my own!) easily is something I value very highly. That said, the same generally applies to Python code. You *can* significantly change the behaviour of the language, but it‚Äôs *culturally* frowned upon. The power to alter behaviour is typically used to hide implementation details and preserve an intuitive API. OTOH, it‚Äôs still ‚Äúmagic‚Äù, and it‚Äôs likely to bite you at some point if you‚Äôre not aware of exactly what‚Äôs going on, say by monkey-patching `socket` with `gevent`. I‚Äôm a big fan of the ‚ÄúZen of Python‚Äù. That‚Äôs why I use Go: it fits the ZoP better than Python does these days.
I really like how it works. It's just that the chosen date is not good. I'm quite sure that `2001 Feb 3 14:05:06 -0700 MST` instead of `2016 Jan 2 15:04:05 -0700 MST` would be way less confusing.
I've got a similar pattern except I explicitly declare the variables at the point that I need them before I immediately assign them. I use this as a kind of signal to say _"hey, these variables? they're used for more than just this little bit"_ 
[https://github.com/timtadh/dynagrok](https://github.com/timtadh/dynagrok) [https://github.com/timtadh/lexmachine](https://github.com/timtadh/lexmachine) 
Of note, it looks like custom tasks were broken in VS Code 1.31 and had to be patched today: https://github.com/Microsoft/vscode/issues/67990 You might have better luck with tasks now, though I still would recommend the other approaches I mentioned.
I'm interested in finding more cool Go repos too. I've recently stumbled upon: * [https://github.com/picatz](https://github.com/picatz) Who writes some cool netsec-related go code, and is a maintainer of [https://github.com/bettercap/bettercap](https://github.com/bettercap/bettercap) * Also, my colleague [https://github.com/jlevesy](https://github.com/jlevesy) recently started a really cool project which deserves more love to create swarm clusters on the fly (√† la \[kind\]([https://github.com/kubernetes-sigs/kind](https://github.com/kubernetes-sigs/kind))) [https://github.com/jlevesy/go-sind](https://github.com/jlevesy/go-sind) * I recently started following [https://github.com/khast3x](https://github.com/khast3x) who tends to star really cool projects that I would never have found out about otherwise * That's all that comes to my mind right now but I might add more if some ideas come up I'd love to hear about other cool go devs!
The Gopher mascot is cute 
I have figured it out. So stupid I am... Wrong: ```go entry := blist.wlanBssEntries[i] pEntry := unsafe.Pointer(&amp;entry) ``` Right: ```go pEntry := unsafe.Pointer(&amp;blist.wlanBssEntries[i]) ```
Oh dear god... please elaborate?!?!?!
Go is almost as efficient as C/C++, while keeping the code syntax simple. That is a win-win situation for both the humans and the processors!!!
It‚Äôs what my company uses. But I specially looked for Go work because I feel the language will grow in popularity and having 4 years professional Go experience in 2020 I think will look good on my resume, in addition to the 8 years PHP before that. Plus I like it. I feel productive in it. 
I appreciate your work on this project.
Hasicorp, docker, etc use Golang.
&gt; Now, instead of an object containing individual properties for things like the uid and pid, we have a single string variable with everything concatenated together. I wouldn't pass this shit on review in any language.
if err != nilThanks if err != nilit if err != nilworked, if err != nilI'm if err != nilnow if err != nilwriting if err != nilidiomatic if err != nilGo if err != nilcode if err != nilall if err != nilthe if err != niltime if err != nilwith if err != nilminimal if err != nileffort!
A little wordy, but... As I gain experience and supposedly more senior titles, I mostly gain a better understanding of how little I truly know and how fast technology is layering on more and more. Working full time in C# keeps me up to date with the keywords added, and updates to the runtime and major frameworks just as writing a lot of Angular keeps me up with frontend things like webpack, ui stuff, Typescript, etc. Python isn't terribly hard to keep up with, but it still has a lot of stuff you can tuck under the blanket and reveal with a single all-powerful method call. Go however... it only has a couple dozen keywords. There are no generics. No breaking changes to the language. I can look at fairly complicated code and understand it in minutes at most (unless it uses cgo which strays a bit from my domains of professional comfort). It's so simple in syntax that I know I can have a busy two months only writing C# and then write some Go without hesitation or relearning anything. It's just so explicit. Some people complain about things that are wordy or miss generics, but I personally feel that those are byproducts of how greppable Go remains. I love that. It's reflected in other areas. A fast compiler, static-linked binaries, a community that works hard to avoid breaking changes, build in documentation tools, and no unused locals (combined with errors in those handy multi-value returns) all give a small assist to that narrative of developer assistance. Delve is pretty great too. Debugging is hard. Things that can borrow from C-related tooling or browser tools have an easier time at making a good debugger, but the progress made on Delve and the work to integrate that in Goland and VS Code are fantastic and make for a sane experience solving problems. In a phrase: ease of mind.
4 years is pretty good for Go at this point. A year ago I looked into changing my focus to Go after several years as a C# dev and some professional Go work but mostly hobby work. The interviewer said, "Well, you'd do better as a C# developer. If you really want to compete for this position, you'll be competing against Go devs that already have 10 years Go experience." I wanted to correct her on the state of Go developer candidates due to the age of the language, but I didn't think it would come across as polite.
I'm viewing the stack traces in log dumps from about 10k layers up. Enterprise &lt;3
closures in python work a little differently though &amp;#x200B; def hi(): i = 40` hi() print(i) # 21 def bye(): global i i = 40 bye() print(i) # 40
I normally just assign all the variables to `_` &amp;#x200B; `_,_,_,_ = a,b,c,d` &amp;#x200B; OP still has a valid point though
Go module experiment allows your code to live wherever. I have migrated all of my Go code so that the main repo is outside GOPATH. GOPATH is still used by the tool chain and to stick binaries in bin/ but that works for me. 
2001 Feb 3 **16**:05:06 -0700 ?
GameDev. (api, databases, data processing)
I suggest deleting this and resubmitting with proper usage of the link. It's really annoying to have to click through to the self-text, only to be met with nothing but a link.
Yeah I'm with you there, there's no language mechanism in the world that will save you from inadequate logging in a complex system.
Libraries that enable distributed async communication between microservices, as well as the core logic of those services themselves.
That wont make the IDE change the colour of the text, making it quite confusing
I'm not saying this is a bad post or that you shouldn't have written it, but Go in its current form is a very bad language for exploring this concept in. Generics would help, but that would only let it squeak up to "average", which is still not very good. This is exactly the sort of stuff Go is kind of designed to keep out of your code base. This is connected to your point... &gt; Unfortunately, I don‚Äôt think the operator has seen much use in the real-world, although it is a neat theoretical idea. You'll note I said that "Go with generics" would be "average", and that average is "still not very good". I believe this is part (though not all) of the reason why you don't see this sort of thing happening in mainstream languages. They're pretty bad at it! When you start exploring "what if I could use amb?", or similar things like "[what if I could natively program with probabilities](https://web.engr.oregonstate.edu/%7Eerwig/papers/PFP_JFP06.pdf)?" or "what would a language designed to run natively across CPUs and GPUs look like?" or any number of other things, you really start to learn just how deeply almost every major language today is still just a shell over what is basically C. If you're interested in playing with this sort of thing, I would recommend getting into Haskell. For instance, in Haskell, [amb is _very_ close to the built-in list monad implementation](https://wiki.haskell.org/Amb), which is used often without much fanfare in the Haskell world. Alternatively, you can try to stay in Lisp, but IMHO you'll find yourself fighting a lot more accidental complexity, and in Lisp you tend to end up with little islands of support for things like "amb" but then the rest of the language can't use it. Haskell has, historically, been much better about being able to implement some crazy idea like this, and then the crazy idea is actually _useful_ because it composes acceptably with the rest of the language. (Go is going to fight you every inch of the way if you try to work in it instead. You'll be into code generation very quickly, and you'll get bogged down in a lot of accidental complexity that will make it hard to see through to the underlying beauty of the ideas.)
Startup in the travel industry. Serving data from databases via gRPC.
Go is simple and really fun to program with. It has excellent interfaces that make all kinds of communications and I/O simple and easy to build upon. The standard library is excellent too. The built-in concurrency features are fantastic, and static binaries make deployment easy. I how easy it is to cross-compile applications too.
If I would base such a decision on a "**single** most [important] reason" I would not be worth the money they pay me.
Control/Management plane for VNFs. 
Then the client will say "it will cost a lot of money and time if I give you the project. So better I try to find alternative." What will be your response then?
Yup
vim. I don't have this configuration, but vim let's you run arbitrary commands on the buffer when it's saving. Other editors usually have plugins for this.
Working for Canonical (the company behind Ubuntu), writing snapd.
finance
Finance, cyber security. Internal support apps.
Im hoping to do this one day :D
Powerchord?
Oof. You read about that dude that used your service to get priveledge from any user?
I wrote the original code (that wasn't vulnerable), reviewed and approved the code that introduced the vulnerability, read the private bug reporting the vulnerability, held my head, and wrote the patch that fixed it.
Thanks for the input and the resources! I have horribly little touch with LISP-like languages but hope to change that soon, and devote some time to learn new concepts, maybe Haskell is a good starting point. Also, this comment of yours strikes gold. &gt; almost every major language today is still just a shell over what is basically C. I wholeheartedly agree that Go is a horrible choice for implementing this concept, and that it should probably *never* be used in a serious setting, but it's exactly the limitations in Go that in my opinion make this sort of thing fun and challenging. The main thing I wished to explore (and hope to get people's views on that) is how one can imitate how continuations are used in other languages, and provide similar results. I understand that this is an anti-pattern in Go, but trying to make it happen is a good lesson to find out why.
You write/maintain those, or you use them ?
Not a single reason, many of them at once: Good tooling, large amount of libraries, garbage collector, not suffering from Academic impracticalities and "CS science syndrome", easy to learn and use, GC, good for getting things done.
Hey man I wasnt trying to mock you! Sorry if it came off that way. Shit happens and I know it. I wrote a bug into my companies code where purchases couldnt be made for a week. Luckily we are super low volume and I emailed the like, 12 people directly and the retried. Again, apologies for coming off as rude or mean, the oof was more like, " I bet you had to deal with a lot of shit over it".
You didn't come off as mocking nor rude. Sorry if it sounded like you had.
Typical Go API calls which return pointers look like: func NewThing(args) (*Thing, error) { ... } Built into this API is an implicit contract: If `error` is `nil`, the pointer is valid to use. If the pointer is not valid, `error` will not be `nil`. (It's possible for the pointer to be valid and error not be nil; that's the case with things like EOF passed back as an error. That won't cause a panic though.) So if you check the error return, it's superfluous to check the pointer as well. If you always check error returns, you should almost never get panics. The last time I got a panic wasn't because of a bad pointer, it was because of an int that was zero and shouldn't have been. If you look at Go's stdlib, there are very few counterexamples, situations where pointers are returned without error values to indicate whether they are valid. So in general, if you're checking pointers against nil a lot, you're writing unnecessary code, or your own function calls are not idiomatic Go and are returning naked pointers where they should also be returning error values.
Monzo Bank in London uses go on the backend I think. Not sure if it‚Äôs API level or business service/engine level though. 
Everything
When you are optimizing for size. :) We are talking about a really small program that when compiled is about 40% the size of the alpine base container image (that's a full linux distro). I just tested compiling the exact same program with gccgo, and got a 66k binary out of it. The interesting part is that this 66k binary is 2x SLOWER to run than the 1.8M bin. Probably due to dynamic linking. To be fair, for my use cases binary size alone isn't going to make me switch language. But it would be really nice to have the cake and eat it too.
I'm not even using a router in my newest project. ([No, really](https://blog.merovius.de/2017/06/18/how-not-to-use-an-http-router.html).)
write. there is game server in java, and everything else around it in go. hopefully one day we'll rewrite it in go too.
I love Ubuntu, nice work!
I love you both
Oh, someone downvoted my comment as you replied, I assumed it was you. Someone misunderstood me! :P
&gt; It does not make it a good thing, but it explains. Correct. I know WHY it is big. It would just be nice if it weren't.
People have Opinions.
I thought it was a well known fact that go isn't meant for defensive programming.. I mean Go doesn't even have basic constructors, you can't even enforce a valid state of your structs. I mean I am not saying you should never check if pointers are nil, but you have to draw a line somewhere. So what do you do about structs with maps? Do to assume they are initialized correctly or check them for nil too?
If someone has the opportunity to see your traffic, that means your traffic is flowing through their network. If your traffic is flowing through their network, they have the opportunity to intercept and tamper with it. There are [hardware devices](https://www.symantec.com/products/ssl-visibility-appliance) on the open market capable of man-in-the-middling TLS traffic at 9 gbps, and you can bet the mass surveillance folks can do better than that. They don't have to "manually target every individual;" they just have to run the traffic through one of those. Now, it may not be feasible to do that with *all* the SSL traffic on the internet, but the volume of traffic from self-signed certs is small enough that it's probably quite feasible to route the bulk of it through man-in-the-middle tools. When I was in college I spent *half a day* and got a *laptop* up and running where it could spoof a wifi access point and [upside-down-ternet](http://www.ex-parrot.com/pete/upside-down-ternet.html) anyone who thought they were connecting to my class wifi (with the instructor's permission - it was a network security class). It would have been trivial to throw in [sslstrip](https://moxie.org/software/sslstrip/) or [mitmproxy](https://mitmproxy.org/) (though I'm not sure it existed then) to start messing with HTTPS traffic for anyone who wasn't validating certificates. If self-signed certs aren't going to protect you from a college kid who spent half a day configuring a laptop, do you think it's going to protect you from a surveillance state? I might concede that not validating certs is 1% better than plain HTTP, but I absolutely stand by the claim that training your users to click through certificate warnings does more harm than using HTTPS without certificate validation does good.
I do not believe, nor claim, that I had a great new idea. I'm not even the original author of semver.
Writing LETTERS of RESIGNATION 
Matured business that develops end to end business software to other businesses. My team mostly writes internal or ‚Äúbehind the scenes‚Äù software on both web and Windows desktops. We use go for everything server related: monitoring, logging, APIs, email servers, data processing, reporting, etc. We also are keeping an eye out on go GUI efforts - would love to snip .Net out of our workflow (it‚Äôs currently only there for the odd desktop application). 
&gt;10 years Go experience Of course, it's you vs the historical Go team... (joke) Go grows in popularity, but not everywhere. All Go jobs I received through Linkedin are for remote jobs (today a message from Australia, I live in France). But locally I was only contacted for C#/NET jobs. Sadly it's safer to have multiple skills, not only Go. &amp;#x200B;
Same here. I've yet to see any need for Docker.
Text analytics (word vectors, API server, model training)
Automotive aftersales SaaS (CRUD REST APIs basically)
What libraries are available for this? I‚Äôm doing some computational linguistics in python but am interested in switching over to go.
Working in blockchain and distributed computing field in a startup 
Wow, that is a large project that does look pretty useful for certain tests, yet mostly unknown.
Finding people who start neat things is an underappreciated skill.
Awesome work!
&gt; Dynagrok is a dynamic analysis tool for Go. It generates control flow graphs, call graphs and control depence graphs. It even has a random code mutator. It also performs a number of analyses, such as: Code clone detection, Statistical fault localization, &amp; Test case pruning. 
You‚Äôre such a pro at being an asshat. What kind of comment is this ^^. 
I didnt intend to come off this way. I explained in an edit/reply to the OP a bit ago.
For me, one of the biggest (but definitely not the only) reasons is that Go was able to say no to many features that are nice individually but not worth having in aggregate. It‚Äôs the most minimal viable general purpose programming language I‚Äôve found. That property makes it a great foundation for building so many things. That, and it‚Äôs also the most fun language I‚Äôve used.
I also like this one: github.com/keegancsmith/rpc
API development for county and state government services. I'm a junior developer working exclusively with Go.
Without the code I cannot really review it that well; however it seems this structure should fix your issues. your actual library: myhostinglocation/name/library: defines the interface myhostinglocation/name/library/implementation: provides the actual API implementation myhostinglocation/name/library/mocks: provides mocks for the defined interface then you can use your program in myhostinglocation/name/main, where you import library and implementation separately. if interface and implementation are very coupled, and you only use dependency injection for testing purposes; put everything in a single file and make the interface private. If your codecoverage tool does not ignore the mocks, who cares? You shouldn't trust coverage, only use those tools to figure out where your tests are weak.
Redesigning MFC-dependent Surface Movement RADAR software for the Federal Aviation Administration. The current 15 year old software is hosted on Windows XP. The new software is hosted on RHEL. Chose go for various reasons and can't be happier. Deployment is now a single executable for each subsystem and the maintenance terminal interface is a web application instead of relying on an MFC-based application needing a dedicated computer. Love the tool chain. Love the language.
&gt; I understand that this is an anti-pattern in Go, but trying to make it happen is a good lesson to find out why. I kind of wish it wasn't. A goroutine feeding a channel has the semantics I want for things like iterators, but the expense is very often prohibitive because the continuation is probably doing something very simple for each item and I can't justify two context switches and a channel operation just to receive "the next int in the list" or something. Unrolling the continuation into a manual function call just makes me want to scream out _isn't this something the compiler is supposed to do_? Then again, about 5-10% of the reason I use Go professionally is precisely to ensure that I don't implement this sort of thing in my professional code, so... sigh.
Startup here. Products started in Node because "everyone knows JavaScript". Now replacing all the Node API's with Go. Even if we were to cluster Node and switch to Typescript; we still can't beat the simplicity and performance.
Just curious what parts in Java and go and why.
API. Startup. Software Engineer. Large peer to peer marketplace.
&gt; manually append a `-mod=vendor` If you want that all the time can't you set `GOFLAGS="-mod=vendor"`? 
Control plane of a distributed storage product. Startup. 
IoT in the transportation industry.
IoT data processing and communication. Company is rewriting their systems. Backend in Go. 
Not many - most of our stuff is home grown OR we write cgo bindings to existing C++ stuff. Python's library availability can't be matched though. 
Nice comeback with edit (y) : - )
research (particle physics, cosmology): data acquisition, control command, analysis pipelines/frameworks and plots.
When I was a kid who just started writing proper software I happened to pick up this strange new language that just released its first stable version in 2012. Then I built a career off it. Over the years I worked in nearly every sector and recently started at Keybase, which is honestly the most brilliant piece of Go I've ever seen. It runs an opensource Go codebase on all desktop platforms and both iOS and Android. And the whole thing is cryptographically verifiable!
Work for a company that does outsourcing. In case of Go it's automotive industry + a large media startup. Mostly performance-related use: optimize existing APIs, data processing, etc.
That should be fixed on IDE level I feel like. For the compiler it should be dead code, so it should also be presented as such.
You can build a self contained static binary and deploy it without dragging a ton of crap on target systems. Corrolaries: FROM scratch docker images &amp; cross compilation.
I do not agree. Updating the code still takes effort no matter how ‚Äúeasy‚Äù it is. 
Marketing / Digital Platform. Mostly REST API‚Äôs and other back end stuff.
While 100ms may be a lot more than 5ms, that still counts as a flaky test. If you want one thing to happen after another, you need a happens-before relationship.
I respect this. I don't why but I do. 
I work for a cloud storage company. We are writing a BitTorrent client at the moment. 
Major tech company, SRE, migrating old python spaghetti to go. Most of them CLI apps and back-end web services/APIs.
I word at a cloud CI/CD company wrangling docker containers with Go (our product is basically pipelines of Docker containers, so lots of lifecycle management). My side project is a tool for a flight sim I used to play quite a bit, and the API is written in Go (and the real-time collaboration aspect of that project is slowly being ported from a Redis based solution to a custom pub-sub solution written in Go). Before my current job, I used Go at a Fintech company to write audit and compliance tools.
Same here. In my case, I work for a remote company that mostly writes C# but it has one Go product (a similar situation as I was in a couple years ago) so I might be able to weasel into some Go work again without changing employers.
AWS-based cloud software at Panasonic, as a QA engineer. I write automated tests in Go, and most of our backend stack is written in Go.
Weather industry, data ingest and api services
I've been working on a _streaming_ library for Reading and Writing Multipart/MIME (but works for HTTP) if anyone is interested or wants to help out: https://github.com/Xeoncross/mimestream 
Network Monitoring. Doing web/API and some cache/database stuff.
It's a legacy proprietary game server (realtime sync component) that is not very easy to replace. Just a matter of time.
Thank you. I just realized after taking a break that the mocks don't have to import the interface. I don't know why they were. I removed that and put them in their own subpackage. Now I can leave things private and everything looks good. Overall the package as a whole is actually just an implementation of another interface at a higher level. &amp;#x200B; I know code coverage shouldn't matter, but every team I have been on has a manager somewhere that wants to see a dashboard with the coverage &gt; 85%. &amp;#x200B; Thanks again for the input.
It's a computer science or general programming question. It has nothing to do with Go specifically. https://brilliant.org/wiki/sorting-algorithms/
I‚Äôm writing specialist CRM code, mostly for large telcos. Several Go daemons on the server side, all talking to each other - and the C++ clients - via gRPC.
Cloud provider, writing backend services to implement features (such as networking and storage) and support infrastructure. It also runs our automated tests.
Accounting system that automates every penny going in and out. 
[removed]
Object construction is orthogonal to that of defensive programming. I draw my line at allowing code that panics into production. Downtime &amp; debugging is very costly for a business. A little extra programming is cheap in comparison.
I love me and you three
&gt;And I highly doubt that the http package is thread safe, even though it states that it is, because it contains no lock objects. Ohhhhh boy, you really do have a lot to learn, doncha?
You're focusing on a function's outputs, but defensive programming applies largely to a function's inputs. &gt; If you look at Go's stdlib You'll see they program defensively as well. Input parameters are checked as a first order of business in each function. &gt; if you're checking pointers against nil a lot, you're writing unnecessary code Code that prevents production outages is very necessary. Downtime leads to unhappy customers and engineers that have to drop everything to fix bugs.
Microservices for a University. We're mostly a Java shop for our server-side software, which replaced/is still working on replacing Mainframe systems, but we're experimenting with Go for new services as we move into Kubernetes and the Cloud because of the lower resource requirements compared to a JVM + AppServer, which theoretically means paying for fewer, or smaller, nodes. Also faster start ups. We're still pretty early in our process and no Go services have actually gone to prod yet. We've got one that's currently-feature-complete and could go live, but nothing would use it yet so we haven't deployed it.
It's okay if you don't understand the utility right away. Spend enough time using the language -- especially in writing a service used in production -- and it'll come to you.
&gt;I've been learning and experimenting with Go over the last 2 weeks... Please enlighten me genius. 
I don't personally tend to stray from SQLx and standard lib, BUT... Sometimes you find a team of devs that don't know any SQL. It's sad but true. Those people might like an ORM. This is usually what people disliking ORMs complain about. However, I think it's a little bit overblown as a complaint. Most people using ORMs probably can write SQL, they know the queries might wind up less efficient, and they choose the ORM anyway. Those people tend to have one of the following reasons: They might support multiple types of databases. It's a pain, and if you aren't selling a product to enterprises (think CRM, document management, etc) you probably don't want to be supporting Oracle and SQL Server at the same time, but at least with an ORM, you will get the correct syntax for both without thinking about the SQL grammar differences and maintaining two scripts. Or... there might be a migration package available for that ORM, and the person using it might use it to migrate databases to new versions. The generated code from that might reduce mistakes and give a productivity boost with each release. Yay! Or... there might be parts of the ORM query building that (if it used code generation) might provide you some type safety. That's a big deal when going between database and application, and sometimes an application sees most of it's bugs along that boundary. I've seen that in very simple applications with lots of endpoints and lots of handwritten queries. Or... someone might have faced the horrors of a method call they had to debug that gave way to a 4000 line stored procedure that did all sorts of things. Now they want all the logic in one language and one place for easier specification review. There are probably other good reasons that I can't think of off the top of my head, but the reasons for and against are usually overstated. I don't care much if someone loves an ORM even though I don't. My opinion is biased towards SQL because I was a reporting analyst before I was a developer, so I have a lot of confidence in my SQL experience. I'm fine working on either type of codebase though.
Do you provide your api to external clients or use the service only inside the company?
It's open source. Why don't you look instead of "highly doubt?"
Startup, working on tools for Kubernetes.
&gt;...because it contains no lock objects Gophers aren't the brightest programmers it seems, which I understand was a design goal of the language. Good job persuading a noob to stick with a language that you presumable recommend. 
Working at Western Digital. Part of our private cloud storage stack is made with Go, though our division is making efforts to move away from Go (and other languages) and onto Java, depressingly. 
"I'm trying to give you an honest answer that won't result in me telling you I need more money next year. When you consider these other options, try and make sure they as good track of a track record as me at not underestimating"
Defense industry. I'm using go for a combination of API services, websocket servers, and streaming data/data processing pipelines.
Seems like your user should be a part of whatever package is using it, rather than its own package.. Would that fit into your design? Also, I think it's a great instinct to be reading and trying out ideas, but if it's slowing you down/stopping you just bail on it and keep moving forward. Eventually your code will DEMAND to be more organized but by then you'll know so much more about the problem you're trying to solve that you'll be able to answer these type of questions much more easily. The best writing is rewriting, even with code. :) Good luck!
Do you know how to use grep? From $GOROOT: &gt; cd src/net/http &gt; grep -r Lock . | wc -l 271 Did you read the documentation? "Clients are safe for concurrent use by multiple goroutines." I don't recommend or not recommend the language. I recommend you not make assumptions and wild conjectures if you are honestly considering a new language.
&gt; You never know if those third party libs are going to panic Most third-party libs intended for use in production services do not panic, for the reason you mention. And you do know, because either it'll say so in the documentation, or you can scour the source code yourself. Projects that aren't well documented and unit tested just don't go into production.
&gt;he problem you're trying to solve that you'll be able to answer these type of questions much more easily. &gt; &gt;The best writing is rewriting, even with code. :) Thanks for your kind answer. I have my entire program actually coded using the Clean architecture guide lines. It really helped me out. But out of curiosity, I wanted to try to refactor some of the code to fit more the Go package philosophy. It's not that obvious. :p I'll try to figure things out. It's not so bad to have user.User now and then. 
A sorted list is far more efficient to search through, if that's what you require: https://en.wikipedia.org/wiki/Binary_search_algorithm A few more use cases from wiki: https://en.wikipedia.org/wiki/Sorted_array#Applications_of_sorted_arrays We use Dijkstra and priority queues quite a bit, those are handy cases of sorting. Sorting of numbers can also be useful for compressing them: https://en.wikipedia.org/wiki/Delta_encoding . Although sorting is not required, doing so decreases the "deltas" which makes your compression better. You can go broader than arrays/lists too. Hash maps and dictionaries apply as well for being "sorted". Just not always as conventional. I'm not sure if this is exactly what you were asking for, but perhaps it is :) 
Online real estate site, pull all listing data in the us+ from the 1k+ MLS/data providers. Custok network apis and data normalization
Cyber security / software engineer, 200 people but doubling (not quite startup, but still growing and small). My team's product is actually in C#, but the Go team has a key vault store that provides secrets to those who have the right to use those secrets. Previously I worked at a trucking company and most devs were right out of college, so when I moved a couple projects to Go, I was met with no resistance. :D Most of those were APIs that either manipulated SQL Server or Active Directory. Someone else might ported something to Go that monitored temperatures of refrigerated trucks. I can't recall for sure on that one. Company size 4k / mature company.
FWIW, I use zsh's autocompletion, which is git-aware (and can't just autocomplete to branches, but to all kinds of stuff). And there is a general menu-system for zsh-completions (though I don't use it, as I'm not a fan). I assume bash has the same. Just thought you might be interested :)
Thread is deleted, as is my GOROOT. Your response is hilarious though. 
The Go community tolerates criticism just fine, when that criticism is reasonable and thoughtful. I can't think of a single community that responds well to criticism that is insulting and ignorant. Go was designed by people at Google to solve Google's problems. The net/http package is used in dl.google.com [(source)](https://talks.golang.org/2013/oscon-dl.slide#36), Vitess (the core database of YouTube), and according to godoc.org, 171k other packages. If Google is using it, I'd guess it's probably thread safe. I mean I hate to use the appeal to authority here, but considering the Go team contains some of the smartest programmer I know of, who have decades of experience writing system software in concurrent languages, who's software is currently in production in one of (if not the) largest internet companies in the world, I find it very difficult to take your criticism seriously, locks or no locks. I think you should read up on the semantics of Communicating Sequential Processes, the concurrency model used by Go. It's obvious by your comment that you either don't understand it, or don't understand it as well as you think you do.
Agreed, user.go should be part of a lager package. This may be a bad example, but if you had a struct called "User" and another called "Password," then you might consider a package named "auth" with files "user.go" and "password.go" defining those struct types. Then, you would be using them like auth.User and auth.Password
Why delete it if my response is hilarious? My response is full of data that disproved a wild conjecture. What is hilarious, on the other hand, is when people make crazy assumptions that get disproven with 60 seconds of research and then fight the people that are telling then the truth.
Thread is deleted, as is my GOROOT. But thanks for a hilarious response. Yes, appeal to authority is a logical fallacy. LOL. 
B2b marketing, cloud data processing, API services, distributed workflows
- No immutability - Implicit interface implementation - No keyword like `this` or `self` - the receiver argument can have an arbitrary name, making code harder to read - Type embedding, especially interface embedding. Along with the implicit interface implementation this allows for some really hard to read code (aka _"We hate OOP and inheritance but we basically implemented most of it anyway"_). Luckily people don't do this too often. - The Billion Dollar Mistake - C interop and going around libc 
Working for a major world-wide IT company, developing RESTful APIs in Go inside Docker containers.
We should talk...
Yeah this is annoying. I wish there were a compiler flag 'Dev - ignore unused anything' For point 2, I create a func doNothing() {package.Dosomething()} When done with development just remove the function and it'll error with the unused packages again. I have no good workaround for point 1
For my understanding Go package philosophy tends to be more centric on domain/context rather than feature or layer approaches presents in other programming language. This aspect enforces our code to be more readable and more understandable. So stuttering is difficult to prevent sometimes, but if you can wrap it in a common domain or context. Auth or Identity can be a good alternative. 
Fish shell has several plugins that give it git awareness (with autocompletion) as well.
http forwarding proxy
1. Can't take pointers to primitives, &amp;MyStruct{} is ok but `&amp;3` isn't. 2. The fact that range returns a pointer one stack slot instead of a fresh copy every loop has been the source of at least 3 production issues on my team alone at $work. 3. Inconsistent behavior between nil value of maps, slices, and interfaces, e.g. `nil` maps will panic if you insert into them, slices don't when you `append`. `nil` is sort of typed with interfaces. In my opinion slices and maps should not be nilable at all, its possible make the zero values not allocate (rust and C++ do this). 4. I like the lengths that go goes to to prevent iterator invalidation in for loops but they can also can introduce surprising behavior that is verbose to correct. For example, https://play.golang.org/p/JaV2p6J7tbd I don't know if the alternatives are better though (rust style type system, or let iterators invalidate freely), some built in lints might be nice though. 
So as infosec/software engineer do you have other responsibilities besides go dev? 
I‚Äôve deleted it because I‚Äôve given up on Go. The language is ok, the standard packages are a bit shit, but the icing on the cake is that the community is filled with arseholes that regurgitate taking points they don‚Äôt understand when confronted with criticism. BTW, dl.google.com, as the name suggests, is read only, which is always thread safe. 
I know this, but my project has too many branches, and autocomplete will list a bunch, so I developed this tool.
Construction project calculation software. Developing distributed systems
I am not criticizing, but just pointing out this construct is named *dog sledding* https://www.reddit.com/r/golang/comments/9tffx0/dogsled_a_go_static_analysis_tool_to_find/ 
Automating things for ecomm
I was not making fun of your idea of using a keyboard macro, I was making fun of Go for the fact that a keyboard macro is useful in the first place.
I dont think you can. Its a project developed over years with extensive functionality, the more you estimate the more the error margins go out, the more you estimate on estimates the more the margins explode. There is also going to be alot of behind the scene requirements that are not obvious, infrastructure (create, maintain + scale), support integrations, analytics + marketing integration, handling logs in a scalable / distributed system so you can fix errors when they happen etc. Essentially theres 100's of projects in that one project, thats why its a business. It seems the client is pointing and going want with no idea of what it is exactly they are after or technical understanding to build a business that develops something like this. To put it in perspective by 2014 they had $18m of investement. Theres lots of info on their blog. So yeah, if you want to co-found a business with them and CTO it up sure, but requires them to have a strong idea, budget, minimal product with a plan how they will either turn revenue or get VC funding because thats what it will take to develop something like ghost platform, its not a static blob of code to be delivered. &amp;#x200B; &amp;#x200B; &amp;#x200B; &amp;#x200B;
I usually use gomock and mockgen, as they are included in the stdlib, and go generate to create my mockfiles, works pretty great.
Finance/insurance doing Devops/SRE tooling
Software Architect/Developer using go for SIP/VoIP. 
This is great, thanks. I think something minimalish like Echo is probably the best thing to learn, then I can go backwards to stdlib or forwards to batteries-included as my demands shift.
wow, I work in the same industry and I always wonder why don‚Äôt they use go instead of C/C++ and Erlang. Do you work for a Scandinavian country or else?
&gt; As an alternative to committing a vendor folder, you can always use a proxy too, which would also speed up clean builds. Proxies have a wider scope of failure than having your vendor committed. It's 
or the tool could keep working as it has been and you could support both methods on one system.
Long time ago I was writing c++ based soft switch and dreaming on something like Golang for this task.
What scale of the product? In TPS.
Queue/Worker systems, Microservices from RESTful APIs to Push Notification servers.
They may be referencing the ‚Äúold‚Äù sort mechanism which required implementing an interface and the ‚Äúnew‚Äù sort mechanism which doesn‚Äôt, but uses reflection, and is therefore less performing.
Or even better.. they use Java.. I work for a Slovakian company, but most of the clients we work for are from Silicon Valley.
Anything around systems and service monitoring with Prometheus, really. Consulting, training, and development, so only part of my freelance work is writing Go.
&gt; Projects that aren't well documented and unit tested just don't go into production. Can't the same argument be used against pervasive nil checks? A panic caused by a nil pointer exception is almost always caused by incorrect API usage. I think that packages SHOULD panic if they're being used incorrectly. If you start nil checking in every possible spot, where do you stop? Are you going to check every parameter? Every struct field? Every method reciever? As much as people complain, nil pointers aren't all that bad in Go. Your defered statements still run, you can recover from it, you get a stack trace. 
Yeah don't get me wrong, I'd certainly much prefer no BC breaks. I still don't see a strong need for a "Go 2" because of that, outside using it as a sort of marketing term or something.
Aye, and they aren't always an option - it's just a potential alternative. Another solution would actually just been to make some aliases for your go mod commands so they're easier to type.
Gamedev here too. All our backend services (login, lobby, dedicated server management, in game items, analytics, etc)
My work in Go is focused on improving privacy in distributed storage and communication systems, and I work for a startup. My role is mostly programming and within reason, my tasks are fairly self-directed. It's a pretty nice way to work in an interesting field.
Do you write server or client side code?
Blockchain at Waves. We are writing a node implementation in Go and various utilities.
Sounds like Smartfox.
Game development -- backend services. We build a set of microservices related to game functionality and deploy on Kubernetes.
*Wooo* It's your **6th Cakeday** campoy! ^(hug)
Full stack engineer. I don‚Äôt have a lot of oversight so I just use Go whenever I feel like it. :-)
Server side. I am assuming that by "client side" you mean a SIP client like a hardware phone or a soft phone. We are using existing hardware phones that are available on the market. 
Damn enviable. Gamedevs are up there. And you can (eventually) test your code by playing games. Good choice with the Java game server . When it provides the functionality you require, or that you envision for your users, in a performant way, postponing is a good option to get going. I hope that the project becomes an enormous success for you guys.
Very good question. I hope that you get many honest posts.
Transfers per second? It's not heavy on processes, but imagine you sold a product to a customer as a subscription. That money is ours (after tax etc), untill the buyer actually consumes their product. The more they consume, the more transactions. Every transaction must be spread out to our in-house parties as a who-gets-what amount. This means splitting up the transaction amount based on minute usage from the buyer. The other parts of our system is built using Node, but I'm planning on using Go more instead. This is very meta explanation, but if you have more questions I'll be happy to answer. 
Startup in agricultural tech. API for data collection and retrieval.
Why do they want to move into Java?
&gt;Thanks for your kind answer. I have my entire program actually coded using the Clean architecture guide lines. It really helped me out. But out of curiosity, I wanted to try to refactor some of the code to fit more the Go package philosophy. It's not that obvious. :p No problem, it's definitely not that obvious! Sounds like you're doing exactly what anyone does that figures this stuff out: hacks away at it. &gt; I'll try to figure things out. It's not so bad to have user.User now and then. Totally agreed, not too bad. Have fun!
SQL/Python learning platform. Some CLI tools and microservices are in go. &amp;#x200B;
I work at a startup writing a cloud-native management controller. Kinda' like a nodeless kubernetes. Go has brought a fantastic mix of pragmatism and productivity to our development.
...Which works only when turned on explicitly, significantly slows down the program and detects race condition only when it actually occures (so good luck reproducing conditions which led to the bug and do not forget that slowing the program can make then dissappear).
One more gamedev: All back end is Go, except game model ticking shared with client side and therefore C#, and live operations web site in Nodejs. 
A bank
Director of Computational Biology at a biotech startup. I use go for bioinformatics algorithms and glue for multi-language pipelines. We're looking for bioinformaticians at the moment.
[github.com/marcofranssen/gothermostat](https://github.com/marcofranssen/gothermostat) Plots thermostat data from your Nest in a React user interface. I run it on my Raspberry Pi at home. 
Gotta make money somehow..
Coding in TypeScript at a Danish software startup in the automotive industry. Did a microservice in Go for vehicle management, which works quite nicely. 
Infrastructure. Web services, kubernetes controllers, cli apps... pretty much everything.
I will be seriously upset if they ever deprecate GOPATH. It's very handy for quick stuff and when your projects are pure Go without dependencies (other than std lib).
Machine learning - fields ranges from NLP to time series prediction to image classification. Attention mechanisms are srsly OP. Pls nerf. 
[sagikazarmark](https://github.com/sagikazarmark) is one of my colleagues at [banzaicloud](https://github.com/banzaicloud). He is the author of many of the tools that make me possible to code in Go without a constant pain. One of these is [github.com/goph/emperror](https://github.com/goph/emperror), which provides the functions you always missed from pkg/errors. [github.com/goph/logur](https://github.com/goph/logur) is another, providing the tools you need to pass your favourite logger implementation to a library, without the need for the library to import anything, or you to either write glue code to adapt your logging framework to the interface, or use the framework the library author prefers. Both of these are worth a try. For actual usage example you can check one of Mark's other projects, [modern-go-application](https://github.com/sagikazarmark/modern-go-application): a good starting point for your new Go projects, which can also [act as a Spotguide](https://banzaicloud.com/blog/creating-a-custom-golang-spotguide/) making your life even easier. You can also find even more useful projects under [github.com/sagikazarmark](https://github.com/sagikazarmark) or [github.com/goph](https://github.com/goph).
Yes, mime/multipart does. My package is built on it actually. I meant the 3rd-party packages for MIME parsing (also often built on mime/multipart) which only support `[]byte` instead of `io.Reader`/`io.Writer`. https://godoc.org/mime/multipart isn't exactly plug-and-play for email processing or body creation. It is fairly straight forward for HTTP, as shown by the OP.
1 question and 1 comment. I understand it‚Äôs test code, but doesn‚Äôt your cancel handling leak a goroutine and all subsequent data? By returning without reading from the data channel, the goroutine will block indefinitely. On a production server, despite goroutines being super light, you‚Äôve still got all that downstream data that wi never be cleaned up. Or does GC somehow clear this up? As for the comment on context values, I agree in your notion about things like passing a trace ID. However, it can also be used rather nicely in a stack like GRPC to inform downstream services of specific behaviors. Eg, if you wanted to be able to test the entire stack without actually writing data, you could pass a ‚Äúnoop‚Äù as ‚Äú1‚Äù, then standardize on never writing if there‚Äôs a noop flag set. It makes it really nice to pass that value along down to services without having to add clutter to the call path. But generally, yes, it‚Äôs a bad idea to pass things like user data or request altering parameters down the call stack like that. 
&gt;I understand it‚Äôs test code, but doesn‚Äôt your cancel handling leak a goroutine and all subsequent data? By returning without reading from the data channel, the goroutine will block indefinitely. This is a fair point. I'll check this out, see if i can illustrate it in an update and fix it. Thanks for the feedback! 
Personal finance. We run a cluster of Ruby and Golang servers as part of a RMQ managed suite of microservices. The Go part is really for managing anything that needs fast low over-head networking for many connections.
Startup - API security - Go gRPC with mTls services all over with some REST gateways there and there.
Is this a thing?!
they use it for everything
Medical domain.[Analytics, Process automation, Controlling sensors for reading patients data] 
I tend to stick to raw SQL as well, but in the rails world, i would use the ORM for one reason, and that‚Äôs subqueries. Not SQL sub queries, but being able to modify them. For example, it let me build the base query I needed, then I could check a get parameter and easy change the ordering or limits/offsets. In raw SQL, that‚Äôs kinda shitty to do, although not impossible. I could also add joins optionally, depending on what I was doing. An ORM always breaks down when doing super complex data tho. We had one app, conveniently written in Rails ORM on a SaaS system (on prem), who‚Äôs ‚Äúreports‚Äù would take 10-20 minutes to run because they abused the ORM so badly. They disabled all timeouts, and suffered from major N+1 recursive problems. I brought in my SQL guy to direct connect to the database (Postgres), and we gathered identical data in 1 well written query, and it only took about 10 seconds to run. Big difference. So ORMs make some things easier on the programmer, but they are limited. 
This contract: Writing an IoT system with Go on the cloud (using Google Cloud Functions) with the gateway application also written in Go (technologies in use Bluetooth, MQTT, some web)/ Last contract: Video transcoders (Go wrapping FFMpeg) and video streamers (Go was demonstrably 100 times faster than NodeJS in the same type of implementation).
* Errors. Not the `if err != nil` bit, no, I don't mind that. It's the fact they don't come with any built-in contextual information. The fact that an error just has to satisfy `typer error interface { Error() string }` is just woefully inadequate. The good news is, the proposed changes coming in with Go2 will basically alleviate this pain point. I'm aware of the various half-abandoned projects out there that attempt to solve that. * I don't expect anything crazy powerful ala Rust or C++, but some kind of easy-to-use parametric polymorphism would be nice, even if it involves `go generate`. I'm aware there are 3rd-party packages out there, but it would be nice to just have a one blessed way. * Functions can return multiple values, but channels are single value only. I end up creating boring wrapper structs to encapsulate the "there could be a value or there could be an error" use-case all the time. 
Fintech start-up building an exchange, Go and Node microservice backend. 
Maybe I'm special/weird, but I rarely, very rarely, get bitten by nil access errors. Unlike C/C++, at least Go's "zero value" is actually useful for value types - like sync.Mutex. Strings are never nil, heck, I can even append elements to nil slices! Maybe it's the combination of "zero value", value types instead of pointers that has just reduced my nil pointer errors to a negligible amount. I'll go as far as to say that I've *never* had a nil pointer error in production code. I've caught all my nil pointer uses while writing tests. 
Startup in the Bitcoin space.
Hello üëãüèª my northern neighbor! You‚Äôre on the spot with Java. I have no clue why bother writing Telecom grade applications past 2015.
Even Powershell, if you have [PoSH-Git](https://github.com/dahlbyk/posh-git)
Api development? Like for what? Someone wanting to programmatically check zoning laws ?
Good to know :) If I ever decide to move to Canada :)
Nil checks, bounds checks, etc. make code safer, there's no arguing against them. Full stop. Yes, it is possible to use panic / recover as an error handling mechanism in a program, but that doesn't mean it should be used in that manner. By and large, a panic should be used to dump stack and kill your program. There are a few corner cases where one can panic / recover (json library has an example), but the recovery needs to be done in the same function as the panic. Using panic / recover as error handling breaks many assumptions about code flow, and thus, your program's state. Recovering from an unknown state is a dicey proposition, if it is even possible. All being said, panics don't work well in a production environment, since they cannot be integrated with monitoring, logging and/or metrics services. The stack goes to stderr and that's that. Here's a great blog post that might shine more light on the topic: https://eli.thegreenplace.net/2018/on-the-uses-and-misuses-of-panics-in-go/
Generally, I'd agree with you- even if I can look at a line of code that's math-heavy and know exactly what it is, someone else who needs to maintain or use it may not, and that someone may be me at some point in the future (including tomorrow :P). Unfortunately, there are areas where breaking things down further is not really an option, as they're either "atomic" in terms of being the most basic operation in the math, or for performance reasons. In this case, this is from a function that has to be called millions to tens of millions of times in the execution of the program. Here's the full function, with some annotations. This is computing the likelihood that a text document was generated by a topic distribution (the words in a set of text documents that have been assigned to the same topic). https://pastebin.com/T0efwpsh The gist- this is in a nested loop within a function that is typically called tens of millions to billions of times during model fitting. Due to numerical stability issues with many tiny probabilities being multiplied together, the loop has to be structured very carefully. Normally in these situations, the multiplication of probabilities would be turned into addition of log probabilities and exponentiated again at the end to get back to a probability. Unfortunately, since this function is called so many times (millions to billions of times) and requires multiple evaluations of logs for every instance of every word, doing the calculations in log space ends up increasing the run time by ~100 times- when profiled, the evaluation of the logs takes ~99% of the total time. This is a special case indeed, and in *most* applications you're absolutely right. Numerical computing unfortunately is full of special cases in demanding applications though. I'm actually considering writing this portion in C and taking advantage of [fastapprox](https://code.google.com/archive/p/fastapprox/) to speed this up, but I have a truly exceptional application and dataset. 
This makes me wish the actual game development could be done in Go. Like if there was a Go -&gt; C# compiler for Godot or Unity.
It's not so much the billion dollar mistake because of production crashes (though those, while rare, are significant) - it's more just a waste of programmer time and attention to check for nil everywhere. Fundamentally returning nil is often either a breach of a function's contract, or a subtle, often undocumented condition. Haskell contains a really good example of how this guesswork is unnecessary. If a function's return type is String then it _will_ return a string, not nil, not anything else. If its return type is "Maybe String" then it will return either a string or nothing, and the "Maybe" type provides helpers to make checking that easy, while explicitly documenting the possibility of returning nothing. The equivalent of GoLang's error handling would be returning "Either Error String" to say you'll return one or the other.
What did you switch into from aerospace? I'm a mech Eng at a space company and considering switching to patent law or software engr so I can move back to the east coast. A surgeon probably has better hours and work life balance than a senior engr at FAANG. Some of the reasons they get paid so much is because they are skilled but also live in high cost of living areas and work long hours.
I‚Äôm the editor of the peer reviewed journal resignation letters quarterly. Would you be interested in becoming a contributor?
FAANG SWE
This example also uses an unbounded ioutil.ReadAll for client controlled data too, like the answers on stackoverflow Why? Is this such a small issue? The fix is so easy too, just wrap the reader in a LimitReader and pass that to ReadAll
The same way you send any file over http, except you will need to specify the right [MIME type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types)
Goroutines and channels. The concurrency model is what really got me digging into go. Being able to use all my processors that easily was a welcome change from basic threads. It felt like grand central dispatch but for every OS. Cgo was another. At the time, I needed to use a windows DLL. It let me build it without needing to get a big windows development environment running. I could cross build and run. It was also super simple. I didn‚Äôt need to relearn everything to start coding. It‚Äôs not compact to the point of being incomprehensible to the new convert to the language. 
For me writing good model types is getting old. My team is considering sqlboiler mainly for that reason. It does get old to write, test, and mock every SQL statement after a while if you have a lot of them. Sqlboiler is not a replacement for writing SQL, it just reduces the amount of glue code you need.
Adtech. Rebuilding an entire bidding platform for real-time bidding mainly in Go, but also incorporating Scala for Spark ETL workflows.
I was not suggesting that panic/recover should be used for error handling. 
It's that legend writing `snapd`! Hello awesome human! Oh, now that I think about it, is there a way to make snaps work in a LXD machine without installing LXD itself as a snap?
If snaps only work on LXD when it's a snap, that's probably a bug (or a missing additional package to get squash+fuse to play nice?). Hop on [the forum](https://forum.snapcraft.io) and ask there, I'd say.
 Business to business, integrating old point of sales using shitty databases with our online ordering system. Startup. I started the middleware but went on more urgent projects and now I'm doing Flutter full-time. 
Red Teamer, I use it to write malware/backdoors.
Awesome!
[removed]
Blockchain. I write smart contracts, sdks, and services.
Depends if it‚Äôs data []byte that you want to send or just some files from the filesystem. Net/http has a fileserver handler for this. https://golang.org/pkg/net/http/#FileServer Otherwise it‚Äôs pretty much set the content-Type correctly and vomit the data into the writer. I saw another reply that had a link to something with more details. 
\`http.ServeFile(w, r, "picture.png")\`
By personal project, do you mean any which you're not getting paid for? Just do it however you want: dive into the coding. If you want to do it all formally with charts and diagrams, go ahead, but I get the most enjoyment out of just thinking about it, talking myself through the high level approach while pacing around, then sitting down and writing \`func main()\`.
Your quote: &gt; I think that packages SHOULD panic if they're being used incorrectly I don't know how else to parse this. I'm just going to panic on this entire thread. Going nowhere. Peace.
What is the name of the startup? 
...carefully
Maybe workforce availability, standard industry knowledge? 
Not a huge fan of Haskell, but I believe Rust borrowed that idea elegantly with Option&lt;T&gt;, where either it's Some&lt;T&gt; or None. That wouldn't really be possible with Go since you'd need super-special syntax magic, or ...well - generics?
APIs and devops
and then spend 3 days refactoring because you want it to be cleaner, realize you were better off before...
I've done several with different variations 1. postgres + gorm + gorm-migrations: small scale project with simple schema, quite stable 2. postgres + database/sql + customized orm (closed source) + golang-migrate/migrate: large scale project serving 20M+ requests per day, stable but customized orm can be messy to maintain 3. postgres + database/sql + no orm (raw sqls) + no/manual migrations: project with very high query/s requirement so it's optimized down to bone, hard to write sql statements but /shrug 4. mysql + gorm + no/manual migrations: small scale project but was frustrated with gorm's lack of batch inserts and other important features 5. postgres + go-pg + pg-migrations: new project, looks stable on start, will update on further development 6. [future] postgres + gocraft/dbr (or sqlx) + go-migrate/migrate: might be the next alternative combination to try for a new project or improving on a previous one
Working in a fintech startup. I‚Äôm using Go for AWS and sysadmin stuff.
Working as a Sysadmin in a startup. Managing pfsense, vpn's, VMs, virtual servers on digitalocean, gitlab, mail server, troubleshooting a.k.a shit management. Recently I installed a pretty neat Elasticsearch cluster so we can use it alongside our existing products. My job depends a lot on other people's code and the opensource community which I am forever grateful.
Alright then ...
Healthcare Research IT, using go to write a streaming clinical note NLP pipeline.
Ah, so you didn‚Äôt get the memo. Ok. He means TPS reports per second. How many? ü•≥
GET OUT OF MY HEAD! But yes. For a personal project, sometimes this is the fun of it. Learning to implement something enjoyable, then doing it a different way. Built that with HTTP/REST? Try replacing it with gRPC. Used MySQL / PostGRE? Try with Cassandra and Neo4j. I typically just dive in. I don‚Äôt have to think about O(n) speed, although I always try to write with the best speed, it‚Äôs often not worth wasting my time optimizing. 
I love Keybase. I remember signing up a few years ago when it was very simple. I logged in a weeks ago and was shocked at how far it's progressed.
That must be pretty interesting; I've often thought that Go would be an ideal candidate for that kind of use. Without going in to too many details (I'm guessing it's quite confidential) - do you see many pitfalls?
As a contractor I worked on a few of Go projects, mainly: - CANbus logging for a prototype device (prototype was built on a Raspberry Pi) - Real time news analytics and deduplication via microseconds - Digital signage logging and monitoring - Little utility microservices for DevOps tasks (basically gluing stuff together) I've just started a permanent role because of the tech stack and industry, and it's split Java and Go - with all new development in Go. It's finance based.
Surprisingly not much, it‚Äôs cross platform so I can target multiple OSes, but the real power of go is being able to compile to raw C code, so when I‚Äôm lazy and don‚Äôt feel like freeing buffers or anything of the sort I can compile a c stub in go and import it in a c program. An easy example would be these password filters I wrote (https://dijigit.com/iDigitalFlame/PasswordFilter), they send any changed passwords to me over tcp lol
I deploy systems to client sites that run some software from Docker containers. The users interact with a client application running on these same systems but they don‚Äôt ever interact with Docker directly. Instead, I have a small Gin API on each box that acts as the backend for a management utility (built with Electron) that provides the user with a friendly interface for status, updates, power on/power off, basic reconfiguration, and troubleshooting.
[removed]
Are you using golang for the implants or c2? If implants how do you like it compared to c. I know fireeye and a few others made some public posts about using go in their engagements but I haven't seen much else 
Both! For C2 I have written some servers and clients. The Golang http server is pretty nice for this too. For implants it‚Äôs pretty awesome, easy to cross compile and I don‚Äôt have to worry about freeing buffers (or more complex memory management). I think the best part is being able to call windows dlls natively and CGO allows for some cool stuff, such as generating c stubs and using that mixed in with some C code you might have lying around. It‚Äôs honestly a godsend lmao.
I‚Äôm currently in the same boat and what I‚Äôve done is wrote a couple of libraries that would be better off being independent from my main program. Currently writing tests for one and the other library actually depends on the first one, so it‚Äôll be a great way to find out how well I‚Äôve separated my project. tl;dr high level pseudo code, rough data flow diagrams, then implementation. 
permissioned blockchain for capital markets
Wait how do you call windows dlls natively? With cgo? 
https://github.com/golang/go/wiki/WindowsDLLs
Kind of startupy small company. E-commerce user analytics data, ingesting massive amounts of data representing actions performed by shoppers on the web pages.
Long time ago I was using go programs to drive FreeSwitch to make and receive calls.
JFDI. But seriously, for me, I do side projects because I want to explore some unknown things or wild architectures that I am not comfortable introducing during day job.
Oh you just made my day :) 
They‚Äôre not adding exceptions they‚Äôre just collecting stack traces when you use errorf or the new error wrapping functions. 
Game dev as well. Our current project only uses it to manage a number of different streams of data, like server logs and performance metrics. Past projects involved an integration with Twitch, that included a stateless http API for a web application that integrated with our game, as well as stateful bots that were spun up per Twitch stream to connect to Twitch chat, and to poll the Twitch APIs for follower/subscriber data (this was a couple of Twitch API revisions ago, hopefully they have better ways of getting this information).
Nice. We're using go and freeswitch to drive hundreds of calls. Do you still do SIP/VoIP?
Haha no problem, good to know there‚Äôs other people out there that get a kick out of windows internals. NtCreateThreadEx Bois!
Yes. https://talks.golang.org/2017/state-of-go.slide#43
&gt; talking myself through the high level approach _while pacing around_ So accurate! :)
I"m now interested in that bug and how it held up purchases for a week
I work at a cybersecurity company as a software engineer. The company is past its startup days, but I personally wouldn't call us "mature" yet. We're getting there though. We use Go extensively across our entire backend. HTTP &amp; gRPC services, databases (both Go based ones and other ones like elasticsearch and SQL), parts of our machine learning pipeline, even an in-house job scheduler we wrote in Go. I'd say 98% of new services/development is done using Go. We still have a chunk of legacy code in a language that shall not be named, but we're slowly trying to kill all of that and move it to Go. We don't have any of our current devops stuff in Go, but it's not an unreasonable ask depending on what you're trying to do. We do have a bunch of CLIs written in Go as well. I don't think I've personally used a language that makes writing a CLI easier. Python perhaps, but I hate duck typing and can't stand writing Python.
I was a software engineer working in aerospace so my domain hasn‚Äôt changed. I left because aerospace is slow and behind the times. Leaving aerospace for a start up was the smartest thing I did to advance my career. I learned more at a startup than years in aerospace. Cost of living is definitely a huge factor. FAANG jobs aren‚Äôt all created equal. Checkout teamblind.com for WLB questions. Depending on company/team/role you may find good work life balance.
ecommerce startup (all of our things from internal tools to core part written in go)
How are you handling instrumentation and deployment process?
Seppuku
What is wlb? Yea I interned in aerospace and while I enjoyed it I had some hesitations returning but nothing else in mechanical seemed interesting. Needless to say I‚Äôm lookin for a brighter future. As a mech engr I feel like switching to patent law may be easier than learning all the ins and outs of a software degree. Tbh I personally wish I was compsci in school because mechanical engr in general just feels old and behind. 
Thank you very much!
Thank you very much!
Thank you very much!
Kudos for owning that. Out of curiosity, did this change the way your team processes reviews or testing? Being a highly publicized bug I‚Äôm guessing there may of been some additional pressure.
May I ask if you are working for a bank or a hedge fund? Also how prevalent is go in front office applications? 
Well. The bug isnt what held it up, me not noticing it held it up :P ive since started checking logs daily.
I can‚Äôt find the right solution until I‚Äôve written the wrong one. So I always plan for a prototype. Don‚Äôt add an abstraction until there are 3 uses for it. Play with existing solutions and steal everything you can. All successful complex systems start as simple ones. 
I like this idea.
Yes, a -dev cmd line option would be great.
Most of our APIs are private and are used by our front-end services to process vehicle and land deed data. This includes tax processing, fee and fine generation, vehicle data validation, plate orders, etc.
First off, your Go.mod file for project1 is missing a requirement on the utils import path. Second, you can use a "replace" directive in your project1 go.mod to point it at your local filesystem location of the utils module instead of it trying to pull it from the internet. 
Cookies should never be considered secure. Ever. We‚Äôve seen padding oracle attacks and others against people that try to store data in cookies. Cookies are not storage. They‚Äôre an identifier that the client sends back on every request. It sounds convenient to pack your session data and offload that to the client, but it‚Äôs fraught with problems. Hell, look at plenty of blog posts and videos that say ‚ÄúDO NOT use JWT for client sessions‚Äù. Bad news all around. It‚Äôs also next to impossible to invalidate a cookie if you aren‚Äôt storing session data locally. Instead, the best option is store a session ID in there and keep the session data elsewhere, like redis. What you‚Äôre probably trying to do is use cookies for session storage. It‚Äôs not the cookie that needs to be secured, but the session data because you‚Äôre handing that off to the user. Golang isn‚Äôt going to hold your hand and make the entire stack into a giant set of libraries. If you want all of that, you can use something like buffalo that includes things like gorilla mux and others. 
https://github.com/golang/go/wiki/Modules#when-should-i-use-the-replace-directive
Working at Google, we're building Healthcare APIs for Google Cloud Platform to help in areas such as Genomics, EHR, X-Ray/MRI Imaging. We also Open Source a lot of it.
Visual Effects Industry (feature film) We are one of the big, award winning studios (Middle Earth). Using Go for a number of api services, concurrent distributed services, and tools that would have previously been written in Python. 
Open file, delete declaration and try to recompile?
I work for a large bank so there are tons of dev teams that write in various languages so we have alot of variety but alot of our backend APIs are being converted to Go. We went down the Go road for a few reasons: easy readability which comes in handy in large dev groups, compiling to a single executable and ootb scalability features, among other things. 
Most languages are working on packing in new features. Strangely, almost every language feature you see today that‚Äôs ‚Äúnew‚Äù is something from the 70s that languages have shed in the early days because how hard it was to make work together. You may consider a language where you can see your work, instead of something like go where you get a terminal or web page output. They can work, but it‚Äôs a bit of a challenge. Generally, I recommend people learn Swift. There‚Äôs a free app on the iPad App Store called swift playgrounds that‚Äôs a great primer to programming. It‚Äôs sorta aimed at kids but you get the fundamentals down pretty easily. Would take a day or two to get going at most. After that, you can drop into Xcode, or open VS Code and do Golang. Go would certainly be a lot less of a brick wall than trying to learn java or similar. And the callback hell you get into with JavaScript. Yikes. 
Absolutelly no!!
If you have an iPhone, and you're decently confident your next phone will also come from apple, and you already have a MacBook or iMac at home, then I wholly concur that Swift would be an excellent first step (and one with great career prospects as well, should someone be inclined to stick with it). But it is still--IBM's efforts notwithstanding--very tightly associated with the Apple ecosystem, so I don't think I would recommend it as a starting place for someone who wasn't already hip deep in Apple products.
I'll start with a warning: many people--especially those new to programming--are motivated by seeing something graphical, but support for creating games or graphical user applications is sub par in Go compared to many other languages. That's the end of the bad news though. If working on programming puzzles, web servers, databases, etc. sounds like fun to you (it sounds like fun to me) Go is an excellent place to start.
I use simply `git checkout $(git branch | fzf)` (with bash alias of course) to cover the case for prompt and convenient branch switching.
Working for a media group with a software division. Initially we built a site generator - some sites in production. Generates a back office written in vuejs with a go grpc backend. Now we are working on a CMS for our different websites and external customers (√† la web agency). 
I mention it because many people have iPads and it‚Äôs probably the best tutorial for beginners. If one is planning to get a job programming, it‚Äôs in ones best interest to get a Mac, as so much programming today is done for mobile, which can only be done well from an Apple device because that‚Äôs where Xcode lives. Otherwise VS Code for everything else. 
Internal tools engineer for a very large hardware/software company. Mainly working on command line tools, web services, and supporting bots for things like automating builds and integration, reporting, dashboards, and other random stuff people (Software engineers, PMs, QA, etc.) need. 
Fintech and ethereum blockchain. Writing cloud services and ethereum native dapps.
I start by isolating the core functionality, and then produce a prototype as small as possible. If the project is going to have tricky parts, like portability requirements, or CGO, or dependencies that I don't fully understand, I spend some days experimenting with these parts. Once done, I create a second project that incorporates all of this. I start caring about testability, CI and CD early when it makes sense.
I'd say No. Its a simple language, which makes it easy to learn, but the problem with simple languages is that they inevitably force complexity into your programs. Which means you need to write more, very often crazy looking, code to get something useful out of it. Your focus while learning should be to produce something cool and useful, if only to yourself. Javascript is the way to Go (pun intended). JS is a simple language on the surface, with a whole massive mess of fucked up behavior underneath; that sounds bad, and it is from an academic standpoint, but from a learning standpoint is means you're more or less eased into the fuckedupness. And you can use JS for EVERYTHING. I'm not exaggerating. Once you know JS, you can branch from there. If you want to learn to make websites, start beefing up on HTML and CSS, then dip into React. If the lack of types in JS start to annoy you, check out Typescript, which is a superset of JS so its very easy to learn for someone who knows JS. If you want to do backend or write a command line app, check out Node. If you want to do mobile, you can learn React Native. Its all JS. JS was written from scratch in 10 days by some dude, and it now powers the entire planet. There is no other language more useful for a developer to know. Every single developer should know it, if only to not repeat its mistakes. Breadth is significantly better than Depth when it comes to beginner learning. JS is beautiful because you can branch out and try a lot of different things and see what you like. If you take a liking to backend development, Go would be a great second or third language. Java is also a strong pick if you take a liking to strong type systems. I'd also suggest Ruby; it gets some hate, but I still believe there are few languages more productive than Ruby. 
Maybe start by choosing a project instead of a language. Motivation is usually tied to producing something you care about. And the language is just a mean for that. Go may or may not be the right language depending on the project. These considerations apart, I think it's OK to start with Go. The language and the tools are small, you won't experience difficulties setting up complex IDE and dev environment. You will also learn about types from the start, and that will structure your programmer mind well.
You're pretty close. But I'd advise you to make use of variable scoping to help keep your code sane. You can re-use the `logger` name within the `uniqueVals()` function without affecting the var defined outside the function as long as you use the := operator (and not the = operator), which you are already doing. logger := logger.WithFields(log.Fields{ "foo": "init1", "mitzvah": "hurray", }) This makes use of your package level logger config within a more limited scope while also allowing you to override values at the function level. And it keeps the code clean and explicit. `WithFields()` gives you a new Entry object without modifying the original. This doesn't really do anything on it's own unless you call one of it's logging methods (Info, Error, etc), so you'll have to assign it to something if you want to reuse it. I really appreciate this aspect of logrus. But I'm a "Mutation = bugs" kinda dev.
Rancher Labs, working mainly on kubernetes installer development Rancher Kubernetes Engine (RKE) 
It also elides error checking, it's not meant to be robust client code.
Does Canonical hire from the US, or is it strictly UK?
It's definitely Ruby for starter, you get to understand the concept and easier to work with Javascript, then you could consider modern languages like Crystal, Go, Swift. However, l recommend you read up the job descriptions in your local job search before you plan.
Online Gaming(Gambling) and just to add, I was not hired into a Go position. I am a software architect who self-learned Go, got a few others started on it, and introduced it into our production. We have a couple of high performance and critical customer facing services currently. Since my company is an amalgamation of several companies acquired over time, we have a mixed back end written in Java, C# and Python. My company recently acquired another company in the field whose entire back end is in written in Go with NATS as a center piece.
I think you will find most agree go isn‚Äôt a good place to start, it is statically typed language, which while have its advantages, makes it difficult for beginners who will have trouble understanding types. Also the extensive error checking is good for production apps but can hinder your learning My advice for this kind of question is usually this, you will learn more than one language eventually, but just the starting one is what is going to be difficult, the rest are much easier, but you can start with one of three 1) if you are interested in web development or apps, start with HTML, CSS and JavaScript 2) if you are interested in data science, web scraping, or just learning something that is easy and sane, with a simple syntax, try Python. Many find python is a great place to start getting your feet wet regardless of where you start. 3) if you are really interested in games, or learning computer science, and how zeros and ones become websites and games. Start with C and then jump to C++ 
Developer tools :) https://sourcegraph.com
&gt; HaGotEm(NULL, 0, NULL, 0, NULL);
Use https://golang.org/pkg/database/sql/#Tx.Query 
You want to use tx.Query instead of database.Query.
Goddammit I even suggested this as a solution: I couldn't find this earlier but obviously I didn't search well enough. &amp;#x200B; Much appreciated. 
WLB=Work Life Balance Since you already have an engineering background, a graduate degree in Computer Science probably won't be that difficult. The hardest thing is practicing to write code, but that's also the fun part. You can never be too good of a programmer. Also consider specialized tracks; there are graduate programs in straight computer science, but also software engineering, machine learning, and security (to just name a few). Don't give up on the dream!
IMHO I self tough myself programming, I would highly recommend learning new language with Data Structures and Algorithm in mind for example, if you like Ruby as an example you might like this https://github.com/kumar91gopi/Algorithms-and-Data-Structures-in-Ruby/blob/master/README.md Learning syntax of any programming language is normal given for any developer but learning fundamentals (Data Structure and Algos) it will be a lot easier to learn different languages. Happy coding 
It looks like you‚Äôre using an external tool (stringer). This error commonly occurs when tools don‚Äôt correctly support build tags, in this case I‚Äôd say specifically per-architecture flags. TL;DR Stringer is not respecting build tags.
&gt;I draw my line at allowing code that panics into production. Downtime &amp; debugging is very costly for a business. A little extra programming is cheap in comparison. &amp;#x200B; So do you always check if a map inside a struct is nil before calling methods on that struct? You know this can panic right?
We use Alpine images in our microservices system too - just because we don't need the whole jungle that comes with other distro images but never because of it's size. Can you vaguely describe the business need for that optimization, please? Thanks for the gccgo bench results, it is interesting to investigate further.
Because they need to be used to index into arrays and as iteration limits, so if I did that I'd be having to convert floats to ints and I wouldn't gain anything. There are also times where having exact integers is necessary for the calculation, particularly when dealing with discrete distributions. I can also often get away with using uint8 or uint16 instead of a 32 or 64 bit int for counts, and that saves a lot of time and memory. They're being added and subtracted from totals millions of times, and if I used a float I start running into issues with precision.
As Xeoncross stated, one of the main arguments being proposed is workforce availability. Our current product was made as a startup before being acquired a couple of years back. Back then, people just picked what language or technology they liked. This has resulted in a smorgasboard of technologies being used. A key component was written in OCaml, for example. Management decided this had to change, and decided to standardize on Java. 
I sure regret how many ports our machines can talk on.
Network stuff for telcos. Last thing was snmp probe that gets line quality data for dslams for whole country and writes that to sql db and kafka for further processing. It was code rewrite from perl and it used to be done on 12 servers, now its just one and not fully loaded one.
Occasional DevOps stuff. We use kubernetes. Not big fan of the language, feels very clunky to use. But it's good enough for automation scripts / cli tools where code elegance isn't a requirement as much. I'm full stack, work in fintech. But even if we could easily switch out entire code base to Go we wouldn't do it. While simplicity of Go is point where many evangelists of the language are trying to sell it, for serious applications, Go REQUIRES microservice architecture as the language on it's own has no mechanisms to fail gracefully. I guess I can only compare this to Javascript how people proslatize. Yeah it's easy to start. But when you have to build something serious, you discover all the mess with the build tools and infrastructure required for making some significant.
I am using [https://github.com/meehow/securebytes](https://github.com/meehow/securebytes) to store a simple struct, encrypted with authenticated encryption (AES-GCM) containing the user id, role and an expiration date. &amp;#x200B;
Well, probably yes. Learning to program today is more difficult than it was 30 years ago. Strange but true because your expectations are so much higher. 30 years ago you learned programming in BASIC on a Sharp pocket calculator with display of 2x32 ASCII characters. You where proud if you did your own car racing game (even if your car drove backwards). Sound was limited to a beep. Today most people expect to produce something much more fancy. New beginner programming languages like https://scratch.mit.edu/ accommodate for these expectations. If you really have now idea about programming you could try this first to get familiar with the basic concepts of imperative languages like loops, conditions and variables. JavaScript is also one of the languages advertised for beginners, again because it allows you to to quite impressive stuff without a lot of hassle. Unfortunately these languages abstract away a lot of what is actually going on inside. A (admittedly bad) metaphor might illustrate this: If you want to learn driving you can learn to drive a gear shift car or you can hire a chauffeur, sit next to him, have him explain what he does and you can enjoy the ride along the the mountain road. Both will learn you something about driving. The first is painful and boring to learn, the second pure joy. My recommendation would be to start with something truly made for educational purpose (like scratch) and switch to Go afterwards. A lot of other languages (Python, ruby, JavaScript, C++) have too much magic and options and will distract you. 
How would you rather?
Recommend reading his slides. Tldr use lots of tricks to reduce ws ram overhead for 1 million connections from 20gb to 600mb. Pretty dang cool
Omnicar 
No, haven‚Äôt touched it in a while, but still have an ‚Äúeventsocket‚Äù package on GitHub - the protocol used to talk to fs.
We are providing API for the external clients, but via larger API gateways and our Go service is only a part of the full response from this gateway.
I work at Cabify, an Uber-like ride hailing app. Almost all the backend related to the core functionality, the real-time aspect of serving trips, is written in Go.
For older services, we are still using rancher 1.6, deploying via GitlabCI with [crane tool](https://github.com/kiwicom/crane). Also, we are using Sentry and Datadog for monitoring and error/panic reporting. We've started with `go-kit` for implementing microservice. It works great, but has some caveats: * Interfaces in requests/responses causes a lot of boilerplate code at every layer because of type assertion. * It supports gRPC, but only unary calls and streaming can't fit into the concept of `go-kit`. 
I know Go is a wonderful language and I personally like many of its features. However, out of curiosity, I'd like to know what is that prominent thing that attracts developers to Go!
And voila you have learned something 2 times already :) It is very true what you say but it can even be fun from time to time.
This is probably a very personal thing. If it's just a side project you have total freedom on how to tackle the problem. I usually make sketches and notes only if I'm still very unsure about what I want to achieve.
[removed]
&gt; assuming that by "client side" you mean a SIP client like a hardware phone or a soft phone I meant libraries for creating client process for working with SIP. But yes, also softphones too. Could you tell you use Go as Core part of SIP handling server or as around stuff, like helper for parsing sip headers and so on? I work in department where my colleagues write SIP server only in C++ and a little in C because this is all about low latency and number shredder
It's distributed (perhaps one of the first distributed). We've got people working from home all over the place.
Conversations about this are ongoing. Our processes as they stand should have caught it. I don't think adding more process would fix this, but we'll see. When this bug was pointed out everybody up the chain up to sabdfl looked at what and how it happened, and there's no obvious hole, no glaring "don't do things this way" gap. But we'll be talking about it more next week at a sprint (that is a week-long crash-a-hotel meeting in canonical-speak). At least for me personally it's more a reminder about getting more sleep and taking more vacation. The publicity hasn't really affected me, nor I think the rest of the snapd core team. Mostly we blame the guy that said "hey we've had so few CVEs! We're awesome!" the day before this landed.
Link for the lazy: https://speakerdeck.com/eranyanay/going-infinite-handling-1m-websockets-connections-in-go
If you don't mind providing details -- what sort of systems? CLI for internal tools or inter-day / intra-day PnL calculations? Also, one of the bigger banks or a startup?
My company use go-sql-driver/mysql and there are no problem caused by the driver. &amp;#x200B; One important configuration people didn't use is [DB.SetConnMaxLifetime](https://golang.org/pkg/database/sql/#DB.SetConnMaxLifetime). You need to configure it short enough, e.g. \`time.Minute\`. Otherwise, many things (e.g. \`wait\_timeout\`, router, OS, docker, etc...) kills connection silently. &amp;#x200B; Of course, SetMaxConns() and SetMaxIdleConns() are also important. My recommended configuration is written in this blog article. [http://techblog.en.klab-blogs.com/archives/31093990.html](http://techblog.en.klab-blogs.com/archives/31093990.html)
PSA: The use of backticks to format code only works in the new Reddit UI. Prefixing the text with four white spaces formats the code in both the old and new Reddit UI. This is how your post looks like in the old design: https://i.imgur.com/YFdhyuO.png Alternatively, you can link to the source code: https://github.com/golang/go/blob/7cf31d8/src/sort/sort.go#L239-L253
&gt;One important configuration people didn't use is DB.SetConnMaxLifetime This really seems hacky to me, surely the point of a pooled connection manager is to deal with invalid connections like that? If there's a write error on the socket, try the next one? I just don't understand their reasoning on that front. However, I stumbled upon that massive write up on the changes a while back and had already implemented that check. It's ten seconds. This component is *very* busy and ten seconds is a lifetime to it. Maybe that's too short? &gt;Of course, SetMaxConns() and SetMaxIdleConns() are also important. This I haven't done, I'll give that a crack and read the blog article, thanks for that
&gt; PSA: The use of backticks to format code only works in the new Reddit UI. Prefixing the text with four white spaces formats the code in both the old and new Reddit UI. It's a pretty obnoxious way to format code though, wish they'd either back-port the formatter or retire the old UI.
It‚Äôs returning a concrete struct with an embedded other struct. The struct, in this case ‚Äúreverse‚Äù, doesn‚Äôt implement a function, it falls through to the underlying, embedded struct. Therefor, by embedding your actual class inside ‚Äúreverse‚Äù, it only needs to override one method, and intercept the parameters and swap them, effectively changing the direction it sorts. So when you call sort.Reverse(...), it embeds the struct into ‚Äúreverse‚Äù. As part of the sort algorithm, it needs to call those methods. So to reverse sort, just change the comparators. Done. 
The question was about why `Reverse()` returns a pointer to `reverse` instead of returning the value directly, I believe.
Thank you for pointing this out, I actually noticed it was weird on my phone and changed it to use the non markdown editor hopefully it fixed it
Well interfaces can be pointers or values. Always use pointers if you want it working on the object and not a copy of it. In short, reads to values, writes to pointers. 
Sure, I'm not certain whether it's required here though - since the embedded interface must already implement `Sort`, you would expect its sort methods to use pointer receivers already if required, so I'm not sure that the pointer return here provides any value, unless there's a scenario I'm not thinking of.
Speed. If it‚Äôs a value, it‚Äôs potentially making a copy when it‚Äôs passed around. As a pointer, it doesn‚Äôt need to create a copy on passing it around. Since it‚Äôs functionally the same, it would just be safer to use a pointer. I almost always use a pointer, but there are cases where a value is better. 
&gt;Or does GC somehow clear this up? Hello again! Just trying to understand this. To clarify, you're referring to here correct? [https://github.com/quii/learn-go-with-tests/blob/master/context/v3/testdoubles.go#L26](https://github.com/quii/learn-go-with-tests/blob/master/context/v3/testdoubles.go#L26) I think because I am writing to a buffered channel it wont leak, it will eventually write to the channel and the goroutine will end. &amp;#x200B; I admit it's not \_great\_ as the work still happens which is not the intent, so I think i'll update the example to make the cancellation a bit clearer by making the code run some kind of loop to illustrate it being stopped. &amp;#x200B; &amp;#x200B; &amp;#x200B;
It's refreshing to see memory treated as a premium. And here we are using 1.5TB of Spark cluster memory to filter/sort/aggregate millions of records. :)
Thank you for the reply, I think this made it a little clearer for me but I'm still a little confused as to why it returns a pointer and not just the reverse struct itself. ``` func Reverse(data Interface) Interface { return &amp;reverse{data} } ``` Doesn't that essentially initialize a new reverse struct as a composite literal and return the pointer to it? The return type is Interface I assume because by embedding a struct of type interface into the reverse struct, it 'inherits' all of the methods required to implement type Interface?
Is this not too verbose, I need `yottadb.NOTTP`, `&amp;errstr`, `"^users"`, `[]string{"1", "message"}` to set and retrieve a message. Am sure this can e simplified using context or namespace. 
They're not free though - you pay for pointers at GC time.
So there isn‚Äôt a ‚ÄúReverse‚Äù struct, only the ‚Äúreverse‚Äù struct. Reverse is just a function to wrap it in the private struct. It‚Äôs a minor detail but sort of important. Interfaces are just a way for the language to say, it a struct is passed to this function, it must implement all these methods, taking these parameters and returning these others. So when it takes an interface, it ensures the struct inside implements all of those. When it returns it, it ensures that the resultant struct also does. As for the pointer, it could return either. When requiring an interface, you can send it either a pointer to a struct or a literal value. When you pass around a literal, it needs to effectively make a copy of the value. Since the reverse struct has a pointer (most likely) to the other struct or object implementing the literal, it could easily return the value and be done with it. But, then it‚Äôs making effectively a copy all the way down. Take a look in the Sort method, and how many functions it calls. Now it‚Äôs doing a lot of extra work. So instead, return a pointer and only pass that around. Becomes a little easier in the long run. May be worth re-implementing the reverse struct and testing it tho. But I suspect it‚Äôs faster to pass a pointer than copy the struct. 
Short answer is no if you are looking to start a career as efficiently as possible. And it has to do not with the language itself but with job market. Go is a new still rather immature language which is sparsly used for general programming when compared to languages like Java, Python or JavaScript. As a newbie your first goal would be to find job quick. And build your skills by on job experience. Go is simply not optimal. It's not to say that there aren't any jobs, but your selection pool will be limited. There is also expectation that you'll have previous programming experience before Go as many developers are like that, due to the fact of it being young and folk often picking it up as second ir third language. Now if it's for purpose of a hobby, when yeah. Go is newbie friendly with shallow learning curve.
A 25+ years old Fintech company based in Montreal, we're moving on-premise systems (.NET) to the cloud and we're rearchitecturing by writing Go services and using Docker.
You do. But passing values isn‚Äôt free either. You pay for those on every method call instead. Internals of Sort show there‚Äôs a lot of method calls, so I suspect it‚Äôs a LOT faster. Maybe re-implement the reverse method and check it. Take a million random numbers and sort them using the built in and then a value passed version. I would bet the pointer is a lot faster. 
Yeah, by embedding the interface, `reverse` implicitly implements `sort.Interface`. Returning a pointer is not required for this to be the case, so not certain why this choice was made.
&gt; Since the reverse struct has a pointer (most likely) to the other struct or object implementing the literal, it could easily return the value and be done with it. But, then it‚Äôs making effectively a copy all the way down. You don't get a deep copy if Interface is a pointer.
Thank you so much for the help. I think I'm finally understanding. I guess my last question is the Less method on reverse is a value receiver does that mean that even if Less is called on the pointer to the reverse struct it would still be passed by value? &amp;#x200B; func (r reverse) Less(i, j int) bool { return r.Interface.Less(j, i) }
If the value can be allocated on the stack instead of on the heap, passing by value should be significantly cheaper - may not apply for this use-case, but should be considered rather than assuming pointers are always faster.
Yep
I hope this is an improvement &amp;#x200B; [https://github.com/quii/learn-go-with-tests/commit/7e7ca278f7e66b5322915def7741a2528f91ae9a](https://github.com/quii/learn-go-with-tests/commit/7e7ca278f7e66b5322915def7741a2528f91ae9a)
No. It -can- be a value. But it can also be a pointer. An interface can be both. The methods that talk to it don‚Äôt actually care which is which. If you pass it in as a value, you‚Äôll often find that the internal values aren‚Äôt mutated, unless it‚Äôs mutating values inside pointers inside the struct. 
Correct. If it‚Äôs a pointer you don‚Äôt, but if the user passed in a value... 
Remember that modern languages figure that out internally dynamically. So there‚Äôs no guarantee a value passed is placed on the stack instead of the heap. In this case it‚Äôs likely to. But if you grab a pointer to it somewhere, then it‚Äôll usually allocate to the heap anyways. 
No, when your method specifies a value receiver, the method always operates on the value.
We have a thing like. ‚ÄúMan on call was really quiet last week, we haven‚Äôt had any serious problems or outages‚Äù we call it Frank, after someone who would famously jinx things by saying it. Yeah, definitely was just curious. I‚Äôve worked with canonical a few times on some things and know you lot are squared away. Fortunately I haven‚Äôt had to deal with a bug or vuln issue but a handful of times I‚Äôve hosed production for a highly used platform. It was also 100% human error due to not sleeping enough, or being burned. Thankfully I‚Äôve got a better life balance now (not because of that). Sounds like your team is taking it very seriously so that‚Äôs good. Hopefully the week long burn doesn‚Äôt add to your need of rest.
I can't think of a sortable data structure that this would apply to, but that's not to say one doesn't exist.
The `reverse` struct is passed around as a pointer, then dereferenced and passed by value in `func (r reverse) Less(i, j int) bool`. Every `Less` call is: - dereference the method set of the Interface(*reverse) wrapper / call it - dereference the `*reverse` pointer - copy the data for the method call - dereference the method set of the inner `Interface` / call it Which doesn't seem ideal to me... I wrote some benchmarks, it looks like changing the receiver of `Less` to be a pointer yields a nice perf improvement. $ go version go version go1.11.4 linux/amd64 $ go test -bench . -benchmem goos: linux goarch: amd64 pkg: github.com/xxx/revtest BenchmarkValueAsValue-16 5 329817719 ns/op 48 B/op 2 allocs/op BenchmarkValueAsPointer-16 5 329125547 ns/op 48 B/op 2 allocs/op BenchmarkPointer-16 5 278396541 ns/op 48 B/op 2 allocs/op BenchmarkStdlibReverse-16 5 331612771 ns/op 48 B/op 2 allocs/op PASS ok github.com/xxx/revtest 11.425s Benchmark code here: https://play.golang.org/p/1VgXq65MOST
Guaranteed to allocate on the heap if you use a pointer. I benched the two implementations of `Reverse()` btw, and it makes zero difference to perf for a trivial example.
*Not guaranteed, subject to pointer escape analysis. Regardless though, the inner interface is subject to similar heap allocation rules.
You are indeed correct.
Might be worth a CL?
Yes - sort of. The compiler will automatically dereference or take a reference if you mix a pointer with value method, or value with pointer method. https://golang.org/ref/spec#Method_values &gt; As with selectors, a reference to a non-interface method with a value receiver using a pointer will automatically dereference that pointer: pt.Mv is equivalent to (*pt).Mv. &gt; &gt; As with method calls, a reference to a non-interface method with a pointer receiver using an addressable value will automatically take the address of that value: t.Mp is equivalent to (&amp;t).Mp. 
Found this through a web search. Nice work! How does it compare to https://github.com/a-h/generate ?
I've been reading though this because I find the concurrent connection issue interesting, the 10Kc issue is what got me interested in Nginx and then NodeJS. I hadn't really learned about Epoll which is used in this example, and came across this: [https://idea.popcount.org/2017-02-20-epoll-is-fundamentally-broken-12/](https://idea.popcount.org/2017-02-20-epoll-is-fundamentally-broken-12/) The video seems to suggest that the multi-threaded use of epoll is potentially problematic.
[removed]
A really interesting history of the quicksort from C. A. R. Hoare shows a good example of how to avoid extra computing when partitioning an array into little and big elements. https://en.m.wikipedia.org/wiki/Quicksort It's also mentioned in the following book on page 32. https://www.oreilly.com/library/view/the-practice-of/9780133133448/ It doesn't entirely cover interfaces in go lol but the thought process is so old school clean with sorting algorithms. Gets you to think piece by piece. You can also see the function name quicksort here in the go spec. https://golang.org/src/sort/sort.go?s=5414:5439#L206 i believe for the example you are referring to this? https://golang.org/src/sort/sort.go?s=6261:6299#L241 Embedding the interface does what it says. It allows it to use other interface methods. The return r.Interface.Less is to ensure the returning Less method is returning the interfaces Less method that is on the reverse struct. ‚Ä¶ Hopefully that didn't sound confusing but it is a witty way to ensure that return type has these methods. Which is just magic in go. https://golang.org/src/sort/sort.go?s=505:783#L4 This portion ‚Äúreturn &amp;reverse{data}‚Äù is doing a lot. It is ensuring reverse is using the interface methods in the package. If you are embedding a lot of these, it is grabbing the values from the address. Also, encase you are doing something witty their reverse method still by passed your wittiness. The data is just type interface so this is pretty abstract to pass. Whatever is going into Reverse is directly coming out. You now have the ability to pass an interface as a param and pass your own while still using this method. 
You gotta tidy up those stale branches!
Actually almost all the binaries in Google are using the Flags. Maybe it's because you aren't accustomed to it. 
I think I know what you're saying, but just to be sure; is there a Golang "thing" called context/namespace?
 No major financial institutions use golang yet. They almost all use java, or a C style language if they need performance. We‚Äôre an ATM/POS operator that transacts in cash and crypto. Most of our scripts today are in ruby, but our higher performance components are in golang. 
Really like the CSP from Standford
I think you misunderstood myself and OP. OP seems to be wanting to write a REPL. REPL = Read-Eval-Print-Loop, similar to something like the interactive MySQL prompt, etc. That is to say, an application that you run, and then whilst it's running interactively you write text to the application via stdin directly from your terminal, and then have the application process that. Flags is an incredibly useful package, and is fantastic for the purpose that it services, i.e. basic application options and providing help text for them. It is not however designed to be used for interactive REPL-like applications. Flags are passed as arguments to the application _to be run_, a REPL is given arguments _as it is running_. ``` $ mysql -u foo -p bar ``` In the above, `-u` and `-p` are "flags" of course, but after you run the application you get the MySQL prompt, which is provided by the MySQL application itself, and is a REPL of sorts.
How do you transmit data to NodeJS or C#? Thought about Protobuf, HTTP-Rest, XML but I can‚Äôt reason when to use what. Or did you connect the client directly to database?
All of our customer facing SIP handling is in c/c++. We have some go sip parsing that is used around diagnosis.
repost üòí
Here‚Äôs an example in docker machine: https://github.com/docker/machine/blob/master/drivers/vmwarevsphere/vsphere.go#L975 
not exactly the same thing. I've been keeping that project on my radar (and have committed changes to it) but it still requires dart. which is a pretty awful language for the reasons covered in dlvan's blog. 
Hi, the decentralized VPN part applies to the fact that the VPN nodes are peer to peer instead of centralized like in traditional VPNs. The blockchain aspect involves the reputation system, payments, smart contracts on the Ethereum blockchain and use of MYST token in the services. As for the number of servers we are running for TestNet it is 6 while our users today are running 39 of them. That is because they want to participate in the process as when we had rewards for nodes during our MVP the number reached 2,000. We will soon implement rewards and incentives for nodes so the number will grow again. You are correct that the multi hops and relays have still not been implemented but will be during this year. We are one of the first VPNs to implement WireGuard for Android mobile apps. Everyone is welcome to contribute and review the code as you have mentioned. We invite you to check out our apps for Android, Windows and macOS and test for free. Would be happy to receive your feedback.
Also Healthcare space, general server-side tech
I'm new to Go but not programming. If I were starting out, Go is great because it's simple, small, and opinionated. Tools like golint, gofmt, etc. force you into patterns so you can focus on writing and testing logic. From what I've seen it's very powerful and capable and supports a number of important paradigms: imperative, functional, and concurrent. The main downsides are the disconnect from a GUI, which can be motivating for many people. It's not that you can't use it for visuals, but unlike JavaScript you won't be using it to make the front-end for web or mobile apps. Another downside from a learning perspective is that it isn't object-oriented, so you'll need to look elsewhere for OO concepts.
What's the purpose of this package?
Working on a cloud downloader project called ƒ∞skele Network (not yet released). I'm doing DevOps. Using Go for daemons, internal utilities and microservice APIs.
I do it like the way u/kivutaro does. I first build the most basic producible artifact of the thing I have in mind. Then I try to refactor for it to be extensible. Then I build extra functionalities on top of the ground structure.
Watermill is a really fine piece of software, I enjoy working with it.
It sounds like a fun use case. But I am always a bit upset when applications need to understand too much from the orchestrator. I like to avoid this dependency. But for rare or good use cases why not.
That is certainly one valid path, but I think "in ones best interest" is too strong. If you want to make mobile business apps, Swift on a Mac is probably the best choice. If you want to go into the games industry or enterprise software, you're generally better served on Windows. If you want to do web programming or server-side programming it doesn't matter all that much.
Poor dependency management. Yeah, this is still a problem in big projects.
Because the error callback is it's own function how to you return from the outer function? You would need your callback to set a variable and check on that anyway. It gets really quite ugly once you expand it out. There is also a concept in Go to fail early. If you were using closures to handle errors you couldn't fail the function early. I think a more complete example with real code would start to show how this won't be cleaner.
What if I want to do something based on that `err` 30 lines after that `http.Get`? Setting an error callback to generic functions is code smell and you're probably will have bad times soon.
FYI, I created an issue to track this (https://gitlab.com/YottaDB/Lang/YDBGo/issues/11). We're looking for help :)
The security tradeoff is making it so an adversary can't use the go-get=1 query parameter manually in curl to explore a repository structure. A company running gitlab that may not have anything related to go in it (i.e. no go modules or code in general). This would be the case if gitlab supported that query param globally in the product.
Depends on the game, but seeing as how large even the mobile game industry is... 
It avoids callback hell... What if you had to handle an error when handling an error? Exiting the original function early would become hard and messy.
Why use error as a closure? Well for the same reason you use closures. https://gobyexample.com/closures And the way scope works in go. It allows you to use that closure for multiple instances. If you do the following single check. if ae, ok := e.(*argError); ok { fmt.Println(ae.arg) } This just covers this instance and you cannot get out of this scope. This was covered by Rob in https://blog.golang.org/errors-are-values You are also calling that function every request and you cannot as easily just do one check if nil for all. Like Rob's example. var err error write := func(buf []byte) { if err != nil { return } _, err = w.Write(buf) } write(p0[a:b]) write(p1[c:d]) write(p2[e:f]) // and so on if err != nil { return err } 
In rust you can just redeclare variables that have the same name but a different type. let foo = 'a'; foo = 'b'; let foo = 1; foo = 2; is legal.
I agree. There isn't one solution to everything just as there aren't one way to make source code suck. But for when you need a little bit of decoupling for, say, making better tests or an easier API, this article can help.
I like both the ways Rust and C# handled it (even though in C#, it should have been part of the language from day 1). The C#/Typescript way would fit Go as well: Only types with a question mark can possibly be \`nil\`, and the compiler checks if you use them in a function that doesn‚Äôt accept a \`nil\`able type there.
[removed]
What route does 404? 
why not use gRPC and when a JSON only client does a request, you use json.Marshal and json.Unmarshal to support JSON? While also supporting gRPC clients. &amp;#x200B; Just curious. Looks like a fun and comprehensive project tho.
All of them. localhost:8080 localhost:8080/assets/ localhost:8080/assets/index.html localhost:8080/index.html
what about localhost:8080/hello ?
Returns Hello World! Thats the only thing that works
Sorry forgot to mention that there is a function underneath those that serves /hello
You need to give more information, man. This could be something simple, or it could be something that has nothing to do with your Go code. Hit it with `curl -v` and quote the output here.
I see, so I guess that was pretty much it. Thank you. But, perhaps I am asking the wrong question. In my code, I am using logrus and resty. I have a logrus field of "url" that I wanted printed in each log statement, which is the URL that resty is using in that given function (different API end points on same server). Would I still solve for this in the above way? Or is there a way to "update the 'url' field with the current value of client.url" Hope this makes sense. &amp;#x200B; Here is an example of something I am tinkering with. I am sure to a professional developer it is cringeworthy, but I figure it is easier to convey what I'm trying to do if you look at my code directly. I'm just learning and playing [snap\_prod\_refresh](https://github.com/CloudSurgeon/snap_prod_refresh_mm)
Here is the command and output from the curl -v: &amp;#x200B; curl -v localhost:8080 \* Rebuilt URL to: localhost:8080/ \* Trying ::1... \* TCP\_NODELAY set \* Connected to localhost (::1) port 8080 (#0) \&gt; GET / HTTP/1.1 \&gt; Host: localhost:8080 \&gt; User-Agent: curl/7.54.0 \&gt; Accept: \*/\* \&gt; &lt; HTTP/1.1 404 Not Found &lt; Content-Type: text/plain; charset=utf-8 &lt; X-Content-Type-Options: nosniff &lt; Date: Thu, 14 Feb 2019 16:36:28 GMT &lt; Content-Length: 19 &lt; 404 page not found \* Connection #0 to host localhost left intact
[removed]
Security and intel. I write heavily-customizable bespoke systems for everything from malware analysis to text processing and reverse engineering.
Small issue, pet-pieve of mine: the only time you need to use ./ is when invoking an executable in the current working directory that is not in your PATH. It‚Äôs an ancient security feature to prevent dropping in replacements for common commands and doing horrific things.
This üíØ
Thanks for finding this example; this is a bit closer to what I'm looking for.
Not seeing a handler for `/` there. Can we see the output of a request to a route you've defined?
webrpc is architecturally inspired and similar to gRPC, but webrpc code-gen is much simpler, writing generators for target languages is simpler, and the type system is not made for binary serialization, therefore we have more flexibility in how we can build req/resp payloads and runtime types. For example, we can actually have a Go server field as \`map\[string\]interface{}\` which is impossible with Protobuf/gRPC. As well, defaults and optionals are supported here too, and even the generator is pluggable. See for the kinds of thing the generator can produce, [https://github.com/webrpc/webrpc/blob/master/\_examples/golang-basics/example.gen.go#L72-L81](https://github.com/webrpc/webrpc/blob/master/_examples/golang-basics/example.gen.go#L72-L81) &amp;#x200B; for us, this is replacing gRPC for all of our infrastructure as in many cases, the infrastructure we make is consumed by end-user webapps. 
The problem I'm having is writing an API in which we return an (val, err) from almost every function. We end up with extremely verbose functions, where one action takes 4 lines of code. It becomes very difficult to "scan" for meaningful logic. The answer at (https://www.reddit.com/r/golang/comments/aqkz6v/apis_that_look_for_error_callback_rather_than/eggrb1p) provides an example of something realistic I could do instead to control this, taken from the blog.golang.org. I'll probably go with that.
While I'm on about it, it would be super great to link to a minimal repro for stuff like this or at the very least text code. It's super hard to work from a screenshot of a text editor.
The only output I receive other than the 404 is for the /bird route which gives me a null (Assume because there is nothing in the database yet). How would I Get the / handler to point to my assets/index.html route?
Yeah Rob is awesome. In a smart way and understandable way. I'm reading his book right now. https://www.oreilly.com/library/view/the-practice-of/9780133133448/ Good stuff, even if it is in c, c++, and Java. It gets your noodle going. 
It still doesn't solve everything though; how would I chain together multiple *different* functions, that take different parameters, without having that 3-line snippet checking err after every call? 
Any more details you need let me know. If you can help fix this I am forever in your debt (Ive been staring at it for about 4 hours now)!
The best solution is to power through this problem now, and wait for the [Go 2.0 error handling proposal](https://go.googlesource.com/proposal/+/master/design/go2draft-error-handling-overview.md) to come in later.
[removed]
Maybe I‚Äôm mistaken, but how are the dependencies being cached in this instance? Does docker handle this with some magic based on the language? You‚Äôre just copying over your toml and lock and running dep, not sure how any caching goes on, but once again maybe I‚Äôm missing something. 
Unless you've got some sort of contractual obligation or something similarly strong, I would recommend just using an existing, solid package that uses some other language. I wouldn't expect you to find anything great in the Golang field. This sort of specialty software often exists in a niche where the handful of best-of-breeds crowd out implementations in other languages, because to even create a half-useful solution in a new language is a ton of work.
I wonder if WS can be implemented using just the standard library or if that is much of a hassle to bother "re-inventing the wheel".
Well that looks nifty. I guess sticking with the "norm" and returning the (val, err) tuple would be the best approach, then just fix the examples when Golang introduces a better handling mechanism. Thanks!
write a handler for route that returns a 301/302 and the new location, alternatively you could move your `index.html` to your root. &amp;#x200B; I don't use `gorilla/mux` so forgive me if this doesn't compile &amp;#x200B; r.HandleFunc("/, func(w http.ResponseWriter, r *http.Request) { w.Headers().Set("location"", "/assets/index.html") w.WriteHeader(302) })`
Doesn't really matter much if you've got Achromatopsia...
What's your definition of stdlib? https://godoc.org/golang.org/x/net/websocket
What is the working directory of your process when it runs ? &amp;#x200B; Using the relative path \`./assets/\` means that, when the code of the http server is executed, the working directory needs to be the one which contains \`assets/\` (not \`bin/\`, not \`build/\`, not \`$HOME\` ...) .
I'm pretty sure a "big" bank is using it for creating their cloudy tools and blockchain initiative but thanks for the details. :)
I would first see if your toml library supports watching a file for changes. If not, look at fsnotify. The idea is fsnotify triggers when the file is changed, then you reload the file details. How your program handles hot reloading the changed data is going to be up to you to discern the most elegant way
They actually have a really nice error handling inside the http package. https://golang.org/pkg/net/http/ https://golang.org/src/net/http/server.go?s=60105:60157#L1963 To be honest I haven't dug into many .get requests per handler but you can wrap anything. I don't know your use case so it's hard for me to say. I mean if you want to abstract away the request method, I suppose you can use the func type as a param. If you wanna go closer to home, you can wrap it in a custom function. https://blog.questionable.services/article/custom-handlers-avoiding-globals Depends how abstract or deep you wanna go. 
Seems similar to [google/go-cmp](https://github.com/google/go-cmp/) or [gotest.tools/assert](https://github.com/gotestyourself/gotest.tools) which uses it.
So, here's another case where a minimal repro and actual code would have been good. What libraries are you using, what order are your routes in, etc. Given your package names, I'm going to assume you're using `gorilla/mux` So order matters and, yes, you can do this, but I might recommend against it because the results can be unexpected. Given the following code: ``` package main import ( "net/http" "github.com/gorilla/mux" ) func fooHandler(w http.ResponseWriter, r *http.Request) { w.Write([]byte("foo route\n")) } func barHandler(w http.ResponseWriter, r *http.Request) { w.Write([]byte("bar route got " + mux.Vars(r)["barID"] + "\n")) } func main() { r := mux.NewRouter() r.HandleFunc("/foo", fooHandler).Methods("GET") r.HandleFunc("/bar/{barID}", barHandler) r.PathPrefix("/").Handler(http.FileServer(http.Dir("./static/"))) http.ListenAndServe(":8080", r) } ``` then you do ``` $ curl localhost:8080/foo foo route $ curl localhost:8080/bar/hello bar route got hello $ curl localhost:8080/hello 404 page not found $ echo "hello world"&gt;static/hello $ curl localhost:8080/hello #again hello world ``` Okay, so far so good, what if they get `bar` wrong? ``` $ curl localhost:8080/bar 404 page not found ``` Okay, not exactly clear, but it makes sense if you think about it, but now we can do this: ``` $ echo "hello bar"&gt;static/bar $ curl localhost:8080/bar #again hello bar ``` That can be kind of confusing. So I think I would still recommend using a `/static` prefix for your assets if you can.
Yeah thanks
If I did go back to school I would much rather go to law school over masters in CS. Personally think it is a much better ROI. 
That's a stack of links there, haha. I'll take a look through them. I'm using the http package as an example; the code I'm actually working on is the YottaDB Go wrapper (https://www.reddit.com/r/golang/comments/aqatmn/announcing_go_wrapper_for_yottadb_powerful_nosql/). One of the people here commented that our API is rather verbose at the moment, so I'm trying to make something that doesn't get whacked with performance but is easier to use... The error checking struck me as a place where the "flow" gets ruined. The current proposal is at https://gitlab.com/YottaDB/Lang/YDBGo/issues/11, but we're open to suggestions 
when you walk the byte array, if there are not 5 chars left, then just don't write that slice into the map?
There are two potential issues you are likely having. One is handling the overlap at the end of one chunk and the beginning of the other - this is not what you are complaining of, I just want to bring it up to make sure you are considering it, and not losing those last four crossed elements in between each chunk, as that would invalidate your methodology. To validate this, write a simple program that just outputs 5000 'A's, then 5000 'T's, 5000 'G's, etc, and run it through your input routine. If your map only has 'AAAAA', 'TTTTT', 'GGGGG' and those 'space contaminated' elements you described, then you'll know you've got an issue. You should have 'AAAAA', 'AAAAT', 'AAATT', 'AATTT', 'ATTTT', and 'TTTTT', etc, and the test I described will make sure you are getting them. As to the end of chunk problem, you need to be looking at the return value of the function that is reading the bytes! It should be telling you how many bytes were read, and you need to stop your loop at 5 less than that value. In other words, you should not have a loop like: `for i = 0; i &lt; 5000 - 5; i++` ... you should have something like numBytes, err := stream.Read(buffer) if (err != nil) { // handle the error } for i = 0; i &lt; numBytes-5; i++ { // do stuff } &amp;#x200B;
The go-mysql-driver badly needs better documentation. It's very well written but you have to configure it correctly.
Ah, actually, I misread this a bit in my other response. If you want to combine having a static directory and having a naked \`/\` point to your \`/static/index.html\`, you can do this: ``` func rootHandler(w http.ResponseWriter, r *http.Request) { http.ServeFile(w, r, "./static/index.html") } func main() { r := mux.NewRouter() r.HandleFunc("/foo", fooHandler).Methods("GET") r.HandleFunc("/bar/{barID}", barHandler) r.PathPrefix("/static/").Handler(http.StripPrefix("/static/", http.FileServer(http.Dir("./static/")))) r.HandleFunc("/", rootHandler).Methods("GET") http.ListenAndServe(":8080", r) } ``` $ curl localhost:8080/ hello index ``` The pathprefix is a little ugly, but that's what you have to do with gorilla mux. Though the interaction between this and `http.FileServer` might be a little weird: ``` $ curl -v localhost:8080/static/index.html * Trying ::1... * TCP_NODELAY set * Connected to localhost (::1) port 8080 (#0) &gt; GET /static/index.html HTTP/1.1 &gt; Host: localhost:8080 &gt; User-Agent: curl/7.54.0 &gt; Accept: */* &gt; &lt; HTTP/1.1 301 Moved Permanently &lt; Location: ./ &lt; Date: Thu, 14 Feb 2019 18:59:18 GMT &lt; Content-Length: 0 &lt; * Connection #0 to host localhost left intact $ curl localhost:8080/static/ hello index ``` But it should still work from the browser's perspective: ``` $ curl -L localhost:8080/static/index.html hello index ``` 
You should ideally be able to set the connection lifetime much higher than 1 minute. It does depend on the mysql config though.
Another (old-school) approach might be to listen for the SIGHUP signal then rescan the config. This won't be automatic, but you won't need to restart the application. Golang signals: [https://golang.org/pkg/os/signal/#Notify](https://golang.org/pkg/os/signal/#Notify) Your program would do something like (mostly copied from the link above): ``` package main import ( "os" "os/signal" "syscall" ) func main() { // Set up channel on which to send signal notifications. // We must use a buffered channel or risk missing the signal // if we're not ready to receive when the signal is sent. c := make(chan os.Signal, 1) signal.Notify(c, syscall.SIGHUP) // Block until a signal is received. go func() { for range c { // reload config } }() // Main process } ``` Then to trigger a reload of the config, do ``kill -SIGHUP &lt;pid&gt;`` where pid is the pid of the running go process.
Viper has this ability builtin: &amp;#x200B; [https://github.com/spf13/viper#watching-and-re-reading-config-files](https://github.com/spf13/viper#watching-and-re-reading-config-files) &amp;#x200B; and can handle TOML files: &amp;#x200B; [https://github.com/spf13/viper#why-viper](https://github.com/spf13/viper#why-viper) &amp;#x200B; might be worth a look?
The read should return the number of bytes read. If you have a buffer of 10000, it doesn't mean you will always get 10000. You could get less. Are you checking that number to know if you need to read a little more to complete the last sequence? 
I have attempted this by not writing any key into the map of length &lt; 5, but it counts the "white space" in the length of the string. White space in quotes because when I try to trim white space using normal string methods it doesn't trim whatever is actually on the end of my string. Do you know a more complete way of checking if its really 5 characters?
I ran a "shitty debug" of printing the length of each chunk as it was read, and it always tells me the length is 10000 if I am gathering a chunk of 10000. A colleague of mine said that go will give you 10000 bytes whether there is enough actual file to fill that or not, it gives some kind of white space characters that I have yet to find a good way to work with. So even if it should be giving me less, its giving me 10000 bytes 
Thanks for your thorough reply! I am including a varaible to catch my overlap of each chunk, I just figured it wasn't worth mentioning as part of the problem I am having, because it occurs whether I include a way to catch overlap or not :/ And I do also include a variable like your "numbytes -5", I grab what I call a "sliceLength" of my chunk length minus my desired sequence length, my loop looks much like the one you suggested
I don't understand what you're looking for with this line of questioning. I've been clear from the get-go: always write code that defends against nil pointers / references. Avoid panics at all costs.
So is the /assets/ or /public/ folder not conventional like in other programming languages? For example PHPs Laravel has the public folder. And thank you for the code, I am offline for the evening but I will try as soon as I get up in the morning.
Thank you... a lot... Im going to try and work out exactly what you've done here, tomorrow when im back on the laptop. I will let you know but thanks in advance. This has been a serious head pickle
Compile with -fsanitize=address with any popular C compiler and you'll have stacktraces and more these days.
This is my preferred approach. It uses the standard library, and is a tried and tested approach. Most devs will instantly know why your code is doing what it‚Äôs doing.
&gt;Mostly Hi mate. Your team was amazing at handling this bug. I wish more of the coverage focused on Linux as a whole being stronger than it was a week ago, due to a team that understood security and was receptive to community feedback. &amp;#x200B; The patch was underway within hours of the report, and a large percentage of boxes around the globe that were previously vulnerable to attack are now safer. &amp;#x200B; All software has bugs. What matters is how they are dealt with. Keep up the great work.
Great timing, I'm literally right in the middle of implementing a large scale websocket deployment in go. I will be reading this quite carefully in the coming weeks.
FWIW, gRPC requires http2 and footers - neither of which can be relied on in a web-context. There's also the issue with bidirectional streaming, which is hard to do well on the web. So far, the closest you can get, is to use gRPC plus an HTTP&lt;-&gt;gRPC gateway, but TBQH, that negates many of the benefits of gRPC. You have to solve authentication and instrumentation and everything gRPC gives you again for the proxy. The gRPC team knows about these and is working on solutions to all of this. But in the end, I totally get why you'd want a solution that is more tailored to the web. Lately, I've been looking at [twirp](https://github.com/twitchtv/twirp) a bit, which is kind of "gRPC light" in that sense - it removes all of the features of gRPC that make it hard to use in a web-context. That being said, it of course also means you have to add these features (e.g. auth) yourself if you need them. Anyway, I don't know anything about this particular project :) But personally, I don't find gRPC very usable as an external gateway for web apps.
Because people overuse pointers by mistake. 
Note that it can further be optimized if just implementing a tcp server that immediately upgrading to websocket Think about it, going from TCP to HTTP, just to hijack and go back to TCP...so why do all the allocations and stuff inbetween? can just do what is called zero copy upgrade
Hi dotwaffle. Your point has merit, and unfortunately there is never a simple process that works in all situations. I find that security issues are not taken seriously without a working proof of concept. They are considered theoretical, not given enough attention, or put at a low priority to fix. I am also not so arrogant to think that I was the only one who discovered this. It is quite possible that this vulnerability was already being exploited by shady government/criminal organizations to target groups or individuals. I worked very hard to write a detailed overview of the issue (in the bug report and blog) and to show exactly where this issue came from and how it could be abused. I think this level of detail helped garnered it so much attention. Ultimately, I think people will learn from this - in terms of avoiding similar bugs. Also, I think Linux admins around the world understand the urgency to ensure the systems are patched. By attacking software, breaking it, and sharing exactly what happened we make it stronger. These decisions are never clear-cut, and I'm not saying my method is the best, but I do feel like this worked out well in this particular scenario. The response by the snapd team was really amazing, and goes to show that the open source model is working here.
I just asked you a simple question because I'm curious about the answer.. You know that writing to nil maps can panic, and if you try to avoid panics at all cost that would imply that you are also checking if maps inside any struct is nil before calling methods on that struct, since that may panic.
I wish twirp had even unidirectional streaming :(
TBH, I don't think streaming really is the way to go either way. It is often easy to jump to that as a solution, but the operational burden of streaming APIs is *considerable*. All the most problematic services I've worked on in the past where streaming APIs. Load balancing, sharding, monitoring‚Ä¶ all become so much harder with streaming. If you can avoid it, it makes your application far more future-proof. But yeah, I do definitely see the usefulness‚Ä¶
&gt; I find that security issues are not taken seriously without a working proof of concept. Totally agree. Surely you can agree that there is a difference between having a proof of concept application drop a file somewhere (`/etc/CVE-BLAH-BLAH` or similar) and granting root access to someone. I do not fault you at all for the way you handled the disclosure to the author. I do very much find large fault with those who signed off on having the announcement including a method that could be used by every script kiddy out there only hours after public disclosure. 24 hours at a bare minimum would have allowed at least the "unattended-upgrades" functionality provided to pick up the change and install it, and mirror networks to distribute the patch -- most have delays of between 2 and 6 hours, smaller ones a day or more. Only 11 hours was entirely unreasonable in my view. I'm not asking for months or even weeks, I'm saying 24-48 hours after the announcement before releasing exploit code gives a nice window where at least automated updates can take place, and those who weren't working (most people are at work only 8-9 hours a day, meaning 15-16 hours away from work) were entirely caught off-guard by this. &gt; Ultimately, I think people will learn from this - in terms of avoiding similar bugs. Also, I think Linux admins around the world understand the urgency to ensure the systems are patched. Quite the opposite, my level of trust in Ubuntu has dropped as a result of this. If this exact scenario had been carried out (including announcing the bug at the same time as the fix being released), but there was at least a day (if not a week) between the announcements and the exploit being shared, I would have considered it reasonable, responsible, and appropriate. This was just awful.
you'll get better help if you supply a link to the code on github, gist, paste, some sort of text based thing where we can see it all. for instance, where is host/port defined? 
I'm on contract for middle eastern governments writing code to detect Jews from pcaps.
Another option that we (i work on grpc) recently made available is grpc-web. [https://github.com/grpc/grpc-web](https://github.com/grpc/grpc-web) You are right trailers cannot yet be relied on in a web-context, so there is no support for bidi streaming, but unary and server streaming calls are supported. &amp;#x200B; The idea here is that you get a very similar API to gRPC that you can access from the web. Some folks have blogged about integrations with popular frameworks as well [https://medium.com/@aravindhanjay/a-todo-app-using-grpc-web-and-vue-js-4e0c18461a3e](https://medium.com/@aravindhanjay/a-todo-app-using-grpc-web-and-vue-js-4e0c18461a3e) &amp;#x200B;
https://gameswithgo.org/ I am an experience programmer, but I've followed through some of those tutorials as I'm learning more about games programming lately and I've had a blast. Could be fun for someone that is new to it all. :)
That is what the gobwas websocket library does in there number 4 example, see github.com/gobwas/ws
It's not easy to return (which is a big enough problem by itself, since that's the most common thing to do), and it also makes you do weird things. In the former example, if Get fails, you return an error. If the latter example, if Get fails, I guess you have to set up a dummy Response object? What should that dummy object set up as its status code or body buffer? What should the final result variable get? And what can the handleErr function do anyway? It doesn't have access to the dummy Response that's being built, and it can't return... I guess it can do some logging? It's not an atrocious sin, it's just worse in concrete ways. :)
Fair points, thanks for your detailed response. I will consider this next time I go through this process. Just to add some clarity, the patch was being automatically installed in the background for about a week before disclosure, I believe. But I completely understand your wish for more time to manually update. Thanks again, have a good day!
You too. If it wasn't for the duration between release of the fix and the release of the exploit, it would have been a very positive experience.
Someone else benchmarked it and it was the same. So it‚Äôs pretty irrelevant. I also trust the library developers over some random dude on the internet. 
Can you share your source code and/or input file?
That‚Äôs just incorrect. You can pass a value or a pointer into an argument that requires an interface. Only concrete types require one or the other. 
We're talking about the method receiver on the struct, not interface func arguments.
I see what you‚Äôre saying now. If you called it on the value of reverse and not the pointer, it would still call the sub call on the pointer of the original struct. Hence why it wouldn‚Äôt matter in this case. 
That is unfortunate. I've had the philosophy for 30 years that being a programmer is about how to think, not the language. It is about systems knowledge etc. and that skill can be generalized to any language fairly quickly. Having a workforce that needs to standardize on one language also goes hand-in-hand with having to introduce heavy process to keep everything organized because your people are 'good enough' to be given a lot of autonomy. Self-fulfilling prophecy. &amp;#x200B;
I didn't say it was a business need. ;) In fact, from a purely enterprise perspective a 6 or 10 or even 20MB bin that just works once it's deployed solves a plethora of problems that more than makes up for the size increase. Especially in the age of microservices-on-containers. Where it becomes a problem is when you want to distribute many go binaries in a size constrained package. Imagine that you'd want to reimplement coreutils in go. Amazing from a security standpoint, since many attack vectors simply disappear. But so does your disk space, unless you do it ala busybox (by combining all the binaries into one to maximize reuse). Also, slightly unrelated, but if you deploy containers really frequently, you're going to need a larger archive for emergency rollbacks. Size might be at a premium in the platform you are using. That's when you start reaping alpine's small size benefits. The same applies, albeit to lesser extent, to the size of the binaries included in the containers. Truth is, I'm silly, and I just want to toy with the idea that we could have all the benefits of go and not pay the disk price for it.
So would I be correct in my thinking that this pointer was haphazardly placed? It seems like there are no benefits to the value being a pointer as all the method receivers are value receivers 
What about [grpc-web](https://github.com/grpc/grpc-web)? From what I hear, it supports server-side streaming but not yet client-side. The only requirement is some sort of proxy like Envoy that can convert these requests into gRPC... somehow the requests between the browser and this proxy are still technically gRPC.
Make sure to use mutexes as needed 
The project I am working on needs "real time" updates. I'd rather not poll. 
Game dev too, we deal with API and data processing.
Sure. The question is whether an RPC framework is the right way to go for that, or whether that kind of subscription API is better done out-of-band. I know, though :) [I see the advantages too](https://github.com/twitchtv/twirp/issues/3#issuecomment-463829407).
I ran into this issue when I was investigating how to write tail in go when used in conjunction with logrotate. I had to watch the original file to see if the content changed, the file moved, or was truncated. [This short talk](https://www.youtube.com/watch?v=lLDWF59aZAo) is what I was following, but you could do the same thing with a few of these triggers. Another idea would be to consistently read the file and [calculate a checksum](https://golang.org/pkg/crypto/md5/), and trigger if the checksum changes.
The other comments are great as far as how to know when the configuration changes; unfortunately that's probably the easy part. The hard part is making sure any running goroutines find out about the updated configuration and make use of it. That includes avoiding races on your configuration (with a mutex or by sending the new config on a channel); re-establishing connections to external services that have changed configuration (like databases or APIs) and are using keep alive or connection pools; closing files and reopening if paths have changed; invalidating caches; and so on. What all this entails depends on the application but it can easily get complicated in a hurry.
was there a question you wanted to ask? there are a few videos of pair programming in Go by Brad and Andrew, members of the go team: https://www.youtube.com/watch?v=1rZ-JorHJEY they're very educational.
Looking for companies that build in go and practice XP. I have worked in XP for a few years and love it, but I want to relocate. I'm looking for a similar work style but including Go.
What is your advice on getting in? Been using Ubuntu for 13 or so years. Got a job as an SDET at a Windows-based shop and I'd like to move to a Linux-based dev position.
You should use alias when needed. What is the meaningfulness of declare a alias `BestValue` for `Value` here?
Before, it was too close to the python color, now it is too close to the perl color.
Haha okay. I work in the industry and have worked in a bulge bracket banks technology. None of their production systems use golang or anything blockchain related. Their blockchain applications aren‚Äôt really serious yet. 
Change the newRouter() function to: func newRouter() *http.Handler { ... } 
[removed]
[removed]
ViewModel is a bit loaded for me. There's ModelAndView in Spring Boot. MVVC in C#. Presuming you want a good separation of concerns, I recommend the Clean Architecture. [https://www.youtube.com/watch?v=o\_TH-Y78tt4](https://www.youtube.com/watch?v=o_TH-Y78tt4) I'm implementing it in Go. It's worked pretty well for me. The general project structure is like so. /my-project /usecases /domain /postgres /rest /v1 /config /rabbitmq In Clean Architecture, your core logic about the domain goes within the "domain" package. Here you define your Structs, or Smart Structs (structs that have methods that encapsulate logic). You also define your services used to get data. If you're from a DDD, these are your repositories. The domain, services implementer like postgres, and the uses cases use the domain models directly. Use cases are the logical driver of any process. CreateNewUser is a simple use case. The implementation's job is to orchestrate the services and model manipulations to get this done. Part of the Use Case layer is the definition of a Presenter, or adapter. The presenter's job is to broadcast the result of use case. This means if the use case succeeded or failed. The presenter gets a DTO; not a domain model. All of my Use Cases are interfaces that follow this simple pattern: type MyOutput struct { // Whatever is needed for the presenter to responsed // to the request. } type MyInput struct { // All the data necessary to do the job. } type MyUseCasePresenter { present(MyOutput) } type MyUseCase interface { execute(MyInput, MyUseCasePresenter) } Notice the lack of error returns. The presenter implementation handles all errors within itself. The use case passes all errors to the Presenter. No returns. When working with REST/gRPC, this means the presenter implementations get the Response. The presenters are stateful. They know to return a 404 for a missing resource, or 409 for bad input. This looks like a bit of work, right? The benefit is that you get great test-ability. Your handlers get a use case. The use case only needs the implementations of what ever repositories it uses. All of this is easily generated for testing. If you use Errors as part of you domain as described here [https://middlemost.com/failure-is-your-domain/](https://middlemost.com/failure-is-your-domain/), you can allow the presenter to map between the Use Case input and the HTTP response object. For example, you can say Error {Path: "Input.FirstName", Code: "Invalid", Message: "no\_nil"}. The presenter can then know that the output response code should be 409 and can use an i18n bundle to look up the proper message to send based on the key "no\_nil".
GoJek
Check out the logrus implementation of `entry.WithFields` If you're using an IDE like GoLand or VSCode, you can likely "go to implementation" from where you're using it in your code to get there. But here's the link to it in github for your convenience. [https://github.com/sirupsen/logrus/blob/master/entry.go#L106](https://github.com/sirupsen/logrus/blob/master/entry.go#L106) Doing this will help you more quickly and easily get answers to questions like these. Plus, it's always good to read over code from common and/or core libraries to pick up on idioms and get ideas for how to structure your own code. &amp;#x200B; Let me know if you have any trouble getting your answer from that and I can guide you through it.
It sounds like you are describing Caddy.
i wonder if something like this helps. ``` package main import ( "bufio" "fmt" "io" "strings" "unicode" "unicode/utf8" ) func ReadSequence(r io.Reader) map[string]int { rc := make(map[string]int) // wrap our reader in buffered reader that implements the io.RuneReader // interface. that means that we can simply ask for one rune at a time. br := bufio.NewReader(r) // we declare cur in the for loop just to limit its scope. this is probably // ugly and i imagine some people would simply declare it outside with // something like: // var cur string for cur := ""; ; { // read one rune from our reader. r, _, err := br.ReadRune() // if we've encountered an error, abort. this is most likely an io.EOF if err != nil { break } // squash our rune to lower case and check if it is one of a, g, t, or c.. switch r = unicode.ToLower(r); r { case 'a', 'g', 't', 'c': // rune matches one of our desired characters, lets append it to our // string. cur += string(r) } // if we have 5 runes in our string, then it must be a sequence of // containing our desired characters and it should be safe to add it to our // map. if utf8.RuneCountInString(cur) == 5 { rc[cur] = rc[cur] + 1 // clear cur so that we can start the process again. cur = "" } } // at this point, we should have a map populated with sequence counts. return rc } func main() { fmt.Println(ReadSequence(strings.NewReader("a gt caga TTT 0233 1 a qr 1 tgtaac"))) } ```
Assuming you have $GOPATH/bin on your $PATH `go get golang.org/dl/go1.12rc1` `go1.12rc1 download` Full list of go versions is available here - [https://github.com/golang/dl](https://github.com/golang/dl)
Also here: https://godoc.org/golang.org/dl.
&gt; reading somewhere Perhaps you saw it in the tweet? https://twitter.com/golang/status/1095073785814962176
Try Tyk.io, the open source gateway does both and is l configurable at runtime.
Caddy looks like it has what I need proxy-wise (minus dynamic configuration?), but it looks like it has a lot more as well. I'm not sure how heavy the extra stuff is, but was hoping for a reasonably lightweight solution.
Thanks. On following your advice, I found that I had an old version on stringer in my path. When I fixed that, my game built without errors.
Depends what you mean by dynamic, and what you mean by lightweight. For example, just because it has a lot of features doesn't mean they will slow down your server. Do you mean small binary size? Then caddy starts at around 9 MB on x86-64, but most Go programs have about 5-6 MB starting size anyway. You could make your binary smaller by removing features you won't use, fairly easily. You'll probably have to either be more specific OR just dive into trying the candidates and choose one.
One advantage of streaming is that you don't have to construct the entire message in memory first and can start sending the data down the wire as soon as you have some, but not necessarily all, of it available. Operationally, this shouldn't really look any different than a unary response. Streams can be closed when you are finished sending data. I expect you are thinking more about long-lived streams, which do bring in some real operational issues, however that is not the only useful place for using streams.
I also went down this rabbit hole with gRPC, protobufs, etc. Finally settled on HTTP/2 +Server Sent Events (SSE) for bi-directionality in this environment 
By dynamic I mean that I can add and remove routes dynamically at runtime, without needing to restart the proxy or dropping existing connections. &amp;#x200B; By lightweight I mean in binary size, but 9 MB doesn't seem unreasonable if the features I need are supported.
Caddy does have a graceful reload, just so you know: won't drop connections (as long as they don't time out anyway)
That's good to know, thanks!
https://pivotal.io/careers many of the product teams write go. 
[removed]
Important ^^
What do you guys prefer, hacking straight into config files or a UI to generate it for you?
Are you wanting to make a service where users can sign up, point there account towards their DB and then your website will expose endpoints for your other services to hit that passes through to the DBs?
Absolutely. The only difference is that everything will run on the user's environment. Right now it is how you just mentioned it. But I want to remove the sign up part. So my website wouldn't come in the picture at all. The downloaded executable would do all the work.
WebSockets are HTTP See HTTP [status code 101 Switching Protocols](https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html)
Yes, but not every reverseproxy properly handles this process.
Is this open source? Sounds pretty interesting!
Still working on it. It was my paid product. Checkout https://github.com/spaceuptech/space-cloud. Don't mind my website. Isn't updated yet.
I need help in figuring out how would you like to configure the tool. Via a UI or via a config file?
If one thing is exactly the same as another thing, why isn‚Äôt that thing a thing? Shorter: always call a thing a thing! Naming is hard. Don‚Äôt make it any harder than it already is. üòä
Yes, of course They are highly performant library and I really respect their work Just bringing this up to this discussion 
Definitely a config file. A UI would be fine too I guess. 
I don‚Äôt think you need the overhead of reading runes when you only expect AGCT
nginx won't proxy http2.. it didn't state that as a requirement but I'd say that this should be a requirement now days.
If your needs are simple enough, the built in reverse proxy in [httputil](https://golang.org/pkg/net/http/httputil/#ReverseProxy) may be your best bet: as of go1.12 it [will support WS as well as HTTP](https://tip.golang.org/doc/go1.12#net/http/httputil) (which means you can start developing against RC1 right now). If your use case is slightly more complex I second the recommendation for Caddy. 
Another advantage is when the requested payload is just silly large and for REST API's you'd require a form of paging/multiple requests to retrieve all data. Streams are brilliant to make this process more efficient!
Any preference on how I can document the various sections of the config file?
I dont think this is safe : &amp;#x200B; `b.mutex.RUnlock()` `return` [`b.data`](https://b.data)`[i]` &amp;#x200B; You should take a copy of the data at [b.data](https://b.data)\[i\] first, then unlock the mutex, the time inbetween these two lines, another thread/go routine can return the incorrect value, for example the Add could of been called inbetween these two lines in another go routine, and therefore the returning the incorrect value. &amp;#x200B; Would be better to make the unlock a defer at the beginning of the function, and this way, it will be called when the function exits. &amp;#x200B; Effectively, the above is a race condition. &amp;#x200B;
That is an extremely open ended question. Personally, I prefer JSON config files with comment support, and use the comments to document the config file (similar to VS Code). Perhaps I‚Äôm misinterpreting, but the ‚Äúvarious sections‚Äù of your question leads me to believe you‚Äôre planning to have a lot of config. I would recommend to keep the config file minimal. For example, [PostgREST](https://github.com/PostgREST/postgrest/blob/master/README.md) relies on [very little config](http://postgrest.org/en/v5.2/install.html) outside the database, instead preferring to use the database itself for configuration. 
May I add its benefits stretch beyond simply test-ability. With this interface and tests, you ensure that you business logic/use cases are safe even if a future developer changes something (granted, your tests need to cover the cases fully). It also makes it easy to swap out a presenter for a different one, as it's not bound to your core business logic. For example you can add a mock one very quickly, just implement the interface. As far as project logic goes though, you're pretty much free to choose how you order it. Main goal is that it's easy to understand and navigate.
Yes I do have a lot of config (filestore, security rules, etc.). I absolutely love PostgREST. But the thing is the database to be used itself is in the config file. But this is an interesting point. To keep the config in the database itself. 
It's usually nicer to embed the mutex and call b.Lock() defer b.Unlock()
Would it be possible to use the golang std context?
Would it be possible to use the golang std context?
Why not use a channel?
That was intended as a joke. Sorry for the unclear description.
Make impossible things (cause we don't have api for that). Like repeat a sync.Once operation, check if mutex is locked, a popular \[\]byte &lt;-&gt; string conversion.
Because it's not the same thing. Writing to full channel blocks, but writing to a full circular buffer overwrites the oldest entry.
If you're using websockets, you only need to auth once when you establish/upgrade the connection. JWT has plenty of other problems, but verification performance shouldn't be one of them for you.
That exposes it as API, and this is supposed to be a circular buffer and not a lock. Handle the locking internally
Where's the M (Model)? Looks like just another wrapper router + middleware package...
Pairing: check. Mobbing: check. TDD: check. Go: no :(
I'm in the same mindset. I would relocate now to write maintainable Go for an XP shop.
presumably in [the ORM]( https://github.com/thinkoner/torm) *"for web artisans"*?
Try Varnish with Nginx for SSL. Both support websockets. 
Yes, it is [https://github.com/thinkoner/torm](https://github.com/thinkoner/torm)
When handling large volumes of data, a circular buffer can be much more performant because it doesn't perform any allocations.
Aside from that exposing it as public API (as was pointed out), I'd also suggest caution with just `defer`ing everything. There's [a relatively big cost to deferred function calls](https://medium.com/i0exception/runtime-overhead-of-using-defer-in-go-7140d5c40e32), and if the logic in the critical section is simple enough and if it's in any way performance-critical, then unlocking manually is the way to go
Temporarily not possible 
Yes, great change! Have always had trouble distinguishing between Go and Python, and had to click the colour bar to see the breakdown every time. What colour is Docker now though?
The route handlers look like they use the same reflect akin to the Martini web framework. It's not clear to me how you reuse middleware functions when the middleware takes the single request context, but it would need to wrap route handlers with parameters that need to specify the params as extra arguments? Also, no tests? 
ya -- i don't know what the input file is so it is safer to assume utf-8 than not. using runes should not be significantly slower than using bytes nd this isn't obviously a high performance application. 
Very true! Thanks for that
sure, I just see it everywhere
I agree. I'm mich more of a multidisciplinairian than a specialist when it comes to technology. I find that picking up new languages or techniques is fairly straightforward compared to analytical thinking and problem solving. But I know quite a few people who focus on single language expertise (mostly C++ developers, I think because of the high level of language complexity and gotchas involved). 
[removed]
[removed]
Please read [this debunking of a similar web framework](https://stephensearles.com/three-reasons-you-should-not-use-martini/).
I genuinely appreciate all your comments. I will take some to process all the opinions and try to find a pathway. Thank you! 
I'll be honest: this doesn't look good. I mean... not even template caching? The routing looks awful as well. I look at this and I'm not sure why I'd use it. It doesn't offer anything i couldn't get from simple libraries that don't lock me into a framework. Also: the code is raising my eyebrow from time to time. Heavily. Like: you are converting your template bytes into a string...in order to convert them back into an byte-array anyways?! What part in your code did i miss where the \`Response.content\` needs to be a string instead of just a \[\]byte and avoid the unneeded conversion? The worst part: i actually wanted to test it. Goget that thing. Copy&amp;Paste your "Quick start" code.... doesn't work. Permission denied trying to create folders. Meh.
Except this one allocates every time data is added... 
I was looking for an architecture which detaches the structs used in the API from the controller layer. Do you think we can achieve that? 
I was looking for an architecture which detaches the structs used in the API from the controller layer. Do you think we can achieve that? 
An easy way to to handle the synchronisation is with [`atomic.Value`](https://golang.org/pkg/sync/atomic/#example_Value_config).
You've made my day. *I'll definitely use it at work in our next project*. /s
Not an answer to your question, but a side note: &gt; grab the string, checking if that string is in the map, if not I add it and set it with a count of 1, if its already in the map I update the count What you said translates to something like: s := string(chunk[i:i+5]) if _, ok := m[s]; !ok { m[s] = 1 } else { m[s]++ } However this can and should just be: m[string(chunk[i:i+5])++ I.e. you don't need to "check if that string is in the map", if a map key doesn't existing the default value (0 for ints) is returned so `m[key]++` will set non-existing keys to 1 and increment existing keys.
How do you imagine that to work? You want to draw a polygon and you want it to crop the outer points as a square and color/transparent everything outside the polygon?
I strongly agree! My programming skills skyrocket when I began to develop Android Apps with Java because of the graphical and interactive aspects of it which made it very funny to program everyday! 
As for configuration goes I‚Äôd suggest using a config file along with a UI. If the config file exists then when the UI loads it uses that otherwise shows a UI to create it. Also can modify the config file from the UI. 
You see.. There is no such thing as free lunch. Everything comes with some price and I would highly suggest you to pay that price and consider it as an investment. However, if you are in the learning phase or creating a practice project for some university, institute, etc. Then, you can opt for firebase, or a hosting provider like 000webhost etc. One can add many more to the list but I have personally used these hosts and I really enjoyed their service. 
The cost has been lowered quite a bit since that issue was raised and note that: func (x *T) foo1() { x.mu.Lock() x.work() x.mu.Unlock() } func (x *T) foo2() { x.mu.Lock() defer x.mu.Unlock() x.work() } will have different semantics if `x.work()` can panic. 
It's gotten better, but the benchmark I linked to was from last year, and I don't know if there's been any improvements to `defer` in the meantime. But yeah, there's caveats to not `defer`ing the unlock. One is that if you're doing anything that might panic, you more or less need it, but I figured this'd be obvious enough not to mention.
&gt; Would be better to make the unlock a defer at the beginning of the function, and this way, it will be called when the function exits, which is the correct time to unlock the mutex in these cases. Would it still be possible to have a race condition using this method (assuming you didn't copy the value)?
Makes sense. Would modifying a config file directly pose any problems to you?
I don't think its embeddable but we use [https://github.com/containous/traefik](https://github.com/containous/traefik). I use http, https, secure websockets with it with no issues.
It depends on what you implement but even basic JWT Tokens can get pretty big. So you will end up transmitting a lot of data. That might be a bigger drag on performance than validating the token. I don't know what you are trying to do but could you batch up the requests into a single payload?
Awesome work!
Thanks!
No
Thanks for sharing! I was trying to decrease number of chunks by increasing singe chunk size but unfortunately nothing changes so I checked multipart package source code and found out that peek buffer size is set as constant to 4096 is any way of increasing this?
That's not how you get the referral. 
is there a video
If I am reading https://blog.golang.org/defer-panic-and-recover correctly I believe the return statement is evaluated completely before the defers start, so a copy of the value is returned before the unlock happens.
Yes. That's what Clean Architecture provides. The API exposes a set of structs. The controller maps those into the Use Case Input. The Input provides all of the needed values for doing things. For example, the input might have a set of changed data of a Profile. The API takes a JSON Patch set ([http://jsonpatch.com/](http://jsonpatch.com/)). You transform this however you see fit into the Input. Within the Use Case you modify the underlying models. The Presenter gets an output. The output might have a set of validation Errors. It can have a success flag. Whatever you send the Presenter needs to be enough for the RestPresenter to create the proper, coded response.
The UI would presumably save settings to a file anyway, right? It seems to me that you're going to need to implement that part regardless, and after that point you can decide whether or not you want to put a GUI on top of it. You should also consider whether a library like [https://github.com/spf13/viper](https://github.com/spf13/viper) fits your needs. It has a lot of nice features that I would want in a configuration system, like overriding config file entries with environment variables.
Oh and worth a mention. I have received infinitely more help on here than I ever did on stack overflow 