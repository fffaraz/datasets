AFAIK, time.Duration is not int, but (maybe) uint64?
`continue` is the preferred thing to use, but technically speaking, `goto` can be used as well: for range expr { ... if cond { goto next } ... next: }
&gt; You don't even have a preprocessor. Yeah, I really "miss" working with C code that use macros so clever that only the author has an idea what/how the code works. So you grab the preprocessor to the rescue, but now the expanded code is several orders of magnitude longer. Not even mentioning the now "pure" C code that the macros generate is a completely incomprehensible mess again. Been there, done that. Thanks but, no thanks. BTW: Go is close enough to C syntax that `cpp` should probably work for you in many, if not most cases, if you really want that. But then again, I don't want to ever have to read/understand your code written mostly in "clever" macros. And did I mention that generics have the very same problem?
You have to indent every code line here with four spaces for reddit to format it properly and leave a newline between code and non-code, just so you know. 1. // String adds indentation to every written line and returns them all as a string. 2. Only tried it on Darwin but that sounds weird yes. 3. A config file can be malformed, making it invalid json. 5. Yes this prints every error. But you do not have to print it, you can just return the body as is if you fail to read the file instead of printing and exiting. bodyFile, err := os.Open(body) // if we os.Open returns an error then handle it if err != nil { fmt.Println(err) os.Exit(1) }
&gt; Except that often people then try to cast back to some other type and hope for the best. This undermines everything and is basically a big backdoor in the type system Not as big as you make it out to be, since a dynamically typed Python function that expects an integer, and will throw an exception when, say, a list is passed in, is also guilty of this. But you are correct in saying that this is a problem, and that people shouldn't do this. &gt; when you can't express what you actually want. When you can't express what you actually want, the best solution is to not do what you are trying to do. People have been programming in C perfectly adequately, without generics. &gt; Well, concurrency isn't a "structure" it's a property of the execution model. That's like saying "OOP isn't a structure, it's a propriety of the type system". Concurent is totally a structure. The structure is independently executing routines, each solving problems in a pipeline (or a more complex arrangement). This can be compared to classical OOP style, where tasks are divided up into classes, and then arranged in a hierarchy. &gt; A mount stupid perspective might be that Windows has no useful place in the world, for example. If you're referring to me, I didn't say that. Only that Windows is closer to Unix then to, say, a Lisp Machine. In any case, "mount stupid" is a term that describes itself.
&gt;&gt; You don't even have a preprocessor. &gt; &gt;Yeah, I really "miss" working with C code that use macros so clever that only the author has an idea what/how the code works. And in what way is one's form of poor usage of a feature an indication that it is bad in general? &gt;So you grab the preprocessor to the rescue, but now the expanded code is several orders of magnitude longer. What's the difference between that and the assembly being generated by your Go compiler? The macro is designed to solve a problem, and the work needed to make it correct is far less than implementing a complete AST transform pipeline that leads to a primitive ISA generation. And even *that* isn't difficult to get right. &gt; Not even mentioning the now "pure" C code that the macros generate is a completely incomprehensible mess again. It's trivially deduced. Are you unaware of what the operational semantics that the code performs and the role it plays? Then you clearly shouldn't be programming. &gt; &gt;Been there, done that. Thanks but, no thanks. BTW: Go is close enough to C syntax that `cpp` should probably work for you in many, if not most cases, if you really want that. And why would I hack on some 90% correct parser through cpp just to use an already crippled language when I could use C++? &gt;But then again, I don't want to ever have to read/understand your code written mostly in "clever" macros. Look at the little monkey thinking macros are clever! Tell me, monkey: do you feel good that you've eaten dog food sold to you thar's shit? &gt;And did I mention that generics have the very same problem? Generics are barely even a metaprogramming.
Strange behavior of code, because on PC i see this formatted right.
Odd you say it, i have it exactly the same way, for some odd reason it sometimes reminds me when i started programming as a child, am not exactly sure if its the syntax which feels like being back at c (which i loved) or maybe and i think its probably here for me, its less of an object-oriented pyramid which makes code super easy to read. It has become my tooling language per default now, still not an expert in any way but done a few production services already and a range of small tools to help my daily life.
Yep pretty weird. Maybe it's about WebKit not working correctly (darwin and all): https://ibb.co/ZfnRX5G
like this ? : https://i.imgur.com/cPPpq2H.png
Ok
ah ... just realized even i got it working i might not want it as im running autosave - that could make one crazy if it cleans those up so maybe just have to keep it the way im doing now :) but would it be possible in VSC to run goimports on run/debug only ?
I've been using golang for the past few years and the majority of the third party libraries I had a chance to use have more than a decent documentation, though, I agree, some libraries could still improve. What's more, from my observations of this community I can say that go developers are really obsessed with a readable and beautiful code, which also applies to comments/documentation. For example, general [guideline](https://github.com/golang/go/wiki/CodeReviewComments#comment-sentences) is that you have to write comments in full sentences in order for them to appear properly in the docs. Some plugins even try to enforce proper commenting style (e.g. vs-code go plugin). Go 1.0 was released in 2012 and it's wider adoption started a bit later, which means the whole community is only budding (imo it's already good, not sure what more we could expect). And besides, python wasn't a very popular language up until maybe 2004, which is 13 years after the initial release, so give golang more time and you'll see even better results.
Can you share a link to this language?
I quickly pushed what I had so far, which is almost nothing but here it goes: https://github.com/dstpierre/exp-mltogo
&gt; PS Algebraic/variadic/sum types would save me much more time than `try` in this particular task I am doing. How so? Just asking because when they are usually mentioned in this context, it's to push `Maybe a` or `Either a b`, which in this case would probably rather increase the error handling boiler-plate. Unless you *also* add some sort of macro (like rusts `?` which seems largely identical in amount of addition to the language and amount of effort saved) or pretty powerful generics (so that you can use Monads). So I'm curious how else sum types would help you :)
tbh not sure why people are downvoting you so hard. I don‚Äôt think you were calling anyone stupid.
&gt; What's the difference between that and the assembly being generated by your Go compiler? The compiler can provide better error case diagnostics on what went wrong than C macros. That means most programmers do not need to have intimate knowledge of how the compilation process works to figure out what they did wrong. The Go compiler sees more use and testing than most custom C macros in the wild do. That means fewer users of the Go compiler will need to debug it than users of said macros will need to debug them.
Is this a repost? * "Download app?" * Popups... * Youtube ad landingpage No thank you
Thanks for pointing out mage. I think this will be valuable for the readers of my post. May I kindly ask you to drop your comment at the end of the article. This would be great.
RIP.
Reading [Constants - The Go Blog](https://blog.golang.org/constants) should help clear things up.
I don't implement functions that can take any type. Normally I take a concrete type or a type that meets an interface and return a concrete type. I don't think many people do, it's just a cleaner way to code I guess.
For me, writing Go code is oddly satisfying. I think some of it is due to the inherent simplicity of the language: it gets out of my way, and since I'm not coding Go 8 hrs/day switching my brain back to it takes less time. Also, at least comparing with the experience of coding Python or PHP, the strict typing and errors as values makes me more comfortable that my code is robust.
"What did you expect to see? No Google logo What did you see instead? A Google logo" üòÑüòÑ
It was only a matter of time.
Go is so simple and the standard library so rich that no one needs to ask StackOverflow for answers.
Didn't mean errors. Tree nodes are easy with variative types. There're two methods to deal with the lack of them in Go: 1. Visitor pattern. Terrible, hard to observe approach for such a simple task. 2. interface with private method and type casting ‚Äì I chose this way. Still lots of boilerplate. Much more than these `if err != nil { return err }`. PS Rust error handling is horrible. Safer than Go's, but definitely much more annoying to deal with.
To be fair, I've met quite a lot of people who claimed "Golang" is the official name because it means "Google Language" ü§®
What's wrong with Jira?
Python and JavaScript are used a lot by very early beginners who don‚Äôt know how to search the docs. Most go developers have some experience when they start so they aren‚Äôt as dependent on SO. As far as third party modules, anything made by random people are bound to have some badly documented projects. For python and JS things like that get weeded out quickly because the users are much more numerous and people are much more dependent on third party libraries to get stuff done. On the other hand, go strong standard library makes it so the need for third party libraries is much less, So less need for people to write extensive documentation for their tools
I think it's a good idea, meet too many devs who think it's called go cause Google
I don't understand all this us vs them mentality here. Yes, Go is open source and yes there are a lot of contributors but the lion share of it's development came and still does come from Google.
Is it still possible to order them?
&gt; I don't think many people do Plenty of people do. Searching GitHub will show you that. &gt;it's just a cleaner way to code I guess. Yes, *in Go*. In languages that support type-level polymorphism it's "cleaner" not to reimplement the function for every type you'd use it on, or not to give up compile time type checking altogether by don't the equivalent of casting a void*. If generics land in Go and aren't horribly crippled, people will start naturally using them in many places that would otherwise be empty Interface and no one is going to argue that they make simple problems complex. Some people will argue that they make complex problems *possible*, but that's not really a downside. You'll always be free to avoid the feature. When you start seeing people using generics for everything because "it's a formally equivalent zero-cost abstraction so I just make all my function arguments generic by default!" then I think we can say that people are standing atop "mount stupid."
I think it's because totally when anyone here says something that isn't just cheerleading Go, they aren't really trying to be constructive either. The whole sub has an automatic downvote reaction after years of dealing with posts like "lol no generics"
I can see this as being pretty handy in a pipeline (validate ServiceMonitor's are there etc).. Will deffo give it a whirl thanks
I agree, but with the projects written in Go I don't think it's quite as hopeless without a Google logo. Go is killing it in the virtualization and micro services world: - docker - kubernetes - NATS - consul - go-micro - etcd - tidb - terraform - helm Not to mention the [+14,000 other Go projects](https://github.com/search?l=Go&amp;q=web&amp;type=Repositories) on github alone.
I have researched a lot of these tools fairly broadly and reasonably deeply for work. I think you need to be clearer about what you are trying to achieve before anyone can say if Argo is useful for you.
Kubernetes is baked deeply into Argo workflows, and everything about Argo workflows is about kubernetes resources. If you aren't using and needing kubernetes, I'd say look at something else. If you do press forward, you'll want to learn kubernetes first as it will help with understanding Argo workflows. Argo workflows is all I've played with, so I can't speak to Argo cd or events.
&gt;&gt; Except that often people then try to cast back to some other type and hope for the best. This undermines everything and is basically a big backdoor in the type system &gt; &gt;Not as big as you make it out to be, since a dynamically typed Python function that expects an integer, and will throw an exception when, say, a list is passed in, is also guilty of this. Yes. Python has literally zero compile time type checking. A lot of effort has been put in to add it because it is so valuable, See the mypy project and pep 484. &gt; &gt;But you are correct in saying that this is a problem, and that people shouldn't do this. &gt; &gt;&gt; when you can't express what you actually want. &gt; &gt;When you can't express what you actually want, the best solution is to not do what you are trying to do. If the alternative is using unsafe language tricks to approximate it, then maybe. In *general* though? I'm sorry but no. That is the [blubbiest](http://www.paulgraham.com/avg.html) answer I've ever seen anyone unironically give. You might decide that you don't want people to try to do whatever it is that they are doing because you don't trust them. Fine. You might even say, "I could enforce that no one tries anything that would confuse a junior dev by using a language that just can't express those things," which is basically what happened with Go, according to the creators, but if you want that then you're optimising for a different problem. It's not like the idea you wanted to express via the type system is somehow wrong just because a junior wouldn't have tried. &gt; People have been programming in C perfectly adequately, without generics. What? No. They just fake it with void* and casting or try to implement the entire function as a macro. The type system in C is very weak. When people need to do something that it can't handle, they basically just leave it behind. &gt; Concurent is totally a structure. The structure is independently executing routines, each solving problems in a pipeline (or a more complex arrangement). I think what you're describing is usually called the [actor model](https://en.m.wikipedia.org/wiki/Actor_model). Concurrency isn't a model, it's a description of what is happening. The same way "rioting" isn't a political system but anarchy is and "domestic abuse" isn't a social system but patriarchy is, etc. &gt; This can be compared to classical OOP style, where tasks are divided up into classes, and then arranged in a hierarchy. Again I think the comparison is between classes that encapsulate some behavior and *actors* that work together to achieve some behavior. Go implements the latter nicely via goroutines. &gt;If you're referring to me, I didn't say that. Only that Windows is closer to Unix then to, say, a Lisp Machine. I wasn't. I was trying to give an example of "mount stupid" statement you might hear from someone who is learning to use Linux. &gt;In any case, "mount stupid" is a term that describes itself. Yes. Learning about "mount stupid" is surely subject to the same problem as everything else, namely, mount stupid.
Desktop link: https://en.wikipedia.org/wiki/Actor_model *** ^^/r/HelperBot_ ^^Downvote ^^to ^^remove. ^^Counter: ^^267875. [^^Found ^^a ^^bug?](https://reddit.com/message/compose/?to=swim1929&amp;subject=Bug&amp;message=https://reddit.com/r/golang/comments/ccb4z3/coding_in_golang_relaxes_me/etolbo4/)
 &gt;I think a less pessimistic way of viewing this is the following : less than or around 1% of the code uses Python-like dynamic typing (but with explicitly stated casting), and the rest is strongly-(statically)-typed code. Where did 1% come from?
I was quite surprised to see the Google logo on the new design. Doesn‚Äôt really add up with recent stories ensuring Go was not serving just Google.
That may very well be the case. Generics don't solve all problems. I think the uses that you do point out highlights an interesting property though. The need for good abstraction isn't too strong at the leaf nodes of a program when you're writing application code that "gets things done." When you're writing libraries that need to work in multiple contexts that you don't know in advance, solid abstractions become much more valuable. Logging is a good example of this. Taken to the extreme you get Go's standard library itself, where it proves to be so valuable that "generics" got hardwired in, despite there being no language support.
Blue personality?
Seems right to me. More likely thag than &gt; GO = Gangus Orangutan
Some people just want to see 'supported by Google' but how about 'created by Google'? I don't think it's fair to treat Google as 'just another contributor'. They really did design and create the language before releasing it to the world. If Google did not put in all that time and effort in inventing the language it would not exist today. I think they've earned a small logo in the bottom right of the website.
How do you know they *wasn't* part of the reasoning behind the language?
Lol. Ranting at me about how I don't own the world and then telling *me* to relax. Come on. I'm not calling anyone stupid. Mount stupid is not a new concept and I think that learning enough about Interface{} to think it is a substitute for generics and then declaring that generics are pointless, as many seem to do, is a good example of it. Oh, and relax.
Assuming Get works like a conventional map accessor, it is unlikely that the ignored value is an error.
I'm saying that when you reach the point in your career where you start unironically golfing with language features rather than doing the obvious, you're probably on mount stupid. I wish it didn't sound like such a slap in the face. I didn't mean it as an insult. Everyone follows the same path, more or less. You will probably look back at your code in a few years and think "why the f*ck was I doing this instead of just writing a helper function?" We all do.
&gt;Hmmm I would put it another way that is, perhaps not as insulting or insinuating. Yes, in retrospect this was not a tactful way to introduce mount stupid to folks who have not heard of it before. Your interpretation is a good one.
I find that unless they host some godocs and really document their code, the readme on github only ever has a few typical examples. Stretchr/testify is a paragon of good documentation in my eyes because of it. Spf13/cobra leaves a lot to be desired, documentation-wise.
Then why return an empty string if it doesn‚Äôt exist instead of a string and a bool?
Usually in web servers you check for empty strings explicitly anyway. It‚Äôs pretty common to have an empty query parameter in a URL.
Yes sir/madam. Short story: that day, Thompson, Pike and Griesemer, while looking at the various programming languages, decided to pick a few ingredients for their recipe... Eventually, generics were ditched for reasons. End of the story. &amp;#x200B; Eventually one day you'll grow up and understand the paradox of adding generics (and other things you're muttering) to a language that has a well defined philosophy who tackle the common practices of other PL and those who blabber about them, and that this philosopy has been choosed by many folks exactly for this, regardless of what the blabbers think o pretend to know about the whole thing. &amp;#x200B; &gt;Lol. Ranting at me about how I don't own the world and then telling *me* to relax. Come on. &amp;#x200B; [I'll make it more simple.](http://culture.affinitymagazine.us/wp-content/uploads/2017/04/991e7f2a2ca2b516134dd032248af5c4.jpg)
Didn‚Äôt downvote but I think the negative response is from making an equivalence of leveraging a language with maintaining the language.
Are you looking for ops or dev?
&gt;&gt; What's the difference between that and the assembly being generated by your Go compiler? &gt; &gt;The compiler can provide better error case diagnostics on what went wrong than C macros. That means most programmers do not need to have intimate knowledge of how the compilation process works to figure out what they did wrong. There is no "intimate knowledge" of the compilation process for C macros. It's dead simple. &gt; &gt;The Go compiler sees more use and testing than most custom C macros in the wild do. That means fewer users of the Go compiler will need to debug it than users of said macros will need to debug them. Are you slow or something? The Go compiler is also meant to support a wide variety of different platforms and configurations; it as a whole is a large project. A macro is a small, distinct *portion* of a project and is *trivial* to debug. Of course, if you're incapable of thinking in terms of abstract symbols being tied to a type system, it more or less means you know absolutely nothing about PLT sufficient to comment anything worthwhile. I'm not even an advocate for the raw preprocessor, but it *is* better than nothing.
Then there‚Äôs a clear difference between ‚ÄûParameter does not exist‚Äú and ‚ÄûParameter is the empty string‚Äú...
Ah, that makes sense. In context, I haven't seen the actual Go language maintenance as the work of a few people, more like a few dozen. There are over a [hundred people who have contributed over a thousand lines of code to Go](https://github.com/golang/go/graphs/contributors)
Dev.
This is ridiculous guys, perhaps we have better things to do? I don't think antagonizing the Go team with borderline troll issues is the best thing we can do. And they have discussed this claim multiple times. Yet it feels like every once in a while somebody wants to light the fire again. I'm sure we can do better.
Jesus Christ. Get ahold of yourself.
üëç
That‚Äôs fair. I don‚Äôt really have a strong opinion but I can see the point of both sides. Ultimately, I think at the surface it‚Äôs a fair compromise. The logo happens to be there in appreciation for the hosting and ongoing investment but if you look at the project page they quickly acknowledge and list all contributors.
"reasons" https://news.ycombinator.com/item?id=16143918
üëå
fucking amazing
ü§ô
Mozilla is scared, people prefer Go over Rust, hahaha
Even spending 10x more S3 space to store your Go function, the gain on RAM consumption is mind blowing, something like 6x. Considering S3 vs Lambda costs, I choose S3 and Go package
Mostly for data ETL. Data source -&gt; Transform -&gt; Transform -&gt; etc... A DAG sort of workflow similar to Airflow.
I don't know kubernetes :-) Thanks for the candid response
Tangential, but I did a double take when I first saw this product, since it's a workflow engine where each unit is a container. Because so is Google Cloud Build, which uses the internal code name "Argo" for its execution engine.
Very interesting, mind sharing your source code?
I personally have no issue with the logo. But, I think the "this is what Google said, and that's it" attitude of the first comment (and immediately closing the issue) is indicative of a bigger problem. If Go was truly an open project, that discussion that was discussed would have been in the open, not behind closed doors. But it wasn't. Once again, a decision was made behind closed doors, and the community was informed of the decision. There is nothing "open" about that. And, this isn't the first time that's happened. Modules was very similar situation. The community was working on a solution. Then the Go team (lead by Russ) presented a completely different solution and said, "thanks for your try, but we are going this way." I tend to agree with those that say that Go is not an open project. That's not necessarily a bad thing. But stop trying to hide behind a label. Just my opinion...
What database were you using? Or no DB at all?
Why not something like Cloud Dataflow on GCP?
that's because go is compiled and statically typed
As an aside, are you using https://github.com/apex/up or https://zeit.co/now for deployments?
The size differences are also a bit deceptive. In terms of costs it doesn't matter, but the node app isn't including the ndoe runtime (afaik) and therefore there is a several MB binary someplace on disk, while the go one includes its runtime and is therefore self sufficent. `32M /usr/local/Cellar/node/12.3.1/bin/node`
Read about personality types. There are many different ways to split up personalities but the simplest is the four colors red, yellow, green and blue. Some studies switch place for green and blue unfortunantly so it's hard to know what I mean with "blue". But look here, this is the colors I was thinking of: http://www.thefitrepreneur.com/4-main-personality-types/
Where is it you‚Äôre trying to avoid installing Go? In the container or on your host?
`package main` `var x int32 = -1` `func main() {` `if x != -1 {` `panic("oh no")` `}` `if x &gt; 0 || x != -1 {` `panic("oh no #golang")` `}` `}` will panic with "oh no [\#golang](https://twitter.com/hashtag/golang?src=hashtag_click) ".
Explanation? What‚Äôs happening under the hood?
Confirmed on go 1.12.6. No need for the second if operand: if x != -1 { panic("foo") } if x &gt; 0 { panic("bar") } Will panic with "bar". If you add `fmt` or other things, it seems to work fine.
Most of the Go package size is probably debug symbols. You could strip them out if you cared.
yep, if it comes to APIs (or anything web related really) GO just shines.
Seems a bit reductionist but I always find these types of things fun.
On my host machine. I'm using docker so there's no need for it üê≥
guessing its the host, just wondering why? especialy since all you need to do is exctracting go and setting up 2 system vars
Actually because around 1% of the lines in the 17KLOC application I mentioned in a previous reply rely on a kinda-dynamic typing. The exact percentage may of course vary, in particular it can be greater for base libraries, as you said above. The point is, for most application code and libraries for specific use-cases ‚Äîwhich probably is what most people do‚Äî, it's a small percentage.
[https://github.com/golang/go/blob/master/src/cmd/compile/internal/ssa/prove.go#L571](https://github.com/golang/go/blob/master/src/cmd/compile/internal/ssa/prove.go#L571) before change // Check if the recorded limits can prove that the value is positive if l, has := ft.limits[v.ID]; has &amp;&amp; (l.min &gt;= 0 || l.umax &lt;= math.MaxInt64) { The l.umax &lt;= math.MaxInt64 check doesn't make sense for int8, int16, or int32, because they still have negative values whose unsigned representation is less than MaxInt64. ref: [https://github.com/golang/go/issues/32560#issuecomment-501096728](https://github.com/golang/go/issues/32560#issuecomment-501096728)
1.12.4 I‚Äôm good, it works
Out of interest, mind sharing debugging results? What is happening?
honestly, install it on your host! you would have to setup a custom and probably complex docker container for that anyway while gaining zero advantage. its probably easier to just download a existing docker go container and copy vim-go into it than the other way arround.
I wonder if the binary size could be reduced by using ‚Äò-buildmode=shared‚Äô for the stdlib. It would be nice if lambda provided this.
astonishing to see people pushing using a framework just because, even to the demerit of their knowledge. Then you have on the other side people acting as in frameworks are the devil because it abstracts a bunch, guess what? even stdlib http does a crazy amount of abstraction over tcp connections. this might be shocking but the stdlib is also code written by humans. The worst tho is the sentiment of ‚Äúgo doesnt have this library so its bad‚Äù, just build it yourself? you might learn a thing or two.
I think most of the binary size is the Go runtime and whatever bits of the stdlib that are being statically linked.
\`modules\` is the officially sanctioned dependency management tool. Use it unless something specific about your situation invalidates it.
I didnt debug too far. I was curious if the first if-statement somehow changed the value of x before the second if. But adding an `fmt.Println` changed the result and it didnt throw a panic anymore. You need two consecutive ifs like shown above to trigger the bug.
chack
You can shrink binary size by `strip`'ping it and then `upx --lzma`'ing! In a side project I've been working on I'm using gocolly. The raw binary is about 15M, after strip and upx it weights about 3M.
Both are fine, when‚Äôs the last time 10ms bothered anyone? Lambda wouldn‚Äôt make sense for hyper-sensitive latency stuff anyway
(Disclaimer: my own opinion but I work on Lambda) How are you measuring duration with respect to "with cold start"? If you are using max duration, this is measured at the start of your function code. The overhead of downloading your code is not factored in to those metrics. The order of magnitude code size isn't free (though might be negligible around 3mb). Best way to measure that is either: API gateway, or measuring from the client you are testing with. I personally test with timings using httptrace: https://blog.golang.org/http-tracing and ignore DNS, and handshake timings (for these specific tests).
Can‚Äôt find the link but in some doc they say the name is because Google starts with Go and Ogle would be a good name for a Go debug function.
Indeed I already tested it, using Lambda Layers. But in this case I didn't measure the package size and cold start times. I'll!
I‚Äôm down
There's 2 databases actually. The administrative part uses DynamoDB, as I don't need strong relationships and constant access (IMHO the Dynamo cost formula is a money killer) The final user part, uses PostgreSQL on RDS. (I'm thinking in give a try on Aurora Serverless, since for now the usage won't be huge and this can help me save some money)
This is so illogical and unfair. Who the hell do he think that is paying captain Pike's salary?
I think both languages have their spaces. But considering that for a single read operation node took almost half available RAM (considering the smallest config) it scares me a little.
I'm using Serverless
I'm always considering the time from the beginning to the end of the response. Package size need to be considered on a cold start since it need to be "downloaded" to lambda environment
Binary size initially turned me off of colly, but then I learned this. It really is a great library.
This doesn't answer my question.
Electron? Seriously? It's beyond bloated and absolute shit.
Why? The Node runtime has a different garbage collector and works differently. Node generally aggressively allocates and only frees when needed. Yes, Node will probably use more memory with two bug free implementations, but hardware is cheap. Your two Lambdas are going to cost the exact same amount because AWS bills in 100ms intervals.
One flaw in C related languages is that the rules for when what type converts to what are subtle and frequently lead to bugs. Go fixed that by making numeric operations on variables require explicit type conversions, but numeric operations on constants are loosely typed, like in C, so you can write `5 * time.Second` instead of `time.Duration(5) * time.Second` which is the explicit version.
JetBrains products are best on the market. They are like mac of IDE, easy with great ux and features. Last time when i tried to write something in language that i dont know (c#) i was confused with visual studio, few minutes later i just downloaded resharper and it was just better experience. With GOland is same, jetbrains products are different league.
Code looks simple and easy to understand. I was able to see how it works in seconds. That's good, kudos.
Some of us read this as South Dakota...
In this specific case I agree. But it's just a starting point
Maybe it's just me, but in services I'd expect packages and would have a cmd dir with the different commands under it. Besides that, like the other comment says: easy to read.
Totally agree. Not sure what's going on in the go community... I have the feeling that it goes from one big happy family towards some family crisis. üòí Let's just celebrate that it's popular and a joy to code in üçæü•Ç and cheers to Google and all the contributors for making that happen ‚ù§Ô∏è
The ‚Äúonly‚Äù one to use is the official Go Modules: https://blog.golang.org/using-go-modules
Surely nobody is going to notice the 8 ms difference, but that's a mootpoint you're making. If you're running a server at full capacity (let's assume for arguments sake), then a 5-fold decreased server load WILL have a major impact. Basically cutting costs by 80%, so I'm not sure why you're so dismissive of this performance difference. Every ms counts if scaled large enough.
Project dep didn‚Äôt satisfy the requirement of repeatable builds.
Yeah if it‚Äôs cpu bound for sure, but you‚Äôd never use Lambda in that case either haha, unless you want a veryyyyy hefty bill, not using Lambda would save you far more than using Go over Node
"vgo" was the prototype name for module support before it officially landed in the standard tooling.
You'd get the answer quicker if you googled for it yourself.
Bad code can be written with _any_ language.
Have you considered you might be part of a cult?
Hi! I'm the author of [Pixel](https://github.com/faiface/pixel), which I think is a pretty good 2D game library. It offers sprite-based graphics, primitive shape graphics, all kinds of input, optimizations like batching, and even shaders. Audio is supported through a separate [Beep](https://github.com/faiface/beep) library. Another great library to check out is [Ebiten](https://github.com/hajimehoshi/ebiten) which is a simpler and easier to use library, but offers fewer features. However, if you don't need the extra featurs, then I'd say the design of Ebiten is cleaner than that of Pixel and you'll have a great time using it.
Thanks for the info - I will check both of them out :)
Forgot to mention, one thing that Ebiten has and Pixel doesn't is mobile support. Ebiten has actually been used to develop a few mobile games.
How did you search interface {} on GitHub? I must be missing a trick as it shows any use of just the word and discards the parens? Either way, complaining against it being a cleaner way to write code in Go seems silly. It's how you _should_ write Go, if you abuse interface{} then you pay the reflection tax. Generics won't solve poor coding choices.
I suppose embracing stockholm syndrom can be relaxing.
So you are measuring this client side?
Throw some basic unit tests on that bitch
https://github.com/avelino/awesome-go/blob/master/README.md#game-development
I've been looking a different solutions for an upcoming project around event handling, FaaS, and workflows. Argo sounds like it is similar to a workflow engine I was looking at (https://zeebe.io/). While zeebe provides a standardised way to model workflows and integrated UIs, they use an approach of treating each step in the workflow as a "service" and then making the workers use a pull mechanism. They must connect as a client under the service and facilitate the service tasks. On one hand this makes the deployment solution of workers agnostic of K8s. But on the other hand it doesn't solve something like scale-to-zero FaaS functions since the workers are external and pull. Argo looks to execute every step directly as a container, which would allow it to be aware of cold/hot instances. They use yaml instead of BPMN to model workflows. But Argo does have a large variety of event source handlers (Kafka, Nats, and Amqp being most interesting to me). Curious if anyone has an opinion on the application for an event workflow pipeline that aims to provide FaaS style handlers as a high level interface to developers.
My experience with cold start and Node.js is that it‚Äôs mostly caused by disk I/O. While launching a Go app requires reading one binary only, loading a Node.js requires reading possibly thousands of small files, and the slowdown is mostly caused by the filesystem and disk.
Ah OK, thats pretty good then. In my observations, the speed of an application is highly depending on the db and the connection, so thats a big plus on your case.
If you `import "fmt"` go imports every single function weather they're used or not which leads to a lot of bloat. Stripping everything you can + UPX is huge.
Money is like, just a concept man.
I didn't say I thought `dep` was better. It was the _way_ that it went down.
S3 is insanely cheap and basically free at the sizes you are talking about (and irrelevant once you factor in developer cost which is where a good chunk of your cost is).
I disagree with their having the decisions made behind closed doors, but I don't disagree with deviating from dep and lockfiles. The amount of suffering I incur on a monthly basis managing my orgs Ruby gems alone had me praising their decision to go for a novel approach. I welcome ideological diversity.
Optimization failure?
(Besides the fact that most apps people build will never reach the scale of a site like Reddit...) If you're building Reddit and aren't using a microservices-based architecture, you're doing it wrong ;)
Where is the label that says Go is '**truly open project**'? Or it has open governance or any such thing? All I see on Go home page is **Go is an open source programming language.** And this is true. People who are clamoring for 'Open governance', 'true open project' or 'open foundation' etc need to put money where their mouth is.
Interesting idea. How do you do it for a whole Go Module?
Can you share the source code?
What IDE do you use for Go?
It does not. Global functions are not part of the structures. You can run it on a folder by adding the `-recursive` argument before the folder. However, this will only work with structures, interfaces, and their functions. &amp;#x200B; Running it recursively within a folder will fine the relationship among the structures in the different packages. For example, it will find that a structure implements a specific interface. Or that a structure is directly composed of another structure.
I agree
I have tried with larger projects. Although when the project is too big the generated graph might stop being useful as there might be tons of relationships between the structures (i.e. too many lines). I'm sure ti will run with the standard library, but it would be a huge diagram. I am glad you see more value to it. Any suggestions? I designed it as as a UML Class diagram generator, but I wouldn't mind it if it turns into something more useful. &amp;#x200B; I do agree it does shows a nice overview of the projects.
Just google what that is ... lol
I'm not qualified to answer your questions but I'll drop some thoughts here. &gt; What do you guys think, should I implement this future ? I haven't looked at your code but I think this is a question you should field with your users. If you have no use for it and your user's don't either, maybe it's not worth implementing? What kind of expectations do they have from the library? &gt; Is it useful ? This is entirely dependent upon application requirements. There are many cases where waiting on client acks is useful and many cases where it's irrelevant.
K*s is developed by fascists.
Of course it is, so is goto compared to structural statements, but contexts make code more readable it is also cleaner when you have to do the correct thing. For example how many go programmers actually check result when closing a file? Even tutorials don't show that, when in reality return code from close ensures the file was written correctly. To handle it with defer it is several lines of code and looks ugly. With contexts in Python either context can handle it automatically (for example issuing rollback when handling database transactions) it will propagate exception or both. Handling things like locks is more robust, there is no way to forget to unlock a lock, while you can forget defer. You also mentioned preformance, go routines and channels. First of all, pretty much all languages (including Python) have channels they just call them queues. Go routines were hyped a lot when go was released, but after years it looks like they aren't panacea for multi threaded programming, they only handle subset of problems and you still can get into usual issues with threading, not to mention that every go routines can access and modify memory of another of you are not careful. As for preformance, yes go is faster, but in most cases you don't need it, the bottleneck is usually in other places. Python is meant to implement business logic and components that supposed to perform fast can be optimized using Cython, Nuitka and others.
Well, I just share an experience that I thought was good and worth it. Systems starts small, but if you neglect even the smallest cost this can become a painful issue in the future.
VS Code
Not considering any extra cost on browsers or rendering. Just a simple http call.
I don't think there are any other users than me so far, it is fresh thing, I don't think many ppl know about my project. Myself I don't rly need that future for my use case, however I was looking for something to do in my spare time, and found google's pubsub has something like it. Therefore I figured maybe I could implement it as well.
Hmm?
In the name of learning I say go for it.
The thing is that executable size and ram usage does not scale linearly. Each tech stack has a base size then anything added only adds a little to that base size. As far as startup time, if you actually had any real activity the lambda will stay hot and have zero startup time.
Google works for the surveillance state across North America, Europe, Australia, and China.
We've put up a late pledge on our website if you're still interested, the link is [https://thegrumpyunicorn.co/products/greg-the-go-gopher-late-pledge](https://thegrumpyunicorn.co/products/greg-the-go-gopher-late-pledge). :)
We've put up a late pledge on our website if you're still interested, the link is [https://thegrumpyunicorn.co/products/greg-the-go-gopher-late-pledge](https://thegrumpyunicorn.co/products/greg-the-go-gopher-late-pledge). :)
We've put up a late pledge on our website if you're still interested, the link is [https://thegrumpyunicorn.co/products/greg-the-go-gopher-late-pledge](https://thegrumpyunicorn.co/products/greg-the-go-gopher-late-pledge). :)
We've put up a late pledge on our website if you're still interested, the link is [https://thegrumpyunicorn.co/products/greg-the-go-gopher-late-pledge](https://thegrumpyunicorn.co/products/greg-the-go-gopher-late-pledge). :)
We've put up a late pledge on our website if you're still interested, the link is [https://thegrumpyunicorn.co/products/greg-the-go-gopher-late-pledge](https://thegrumpyunicorn.co/products/greg-the-go-gopher-late-pledge). :)
Cool?
Fascist
Good talk.
Thanks for your support! :)
Oh cool, I really like that one! :)
He's my favourite too! :)
Thanks so much! :D
As /u/philipstorry said, we'll send out a survey around late July, where you'll pick your pins and provide an address to ship to. Thanks for your support! :)
Any language can be your entry level language.
Golang has a great community and there is more and more companies using it. Even if some use it for complex stuff, I am pretty sure it is not the majority. Keep in mind that entry level jobs still need a basic understanding of some concepts such as databases and algorithms. So learning Go is clearly a great idea, but I would not focus my energy only on the language. Good luck!
What would you suggest would be a good enough number/type of languages on your resume? Would love to get started quickly, can pick things up very quickly and invest my entire day, but reading posts in the programming subs, I'm very much a newb :)
Hey r/JustAsItSounds can you please take a look at above comment of mine? I'd love to hear more feedback.
I've been a systems programmer for about 20 years. I no longer list fortran or cobol on my resume. I've never listed lisp on my resume even though it is probably one of the most fun languages to use. Knowing the syntax and core libraries of a language is just the beginning. Having deep experience with a significant software systems is probably as important as knowledge of any particular set of languages. Though these days lots of the new stuff is in "code for the web" which probably means javascript, python, php, and one or two of the "hot" frameworks. the otehr side is in "code for infrastructure" which probably means ansible, puppet, salt, chef, docker kubernetes, teraform and a double heaping hand full of other tools. Whatever first language you pick I'd recommend looking at javascript second. Then be ready to OJT on things like bash, awk, ansible, puppet, and a long list of tools, libraries, ide, editors and other utilities.
What could be improve is removing the necessity to run with higher privileges.
Serverless Framework?
To be frank, you're going to be a shit developer if your goal is to pad the resume with many languages. As someone who runs an agency, while it's nice to see all that on someone's resume, it makes me question how well do they actually know each? Is "XXX" something they did for a month and slapped it on paper as "knowledge"? I've been around the bush for programming over my many years... C, Python, Ruby, PHP, Java, Node, Go, etc. In my honest opinion, Go is a great language to get into, it's my honest favourite I've dealt with. You can build small or big with it. It writes clean, looks clean, runs clean. Go will give you the fundamentals of how to think logically, how types work, how they interact. It's a little bit of a untraditional language. What you gain will help you write better code in the next language you tackle and the next. Not only that, type safety seems to be a hit the last couple years... it's "coming back" because it's beneficial. Languages like PHP are pushing towards it, people who are heavy into Javascript are taking on Typescript to fill that void, and so fourth.. Go can do both web side and backend side, it's beautiful and has a wealth of built in tools to help you develop (gofmt, gopls, test, etc) and it's documentation is superb! I'd say pick a little idea and try and build it, fail, break it, learn from it and grow.. also follow gobyexample.com it's a great resource to learn.
Overall looks good : congrats! At first glance, I would remove magic numbers/strings everywhere as they should be constants if they are constant or constructor parameters if they are allowed to change.
Looks neat. The name reminds me of Monday, the PM tool. Their ads play all the time in YouTube for me.
That depends on what your goal is. You will always want a language that you can use as your "get shit done" language that you have down cold, but it's important to recognize that languages are tools and different problems sometimes require different tools. Go is not currently designed for very high throughput applications, for example; it has been optimized with low latency in mind. So, keep learning one but don't hesitate to play around with and learn others. After a few languages, you'll have a better grasp of programming in the abstract, and it'll make you a better programmer in every language. Most software engineers can probably use 4+ languages once their careers get rolling. DevOps probably have a general purpose language or two and 2+ scripting languages (bash, Python) under their belt after awhile. For mobile development, it's all about frameworks more than languages, and for game development it's all about engines, but the same ideas apply. The more you learn, the better you'll be at all of them.
&gt;Either way, complaining against it being a cleaner way to write code in Go seems silly. It's how you _should_ write Go, if you abuse interface{} then you pay the reflection tax. Can you elaborate on this? I don't think I understood you.
Yay!
Totally agree with this. My entry language was Python and at my current company we use Go. Picked up both languages at work. Went through a CS degree but the most important thing I‚Äôve learnt from my four years is learning how to learn.
I'm not familiar with these js bindings, but the thing is that in Go, errors are just values. And panics are **really** panics, so that's not an option either. Did you try with [`js.Error`](https://golang.org/pkg/syscall/js/#Error)?
&gt;I'm not familiar with these js bindings, but the thing is that in Go, errors are just values. And panics are really panics, so that's not an option either. I believe the \`js.Error\` type is well suited for letting an existing JS error object satisfy the Go error type, done by wrapping the value.
Number of languages matters next to nothing in the best case, and in the worst case it‚Äôs the thing holding you back from your dream job. I worked for one of the big companies that every engineer wants to work for, and all too often I see people put on the no-recycle list on a rejection for lying on their resume about proficiency. Don‚Äôt put something down that you can‚Äôt be probed about. If you put down something like: Golang, Python, Bash And then have your best and most relevant projects highlighted with a small narrative, that‚Äôs going to go FAR with the people that matter. If you had a narrative like... ‚ÄúWrote tool X in Go which did these basic things (link2repo), and used python and bash to automate deployments, and make and other linux builtins to automagically run tests and builds, that‚Äôs hot. You get more points for doing more projects in the best languages and tools available for those workloads, while maintaining simplicity and maximum customer reach.
I'm not sure if a you can `throw` from Go to JS but you will be able to pass a JS error object from Go to JS. ```go return js.Global().Get("Error").New("error message") ``` Then you can throw the JS error object back in the JS. ```js throw hello() ``` *I wonder if calling `eval` from Go could throw in JS.*
Remove docker from the equation.
I feel like your lib would be more generically useful if you omitted the function requirement. If it's simply a queue with rate limit, where people can Pop() (or similar) from. Everyone can implement a function for handling the item retrieved as they desire outside of the queue object. It's not really the queue's responsibility to do something with the items in it. Thoughts?
Focus on Algorithm, Data Structure, Math, Problem solving skills instead of binding yourself to programming languages and tools...
it's not like it's in any working state, I just started playing with this idea like 1 year ago and never really thought it would become a thing: https://github.com/dstpierre/exp-mltogo
What was your LOC for both these projects?
Hm, I did think about it again, and in my case it's more around 0.1% (less than 20 lines of 17K), I did a misscalculation because probably even I thought it would be more than that :-)
First language isn't terribly important. What is important, is having a few years of experience as a programmer and a little portfolio of \*\*completed\*\* projects. Or a degree. Either way, something to show that you know your way around an editor and can get stuff out the door and into users hands. Languages in that regard is just a tool. And using the plural here, yes, you'll need to know more than just the one. There sadly is no language to rule them all. Certainly Go is quite versatile, but for frontend work better options exist. Hell, even for backend - sometimes other languages make more sense - like C# if targeting Azure as a platform for instance. Short of it being - be versatile. And there are no 'shortcuts'. Unless really lucky, you'll need a few years of experience and results to show to before getting a toe inside the door. Experience is really the keyword here. It'll take a while before things start to click as it were, the pieces start to fit together. But if you stick with it - it will be worth it. Programming is both fun and fascinating. And at times frustrating. But if it were easy, everyone would do it?! :) Go is a good place to start, but it is just the start. Plenty more to learn.
I am pretty sure that when you reach a point where an 8ms optimization has a huge cost impact, you definitely want to move away from lambda.
i agree with that statement so much i ~~could~~ should - print it - pin it - pray in front of it everyday i would also add something for OP: when you become sufficiently proficient as a programmer, languages just become tools, you can switch with some overhead but the core of programming is shared among languages. Yes python doesn't require memory management, the syntax is pretty compared to C and pip makes your life easier but all in all its like comparing a hammer and a screwdriver : they both fit in your hand and you can ~~kill~~ build with them. NB: the only part where I disagree is about JS, unless you want to do web stuff specifically i don't recommend JS, same goes for php. They give you way too much liberty to do bad things without punishing you and you might think you are doing good whilst you are memorising bad practices. ( disclaimer, I would not concider myself a Senior so it might be more beneficial to you to simply follow u/crashorbit insights, he absolutely nailed the overall idea)
PostgreSQL can do NoSQL with JSONB column types
If you're using docker, add vim to install in your dockerfile, along with any plugins like go-vim. Then either make vim your entry point, or make your program the entry point and just use `docker exec` to run vim in the container. I make use of goland to execute from inside a docker container. It does exactly what you're looking for, but it's a professional feature.
as far as i know you can configure vim-go default file .. and remove the gofmt line from the onsave section .. that might solve it
In my area Javascript/React/Express is hot Python as a secondary for scripts rarely as main. Nothing for golang yet..
curious why you aren't enrolled in University and going for a CS degree?
check go binding of raylib... easiest of all and you can focus on your content creation . just have a look of repo , and you will get idea https://github.com/gen2brain/raylib-go
its not doing that or is it? dq, _ := queue.NewDeliveryQueue(MaxMessagesPerSecond, func(item interface{}) { log.Println(item) wg.Done() } his queue uses the function defined there and that could be anything. unless you are talking about the queue function beeing the always the same thing. thats something i would change as well. wg.Add(func() { log.Println(i) wg.Done() }) PS: pseudo code! havent written go in a while
If I understand your question correctly this is my response: You shouldn't expose the port your app is listening on to the outside world, best to have everything come through HTTPS and let NGINX decide which localised port to send the request onto. All you need to do is set up a service to run your ./mygoapp then have NGINX send the request onto whatever port that app is listening on, this means you can setup your firewall correctly and not have to open up many ports to the scary outside world. You are correct that unlike Python you won't need a 3rd party web server like gunicorn or passenger as Go's built in is solid. &amp;#x200B; \`[domain.com/app1\`](https://domain.com/app1`) is preferable to \`domain.com:5000\`
but we are google
Yeah you are correct about not exposing port i forgot that you cant specify that in your domain provider. Also some go frameworks have https support with auto lets encrypt certs so if am correct i should use nginx when i want to server multiple services from one server.
Well yes exactly. In this setup, the queue is a simple "run a function X times with a rate limit". This kind of limits what you can do with this queue. If you'd pass objects into this queue and retrieve them with a rate limit, someone using this queue has endless options.
A load balancer is almost always a good option irrespective of what language you write your web server in because it allows you to horizontally scale easily and adds resiliency
IMO, Go is the one of the best languages to start with. It has found excellent balance between low-level and high-level programming. e.g if you want to do something, you can use standard or 3d-party library and say: "just do this, I don't want to know how will you do this", but if you need to control the process, you can do this as well. This approach allows the programmer to control and optimize that parts of the application that he needs and in the same time quickly bootstrap the app.
Go wasn't my first but it felt like it was. Go is so simple, the hardest concept are interfaces and when you implement that interface tour exercise you gonna feel smart. As ecologists I used most of my time writing scripts or statistical libraries before R come to existence. Go literally made me drop my PhD entrance ideas to try developing for live. Three companies later and a lot of freelancing make me feel accomplished. Go has this vibe of "you can do it".
If you have mobile clients it also helps by absorbing the load of dealing with lots of open sockets with poor connectivity. Go‚Äôs multiplexing is pretty much state of the art, though. The other advantage is that you can do hitless rolling software upgrades, specially if you have a service mesh reverse proxy like Envoy or Traefik: remove the server process from the proxy pool, wait until it has finished serving in-flight requests, restart and put it back in the proxy. No request lost.
Thanks, I like `return js.Global().Get("Error").New("error")`. I can then do a `instanceof Error` check after each call to check and throw the Error type directly in Javascript.
No, you don't need one, and you're better off without one. Even if you get 10k requests/second, many cloud providers have cheap powerful hardware so you can just beef up your server spec instead of spreading out to multiple servers. Even if you do spread out to multiple servers, you don't need a separate load balancer. You can write one in Go.
Setting up auto cert inside your go application is trivial https://godoc.org/golang.org/x/crypto/acme/autocert ``` // you need to provide a directory for autocert, in this example we use `~/certs` var home, _ = os.UserHomeDir() var certsDir = path.Join(home, "certs") // a list of domains that we want to certify for and that can point to our server's IP var domains = []string{"mydomain.com", "myotherdomain.org"} var certManager = &amp;autocert.Manager{ Cache: autocert.DirCache(certsDir), Prompt: autocert.AcceptTOS, HostPolicy: autocert.HostWhitelist(domains...), } var listener = certManager.Listener() var server = http.Server{ Addr: listener.Addr().String(), Handler: YourHandlerHere, } log.Fatal(server.Serve(listener)) ```
From a performance perspective, no you probably don't need a load balancer/proxy like nginx in front of your Go app. Go's HTTP server is efficient enough for handling quite a bit of traffic. There are still convenience and ops reasons to do so, though. Eg, to serve traffic on 80/443, the process has to be privileged. There are plenty of ways to do it properly and securely, but all involve a bit of work and know-how and messing up can be a security problem. Nginx serves static files, can do virtual hosts, has flexible SSL/TLS configuration, logs in a standard format, etc. Those are all things that you *can* implement in your Go app (and might want to for specific use-cases), but really if you can just delegate it to nginx and keep your app simple, you're probably better off. The most important reason though is probably just to have that layer of abstraction in place. With a load balancer/proxy setup in place, it's much easier to scale to multiple backend nodes or to orchestrate a move between servers, versions, or cloud providers, and it gives you a better starting point to set up failover and redundancy.
need? no! want? yes! unless we are talking a small project or something only you use, you dont need one. once its large scale project, absolutly yes. you will encounter so many problems down the line where loadbalancers just make everything more easy. like routing US users to different servers, partialy updating servers, adding more routes without having to update everything (microservices) and so on.
I'm not sure you know what faschism is
Go is a great first language. It‚Äôs very light and blunt and gets the job done.
Yeah, that was my first thought.
Cool way to spell it bro
Fixed it love, english isn't my first language
Exactly
Go apps are very performant, unless you have many instances of them load balancer is optional. But remember that default timeouts and other parameters of http.server have to be tuned take look at https://blog.cloudflare.com/exposing-go-on-the-internet/
why write a load balancer when there are proven ones out there? NIH syndrome.
Cool, do you mind if I DM you to ask you some questions? I was just starting to learn more about that.
Of course not. Go on.
You don't have to write it, you can use a library. Why use something other than nginx? Because then you have fewer things to configure.
&gt;hat is important, is having a few years of experience as a programmer and a little portfolio of completed projects. I'd agree with that. But a person will become a better programmer if they're exposed to different *types* of programming languages. It makes sure you consider the algorithms and don't get stuck in a rut doing things the same way all the time. In my time I've used Lisp, ML, FORTH, Perl, Java, Javascript, C++, C, assembly and golang as well as random amounts of Ruby, Python, BASIC and similar. Learning multiple similar languages won't help, but learning from ML while programming in C will give you a new appreciation for a lot of things.
nginx as a load-balancer? Well you *could*. But haproxy would be better, that is literally what it is designed for. Very configurable, and extensible with lua if you need it.
How is it an improvement, having to learn a specific program and all its configuration options, vs just using a library that you embed in your final product? When you embed a library you have less things to maintain.
sometimes it's worth doing something regardless of practicality
Idk man I feel like it would be hard to do Rust as a first language.
People usually use load-balancers because they need (horizontal) scaling. For example you might have ten hosts running your application, four database hosts on the back-end. And in front of that you need a load-balancer to route traffic to the app-servers. &amp;#x200B; Me? I'd have another two hosts, or possibly three, all using shared IP setup and running haproxy as a load-balancer. Completely distinct from the app-servers. If you want to run your "library" load-balancer it seems like you'd have to directly expost your application-servers. Unless you think you're going to run them on the same pair/three hosts in front. Really at that point your library better be pretty damn configurable to route traffic appropriately, maintain status/health-checks and handle special routing. &amp;#x200B; e.g. Imagine you offer an API, with tokens. You want to offload that check. You might also decide that two of your back-end application hosts are slower/weaker and you push all clients in a trial there. Leaving the bigger hosts for paying customers (ha! Cynical-Steve says maybe do it the other way round ;) Will your library solution offer that flexibility? &amp;#x200B; &amp;#x200B; At the end of the day you make your choice and do what you prefer. But when you handle big-load you'll want a capable solution. A random library might be that, but compared to the **years** of solid performance from haproxy I know what I'd choose..
Yes, but this is what Haskell is for.
At 42, feel like I'm too old to jump in to a completely new field, at times. Was wondering if I could pick a newer language and have an easier time getting into the industry because of that, what the intern scene is like, best ways to become proficient enough to actually become productive enough, quickly enough, with the language. Sounds like most folks in this field really "live it" 24/7.
not sure why you‚Äôre getting downvoted, you‚Äôre right. this happens in our industry a lot - people change the things they can control, pushing for wins, where ultimately an architecture change makes more sense and saves more time. I spent months re-jiggering our metric system for better performance at $oldjob and eventually wound up replacing the whole stack and doubling disk sizes for better IO. anyway I guess my point is that you can tweak things forever, but stepping back and taking a larger view is v important too.
I mean to say that, when I look at goland job offers, employers do want other languages/skills, and I'm coming into this completely new, so I'm probably going to have to learn more than just go. Thanks for your great reply.
You are, but I would suggest always using NGINX in front of your Go services, no need to deal with ssl on the app level that way. NGINX also is tried and tested and has a lot of security features and caching built in.
You need one as soon as you want two (sub)domains on one IP.
short answer: yes long answer: yessssssssssssssssssssssssssssssssssssssssssssssssssssssssssss &amp;#x200B; '\_\_') especially for backend, except, for mobile: learning Dart (Flutter) or Javascript (NativeScript, ReactNative) would be better alternative for web frontend, Javascript is a must for game frontend, C# (Unity) probably better.. but yeah, Go is good for entry level
It's the concept of separation of concerns... Why have your go app try and do everything. I mean, you CAN have your go app handle SSL encryption, and certificate renewal, and listen on a privileged port (80 or 443) and even have it drop to an under-privileged (non-root) user after it binds the privileged port... But just because you can, does not mean you should. Your app should handle running your app, let the complexity of handling SSL, and privileged port binding and such be handled by something that is purpose built for that (likely nginx assuming you aren't running in a kubernetes infrastructure... And maybe even if you are)
btw isn't StackOverflow is better platform for asking this kind of question?
Where's the relevance? I run five domains on the same server and I don't have any separate proxy or server.
You don‚Äôt have to but you should. There are things your application shouldn‚Äôt care about. Here are some examples: Your application shouldn‚Äôt care about what domain the app is supposed to be hosted on. If you have multiple web apps hosted on the server and you wanted it to both use port 80/443, you‚Äôll need to parse the host header and map it yourself. It‚Äôs probably better to create multiple services instead of a monolithic service and let a reverse proxy such as nginx or haproxy handle this for you. Your application shouldn‚Äôt care about how to keep a server from dying and do health checks of other servers. If you‚Äôre running a service that must remain up at all times, you‚Äôll need to run your service on more than one server. This is where a load balancer helps as well because it can do a simple health check on your web server to decide whether or not to keep sending traffic to that server. Your application shouldn‚Äôt need to know how and where to write log files. Most web apps write their logs to stdout. That is the preferred way when running your web app in a docker container. There should be something that collects the log output from your web app and writes it something else or sends it to somewhere else.
May I suggest a few tweaks to your repo, for general code quality: * Allow users of the lib to insert a logger, rather than providing one and only offering the option to write to a file. Some people might not want any logs, stdout or file. * Generally, don't print log.Info lines that users of your lib can't manage. E.g. in your prosumer.go you log when a consumer starts and finishes. * prosumer.go &gt; Prosumer should have a queue as object instead of extending it. Currently the Queue methods are publicly available I believe, which is not something you want to expose to users of your lib. * Allow for closing the Coordinator without waiting for all tasks to finish. * prosumer.go: time.After(time.Until(last.Add(c.batchInterval))): Be sure to use a timer instead of calling time.After, as you can re-use timers saving allocs. * Follow-up on this, it might be more elegant to use a time.Ticker that sends ticks on the batchInterval duration. Then you don't need to track "last" and start new timers all the time. Simply check if the ticker already fired, or wait until it does. * prosumer.go: initialising your "received" array with batchSize as backing array size might be good for performance, although this depends on batchInterval and the rate at which tasks come in. Backing array size init: received := make([]interface{}, 0, batchSize) * Generally the go func(i int) in your Coordinator.Start() feels like it should be gathered into an object/type, like a "worker". Would make this feel a bit cleaner. * Am I wrong, or will your prosumer "actively" wait while your Queue is empty? That for-loop will wait a batchInterval until checking the queue again (empty), to proceed to waiting the batchInterval, etc. * prosumer.Put(..) should expose errors, that should also be exposed by the queue, when the queue is discarding data based on its reject policy. A warning log is quite useless for external users if they want their code to react on the queue being full or not.
Five domains on five different ports or how do you do it? If you only have one IP but two processes which want to serve on port 80/443 how do you do this without a reverse proxy?
I don't recommend using an nginx load balancer for a Go server. If you need a frontend, use the one that your cloud provider provides or use the free tier of cloudflare.
One process serves all domains. The root handler checks the domain ('Host' header) to determine which mux should handle the request. The process listens on both 80 and 443.
You just described a reverse proxy with the limitation that you can't have multiple processes in multiple programming languages.
Reverse proxy it's a process that doesn't nothing except forward requests to other servers. Here there's only one process. I don't want to have 5 processes in 5 languages, that's insane.
Somehow people are ignoring the most important aspect: security. Nginx has been around and is designed to handle malicious users. For example, SlowLoris attacks. I‚Äôm sure Go tries to handle these security issues too, but Nginx certainly has a lot more time for it.
Just some more reasons: * Not worrying about the SSL implementation or choice of ciphers *in your application code* as vulnerabilities are discovered * Deferring caching to a separate layer based on header responses * Enabling someone else to put in extra security layers like (like detection of XML vulnerability exploit attempts, SQL injection). While you should be avoiding most of these yourself, a security team may want to bolster these or manage them themselves. * Allowing someone else to manage it and update it outside of your release cadence * Being able to move it off the machine and load balance across multiple machines * Layer 7 routing, health checks, metrics, circuit breaking, retries
The balancer is only needed in high traffic projects, so most likely you don't need it. The proxy is for security reasons. If you are using Heroku this is already solved for you.
Yep. As much as I'm careful to avoid prematurely over-architecting applications, I've put a LB/proxy of some sort in front of basically every app I've exposed to the public for at least the last decade and I've never once regretted adding that layer.
At the moment we don't have anything that is similar to PyCharm's remote development support. We planned to do this for 2019.2 but we run into additional complexity and we think the feature is not ready yet, even as an early technical preview. Hopefully, this will be available in 2019.3, but I cannot guarantee this. Meanwhile, you can use the `Remote hosts` plugin to achieve a partial setup for this. You'll need to have Go and the sources installed on your system, but then you can synchronize them with the remote host and make the compilation there using the builtin Terminal, or if possible, use the cross-platform compilation feature of Go from the Run Configuration and sync just the binary after that. You can read more about the `Remote hosts` plugin here: https://www.jetbrains.com/help/go/remote-host-tool-window.html and if you need more details on this, please let me know and I'll be happy to help out.
Is there a command for updating ?
For performance concerns, no. nginx or a web/http server like gunicorn is not needed. You need them in python because python is single threaded, which is not ideal for web apps. So you need something like gunicorn as a process/thread manager. nginx is required in case gunicorn is backed up and all workers are busy, nginx can "queue up" incoming requests. Go is not single threaded and can handle simulatenous incoming web requests just fine. Having said that, that means you do need to manage the requests yourself to make sure they are processed/terminated properly. That's why `context.Context` is created because it is highly useful to terminate long running requests that might take up memory/cpu. nginx however has more useful features such as TLS, reverse proxy, load balancer, security, static files, among other things. Not needed for performance, but you might need them for those other features.
There is a subset of rust fuctionality that works well as an introductory language. It's just too new to have been treated that way yet.
Go gave me depression
&gt;And maybe even if you are Just a note, nginx is the default, and most common, proxy for kubernetes. Yes, there are other ingress controllers, but nginx is far and away the most popular.
Hence why I said "and maybe even if you are"... In my production infrastructure, I use AWS ALB's as my ingress, not NGINX. While nginx might be the most commonly used one, it is far from being a standard. Of all of the large scale k8s clusters I manage, not a single one still uses nginx... ALB's, istio, traefik sure, but none of them are nginx. Not saying that it doesn't happen though.
&gt; so is goto compared to structural statements Goto absolutely has its place, just like defer. Mistakes happen because of long and/or confusing code. If you can't see the target of a goto on the same screen as the call itself, then it's probably a bad usage. If you can't see the end of the function from a defer call, it's probably a bad usage. If you can't easily see the end of a with context, it's probably a bad usage. I try to keep functions small and/or simple and usages of `defer` (or with) clear. If defer calls need to run in a particular order, I'll often split them up into separate functions so it's impossible for someone to accidentally reorder them. Likewise with `with` in Python, I try to limit my usage of `with` so the covered code doesn't grow very large (don't want to hold a lock or a file handle open longer than necessary). &gt; For example how many go programmers actually check result when closing a file? Even tutorials don't show that That's what linters are for. `gometalinter` is great for that. &gt; Handling things like locks is more robust, there is no way to forget to unlock a lock, while you can forget defer. Yes, this is my #1 complaint about Go. I _much_ prefer the Rust solution to the Python one. In Rust, the compiler checks that you cannot use locked data incorrectly, while preserving the ability to unlock a lock before the end of the scope. If I need to unlock something early in Python, I basically have to avoid `with`, but with Go, I can throw in a `defer` anywhere I please, so I can choose to unlock early or defer the unlock for later. If I can't have Rust-style guards, I prefer Go's `defer` (or even better, D's `scope(...)`) to something like `with`, though `with` is certainly better than nothing (and better than Destructors). &gt; Go routines were hyped a lot when go was released, but after years it looks like they aren't panacea for multi threaded programming They're absolutely not, though they _are_ super convenient. I miss Rust's green threads from the pre-1.0 days, but other than that, Go's are a really good mix of features, and I much prefer them to threads in most situations. I like not having to worry about how many goroutines I have (tens of thousands of goroutines is completely reasonable), I just focus on making sure I use them correctly. Python has the same issues with memory sharing, they're just more tedious to use and don't scale nearly as well as green threads (OS threads in general can't really scale to tens of thousands). &gt; As for preformance, yes go is faster, but in most cases you don't need it Sure, at which point it comes down to whatever makes your tasks easier to solve correctly. I think Go offers a lot of features for highly-concurrent problms.
because goland didn't start from zsh.
How would I add a load balancer like nginx to my go webapp running on a VPS like digital ocean?
This is a pretty old project of mine, but it‚Äôs a parser/interpreter for a simplified subset of JS using yacc. https://github.com/mhoc/msp I‚Äôm sure there are more modern tools available, but it may help you get started.
This is a DTLS (so TLS for UDP) library in Go that does not rely on CGO to wrap some external library (like OpenSSL for example). The notable thing with the 1.4.0 release is that it now supports AES-CCM and PSK which is in use by a lot of IoT devices.
Also to protect against slow connections from (malicious) users.
Saw this on a tweet by Brendan Eich a few days ago: https://bellard.org/quickjs/ looks like it supports the latest standard. It‚Äôs not Go, however, but C, which you might be able to integrate in a Go app. (I haven‚Äôt tried the library at all yet, but saved it as an interesting project)
This looks awesome, however, I am trying to do exactly that in Go, so wrapping a C library is not an option at all. Like, if I would wrap just the parser part of this project, why not all of it... But thank you so much for that hint, the implementation will help me with some of my issues that I will encounter! Good to know that there's source code out there that isn't V8 and OpenSource that is executing ES6+ :D
I would recommend ANTLR4. It has a nice Go target. There is already an ES6 grammar for ANTLR4 here: [https://github.com/antlr/grammars-v4/tree/master/javascript](https://github.com/antlr/grammars-v4/tree/master/javascript)
Yes, but I would need a grammar for ES9, and just extending the ES6 grammar would be just as good as writing a new one (because I got no experience and don't understand what's written there), or I could just write the whole parser in Go myself.
You will still need a load balancer if you want your service to remain available if any of the things behind the load balancer go down. A load balancer should be doing health checks to see if the target is up, and will stop sending traffic when the health check fails. This means that your Go app, a server, network hardware, or an entire datacenter can fail but your app can stay up because the load balancer can just redirect traffic to another place running the same app.
 Check this out [https://www.digitalocean.com/community/tutorials/how-to-install-nginx-on-ubuntu-18-04](https://www.digitalocean.com/community/tutorials/how-to-install-nginx-on-ubuntu-18-04)
Also, the JavaScript grammar is an ES5 grammar, the ecmascript grammar is the ES6 one.
&gt; There are still convenience and ops reasons to do so, though. Eg, to serve traffic on 80/443, the process has to be privileged Not if you set capabilities.
So you think writing an ES9 parser from scratch is easier than updating an ES6 ANTLR4 grammar?
No, writing the grammar from scratch would be, because I don't have to understand what someone else thought.
Much faster than writing from scratch would be to re-use / tweak existing parsers: https://github.com/robertkrimen/otto/tree/master/parser https://github.com/dop251/goja/tree/master/parser
Goja and Otto are both ES5.1, and AFAIK not even feature complete 5.1.
It does need a load balancer for the same reason a Python app needs a load balancer. It doesn't need a proxy.
Yes, but es6 is es 5.1 + additions. This is 90% of work done (and more importantly tested and debugged) for you. If you look at the code, the parsers follow ecma script spec: [https://github.com/dop251/goja/blob/master/parser/statement.go#L15](https://github.com/dop251/goja/blob/master/parser/statement.go#L15) [https://www.ecma-international.org/ecma-262/5.1/#sec-12.1](https://www.ecma-international.org/ecma-262/5.1/#sec-12.1) The point being it'll be easy to extend to and you won't do any better if you write this from scratch.
That is correct. I will try to implement a new feature as a POC and see where it gets me.
I'm just curious now, can I ask what you're using it for?
https://github.com/gojisvm/gojis :)
Thanks!!!
The same protection can be done by setting IdleTimeout, ReadTimeout and WriteTimeout on http.Server. No problems with some direct moderate traffic (up to 100req/s) on directly exposed Go http server with tls.
Awesome this is just what I‚Äôd been looking for for some IoT stuff üëçüèª
Yeah, you can even run nginx in the same server on the privileged ports and then have golang listening on a high localhost port.
Thanks for the update, just purchased!!
Some pub/subs fire and forget (Redis) others maintain state even after consumed (Kafka) so it all depends on your (users) requirements. Also weigh up the complexity this may add to your codebase; it may not be worth it.
I know of guys that went back to university in their 50's.... where are you going to be in 4 years, you will either be 4 years older with no degree, or 4 years older with a degree
So, DTLS solves two problems of UDP: packet lost and reordering: [RFC 6347](http://tools.ietf.org/html/rfc6347).
Yes, there is the VS Code is free argument. And that's what got me started with VS Code. But I keep coming back to Goland on eval to try it and never seems to stick. I like VS Code Workspaces. And I support the language server model that MS is promoting. I'm using gpls in VS code now and am generally pleased. It's only going to get better.
&gt;prosumer.Put(..) Thanks. those are all valuable. Most points make sense for me, and I create an [issue](https://github.com/jiacai2050/prosumer/issues/1) to track. &amp;#x200B; &gt;Am I wrong, or will your prosumer "actively" wait while your Queue is empty? That for-loop will wait a batchInterval until checking the queue again (empty), to proceed to waiting the batchInterval, etc. That's the case when queue is empty. Firstly Dequeue is one case of switch, but later learn that close channel will always read successfully, without blocking. I also believe improvement can be made here, I just don't figure it out now.
&gt; I find that unless they host some godocs and really document their code, the readme on github only ever has a few typical examples. Stretchr/testify is a paragon of good documentation in my eyes because of it. Spf13/cobra leaves a lot to be desired, documentation-wise. Yes it is. I quite agree with you
Really?
Originally I loved the idea of AOP, the magic annotations, etc.. but now, I find that a lot of code is cluttered with all sorts of annotations, it is not easy to read/understand, and if you dont know the frameworks/libraries the annotations are from and how they work with things, and worse, how they work with other annotations on the same classes.. you are forked. I realize that in some cases they reduce code, but despite migrating to them in JEE with ORM and such back in the day, I really dislike all the hoops you gotta go through if you are not familiar with them. That is one thing I like about Go and to some extent NodeJS. I suspect they both may get something like it eventually, though I hope not.
Nice article! It's nice to see, dare I say, *intermediate stuff* on Go. Keep it up
Isn‚Äôt redistribution of the Oracle and MS driver a violation of the license?
The number of questions on StackOverflow says nothing about the quality of the community. Absolutely nothing. &amp;#x200B; Regarding third-party documentation, there are always devs out there that don't know how to properly document their libraries (or just don't care). This also does not say anything about the community as a whole.
Thanks for sharing and thanks for GoJSONQ. Recently I used the package to quickly fetch a pair of values from JSON data without having to create a complete JSON-to-struct mapping.
Hey there! It's been a while and mira supports custom `*http.Client`s now! You can do it as easily as ``` r, err := mira.Init(myCreds) r.SetClient(myClient) ``` [New release of mira](https://github.com/thecsw/mira) supports that now! Thanks for your suggestion
Just like that. Here is an example: [https://play.golang.org/p/fkzLERAios5](https://play.golang.org/p/fkzLERAios5).
The picture says no ads but my phone says otherwise
Thank You :)
[https://golang.org/pkg/fmt/](https://golang.org/pkg/fmt/)
Read this page of the GoDocs: https://godoc.org/-/about &gt; GoDoc generates documentation from Go source code. &gt; To add a package to GoDoc, search for the package by import path. If GoDoc does not already have the documentation for the package, then GoDoc will fetch the source from the version control system on the fly and add the documentation.
thanks
Thank you. Learning new things by the day.
You could initialise everything at once if you wanted using a composite literal: [https://play.golang.org/p/ZYuMCR3nMqh](https://play.golang.org/p/ZYuMCR3nMqh)
Just don't say no ads üòë
My use case is such that I cant initialise everything. My functions needs to use already existing structures(in this case a,b) to intialise the parent structure(in this case c)
Should note that it needs to be in the same package. Because they‚Äôre lower case, they‚Äôll be private to the package, which can be solved with an initializer or just making them public (caps).
I had figured that in order to release an application that uses the driver, you must be able to redistribute the driver. But good point, thanks, I'll check. At worst it will require building by each user, and I can make that easy enough using docker.
If you have a Go distribution installed, you should already have `godoc` installed in your $PATH. - Place your main.go in a package path under $GOPATH. For eg - $GOPATH/github.com/user/package/main.go - Start godoc as godoc -http=:6060 - Visit localhost:6060/pkg - Under the `Third party` section, browse to your package. You can find more information at https://godoc.org/golang.org/x/tools/cmd/godoc
Yeah ads are fine if you wanna make few $ on side with it to recoup time invested but don‚Äôt say ‚Äúno ads‚Äù if you have ads it kills trust forever.
Yeah, i get that. Thanks.
As I understand, it isn't go module compatible?
It should work. But you don't have to edit it like that, it should be available in the normal settings. (You could also choose for goreturns or goformat) Type in the seach box above the regular settings field : format tool and it will quickly filter all settings on this :-)
thx
I hope they update godoc to Modules soon.
Can you return an error slice ?
&gt; I had figured that in order to release an application that uses the driver, you must be able to redistribute the driver. I see you haven't dealt with Oracle's legal team before. Common sense costs extra.
I could, but that would mean I wouldn't implement the io.Closer interface. [https://golang.org/pkg/io/#Closer](https://golang.org/pkg/io/#Closer)
remember -- an error is a type that implements `Error() string`... that's all. how about: ``` type ServerErrors []error func (se ServerErrors) Error() string { s := []string{} for _, e := range se { s = append(s, e.Error{}) } return strings.Join(s, ",") } func (s *Server) Close() error { var errs ServerErrors for _, conn := range s.conns { if err := conn.Close(); err != nil { errs = append(errs, err) } } if err := s.listener.Close(); err != nil { errs = append(errs, err) } return errs } ```
503 for me
Implement this ``` type errSlice []error func (e errSlice) Error() string { //TODO: how you want your "multiple errors" expressed } ``` From there, just append all errors to an `[]error` and at the end you can do this: ``` if len(allMyErrors) &gt; 0 { return errSlice(allMyErrors) } return nil ```
Holy crap how do I type code on Reddit.
Ah I just realised @ruertar also suggested this solution haha. Forgive me for repeating it.
Generating static documentation for your project is just about impossible, unfortunately. It‚Äôs a big hole in the go ecosystem
This still uses cgo, so I don't see whats the benefit using this over the "native" one.
This is the correct answer. OP, look here.
&gt; Node Function &gt; Package Size: 300 KB (zip) &gt; Go Function &gt; Package Size: 3 MB (zip) I don't think it's fair to compare a zipped Node app with a zipped Go app The Go app is a compiled binary blob that contains both the Go runtime and your code. On the other side of the fence, the Node packaged zip ONLY contains your code (and the vendor depencies) IT DOES NOT CONTAINS THE RUNTIME That means that, if the only thing I have is a clean linux install and your packaged zip, I would be able to run the Go app (since it's a self dependent binary) while the Node "app" would be unusable If you were to include the size of the Node runtime, it would be substantially heavier The latest node runtime for linux weighs ~13.8MB
The RFC seems to suggest otherwise &amp;#x200B; \&gt; The behavior of such applications is unchanged when the DTLS protocol is used to secure communication, since the DTLS protocol does not compensate for lost or re-ordered data traffic.
Why don‚Äôt you just write/read from disk yourself, if it truly needs to be simple?
How about https://github.com/mattn/go-sqlite3
/r/amItheasshole for saying no ads and then having ads....
Thank you for constructive response. I deeply respect sqlite project. Think in this case it will be a little more complicated version of KV store.
This is still wip, and very unlikely to have any real benefits at the moment :) &amp;#x200B; Although... &amp;#x200B; For oracle, it does not require the oracle c client at buildtime or runtime. (This is because the JDBC driver is plain java). Which is pretty great. &amp;#x200B; There are other features in JDBC drivers (like the continuous query notifications in oracle I'm working on in a branch) that will be easier to use with the JDBC driver than reimplement in go. Also, at least on mac, all of them seem to be quicker than the go drivers. But slower on linux. It is possible my benchmark just isn't very good.
Yeah that‚Äôs true but it‚Äôs reliable and battle tested :-) and likely to be around for a while ...
If that‚Äôs your main concern I‚Äôd definitely consider SQLite. It‚Äôs relatively lightweight and a great match for the described workload and can easily handle millions of rows.
I‚Äôm not the OP - but I agree with you
how many is a few "sensors"?
But what about Robert Griesemer?
When you include the need for persistence, it's not going to get any simpler than bbolt or badger
It is something that is being worked on. Feel free to subscribe to https://github.com/golang/go/issues/26827.
https://github.com/golang/go/wiki/CodeReviewComments#import-dot TL;DR: It's useful in tests, otherwise it makes your code far less clear when reading it, so it's not advised to do it. Honestly, just stick to writing out the full thing, it's not that bad!
From my understanding the best practice is to literally import fmt and use the full names of functions like fmt.Println. This is how all the biggest codebases do things, and means any Go programmer can pick it up. The only thing I can suggest is maybe using an editor which allows you to create your own aliases, so you can type Pln, but it automatically gets replaced with fmt.Println.
Proxy: Don't need, but it might be advisable. Maybe go with something like Cloudflare if you want something low-maintenance, as the main benefits you'd want are to do with lower maintenance and environmental differences that you might not want to keep in your codebase (e.g. maybe you don't use LetsEncrypt locally, but have something like Caddy set up do handle that in staging and prod?) Load balancer: Good idea if availability and performance are a must, otherwise, not necessary. If your app is low-throughput, the main concern would be availability. Load balancers will help you point to multiple datacenters if you want, meaning if one DC goes down, your app still functions.
I wrote total storage is below 1kb, if you like more details, useful data (without serialization and safety overhead) fits into 7 uint32. They only make sense together, that's why "even multiple key-value store is overhead" is stressed.
https://www.youtube.com/watch?v=YS4e4q9oBaU The actual content is here...
I prefer having this graceful shutdown code outside of my server code. The main.go file creates/starts the webserver, which makes it a logical place to shut it down as well in my opinion. Thoughts?
https://github.com/oakmound/oak
This is what you should do. - use editor features to simplify writing code. (Use snippets and auto completions) - use language features to simplify reading code. (keeping the `fmt.Println` is best because it talks about the package as well as the function itself.)
I second this. Custom code snippets is the way to go: - https://code.visualstudio.com/docs/editor/userdefinedsnippets - https://www.jetbrains.com/help/go/settings-live-templates.html
Definitely give this a read.
Maybe there are some other tools, which can be used to generate docs from comments? I saw a lot of them, but for C++, Pythonm, JS, etc.
If there are, I don't know about them
&gt;\- KV storage like bolt/leveldb would work, just overkill because there is one value to store and they clutter my sigabrt goroutine list :-) Yeah, no, that's not a valid reason. ;) Since you care about data integrity, I'd go with something proven, like the sqlite suggestion.
thanks! the only problem i have with this method is that three is no way to really add context to the error without also obscuring the underlying error type. i guess if it was up to me, i might do something like (and this might be ugly): ``` type ErrorWithContext struct { context string // context err error // preserved error value } type ServerErrors []ErrorWithContext func (se ServerErrors) Append(e error, f string, v ...interface{}) ServerErrors { err := ErrorWithContext{ context: fmt.Sprintf(f, v...), err: e, } return append(se, err) } func (se ServerErrors) Error() string { s := make([]string, 0, len(se)) for _, e := range se { s = append(s, fmt.Sprintf("%s: %v", e.context, e.err.Error())) } return strings.Join(s, "; ") } ``` this way we can annotate the error AND preserve and retrieve the original error value so that we can compare it with pre-defined/sentinel error values like `io.EOF`, `os.ErrClosed`, `os.ErrNotExist`, or type assert it to provide behavior outside of the scope of the `error` interface, etc. but again, i my point is: the cool thing about errors in Go is that they're interfaces and we can define our own type that conforms to that interface with whatever details we like. just don't write code as ugly as mine. :)
no stress man. it takes a village to raise a gopher.
Readable is better than clever
\[shamless\_plug\]gopkg.in/goracle.v2 needs the client only at run-time, and should support CQN.\[/shameless\_plug\]
The normal and expected thing to do is to write out the fully qualified names. Saving characters is the last thing you want to do in programming, code is read much more than it's written
Code is likely to be read many more times than it is written, so it's best to opt for readability.
Haha you must despise the error checking in Go if you dislike the boilerplate in fmt print statements. Anyways I'm in that weird place where I can make some working stuff in Go but don't know the low level best practices quite yet, wish I could help you though.
If you start a line with four spaces, it's formatted as code.
Thank you very much! Works perfectly
Came here to suggest something like this.
Looks like a bug in the code to me.
where? it works well.
It certainly works. But that goroutine will hang until something reads 1 single value from it. It‚Äôs like they intended to make it i &lt; 5, but accidentally put &lt;=. Authors aren‚Äôt perfect.
Use the full name. You will only confuse other readers and yourself (when you come back to this later). Its really not as big of a deal as you think to type the whole thing.
i also have problem with this. why used i&lt;=5. do you see the explain, author said send 6 value to 5 cap buffered channel .
In GoLand you don't even need a live template for this as the autocomplete is smart enough to import the package and figure out the function name automatically from only "Prln", for example
You [shouldn't create references to struct fields to save typing](https://play.golang.org/p/6XH0lZnqa7w), don't remove package namespaces either.
It‚Äôs really hard to say without reading the context as to why the value was chosen. To me, it looks like it was likely a bug. But, they could be demonstrating something. When there is 6 values, the goroutine will block until something reads one value, freeing up a spot in the channel. Then it writes that ‚Äú5‚Äù, finishes the loop and closes the channel. Channels don‚Äôt close immediately when there is data left in them. Your consumers will read the data before they process the close event.
https://golang.org Hello, it appears you tried to put a link in a title, since most users cant click these I have placed it here for you ^I ^am ^a ^bot ^if ^you ^have ^any ^suggestions ^dm ^me
We use goracle in production, it is excellent.
yes ,The channel will block at the 5th until it is read by the consumer. But I still don't understand why I sent 6, I tried to modify the program to send 5, it still works the same? Sending 6 will make the goroutine work faster? What is the principle?
Please don't do this. If Java programmers can type `AbstractSingletonProxyFactoryBean` and live with themselves, you can write simple `fmt.Println`.
https://www.reddit.com/r/programming/comments/ccidly/golang_issue_ticket_remove_the_google_logo/
Absolutely. Only caveat I see is unless clever means optimization _when/where_ it matters.
As I said, both work fine. It‚Äôs a contrived example designed to teach something if it‚Äôs in a book. As I said before, it looks like a bug. They probably accidentally made it emit 6 values instead of 5. But impossible to know without context.
Goja is a fork of otto that has been more active overall than otto since the fork a number of years ago. Both have diverged a lot, but since otto has remained active, there are bugs in both not fixed in the other. Personally, I believe if you pick one, goja is the better choice due to the better performance and somewhat more responsive maintainer.
you can check code in here [https://github.com/kat-co/concurrency-in-go-src/blob/master/gos-concurrency-building-blocks/channels/fig-chan-ownership.go](https://github.com/kat-co/concurrency-in-go-src/blob/master/gos-concurrency-building-blocks/channels/fig-chan-ownership.go)
I can count the number of dot imports we have on one hand, and we only use it for utility packages with an assortment of things that _would_ normally be in the same package they're imported in, but have been moved for organization/sharing purposes, and they share a name with another imported package that's more widely used. We usually just change the package name instead of dot-importing the package, which is why there are so few dot imports. I don't think I'd _ever_ dot import a stdlib package.
How about adding context using [errors.Wrapf](https://godoc.org/github.com/pkg/errors#Wrapf)? The underlying cause can then be retrieved by [errors.Cause](https://godoc.org/github.com/pkg/errors#Cause).
I have not used Go Modules extensively to have a proper answer to this question. But this project will read a folder and all its content for \*.go files. For this project, the GOPATH is irrelevant since it will not bother finding the relationship of the imported packages. In order to keep the diagram contained to your projects, it will only find dependencies and relationships with the structures and interfaces within the project itself (including all the folders within the given path if the -recursive argument is passed)
Docker, Kubernetes ?
As someone with a similar goal, I would suggest you to check out #open-source channel on slack group for golang. https://invite.slack.golangbridge.org/
This is a really great write up! Good job
absolutely -- that's completely reasonable. was just trying to demonstrate that he doesn't even have to use `errorsx`. i think i basically wrote `errors.Wrapf()` above.
Thank you all for your feedback. I get your points. "code is read much more than it's written". This sentence really clicked in my head.
Go modules work fine in 1.12. Have at it.
I don't mean to sound cliche, but, don't put off for tomorrow what can be accomplished today :)
Yeah, that's correct :) No problem.
&gt;Goto absolutely has its place, just like defer. &gt; &gt;Mistakes happen because of long and/or confusing code. If you can't see the target of a goto on the same screen as the call itself, then it's probably a bad usage. If you can't see the end of the function from a defer call, it's probably a bad usage. If you can't easily see the end of a with context, it's probably a bad usage. I'm myself a big proponent of using goto in languages like C when needed, because it can make code cleaner. My point is that goto and defer are needed, because the language has its deficiencies. Python doesn't have goto, but also has statements that makes it unnecessary. &gt;I try to keep functions small and/or simple and usages of `defer` (or with) clear. If defer calls need to run in a particular order, I'll often split them up into separate functions so it's impossible for someone to accidentally reorder them. Making functions small is a good practice, but not getting lost with defer shouldn't be the reason for it. You are essentially proving my point that it is prone to errors. &gt; Likewise with `with` in Python, I try to limit my usage of `with` so the covered code doesn't grow very large (don't want to hold a lock or a file handle open longer than necessary). That's what `with` creates a block to make it implicitly show when the object is live. You don't have that with defer, you need to separate the block into a function like you do. I don't understand why would you avoid `with` though. It makes code clean and less error prone. &gt;That's what linters are for. `gometalinter` is great for that. Yes, liners will point that out, but many people will still ignore it, because adding the check will make the code ugly. &gt;I _much_ prefer the Rust solution to the Python one. In Rust, the compiler checks that you cannot use locked data incorrectly, while preserving the ability to unlock a lock before the end of the scope. If I need to unlock something early in Python, I basically have to avoid `with`, but with Go, I can throw in a `defer` anywhere I please, so I can choose to unlock early or defer the unlock for later. I'm not sure this is a good idea, to avoid deadlocks you supposed to unlock locks in reverse order you obtained them. Releasing then like that is a recipe for these issues. `with` makes you do the right thing. &gt;If I can't have Rust-style guards, I prefer Go's `defer` (or even better, D's `scope(...)`) to something like `with`, though `with` is certainly better than nothing (and better than Destructors). &gt;They're absolutely not, though they _are_ super convenient. I miss Rust's green threads from the pre-1.0 days, but other than that, Go's are a really good mix of features, and I much prefer them to threads in most situations. I like not having to worry about how many goroutines I have (tens of thousands of goroutines is completely reasonable), I just focus on making sure I use them correctly. Python has the same issues with memory sharing, they're just more tedious to use and don't scale nearly as well as green threads (OS threads in general can't really scale to tens of thousands). Yes, Python has the same issue with shared memory, but go with routines didn't need to have them. The hardest part in multitasking is to correctly use shared memory, correct use of locks etc, and go has the same issues most languages have, while it had opportunity to avoid them.
Yes, it makes sense, but golang is so clean and tasty to code that actually this doesn't matter. Start at problem solving sites. I'd like to use [gobyexample.com](https://gobyexample.com) A LOT.
Treafik, kraken, caddy, prometheus, i would sugest projects from Cloud native foundation landscspe https://landscape.cncf.io/
This is why it‚Äôs called DeliveryQueue. The idea behind this package is to immediately process the messages but not more than N items a seconds. If you desire to implement a regular FIFO queue and pull manually using this package, you might want to look at ‚Äòqueue/buffer.go‚Äô which implements a Buffer and it is essentially what you are talking about. DeliveryQueue is just a construction built on top of it.
Start today, go is the most stable language available on the market :)
&gt; Python doesn't have goto, but also has statements that makes it unnecessary. It has _some_ solutions for those types of problems, such as `else:`: while True: while True: if condition: break else: break But this doesn't work that well for more nesting: xloop: for x := 0; x &lt; len(xs); x++ { yloop: for y := 0; y &lt; len(ys); y++ { zloop: for z := 0; z &lt; len(zs); z++ { switch condition(x, y, z) { case CONTINUE_X: continue xloop case CONTINUE_Y: continue yloop case ERROR: return err } } } } But it has no way to move to a different switch case (doesn't have switch) or otherwise combine logic for similar cases: switch value { case FANCY: someLogic() fallthrough case BASE: otherLogic() } You can certainly work around issues like these, but that can result in harder to follow code. I know I've done my fair share of stuff like this: flag = False if condition: flag = True elif other_condition: flag = True ... if flag: cleanup() In C, I can just `goto err;`, and in Go, I can do that or use defer: cleanup := func () { } if condition { defer cleanup() } else if otherCondition { defer cleanup() } &gt; You are essentially proving my point that it is prone to errors. Sure, it has that potential. But you don't _have_ to use it. I prefer how Rust does it, but I prefer defer to Python's `with` as well because it's easier for a new developer to understand (no magic function calls, everything is right there in front of you). &gt; You don't have that with defer, you need to separate the block into a function like you do. Yes, I absolutely with defer could work at the block level. D has the same idea, but it can optionally be block or function scoped. &gt; but many people will still ignore it Then it's an infrastructure problem. Put the linter in your CI and require CI to pass w/o linting errors before getting into the codebase. In doing this, we end up with stuff like this: // we don't care about err here because ... _ = f.Close() This makes `defer` a little uglier though: `defer func() { _ = f.Close() }()`, but still readable, and it encourages good comments describing why we ignore errors. &gt; to avoid deadlocks you supposed to unlock locks in reverse order you obtained them [Variables are dropped in reverse order](https://doc.rust-lang.org/std/ops/trait.Drop.html#variables-are-dropped-in-reverse-order-of-declaration), just like `defer`, so you get this behavior by default. So `with`, `defer` and `Drop` _all_ do the right thing by default, and doing it another way is _possible_ and obvious. &gt; The hardest part in multitasking is to correctly use shared memory, correct use of locks etc, and go has the same issues most languages have It includes channels in the language and promotes that for synchronizing state over other options like locks. In many (most?) cases, a channel will work where you would otherwise use mutexes. And since there's language support (`select`, `val, ok := &lt;-c`, `range c`, etc), it makes it easier to do the right thing. That being said, I _hope_ the Go team looks at this use case when looking at requests for generics, since that's often how this type of locking behavior is implemented (`Mutex&lt;T&gt;`), though it would also need scope-based destructors to be really useful. Python's `with` isn't a panacea here, since there are many times when you need to manually lock/unlock and a `with` doesn't give you enough flexibility. So, Python _also_ has this type of issue. Both languages have tools to avoid common memory issues, I just prefer Go's design to Python's.
Thank you for your kind words :) Goja is not exactly a fork, I took the ast and the parser from otto, the rest was written from scratch. I have plans to gradually add some of the ES6 functionality in, unfortunately don't have much spare time right now.
no.. it's just a minor changes '\_\_') start now..
Thanks, I'll check this out.
What are some of the disadvantages of this? I recognize that trying to have two separate systems that have completely different paradigms can not correctly and easily implement the same interface, but in some situations this can be helpful.
I‚Äôm confused. What does this bring over Makefile + go.mod? Aside from not working with stuff like Renovate and go mod tidy.
Any link that explains go modules with simple examples? I've become so used to GOPATH
I love this advice / summary
Psst, https://golang.org/pkg/net/http/httptest/#NewTLSServer
The standard queue does not offer a rate limit though, which is what your package provides. I may have misunderstood your intention for the package though. I thought the focus was on the rate limiting part.
Dot imports make your code more fragile regarding future releases of packages. For example, if your code has a function "Foo" and the Go team adds a function "Foo" to package "fmt" in a future release your code will no longer compile.
&gt;`curl -fsSL https://azukaar.github.io/GuPM/install.sh | sudo bash` No.
In general, in Go, it's a good practice to eliminate source-level coupling between packages through the use of interfaces defined on the caller's side, so-called _consumer contracts_. Normally this decoupling is relatively safe, because it's still enforced by the compiler when you go to wire up your component graph. That is, when you try to pass a foo.ConcreteJob as a bar.JobContract in your package main, the compiler will complain if the ConcreteJob doesn't satisfy the JobContract. But in this case, your intuition is correct, there is less safety on offer, because the compiler isn't going to check that the error returned by some function has an IsTemporary method defined on it. There's actually no way for the compiler to do that, because you're boxing up the concrete error type into a generic error interface, passing those around, and then asking (not telling) the compiler if it IsTemporary, which can fail at runtime. In my opinion, Dave's advice goes a bit too far here, for exactly this reason. And I think if we zoom out a bit, it often makes sense that there _would_ be a source-level coupling between a caller and the API they call. Interfaces as consumer contracts are a way to encode the notion that the caller only cares about the behavior of the thing it's speaking to, not the implementation. But in Go, "behavior" is a term that really only captures method sets; when we start talking about types and values, that's "implementation", and errors are, in my opinion, implementation, not behavior. If you really wanted to do things Dave's way, but safely, you'd need your API package to have functions and methods that returned more specific error interfaces than plain error. For example, type API interface { Request(context.Context, Resource) (Token, TemporaryError) } type TemporaryError interface { error IsTemporary() bool } This would allow you to define a consumer contract for the API whose errors were safely checked by the compiler. But, the fact that you don't often see package or type method sets with errors like this in the wild is evidence, I think, that most programmers don't view this particular juice as being worth the squeeze.
[removed]
I think I understand why someone would write (h.fn)() in order to make it clear it's a field and not a method, but it's weird, and ultimately more confusing to me, not less. I would personally write h.fn() and probably ask (but not demand) the same in a code review.
Glad to hear I'm not thinking something wrong. &amp;#x200B; In your last example, things get better, but I guess Dave would say that you're forcing the implementation to depend on the API package. And he insists that's something *bad*. &amp;#x200B; What's really the problem of an implementation to depend on imports on an interface package is trying to satisfy?. I mean, if part of its existence is being an implementation of an interface, what's the problem? &amp;#x200B; Yes, implicit interface comply will avoid importing the interface package, but under the hood, the dependency is indirect in the source-code usage and the compiler will check it.
To tell the truth, we tried twice to use modules in our projects and it is too raw to use. It is very uncomfortable to develop with modules. Any editor (goland and vscode) I used work very strange and don't recognize locals or third-party imports from time to time.
I don't totally understand you when you write &gt; What's really the problem of an implementation to depend on imports on an interface package is trying to satisfy?. I mean, if part of its existence is being an implementation of an interface, what's the problem? But I'll try to answer it by saying this: All else equal, if I write a bit of code that uses a dependency to do its work, it's better to represent that dependency as a consumer contract than as a concrete type. That way I'm forced to think about the specific behavioral requirements (i.e. methods) that I need from the dependency, and use only those things when I do my work. When new programmers read my code, it's very clear what that code is doing with the dependency‚Äîit can only possibly use the methods defined in the interface‚Äîso there's no risk of it e.g. reaching into the internals of the concrete type and messing with stuff, which makes code comprehension a lot easier. And when it's time to test that code, I can easily create and pass in a mock (or fake, or fixture, or whatever) version of that dependency, so that I'm sure to only test the code I wrote, and not have to figure out how to, say, monkey-patch a concrete API so that it doesn't call out to the internet in a unit test. And, finally, it makes it easier to avoid things like import cycles, by keeping all packages essentially independent until they're wired together in whatever configuration you want in your package main. (This is part of what Go programmers mean when they say "Return structs and accept interfaces", i.e. functions should return concrete types, but take interfaces as parameters.) Of course, all of this theory is meant to apply to situations I describe in the first paragraph of my previous comment. It's more dubious when we try to apply it to errors and e.g. IsTemporary. Does this clear things up, or did I just confuse you more? :)
Persistence and durability layer: https://godoc.org/modernc.org/file Data structures atop of the previous: https://godoc.org/modernc.org/db Both packages are used by: https://godoc.org/modernc.org/ql
Thanks for your patience explaining. I agree with defining consumer-interfaces to avoid depending on concrete types, which allows easier testing and also future-reusability. What I tried to say in what you quote was the following: In his post Dave seems to insist that adding the source-code dependency to the API package isn't very nice. Precisely: &gt;If your code implements an interface whose contract requires a specific error type, all implementors of that interface need to depend on the package that defines the error type. &gt; &gt;This intimate knowledge of a package‚Äôs types creates a strong coupling with the caller, making for a brittle API. My question is: what is the problem of *all implementors of that interface need to depend on the package that defines the error type*?. If the implementor intention is to implement an interface of a certain package, what is the problem of depending on that package? Also, I don't understand his last sentence. Who is the caller in his explanation?. If as a caller I use the package *ioutil*, I'm already importing that package... what does he mean to try avoiding using depending on *ioutil* for error types if I'm already importing the package to know about the interface of the API?. &amp;#x200B; I'm sorry for many questions... but there's something that I seem to ignore here.
I'm working through this; [https://blog.golang.org/using-go-modules](https://blog.golang.org/using-go-modules) which makes sense. I'm having trouble putting them up on github and then importing into another go file though.
What advantage does this provide over a regular \`git diff\` (or whichever VCS diff tool)?
Basically it provides the information in one line and separated to Added, Changes and Deleted dependencies. The go.mod files does not contain sub-dependencies so diffing them only would not be enough. Diffing the go.sum files can be misleading too, since they record changes over time. :) You could diff the vendor/modules.txt files but it‚Äôs also pain to do manually.
Thank you so much! This is awesome reusable work. I'll likely rewrite my persistent queue package from leveldb to that.
Well ideally (almost) everything NPM has and more : \* more consistent module management (it's easy to have wrong dependency in Go mod) \* proper version range without using online proxies like gopkg \* offline mode \* isolated environment per project (your dependencies get installed inside the project and not globally) \* additional tools like env manipulation (test vs. prod env?) \* not having to write makefiles (+ windows compat) \* proper caching startegy for compatibility \* multi-languages dependency (ex: JS deps for Gopher, Java deps for go-mobile) \* serving your go binary as a dependency rather than a global module \* version / publishing management other than a git push
Check out the {{range}} template operation.
Thanks for the clarification. I don't know where the definition of fork ends, but I certainly know you put a lot of work into the project post using the parser and ast. I appreciate Goja very much, and I've poked at source in the past to try to gain enough familiarity to make a PR for the open issue requesting some additional annex b stuff. I need to somehow make the time to finish a small PR for that and remind myself what I learned. It isn't a lot of work, so I don't have a good excuse. I keep hoping someone will finish the PR for the ES6 Proxy, but alas, I stopped tagging noctarius about a year ago after no reply. I guess we're all pretty busy. If you find just a little bit of time, I would be very interested in seeing you accept the module support PR and pushing a tag for v0.1.0 or whatever pre-v1 version 1 tag you think might be appropriate. It would help projects use Goja without being worried about eventual API changes and such.
OK so I thought I should get back to you, because I've been thinking a lot about this question, and you know what? I can't think of anything. They may emerge if people get to grips with your system, but I think you could release now and it would be fine :)
In my mind, this doesn't really check any of the difficult concurrency problem boxes -- it just looks like someone wrote Promise.allSettled in go.
&gt; golang is so clean and tasty Strangely, yes, it really is.
Haha, thanks! I really appreciate this kind of honesty! I will release the proposal, but I decided to wait until GopherCon, because Ian Lance Taylor will present his new ideas on generics. If his ideas are great, then I won't need to release my proposal, if I won't like them, I will release it.
Editors not understanding the feature != the feature not working. Modules works fine. If your editor is really struggling put your code in `$GOPATH` and set `GO111MODULE=on`.
I use both, Goland has been doing fine since 1.11, vscode has been more rocky. It works great for us, but we never converted a project. It was modules from day one. I found $GOPATH to be less than desirable so was happy I got in at the same time as mods.
In what scenario would you need to "move around" in a text file rather than either reading it into your program or parsing out relevant information using the shell? It seems like this should be a job for bash.
I thought the official docs were pretty good. It‚Äôs basically ‚Äújust‚Äù a go.mod file in the root of your project and use imports like normal. The tools takes care of things pretty well.
Go for it! 1.13 isn‚Äôt charging things terribly much as a whole. Just use the go mod stuff from day one and you will be none the wiser :)
I wrote [goup](https://github.com/lpar/goup) to handle it.
https://github.com/d1str0/drupot https://github.com/Trevor Leake/magenpot
UPX is awesome, but if cold start is a concern it might be a case of robbing Peter to pay Paul. Would definitely agree about stripping, the savings can be huge!
What? Most of these are handle by go modules natively. Bringing npm to go seems like a solution looking for a problem
The use of references inside of closures to allow the use of a generic function in this way strikes me as clever rather than clear. Does anyone else have the same impression? Or, is it appropriately clear as well as clever?
More like a problem masquerading as a solution.
The latest minor version completely shifted gears on dependency management. The maintainers are currently considering significant additions to error handling. These are good things, but there are many many older and more stable languages. That said, OP should totally just start learning Go.
There absolutely is a technical problem being solved with microservices, it just may not be a problem you have. Monoliths scale vertically and there are technical limits frequently realized even with medium sized workloads. You can preach optimization, but microservices are easier to reason about, develop and deploy (and probably cheaper) than seriously optimizing compute, databases, network, etc...
This is a popular web series. Be aware that the repo code doesn't _always_ match the article. Might be better that way, though, as it forces you to find and fix inconsistencies ;) https://dzone.com/articles/create-versatile-microservices-in-golang-part-1
 i'd join all of the args into one reader using `io.MultiReader()` then wrap that in a `bufio.Reader`. that way you can parse it all as if it is one continuous stream. something like the following: ``` package main import ( "bufio" "io" "log" "os" "strings" ) func main() { readers := func() []io.Reader { rc := []io.Reader{} for i, arg := range os.Args[1:] { val := func() string { if i != len(os.Args[1:])-1 { return arg + " " } return arg } rc = append(rc, strings.NewReader(val())) } return rc } r := bufio.NewReader(io.MultiReader(readers()...)) for { r, _, err := r.ReadRune() if err != nil { break } log.Printf("%c", r) } } ```
This bugs me. I've seen this show up over on Windows with an install management system called Scoop or [Scoop.sh](https://Scoop.sh), something like that. I'm not at all fond of this trend of 'download and \*execute\*' a script directly from the internet. Doing it directly from github where you are additionally exposed to account takeover attacks just makes it worse. (Scoop combined the worst of both worlds - went to a private website, exposed to DNS attacks and DNS expiry takeover, that \*redirected\* to github, adding the github account takeover vulnerability). &amp;#x200B; Ramping that up to running a script you just downloaded as root? Now your computer belongs to someone else.
thanks alot, really good
My program actually aim to connect to a remote shell via SSH like bash/zsh/fish...(the one used by the machine you're trying to connect to). Then you can use this shell as you would use SSH(The program).
Dot imports suck, and languages that only have the equivalent of dot imports suck. (Looking at you, Ruby [otherwise a fine language].) Dot imports suck because when you see FuncName, there is no way to know where it came from unless you‚Äôve memorized all of the possible exports of everything you‚Äôre importing. That is crazy and does not scale to even medium sized codebases.
Wanted to repost this one after some heavy updates as I think it might serve some folks that want to produce images or documents. The vector drawing operations can be considered as an alternative to Cairo, but it also has some advanced text setting functionality and LaTeX (external) support. I've spend much time in perfecting the path operations to be mathematically correct, see the linked articles and papers in the readme. In the future I expect to implement full EPS target support and more advanced font parsing. Let me know what you think.
&gt; My question is: what is the problem of "all implementors of that interface need to depend on the package that defines the error type"? If the implementor intention is to implement an interface of a certain package, what is the problem of depending on that package? I think you are over-analyzing this relatively subtle argument, but I'll try to explain a bit more. Dave is saying that if your package returns sentinel errors, you're requiring anyone who wants to program against those errors to import your package. And, even more, this requirement is transitive, so if you use a package that uses a package that uses this package with sentinel errors, that outermost package would have to import the innermost package to program against those errors. Dave's claim is that this is something like a layer violation, exposing something like implementation details. You asked: "what is the problem of depending on that [innermost] package?" and I think Dave would say that, theoretically, you shouldn't need to know those sort of "implementation details" to effectively handle errors from packages. Concretely, at the bottom of the article, Dave suggests: (1) avoiding sentinel errors, because the only way to program against them is to compare against them directly, meaning you have to import the package that defines them; and (2) preferring to "assert for behavior", e.g. the IsTemporary stuff, which doesn't require importing the package where the errors are defined. I think this is what Dave means in his second sentence: &gt; This intimate knowledge of a package‚Äôs types creates a strong coupling with the caller, making for a brittle API. Dave's claim is that if a package uses e.g. sentinel errors, and if they ever decide to change which errors are returned in a given situation, consumers will break. But if the package uses error behaviors like IsTemporary, there is more flexibility for the package to change its implementation, without breaking callers. I hope that explains Dave's reasoning. Now I'll add my own comments: as you initially observed, there aren't well-known, general-purpose error behaviors like IsTemporary to check for, and I rarely see this kind of stuff applied in practice, so I'm not sure how pragmatic that part of his advice actually is. Furthermore, sentinel errors can be used effectively in lots of places, not only the stdlib, and I don't go out of my way to avoid writing them, as I generally find the benefits they bring to outweigh the downside of "source coupling", as Dave puts it. Finally, I want to emphasize that the points made in the middle of this article‚Äîand, I'll note, many of Dave's other articles‚Äîare subtle and sophisticated. I think the conclusions he reaches in the final section are basically sound and worth thinking about, but please don't get caught up trying to analyze the details. Especially as a newcomer to the language, there are IMO much better ways for you to be spending your energy.
The article was written before xerrors. For new code, use Is() and As(): https://godoc.org/golang.org/x/xerrors It will be standard in the next version of Go, but you can import it today.
Actually, I took for granted that no other than the direct caller was going to check against errors. So the transitive 'problem' wasn't in my mind. &amp;#x200B; Anyway, I'll take your advice about not get caught in this discussion. I think you helped me understand/confirm what are the important points on each type of error handling. I'll get back to this in some weeks when my mind gets more idiomatic on Go. &amp;#x200B; Thanks!
Interesting, will take a look!
No. Never wait to learn anything.
An implementation of error slice: https://godoc.org/github.com/carlmjohnson/errors
Maybe you can try: ```html {{ range $arr := .arrs }} &lt;div&gt; {{ $arr }} &lt;/div&gt; {{ end }} ```
&gt; The latest minor version completely shifted gears on dependency management. Previous minor version, really. Modules were added in 1.11. Some tweaks along the way, but no radical changes.
Hey, it looks great ! Kinda similar with gofpdf, but with more feature and better documentation. Kudos to you. Is RTL language supported ? I've tried it with Arabic, and unfortunately it panicked. By the way, thanks for your packages. I've extensively used your minifier and parser in the past, and it really helped me with my job.
I agree that third-party support is lacking, but that isn't magically going to be fixed the moment 1.13 is released. It will only be fixed when those projects are brought up to speed, which could happen tomorrow, a year from now, or maybe even never. Waiting for the day 1.13 ships isn't going to help on that front.
I'm curious whether the race detector would flag this or not.
I really didn't like how promise handling in javacsript removes the error handling from the scope of the execution path making it harder to know what was happening (as far as state) when the exception was caught by some global handler later on up in the chain. Now, you could certain catch and throw at every step, but then you're basically re-inventing an ugly version of Go's error handling.
so https://godoc.org/golang.org/x/sync/errgroup?
Yes it would. The errors slice is not synchronized. It boggles my mind how many Go developers never run the race detector and publish libraries. The amount times I have had to fix concurrency issues in libraries because I develop with race detector on is astounding.
Can you explain or point to a reference on how to use race detector
Yeah, I did this as well... But still have the problems with development
Just add the -race flag to go run. It will log to the console when multiple goroutines modify/read the same memory at the same time. It adds CPU and memory usage but most of the times it's not really an issue.
Is there a way to do this for something running on kubernetes?
So you're just making a wrapper? Why use the ssh library rather than just calling the `ssh` program using `exec.Command`?
I'm running one of my service which was already built with Django backend. It used the Django basic auth user model, it seems using PBKDF2_SHA256. This time I have to build another API to share the user data in the same DB. This code snippets are to hashing and compare the password. I hope this can be useful for anyone or hope to have a code review to fix from awesome developers like you folks.
Nah man. Monoliths can absolutely scale horizontally. And they‚Äôre a ton easier to reason about. Microservices are complex things that require a lot of work to make function.
I don't know if you can build a binary with -race. In any case these stuff should be caught with tests instead in production. I guess you can always have one special pod with race detector on.
I agree with [kapoof\_euw](https://www.reddit.com/user/kapoof_euw/), forcing the caller to provide a function (which itself is called in a new goroutine) is limiting, and allows a bunch of weird races. For example two queued items can be delivered out of order. In addition, the code does not seem to sleep the proper amount in [DeliveryQueue.Poll()](https://github.com/kisulken/deliveryQueue/blob/master/queue/queue.go#L59). I don't think you don't want to sleep the entire q.interval, but rather only what remains of the interval. Also for consistency and so intervals don't drift so much, I'd suggest calling [time.Now](https://time.Now)() once in Poll() and reusing the result. I also believe StopPolling() doesn't wake up a Poll() which is sleeping on interval. That's unfortunate. Imagine of the interval were long, like an hour. And the caller wanted to shut down the DeliverQueue, so they called StopPolling(), which returned, and then many minutes later Poll() woke up, and delivered one more message. That would be a surprise, and possibly cause bugs if the caller didn't anticipate it. Then again forcing a goroutine on the caller is also going to cause races between Stop and Poll's callback, so they'd have to handle it properly anyway, if they realized it would happen.
There was a good talk about writing a lexer a few months ago. Probably worth checking out.
Yes you can. It's just that the binary will run slow and take more memory than normal.
Nice. I was looking for sth like the Azure Functions Proxies, but not from Microsoft. I should be able to deploy this as a Google cloud function, right?
I usually have one start function and one stop function and on a signal receive I basically call the stop one and that triggers the start to return. But this approach is also valid.
if err != nil
Using the SSH program instead would not allow me to do some audit around logs(input/output from the session). Or maybe it is possible to get log from an SSH session but I'm not aware of any way to do that. I know you can check which RSA key was used to connect to the remote host using a specific level of verbosity in the SSH config and then checking in this file `/var/log/auth.log` but I don't know if it's possible to check for raw history.
this can actually be used along Emscripten
If you use `exec.Command` you get a `*Cmd` back, which has the methods `StderrPipe()`, `StdinPipe()`, and `StdoutPipe()` that allow you to write and read any data you want. Just forward the std* files to the command and write them to a file.
You *really* need to check the error from `rand.Read`.
&gt; Go &gt; high performance
Thanks for this post. I seems a much cleaner version of a query builder helper I did in my backend server. I'll add this modifications to my code as it will clean allot of boilerplate I have.
&gt;I seems a much cleaner version of a query builder helper I did Are you willing to share the code for this, or at least share some of the ideas behind it? I'd be curious to see you ideas other people have on this topic.
I filed a small issue related to subpackages not nicely being visualised. [https://github.com/jfeliu007/goplantuml/issues/24](https://github.com/jfeliu007/goplantuml/issues/24) Never the less if that would be in this thing is very usefull to generate this as uml as part of the documentation.
I'll be glad too, tomorrow when I get to the office I'll add a sample.
I mean that's how most PM gets installed, you dont have much alternatives. That said, since it bugs a lot of people, I will at least remove the sudo off it by installing in /home rather than /usr.
If you need more than PBKDF2 SHA256, I recommend checking out: https://github.com/alexandrevicenzi/unchained I've been using it in production for a few years now; solid library.
Nice article, I'm definitely a fan of first class functions. Haven't used gorm in years, but I think it actually kind of supports what you wanted to do in the first place: http://gorm.io/docs/method_chaining.html#Scopes
denormalization often leads to data fields repetition on NoSQLs dbs like cassandra, About that i recommend you use secondary indexes or [https://www.datastax.com/dev/blog/new-in-cassandra-3-0-materialized-views](https://www.datastax.com/dev/blog/new-in-cassandra-3-0-materialized-views)
Correct, it's not synchronized, but each goroutine(i) only writes to errors[i] -- that seems safe to me; is there a bug I'm missing?
It's an extremely minor change, it's just changing the default behaviour. It's been possible to work without using the $GOPATH since 1.11 :)
Sweet! I've been using fogleman/gg, but this has a few things that are nice to have. Excited to play with it to see if this is something I can switch to easily.
ACK
So, uh... Does that means I can run this? https://ccbrown.github.io/wasm-go-playground/
SYN?
/r/ackackack
...why
Hey, one of the authors here. &amp;#x200B; The reasoning behind this project is that I always wanted a simple commandline tool allowing me to join data from different places, without needing to set up stuff like presto or spark. On another hand, I never encountered any tool which allows me to easily query csv and json data using SQL (which at least in my opinion is fairly ergonomic to use). &amp;#x200B; This started as an university project, but we're now continuing it as an open source one, as it's been a great success so far. &amp;#x200B; Anyways, feedback greatly requested and appreciated!
[In the movie ‚ÄúMars Attacks‚Äù the Martians all talk like that](https://www.youtube.com/watch?v=YklZBA9UBjc). Since you called your project `martian-lang`I attempted a joke. (If you haven‚Äôt seen it I‚Äôd definitely give it a watch.)
One, not OP. Two, was making a networking joke and subsequently forgot that Reddit will be Reddit.
Unfortunately, materialized views have a lot of problems in Cassandra (e.g they aren't consistent and are flagged as experimental), and Cassandra's secondary indexes are local only.
Great feedback thanks. I'll take a look.
OP (Endtest) is spamming up tech subs, every day with multiple accounts [1,](https://www.reddit.com/user/boss_scarbos) [2,](https://www.reddit.com/user/dragnea_presedinte) [3,](https://www.reddit.com/user/llupei) [4](https://www.reddit.com/user/wernerklaus), [5](https://www.reddit.com/user/jos_cu_klaus), [6](https://www.reddit.com/user/sa_vina_werner), [7](https://www.reddit.com/user/ihavelepower), [8](https://www.reddit.com/user/viorica_presedinte), [9](https://www.reddit.com/user/werner_sclavul), [10](https://www.reddit.com/user/basist_infect), [11](https://www.reddit.com/user/felix_presedinte) ultimately in an attempt to make you pay money for the service he runs (endtest). [This is the kind of person you're dealing with here](https://imgur.com/xyfZ59P) Still want to give endtest money? **Vote and report accordingly.**
Great work! Can this be included into [https://github.com/golang/lint](https://github.com/golang/lint) ?
Basically, but their second version returns a slice of errors. &gt; Wait blocks until all function calls from the Go method have returned, then returns the first non-nil error (if any) from them.
You can run a Go program with the Go playground compiled as a WebAssembly binary, inside a Go program that uses the wasmer library. Yes. This is very meta, and probably useless, but fun, but yes :-p.
try() can go anywhere a function call can go. Where it really comes into its own, is in constructions like this: 'x := func(42, try(efunc()))'. Which is a lot shorter then: ``` temp, err := efunc() if err != nil { return } x := func(42, temp) ```
So I posted about an early version of this tool already 3 weeks ago, but it now has evolved into something completely different, which generates GitHub badges from Astronomer reports. Examples \[here\]([https://github.com/Ullaakut/astronomer/releases/tag/v1.1.0](https://github.com/Ullaakut/astronomer/releases/tag/v1.1.0)) Feel free to play around with it :)
The \`newSelfSignedCertificate\` function looks like caddy's [code](https://github.com/caddyserver/caddy/blob/master/caddytls/selfsigned.go). I guess a mention to it should be added.
&gt; Which is a lot shorter then Can't care less. It is easy to see what is happening. And use your editor snippets to write less.
&gt; I kinda support this feeling. I don't like implicit magic. It's just sugar for the usual case. It was clear based on the normal error handling methods that try was not just a simple convenience but one that removes an oft-brought-up complaint from golang programmers of all skill levels. In a similar light, we use `switch` instead of `if` sometimes. You're just adding a syntactic sugar for complex branching that could be made more explicit using only `if-else if-else` statements. I can't comment on your thoughts on where it could lead because it's just speculation. `try` is still technically declarative and is no more implicit than `switch`. A language without convenience at all would look pretty bad tbh, and choosing the conveniences we want to have is part of evolution of all languages. the arguments about context, sure I understand them. However defer calls to inject context are not really the major goal of `try`. The major goal is to make the 99% case easier to code for. most error handling is just the following block ``` if err := something(); err != nil { return err } ``` might be slightly different, but you get the idea. Try is just a sugar for this immediate return. Re: context... adding context to an error as it happens imo is not elegant anyway and it reads horribly. At that point just implement exceptions and allow them to bubble up with the unwound stack. If this is what we really want lets not skirt around the bush, but then again this is contested as well.
I actually have a ticket this week to investigate/POC this tool for adding auth to an internal web app. Has anyone used it before that can say a bit about what they think?
i regret the post above. instead, you could have simply done something like: ``` for rr := strings.NewReader(strings.Join(os.Args[1:], " ")); ; { // ... } ``` since `strings.Reader` implements `io.RuneScanner`.
I think the idea that what is arguably the first major change to the language itself in _seven years_ is suddenly going to open the floodgates to massive change is ridiculous. I was saying many languages change too quickly and often before it was cool. I've been saying C++ and Python should pretty much just declare themselves done and stop adding stuff for the last four or five years. But that doesn't mean the solution is to never do anything; that extreme is wrong too. &gt; I'm not suggesting to abort try() completelly. we could just b have to discuss more and check other proposals. The truth is, we've _had_ that discussion. Interminably. At this point, it's time to do something, at least experimentally, and see how it goes. Otherwise we might as well just throw in the towel and declare that nothing is ever going to change ever again. And if that appeals to you, then just lock yourself to the current version of Go; you don't need our permission to do that. It's weird, after so many language communities I've been in that are frankly way too excited about pretty-shiny changes to see a community actively _terrified_ of change like this. If nothing else, honestly, I'd support shipping `try` just to exercise the joints a bit and prevent this calcification from setting in. It's not healthy to be this stuck to the current, exact design of Go. It's a good language, maybe even a great language, but that's all; it is not perfect, and it is not impossible to improve it.
We used casbin (the non-server variant) and tossed it. It depends on what you're looking for. The big hangup for us is that Casbin operates in-memory, only writing when you tell it too, so unless you write all the time there's the chance that a server crash loses your data. Additionally, we have multiple nodes, and rather than try and set up etcd or something so that multiple casbins could stay in sync, just opted for a solution where the persistant data lives in a database (we went with `ory/ladon`, although `ory/keto` is their new hotness?)
It's not the writing less that's the problem. It only takes a few seconds to type the err stuff even without and IDE snippet. The problem is reading. The error code really clogs up reading and understanding what's going on in the code. It's like the LISP folks who keep saying the parens don't hinder readability and "you get used to them." Some people do, some people don't. But the people who do get used to them often forget that many never do. They keep going like everyone reads code the way they do. This same thought process seems to hold for error code in Go. Maybe an alternative is to just consolidate the error handling. Something that will take care of readability in these boilerplate cases. Something to take all that if err != nil return code, shorten it but leave it contextually the same, and then drop that shortened code in place if all the boilerplate. I'm sure something like this would make everybody happy.
A couple issues with the code, it probably works for your case, but there are some details that make it not work for everybody. There is also a security issue. **Security Issue** You need to be making a constant time comparison, instead of doing a `hash == dbhash` comparison. You should use [subtle.ConstantTimeCompare](https://golang.org/pkg/crypto/subtle/#ConstantTimeCompare) to compare the byte arrays. This prevents oracle and timing attacks that can be made to determine the password based on the time it takes to get an error response. **Hash Compatibility** What really needs to be done is to parse the hash, the first bit is the algorithm, i.e. `pbkdf2_sha256`, however in older instances, you might find `pbkdf2_sha1` or `pbkdf2_md5`. The second bit is the rounds, the `100000` in your hash is the iterations, older django instances might have used a lower number in the past. If it works for you and you know you don't have to deal with the older hashes, then this code works fine (until django changes a default in a future version). Just make sure you update to use the ConstantTimeCompare function to check your equality.
I had a very specific need for easily generating static GoDoc sites (yes I know there are ways to do this with wget), for publishing on an internal documentation portal. I also wanted to fix the links, and strip out some of the links which are useless to me. So I put this tool together last night to solve my use-case.
&gt;I think the idea that what is arguably the first major change to the language itself in &gt; &gt;seven years is suddenly going to open the floodgates to massive change is ridiculous. &amp;#x200B; I totally agree :D my post was exaggerated. and was a test. &amp;#x200B; I wanted to check if anybody would bite the bait, and suggest even more changes on the proposal. if anybody agreed to any suggestion, \*then\* I would get really worried ;) &amp;#x200B; so far I'm not too much into the try() team, but as you said, we better release it in the field, and see what happens. it is much better if a simple change fail, than if a big one fail. &amp;#x200B; this change may just contribute to the maturity of the community process and the language.
Try the golang track on Exercism (https://exercism.io/tracks/go) - practice problems with feedback from mentors
https://docs.google.com/document/d/1Zb9GCWPKeEJ4Dyn2TkT-O3wJ8AFc-IMxZzTugNCjr-8/edit?usp=drivesdk
[removed]
[removed]
This looks very cool! I have previously used [https://github.com/timshannon/bolthold](https://github.com/timshannon/bolthold) and [https://github.com/timshannon/badgerhold](https://github.com/timshannon/badgerhold) which seem to be very similar. It would be nice to see a comparison between those and see some benchmarks against those!
Oh! This is great news. I took a lot of interest when you fist announced work on the Go availability, and I'm looking forward to trying it at version 1
&gt;x := try(myfunc()).OrDefaultsTo(y) This won't be a problem because try(func() (T1, error)) returns T1. So unless T1 has a OrDefaultsTo() function this won't be possible.
If you want a book, you might try "Get Programming With Go" by Nathan Youngman and Roger Peppe.
RST thread
You can sign up for daily coding questions at dailycodingproblem.com and solve them in go.
Good point, I haven't tested any RTL or vertical text yet. Great to hear you find my packages useful!
Nice, yes fogleman/gg is a nice project that gets the job done. Let me know your experience with the library, whether something is missing or whether some functionality seems counter intuitive to you.
The server should not leak connections no matter what the client does. This looks like a mix of client and server code. \`\`\` 2019/07/15 16:16:59 http: Accept error: accept tcp \[::\]:8100: accept4: too many open files; retrying in 1s 2019/07/15 16:17:00 http: Accept error: accept tcp \[::\]:8100: accept4: too many open files; retrying in 1s \`\`\` Can you mock out having the server contact the client (what it looks like is going on... a server spawning a client), and see if you still leak? On Linux, you can can count filehandles for a process using proc \`\`\` ls /proc/{thegoprogrampid}/fd | wc -c \`\`\`
Have you done any profiling (using net/http/pprof)? Monitoring the goroutines might indicate where you leak, if at all. I have also encountered CLOSE_WAIT states on sockets once before. Before a port can be reused you have to be sure that there is not any delayed data from the old session that can be misinterpreted in the new session (Nats make it near impossible to be sure that a new connection has a different ip, for ons example). The Linux kernel waits a while (I don't recall how long, but it was crazy, more than 'n hour) before reassigning ports. Now I am not sure if those ports count towards file handles. All of this is from memory, so it might not be 100%
 obx := objectbox.NewBuilder().Model(ObjectBoxModel()).Build() Great demonstration of how nice options are. https://commandcenter.blogspot.com/2014/01/self-referential-functions-and-design.html https://dave.cheney.net/2014/10/17/functional-options-for-friendly-apis
Is it fast and lightweight better than Electron?
Ohh. Note for others: the actual persistence is implemented by a C library. You're told to install it with bash &lt;(curl -s https://raw.githubusercontent.com/objectbox/objectbox-c/master/download.sh) 0.6.0
Don‚Äôt use math/rand for crypto!! That‚Äôs why there‚Äôs crypto/rand.
I have the full dump of \`lsof\` during that time, so I know it was my process that had 10k TCP connections in \`CLOSE\_WAIT\`. Any clue as to what this might be? Is it a specific endpoint that's problematic, or is it something that applies to all the endpoints? Could it have to do with a library I'm importing? And most of all, why oh why isn't it enough for the client to close the request -- feels like this should close it on the server side as well, but instead they seem to sit in \`CLOSE\_WAIT\` for an undetermined amount of time. Any ideas what I can do to get to the bottom of it?
Yes its based on that file. You can see me also as contributer to that File in caddys repo. Most Code is from others ( Go authors Std lib), it would be fair to mention all owners, but this was a quick solution. It was always to complicated to get a fast TLS config
Is there anything wrong with the standard net/http package? [https://godoc.org/net/http](https://godoc.org/net/http)
And we initially based ours off of this in the standard lib: [https://golang.org/src/crypto/tls/generate\_cert.go](https://golang.org/src/crypto/tls/generate_cert.go) \- but mostly to verify that our procedure was correct as it relates to verification of certain values. There's only so many good ways to generate a self-signed certificate correctly (and even now we are probably still missing something).
The best way is to find well written open source code on github and spend some time reading or even fixing some issues (adding test cases of course).
REST calls are nothing more then HTTP calls so [https://godoc.org/net/http](https://godoc.org/net/http) should satisfice your needs completly. or in short terms: its build in :)
Oh, literally nothing. Thanks.
Thanks. It looks like the library is pretty nifty. I was actually asking about the state of internal libraries, so it looks like http is a *first-class citizen* in Go, nice. Looks like I'll be diving in to this project with Go, thanks again.
That's fantastic! I like it :)
This is really cool, thanks for working on it! I've been considering writing such a tool myself in the past, but decided against it because it's a lot of work. Especially when trying to support advanced SQL features.
Try to take a look at this one : https://github.com/recoilme/slowpoke
How does the first layer decides to which second layer the request is going to? Do you have it in a database or do you utilize consistent hashing? Maybe the database tcp connections are leaking.
im like 95% sure that you will never ever get a internal rest library because that would be aggainst the whole idea of GO (lightweight, easy, no clutter). Technically you have everything you need with [https://godoc.org/net/http](https://godoc.org/net/http) and [https://godoc.org/encoding/json](https://godoc.org/encoding/json) you can however use one of those external libraries (which aggain is the idea behind GO) but i strongly recommend that you start off using the internal ones first, because otherwhise you will have a hard time debugging stuff and getting used to the GO basics.
It's not a problem in Ruby because Ruby uses module nesting for qualification of function names. While it's possible, it's a faux pas to implement global functions in modules for import. Now, it'd make sense to call out Python on this.
From the FAQ: &gt; Is this an alternative to Electron? &gt; &gt; Depends on your requirements. It's designed to make it easy for Go programmers to make lightweight desktop applications or add a frontend to their existing applications. Whilst Wails does not currently offer hooks into native elements such as menus, this may change in the future.
Few thoughts: You should reuse the http client, this is your biggest problem imo You don't need to close body on the server side You should have timeout in both server and client.
You are probably not closing properly on the server side. This isnt the clients fault.
I do reuse the client, I have it as a singleton. Also have timeouts on both sides. Anything else it could be?
Awesome how might that be happening? On the server side I close the body after reading it via a defer ‚Äî anything else I need to do? TIA!
Thanks. I was just trying to make a joke. Didn't work well apparently :-/ &amp;#x200B; Regarding Go and classes: "Classes" in the traditional OOP sense can inherit type definitions and behavior from parent classes, and Go deliberately has no inheritance. UML has its roots in OOP languages, hence with a focus on inheritance, which is why I find it a quite interesting idea to use UML with Go.
are you also closing the writer of the response, not only the reader of the request? :D &amp;#x200B; &amp;#x200B; Is the defer being called? how are you implementing the server?
Are you creating a client on every request? And did you try to set no or low keep alive in the server layer 2?
The client is a singleton but interested what you mean about keep alive, how do I do that? Sounds like that could help? Thanks!
[removed]
Interesting what do you mean by writer of the response? I just do a w.Write(bytes) ‚Äî I don‚Äôt close it explicitly. Do you have to?
Can you show us a paired down example of the server code? CLOSE_WAIT makes it sound like the client did close() its side of the connection and the server never calls close() on its end.
&gt;Interesting what do you mean by writer of the response? I just do a w.Write(bytes) ‚Äî I don‚Äôt close it explicitly. Do you have to? YES. \&gt; defer w.Close() &amp;#x200B; should do the trick. give it a burl
It is, though we're definitely not trying to be fully compatible with the SQL standard anyways. (There will surely be a lot of features we won't support). On the brighter side, at least a lot of the stuff is already well thought out, so you don't have to break your head on thinking about how to design some feature for ergonomic use, you just have to reach for the SQL standard.
Thank you very much, reading slowpoke/pudge code helped me in educational way. Hope you'll find something useful in following. Admire the "always sync" feature in time when most people only want faster writes. Though I failed to understand how it makes sync at every write. - `slowpoke.Set = return pudge.Set` - `pudge.Set = Open(filename, nil).Set` - `pudge.Open(filename, cfg*Config)` uses DefaultConfig when nil - `DefaultConfig.SyncInterval = 0 sec, 0 - disable sync` - `pudge.db.Close()` would call `db.f{k,v}.Sync()` but can't see if anything is calling Close. It doesn't make any checks that written data is read back unchanged. And "delete old backup file before [creating new] + ignore all errors".
How popular is WebAssembly? I haven't heard of it being used outside of an occasional tech demo. It does seem useful though.
Haven't find integrity checks, did I search wrong keywords (hash) or is it on purpose?
There are good frameworks, but simple requests can be made with the net/http package (imported as written). Also, REST isn't a kind of network programming, its an architectural template for general web services.
https://golang.org/pkg/net/http/#ResponseWriter The ResponseWriter does not even have a close method, so not sure what you are referring to here.
Close-wait is exactly what it sounds like. The connection has been shut down protocol wise but the kernel is waiting for the program to call the close system call. Only your program can close the fd, because you might still be using it even though the connection is closed (polling, getsockerr and other syscalls). You still need to determine if these are fds created by Accept or by Dial. Are you using the net package directly anywhere or via net/http only? There's a missing net.Conn.Close call somewhere but the tricky part is to figure out where.
Maybe these `TestWAL*` tests are what you're looking for? https://gitlab.com/cznic/file/blob/939bb01b4fd0a55ea6e08826217893077285b9c9/all_test.go#L1712
This looks great!
Sorry for not being clear, looking for something like this during normal operation, not in tests. ``` // https://github.com/syndtr/goleveldb/blob/02440ea7a28525b3079783ad9c27083994a42366/leveldb/table/reader.go#L568 if verifyChecksum { n := bh.length + 1 checksum0 := binary.LittleEndian.Uint32(data[n:]) checksum1 := util.NewCRC(data[:n]).Value() if checksum0 != checksum1 { r.bpool.Put(data) return nil, r.newErrCorruptedBH(bh, fmt.Sprintf("checksum mismatch, want=%#x got=%#x", checksum0, checksum1)) } } ``` Are you the cznic person? Thanks for c-for-go, it's great and saved me from hours of stupid work.
Been working through Gophercises.com. It's the best I have come across for any language. Really a blessing when learning a new language.
There are a ton of excellent tutorials, but the best way is the same as any other language - pick a problem and start solving it, piece by piece. That said, my favourite Go tutorials: [https://lets-go.alexedwards.net/](https://lets-go.alexedwards.net/) \- effectively you recreate github gists as a go app. Uses new module system. [https://quii.gitbook.io/learn-go-with-tests/](https://quii.gitbook.io/learn-go-with-tests/) \- TDD driven tutorial. Whether or not you like TDD, IMO it's a good way to introduce a lot of Go concepts.
Direct link to the Github repo: [https://github.com/objectbox/objectbox-go](https://github.com/objectbox/objectbox-go)
https://purpleidea.com/misc/mentoring-program/
Meta programming can be a double edged sword. It has its use cases although I would agree that when you get into run-time reflection the negatives far out weight the good. I personally prefer a good DSLs or fluid API when it comes to hiding boiler plate and I don't think annotations are that bad if you keep them to a manageable number like Retrofit or Moshi but then again I usually reach for Fuel instead which is a dsl and fluid api.
Fair enough. I saw your contribution after posting my comment, when I went back to the source code to verify that I wasn't completely wrong üòÄ
Since this is the Go subreddit, I would have liked to see chromedp in the mix: https://github.com/chromedp/chromedp
Looks interesting, can you give an example of a high performance computation pipeline? Bonus points if you add it to README of the repo.
Namespaces are a hack solution to the problem of crap import systems. Yes, *if* everyone follows the namespace and autoimport conventions, it‚Äôs *more* predictable, but that‚Äôs just a conventional bandaid on a fundamentally flawed system. Languages with only the equivalent of dot imports are defective, fullstop. You always want your imports namespaced, so why make that the option that takes effort and convention? It‚Äôs like languages that require a `break` between switch cases: you can work around it, but the system is broken by default.
This. So much this. The built in libraries are amazing. Third party libraries can add things that are useful, but don't use them out of the gate. For instance, I've found exceedingly few instances where I've needed to use a JSON library other than encoding/json. It just works.
do resp.Body.Close() right after you obtain resp
How stable is the API? This seems like it could be a great library for, say, data processing
good
I thought ‚Äòtry‚Äô was good. Oh well.
Look up how AutoCad uses WebAssembly. Definitely the coolest wasm example I‚Äôve seen so far.
I like the approach that is taken wrt to experience reports, openness and efforts to take an objective view. It is a good way to trigger meaningful discussions and conclusions, thanks Go team!
Can't say I was excited to have try added in the first place. It seemed like there wasn't a way to concatenate messages to the error string with it.
i mention looking at client code to troubleshoot a server problem, because you have to not leak due to client mistakes, disconnects, or actual client malice. sure, you might find that you have a client that is not closing connections and fix your client, but the leak is still there if any client can still be written to make it happen. i had a load testing client that was running my service and all proxies in between us out of file handles (all of them, with Vegeta!). I had to just put in admission control in all processes (proxies, and my actual service) to just limit the number of outstanding requests, because filehandles are finite.
Well, I'm glad someone tried
The ... is just cutting out stuff where I set up variables, just a bunch of string operations nothing interesting. Is your thought that if I get an error in the request I could end up not closing the connection? For some reason I assumed an error meant there was nothing to close?
Interesting, thank you so much! It does indeed sound like there is a missing close somewhere. And i certainly suspect it's in layer 2, because I haven't seen this in layer 1. I do actually use go-pg in the layer 2 code, so I was thinking that as well, but what doesn't make sense is that I can see the leaked connections are between the layer 2 node and the layer 1 node. So I'm pretty sure it has something to do with the web request from one to the other. I like your idea of stripping down the code until I can reproduce it on something fairly simple. Truth is I don't have a reliable way to reproduce it at all right now!
I haven't, what's the best way to monitor the network side of things? Or do you mean just normal \`pprof\`? These FDs are hanging around a long time, so doubt the kernel is doing it on purpose. :(
Yes! Thank you, whatever/whichever ‚ÄúComputer Jesus‚Äù made this happen!!!!
Nice
F
I caught that
Sorry I made a mistake when reading your code. Yes I think it's fine. The reason why I asked about ... is because of the code looks indented and I thought the problem could he hidden in there. Can you post what you do in the second layer too? Again, maybe the problem is in the details.
Well, that's one less tech to track on this end. /shrug
Thank you Go team. I hope you declined it because you agreed with the arguments raised by the community and not just because of the overwhelming majority of comments being against it. I personally didn't like the proposal as much but I'd hate it for Go to become a "democratic" project where the community bullies the Go team into making popular decisions.
finally..
No. golint checks for violations of a specific style guide. That guide does not disallow the use of `defer` in loops. And generally speaking, not all defers inside loops are bad.
This is a package I wrote a pretty long time ago, but I figured I'd share as over the years I've found the data structures (in particular the ordered map) to be really useful for several projects.
Honestly I love Go, my biggest gripe with it is the primitive error handling. I know I‚Äôm going to sound like a Java dev but exceptions are a must.
thank goodness
Go has exceptions. It's called panic/recover. Yet we are told to just not use those, because they're icky in the eyes of the Go devs.
i hope they decline everything. so many languages have become overburdened by the addition of unnecessary features it‚Äôs nice to see some pushback against that trend.
Exceptions are categorically worse because it‚Äôs non-obvious and near impossible to know what your code *actually* does. Not to mention the stupidity of people using then as flow control (no, http errors are not exceptional, they are the norm!). Lots of languages have them, it just breeds laziness and bad practices. I‚Äôm happy the try proposal got shut down, specifically for the same reasons exceptions are bad. They are difficult to reason about and interferes in writing solid software intended to do a job rather than impress people at conferences. Try was magic and cleverness. I hope they iterate until they find a better solution, but right now this is the best I‚Äôve seen honestly. Getting rid of errno was a big improvement.
My problem is that it‚Äôs impossible to evaluate the type of error that‚Äôs being returned from just a string. It becomes complex to guess the behavior of third party libs without typed errors/exceptions. If I know a function may throw, then I can handle what it throws at me. In case of a function returning nil or a string as an error message, I have no idea how to handle those sanely. Also, this is purely my opinion, I‚Äôm not saying that I‚Äôm right and you‚Äôre wrong. I just dislike that particular aspect of Go that‚Äôs all.
Just to be clear, this doesn't persist data across runs, correct? Shutting down the app clears the database?
I guess hope is the wrong word as it implies I don't entirely trust the people leading the Go project. To clarify, I did not mean that.
panic
[removed]
You don't have to handle stringly typed errors. Wrapping errors properly and checking if a certain error is in the error chain is part of the [proposal for inspecting errors](https://go.googlesource.com/proposal/+/master/design/29934-error-values.md), in particular the `func Is(err, target error) bool` and `func As(err error, target interface{}) bool` improve error handling greatly.
best news of the day!
So what's the proper way to bubble errors without losing context?
Agreed, look at typescript. Thats a bloated language in a short time
Run the survey again. Most devs got used to (and I think most of them like) how errors are handled.
Yeah, I think it would have been useful as well but I don't know if it's useful enough to warrant it's own language feature.
https://godoc.org/golang.org/x/xerrors
Well, it's JavaScript with types, after all.
\+Kotlin +Rust - there are merits to both, but there are some complaints/worry about both being overburdened already. I really appreciate Go is taking a different approach.
That's better
recover
Anybody got any of those generics?
indeed
If they were going for volume, I think they would've declined a long time ago lol. I think they were convinced by some legitimate criticisms that could not be addressed and which were not considered at the time of writing. A vast majority of the comments were predictable and many even addressed in the proposal itself, but the code coverage aspect (for example) is a fundamental shortfall that would require substantial changes to analysis tools if it were solvable at all. I think the feedback about not solving the right problem took awhile to sink in because the if err boilerplate is like one of the single most common criticisms of Go and something that single-handedly keeps people away from the language, so they were weighing community feedback against community feedback, which is always going to be harder.
You should checkout rust if you want strong error detection. Honestly kind of annoying as Rust forces you to handle every scenario. For smaller programs Go is more simple and easier to get up and going.
Except.....
I hope everyone remembers this when future contentious proposals come out, so that we hear less complaining about something being "forced into the language" or whatever. When the Go Team says they are willing to decline a proposal or pull a feature, they have shown us they mean it.
As a newbie to Go, is this something that should be implemented at the package level now?
Or else?
For the record, they also pulled the first version of type aliases, which Google really wanted but the community hated. The community agreed to the version that finally shipped.
No, ‚Äútry‚Äù was a proposed macro for if err != nil. It can‚Äôt be implemented by user code.
Even if it's theoretically safe, it's easy to screw up, and makes your code unable to be run with race detector. I think you have to either wrap access with a mutex or pass a ref via channel to avoid having the race detector go off. Considering the race detector caught several race conditions in the stdlib, of all things, it's best to keep to patterns that the detector does not flag.
Yes, Go‚Äôs errors are functionally the same as Java. Panic is an unchecked exception, and error is a checked exception. But culturally, it‚Äôs quite different. For one thing, the convention is to just use ‚Äúerror‚Äù instead of a concrete type.
Yay!
They have the survey every year.
Yay!!
Lot of cheering in here, but for me, this validates my life choices to use less Go. When the userbase declares that the current error handling story is adequate, it may be worth pondering whether the last couple years have filtered the userbase to people with a high tolerance for pointlessly obnoxious design decisions, and questionable definitions of "simple."
Now if only we could get enums.
ensure
[removed]
I have not used it nor am I an expert but my understanding is it has the potential to be a serious targetable runtime once high level features like memory management are fully landed in major browsers and engines. Teams that have the manpower to smooth these edges are already finding use for it. Someone mentioned AutoCAD. Microsoft has done some interesting work with Blazor and .NET Core demonstrating how someone might run a core app as webassembly in various situations. I think games and other "need native performance" applications are good examples of what can be done today. For now it's in my "promising and nascent" folder as a business software coder.
I don't get why "try" was declined but "check" is still in the running... [https://github.com/golang/go/issues/32811](https://github.com/golang/go/issues/32811) &amp;#x200B; With catch: `x, err := f(2)` `catch(err)` `y, err := g(x)` `catch(err)` &amp;#x200B; With try: `y := try(g(try(f(2))))` &amp;#x200B; I hope we get something that'll allow the last version. If not people will just use their own homegrown boxing and return types, which is never great for readability.
Exceptions are probably the worst form of error handling, and I‚Äôm not a Gopher.
I am looking at this to replace an Adobe AIR application. I have done this search every six months since 2015 or so and Wails is my first real glimmer of hope. The idea is levage a native web runtime on each platform to go unlike bundling chromium to node. This reduces a lot of the bloat with a risk of platform specific differences and drift. I am hoping the upstream rewrite of lorca or webview (wails uses webview currently) completes successfully.
Go vet will warning you to use "ID" , not "Id".
It seems persistent. The package just a db client.
I'm leery of the transport in the client. The docs say to create the transport once with good defaults and reuse it, and the [default transport](https://golang.org/src/net/http/transport.go?s=21337:21384#L37) has far more timeouts being set by default than you have provided in your version. I don't know enough about what's going on under the hood to know if the single timeout set at the Client level is enough to catch everything bad that could happen.
URL query parameters are `key=value` where key and value are just strings. It doesn‚Äôt care if there are brackets or not, it‚Äôs not going to try and interpret your key into something else. If you have two different fields, just give them different names (no brackets), and then put them into whatever data structure you want in your http handler.
Have to say, I had mixed feelings on the try proposal. In the end though, I am content seeing this rejected.
What a relief!
It's not only a client. It is apparently an embedded database with a C library dependency
Feedback more than welcome :)
await?
Are you trying to make a daemon? Or something a user would click and run in the UI? If it‚Äôs a daemon, then you‚Äôll want to have it run via `launchd(8)` in macOS or `systemd(1)` on Linux. You can google for more info on how those are setup. If you are looking for a way that users can launch it from the GUI, there are some different options. For Mac, you could embed the binary into an AppleScript bundle and launch it that way, but your user interaction is very limited (and you‚Äôd need to learn some AppleScript). You could also try [Platypus](https://sveinbjorn.org/platypus) which might be easier.
Having read the arguments, I come to more or less the opposite conclusion. It's not that the current error handling story is adequate (though, there _are_ people who feel that way), it's that try simply doesn't solve the right problems. It's entirely a questionable definition of 'simple' that people thought made it _harder_ to do things correctly in many cases. And the discussion brought to light a number of aspects of both current error handling methods _and_ the proposed try language that need to be improved.
I don't drink the Go kool-aide, but the panic/recover model really is icky (and so are exceptions) in highly concurrent applications. I will say this for Go: it forces you to take your sad paths as seriously as your happy paths. That's not always desirable, but it's usually a good idea in the types of applications that Go was designed for.
Are you able to go into more of what you are doing on the app server side that has the CLOSE_WAITs? Are you using mux or Buffalo or anything? goroutines? CLOSE_WAIT means that the client sent a FIN packet, you could confirm that with a packet capture, but the application is not closing the socket. I would think this exonerates the client you wrote and the issue is on the server code.
I edited the original post to include a snippet of the server code. It's the same general pattern most of the endpoints follow, curious if you see anything in there?
I just added it to the original post if you have any ideas! TIA!
I just added an example of a server-side (layer 2) endpoint -- thank you in advance for all your help. The gopher community is awesome!
I was going to make some snide remark about picking a topic that wasn‚Äôt so beat to death, then I read it. You go into some serious under the hood detail on how the channels actually work. Very very cool! Good job.
Looks really useful. May I suggest adding a convenience method so I don‚Äôt need to instantiate a new tracer? Something like xtrace.Trace(err error)
That's a great idea! I'll get something together for this soon.
&gt;Are you using mux or Buffalo or anything? goroutines We use \`mux := http.NewServeMux()\` to compose our \`http.Handler\` but nothing fancier than that. We use goroutines plenty in the backend stack but the handlers don't use goroutines, they all call synchronous functions in the backend and then return the output as JSON. TIA for any ideas you have!
Yea for a convenience method, just having it print to stderr is probably sufficient. Just a standardized format. The less that needs to be configured, the better. Then if one needs the customization they can make their own function that does that. :)
Where is the database "located"? Is it like sqlite where there's a file saved locally, or is it remote, or what?
I like how V handles errors with option types: https://vlang.io/docs#option It's a lot less verbose that err != nil all over the code and you get advantages of exceptions like ability to bubble up.
There's check for structural integrity of the [`*Allocator`](https://gitlab.com/cznic/file/blob/939bb01b4fd0a55ea6e08826217893077285b9c9/file.go#L1270). But there are no checksums. The model used here is on a low level. The API allows to overwrite a single byte anywhere within an allocated block. Having checksum/CRC/etc would make perfect sense at a higher level. &gt; Are you the cznic person? Last time I checked, yes ;-) &gt; Thanks for c-for-go, it's great and saved me from hours of stupid work. Thanks, but that's not my project nor I ever contributed to its code. All the work was done by [xlab](https://github.com/xlab/c-for-go).
Good news
I don't know if I'm seeing this right but I can see two potential issues. You don't defer Close request body as soon as you get it. Second, might not be an issue as it might be enforced by Body Close but also try to defer io.Copy(ioutil.Discard, req.Body). The idea is that you must consume all the body before closing it as you're likely using keepalive.
`&lt;- ch`
I'm so proud of this community
how are you doing this on windows
I missed that the first version was declined. Do you have a link to the two to compare?
Yes!
I was surprised that website that my company use daily (figma) uses webassembly. Also heard AutoCAD web uses it, and Google Earth 2 beta too. I guess it's just still immature.
This is some of the best news this week. I was really worried that Go would stay heading down the Java/C++ path. Go's error handling is one of its best features, and I have yet to see a single example of a situation where try would work but the current errors wouldn't.
The Ruby way makes sense for Ruby because it's more flexible. It's what allows Rails to monkey patch standard types to permit things like: 3.days Clearly you prefer the go way of doing things. That doesn't make the Ruby way defective.
Not at all currently, that 0.1.0 is intentional. We may be adding a server postgres protocol interface, would that work for you?
I consider the first example you clearly dislike to be very readable. That on the other hand &gt;`y := try(g(try(f(2))))` a garbled mess I never want to see in a codebase
Agreed. It was handled well.
Great!
I agree. I don't think the current process is perfect, but I would want any solution to make the situation _substantially_ better, which try proposal did not do IMO. Also, it shouldn't be less explicit and simple than the current if err code. It's a challenging problem to solve in an idiomatic way.
Checksum to be done in db.SList/friends? &gt; Thanks, but that's not my project nor I ever contributed to its code. I'm sorry, I was reading your gitlab repository list and somehow confused into thinking that's where c-for-go come from. Sorry.
Actually frameworks and large libraries are the exact things I'd like to avoid at this point, since I'm starting fresh (to Golang, not programming). I'm aware that REST is not network-programming per se, but I was unable to find a better way to write that sentence. :)
Below some variables to tweak with on both sides. Just in your case I really think that something is keeping the connection open. You probably have a lot of goroutines on the server. Do you have some metrics on that? Prometheus is nice for that but you can do this simply with a snippet in your main() func. Also: Can it be that you're not closing a DB result from a query? `go func() {` `var mem runtime.MemStats` `runtime.ReadMemStats(&amp;mem)` `for {` `time.Sleep(time.Minute * memtatsUpdateTime)` `runtime.ReadMemStats(&amp;mem)` `// switch logrus for whatever you want` `logrus.Warn("Memory before GC ",` [`time.Now`](https://time.Now)`())` `logrus.Warn("Alloc ", mem.Alloc)` `logrus.Warn("Total Alloc ", mem.TotalAlloc)` `logrus.Warn("Heap Alloc ", mem.HeapAlloc)` `logrus.Warn("Heap size ", mem.HeapSys)` `logrus.Warn("Heap objects ", mem.HeapObjects)` `runtime.GC()` `runtime.ReadMemStats(&amp;mem)` `logrus.Warn("Memory after GC")` `logrus.Warn("Alloc ", mem.Alloc)` `logrus.Warn("Total Alloc ", mem.TotalAlloc)` `logrus.Warn("Heap Alloc ", mem.HeapAlloc)` `logrus.Warn("Heap size ", mem.HeapSys)` `logrus.Warn("Heap objects ", mem.HeapObjects)` `}` `}()` &amp;#x200B; On server side you can play with these variables. Remember in your case you maybe have 1 host connecting and these numbers may vary on your use-case. `s := new(http.Server)` `s.ReadTimeout = 60 * time.Second` `s.WriteTimeout = 60 * time.Second` `s.IdleTimeout = 5 * time.Second` `s.ReadHeaderTimeout = time.Millisecond * 800` `s.SetKeepAlivesEnabled(true)` `s.MaxHeaderBytes = 1 &lt;&lt; 16 // 65K` &amp;#x200B; On your client: `http.DefaultTransport.(*http.Transport).MaxIdleConnsPerHost = 50` `http.DefaultTransport.(*http.Transport).MaxIdleConns = 100` `http.DefaultTransport.(*http.Transport).IdleConnTimeout = 10 * time.Second // timeout idle connections` `http.DefaultTransport.(*http.Transport).MaxConnsPerHost = 20000 // in your case it's probably one host?` `http.DefaultTransport.(*http.Transport).ResponseHeaderTimeout = 5 * time.Second`
I'd not be interested in that anyway. I'm not a programmer who wants to do everything in so-called automagic one-liners. I've skimmed the documentation and looks like it's perfectly usable for my use case. I'd rather walk the hard way to learn a language rather than use some library to do what I want without understanding anything. Where's the fun in that? :) Thanks again for all the fish. :)
uhm? type MyEnum int const ( Foo MyEnum = iota Bar MyEnum ) func foobar(e MyEnum) { ... } ...?
A const is not an enum. For example, I could just pass any old int to that function: `foobar(MyEnum(-918))`
It is rather a Rust‚Äôs lack of good design this language is horrible at error processing. Something like let file = open(...) if !file { // return errors::wrap(file.Err, "doing something") // file as Err branch exited, file is officially Ok now, can use file as file object, not Result&lt;file, error&gt; } match file.read(buf) { Ok(res) =&gt; ... Err(x) =&gt; } instead of match open(...) { Ok(file) =&gt; { match file.read(buff) { Ok(res) =&gt; ... Err(x) =&gt; ... } Err(x) =&gt; errors::wrap(x, ‚Äúdoing something‚Äù) } Would make Rust error handling much clearer for humans. Nesting is complicated for our kind. And this Result resolution construct would work as well or even better file = open(...) on err { return errors::wrap(err, "doing something") } match file.read(buf) { ... }
Good that they listen to feedback, but I was personally waiting for some solution to the endless boilerplate in Go before I consider it seriously for anything. That includes generics also.
Double wrap looks weird yes. But single wrap can make initializing structs clean.
defer
Why would you do that? With the explicit typecast being required, it's not like it would happen by accident, so why is it a problem?
I believe you supposed to use defer for that.
If you write a library and the enum is part of the api, you now have to handle default cases in switch statements (or be ok with weird behaviour) You could argue that the user is the one at fault for passing invalid parameters, but honestly murphys law bites all of us one day.
It can happen by accident. For example, `json.Unmarshal()` will let any integer value through. That's a weakness of the JSON package which you have to work around by implementing `UnmarshalJSON` on your type and then validating the incoming value, which is obviously a chore and a source of brittleness, because now you have to maintain a list of valid values to validate against. With a true enum, Go would already have this list statically and you would be able to use reflection to derive it.
500 never closes the responses body. Move your defer up higher.
Someone purpose this in go
Ok, I wasn't sure you could see where the connections were going. If it's between the nodes then that's what you should focus on, obviously.
have someone tried this: [https://github.com/cockroachdb/errors](https://github.com/cockroachdb/errors) ?
[Yep](https://github.com/faiface/generics)
Directory on your file system https://godoc.org/github.com/objectbox/objectbox-go/objectbox#Builder.Directory
Yes, ObjectBox is an embedded database (like SQLite) using a local file for data. Sync and remote C/S are WIP.
Dope! That's actually really cool!
The biggest issue that the try proposal had was that it made it notably harder to cleanly wrap errors with more useful errors. Sure, you could do some defer magic to provide some very _generic_ error wrapping, and if you wanted more you could simply not use try, but in both cases this makes the currently recommended best practices much more jarring. And at the point where you're actively making it _worse_ to follow best practices, it's time to come up with a better plan.
Pyodide (scientific Python stack in Wasm) [https://hacks.mozilla.org/2019/04/pyodide-bringing-the-scientific-python-stack-to-the-browser/](https://hacks.mozilla.org/2019/04/pyodide-bringing-the-scientific-python-stack-to-the-browser/). &amp;#x200B; Google Earth (now uses Wasm) [https://blog.chromium.org/2019/06/webassembly-brings-google-earth-to-more.html](https://blog.chromium.org/2019/06/webassembly-brings-google-earth-to-more.html) &amp;#x200B; WebAssembly can run on the kernel, [https://medium.com/wasmer/running-webassembly-on-the-kernel-8e04761f1d8e](https://medium.com/wasmer/running-webassembly-on-the-kernel-8e04761f1d8e) &amp;#x200B; 1password uses WebAssembly, [https://blog.1password.com/1password-x-may-2019-update/](https://blog.1password.com/1password-x-may-2019-update/) &amp;#x200B; WebAssembly has a package manager, [https://wapm.io](https://wapm.io) &amp;#x200B; Cloudflare and many other cloud providers are providing FaaS based on Wasm &amp;#x200B; More and more cryptocurrency &amp; blockchain projects are using Wasm, like NearProtocol, Cosmos, Spacemesh etc. &amp;#x200B; And so on :-).
make a service :)
I've used this in the past to get cross-platform service execution [https://github.com/kardianos/service](https://github.com/kardianos/service)
So what would be a use case for this database?
You don't need the explicit typecast in that example actually, because -921 is an intyped constant and its automatically converted to the right type. Just like you can do 10*time.Second.
If you're doing it yourself.. I think you should use a \*Food pointer for favourite food and then when you're saving to the DB and loading from, building the foreign key adequately. Make methods for the return of dislikes, that way whenever you're loading up the User object, you're not processing and loading up all the dislikes until you're using them. You might want to make an "ExtendedUser" struct that contains everything so you can hit the dislikes once or load it all up together when you DO want it.
oh my bad. I thought you were truly trying to hide it (like a backdoor). like the other poster said, launchd is probably your best bet. its common for projects to ship with launchd, systems, sysv init scripts etc. good luck.
!RemindMe 1 day
Wails author here. Not sure who submitted this but happy to answer questions üòÉ
I will be messaging you on [**2019-07-18 09:13:02 UTC**](http://www.wolframalpha.com/input/?i=2019-07-18%2009:13:02%20UTC%20To%20Local%20Time) to remind you of [**this link**](https://np.reddit.com/r/golang/comments/ce8j5h/how_do_you_consume_the_gonuts_google_group/eu0tof1/) [**CLICK THIS LINK**](https://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=%5Bhttps%3A%2F%2Fwww.reddit.com%2Fr%2Fgolang%2Fcomments%2Fce8j5h%2Fhow_do_you_consume_the_gonuts_google_group%2Feu0tof1%2F%5D%0A%0ARemindMe%21%202019-07-18%2009%3A13%3A02) to send a PM to also be reminded and to reduce spam. ^(Parent commenter can ) [^(delete this message to hide from others.)](https://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Delete%20Comment&amp;message=Delete%21%20ce8j5h) ***** |[^(Info)](https://np.reddit.com/r/RemindMeBot/comments/c5l9ie/remindmebot_info_v20/)|[^(Custom)](https://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=%5BLink%20or%20message%20inside%20square%20brackets%5D%0A%0ARemindMe%21%20Time%20period%20here)|[^(Your Reminders)](https://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=List%20Of%20Reminders&amp;message=MyReminders%21)|[^(Feedback)](https://np.reddit.com/message/compose/?to=Watchful1&amp;subject=Feedback)| |-|-|-|-|
This sounds awesome and we're glad you are looking at Wails. Let us know how we can help!
I only just learned about this project yesterday, but to me is sounds like a good candidate for a project that currently uses either bolt or badger (modular backend). They are small messaging services that store and relay data between different hops. The requirement is to have an embedded file-backed database with transactions and sequential range queries (like a FIFO queue). ObjectBox seems like a really flexible way to replicate the requirements. I wish it didn't need a shared object dependency though. Will have to investigate if it can be statically linked.
I often fail to add package-descriptions since it's currently a chore to add a new `// ` every time I insert a newline. Is it possible to make it so Intellitj automatically inserts `// ` infront of the new line if I was above the `package` clause?
You could implement the json Marshaler / Unmarshaler interface on the enum type that checks it's validity and errors, it could error with a sentinel error that's easy to handle in a http handler to return a bad request etc.
This seems pretty straight forward, if you're interesed in being a Go lang dev, then be a Go lang dev.
Wise decision.
Many probably won't. Being perceived as a victim is a powerful way of winning people to your side.
Why not both?
iirc. a Handler does not leave the request body open, but a HttpClient does keep the response body open
Does it work with Go modules?
Havent used it myself, but it could send you off in the direction of looking at alternatives, purge though do note that they dont fsync things. Most ive seen are mostly focused on implementing the keysearch/kv store in different ways, if i were dealing with a task with only a few sensors i would skip the KV concept in the data file and just compact the code for writing and make it foolproof in one single block of read/write. So nomatter if you have 1 sensor or 10 sensors datafile size would be fixed. And then implement KV store in a different way could be a seperate file that points into the datafile ? I am aware you dont want to write it yourself, but you could achive no overhead and fairly simple in regards to errorhandling as its a single read and a single write operation.
I run into the same problem often (also a big fan of repository pattern), and my approach depends on what my use case is. Sometimes I'll make the related entity a property, or use some form of an identification (like a foreign key, but usually some form of an identity that is storage backend agnostic). I'd also like to hear thoughts of more people on this.
Monkeypatching standard types has no real connection to imports. You can monkeypatch Python, which has self-namespacing imports. JavaScript is a weird case because they added a real import system late and in multiple phases (require v. import) but it too supports changing object prototypes. It‚Äôs just culture that makes Rails do its thing differently.
Agree.
I just stumbled upon this on GitHub and I wanted to share it! :D It looks useful. Thank you for your effort.
this. im not aware that both exclude each other. if anything, they work perfectly hand in hand
Probably, you can make it private type enum int const ( Foo enum = iota Bar enum = iota ) func foobar(e enum) { ... }
ObjectBox will add an option to use it using a static lib in the future.
&gt; Checksum to be done in db.SList/friends? Yes, that's definitely an option. For example, add the checksum size to the `dataSize` argument of ((*DB) NewSList)[https://godoc.org/modernc.org/db#DB.NewSList] and update the checksum within the node whenever a node is written. Check the checksum when a node is read. I would be glad to take a look at your project if it's published somewhere.
The equivalent in Rust, the `?` operator, is incredibly useful. However, Go lacks the features that Rust has that makes it pleasant to use and makes it fit really well in the language.
I wrote a lot of golang code for the last few years. The appealing part was it kicked OOP out the door. That was my huge take away. I definitely missed generics, so much I often would voice concern over it. Before, anyone says whats stopping me from using a code generator, that is what I did. It was a bandaid over a problem that should been solved at the language / sdk level. &amp;#x200B; Secondly, how go does error handling was a step in the right direction, but definitely need improvement. It was not until I understood rust was of handling errors through Enums / ? / Ok / NOne, Err, that I knew what go needed in the next version. &amp;#x200B; Problem with go is the leadership, its a hard thing to admit, cause they created a language that changed the world. world was begging for a simple fast language 10 years ago. C++11x was simply a horror storry, C++ is dead to me, completely. I will never touch it again. C is still a valid choice. Quickly rust is replacing the C choice to some. &amp;#x200B; This try proposal, shows me its time that go makes some changes to the language. Either they do it, or they fall further behind and start losing mind share.
This would be great if they would finish it and put it in the compiler. Fork golang, do what ever it takes.
I want to run this on prem. We don't have "cloud" access.
&gt;workflow zeebie looks good. But not production ready according to their website.
Love these types of projects and I'm excited to play with it. It would be useful with some high level understanding of performance characteristics; Does it do all in-memory or does is spool to disk during expensive sorts/joins/aggregations (how and when can i expect it to oom). Any use-cases workloads it shouldn't be used for? Some documentation on how to extend the providers (parquet format and remote file/blob stores comes to mind). Care to share some thoughts regarding the streaming aspects that are on the roadmap? I can also see cases for embedding this in other solutions (not just for cli use)
It was a proposal
You make another function to get rid of the nesting. Rust‚Äôs errors are a little lower level than python. You can make that layer yourself with a function. It forces you to handle every scenario with match. Other languages will just crash
They are working on their own generics proposal, they're gonna show it at the GopherCon. I'll see it and then decide if I want to pursue this mine one :)
There are "proposals" and then there are "proposals"... This one had a fairly detailed design included rather than just a passing idea that still needed refinement.
Good news
I‚Äôve found that some ideas need a detailed design to gain any traction. Sometimes it just helps wrap your mind around the idea. I don‚Äôt think that it necessarily means the idea is being shoehorned.
you mean full stack?
ok
Hey, currently we haven't done any performance tuning so it'll probably be fairly slow to handle big workloads (joining especially is a blocking lookup join per record, this is nothing hard to fix, but it's not in our initial release, which is a minimal working version). &amp;#x200B; Back to your question though: You can expect it to OOM if you use a table or csv output and have a huge dataset, as they need to be first stored fully in memory to see what columns have to be there. If you use JSON then this isn't a problem. Another one is that whenever you use the distinct operator, it stores the records in memory to filter out any duplicates. Everything else works in a streaming fashion. Which means that aggregates only have one entry per group, for the rolling output value, which they emit after having received all records. &amp;#x200B; Currently we do not ever spill to disk, and I think we don't plan to, other than maybe indexes for json/csv files. &amp;#x200B; Adding a provider is basically copying one of the existing ones and changing it to suite your usecase, they all just implement an interface, but we'll make sure to add some documentation, as most people seem to be willing to contribute with exactly that. (the JSON data source is really simple, and should be a good starting point for anything) &amp;#x200B; Regarding the streaming aspects: we haven't drafted any design yet, though I've started reading the recent paper One SQL to rule them all, which also seems to have caused the SQL standard committee to work on it. So maybe we'll just see if they come up with a good design and use it, instead of rolling our own. I've seen that Apache Drill currently handles it in a way that's exactly the opposite of what we want, as they just handle all messages in a topic as one big table and scan it all. If you have any advice we could take into account when designing the streaming semantics, sure let us know! &amp;#x200B; And make sure to send us any feedback after playing with it! As currently this is the most important part for OctoSQL, to iron out any obvious bugs and limitations.
Yeah, these days if you don't come to the table with a completed product, your idea is tied to the conference room table and poisoned, drawn, quartered, stabbed, shot, disemboweled, and hung. ...and just before its head dies, it will proclaim: "Death is but a door. Time is but a window. I'll be back." Ghostbusters 2...what a great film.
Especially these days
Can‚Äôt we just pretend? :)
Just because they don‚Äôt like solution X, doesn‚Äôt mean they‚Äôre denying problem Y exists.
oh, don't you? Hrm. Well, that is not ideal then, I'll grant.
Not necessarily. The more you know the more value you will give to the team you work with. For example at work I mainly do Java backend but in my current team if someone has to touch SASS they ask me because I have better understanding of how CSS and SASS works. It's not that it is complicated but the others never took the time to look into it. Also if I stuck with Angular there is a guy who always ready to help me.
Link: https://github.com/golang/go/issues/16339#issuecomment-258527920
Let's not and give credit where credit is due.
Guys Can u give some tips about #8
&gt; You make another function to get rid of the nesting. Rust‚Äôs errors are a little lower level than python. You can make that layer yourself with a function. It forces you to handle every scenario with match. Other languages will just crash I am afraid you don't get an idea. There's no function. Just a special shortcut to discern between `Ok` and `Err` without `match` to avoid nesting.
Great project, how does it compare to lorca? [https://github.com/zserge/lorca](https://github.com/zserge/lorca)
Hello, Seems nice but I encounter this error when I try any examples: ```# github.com/tdewolff/canvas ../font.go:80:11: f.sfnt.PostTable undefined (type *sfnt.Font has no field or method PostTable) ../font.go:81:23: f.sfnt.PostTable undefined (type *sfnt.Font has no field or method PostTable) ```
If I see generics go down the exact same way, I'm going to reconsider my opinion of Go and it's community. Go is good, Go is not perfect, and if it can't even creep forward after seven years, maybe it's not the right thing for me to be investing in.
How did you call it? It seems to be happy: [https://goreportcard.com/report/github.com/objectbox/objectbox-go#go\_vet](https://goreportcard.com/report/github.com/objectbox/objectbox-go#go_vet)
Oh! really appreciate your comment!
Appreciate your review! I didn't think about timing attacks, but I should look at it.
Thank you for your suggestion.
Much appreciate your detailed comment. Awesooooome!
While you are asking for enums, I could really go for exhaustive matching on them too.
Yeah. That should be part of `go vet` at the very least, if not built into the compiler.
I see it as most similar to badger but trading out some complexity of usage by adding complexity of using go generate. Object box looks extremely simple to use. It also isn't new. It's only new to Go, but it is heavily used in Java as I learned when this project was first announced here.
When is GopherCon? I'm suck using Golang at work. And it would make my life much easier having generics. New projects I start I try to use Rust. But we have a lot of go code already.
If your interested, there‚Äôs a whole [proposal discussion on GitHub]( https://github.com/golang/go/issues/19814#issuecomment-388661834), but it seems to have been forgotten.
OP (Endtest) is spamming up tech subs, every day with multiple accounts [1,](https://www.reddit.com/user/boss_scarbos) [2,](https://www.reddit.com/user/dragnea_presedinte) [3,](https://www.reddit.com/user/llupei) [4](https://www.reddit.com/user/wernerklaus), [5](https://www.reddit.com/user/jos_cu_klaus), [6](https://www.reddit.com/user/sa_vina_werner), [7](https://www.reddit.com/user/ihavelepower), [8](https://www.reddit.com/user/viorica_presedinte), [9](https://www.reddit.com/user/werner_sclavul), [10](https://www.reddit.com/user/basist_infect), [11](https://www.reddit.com/user/felix_presedinte), [12](https://www.reddit.com/user/werner_la_puscarie) ultimately in an attempt to make you pay money for the service he runs (endtest). [This is the kind of person you're dealing with here](https://imgur.com/xyfZ59P) Still want to give endtest money? **Vote and report accordingly.**
I've never either used Badger before. When would I want to use such a database? We're now mainly working with in-memory key value stores (redis, simple go maps) and some heavier db solutions (mysql, dynamo) which do not sound to be on the same level.
https://lmgtfy.com/?q=gophercon+2019&amp;s=g
Since you're kind enough to answer detailed questions, would you also theorize a bit about adding checksum to metadata? I don't want to sound paranoid, but SD card wearout is expected, and I don't really know how it will perform so expecting worst: random bytes changing. &amp;#x200B; Yeah it's very public [https://github.com/temoto/vender](https://github.com/temoto/vender) is uhm composed application? [https://github.com/temoto/spq](https://github.com/temoto/spq) was quickly written as precious data queue using syndtr/leveldb specifically for vender. Saving uhm non-queue kind of state to disk is coming unlikely today, in next days. We're making kinda big project by two people and brother is more hardware guy, so any code review, any feedback is greatly appreciated.
Isn't it a code smell to export something who's type is private? You can't type switch on it, right?
The popular jsonapi spec (and others) use these brackets. I've also used these brackets back in my PHP days and they were handled by default there. People must have ran into this with go before. Google's own repo has a way to encode these query strings, but not decode... though there's a PR for it that's not merged yet :( https://github.com/google/go-querystring/pull/23 Guess I'll have to write my own until this is merged
I had never heard of or seen this language. Looks pretty cool, almost like a cross breeding of rust and go.
u/thejvexperience &amp;#x200B; I highly recommend you take a look at this excellent article on the subject: [https://blog.cloudflare.com/exposing-go-on-the-internet/](https://blog.cloudflare.com/exposing-go-on-the-internet/) &amp;#x200B; It pretty clearly identifies and solves your exactly problem. Enjoy!
I don't use google, do you have a link to duckduck go?
Oh I assumed you are recoilme, the author. Sorry. &amp;#x200B; Indeed, probably will do simple read/write. It's not like I don't want because lazy, just wanted to save time if somebody has already done same job. [It is more complicated](https://blog.dgraph.io/post/alice/#what-could-go-wrong-when-you-modify-a-file) than single write, but yeah, there is opportunity to make it correct with reasonable effort.
The only reason to add wrapping every time you see an error is to provide a poor man's stacktrace. They should have implemented try and added stacktraces too.
https://github.com/StabbyCutyou/generics
I typically load and resolve all database keys to pointers in the structs if I can keep guarantee they'll all be around when I use them. In other words, walking up and down the struct graph via the pointers. If I can't make this guarantee I'd go for storing the keys as ints in the structs. I'm assuming you're running this on a back end someplace (because of some of your wording) so In this case I'd be tempted to just load the entire food table into memory at once. There probably aren't more than 10-15,000 different foods and even with extra fields the entire memory footprint is trivial compared to what you'll have available. This means resolving all foods into pointers will work well. I'd definitely keep the disliked foods as a separate table and structure. Without an ORM keeping referential integrity in a list of foreign keys can be a pain. (Depending on DB, of course.) Also, a user probably doesn't have more than a hundred or so dislikes so I'd load the disliked foods when I load the user. This keeps your tree consistent with all keys resolved so you can keep pointers here too. Finally, favorite food falls into place as a pointer too as all your foods are in memory. But I'd likely move favorite foods out into a separate table unless you're 100% certain there will never be more than one favorite. No matter what you can still query and load users with a nil/null pointer for the favorite food. That's common and as long as you're in a separate bit of logic where you can guarantee you won't accidentally try to use the pointer it won't make any difference. But don't be afraid to make extra purpose driven structs if, for example, you're querying for reports and such. It can really help to build a struct that doesn't map 1:1 with a table. Anyway, a lot of assumptions for not knowing your application so I hope I'm not adding yet more confusion.
Funny, I never saw a decent argument against try. The primary argument was that if err != nil is the right way and superior to error handling in every other language. And try couldn't make things harder because it wasn't replacing any functionality. Nothing was stopping anyone from using the old approach when justified.
Very.
Very much so.
When every argument against solution X was that problem Y doesn't exist, that's typically what it means.
Could not agree more. I was a tiny bit worried.
It was definitely the correct decision. Glad to see they rejected.
Read effective go, take a udemy class, familiarize yourself with the golang website, and in specific, where the core libs are and their documentation.. and then you‚Äôre off to the races.
Well a backdoor would be ideal but I‚Äôm not experienced with Go and frankly don‚Äôt have the need to or time to go (hahah) in depth with learning it
In the end, most of us argued our parts. It was a flurry of upvotes and downvotes of various views, but the important thing is that the community had its say regardless of what was the popular opinion. From this, the Go Team likely will be coming up with their own ideas. Though they rejected the proposal, they mention they felt there wasn't enough representation of the problem to warrant the change. They didn't outright reject the idea, but rather said "We want more experience evidence to see if change needs to happen and how". This is a wholly fair response, but one that says we may come back to this idea, or something similar. I'm also a bit bummed out `try` didn't make it, but at least they will look into error handling more closely.
Granted there may be other ways to monkey patch, like: Foo::Bar.instance_eval do def baz "baz" end end However, the ability to reopen a class or module declaration in any code is the primary mechanism used for monkey patching. Either way, the point remains. The way it works in Ruby is because Ruby chooses to approach things by maximizing flexibility and functionality and depending on the developers to make good choices, not by handcuffing the developers and making their choices for them. That approach is antithetical to the Go approach, which is why it's not surprising to see someone on r/golang targeting Ruby.
&gt; would you also theorize a bit about adding checksum to metadata? I hope to take provide some feedback tomorrow. My first idea is adding a very thin layer on top of `db` with the same API that just handles the checks transparently. &gt; Yeah it's very public: ... I hope to also take a look tomorrow. Thanks for the links.
This is a big part of the reason (at least I believe) that Linux took off the way it did. Linus doesn't take shitty code, and he does't let anyone treat him like a doormat for the kernel. (All the Linus bullshit aside) He's a good manager and gatekeeper for what ends up in the kernel, and what everyone will have to deal with. I'm really glad to see the same thing here, just without the incessant and necessary name calling.
I mean.. it's quite obvious if the article is named "Puppeteer vs Selenium" but after a few lines it starts bashing both and inserting a "new and much better" option.
This would be for projects that want to have an in-process key-value store (with some additional query capability, though not the same level as SQL). If you load balance between machines, you are less likely to use this. If you don't expect to need that, it's simpler than Redis. Certainly if you've already integrated Redis or a database, you wouldn't replace either with this. Same with Badger, though Badger is also actually the engine behind Dgraph, which is a large graph db product.
A male badger is called a boar, the female is called a sow, and the young are called cubs.
I get that. There are too many parenthesis there, and one letter functions. Part of it is that "try" could be a keyword like some of the other error handling proposals, and part of the lack of readability was my fault for using single letter function names. The point is the current if err != nil is not compossible. Consider this instead, which is a real example from my code with a hypothetical "try" keyword: `s := s.Init(try` `f.Open``("myfile")` Rust does this with a `?` which is much better than the try proposal, and almost universally makes the code much more readable. What I dislike in the first example isn't how it reads in a short snippet, but the overall code noise. Repetitive code that all does the same thing should be able to be abstracted away somehow... any way. The lack of readability is in the ultimate vertical noise and number of lines per file (or number of files in a project if you go that route), and the amount of time it takes to jump between contexts.
Some examples: * Primary DB to run on small devices like RPi (IoT/Edge setup) * Standalone applications (e.g. desktop apps) * Small server apps not requiring a dedicated database server (e.g. server runs on a single machine) Client/server mode and data sync are currently work-in-progress. Once released, it should be fit to run typical server apps, especially you want your data model in Go, and don't care too much about SQL.
Thanks!
There is about 4 negative comments vs 425 likes. I think the Go leadership is listening to its users.
ü•≥
this bot made me giggle today, but it's going to become annoying over time, I think
I want @annotations though. ^(/s)
I'm really worried about the Go community becoming overly conservative. try was not perfect, but the discussion triggered by the proposal was mostly about doing nothing, instead of improving the actual proposal. In other programming language communities, I've seen hard discussions, but with a shared desire of moving forward. With Go and try, I've seen a desire to stay exactly where we are... Maybe I should spend more time looking at other options like Rust, Kotlin, Elixir, etc. I'm a bit sad about this, to be honest.
It's harder to find Go opportunities, so hang on to that if you love it! If you grab a UI dev card now and then to keep it in your mind, it might help you to keep sharp in case you need to be flexible for a job move eventually.
I've fixed and implement what I got from your valuable comments. Appreciate it very much. &amp;#x200B; [https://gist.github.com/mattdamon108/f4860b8e9b2e3d913408434f1bfb2fd7](https://gist.github.com/mattdamon108/f4860b8e9b2e3d913408434f1bfb2fd7)
privacy isn't worth much as long as it's always per package... By the way, can we please get `private` keyword that is struct-specific? ``` type MyContainer struct { secret private interface{} } func (c MyContainer) Get() interface{} { return c.secret //no issue here } func x(c MyContainer){ c.secret // Error: Access to private fields of a struct is only allowed within its methods } ```
You know, I haven't tried it there yet. But if your module is not under a GOPATH it would probably not work. However it probably wouldn't take much work to get it to work for Go Modules outside of a GOPATH.
The search term is in the url
Interesting. This may allow me to get rid of the globals here [https://github.com/libretro/ludo/blob/master/libretro/libretro.go#L260-L269](https://github.com/libretro/ludo/blob/master/libretro/libretro.go#L260-L269) Do you think it would help me to pass a type instance for a method to be executed in a callback in C?
I am not against modules ‚Äì this was a good way to go. I am not against generics in the proposed form ‚Äì I am glad they didn't use `&lt;&gt;` But I am totally against `try` proposal.
Badger is a K/V store; ObjectBox operates on structs including queries on fields, field indexing, relations etc. So it goes way beyond simple K/V caching. And btw, the lowest level ObjectBox is also an K/V store.
The sudo is now removed :)
Now THIS looks great!
&gt;the discussion triggered by the proposal was mostly about doing nothing, instead of improving the actual proposal `try` is a fundamentally broken concept. It encourages programmers to just pass the error up. The current situation forces me to think about whether I can handle that specific error myself. Personally, I'd much rather see: * if checking for nullable types being null (`if err {handleError()}`) * `=&gt;` as an alternative to `{}` in single-line `if` and `func` (`if err =&gt; handleError()`)
Fullstack if you like startups and responsibility for delivery apps by yourself. If you like more stable work go with either UI or backend. In my opinion projects in Go often can be delivered with better quality because of tools build-in and more well delfined structure. Compiled languages will reducie problems on production servers :)
Thank God!
I was thinking the same thing. A 'try' without some kind of "wrapping support" (even if it's just prepending a string) would be quite harmful to the context/usability of the returned error.
Exactly. I'm not worried about the try proposal being withdrawn. Maybe it wasn't good enough. I'm worried about the verbosity issue not being addressed.
Can you give me a link like you did before? That was really unique and no one else has ever done that before.
And to be clear, this is the sort of thing that is why I'm not actually yelling right now. It's a valid position. If this becomes a trend, though, I'm very concerned. I actually consider modules a separate case; that was a tooling change. Tooling has actually had a few changes made to it over the years, like vendoring. I see no reason to be concerned that's frozen forever, and I'm comfortable with moving slowly and with a high degree of concern for quality and backwards compatibility. It's the language that I'm worried has become frozen forever and ever amen. I also want that to move slowly and with a high degree of concern for quality and backwards compatibility; I don't want to see it *frozen*.
&gt;Maybe I should spend more time looking at other options like Rust, Kotlin, Elixir, etc. You definitely should. When one need features they move to more featureful language.
&gt;optional manual variable deletion (to clean up older variables in longer functions Don't forget you can open scopes whenever you want, you don't need an "if" or a "for" loop: blah := BlahBlah() moreCode() { confinedErr := somethingErrorable() // a few dozen more lines } I've done this a few times in production code where there's no compelling reason to pull something out to a separate function (extraction a function that is used only once is not always stupid, but if you can't give it a really solid name that precisely matches what it does it can just sometimes scramble logic around the file for no reason), and I use it a lot in test code where I want to set up some particular environment used by several small-to-medium sized tests, and I don't need to just repeat it over and over: func TestSomething(t *testing.T) { env := InitialTestingEnv() // imagine this takes 5 or 10 lines more or something // assert that cows in this environment are spherical { cow := env.GetCows()[0] if !cow.IsSpherical() { t.Panic(...) } } // assert that cows in this environment are frictionless { cow := env.GetSampleCow() if cow.Mu() != 0 { t.Fatal("friction found") } } // maybe assert something about logging here, or that certain // metrics were collected, etc. } I've played with the Setup()/Teardown() functions, or having a `RunTest(t *testing.T, func(env *TestingEnv) error)` sort of thing, but it seems like often just opening scopes is all I really need, as long as I have other reasons to believe the previous tests can't "pollute" the environment somehow.
Go is great with concurrency. It's real easy to write logic to handle potentially massive jobs that Go routines will chug. Blockchain as you should know is big data. Big data is almost exclusively handled in a concurrent fashion. Go and blockchain go together like a fork and spaghetti whereas other Non-Go approaches may be more akin to eating the spaghetti with a collection of specialized tools. Which means more licensing to worry about, interoperability / integration problems, and barriers to understanding how the whole program works.
The author was writing "volt" in Go but didn't like the language for GUI tasks and ended up writing "v" to fix those issues. Really neat story and great progress by a single developer.
Looks really nice between this and [https://gleam.run/](https://gleam.run/) I really hope one of them takes off in the near future.
I'm going to answer the question "Is there a specific way to be a blockchain engineer?" &amp;#x200B; IMHO, build your own toy blockchain, or a blockchain client in Go: a demo project to show you know and understand the basics, then put this on a resume and apply to places doing work with blockchains. That's it, you're done; you will absolutely get hired by one of them. &amp;#x200B; Good luck.
Have you read the entire response body? Otherwise the connection can‚Äôt be reused.
Stroustrup's Rule [https://thefeedbackloop.xyz/stroustrups-rule-and-layering-over-time/](https://thefeedbackloop.xyz/stroustrups-rule-and-layering-over-time/) [https://youtu.be/LIYkT3p5gTs?t=2874](https://youtu.be/LIYkT3p5gTs?t=2874)
I appreciate the improvement but it's still not good practice, because I can't see what's being executed. It's fairly easy for a server so show something benign to a browser but serve something malicious to curl. I'd much prefer something like `git clone` then running a script as a separate step.
Oh ho ho!
And let's sprinkle some macro! on top of that beauty. ^(/s /s /s)
I didn‚Äôt catch that all. The following concerns were raised: 1. Difficult to explain to new-comers 2. We are back to using naked returns all over the place 3. Difficult to debug with ‚Äústep-thru‚Äù 4. Linters and other code-quality checkers will have a difficult time with it 5. Makes decorating errors with additional contextual information difficult. 3. and 5. are plenty for me to justify tossing it aside.
I didn't give you a link
You gave me a link to a search engine demo. Can you do that again but with duck duck go?
Once you are looking at a discipline that specialized, it's pretty hard to get as much out of books as maybe a blog post and mostly it comes from working for a specialized product company or from working for a very large company. If you pick an open source project from your field and make contributions, that might be a good way to practice too. Don't be afraid to spend some money to spin up machines in Azure or something to experiment with load balancing or something like that. Reading only goes so far compared to really using the tech.
No I didn't
For a better and CONCRETE Go
True. But they also say they that their production ready milestone is 3rd quarter this year.
You can always decrease size by using upx https://upx.github.io/ and compiling without debugging symbols.
Go is great for distributed systems. It's really easy to write servers and clients, produce code that's simple to deploy and runs on a lot of operating systems and architectures. Writing blockchain code is something you could do in every language as long as you understand what a hash is and how the rules translate into the properties of your blockchain. And a lot of blockchains really don't have the properties they claim to have.
Thanks, this looks handy. And solid godoc! [https://godoc.org/github.com/vfaronov/httpheader](https://godoc.org/github.com/vfaronov/httpheader)
damn you trickster
Interesting, you mean on the server (layer 2) side right? So when I do `w.WriteHeader(500)` and then return, that leaks a FD? I assumed since there was an error that i didn't have anything open that needed closing.
Any idea how i do this? Or how I could possibly be leaking connections?
Unfortunately I've gone through that blog post ad nauseum and it didn't fix my problem. I suspect it's something pretty nuanced, as I set up a whole QA environment to try to reproduce it and even when a fire requests in a tight loop nothing bad happens. It's really perplexing. Do you know whether I have to call \`r.Body.Close()\` after parsing JSON out of the POST body? Is it possibly that? I'm getting conflicting info on whether I actually have to call that function. Thanks so much!
Interesting -- could it be an endpoint that, for one reason or another, never actually reads its input? Would this cause a resource leak?
What do you mean by this? I typically use the \`json\` package as above, which should read the whole response body right? But I'm wondering if I have some other endpoint that \_doesn't\_ actually read the POST body, could that be the culprit?
If you want to learn go, http is great but not intuitive and doesn‚Äôt display things like the ‚Äúattitude‚Äù Go syntax has. Its awkward but you‚Äôll get to a point where it clicks, and visualizing how the logic should look and debugging becomes much easier. Good Luck!
A lot of people are saying that Rust does it well. As someone who's only done some light Go, it makes me think that I should give Rust a try before I invest more time into Go if they fill a competing niche. The "if err != nil " everywhere looks crazy ugly and annoys me, I don't see how anyone can claim it is better than a try statement or really any of the error handling built into literally every other modern language. &amp;#x200B; This particular try proposal looked problematic and awkward but the decision of denying instead of improving it or coming up with an alternate is a bad sign to me. There are some better suggestion in this reddit thread that is less than a day old. Some criticisms say try encourages not handling the errors in your code but how is it worse than the current situation? You don't have to do anything with errors now either. You could make the catch portion required but it's not like a developer would have to do anything with the error there either. There's a limit to how much hand holding you can give for a bad developer and it shouldn't come at the cost of a very commonly used tools for everyone else. &amp;#x200B; The person who cited V Lang is definitely my favorite suggestion.
&gt; If reusing the http connection is important for your application you might need to add something like this at the end of your response processing logic: `_, err = io.Copy(ioutil.Discard, resp.Body)` &gt; It will be necessary if you don't read the entire response body right away, which might happen if you are processing json API responses with code like this: `json.NewDecoder(resp.Body).Decode(&amp;data) ` http://devs.cloudimmunity.com/gotchas-and-common-mistakes-in-go-golang/
If you credit the original contributor, and this project's open source license allows for it (most do, I think), then yes
If the code is in public domain (not very probable), you can use it very freely. If the code has some other license, you can use it only while adhering to the license terms. If the code has no license you cannot use it. You can contact the author and ask him to license the code or at least to provide you with a permission to use the code.
Maybe I'm being dumb, but in terms of binaries what does it really matter? You have a binary instance once, maybe twice, but not dozens and dozens of times on a system. So in this day and age what actual difference does it make if it's 1 or 50 MB? For targeting embedded systems I get it, but a GC language isn't great for that in the first place.
Shameless plug here. I wrote a `map[string]interface{}` helper library, and included this feature. You can find it here: [github.com/atedja/gmap](https://github.com/atedja/gmap). Look for `FromUrlValues`
Startup time can be affected by binary size. In the age of microservices and kubernetes you do have dozens and dozens of instances running and Go is the language of choice here generally. Rolling update of a 1MB or 100MB service is not the same thing. Things like binary size can be insignificant at first but they accumulate and suddenly everything runs slowly and takes too much space.
Fixed the panic (will commit soon), but RTL will be supported later on as I need to write my own SFNT parser.
Hm, didn't consider microservices and containerization. That's a good point. Thanks.
It is js with types but it has some weird concepts like conditional types. Index types and weird constructs that lead to trickyness and not necessarily good code quality. It leads to a lot of mental overhead. Golang has a tiny API compared to typescript.
Open to remote employees or only looking for someone local?
$110k in NYC?
Also as noted at the end of the post WASM size comes out similar, and time over the wire makes a big difference there.
The first thing you should do is not ignore errors. Check them and print them. Secondly, you say a window pops up and disappears. To fix that, run the file from an existing terminal window: `go run main.go`
1 is just silly, it's very simple to explain. 2 isn't true at all. I can't speak to the truth of 3 and 4, but I'm skeptical. 5 isn't true either. Like I said, nothing was stopping anyone from using the old approach when justified.
Use a bufio.Scanner
The web interface for Google Groups is unusably bad. I think the only suitable way to consume it is via an email subscription :(
Also, try using the Go playground to share code, as it's near impossible to read what you have there. [https://play.golang.org/p/dbr62vnw\_GI](https://play.golang.org/p/dbr62vnw_GI)
Also bigger binaries (more precisely, bigger TEXT segments) can also correlate with an increased likelihood of icache misses, that can in turn cause performance to worsen. TEXT segment size per-se is not the only factor of this, but it contributes.
Based on other posts he's made recently, I think you're onto something https://www.reddit.com/r/golang/comments/ce4yp7/question_about_hiding_execution_of_go_binary_on_a/
"catch" supports error wrapping, "try" did not. That alone is enough for me to like the former suggestion and reject the latter.
I hadn‚Äôt heard that one before. I will keep it in mind.
I‚Äôm running pentests for work for gods sake if I was doing something illegal I wouldn‚Äôt post it on reddit
No that‚Äôs what I want to happen
Yes and no. You said this happens very rarely. I would assume either that or an error. Shit happens all the time the question is how :)
...which is slow, and also requires as much code as `if err != nil { return ... }` So basically the try proposal didn't offer anything to people who wrap their errors.
Ya that's way low....3yrs can net you that in a lot cheaper places to live.
I think there was a lack of understanding from the Google developers regarding what the community actually wanted, and they just guessed badly. The `try` feature would have worked well for the Go stdlib, but the stdlib code is atypical. I put together a survey to try and find out what _features_ people wanted from any improvement to error handling, ignoring all questions of syntax and naming. (it's at https://forms.gle/vkFsGRimgnwBpArq8 if anyone wants to add their opinions.) It looks as if most respondents don't have a problem with having error checking on a separate line of code, and most of them wanted error wrapping to be supported functionality. So `try` just didn't offer enough people something they wanted. I do think that people new to Go would have liked `try`, but I also see people new to Go asking for Java-style exceptions a lot...
Relevant username
Kubernetes ad you know it today was not originally written in Java. Maybe tiny pieces of it were, before it ever had a name, as tech demos.
I found this very useful! Couple of things to think about for me
i'm glad they don't think like you, you want Go to become .net / java, they are both stuck with their heavy runtime now, they can't target webassembly, and they are being replaced by go because they suck for microservices
You should lead with that.
You know in hindsight i should‚Äôve but also like I would assume if I was doing something bad I wouldn‚Äôt post it on reddit on a non throwaway account.
From what I found it was written in c++ but rewritten in go
1. This will not bypass edr alone 2. There are only so many ways to skin a cat. The golang runtime will not be sufficient to obscure your actions, you are strongly at risk of EDR killing the parent of a process that ran "net use" 3. Your reverse shell does not use any encryption / obfuscation, any potentially triggering data will be detected by IDS/IPS Obfuscation means nothing in this sense. At some point, as each command spawns a process, the command and arguments will be interpreted by EDR solutions.
Fair enough. Your questions sound specific to pen testing and not specific to Go.
Most boring trolling ever in that case
Nice read. I haven't been satisfied with our current error/log handling. I have a better understanding on how to approach it now, thanks.
nah, we need a `goto` statement. oh
The pointer information is interesting but I don't find it representative. When you've decided to pass around a struct instance as a pointer you've probably already decided you want the data to be mutable and that you're going to pass around the same reference repeatedly. The usage shown in the GitHub link seems more like a micro benchmark optimized to show the discussed result rather than typical reference use. (Not that there's anything wrong with doing that.)
There seems to be support for modules now https://github.com/google/ko/pull/60
The pointer one I take issue with personally. There are a lot of gotchas with method sets around interfaces and value passing, so I generally consider it a premature optimization. Pass a value if you might pass it as individual parameters, otherwise pass a pointer. The escape analyzer can allocate pointers to things on the stack when they don't escape, so that argument is irrelevant, and the note about Read is also inaccurate because passing any reference (pointer, slice, etc) will cause it to escape to the heap. You pass in a buffer so that Readers don't have to allocate the buffer and you can control reuse, not because of stack vs heap.
This. Debug symbols (which are default included) tend to be large. (Lots of them are compressed if your platform and debug infrastructure support compression, but not all platforms do.)
My (limited) understanding is that everything under the /x/ path is experimental and some of that stuff ends up getting left behind (not further developed) or removed. As such, I tend to prefer a mature third party library of one exists.
Did you mean Struct Diagrams?
I found these two articles give better info about pointer performance https://segment.com/blog/allocation-efficiency-in-high-performance-go-services/ https://go101.org/article/value-copy-cost.html
Definitely check out https://github.com/nhooyr/websocket - it's much more recent than either of those libraries and has a pretty excellent API. There's a big comparison section in the README, too.
How do you import vscode keybindings to goland? like it's hard to move into goland because i don't know the keymaps or it's just too time consuming when changing default keys if I also can import extensions from vscode
&gt; Anyway, a lot of assumptions for not knowing your application so I hope I'm not adding yet more confusion. All good. Actually I think my food example has made your answer a bit too specific. I just wanted to indicate that I wanted one object to link to another object, and one object to a list of objects. Regarding loading everything into memory, that isn't practical in my actual use case. &gt; No matter what you can still query and load users with a nil/null pointer for the favorite food. That's common and as long as you're in a separate bit of logic where you can guarantee you won't accidentally try to use the pointer it won't make any difference. Ah, I wasn't sure on this point. I have the impression that if you load the object, it should be a full and true representation of the object. But this could be addressed by my 1st option below... &gt; But don't be afraid to make extra purpose driven structs if, for example, you're querying for reports and such. It can really help to build a struct that doesn't map 1:1 with a table. I have considered this since posting. I have actually had 2 thoughts; * 1) Have a model struct, but it should only contain table columns that are properties, eg the ID and Name. Anything that then gets related entities should do so through a repo interface with get and set methods. * 2) Dont have any model structs, and instead only have repo interfaces that return specifc structs to suit that query. Because say for example I want a page to show the top 5 people with the most disliked foods, and also list those foods beneath those people. This could be written as a single SQL query, and would slot into the 2nd option nicely. But for the 1st option, it raises the following questions; * 3) If 1 big query, where would that query live? (eg in the user repo, or the food repo, or a third repo?) * 4) If split into seperate queries, one could get the 5 users, and another could get the disliked foods for those people. But to prevent n+1 problem, I would need a query for getting disliked foods for multiple people, and then feed that into a map or something? Thoughts?
based
X just means extended stdlib. It‚Äôs usually excellent and well supported. Experimental packages are explicitly documented as such and under the x/exp path iirc.
OP didn‚Äôt delete their account, only the post: &gt; _I just learned that kubernetes was originally written in Java but then got rewritten in Go. That seems like a very odd decision to me considering Java is an effective enough language but if you really wanted to rewrite it why rewrite it in a language that doesn't have OOP?_ &gt; &gt; **submitted by** /u/SJWcucksoyboy
Just don't use upx to reduce startup time. üòé
Sounded like I wasn't going to get an answer so decided to delete my post.
I concur.
You definitely can not import extensions.. VSCode is NodeJS/JS. IntelliJ is Java. You may find similar plugins for IntelliJ (Goland). I believe IntelliJ has ways to import or at least find similar mappings to other IDEs. I am pretty sure it had bindings for Eclipse. May have to do some digging about VSCode.
You also get equity, startups are inherently a risk. 3 years of experience not strictly required.
We are looking for someone local right now
still, respectfully, $110k (max) is very low for a go position in nyc -- even with equity.
I agree, but I'm also just an intern and don't get paid enough.
oh... It is go lint... I think I don't care if a third-party package passed vet or lint, but it can't force me to write code which shouldn't pass go lint. &amp;#x200B; Gorm will use the "ID" field as primary key. It's ok. You want me use "Id", bye.
kids, startups are one of the dumbest choices one can make in life. resist the temptation.
look at vyrus001 github for clues
The [Godoc for x/net/websocket](https://godoc.org/golang.org/x/net/websocket) says &gt;This package currently lacks some features found in an alternative and more actively maintained WebSocket package: &gt; &gt;[https://godoc.org/github.com/gorilla/websocket](https://godoc.org/github.com/gorilla/websocket) So you should probably use the Gorilla package or [https://github.com/nhooyr/websocket](https://github.com/nhooyr/websocket).
You need to move the goroutine out from your for-loop (but after instantiating ww), otherwise you‚Äôll continually fork a new goroutine on each iteration!
Excellent article. I was a bit surprised by the pass by pointer vs value. Good to know
I don't get it. That makes no sense.
&gt; Those 10 lines are about sending &amp; parsing JSON requests over HTTP in GOLANG. While other comments are correct in that code that doesn't mention a license is not permissible to use without permission from the copyright holder, you could take one of two approaches: 1. Code related to sending and parsing JSON over http in Go--especially a mere 10 lines--is probably a common snippet of code and not something a court would hold as copywritable. Don't just think about whether it seems obvious, though. Look for other examples with that sort of code. Also look away and rewrite the logic. You'll probably use some different variable names and slightly different organization. At that point you're good. 2. The legal footing for this is less assured, but you could probably argue that any code in an issue or PR for a project was intended as a contribution under the license of that project. Look at the license of the project and you can probably use the code in a method consistent with that project license.
Ah. Ok. It‚Äôs just a branch under x then. So, is the x stuff candidates for inclusion in the standard lib?
If it helps anyone, here is the equivalent Caddy config: proxy /faktory 127.0.0.1:7420 { header_upstream X-Script-Name /faktory transparent } Then, in regards to: &gt;But this has one very big problem: it doesn't know about the /faktory prefix! Could the proxy just strip the /faktory prefix before passing it through? i.e.: proxy /faktory 127.0.0.1:7420 { header_upstream X-Script-Name /faktory transparent without /faktory } Then you wouldn't need to hack in a special mux in your Go code. Not sure how that would affect the rest of the setup; maybe the relative links would still need help as the article describes, but this looks quite a bit simpler this way.
Well I got the remote shell running without firing any alerts so far
No it‚Äôs more Go related questions like getting the binary to run as a bakcground process in Go withkut making a daemon
I would use a select with a default. If it grabs something on the channel, namely the ctrl-c, you can do whatever you may need to. Otherwise just run everything from inside the for. As was noted, don‚Äôt put that goroutine there. Or anywhere. Just handle the channel directly.
The author lost me right at the beginning: "Unknown Enum Value" Go has no enum types. You can verify that here: https://golang.org/ref/spec#Types
Waitaminute...
Passing by reference isn‚Äôt the same as passing by value. By reference, you only have one object as you progress through your code. Passing by value creates multiple copies. With reference, little to no new memory is allocated. With value, a copy of the object is allocated. With a pointer, 8 bytes are allocated. Reference should be the fastest.
Most of the criticism against try was that it doesnt do enough though so it wasn‚Äôt just about being conservative.
I‚Äôve been really enjoying Todd McCleod‚Äôs golang courses on Udemy. I‚Äôm working on Go in Practice as well.
After coming from ruby and picking up Ginkgo, this is the first time I've stopped to wonder if maybe the reason the built in test framework isn't as feature rich as I expect is because that isn't how you do it in go..
Very interesting topic, thank you. I must admit I'm always returning a pointer everywhere.
Can you post some code? Depends what you're doing.
They refer to constant iota enumeration.
If your struct is less than the size of a cache line (64 bytes) copying it or copying a pointer is basically the same speed. Making multiple copies of structs on the stack can be much faster than having one struct on the heap that the garbage collector will have to keep track of. But there is no general case here, you'll have to benchmark this case by case.
There's no such thing in Go as "reference". Sometimes they mention "reference objects", but this only means object has pointer inside, so its copies will share same data.
Also [https://medium.com/@blanchon.vincent/go-should-i-use-a-pointer-instead-of-a-copy-of-my-struct-44b43b104963](https://medium.com/@blanchon.vincent/go-should-i-use-a-pointer-instead-of-a-copy-of-my-struct-44b43b104963)
upx decompresses your binary into RAM before running, so your whole original binary size is now counting towards your process' resident size instead of being simply mmaped from disk. Not a good idea if you want to reduce resource usage and start time.
Thanks for the advice. The project will have an SQLite backend and maybe a GUI/TUI so I'll be exposed to more parts of Go than \`net/http\`. If I can start to somehow make Go do what I want, I'll use it more in the future, so I'll explore its features and ways eventually. Thanks again :)
Yep. I assumed the same thing and was leaking them hard for a few days until I realised.
 godoc -http=:6060 How is this hard to use? Just open the browser, navigate to `localhost:6060` and there you have live documentation of your code.
`iota` is just a convenience macro-like thing built into the compiler. It introduces no new types nor new behavior into the language compared to just writing the numeric literals manually. Constants defined using `iota` are semantically totally independent of each other. The untyped ones can legally appear in context of many different types. Compare that to eg. Pascal where the enumerated type has a name and its values are not assignment compatible with any other type without explicit conversion.
Interesting. I read the criticism about try not doing enough (try is probably lacking regarding automatic and manual error annotation before propagation). But I felt like these criticism were a minority. Maybe I retained a false impression of the whole discussion :-) &amp;#x200B; Personally, do you think the Go team should design a new proposal with the goal of reducing error handling verbosity, including a mechanism to annotate errors manually or automatically before returning/propagating them to the caller?
For computing at the edge, binary size matters when you're updating over cellular data.
&gt; Like I said, nothing was stopping anyone from using the old approach when justified. The trouble is that it is justified (nay, necessary) in most cases, which leaves `try` being useful only a small percentage of the time. What u/Testiclese is trying to say is that if we're going to add special error handling features, we should be looking at something that makes the common case less difficult.
No, it should not and will not be always the fastest.
`try` is hardly a development. It is just a workaround upon powerless type system Go has. Workaround with many pitfalls like resource leakage and the vet barely helps with this issue. And it is an anti-pattern for network services where we should diagnose what resource cased a problem, each time.
It doesn't force you to use anything. You can name your ID field YOLO if that suits you :). Though it recognizes ID/Id/iD/id (i.e. any case) for what it is so that you don't have to annotate it to let ObjectBox know it's a primary key.
https://github.com/golang/go/wiki/SubRepositories
You can actually git clone and run [install.sh](https://install.sh) yourself without going though cUrl, I'm gonna add it to the Readme. I'm just writing it that way as a shortcut, because a lot of PM are installed like that (stuff like Brew for Mac, Yarn, etc...) because it's a bit dumb if you need a package manager to install a package manager ahah Thanks for the feedback
BTW, ObjectBox is not in-memory but "on-disk" (ACID compliant)
I've taken this approach and basically renamed &amp; removed whatever I could. There aren't many other ways to handle JSON requests, and we're all using an endpoint the way it's designed. I'll give a shoutout to this person in my PR and it should be all good. Thanks for the input!!
&gt; I don't want to sound paranoid, but SD card wearout is expected, and I don't really know how it will perform so expecting worst: rand Thinking about this again: It's clear SD cards can die or begin to gradually die at almost any time. But I'd have thought it's a block device with its own CRC guards per logical block/sector. IOW, is it really possible to read from a file on a SD card and get corrupted data - but no I/O error? I'd like to be sure about this before attempting to potentially duplicate for no good reason an integrity layer.
You can‚Äôt compare a GC language with a non-GC language; C/C++ is ALWAYS going to be better in terms of performance; but Go makes it a lot easier to implement, and will be performant enough for 98% of the time. The Go stand net package is pretty solid; if I need more lower level control over the socket then I would probably do it in Rust.
This looks like it would be a blast to go through. I love seeing creative projects like this instead of the typical to-do list/blog app.
Couldn't agree more. The tricky bit is hiding / introducing some of the trickier aspects of the project like terminal escape sequences. The author herself said this is not a complete beginners go project.
&gt; C/C++ is ALWAYS going to be better in terms of performance Not always. *Well-written and heavily optimised* C/C++ is going to be better in terms of performance. It's a lot easier to write poorly performing programs in C/C++ than it is in Go though.
Well, we're speaking about the article. And the article describes the enumeration like coding, which in the context is defined as a type with predefined constants, using the `iota` keyword. And in terms of the discussion predefined type and constants are named by their purpose as an enumeration, rather than by the actual language category. So, this is an enumeration by it's purpose, even though there's no enum in the language itself. The point of the discussion is the bad coding, not the language concepts or the lack of totally unneeded elements and categories. As for `iota` it's ability to define a constant value goes far beyond something simple. It's simple to use, yet, it can create really complex iterative values, essentially releasing the very same definition burden from a developer.
OP if you want high performance with fewer sharp edges than c++ you should consider rust. They use that for linkerd 2.0 and it blows envoy (written in c++) out of the water in terms of performance. Granted, it's not an apples to apples comparison but it is food for thought
If you are writing it to an embed device, you should write it in asm
1) space for "pkg-name" flagname. &gt; "The name of the package for which documentation should be generated.If none is provided, we will attempt to derive it using the GOPATH." 2) new line for "fmt.Printf("ERROR: Failed while processing '%s': %v", path, err)", otherwise two stacked error messages. 3) re prev error. "exit code 1" isn't really informative =(, but I guess it's ok? - Sorry I don't want to spend time on gitlab at this moment to find out how to work with it.
Updated. Thanks for the suggestion
&gt;https://play.golang.org/p/S9fsezkKlwB Oh. Yes, thanks [https://play.golang.org/p/DGQHr7YHEOW](https://play.golang.org/p/DGQHr7YHEOW)
&gt; Well, we're speaking about the article. And the article describes the enumeration like coding, which in the context is defined as a type with And that's wher the article gets it totally wrong. There's no type associated with `iota`. It's an *untyped* value. That untyped value can be assigned to a named type, like `int`, or `T`. But that does not make `int` ot `T` an enum type. It seems it needs to be reiterad: There are no enum types in Go, `iota` is not an enum type, neither are constants created using any expression, with or without using `iota`. &gt; As for iota it's ability to define a constant value goes far beyond something simple. `iota` can define just and only a simple integer sequence, absolutely nothing more. That's how it's specified. What you're talking about is an *expression* that uses `iota`. And yes, expressions can be arbitrary complex. That fact relates to neither `iota` nor enums/enum types.
Well, yes, as I said, even though there's no such a language category in Go, in the context where an int based type is defined to provide options and|or flags with a set of predefined constant values, it is by definition an enumeration. And the article doesn't suggest that language supports enumeration types, it just uses the semantics.
I disagree. I've made way more money with better benefits + gotten equity/revenue share at startups than I have at any larger and more established enterprise. Quality of life in the workplace is waaaay better, too.
why not put everying in a \`map\[string\]string\` first -- that way you can capture all of the fields and values and sort through them later? here's a simple test file that illustrates what i'm talking about: ``` package foo import ( "bufio" "io" "strings" "testing" ) func ParseOutput(r io.Reader) (map[string]string, error) { rc := make(map[string]string) scn := bufio.NewScanner(r) for scn.Scan() { val := scn.Text() // find first instance of ':' pos := strings.Index(val, ":") if pos == -1 { // wasn't able to find colon continue } // split line on first ':' and trim space from each side (probably not // necessary for the left-hand-side but why not do it anyway? rc[strings.TrimSpace(val[:pos])] = strings.TrimSpace(val[pos+1:]) } return rc, nil } func TestParser(t *testing.T) { input := `Enclosure Device ID: 252 Slot Number: 2 Enclosure position: N/A Device Id: 8 WWN: 55cd2e414fcd188d Sequence Number: 1 Media Error Count: 0 Other Error Count: 0 Predictive Failure Count: 0 Last Predictive Failure Event Seq Number: 0 PD Type: SATA Raw Size: 223.570 GB [0x1bf244b0 Sectors]` fields, err := ParseOutput(strings.NewReader(input)) if err != nil { t.Fatal(err) } t.Logf("%#v", fields) } ```
The author's apparent intent to share the code combined with the obviousness of the code is certainly strong indication that you should be fine with this approach.
https://github.com/TheThingsNetwork/go-cayenne-lib First google result
Thanks!
you can use Kafka itself in Golang