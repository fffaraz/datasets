I am currently working with a monorepo that mostly consists of java projects. We also have some go projects there. We use bazel do define dependencies but still use the language's own build tools (gradle, go build) to do the build. We basically use filegroup bazel rule in each projects to define the project's file and list of other projects that it depends on. Then feed the changed files of each git push to bazel query rdeps to see what projects are affected and need to be built. Once I have that list of projects I could trigger the corresponding jenkins builds. 
&gt;Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis \- George W. Bush probably, *Epigrams on Programming*
Are you seeing the stack traces from a panic as part of a test suite, or normal program execution? You could write a function that parses the stack trace and only returns the lines you care about. Call that function from a deferred recover function. https://github.com/maruel/panicparse might be helpful.
Out of curiosity what is the benefit of monorepo? Is it just code sharing? If so isn't that a solved problem and especially in go where you can simply point to a dependency via git url? 
Industrial high quality code is 70% to 95% error handling: You want to make sure your plant stops gracefully without explosion or too many body parts lying around. I do not know why people consider 50% error handling a lot just because it's the web.
Chi isn't bigger, it's probably more lightweight actually. Echo is still a good choice though, but Chi is popular due to it being close to the standard library and it has some nice grouping options in the router (but Echo probably has too). So ultimately it doesn't really matter all that much which one you pick.
YMMV depending on scale - if you've got a handful of services then maybe it's not the right approach. I work on a codebase with about 500 microservices, and I can't imagine how painful it would be to work with 500 repositories. I'm not even sure how code review would work for us (we use github PRs). If you're strict about having single responsibility then a feature you want to implement might touch several services, it's very convenient to have those all in the same place. It also allows you to make a breaking change to one of those shared libraries and update all the callers in a single commit, rather than having it spread out and having different repos in inconsistent states until you're finished. 
It's definitely a shock initially, coming from languages with exception handling for example. One quickly learns to appreciate how nice it is to be explicit though.
In other languages, you can use exception handling to "get me out of here". It makes it look like there is very little error handling code. On the other hand, it makes it nearly impossible to document and study all the flows of errors around the program. For example, say you need to call the routine below. In another language, you have no idea if the things below it can error out or not. def foo(bar) { warble(bar) blah(bar); } In Go, if the routine can return an error it will. That is a signal to all the callers that they have to remember to handle that case (even it's just passing the error back up the stack.)
They are two different articles.
[removed]
Doh, my bad. I replied without thinking. The legacy app that I work on uses stdout/stderr for parent-child comms, not stdin. If you still have stderr, that is good for printing/debugging. 
it makes versioning a lot easier. suppose your services share common RPC definitions, you can have reasonable confidence that any service deployed on the same SHA would be API-compatible with each other.
Any language is able to manage signals ... 
doesn't that make it a distributed monolith at that point and not a microservice? At which point, because they're inter dependent.. it is the same application just split over many instances so of coarse you would want them in the same repo.
&gt; our Amazon AMI image I get the need for clarity in the doc, but I couldn't help but snicker at the repetition.
GOPATH should be pointing to the directory where you will be storing your source code. I personally created workspace directory called **workspace** in my Home Directory just to keep it simple. (I am using Ubuntu)So I set my GOPATH as follows. **export GOPATH=$HOME/workspace** Make sure that you have **bin, src** directory inside of your **workspace folder.** You can then just create folders inside of the src directory for each of your projects you would like to create. 
Are you even versioning at all at that point? If HEAD always must be fully compatible it sounds like you make versioning easier by flushing it down the toilet.
The point of a supervisor such as s6 is not - generally - worrying about graceful shutdowns... it's about restarting things when there are ungraceful ones, such as a panic.
While it is good to have lightweight init runtimes in the case of containerizing legacy apps that were never meant to run this way - I believe a idiomatic container does not include a user runtime at all in most cases. Just a single application and all of its dynamic dependancies makes an excellent container. Golang being incredibly easy to build statically makes it ideal to produce a binary into a scratch container - just be careful with GPL licenses in static binaries! Making a container built on scratch will also help with legal-inspired compliance scans. 
this is really the only correct answer, however with docker that's not really needed anymore.
Its all about changing multiple services at the same time. They are not related but talk to each other to share data when needed like project service needs authorization data for user service, so it needs to fetch that (may be can done different way). Having code in single repo helps, to do changes at all places in one go. I am not saying this is only way to go but one way which currently i am feeling comfortable. Code sharing is just another thing, when we use same code at two different service, we move it to common code instead of making library right away. If same code is used multiple times, then it finally go to library(we haven't started it).
Agreed to this point. Same reason for me.
Nope it doesn't make it distributed monolith. It's just that we are adding a request in one service and responder route with handling in other service when they need to talk to each other, which happens a lot. I am not sure if we have services not talking to each other, its just that they don't share databases and have their own bounded context. They need to interact with each other when needed.
This might be a little pedantic, but docker really doesn't provide this in an of itself. Runit, daemontools, supervisord, systemd, etc. all can restart processes that fail and docker doesn't automatically restart a failed process unless you configure it. The point being is people should understand how they are going to deploy and run the application and code things accordingly. If your organization doesn't use an init, then you'll likely need to do things like signal handling, graceful shutdowns, etc. Solving that problem with a supervisor on your container is another way to paint that bike shed that is perfectly OK too. 
I've been programming in Go for a while, and yes, that part kind of sucks. The programs are ultra reliable, since all errors are handled, but it is a bit of a waste. My proposal to eliminate this issue is, in Go 2.x, to have ``` v := f() ``` become shorthand for ``` v, err := f() if err != nil { return err } ``` Details: https://groups.google.com/forum/#!topic/golang-nuts/z3qgLaCLXG0
Exceptions. You're proposing exceptions.
There has been a weird case where I didn't return my error in the last return value.... Instead I returned something like `(int, int error, error, bool)` (it sounds weird now but it makes sense in the context that I was working on) How would your proposal fix that
No exceptions please.
Not exactly. The error is still returned. The error is still in the function signature. The error still needs to be handled eventually (since you can't return an error from main). I have seen a much better proposal for fixing this in hypothetical Go 2, but I don't think I can talk about it. Rest assured, Go developers have thought of your idea at some point, and improved upon it. I realize as I'm typing this that I'll probably get downvoted. Oh well. Just know that Go developers are thinking about this problem and have some good ideas.
&gt; eventually That's it. No. The idea of "handle an error in a place which knows how to do that, and not in the place where the error occured at" is precisely what exceptions do. It looks very cool in textbooks, but not at all that cool when you need to write code which is either robust or has _sensible_ (as opposed to generic) error reporting, or both. For understanding the former, I hearily recommend reading [this](http://250bpm.com/blog:4). 
To me this is a simple question of readability. error handling is horrible noise that can be mitigiated by a simple change in go fmt. Allow if statements to be kept on a single line when therei is only one return statement in the if. Just like with functions. If i write : var ( err error ; a,b Baz ) if err,a= foo(); err!=nil { return err } if err,b= bar(a); err!= nil { return err} it should stay that way. No need for anything else. That form is way more readable imho. And coming from Ada I always declare my variables at the function or block level beforehand.
So what you're saying is that you're not allowed to ever use `return err` in Go? Because that's what is being proposed here.
&gt; Is there a way to manage errors more elegantly? the answer is no. All alternatives (like functional errors) have obvious issues. You could have a version of each function you write that panics, but you need to prefix them with "Must" and offer an alternative that does not panic. Something that could be automated by a tool by the way.
Some quick notes. Your code is outdated, there have been some changes in latest master. - The `Global` value is a function now instead of a variable. You have to use `.Global()` everywhere. - Callbacks are now `Release()`d instead of `Close()`d. - The signature for `NewEventCallback` has also changed. Just mentioning because people sometimes copy-paste code from blogs and get confused when it doesn't compile.
As /u/kostix said and I will repeat... You should not just be returning errors, because you're leaking the problem scope. `LoadConfig` shouldn't return `io.EOF`.. That's useless to the caller. type ConfigLoadError struct { retry bool err error } func (c ConfigLoadError) Error() string { return fmt.Sprintf("failed to load config because %s", c.err.Error()) } func (c ConfigLoadError) Retry() bool { return c.retry } Now we have an error worth returning. If the caller is so inclined, they can even interface-assert it as an `interface{Retry() bool}` and see if it's worth retrying. Almost never should you just be returning the error you got, because all you're doing is asking someone else to understand the different kinds of errors that your own function is encountering.
Of all the attempts to trim verbosity, this is generally one of the most reasonable. There's a few points though: if err != nil { return err } This pattern is literally everywhere, and is easy as hell to spot. It doesn't take someone long to be able to read code and literally not even see these lines anymore. Without it, though, the code would be denser, and that may make it harder to read. When reading code, you rarely care about the error handling, you want to read the logic and flow... Go makes this very easy by keeping the error handling small and neat. Also, the other issue with that shorthand is that it encourages people to just return the error, instead of dealing with it in some way. As soon as you do anything responsible with the error, you have to go onto a new line anyway. It's optimizing for the laziest possible way of handling errors, which should actually be discouraged.
That's right. Inspect the error, determine an appropriate course of action. Should my caller care about this error I just got? Or do they just care that I failed... Should I care about this error, is it something I can fix, or provide extra information about? At minimum, can I tag this error with some additional context, like what was I trying to do when I encountered this error? At minimum, absolute bare minimum, you should do this: return fmt.Errorf("error while fooing the bar: %s", err.Error())
Sometimes I miss a keyword for this. Something like: &gt;v := trap f() would be short for &gt;v, err := f() &gt; &gt;if err != nil { &gt; &gt;return err &gt; &gt;} It would be a compile-time error if f() isn't returning exactly one error (but it could return zero or more non-errors). If trap shortcuts, the zero-value is returned for non-errors. I do kind of agree with /u/danredux though, just returning errors in this fashion is usually not helpful to caller.
Ok got it! Thank you very much for the feedbacks!
I think change(s) list, but I might be wrong.
Sorry but why there should be race condition there?
Careful, that's a very opinionated opinion you've got there. There's a ton of code, including in the Go standard library, that just returns err.
Source? As far as I am aware, the stdlib doesn't return non-relevant errors, so I'd be curious to see the incidents you're referring to.
There are plenty of bad things about having most of your code be error handling. It makes the code as a whole harder to read, which is counter to one of the core ideas of Go. It obscures the happy path, forcing strain on the reader, because most of the time they want to see what the code does, not whether it deals with errors or not (the later being automatically assumed to be true for seasoned code). The reader might start skimming through the code due to the repetitiveness, potentially missing pieces of code they needed to read. It also causes strain on the writer, which in turn might lead to bugs. So please, lets not kid ourselves that the current situation is the best possible way of dealing with errors. I'm glad that there is a realistic discussion on how to improve things for 2.0.
Also this https://commandcenter.blogspot.com/2017/12/error-handling-in-upspin.html 
Thank you very much, I'll update my examples and github repo quickly.
map[string]Student should work.
I don't see a way to pass map[string]interface{} e.g. some options, it is possible with gopherjs. Is that going to be added before final release? 
I'd like to recommend you github.com/pkg/errors .Wrap to add some textual context to the errors instead of passing them as-is - so you know where the error comes from.
The approach has merit because it's an idea that can work alongside the current err check pattern. If it's necessary to add context, or if returning the error is not appropriate, then proceed with the if err check same as you do now. The compiler can determine when a function returns multiple values, and the err value is being returned but not assigned. In those cases, the automatic if err and return is identical to writing it out ourselves. Simply, continue writing code the same way you do know, but if you don't need to do anything to the error and simply need to return it, the shorthand approach solves that probem.
The shorthand pattern doesn't need to accommodate everything. It can be made to work only for functions that return one error value. Alternatively, it can follow the same pattern as named return variables. 
Just grep return err in the Go code.
So is it still experiment or ready for production?
What database are you using?
Nobody is saying that the current situation is the best possible way, but I still think that having a lot of error handling doesn't mean you're doing something wrong at all.
The obvious question: does it utilize v8 garbage collection or inserts it's own gp gc in the generated wasm runtime? 
Nope, this proposal maintains localized error handling. You can still do custom error handling just like we do now, but it's optional rather than forced.
Good question. As per https://groups.google.com/forum/#!topic/golang-nuts/z3qgLaCLXG0 , there would be no shortcut for handling this case, as it returns more than one error (and that one error isn't returned last).
You can catch exceptions inside the function, too. This is exceptions, this is literally how exceptions work.
Nope! If the shorthand I proposed were instead equal to v, err := f() if err != nil { panic(err) } _then_ I would be proposing exceptions. But I'm not. The semantics and behavior are the same as present, but without the boilerplate.
You are speaking as if my proposal eliminates the option to do what you suggest. I have eliminated no such thing, but if you want to follow the very common and reasonable idiom of having `return err` everywhere but not have to type out all that boilerplate, you _can_ with the proposed shorthand notation. Also, if you read the end of my proposal you'll see that I suggest that being able to register your own default error handler function so that you can leave annotations just like in your example. Copy and pasted from my proposal, at the end, as a related idea I'd like to explore: errors.RegisterHandler(function(callerName string, err error) error { return fmt.Errorf("Error from %s: %s", callerName, err) }) This accomplishes what you show in your example, but without the boilerplate.
That won't necessarily highlight this issue though. They still used typed errors where applicable to attach extra information and handle different kinds of errors in different ways in certain places. Other than that, the standard library doesn't have too many parts that are all that "deep". After all, it's the standard _library_, not an application on it's own. Having to choose how to handle errors often comes up more in applications receiving errors from libraries (that are often quite shallow).
The stdlib uses `return err`, `return 0, err` and the like many hundreds of times: https://github.com/golang/go/search?q=%22return+err%22+OR+%22return+0%2C+err%22&amp;type=Code
AFAIK, wasm currently does not provide GC, so there was probably no other way than to use Go's GC.
I disagree, less lines != more readability IMO. It's much easier to read when the code isn't as dense. I hate the idea of trying to scan for that in a document where there's any sort of dense code.
I'm not sure why you are asserting this so strongly; the stdlib itself uses `return err`, `return 0, err` and similar statements many hundreds of times: https://github.com/golang/go/search?q=%22return+err%22+OR+%22return+0%2C+err%22&amp;type=Code See my similar comment above that mentions a way to do something similar to what you suggest here, but without the boilerplate.
It's not the worst suggestion I've seen, but the implicit return is really nasty. If I'm reading some code (which I'm doing much more than I'm writing it, bear in mind), I don't want to have to check if something returns an error when I see `a := b()`, just to check if the function could return without the word return being used there.
Yeah, this solves the problem that I've mentioned in my reply to /u/EclecticMind. Maybe even something like: a := b() or return Keeps it nice and explicit, like the `trap` solution does.
Written by /u/quasilyte, who is employed by Intel to work on the Go compiler. Not sure why it hadn't been shared before. Hopefully this material will help improve the official docs. If any of you aren't familiar with the Go compiler or its SSA phase, there are now a couple of READMEs you can have a look at: * [cmd/compile/README.md](https://github.com/golang/go/blob/master/src/cmd/compile/README.md) * [cmd/compile/internal/ssa/README.md](https://github.com/golang/go/blob/master/src/cmd/compile/internal/ssa/README.md)
postgresql
For now, everything is through callbacks. You cannot `pass` anything or `call` any function in Go from JS. Calling Go functions is not in the scope of this release. You can however be tricky, and set global objects and access from Go. In a way, you are "passing" things.
how can access student through the id then? I did try this , every name maps to a struct consisting of age weight and height. But how to store it?
I feel like everyone misses the point with these discussions. I think there are two areas of concern, and everyone only talks about one of them. 1. Ergonomics of error handling. What should the syntax be? What features do we want? 2. Adding information to errors. Go currently sucks at this, wrapping error strings and destroying error types and error values is the most common and sane way of add information. Worse yet, **usually** all people add is what amounts to a shitty stack trace. Ie, the wrap string just indicates that the failure was on `open file: %v` or w/e. If we fix #2 and improve the amount of information errors get *by default*, we'll be far less concerned on how commonly programmers add yet even additional error information. I like errors as values, I think we should keep that personally. But I don't think we should always have to write our own stack traces. That's just gross. We're programmers, lets focus on the clear ways `error` needs improvement - and less on picking the color of the bike. My 2c
How does this simplify the more desirable case, where you wrap a context around the error?
Callbacks may take arguments but won't return anything, so you can send values from JS to Go but you can't return values from Go to JS... Callback arguments are received in the form of a \[\]js.Value slice. I think you may use js.Value as an equivalent to map\[string\]interface{}, since it has a Get() method which takes a key string and returns another js.Value.
I updated the article, the sources on github, and pushed the new images to docker hub, thank you again.
&gt; I am statelessly appending something to a slice? You are modifying a variable on multiple goroutines without protection. I'm not sure what you think "stateless" means. append has to be able to allocate a new slice and copy the old, so imagine that two of them decide to do that at the same time.
Yes Go's GC has been ported to wasm: [https://github.com/golang/go/issues/18892#issuecomment-359208503](https://github.com/golang/go/issues/18892#issuecomment-359208503)
As for building an object to send to a JS function, something along this might work: ``` opts := js.Global().Get('Object').Invoke() // New JS Object opts.Set("key1", "str") opts.Set("key2", 123) ```
Good question. This is covered at the bottom of my proposal. We could register a default error handler function in a way that perhaps looks like errors.RegisterHandler(func(callerName string, err error) error { return fmt.Errorf("Error from %s: %s", callerName, err) }) or like errors.RegisterHandler(func(callerName string, args []interface{}, err error) error { return fmt.Errorf("Error from %s(%+v): %s", callerName, args, err) }) Also under this proposal, _if you want to write your own error-handling code, you can, exactly how you do now_.
There are still many uncovered parts, unfortunately, like what does idx suffix mean and what is the purpose of having op+load/store variants, etc. Article is not exhaustive and can only serve as a starting point. 
This is a great point. I want the same thing, and I cover this at the end of my proposal: I think it'd be cool if we could set a default error handling function. This could look something like errors.RegisterHandler(func(callerName string, err error) error { return fmt.Errorf("Error from %s: %s", callerName, err) }) or errors.RegisterHandler(func(callerName string, args []interface{}, err error) error { argsStrs := make([]string, len(args)) for i := range args { argsStrs[i] = fmt.Sprintf("%#v", args[i]) } return fmt.Errorf("Error from %s(%v): %s", callerName, strings.Join(argsStrs, ", "), err) }) So we get (1) less boilerplate, (2) better default call context than a mere `return err`, (3) we don't need to re-type that contextual information all over the place, and (4) we can still write custom logic where we want to (but we're not forced to in the simple cases).
An interesting talk on this subject by John Cinnamond: https://www.dotconferences.com/2017/11/john-cinnamond-go-lift Warning! Functional programing involved...
What do you guys have to say about gin? Planning to transition from node to go and id like to know the whats the standard
You are conflating one fact about exceptions with what exceptions are. Exceptions cause software to explode if you forget to catch/check for an error. This proposal introduces nothing like that. I have proposed syntactic sugar to cut down on error-handling boilerplate code. Asserting that the introduction of syntactic sugar somehow changes the entire paradigm of error-handling is factually incorrect; the semantics and behavior are the same, but the syntax is more succinct.
JWT Tokens must also make you snicker ;)
A reason to not run your go application as the root process is if you execute other commands. In that case you should probably want tini etc (or --init with new version of docker https://docs.docker.com/engine/reference/run/#specify-an-init-process) see https://github.com/krallin/tini/issues/8#issuecomment-146135930 for a nice explanation.
I'm using Archlinux. Vim is not so easy, but programming is not easy either. Vim is simple and powerful.
Considering that this is your third post for the exactly same question please tell us: Where is your actual problem? Do you don't know how to get started? Do you want to know an idiomatic solution? Do you don't know how to unmarshal JSON into a Go data-type? Take a look at encoding/json. Do you don't how to insert an entry into your database? Take a look at database/sql. Have you already created a db schema? What do you exactlx mean with dynamic-key? Does the data-type change? But as it is probably an JS-object name it is a string. Do you want to use the JSON key as primary key? Is the data like in your example an array of JSON with the same structure? This would simplify things a lot. PostgreSQL has a type for JSON. Do you want to use it? Please put the at least the db-type in the post description.
And what exactly was wrong work the previous discussions? Why should we keep answering the questions if you're not even going to implement the answers, or show any evidence that or answers are helpful? [How to ask questions the smart way](http://catb.org/~esr/faqs/smart-questions.html) [Don't be a help vampire](http://www.skidmore.edu/~pdwyer/e/eoc/help_vampire.htm)
I don't like it, because its doing something implicitly that could be easy to forget. I would prefer a new keyword added, which I'll label as `raise` right now to be clear that what we're creating here is similar to exceptions. func container() error { v := raise f() } This keyword is allowed as a shorthand under the following conditions: 1. An `error` type exists in the last/final position of `f()`'s return types. 2. An `error` type exists in the last/final position of `container()`'s return types. If `f()`'s `error` return value is not `nil`, it is returned immediately. Every other return value is initialized transparently to its zero value, unless named return arguments are provided. That being said, I would prefer this to be more explicit, and a new language-level generic type be introduced; `result[string]`. This reads that the type it returns is either a `string` or an `error` (of course, you can specify whatever type you'd like in the brackets, just like maps or slices). It would abide by an interface that looks like: interface result[T] { Value() T Error() error } If a function returns a single value and that value is of type `result[T]`, then you gain access to two new keywords to help manage that result type: - `v := raise f()`: Just like above. If `container()` returns a result of any type, its `error` value will be returned as the `error` of the `f()` result type. The `Value` type can be different; if `.Value()` is called on it, it will return the zero value of that type. - `v, err := unwrap f()`: Unwrap the result for traditional error handling in `foo()` itself. Creating a `result` could happen one of a few ways, but possibly something like: - `make(result, "it worked", nil)`, `make(result, "", errors.New("it failed")` - `make(result, "it worked")`, make(result, errors.New("it failed"))`; if the second argument fulfills the `error` interface, then we can elide the value argument, given that Go has the powerful idea that zero values of all types are consistent. - Possibly even `return "it worked"` vs `return errors.New("it failed")`. Finally, I would also like to see the actual `error` type it can return be optionally customizable, given that its pretty common to specify more complex errors. This syntax could be expanded to say `result[string]CustomError`; `CustomError` must be an interface or value which fulfills the `error` interface. However, this might be getting too complex, and at that point you might just want to revert to using normal two-value return syntax. 
because your typical web app is not as safety critical as a power plant?
Thanks! That is what I needed.
Any different from the talk of the same name she did a few years ago?
&gt; In many languages, you need to run an application like S6 to detect a shutdown and send your app a graceful shutdown in order to avoid lost requests. In what languages do you *need* to run S6? I'm curious.
We're building both a registry and a proxy. You can use one or both, but if you use the proxy you have no obligation to use the registry.
1. Maybe introducing a new keyword _is_ worth it here... 2. The behavior of exceptions (or panics) is quite different, as these could crash your program if not handled, unlike a returned `error` value. 3. If you want all the rest of that, why not just code in Rust rather than turn Go into Rust?
Iâ€™d just make subdirectories and use import as needed. You may also want to look at ldflags and other compile time options to help put some logic into your builds. You may also be interested in plugins. You can compile shares objects with Go. The downside here is their size (I believe thereâ€™s plans to address that). Plenty of options and tools to be clever, itâ€™ll be a matter of what works best for you.
Leftpad ðŸ˜‚
Curious, at 4:50, the go code appears to be using the Unicode not equal to code point?
Iâ€™m probably the minority, but Iâ€™ll always maintain that versioning/package management is a bad idea for Go. I believe it has the power to destroy some of the best qualities of Go. History has only proven that it has been a major problem time after time. Python, Ruby, PHP even, and perhaps Node.js being the worst. Having hundreds of megabytes in a node_modules folder is perhaps the worst consequence in programming history given the entire point of JavaScript. Iâ€™d hate for Go to end up the same way. Force people to be on top of things. Itâ€™s a good thing. A little bit of builds breaking is better than the alternative potential (Iâ€™ll say itâ€™s just a potential not a guaranteed death sentence) disaster. Like a package? Worried? Fork it. Version control handles these issues for us. Thatâ€™s the proper domain. Not the language toolchain. Iâ€™ll fork on github, use my fork, and then pull from upstream or cherry pick as I see fit. Solves all of the problems........except one. Laziness. It does require time. Ok. Well that out of the way, I do look forward to seeing what the community comes up with here.
This is a correct answer and is still greatly under-mentioned in the Go community. It took me a year of coding in Go and reading all these "that's the go way" before I finally got to \`pkg/errors\` (after making my own package which basically does the same thing, btw). It definitively changes how you deal with errors in your software, SPECIALLY when there's no sane recovery from the errors and you may just want to tell the user 'nope, i failed' but still log and soft-handle (send the error to a metrics system, have the stacktrace to debug, etc). I find this is generally the case with simple HTTP APIs which perform CRUD operations. Before \`pkg/errors', my code looked mostly like this. func Get(id string) (thing, error) { t, err := db.get(id) if err != nil { log(err, "in Get function") return thing{}, err } return t, nil } Now, I can just do func Get(id string) (thing, error) { t, err := db.get(id) return t, errors.Wrap(err, "getting from db") } It may look like a simple line but I've gained a stacktrace too, which is incredibly useful tool for debugging. I can just handle the logging and distribution to other services of my errors transparently at I/O or HTTP handling layer of my code, which is where it should be in most of the cases.
That's an entry-level rate for full-stack qualifications.
Admittedly might seem counterintuitive in the beginning, but if you ignore the spread-op for a moment, then kinda expected. When passing slices, we usually don't want what folks call a "deep copy" to be passed --- instead the "slice" consists of a triplet (imagine sth. like startAddr, len, cap) that's cheaper to copy around. On the other hand, passing an _actual_ array (not a slice) would indeed be copied. Now what about the spread operator syntax-sugar? On the whole it shouldn't change slice semantics, since the callee does receive a bog-standard slice from the caller and should be able to operate on it as-usual without surprises. So like maps, slices are these somewhat-special "reference value types" --- lenses or windows into underlying 'stores' that they offer indexed reading-from and writing-into. Passing "copies" around of them won't create full copies of said underlying, and performing such deep-copies is an expressly explicit manual effort. Bit tricky to wrap one's head around at first, coming from many other high-level languages, I guess. But quickly internalized in practice.
wait, slack? I looked around there but all they allow you to do is to create your own workspace and that's it
Ah this is great. Before Ilya's CL came out, I have been wondering how would one go about adding FMA support to the compiler. I had figured out the opcode and rewrite part, but the codegen implementation was where I got stuck. This is great stuff. We need more of this.
You are very lucky! Because PostgreSQL does support JSON via columns of type JSONB. And you can define GIN indexes on those columns. And even better, there is a PostgreSQL-specific ORM for go: [https://github.com/go-pg/pg](https://github.com/go-pg/pg) That helped me solving similar problems.
It seems kind of crappy to have to convert Go types (structs and slices) to JS types (objects and arrays) everywhere.
One of thing is don't try to optimize and be too smart about int size, it will bit you on the end, if you're not sure just use an int64.
It looks like Go 0.10 should be replaced with Go 1.10?
I love any idea to make Go error handling less verbose. However, it should no become less *explicit*. Completely hiding the error handling makes code harder to understand. It is the same problem as with exceptions in other languages: Does this code return an error? v := f() You cannot tell without looking at the source of f(). This is exactly what should not happen in Go. And there is also nother possible issue. This code if err != nil { return err } is, as far as I am entitled to say that, not idiomatic Go. Or, at least, some do frown upon that. Why? Because when the error bubbles up the call chain, it should take some context from each of the callers with it, to make troubleshooting easier. If the final log entry just contains something like, "I/O error: expected 1024 bytes, got 12" because this is the database driver's view of the problem, then this is not very helpful. If the calling functions add context along the way up the call chain, the final log entry will tell you exactly at which functions to look, which data to use for replicating the problem, etc. Have a look at github.com/pkg/error to see what I mean. So my $0.02 for new error handling in Go: Strive to make the syntax more concise but still keep it explicit, and allow adding context when the error is passed up the call chain.
This is a great overview, thanks for sharing!
Nah, its just an editor trick. "font ligatures" https://www.goheroe.org/2017/08/15/enabling-font-ligatures-on-visual-studio-code/
[removed]
its a vscode decorator
Cheers
This is the go way. The language should be renamed to "if err!=nil {return err}" 
Thank you for your comment
That's why your business-logic to error handling ratio is 1:1 for web app and 1:10 or 1:20 for a power plant.
I am 99% sure it will error given the inconsistent use of semicolons.
This is indeed nice, however, what do you do if you don't immediately return there with a Wrap, but rather have to move on? This is okay, if you have no other lines after that \`t, err := db.get(id)\`. But if you have to continue on and handle another error, that's it. Upon an error you have to return. Also, also, I don't see this gem mentioned: [https://blog.golang.org/errors-are-values](https://blog.golang.org/errors-are-values)
Yeah, having done Java before, the Spring error handling gives me fucking PTSD compared to go.. Oh kewl, let me look at this 233 lines of errors all the way through the Spring callstack. That narrows it down. 
[removed]
That package does not parse the registry manually. It calls windows functions to modify the registry. So if you want to modify a registry hive manually, you'll need to look to another solution.
[removed]
&gt; Is this intended behavior? Yes it is. Passing a slice that shares the backing array between the caller and callee makes the mutability expected. OTOH, it would be quite surprising when an argument like `i` is passed to a variadic function for it to bu mutable by the callee.
$75/hour is an entry-level salary? Where?
$75/hour is roughly the equivalent of $55,000 a year for a Freelancer. A full time job with those qualifications should be pulling in $75 to $125k plus benefits anywhere in the US.
If this is contract work, $75hr for 40 hours a week yields a ~$75,000 salary after taxes in California - that's a typical junior developer starting salary here. 
Why isnâ€˜t anyone suggesting the go tour? Or i am blind? It is available on and offline and is awesome to learn the first steps.
Gorilla? 
We are getting crumbs over here!!1
Please enlighten me. In what range will I find people?
I will agree with you this time, only because OP seems to be living in Chicago: â€¢ https://www.reddit.com/r/politics/comments/8156s5/illinois_house_approves_bill_that_would_raise/dv0m08f/?context=3 â€¢ https://www.reddit.com/r/videos/comments/5auwq6/the_final_play_of_the_world_series/d9jxf4i/?context=3 â€¢ https://www.reddit.com/r/AskReddit/comments/3f6k5e/people_who_live_near_famous_tourist_destinations/ctmyduv/?context=3 â€¢ https://www.reddit.com/r/blog/comments/2cldbm/help_teachers_get_the_supplies_they_so/cjgn4d4/?context=3 â€¢ https://www.reddit.com/r/funny/comments/1dh4j1/ahhchildhood/c9qem5r/?context=3 â€¢ https://www.reddit.com/r/technology/comments/rgw4m/starting_july_1_isps_are_voluntarily_rolling_out/c45wuq6/?context=3 But $55k/year is more than enough to live a luxurious life in certain parts of Canada, most of Latin America, and many countries in Asia. Heck, I was able to live 3 years in Berlin with $48k/year without any problems. It seems that some people in this sub-reddit are assumming that the majority of Go positions advertised on the web are targetted to US citizens, or as other commenter said in this thread, Californians, which are used to higher salaries.
I will agree with you this time, only because OP seems to be living in Chicago: â€¢ https://www.reddit.com/r/politics/comments/8156s5/a/dv0m08f/?context=3 â€¢ https://www.reddit.com/r/videos/comments/5auwq6/a/d9jxf4i/?context=3 â€¢ https://www.reddit.com/r/AskReddit/comments/3f6k5e/a/ctmyduv/?context=3 â€¢ https://www.reddit.com/r/blog/comments/2cldbm/a/cjgn4d4/?context=3 â€¢ https://www.reddit.com/r/funny/comments/1dh4j1/a/c9qem5r/?context=3 â€¢ https://www.reddit.com/r/technology/comments/rgw4m/a/c45wuq6/?context=3 But $55k/year is more than enough to live a luxurious life in certain parts of Canada, most of Latin America, and many countries in Asia. Heck, I was able to live 3 years in Berlin with $48k/year without any problems. It seems that some people in this sub-reddit are assumming that the majority of Go positions advertised on the web are targetted to US citizens, or as other commenter said in this thread, Californians, which are used to higher salaries.
What do you see as some of the scalability problems with database/sql?
[removed]
I completely agree; I'm against any form of abstraction that hinders readability for the sake of keystrokes. Which is why the suggestion you made in your other comment to use \`or return\` makes the most sense.
Yay! Can we get rid of Javascript now?
It does not enforce 100%, but the level the user choses to be good-enough and prevents accidental coverage gaps. "Good enough" is not measurable and should still be the goal. Adding branch coverage via https://github.com/junhwi/gobco would make it more strict and would be a nice feature, but I wanted it to be independent/simple at first.
The standard Go library is the standard library that should be used in Go.
So you use no 3rd party libaries or frameworks? Just pure Go?
I guess it depends what sort of programs you're intending to write. There's a lot of good libraries out there. Take a look at https://golanglibs.com/
Depends on what you are going to do. Each time I use Go's built-in libraries, I feel like I was using 3rd party libraries.
&gt; My system (a Raspberry Pi) doesn't have a reliable system clock. Why not? I think you should fix that problem first. &gt; Will `time.Sleep` still work It depends. See https://github.com/golang/proposal/blob/master/design/12914-monotonic.md If you are just somehow setting time to random values, it could be fine. If your clock is randomly drifting, it won't work. No language can paper over a broken system clock.
If you just have a small number of routes, then yes, just use the standard library. You can declare static routes, but you have to parse out the HTTP method yourself. It does get ugly if you have many routes. I recommend starting with a router library (http mux). Don't stress about it too much, just pick one. Switching routers isn't that big of a deal. You can also choose to build on one of several high level frameworks (gin, gorilla, etc), that do much more, but are more pain if you need to switch. I would not start with these. 
I don't like the trailing `or return`, though. The best proposal I've seen thus far is: v, err := f() check err, fmt.Errorf("foo failed: %v", err) The new `check` keyword takes two arguments: the first is a "not-nil" check, the second is the return value. This looks very nice and allows adding context to errors. I think two lines is "short enough", and the value of cramming stuff on a single line isn't worth it.
&gt;Why not? I think you should fix that problem first. That's what I'm trying to do :). Write a go program which every X period of time would use ntp to update system time. I would have used cron or something like that, but that would put the cart before the horse.
The source for the standard library (and the compiler and other tools) is in the source code tarballs you can download from [https://golang.org/dl/](https://golang.org/dl/) PS ctags are nice, but the (also part of same tarballs) guru tool gives you not only jump-to-definition and list-callers or references to this, but higher level analysis like "what's a code path from main() to here?" and "what classes in the entire $GOPATH and $GOROOT implement this interface?" and "where is code which sends/receives from this channel I'm receiving/sending on?". And the answers aren't approximate either. They are right. The things guru doesn't handle correctly is it doesn't obey GOARCH (it assumes you're asking about the host's architecture, not the targets), and it doesn't handle cgo much at all. So if you have a lot of cgo then ctags might work better.
ntp already syncs the time periodically, you shouldn't have to write any code. Perhaps you should just buy a new PI. How much is your time worth?
Yeah, I mean... unless you need something very specific that the built-in library doesn't provide, it's really well-documented and the APIs are well designed (with the possible exception of the log package).
Assuming you can run code on a Windows machine, you can call the windows API to load the hive into a specific registry key (hkcu\foo) then read and write into that key. Be sure to unload it when you're done. Doing this on other platforms will be an exercise in insanity.
Moving from JS you wonâ€™t need to think about optimizing performance for quite some time. Learn to code with a minimum set of tools, mostly the standard library, and your app with be faster than a scalded cat.
This is such an interesting article, I've been looking for some personal challenges to put my minor Go skills to use and learn the language a bit more. This is definitely going on my side project list!
Well, "ported" sounds a bit inaccurate. Go's GC is written in Go, and the Go compiler was updated to output wasm, so the GC to a large extent just came along for the ride with the rest of the runtime (maps, channels, etc). There were a few runtime tweaks needed (as with any new port) but not a ton. It was mostly in the compiler. 
Suck it up and parse the file is what I'd suggest, if you can't find a library to do it for you.
I got into it rewriting a node project, used [labstack echo](https://github.com/labstack/echo/) seems pretty good. Still some things that confuse me about Go and I still hate types but overall itâ€™s sooo much easier on my sanity than Node. 
Yes, they are two different articles.
reddit search didn't show it to me. The new reddit UI has many bugs.
Just run ntp. Or better yet, chrony. You don't need to do anything periodically.
That particular project looks very naive, I'd ignore its existence for now.
You might also find [awesome-go](https://github.com/avelino/awesome-go) useful
You call once then get all messaged in queue. Then you can process them so you can batch insert. SQS isn't a streaming service. It litterally has messages waiting in their servers to be read. Once you read the messaged the messaged become unreadable and hey presto you've cleared your queue reliably. Do this every minute or so, the http overhead will be trivial. The cost is very low and the service is highly avaliable.
Did you maybe mean "path coverage" ? Because branch coverage is already builtin, did you even try it ? It might not be perfect, but it sure catches bugs (unreachable branches / forgotten tests), so I prefer it over "nothing".
I don't feel like dragging this conversation out. Stop moving the goalposts. The original topic was about adding a shortcut for return err. Clearly, you admit that return err isn't bad if it's not "deep". Therefore, you're wrong that it is "almost never" correct to return err, unless you redefine "almost" to mean "sometimes".
If you're talking about clock drift in the order of seconds, your Pi shouldn't drift that much. If it does, get a new one. If you're talking about clock drift in the order of milliseconds, or nanoseconds, the Pi's clock yeah sure it's probably not that accurate. If you just need it for timing how long something takes on a short interval, I'd probably not worry about it. In general though, NTP does it's thing. If it's not, depending on the situation maybe switch to chrony, but probably not on a pi cause your problem there probably won't be consistent day to day.
The first gen raspberry pis didn't have a hardware clock to reduce their cost. Not sure if they added it in the second gen or the third, but I'm pretty sure the 3 has one.
You can try godef. I tried ctags for go too,but found godef is the solution.
&gt;Side note: By using fmt.Println, the error is directed to the standard output device (os.Stdout). It would be better to write errors to the standard error device (os.Sterr), e.g. by using log.Println, but this will add a timestamp to the output and look too verbose. Of course, you can change it later. https://godoc.org/fmt#Fprintln fmt.Fprintf(os.Stderr, "stuff") Or any of its peers (Fprint, Fprintf...)
ohhh i see what you mean. you are talking about the process of sending the messages to sqs. Thats an interesting concern. I suppose you can have have a seperate microservice that just handles the ingress of messages. ORR you could go even further with the AWS buy-in and use cognito to give the user permissions to send messages directly to SQS. Completely bypassing the need for it to hit a central server first.
I don't know why you would want to... Our team uses node for all the API stuff, and uses golang microservices for anything intensive. It really sucks to rewrite all your api's in go for no reason.
Thank you, I may update the article accordingly :)
Yes, sorry for the inaccuracy, thank you for pointing out
&gt; the hive I have saved with "reg save HKLM\SOFTWARE myhive.reg" A reg file is something completely different than a registry hive. A reg file is just a ini file. It's pretty easy to write a custrom parser for it. A registry hive is a more or less undocumented binary file the windows system internal uses. The easiest way to modify a registry hive is to use windows functions to mount it in a specific registry path, and then use normal registry functions to modify it. 
Interesting. Seems cool. Just a question, why would I use this over Jaeger?
Use systemds timedatectl to sync the time. I had the same problem with my rpi.
Is there a reason you are not using https://github.com/fatih/vim-go instead?
It's one of the biggest upsides of Go. The standard library is modern and very wide for web/network development. There are third party libraries, of course, but they aren't "de facto standard" like some are in Node. 
Nice. Few tips: https://github.com/skx/go.vm/blob/master/cpu/cpu.go#L152 use constants here instead of magic numbers. Create a custom type for Opcode with string method and cast `instruction := opcode.Opcode(c.mem[c.ip])`. Then you can do `debugPrintf("%v\n", instruction)`. And remove a bunch of lines.
That's good feedback, thank-you. Regarding the constants they're already defined in [opcode/opcode.go](https://github.com/skx/go.vm/blob/master/opcode/opcode.go) and so I was planning to switch to them. The printing tip is a good one too, thank-you.
Disclaimer: I created this. Meant to be a URL shortener with cool features. One of the cool features is authentication, where you can add OAuth to your links (e.g. [john@gmail.com](mailto:john@gmail.com)) so only users with that Google account can access the link. Currently only supports Google.
Hmm, not sure I'm moving any goal-posts, that was my first response to you. Maybe you think I'm /u/danredux? My interpretation of /u/danredux's argument there is that in a project you should almost never be using a naked `return err`, because in a project you'll generally have more layers of code, and that additional context is very useful for debugging. Libraries are bit trickier because there are plenty of libraries where receiving _any_ error is the only thing you'd care about, then there are others where you care about what actually happened, e.g. `sql.ErrNoRows`. It has to be judged on a case-by-case basis depending on the functionality of the library. Either way, as long as the library consumer can handle any error appropriately, that's what's important.
Sorry if this seems like a dumb question, but what is a span?
Great article. Thanks for sharing.
Oh nice, this is better than my idea.
Represents a "segment" of a trace. See more details here: https://github.com/opentracing/specification/blob/master/specification.md.
Thank you
ah thats a good idea, limited to windows of course but that may be ok in my use case. Many thanks! Although one day i may try the insanity route :)
Same question
Also want to echo this -- node for API endpoints and go for back-end services makes a ton of sense. Go may be great at a lot of things but personally I don't care for their HTTP route/auth configuration. Express really is quite good at what it does.
just forget about npm and fetching libs for everything. If you are doing webdev you can get away with almost just the standard lib and gorilla packages
[removed]
Every variable in Go is mutable. What you mean is pass by value vs pass by reference. In Go everything is passed by value. You can emulate pass by reference however by passing a pointer. Considering a slice holds a pointer to the underlying array it can be mutated. And this is what is happening here. In variadic functions the array is not copied because of better performance.
I mean it's good to know that you should set various http server/client timeouts, defer response.Body.Close() for http requests, resort to channels as a synchronisation and not a messaging pattern, throw your code through errcheck or something, pay attention to unbounded goroutine spawning, ... if you do, you at least stand a chance of handling production load :).
I may be misunderstanding, but this reads to me like you're using express/node just to reverse proxy requests to go back-end services? What are the express/node features you're after, what are you actually taking advantage of here? Regarding the router comment: I can't think of one thing (including syntax), that I don't like about [chi](https://github.com/go-chi/chi), and I used express in many projects before. Best guess, you're relying on some npm middleware packages and it's easy to call `router.use(cors)`? (chi has a similar API + provides lots of middleware examples, CORS, JWT, ...).
It seems that your comment contains 1 or more links that are hard to tap for mobile users. I will extend those so they're easier for our sausage fingers to click! [Here is link number 1](https://github.com/go-chi/chi) - Previous text "chi" ---- ^Please ^PM ^/u/eganwall ^with ^issues ^or ^feedback! ^| ^[Delete](https://reddit.com/message/compose/?to=FatFingerHelperBot&amp;subject=delete&amp;message=delete%20ID_HERE) 
How's this differ from [OpenCensus](https://opencensus.io) ?
Chi looks really good, I'll have to take a closer look at it. It seems to have a lot more batteries-included rather than the loose collection of express-compatible packages (that also widely vary in their quality and maintainability.)
Me too 
I think that stdlib compliance is a must for a project
Thanks, I fact I'm looking for something with little dependencies, It seems that chi will be my "weapon" of choice
Cool to see this in the standard library!
&gt; As I said in the proposal itself, this syntax would not be forced upon you, but would be optional. FTR, I consider this an anti-feature (i.e. a major downside of this idea). Readability and Engineering at scale in general is all about consistency and uniformity. i.e. you're giving me the worst of both worlds: My own code won't change very much (as I don't tend to just pass errors up the stack), but I still have to know this shorthand to understand other people's code. I also find it problematic to have control-flow without syntax. The branch and potential error return right now is obvious just from the AST - with your proposal, you need to understand the types of the function you are in and the types of the functions you are calling. Lastly: &gt; The Simplest Possible Go 2 Error-handling Proposal There are many concerns people have about Go's error handling and personally, I consider "boilerplate" to be the least important of them. Other concerns include it being easy to forget to handle an error (which your proposal makes worse) or the lack of safety in error types (a thing I'd personally like addressed, i.e. communicating error details with static guarantees). I'd really like to have those concerns separated, because everyone wants different things solved that are related to error handling.
How are you calculating this?
It also adopts orphaned processes and needs to shut them down as well.
For the most part, yes. Imagine a world where you don't need over a GiB of node_modules to get your project running :)
i.e. RTFM?
&gt; Traces in OpenTracing are defined implicitly by their Spans. In particular, a Trace can be thought of as a directed acyclic graph (DAG) of Spans, where the edges between Spans are called References. Which led me to https://en.wikipedia.org/wiki/Directed_acyclic_graph I'm still not sure what a tracing span buffer is.
More technically speaking.. When you *call* the variadic function, your passed-in values are all copied into an array, and a slice is created for that array. You are then passed a *copy* of that slice. The caller is the one that set up the slice to point at copies of the arguments passed in. The call itself copies that slice and all other arguments in order to call the function. The function then gets a copy of all the arguments. Most of these copies will get optimized out to some degree, but you'll never be able to notice whether or not they were actually copied, as it's part of the language spec to make them function equivalently.
Thanks for bringing this stuff up. I think there's a bunch of "gotchyas" in the language, and all of them should be compile-type errors somehow.. In my opinion, the language won't really be *complete* until, for example, unbounded goroutine creation is a compile-time error.
Anyone know when a sane import/export of functions is slated to land. I'm talking about the way Rust does wasm. It's sad to see my favorite language lagging :-)
Well I work on Jaeger so I have a bit of experience here. I'm guessing it relates to the idea of no sampling based on the description. Without sampling, traces are emitted every time the tracing code is hit, which leads to a large number of spans that need to be analyzed and potentially inserted into storage. Therefore, this project provides a buffer to help maintain the spans before they are committed to storage.
If you don't care what country the developer is from then this rate is OK - there are many countries with low cost of living. Freelancer has to account for: - health insurance - other mandatory payments (varies per country - could include pension plan, unemployment insurance and more. those are usually split between employer and employee) - paying income tax, including what would otherwise be covered by employer contributions - lack vacation or sick days - non-billable hours (5-30% of the time, varies) - the fact that they won't be employed 100% of the time - buying own hardware/software/paying subscriptions - other cost of running a business (accounting, etc) Rule of the thumb is to earn the same amount as salaried employee you have to charge at least twice the hourly rate a salaried employee would make or annual salary divided by 1000. For example a salaried employee making 120k / year before tax, with 10 vacation days is being paid 120k for 50 weeks, 40 hours per week - $60/h (ignoring sick days and statutory holidays). From which you get $120+ /h regardless which of the two methods you use.
Better yet just stream the output to os.Stderr and os.Stdout directly ``` cmd.Stderr = os.Stderr cmd.Stdout = os.Stdout [`cmd.Run`](https://cmd.Run)`() // intstead of cmd.CombinedOutput() ```
Sorry, still not following. Reading the https://www.jaegertracing.io/docs/ I get the sense this is some kind of activity log for a distributed system. 
Yes, that's also a valid point. I mentioned it for further improvements. It's difficult to get the best balance between correctness and a minimal implementation :)
Usually in that structure you're getting the error from a previous function call. So err == nil IS the non-error case. If you flipped the logic it would look something like... value, err := aMethodCallThatMightHaveAnError() if err == nil { // do something with value since I know the previous call was successful doSomething(value) } else { // err was not nil so I should panic panic(err) } 
Came up with the language spec section for this: https://golang.org/ref/spec#Passing_arguments_to_..._parameters If f is invoked with no actual arguments for p, the value passed to p is nil. Otherwise, the value passed is a new slice of type []T with a new underlying array... ... If the final argument is assignable to a slice type []T, it may be passed unchanged as the value for a ...T parameter if the argument is followed by .... In this case no new slice is created. --- There are two possible behaviours when using one same variadic function - if specifying individual variables, when those are changed inside the function it's not reflected outside. However if a slice is passed, the changes are reflected. That's super weird and obscure. Thanks for your replies everyone.
I completely disagree. You can structure your code so all the routes are clear and readable. Additionally I would recommend NOT starting out with a framework like gorilla. Itâ€™s better to know the stdlib and where you donâ€™t like how it does things before jumping into a framework. To note, in the 4+ years Iâ€™ve been writing go services (dozens of them) Iâ€™ve yet had a need for a framework.
Yes; just pure stdlib go. 
Receivers are just syntactical sugar around function parameters. func (a *A) Foo() is equivalent to: func Foo(a *A) You're just passing pointers or copies of values around.
Value receivers: Receiver is copied. Useful to protect against accidental modifications (methods are basically "const"). As usual: The Tour of Go explains all this.
No. Panic panics. It does not do magic (here check its argument). No magic in Go. Also: Should panic([]int{}) panic? Should var f func() ; panic(f) panic? Yes of course, so why something even more magic for error?
When you remember that all you ever get are copies, it'll make some more sense. You could have a struct `type A struct{ *B }`, and if you have a method on just `func (a A)`, it'll have a copy of the pointer pointing to the same B. So, it's not like methods on types (as opposed to being on pointers) are unable to change state, they are. The other thing is, the compile is much less likely to optimize a pointer method, because it escapes. People have this misconception that using pointers is cheaper than copies, but pointers have to be followed, copies don't. If you have a method accepting a type, it'll get a copy, and *nothing else* will be changing that copy. With a pointer, something else might be changing it. This allows for some pretty decent optimizations. You should use type-methods as much as possible, unless you do need to modify the type. It's safer. You can even edit the value passed in, knowing it won't edit the calling type. Only when you actually need to edit the type should you declare a method on a pointer. Also, for the most part, calling `(*T).meth` when meth is `func (t T) meth` will automatically dereference and copy it, so it's not like it's any harder to use. Some people think pointers are required, but good libraries use copies anywhere modification is not required, with the rare exception of very-large objects where copying is prohibitively expensive. This goes for any arguments, not just receivers. 
No, using panic like this is almost always just laziness. You should handle the error. Usually it is enough to just return the error, but often it's better to add some context to the error. Imagine there are two functions both creating a temporary file and when either of these functions fail to create the file and you see "failed to create /tmp/abcd.tmp". How do you know which one caused the error? Add some context: if err != nil { return fmt.Errorf("saving configuration: %v", err) } Now you can probably find the source of the error.
While you're correct that [The Tour of Go](https://tour.golang.org/welcome/1) does talk about this. I don't think it's entirely accurate or fair to assume that those tutorials capture or are able to efficiently convey the necessary idiomatic and theoretical concepts to truly understand what that tutorial is saying. Or said another way, that tutorial is a whole lot of theory with not a whole lot of practical application. It may be good to consider how often developers are asking this \*kind\* of question and to find new ways to express the information. Not everyone learns the same way or consumes information effectively in the same way. This is something I've seen every programming language community have to come to terms with. Sometimes, most times, RTFM isn't enough because the consumer of the information may be missing critical pieces that make this format useless. Just my two cents.
The problem is that if I want to specify exactly how the bytes are laid out in my format, I have to rely on package foo to lay them out that way. If foo includes some extra field that I don't want in my format, I need to manually tweak the encoded bytes to remove it. Also, if foo's developer pushes a commit that changes the encoding, then my format breaks. You can prevent this by vendoring, but that has its own maintenance costs.
Would love to find some junior level Go programmer positions in California myself @.@
Thank you for the in depth explanation. I hadn't fully understood the ramifications of the copy mechanic functions defined on structs even though it's second nature when dealing with the arguments to function calls. 
What happens in this scenario? type Node struct { Data string Next !*Node } The first time I initialise a `Node` object, the `Next` pointer is initialised as well... which happens to be `Node` as well. If I understand your proposal correctly, this would set off an infinitely recursive instantiations, no?
You shouldn't use panic, ever.
I wouldnâ€™t say never. There are plenty of legitimate uses for panic. A better word would be â€œrarely.â€
I mean, yeah, sure. The opposite of what Node guys generally do :)
Two options: Runtime error (OOM). No real reason to hide this, as someone would have to go out of their way to cause this issue and it would crash immediately upon instantiating one. Or, have `!*T` instantiate a normal zero-value version of T, not recursively expanding the `!` fields of `T`.
By the way this is already being done. For example, allocating a type like `[2000000000][2000000000]byte`... I see no reason why it couldn't be done here, too. https://play.golang.org/p/OLU-nATzc4d
Yeah, it could be really great if WASM will be like the .NET platform intermediate code format, and you will not need to know any other language to do a frontend stuff, only the lang you like.
The Wrap and Wrapf functions in the errors package are also useful so you don't lose stack info https://godoc.org/github.com/pkg/errors#Wrap
The [go-staticcheck suite](https://github.com/dominikh/go-tools) of which errcheck is a part of, helps to detect some *library* misuse. While I agree with your sentiments, I don't think it's practical that the compiler will enforce library patterns. If, when writing your code, you would specify that you're satisfying something like `io.ReadCloser`, then yes, the compiler *could* error out, if you forgot to invoke the Close method (but Go doesn't have type hints that would let the compiler know that I'm implementing io.ReadCloser, or that I'm even using it as one if I just use the struct directly...) Unbounded goroutine creation is a valid design pattern. If for nothing else in addition to each request in a net/http server, also for benchmarks that measure the performance of goroutine spawning and the scheduler. There's just no practical way to know that you're doing something bad unless it's directly a `for { go func() }` loop. Things like race checks are part of the testing tools (`go test -race`), and goroutine stats are part of the tracing tools (`go tool trace`), and those things (generally?) I don't see in CI jobs, but only when debugging, or rarely, when there's a dev who does his due diligence ;) tl;dr: not everything is the compilers responsibility
Hope it works out. So far it's the nicest which I've seen, and I love the Route and Group helpers which Express doesn't have (I believe). It's nice to be able to group middleware for a set of API calls which you're implementing.
Hope it works out. So far it's the nicest which I've seen, and I love the Route and Group helpers which Express doesn't have (I believe). It's nice to be able to group middleware for a set of API calls which you're implementing.
Create CGO bindings for the [hivex](https://github.com/libguestfs/hivex) library. (That library can also be used to edit registry hive files) I've made such bindings before in a previous job, but I wasn't able to open-source that code. :-(
There is a huge difference between "the runtime tries to allocate ~âˆž memory from the OS which fails" and "the runtime runs into an endless loop, when trying to allocate a value". Besides, there is already a way to do what you want: Don't use pointers. If you use `struct Page { Hits int }` that already creates storage for a 0-initialized integer. No reason to artificially indirect anything here. Either way, the actual answer to this question is the same as for why Go doesn't have constructors or why you need to `make` maps and channels before use: Go tries to make the cost of declaring a variable predictable. The cost of `x := new(T)` is the cost of allocating and (potentially) zeroing a `T`. It's essentially constant. If `T` has to be recursively initialized, that cost becomes unpredictable.
I'm not sure if these things shouldn't be the compilers responsibility. Personally, I think they should be, at least the runtime and languages responsibility. Forgotten goroutines don't even belong in benchmarks. Every goroutine should have an exit strategy. I suppose technically this counts as the halting problem, so I shuffle that away into the "wishful thinking" category. However, mandatory function calls should be enforceable. I should be able to specify that a struct's Close method *must* be called before the GC of that struct. Being able to specify a few GC-specific behaviours would be very helpful for this sort of thing. It's also not that farfetched - the stdlib itself has things like `noCopy` to alert when an object is being copied... How about we embed a `canGC` field (which is just a bool), and the GC will queue up a general panic if it GC's something which has `canGC==false`? So the struct would be able to set it to true... Stuff like this is useful. I don't see any reason why we shouldn't fill the language with simple and small utility types that fill in the gaps that the runtime can't. If you want to go the tooling route, then maybe a tool could be the one running these additional checks, unfortunately it's the kind of check that needs to be run a runtime...
I am sorry, but this is plain fucking stupid. Just use a valur rather than a pointer and it will be zero. 
Well, the only legit usage I can imagine is for Must functions. Any other thing than this can be done in better, graceful way
I'm not quite sure what the point of using proper buffers is if you convert to strings repeatedly inside your functions.
Struct fields are copied when the struct is copied. Two copies of a struct would not have the same underlying struct. Want to add a mutex to your struct? Suddenly you either need a constructor, every method has to have a pointer receiver. The implementation now dictates the method signature of your type, and package. I still hold that fixing a bug in my struct implementation should not require the users of my library all to have to update. One of my structs that should be usable as a copy suddenly has to be used as a pointer, because I wanted to add a cache, or pool, or counter, or mutex, or anything that should be internal to my type...
As a general rule, yeah. But not always. Eg, big.Float will panic on NaN values. Sure, they could add extra state and make every operation return (T, error) or have an Err() error method that you have to check, sorta like sql.Rows or bufio.Scanner. I did it that way with my big decimal library. But panicking on NaN makes the big.Float API simpler and 9 times out of 10 NaN values are programmer errors. 
Is it normal to commit your Golang app's dependencies?
[removed]
Yes.
It's up to you â€” https://github.com/golang/dep/blob/master/docs/FAQ.md#should-i-commit-my-vendor-directory
It's up to you â€” [Golang/Dep on: Should I Commit my Vendor Directory?](https://github.com/golang/dep/blob/master/docs/FAQ.md#should-i-commit-my-vendor-directory)
You can avoid _nesting-hell_ doing something like this: value, err := aCallThatMightHaveAnError() if err != nil { panic(err) } doSomething(value) The logic is exactly the same, but it's more human readable. Read more here â€” http://blog.timoxley.com/post/47041269194/avoid-else-return-early
Yes, for reproducible builds.
There's tons of panic &amp; recover based error handling in the stdlib. it's faster at execution time than passing around `error` values as well
For me, part of the charm of Go's explicit error handling is just that, that it's explicit. It makes it much easier to ensure that services are handling all errors correctly. Unfortunately, this proposal loses that. So, I'm a -1. (It is clever though!)
Im glad about this thread, everybody is being friendly :D.
I got sick of creating HTML forms for Go structs so I built a package to simplify it for me. It's not very useful for APIs or anything not using server-side HTML rendering â˜¹ï¸ It probably has a few bugs as well. I mean, I use a similar version internally, but haven't ported my projects over to this particular package yet.
Very good explanation. But in the last paragraph are you telling Go has move-semantics? I know C++ and Rust does this but I am curious to know about this optimization existing in Go. 
in an environment that requires stability, absolutely. this will change soon with vgo as it allows dependency caching, meaning your IT/ops group can run the dependency server for your org and achieve reproducible builds without commiting dependencies to the actual repo
So true! Make use of early returns and avoid deep nesting. Having an else in your code is almost a codesmell. Only if you really want to continue after each branch it is appropriate to use.
My rule of thumb is that every I/O related should indeed return an error (including input validation). But for bad internal state or out of scope function input a panic fits better most of the time.
Is panic really faster as it causes stack unwielding?
I know it is idiomatic Go to 'make the zero value useful'. But sometimes it is necessary to create a constructor like in your case.
If youâ€™re still twiddling what has pointer methods and what has value methods, you arenâ€™t at 1.0.
`func (p *Page) Method { if p.hits == nil { p.hits = new(int) } }`
\[off-topic\]: Thank you for [gophercises.com](https://gophercises.com). 
That means Go doesn't have version pinning a lÃ¡ Python/Pip?
Agreed, thanks!
It's tragic when a lot of work on an obscure topic can't be shared, saving another developer's sanity for something that has virtually no chance of helping a competitor.
Yeah, instead I'm going to keep using erlang and let SASL handle detailed logging, or use a language with exceptions, instead of manually adding context on everything, thank you very much.
Go by example has a lot of bad examples and is badly in need of an update. Don't blindly trust it.
The general consensus is to follow the structure of the standard library. How that applies to applications, has been described by Ben Johnson in [Standard Package Layout](https://medium.com/@benbjohnson/standard-package-layout-7cdbc8391fc1). More helpful material on the subject: [Code Like the Go Team](https://talks.bjk.fyi/bketelsen/talks?p=gcru18-best#/) ([Video](https://www.youtube.com/watch?v=MzTcsI6tn-0)).
For me this is more common use case of strings.Builder vs string concatenation func BenchmarkConcatRepeated(b *testing.B) { for i := 0; i &lt; b.N; i++ { s := testData[0] s += ":" s += testData[1] s += ":" s += testData[2] s += ":" s += testData[3] s += ":" s += testData[4] _ = s } } func BenchmarkBuilder(b *testing.B) { for i := 0; i &lt; b.N; i++ { var b strings.Builder b.WriteString(testData[0]) b.WriteByte(':') b.WriteString(testData[1]) b.WriteByte(':') b.WriteString(testData[2]) b.WriteByte(':') b.WriteString(testData[3]) b.WriteByte(':') b.WriteString(testData[4]) s := b.String() _ = s } } 
Add an error handler for `t.Execute()` to see if something is failing there, like this [1]. I would test the code by removing all the logic responsible for sending the HTTP requests to the 3rd-party service, mocking the response and sending the POST request manually, using cURL for example. The only thing that comes to my mind right now is that your POST request is not being handled correctly, or the template is failing because `response.Outputs[0].ResData.Concepts[0].Value` is a string rather than a float64, or something along those lines. **Note:** Don't forget to return your functions during errors. You have a `fmt.Println(err)` when the template package fails to parse the HTML file, but you are letting the program continue with its execution with the execution of the template, this will surely panic because the parser failed to initialize and your program is ignoring that error. [1] https://play.golang.org/p/1qEGbwl1u7O
Try with longer strings.
https://www.ardanlabs.com/blog/2017/02/design-philosophy-on-packaging.html https://peter.bourgon.org/go-best-practices-2016/#repository-structure https://rakyll.org/style-packages/
Ah that makes more sense. Thanks for the share!
Not quite sure what you mean. ELI5 :)
run something like `if 1 == 1 { foo } else { bar }` and it will complain about both branches not being covered.
&gt; I usually hear the http library is enough to get the job done. I often hear that too, but it is an unfortunate oversimplification that completely omits the reasoning behind it. Here is the long form as I know it (details may vary): "Start writing your http/rest project from scratch using the standard library, as it most probably has all you need. If you find the standard lib does not meet your needs, feel free to pick a suitable third-party package. Just don't prematurely decide to use a third-party library without trying the standard library first, as this may bring unnecessary dependencies and/or limitations into your project."
[removed]
Who needs version pinning when you can `go get` and pray.
[My long-form answer](https://blog.merovius.de/2017/06/18/how-not-to-use-an-http-router.html) :)
Is there anyway to run these without compiling i.e. to see the output as a demo?
&gt; Suggestions on folder structure, does this looks fine? For Go? No. Go packages are not classes and not files, they package stuff that "belongs together". Your different models do not belong together (they are different models). Your services do not belong together (they are different services doing different things on different data structures). But everything about your users belong together: There are user models, user services and user repos and user controllers and user whatnots. The user services work with user models and user repos and user controllers. So these thing belong together and thus make up a package user. (I would argue that this type of grouping would be more sensible even in other languages: What is the benefit of grouping all models into a models/ folder? If you are looking for the user model it is natural to look for "user" and "model" which maps naturally to user/mode file path. Maybe Java people who are used to com.company.framework.data stuff find the reversed more naturally.) Do not think about a certain folder layout as being "clean architecture". Folder layouts are conventions (for humans or for tools), they do _not_ reflect the architecture of your application. &gt; What is preferred: IUserRepository.go vs iuserrepository.go or iuserservice.go vs IUserService.go None. Sorry. 1. The I-prefix lives in Java/C# land only. Interfaces in Go have a er-suffix (io.Reader, fmt.Stringer, etc). 2. The filenames are not per se named after a single type as often the package contains several types (see your first question). 3. Mixed case filenames are cute until your filesystem does not distinguish cases. Keep it simple, lowercase only. Take a look at how the Go stdlib names its files. &gt; Replacing mysql to mongo should be easy, from this is looks like i just need to change repository code. Well, no. MySQL and MongoDB have different performance and operational characteristics. If your application does not depend on these differentiating factors then yes: Just change the repo code. But then there is no need to change from one DB to the other. And If your app depends on certain operation characteristics e.g. of MySQL then you cannot switch to MongoDB anyway. (And please: The language is called "Go". Go. Neither go, nor golang nor Golang.)
All of this is heavily dependent on compiler optimizations. strings.Join requires a function call (may optionally be inlined by the compiler) and some extra branch instructions, and to avoid allocating extra memory it would have to iterate over testData twice, once to count the length of each string and once to actually copy them. To avoid looping twice, it could amortize the cost of allocations instead, although ofc that isn't as memory efficient and won't be faster in every case. fmt.Sprintf has to do a bunch of complicated stuff to support all the different formatting options at runtime. Go could probably optimize this further with a compiler builtin, but I don't think it could ever end up being faster than strings.Join even after some optimizations. Concatenating strings doesn't require a function call, and it requires fewer branches, and the compiler can easily generate optimal code that allocates exactly the right sized buffer for the resulting string. The compiler can also easily generate optimal code for copying everything into the resulting buffer. This is basically the case where it has a maximum amount of information available. But this only works if you set it all up statically like this. A bytes.Buffer uses amortized allocations so you could see way more allocations if you increase the amount of stuff being written. It can copy the contents of the strings directly into the buffer when you use WriteString, but it still has to make a new copy of the underlying buffer when you convert it into a string. So in other words it has to loop twice and possibly make multiple allocations. (Under the covers, it can use things like a sync.Pool to reduce this cost.) You might think that a bytes.Buffer and a strings.Builder provide almost the same optimizations, but that's actually incorrect. strings.Builder has an extra key piece of information: it only builds strings, and strings are always immutable. This means it can reuse an underlying byte buffer for any constructed strings (strings just point to a place in that buffer), which provides greater efficiency under some circumstances.
I'm in the same boat as you. At work, I've written a complete web service in go using just \`net/http\`. It did involve some extra work, but I'm happy with it so far. If you're comfortable with design patterns and architecture, the standard library does the job pretty well. But it did require some trial and errors, and I had to probably reinvent some wheels. So why not use a framework to get rid of the duplication? well, that's a call that you need to take on the basis of your needs. some reasons to stick with standard library would be: * it comes with go's backwards compatibility guarantee. even after a few years, you will be able to use the latest go versions \`net/http\` and it would work as expected. * the standard library will probably receive security updates more frequently than any library. * since it's part of the standard library, every go developer will probably have experience with it, and it will make it easier to onboard new developers. * you eliminate a dependency from your code base. there are some issues with using the standard library, which can be mitigated with good design and some extra work; You can also plug in compliant libraries for certain functionalities (for instance, you can use \`gorilla/mux\` for the router, which can be used as a drop in replacement). Another problem with using a framework is that they may be \`opinionated\`; When using the clean architecture, some frameworks may become counter productive. the stdlib on the other hand isn't very opinionated, and you can compose it in the way that you want to.
Thank you so much!
&gt; SQL is hard. Is it really though? I know a lot of people who know SQL, I don't think I've come across anyone who's tried to learn it and thought it was difficult to get the hang of. Speaking of which, this looks much more like it's relevant for a K/V store, not a SQL-based RDBMS. That aside, it still seems like given that this is an interface, you're not solving that problem of SQL being "hard", you're just providing another layer to slot into someone's application on top of another abstraction that already exists. I think it makes much more sense to make purpose-built types (and interfaces if and when you need them) to handle certain _roles_ specifically, like caching for example, or accessing a database table - those will more than likely be handled in two distinct ways. This seems to take [this](https://github.com/golang/go/wiki/CodeReviewComments#interfaces) and try to take the most extreme method of throwing it out of the window. Why would I want to pull in a library for 2 interfaces and 2 errors, when I could just define that myself _with ease_ in my own code as a single file? Even if you think about it in the context of a set of applications that want to use the same storage mechanism - you would care far more about sharing the implementation, not the interface (again, because of the above rule). 
Skip the exercises and work on a project. It doesn't have to be a serious project but it should be something you can complete (or make meaningful progress on) in the space of two days. You can bootstrap it by putting together the basic app structure so there is something that runs and can be deployed, then work together on writing the business logic. 
As others have mentioned, it depends on the length of the string being created. The implementation is here: https://golang.org/src/runtime/string.go#L15
There already is a check for this: https://play.golang.org/p/J8lQX6Ewn51 &gt; prog.go:7:6: invalid recursive type Foo
It'd be quite reasonable for Node to handle e.g. CRUD operations going straight to a database, but setting up non-customer-facing Go services to handle e.g. deferred computations that are triggered by queue jobs or other events. Sort of depends on whether your app has much more to it than CRUD operations.
There was a discussion on compilers along the lines: You have a function that produces a set of 10 fibonnaci numbers. This function is recursive. When the compiler takes a look at the code, it may "unroll" the recursion into a linear set of function calls, a better one would inline the function calls and the best compiler would just evaluate everything into an array of `1 1 2 3 5 8 13 21 34 55`. Go favors simplicity. Unfortunately that means that the compiler is most of the time in the dark in regards to how your code flow must execute. There are no destructors (which is a caveat in this sense when you're leaking resources), and, while damn impressive, it's a far cry from something like C++. This has trade offs in the feeling that you're left to your own devices, but often that's a good thing because at least you're not fighting some magical program flow which isn't explicit. It does mean that you have to track your resources better (but still, way less than what you'd have to do if you'd have to use `malloc` and `free` for all your structs explicitly). Anyhow, I find it a good trade off, which gives me more benefits than pitfalls, especially to languages that push *all these errors* into the runtime and make it hard to debug (ie, scripting languages). Moving a lot of this stuff into the compile time will just make the compile time slower, and there are practical limits there also.
It does, just like Python, with extra app
&gt; Why would I want to pull in a library for 2 interfaces and 2 errors, when I could just define that myself with ease in my own code as a single file? Thank you for bringing this up: I think you should not. That's why the store package only comes with a `doc.go` file. You should define an interface with what you need on the client side. &gt; you're just providing another layer to slot into someone's application on top of another abstraction that already exists The idea is to define a syntax, so that if you want to build the next Redis driver, if you expose those methods from your `Conn` you make life easier to the part of the coding population who doesn't need more than so for the specific software they're building. On the other hand, there are gokv/mem, gokv/postgres and gokv/redis, which are in their infancy, but whose goal is to provide compliant efficient methods to the respective targets. gokv/postgres only imports lib/pq for testing and Redis could easily be based on net.Conn. &gt; it's relevant for a K/V store, not a SQL-based RDBMS I had this intuition too, that's why I've called it gokv :P However, I am mostly working with encrypted data, and mostly on Postgres. So I happen to use SQL, but no foreign keys for example. I came up with gokv because it fit my use case; the very purpose of opensourcing it is because I want to find out if it can fit someone else's use case! Thanks a lot for asking all those smart and to-the-point questions, they help a lot for the discussion.
Maybe you can reuse some of my material here: [repo](https://github.com/mhausenblas/go4ops/), [slide deck](http://301.sh/go4ops).
First stop - the entire official tour [link](https://tour.golang.org/welcome/1) 
The [README.md](https://README.md) has bullet points with links for demos on each experiment it should run on chrome or firefox (the ones I tried) ex: [https://stdiopt.github.io/gowasm-experiments/bouncy/](https://stdiopt.github.io/gowasm-experiments/bouncy/)
`init()` functions are the usual way to do this, yes. You can have as many of those in your package as you want. Even multiple ones in the same source file.
They seem to work fine on my Pixel phone in chrome 
&gt; Not every store implementation will, nor should, implement every defined method. http://cdn-static.denofgeek.com/sites/denofgeek/files/styles/main_wide/public/2017/03/willy_wonka.jpg?itok=GVmXgnez How is one supposed to implement an interface without implementing all its methods?
&gt; However, I am mostly working with encrypted data, and mostly on Postgres. So I happen to use SQL, but no foreign keys for example. I came up with gokv because it fit my use case; the very purpose of opensourcing it is because I want to find out if it can fit someone else's use case! That's a noble goal, I'm sure someone else has the same needs as you somewhere. &gt; Thanks a lot for asking all those smart and to-the-point questions, they help a lot for the discussion. Thank you for taking the time to reply as you have. You seem to have a great attitude towards this and criticism.
Absolutely hit the nail on the head with all of the points you've listed here. I will also add another though: &gt; What is preferred: IUserRepository.go vs iuserrepository.go or iuserservice.go vs IUserService.go If you can't name your interface after the actual thing it is, i.e. in this case `UserService` and `UserRepository`, then it's _probably_ because you don't need that interface. The reason you probably don't need that interface is because you're probably defining an interface for something that has, and will only ever have 1 implementation (outside of tests). That aside, [this](https://github.com/golang/go/wiki/CodeReviewComments#interfaces) is another guideline (note, guideline, not rule) that is good to get to grips with when moving from an OO language to Go. If you define interfaces where you want to use them, you'll get interfaces that are much more focused, that are easier to implement in tests (if you need to) as mocks, etc. And it will make what your code is actually doing a little clearer. And remember; accept interfaces, return concretions.
Here's the thing: nobody should import store.Store directy. In your code you define your needs, like: type adder interface { Add(blabbla) } And then you look for a Store implementation that offers that method.
Advent of Code https://adventofcode.com/ has some nice exercises.
Neat :)
Now the question is, how long until I get get WASM in NodeJS, specifically node embedded via React Native. Go -&gt; RN would be neat, albeit less performant probably, but a nice experience potentially for easy side project mobile apps.
Thank you a lot for this!
Why tho? if you can compile directly to the platform and have some bindings in place :) there is also this: [https://github.com/golang/mobile](https://github.com/golang/mobile)
You got me here, i come from Java background so trying to acquainted myself with go's terminology and way of working. That is why wanted to know how community thinks about structuring project. Thanks for giving a different view point. One of the reason of not going to this approach is circular dependency as when i have a module user and another module account, if both needs to intract with each other, then both have each other as dependency. If i keep everything separate then that case can not happen. I agree with your approach and this can be one way to do stuff. 
So far I've not seen examples of Go -&gt; Native UI that has felt even remotely as easy and clean as React Native. I don't even like JS or React _(though, it's okay for what it is)_. But the ease to get native components is pretty good, as well as compiling their native bundles/etc. I'd of course prefer to use pure Go, but I just haven't found that yet. And of course, I want a mostly mature option. With that said, there does seem to be a good number of options for building go programs which draw directly to screen, like games and such. However I want easy native UI components, not OpenGL.
i loled :P
Happy birthday to hu^^go Sorry
[removed]
You are welcome! ðŸ˜€
http://whispering-gophers.appspot.com/ that particular repo might have bitrotted a little, people have been copying it over to github, e.g. https://github.com/campoy/whispering-gophers
Thanks, this looks interesting and very relevant. Agreed with your point of 1 actual implementation and 1 mock for test cases. Regarding guideline, api should have UserService interface and service(UserService implementation) should have UserRepository interface with same name as they uses values of the interface types. Location of interface problem is solved from this suggestion. Naming can be same for both interface and implementation. 
I agree on a small project. If you have something that runs and then a list of features that everyone can work on adding, they will learn a lot of useful skills. Exercises and algorithms can be fun and might help someone be a better student, but they probably won't help them be a better employee somewhere.
Despite the severity, it's good to see that this is probably also something that might affect no one.
It's a HTML element, `&lt;span&gt;`, of course! ^^\s 
This post has some really good suggestions - https://www.reddit.com/r/golang/comments/8v9d6j/how_to_manage_errors_effectively_in_golang/
Would be great if the top post included just some context and not only a link.
&gt; initialise some global variables/consts I would avoid doing this in general, but especially in a library. Are you sure you need them to be global? 
There are reasons against using global variables. See e.g. [A theory of modern Go](https://peter.bourgon.org/blog/2017/06/09/theory-of-modern-go.html): tl;dr: magic is bad; global state is magic â†’ no package level vars; no func init 
Have you seen https://github.com/maxbrunsfeld/counterfeiter ? I use it and have been pretty happy with it.
Itâ€™s quite important to understand that if youâ€™re using HTTP properly, a large app is simply a bunch of mutually exclusive HTTP endpoints (verb/path combinations). Which is to say, there are no special large HTTP app requirements.
Agree 100%
The best kind of versioning IMHO. One git SHA at a time. Every other versioning system is a figment of human creativity. ðŸ™‚
IIRC 12 factor specifically says thereâ€™s only ONE backend, environment variables, just as god intended it. ðŸ™‚
I started using Hugo for my blog before I even looked at Go. It didn't hit me that Hugo was written in Go until a few weeks after I started learning about/experimenting with Go. It was a "Wait...Hu...*go*...Hu*GO*!" kind of moment.
got em!
Make sure they don't do oop and understand how you have the option to embed types inside interfaces and other types. Not saying you have to but it's kinda in the standard docs. https://medium.com/@snippet22/reader-types-2ba61290a5cf 
[removed]
Hi /u/Emacs24, friendly ping, please see my previous comment. I would love to help you and make the experience better, but we need your help. Thank you.
That's not how you're supposed to use go interfaces...
Hugo is life saver! Thank you and happy birthday!!
For the lazy: &gt; Filippo Valsorda &gt; Jul 3 &gt; &gt; &gt; Hello gophers, &gt; &gt; A vulnerability was recently reported in github.com/golang/gddo (Go Doc Dot Org), the software that runs godoc.org. Note that this is a separate program from golang.org/x/tools/cmd/godoc, which is unaffected. &gt; &gt; godoc.org is patched, and this only affects you if you run your own instance of gddo. &gt; &gt; An attacker could use specially crafted &lt;go-import&gt; tags in packages being fetched by gddo to cause a directory traversal and remote code execution. &gt; &gt; The fix is available on the master branch: https://github.com/golang/gddo/commit/daffe1f90ec57f8ed69464f9094753fc6452e983 &gt; &gt; This was assigned CVE-2018-12976. &gt; &gt; Weâ€™d like to thank ztz of Tencent Security Platform for discovering and reporting this issue. &gt; &gt; Cheers, &gt; Filippo for the Go team
Well, you know what the expected output should look like. Start small and write tests to compare generated data from you mock up of what the generated data should be. You can load a file containing your hand made result and `reflect.DeepEquals(_)` to ensure the generated matched your mockup. I've done something similar comparing JSON results [here](https://github.com/LaughingCabbage/fortnite-tracker/blob/master/v1/json_test.go)
True, I should've specified
I think you're after something like a JWT with asymmetric cryptographic signatures. In other words, use a JWT library like https://github.com/dgrijalva/jwt-go. **Make sure you use either RSA or ECDSA as your algorithm type.** You will protect the *private* key that you use to *sign* the data. The other party can then take your *public* key and use that to *verify* the token has been signed by you (or at least your private key, hence the importance of keeping it safe). There are other ways to do this, but JWTs are very popular/standardized for this sort of thing with plenty of well-written libraries in all different languages to interact with them.
ah true, idk what to call this coverage then :D ... a bit better than line, but yeah full branch would be nicer
because you're starting 100k goroutines and I guess your computer doesn't have enough ram.
Interesting. Could you speculate why it appears Perkeep isn't using JWT? Ie, they're using PGP - thoughts as to why PGP might be chosen over JWT?
* `Swappers = Swappers + 1`, this is an `int`, not async safe. * You are starting too many goroutines, they are "lightweight" but not free. * I'm guessing `go func()` is just adding overhead to the already large amount of goroutines. * You should have included the error thrown by the program, it probably says exactly why this happened.
Thank you!
https://github.com/baltimore-sun-data/small-plate/blob/master/main_test.go
Go ahead and make it, first of all do it for yourself and second for others who might need it. If you find it useful for yourself, then it can be useful for others too. Never do something only because how many people will gonna use it, you can learn only by doing, be it so silly or usefulness. 
&gt; PGP/GPG scares me Perhaps this isnâ€™t the project for you. ðŸ™‚ Donâ€™t fret. Thereâ€™s a ton of â€œhow to do X with GPGâ€ on the web. Make sure a few sources agree on a strategy, take your time to educate yourself, and by the end of the project youâ€™ll no longer be afraid. ðŸ‘ðŸ»
https://godoc.org/crypto/rsa#SignPKCS1v15
This would be my favorite way for this case. Some go developers call these 'golden' file testing. I'd recommend checking google for `golden file golang` or whatever. If it's a nice setup it'll tell you your file has changed from what's expected, and you can add a flag to automatically update it so it'll pass the next test (Of course, after you double check that the change is actually expected). It's pretty great way to test templates or complex JSON/structs.
I see this is very popular, but there are tons of static site generators out there. What makes this one so special? I'm using Pelican currently and pretty happy with it, would Hugo give me anything worth switching?
One piece of feedback is that you are not checking if crypto/rand.Read fails. Another is the static work factor for the KDF. I'm having a hard time thinking about the applicability of PAKE. Is it basically a form of forward secrecy for secure channels based on a password? That two parties use PAKE to derive a secure key and then never use PAKE again?
Can you string together capabilities in one pass.. e.g. apply a blur, transcode it to a different format, change its resolution, etc.. or do you have to do each of those to the file storage thus taking more storage and more time to process?
Each goroutine gets created with 4k stack size. 4k * 100k = 400M. So you could spawn one million and they would *just* take up 4 GibB. It gets problematic however if you perform expensive computation on each and the stack-size growth.
Disclaimer: I don't know how secure you want the process to be and you should probably use PGP. You could just use a hash. Any modification to the JSON causes a completely different hash value (there are hash collision attacks but they are difficult and with a good hash function it is almost impossible). You just have to make sure the hash does not get modified (which is probably the biggest flaw here). Don't use the same connection for both and this does not give you any verification just confidentiality.
Speed.
From the configuration file example it sure looks like you can, for example the blur preset generates a thumbnail with a width with a blur. blur: quality: 80 filters: thumbnail: width: 700 blur: sigma: 5.0
If you are interested, you may want to check github.com/gokv/mem It is an inmemory Store implementation, which only exposes a subset of the store.Store interface methods.
I didn't look too closely to perkeep but it appears they are wanting to embed the signature in the JSON object as a field. JWTs include a header and signature component separate from the document. JWTs are also canonically base64 encoded. With the abundance of JWT libraries, it's trivial to extract the decoded document body of the token though. Keep in mind that PGP/GPG are just a single method/implementation of signing data. JWT is a format/spec. Both use standalone cryptographic methods for the actual verification step. You could easily use one of many signing algorithms out there (the go crypto lib should have several options). I just recommended JWT as it sounds like what you're looking for based on your post and has tons of support. 
[This](http://vincent.demeester.fr/posts/2017-04-22-golang-testing-golden-file/) article has some commented code example for the method you describe.
This is not a problem for massive parallelism: one thread per core is much better.
The problem there is I'm doing something similar to what Perkeep does, storing content addressable data. Which is secure in that it can't be modified directly, but it's insecure in that it, like Perkeep, can be "mutated" in immutable-friendly ways. In the end this means if an attacker gained access to the filesystem, they could add new entries and claim they were the authors. So partially I want this secure, but I'm also trying to learn a *bit* about cryptographically signing data. As Go has good resources for encryption, but I've not seen much on signing. Luckily while it's not documented well, Perkeep's codebase is definitely a good resource for this.
Appreciate the added information, thank you!
I am happy to have worked with u/quiI on this chapter. Please post any feedback. I would love to make the chapter better :)
Yeah, agree. Will do a small project as well.
interesting, the .wasm files aren't as big as I expected
That's mandatory prep :D
Thanks, will definitely use them!
No. If youâ€™re happy with your current static site generator stick with it. Migrating wouldnâ€™t be worth it. I use Jekyll, Middleman and Hugo for different sites and they may as well be the same tool. If I was starting fresh would probably use Hugo though
Upon the very first: &gt; # Write enough code to make it pass Shouldn't that actually be: func Search(dictionary map[string]string, word string) string { return "this is just a test" } I get that the chapter is long enough as it is, and that's a fairly obvious step to not do in real life, since the implementation is arguably as simple or simpler. But Everything TDD I've read stresses the importance of still doing the "stupid case".
Yeah this is going to be terrible in regards to code review. The change set is NOW at +5,298 âˆ’31. I they don't break it down in the sizable chunks it will take a lot of time and effort for people who might not have it. I agree with everyone writing before me here. This could / should have been handled in a very different way and the frustration of that can be heard out of what the commenters were saying in that issue.
\+1 on this. Personally I just create a boilerplate project. Shameless selfplug: [https://gitlab.com/junland/sled](https://gitlab.com/junland/sled) Still a lot to work on this project, but it's a great way to learn Go and you basically have the same code base for all of your future projects. It's a good middle ground. Also it's super sustainable if your doing it for open source projects. But def try do stdlib first and then do 3rd party libs / frameworks. 
The section right before that has the minimum test case you are referring to. [https://quii.gitbook.io/learn-go-with-tests/go-fundamentals/maps#write-the-minimal-amount-of-code-for-the-test-to-run-and-check-the-output](https://quii.gitbook.io/learn-go-with-tests/go-fundamentals/maps#write-the-minimal-amount-of-code-for-the-test-to-run-and-check-the-output)
Yes, you can and it will create a single image on storage in a single pass. 
Yes of course ! An other things that i miss in Go is a RML (Reportlab) compatible library like https://pypi.org/project/z3c.rml/
/u/pzl is referring to TDD saying "only make the test pass". Technically, returning the string, verbatim, is the simplest way to make the test pass. However, a second test would put a couple strings in, and check that each string returns the expected value. That test would then fail, and wouldn't pass until you did the proper thing.
Ah, I see what you mean. Thanks for the clarification.
https://quii.gitbook.io/learn-go-with-tests/go-fundamentals/maps#using-a-type-alias That's not a type alias, it's a type declaration. Type alias is of the form `type A = B`.
Finally decided to change code structure in below way: - Keeping model in model package for general structs. They needs to be accessed by api, services as well as storage packages, so better to keep them separate. - Moving repository interfaces in services as services need to call repository, keeping service interface in api, as api calls (having main http handler with validation and response creation) service package. We can merge api and service but keeping them separate for now, will think more here. - Keeping data transfer objects which return to end user in api (sometimes they can models too), as api will return them in the end. model structs might not be one which go to end user. Do let me know if this looks better than before.
The main advantages of Hugo are the speed and having a single binary, i.e. an interpreter and dependencies don't have to be installed. Interpreted languages like Ruby / Python have the flexibility to pull in new dependencies when needed but aren't self-contained like a single binary. However, as you can read in the blog post, with each version we try to cover the most important requirements like image manipulation, SASS compilation etc. to provide a fast and self-contained framework to build static websites that isn't dependent on package managers. Not all niche features can be supported. npm and other package managers can still be used *if needed.* If you're lucky with your current stack there's no need to switch you don't gain any major improvements. Choose a static site generator by it's pros and cons.
The main advantages of Hugo are the speed and having a single binary, i.e. an interpreter and dependencies don't have to be installed. Interpreted languages like Ruby / Python have the flexibility to pull in new dependencies when needed but aren't self-contained like a single binary. However, as you can read in the blog post, with each version we try to cover the most important requirements like image manipulation, SASS compilation etc. to provide a fast and self-contained framework to build static websites that isn't dependent on package managers. Not all niche features can be supported. npm and other package managers can still be used *if needed.* If you're lucky with your current stack there's no need to switch you don't gain any major improvements. Choose a static site generator by it's pros and cons.
https://yourbasic.org/golang/type-alias/ Yep, you seem to be right. There is a difference
[removed]
I am honestly jealous that you can get a job where you can work with Go primarily, even if it's just an intern position. Put jealousy aside, I suggest checking out Mat Ryer and Dave Cheney's blog posts. They had a lot of interesting things. Go excels in concurrency and gRPC (go routine, channels, gRPC, etc). There are a lot of things to learn in that field. Otherwise, there are a lot of small things that you can learn as well, such as authentication/authorization, integration, web assembly (coming), etc. If you still want more challenging stuff, work on a personal project. That's the way that I learn Go and I have been enjoying it so far.
Ran fine for me, even at 1m.
This was downvoted when I got here, but this is an important distinction
Thank you for your response I feel incredibly lucky to have this opportunity. Iâ€™ll have to check out those blog posts! Iâ€™ll also start looking into some of those smaller things you mentioned. 
Looks promising that this is easy to support on any static site, hopefully there will be tooling around making static repositories that don't require running a custom web service to host packages.
Thanks for the `.golden` file suggestion. Seems pretty useful in this case.
thank you for the link to the worker pool examples -- that helped me make this much more simple and complete.
that's true even after refactoring and making this as simple as i can it still takes longer more workers tossed at it, but it was a way for me to try and learn abit more about goroutines etc.
Which Cambridge?
Go in action is also a great book imo!
https://github.com/monkeyworknet/go-montyhall &lt;-- newly refactored
thanks. Cambridge, Massachusetts
What's helped me the most with any language is tackling a project outside of my comfort zone, to put it bluntly I write something I'm not really qualified to write. 
How many years of experience should a candidate have? I'm looking for a remote job in Go but I don't wanna waste anyone time lol
Understood. Ideally at least 3 years of experience with low latency, high throughput, data processing at scale using Go.
Got it, thanks!
If Iâ€™m proxying for Github, would the full URL be arschles.com/github.com/my/module/@v/list?
read more go, write more go. One thing that helps is that go is mostly written in go. This means that you can read the go source for examples on how to structure things. 
Man I wish Digital Ocean had an SF office..
Bugger. Cambridge UK reporting in, currently video streaming in Go.
US-only remote?
I would start by reading about Linux namespaces. Here are a few articles that can help you to start: https://medium.com/@teddyking/namespaces-in-go-network-fdcf63e76100 https://www.infoq.com/articles/build-a-container-golang https://www.linxlabs.com/namespaces-and-go-part-1-user-namespace/ 
Iâ€™ve updated the docs, and the wiki. I also like to snicker at my own readmeâ€™s. What do you need help with?
I'll double-check with our recruiting team tomorrow. In the past we've hired international folks.
[https://gophercises.com/](https://gophercises.com/) by /u/johncalhoun 20 non-trivial exercises (approx 30h long content), totally for free. You will find there a lot of idiomatic Go and much, much more.
Thank you! I think one of the P2P business ideas I have Iâ€™ll write the micro service in go at least. Golang doesnâ€™t seem like the best language for building out a desktop application. Probably going to use Python or Rust for that.
Thank you Iâ€™ll check it out!
I didnâ€™t know that, thank you!
Nice resource thank you!
You are streaming in the wrong Cambridge.
Same. Trying to write things I'm completely unqualified to write in Go is incredibly effective both for learning the language, and for using up all my free time.
Not sure if you're the minority or not, but I've heard that opinion before for sure! I see the proxy as kinda a middle ground - you could still fork if you want to and get code directly from github (but you're still on the hook for issues that arise when you treat github as a CDN) but you can also maintain your own proxy and pull things from github into your proxy's datastore - whether they are your forked things or someone else's. All that code stays immutable until you touch it, so you still have the absolute ability to curate (I'm summarizing what you said about cherry picking, etc... with this word) as you see fit, but your packages are separated from your code and packages are delivered via a dedicated server. If you have thoughts, by all means shoot them my way. I love hearing this perspective
Thanks! I will make the correction.
Are more methods going to be added such as getting attributes for a user, DN of a user etc
So, this is built using the more extensive LDAP library available for Go. My goal for this is to weed all the advanced features out and just let you get down to the basic functionality you need out of ldap. First, authentication. I think it would be good, and I already have some code that could be used to simply find a user and get their info. But, I want to keep it minimal, so Iâ€™ll probably just do a get user function. I want to keep it easy to get working when you have a fairly straight forward setup and donâ€™t need to bother with tweaking settings or do any modifications to the ldap server. A get user function would require a slice of strings with the ldap user attributes you want to retrieve, so Iâ€™ll probably have a type for that and let you pass that in with a username (or any field that can filter out a unique entry) 
You probably want to post in a Linux subreddit, as there won't be much Go specific information. Specifically look into SELinux and capabilities.
Thanks - good point. What is a way to go about a dynamic work factor? It doesn't matter if the weak password is later figured out. The weak password is used to seed an interaction between the two parties that guarantees they will each establish the same strong key, independently, through their interaction. They could use that strong key indefinitely. No one else can determine the strong key because it is generated through the interaction, so even if you knew the weak password you could not obtain it because you did not partake in its creation. There's a more detailed explaination in \[this crypto book in the PAKE section\]([https://crypto.stanford.edu/&amp;#37;7Edabo/cryptobook/BonehShoup\_0\_4.pdf](https://crypto.stanford.edu/%7Edabo/cryptobook/BonehShoup_0_4.pdf)).
Awesome, I'm working on a side project where I was too lazy to build the LDAP plumbing by myself, this would be perfect!
Awesome, I'm working on a side project where I was too lazy to build the LDAP plumbing by myself, this would be perfect!
Unfortunately not yet. Heroku (Salesforce) hires Go engineers if you would rather work out of an office. 
I may look that way. Ive been doing c for far too long and need to swap it up. Thanks and good luck!
How does this fit next to http://gorm.io? 
Too far to travel to the other Cambridge, I'll stream from here.
OP meant data stream processing.
I think he meant video data stream processing 
&gt; customer-facing monitoring team 
Work on side-projects, where you know it will be a challenge. For example, and a friend and I are working on a new GraphQL server implementation for Go. We've finished the query parser, but still have quite a few steps to go, but it's presented a huge opportunity to learn a lot about Go. One thing we focused on with the lexer for example was performance, we wanted to see if we could make our lexer the fastest - and we have, we've not tested a faster Go lexer, and we've come up against I think 4 or 5 others now. We're hoping to continue that the whole way through and end up with a 2018-spec compliant server implementation that's blazing fast (i.e. faster than the Node.js reference implementation, unlike the other Go ones).
Thatâ€™s so damn cool. Maybe I should look into doing some ports as well or contributing to a ongoing project. That could be a great learning experience. 
what's the way to do it then, if I need to store pages numbers for 3 books (as an example) and make it available in different functions of the package?
Have you seen [https://github.com/yudai/gotty](https://github.com/yudai/gotty)? Is yours different from doing `gotty -w bash`?
I think it's different in the sense that it's for interacting with HTTP APIs out there that already exist. So for example if you create a GitHub access token, you can add that to your config (or environment) and then configure httpu to hit any endpoint, and then store results in memory to be used with other resources. Gotty looks really cool though! I'd not heard of it until just now, so thanks for linking me!
&gt;So for example if you create a GitHub access token, you can add that to your config (or environment) and then configu Sorry my mistake, just watched the gif and that explains it all :) So it's more like [Postman](https://chrome.google.com/webstore/detail/postman/fhbjgbiflinjbdggehcddcbncdddomop?hl=en), gotcha!
Exactly! :D I should maybe do a better job of explaining it on the README haha
Neat, thanks! 
Happy cake day. 
Thank you, sir!
Config is something I've thought a fair bit about since I started working where I do now. We still have issues with config every now and again. Fundamentally the reason for our troubles has come down to one thing; that we were loading configuration from several sources. We'd have a file with defaults for local development say, and then merge configuration from Consul's key/value store on top of it. If Consul went down, and an app restarted or was deployed, etc. - then it would still start, but with the wrong configuration. The most recent application's we've built have been designed to only explicitly load configuration from _one_ source, and if that process fails for some reason, the app won't start - and that's something we'll know about. It can be difficult to see what's going on specifically in running applications, e.g. which database host are you pointing at, so if that configuration is wrong, but appears "valid", it can be really tricky to tell if you've loaded the right configuration otherwise. &gt; Dynamic Config This is another thing we've thought a fair bit about, but we have always found that there are simply too many gotchas to bother with this. The most simple solution I can think of without resorting to polluting code with weird dynamic-config handling stuff is just restarting apps when config is changed - which is pretty easy to accomplish too. One issue we have seen with this is how do you handle things like database connections, where you'll likely keep the same connection around for a while? You'd have to add code to react to that, so surely it's not just as simple as using a config library that handles that watching aspect? Your code has to be able to handle those changes in configuration still too, right? &gt; The way in which config is managed and consumed needs to evolve. I'm interested in what prompted this line - what made you feel that the way configuration is managed and consumed needs to evolve? What about configuration management would you change? And what else would you try to change with regards to consuming configuration?
Can I import postman collections?
This is now modified in the chapter. I removed the section about type aliases. Turn out you can't define methods on a type alias of a map.
Yea Iâ€™m sure there will be flexibility to work the way you want. Thatâ€™s why Iâ€™m curious to see how this all works. Though I wonder at what point I wonâ€™t have a choice. I canâ€™t fork all dependencies of course. I mean it is what it is. But where are the hang ups going to be? Remember the leftpad issue with npm? I wonder if anything has gone into the design here to prevent issues like that.
If you're at a company that is doing Golang, I think you're in a really good place to ask for permission to learn to take on more than you are at the moment. Dig into the code and look at if they're using goroutines. Look at their coding standards and see how they are using interfaces or tests. If possible, play with some of the code locally. At some point you should be able to talk to your boss and show them that you've been self motivated to learn more than just what they're assigning you, and that's potentially a great step towards getting a job or a good reference.
thanks, you too!
I'm a bit wierded out by the functions that are called "Must..." that return errors. I thought it was established by convention that (see regex and some other standard library functions) that a Must function panics on error?
https://tour.golang.org is quite cool!
Nice, now build a tool to read TypeScript definition files to generate Go structs :-) Seriously though, people should be aware that crossing the JS-WASM divide has consequences so if you're already writing a Go+WASM project, ideally you would find pure Go deps instead of JS deps unless you have to integrate w/ the JS world a lot w/ the lib anyways (e.g. the DOM).
[removed]
&gt; customer face-monitoring team
The problem is that you're using :=, which creates a new variable with the same name. Use = and it will work. 
var temp is being declared again in the inner loop because youâ€™re using â€˜:=â€˜ instead of â€˜=â€˜ 
In go, \`:=\` and \`=\` are very distinct. \`:=\` declares and initializes a \_new\_ variable. So in the 29 line, you're telling Go you are creating a new temp variable and initializing it to whatever ParseFloat returns. \`=\` just assigns a new value to an already existing variable. Try changing the \`:=\` in line 29 to a \`=\` and it will work as expected. Now, try deleting line 22, where you declared the variable, and see which error you get. This should make things a little bit clearer :) 
Thank you very much =) Such a silly error \^\^ Now it's more clear! ðŸ˜Š
I just usually share this but some links are outdated. And some examples are considered now not good practice but I still collect stuff. Copy it, add to it, make it your own. https://docs.google.com/document/d/1Zb9GCWPKeEJ4Dyn2TkT-O3wJ8AFc-IMxZzTugNCjr-8/edit?usp=drivesdk 
Thank you! Will look through it carefully :)
Not yet, but that is something I've been thinking about :)
I read two books that I can both recommend: * [The Go Programming Language](https://www.gopl.io/) by Alan A. A. Donovan and Brian Kernighan, which gives you some nice background and answers many "Whys", but also has examples * [Go in Action](https://www.manning.com/books/go-in-action) by William Kennedy with Brian Ketelsen and Erik St. Martin, which is also awesome, more hands-on focused with tons of great examples Other valuables resources: * [https://github.com/campoy/go-tooling-workshop](https://github.com/campoy/go-tooling-workshop) * [https://github.com/avelino/awesome-go](https://github.com/avelino/awesome-go)
Thanks! I do like the in Action series, read some great books in other technologies before, will research a bit about it.
Just curious, why is it not enough to just bind username &amp; password for authentication? Is search necessary afterwards?
I'm learning Go as well, but it's like my tenth language (I won't say I'm that proficient in half of the languages, but let's just say I've seen some programming before). I've been doing Stephen Grider's Go course in Udemy. https://www.udemy.com/go-the-complete-developers-guide/learn/v4/ However, while it's not paced that quickly, it would probably help to have learned another language prior to Go. I think, these days, a lot material for new programming languages are not aimed at beginners (because it take so much work to teach beginners). 
That would be a great feature
That would be a great feature
I believe Go Programming Blueprints by Mat Ryer would fit your needs pretty well, given your experience.
&gt;Right now, thereâ€™s no thread support for WASM expect in Safari. [citation and spellcheck needed]
happy cak d
This seems to catch many people off. It's been shown before with the "go in a for loop" scenario... for _, v := range vs { go func() { fmt.Println(v) } } Printing, maybe, only the last v, or a random collection of v's. :D
This looks neat! I think the UI could use a little work. Maybe take a look at [wuzz](https://github.com/asciimoo/wuzz), which aims at being a slightly better `curl` vs targeting APIs.
What you need is a sandbox not a container. I would recommend you try firejail (https://firejail.wordpress.com/), which uses all of these techniques to create a real sandbox. My recommendation if you want to create your own sandbox is to look into: * Linux namespaces (https://lwn.net/Articles/531114/#series_index) * cgroups (https://www.kernel.org/doc/Documentation/cgroup-v2.txt) * seccomp-bpf (https://www.kernel.org/doc/html/latest/userspace-api/seccomp_filter.html) There is a lot more you can do, but these APIs should set you in the right path. IMHO, I recommend you just use firejail. It works and it is really easy to use. It can be subverted though, it is definitely not infallible. 
Something like this should be a part of every language's stdlib
Firstly, welcome to programming and Go! Programming is a lot of fun and Go can make this process more joyful, and I wish you will get to that stage someday! However, given the fact that you just started learn programming, I would not recommend Go as the first language to learn. Here are my reasons. For beginners, it's important to have a *very solid foundation* of basic computer science (CS) concepts, whether or not your want to have a CS career: type, function/method, class, object, interface, inheritance, common algorithms and data structures. Go is not the ideal language that can teach you all these basic concepts. Java and C# has a lot of good resources that can teach you all these basic concepts, and those resources targets at readers from the beginner to the advanced. The amount of resources that you can find for Java and C# is many times than what you can find for Go. Based on my experience, Go works great for experienced developers, especially those who have had substantial experience with C/C++, operating systems, and real-world software development experience. Go makes a lot of thing easier for those developers and has a lot of tricks that make those experienced developers lives easier. However, the benefit that Go can bring to an experienced developer may not be that obvious to newcomers. This may plant wrong perception of Go in your mind. This is just my two cents. Go is a great language, but I personally don't believe it's designed for beginners. I am not saying that you should not learn Go. I am saying that Go might not be the optimal learning tool for you at present.
There's a lot of data that streams in addition to the video.
I'm biased against Java as a first language, so I apologize that I strongly disagree, by offering different advice. Go is an okay first language as long as the student is understanding of the fact that go is opinionated in different ways than other languages. My opinion against Java is: Having a first time student learn Java first is like telling a first time writer to write a dictionary. Needlessly complex and verbose for the sake of verbosity and complexity. But as a whole I think Java is a waste of time and I realize I'm in the minority with my disdain for the language. Personally I think that if you want to teach basic programming you have the spectrum: Very syntactically forgiving: python, but teaches meh habits due to dynamic typing and other "pythonic" practices. Middle ground: go, static typing with some modern twists, great compiled language, but opinionated in ways different than many others. Close to the metal, trial by fire languages, c/c++. Incredibly rewarding but difficult to learn first language. Teaches good habits in thinking of memory as a resource, but not forgiving. I will never understand why Java is recommended so I'm biased.
I looked at some samples of the book and really liked the idea, it's all practice! Thanks for this recommendation! I'll definitely check this out! :)
I love "the little go book" free pdf. 
I think you missed the point of OP and my response to OP. OP (assuming him) mentioned that he is a beginner and did not find many beginner resources for Go, and that's what he was asking for: resources of Go for beginners. The fact is, the amount of resources for Go beginners is a fraction of the resources that are available for Java/C# beginners. So, instead of leaving OP in dismay, I suggested him trying Java/C# first and *build a solid CS foundation*, and come back for Go later. It might be a detour, but I believe there are substantial benefits to this approach. I think you have a valid point for Java. When I first learned Java as a CS undergrad, I thought it was amazing and I absolutely loved it. Overtime, I found Java ridiculously verbose and painful to *work* with, but mostly for technical reasons. I personally don't like *working* with Java every day, but it does not prevent Java from being a good teaching tool. I worked as a teaching assistant at the CS department when I was in grad school. I have worked with classes that taught Python, Java, C#, C++, and C. Python, Java, and C# were used to teach CS 101 (intro to programming), and C++/C was used to teach CS 102 and 103 (data structure and machine organization). Students who graduated from the Python course had *a lot* to catch up when they entered CS 102. It was not just program syntax that they were struggling with, but the basic programming concepts, like type, variable declaration/assignment, string concatenation, etc. Students who graduated from the Java/C# courses had lesser problem with the syntax and basics of programming, and they were able to focus on the course material more than the Python students. It was just my observation and nothing experimental. In my opinion, Java/C# has a lot of CS and programming concepts built in that allows anyone who masters these two languages capable of mastering other languages in a shorter time. From a teaching perspective, a strong foundation in Java/C# opens doors to other technical skills. I acknowledge that there are exceptions to this where people who mastered Lisp or Python first can also master other languages easily. However, the large amount of Java/C# resource that are available to people from beginners to the advanced is what makes them great for teaching.
Thanks for sharing this article. I have a few suggested corrections: 1. At the end, in the "THATâ€™S A WRAP" section, the link in "You can find the code for the application in my [Github repo](https://github.com/Sebastian/go-wasm)." is 404. I think it's missing an M at the end of your username. 2. About the two paragraphs starting with "Another reason is the lack of tree shaking features in Go." and "In the Go ecosystem, tree shaking isnâ€™t a really topic because application size isnâ€™t that important on the server side." I don't believe that's accurate. Tree shaking is another term for dead-code elimination (DCE) and the Go compiler has some very sophisticated support for doing that, even when the reflect package is used (it makes it harder, because you have to be sure eliminated symbols won't be accessed via reflection). You can read the https://blog.golang.org/go1.7-binary-size blog post about the DCE improvements that have gone in during the Go 1.7 cycle. There's also the https://golang.org/issue/6853 issue which tracks the topic of binary sizes and the progress to make them smaller. The two paragraphs you wrote make it sound like "Go has no dead-code elimination and it doesn't care about binary sizes", which I don't believe is true. It is true however that this field is important for JS and a lot of work has been done there, and there is still room for improvement in Go. But it's not right to dismiss everything that has been done so far. For reference, the DCE in the Go compiler is more advanced than in the GopherJS compiler, which also cares about output size.
Here's another way to solve the problem without having to create any interface, thus avoiding any premature over-architecture of your code, making it easier to write, refactor, optimize, and, above all, read. https://play.golang.org/p/mOZq-53JwzG The general rule is: avoid creating needless interfaces. Interfaces are good to abstract common functionality across many types. If your code only has a single type performing that action then creating an interface for it is just premature abstraction for the code. This will also make your testing a lot more complex and likely harder since now you need to write test for the type implementing the interface and tests for the type using the interface instead of a test to do an end to end run. Of course, you can always supplement the end to end run with additional, specialized, test cases when special corner cases need to be tested, but that's a different problem, and can still be achieved with the above code.
I thought you said we were having streamed clams
This is an interesting approach to the problem. But I think if you have an existing database that's sizable it could be tough to begin using since you have to port your db schema to go structs. Also the maintenance of redoing all schema changes in that set of structs manually taking care to make sure changes are reflected seems burdensome and seems prone to error. Definitely a fresh take on things though, really like the thorough relationship support. I wonder can it do multiple level eager loading? Not sure how that would look given the examples. Nice work.
I'm assuming you want to sign with a private key and verifying with a public key. It also seems that you don't want to add another layer of encryption to your message. If so you can use something like ed25519 to just do a signature of the data. In this scenario the receiver has ONLY the public key. The sender signs their message with their private key. package main import ( "bytes" "crypto/rand" "encoding/base64" "fmt" "io/ioutil" "net/http" "golang.org/x/crypto/ed25519" ) const JSON = `{"my":"json object"}` func main() { pub, priv, _ := ed25519.GenerateKey(rand.Reader) fmt.Println("PUBLIC: ", base64.StdEncoding.EncodeToString(pub)) fmt.Println("PRIVATE: ", base64.StdEncoding.EncodeToString(priv)) // SIGNATURE sig := ed25519.Sign(priv, []byte(JSON)) fmt.Println("SIGNATURE: ", base64.StdEncoding.EncodeToString(sig)) // VERIFY fmt.Println("Is Valid:", ed25519.Verify(pub, []byte(JSON), sig)) fmt.Println("IsValid:", ed25519.Verify(pub, []byte(JSON+"SOME other data"), sig)) // HTTP Flow - sending message reader := bytes.NewReader([]byte(JSON)) request, _ := http.NewRequest("POST", "where.com/message", reader) request.Header.Add("signature", base64.StdEncoding.EncodeToString(sig)) // HTTP Flow - receiving message body, _ := ioutil.ReadAll(request.Body) header := request.Header.Get("signature") signature, _ := base64.StdEncoding.DecodeString(header) ed25519.Verify(pub, body, signature) fmt.Println("Request valid", ed25519.Verify(pub, body, signature)) }
This is cool! How much of your exampleâ€™s flexibility comes from the fact that go core created an interface around RoundTripper that decouples your application from the default clients implementation? Is the difference that they were planning for extension?
Looking at the Go implementation, https://i.imgur.com/d1gJWIY.png , they have at least 5 different implementations for this functionality in the standard library, not counting the 8 others in the tests files. Furthermore, we can rewrite that example to use a function type instead, https://play.golang.org/p/Zh0ykSGhNiu, and it won't even matter that we are sending a custom http client or not, as we can control the function that gets injected in "analyze()" during the test so we can suppy a mock function there.
And to answer the "planning" for extension. To whom are you referring to? Stdlib or the blog post author? If the later, then again, I don't see the value of plannning for something that may not happen. The standard library already had the need for this, allow users to insert their own transports, so that's why we have it there. I'm arguing to make no abstractions until an abstraction makes sense. If I'm abstracting what is used/implemented in a single point, then is there really a need for that abstraction? What does it abstract?
I checked with our HR team and the engineering manager. We can hire remote folks from Germany and the Netherlands, in addition to the US.
And to answer the "planning" for extension. To whom are you referring to? Stdlib or the blog post author? If the later, then again, I don't see the value of plannning for something that may not happen. The standard library already had the need for this, allow users to insert their own transports, so that's why we have it there. I'm arguing to make no abstractions until an abstraction makes sense. If I'm abstracting what is used/implemented in a single point, then is there really a need for that abstraction? What does it abstract?
I hope they didn't do .net coding patterns and multicasting delegates and stuff. Cause drilling down to the language spec to have a better mental model is well not good. I just really hope you didn't make them memorize something so high level with not giving an easy way for them to create their own. 
thank you! I'll refer this to some .NL friends!
in the same bot as you :), was going to learn js/python first but am now inclined towards go
Todd Mcleod on Udemy. He has a great introductory course and another one for web apps in Golang. He is the man!
.NET was not even mentioned during the entire course. We used C# purely as a "better Java", and C# the language itself and programming technique was the only thing we focused on. 
So, basically the client has a username and password for the initial bind that grants it read access to the ldap server. Then, you can look for the username that wants to log in and try binding with their password. 
I mean if the read access is granted, we can assume that the user is authenticated can't we? I am asking since I have a smilar service in Go and wondering whether I am doing it wrong :)
**Step 1:** [Get Programming with Go](https://www.manning.com/books/get-programming-with-go) - Not for a complete beginner, but it can get you going with just [The Go Playground](https://play.golang.org/) if you're dedicated **Step 2:** [Appendix A: A Command Line Crash Course](https://learnrubythehardway.org/book/appendixa.html) - Kind of a prereq to using Go from your computer **Step 3:** [Introducing Go](https://www.amazon.com/dp/1491941952) - You'll review most of what you've learned from **Get Programming with Go** but this time from your computer **Step 4:** [Exercises for Programmers](https://pragprog.com/book/bhwb/exercises-for-programmers) - Practice Go programming. I recommend working through the first 8 chapters. **Step 5:** You should be good to go to learn more about Go and programming
[removed]
Lots of people offering great links to other similar tools to learn from. I find this feels a lot like a CLI version of Insomnia, which is a really nice GUI client.
Todd has I believe updated versions of these Udemy courses at https://greatercommons.com/ Higher price, but I'm currently going through it. It starts out with the *super basics* of programming. I mean that it is designed as an intro to programming course that happens to use Go. It'll go over variables, flow control, and so on. He even claims that his courses range from beginner to intermediate, while shouting out Bill Kennedy for intermediate to advanced. 
Yeah, I mean if you have the DN for the entry you want to authenticate, you can directly bind for authentication. But, typically, people will have something like their username or uid if some sort and their password. The client has a dn and password for an initial bind and then may search for the userâ€™s entry. The client takes, as the filter field, the LDAP attribute which your organization uses for its account uid. If your setup has everything it needs by just binding directly. this is more than you need. You arenâ€™t doing anything wrong. 
Ldap is a real hassle 
Update: I had a trailing comma in my Postman json and can never get back the last 4 hours of my life. I love every second of this
Now that others here have made you aware of how you're shadowing the outer variable, you may want to look into the `go vet` command, that can tell you where shadowing occurs in your code.
I think, in this case, the only benefit you've gained is that instead of writing your own interface, you're using one that the Go stdlib provided. Its not a fundamentally different architecture or idea. Which, I mean, to be fair: That's a great thing. Always reuse if you can. But you can't always reuse.
There are debuggers for go but a quick way to see what's going on is to log the incoming request, or errors, or whatever else you want to know to the terminal the server is running in: https://golang.org/pkg/log/
It seems that your \`func main\` is exiting (therefore terminating your program) before each \`goroutine\` is finished converting ins to outs. If output order doesn't matter, you could use a \`channel\` that each \`goroutine\` writes the output to, which will block \`func main\` from exiting. Then place each value in a new 2d map.
"a" is a slice. This works: result = fmt.Sprintf(format, a\[0\])
If order does matter, a simple mutex or [wait group](https://golang.org/src/sync/waitgroup.go) would work as well. A simple mutex you can use with little added code would be a [semaphor.](http://www.golangpatterns.info/concurrency/semaphores)
And if you don't need output at all, you can use `sync.WaitGroup` to explicitly wait for those goroutines to complete.
Over-engineering and making things more complicated than they should be is NOT the go way, while there are legit reasons to do that, always use it as the last approach.
I wrote a [tool](https://github.com/OneOfOne/struct2ts) that generates TS classes from Go structs, does that count?
Why not Hugo?
not enough in here to be sure. this schedules 12 co-routines. if there is only one process, and none of them ever yield (ie: read or write a channel, via IO calls or direct channels, sleep, etc) then they might not be scheduled. the program might exit in between them being scheduled and running. Google on how to use sync.WaitGroup. You probably want to Add a Wait on (i \* j) Done calls; and not go past that point until they all run. treat goroutines as if they are NOT preempted and you are on a completely single-threaded machine. if you schedule a routine, then the thread you are in has to go to sleep waiting on something (usually reading out of a channel) before you can really expect another one to be scheduled. ie: (x := &lt;-answer) goes to sleep waiting for another thread to do (answer &lt;- a) concurrently. if len(answer)==0, then that second one will go to sleep until the first reads it.
An alternative viewpoint: â€œPreemptive Interface Anti-Pattern in Goâ€ https://medium.com/@cep21/preemptive-interface-anti-pattern-in-go-54c18ac0668a
This is just dropping your own mock into an interface the stdlib provides. Itâ€™s the same thing. I use the library gomock along with interfaces. Makes setting them up very easy. 
What does the OPs example accomplish? If you ever need to change the implementation of http, you can change it in one place. But how hard is `s/http/newCoolerHttp/` exactly? The downsides on the other hand, are huge. Function calls become way too long and the code becomes much less readable. And chances are, you wrote your code to depend on that exact implementation of http, so if you ever change it, you'll need to rewrite the whole thing anyway. The only benefit I can see (and the only reason I ever use this pattern) is for testing.
How about Canada?
I have figured it out. While writing to an index, you are using `-http` flag. If you do that, it generates the corpus in a separate goroutine and hence your index file is incomplete. That is why it exits immediately. Use this - `$ godoc -index_files=/tmp/goindex.db -write_index -v` And then run - `godoc -http=127.0.0.1:8008 -index -index_files=/tmp/goindex.db -v`
Oh thank you very much for the hint indeed! I should also learn how to do some debugging with vscode actually ^^
Hey thanks for this. I ended up using a waitgroup and putting a wg.Done() inside the goroutine and a wg.Wait() after the loops. Pretty much exactly like you said. Go is pretty fun but sometimes it is tough to wrap my head around. This behavior kind of reminds me how with CUDA cpu operations will continue while a kernel is being executed on GPU.
main() wasn't actually exiting because I had a for loop making the call to the function that this was living in but the behavior was similar in that it was looping around again and again and sometimes finishing the matrix output and sometimes not. I ended up getting it to behave with a waitgroup but I will try rewriting with channels because I know they are important also.
You can simplify the way you think about this by just knowing that any functions executed with "go" keyword are going to run async (like threads) and it is up to you to introduce a way to synchronise them (waitgroup, channel, mutex, atomics) 
Yeah totally. It reminds me of MPI_Gather in MPI code (kind of...).
There is basically no chance that once you get this working it will be faster than the non-parallel version. 
Well it definitely is much faster when implemented in openMP. What I am doing is a little toy project as a sort of "hello world" that I like to do when learning a new language which is conway's game of life and if the language supports some sort of parallelism then I break out the calculations for each individual cell in a matrix in a parallel loop. I don't know enough of what is going on under the hood with golang yet certainly though to know if this is an implementation that will see any observed speed up in a concurrency model.
Hey thanks Iâ€™ll definitely check it out
You really can't. This is considered bad behavior in the SMTP world and the problem is already solved by having email bounce and the user taking the corrective action.
Hey thanks for the reply. So how can I achieve this. Any library/package for this?
No one has mentioned https://gophercises.com or any of Jon Calhounâ€™s other work. Iâ€™m currently enjoying it. Iâ€™m only ~1/3 through. Iâ€™ll be sure to check out the other supplies linked in this thread though! 
Depends on what is happening inside the goroutine. If itâ€™s making an external api call, database lookup or anything that takes awhile then using concurrency certainly will speed it up. 
Then the function was exiting before the goroutines finished. Don't use channels where they are not necessary, a wait group will likely be more performant. One thing you'll want to account for is unbounded parallelism. If you have millions of goroutines spawned at the same time it will likely lead to a decrease in performance. Take a look at [this gist for an example of bounded concurrency](https://gist.github.com/montanaflynn/ea4b92ed640f790c4b9cee36046a5383). Also I recommend watching [Concurrency Is Not Parallelism](https://www.youtube.com/watch?v=cN_DpYBzKso) by Robe Pike. 
Since you already have experience with development, I can recommend [Distributed Computing with Go](https://www.amazon.com/Distributed-Computing-concurrency-parallelism-applications/dp/1787125386/). The book starts off by discussing runtime in Go, then how to do asynchronous programming with channels &amp; patterns of using channels. Then spends the remainder of the book building a reverse search index to show how goroutines &amp; channels work together.
I don't think this is over engineering. This is applying to solid principals. Namely the ID of SOLID. I, many smaller interfaces, giving functions smaller scope(almost fits in with S, single responsibility) and D dependency inversion using interfaces leading to easy reuse and drop in and out replacements by relying on abstractions rather than concrete implementations.
I find it much easier to use any proper scripting language like python or ruby to do this kind of stuff instead of learning new tools. Even if you donâ€™t know any of this languages well, return on time invested will be much better for sure. You will be amazed what great http libraries have both languages and how easy is to manipulate data. 
https://ednsquare.com/@golang
It's not about a package, it's about a bad approach. You just shouldn't do that. It serves no real good and causes a lot of annoyance. 
Thanks for replying Can you suggest some better approach
Unpack the array, using `...` https://play.golang.org/p/9gGHSUczkBD
It would probably be better here for you to move the inner loop inside the go function calls. Instead of operating over all cells in parallel, you'll just operate over the rows of your grid. This should reduce the number of spawned goroutines and reduce the impact on performance of context switching.
Man I wish DO had an office in London
Try this one out: why should you learn Go? https://ednsquare.com/publisher/view/Why-should-you-learn-Go-------NPDPbZHQ2R
Thanks for giving the feedback. \`sync.WaitGroup\` could be used either. I might be writing the next version in this way. Good point \`wp.kill\` ! \`int64(atomic.AddUint64(&amp;reqPerM, \^uint64(0))) &gt;= 0 \` reqPerM will be decremented by this line of code. How \`LoadUInt64\` would be more helpful for me?
Why only Germany and the NL ? Is it because you have some staff and offices there ?
You can contribute to Gorgonia library, which is basically TensorFlow or Theano written in Go. https://github.com/gorgonia/gorgonia
Why not recreate one of your github projects to golang? Having a quick look at your repos, Pearsend looks like a good candidate. You know the logic and tasks you need to handle, so the challenge will be doing them in the Go way. Maybe even extend to adding interoperability between the python and Go implementations?
You need to watch https://youtu.be/ySy3sR1LFCQ
That sounds like a really great idea, especially making them inter-operable! Thanks.
If you're into redeveloping someone else's idea in Go, I'd pass on my note to you. Recently saw Snibox - Snippet manager here on Reddit. It is built with Ruby on Rails. I liked the project very much in how simple it was yet very functional. I wrote down a few points to myself that if I were to build an app to learn Rust, this would be it. You can try to do it in Go if you're interested. ```sh \+----------------+--------------------------------------------------------------------------+ | Logo | |-------|search box|-----------------------------------| Settings | | | |------------------------------------------------------| | \+-------------------------------------------------------------------------------------------+ |Tags |Snippets | | | | |filename.go \^iew options V | |Python 3 |read\_from\_file.py | +-------------------------------------------------+ | |Go 12 |read\_from\_file.go | | | | |Linux 2 |get\_links.go | | | | |blah 3 |useful\_snip.go | | | | |foo 4 |snibox.go | | | | |.... | | | | | |.... | | | | | |.... | | | Snippet editor/viewer | | | | | | Syntax highlighted | | | | | | | | \+----------------+ | | | | |Users | | | | | | | | | | | |All (default) | | | | | |Aravindh 12 | | | | | |code\_mast 3 | | | | | |...... | | | | | |..... | | | | | |.... | | +-------------------------------------------------+ | |...... | | +-----------------------+ +---------+ +---------+ | | | | |commit msg | commit | | Copy | | Update | | | | | +-----------------------+ +---------+ +---------+ | \+----------------+--------------------+-----------------------------------------------------+ ``` It'd be just displaying snippets(as files) from a Git repository, and have the ability to commit updates back to the same Git repository. + Brownies if this whole thing is built as a single binary that someone can run as ./awesome-snip-manager If the ASCI image got messed up by the editor, here is a screenshot of my scribble.. https://imgur.com/a/4AWXNgf Cheers! 
^(Hi, I'm a bot for linking direct images of albums with only 1 image) **https://i.imgur.com/Imdm3Pc.png** ^^[Source](https://github.com/AUTplayed/imguralbumbot) ^^| ^^[Why?](https://github.com/AUTplayed/imguralbumbot/blob/master/README.md) ^^| ^^[Creator](https://np.reddit.com/user/AUTplayed/) ^^| ^^[ignoreme](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=ignoreme&amp;message=ignoreme) 
[https://gophercises.com/](https://gophercises.com/)
Seems like I'm still not getting completely how scopes work -.- I get how it works for variables but why it also affects returns? Here the linting alerts me that the function is missing a return at the end. func isUnique(h, c, L float64) bool { for i, color := range usuedColors { if color[0] == h &amp;&amp; color[1] == c &amp;&amp; color[2] == L { fmt.Println("This color already exist!") return false } } }
Thanks for that! Looks like a interesting book, will check this out!
I would say you should instead use a pool of worker goroutines (one per core your CPU has) which you push work to, rather than creating one for each pass of the loop. This article has a good explanation for why (basically more goroutines puts pressure on the scheduler) https://medium.com/@val_deleplace/go-code-refactoring-the-23x-performance-hunt-156746b522f7 - the section near the bottom about concurrency
I declare GUI!!! You know you canâ€™t just say GUI.
You have used the word "generic" [1] in your postâ€¦ **Go doesn't have Generics** [2]. However, many people need them and so the core programmers are collecting experiences here [3][4] to understand the need for Generics a bit better before jumping to an implementation. Some people have predicted that Go will have Generics support with version 2.0 [5]. For now, your best bet is to either create a different function for each API endpoint that handles one single JSON object/array individually, or create an interface [6] to implement the flaky concepts from scripting languages that is _"generic procedures"_. [1] https://en.wikipedia.org/wiki/Generic_programming [2] https://golang.org/doc/faq#generics [3] https://github.com/golang/go/wiki/GoVsGenerics [4] https://github.com/golang/go/wiki/ExperienceReports [5] https://dave.cheney.net/2017/07/22/should-go-2-0-support-generics [6] https://gobyexample.com/interfaces
/u/Anton-Bekker what happened? Why did you delete your post?
I used `testing/quick` recently to test that my asm-optimized functions match a reference implementation: https://github.com/lukechampine/fastxor/blob/master/xor_test.go It was easy to set up and gave me broad confidence that my code was correct. However, `testing/quick` isn't exhaustive: I had to tweak it a bit to generate longer slices in order to improve coverage. So it's worth printing out the generated test cases to evaluate whether they're actually effective. Finally, if you're testing code that absolutely has to be correct, use a fuzzing library like `go-fuzz`. Fuzzing will do a much better job of finding buggy edge cases.
Wow, I sincerely appreciate the detailed response. I'll probably rethink how I'm going to do this. It's not a complete necessity I abstract JSON / the serialization format away from main, so I think I'll just handle that outside of my generic request function in this case. I just wanted to make it easier to swap JSON for XML or protobuf down the road. As I've encountered some similar problems in other projects, I've always elected to work around generics like this but really wanted to know if there was a way to make this work. Thank you so much.
Looks like I miss something. Link to project silently disappeared from my post after publication and I'm not sure why.
https://mholt.github.io/json-to-go/ https://mholt.github.io/curl-to-go/
&gt; but really wanted to know if there was a way to make this work There is a way, doing something similar to this: type Foobar interface { func GET(url string, in interface{}, out interface{}) (*Request, error) func POST(url string, in interface{}, out interface{}) (*Request, error) func Request(r *Request, out interface{}) (io.Reader, error) func Decode(r io.Reader) ([]byte, error) } â€¢ Both methods GET() and POST() initiate a HTTP request with the respective HTTP method, â€¢ Both methods pass the request to Request() and this one executes it and reads the body, â€¢ Decode() receives the response body from Request(), decodes it, and returns the []byte, Then, you can implement Foobar anywhere and decide how Decode behaves _(JSON, XML, Protobuf, etc) var buf bytes.Buffer _, _ = (&amp;buf).ReadFrom(res.Body) return &amp;buf, nil Using the code above you can pass the HTTP response to the other methods without worrying about what content-type they are or the structure of the data. And with Decode, which again can be implemented differently by other structs, can take care of the differences in the API endpoints. I have faced this problem in the past as well, and this is how I have solved it, works very well and the type-safety is still in place, no Generics needed _(kind of)_.
&gt; but really wanted to know if there was a way to make this work There is a way, doing something similar to this: type Foobar interface { func GET(url string, in interface{}, out interface{}) (*Request, error) func POST(url string, in interface{}, out interface{}) (*Request, error) func Request(r *Request, out interface{}) (io.Reader, error) func Decode(r io.Reader) ([]byte, error) } â€¢ Both methods GET() and POST() initiate a HTTP request with the respective HTTP method, â€¢ Both methods pass the request to Request() and this one executes it and reads the body, â€¢ Decode() receives the response body from Request(), decodes it, and returns the []byte, Then, you can implement Foobar anywhere and decide how Decode behaves _(JSON, XML, Protobuf, etc) var buf bytes.Buffer _, _ = (&amp;buf).ReadFrom(res.Body) return &amp;buf, nil Using the code above you can pass the HTTP response to the other methods without worrying about what content-type they are or the structure of the data. And with Decode, which again can be implemented differently by other structs, can take care of the differences in the API endpoints. I have faced this problem in the past as well, and this is how I have solved it, works very well and the type-safety is still in place, no Generics needed _(kind of)_.
Assuming you don't really care about what's in the structure to begin with, why not just pass the json as a string and skip the marshalling to begin with? On the flip side, to modify the structure in some way, you need to know how to modify it, meaning you must have some code trying to figure out what the data is anyway. What does that code look like and why not promote it in front of your API call?
Small errors hurt the most
You want to send spam but don't want to get labeled as a spammer? Seriously?
Yes, I've already read through these and have utilized mholt's converter a number of times - very useful tool. I've especially paid attention to the "decoding arbitrary json data" section, but unless I'm missing something, it would make it difficult to re-marshal it exactly as it was without the struct tags? 
In this particular situation, seeing as your just gonna pass the pointer to `json.Unmarshal()`, use type `interface{}`: func APIRequest(URL, method string, v interface{}) error `interface{}` matches *anything*. Its use is generally frowned upon, as you lose all the lovely compile-time type checking and need to do a lot of type assertions to turn `interface{}` back into something useable. However, in this situation, `interface{}` is exactly what `json.Unmarshal()` expects: json.Unmarshal(data []byte, v interface{}) error So as long as you're not planning to do anything with the pointer except unmarshal into it, I reckon `interface{}` wouldn't be a terrible choice. Defining your own interface and making your structs implement it doesn't give you a whole lot more safety, as `json.Unmarshal()` doesn't care about your interface.
My code in main will know what structure it is in, because I was making a pointer to the struct in main, then passing that pointer to my request function which would have deal with the unmarshalling. I wanted to unmarshal it into a well defined struct to make the client library self-documenting and be able to easily access data from the client application using the library. 
I don't have the full details from HR, but we do have existing facilities (data centers) and staff there. We are also hiring for [other positions](https://www.digitalocean.com/company/careers/) in Berlin.
Those are the only 2 countries that our recruiter listed, unfortunately.
thanks!
I would just parse it to []bytes and from there you can do whatever you want. If you don't care what happens then yeah just use a struct. If you don't know the structure then use a map. Either way though you have to work in some format of data type in any language, just the type inference I guess is done for you but what's a big deal turning it to []bytes? I mean Jesus it's not hard.
OP, your example link is broken.
[removed]
I'm writing a client library and wanted to use structs instead of a map so that the library is self-documented with what data is available. It's especially useful when using an editor that has auto-completion to have the possible fields inside the expected JSON message to be available for the developer to see before they even their code and look at the response body. Nothing is wrong with parsing it to bytes and leaving it to the user of the library to deal with, but that somewhat defeats the whole point of what I'm trying to accomplish. I'm fairly new to Go, and have really only been reading and using it for about 6 weeks now, so I was just wondering how this problem is normally structured, as you're right - coming from weak typed languages, the inference is done for me and generics are something that I was so comfy with before that I didn't even know it was a thing. 
zomg thank you ðŸ˜
More than happy to help if I can
Think about this question: What does the function return when the color does not already exist?
Could you please ask again? I think given the geographic proximity and culture similarities, its very likely Canada is allowed but your recruiter just didn't mention it.
Well if you are having a hard time with just parsing types... Go is not your language. If you look at the go docs you will see nothing but types. Good example is the Reader and writer types. https://medium.com/@matryer/golang-advent-calendar-day-seventeen-io-reader-in-depth-6f744bb4320b https://tour.golang.org/methods/21 My point of saying it's not a big deal is that if you know the documentation then it really becomes a non-issue. 
https://play.golang.org/p/VFTFMbLerPK
\&gt;Well if you are having a hard time with just parsing types... Go is not your language. Thanks I guess? I mean I've been using Go for a little under a month, and I'm still learning the language features. I didn't realize there was no support for generics. I've figured out the path I want to go down where I get the best of both worlds, it's just a little more verbose than I'd have preferred. 
A perfect example is io.copy. https://golang.org/pkg/io/#Copy You are using the Reader type which automatically let's you have a string param and then you get a few io methods too. The Writer type sorta works the same way but the point being you get to then shape the behavior by using both in io.copy. this does a few things. 1. You can reuse or rename Reader/ Writer interface. 2. You converted the value into a string and it automatically gets both io methods. 3. You have a package type that utilizes both. 4. You get a something that can be reused, switched, converted, and renamed "out" of the package, "without" touching previous code. 5. Anyone can drill into how this was created for a better mental model. You can throw more methods into those interfaces and call it whatever type, they don't have to use your whole package even though you have built something from the ground up that is completely uncoupled and reusable from it's most basic components up, without initializing other objects.
What gave you the impression that Go encourage short variable names at the expense of longer variable names?
well should of said if you just want to copy paste methods then just use php with php.net and copy paste away. You prolly won't remember much and you really can only take for granted the methods do what they say, and you prolly won't write reusable code, and you will have to worry about versioning, and you can't drill down the methods to the spec, and you will have to watch for deprecation. But you know if it saves on being verbose it's all cool.
And Go linter will hit you with a warning when you try to use this/that/self but will bail on code for of 1 letter variables that are undescriptive for receivers... priorities and all that...
Russ Cox explains why here â€” http://research.swtch.com/names There is also a presentation here â€” https://talks.golang.org/2014/names.slide And some more articles online that cover the topic very extensibly: â€¢ http://wordaligned.org/articles/go-for-short-variable-names â€¢ https://groups.google.com/forum/#!topic/golang-nuts/J9QeizedpuI â€¢ https://softwareengineering.stackexchange.com/questions/176582/a â€¢ https://www.quora.com/Why-does-Golang-promote-short-and-kind-of-meaningless-names-for-variables â€¢ https://blog.learngoprogramming.com/golang-short-variable-declaration-rules-6df88c881ee â€¢ https://www.reddit.com/r/golang/comments/2hwch1/a/
I donâ€™t think itâ€™s so much that go encourages it as much as the fact that rob pike created it. Since rob is primarily a C guy and C programmers (at least the old school ones) tend to use short variable names.
&gt; A generic function that can take in some unexpected type as a parameter, perform some action on it, then return the result - the unexpected type part is the part that is tripping me up. Because Go has very little capabilities when it comes to polymorphism - It has interfaces and or "interface {}" as a catch all type. If the number of types you accept in a function is finite you can mimic unions. There is also runtime reflection but it's horrible to use frankly.
There are lot of product companies doing this. Zerobounce is one of them.
If you'd like to continue this engagement of autistic battle with me, please pm me. I'm not sure why you're telling me I'll "prolly write bad code" or what your problem is. I was simply asking a question about Go and how to handle a problem I have never faced before due to not having to deal with types in the past. I'm a hobby programmer who is doing this for fun, so I'm sorry you came across my post and it offended you. My question has been answered, thanks. 
not to sound silly, but if your testing code absolutely has to be correct, and it's technically and practically feasible, go ahead and go for the exhaustive method.
**There is no central registryâ€¦** But there is this [1] and this [2], however, there is no official tool to compare with Rust's `crates` command. Many people have built vendoring tools in the past [3] including `dep` [4] which used to be considered the _"official"_ tool to manage dependencies among Go developers. This changed a couple of months ago when Russ Cux proposed `vgo` [5][6] which apparently is going to be the future, but I don't see Google hosting nor sponsoring a central package registry _ala_ Crates, RubyGems or NPM any time soon. [1] https://godoc.org [2] https://golanglibs.com [3] https://github.com/golang/go/wiki/PackageManagementTools [4] https://research.swtch.com/vgo [5] https://github.com/golang/vgo
Context of how a variable is used is important. If you have a global variable then it's better to be descriptive, but even then, because globals are package scooped, you can leave the package part of the name out. For most functions, you have short lived variables that fits on one page, you can see everything it does in one screen so you don't really need to name it. There is also static typing so you don't need to include the type in the name either. The downside of longer names is that there's more to read, and when you change you code, the name can become wrong. 
Dependency management is a work in progress for the Go ecosystem. Without fully understanding which aspects of crates.io you're looking for, it's hard to say whether current proposals would satisfy them. The currently accepted proposal for an official package management solution is [vgo](https://github.com/golang/go/wiki/vgo), and part of that proposal may be some sort of registry/proxy/cache, one such proposed implementation is [athens](https://github.com/gomods/athens), there's still a lot to work out though. In the mean time, if you want to find Go libraries, there are options like [go-search](https://go-search.org) or just [godoc.org](https://godoc.org/).
It seems that your comment contains 1 or more links that are hard to tap for mobile users. I will extend those so they're easier for our sausage fingers to click! [Here is link number 1](https://github.com/golang/go/wiki/vgo) - Previous text "vgo" ---- ^Please ^PM ^/u/eganwall ^with ^issues ^or ^feedback! ^| ^[Delete](https://reddit.com/message/compose/?to=FatFingerHelperBot&amp;subject=delete&amp;message=delete%20ID_HERE) 
Also https://www.lysator.liu.se/c/pikestyle.html
It's to discourage writing go as if you're writing a language where those variables have special meaning. And yes, this/that/self is less useful than a single letter because you can use different single letters for different types and make your code easier to search and read. 
"memory" in your Go code isn't the same data type as "memory" in your C code. It's a slice rather than an array, so the pointer you're converting is the pointer to the slice header, not the pointer to actual memory. You want: memory := [2]uint32{ 0xBBBBAAAA, 0xDDDDCCCC } 
No you wanted generics and type inference in a type strict language. There's exactly a place on Reddit for people like that. https://www.reddit.com/r/pcjcopypasta/comments/8qy6x7/cute_lol_no_generics_go_poem/?utm_source=reddit-android
Go's encouragement of short variables is probably the thing I dislike the most about it. There is no good reason to use short variable names. Readability of code is very important. You are going to spend more time reading code than writing it long when it comes to projects.
I'm learning as I Go. I found 2 solutions including yours. With yours I can do: memory := [2]uint32{ 0xBBBBAAAA, 0xDDDDCCCC } wordptr := *(*[1]uint16)(unsafe.Pointer(&amp;memory)) at which point if I print wordptr[0] I'll get 0xAAAA. Awesome, but I'm not sure where to add an offset when I need to. I can't add it to &amp;memory or wordptr because of type errors. Where can I add one? 
 umempoffset := unsafe.Pointer(uintptr(umemp) + uintptr(3))
Got it! Sweet thanks a bunch!
Iâ€™m conflicted about it too. I like short names for very local and obvious variables and descriptive names for struct and package level variables.
Long variable names look ugly and complicated. If a piece of logic requires a variable to be named something `userAccountPreferences` in order to disambiguate it from other variables, then chances are the logic is approaching a difficult-to-maintain level of complexity.
I never said I wanted them in Go anywhere in any of my posts. I don't know enough about the implications to include them. 
You'll want to add it to your .bashrc / .zshrc https://github.com/golang/go/wiki/SettingGOPATH
*facepalm* yeah indeed. This wasn't a golang problem but a mere logical one indeed. 
The GOPATH environment variable specifies the location of your workspace. If no GOPATH is set, it is assumed to be $HOME/go on Unix systems and &amp;#37;USERPROFILE&amp;#37;\\go on Windows. If you want to use a custom location as your workspace, you can set the GOPATH environment variable. Say your workspace is at desktop named as "full-stack-go-" then run this command in **terminal** `export GOPATH="/home/mic/Desktop/full-stack-go-"` `echo $GOPATH` /home/mic/Desktop/full-stack-go- (output)
If you setting GOPATH as i replied in above comment, GOPATH variable is available in your terminal &amp; it will be destroyed as you close the terminal. **If you want to set GOPATH variable permanently you can edit .bashrc to do it.**
Please read this - https://github.com/golang/go/wiki/CodeReviewComments#variable-names Go does not encourage short variable names _everywhere_. The further a variable is used from its declaration, the longer it has to be. Important variables should always be named appropriately. OTOH, it is not idiomatic to name a loop counter as `loopIndex`, just name it `i`. 
ok thanks for the clarification!
A guy at work always uses ii. I asked him why, and essentially searching a file for just i is a pain - ii was more likely to be found quicker.
It's been fixed!
colly is already pretty simple though
Sorry about that, fixed it.
Yes, I like colly. Although I built something using goquery before colly got released which broke due to changes in the website. In my head it was easier to keep scrapers updated if the config data of where to seek can be separate from code. That's what I started this for. Though now I have few more plans fir it.
In this case you can let the array indexing do the pointer math. It's less wordy than the uintptr/unsafe.Pointer dance. memory := [2]uint32{ 0xBBBBAAAA, 0xDDDDCCCC } as_u16 := (*[4]uint16)(unsafe.Pointer(&amp;memory)) wordptr := &amp;as_u16[3] And if you did have a slice rather than an array, &amp;slice\[0\] gives you a pointer to the 1st element. slice := []uint32{ 0xB...,... } as_u16 := (*[4]uint16)(unsafe.Pointer(&amp;slice[0])) ...
A bit late to the party for this, but participle is not designed for building lexers, it's for building parsers. In fact it uses the text/scanner lexer by default.
This article would be much nicer if you'd omit part with setting Go directory and dep. These 2 things belongs to separate articles
v := *(*uint16)(unsafe.Pointer(&amp;memory[0]))
Slight problem I've found with using .zshrc is that when I run vscode from dmenu, it doesn't pick up the environment variables. I'd say .profile is a better bet.
Imo of you need long variable names for your code to be compensable, then you probably want to think about reworking the structure. Go also encourages short functions with low cyclomatic complexity. If you have small functions which are generic then specific variable names are no longer applicable.
I think it's even simpler: every programmer knows `i` means loop counter. It's the correct name for such a variable.
What if i call the binaries without os Arguments? Should create a file with a default name or exit with an error.
When I am thinking of variable names, I am thinking of business domain inspired names. In my mind, it makes it easier in the long term to maintain and onboard people to the code base. In a way, I don't need to have my mind wrapped around a more substantial chunk of the code base to understand what a particular function does. I'd prefer `primaryAuthor` and `secondaryAuthor` over `pa` and `sa` for example. Of course, if what I am doing is handling a request, I understand using `r` instead of `request`. Maybe, It is more about the domain! Perhaps, Go is not intended for the use cases where languages like Java and Scala are used for, but rather where C is used. Thinking about it, if I was coming to this Go C, or some other language where long variable names are not allowed or even if I am using an 80 characters wide screen it is natural to shorten the variable names as possible and use `prmUsr` and `sndUsr`, But coming from Scala with a full-fledged IDE I find it less natural.
I am new to go myself, but I will take a dig at your code. (I think code reviews are an awesome way to learn new stuff) 1. Use methods. ```go func (i *Indenticon) SetFilename(name string) { i.filename = name } ``` This can be then called like, ```go var i Indenticon i.SetFilename("FILENAME") ``` 2. Make createIndenticon an exported function, (i.e. `CreateIdenticon`) 3. Error handling. 4. Maybe you can ditch `setFilename`. Instead ```go identicon = Identicon{ fileName: name, } ``` 
I'm curious about this too. I don't think Go itself encourages short variable names. Maybe OP's using a linter that suggests short variable names?
Agreed, you are right. Many peoples having issues with this step..!
Sorry, I forgot to mention this point if you add new path to your **.zshrc or .bashrc** you must reload it to make new path to work correctly. if you use **.bashrc** tun this command in terminal `source ~/.bashrc` if you use **.zshrc** tun this command in terminal `source ~/.zshrc` Hope this works.
Yeah, idk. I personally never encountered any warning or error with my variable names so I'm legitimately curious on what OP means. Every language has (or should have) coding standards and variable name convention is part of it, is he referring to some Go coding standards? If yes, I'd like to have a look at the documentation.
This is so awesome
Thanks...
That only works if you load the editor from the terminal. When you run something through dmenu, it doesn't execute your .zshrc or .bashrc, and therefore those variables won't be available (at least with VS Code).
If you're only scraping one page why would performance matter? 
I am reading through [The Go Programming Language](https://www.gopl.io/) book and also in [Ultimate Go Programming](https://www.safaribooksonline.com/library/view/ultimate-go-programming/9780134757476/). For an example there is a method `FToC` in the examples instead of `FahrenheitToCelsius` or `tempconv` instead of `temperatureConversion`, `err` for `error` and `fmt` for `format`.
I agree, `i`, `j` etc. are not good examples since they mean loop counters by convention. 
If your setter has no side effects like that, it's probably better to just expose the field itself. This isn't java ;) ``` ic := &amp;Identicon{ FileName: name, } ```
Give a look on astuart.co/goq. 
I don't think that well written code with small functions doing specific job is mutually exclusive to long variable names. Of course, you can have few lines of documentation against a function to explain what things do. But I think it make more sense to have descriptive names. In my personal experience, I have never used long variable names because there was many of them in the same scope. Also, it is more around `preferences` vs `p` for an example. or `req` and `res` vs `request` and `response`. Some times though an `extreamlyLonVariableName` might make sense, but those situations in my experience are rare or might just be a result of complexity in the business/problem domain rather than in the solution/code domain.
Cool, thanks.
`func companyHasShipsInAsiaPacific(company Company) bool { ...` Then I can say `if(companyHasShipsInAsiaPacific(company)) { ... ` The complexity here is coming from the business not from the implementation and hence the long variable name. 
I'm high
I'd rather be consistent across the language when I refer to `this/that/self` than using a different single letter variable for each type. It would have made more sense to me to always use `I` for an example to refer to self if the four characters are too long.
Sure, but that examine is a great example of a non generic piece of code. The right choice for the job in hand, but in a code review I'd ask for example does: if company.Ships().In(AsiaPacific) {...} give you a structure of smaller simpler more reusable functions that is just as readable in that single statement as well. Of course it all depends on the larger problem, but at a guess I'd say your companyHasShipsInAsiaPacific function looks like it would be a huge complex single use function, and as a rule those are normally harder to maintain IME.
pa or sa is really dumb. Using it anywhere other than immediately after the declaration would result in having to scroll up to the definition. I, personally, absolutely prefer the full, written out name as you do. However my coworker (who has far more experience in Go) would prefer priAuth or secAuth and, unfortunately, this is how we are proceeding with our app. With good code completion/variable completion and no limit on variables names I donâ€™t see a reason for useless abbreviations over explicitness. 
They are good examples. The convention is acceptable because their origin is immediately visible.
No, especially not with a capital letter, that's signifies an exported symbol. The guiding principle for go's design is that we spend more time reading than writing code. You should spend more time reading other people's go code, some of the coding conventions take getting used when you are from a different language, but once you do, your code will be more pleasant for other go coders to read too. 
Oh I understand your point completely. I guess my definition of a long variable name is something that is approaching a sentence. Included in my programming history are Java and Objective-C, both of which have a tendency to be a little excessive on the variable naming front. My opinion at that time was "_they all compile to the same size, so it's no big deal_" Lately I have come to the realization that this kind of code is much easier to write than it is to read, and readability should be the foremost concern after composition. It could very well be a reading deficiency on my part, although I am sure there are others like me who see long names and immediately lose focus on what the code is doing, because there are layers of context embedded in the variable name itself. I'm definitely not advocating for a loss of descriptiveness in variable names, but I am saying that an excessively long variable name indicates a code smell, even if it's specific to a particular piece of business logic. I also realize that these scenarios are almost always unavoidable, so they should be kept as separate as possible from the rest of the code base. Again...my opinion/observation only, but I do find that succinct names and shorter lines of code are much easier to keep in mind than longer ones.
Thanks :). This is very helpful. I would argue though that `Short is (easy to type)` is not a thing really in 2018, since tools help with that. I like the reference to how name length should be proportional to the scope. Also, introducing the package name in the variable name again is redundant and I agree that it is a bad style. If code is a year or more old and few developers iterating on it, with the high turnout. It is easier to on-board people and share domain knowledge with descriptive names. They might be longer for the domain seasoned developer that works in the same codebase for a while. Code reviews is another area where descriptive names make things easier to follow and hence, less bugs to escape. I find a value in let's say searching for all usages of a certain domain concept by using good old plain text search. If we are consistent in calling a country code `countryCode` we are more likely to find instances of `countryCode` instead of searching for `c` or `cc` which might be used for country, car, caseStudy, etc. Of course it might just be my attention span ðŸ˜‚ 
So, I spent some time reviewing this and want to understand what your goals are with this exercise. I have been rewatching Frances Campoy's Just for Func videos recently, and decided to try and review this similarly to how he reviews code. Given that it took me some time to understand just what the code is doing, and then I wasn't sure if you are trying to learn how to create these icons, create a library to create the icons or if you are generally just using this as an exercise to learn Go. Given that what I can gather is you take a filename's checksum and utilize it to create a 5x5 (250 pixel x 250 pixel) png icon. When I think about this I would probably have rewritten it into a utility that takes a filename and then generates the image and saves it to a file. Then I started thinking about what if I wanted a bigger grid, say 7x7 or 10x10? Then why stick with a white background, can I use the checksum to create a complimentary background color, and if I wanted the grid to be bigger or smaller, or change the size of each square... My first comment, is more comments, reading the code was a challenge, and given the reuse of variable names (i for Identicon and index counter of the array) h as a hex array that is actually checksum, and more... For fun I think I might try and take what you have and recreate it as a library with some more functionality (I will share my results so you can see how it could be done differently), but that doesn't really help you learn Go. I wouldn't call myself a Go expert, but I have written some utilities and keep playing around whenever I can, so let me know if there is anything specific you are looking for. Maybe I will be able to help.
I personally prefer `maxPhysicalAddress` over `maxphysaddr`. Also, a quick lookup on the length of identifiers in C, I found that uniqueness must be guaranteed in the first six character in a variable name which was latter upped to 31. This article was written in 1989, so I think they had only the luxury of the six characters back then. I coded on a monochromatic 80 characters screen with the 6 characters constrains for which the short names made sense and to be honest was fun to abbreviate company to cmp and love to lv. But we are no longer concerned with punch card from which the 80 characters limit came from nor writing a long name is a problem with modern tooling. 
I agree, it is sometimes hard to read code when there are three or four single letter variables within three lines of code.
I don't think our brain reading speed is directly associated with the number of characters a word is formed of. Instead, it is around the image of the word. We tend to scan not to read. So, `c` and `company` are likely to take the same amount of time. It might be hard to figure out what `c` means compared to `company` for an example. On contrast `i` is universal understood as the counter index.
I wrote c in on very constrained machines, I can totally relate to that.
Thanks :)
``` company := Company{} company.Bankrupt() ``` vs ``` c := Company{} c.Bankrupt() ``` I like the second version better. Again, this only applies when the variable only lives in a few lines that you read all at the same place. 
That is the primary reason I will stick to short variable names whenever possible. Because, when one joins a community one must respect the culture and conventions of that community. When I was doing Scala a one letter variable name would probably give me a stroke :D. I wouldn't like to cause the same pain to my colleagues working with Go. Btw, using the case of the first letter to determine visibility is another thing I am finding interesting about Go. But that is a totally different conversation :D.
I disagree, I would rather have a descriptive name than a generic one with a will need comment. The i example is a bad one because that is just common convention, the logic doesn't extend to other variables
I guess we need to respect the community we are joining. It is good sometimes to question what people, including ourselves, take for granted. This is how the world has evolved. I will always follow the decision of the team and the community because at the end of the day there is no right and wrong and consistency in my mind is better than correctness. After all correctness is subjective. Consistency is something a team or a community would agree upon.
I agree on `company.Ships().In(AsiaPacific)`. But unless there are other companies that ship in other places, this code will be premature refactoring IMHO or upfront design if you may. This function could be called once or twice to handle a very specific fringe business case. If we don't have those fringe cases, any off the shelf piece of software will do our jobs ðŸ˜‚.
In most of my work experience I have not been a specialist in a certain piece of code. I did vertical slices in complex pieces of code with tons of edge cases. I found it hard to keep everything in my mind at the same time jumping from one feature to the other. expressive variable names helped a lot. Yes, there was a lot of complexity that I wish were not there in some cases. But complexity happens and technical debt occurs and when I try to maintain code that was written even by me months ago, I find it easier to navigate through and refactor complexity when things are expressive. I am new to Go, and I am sure I am going to be writing a lot of shitty code that for my future self sake and the sake of my colleagues and my company, I like it to be understandable down the road.
Good point. I also like the point of *convention* across code. In a way, if we use `c` for company across the code that would be good. But then what happens if we introduce a new concept for Creator and then for Consolidation and then maybe Catastrophe. What happens if a couple of those happen in the same short lived scope. Do we keep using `c` for company and use `Catastrophe` or should we use `ctstrph`!
Don't use ctstrph for sure, maybe cat is better. There shouldn't be that many one letter variables names, when I see 3 or 4 used at the same place I start refactoring to longer names because it's getting hard to keep everything in my head. In the end, you want to be readable without being too wordy. I usually use c for Context, b for builder or buffer, s for string, and n for number. If you have more than one of these, then you need better names.
I think maybe another way to look at it is that it's generally more "idiomatic" to plugin or extend the std lib than it is to define your own abstractions/interfaces. Go has some great abstractions already built in that make sense. If you're using the io package, use fake io.Reader/io.Writer structs. If you're using net/http, use httptest. Better to rely on the abstractions of the language which are understood by the community rather than develop your own business level abstractions (which are usually a lot more complicated). When your business logic outgrows the language, then you should structure your code to clearly separate business abstractions from your language abstractions. 
What about CockroachDB instead of Postgres?
If you are curious about the benchmarks https://gist.github.com/trashhalo/b2f120fb9d20bd4003bf125c0200b601 There seems to be a 3x performance penalty for using go webassembly
This took me a little while to understand because it was never really explained to me properly, but I hope I can manage it. When you pass a normal variable to a function, think of it as making a copy and then performing your actions upon the clone. That's fine for some things, like adding two numbers together. Pointers, however, send a memory reference to the actual object. This is useful for two main reasons: 1. Within the function, you can edit the original object, because you're changing the object found at that memory reference, not a copy. 2. If you are dealing with really big objects in memory, you don't want to be copying them in to a function. By sending only the memory reference, which is tiny, you are saving a lot of resource usage on your system. I really hope that helps.
In Go, anytime you do an assignment or call a function, it does a shallow copy of the variable. This creates a problem: what if you wanted to mutate the original object and not just get a new copy? The answer is use a pointer. From a technical point of view, a pointer is the address in memory of the original object (or nil if itâ€™s not set). From a practical point of view, use pointers when you want to be able to change an object instead of making a copy. 
Of course! you can use and Database of your choice. Postgres is used for simplicity of tutorial.
&gt; Iâ€™ve been using Python for over 2 years, and the concept of pointers still makes 0 sense to me. There are other more detailed explanations, but with you coming from python maybe think of a "x := y" as two different operations depending on if y is a pointer: * non-pointer type is kind of like python "x = y.copy()" * pointer type is kind of like python "x = y"
Makes sense, thanks :) If I might add, it might also depend on the complexity and the type of problem one is handling. But, if I understand correctly, I like your perspective, start short and then refactor for longer names if you need to.
In theory, canâ€™t you just use a pointer in every case?
If you want to optimize memory usage, yes. Some situations might call for immutable objects so you'd want to avoid pointers.
You could but it would be messy and unneeded. Adding to what he said, there is no point in making a copy of the http request, that would only increase memory footprint of your program. Instead, you can use a pointer and pass a pointer to the memory location of the http request. This is common to do with large objects and structs among other things. Also, welcome to Go! 
You wouldnâ€™t want to though. For example, if math.SquareRoot took a pointer, you would worry that itâ€™s going to mess up your original number. 
Dave Cheneyâ€™s post finally made it click for me. Including the article [here](https://dave.cheney.net/2017/04/26/understand-go-pointers-in-less-than-800-words-or-your-money-back) in case you havenâ€™t read it.
There's always `maxPhysAddr`, more readable, still obvious. `maxPhysicalAddress` isn't too long IMO, but it's all about context too, depends where it's being used, and how. If you have plenty of context available, a short name can be better than having to read a book.
Thanks for taking the time to give my code a look! There are certainly a lot of issues with it. I tried going through some of the design principals the creators of Go layout, but I guess I may have taken them to the extreme. As for the program itself, you had the first option right. At this point, I'm just trying to become more familiar with Go. Awhile back I did a tutorial on Elixir and one of the follow-along projects was exactly this. A simple CLI utility to generate one of those github style "no profile image found" profile images, which is called an Identicon. In this example, they're a 250px by 250px png split into a 5x5 grid, where each grid is shown and colored based on the checksum of the user's actual name, username, or whatever criteria you want. Here's an example of my name: [carson](https://imgur.com/a/69jwE6u Do you have any tips for making sure that my code is more legible? I'm guessing I got a little confused with the design principals. Do you have any other suggestions for me?
Yes, it is terrible.
Good old plain text search will be lot more useful on method name, fine name, structs name/field etc. Well it seems you like long variable names in general. So you can enforce it in projects you work on. After all it is not some compiler error for long names.
I'm posting this here, because the discussion seems relevant in light of how Go differentiates itself from C/C++/Java for example. I find some points in the comments and the linked [Jai](https://github.com/BSVino/JaiPrimer/blob/master/JaiPrimer.md) introduction/manifesto interesting. For example, compile time code execution part seems very interesting, from the perspective that it solves something very specific to game development (the computation of expensive operations at compile time, producing the final array in the binary); I find that this could also be applied to some things that are quite common with Go and are currently being solved with code generation - namely the (infamous by now) [jteeuwen/go-bindata](https://github.com/jteeuwen/go-bindata) (which you absolutely shouldn't be using anymore), and similarly [rakyll/statik](https://github.com/rakyll/statik). If one could produce a function that would just read these files/folders at compile-time, I do find a lot of the mess around these libraries would go away, because you could read anything (just parse a JSON at compile time), produce anything in terms of structures (go beyond just a simple `map[filename][]byte`), and still keep all the type safety with more convenient and understandable code. Do you find some other things that make sense to your use cases with Go?
It seems that your comment contains 1 or more links that are hard to tap for mobile users. I will extend those so they're easier for our sausage fingers to click! [Here is link number 1](https://github.com/BSVino/JaiPrimer/blob/master/JaiPrimer.md) - Previous text "Jai" ---- ^Please ^PM ^/u/eganwall ^with ^issues ^or ^feedback! ^| ^[Delete](https://reddit.com/message/compose/?to=FatFingerHelperBot&amp;subject=delete&amp;message=delete%20ID_HERE) 
I was interested in the discussion and the different points of view. I have learned a lot from you and every other point of view that was expressed here. Yes, I am a fan of using more descriptive code including identifier names, but I didn't code in Go before. When I did C, long names were not an option. With Go, I needed to understand. After all, we don't work in isolation, we work within a team and a community. Even if I am totally for the longer names, I will follow the community convention. The discussion here helps understanding where to strike the balance.
Ty!
I'm not sure why code critique gets downvoted on this sub so often. I'm also very new to programming so anything I add below here take with a grain of salt :P 1. First critique, no comments or readme to tell me what this code is even intended to do. It's helpful to have at least a basic understanding of your goals before diving into the code. 2. re-use of same variable names without comments threw me a couple of times. buildGrid function for example your use of i is a bit all over the place. 3. overall after spending some time figuring out what everything did I didn't see anything terrible wrong with it that jumps out at me ... I do need to go read more on the gg package :) Sorry not overly useful for you but is for me 
me too man, me too ... fn("I still can't believe South Korea beat Germany 2-0 to put them last in their group")
I'm here to also help
If you use vgo, this problem goes away. You arenâ€™t redistributing the dependencies, thatâ€™s on the downloader and whether they go on to redistribute. If you donâ€™t want to use vgo, if you put things in the vendor folder, and do not modify them, youâ€™re golden for most licenses. I would suggest avoiding LGPL and AGPL as a matter of course anyway, and of course anything thatâ€™s not OSI certified.
&gt; I do find a lot of the mess around these libraries would go away, because you could read anything (just parse a JSON at compile time) Including `/etc/passwd`. Or `$HOME/.ssh/id_rsa`. I maintain, that Go not having meta programming abilities is fundamentally a *good* thing. It means that if you execute a `go build`, you can be sure that a) it does nothing but compile your code and b) that it has a predictable (quick) build time.
Thanks, I will check that out now!
Cool awesome.
Uff, this is a controversial topic, but as someone who used to program in C++ back in the day when it was just "C with objects" and had to do some work in it recently: yes, C++ is a terrible language. There's so many broken things about it, I could write several blog posts about all the problems I found: - Not having a proper packaging system makes managing dependencies a nightmare when compared with any modern language - The tooling around it is *very* hard to use. CMake was supposed to make "make" a thing of the past, but the moment your project is more complex than a simple "hello world" example, your CMakeLists.txt file will end up being as complex as any Makefile - The language itself is incredibly complex and full of arcane rules. Resource management is already hard enough, but C++ introduces all kinds of rules around [move semantics](https://stackoverflow.com/questions/3106110/what-are-move-semantics) that make it *by far* the most complex language I've ever had to deal with - The syntax has become so outdated and obtuse, it's not even funny. The lambda syntax is a pretty good example - Having "header" and "source" files made sense back in the day when compilers had limited memory to parse a file, nowadays it just makes the code harder to follow with no added advantage - Name mangling in shared libraries is still a problem, so if you want to share your code with any other language you have to create a C wrapper around it and export that, adding a completely useless indirection layer and call in the stack Don't get me wrong, some of those are strong features when you are one of the 0.01% of people who need them, but for the rest of us they only introduce complexity.
I think this is a copy of [this article](https://www.sohamkamani.com/blog/2017/09/13/how-to-build-a-web-application-in-golang/) please give credit when due!
[https://www.reddit.com/r/ProgrammerHumor/comments/8x3xbm/its\_not\_easy/](https://www.reddit.com/r/ProgrammerHumor/comments/8x3xbm/its_not_easy/)
Go's `map` already has this behavior. Most implementations of `set` simply wrap `map` with some helpers. For example: https://github.com/fatih/set -- though I would recommend implementing your own, as it's only a few lines and it tends to evolve to your specific use case. Your next question might be "what if I wanted to implement `map` myself?" and the answer would be that `map` (and some other builtin types in Go) is special and generic. You won't be able to implement something equivalent in the base language without the overhead of reflection. This is partly by design, and partly because generics haven't made it into the language yet.
For many licenses, for example GPL/LGPL, you're on the hook for distributing the library source anyway if you distribute binaries.
If you're distributing Go binaries, you're bound by all the licenses of the Go libraries you use, as you're doing the equivalent of static linking in the C world, in which case, vendoring the source code is irrelevant to any licensing discussion. If you're not distributing binaries, that's a different story. The `vendor` directory provides isolation for different library versions between different projects. The reason some people advocate for committing `vendor` is that currently, that's the best method available for avoiding the `left-pad` scenario, though there are long-term plans to support some sort of proxy/registry for Go libs as an extension of `vgo`, but we're not there yet. If you want to use `dep` for dependency management, but don't want to commit `vendor` to your repository, just ignore it with `.gitignore` (then you can think of it like `node_modules` in node-land), with the understanding that if one of your dependencies does something silly or malicious, your build may be broken/tainted. If you want to use `vgo` for dependency management, you can choose whether or not to store your dependencies in `vendor`.
If you want to learn Go, the best first step is to go through the [tour](https://tour.golang.org/welcome/1). This is a tour of the Go language and is a great place to start to familiarize yourself with the language. Next there are several articles and blog entries found here [Documentation](https://golang.org/doc/) on the [golang.org](https://golang.org) site. Something I have seen when a program is ported from one language to another is the result looks a lot like an odd dialect of the original language, your code looked like javascript as much as it looked like Go, and I would almost say it looked more like javascript than Go. I am continuing to build out my interpretation of what you wrote, and at some point I might incorporate the drawing mechanisms into this utility rather than utilize the same library you did. I would do this for two reasons: 1. You are using a real small part of this to just create a simple canvas and paint a handful of blocks; 2. I want to continue my learning and what a great way to do so than by expanding the project a little more. I will keep you posted as I check this code in.
I am not distributing binaries. However, it looks like dynamic linking is supported in go so wouldn't that solve any static-linking issues? Thanks for the explanation regarding vendor. It's starting to make more sense. 
[removed]
I love meta programming but not having any meta programming is one of Go's sorta core principles. If you have work you need to do where meta programming is a big help, Go is probably just not the right language for that work.
Should help you a lot. https://blog.gopheracademy.com/advent-2016/advanced-encoding-decoding/
In more recent versions of the Go toolchain, it is *possible* to dynamically link packages. This might be a valid strategy to work around e.g. LGPL, however it doesn't happen by default, and there are trade-offs in higher complexity build and distribution.
I agree with most of this but the "syntax is outdated" is funny to me. Why does that make the language terrible? I could say the same thing about go and it wouldn't make a difference.
That was the clearest, shortest explanation Iâ€™ve read thus far. Great find.
This is my first serious Go project, I'd be very interested in some critical feedback. PS the reason the repo has so many stars and I'm only just now asking for feedback is because I've just completely rewritten it.
*Beep boop* I am a bot that sniffs out spammers, and this smells like spam. At least 100.0% out of the 25 submissions from /u/geekoman199 appear to be for Udemy affiliate links. Don't let spam take over Reddit! Throw it out! *Bee bop*
Although it is an anti pattern in go, it is really handy and non pre-emptive when you keep unit testing in mind. It is easy to create a mock implemtation of an interface, and use that as dependencies while unit testing. Is there a better GO way of unit testing and mocking without interfaces? 
Programmer's hubris I suppose. I had been using Hugo but for my casual requirements it was an overkill in terms of complexity. Hindsite emphasises simplicity and ease of use.
Added 3 more reference links to it.
Man, what a time to be alive. The last text based browser I played with was lynx and that was years ago. This is a pretty big step forward from that. I am using the 64bit binary rpm, and it is pretty slow on my end. Slower than my normal firefox. Do you have suggestions for speeding it up? My env: uname -ro # returns: 4.17.3-200.fc28.x86_64 GNU/Linux firefox --version # returns: Mozilla Firefox 61.0 bash --version # returns: GNU bash, version 4.4.23(1)-release (x86_64-redhat-linux-gnu) gnome-terminal --version # returns: GNOME Terminal 3.28.2 using VTE 0.52.2 +GNUTLS 
Firefox binary not found: c:\Program Files (x86)\Mozilla Firefox\firefox.exe My firefox is not x86 - how can I change that forlder?
Haha, thanks :D Well it's always going to be a few 100 milliseconds slower to render and sync than the equivalent Firefox GUI on the same machine as it has to take the extra step of parsing a page to pure text. Where you notice the speed is when you're on a slow connection locally and run Browsh on a remote VM and then SSH (or ideally Mosh in). 
`browsh -firefox c:\Program Files\Mozilla Firefox\firefox.exe` That being said, I've really struggled with getting it to run on Windows, so I'd be interested to know what other problems you run into. Thanks.
Thanks yeah it seems to not work. I used this for teh command (I can't run the command browsh): $ ./browsh_1.2.0_windows_amd64.exe -http-server -firefox c:\Program Files\Mozilla Firefox\firefox.exe
Can you run it with `-debug` as well please? And paste me the output of `./debug.log` I'm not too focussed on Windows though I'm afraid, as ultimately it's designed to be run on remote VMs
That makes sense. I am not sure this fills any specific use case for me other than I like it. This is awesome.
;)
Waiting for Firefox to connect... Attempting to connect to Firefox Marionette Starting Firefox in headless mode Using default profile at: C:\Users\GG\AppData\Roaming\browsh\firefox_profile FF-MRNT: 50:{"applicationType":"gecko","marionetteProtocol":3} Sending `newSession` to Firefox Marionette FF-MRNT: 533:[1,0,null,{"sessionId":"3782eede-b80f-499c-a685-54d8ce63b911","capabilities":{"browserName":"firefox","browserVersion":"61.0.1","platformName":"windows_nt","platformVersion":"10.0","pageLoadStrategy":"normal","acceptInsecureCerts":false,"timeouts":{"implicit":0,"pageLoad":300000,"script":30000},"rotatable":false,"moz:accessibilityChecks":false,"moz:headless":true,"moz:processID":8140,"moz:profile":"C:\\Users\\GG\\AppData\\Roaming\\browsh\\firefox_profile","moz:useNonSpecCompliantPointerOrigin":false,"moz:webdriverClick":true}}] Sending `setContext` to Firefox Marionette FF-MRNT: 13:[1,1,null,{}] Sending `executeScript` to Firefox Marionette FF-MRNT: 25:[1,2,null,{"value":null}] Sending `setContext` to Firefox Marionette FF-MRNT: 13:[1,3,null,{}] Sending `setContext` to Firefox Marionette FF-MRNT: 13:[1,4,null,{}] Sending `executeScript` to Firefox Marionette FF-MRNT: 25:[1,5,null,{"value":null}] Sending `setContext` to Firefox Marionette FF-MRNT: 13:[1,6,null,{}] Sending `setContext` to Firefox Marionette FF-MRNT: 13:[1,7,null,{}] Sending `executeScript` to Firefox Marionette FF-MRNT: 25:[1,8,null,{"value":null}] Sending `setContext` to Firefox Marionette FF-MRNT: 13:[1,9,null,{}] Sending `setContext` to Firefox Marionette FF-MRNT: 14:[1,10,null,{}] Sending `executeScript` to Firefox Marionette FF-MRNT: 26:[1,11,null,{"value":null}] Sending `setContext` to Firefox Marionette FF-MRNT: 14:[1,12,null,{}] Sending `setContext` to Firefox Marionette FF-MRNT: 14:[1,13,null,{}] Sending `executeScript` to Firefox Marionette FF-MRNT: 26:[1,14,null,{"value":null}] Sending `setContext` to Firefox Marionette panic: runtime error: invalid memory address or nil pointer dereference [signal 0xc0000005 code=0x0 addr=0x8 pc=0x4b4cdd] 
Oh it got pretty far! That's good news. Ok I'll look into thanks.
No problem.
[removed]
Well, for the `$GOPATH`, you actually can set several locations like in a Linux `$PATH` variable. Keep in mind, that the first location will be the one go installs external deps. Mine does look like this: `EXPORT GOPATH=$HOME/go/external:$HOME/go/internal` my code goes into the second folder in `src/github.com/github_name/project_name`. The code, that others wrote, is in the external folder. That keeps my project folder clean. Every project is one single repository. For your project ... I generally try to split responsibilities in my code and frontend and backend (especially with an API) would be 2 projects, but I also have a prototyping setup, where I have "static" (frontend) code within the go project. The structure looks something like this: * `.../project_name/cmd/server/main.go` * `.../project_name/pkg/...` * `.../project_name/public/...` In `cmd` goes everything that is compiled to a binary, like the server command that starts the server. In `pkg` is the actual code. `public` is a folder that contains the frontend files (images, js, css, html). I sometimes have a `frontdev` folder as well if I am going to use a lot of pre-processing tasks to generate css, js and html files. The output will be stored in public. To have access to my frontend files I do something like this in the server: `fs := http.FileServer(http.Dir("public/"))` `http.Handle("/", http.StripPrefix("/", fs))` This makes the `public` folder available on the root of the web project: `http://localhost:8080/`. It is a quick way to hack something together.
As mentioned by others map is your best bet. If you don't care about the value and only the uniqueness of the keys matter use zero-sized types like struct{}. There are two other options: You can use reflection which I'd recommend or you if you really care about performance you can play around with the unsafe package. For reflection the sort.SortSlice function could be a good start. One last thing to note is that slice elements don't have to be comparable while map-keys do.
It was described that Go syntax is simple. In the sense, if you know a curly-bracketed language, you already know the syntax of Go. That holds true for the most part. Now imagine, something that were typically comparison or binary operators like `!^&amp;&lt;&gt;` and even `?` (not as a short-if) as part of the language syntax. You might find that `var-&gt;x` is understandable (in a convoluted obj-&gt;a vs. *obj.a way), but beyond that a lot of programming languages just went down dead end streets in terms of syntax. I'm sure there's somebody smarter than me who will point at LISP or COBOL or something like that as the origin of the convoluted syntax languages (or maybe those just have a bad rep along with an insane longevity since we're still talking about them in 2018). There's just two lines of thought from my perspective - insightful researched contributions to language syntax that use practice and intuition as a guiding principle, and then there's things like ruby, python, javascript, even perl, and especially c++, that just introduce new symbols and operations that are, frankly, ridiculous. I've literally seen `@var` and `#var` being used as syntax to count the number of items in an array. That seems very far from intuitive.
What language is your poison of choice for meta programming? What kind of meta programming do you most often do? (I resorted to relatively simple macros in C++ back when I was doing it, and Java template syntax for maps, lists, the usual - in comparison with what I've seen above, I'd classify that as entry-level meta programming ;)).
Well, C++ solves problems Go can't. Go solves problems C++ fits badly. Can we choose the right tool for the right job and move on? Of course C++ looks antique and full of cruft, it was there in the 70's. Let's see what go looks like around 2050.
As a side note, don't confuse strong and static typing. Python and PHP are dynamically typed language, but while PHP is weakly typed, python is strongly typed (it won't happily convert your int into a string without you making it explicit, for instance).
If you've not come across it, jennifer makes generating complex Go code simple. The API has been stable for a few months now and it's being used in a growing number of projects, so it's high time I called this a v1 product. So no more changes unless they're absolutely critical. You can be certain that code you write using jennifer now will work forever. 
Can I instal it with `go get`?
I'm not sure that'll be too easy, because it needs to include a bundled binary blob. Do you know how to do that?
What does it need to do with the binary blob? If the Go code just needs the data at runtime, you could bundle it in the Go binary... There's lots of packages that do this - e.g. https://github.com/alecthomas/gobundle p.s. the docker command isn't working for me: ` $ docker run -it browsh/browsh Unable to find image 'browsh/browsh:latest' locally latest: Pulling from browsh/browsh bae622905f92: Pull complete 2c8e1e23bfe9: Pull complete b4a1efa98d7d: Pull complete ea715aa2abe7: Pull complete 0485f3c72388: Pull complete 97a2b8247df4: Pull complete 7aef619f96eb: Pull complete ce9bf46ef456: Pull complete e403c2a71b0a: Pull complete 9a12fb9dce08: Pull complete 3f3fde614df0: Pull complete 3c577a4c27dc: Pull complete cef8922cce2f: Pull complete Digest: sha256:8eda0186982894fd2b9a60591fd7e4b9228b100943b3084facb2e0d7f8bdf63d Status: Downloaded newer image for browsh/browsh:latest standard_init_linux.go:185: exec user process caused "exec format error" `
Did you obtain the project via `go get`?
Oh right, ok, then I'll see if I can get `go get` working. Hmm, interesting Docker error. What OS and CPU arch are you on? That image is used live for the `ssh brow.sh` service, so I know it works otherwise.
Just a Macbook with the standard Mac Docker client...
&gt; ^uint64(0) I missed the `^`. My bad.
Great, thanks. I've submitted it as a Github issue for now: https://github.com/browsh-org/browsh/issues/62 You can subscribe there for any updates.
Depends on what the project uses. If it uses `git`, a combination of `git reset --hard origin/master` and `git clean -f` usually does the trick. &gt; Furthermore is it dangerous to remove a package by deleting its folder? No, not a problem. Things using that package won't build anymore until you re-fetch it though.
Yes it's the only way I am using to obtain packages at the moment.
&gt;No, not a problem. Things using that package won't build anymore until you re-fetch it though. Yeah of course, I'd expect that \^\^ Thanks for the git hint =)
Much worse than plain C. Just my opinion.
Sorry for the stupid question but what would be the usecases of this over just writing go?
That was the exact reason python 3 is not compatible with 1 and 2. It had primitive structures in it that shouldn't be dealt with anymore. https://docs.python.org/3/whatsnew/3.0.html
I used jennifer on a project over the last week and really enjoyed it. Once I learned the constructs it became simple to write any manner of code programatically. Thanks for building this project, it's a real time saver.
Then it sounds like this is a git question. Try to use git reset or git checkout on the files you've changed. Use git diff to see what you've changed, etc.
Not a stupid question at all. Code generation is one of those tasks that saves you a lot of time if you have a lot of boilerplate code to write. For an excellent example, take a look at: https://github.com/dave/jennifer/blob/master/jen/generated.go - it's 2,200 lines of Go that make up much of the API of the jen package. Most of the functions and methods are very similar, so the genjen command generates this file. It uses data in here: https://github.com/dave/jennifer/blob/master/genjen/data.go - and generator logic in here: https://github.com/dave/jennifer/blob/master/genjen/render.go
Ahh thanks of course! 
You all seem to be quite right. map is the way to express a set in go. And I will consider using it as such. If I want to have a slice of my set, for example for passing it to xml.Marshal I still have to copy&amp;paste a toSlice function for every of my struct, is that correct? Or is there an elegant solution that can take any map and return its keys as slice?
Yeah I guess that nuking the local repo is the best option with a good hard reset =)
Forgot to slip in something about "It's coming home" :/
I've made some updates and added some comments for you. :)
Fork it, clone your fork to where the existing package naming would put it in your GOPATH. You don't have to change the package names.
I recommend you to take Todd McLeods Udemy Go course. He really goes in depth with everything pointers structs maps interfaces channels functions error handling etc etc everything possible. Its like 22 hrs long but it really breaks everything down so u understand 
That's a good idea, thank you.
Clone the original repo, fork it, then add your remote to the repo: git remote add youruser https://github.com/youruser/originalrepo.git Now you can push to your fork like: git push youruser branch
I've toyed with C macros a bit of course, and Nim a little bit, and lately Rust. I've been using it most recently in Rust to make it such that you can write a block of SIMD code and at compile time generate either SSE2, SSE41, or AVX2 instructions. https://github.com/jackmott/simdeez My first proof of concept of the idea was with Rust macros, which would work, but someone pointed out you can accomplish it with traits and generics as well. It *does* take a while to compile! 
I couldnâ€™t be more excited about this! This is by far one of the most technically proficient teams I have come across in the Blockchain space.
Similar situation here. Generally, you're asking for how to convert a map to a slice of keys. If that's the case, then you'll need to write the 3 lines of looping and appending. But what is the actual problem you're solving? Do you need to xml.Marshal your struct into a specific layout that is different from the layout of the struct itself? If that's the case, then you want to implement one of the [encoding.Marshal interfaces](https://golang.org/pkg/encoding/). Also what do you mean by "every one of my struct"? How many structs do you have that implement a set? 
Thanks mate. Best feedback so far!
Thank you very much for your advice :) I figured it out now using reflection. Here is the link to a playground showing my implementation: [https://play.golang.org/p/qR557KHFkRh](https://play.golang.org/p/qR557KHFkRh) Xml Marshalling works very fine for me, I figured that out. The Problem I am trying to solve is reading data from 3 different sources, packing them into 3 structs and saving them to 3 xml files. Data from the sources might be duplicated, but it is extremely important that one instance only appears once in the xml file. That is why I need the set. Unfortunately xml.Marshal doesn't seem to work with maps, but I solved the problem for me now using reflection. Although 3 functions for 3 structs seem maintainable, I cannot foresee whether more data sources / structs will be added in the future. I also like that I can reuse this code now, as it seems to work with any struct. Again, thank you very much for your help!
Thank you very much for your advice! :) Reflection was the keyword I was not familiar with. It helped me solve the problem for any struct, as it seems. Here is the playground showing my solution: [https://play.golang.org/p/qR557KHFkRh](https://play.golang.org/p/qR557KHFkRh)
That's awesome. I've got a multi step build process with SCSS/SVG assets and this will help make publishing a lot easier!
Thank you, I think I see what you're saying. You're saying that instead of having my project code in `User/Documents/Code/project1/api`, and `User/Documents/Code/project1/web` - that I should put my frontend code alongside my Go code in the place that Google wants it - like this: `~/$GOPATH/src/project1/pkg` (which is the api code) and `~/$GOPATH/src/project1/web`. I like that - I may look in that direction. Thank you. 
Things I would recommend: 1. Use methods (Was already mentioned, but it was the first noticeable thing). 2. Longer variable names (see `makeGridCell`). It is so hard to follow. You don't need comments on good code (or very little at least) 3. Flag package is pretty good for command-line apps. It has --help built in Things you might not know: 1. In `makeGridCell` you know how long `r` will be when you are done. So you can create `r` with capacity that is large enough for all the appends, but with zero length using `make([]byte,0,len(o)*2 - 1)`. Then there is only one memory allocation (else append might have to allocate more memory). In this particular case you can get it down to zero allocations (one in `buildGrid`) by allocating `row` once and passing it as a parameter to `makeGridCell` (and zero-ing it using `row[:0]`). Then some weird things I don't understand: 1. Inconsistent usage of pointers (eg `func buildGrid(i *Identicon) Identicon {`) 2. In `buildGrid` there is the following code &amp;#8203; end := i + 3 if end &gt; len(h) { end = len(h) } row := makeGridCell(h[i:end]) if len(row) == 5 { cells = append(cells, row...) } Now `row` will only be length of 5 if `h[i:end]` is length of 3, right? But if `end &gt; len(h)` then `len(h[i:end]) &lt; 3`, so why not break if `end &gt; len(h)`?
Following up.
You're welcome, good luck! :)
Simply using `import` without including the library in vendor doesn't make it dynamically linked. In fact unless you use https://golang.org/doc/install/gccgo to compile your golang code it will always be statically linked. Which is most likely why I don't recall seeing a LGPL or GPL licensed go library.
Just confirmed that Canada is OK.
I might be complicating this further but why not just use abstract types? https://golang.org/ref/spec#Appending_and_copying_slices Cause it looks like you are needing two generics for type and size and then you have to compare the two and then add them together. I think this can be simplified without the reflection package and it wouldn't be so coupled. If of course you wanted to look deeper into this. 
The previous suggestions are good. I also like to consult this list if I am trying to find a Go package that does something specific: https://github.com/avelino/awesome-go
&gt; *but it comes very awkwardly* Gonna need a real-actual-problem(s) explanation here to advise, "awkward" is more of a feeling..
I use a makefile.
I guess you are right, "outdated" doesn't really convey why the syntax is bad. I think what I meant to say is that it's clearly a syntax that has a lot of baggage. The language has been around for a long time, and every new committee seems to feel the need to add more syntax, sometimes so subtle it's very easy to miss. Go's syntax is... OK. Personally I prefer Python's or TypeScript's syntax (let alone language features).
I recently fixed a bug in it, and I could run it fine on my desktop with basic `go install`. All I needed was a running Redis server. So I think this has changed now?
Why do you need a mature build system for Go? You can easily integrate it into any of the existing major CI systems.
Why do you need a build system at all? I have a project with multiple executables and have no problems using only the go command at all. I embed version number, git commit hash, etc. into the binary, this makes a few more lines to the build command. This is all tied together using a simple Makefile. And everything is integrated into Travis CI. Its actually really simple.
bazel
Makefile is the standard. You can also use "go:generate", which is builtin. It's typically used for generating Go code, but can be used to build the binaries if you wanted.
This is good, but try creating a map instead. Right now your solution is O(n), map's are O(1) amortized. Also, test whether it's more efficient to use reflection to populate the map, or using a `map[interface{}]struct{}`. Many people don't realize, but you can use the empty interface as a map key!
&gt; What do most people use? Your choice of build system shouldn't be based on some popularity contest. If you can't be bothered to describe the problems you're running into, you won't get very good answers. Here's the classic guide: http://www.catb.org/esr/faqs/smart-questions.html 
Please read, and double-read, this: https://golang.org/pkg/unsafe/#Pointer It explains precisely the *correct* ways to use Pointer. Especially if you plan on doing pointer arithmetic, this is required reading.
You sure about that mate? And if so, what do you recommend?
I re-read this a few times and I think it did the trick. Still a little fuzzy.
The language is called "Go". Its fine to call it golang/the language with no generics/whatever on a day to day basis, but you are supposed to be teaching people with this, and you already have a mistake in your title ...
It is not strictly related to Go. But I would get rid of else clause in your main.go. I loathe them! :) func main() { name := "identicon" if len(os.Args) &gt; 1 { name = os.Args[1] } identicon := createIdenticon(name) identicon.save() }
This subreddit is literally called 'golang'. 
I'm not teaching people... I'm teaching myself and I want to share useful materials with the community. Thank you for your constructive comment... :*
So is the mailing list and the website, but that doesn't change the name of the language itself; it's short for "The Go Language."
@dbk00p it is true ! I did not made attention to this.
The sub is not an official communication channel. It can be called Daisy for all that matters
My repo is not official also ;)
not sure if a reference link is enough, when it's a complete copy with just a different stylesheet. imho this is plagiarism...
https://stackoverflow.com/a/32325270 this should get you most of the way
That sounds promising indeed; my remark was based on an old experience. Thanks for sharing!
Nice
Does this mean a cgo requirement?
flag.Duration would be a nice example that a lot of people don't seem to know about
Thanks for sharing the original author.
[removed]
Having to use shell script and makefile in 2018 is an actual problem
*blink* I just use templates...
This is cool! Does it supports vim style keybindings?
Note that the example shows using `target+"."`, but the library already has `dns.Fqdn(target)` for that which will also handle domains that are already fully qualified. https://github.com/miekg/dns/blob/dcdbddd8102b79eeef1329473dffab4aec17ca25/defaults.go#L228
Uh, why exactly?
Travis CI is actually a build-system. The only question remains that does your current workflow tempt you to build binaries on your local machine and deploy them? If so, then what prevents you from building a binary from a "dirty" git repo (un-committed changes)? In that case your binary would have the "git hash" of the last commit but actually be different...?
Makefile was the standard, Makefile+Dockerfile is becoming the new standard.
You should check out the article titled "effective go" 
Looking at the post, I don't see a reason why cgo would be required there.
The link to structs in your readme is broken, there's a typo.
Yes. The commit linked in the blog post indicates they are using https://github.com/wellington/go-libsass which is a Go wrapper to the C libsass library, so this will require CGO. However, given they offer binary downloads (e.g. via brew etc) this is not that big a deal IMO.
I've always wondered, is putting flag code (be it stdlib flags or a third-party lib) in init idiomatic?
init() and main() are effectively the same thing in a main program, so I don't think it makes much difference. 
Here are two videos I did on pointers, maybe this helps: [The Pointers lecture from my course](https://appliedgo.com/courses/mastergo/lectures/2618279 ), available as preview [AppliedGo Quick Bits: Pointers vs References](https://youtu.be/A6G7qxnFUS0) 
Have you considered using lambdas? Lambdas allows you to 'defer' the need to know about the concrete type of a variable till later. It also allows you to swap behavior (json for xml parser). The function `FromJson` still takes an empty interface, but that does accurately match the requirements/restrictions it places on the type. But if that bothers you (or you need type specific unmarshalling), then you can define a function like `CompanyFromJson` that does that. I have found that in most cases where a function needed a 'generic' parameter, a lambda could take its place. If you ever run into the situation where you need to write a lot of functions (Like `CompanyFromJson`,`UserFromJson`,`ItemFromJson`,`CartFromJson`, etc) then look at`go generate\`. All the best. type Parser func(r io.Reader) error func main() { //Create a pointer of the struct I want to use to hold the expected data for this particular request co := &amp;Company{} //Pass the pointer to the function that handles the HTTP request and unmarshalling err := APIRequest("/company/companies/1", "GET", FromJson(co)) if err != nil { log.Fatalf("request to get company 1 failed: %s", err) } err = APIRequest("/company/companies/1", "GET", CompanyFromJson(co)) if err != nil { log.Fatalf("request to get company 1 failed: %s", err) } } func APIRequest(restAction, method string, parser Parser) error { req, err := http.NewRequest(method, restAction, nil) if err != nil { return err } resp, err := http.DefaultClient.Do(req) if err != nil { return err } defer resp.Body.Close() return parser(resp.Body) } func FromJson(o interface{}) Parser { return func(r io.Reader) error { return json.NewDecoder(r).Decode(o) } } func CompanyFromJson(c *Company) Parser { return func(r io.Reader) error { return json.NewDecoder(r).Decode(c) } }
Iâ€™ve been very happy with kingpin. Why would I use this instead?
16. Structs - url is invalid, there's missing 't'
init gets called when you run your tests, too, so there's a good difference there- you run the risk of having things set you didn't explicitly set within that test code which can cause unexpected results
Cool project! Asm being over the top of my head already, but itâ€™s cool to see :)
It's simpler to write a factory. Go is not java, it doesn't have generics, it doesn't have annotations that can be fully typed checked at compile time,you can't really use xml,json or yaml as a configuration file in order to configure an IoC container in your code either like Spring or Struts, since there is seldom ways to create types from a string representation at runtime, so all these things introduce is more errors or panics to manage which defeat the purpose. Instead, write safe readable code, something like that (pseudo go code) type MyFactory struct { foo *Foo bar *Bar } func(f *MyFactory)Foo()*Foo{ if f.foo == nil { f.foo = createFoo() } return f.foo } func(f *MyFactory) Bar(i int)*Bar{ if(f.bar == nil){ f.bar = createBar(f.Foo(),i) } return f.bar } Back to the basics is a more accurate way to describe Go rather than "simplicity". 
Personally, I prefer doing it in main because that forces you to not rely on global state, but pass the values around.
Thanks for the tipp. I do know that my implementation is O(len(slice)) on every insert, which is quite bad. But it is a bad example then. I wanted to know how to operate on arbitrary slices. With my new knowledge I could now set every value with even index in a slice to nil (I bet this is a bad example too :P). It was important to me to understand how to write reusable code in Go without having generics. Reflection is the thing I didn't know about.
fixed :) thank you .
fixed :)
[https://github.com/smileisak/go-training/blob/master/random.go](https://github.com/smileisak/go-training/blob/master/random.go) \- in this you could also show crypto/rand random number generator, as a better and safer alternative to math/rand
I just found base64 and sorting are also corrupted :)
This is what I tried and failed. I set up an interface to my structs and tried to define a function that takes a slice of the interface, an element of the interface and returns a slice of the interface. But that code wouldn't compile when trying to call the function with a specific struct. Here is a playground of what I was trying to do: [https://play.golang.org/p/WKIfqvO1UFK](https://play.golang.org/p/WKIfqvO1UFK) Fixes and explanations to this are much appreciated.
Yea, thats what i thought. Would be nicer without IMHO.
it wraps libsass now.
Not yet! But it's planned: https://github.com/browsh-org/browsh/issues/31
Fixed also ;) thank you @kerakk19 for you're so helpful.
I will take a look at it. :)
Same as that. Kingpin is the mutt's nuts. Never liked cobra, not least because it leaks stuff like `stringSlice` into the help string.
I use hugo from homebrew. After seeing `hugo` get updated, I tried using `toCSS` earlier today and I got an error message along the lines of "this version of Hugo doesn't do that". I assume this'll get fixed in a few days.
Ive enjoyed cobra which makes CLI command structure, required arguments, subcommands, help text, posix flags and more super easy
its not quite ASM, just intrinsics. The names look scary but you can look up what they all do here: https://software.intel.com/sites/landingpage/IntrinsicsGuide/# _mm_add_ps -&gt; "multimedia add single precision (float 32)" adds 4xf32 numbers at once _mm_sub_epi32 -&gt; "multimedia subtract int32" subtracts 4xi32 numbers at once and so on 
I was only thinking about it from the main perspective. I didn't consider the effect on testing. 
[removed]
For me it feels WAY more close to C than Java. There's lots of stuff one can remember though, but that's due to the extensive, feature rich standard libs that come with it - and everything is pretty well documented so in the end you only gotta remember one thing: where to look it up :-D
There are build tags, so you can compile without Cgo, you just lose the SCSS compilation feature. 
File an issue. Sounds like the brew formula needs to be updated for the new Cgo stuff. 
Definitely closer to C due to pointers and general language structure, but the syntax is kinda it's own
In go you don't have classes and programming is "very similar" to programming in C. You can say that go is modern C language
As much as it is unpopular to say, I really like the simplicity of [urfave/cli](https://github.com/urfave/cli) _(previously codegansta)_. I'll have to give flaggy a try to see how ease of use compares
Kingpin didn't distinguish between a flag unset and a flag set to the default value, last I checked, which is my biggest beef with it, but sadly neither does this new library, so...
I'd argue that in some sense Go is closer to Java (it is GC'ed, memory safe, has a decent runtime, high-level data-types, strict typing, modern modularization,â€¦) and in some sense it's closer to C (Control over memory layout. Compiled to native code. And no generics, I guess. TBH I can't think of a lot more similarities). What that adds up to, will in general depend on your background and what you are looking for in a language.
C + GC + modern libraries
use closures to cache data https://play.golang.org/p/IY-BMUfuejc
&gt; 35 different flag types supported and no interface to define your own value type.
I'll give a better answer hopefully later today but from a glance part of the issue seems to be comparisons of types. I was going to write it out but I wasn't 100% on how much access you have to the data (aka API, xml, db) but if you don't then you at least need to know the rules of comparison. This article helps a lot but isn't going to give you the answer. https://go101.org/article/value-conversions-assignments-and-comparisons.html http://yourbasic.org/golang/conversions The problem is you have two types and you are comparing them. You either need to setup generic interface{} type vars in the beginning and use them as params or convert to them. This is because you also on top of that are iterating through parts of two types and comparing them. Which isn't going to work. In go everything is just a type but types are different. A lot of people just want the var a == var b senario and not think about types but then they lose the magic of utilizing types to add methods or uncouple structures. Case in point the following. https://medium.com/@snippet22/reader-types-2ba61290a5cf https://play.golang.org/p/IA09xBX7dYF But if you only have access to receiving unspecified data then you can use maps too. https://blog.gopheracademy.com/advent-2016/advanced-encoding-decoding/ http://polyglot.ninja/golang-json/ I hoped that helped but I'll try to get time tonight hopefully to maybe provide an example. Cause I'm more then sure you can simplify this a lot. 
I've been using pflag, I thought cobra and some the other bigger CLI libraries were quite big. Also I don't have projects that use sub commands. This is pretty nice and doesn't look complicated to set up. Nice work!
I started out my career in (embedded) Java and later on switched to C, but these days I'm more a (dev)ops guy, and don't code anymore for a living. I do write a lot of tools and have some hobby projects going - and my go-to language is Go. For me Java is nowhere near in my mind when having to compare Go to a language. To me, it's a fun version of C. Writing tons of boilerplate code and taking care of the memory-management becomes meh after a while - and Go eliminates a lot of it (not all though). But using 3rd party libraries is dead-easy, compilation too, it being very opinionated eliminates a lot of the decisions you have to make when starting a new project, which also makes exploring existing other-ones a lot more transparent. I'd compare it more to the compiled counterpart of a scripting language like Python. It's very quick to write something amazingly functional in it, and yet distributing it is not a complicated mess due to it's static compilation and cross-compiling to another platform being dead-easy by just setting 2 environment variables. One of the main things I really like about Go is how quickly you dive into other people's code. It seems to remove all barriers - and jumping into the stdlib's or a 3rd party lib's codebase just to figure out how it works becomes very natural, certainly if you use the standard tools like [godoc](https://godoc.org) which links directly to code in your repo.
&gt;Good bot!
Geez, I'm glad he didn't break space-time and collapse the Universe. But embrace this, folks. Bloat isn't going anywhere it will just all be in binaries instead of webpack builds. 
Nifty idea to open the package path from the browser like godocs. Nice work!
Go fits a similar market niche to Java, but the programming language itself is essentially a modernized version of C with GC, packaging and higher-level data structures. One might argue that is why Go has been so successful, it opened up the world of application development (network applications, specifically) to a lower-level, arguably faster non-JVM language.
Does anyone know why chrome is so slow at loading webassembly?
Looks interesting (though may be confused with http://noiseprotocol.org/). I will have to take a peek at the DHT, as I have been working on https://github.com/cretz/tor-dht-poc which is a proof of concept of creating a DHT in Go that can broadcast peers for a certain value, and be able to access that same DHT from JS, all anonymously over Tor. We agree on many of our primitives (I am also the author of https://github.com/cretz/bine which might have value to you if you want anonymity).
Nice work, this is something Iâ€™ve wanted. I see the implementation is quite simple because it uses the `go` command and writes to a temporary folder. Iâ€™m curious how much work it would be to compile everything in memory and not shell out (the way `gopherjs serve` does). I suspect itâ€™s a very large amount of work, unfortunately.
I would like to know this as well.
Hi, thank you for taking a deep look at the implementation! I didn't know that `gopherjs serve` puts the compilation result on memory. I'm not sure how much work we'd need, either. As you said, the current implementation is not bad in terms of code readability. I'm satisfied with the current situation so I don't plan to change that. I might have needed to add deletion of wasm binaries not to consume disk unnecessarily.
Thank you :-)
https://agitated-tesla-9f4163.netlify.com/app.wasm - 7.87MB ðŸ˜±
Great to know! Thanks a lot for the feedback :). Want to warn though that the main components implemented in terms of a DHT is just the routing table itself, as not every P2P application requires a full-fledged DHT but just acknowledgement/discovery of peers. As for browser support, we actually already have it working for our own use case of Noise; would be more than happy to directly work on websocket support in the coming few weeks. From what I see of `bine` by the way, if it supports the net.Conn interface entirely it's easy to plug it in as a transport layer for Noise :). That's how KCP is supported apart from TCP.
No.
I took a Kubernetes workshop last year and it was enlightening if a little dense. Frankly I struggled to keep up at the end of the say -- I think part of it was fatigue from travel and the amount of content. I highly recommend signing up for one.
&gt; I might have needed to add deletion of wasm binaries not to consume disk unnecessarily. As far as I know, most OSes clean the temporary directory periodically, so it shouldnâ€™t be a big problem if you canâ€™t easily delete the files (because itâ€™s hard to know when theyâ€™re no longer neeeded).
What was your background coming into the workshop?
I've traveled to places with very slow connection speeds as well as those with restrictive networks. Combined with Mosh I can see this as very useful in either case. Next step is a mobile app.
I made a chromium issue for it. [https://bugs.chromium.org/p/chromium/issues/detail?id=862210](https://bugs.chromium.org/p/chromium/issues/detail?id=862210)
Really nice, this will make building social networks like scuttlebutt in Go much easier. - How do you handle 1K, 100K, 100M peers? - Is streaming supported (if not, how are large files handled)? 
How big is the go runtime though? I was thinking it was on the order of only 1MB maybe its bigger in webassembly.
The main issue is that you're not writing the same amount as you're reading. For example, if N is how many IP's you have, you're reading N items from the `c` chan, but writing one per TXT record. Also, you're sending `[]string{"no results"}` to the channel, but when receiving, you're checking if you got a nil... At no point do you put a nil into the channel. If you want to do it this way, ensure that every "search" call sends exactly 1 item into the `c` channel, and if there is an error, ensure that you do send a `nil` to the `c` channel, so that the receiving code can know to recv from the error channel.
I liked Todd's web dev class with Go. The fundamentals course was way too condensed &amp; overwhelming for a beginner, imo. That being said, he's been great for the Go community.
Why are there so fucking many flag parsing libraries? The one in the standard library has always been enough for me 
Heyo! - 1K, 100K, ... peers works out entirely fine, and our peer discovery mechanism reflects that by only bootstrapping you with at most `dht.BucketSize` amount of peers. You can easily implementing reliable broadcasting methods as a plugin (we provide a naive broadcast function in `network/network.go`!) to thereafter spread messages around the entire network. - Yep, streaming is 100% supported and we got a proxy example which proxies streams from one TCP connection to another peer: https://github.com/perlin-network/noise/blob/master/examples/stream/main.go 
Ah ok thank you so much, that makes a lot of sense. Is there another way to read off the channel that doesn't require the loop that I have?
Anyone working on a generator for single page frontend applications yet? /s
It's 20MB
You can range over channels directly, it will terminate if the channel is closed. for element := range myChannel { print(element) }
Ah ok thanks! That makes a lot more sense
Been looking for quite a while. Doesn't seem to be the case. A bunch of abandoned projects at best 
Oh, can also shorten the for to for range serverList { } // or for i := range serverList {} // if you need 'i'
It doesn't even support `--foo` does it? Always drove me nuts how the stdlib uses weird flags that feel not POSIX _(I'm not sure what it actually is, it may be POSIX, /shrug)_
Some modifications are needed to make sure that the program runs without a hitch and we don't end up in case of starvation. I usually also provide a `done` channel to the workers to keep track of when to close up the channels in the source. Hope that makes sense. I would update the code as follows: ``` func main() { c := make(chan []string) errC := make(chan error) done := make(chan bool) // Necessary to prevent leaks, always close channels. defer close(c) defer close(errC) defer close(done) serverList []string{"1.1.1.1", "2.2.2.2", "3.3.3.3", "4.4.4.4"} for _, server := range serverList { go search(query, server, c, errC, done) } // this for loop just hangs after getting the results // of a few queries from the channel :c: completed := 0 for true { select { case msg := &lt;-c: results = append(blacklists, strings.Join(msg, "")) case err := &lt;-errC: log.Println(err) case &lt;-done: completed += 1 if completed == len(serverList) { return // break the loop now, all workers done. } } } } func search( query string, server string, c chan []string, errC chan error, done chan bool) { defer func() { done &lt;- true }() client := dns.Client{} msg := dns.Msg{} msg.SetQuestion(query+"."+server+".", dns.TypeTXT) // 208.67.220.220 is opendns nameserver r, t, err := client.Exchange(&amp;msg, "208.67.220.220"+":53") if err != nil { errC &lt;- err // send error over the channel // there is an occasional error here: //read udp 192.168.1.5:58332-&gt;4.4.4.4:53: i/o timeout } log.Printf("Took %v, %v", t, server) if len(r.Answer) == 0 { c &lt;- []string{"no results"} } for _, ans := range r.Answer { Arecord := ans.(*dns.TXT) c &lt;- Arecord.Txt } } ```
I haven't completely tested the code yet. Please try and execute the code and see if there is a problem, I can take a look further. Also a great reading resource is as follows: https://blog.golang.org/pipelines
In addition to this, we can make this code a little bit shorter by only using the `errC` and do away with the `done`. I didn't wanna touch that part of functionality yet.
Thanks! That fixes the channel issues. Do you have any idea why I'm occasionally seeing an i/o timeout? read udp 192.168.1.5:51119-&gt;208.67.220.220:53: i/o timeout I assume it's because I'm making queries too fast on my end, but I'm not sure how to slow that down in a smart way
Thanks very much for the hints :) I have implemented this now: [https://play.golang.org/p/IIaB8Zt6ooW](https://play.golang.org/p/IIaB8Zt6ooW) Is that the direction you were pointing at? It works just as well as the reflect method for every struct that implements my Comparable interface. But it does not seem as elegant to me, because the reflect method works on arbitrary slices and the types don't need to implement an interface, as reflect.Deepequal seems to take care of that. It is still very good to have this experience with functions that take interace(-slices) as arguments now. I feel like I learned a lot with these two examples :)
Can you explain how this works? ``` defer func() { done &lt;- true }() ``` I would have thought this would run for each goroutine, so after the first one finishes it would stop, rather than the last?
I think if it bothers you you can start the name of your option with a dash. What it doesn't support is -abc actually meaning -a -b -c, but I hate that so meh
+ easy concurrency + interfaces
+ packages (finally getting rid of headers)
more like C. but with the good parts of java.
I'm pretty experienced but haven't had any exposure to kubernetes. The concepts weren't difficult to understand but it was a lot of information -- lots of commands and patterns that I should probably have practiced. I think anyone would have benefited from it.
I guess that's not uncommon for a workshop. They'd rather leave you with too much information than too little.
Please, use [https://play.golang.org/](https://play.golang.org/) next time for your code
Think of a pointer like a street sign. Obviously the sign isn't the city but you know how to get there, it points there.
I mean, I just want it to be consistent with nearly all other tools. Single letter flags can be combined, word flags are behind two dashes. Go feels like the odd man out in, I think, all of the tools I use on a day to day basis.
&gt; Can anyone see something obvious that I'm missing? Yeah, you're not debugging your own code. &gt; the channel output hangs for some reason. You can find that reason quite easily yourself using a tool like gdb or delve, or sending SIGABRT to the process and combing through the stack dump yourself. If you don't learn how to debug your own code, you're not going to learn the language very quickly, or very well...
Oh will do! I didn't realize there was a share functionality with that :)
Just to throw it in here - there is D. It breaks with C and is by many considered C++ done right. It compiles almost at Go speed and has very powerful meta-programming facilities. Yes Go is not an universal language but none is. Go supports true procedural programming exceptionally well but many people don't utilize its full potential.
[One or two minus signs may be used; they are equivalent.](https://golang.org/pkg/flag/)
longflags are a gnu extension and not POSIX in any way
'simplicity' hum I think you mean easiness but urfave/cli is highly complex.
Went to the webdev one. Informationally it was great, but I don't like Buffalo as a framework. It's essentially Rails in Go, which I really didn't like.
Yea, I mentioned it might not be. As I said, all I know is that of the CLI tools I use on a daily basis, Go is literally the only weird one.
Do you have any examples where that's helpful? As a user, I'd expect the same behavior probably.
https://gobuffalo.io/en/docs/generators generates models, views, and validation (basically a simple CRUD) that you can then start working with and customizing. So it's more powerful than an automatic scaffold you can't customize. https://github.com/mustafaakin/gongular is another (slightly related) project you should look at if you plan on having validation on a lot of REST API endpoints as it handles so much of the heavily lifting for you. (Great for Javascript / Mobile Apps) 
You could give a try to [https://github.com/heetch/confita](https://github.com/heetch/confita). It's a lib that loads configuration from multiple backends and stores it in a struct. It's a cool project for beginners for various reasons such as: * codebase is still small * you can start by writing a new backend labeled as good first issue, if you're unsure of where you're going, just have a look at the other backends * we're welcoming contributions and we're not hostile. On the contrary, we'd be glad to gentle and constructive reviews.
\`init()\` is for used libraries (\`package {mylib}\`) to run initialization procedures before \`main()\` is called. I don't know if it should be a hard rule, but I'd very much suggest not using \`init()\` in an application (\`package main\`).
How are structs with methods any different than classes?
Yup, absolutely. Say you need to have several sources for settings with different priorities, for instance with a setup where the main source is a configuration file where default parameters for every run are specified, but you want to let the user override those defaults on a run to run basis with command line flags. (Which is nowhere near uncommon, BTW). Say one such setting is a boolean value. In that case, the corresponding flag being left unset explicitly means, use the default from the configuration file (which may be either true or false), whereas the flag being present and set to false explicitly means false. Generally speaking, the pattern of "an entity has properties, and can perform actions that have corresponding properties, and the action's properties are the entity's default unless explicitly set otherwise" is a pretty common one and it was a bummer to me to find out that Kingpin, while otherwise pretty darn nice, doesn't support it.
Sweet, thanks!
Im attending this one. I have never worked on rails. Which framework would you use for web dev? 
Great work OP! I've been seeing this around and haven't had time to look into it in depth. Come to find out it is written in GO! 
docopt.go would be ideal if they finally removed their git shadow mess
The defer keyword ensures that the function following it is called exactly once, after the surrounding function returns https://tour.golang.org/flowcontrol/12
``` case &lt;-done: completed += 1 if completed == len(serverList) { return // break the loop now, all workers done. } }``` ensures that the loop waits for all goroutines running search() exit before returning from main()
Looks interesting. I only wish it could require one dash for short flags and two dashes for long flags. I donâ€™t like the mixing of one and two dashes. 
Jennifer is a self-hosting code generator? Neat! 
[removed]
I personally like Echo. But there are a few "micro frameworks" out there that are similar. I just don't like all the behind the scenes magic that big frameworks do.
[removed]
It's an easy library to write, and the space is large enough that one library can't completely fill it. Same reason you get dozens of web frameworks.
This is pretty cool, web assembly is exciting and Go support is even better!
Ah. That's unfortunate if cgo is involved.
A simple console.log wasm binary weighs in at 1.3 mb. This includes no dependencies outside of syscall/js.
We must go deeper.
bep already fixed it. Hooray for timezones!
Ok, This was a fun and frustrating project. Here is a [link](https://github.com/hambletor/identicon) to my solution, that also includes the ability to change the size and block count as well as both foreground and background colors, and gives you a way to review the pattern prior to saving to either png or jpeg. If you want I can go over some of the details, and my next effort will be to replace the gg library (pretty nice though) with the native drawing library. Let me know if you have any questions.
Well in terms of the comparison to Java classes, Go structs have less capabilities, such as a lack of constructors and overloads. 
Bep is incredible. 
I think this is overlooking the other, other form of concurrency: SIMD. So far really only C/C++ really have good support for it, and in that case itâ€™s by just embedding assembly code in it. Iâ€™d love to see more languages take it seriously. 
Please donâ€™t do this dance with globals; please take dependencies as parameters to constructors.
Iâ€™ve never attended one but Iâ€™m giving one! If you sign up for it let me know what youâ€™re looking for. Or redeem this Reddit comment for one free in-workshop hug.
\&gt; Erlang is designed from scratch for concurrency. Erlang provides full control of interactions between threads to the programmer via message passing, through which he must do all communications. This is the source of Erlangâ€™s legendary performance on multi-core computers. Erlang is actually pretty slow compare to other languages.
Yeah but that's a js interpreter isn't it?
If the default is in the config file, can't you just avoid calling `Default()` on the flag?
Probably because the behaviour of the flag package is surprising since GNU/BSD have made the long/short flag behaviour ubiquitous on modern *nix systems.
You need to add a semaphore to add bounded concurrency. Otherwise all your goroutines will spawn at the same time and saturate the network. Check out this example of [Bounded Concurrent Get Requests](https://gist.github.com/montanaflynn/ea4b92ed640f790c4b9cee36046a5383), depending on how good your network is you might see the performance following a bell curve. The thing you'll want to look at is the use of the buffered channel which blocks once it's full. Check out lines 24, 31, 44 and 58.
- precise control of memory 
I don't know if it fits to your requirements, but how about [qor/admin](https://github.com/qor/admin)? here is the demo, [https://demo.getqor.com/auth/login](https://demo.getqor.com/auth/login), you just login to that (test accounts provided) and access the admin page [here](https://demo.getqor.com/admin)
Rust has it now, C# has it coming soon. "its happening!"
[removed]
[removed]
You are right about that. WaitGroup achieves just that but under the hood, the logic remains the same I guess. 
Nice! This looks like an interesting project. Just one concern, though: do you do integrity checking on messages passed around? I can't review the code properly on mobile, but I didn't find any thing that seems would make sure the messages were not modified. If I understand correctly, because Salsa20 is a stream cipher, and it just XORs the keystream with the plaintext to encrypt (correct me if I'm wrong, never actually looked into Salsa20 and co...), it makes modifying the ciphertext with known plaintext trivial for an attacker, not good.
Why not skip multiple executables and use [cobra](https://github.com/spf13/cobra) instead?
IIUC ServeFile blocks until the data is sent, so I think I can remove the file safely after that. &gt; most OSes clean the temporary directory periodically Yes, but as wasm binary sizes are megabyte-ish, so removing them as soon as possible would be a good manner. Anyway this is not an urgent thing.
While this is a good practice isn't explicity injecting all deeps through the function just plain cumbersome? With certain packages that need to be mocked I like depency injecting via function params.
Is this is the webscale equivalent of pypi for javascript?
Thank you for your reply. Those are some valid concerns. Yes I reused the Nonce. I know that is a bad idea. Just for the sake of testing I didn't add the nonce handshake cuz, I had to add some server specific code to maintain a unique nonce for any given Connection. Still a hobby project. Need help from people. Adding a MAC for preserving the integrity or to check the packets is in my bucket list. 1. Yes I'm yet to add a MAC, but with salsa20 2. Will add the random nonce generation for each client in the handshake too. 3. Yep will not reuse nonce. 4. I used salsa20 from the experimental package [https://godoc.org/golang.org/x/crypto/salsa20](https://godoc.org/golang.org/x/crypto/salsa20) : I think that is mature enough. I actually did a blog write-up for how I wrote and future plans [here](https://blog.aki237.me/update_on_pin.txt).
&gt; isn't explicitly injecting all deeps through the function just plain cumbersome? it's a minor inconvenience that hasn't really been an issue with my code so far. Can you provide an example of when it's a major inconvenience? &gt; With certain packages that need to be mocked I like dependency injecting via function params. I use the standard constructor and pass in mocked dependencies. I use `httptest` for testing http servers. It's been good to me so far. If I have a struct with a significant number of dependencies, I might package them up into a struct, and then possibly add a verification method to that struct. I haven't had a need to do this yet. A trivial example: ``` type ServiceDependencies struct { service1 *Service1 service2 *Service2 service3 *Service3 service4 *Service4 } func (s ServiceDependencies) Validate() error { if s.service1 == nil { return errors.New("Service1 is a requirement for Service") } //.. return nil } func NewService(config Config, dependencies ServiceDependencies, logOutput io.Writer) (*Service, error) { if err := dependencies.Validate(); err != nil { return errors.WithMessage(err, "Unable to create new Service") } // ... } ```
Separation of data and behaviour (in classes/oop you can define default values, not so in go), classes imply inheritance, go only has composition. 
Fun read, the entire porting portion is very well documented. Shame there aren't that mant resources on porting software like these across the *nixes. I want to ask you on the switch from TLS to a roll-your-own crypto, though. In the link you mention performance, I'm curious on how the old TLS implementation compares to the current Salsa implementation. I was under the impression that crypto is relatively fast and the bottleneck is going to be the network in most cases. There are too many pitfalls to avoid when writing crypto code that I would personally take the hit in reduced thoroughput for being able to rely on a battle-tested implementation and protocol. The time-based key change you mention sounds very interesting, by the way! Good luck with your project!
I have a weak 1 core server in DO. And the snappy part of it (pin) is a hungry compression. Actually it was added in some openvpn nightly builds but snappy never reached the release. When I tested pin with TLS and snappy the avg CPU usage was around 23 - 25 %. But under same conditions with salsa20, it was around 18 - 21%. And TLS was never an option. Just for the sake of encryption I added TLS. Not even trusted certificates. Switched to salsa20 and the performance and speed is pretty good. The bottleneck, considering the network link speed to be some constant upper limit, was always on the CPU. Also what I didn't mention was the effect of interface MTU on the throughput and CPU usage. When the MTU configured is high, (2000 or more) the CPU usage barely reached an 12% but the throughput will be really low. And obviously for low amounts the CPU usage was very high. (IP Buffers filling up real quick requiring snappy processing often). But It reached a highest speed and a acceptable CPU time, at 1300 - 1500 (MTU). So I tried to really trim the CPU usage as much as possible to make it run decent in a crappy server as mine without having to stop some processes. (Also added option to specify MTU)
You can replace that with your own string if you enclose it in backticks in the help string, like this: https://github.com/restic/restic/blob/master/cmd/restic/cmd_backup.go#L89
Some additional information: I'm using go-kit. I've traced the context through the endpoint/transport and it's getting passed around as expected.
Based on this: https://github.com/apache/thrift/pull/1459 Am I correct in understanding that I have to use HTTP as the transport? 
Basically. That might be a kind of interesting use case for my joke repo. Some middle ground between all js and noscript. Create an environment that can do basic page effects but not mess with localstorage cookies canvas etcetc
Thanks! That's very handy to know.
Unfortunately, cobra has the [exact same problem when integrated with viper](https://github.com/spf13/viper/issues/276).
We are using qor/admin and are happy so far. :)
You mentioned the word 'joke'. Chuck Norris doesn't joke. Here is a fact about Chuck Norris: &gt;Chuck Norris can judge a book by its cover.
Contexts don't get "passed" over the network at all. The client uses a context to cancel the request, and the server provides a context that can be used to check when the request has been canceled (e.g. due to connection closed), but they're not the same context and none of the values get serialized by the HTTP library.
This is awesome! Thanks for taking the time to take a look! I did have one question though about [these lines](https://github.com/hambletor/identicon/blob/master/identicon.go#L68-L86). Is there a reason that you're using `return func(...)` instead of defining it as a method of the struct? `func (i *Icon) ...()...`
I decided to sign up for the beginner's training. Although I've only been looking at it for a few weeks, the beginner's stuff might be too beginner, but it's cheap! Typically, I look for a conference and find out too late, but I was able to find it a few days ago, so went ahead and signed up.
Someone is fond of Lovecraft.
I never thought of that with your *[]comparable type. Because the pointer is pointing to the non slice one's memory space too. You are using two different types in one memory space. You kinda created a generic out of that. Lol that's awesome. I'll have to look at this tonight cause last night I did too many things.
&gt; What can you do with GO that you can't already do with python? Multithreading.
Woah woah woah! Slow down! do not ever rely on just one language. You don't have to forget one to learn another. In my workplace we use nearly 10 languages, all have their purpose. Use the right tool for the right job. Python is awesome for Machine learning (especially when building/training new models and experimentation). Go is awesome for writing servers and command line tools where performance is important. R is awesome for statistics. C is awesome for low low level systems. Rust is awesome for memory-safe systems, etc. 
Or Turing machines?
Yes, it is know as the [Functional Option](https://dave.cheney.net/2014/10/17/functional-options-for-friendly-apis) pattern. I discovered it a while ago reading [Dave Cheney's blog](https://dave.cheney.net/), then I saw it used again while watching some [JustForFunc](https://www.youtube.com/channel/UC_BzFbxG2za3bp5NRRRXJSw) episodes (highly recommend them, Francesc Campoy does a great job with a lot of different topics and they are entertaining as well as informative) In Go you can treat functions as parameters as they are treated as first class elements like a string or int... So what is happening is the Option is a type that represents a method on the Icon type, so I can then call the methods in the constructor New. It is a clever pattern that utilizes Go's capabilities to manage a challenging topic of how to configure your code. The first link I added goes over the progression of techniques finally getting to Functional Options. 
Replace Go with Japanese and Python with German. What can you do with Japanese that you can't already do in German? Or is the argument that Japanese just does it all better. I like Japanese and really want to learn it, but I have to learn German since the xxx. The question doesn't make that much sense. Better is relative. Go has some strengths, Python has some strengths. Most people learn more than one language, at least, partly.
I'd actually say the opposite is true. I'm a hobbyist developer and I'm coming from Python. That's all I know/knew. Now I'm learning Go because I need something faster than Python and Go is awesome at that. It is simple, minimal, non-bloated. I actually even think it is easier than Python, because there seems to be less syntax to learn.
\- concurrent programming \- systems programming is better in go You can almost do anything you want python but the above are some things go excel in.
Yeah, because Person is also Comparable, I can store them in the doglist too, as it is a \[\]Comparable. But the characteristics of Dog and Person get lost in that context. When iterating over the doglist, I can only use hash() and equals() on the elements, as these are the only safe operations on a Comparable. If I want to get a Persons age, I have to do a type switch on the element, as shown here: [https://play.golang.org/p/tE0dYt-cdEN](https://play.golang.org/p/tE0dYt-cdEN) So it is behaving as interfaces in Go should behave, or at least as I understood them.
\&gt;What can you do with GO that you can't already do with python? Get within a factor of 2 of the hardware's performance potential. Possibly less likely to have bugs due to the static type checking. All languages can do all the same things, its only a question of how long it takes to write the code, how likely the code is to be correct, and how fast it runs.
First it is called 'Go'. Second python and Go have as much in common as any other random picked languages: very few or a lot depending on who you ask. Both languages are turing-complete so you can do everything with both. Both python and Go provide good bindings for TensorFlow but if you want to get really serious look at C/C++. Next application development there are bindings for Qt and GTK+ for both languages. But again Qt is C++ and GTK+ is C. Go shines more on servers or in high concurrent tasks while python is a general-purpose-skripting-language for up to midsize projects. If you care about performance and know that concurrency will benefit you use Go. If you want fast development choose python.
&gt; What can you do with Japanese that you can't already do in German? Weird fetish porâ€” wait
Got me there. ðŸ˜€ Also following their theme of having a Cthulhu named go monorepo code base. â˜ºï¸
Oooh, cool. I use higher order functions all the time in JS, which I'm assuming are basically the same thing? Honestly, just didn't know that you could do that in Go. TIL!
By â€˜assemblyâ€™ do you mean the low level machine code? Also by â€˜multithreadingâ€™ is this synonymous with the notion of â€˜concurrencyâ€™?
I was being snarky. But yes. CPython sucks at concurrencyâ€¦ and all programming languages are turing complete and equivalent at some level. You will **never** end up in a situation where you only need to know a single programming language.
True.. Iâ€™m a minimalist at this point though since itâ€™s taken me a while to get a handle on python, so learning more languages at the same time is daunting. Iâ€™m coming from geology and not computer science. 
ðŸ˜†
Thatâ€™s true, and I like the comparison.. but I meant the question in the context of working with GIS mapping software (geospatial info systems) and mapping application development. So to push the analogy, learning German in the 18th century wouldâ€™ve been more prudent if I wanted to create navigational charts for Europeans. Whereas learning Japanese wouldâ€™ve been fun, but virtually useless at that time, and for that purpose. 
The more languages you learn, the easier it is to learn them. You start approaching new languages from the point of view of 'How does this language accomplish &lt;x&gt;, is it like &lt;y&gt; or &lt;z&gt;', and 'what new things does this language bring', and 'what is this language &lt;x&gt; really good at that is annoying to do in &lt;y&gt;'. The first few you learn will be a struggle, but it gets easier. You may want to learn some other useful languages as well, which may not be as applicable to your current use-case, but will help you learn new concepts and techniques. 
So clearly, you need to learn Python. If you want to learn Go, that's fine. It's not necessarily wrong to learn a language for the fun of it.
When you have a situation where your app suddenly receives extremely high throughput, Python will disappoint you, or force you to spend a lot of money on hosting (that has happened to me in the past, not just Python but Ruby and Perl disappoint equally). No amount of screwing around with gunicorn or uwsgi or replacing with PyPy will make Python run as fast as Go.
haha yeah Iâ€™m noticing that.. in order to webscrape using python Iâ€™ve had to learn javascript, html and css.. regarding language equivalence, do you mean (something like this)[https://akr.am/languages/]?
At my work, in my position, we use Python, C++, and Go. Other positions use a wider variety as well. Many developers are familiar with at least 6. My background was in Econ and then I got a Masters of Analytics just last year. I started learning to program in my masters and since then Iâ€™ve learned (or at least used in some minor way) C, C++, Python, R, Java, JavaScript, Go, and SQL. Donâ€™t be afraid to try and learn the fundamentals of another language! It may seem daunting but I think youâ€™ll be surprised how well your mind can keep the two apart, because in most cases, they solve different problems using different logic
The standard library flag package has the disadvantage that it doesn't match how normal Unix commands accept flags (even beyond long flags). Many people expect that you can use, eg, `fgrep -il ...` to specify multiple boolean flags at once; Go's standard library doesn't accept this and so any Go commands using it will be subtly different from regular Unix commands. If you're trying to use Go to write a program with flags where people using it don't have to remember this peculiarity, you wind up wanting another flag package.
Did you just send a steam of data into one memory space, split it up generically with custom types for comparison, and then recombine it? That's pretty neat stuff man.
go-kit contains special support for extracting tracing span information from a context, serializing it into the HTTP request, and then unpacking it again on the server side to place into the server-side context. This isn't a general mechanism, since it can only do this for context data keys it specifically recognizes. For example, see [the code that copies opentracing data into the HTTP request](https://github.com/go-kit/kit/blob/37dd21e10ccb4761e161e7264a5984f770ea18a5/tracing/opentracing/http.go#L19-L47).
Right, Erlang is not known for it's speed, especially with IO. But it is known for it's performance in concurrent and distributed computing, which is what the article is highlighting, not speed.