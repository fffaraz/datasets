oh my gosh, really? haha isn't that an interactive shell, like it runs go code like you could run python code by running the python command? what i wrote is like a bash but written in go.
Oh yea it is, my bad That being said, theres also a shell framework in Go called Gosh haha
Where do they belong? 
IMHO not having „generics“ isn‘t a lack of feature! If someone really understands what „generics“ are and knows the price languages should pay to support them, then they might not see this as a language con. Golang does not have nor supports generics and thus gets more popular each day. language creators face problems and by making their language, they try to handle this problems. When they don’t put „a feature“ into a language, they might want to avoid „future problems“! One of the biggest features of Golang, as others might accept it, is that „golang does not have many features“! Golang is based on older (in this case C) languages and again, i think its for those who don’t care „how shiny their language of choice“ is, they just want to do the job and get done with it. Remember, creators of golang also worked on C (Rob Pike). If you still ask, and think of this as a lack of feature, then I‘d say take another look at „why golang was created at the first place“. Golang‘s philosophy is to be simple as possible, as it’s makers (Ken Thompson) has always insisted on this philosophy.
You are right, but i want to point out that I did not make a blanket statement. I said "*tends* to be more efficient". Its always an "it depends" but if you find yourself with a very large struct that contains an array of structs then it might make sense to do something like this. Always profile it though
Reminds me a little bit of LTSpice :) &amp;#x200B;
You are correct that arrays are what I meant (hence why i reneged on slice in my original post) but also misconstruing what i said. I did not say use your intuition to decide. You should profile both cases and see for yourself if its the right decision. Its not uncommon for a struct to contain an array of structs and so this is not an "almost never true" situation. Less common yes but not uncommon. Additionally, your definition of "matter" differs from others. If passing by reference saves 2 ms over 1000 loops that may matter to one person but not to another. I dont try and assume what applications you write.
Its simpler and provides a read only view of the data which can be nice. You can be sure that a function will not mutate the callers version of the struct. For example, printing a struct by passing via value would be nice if you wanted to be sure that the print function didnt accidentally mutate your struct under you.
LTspice is great tool!!! But but my simulator is more focused on the solving of DC (and especially sinusoidal) circuits from a course of theoretical electrical engineering.
Plans to add an graphical "Drag&amp;Drop"-Interface for circuit creation ? Nevertheless great work so far and easy to use with a browser :)
go-swagger, twirp all do something similar. 
Thanks!!! In this form, the simulator works in any browser (for example - simulation in Lynx :-) [https://acdc.foxylab.com/sites/default/files/foxysim\_lynx\_inp.png](https://acdc.foxylab.com/sites/default/files/foxysim_lynx_inp.png) [https://acdc.foxylab.com/sites/default/files/foxysim\_lynx\_res.png](https://acdc.foxylab.com/sites/default/files/foxysim_lynx_res.png) And on the smartphone is IMHO not very convenient to drag components. Therefore, while the graphical interface is not planning.
I think you could achieve this really but really easy within a kubernetes cluster. It does exactly what you are describing. 
I think this is a good idea. We are fully invested in dep at work with no plans for Go modules (too many problems with existing &gt;v2 projects vs dep). Transfering the repo would signal that dep is still being actively developed. It was never developed by the Go team anyway, so it never really belonged in github.com/golang.
&amp;#x200B; I think if they talk to one database it might affect the fact that "services can scale independently" and might introduce a single point of failure. &amp;#x200B; Just thinking out loud, I am interested in this topic too.
Why?
Clever code is the worst, no matter what language.
Reminds me of [Kernighan's law](http://www.andhapp.com/blog/2010/03/07/kernighans-law/)
Hah, thanks for reminding me of this one, great quote!
You should rename it to goash (GO Again SHell). :) Although I suspect this name is already taken too.
Is it POSIX compliant shell?
Can’t you simply do exactly this by passing Chan that goroute checks periodically for commands and making it effectively a thread Id. Ofc everything depends what you do in goroutines but as far as I recall there is no guarantee that pthread threads cancel will instant kill it without any lag.
Did you mean to ask that to yourself?
Looks you really care. Why? I shouldn't express my opinion?
Interesting. I am an on'n'off user of this Go-based shell: - https://github.com/elves/elvish
Why not? 
Any screenshots?
&gt; Python is so expressive, it's easy to do some really cool things in only a few lines of code Interesting, this was actually one of the things that I really learned to love about Go. To me, reducing the amount of things happening in a single line of code makes significantly improves readability and makes it easier for new programmers to pick up. I still dread reading perl scripts where someone got fancy and decided to write everything into a single line of code.
Most common scenario I've come across where it's helpful is when dealing with a context for timeouts. Something like this: select { case work := &lt;- workChannel: // do something case &lt;-ctx.Done(): // timeout waiting for something }
Given that using reflection can be dangerous, shouldn't it be complex? Making it complex helps discourage it's use
I think there's a difference between being too clever (Bad Programmer), being too obscure (Bad language - AKA: Perl), and being expressive. Expressive means that the thing that I'm doing is idiomatic for the language and contains one easy to comprehend concept. You can't tell me that the gist I posted of sorting map keys is a concept complicated enough to merit all that boilerplate code. While I appreciate the simplicity of Go, my point was that it often operates at too low a level.
The \* operator is used in two ways, when used with a type it represents a pointer to that type and when working with a variable its used to de-reference a pointer into the underlying value. The &amp; operator is used to take a pointer of a value. The := operator is just a convenient method of allocating a new variable without having to specify the type, the compiler infers it. \`\`\` // creates a new instance of myStruct var foo myStruct = myStruct{} // creates a new instance of myStruct and assigns it's pointer to foo2 var foo2 \*myStruct = &amp;myStruct{} &amp;#x200B; // using \* on foo2 will give you access to the underlying value, in this case an instance of myStruct var foo3 myStruct = \*foo2 \`\`\`
Type embedding like this is similar to creating a field in T of type *S. You can actually access that field like this, which could be done to create a T out of a *S: s := &amp;S{"blah"} var t T t.S = s
How would this protocol work with thousands of peers?
Have any good resources you can share on understanding that cost? 
This was a pretty cool talk on visualizing concurrency with Go routines. Helped me wrap my head around a few different use-cases. https://www.youtube.com/watch?v=KyuFeiG3Y60
Yeah, I can empathize with you there. I hated GOPATH when I first started with Go. Was super glad when Go 1.11 was released and I wasn't bound by that constraint anymore. 
There's a lot of use-cases for it outside of channels as well, especially in the context on HTTP APIs. Using it in HTTP handlers for Deadline timeouts makes it incredibly easy to short circuit requests (and all sub-requests!) when the handler is running longer than expected.
There should be a reason for the new shell. How is it different from the existing ones, which are well tested?
First of all it is required to have experience with plenty of web frameworks of different programming languages, i.e Java(JSF, Spring), C#( .NET Core, ASP.NET). After that you have to use or at least read the code of other Go web frameworks, the most trending ones are the https://github.com/kataras/iris (new, growing popularity) and https://github.com/gin-gonic/gin. Their code base is actually maintanable and a lot easier to read than the rest, good luck on your journey!
Learning purposes or just for fun are pretty valid reasons for me, which I assume are OP's
&gt; errors on unused imports, variables etc. This is actually something I wish more languages would do. It helps keep the code cleaner when you know that everything you're seeing is still being used and is needed. I've seen way too many PHP code bases where 90% of the variables in a file weren't being used anymore but you couldn't tell because it was lost in the spaghetti code. If you haven't yet, checkout `goimports`, it solves a lot of those issues for you automatically. 
I definitely agree with you on dealing with collections, there shouldn't be so much boilerplate to work with effectively. I also agree there's a difference between being too clever, too obscure, and being expressive, I was mainly highlighting that because Go is expressive, it makes it harder to be clever, at least in the traditional sense of shoving things into one line.
Part of go's appeal is getting away from all the magical shit that Django and Rails does
[removed]
Thanks! I work with Spring on a daily basis and have a good amount of experience with Expressjs and Django. But I do need to go through some go source code. Thanks!
&gt; because Go is expressive, it makes it harder to be clever Agreed! That is a good point, and also a welcome feature.
[removed]
Yep, I haven't totally gotten past this yet, but have felt like there's a better go centric way to be discovered. Got any tips or links to point me in the right direction?
Which is a compelling reason for generics as nice libraries doing exactly this would be possible if they were introduced.
I just stumbled on an article today talking about “gotchas” when using append, and I recalled a bullet point that said “use append only to append new value to given slice, not to create new one.” From what I’m seeing in your code, I think you’re doing what he cautions against. I’m on mobile or I’d try it out myself, but give the article a read. It’s pretty short. I think the section about the “copAndAppend” function might be what you’re looking for. https://medium.com/@Jarema./golang-slice-append-gotcha-e9020ff37374
Not using `interface{}` for all your data is probably the best solution; using structs is almost always better.
Pick a struct from another package, one with a field containing a slice or a map. It'd be really nice to be able to lock that, right? // package external type Thing struct { Pizza []byte Topping string } // package main type hut struct { sync.RWMutex external.Thing } func (p hut) Eat() { p.Lock() defer p.Unlock() if len(p.Pizza) &lt; 1 { p.Pizza = p[1:] return } panic("out of pizza") } The hut type has composited the methods on sync.RWMutex with the struct fields on external.Thing. So long as there aren't any shared (exported) field names or methods, it's as though they are one unified new type rather than two sub-types of a struct type accessed through specific names.
Strings:) There’s a lot of languages now that can deal with enums being of many different types and converting to/from the basic type to the enum. It’s especially useful if you get data from the outside world, such as json. Then I can convert the string into the enum, and if there isn’t a match it gives me an error. An example of such a language is Swift (but that’s not the only one). Tying to build that functionality in go requires more boilerplate than what it’s worth. That said, i’m firmly against adding things to a language just because someone (in this case me) misses it from another language. There needs to be more compelling reasons. Enums are really ints, a la C, are quite limited these days for certain types of applications. YMMV.
I've personally used Esc for a few years now. [https://github.com/mjibson/esc](https://github.com/mjibson/esc). Works a lot like biodata, rice, etc...
Was expecting Angus. 
On line 15 of your example youre setting the first element in the []interface{} to the array stored in the map value. That's not a cast or a expansion of the values. I think your issue is you're starting with an int and then initializing your slice with that value, but it doesn't work once the value becomes another slice. You have to expand that slice if you're looking to initialize a new slice, or rather than initialize a new slice with []interface{m['hash']}, you need to cast it like m['hash'].([] interface {}).... I have to ask though, this all seems really brittle and complex. What are you trying to accomplish in taking this approach?
That worked! Thank you for explaining that. I'm still wrapping my brain around Go and how different (and how much simpler) it is compared to the languages that I'm used to.
My understanding was that even reading is not thread safe even though it might usually work. 
A+ name
Yeah, I was afraid of that
``` for i := 0; i &lt; 5; i++ { if temp["test1"] != nil { temp["test1"] = append(temp["test1"].([]interface{}), i) } else { temp["test1"] = []interface{}{i} } } fmt.Println(temp["test1"]) output [0 1 2 3 4] ``` Thanks for the suggestion, its finally working. Basically I'm trying to create an in-memory datastore, similar to redis or memcached, but a really simplified version. I'm trying to reuse as much code as I can for my projects, so for example having a predefined `User` with username, password etc. However, once I import this code into a new project I need to add more fields to it, eg. `User["Todos"]`, which wouldn't be possible with structs as you can't dynamically add fields, whereas you can dynamically add fields (interface{}) to a map.
[removed]
GASH (Go Again SHell)
Beego, gin-gonic, echo, revel, go-kit (micro services, similar to dropwizard). Too many already, Gin has most GitHub stars and it the most popular among these right now 
haven't you ever done something just to do it and learn?
Oh my gosh this is great
Looks you have got it. In fact, you don't need an if-else block: for i := 0; i &lt; 5; i++ { old, _ := temp["test1"].([]interface{}) temp["test1"] = append(old, i) } 
&gt; From what I’m seeing in your code, I think you’re doing what he cautions against. He is creating a new slice with every append call.
Maybe these youtube video downloader can give you some ideas on how to access the video content: - https://github.com/rylio/ytdl - https://github.com/kkdai/youtube
They seem to be maintaining github.com/satori/go.uuid after it was abandoned with some critical issues, so that's nice.
interesting use case. maybe give [https://github.com/patrickmn/go-cache](https://github.com/patrickmn/go-cache) a look, if you haven't yet. Sounds like it might be aligned with what you're trying to do. 
I've struggled understanding how to use concurrency. Architecting my code using interfaces for polymorphism. And also, I had quite a hard time learning cgo. Especially passing function pointers, or struct arrays. Cross compiling cgo code was also difficult.
The website doesn't have to be public, it just needs to be accessible from go.
Upload to S3 first and you can hit 250MB.
Examine the response from www.youtube.com in your browser's dev tools (networking tab) and you'll see that content comes many domains other than www.youtube.com. There are probably a number of other issues that require a more comprehensive understanding of HTTP(S) and how content is served, including JS, and stuff like content policies, etc.
iris-go is actually kataras. As you can see, he is sneakily trying to promote his project yet again by mentioning it first while ignoring other projects. &amp;#x200B; If you don't know who kataras is, check out this blog post: [http://www.florinpatan.ro/2016/10/why-you-should-not-use-iris-for-your-go.html](http://www.florinpatan.ro/2016/10/why-you-should-not-use-iris-for-your-go.html)
I absolutely adore the name. Hah! Probably won’t be enough to move me off bash (please don’t hurt me), but I applaud the effort. 
It's the Go community like golang-standards: [https://github.com/golang-standards/project-layout](https://github.com/golang-standards/project-layout)
I recently started using defer for a really nice way to format server logs on a web app. I’m on mobile so excuse my formatting. ` defer func(startTime time.Time, r *http.Request) { elapsed := time.Now().Sub(startTime) log.Println(elapsed, r.URL.String()) }(time.Now(), r) `
Youtube might be using quic. i'd try something non-google - if you want video go for twitch or vimeo.
interface{} is often very useful for functions that need some arbitrary work done on the data, like in a library. Rarely useful in your own code unless you’re also writing a library. Using interface{} often breaks the type checking that makes a strongly typed language so safe to run in production. 
While I agree that it does that, I often miss the nice “just works” of rails. Things like templating and automatically adding XSRF tokens is really powerful. Too many apps, not just go, have vulnerabilities that are so well known but someone just “forgot” about it. I’m glad I’m writing an API app now instead of a web app. 
Async read/writing sockets, and closing them. Easy to deal with them when just opening and being happy they’re there, but I constantly leak goroutines when sockets close. Learning now, but damn, I wish there was just a nice library that would take a io.ReaderWriter and deal with that shit for me. 
Gonna read through this tomorrow. I chose to do a full microservices architecture. Always weary of serverless. I can easily see the benefit of a microservices but can’t see why I would want to be vendor locked. :(
It's not "go way". You've just learning how to do OO correctly in general. 
That's an interesting use case, but I have to wonder about the legitimacy of representing a limited number of states using an arbitrary-length data structure. Is that a web thing?
Damnn I forgot about this completely! Thanks
Definetly not
That looks pretty cool, I'm tempted to give it a Go
I'll definetly add some once I make it look a little bit prettier.
The way we set stuff up is the backend is always an API, it just returns json. Then our frontends can either be a SPA, mobile app, web app, whatever. They're always completely separate though.
The reasons why Go doesn't have feature x is because it would impede compilation times. The supposed "clean" design of the language is an after thought. Go in a way is a wonderfully broken language.
Yeah, there are definitely legitimate uses of `interface{}`, and I can't be sure, but reading the post here I'm not so sure this is an example of that.
I use it myself for a PrintJSON(interface{}) function. Basically just log prints a json.MarshalIndent. It’s a good use cause I just pass it along. Sometimes in api code I’ll use it. But generally I can’t think of a time I would use it when I know what’s coming in. Often better to use an interface instead. 
Now, greedy gophers want fewer CPU consuming percentage on GC. ;)
I switched to https://github.com/google/uuid after the incident[1]. [1] A backwards incompatible change was made breaking a lot of packages.
I'm looking for feedback for this proposal. For example, are there any design flaws and shortcomings in it? Any improvement ideas are also welcome.
I am greedy on performance too. but on my system, the GCCPUFraction value returned by runtime.ReadMemStats is 0.006678, so without considering the penalties caused by GC's write barrier, 0.67% of available CPU time was spent by GC. &amp;#x200B; 
my main grip with `elvish` is the behaviour of the TAB-completion: - https://github.com/elves/elvish/issues/672 it would be my main shell otherwise...
You would be surprised how far you can go without choosing any. Give it a go first
Oh, thanks was thinking will use a basic router like chi, and not a full fledged framework
Chi is awesome and a good choice too.
It depends on how you write code I guess. I like to set up the structure first and then do the implementation. This is difficult in golang because it does not compile when I added everything I know I will need later. Removing unused things should always be a step in the DoD, Thanks for the tip about goimports.
The goal of dep is "an official experiment". When the goal change it'll be less confusing to just fork and rename the project.
dep as never been something else than "an (official) experiment".
Out of curiosity, what makes Go's GC so good? Are these mostly careful microoptimizations or is the design radically different from other GCs? Is there a paper explaining its design?
GC is optimized for low latency rather than throughput. The fact that Go is such a simple language also helps. 
[https://blog.plan99.net/modern-garbage-collection-911ef4f8bd8e](https://blog.plan99.net/modern-garbage-collection-911ef4f8bd8e)
To me it sounds like an interesting and fun project, though I have to point out that I don't think it has a use. The thing I love about go is the fact that you can build apps without having to rely on frameworks. That being said, you should go ahead with the project. I think you will learn a lot from it. I would also love to try it out :)
Go luck!
I think if you want feature complete + flexible it inherently means more magic, conventions, config and complexity, javas spring framework being apinnacle example. Those frameworks have a time and place, but many people and especialy gophers prefer simpler, quicker, easier. If you make it simpler you will always loose some of the flexibility and features, hence the explosion of "simple" and "small" web frameworks. This is much more in the realm of right tool for the job and you can get a great, simple service written. However, I think this has been a problem around long enough and solved enough times that really its already been done or really there is a web framework out being used and may benefit from a feature being added or something simplified / improved and get you where you want to be. For me I think rest api's are shifting to documentation first and codegen. I find them better to work with and reason/understand. In particular I would suggest swagger and for go, go-swagger. Although its not the right tool for the job always, GraphQL I quite like too.
The readme of https://github.com/gofrs/uuid is very confusing from a new organisation and new package : &gt; It is recommended to use a package manager like dep &gt; As of v3.2.0, this repository no longer adopts Go modules Looks like gofrs is an organisation to help people who don't want to jump in go module wagon. Let's see if it's going somewhere... I'm switching from gofrs/uuid to google/uuid !
Chi is just a router, not a framework and just plugs into the stdlib.
In addition to what shovelpost has said, iris is also not new - it's been around for years now, and has never been appealing.
Also this: [https://making.pusher.com/golangs-real-time-gc-in-theory-and-practice/](https://making.pusher.com/golangs-real-time-gc-in-theory-and-practice/)
The thing about exceptions is that you can write: x := fooWhichMightThrow() instead of if x, err := fooWhichMightThrow(); err != nil { return err } In other words, the common case of simply propagating the error to the caller is handled for you. Compare this to Rust, which has a similar error handling philosophy but adds some syntactic sugar on top: let x = fooWhichMightThrow()?; ^--- unwrap the Result and return the contained Err, if any I find myself using this syntax _a lot_, which indicates how much more verbose things would have been in Go.
I found reflection hard: both struct inspection and setting values. Especially as I was using pointers a lot so I could capture nil fields vs empty fields. 
Don't you have a reverse proxy or something before your go endpoints to filter that traffic out? Should be terminated as soon as possible.
"Optimizing" away an if statement at the expense of code quality seems absurd, especially within the context of network requests.
Probably. Our company is like a black box though. I write services and assume everything that calls is it will probably do it wrong.
Thanks!! Glad you found it useful so far! And I agree, there's a lot of work to do, and the tooling is actually pretty hopeless for local testing at the moment. There's a few useful third-party solution, but some of them don't work for Go annoyingly!! Hopefully I'll address some of these issues in this series. But there's still a few unknowns/frustrations. 
https://blog.golang.org/ismmkeynote
Thanks! I'll let you know how it pans out
Yeah I agree, I think go could use a little bit of "secret sauce" although most seem to disagree.
Aside from whether or not this is a good idea as such, did you measure the performance different of this `if` check? I'd be surprised if a simple string check would show up to be honest, but I could be wrong. Either way, when talking about performance: measure, measure, measure. Otherwise you're just arguing without any data. With measurements, you can make a rational trade-off: "yes, this will make the code quality worse, but it gives us a 59% performance boost", or "no, this change will only give us a 0.001% performance boost, and isn't worth it".
The only one cooler would have to be "go in the shell" xD
Sweet! Now make it cute! ;)
I wonder if this would be better as a Node project...
Then you definetly should check everything, right?
Exactly, but that safe approach is more how I’ve been taught, not how the company promotes we should write Go.
Thanks a lot!
If you have to use a switch every time you want to use an instance of a type, that instance's typing isn't doing enough work. At least as far as idiomatic Go is concerned.
We obviously use enums in very different ways. 
Today my friend said he will provide release binaries to so you can install it without Go 1.11
ready
With this CLI you can autocomplete GraphQL queries, get help about possible queries and fetch full objects from graphql server
Without starting a flame war, I expect the introduction of generics will negatively impact this?
I wouldn't expect it to. The current proposed design resolves all types at compile time, so the resulting source code is equivalent to current Go code. If anything, while generics won't have a direct effect, the ability to write more code using value types and stack-allocatable types, because of the decreased need for interface{} in data types and the ability to use more appropriate data types because more will be available, should generally make it even easier to have less garbage generated in the first place. It won't be an automatic event, just that it will be possible to generate better code like that as we get used to it.
Not necessarily, remember that Go is a compiled language, so the generic functions/containers will be compiled when you run the code. There may be some compiler slow down though. 
lol, nothing would ever be better as a node project :P An interesting language in the JVM sphere I find is Kotlin, I havnt seen a nice little simple web framework. Ktor is interesting, kinda like Gorilla mux for go. I'd absolutly love to see a kotlin-swagger implemenation based off of ktor, its a large undertaking but the basic get with a model would be fairly easy. There are some Java ones and I think a kotlin one but last time I checked they were all spring or something like that, like 100Mb of dependencies to serve GET /hello/world or something stupid. &amp;#x200B;
Welcome star My GitHub repository! :)
Go's GC can be low-latency because it's not a generational (or "moving") garbage collector. Most languages use generational collectors because they make allocations cheap and short-lived objects can be freed virtually for free--these are important properties for object-oriented and functional languages which allocate frequently (in most of these languages, every object is heap-allocated); however, Go has value types (i.e., data can live on the stack) and they're used pervasively in idiomatic code (also, it's often easy enough to move heap allocated objects to the stack), so Go wouldn't get as much lift as other languages from a generational collector (although allocations would be cheaper).
I don't think the language helps because it's particularly *simple*, but it does help. The main thing is that Go, unlike Java, JavaScript, and (to a lesser extent) C# stores variables and fields inline. In Java, if you have a variable or field of class Foo, that means you really have a pointer to a Foo that is always allocated on the heap. In Go, if you have a variable or field of struct Foo, the bytes for that Foo are stored right there. If it's a local variable, they are on the stack. If it's a field, it is in the chunk of memory allocated for the surrounding object. In practice, this means Go allocates fewer objects that need GC at all, and when it does, you tend to get a smaller number of larger objects instead of a cloud of tiny objects all pointing to each other like you get in Java. One way to look at this is that Go's GC does a better job because it has an easier job. Another way to look at it is that the language designers deliberately designed Go to make this feasible. I think the latter is a fairer perspective.
Packages names like `util`, `common`, etc. are indeed bad, but they're not always bad because you end up importing them into other packages. Utility packages on their own aren't always bad, it's just usually better to name the packages more clearly. Using the domain of the package generally helps, similar to how `httputil` is a thing, it's a utility package for HTTP - that's much better than a catch-all `util` package. That said, often you'll find if you name packages correctly the word `util` doesn't even need to make it's way in. If there is some significant code that needs to be used by more than one package though, centralising it is probably a good idea. Either that, or it may be an indication that all packages involved should be one single package.
It will probably increase the compile-times to some slightly noticeable amount.
Unless you're really itching to learn how logging libraries work in great detail, or are really just planning on using this to learn, then I'd maybe pick a more complex / less overdone problem to solve. There are quite a few logging libraries for Go already that are fantastic. Uber's Zap is a great one, many times faster than Logrus, and supports structured logging. If you did want to continue working on this, then I'd take a look at the features you could implement from those libraries, and bear in mind that for logging, performance can be quite important - I've had a few applications speed up a noticeable amount just by reducing logging, and swapping Logrus to Zap. As others have said, it's quite easy to do many of the things your library is doing with the standard library. In fact, when you look at `logger.go`, all of the functions are 1 liners, and the arguments are the same as the fmt function calls' arguments, except you're just using the struct to set the writer once - but that's not really worth importing another dependency for. The file logger seems to be the exception to that, but there you could actually avoid a bunch of duplicate code by storing the writer you create on the Logger struct. In fact, it seems like it'd be better to get rid of that whole package, and just make a constructor function in your top-level package that makes that writer and returns a logger with the writer as it's Target, like this: https://play.golang.org/p/jpMeGWdh-A1 Where I work we have a logging library, but it only exists to provide an interface. We use that same interface across all of our applications, but have been able to swap logging libraries in the past. It doesn't actually contain any logging logic, it just provides a nice way to construct a logger, and then using it is the same everywhere. You might find that developing something like that for your own applications is quite useful.
This, but maybe look at using Go Modules for new projects - dep hasn't had any updates since October last year when Go Modules really started to pick up.
Interesting, I’ve been using it for 2 years and have had only one major issue, other than an incident in late last year I’ve had zero outages for anything.
Awesome usecase. Would be great if you put that as wel as a reaction on the blog itself so you can score some more points with the readers of my blog.
Yeah that's why I wrote my own alternative: * https://github.com/skx/implant Seems like I'm not alone, these tools aren't hard to write after all.
BTW, a more readable shorthand for `elapsed := time.Now().Sub(startTime)` is `elapsed := time.Since(startTime)`.
I habitually check the method type, because to my mind, in the sense than an HTTP request is a "method invocation" \[1\], I consider the name of the method to be the URL _and_ the verb used to get it. I don't think it's necessarily a viable strategy to try to throw all verbs through one method. In those cases in Go where I do indeed want to handle multiple methods, generally the handlers look like this for me: func Handler(rw http.ResponseWriter, req *http.Request) { switch req.Method { case "GET": HandlerGetVersion(rw, req) case "POST": HandlerPostVersion(rw, req) default: handleUnknownMethod(rw, req) } (Properly formatted, of course, I just banged that out.) But my perception is that I'm in the minority. But the reason I try to stay in this habit is that it's a good idea to make sure in a handler that you _know_ what the method is, so you don't accidentally mutate something in a GET. In particular, it is actually fairly important and can even become a low-grade security bug in combination with other things like caching if you write a handler intending to receive POST data but it turns out you can cause the state mutation using a GET request. (This is particularly magnified in environments that conflate form parameters with querystring parameters.) That's the biggest problem that comes in practice from not checking the method. I solve this by just always being careful about the method, which is cognitively simpler for me to maintain as a discipline than conditionalizing that on the specific verbs involved. \[1\]: That is, of course it isn't, an HTTP request is pretty complicated and is its own thing. But if you think of it as one, this is how I think of it.
I'm still missing a functionality to just allocate a memory chunk as unsafe.Pointer and free it at the moment when I actually want to free it.
So far, modules hasn’t been production ready for me. But yes, that seems to be the future. 
Not simply. You can get some of the same semantics if you control all of the code, but this means it shouldn't cross API boundaries. It's better to just embrace the paradigm than to fight against it.
&gt; If someone really understands what „generics“ are and knows the price languages should pay to support them Go already pays that price while not having them, since 'interface{}' is boxed.
&gt; The current proposed design resolves all types at compile time, so the resulting source code is equivalent to current Go code. To the best of my knowledge, the plan is to instantiate *types* at compile time, but not *functions*. That is, a generic function call will roughly work like passing an interface currently, likely including the allocation overhead (the generic function doesn't know the size of the argument, so args can't just be passed on the stack). That means, programs using generic datatypes/containers that currently use `interface{}` (think `container/list` or its cousin `context`) might get a little bit more efficient. Meanwhile, programs that replace monomorphic by polymorphic function calls (e.g. using a generic `math.Max` instead of an inline-comparison or generated function) might get a little bit less efficient. Personally, I expect the result to be pretty much a wash, because I'd expect that most function-calls that will be polymorphic in the future are polymorphic now (via interfaces) and that not a lot of programs will benefit from the compile-time instantiation of types. But there will probably some cases where this goes one way or the other. We'll see.
This post contains a number of inaccuracies and misrepresentations about both garbage collection and Go.
You can totally do that using `mmap`. The main issue you will run into with that is that the GC won't like if you have Go-pointers and non-pointers at the same addresses, but you can probably still do many if not most interesting things by adhering to the [cgo rules](https://golang.org/cmd/cgo/#hdr-Passing_pointers) (effectively, every pointer pointing at your `mmap`ed area is a C-pointer). The fact that this is possible, but not a widely used mechanism, should serve as a hint though, how good of an idea this is.
If you consider this then I guess the APIs are not restful. Then for GET requests it’s probably “safe” to remove the check. I would not do it cause micro optimization is a bad thing and also, it goes against how a developer expect things to work. HEAD requests will work but also send the data. That can be a problem.
Wow, that's an interesting story.
Thank you. I'm gonna look into it... Is it going to work on any OS with no need for gcc/cgo?
That sounds disappointing if accurate. I thought most of the benefit of generics came from monomorphization (at the expense of some binary bloat). I guess it's still easier to express things, but I don't like paying for it with a virtual call.
Yeah, making something like Java pausless ala Azul required an extremely expensive read barrier since the pointer locations change during GC. They actually hardware accelerated this in their custom processors. For normal x86/amd64, they ended up writing custom kernel patches to speed up stuff (TLB flushing?) and it ended up costing something like 30% throughput. That's all info from years back, no idea what it looks like now, though I do know mainline Java has a couple low-latency, lower-throughput GCs in development.
Sounds like you're leaking goroutines. How do you reuse them? This is usually done by a worker pool: https://gobyexample.com/worker-pools
In addition to what everyone else pointed out, Go pervasively encourages and utilizes C-like efficiency in memory reuse, what with array slices utilizing a backing buffer and stack allocation. There's just less GC work to do compared to Java.
My favorite part of this graph is that the scale is in microseconds, not millis.
&gt; I thought most of the benefit of generics came from monomorphization That's a misconception. In fact, I've argued in the past (and I'd still argue) that it's impossible for generics to improve performance over interfaces - because if the compiler can prove the static types a generic function is instantiated with, it can also prove the static types you pass as an interface value. And do the same style of devirtualization. The advantage of generics is that it offers you a more powerful type-system, so you can encode stronger, compiler-checked invariants into the types. &gt; I guess it's still easier to express things, but I don't like paying for it with a virtual call. One design goal of the contracts design is that an implementation can choose where on the spectrum of dynamic to static instantiation it wants to fall. That means a) if the gains prove high enough, gc might later start instantiating functions at compile time and b) it would be possible for an alternative implementation (e.g. gccgo or something completely third-party) to trade off compile-time for speed. But, honestly, all of this is pure speculation at this point. It's not even clear that it's *possible* to implement the contracts design as is - much less how that implementation will look. We'll have to wait and see - probably more than a year.
I almost always return a suitably modified error and not the original, because the original error will usually not be helpful. So my code looks more like this: if x, err := fooWhichMightFail(); err != nil { return Fail("the foo failed because of some particular reason: %s", err) }
&gt; any more hints how to do alloc() / free() You want to use [mmap](https://godoc.org/golang.org/x/sys/unix#Mmap) and [munmap](https://godoc.org/golang.org/x/sys/unix#Munmap) with [MAP_ANONYMOUS](https://godoc.org/golang.org/x/sys/unix#MAP_ANONYMOUS). You are probably going to have to either write your own allocator to amortize the overhead (you can only map full pages and you wouldn't want to do that for *every allocation*), or only use this for large areas of homogenous values. &gt; Is it going to work on any OS with no need for gcc/cgo? No need for cgo. It *is* OS specific, but I'd assume any OS Go runs on supports something like it. After all, the runtime needs to allocate memory somehow - you are simply doing the same thing its doing. `mmap` and `munmap` are POSIX-specified, so they should work on all unix-like OSes (Linux, \*BSD, Darwin) and probably (?) windows. I don't know about Plan 9 and I don't know about other OSes Go supports. It won't work on js/wasm, I guess, and neither in other sandboxed environments. But really, just look at how the runtime allocates memory on your favorite OS. Then do the same. --- (though, again, to disclaim: I actually should say *don't* do the same, because it's a bad idea, but if you're hellbent on doing it, that'd be the way to do it)
I've worked on Java projects where GC pauses were in the tens of seconds. Go's GC is amazing.
malloc isn't a kernel call in C. just a library. In linux it can call the kernel if it needs to get more space, in older implementations sbrk'ing some more space ( extending the process memory space at the end ) or using mmap to map in some new memory these days, but most of your malloc calls should stay in userland. Taking locks to do these things safely under linux should only have to call the kernel if taking the futex the lock is based on is contended.
My apologies; now that you remind me and I refresh my understanding, that is correct.
Yeah exatly I use a worker pool of go-routine, so you suggest to check the implementation of the worker pool?
And what's the upside? I mean, couldn't I just create a struct and then, when necessary, pass its reference?
look at the go source. find the \`mallocgc()\` function in src/runtime/malloc.go 
To you first question: Go uses a custom allocator that does allocate in spans much like the JVM. I can really encourage to read more about it, it is very interesting. To your second point: No, you can not force Go to allocate on the heap or stack, even new or make can place their values on the stack. One thing you can do however is providing the compiler flags which will print out any information about its escape analysis (compile with `-gcflags '-m'`), This article does not Go into lots of details but it is informative enough to spark interest: https://about.sourcegraph.com/go/gophercon-2018-allocator-wrestling/
&gt; It still seems to me it shouldn't affect GC either way. Again, depends a bit on the program :) For example, if you use `container/list` with a non-pointer-shaped value currently, you incur two allocations per Node - one for the node, one for the `interface{}` value contained in it. A generic list would only need one allocation, as the value can become a field in the type. So garbage might go down, which is one of the best ways to reduce GC pause times. This might actually be interesting for `context`. [context.WithValue](https://godoc.org/context#WithValue) could become a generic `func WithValue(type K, V) WithValue(ctx Context, key K, val V) Context`, returning a [valueCtx(K, V)](https://golang.org/src/context/context.go#L480). The latter thing would be a generic struct-type, instantiated by the compiler - and if the compiler is sufficiently clever (which isn't super unlikely in this case: `WithValue` would become a trivial function that just returns a struct-literal, so it could be inlined and thus trivially devirtualized), you could get any usage of `WithValue` with non-pointer-shaped key/value down from 3 allocations to 1. And `context.Context` is used widely enough that it might matter. *Will* it matter? I doubt it too :)
Make an interface with GetContents and other methods that you plan to use on Repository and pass that to your function. In test you pass in your mock that implements the same interface. You can also take a look at net/http/httptest and see if that fits your needs.
For debugging you could print out the numbers of goroutines periodically with `runtime.NumGoroutine()`.
Thanks for the clarification. I remove the reference to malloc.
If you are trying to forward the conn to proxy, wouldn't you want to `io.Copy(&amp;buf, conn)` instead of trying to read the destination connection? I'm not sure I understand the two goroutines. My thought would be that you would first copy from conn to proxy, and then if you expect a req/reply protocol you would copy proxy to conn, but serially. 
Thanks for the reply, I tried conn.Read() but not able to copy back to proxy.
Two questions. Are you reusing a memory buffer for your chunks of data or creating new ones every time? And, are you actually going into swap and experiencing memory exhaustion or just observing high memory usage reports? 
Instead of io.Copy(&amp;buf, proxy) try len, err := buf.ReadFrom(proxy) if err != nil { fmt.Println(err) } else { fmt.Printf("Message size = %d\n", len) }
When mocking you need to inject the dependency into your function. To do so, you create for example an `ContentProvider` interface that has just the methods you need and request it as parameter in the function. Something along this: interface ContentProvider { GetContents(...) ... } func DoSomething(cp ContentProvider, ...) (result Result, err error) { ... fileContents, _, _, err := cp.GetContents(ctx, owner, repo, filename, nil) ... } Now you can write a mock that implements this interface and pass it your function for testing.
If I were to create a script, I would use Magefile. I have not tried monorepo myself but am using Magefile for my build/test/release/deploy tasks.
You've got at least two major sources of problems. First, you're going to be browsing the "localhost" domain. Along with the special rules the browser applies to this sometimes, you're on the wrong domain. Cookies will fail to work properly with Google's infrastructure, CSP requests will go wrong and fail closed on you, and so on, a whole smattering of Same-Site Origin related functionality is failing for you since you're on the wrong domain. Second, you've got SSL-specific issues, because you're pulling down the HTTPS website into HTTP in your proxy, and modern browsers won't pass certain things along from the HTTP space into HTTPS space for security reasons. There's a ton of little possibilities, and determining exactly which is failing could take a while. One option is to give up and declare success. I'm not being sarcastic; it may be the case this is enough to prove the point to yourself, and the next step is a bit bigger. The other major option would be to create a real proxy server, that you'd set in your browser settings as your proxy server. If you do that, and set yourself up with a locally-trusted SSL cert your proxy server can use, you should be able to get YouTube working. In that case, you'll be on SSL, and in the right domain. If you want to crib a bit, [this claims to be an HTTP proxy server](https://github.com/RouterScript/HTTPProxy), though it doesn't seem to deal with SSL at all, which unfortunately you're not going to be able to avoid.
Interfacing with https interfaces such as rest or graphql. You get a json back, and more often than not states are represented by strings. Swift enums are even more powerful, together with its very powerful switch statement. But I am unsure if powerful means better at all times. Sorry for the vagueness:( I feel that trying to avoid enums have caused more issues than it has solved in the past (case in point, Java).
out of curiosity, what are the changes between 1.11 and 1.12 that result in those improvements?
Idk why but this made me chuckle. I like you OP
&gt; In Java, if you have a variable or field of class Foo, that means you really have a pointer to a Foo that is always allocated on the heap. I thought Java optimized that, but the update to [this article](https://www.beyondjava.net/escape-analysis-java) seems to indicate they don't. Surprising.
That feels like trying to compensate for a bad design decision in those interfaces. If I was in that situation, and just wanted the indication of a certain state rather than the value that indicated it, I'd convert it to an integer upon receiving it and pass that around instead. It feels like a really narrow use case though. Usually you either want the value, or the request has already been converted by whatever you receive it from. That's mostly true about the standard library http module anyway.
Link for the lazy: https://github.com/golang/go/blob/master/src/runtime/malloc.go
If you look at https://tip.golang.org/doc/go1.12#runtime and then look at the HTML for those pages, there are comments referencing changes: &lt;h2 id="runtime"&gt;Runtime&lt;/h2&gt; &lt;p&gt;&lt;!-- CL 138959 --&gt; Go 1.12 significantly improves the performance of sweeping when a large fraction of the heap remains live. This reduces allocation latency immediately following a garbage collection. &lt;/p&gt; &lt;p&gt;&lt;!-- CL 139719 --&gt; The Go runtime now releases memory back to the operating system more aggressively, particularly in response to large allocations that can't reuse existing heap space. &lt;/p&gt; &lt;p&gt;&lt;!-- CL 146342, CL 146340, CL 146345, CL 146339, CL 146343, CL 146337, CL 146341, CL 146338 --&gt; The Go runtime's timer and deadline code is faster and scales better with higher numbers of CPUs. In particular, this improves the performance of manipulating network connection deadlines. &lt;/p&gt; &lt;p&gt;&lt;!-- CL 135395 --&gt; On Linux, the runtime now uses &lt;code&gt;MADV_FREE&lt;/code&gt; to release unused memory. This is more efficient but may result in higher reported RSS. The kernel will reclaim the unused data when it is needed. To revert to the Go 1.11 behavior (&lt;code&gt;MADV_DONTNEED&lt;/code&gt;), set the environment variable &lt;code&gt;GODEBUG=madvdontneed=1&lt;/code&gt;. &lt;/p&gt; &lt;p&gt;&lt;!-- CL 149578 --&gt; Adding cpu.&lt;em&gt;extension&lt;/em&gt;=off to the &lt;a href="/doc/diagnostics.html#godebug"&gt;GODEBUG&lt;/a&gt; environment variable now disables the use of optional CPU instruction set extensions in the standard library and runtime. This is not yet supported on Windows. &lt;/p&gt; Then take this CL numbers and look at e.g. https://golang.org/cl/138959 And from there you can find the GitHub issue with more details. 
https://godoc.org/modernc.org/memory
I still don't understand from your example what you are trying to achieve with the two goroutines. You should try another approach where you read first and the write back. 
Hey this is awesome! So I need two wireless cards? I’d like to send large files from my MacBook to my Linux box. 
Or https://github.com/golang/groupcache ? I haven't used it personally, but it is listed as a "replacement for memcached in many cases".
Thank you! Yes, both ends need a wireless card unfortunately. I have had success with USB wireless dongles, but many of those don't have driver support on Linux.
It is basically comparing two strings which is so low on cost I wouldn’t really skip it.
I would recommend using gin for everything. Gib is good.
I quit using it about 2 years ago. Maybe a little more.
&gt; &gt; '(' is a char. &gt; &gt; '(' is a rune. '(' is a uint32.
You're considering trading reliability and future proofing for very minor performance improvements. That's generally a no go in my book. What happens in 6 months when your infrastructure changes and now that endpoint could get more than just GET requests?
[removed]
This is a misguided attempt at optimizing code. If you're doing anything over a network (and you are, since your frontend is calling this Go API), even if your service isn't doing any other I/O (reading a file, accessing a DB, making network calls), the cost of a string comparison is **nothing**.
For now it's only JS client and protoc plugin that's being generated, grpc/grpc-web relies on nginx or envoy for proxying. There seems to be in-process proxy on the roadmap. AFAIK the improbable in-process proxy is not compatible anymore due to protocol changes.
Please, enlighten me. 
[removed]
I'm a big fan of using `httptest` with saved mock data. Example (from the library you mentioned) [here](https://github.com/google/go-github/blob/530b7c552e7576b823c5a3534b6f181ae4340591/github/github_test.go). So basically I would send some real requests, save the response data to text files in a `mocks` folder. For your test, you start a server with httptest and serve those mocks in response to the github object requests, which you point at your httptest server.
Nice! Glad to see you’re still working on this. 
&gt; it split in a smaller chunk, and it analyses it using the go-routine Do you use `strings.Split` or `bytes.Split` ? Or some kind of string/slice slicing? Do you remember some results of those split? String/bytes slicing (and splitting) holds pointer into original huge string. If you remember small result of splitting/slicing of huge buffer/string, then you will retain whole origin huge buffer/string in memory.
I use MakeFile to run all the various "go test" commands and then fail/succeed. It also handles destroying/remaking the test database so each full run of the database tests uses a clean database
Generics plz
Mocking the request response requires understanding the API request response that we want to mock though. I like using that mocking technique if the code I'm testing is also using http call to the external API. But if I'm using a wrapper library, I'd rather mock using dependency injection itself. Otherwise, I have to understand both the library interface AND the API interface is using underneath it whenever I need to mock.
Dear god this is even more complicated than the "official" proposal
It does look more complicated, however, when you get the main point, it would be easier to understand.
Not sure why you got downvoted, you are correct. Chi is certainly not a framework.
Unit tests?
No as far as I know...blackfriday is good, fork it and extend it as much as you want (needs time)
I'm not immediately connecting how you're employing listening to changes in... something... with responding to a request to search? Are you doing some sort of in-process search where you're updating a map or index on document changes?
So for example I have a data service and a search service. The data service would act as persistent storage, while the search would index data and provide a search API. They're both acting on the same data but in different ways.
Typically a lot of people would recommend "services" be bounded contexts in a domain, like "orders", not something that almost every bit of business logic would need to be coupled to, but maybe I'm misinterpreting what you're saying.
[removed]
Sort-Of! Sorry, I'm away from my computer so it's difficult to demonstrate, but a basic implementation of the Observer pattern is made up of two core concepts: Events and Listeners (or Publisher's and Subscribers). Essentially, an Event can be emit, or sent out, to any number of Listeners, who can then perform their own work in reaction to the emitted Event. It's important to note that the Listeners do not act *on* the Event or its context, but instead just react and perform their own independent tasks. The question I'm proposing is if that level of decoupling hurts the ability to follow execution flow. I feel it hurts human readability, but wanted to hear other thoughts.
https://play.golang.org/p/F2pfWy7Lxcm (see bottom) Generally, I think it's better to use something like the observer pattern for things that are not known at compile time. If it is known at compile time, the middleware pattern or composition allows you to see the flow of the code more explicitly, while still allowing you to decouple.
I like this point. Middleware is very practical when you have to do a number of known tasks upon the execution of a related task. I also think composition really shines here. For example, I think it would be very easy to follow the flow of execution required by passing a search service as a dependency of the document service, and just calling the appropriate index or unindex methods themselves. That works a lot better when you only have a few number of extra tasks to perform, and is a little bit easier to understand especially when the trigger for those tasks is a lot more variable.
Middleware makes it really easy for people to pick up your code. However, I am biased towards nodejs express. 
Yeah, but only model test have
If you prefer video. https://youtu.be/n59VtiRx34s
This is the approach I take. E.g., if I'm working with memcache, I write an interface for a cache. That way not only can I mock out memcache in my tests, I can swap it with a different type of cache, like an in-memory cache, file-cache, no-cache at all, etc. The only problem becomes asserting that your caching actually worked... At at that point, turn to integration tests. 
Is there a way around this? How can you discard that original string in memory?
Checkout hoverfly
I’m 100% on board with an observer pattern. Kafka does this at scale and it works well. It’s how iOS gets its performance and reactivity within apps. I’ve found a middleware pattern to be a bit of a mess. It’s kinda fragile in many ways. If you need to change something at one layer you often need to do the same at the rest. Go lends itself well to pipelining, which is a nice version of middleware. But it also lends itself well to an observer pattern. One way you can think of an observer pattern is a fan-out pattern, which is widely used in go. 
No the chunk from the database is a slice of structure. Each go routine use a single structure, when all the slice is consumed I read again from the database the next group of structure and the driver I use it return to me a new slice of those structure
It's the driver to the database I use the responsable of this choice, I give to him the same slice pointer each time but from what I read it should creating a new ones every time. I observe memory exhaustion during this process
I’m confused. Why do you need to mock time? 
Environment variables and a bash script tend to do the trick of you're bash inclined 
You might also get it done with netcat: ``` # serve file on some port cat file.zip | nc -l -p 1234 ``` ``` # read from the port from the other machine nc the.other.machine.ip 1234 &gt; file.zip ```
clockwork is a great time mocking lib 
Only by copying: `copy = "" + bigstring[start:finish]`
And you don't remember pointer to structure inside of slice anywhere?
I don't think this is a particular good example of the 'Single responsibility principal'. It says: "A class [in Go package] should have only one reason to change." Like it says apply it in the large. Questioning every line in your program has no point. I like to rephrase it as follows: "Put things together that change for the same reason." And here you could argue the opposite way: If the called functions are strongly related to the calling function (They change for the same reason) you should inline it to accommodate change when it task changes.
&gt; Loki does not do full text indexing on logs. By storing compressed, unstructured logs and only indexing metadata, Loki is simpler to operate and cheaper to run. I understand this is a trade-off, but unfortunately one that makes it much less useful. Sometimes you just have to search for a string in the log body.
Great article, i was just facing the very same issue and although I already found out about the `replace` directive within `go.mod` files I didn't get it working. Your example repository made things very clear to me and it worked out of the box. Maybe you want to add a direct link to [https://github.com/vyskocilm/gazpacho](https://github.com/vyskocilm/gazpacho) here? Anyway, thanks a lot!!! 
Nice job, fellow bitcoiner! A few things off the bat: Nice to see you understand the gist of what RFC6979 is doing under the hood, as you have an extremely barebones re-implementation of the idea. Kudos. Unfortunately, you are missing some of the most crucial parts of the RFC: namely, looping Step H to generate a deterministic string of nonces in the (rare) event of the nonce generating an improper signature. (ie. rX == 0 or rX == Curve.N... or k == 0 or Curve.N would make invalid signature, and RFC6979 says that if you get an incorrect sig you should loop step H in the nonce generation func once more) So just from a cursory glance: 1. Need to check the validity of k and rX, and if either is invalid, you should loop back to k0 generation and add some counter or something to generate a new k0 to try again and hope you don't get invalid signature again. 2. RFC6979 is not that hard to implement, so it might be worth it to just do a full implementation. iirc btcd/btcec package has a func... though they don't implement looping and just return an error on invalid sig... (I guess they assume it is too rare to care about)
[https://en.wikipedia.org/wiki/Garbage\_collection\_(computer\_science)](https://en.wikipedia.org/wiki/Garbage_collection_(computer_science))
[removed]
Some people like to blame all of the slowness of languages like Go, C#, and Java on garbage collection, but that isn't a very complete story. People will correctly tell you that normally garbage collection takes up a very very small % of total runtime, and that is true, so what else is going on? There are some indirect and related things as well. &amp;#x200B; &amp;#x200B; * Languages that have garbage collection are attempting to be memory safe languages, so: * Thus they will also tend to have array bounds checks when the compiler can't prove they can be elided * They will tend not to allow as many clever casts * They will tend not to allow pointer arithmetic * providing ways to leverage SIMD instructions by hand is hard (Go gives access only through Go assembler at the moment) * They will tend not to have a way for the compiler to do floating point optimizations that can change results like --ffast-math in C compilers &amp;#x200B; * Garbage Collection has some indirect effects aside from how much time is spent doing GC * Every time the GC runs it pollutes the CPU caches, slowing down code that runs later * GC will normally imply a degree of overhead when doing FFI (interop with other languages). Go has even more overhead due to how it manages it's stack, which facilitates goroutine features. Lots of things require FFI still (3d rendering, for example) so those things will always be slower. * The control you get over memory layout of your data is usually limited to some degree. For instance in Go you can't explicitly control whether data goes on the stack, or heap, or \*where\* to goes on the heap. On the bright side in Go you can at least work with any type you create as a value or a reference, so you can at least control things like making sure your array is an array of values in contiguous memory vs an array of references, which you can't in Java. Accessing RAM is very slow, controlling memory layout on modern computers can be a big deal, assuring that you hit the L1 and L2 cache as much as possible. &amp;#x200B; There are also just some cultural things, people working on the C and C++ ecosystems are doing so because performance is priority one. People working on ecosystems of memory safe languages obviously have a bit of priority for safety, correctness, or productivity or they wouldn't want the GC! &amp;#x200B; None of these things in isolation is normally a very big deal but they can add up.
There must be a trade-off between security and performance.
The name of the language is Go, not Golang. Since the Golang language doesn't exist, nobody can answer your question... 
???
During tests I need to check the correct behavior of functions run periodically by tickers. 
why is it mentioned as Golang across multiple resources then? Even the subreddit is named golang.
https://twitter.com/rob_pike/status/886054143235719169?lang=en https://www.reddit.com/r/golang/comments/30wsrs/the_name_of_our_language_is_go/
There are tons of differences in the implementations of C and Go that slightly slow down Go in favour of safety. A few things: - goroutine scheduling - growing stacks - Runtime checks for memory access (you panic on nil not segfault) - runtime reflection - Bounds checking on arrays/slices - No naive casting (safe type assertion) - Different calling conventions - this allows panics at any pint - Go relies more on the stack (no fastcall) - Defer - Much fewer optimizations in favour of fast compile times - latency optimized GC, this limits throughput All of this and much more lead to the fact that cgo has quite some overhead. C is still the most dominant language and this will be remain true longer than we all live. Go improves C in lots of aspects that address issues faced today. 1. Go is memory safe making it way less dangerous to program critical systems 2. Great multicore capabilities in times after Moore's law 3. Go scales great 
Indeed. I'm not saying mine is better. But it seems a little dead, there are pull requests and issues pending for a long time without comment. Plus, after incorporating tickers, there was no new version (still at v0.1.0). Also, it was a nice exercise for me. 
Another thing is that the GO language with the compiler is designed to compile fast. A typical C compiler can do more clever things. GO as a language is fast but many libraries are not as fast as the equivalent libraries for C.
Also the Go compiler has a good balance between compilation speed and optimization.
https://golang.org/conduct#values
Surely you meant to link to https://golang.org/ref/spec where it says "The **Go** Programming Language Specification". The link you posted by mistake doesn't explicitly say anything about the name of the language (although implicitly the name "Go is used).
Yeah, I'm with logicaleak here. I'm not following the though process to this conclusion. Can you provide more please. 
No, it's the correct link. Be more welcoming and patient.
I am very welcoming and very helpful by correcting common mistakes. Incidentally I am welcoming and helpful because that's how I like to be, not because some web site tells me to be. 
There are a number of little things: * primarily, the Go team wrote their own compiler which isn't as advanced as a top of the line compiler like LLVM or gcc and thus produces slightly slower code than you could get from a typical C program * the Go compiler inserts a stack-checking prologue into every function, slowing down function calls by a handful of cycles. This again slightly reduces performance * the Go language mandates bounds checks. While the compiler can usually optimise these away, some remain and eat at your performance. On the other side, you can avoid a bunch of security problems that plague C programs this way. * the Go runtime uses a garbage collector which takes time to run. Unless your program can keep all cores busy at all times, this is unlikely to have a performance impact as Go's garbage collector has been designed to run concurrently with your code, only stopping the code for as little as needed. It can actually make your code go faster because allocating memory is much cheaper than with C and releasing memory is free (as the garbage collector takes care of that) 
No, you're just being a dick 🤷
https://tip.golang.org/doc/faq#go_or_golang
Ah yes, a proper link. 
If you think that stating clear and objective facts is being a dick, we don't have anything more to discuss. 
Because "Go" is such a generic term that makes it really hard as either an identifier or a search term. It's is an abundant English word, an ancient popular board game, and so on. When you search google for solutions you usually have to use "golang &lt;term&gt;" instead of "go &lt;term&gt;" to get useful results. Long story short it's a bad choice for a language name and calling it Golang is alright to avoid confusion.
How is this relevant to his question? He didn't ask for about the history of the the languages name. This answer is equivalent to him asking how ice cream compares to gelato and you replying, "Most ice cream is actually ice confectionery because it doesn't contain enough dairy to be be called cream. Since you aren't specific enough in your definition, nobody can answer your question". Everyone knows exactly what he means, but instead of answering him you answer with a statement containing language that implies he's an idiot. You could have even said "Just a heads up, the language is typically referred to by go instead of golang and here are links explaining why".
Yes. Mostly safeness vs speed. But also faster and easier to write code with fewer bugs. Entire classes of bugs are prevented. Especially for beginners. 
Go, while not being as fast as C/C++ or Rust, is pretty darn fast. Some resources about Go's performance: - GC with microsecond pauses during millions of writes per second on a Raft implementation: https://old.reddit.com/r/golang/comments/aetba6/gcs_stw_pauses_in_go112_beta_are_much_shorter/ - Network Driver implemented in Go (10% slower than C under optimal conditions): https://old.reddit.com/r/golang/comments/9uorh8/writing_network_drivers_in_go_thesis_in_pdf/ - Google ported `dl.google.com` from C to Go. Slides of the talk: https://talks.golang.org/2013/oscon-dl.slide (this is a bit biased since it's natural that software improves in every aspect when rewritten but it does show that Go can power gigantic scale like dl.google.com). - SpaceX is using Go for it's telemetry system: https://old.reddit.com/r/golang/comments/3pu3nl/spacex_is_using_go_for_its_telemetry_system/ (specific usage of Go here is unclear and probably wasn't anything embedded in the rocket but I shamelessly included for coolness fator, sue me 😎) With that said, obviously I wouldn't recommend Go to write low level drivers or AAA games as there are languages/platforms more suited for these. But for vast majority of software Go will do just fine while being easier.
&gt; How is this relevant to his question? For someone interested in $X, I'd say that knowing that $X is not in fact called $Y ranks pretty high on the top of the things to know if you want to be part of the $X community. &gt; This answer is equivalent to him asking how ice cream compares to gelato and you replying, "Most ice cream is actually ice confectionery because it doesn't contain enough dairy to be be called cream. Since you aren't specific enough in your definition, nobody can answer your question". You are right, it's pretty analogous to that, so I don't understand why you bring it up as a negative example. That's a perfectly good response. If I would have asked that question I would be very happy to have received that response. I'd have learned something, always a good thing. Clarifying a question is again a very good thing. &gt; you answer with a statement containing language that implies he's an idiot I have done no such thing. I have only stated factually correct statements. It's amazing how people are annoyed by true facts, but they have no problem with calling others [a dick](https://www.reddit.com/r/golang/comments/af721g/why_is_golang_not_as_performant_as_c_or_c/edw6mms/) in this very thread. The hypocrisy is astounding. 
good to know! I guess it has gained enough popularity and search engines like Google provides better results on the query with this keyword. It's like JavaScript to ECMAScript, I guess.
Stack overflow prologs and bounds checking cause some overhead, but it's pretty minor compared to your first point. The compiler is simply not as advanced when it comes to performing optimizations. Inlining is not as advanced and there's no vectorization.
Minor point: reflection and defer have no effect on performance unless you actually use them. 
@jackmott2 has answered it.
Thanks a lot, very enlightening! I aldo want to ask: which books/online reads do you recommend to learn more about low level go?
&gt; AFAIK Golang is very close to C or inherits many features. If this is the case, why is Golang gaining popularity? Go and C might share syntax similarities but that's it. They are completely different beasts. Go is gaining popularity for many reasons but mostly due to being simpler while still being pretty darn fast. Some resources about Go's performance: - GC with microsecond pauses during millions of writes per second on a Raft implementation: https://old.reddit.com/r/golang/comments/aetba6/gcs_stw_pauses_in_go112_beta_are_much_shorter/ - Network Driver implemented in Go (10% slower than C under optimal conditions): https://old.reddit.com/r/golang/comments/9uorh8/writing_network_drivers_in_go_thesis_in_pdf/ - Google ported `dl.google.com` from C to Go. Slides of the talk: https://talks.golang.org/2013/oscon-dl.slide (this is a bit biased since it's natural that software improves in every aspect when rewritten but it does show that Go can power gigantic scale like dl.google.com). For vast majority of software Go will do just fine while being easier to write and maintain.
Just browsing on my phone but a potential issues I see: &amp;#x200B; mock := NewMock() mock.After( 1 hour ) -&gt; do FooA mock.After( 1 second) -&gt; do FooB mock.Forward ( 1 day) For ease of use, I would hope FooB resolves before FooA, but in your current implementation looks like it would be the other way around. Another useful function might be mock.RunUntilDone() that moves the time forward just enough so all the After-Channels are resolved. 
Nice, thanks :) I will see what I can do about that
No. You're just being a dick. 
[abtime](https://github.com/thejerf/abtime) isn't perfect, but it does most of what I need. Since I haven't worked out the perfect API and I'm not sure one exists, I haven't made a newer version.
thank you - it's exactly what I need. I'll have a look...
I second this request. @jackmott2 do you write a blog or something? If not pls consider. 
&gt; There are also just some cultural things This is where the biggest misunderstanding come from IMO. Unless you do embedded things or video games where you deal with the hardware directly, Go is as fast as you can possibly get. If you are building webapps, or even a game server, your speed bottlenecks are going to be during the network and database calls. Then you read blogs of people saying [insert language here] is slow using a forloop benchmark, then of course everything will be slower the further up you go. Even then, by "slow", it is still 1000x faster than you blink.
&gt; Many use the golang name, though, and it is handy as a label. So you’re not just rude, you’re also wrong. Are you going to correct all of your comments now, or just pretend it’s still “impossible” to answer OP’s question despite “Golang” being an officially sanctioned label? After all, you’re here to educate people, right? And your comments were incorrect. Looking forward to the corrections. 
&gt; Minor point: reflection and defer have no effect on performance unless you actually use them. Reflection at least requires every object to carry some kind of type ID at runtime, which is a small overhead if not required. 
Hi new, I’m dad
I'm impressed. 10% slower than C is very good, even if it's just under optimal conditions. I wonder how Go compares to other safe languages like Ada with full bounds checking plus safe compiler optimizations (-O2 on GNAT)? They might not be far apart.
cool. Can you please give some insights on concurrent abilities of Go in layman's terms? AFAIK Go does message communication over semaphore.
No one is going to help you build a social network. Those things take years of Dev time
How to identify someone who doesn't know nearly as much about programming as they think they do: They use the word "performant", ever.
/r/iamverysmart
&gt; both didn't have versions for vendoring I fail to parse this. Can you please elaborate? 
Welcome 😊 I started to record some tutorials on [building a social network](https://www.youtube.com/playlist?list=PLOzDrFftjC0-yDkIIllvqRHJ_5XyIPxI4). Tho, these are not meant for beginners. Could you tell us the features you want in the social app you want to build?
[removed]
Sorry I don't have experience with Ada or similar languages to help you there. But Ada and Go use cases hardly overlap, if at all, comparing them doesn't seem productive in my opinion. I'd be curious to see numbers though.
There is an amazing talk which explains channel internals better than I ever could: [GopherCon 2017: Kavya Joshi - Understanding Channels]( https://www.youtube.com/watch?v=KBZlN0izeiY)
I'd suggest overall learning how to program in Go. From doing API development in Go over the past few years I've learned that you need a good understanding of the language you're using to be able to accomplish what you want. That said you'll also need to develop some sort of frontend. Think can be done in Go but if you were to follow the leader, most people are using SPA frameworks such as React, Angular, Vue, or Ember. There are a lot of different variables at hand. &amp;#x200B; If you want to build this website in Pure Go, you'll be wanting to search Google for "html template golang" that'll get you to a place where you can start learning how to render html with Go. If you want to build an API in Go and use another web framework as the front end, then Google "rest api golang" and you'll find plenty of articles out there that'll get you the basics.
You might also want to look at things like data models. A graph database (try Dgraph, as an example) will also simplify the social interactions dramatically. Consider design from mobile and API too. A good API will save you a lot of work later.
Yeah, Graph databases are well fit for social applications. [DGraph](https://dgraph.io/) is a graph db written in Go.
Well I can't find anything from the top of my head. A good tip though, you can check out this github list of know libraries: [https://github.com/avelino/awesome-go](https://github.com/avelino/awesome-go)
I suppose the same place where you would find a book to learn about low level javascript. /joke Don't intend to offend, but if you intend to do low level programming, Go is simply not the right language for it.
No, it doesn't. In Go, static types are known at compile time (being a statically-typed language). Reflection tables don't live with values, they are in a different table. If they are not used, they are not even paged into memory. Interfaces carry a dynamic typed, but C doesn't have interfaces, so the comparison is unfair. If you were to implement interfaces in C "manually", you'd use a union with a field for type discrimination, having the same overhead as Go (though in C you could avoid an extra indirection by packing the value inside the interface). Plain old data in Go does not have the overhead of carrying type IDs at runtime. 
Shameless plug: &gt;C is still the most dominant language and this will be remain true longer than we all live. Go improves C in lots of aspects that address issues faced today. &gt; &gt;Go is memory safe making it way less dangerous to program critical systems &gt; &gt;Great multicore capabilities in times after Moore's law &gt; &gt;Go scales great Rust does each of these better at twice the speed. Just don't. Don't try to bend the languages to do what they aren't intended to do.
No each goroutine copy the struct so after all the struct inside the slice are dispatch no one is using the slice of struct
I'm not sure why are you comparing Go to C. Go is not intended to be used where C would be usually used. Go competes with high level languages like Java, Python, Ruby, NodeJS in post Moore's law containerized networked world. If you're looking for system level language which was made to solve similar problems Go is ment to solve, go check out Rust. Now does this mean you can't use Go for low level things. Sure you can. You can use Node js for it too. It's just very impractical.
Well nobody's saying they're replacing systems level languages with Go. I mainly use Go as a bridge between Python and C++. I write C++ when I want speed, and Python when I wanna get things done fast - and Go bridges these worlds nicely. It's much easier to write than C++ and faster than all the interpreted languages (Python, Ruby, NodeJS). As for "unsafe multithreading support", channels are buffered pipes that are already thread safe, and for everything else it's just a matter of adding a sync.Mutex or sync.RWMutex and a Lock() and Unlock(). 
I don't know a lot about low level Go actually, which I guess would just be using Go assembler mostly, which I have never done. &amp;#x200B; &amp;#x200B;
No but I did a video series teaching programming with game projects in Go a while back: [https://gameswithgo.org/](https://gameswithgo.org/) &amp;#x200B; &amp;#x200B;
Oh my god compiling a sizeable application with all optimizations turned on in cpp can take an absurdly long time. Linking, too.
There are some great answers already on the technical "why". But I should also point out that a goal of Go is to be reasonably fast, but not necessarily the fastest. There is a huge middle ground between the popular languages out there that are ridiculously slow (eg Python and Ruby) and the languages that aim for performance over almost everything else (C, C++, Rust). Go is still very close to the "C" end of the spectrum.
Things that are important to know in go are how to check if a key is present in a map, and how to build a struct that mirrors some Json, and be able to unmarshal it.
So, due to the inits needed by the GitHub library, I ended up in splitting the original function. Something on the lines of: type _Repositories interface { GetContents(ctx context.Context, owner, repo, path string, opt *github.RepositoryContentGetOptions) (fileContent *github.RepositoryContent, directoryContent []*github.RepositoryContent, resp *github.Response, err error) } func (c *Client) DoSomething(...) (result Result, err error) { ctx := context.Background() ts := oauth2.StaticTokenSource( &amp;oauth2.Token{AccessToken: c.AccessToken}, ) tc := oauth2.NewClient(ctx, ts) githubClient := github.NewClient(tc) url, _ := url.Parse(c.APIBaseURL) githubClient.BaseURL = url return c._doSomething(ctx, githubClient.Repositories, ...) } func (c *Client) _doSomething(ctx context.Context, r _Repositories, ...) (result Result, err error) { fileContents, _, _, err := r.GetContents(ctx, ..., ..., ..., nil) if err != nil { log.Fatal(err) } // Do something with fileContents return result, err } Then I mocked `github.Repositories` using `testify`.
I agree with Permagate. The GitHub API calls internals are [github.com/google/go-github](https://github.com/google/go-github) concern. I don't want to change my test when the underlying API changes.
[https://www.youtube.com/watch?v=6qCH7Y2rc\_w](https://www.youtube.com/watch?v=6qCH7Y2rc_w) Some very fine interview, about modern day disruptive technologies, spoiler: it includes Go. It may explain everything in more detail, provide some real life application examples as well as few case studies. Also provides better contextual understanding what makes disruptive technology, well, disruptive. (in case in Go it talks about why go is disruptive) There are two main reasons which made Go: So lets focus on the first, why to replace languages like Ruby, which was used extensively for automation previously. (for example capistrano). Because these well known and developer languages weren't designed with multi core processors in mind. Concurrency and parallelism is quite difficult to manage in such languages. And while these languages do have or will have their own answers to it, they are just too inertic to adapt. Go has it build it with very easy to reason about syntax. And it has it's own concurrency model, which is not to be mistaken for parallelism / multi-threading as we usually understand, although it can do that too. It turns out that concurrency is also quite useful to networked environments, and since now everything and one's dog is in the some sort of docker container (which is an interesting topic to dwell on it's own) it made language more relevant. And the fact that enterprise standard containerization solutions are written in Go - Kubernetes, lends to languages popularity a lot too. Second focus, and main language focus - user productivity. This is the reason why you have dreadful error handling. This is the reason for rather poor expressiveness of the language. This is the reason why you can do multi-threading easily, and yet still suffer from plethora of runtime errors which could be checked at compile time, but aren't. This is why you don't have generics. All of this would impede compilation time and waste resources at Google. The supposed "clean" language which ends up in a mess where proper error handling is required, is an after thought. However, it's wonderfully broken language and allows developers to jump into it right away. I was able to write a 'test' microservice in Go under 3 hours when I first jumped into it. It compiles as fast as it feels like it's not compiled ahead of time. &gt;Go does exactly what it set out to do very well. Sadly, what it's set out to do is not always in line with wishes of what other users want it to do. &amp;#x200B; However. User productivity comes at the cost. And while Go is very performant when compared to the languages it competes with. It's even generally faster than Java in most cases, it has it's own runtime and it's also garbage collected. While it's good enough for any kind of web work, because language performance is very rarely the bottle neck of I/O devices, it tends to fall short when it comes to things like robotics where precision is crucial. Or in terms of game development where performance can make or break one's ability to sale a game in very competative environment. Also, fact that language has to carry it's own runtime with it for it work isn't exactly ideal because it limits it's portability. For something to be really cross platform, you want to have ZERO runtime. This is what limits Go to stay in the cloud and will prevent it to be used for the same cases where C is used. However, by this point you may understand that Go was never ment to be used where C is commonly used. For language which solves same multi-core problem but in system level languages, there is Rust. In the link I've provided it's also mentioned. 
When people say "C is faster than Go", they are right, but it's important to keep in mind the following caveats: * **This assumes you are using the same algorithms.** For example, Go makes it trivially easy to use a Hash table with O(1) access, but in C that is not a native data structure. So C programmers often just grab an array or a linked list (both O(n)) and only consider changing if they detect a bottleneck. * **This ignores the "time" as a resource.** Everyone only compares the "best" algorithm, even if the C version takes many times longer to write. * **This ignores ability to debug/understand/maintain.** Every C program that uses a hash library is using a non-standard one, because there is no standard one. Therefore, it takes more time for programmers to ramp up. Also, in C, programmers are always wondering "who owns this memory? Do I have to allocate it? Do I have to free it?" * **This ignores security.** We all know how hard it is to write a correct C program. But (as mentioned in the [State Of Software Security report](https://noncombatant.org/2019/01/06/state-of-security-2019/)) even [expert programmers cannot find a universal way to find the size of a static array](https://groups.google.com/a/chromium.org/forum/#!topic/cxx/2UTgWpM5N0c) in C++. God help us mere mortals who don't know every nook and cranny of C/C++. * **Computer time is cheap compared to developer time.** Many top websites are written in Python, Ruby, NodeJS, which are \*much\* slower than C or Go. If websites were required to be in C/C++, the internet would be a dismal place. Even big websites spending millions on servers rarely "rewrite things in C" to be faster. If they want to reduce costs they rewrite the bottleneck. After all rewriting parts that [aren't the bottleneck](https://en.wikipedia.org/wiki/Amdahl%27s_law) don't speed up your website. \&gt; Golang is very close to C or inherits many features. If this is the case, why is Golang gaining popularity? Heh. It's not just that Go is gaining, it's that people are realizing just how dangerous C/C++ are. They are basically impossible to use correctly by newbies, and the vast majority of programmers are newbies all the time (at language they don't use regularly). \&gt; What's the primary domain of use - cloud? Yes, it's a good fit for cloud because it doesn't drag along a runtime (like Java/Node/Python.) So people use it a lot in application servers and infrastructure management. (TerraForm, Docker, Kubernetes) But it's not just limited to "cloud", it's also a great fit for CLIs. And as an all-around utility language. It's slightly slower to develop in Go (compared to Ruby/Python/Node), but built-in type checking and race-checking will give you way more robust programs that have less bugs. It's not great for native GUIs or mobile apps (yet) -- but that's OK, the web is a de-facto cross-platform GUI, so just write a web app. It's also bad on smaller systems (32bit or less).
\&gt; Sometimes you just have to search for a string in the log body. AWS [has a service](https://aws.amazon.com/athena/) that can do that. Sure, that search is "costly" compared to ELK or something. But if you do searches infrequently, you can save big: ELK requires storage that is many times more costly than S3 (e.g. EBS), and will always dominate your costs unless you search a lot.
Yes indeed. It's very productive language. Just that when people compare it with C they implicitly state that it's somehow on the same level. You don't go comparing Python with Haskell, maybe unless you having specific context in mind. Go doesn't have an answer to data races. It doesn't mean it blows in your face, but debugging those isn't exactly fun. Especially when such problem shouldn't be a possibility to begin with, given that it should, ideally, be checked at compile time.
cool, thanks! &gt; it doesn't drag along a runtime (like Java/Node/Python.) please elaborate in simple terms.
Go does drag a runtime with it.
Almost as fast as C is it's best feature. For a bit less speed you get in exchange: * speed of grok - getting thrown at a completely foreign golang project is much less painful than other languages. * development speed through abuse - yes, *please do* throw everything at a buffered channel and forget about it. because the syntax is so sparse, it's kind of hard to mess up, even if you're completely new to the language. when the next guy comes along to fix it, see first point. * outing the do-nothing wankers on your team - people who complain about go's lack of generics, how functional programming will cure poverty, or beg the project leader to let them splinter a co-worker off into a competing Rust team all have one thing in common: they'd rather complain about Go than do meaningful work. Ditch these people. They make great self-employed consultants. 
I don't usually interview beginner level candidates, but if I did I'd start with some basic stuff like how do types work, diference between functions and "methods", basic pointer usage and so on. If they breeze through all of those easily, I'd move on to goroutines and channels.
Go does have a run time. &gt;Does Go have a runtime? &gt; &gt;Go does have an extensive library, called the *runtime*, that is part of every Go program. The runtime library implements garbage collection, concurrency, stack management, and other critical features of the Go language. Although it is more central to the language, Go's runtime is analogous to libc , the C library. &gt; &gt;It is important to understand, however, that Go's runtime does not include a virtual machine, such as is provided by the Java runtime. Go programs are compiled ahead of time to native machine code (or JavaScript or WebAssembly, for some variant implementations). Thus, although the term is often used to describe the virtual environment in which a program runs, in Go the word “runtime” is just the name given to the library providing critical language services. \- Official Go documentation, FAQ
The Go memory allocator is based off tcmalloc's design, though it diverged somewhat. 
Thanks all for the comments/help. I now understand this is more complex than I thought, and I'll have to do more experiments. 
Fast compile times are the top priority and defining feature of Go and it's awesome as hell. Long compile times really break my "flow" or work rhythm, especially if I'm tired. If your minds sucks at being "busy waiting", Go is such a relief to work with
&gt; Also, fact that language has to carry it's own runtime with it for it work isn't exactly ideal because it limits it's portability. The portability of a language implementation and whether it has a runtime or not are unrelated. 
If all you care about is compile/debug cycle, yes. However, the optimization is really quite poor. It is pretty close to C -O0 with just a couple of low-hanging optimization fruit eaten.
You did something weird.
You need to use [template.URL](https://play.golang.org/p/_yrkktQr0Z2).
If you store a URL as a string and pass it to a template, it will be escaped. If you turn the string into a template.URL then it should do what you want. See also: [https://stackoverflow.com/a/36932024/211176](https://stackoverflow.com/a/36932024/211176)
Of course it is related. If my wasm module weights 1,5 mb just because it has to pack the runtime with it for it to run, I will use something which compiles to 100kb for doing the same thing.
This has nothing to do with the notion of portability. 
It does. Because not all platforms allow for huge binary sizes. I'm not really interested to have a semantics game. But if you do, please read the original point again. It's not "ideal" does not mean, it cannot be used. It indicates that it should not be used.
I had a bunch of tech interviews recently, here is top asked questions apart from language specification and std library (sync, context, math etc): How types and data structures exists in memory, what is heap and stack, how to discover in which of them variables was allocated, how garbage collector works, what is pointer and when you should use it, what more efficient map of pointers or real values etc, tests, benchmarking, profiling, go implementation of algorythm stuff with binary search, btree etc. I don't know what questions are on "beginner-level", but all of them based on go tour, effective go and other "entry-level" documentation. 
Are you looking to just build API and deploy it or like a full app with Db messaging maybe. A UI. Etc?
When I wrote the numerous Go compiler targets and different Go ports, I wrote alternative runtimes that weighed in about 10-20kB. A language is not an implementation. A runtime doesn't need to be large. The current one in the GC implementation is large because of various engineering tradeoffs. It's trivial to make Go fit onto small systems, even with the current implementation, as long as you are familiar with it. As a side note, I've had Inferno (full language similar to Go with GC *and* operating system) running on microcontrollers. The only reason Go doesn't run today on microcontrollers is lack of serious interest. Go is not the best language to run on microcontrollers, but that's because of other reasons, not because of the size of the runtime (coincidentally Rust is also not ideal on microcontrollers). 
&gt; Many top websites are written in Python, Ruby, NodeJS, which are *much* slower than C or Go. Those websites are seldom computationally intensive. Usually they're just waiting for an answer from a database, networked service, or getting something off a disk. Application CPU is seldom the bottleneck for such applications. For a web page that makes five database calls to serve the page, a Python application might take 2-3% longer than a C application. 
 &gt;Are you looking to just build API and deploy it or like a full app with Db messaging maybe. A UI. Etc? Yeaah a full API that involves deployment to docker eventually...
So for the go to work in the environments it's not designed to work, you need to reverse engineer the tool your working with. Not to mention the problems this introduces to the developers who are not familiar with your "adapations" but have to maintain the software for years to come. Sorry, I don't really see how this helps your case.
Well building to docker is super easy. Install docker. Create dockerfile that adds your go binary. Build it from alpine or something. Expose port 80 or 8080 and run it. What library for API are you using 
There is no reverse engineering involved. Obviously an implementation has to have maintainers. Why is this even mentioned, I do not know. You think that because Rust "doesn't have" a runtime (hint, it actually does), Rust targets don't need to be maintained? There's a reason only a subsets of Rust targets are Tier 1 platforms. Different Rust targets need to be maintained and require varying degrees of effort to do so, just as different Go targets need to be maintained. This has nothing to do with the size of the runtime. Just FYI, I authored and maintain several Go ports. I haven't done any Rust port, but I have been involved with the team that did the Solaris/SPARC port for Rust. I probably know a thing or two about the portability of Go and Rust. 
Okay will try it out, right now am using mux
Great Work Mate !
I mean, we are getting to semantics again. Yes, all non assembly languages have run times. Not all run times are made equal. Some need virtual machine. Go doesn't however it has quite a few processes running, which are not present in languages like C. For example - garbage collector. It impedes the performance by varying degrees. It's easier to maintain something which works on it's targets 'as is' rather than some adaptation or with third party tool requirement. Later is usually more favorable, first one is more commonly dreadful solution. I'm just a guy who does web assembly and some FFI's for queues. And during my time I found that Rust is a lot more performant language for it. I brought up the wasm binary size, because that was I suppose the main reason I dropped it from my common use. I still write some Go because we are migrating to kubernetes where I work, but that's about it. Can't say I like it much. Not to mention that Rust feels a lot better designed language to begin with. Now I guess you can categorize that to opinion section, which doesn't directly touch on our conversation. But I suppose I could admit to my potential biases. Can you elaborate on Rust's problems? 
That's not true. Only objects of interface type have to.
You should checkout [golang.org](https://golang.org) blog, design documents, proposals, blogs from people on the Go team. Gophercon and other venues occasionally have some good stuff about internals. There's not really a book or a single place where you can find that stuff. Go runtime changes constantly and, IMO, intentionally has no formal specification to be flexible. &amp;#x200B; Design documents in particular are filled with useful information but you will have to search for them. Wiki on github does list some but definitely not all of them. Like this one about changes in GC in Go 1.5 [https://docs.google.com/document/d/1wmjrocXIWTr1JxU-3EQBI6BK6KgtiFArkG47XK73xIQ/edit#](https://docs.google.com/document/d/1wmjrocXIWTr1JxU-3EQBI6BK6KgtiFArkG47XK73xIQ/edit#) 
&gt; This assumes you are using the same algorithms. For example, Go makes it trivially easy to use a Hash table with O(1) access, but in C that is not a native data structure. So C programmers often just grab an array or a linked list (both O(n)) and only consider changing if they detect a bottleneck. Switching languages sometimes gives you 1.5 to 2x speed up. Switching algorithms often gives you 10x speed up. &gt; This ignores the "time" as a resource. Everyone only compares the "best" algorithm, On the other hand, the 1 is pretty large for hash tables, so C programmers are often inclined to find different solutions for their problems with better running time whereas Go programmers are inclined to just grab a bunch of hash tables where arrays or other fast data structures would yield better performance and less memory usage.
Go is such a simple language there should be nothing off limits, if it is documented in the language spec or Effective Go.
&gt;This discussion is going nowhere so I will excuse myself. But not before mentioning that currently Go runs on more targets than Rust (that's only because of market interest, there's no intrinsic reason why Rust wouldn't run on more platforms). Lets sum up. I've given real life example where Go fails as a language to deliver the desired result when it's ported to be used in different environment provided by official implementation. I don't know if you do front-end, but 1.5 mb binaries are simply not acceptable for wasm when you're having common usecase of service worker. I know it's still experimental, but the reasons why it's so big is not due to lack of optimizations, but because it has to bring it's own runtime, my previously noted aspect. You answered that one can change the runtime as it's just an implementation provided one has deeper knowledge. In fact stating that it cannot be used "as is". And you point out how Rust is supposedly problematic too. Which I'm not sure how is related with conversation at hand, but since you've mentioned and I do work with the language, you sparked my interest, perhaps you know something I do not which could save me time and frustrations in the future. But here you decided to cut the conversation short.
&gt; my suspicion that Go attracts a lot of inexperienced developers That's kinda the point of Go, at least one of them. Being friendly to new programmers so that they could easily pick it up and start coding on a new project and not break everything because they don't understand rvalues or move semantics. I don't have an exact quote but I believe someone on the Go team said something like that in the context of Google using Go instead of C++ for some of their internal projects.
Yeah, they wanted to make the language something that anyone can pick up under a day provided they have some previous experience programming experience. That's obviously a huge strength the language has. Now compare that to C++ and... No wonder. 
Actually, Rust doesn't even have all the advantages of Go. His ownership is complex, the language itself is very complex, it doesn't support concurrency as well as Go. And 2x times slower is exaggeration. In some specific cases - maybe. And in these cases you can use Rust. That way core of you system is fast but everything else can be written in much simpler and still pretty fast language like Go.
Yes, simplicity of Go is very good design. I'm experienced programmer and Go actually makes coding fun again. It's a breath of fresh air after all this C/C++/ObjC/Python/C#/Java nonsense. &amp;#x200B; And why do you need while? For loop in Go is much more flexible than in other languages. There's no need for while, it's redundant. At this point I don't even know if you're serious or trolling.
I was once asked in a Go interview to write the logic that strconv.Atoi and strconv.Itoa uses. Thankfully they said I only had to worry about base 10. 
I wouldn't interview for a language, especially for a language as simple as Go for someone with years of experience. I would expect you to have learned and be somewhat fluent in the language within a week as a matter of course. Interviews should be focused on the interesting things like designing solutions for problems, not testing if someone can answer basic questions about a language.
Why then Facebook wrote this [https://hhvm.com/](https://hhvm.com/) ? Language has a big part in website's performance. That's one of the reasons why people are leaving Ruby, for example.
I think it means that Go compiles into a single binary with no external dependencies if you don't use CGO. Even though there is a runtime, you don't care about that. Just copy a single binary and it will run on any machine or inside any container. Java, Node, Python, they all require you to install something on the machine when deploying.
I would like to add a few more to the excellent collection: * Calling system functions will require a different stack in Go. Hence, code with high system calls can become slower than C/C++ implementation * The Go runtime has a scheduler and does a great job on average. If you have special requirements like very important tasks that should take precedence over other calls, I don’t see a way to do it in Go. This is getting more into real-time software. * As pointed above, not having control on memory layout can hurt performance - Cannot control locality of reference. * Not able to set thread affinity (since Go shhedules your routines in its thread pool) can result in excessive CPU cache invalidation and drop in performance. Since Go is primarily used for developing servers, they are mostly IO bound. Hence, most of the performance shortcomings are overshadowed by IO late cues. 
&gt;array In many cases array is actually the best data structure as it's very CPU cache friendly. Hash maps are not. Linked lists are just useless. &amp;#x200B; It's not about speed but about what suites the job better. If hash map is better fitted for the job, then I will use it regardless of the language. I write in C and finding decent implementation is not hard. I used one myself not that long ago. Not for performance reasons but because it made my code simpler. If I find that it actually hurts performance (and it may very well be, cache misses are very expensive), I will switch to something else, be it C or Go.
&gt; It's not good design when you don't have while loop That's because the `for` loop in Go is literally equivalent to `while` if you drop the first and last parameter: https://play.golang.org/p/wmGY9rbUWed package main func main() { cond := true i := 0 for cond { if i == 3 { break } i++ println(i) } } The problem isn't with the language or inexperienced Go developers. The problem is you not knowing what the fuck you're talking about and pretending otherwise
Electron by itself uses the rendering engine, but Electron and Node.JS are almost always tied together in an "electron application". Paired with Node.JS the application uses the Chromium rendering engine, HTML and CSS parsers, V8 JavaScript runtime, the webworkers threading framework, and the Chromium sandbox security model. At that point, the application is basically a Chromium tab minus the Google account integration. Some Chrome extensions even work fine if you load them from the BrowserWindow object in the Electron app. I think the fact that the back-end is almost always tied in to the Electron front-end is what leads people to call Electron a "web browser". Personally, I don't have any problem with it - I believe PWAs are the future of GUI applications, with more money spent on HTML as a presentation layer than any other framework in the world. * Disclosure: I'm typing this comment from Chrome, with Visual Studio Code, Discord, and Spotify running in the background. All of these are Electron applications (except Chrome of course) and they all work great.
- Difference between struct and interface? - how to add an item to a slice? - how to get a value from map for a key? - what’s a go routine? - is slice passed by reference or value to a function? how about struct? - how to handle errors? What’s a panic and how to handle those?
&gt;I've tried to render a url as string, URL, JS and HTML. 
I've tried to render a url as string, URL, JS and HTML.
If `dep` is no longer going to have core maintainers on it, are there plans for an official dependency management tool?
&gt; For someone interested in $X, I'd say that knowing that $X is not in fact called $Y ranks pretty high on the list of the things to know if you want to be part of the $X community. Not when $X and $Y are synonyms. Language is fluid. 
clockwork doesn't have any git tags (i.e., no version). So the current revision is version v0.0.0-20161215174838-7dc76406b6d3. clock does have a tag for version v0.1.0 but has since commited changes that I depend on, so I can't lock on v0.1.0 but have to lock on the commit. It's possible, of course, but it's not great as you don't get any updates easily. &amp;#x200B; We vendor our dependencies, i.e. including them in a vendor/ directory in the repo. Dependencies without proper version tags are not a good thing to use.
see my update
see my update
Came here to post this. I interviewed for a position at a company using golang, without even knowing the language. Didn't matter one lick, since I was able to display competency in many other aspects of engineering. Equally as important is one's rapport and clear communication with the interviewers. A saying I often express when it comes to languages: You don't find jobs for "screwdriver expert" or "hammer specialist" so much as you do "electrician" or "carpenter". A tool is just a means to complete a job. More important to know what you're doing with the tool...
Why is that a problem?
I'm confused as to why doesn't Reddit let me upvote thorough, excellent answers like these twice.
Now that I have a bit more time, it may be worth elaborating on my comment about how abtime may not be perfect, but I haven't worked out a better API. It's actually a mistake in a clock mocking library to assume that time is monotonic, because in a multithreaded environment, it... isn't. If you have alarm A that fires at time 1000milliseconds, and alarm B that fires at 1001 milliseconds, your mocking library should actually support firing B before A, because _in real code that may happen_. If your mocking API only supports moving time forward monotonically, it will be unable to test things that you may need to be able to test. This is why all my [abtime methods take an ID in addition to the original arguments](https://godoc.org/github.com/thejerf/abtime#ManualTime.After), so you can trigger things in arbitrary orders, not just the "official" order you hope will happen. My comment about not figuring out the perfect API revolves around the fact that can _still_ not be enough, technically, or you may need to increment that ID or something, but I haven't got a great way to make it easier. I also haven't come up with a (sane) way to identify a call without having to add an explicit ID. This also does place some responsibility on the user to track whether their time advancing is also matching up with their code's expectations as to when their alarms fire, though in practice I've not encountered this problem yet.
Here [1] is the same code that I posted in my comment but using your URL. I think you are confused by the “escaped” forward slashes that appear in the resulting JavaScript code. But once you print the content of that JavaScript variable using `console.log` you’ll see that it works. If you compare `someURL === 'https://domain.com/path1/path2/path3'` you’ll get `True`. I am 100% sure are just being misled by how JavaScript handles URLs. [1] https://play.golang.org/p/BEOe6T6RTXv
At Facebook's scale a 2-3% savings on the time a request takes becomes pretty significant. Very few websites approach that scale. Also, while I said application CPU is seldom the bottleneck, that doesn't mean never. I expect Facebook has some more computationally intense items than others, and once you have an optimized interpreter, why not use it everywhere? 
What does the stack check prologue do?
It checks if enough stack space is available to run the current function and allocated more stack space if not.
Well, the quote was about "top websites". Obviously they do care about even small savings. And I still don't buy whole 2-3%. The difference could be massive in terms of latency alone. There's a reason why Go opted for low latency GC instead of high throughput like Java and pretty much all the others where STW pauses could be huge.
Interesting. Does Go allow you to have non-contiguous stacks then? Or does it allocate more space then copy?
The gc implementation of Go used to have discontiguous stacks (called split stacks back then), but it has moved to contiguous stacks, which are copied. I believe gccgo still uses split stacks. 
They used to have non-contiguous stacks in increments of 8 kB initially, but they changed this around in the last few releases. I am not up to date as to what they currently use.
&gt; The problem isn't with the language Yes it is problem with unexpressive language. What you've just provided is a code which would not pass a half decent code review in any other language which has proper expressiveness, due to break statement under condition being in the loop body. &gt; or inexperienced Go developers Well when, we have different minimals standards I suppose. &gt; The problem is you not knowing what the fuck you're talking about and pretending otherwise Thanks for proving that Go community is as toxic as some of the worse individuals in javascript folk. 
I'm not trolling. I'm not sure since when commonly accepted practice became trolling. it's not redundant, unless you don't have a problem with messy code. And the go implementation results in messy code. Break statements with if's in loop bodies are awful, and don't pass reviews when while is available. Because while is a better cleaner way of expressing the same thing.
The break was a brain fart caused by beer. The point still stands that you're denigrating a language based on a complete lack of understanding of even the thing you were trying to critique, and for someone who keeps harping about the immaturity of others that's extremely ironic
Yes it is quite complex language. And ownership is there to make language memory safe while not implementing garbage collector. it also lends to some other aspects. &gt; it doesn't support concurrency as well as Go. I'm not sure what you mean by as well. It has very slick syntax for it and it's easy to implement. However it lacks additional safety net to ensure that it works as you intend it works, which Rust provides due to it's ownership system. There is no chance for dataraces as compiler will check that for you. In Go you might end up with nasty run time errors which are extremely difficult to debug, like data-races between the threads. However, Rust compile times can be quite painful. Because compiler checks very strictly. And implementation can be a bit more complex. As for performance, yeah it's around 2x slower on average. Internet is full of benchmarks. I've personally tested on few real life cases with web assembly, and Rust was quicker close to 4 times. Although such a gap could have been because current Go wasm implementation is in early stages.
I'm pointing out that due to lack of expressiveness of the language, developers have to resort to code writing patterns which more commonly fail to communicate intent of the code and quite often end up in over verbose mess. This also leads to more verbose comments, another common code smell. This alone is fine. I fully understand that different approaches make different trade offs to solve the problem. However, I'm baffled by some Go developers, and not all are like that, obviously, to insist that handicapped syntax of the language is the optimal solution.
Alright, implemented. Thank you very much, I didn't catch the error.
If I’m doing an entry-level / beginner coding interview (for any language), I usually start off with a variant of FizzBuzz, and following up with questions to get them iterate on the idea and improve it (assuming they can get the basic answer at all). For me, these would usually be intern interviews. For example, I may start with a more generic `for all numbers between 1 and 30, print “Fizz” if divisible by 3, “Buzz” if divisible by 5, and “FizzBuzz” if divisible by both, print the number if not divisible by either`. Then I’ll ask them to make it more flexible by making the different values variable (instead of 3/5 and 1-30, allow me to specify). That will help weed out the few that at least memorized an answer. Assuming they (hopefully) get past that, I will usually crank up the difficulty a bit by telling them to refactor the code to **not use modulo**. This is usually where I really see some interesting stuff. The idea here isn’t necessarily to get a “perfect” answer, but to see how the person thinks and problem solves. If this goes quickly (usually by recreating `%` using `int` division, multiplication, etc.), I will ask them to try a different way, and to think about ways that they could improve the efficiency, reduce the number of operations, etc. For Go specific stuff, I usually want to see them use an `io.Writer` being passed into the function and writing to that, instead of just `fmt.Printf`. If they haven’t, I may try to ask follow on questions about reusability. I will also ask them how to test the function (which also basically requires `io.Writer`), and hope (expect) to see them write a unit test for it.
Never interview for a job based on the language. 
I find these questions odd, but that may just be the kind of work I do (web apps, command line tools, automation). &gt; How types and data structures exists in memory, what is heap and stack, how to discover in which of them variables was allocated, how garbage collector works ... ... ...what is pointer and when you should use it, what more efficient map of pointers or real values etc... These are interesting things to know, and can be useful for optimization, I don’t find myself thinking about this stuff on a daily basis, and don’t think I should most of the time. I personally want to see problem solving skills during an interview, not optimization skills. &gt; tests, benchmarking, profiling These are much more critical. Very useful to see these skills in an interview. &gt; ...go implementation of algorythm stuff with binary search, btree etc. I’ve had people ask these kind of questions before (not for Go specifically), but I’ve personally never found any of this stuff useful for an interview. Maybe if I was interviewing for core language or standard library development, but not in everyday use for what I do. I’d much rather people use already optimized and tested implementations instead of trying to re-invent the wheel.
I think the interview process will judge you the basic concepts of data structures and algorithm. Languages choice is secondary if you apply for entry level position. To some extent, you can learn go fairly quickly and adapt to it. If you are keen to go interview question. You could try to represent these following concepts in Golang: - Class interface - Inheritance and encapsulation - Slice, map and nil values - Handling errors - Go profiling and testing.
Just use from scratch; no need for any silly OS
Outstanding reply
How does it start up and run? 
Just to be sure - I don’t really recommend asking these kinds of questions since most swe don’t know golang, go is easy to learn for anyone experienced in other languages (and no one starts out learning programming with Go), and questions of this kind don’t really show proficiency of someone in software engineering, just that they know a few things about syntax and understand some concepts. Also, some of these questions are more like go gotchas that frankly I’d classify as downsides of go. But these quirks are something you’d run into pretty early in go development.
A statically compiled go binary needs no OS. A docker container provides access to the host Kernel. So your dockerfile looks like FROM scratch COPY mybinary mybinary ENTRYPOINT [“mybinary”] (I’m on mobile so I apologize for the formatting 
I currently use packr and I am very happy with it. Checkout https://github.com/amir20/dozzle on how I use it and dockerize it. 
Ah, yes.. that makes sense.. but he said he wants to deploy it to the cloud. I believe for that you still need the OS in docker so that it spins up. I dont think there is any host OS that it can run off of in that scenario is there?
You should add more code if you want more help. It’s impossible to say what’s wrong unless we have a minimal amount of code that reproduces the issue.
One thing that I liked to see starting out was if something was concurrent safe or not. Like the Go cache article isn’t thread safe, so it might me a good idea to tell people why it’s not
No you don’t. A container works the same no matter where you run it; that’s the point of containers. Scratch containers are the best kind of container.
Yeah, but lots of top websites didn't start that way. They started out as websites developed by small teams that took off. Reddit is written in Python; Facebook is written in PHP. Those languages were chosen because they were convenient for developers, not because of performance concerns. By the time they were "top websites" they had enough legacy code that massive rewrites to more optimized languages were infeasible. For Facebook it was apparently easier to write an optimized PHP interpreter than rewrite their code in a more performant language. As far as the 2-3% claim: I've spent a lot of time optimizing web applications written in Python, Java, and Go. Almost without exception those applications spend over 95% of their time waiting on networked services or disk, and the rest is some form of serializing / deserializing data. When you're spending 95% of your time waiting for a database, even if you had an infinitely fast language for your application code you could only take 5% off of your total request processing time. If you get your application code to run 10x faster, you only get a 4.5% improvement in your request processing time. Until you've optimized other points like indexing queries, parallelizing network requests where possible, caching to avoid repeated network requests, etc. worrying about the performance of your application code is a waste of time. At Facebook's scale with an estimated 60,000 servers, they've likely done those other optimizations and writing an optimized interpreter to save 3% on application code execution might mean they need 1,800 fewer servers. Until you reach that scale, being able to develop code rapidly almost certainly has more value than worrying application code execution. Of course there are workloads where this isn't true, and language choice tends to be much more significant for those workloads, but for typical web applications they just don't spend enough time on computation for it to matter until you're at the scale of a top website.
TLDR they are mostly people who worked on `dep` and got offended by Go's choice of moving using `vgo` instead. People who say "I don't like modules" but want to use `dep` are super confused on how either of them works.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/u_yatendernitk] [Why is Golang not as performant as C or C++?](https://www.reddit.com/r/u_yatendernitk/comments/affgqy/why_is_golang_not_as_performant_as_c_or_c/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
If you're on a RPi, Go can be more than real-time enough. On a more real time system, you might need to pull out the real time pieces into a small C binary and control it via subprocess+fds or something of that nature, but that shouldn't be necessary if your hardware can be controlled from a non real-time OS like RPi.
While he's wrong and go's `for` can replace `while`, it can't replace `do while`.
&gt; primarily, the Go team wrote their own compiler which isn't as advanced as a top of the line compiler like LLVM or gcc and thus produces slightly slower code than you could get from a typical C program But gccgo and llgo are supposedly even slower
&gt; What actually works? The code posted in your question works! Note that `"https:\/\/domain.com\/path1\/path2\/path3"` === `"https://domain.com/path1/path2/path3"` in Javascript.
&gt; what is heap and stack, how to discover in which of them variables was allocated, Eh? The compiler does escape analysis and the runtime keeps an object tree to do mark and sweep. Where in the runtime can you ask it if a reference to an allocation is on the heap or the stack and when can you be sure it won’t do heap promotion at run-time? https://golang.org/doc/faq#stack_or_heap That question doesn’t make sense because the runtime chooses what to do during execution. This sounds like a C interview question whose answer has no place in Go IMHO. 
So you are saying all these containers that always start from an OS shouldn't? So if I build a container with just my binary...it runs the same on any host including the cloud ? What is the host on each cloud. 
Thanks for your review, i didn't find your mentions in the https://github.com/sipa/bips/blob/bip-schnorr/bip-schnorr.mediawiki do you have test cases which fails with the current implementation? what does rX == Curve.N... mean? rX &lt;= Curve.N? 
It doesn't matter what the host is, that's the point of docker
can you share the benchmarks?
Then why does pretty much every example available show the Dockerfile starting from alpine or Ubuntu or Java or something. Or it starts from scratch but then downloads and installs Ubuntu or whatever. 
Bookmarked this. Way too much good info here to pass up. “Shutting down http gracefully”, literally something I was needing to tackle here shortly. Love it. 
`do while` is rarely, if ever, the best construct to use, though.
Developers write C++ in a myriad of different ways. What is readable to one developer may be incomprehensible to another, just because of differences in how they approach problems and the style of writing. Go is the most uniform language I have seen, style wise. Developers write code in very similar ways, and `go fmt` is commonly used to ensure a uniform style. Pick up any two Go repos from GitHub, and chances are high they have been written in a very similar style, with very similar patterns. Readability, in terms of not being surprised, is very high for Go.
I think Go is faster than that. Benchmarks? Sources?
Oh man! I read about this release in “LOL, No Generics Magazine”. Great little quarterly. The latest issue had an article about how Go is a dying language and version 2 is never happening. Definitely recommend checking it out.
&gt; i didn't find your mentions in ... Under verification: &gt; Let r = int(sig[0:32]); fail if r ≥ p. &gt; Let s = int(sig[32:64]); fail if s ≥ n. This should also say fail if r or s == 0. But it says so indirectly: &gt; Let R = sG - eP. &gt; Fail if infinite(R) or jacobi(y(R)) ≠ 1 or x(R) ≠ r. How does R become infinite? if (s - ep) == 0... Also, if x(R) == x(P) then the jacobi check fails... so if s == 0 OR if s - ep == 0... you will fail at the very end of the verification step... One hackey way around this is to run verify on the return value of sign before returning it (lol) just to make sure you're covering all your bases... Otherwise you need to understand what causes all the fail states in the verification in relation to the signing variables... which requires a deep knowledge of crypto. &gt; do you have test cases which fails with the current implementation? If I did, SHA256 would be broken. ;-)
Oh man! I read about this in "LOL, Resentful men circle jerking". Great little quarterly. The latest edition had a chapter about how a bunch of emotionally unstable, resentful men, in a futile attempt to soothe their wounds from being continuously rejected by nature and the world. find false happiness into articulating their resentment towards anything even remotely successful, unaware of their irreversible descent down the belly of the beast. Definitely recommend checking it out.
&gt; Not able to set thread affinity (since Go shhedules your routines in its thread pool) can result in excessive CPU cache invalidation and drop in performance. You can set thread affinity per goroutine using runtime.LockOSThread() 
Reflection based, `interface{}` typed API? Thanks, but no, thanks.
You're probably using `html/template`. Use `text/template` and no escaping will occur. Of course I'm making a guess, you should post a small and complete example of your code so we can advise properly.
Thanks for feedback
Safety has nothing to do with security
I was interviewed for highload projects with heavy calculations when optimization is one of a main goal and unoptimized algorythms may ruin time exectution badly. So it is what it is, I didn't compose those questions myself.
It's question about profiling memory allocation with gcflags and such. If you have critical perfomance algorythm you may write benchmark and start profiling/optimizing it.
Found this: https://github.com/fatih/vim-go/issues/2018 Someone suggested: autocmd BufWritePost *.go silent! :GoBuild -i But I didn't really like that, it seems it was kind of laggy. So it seems it's general issue, but if anybody has any good suggestions, I'll be happy to hear them.
but there are already have the conditions https://github.com/hbakhtiyor/schnorr/blob/master/schnorr.go#L65 https://github.com/hbakhtiyor/schnorr/blob/master/schnorr.go#L69 https://github.com/hbakhtiyor/schnorr/blob/master/schnorr.go#L80 
if I understand you correctly, something like this maybe? &amp;#x200B; [https://github.com/oxequa/realize](https://github.com/oxequa/realize) &amp;#x200B; &amp;#x200B;
I'm still not buying your claim that the problem with Go is a lack of expressiveness, or that its syntax is somehow unfavorable for reading. Go's the first language I've run into where the stdlib is actually readable by a normal human being. Comments are usually used for documentation, and I really haven't ever seen any examples of over-commented code, and I have a hard time understanding how documentation (i.e. comments above exported functions) could be considered bad
Lack of support for Gomod is a bit of an issue, too.
Yes. In the Verify function. So someone who makes a signature like that with your functions will fail and even though they used their private key and made a signature using your function, it fails when you verify. I think it is not written in the BIP because it is too obvious: "Don't generate an invalid signature." I told you how you can avoid creating an invalid signature, and make it so that every private key and every message can always create a valid signature.
Something I don't understand is, why you are defining an interface. You just use one implementation. So what you have here is also called interface pollution. If you want to optimize your package for speed , the usage of an interface makes the call much slower. Just remove the interface and just use the type directly. That will make your code much faster.
Yea that could actually work, I will try it out. Thank you very much! I'm also thinking that on vim I could maybe automatically run install when I save a file, but it would have to run on background so it would not cause lag during editing.
That's because they use a worse runtime.
We need link to this explanation on the sidebar. 
Go compiler does some optimizations like inlining, removal of slice bounds checks, escape analysis et, c so I would say it's closer to something like -O1
You can enforce uniformed style while retaining proper expressiveness which for example would allow to write less syntax noise when handling errors. We already have such examples. Javascript, one of the most bloated language, has ESLint, air b n b standard. Everywhere it will looks the same too. Now ofc it's not adopted at language level, but it could. I mean what you wrote is post hoc excuse why language lacks expressiveness and why it's ok to have syntax noise. Like if err != nil checks are syntax noise which pollute the cognitive load of the reader. 
3 reasons: 1) For many exercises teaching people its useful to allow folks to log into the container 2) Other languages which do not compile to native binaries need an OS: e.g Java/Node/etc; this provides a tangible reason to move away from those languages. 3) A very very large amount of bloggers have no actual clue or real life experience with production go or containers and just want to build a following. The most egregious of the last one was an article I saw from someone who worked at a bootcamp company as a teacher and they clearly had ZERO production distributed computing experience, yet the article was supposed to entice people to take the class. You’ve been questioning me on why a whole bunch, and I called out your sources. For context my background is 20 years in tech, many dozens of go services in scratch containers running in production over the past 5 years or so. So instead of arguing build your binary with CGO=0 and put it in a scratch container. 
https://en.wikipedia.org/wiki/Syntactic_noise I'm tired arguing for things which were resolved decades ago already. Go is full of it. It cannot do without it as the example you've provided. Just because it's -readable- in a way that you can read it easily, doesn't make code easy to read. Because you're reading a lot of irrelevant clutter along the way. Sure consistency helps. I suppose brain get's used to start ignoring huge chunks of code and just jump to relevant parts. However, that's still additional cognitive load. And sometimes your brain might skip something what is of relevance. https://www.youtube.com/watch?v=ZsHMHukIlJY "Seven Ineffective Coding Habits of Many Programmers" This is a talk by a well known personality and author in tech world. An IT consultant who seen a lot of good and bad with special interest in linguistics. This talk is focused on readability. And how programmers tend to ignore this requirement. Might be interesting. 
The old nsf version had some autorebuild option. This newer version has a -source option to perform autocompletions from source code instead of the compiled package. I would suggest you check out Rebecca Stambler’s fork: https://github.com/stamblerre/gocode She is working on the official Go LSP server that will eventually replace all of these gocode forks.
Makes sense, thank you!
Why don't you use \[TableDrivenTests\]([https://github.com/golang/go/wiki/TableDrivenTests](https://github.com/golang/go/wiki/TableDrivenTests))? With it, your \`validators/validators\_test.go\` could be rafactored like this. \`\`\` func TestFinalNewline(t \*testing.T) { var tests = \[\]struct { name string param1 string param2 bool param3 string wantErr bool }{ {"without newline", "x", false, "lf", false}, {"\\n with lf", "x\\n", true, "lf", false}, // ... } for \_, tt := range tests { tt := tt [t.Run](https://t.Run)([tt.name](https://tt.name), func(t \*testing.T) { err := FinalNewline(tt.param1, tt.param2, tt.param3) if (err != nil) != tt.wantErr { t.Errorf("check failed wantErr is %v but err was %v", tt.wantErr, err) } }) } } \`\`\` &amp;#x200B; I think it's more readable and easy to add/delete test cases.
I'd love a carefully curated link list newsletter and this looks nice. However, I randomly clicked on the Go vs Javascript and recursive functions article under Fundamentals, and it is a real mess! I don't think the curator even read that.
Why don't you use [TableDrivenTests](https://github.com/golang/go/wiki/TableDrivenTests) ? With it, your `validators/validators_test.go` could be rafactored like this. ```go func TestFinalNewline(t *testing.T) { var tests = []struct { name string param1 string param2 bool param3 string wantErr bool }{ {"without newline", "x", false, "lf", false}, {"\n with lf", "x\n", true, "lf", false}, // ... } for _, tt := range tests { tt := tt t.Run(tt.name, func(t *testing.T) { err := FinalNewline(tt.param1, tt.param2, tt.param3) if (err != nil) != tt.wantErr { t.Errorf("check failed wantErr is %v but err was %v", tt.wantErr, err) } }) } } ``` I think it's more readable and easy to add/delete test cases.
Nice attack on men. At least you didn't get super specific with an attack on 'white men in tech'. I thank you kindly, person of unknown gender status.
&gt; people who complain about go's lack of generics, how functional programming will cure poverty, or beg the project leader to let them splinter a co-worker off into a competing Rust team all have one thing in common: they'd rather complain about Go than do meaningful work Ironic
Hi @u/gargamelus. Don’t know why this is downvoted. Sometimes I select on the basis of ‘experience Golang from the trenches, rather than ‘learn from the trenches’. And I like to include female experiences as they are in minority. But your feedback reminds me that is maybe not enough in line with the proposition of learning Go
Without specifics on your use case, I would have the ticker's time.Duration interval as configurable. In prod, run it at 24 * time.Hour, but under test, have it run at time.Millisecond * 25. The few times I needed control over time, I've passed in a time interface that has methods I need, like Now().
Memory safety and memory security is the same thing. Out of context, yes, safety and security may have different meanings. Safety does contribute to security.
Huh, apparently the Go team is working on one now too (a language server)
Well that makes more sense. I have had people ask these kind of questions for entry level stuff, which didn’t make sense to me. 
As realize has issues with go mod you could use [https://github.com/cespare/reflex](https://github.com/cespare/reflex)
/r/iamverysmart
Need a lot more information, and this is where some experience with software engineering comes in. You need to estimate how much traffic you expect to get, how much it would cost for a Django back end to handle it, and how much it would cost for a Go back end. Then, you also factor in time to develop. Roughly how many hours would it take you to make the project in Django, and how many hours it would take you Go. Doing this exercise a couple times myself when talking about start ups with friends, I think for a small ecommerce website you should use a backend as a service like Google Firebase and have all of your functionality live in a front end framework like Angular or React. Fastest time to develop, low maintenance costs for the developer, free hosting until your traffic goes up significantly. There are some issues where costs can go up significantly for a large website, but to get started with a $0 investment it's a pretty great option. BUT, this is outside of the scope of the original question. Going back to that, I think Go is a better option. Time to develop is not significantly more for Go then it is for Python, unless you are skilled with Python/Django and are having trouble learning Go. Go is much more efficient at handling requests, so you'll save money on hardware.
[removed]
Thanks other than lack of libraries do you think golang is a fine choice for ML applications?
If your many argument is that Go isn't truly a systems language, then yes, I'd agree that to be the case, but a lot of people use languages that are orders of magnitude slower than Go, like NodeJS, PHP, Python, etc. If runtime performance is your absolute top priority, you will be using C, C++, or maybe Rust. In most cases, raw CPU performance isn't the top priority; often productivity (ex. time to complete the project), security, and memory efficiency are more important, particularly for web development, and Go is a good optimization for those use-cases. &gt; And all these Go hypers who think that Go can somehow replace system level languages with it's heavy runtime and actually quite unsafe multi threading support. C / C++ are ridiculously unsafe in terms of memory management and multi-threading support.
I see a bright future for ML in Golang. Tensorflow for example is currently supporting Golang. Next could be anything... Being easy to perform multi thread programming with goroutine. It’s extremely useful and promising for better ML training performance. All we hope for is more and more exposure of the language to developers. Then more and more libraries will be built. However, for now, python is still a must know for ML dev. Thanks for the support! If you find the tutorial, please consider give it a clap on Medium (or 50 claps also can :p)
&gt; Go doesn't have an answer to data races. It doesn't mean it blows in your face, but debugging those isn't exactly fun. Especially when such problem shouldn't be a possibility to begin with, given that it should, ideally, be checked at compile time. Are there languages in widespread use that prevent data races, other than by eliminating multithreading, other than Rust?
For sure thanks for the response and I already did. 
4.7. More seriously you'd need to give a __lot__ more information before anybody could answer. 
Thanks :))))
This is like comparing apples to oranges. Django is a framework that handles things like templating, ORM, sessions, etc. Go is just a language. You’ll likely need to investigate how to handle the things Django does for you in Go. Using Go would probably increase dev cost since it may (but may not) take longer. If you’re concerned about server cost I would just build the backend in Go which will cost very little and then serve static html (built from angular or something) via s3 which will be fast and fairly cheap. Django would most likely require the front end and backend to be deployed together which may drive costs up. This is all obviously all hypothetical and you should really take into consideration other factors like dev time, maintainability, easy deploys, fast iteration, etc...
You are in the best position to force yourself to write efficient software. Django is something that I loved to work with the most, until I fell in love with Go, it really made me love programming again. By thinking about resource utilization, you will learn a lot, even if you spend more time developing. If you aim to learn, be creative and use less resources on your server, go with the Go. If you want to reuse already made (very good) generalized solutions to minimize development time, but end up with a bit less knowledge for the next project, go with frameworks like Django. Memory utilization mostly depends on application business logic, but you can be much more creative with Go to optimize, then with frameworks for interpreted languages. For example, a single instance of [NewReleases](https://newreleases.io) web application allocates only 22MB (using boltdb for storage) and it makes around 15 http requests per second to update upstream information. Another Go project, which is not active now, needed around 400MB alone for handling 25k visitors per day, directly exposed to the internet (without nginx or lb in front), without any problems.
First, don't learn Go for your purpose. Go is to get stuff done. If you want to learn I suggest that you learn Common Lisp (\[SBCL\]([http://sbcl.org/news.html](http://sbcl.org/news.html))). &amp;#x200B; Figure out how to: * build a \`cons\` cell out of a \`lambda\` * build a \`list\` out of \`cons\` cells * build a \`struct\` out of a \`list\` and a \`macro\` * build a \`class\` with single inheritance out of a \`struct\` * (optional) build multi-inheritance classes too This will teach you on the way hell of a lot of things and at the same time not take that much time to understand all. Lisp invented \`if\` and \`else\` and object oriented programming, alone therefor it is a good idea to learn it and understand from where the modern programming world is coming. Even if you never use Lisp for real work, learn it. It will make you for sure a better programmer.
Unless this changed within the past few months, TensorFlow doesn't have complete bindings for Go, and it's not possible to do basic things like training a model in Go, which IMO prevents it from being considered "supported" even if TF claims it is. I think Go would be a fantastic language for ML, but only once complete TF Go bindings are available. If you're working on a hobby project or doing something that doesn't rely on TF, then Go would be a fantastic choice.
I wonder if this partly comes from the term "language", as you certainly wouldn't hire a Spanish speaker for an Arabic translation job.
Then that’s a profiling question around the benchmark tooling in the unit test framework. Still different than your initial question. 
Absolutely agree! Sorry for the confusion. When I said Tensorflow supports Golang, I didn’t mean it’s ready for production. Cause TF for Golang is still in experiments and mostly load models in Python. I do believe a better future though.
I think I know why it was downvoted. I reread my comment and I really sounded like an ass. Sorry for that, didn't mean to do that!
It would be helpful if you showed exactly what requests.go:71 points to. That would tell us what is being accessed. There are a few reasons in this code that it could be crashing. You make a few assumptions that values can be type asserted but don't check. Could be the body being asserted to a specific map type with no error check. 
You also don't initialise the HTTPRequest field as far as I can see, so it remains a nil pointer. 
You bring forth another good argument for why Go is readable: when reading source code you can often see everything you need right there, locally in the code. In other languages, having to dig several layers down to find out what a single line of source that someone else wrote is more common. I'll ignore the incorrect personal characteristics. I program in Python, C, C++, Rust, Assembly and Go, and have been programming in a variety of languages for over 20 years.
I don't have a CS background either, but I started in Python, and then Go and C++. I'm similar to you in that I don't enjoy front end dev. I also can't recite algorithms in an interview. Just pick a small project to serve a real need and build on that (that is what I did). I don't think lack of a formal CS background is going to cause you any issues with Go. 
updated, sorry about that
I have updated the code you can take a look now. Thanks
You know. I felt the same way, except it was about the comment /u/shovelpost was replying to. Generics is a tired subject here. We are almost all happy to discuss it constructively and there is some seriously interesting discussion down that path, but if your only contribution is to show up in a sub reddit to effectually say "lol must suck not to have the generics!"... It is not a gender thing, it is just a tired subject...
Does Golang need be good at everything? Are there characteristics of Golang that make it less suitable for some uses than others? Python and other languages are really good at experimenting and building models. Why not just train a model with a language / ecosystem that’s great for model building, then output that model to something like Onnx [1], so the inference can be run in your language of choice? [1] https://github.com/onnx/onnx
you're idiot? while you're making predictions, my question has already been solved
A "runtime" is code you need to run your code. Languages like Ruby, Python, Perl and Node are called 'scripting' languages because you write some text (a 'script') and feed it to the language runtime (usually a compiled program called `ruby` or `python` or `node`). The computer has no idea what to do with your script, so you have to feed it to the runtime program which interprets your script. (Often that is too slow to interpret line-by-line, so they Just-In-Time compile some bits of your script in memory.). In Java, the programmer does "compile" the program to disk, but the program uses "bytecodes" that need a "JVM runtime" to interpret. The ironic thing is that most of these 'runtimes' are written in C. So if you know the language, you can't 'change' the language without learning C. The upshot of all this is: No matter how small *your* program is, you need 10-100MB of "stuff" installed before you can run a program in those languages. You can also get subtle and hard-to-find bugs when you build and test your program using a specific runtime, but then ship it to a server that has a *slightly* different runtime. (This causes programmers to throw their hands up and say "It works fine on my laptop!", which isn't helpful.) Go binaries can be as small as 1MB. (Technically, Go does have a very small "runtime", but it's compiled in to your program, so you don't notice it.) The cool thing is that both the [Go compiler and the Go runtime](https://www.infoq.com/news/2015/08/go-1-5) are actually written in Go. That means you can generate binaries for Windows, Mac and Linux (including ARM Linux) from any platform. That's really hard to do in C.
Honestly, forget TF bindings for Go. Go-native ML libraries have big potential IMO: easy imports, powerful standard library with a lot of I/O utilities, compiled binaries, and easy deployment as a web service make it pretty ideal for lightweight ML tasks. We might not see Deep Learning in Go but it's plenty fast for most things, more friendly than C, and more serious than Python
I understood your argument the first time, my entire point is that I really don't agree. Go has problems as a programming language, but *syntactic* noise isn't one of them – and only having one looping construct really, really isn't an example of syntactic noise. If anything, the syntax itself is extremely sparse; the problems lie on the semantic side, with eg. the current lack of generics causes either loss of compile-time type safety, or requires other workarounds. Channel and goroutine management could also use some improvements (from an API point of view), but those are again not syntactic issues
You don't have to mock the URL, you can mock the fetch operation. Also when you find something is hard to test, it is usually a "smell". In this case indicating you might want to separate the fetching and the parsing into separate functions. _getAllBreweries_ can then just call both. You can then load a json file you keep in your test folder to validate parsing, and mock (or not test) your API fetch. 
A thing to consider is "time to MVP" is still "cost", so if you're a Django expert and a Go beginner, the overall "cost" for the Go project will be way higher, even if the server costs are lower. That being said, Go is awesome and I think you'd be fine using it. With Go, you can do more with less, so general server costs will be much lower.
If you're set on writing "unit" tests, you should look into mocking libraries and/or just create an interface for however you're hitting the brewery API, so in your test suite you can create something like a \`TestBreweryAPI\` struct that implements that interface, thereby creating a mock yourself. FWIW, I think this is a scenario where unit tests won't buy you much. You're testing whether your code works well with someone else's code, but then you're mocking someone else's code to be yours. If the Brewery API changes, or you misunderstood something about it, your tests wouldn't catch it. I think your time would be much better spent using something like the \`testify\` package and actually hitting the brewery endpoint in your tests. That way, you're using your real code and hitting real endpoints, so if the API changes or you are actually wrong about how things should work, your tests will blow up. Just my 2c though. Lots of people still write and love unit testing.
You can learn about Data Structures; Algorithms; and Theory of Computation.
You don't need to dig deep what someone wrote, because the language itself has a way to deal with it. There is no need to inspect how someone implemented reduce algorithm. See now you're trying to sell obvious disadvantage as a good thing, when it's just an example of needless syntax noise which is yet another source for bugs and low performance. I expect to see something like this being de fact standard library, even if it's not provided by the language in time to address poor expressiveness of the language. https://medium.com/@ivan.corrales.solera/could-koazee-be-for-go-like-lodash-is-for-nodejs-5d08b1d3f01e
You can just look at the code gen. It is very, very basic.
This doesn't really help. Your post is a big mess of code and you only explain the nature of line 71 and not the actual code. What you need to be using is something like pastebin. But my guess is that because you don't actually initialise your HTTPRequest field, you are going to crash when you try to access its Headers field. 
I am working on a project that was written by a guy like you mentioned in your comment, who begged to introduce go into the company. After completing the project he moved on to a different company. We realized after some time that it’s a complete shit show in terms of performance. He is using boltdb which is designed to work on SSDs but he forgot to take into consideration the fact that this service runs on spinning disks. This is just the tip of the problem pyramid. We are rewriting this project in C because that’s the right language and anyone who thinks go can compete which C in terms of speed is deluded. This project has cost the company a lot of money in terms of developer hours which according to your point is a positive for go. I know you’re gonna point out that the dev was shitty, but go allowed him to write that piece of shit code. Rob pike is a fucking idiot
yep. python it is
&gt; Are there characteristics of Golang that make it less suitable for some uses than others? Since it's garbage collected, I don't think it's suitable for systems level programming. It's great for nearly everything else though. ps. You can create hyperlinks on reddit like so: `[this is a link](https://this-is.link)` I wonder what the overlap between this sub and HN is. I suspect it is disproportionately large.
Go sounds like a good opportunity. Maybe get the hang of grpc.io with Go as well, SLI/SLO
Someone recently shared [this](https://github.com/ossu/computer-science/blob/dev/README.md) resource with me, but I've not had a chance to look at it, hopefully it'll have something of use.
I would love to know how to train a model using python and then use that in golang. But I dont know where to start. A tutorial for that would be awesome :) or do you guys have a good starting point? thank you
if you're starting an ecommerce site, you should really use a solution like Shopify rather than trying to build it yourself. An eShop is an eShop, unless you've got some serious differentiation magic planned for your webfront, which I highly doubt. Once you reach a few hundred thousand dollars per year in revenue, maybe it's time to consider writing your own from scratch.
Well I'm sure after 3 years you know this but.. https://learning.oreilly.com/videos/ultimate-go-programming/9780134757476 But in general I think you are basically looking for more low level stuff. Like lisp/closure. Go actually borrows a lot from it but you can go down deeper. Like instead of just random goroutines you can actually keep track of coroutines and state. Because you can have listeners from a parent state to a child. 
For example, using fixtures for testing. Imagine a set of fixtures with a specific expiration date which after that date need to be removed from the database (something like session keys). A daily goroutine deletes the stale ones from the database using a ticker. Since the fixtures have a specific expiry date set, you need to set the system time to that date. Mocking time.Time makes that rather easy.
looking at the code, it appears the definition of lazy here is a little unintuitive. It appears to run each operation across the entire array, then move to the next operation, and run that one across the entire array. This is bad for performance because cache locality is destroyed by flushing the cache. A truly lazy iterator implementation in Go would be fun to see, maybe modeled after Rust's iterator? As soon as Go has generics, that will be a cakewalk, but it's painful to implement right now, so I would just stick to nested for loops.
Code tailored to run on SSD sucks on spinning disks regardless of the language. One could rewrite it in assembly and it would suck in the same scenario. Only an idiot would think this has anything to do with Go.
Self righteous finger pointers are the worst breed of do nothing wanker. Right away he admits the top suspect in perf hit was due to optimizations issue in the storage engine, which is easily rectified for kv stores. Then hand wavey generalizations about the Altar of C. So tiresome.
Damn, you're really giving me something to think about! Didn't even think about that. Maybe instead of triggering specific IDs there should be an option for \`ManualTime\` (or \`Mock\`, in my case) to shuffle the tickers instead of moving forward monotonically. Maybe an option adding slack. \`clock.NewMockWithSlack(time.Millisecond\*100)\` could create a new \`Mock\` that shuffles the order of execution within that period of time?
Regarding algorithms, you should take advantage of LeetCode and work through problems at your own pace. Spend time learning the theory behind every solution and absorb everything you can find about the specific problem.
&gt;Python and other languages are really good at experimenting and building models. Is it the language itself that makes it good at those tasks though? Or just the fact that it is beginner friendly for the sciencey people who know just enough programming to run their models? Or due to the large amount of libraries available for these kinds of tasks? The last one is circular reasoning if you are trying to argue that people shouldn't develop similar languages in other languages taht do not yet have them.
Wrong advice. He needs to stick to fundamentals not next shiny framework in market.
You can use the [`httptest`](https://golang.org/pkg/net/http/httptest/) package from stdlib. A simple example: var base = "https://api.example.com" func testFun() { http.Get(base + "/foo.json") } Testing code: func TestFun(t *testing.T) { server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) { // Write whatever you want; you can change behaviour depending on // request path, params, etc. w.Write([]byte("{}")) })) // Point requests to test server. base = server.URL testFun() } IMHO this is much better than "mocking" all sorts of stuff in the code, as that will make the code a lot more abstract/complex but not actually better.
So I implemented waveform today and noticed something funky with `skew_ratio`. The documentation [here](https://lan.developer.lifx.com/docs/light-messages#section-setwaveform-103) says it's signed 16bit integer with `[-32768, 32767] scaled to [0, 1]` (who does that? why not use unsigned with `[0, 65535] scaled to [0, 1]` instead?). So I implemented that as described in the documentation [here](https://github.com/fishy/lifxlan/blob/7db200226f07367f8d73540a4b665d0cb6b6d1b2/light/waveform.go#L49-L51) with [test here](https://github.com/fishy/lifxlan/blob/7db200226f07367f8d73540a4b665d0cb6b6d1b2/light/waveform_test.go#L29-L49). But it doesn not work as described [here](https://lan.developer.lifx.com/docs/waveforms#section-pulse). It works with `0.5`, but with `0.25` and `0.75` the behaviors are flipped from the document's description, so I have to actually do [`1-skew_ratio`](https://github.com/fishy/lifxlan/blob/7db200226f07367f8d73540a4b665d0cb6b6d1b2/light/waveform.go#L156) to get what the documentation describes. Maybe the documentation about pulse waveform got the current color and set color flipped?
&gt; I don't think it's suitable for systems level programming Might wanna specify what you mean by "systems level programming", given Go seems to advertise itself [as a systems programming language.](https://github.com/golang/go/wiki/GoForCPPProgrammers)
Tbh, in most applications there may not be an upside. Using pointers could technically be more performant if the size of the pointer is less than that of an instance of the struct, but that's definitely a micro-optimization and shouldn't impact 99% of applications. One potential benefit is using a type like `*myStruct` allows you to use `nil` when the struct wasn't set vs using the zero value, but you have to be more careful when doing so to avoid de-referencing a nil pointer. 
It was originally intended to be a C++ killer, but it turned out to be a ruby killer. It's not replacing C or C++ for things like operating systems or firmware.
The thing to remember is what you're testing. You're not testing their API, or the standard library's ability to make calls to it. You're testing your code that creates that call, and your code that handles the response to that call. Obviously, these should be two separate functions. You can use httptest to create a test server that checks what parameters you're sending to the server in the API call. You can then check that you're actually sending the right stuff in the call. Note that you're only comparing the response you get from your function (the parameters in the API call) with what you expect it to send given the inputs you gave it - this is just about checking whether your calling function does the right thing in isolation. Your response handler can be passed any kind of custom response to see what happens to it. Obviously there's a dependency on getting the mocked response to match what the actual API is going to send, so recording some actual real responses from the API and replaying them at your response-handling function is a good idea. To do an Integration Test that checks whether these two (or more) functions work well together to provide the functionality you need, is a different matter, and that can get more complicated as you may have to call a test version of the API to check that everything flows smoothly. But that's a different thing from unit testing the individual functions.
Note that your code example isn't formatted correct.
Have you looked into contributing to the community? Start reading the compiler and learn why they made the choices they did. If it’s more just ways to apply Go, then look up freelance boards and see what’s out there.
if you're looking to learn from the people who inspired Go (rather than the people who use Go as inspired) I strongly suggest "The Practice Of Programming", co-authored by Rob Pike. it is not Go-specific, as it predates it by quite a while, but a lot of the know-how in that book has definitely carried over to Go.
If you are foolish enough to introduce such a language to the company for anything outside of the most small and niche unix programs, you are incompetent and must stay away from this industry.
This is certainly interesting to me, though appears rather early on (missing a lot of plugins to make it functional beyond static address assignment). Will be keeping an eye on developments.
Damn, so much text just to troll? Is it a full time job for you?
&gt; Rob pike is a fucking idiot Seems a bit mean. Can I know how you really feel?
The problem is that tradeoff is not a choice. Some logs are just fine without it, some are useless without it
The only alternative to blackfriday I know from the top of my head is [golang-commonmark](https://gitlab.com/golang-commonmark/markdown) that implements the Commonmark specs. Not sure if and how it is extensible.
Rob Pike himself admitted it was a mistake to label Go as a systems programming language. He said it should have been rather called a servers programming language. IIRC, this was in the panel interview with the creators of C++, D and Rust. 
The usual suspects: - Corman, Leiserson, Rivest - Knuth - Skiena 
Which platform?
Better you can build your system around ipc like queues eg. rabbitmq and have part of system that is written in slower language that is doing modeling and other parts of system that require speed in go.
Make sure your calling close on everything. Http requests, files, database row sets and files are the most common offenders.
You might be interested in [Gorgonia](https://gorgonia.org/gorgonia): it's a Go-native library for doing deep learning. And yes, it is comparable with TensorFlow (owing mainly to both TF and Gorgonia outsourcing major work to CUDA)
Check out Gorgonia. It's equivalent to Tensorflow and PyTorch.
Speaking of ONNX, here's a Go version of ONNX, that interfaces with Gorgonia: github.com/owulveryck/gorgonnx
I mentioned that it was just the tip of the shit iceberg you motherfucker. 
Well if you read the comment properly you moron that was just one of the problems. Go crawl up rob pike’s asshole
While I appreciate seeing new releases of Go libs announced here, may I kindly suggest doing so only for minor or major releases rather than for every patch release? If no new or updated features are being announced, this only adds to the noise. Lib users who are interested in getting updated on patch releases may watch the repo for updates.
Please show some respect towards those who want to help you.
The reason why Go (the actual name of the language) is less "performant" than C is the same as why C is slower than FORTRAN. The more you allow the compiler to optimize your code the faster code it may generate. Unfortunately these optimization permits tend to produce (ugly to debug) bugs.
CUDA compatibility is a nice feature but it's also very platform specific and can be tricky to setup, which defeats some of the best parts of Go. From the looks of it if I were going for CUDA I would just use Tensorflow. Now, if someone made Goroutines that could run on the GPU, I'd probably faint. 
[removed]
Working on that
[Go 101](https://go101.org/article/101.html) is a book helpful for both beginner and experienced Go programmers.
Maybe a link to the code would be helpful. One can only speculate without seeing the benchmark. 
You're getting `nil` as expected: https://play.golang.org/p/YzPodDTVlKs
Are you trying to create a separate Mongo connection for every API request or something like that? `apiserver/db.NewMongo(0xac2b00, 0xc0008247c0, 0xc005620460) /mnt/a/apiserver/db/mongodb.go:14 +0x6f apiserver/server.(*Server).GetPosts(0xc0003d83c0, 0xc002004000) //mnt/a/apiserver/posts.conrollers.go:21 +0x4e` &amp;#x200B; There is not enough information provided to get an understanding of how your application is using Mongo. But in any case, you are not going to get the same throughput from Mongo as you would from a plain HTTP server. &amp;#x200B; &amp;#x200B; &amp;#x200B;
That means that Mongo refused the session, and you forgot to check the Mongo's error, just went on with a nil session handler. Do CHECK RETURNED ERRORS!
The `nil` value of slices is an empty slice. That's why in your example it prints `[]` instead of `nil`. If you want to check whether or not there are any submatches, then you need to compare the result of `regexp.FindStringSubmatch` to `nil`. /u/0xjnml showed this by editing your example.
PMML
Just an FYI. I was i the Python and Scipy community for years. Not too long ago it was thought Python could never compete with Matlab or Java in ML.
I didn't get your full question but I am also want to get a better understanding about using context in Go API projects
&gt; Does Golang need be good at everything? No. It is sufficient if Go is good at everything.
By using Go context package I just have an uniform standard for API timeouts and cancelletion across differnt Go packages or are there more benefits I'm missing? I can just use context in sort like an pipeline process in UNIX?
&gt;what are the main benefits against using writing own functions in an API for this? Well, of course you can write all this yourself. Like you can write all HTTP handling yourself instead of using net/http. Which makes the benefits obvious: a) it's done already, b) it's bugfree, c) other people know it already and d) other code uses it. &gt; Why are context safe for using with multiple goroutines? Well, because they have been programmed that way. &gt; Any links or resources you can recommend? https://blog.golang.org/context
Author of coredhcp here - yes, the project is at its early stages, but it's also already getting a lot of attention from various ISPs and cloud providers, and subsequently getting more reviews and development time. It is also based on a mature DHCP library, [https://github.com/insomniacslk/dhcp](https://github.com/insomniacslk/dhcp) , with well-tested parsing, server and client code. I will add more information about the status of the project on the README, so that users know where we are. Feedback, issues and PR are welcome! :)
&gt; Any links or resources you can recommend? Thanks for the detailed answer and link to the blog post!
You are comparing the `char` variable to the bare numbers 0 and 9, but you have to compare them to the ASCII value of these character, ie `'0'` and `'9'` (with the ticks!). Or just subtract `'0'` from char before doing your comaprisons, this way also you sum will be correct, otherwise you will be adding numbers which are much too high (by 48 for each digit).
Random items from the roadmap (non comprehensive): * API plugin (to control the server via thrift/gRPC/REST/whatever) * automatic configuration reloader * plugins to use multiple backends (e.g. mysql) * plugins to manipulate more DHCP options * a web UI based on the above API What's already there: * support for both DHCPv6 and DHCPv4 * plugin chain: every functionality is implemented as a plugin, and the server goes through each configured plugin * static file for leases (more dynamic backends to come) * custom server identifier
My teams work in FOSS. I could care less how your standards are trying to bankrupt whatever company unfortunately employs you. 
I can't really understand this: you _lock_ your vendored packages to their particular revisions one way or another. A tag is just a pointer to a commit, and normally tags never move (if a tag moves it's a potential disaster for obvious reasons). So once you locked a package to a tag it's absolutely the same to the case you would have locked it to a commit, just in the former case the "locked to" version looks prettier and more human-friendly (of which there is no dispute). But saying that a package does not support vendoring if it does not have tags is an unfounded claim.
Fired. Pack your box. 
thanks, I was comparing it to nil and it wasn't working, I guess it must've been something else :?
When you defer, the arguments are evaluated immediately. Only the call gets deferred. This is why you can't refer to variables, which are defined later on. Because the arguments are evaluated immediately, the function which you passed will be ran immediately. The result of that is used when the deferred function runs.
Only the top-level function call is deferred, its arguments will be evaluated at the time of creating the defer. Wrapping the whole thing in a lambda will do what you expect.
Thanks!
Yo Golang
Thanks!
&gt;My teams work in FOSS. I could care less how your standards are trying to bankrupt whatever company unfortunately employs you. Says the code monkey who employs a fundamentally crippled piece of shit to back its product. Go advocates are too stupid to use the most trivial of abstractions. If you truly think `void*` or some other loosely typed shit should be used in all situations you are nothing more than a cretin who's been duped into some old oaf's useless fantasy.
I'm not sure I understand your question right do you mean Godoc content or do you mean Godoc CLI tool etc. the Godoc website? Could you please provide more details this would make it easier to answer your question precisly 
That's rhetorical, right? [You can't do webscale without Mongo.](https://www.youtube.com/watch?v=b2F-DItXtZs)
&gt;Why are context safe for using with multiple goroutines? &gt; &gt;Well, because they have been programmed that way. And the reason that they are programmed that way is because they are used to cancel/timeout concurrent work.. The important feature is to cancel a whole bunch of work as soon as possible. It's a little bit similar to what exceptions gives you in single threaded applications except that you have to handle them at specific places in the code.
Hi, I've ported the kickstarter's event sourcing framework ([https://kickstarter.engineering/event-sourcing-made-simple-4...](https://kickstarter.engineering/event-sourcing-made-simple-4a2625113224)) to Go. Any feedback is welcome. 
It's a turing complete programming language, it can do anything you like. The assertion in the title is false. 
bugfree made me laugh :D
Take a deeper look at `net/http` and the `Handler` in there. It's a pretty generic approach which is based on the one simple method `ServeHTTP()`. `Handler` can be nested and wrapped, also the `ServeMux` is nothing else than a `Handler`. This way you got a simple toolbox able to implement any kind of method and path interpretation. Also it's pretty simple to build a function taking a `Request`, analysing `Request.URL.Path` and return the nth part of it (use `strings.Split()`). So here let your multiplexer point to a `UserHandler` and in the `ServeHTTP()` do a kind of `id, ok := GetPathElement(r, 2)`. And if the bool `ok` is `true` you've got the user ID in the variable `id` – so simple. And no, Go is not Ruby on Rails.
&gt; What are the main benefits against using writing own functions in an API for this? Context is currently more ubiquitous. This question could be interpreted as you asking "why should I include context.Context in my own method signatures?" or "why should I use context.Context, and not write my own solution for cancellation?" For the first possible question, it's basically because context.Context needs to be passed down through function calls so that the same context.Context instance can be used throughout a set of function calls, or for example, for the life of a single HTTP request. You can of course scope the lifetime of a context however you wish. For example, you could have something timeout within an HTTP request by using a context separate to the request context. For the second possible question, the answer would basically just be because context.Context is already widely used, and does work. If you wrote your own solution, you'd have to rewrite a load of other code, and would likely still end up using a context.Context somewhere to interface with other libraries. &gt; Why are context safe for using with multiple goroutines? I didn't feel that "because it was programmed that way" was really a good answer for this. Basically the cancellation part of a context uses a channel. Channels under the hood handle synchronisation for you, similar - if not the same way that a mutex would be used to synchronise access to something. When you close a channel it "broadcasts" that close to all consumers of a channel. So, when you call the cancel function of a context it's actually closing the "done" channel of the context, which then unblocks any waiting `&lt;-ctx.Done()` calls because they all receive that close message - triggering whatever shutdown / cleanup code, etc. that you might have.
If you think anybody cares, not mentioning the customers who pay your bills, then you’re fucking delusional. Our last Go powered components in a big project reached 1/2 million paying customers. It used JS, objective-C, Go, Ruby, and some bits of assembly tossed on for good measure. Without Go we would not have shipped a complex set of requirements in such a short time frame. Sticking to gRPC and protobuf saved an immense amount of time in linking smaller clusters together, some on opposite corners of the planet for a service that has to roll connections over to different dc’s depending on location. No errors, predictable perf, and easy devops. For that product it’s an excellent choice. For any Internet related product, Go is an excellent default choice. So What’s your story. Embedded? RTOS? or just building Castles in an era of condos? 
A good piece of advice someone gave me sometime ago; that code is primarily meant to be read by other humans, and *reading* code is essential in becoming a better programmer. I'd suggest picking up a relatively popular but simple Go repo, and try to understand the flow between data, the design decisions taken, and what you'd do differently. Then, try picking up a more complex repo, and do the same! It worked wonders for me when I was trying to battle through the initial phase of understanding to a more advanced level. 
any favorite golang git repos ? :)
I second this. Remember that the cost of your work, and the possible downtime of your website [will almost always](https://blog.codinghorror.com/hardware-is-cheap-programmers-are-expensive/) outweight the cost of hardware/bandwidth/servers. Pick what you're most comfortable in, get a free weekend and rush an MVP out, be it in Python, Go, Lisp, or even PHP.
!RemindMe 1 day
I will be messaging you on [**2019-01-15 13:36:57 UTC**](http://www.wolframalpha.com/input/?i=2019-01-15 13:36:57 UTC To Local Time) to remind you of [**this link.**](https://www.reddit.com/r/golang/comments/afv8gp/can_we_increase_the_number_of_concurrent_users/) [**CLICK THIS LINK**](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[https://www.reddit.com/r/golang/comments/afv8gp/can_we_increase_the_number_of_concurrent_users/]%0A%0ARemindMe! 1 day) to send a PM to also be reminded and to reduce spam. ^(Parent commenter can ) [^(delete this message to hide from others.)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Delete Comment&amp;message=Delete! ____id____) _____ |[^(FAQs)](http://np.reddit.com/r/RemindMeBot/comments/24duzp/remindmebot_info/)|[^(Custom)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[LINK INSIDE SQUARE BRACKETS else default to FAQs]%0A%0ANOTE: Don't forget to add the time options after the command.%0A%0ARemindMe!)|[^(Your Reminders)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=List Of Reminders&amp;message=MyReminders!)|[^(Feedback)](http://np.reddit.com/message/compose/?to=RemindMeBotWrangler&amp;subject=Feedback)|[^(Code)](https://github.com/SIlver--/remindmebot-reddit)|[^(Browser Extensions)](https://np.reddit.com/r/RemindMeBot/comments/4kldad/remindmebot_extensions/) |-|-|-|-|-|-|
Figured it out. Why this happened is beyond me though. What I ended up doing was to tank `$GOPATH/pkg/companyname`. I then ran `for x in $GOPATH/companyname/* ; do go build -i companyname/$x ; done`. This recreated the package objects under `$GOPATH/pkg/companyname`. Now it works like a charm. The maintainer over at nsf/gocode makes a good point: Autocomplete tools should work with source code, not these somewhat workaroundy platforms. This however will at least resolve any issues someone might be having. Happy gophering
This looks just like pipelines, described on the Official Go blog here: https://blog.golang.org/pipelines
"More bugfree than your code" would be more correct.
Hmmm, there are way more experienced people in here who could chime in, here's a couple of my suggestions: - [golang/go](https://github.com/golang/go) You will hardly find anything more go-like than the official language's repo - [spf13/cobra](https://github.com/spf13/cobra) Is used by many FOSS projects, and is quite popular - [fogleman/pt](https://github.com/fogleman/pt) A path-tracer written in Go, it's quite fragmented as a repo, could maybe be grouped better - [mattn/memo](https://github.com/mattn/memo) A simple program, that is quite congested, maybe could be broken up more - [ncw/rclone](https://github.com/ncw/rclone) Useful app, which I think is nicely broken up, and follows some good practices
Even better, make use of https://github.com/stamblerre/gocode
Thank you so much for the guide. I will try this approach. 
Your results don't make sense to me. I have to assume you've run out of file descriptors. Try adjusting your ulimit to something arbitrarily high or 'unlimited'.
Silly question, but can you see what limits are you hitting? Is it really an issue with concurrency? I'd check if you're hitting some [file descriptor](https://stackoverflow.com/a/23319116) limit, some bandwidth limit, if the memory usage spikes when running the test (16GB should be more than enough tbh), or a Windows-specific bottleneck. If you'd have a much more complex handler, where time would be an issue, you'd probably want to use a job-worker pattern where you'd use different channels to queue 'jobs' and execute them.
The same machine running a com.sun.net.httpServer actually handles more connections than the golang server, that's what confused me. 
sry for nitpicking
it looks silly, but the point is does go actually handles this correctly? I checked the same with Sun's HTTPServer as i mentioned. On same machine, On same OS. &amp;#x200B; It had less errors during the test actually, even with a load(it executes a process and return the result to the client, 18% error on 5000 requests by JMeter), while on go i had 83% error percentage
thanks SO link seems useful for me :) 
The context package provides just that: Context around the execution of a go-routine or "the circumstances that form the setting of an event." One of the circumstances around an event is a time range or deadline. That is, if you were going to announce a party, one of the things you'd mention is when it was going to happen and for how long. The time that a party occurs really doesn't have anything to do with what kind of party you're having or what kind of cake. In this way, context doesn't (or really, shouldn't) impact the details of what your go-routine does; the context just sets up the environment in which it runs. Likewise the context package provides ways of specifying how long a go-routine should run with `WithTimeout()`, `WithDeadline()`, and `WithCancel()`. `WithTimeout()` and `WithDeadline()` allow you to specify the the timing portion of the context of your go-routine. They both behave in a similar way -- one you pass a duration (I'd like this go-routine to run for at most 1 minute) and the other allows you to set an absolute time (I'd like this go-routine to run until, at most, 1:30). They both also provide a `CancelFunc` which allows the caller to trigger the cancellation of a go-routine at any time. `context.WithCancel()` returns a cancel function only and doesn't provide any timers. Of course, it is important to always know how and when your go-routines will end. `WithTimeout()`, `WithDeadline()`, and `WithCancel()` allow you to do that. To stretch our party analogy further: It would be pretty brave to extend an open ended invite to a part. Finally, context `WithValue()` allows you to pass a key/value pair down the the call chain. These values should be contextual as well -- in that they shouldn't really alter the behavior of the go-routine but inform it -- to provide information about the circumstances under which the go-routine is running. For example, if you are writing a web service and you want to communicate session information down the call chain. That information is what some people would call "request scoped" meaning it is only pertinent to the functions involved in servicing that request. The way I think about it is if absolutely no other go-routine would care about the data, then I might put it in a context value. So, for example, a database handle (like something of type `*sql.DB`), almost certainly wouldn't go there if you have other go-routines that use the exact same `*sql.DB`. If we're using our party analogy, maybe our party has an address and maybe it has a dress code. These things don't impact exactly how we have the part but inform us of the circumstances around the party. So, in short, I think context communicates contextual data in which go-routines should run. The two major types of contextual information are: (a) how the go-routine should end; whether this is by some timeout or by providing a mechanism for the caller to end it directly and (b) contextual values that inform but not affect how go-routines should run. 
I mean Godoc web content, design, usability, navigation
I learned it from Just for Func https://youtu.be/LSzR0VEraWw
awesome thanks !
There are a few things I missed in Godoc. So I searching for more powerful alternatives. Some examples what I mean: * I think it would be cool if near the names of functions and methods, there is a button, clicking which I will see the source code, not a link to it. * possibility to hide vendor directory * show TODO(all comments start with “TODO:” or the same)
“No generics, lol lame not as good as Rust thanks g$$gle” is the usual way to mock Go. 
Nice to see people thinking along similar lines. Over the holidays I started working on an implementation vaguely along these lines, but with a goal to support both the web, and mobile. This goal adds some complexity when implementing native widgets, but I think with a decent core widget set most users will be able to get away with just writing framework widgets (ie - widgets that don't need knowledge of the underlying platform). In any case, while working on Vecty we discussed many of the approaches described in the article as Vecty evolved, and came to similar conclusions. For my current project, I've decided to try using struct fields rather than a functional approach - I'm not sure the constructor/option-struct pattern adds significantly to simply using fields on the widget directly. The *interesting* parts start to emerge though when you actually integrate the rendering pipeline - the ideal user-facing API is not always so easy to realise.
sorry but shitty article, really opinionated,biased and not professional...stop trying thinking about a language for everything, every language has its pros and cons...
It’s an object that contains a “done” Boolean. You can pass it around to various goroutines, each of which should watch the variable and exit if the value is ever true. It’s thread-safe. It can return a “cancel” function that sets the internal “done” boolean for you. You can also add arbitrary key-value pairs to it. The big selling point is that it allows you to cancel long-running async operations rather than just abandon them.
&gt; I think it would be cool if near the names of functions and methods, there is a button, clicking which I will see the source code, not a link to it. Click the name of the function itself. Don't feel bad, I made this exact post to /r/golang a while ago too. &gt; possibility to hide vendor directory Do you mean the possibility to show it? It already hides them. What version of Go are you on? &gt; show TODO(all comments start with “TODO:” or the same) It does that already for `BUG:`. In a command-line invocation you can add more things via the -notes parameter; see `godoc godoc` and look for `-notes`.
It's my personal blog, so it's ok to be opinionated and biased. And I'm not sure what do you mean by "professional", but your rude comment is not professional either. As for "language for everything" – that's true, trying to fit a single language into any niche is doubtful pleasure, but that's exactly what I tried to explore in the article. Where and how Go will fail to address needs of decent UI framework. Many people are 100% sure that you need generics for that, and my experiment showed that it's mostly syntactical thing and Go actually is a good fit here. If you disagree, please elaborate on your opinion, I'm genuinely interested.
A few thoughts. Flutter uses Google Skia library to do all the drawing. Creating bindings for Go could be a huge undertaking. Building on top of `shiny` might be a better approach but will also require writing a lot of code to support themes and all features required by Flutter-like engine. Using dot import is not OK. Chaining methods during widget build phase might work because most of the methods won't generate errors. Dart has one over Go in this by supporting exceptions. Once you consider handling errors proper, the code will look uglier. Flutter supports hot-reload (and continuing from the place right after the change) during development thanks to Dart VM. There are attempts to create an interpreted version of Go but building full VM is a big undertaking. Dart and Flutter work well together. In my opinion, GUI solution for Go should be more idiomatic instead of emulating other systems. 
Very interested in this, I'm working on a sensor network where the Gateway aggregator and Cloud services are written in Go. I was planning on using InfluxDB as the sensor readings database and PostgreSQL for context (location, device types etc.) Being able to use the same Database will make deployment easier. But InfluxDB has good tools for viewing and analysing, so I will need to balance that. But I'll have a go with this and see how it works, I hope that I can sort out a reactor that will convert the data to a readily available Dashboarding/reporting tool.
Check ulimit still (assuming a unix environment), see what you are working with. Default is like 1024, and after that, you get errors. If you take your connections down to 500, that is another way to vet if it is file descriptors (assuming you are not doing something else at the same time using up that limit). You \_should\_ get zero errors with your benchmark, and should be doing like 5x the rps you are getting no problem on a standard macbook. I'm not familiar with com.sun.net.httpServer, and so maybe there are strange improvements there. 
sure thanks for the reply
Try comparing with notEqual to an empty string: {{ if .currentTitle ne "" }} 
This might be a dumb question, but the example in the README shows opening a local file. Does this support 20 servers using the same DB? Or is this more for single-instance apps?
Yes, it's local file. Pudge is embeddable database engine, it's working like library, not as server
But he said Mock ***In*** Go: ```go package main import "fmt" func main() { fmt.Println(“No generics, lol lame not as good as Rust thanks g$$gle” ) } ```
Gotcha. Thanks for the clarification.
I think the incompatibility you're referring to was the lack of support for the grpc-web-text content type. This got merged into the Improbable repo recently, so I believe the Google JS client is compatible with the Improbable in-process Go proxy (https://github.com/improbable-eng/grpc-web/pull/292). I haven't tried this myself, but that's probably the combination I'll attempt to use once I'm at that stage in my project.
They are different types, one is int and the other one is string
Try to declare waitgroup as "waitgroup := &amp;sync.WaitGroup{}"
Didn't work, same error :(
However, it does support time range and meta data based filtering. The idea is that once structured log data fits in your computer's memory, you can grep or regex search on it. I think this tradeoff is a fair one as almost most of log related searches are for error messages or a specific ID. It rarely requires the sort of stemming, tokenization and relevance scoring that is required for full text passages.
sizes := make(chan int64, 4) &amp;#x200B; &amp;#x200B;
Doing what you suggested reduced the error but still doesn't work: File /tmp/test3 size 237 !!!!!!! File /tmp/test1 size 79 !!!!!!! File /tmp/test2 size 158 !!!!!!! fatal error: all goroutines are asleep - deadlock! goroutine 1 [chan receive]: main.sum_file_sizes(0xc000064180, 0x4d8fa0) /home/gophie/go/src/bitbucket.org/gophie/tutorials/goroutines_parallelism.go:15 +0xf6 main.main() /home/gophie/go/src/bitbucket.org/gophie/tutorials/goroutines_parallelism.go:56 +0xc0 exit status 2 &amp;#x200B;
Inside sum_file_sizes you range over files which is chan will be closed only after exit main function. You should read how defer works.
Neither. Just use Shopify or setup something like WooCommerce/Spree. Spend the development efforts on making the experience better for customers (better storefront templates etc.). Web store fronts are not complex but require a lot of features like product catalog, pricing based on variants/bundles, tax compliance, refunds, payment gateway integrations, coupons etc. There is no value in rebuilding if you are starting new. So I would recommend that you use existing open source projects or existing services. There is still plenty of stuff you can scratch your "build with golang" itch with things like your mailing list integrations or differential pricing or just going crazy with your reports. Most of these platforms have a very decent API that you can use to write all manner of extensions that would serve your business needs.
Nice
Ooook that was it, thank you! I've read and used defer before but I didn't see the problem since I was too focused on the sum function. &amp;#x200B; Thanks again!
There is no need for a buffered channel here. The other suggestion about the main defer to close the input files channel is correct. 
The waitgroup value is fine. It isn't being copied around. 
And the way you could read that deadlock stack trace for debugging is that you can see it got your 3 input files and is blocked on 3 goroutines trying to send the size results. And the 4th goroutine is stuck reading the files input channel. So you can see nothing can proceed past that for loop which points to nothing closing the files channel. 
Yup, you're right. I kept the sizes buffer asynchronous. There's only need to add buffer to the files channel since otherwise the program would've been blocked from the start (deadlock).
Nice read. I have started learned Flutter over the last week so this was good timing. I both agree and disagree with the opinions in the writeup. It does prove that at least with the given example project one could potentially express it in Go. Although the lack of hot code reload would be a problem. I've been a Qt developer for many years so funny enough I am actually most happy with the non-tree linear definitions. I haven't learned enough of Flutter yet to know if this is a problem, but one thing I think could be an issue with Go would be the lack of 1st class constructors. One would not be able to pass a prototype so that it could be constructed later. The constructor function would have to be passed, and the arg spec would have to match what is expected. Just a random thought. 
Nice article, thanks! Two suggestions (or, maybe, questions about why you didn't take these approaches): 1. In "The State," instead of an explicit call to `Rerender()` how about having action function signatures return a bool, and return `true` if the widget needs to be redrawn? Having a hidden requirement like forcing the dev to remember to call a function increases the opportunity for bugs. 2. Version 5 of your tree could exclude the function calls and just be sets of parameters. Tree creation happens rarely so having extra work in the builder to test param types and call the right constructor wouldn't be too onerous, and would make the code cleaner. I like it; thanks again!
thank you for your informative post - like OP I too have had this nagging question in writing my own services and found when wrapping GCS (google cloud storage) I needed to provide a context but didn’t know why or how I should (context comes with a nifty method `context.TODO()` fyi if you’re not ready to make the plunge) but I want to come out of my shell with stunning this and consider if the only part of my app with context is GCS or should more operations like mongo, rabbitmq, and my own services be wrapped with context? What would you say on that?
Thanks! 1. Interesting thought, but the benefit here is that we don't restrict developer in ways how to work with state. They could launch separate goroutine to update state or put it somewhere in defer/closure/etc. 2. I like it. That's like truly 100% declarative way :) Probably not the most flexible way, and will require some reflection magic to automate widget building function, but definitely an interesting approach.
 ![Alt text](/path/to/img.jpg "Optional title")
Thanks! Fair point on hot reload, but that's an interesting challenge by itself. I bet if Flutter team have chosen Go, they'd come up with a decent solution. Currently Dart ships VM only in debug mode and exactly for the purpose of Hot reload, but the release code doesn't have one. Maybe Go compilation speed could provide near-hot realtime, don't know. I'm not sure I understood the problem with "first class constructor", though.
Were you comparing it to nil or were you looking at fmt.Printf output and assuming it wasn't nil? Take a look at https://play.golang.org/p/UA_YZUFx-kK for seeing the real type and value returned. It is returning nil of type []string.
That's awesome. Is the project you described publicly available? I would love to track it. And thanks for the work on Vecty, it's fantastic!
Thanks for you comments. Yeah, UI framework requires insane amount of well-coordinated contribution. As for the dot imports – in general, it's a bad practice yes. But here is the thing – normally we write in Go and choose the library to use. Language (Go) comes first, library second. In this case, I want to write in Flutter and underlying language is the secondary (the whole point of the article is to show that this underlying layer is abstracted well enough and theoretically can be Dart or Go or something else). So Flutter comes first, language (Go) second. This reverse order makes it okay to have dot import for me. In all other cases, it's a bad practice, for sure. Not sure I explained the difference clearly enough, but that's my line of thought.
I'm waiting on a .dev domain registration to complete before I publish anything, so that I don't have to change the import paths. I'll try to remember to update here when February rolls around.
 type Category struct { id int Parent *Category }
[removed]
Ah, that simple! Thanks
1. In practice, it's not onerous at all, and lets the user explicitly control updates. 2. Tree generation actually happens all the time - every time a widget updates, that whole sub-tree needs to be re-rendered (or at least the internal representation must be regenerated, this may or may not result in updates to the rendered content).
If you're coming from another language and already understand what a framework does under the hood, then definitely find a library for what you want to do. Gin is really nice for what you described: https://github.com/gin-gonic/gin There is authentication middleware available for it. There's even some middleware for auth you can use that can be used with standard library http router.
Can i ask you why don‘t you ditch gvm for docker compose variables for the go version? From golang:{version} And start docker-compose with an .env file If i misinterpret the gvm intention please let me know i did not know it 
 &gt; &gt;I'm not sure I understood the problem with "first class constructor", though. I was trying to find a similar reference to this topic that came up when I first started trying out the github.com/therecipe/qt bindings. The problem I saw was when you want to reuse and extend widgets. The lack of an implicit constructor meant that if someone extended a widget, they would have to be sure to directly call the embedded type constructors and not use the new widget by value. But seeing as I can't find the original link I imagine it doesn't translate to a Flutter architecture and one would expect that a NewFoo would construct a Foo and call the constructor NewBar to init its embedded Bar field. And one would never use a Foo zero value. 
I just asked Siri to remind me to check this thread as well :) Thanks!
Holy shit, this is beautiful!
Yes and by design: `go run` does not cache compilation results.
Any type must have computable size. If it does not then it's a `invalid recursive type`.
The difficult part of GUI programming isn't in the drawing, but is in the layout and event handling. Flutter's approach to layout is simple, but efficient and expressive for complex interfaces. Relying on skia for 2d graphics was wise in allowing them to tackle problems like layout, text, animation, etc. However, it doesn't make or break flutter's architecture, i.e. they could plug in a different library if they wanted. Although they use a declarative model for describing UIs, most interactivity and event handling is done through callbacks, a mechanism that is not as commonplace in Go code. Go's concurrency model allows for an expressive way to define interactive UIs through goroutines, channels, and the select statement. It would probably be more programmatic than flutter since one can chain goroutines to filter a channel of events.
How about building it using proto3 models w/ regular param/result for normal calls and channels for streaming ones. Then you can build the thin layers to translate to any of the communication methods and be able to switch (using proto's binary format in some cases, json in others, whatever). I don't usually advocate for over-abstraction like this on initial versions, but in this case it might have value to make the separation and just pick one protocol impl to start with.
that'll throw an exception
Uh - what happens if I change the capitalization?
I didn't mean to say it's impossible, but it's impractical. If you use a package with a good versioning strategy, you can easily upgrade your dependencies, e.g. from v0.1.0 to v0.1.1 without reading every commit and inspect every change. There is an implicit trust that revision changes fix bugs but don't introduce API changes. That makes it easier to handle your dependencies. At my current project, we're only using versions. Depending on libraries without releases is disallowed. 
One thing my team at work does is put a unique id in the ctx for each request our services handle so you can track the logs for that individual request while multiple unrelated goroutines are logging. We filter out the logs that don’t have that unique id and can easily follow what’s going on. Not so easy when 20 requests log simultaneously with no way to filter.
Shameless plug: [This might be useful to you](https://blog.merovius.de/2017/06/18/how-not-to-use-an-http-router.html) :)
Don't worry, I am Android developer for 2 years and still have no idea what context does
Related talk: [https://talks.golang.org/2014/testing.slide#1](https://talks.golang.org/2014/testing.slide#1)
What's up with Go community for downvoting people who are asking for help? Reflect bad on the folk, guys and gals. I'll just take this print screen just in case.
Thanks for info! It was blocker for me at that moment and I've switched to using envoy.
Comments from previous discussions: https://news.ycombinator.com/item?id=18857162 https://www.reddit.com/r/programming/comments/adwhk3/courier_dropbox_migration_to_grpc/
Makes sense. If it's a value, then the zero value would be another Category, and you would have initialized, zero-value Categories all the way down until you overflow the stack. With a pointer, the zero value will just be nil
A nice video. [https://www.youtube.com/watch?v=LSzR0VEraWw](https://www.youtube.com/watch?v=LSzR0VEraWw)
[removed]
I guess, if GUI building is restricted to `main` or dedicated package, all the business logic lives in other packages, and you guarantee no accidental shadowing, then it would be OK to dot-import. Personally, I'm fine with package prefixes all over widget building code so long as prefix is short and clean.
no, vscode is much better
I used this package a few weeks ago for a project, but ultimately wasn't able to do what I needed. It's a cool package, but unfortunately, it seems that once I got the program running in a Chrome profile, and then the only change was making it run headless, it ran as a different profile, making it impossible to use an earlier login from the non-headless configuration. &amp;#x200B; Has potential, but needs work. :)
Hello thank you for your response. I'm currently working in a project that its' leader just left so it was already like this, but I'm not sure what'd be the answer for not these questions. I'm sorry, I've had never used Docker before. As far as I know this gvm is used to manage Go's version in case of a update, is it correct? I think the project leader may have wanted to use it so it could be updated while deployed or something like that? And why shoud I start docker-compose with an .env file? Real question. &amp;#x200B; &amp;#x200B; &amp;#x200B;
Hello thank you for your reply! Well yes I'm really having a hard time on this, mainly I think because of Docker but I'm also not experienced using Go as well. Thank you for your kindness by the way.
Nice. But I’ll stick with BoltDB.
Apparently, there is an experiment with [Flutter desktop embedder in Go](https://github.com/Drakirus/go-flutter-desktop-embedder) 
You've had decent performance from and SPA on a Raspberry Pi?
I've got four /humblebrag
Thanks, I'll have another look.
Thanks! I'm experiencing large write and read performance degradation on long living db with bolt, when db size don't feet in memory. I don't want write what bolt is absolutely garbage, it has nice api and work very well on ssd and very small databases (less than 16 Gb in my case). Be careful with bolt. 
Why mock the database at all? The performance impact of a real databaae is low, how many requests can your app handle per second? And the resulting tests are so much more readable and robust to changes. Save the mocks for external services imo.
From go-watcher repo ``` For the cases where your main function is in another directory other than the dependant package, you can do this by passing a different package name to -watch parameter. watcher -c config -run github.com/username/somerootpackagename -watch github.com/username ``` So something like this should do the trick. ``` CMD ["watcher" ,"-run", "/go/src/finance/cmd", "-watch" ,"/go/src/finance" ] ```
The submitted url is https://blogs.dropbox.com/tech/2019/01/courier-dropbox-migration-to-grpc/?utm_source=Software+Weekly&amp;utm_campaign=ee67f84f3d-EMAIL_CAMPAIGN_12_03_2018_16_23_COPY_01&amp;utm_medium=email&amp;utm_term=0_846fac531b-ee67f84f3d-183167697 Who not use https://blogs.dropbox.com/tech/2019/01/courier-dropbox-migration-to-grpc/ direclty? 
Can you provide a code example where it does not work as expected?
Take a look at the Plush package. I found it to be easier for templating.
ELI5 please :)
Great one, would recommend anybody that is struggling with understanding context
How does one upgrade Go project written in 1.6.4 to the latest version
Yeah, it's the renderer for desktop GL. I mentioned it in article.
A REM song comes to mind
to answer your question first: if you would want to substitute variables in the docker-compose file you would need a way to do this. Sure there is "sed" or "envsubst" or something alike, but docker-compose way to do this is: use an env file with your values in it. $ cat .env VERSION=1.10 $ cat docker-compose.yml version: '3' services: app: image: "app:${VERSION}" i come from the viewpoint that a docker image/container should be immutable, just so you know why i am arguing the way i do ;) i would suggest ditching the whole golang version change in runtime. This is in my pinion not only a bad idea, but also makes things a lot more complicated. If i would have to do this, i think i would build a docker image for each major golang version and reference them in the compose file whenever i want to change them. And inside the docker image i would just install what i need in order to function correctly. a dockerfile could look like this: &amp;#x200B; `FROM golang:1.9` `LABEL maintainer="Can Yucel` [`can.yucel@gmail.com`](mailto:can.yucel@gmail.com)`"` `ENV WATCHER_VERSION 0.2.4` `ADD` [`https://github.com/canthefason/go-watcher/releases/download/v${WATCHER_VERSION}/watcher-${WATCHER_VERSION}-linux-amd64`](https://github.com/canthefason/go-watcher/releases/download/v${WATCHER_VERSION}/watcher-${WATCHER_VERSION}-linux-amd64) `/go/bin/watcher` `WORKDIR /go/src/finance` `ADD ./build/package/entrypoint.sh /go/src/finance/cmd/finance` `RUN chmod +x /go/src/finance/cmd/finance/entrypoint.sh &amp;&amp; \` `chmod +x /go/bin/watcher` `ENTRYPOINT ["/go/src/finance/cmd/finance/entrypoint.sh"]` `CMD [""]` 
Simple and concurrent don't go together
LiteIDE is exceptionally good. The only problem for me was Qt. Maybe it's just me, but I've experienced lag with LiteIDE based on Qt.
Looks good. If you're interested in a basic code review of the stars demo just let me know.
yeah, skew\_ratio is a bit confusing, looking at it now I'm also a bit confused. I'll see if I can get some clarification when I'm back at work from sick leave.
Interesting. True, my use cases have only dealt with embedded key value stores that usually all fit in-memory, and don’t require this kind of read/write performance.
&gt; What's up with Go community for down-voting people Always remember that it's not just the "Go community" that has access to this sub. There are people who actually waste their time hating on Go's success. Take a glance at /r/programmingcirclejerk/ for example, they were caught in [explicit vote manipulation](https://www.reddithelp.com/en/categories/rules-reporting/account-and-community-restrictions/what-constitutes-vote-cheating-or) in a not distant past with a post. I reported to Reddit Admins which acknowledged their wrongdoing and warned them. Nothing is stopping this [kind of people](https://i.imgur.com/VM11APw.png) from coming to downvote and troll posts here. In fact they link comments and posts from /r/golang in their sub frequently and whatever they link clearly gets downvoted here. To think otherwise would be rather ingenuous. So no, it's not just the Go community. There are people and even subs dedicated to doing nothing but degrading the experience of subs like ours.
&gt; Uhm, to me, the stateful widget is just a widget without a state, so why invent a new class here? It's a marker. Introspecting a Widget to determine if it has fields and whether those are state or just internal fuzz is not possible in the general case. However, knowing that a widget is stateless helps the rendering engine eliding redraws; saving time and increasing performance.
Thank you so much for the heads up. That absolutely makes sense to me. I'm sorry, the project structure was a little different than I've posted - the main.go file is actually in `"/go/src/finance/cmd/finance".` So I have tried to put this in Dockerfile: `CMD ["watcher" ,"-run", "/go/src/finance/cmd/finance", "-watch" ,"/go/src/finance" ]` But it still gives me: &gt;can't load package: package finance: no Go files in /go/src/finance What I find really weird is that there is actually no package called finance in my project... &amp;#x200B; By the way, from this quote you've sent, it says I can pass a different package name to -watch parameter. My main package is `/go/src/finance/cmd/finance` (called `package main`), where my `main.go` file is situated, so did I get it wrong or does the -watch parameter actually should go with `/go/src/finance/cmd/finance`? Well, I've tried it like this but it also didn't work. :-\[ Anyway, also from the go-watcher repo, there is: (we assume that your GOPATH is properly set) And as I've mentioned before, I think my GOPATH is being messed up by GVM. So your answer is probably correct and will help once I get rid of this trouble with my GOPATH. I'll probably get rid of GVM, or find an alternative.
Hey foofoo300 thank you very much for your answer. I'm sorry I think I may have got confused. Yes I'm actually using a docker-compose.yml but I totally forgot to mention it. Here it is: &amp;#x200B; `version: '3'` `services:` `db:` `image: postgres` `environment:` `POSTGRES_DB: dev` `POSTGRES_USER: postgres` `POSTGRES_PASSWORD: *********` `ports:` `- 5432:5432` `app:` `image: canthefason/go-watcher:latest` `command: watcher -run finance` `ports:` `- "80:8080"` `environment:` `- GO_VERSION=1.9` `- GOPATH=/go` `volumes:` `- .:/go/src/finance` `depends_on:` `- db` &amp;#x200B; So is this file wrongly configured? From what I understood the GOPATH variable that I set in Dockerfile is being used in here, or is it the opposite? &amp;#x200B; Also, basically then you'd recommend me to ditch GVM and use the Go's version that I want to use directly in my image? I really don't know why the project leader was using it. Or if the case is that it's really good to use it, do you know any other alternatives I could use instead of GVM?
i think i still not fully understand your problem. What exactly would you like to accomplish with this setup? What i understood is: you want to rebuild your application whenever a new file is pushed or a file changes, right? &amp;#x200B; what i would go for is question why you want to do that, or is really needed or just bad design? Can you elaborate a little bit what your application does so i can better understand and maybe come up with a good solution for this particular problem? &amp;#x200B; normally what i do is: 1. i change some code for my go application 2. i rebuild the image 3. i redeploy the image to my "server" this all could be automated sure, so if you do this to reduce toil then your(or your predecessors) approach is maybe not the best. I strongly would ditch gvm if it's only purpose is to choose a golang version. Because if i have to change the golang version i could just build another docker image, they are pretty cheap to build and to run and much more simple if it's just go and your watcher instead of go from gvm with all it's specialities and problems and the watcher. But i love to be enlightened if i am wrong because i am curious now :)
 you want to rebuild your application whenever a new file is pushed or a file changes, right? Yes, what you understood is definitely right! what i would go for is question why you want to do that, or is really needed or just bad design? I have been working in a company for some time as an intern and the project leader did it this way (with a Watcher) and he used to say we should use it, because this is a micro service and when it gets deployed any changes made to the Go files would be automatically recompiled and run by this Watcher, or something like that. But he got fired some time ago and I took over the project. Also, as you've said, you rebuild the image when there's a change to a Go file - I think we are trying to bypass that need of rebuilding the image every time there's a change, as it takes some time to rebuild it and it kind of delays the programming, debugging and stuff. Can you elaborate a little bit what your application does so i can better understand and maybe come up with a good solution for this particular problem? In sum I'm developing a micro service in a Docker container, the project is implemented with Golang and using PSQL. Also, I'm using a Watcher to automatically recompile and rebuild and run again the Go files every time I make a change to a Go file. At last, the Go version and installation are being managed by GVM. When I run the Docker container, the GOPATH is always being set by GVM and I can't change it to the path that I want to use (`/go`). It's always being set to `/root/.gvm/pkgsets/go1.9/global`... and the Watcher assumes the GOPATH is set correctly (that would be `/go`). Therefore, the Watcher is unable to compile and run the project, as it is (probably) looking for the wrong path. I think the problem may be this, wrong GOPATH being set by GVM... I strongly would ditch gvm if it's only purpose is to choose a golang version. Yes I think I'll definitely ditch it, as I can't seem to find a way to change the GOPATH correctly inside the Docker container, from the GOPATH that the GVM uses.
Thanks that was really insightfull. without sugar coating: this is a very bad idea! there is very good reason, why everyone in the business is implementing a CI/CD pipeline to rebuild their application whenever files change. You want versioning and tests. You do not want a behaviour change in your application whenever someone changes code. This is utterly and overall bad design from the start. Second to that, just because it is a microservice does not render the first argument obsolete. So but to help you further with your question which a very like to do: I assume you want to continue doing the way it is now: 1. ditch gvm there is no reasonable argument to change the golang version on runtime. 2. use the official image from golang. FROM golang:1.X 3. configure the watcher as you would normally but ditch the entrypoint script if it is not helpfull and start the watcher with only the CMD instruction something like this: CMD ["watcher"] I hope this clears stuff up, if you need help implementing it, and you struggle to accomplish, drop me am PM and i will try to help
I just want say. I like this logo. 
 everyone in the business is implementing a CI/CD pipeline to rebuild their application whenever files change I've recently graduated from college and saddly, I learnt little to nothing... I even had to search for what is a CI/CD pipeline, lol, but that is indeed a great approach to what we're in need of. I assume you want to continue doing the way it is now As I just took over this project and we're delayed to deliver this project, I may first try to get this Docker container up and running in this (bad) way. But I really liked this CI/CD approach, if I understood it rightly, and I'll definitely talk to my boss later on and convince him to let us implement it in this project. This is utterly and overall bad design from the start The former project leader was a very stubborn and hardheaded person, he would not accept any recommendations or improvements and demanded us to do everything exactly in his way. That kind of makes sense because, of course, he was the project leader and I was a mere intern, but now it feels good to know that he was not following through a good direction. I'm very greateful for your heads up. use the official image from golang. FROM golang:1.X If I correctly understand it this image that I'm using implements a "Debian" Linux container, right? So let me ask you, can I use multiple images within the same cointainer/Dockerfile? If I was to use this official Golang image, can I use it within this other Debian image? configure the watcher as you would normally but ditch the entrypoint script if it is not helpfull and start the watcher with only the CMD instruction something like this: CMD ["watcher"] I'm also not exactly sure what this entrypoint script was doing, but when I tried to rebuild the image with --no-cache flag, this happened when I Docker build: `Step 13/16 : ADD ./build/package/entrypoint.sh /go/src/finance/cmd/finance` `ADD failed: stat /var/lib/docker/tmp/docker-builder594091183/build/package/entrypoint.sh: no such file or directory` So from what I understood, this error showed up, (I think) because there was no [`entrypoint.sh`](https://entrypoint.sh) in the volume. So I've created a pretty dumb [entrypoint.sh](https://entrypoint.sh) file in my volume so the Docker could mount it inside the container, but it doesn't do anything, I made it just so the Docker container could get completely built. This is the [`entrypoint.sh`](https://entrypoint.sh)`:` `#!/usr/bin/env bash` `set -e` `exec "$@"` I'm really not sure why it is being used, and why should I set an ENTRYPOINT in the Dockerfile.
ok then let me follow up a little bit. the entrypoint.sh is for these scenarios for when you want to do more than just fire up a single command. let's construct some simple example. there are 2 commands you need to execute then you would create an entrypoint.sh (you can name it whatever you like btw) with: `#!/bin/bash command1 command2 and your dockerfile would look like this: FROM debian ADD entrypoint.sh /entrypoint.sh RUN chmod +x /entrypoint.sh ENTRYPOINT ["entrypoint.sh"] #################### with in your case just a single command issued namely watcher i would ditch the script entirely looks like this #################### FROM debian ADD your-code /your-code WORKDIR /your-code RUN install watcher with curl and stuff RUN chmod +x watcher CMD ["watcher"]
I've settled on two test suites. Normal 'go test' for unit tests* and an acceptance/integration test suite. Unit tests: remote stuff is behind an interface that allows fakes to be passed in. These allow for validating error code paths and such. Here, there is no DB and absolutely no mocked DB. There is an interface like 'UserGetter(userID int64) (User, error)' and code in my test can return a User or an error. The acceptance/integration tests spin up (in docker, but soon, kubernetes) one or more working environments. They test the service from the black box level, with only access to it's external API, emitted metrics, and logs. It runs real DBs and small services under my control, and represents everything between the edges of what my service under test needs. For some dependencies, I'll have a stub service running or a sink. This let's me know that errors are handled correctly and that my running service will behave correctly. * I typically will use 'go test' in subpackages, but at the root package, I use a test runner (bin/test, but make test would work) that exludes my acceptance test directory and ensures that tests run with the race detector.
It's easy simple, dont start with a framework, start with the basic library first, to see how everything works Take a look at [https://astaxie.gitbooks.io/build-web-application-with-golang/en/06.1.html](https://astaxie.gitbooks.io/build-web-application-with-golang/en/06.1.html) for working with cookies
Haven't used LiteIDE for a long time, it was rubbish, dont know how good is the latest version. You could try GoLand, VSCode, Sublime or even Atom.
I got the original link from a newsletter I subscribe too. I'll make sure to trim off the extra fat next time.
that's shit
I wrote this as one of my first Go projects a couple years ago. The code isn't the best, and the frontend is written in Angular 1 (depreciated now) so I've been meaning to rewrite it, but just never had time. I final quit stalling and went ahead and open sourced the codebase as-is. This was a tool I needed and hopefully will help other developers see how easy it is to integrate SMS into their application for neat things. 
to those who spend my time? Nooooooo
I think your question is related to "I would like to use any/all the repository methods like a transaction from *outside*", sadly I haven't found a good answer without leaking the implementation details into the other layers (like you said). The approach I follow is to define a concrete Repository method that receives a "command" to be used as the transaction. For example assuming you want to add a collection of `Record`, then I would define a `AddRecords(r []Record)` and inside the repository implementation I'd use a transaction.
Depends on how much data is in the DB, usually, you don't call the DB for each request if the data did not change and it is stored in a cache.
I thought it wasn't working as expected, which is why I went down this road getting confused about the `fmt.Printf` output, but now when I went back and changed my code back to `nil` checks it works, so I must've been mistaken and it was something else that was broken.
doesn't `{{if .currentTitle}} {{.currentTitle}} {{else}} {{.defaultTitle}} {{end}}` do it?
** Shivers **
How does this compare to [jennifer](https://github.com/dave/jennifer)?
Where is this used?
Thanks. Hope you get well soon! 
no. what if `currentTitle` wasn't passed as a variable to a template?
Hey u/Jokkamo Seems like the syntax is off in the template. I created a blog about templating : [https://medium.com/@awkwardferny/golang-templating-made-easy-4d69d663c558](https://medium.com/@awkwardferny/golang-templating-made-easy-4d69d663c558). Hope I helps you!! 
Bobby Tables' school upgraded their enrollment recently. 
You trying write C#/Java-ish code in Go. No, it's not idiomatic and quite confusing. Please, read documentation [https://golang.org/doc/effective\_go.html](https://golang.org/doc/effective_go.html), you find all directions for writing simple and understandable code.
[removed]
I'm not a windows user, but according to the SETX command documentation it says it can edit the registry for the user or system to make the change permanent. So setx is probably what you want, and probably the first form with individual arguments. https://ss64.com/nt/setx.html
yeah. I'm not a windows user as well. Just making a system agnostic program and windows has been kicking my butt.
[https://golang.org/pkg/os/#Setenv](https://golang.org/pkg/os/#Setenv)
I think I've tried this before, but it does make lasting changes to users machine. I could be wrong.
This will modify the environment of the running process, not modify the Windows PATH environment variable permanently (which I think is what the OP is asking to do).
It is not easy to do in Windows if you want to change *system* environment variables. You have to add or edit variables under the `HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\Session Manager\Environment` registry key and then broadcast a `WM_SETTINGCHANGE` window message. To edit Windows registry you need WinAPI: set of `Reg*` functions. Then call `PostMessage`. Use `syscall` package to call WinAPI from Go. Probably somebody already wrote Go package for Windows registry so it can simply your task.
[removed]
Yeah, you are funny
This. There are also a myriad of different reasons why on some projects a database is not trivial or fast to spin up, which can include licensing, initialization time/cost, dev/prod OS differences &amp; config, system load, clustering setups and a circular issue with setting up the test environment correctly in your test. I've seen databases whose minimal full setup involved gigabytes of data.
Nowhere. I was thinking about ways to build a simple analytics tool for internal purposes and can't really think\google of a nice way to map UI changes to sql queries. For example: you have two tables in your db. Say Stores and Devices. When you web ui loads you have constractor component and two 'table' items (Store and Devices obviously, they do have info about their respective fields as payload). You can drag-n-drop those items on constructor component. As a result of internal logic you have some sort of a message to your backend that can and will be used to generate sql query. (In this example this should be a select with inner join).
Hey foofoo300 I'm not sure how to DM you, but I'm having some trouble changing my container. I've changed my Dockerfile and it is now like this: `FROM buildpack-deps:jessie-scmMAINTAINER Can Yucel "can.yucel@gmail.com"RUN apt-get update &amp;&amp; apt-get install -y --no-install-recommends \g++ \gcc \libc6-dev \make \pkg-config \bison \&amp;&amp; rm -rf /var/lib/apt/lists/*SHELL ["/bin/bash", "-c"]` `ENV GO_VERSION 1.9RUN curl -s https://storage.googleapis.com/golang/go${GO_VERSION}.linux-amd64.tar.gz| tar -v -C / -xz` `ENV GOPATH /goENV WATCHER_VERSION 0.2.4ADD https://github.com/canthefason/go-watcher/releases/download/v${WATCHER_VERSION}/watcher-${WATCHER_VERSION}-linux-amd64 ${GOPATH}/bin# RUN mkdir -p ${GOPATH}/bin &amp;&amp; chmod +x ${GOPATH}/bin/watcherWORKDIR /go/src/finance` `CMD ["watcher", "-run", "/go/src/finance", "-watch", "/go/src/finance/cmd/finance"]` &amp;#x200B; I haven't changed the docker-compose.yml as I saw no reason for that. The problem is, after building the image, when I `docker-compose up`, the output is the same as it was before - it's like its using the old Dockerfile image, instead of the one I've just built. I have ditched the GVM but when I get into my container's bash I can see the GOPATH is still the same as if it was installed with GVM (`GOPATH="/root/.gvm/pkgsets/go1.9/global"`). I've tried to docker rmi to remove some images, also I've tried docker-compose down then building it then docker-compose up but it's still looking the same old one. 
Thanks for your reply. This should be of help. I've always wondered how when you download programs like docker/homebrew etc. they are always accessible in your PATH immediately.
Those tools are often installed to a directory already in your PATH. 
I agree. From an admittedly fairly quick look, I don't see what benefits this library has over jennifer. I might be a little biased as I'm a happy user of jennifer. I have a project that uses it to generate hundreds of types, and over 15,000 functions.
I think you might want to specify the timeout on an http.Client for PostForm.
Ternary „replacement: AFAIK, in go, you initialize a variable with the “else-value”, and if condition, variable = other value ``` isOddLength := “no” if len(array)% 2 == 1 { isOddLength = “yes” } ```
Have you tried it? ;) 
Tip: If you came from node/php/ruby and didn't use the streaming API, Go will reward you handsomely if you learn to. `io.Reader` and `io.Writer` are important for (big) data.
Cool, thanks for sharing
I cannot recall whether I've used syntax like the above before and it worked or if I did this... {{ $currentTitle := .currentTitle }} {{ if ne $currentTitle }}
[removed]
[removed]
When I clicked I knew I need to look for promises. Man that example is pure evil. 
 possible typo in first sentence of the conclusion, 'in and off itself' should be 'in and of itself', maybe?
Not in Windows. It would be too simply. :) In Windows many applications creates an alias under `HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\App Paths` registry key. At least it was so when I used to write applications for this OS.
Here: https://gopherize.me/.
Interesting... the tests use go-testdeep for testing go-testdeep... I wonder if computer science can prove or disprove the theoretical existence of a bug that could affect the tests in a way that the tests would not be able to reveal the existence of the bug... Or should I just go to bed.
I found that one but was looking for more custom (e.g., adding specific objects in the gopher's hands, putting the gopher in a situation [sort of like this] (https://img.devrant.com/devrant/rant/r_557673_5ZQ9F.jpg)
Please stop bringing JavaScript refugees into Go. They’ll likely push for more features that make Go less Go, and eventually have us become java, but compiled.
Yeah, I like jen as well, so I may be biased too. I used it a few months ago to write [something which generated code to use hashicorp/go-plugin](https://github.com/jakebailey/plugingen) with arbitrary interfaces. Though, I wish there were a better way to convert between `go/types` and `jen`. It's a bit annoying to read info from other Go code and not be able to generate 100% compatible code. (My project isn't perfect, and breaks on most things with custom errors, including one of my examples...)
Well, probably you need post a job on Fiverr or Upwork.
I took a look at the code and it kind of feels like you were using packages in a way you would use classes in an OO language. The cmd/dogfacts looks perfect, but I don't feel like the 'pkg' folder really helps, if you look at [Google's golang standards](https://github.com/golang-standards/project-layout), they say pkg should be used for things 3rd parties would be using from your code. I would have probably move everything in `pkg` to the root, rename `api` to `server`, think about where to put the mocks. Take a look at this other post for more resources: https://www.reddit.com/r/golang/comments/8g26il/what_is_the_recommended_go_project_folder/ I don't really know how to make the code more go-like, or what the proper layout should be for you. I still have issues with naming and organizing code.
There's something so tempting about using io.pipe in painfully clever ways, yet I never seem to see it used in the wild
What a dumb thing to say you muppet. 
Some vile opinions in the comments. I’m a node developer and am very interested by this post, but it seems to golang community isn’t as friendly as they pretend to be.
He specifically mentioned two Unix tools so I assumed that we weren’t referring to how windows does it. 
Why does this work in Firefox and not in Chrome?
Oh, yes. In case of Homebrew a user probably has all binaries in a single place.
Yes, thanks :) Not a native speaker, such mistakes happen a lot to me :)
Dumb? You really think brining in people who actually are okay with writing JS isn’t gunna create more push for awful, lazy language features? Linux is getting bloated already and is getting slower. I don’t want Go to lose what made it good because we were so desperate for adoption we went for the lowest common denominator. There’s already a big push to make Go less Go and more Java/C#/Bad. Let’s not bring in more people who would push for this without first dealing with the issue we already have and getting them to understand why Go is important, what Go means, and why it must keep its principles.
Yes. Your previous comment is stupid as is the one I’m replying to now. 
i've been using github.com/krolaw/dhcp4 with a custom html5 frontend on my lan for about a year without too many issues. I have been wanting to implement a middleware type of implementation to modify dhcp requests/responses in flight. DHCP is one of those protocols that not everyone does correctly; I've seen some TV's that do one request per power on no matter what the lease time is set at, other devices handling broadcasts/direct messaging differently, etc. Handling all the cases can get very tedious without having an easy to expand implementation.
[upsin](https://github.com/upspin/upspin): written by people from the Go team. Also worth seeing is how they [go about error handling](https://commandcenter.blogspot.com/2017/12/error-handling-in-upspin.html). [oklog](https://github.com/oklog/oklog): has good design docs. It's abandoned but still great to look at. &amp;#x200B; Will update if more projects come to mind.
So stupid you don’t even bother to think of an argument against it?
You'd be quite disappointed with the go 2 proposals then lol
Will take a look, thank you!!
Postgrest already does something like this. It's not yet feature complete, but I'm in the process of building something similar to integrate with Go applications that supports more backends and more flexible configuration: https://github.com/royallthefourth/bartlett/ Right now it only supports simple `SELECT` and `INSERT` operations. You'd also be the first production user...
Nodejs developers won’t make the language worse. Dumb people will. You are one of those people, rigid and fixed. You believe diversity and inclusiveness leads to poor outcomes. If anything you’ll hold the language back. You believe golang should be protected from nodejs developers, without taking into account that perhaps they are moving towards golang for its simplicity, not to turn it back into nodejs. Most developers who are embracing golang started on other languages, many of which you mentioned previously, shall they all leave as well. Don’t be so ridiculous. 
Just my opinions, does not mean I am right: * I think the structure is fine, although I know some people don't like the cmd/pkg structure * Some people don't like to include a test dependency and use the stdlib. Myself I prefer the standard lib for testing, but I feel that is a choice. In my eyes testify is seems very Junit like, and therefore like Java. * I like to define the interfaces in the package I use them in, not where the implementation is. Overall the code looks pretty good to me. You can't please everyone 😁
I mean, the error values proposal isn’t bad, but there’s bad in the other proposals. Especially generics. Nobody would be even considering it in Go if not for the mass influx of people from other languages, and the lack of ability within the community to shape them into a Go mindset. There were just too many. It’s only going to get worse, the more we value growth over anything else. It’s better to grow slower, but actually be the best designed language in a world of C#s and JavaScripts. That’s how you democratically change the programming landscape for the better, slowly. Right now, we’re implementing Microsoft’s “embrace, expand, extinguish” doctrine, in a way. It’s just that we’re doing it to ourselves.
looks good to me. I suppose its eye of the beholder. I like how you have a Makefile. You checked in your go.mod &amp;&amp; go.sum. You have a .gitignore. You have tests. &amp;#x200B; &amp;#x200B;
Diversity and inclusiveness can definitely be bad. You wanna be inclusive? Linux tried that. Oh and now Linux is becoming less Linux, more bloated, and slower. You’re just taking these people and assuming they can make the language better without fully grasping why it is the way it is. You claim I’ll hold the language back. Sure. I just said I’d rather it grows slower and doesn’t fall for the same traps that other languages fell into for the sake of quick adoption. You’re looking at a language which brings out the worst in programmers, and asking them to join into the best designed language that exists, and just *hoping* that they will just understand all the philosophically important parts of Go without spending at least months interacting with the community and learning. Too much of them come, and it won’t be people from the Go community helping them, it will be other people who came from these languages. And soon, no one cares about design simplicity. Nobody cares about performance. You’ll se giant, fat, bloated frameworks become so popular you can’t use some packages without it. The people who value design simplicity, are not likely to be js devs. They are out there, but they’re in a clear minority. If you expect people to come to go for simple design and all the other great decisions the developers have made with it, from getting a general audience of JS developers, I don’t know what to tell you. I just don’t see how that would happen. And then you strawman me, even when the answer to your strawman was already posted by me. I’m not saying people should leave Go. I’m saying we shouldn’t focus on adoption as much as we do right now. Not nearly. The community isn’t big enough to help people understand, adapt to, and expand the current Go philosophy in a way that respects the initial goals of the project. If this sounds ridiculous to you, I have a feeling you may be misunderstanding me.
I would imagine you would make a path and just render a html/template response similar to any other path you already have. that is is requested with ajax is meaningless, you can request your home page with ajax. so just make a "partial template" in golang.
Your issue seems to be with JS developers more than anything. You’ve clearly had a bad experience with Js which is causing you to react badly. 
In golang. 🤔 Like why would you do it differently inother languages...
Js, react, heh. I mean, you set up a gotcha question really, so I’ll answer you with another question. Based on the popular usage of JavaScript, do you think that, should the user bases be swapped, that these patterns of language usage and design be applied to Go as well?
There isn't an idiomatic way of doing this - you can surely serve whatever you want in your response, but you'll need to write JS to handle this sort of weirdness.
Dumb question. 
Then explain why it’s dumb. I’m assuming here, but it kinda feels like my concerns are being waved away for whatever your personal biases are. Just an assumption, though.
You say “we” but you are 1 person. 
uhuh you can lose the pkg folder and different packages aren't needed in this case imo.
because let isOddLength = array.length % 2 === 1 ? "yes" : "no" is more compact. And some people value compactness over readability.
Yeah. As if the compactness of code impacts anything other than readability. I think it makes it less writable too.
yup.
????
It's not less readable to everyone...
Also, I dont think the sync package is really necessary with the example provided, works with it out all the same, as the &lt;-c in the append will block till the value is sent on the channel anyway. &amp;#x200B; [https://play.golang.org/p/b9H7DxShPyM](https://play.golang.org/p/b9H7DxShPyM)
99designs? Clients have used us for a fair number of Gopher related logos for open source project before [including our own project](http://gqlgen.com). We're also really big Go users over here!
&gt;ope for is more and more exposure of the language to developers. Then more and more libraries will be built. However, for now, python is still a must know for ML dev. Thanks for the support! If you find the tutorial, please consider give it a clap on Medium (or 50 claps also can :p) My friend does PHD work and has switched to golang from python and clojure. He said he got good results in terms of pure execution fo training of models and like it for that reason. Plus golang is an awesome lang to work in.
I agree with this! With that said ideomatic Go is having everything in root OR having an src and a test directory. Personally can't handle having everything in root so I use the src and test structure. As for your code, everything looks good to me!
Small POC on your spare time like I've done in my company with solid doc. I can give you further hints if you want but it depends on your current status (dev, lead, architect,...)
Well I shouldn't have said "homebrew". I guess chocolately would be a better example in this case. Basically when I install Docker desktop, i see that PATH is changed on my machine automatically "C:\ProgramData\Docker\Docker\Resources\bin". I'm guessing they do what you are talking about ? HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\App Paths registry key. At least it was so when I used to write applications for this OS.
Introduce Java
I am like mid-senior developer. I was brough on as a JS specialist so I have some pull. I was lead JS dev in last company, but they were smaller.
The code is good. The architecture is a bit confusing as I’m not finding things where I’d expect them to be. I’d get rid of the “Application” object. You only need the Server and Client as the high-level objects. Your cmd program only needs to know about the Server. It creates one that listens on a port. Then your test should create both a Server and a Client, using the Client to connect to the Server. Some of these things you’re doing, but I just wanted to reinforce that you don’t need the Application object. Your cmd program pretty much *is* that.
https://github.com/ashleymcnamara/gophers 
I think it’s more apples-to-apples if the console.log statement used the log package instead of fmt. 
Thanks
It's not really that bad to read once you're used to it. I find the triple equal more annoying but such are the perils of dynamic typing.
How about passing the transaction into the methods?
Feel free to leave an criticism. I would love feedback. APIs are not frozen yet!
Well said. One thing to consider is the overhead of each channel traversal. Channels are fantastic, but they’re not free, they’re FAR slower than a method call.
Out of topic. The experiene of reading code on medium is too bad, much worse than a github page.
Out of topic. The user experience of reading code on medium is too bad, much worse than a github page.
I'm actually cooking up something similar to this right now. It's neither feature complete nor battle tested, but it's coming along: https://github.com/royallthefourth/bartlett/
I reckon OP was looking for one of the (few) artists who are known for having done Gopher art in the past; not a random person trying to imitate the style for their first time.
How is JS not helping the company meet it's business needs. "I like it better" won't fly. Especially if you have an existing team of JS devs
[removed]
If it's new work, a verifiable Cost Benefit Analysis usually works wonders. Are there things that you could do with Go, that you cannot with Node, that would save the company time or money? Are there things in Node that cannot be achieved at all because of performance issues, that Go would be able to achieve? My guess is you wouldn't find anything fruitful from a CBA perspective because JS devs are usually cheaper than others, and your company already has an abundance of JS devs they're already paying to do stuff. If you can find some performance bottleneck in Node that is solved with Go, do a PoC to solve it and move forward from there. Generally, though, business goals are very different from individual goals, and "I want to use a different programming language because I like it more" doesn't align with pretty much any business goal.
You really think so? I absolutely love Medium. I find that I'll read an entire article on Medium, whereas on most other platforms (especially github), I skim &amp; skip.
[removed]
[removed]
I use people per hour. It sounds like it’s for prostitution, but it’s actually for creative people to sell their skills for far below market value. I feel dirty using it, but it’s a great way to get great work done. 
for the love of... change that image. wow.
Which image? My avatar, or the readme?
Oooh excellent write-up. Thank you!
You have to present a solid reason, showcase your demo and commitment to get the team to work on the risks and benefits. We can’t advice you just like everyone else, your project managers is the best person you can seek to.
sorry your avatar was cringe... but that aside I do like to see folks start with such a small `main` and using `flags`and not how I always start a project with `urfave/cli.v2` - I see I am also outdated with directory / file structure because I didn’t recognize `internal` was a new root directory structure idiom front the projects I’ve seen but good seeing you updated and using `go mod` and what some quick googling found: https://medium.com/golang-learn/go-project-layout-e5213cdcfaa2
Not sure what to say about you not liking my avatar, I use it pretty much everywhere. I will agree that it's annoying that GitHub &amp; Reddit decide that's the image to expose for a repository though, and not an asset included there (such as the image in the README). I'm curious why you think it's cringe, feel free to pm me. &amp;#x200B; I'm glad you like the project overall though, feel free to provide suggestions if there's functionality you feel like I could add, as I'd love for this to be usable beyond just being an \`http.FileServer\` replacement.
I’m not specifically sure, but I think you need to use both this and setx. This will set it in the current context and for forked processes, and setx will set it for future executions. I’m not really sure how env works on windows tho, but I seem to recall that it’s pretty similar to posix systems as it was added to gain near posix compliance. You won’t see the env change on existing processes. So if you use this package, it should see it on newly forked/exec processes that spawned from the current go process. Setx will apply on logout/reboot to all processes. 
Unfortunately not. I'll keep my eye out for any new services that could be optimised with golag
Yeah so something like this: exec.Command("cmd.exe", "/V", "/C", "setx hello world") Will change the users environment variable. However, one would need to refresh cmd/powershell for it to be usable. os.Setenv only survives for the lifecyle of the golang binary execution. Not a permanent change to the user's machine. I think using HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\App Paths registry key may be the best route to go. The other alternative that I went with was installing directly to known folder already in PATH. 
brew cask tho
I’m not sure what you’re actually doing or why you need the env set (using env can be great). Perhaps some background could help a little? If you just want to generally set it for running cmd processes, the short answer is that you can’t without directly calling set inside existing cmd windows. That is, if you run a go executable, then set, it will actually spawn a new cmd that’s a descendant of the go process and the set won’t propagate back to the originating cmd window. If you want to set an env var for descendant processes, you can use Setenv. Eg, if you are using go to set up the environment for a custom app that needs the environment configured before it launches, this is a viable option. If you want to set it for cmd processes that will start in the future, setx is your way to do it. 
Yeah, it is `App Paths`. BTW, I find out that there is a standard package which provides wrappers for WinAPI/registry: `golang.org/x/sys/windows/registry`.
I'm basically building a cli that has brew/chocolately like commands that can install external command line accessible programs to a user's machine (makes setup easier than user needing to go download from elsewhere). When downloading these external dependencies onto a user's machine, I want them to be accessible immediately with the cli as well as to the user. So for example, if i use the cli to install "program A", I want the cli to execute "program A" as well as make it accessible directly on command line. If this program is automatically accessible in PATH that would be ideal. Setting/Appending PATH automatically after downloading external program was what I was after. Could be thinking about it the wrong way. Still somewhat a newb. 
Gotcha. A custom package manager. So the only way I see it being possible is to place the executables into a known PATH. Eg, create a %HOME%/packagemanager/bin directory and use setx to add that to the environments path variable when the package manager is installed. When the package gets installed, place it’s executables in that directory. That’s fairly common behavior for package managers. 
yeah that's what I currently am doing. Just wasn't sure if best. Thanks!
Thanks so much. Actually just found that package about an hour ago. Going to try it out tomorrow.
Your service can "get or find" information from other repository's, but it should only be modifying/saving one aggregate at a time. If your not able to do that you should look into events. &amp;#x200B; Here is a DI example I did up for someone else [https://github.com/longfellowone/field-services/blob/master/pkg/archive/temp/di.go](https://github.com/longfellowone/field-services/blob/master/pkg/archive/temp/di.go)
I find Medium to be meh at best. For programming related articles, [DEV](https://dev.to/) has been more goto for awhile now.
It's unfortunately not cross-platform, so it won't work on Linux. Linux brew is not a full equivalent.
I think my [stats](https://github.com/montanaflynn/stats) library is a pretty good example of creating a well tested and documented package. 
It looks pretty good! If anything, its just a bit complex in its configuration. Have you seen **https://github.com/Rican7/retry**? (Full Disclaimer: That's my library.)
Is that mostly because you prefer the typical article content? Formatting looks pretty similar at a glance.
[removed]
Hey that's great! I've been looking for a project like this, aka "curl for graphql". And the CLI tools I found so far were bloated IDE-like REPL monsters. This is much closer to curl's spirit! Only thing is that it doesn't handle cookies, but apart from that, that's an impressive little project!
Thanks, I had not. Seems nice. I do like struct configuration myself, but I could see how some people would like would prefer the functional approach you took. Pretty slick.
Why do you need to start from query in form of a JSON struct? I would start with the simplest approach possible and store the query verbatim: {"query": "select a.a, a.b a.c b.d b.e b.f from TableName a join TableName2 b on TableName2.d=TableName.a"} If you need parameters, add them using SQL placeholders. If you really plan to *generate* different SQL statements dynamically from query snippets, I see no need to first generate a JSON struct and then transpose it into SQL syntax. I would rather generate the SQL directly. (Just my £0.02)
Good way to make Go appealing.
Is there any file size restriction for the file to be hidden, with regard to the file size of the image? Like, for example, "the file to be hidden must be no larger than 10% of the image".
Mostly from a writing standpoint. DEV uses markdown with some enhancements specifically aimed at technical articles while Medium has a much more limited formatting options. Medium's comment system is also just... bad.
"Just imagine you have strong types and many event loops!"
Yes, there are some restrictions. It depends on the carrier's file encoding but roughly i could say data file must be around 20% of carrier. There are some strange situations, which are mentioned in Disclaimer paragraph of the README that in case the image is jpeg, jpg there is some compression of pixels, and the result file is bigger because it is saved as png, so it could be even possible in this situations data file that is hidden even to be bigger than the original carrier file. So my advice is if you want to hide something, just try it and if the carrier file you chose is too small for your data file the tool will respond with "This data file is too big for that carrier!" and therefor you must search for a bigger carrier.
- Drop the `./pkg` directory and place the package directories in the root of the repo - Remove the binary from the repo, put it to a `./bin` directory and add that to your .gitignore Other than those points I see nothing wrong with the code, it looks quite idiomatic not "Java-like" to me.
Interesting but why would you use windows anyway :)
Go: solves NP problems in P time.
Aaaand you are a winner of a Ton of money, thats one of the millenia questions i think :D
https://en.wikipedia.org/wiki/We#Editorial_%22we%22
I wouldnt be selling it on performance. Because of two reasons. Language performance is rarely the bottleneck. And where you would use FFIs for heavy lifting, C++ / Rust simply do much better. Now you may not like it, but imagine you might end up with similar resistance. I suggest to scrap performance part and focus on other advantages people tend to forget. Concurrency. Compiler, which works as fast as it's almost dynamic language, easy to pick up and be productive. Lesser requirements for dependencies due to great std lib. Other people already pointed out that you have to make a case for business value. I'm suggesting not to focus on performance part. :)
sailing on the same boat. Looked at various open source projects (Eg. openfaas [https://github.com/openfaas/faas](https://github.com/openfaas/faas)) &amp; realized that it takes some time to get in to the community. I started writing a couple of packages. Feel free to contribute. In fact, would love to hear your feedback/thoughts. Thanks. [https://gitlab.com/viggy28/afirebase-go](https://gitlab.com/viggy28/afirebase-go) [https://gitlab.com/viggy28/aslack-go](https://gitlab.com/viggy28/aslack-go)
&gt; I do like struct configuration myself, but I could see how some people would like would prefer the functional approach you took. Pretty slick. Thanks! I actually got the idea from a blog post from Dave Cheney: https://dave.cheney.net/2014/10/17/functional-options-for-friendly-apis
IDK about breaking all the rules, but it seems like a fair amount of work to justify working in an awful OS ecosystem.
Thank you, committed!
Definitely a few interesting projects, but there’s a lot of fluff and not a lot of supporting argument for each to make a top 5. Reads a lot like a buzzfeed article. 
Haha very nice
Can't speak for anyone else, but I think your avatar is very cool! Some people who don't have that kind of high quality personal branding are bound to be jealous ;)
&gt;Dumb? You really think brining in people who actually are okay with writing JS isn’t gunna create more push for awful, lazy language features? &gt; &gt;Linux is getting bloated already and is getting slower. I don’t want Go to lose what made it good because we were so desperate for adoption we went for the lowest common denominator. &gt; &gt;There’s already a big push to make Go less Go and more Java/C#/Bad. Let’s not bring in more people who would push for this without first dealing with the issue we already have and getting them to understand why Go is important, what Go means, and why it must keep its principles. You're obviously slow. The battle you're fighting is laughably wrong, let alone the connections you're making with JavaShit and half decent languages like C#. Go is just some old fart's evangelism from the 16th century. 
The Project Calico repositories have a bunch of well-written Go, like [calicoctl](https://github.com/projectcalico/calicoctl).
Couldn't agree more.
https://github.com/gaia-pipeline/gaia is always looking for contributors. :)
And today on buzzword roulette...
Nice! If you want ideas, could look at [https://github.com/zeit/serve](https://github.com/zeit/serve)
Not yet.
Yep, the unique solution I've found is move the impl to the svc layer, and I don't like that :/
This is the first solution that I said in the post, but using this approach, you need to put the repository implementation (db, mem, file...) in the service layer, and it's what i'm trying to avoid (if it's possible)
1. Nothing awful about it 2. It wouldn't be different on any other OS if you would like to call C library without using CGO. Recently runtime on Darwin was rewritten in similar way to use libSystem instead of raw syscalls. The problem is with Go, not the OS. You can't easily call external libraries.
[removed]
&gt; Why do you need to start from query in form of a JSON struct? Well, for this is just a one possible way and I'm open to all possible suggestions. This approach (cooking the query in frontend from the beginning) is even a bugger issue when it comes to different sql attacks, no? I mean - the way I've described can obviously a huge security issue already, but having a whole query out in the open will be much worse.
Hey! I’m part of a student-run software development club at UBC in Vancouver and we have a in-house deployment tool called inertia in Go: https://github.com/ubclaunchpad/inertia Ive worked on it a lot and I think it’s pretty interesting! Granted It’s a bit rough around the edges but it’s in use by several teams and we’re always looking for ways to improve it! Feel free to DM me directly as well if you have any thoughts or questions :)
[removed]
I do like context support in codyoss/retry, but if I create common lib to be used in many place of big project it's easier to adopt Rican7/retry, so I would vote for some mix ;)
Guy's reply is spot on and this is very easy to do just by translating the way old c/c++ programs are doing it. But people already done it for you and the best way to go about this is to search on github the stuff the guy posted. I just briefly checked WM_SETTINGCHANGE language:go on github and yep it's there. I wont post just a single repo but you can surely find the code that is capable of doing what you want.
This is platform and display server specific, and complicated.
`s/pattern//`
Thanks for the answer. Your example looks more or less like the code that I posted on the playground, the unique real change is that you're not returning interfaces. (I'm reading about this atm). Anyways the problem is still the same, your service layer is not accesing to your repository implementation, in your case in memory with `order := make(map[string]*Order)` so what do you think would be the approach if you would need to access it (e.g for managing Tx ?)
Nice article. I recently wrote a camera reader for Windows, and although I don't use Windows I must respect how it works. I used old VideoForWindows API via syscalls, so there is no CGO involved, and that same app can run in Windows 95 (if some older Go can compile for that) and in latest Windows 10. They have some wrappers from old to new APIs etc. and that same old API still works. Is it possible in theory at least to load .so file like that on Linux? Even `plugins` just use CGO and `libdl`. As I understand on Linux that is part of the C lib, i.e. glibc and not kernel, but is it possible to write such loader in pure Go ?
https support please :)
&gt; so it won't work on Linux. Why should it? Linux doesn't need crappy workarounds like OSX, it has proper package managers.
If you're talking about X Window system then yes: look at `xwininfo`, `xprop` and `xwd`: the former two are able to search for windows given the specified criteria and the latter is able to dump the window's contents into a file. Otherwise, you'd need to dive into platform specific APIs to do what you're after. 
Homebrew uses binaries by default, they're called bottles. 
In my experience using package managers for cross-platform development environments is hard. You need to test each version, each distro you want to support (while downloading the same binary from a different file usually just works). You also need rather verbose install scripts to support all package managers. Also, package managers usually install a single, global version which might not be compatible with all of your projects. &amp;#x200B; If being self-contained and portable is important for a project, using install scripts or any other solution to just download the required binaries to a bin directory and use them from there provides a much better developer experience than telling them to install these packages with those versions (unattended installation using scripts is not an option IMHO when it comes to installing packages to a global scope). Speaking of versions: when you work on a large number of projects, it can be quite common that some projects require newer versions of a tool, while other projects don't work with newer versions. Being self-contained helps in this case too. &amp;#x200B; Obviously, if you don't have these problems then this tool probably won't be much help. But imagine contributing to an open source project: isn't it better if \`make up\` prepares everything for you?
The differentiator is rather that it works in a cross-platform manner: when there are pre-built binaries for Linux and Mac it helps creating a portable development environment. It also makes the env self-contained, so it doesn't depend on your setup at all (of course it won't install things like Docker or virtualbox). &amp;#x200B; You can use the exact same tooling on Mac, on Linux, in CI envornments. &amp;#x200B; But of course, it's not trying to replace package managers, but help maintaining a portable and self-contained development environment.
Generics in Go is a requested addition since the publication of the Go language basically.
An unnecessary one
Actually the article is quite OK. I have a KP solution using Cython and using some parallel constructions. I have no idea how it compares with the NumPy version, but it deserve some investigation. https://github.com/openSUSE/knapsack/blob/master/knapsack/cknapsack.pyx
Thanks for the course.
The part you are referring to is often called "type assertion", it allows you to test and convert one variable to another type of variable. It's a lot like casting in other languages. One quick example I whipped up for you: [https://play.golang.org/p/XkMUmysqyfT](https://play.golang.org/p/XkMUmysqyfT) Alternatively, you can take a look at this part of the GoLang tour: [https://tour.golang.org/methods/15](https://tour.golang.org/methods/15)
I wrote this about half a year ago and it's been used by my bot which pastes RSS feed links from various Finnish ministeries to /r/ministerio. It also caches the last 10 000 links.
Seems like there's a lot of code for something that essentially does: select { case &lt;-time.After(deadline): error() case &lt;-semaphoreChannel: work() semaphoreChannel&lt;-1 } Perhaps it's good to highlight the advantages of your package at the start? As in: what problem does it solve? Aside from this, a remark/concern: in high-concurrency environments, is the use of "time.After(..)" something to be concerned about or not? It's more efficient to re-use timers, but the concurrency makes this slightly more difficult of course. But perhaps you can solve this with a sync.Pool to try and re-use them as much as possible?
because existing hardware does work like sh\*t on any linux System (e.g. newer Notebooks sometimes don't even boot, or need special treatment, like a precompiled kernel or boot flags, or have abysmal battery lifetime even with properly tunes powertop/tlp/etc.) Customers don't buy your software if it includes buying another eco-system because everything you just got - yeah thats gone when using a different eco-system. "Replacements" are no alternatives, because it's bad for the company's economy, requires consumers and workers to learn a whole other system. &amp;#x200B;
Ever seen a nested ternary Operation? Like... 15 layers? I have... it is unreadable AF
You're right, look at Lua: you'd have a hard time finding a current platform without an implementation. Even the DS and PalmOS have it.
How did you measure that this library is not fast enough? &amp;#x200B; Did you recreate a SchemaLoader all the time, or did you reuse existing schemata? e.g. schema, err := gojsonschema.NewSchema(schemaLoader) ... result1, err := schema.Validate(documentLoader1) ... result2, err := schema.Validate(documentLoader2) ... // etc ... &amp;#x200B;
Perhaps should you go to bed, yes :) testdeep package is tested via [github.com/maxatome/go-testdeep/internal/test](https://github.com/maxatome/go-testdeep/internal/test), which of course can not use testdeep (coz cyclic imports otherwise, as you should know). But perhaps are you referring to examples cases (and so tests, as mostly all examples are able to run)? In this case of course they use testdeep, as they are examples... Then [tdhttp helper](https://godoc.org/github.com/maxatome/go-testdeep/helpers/tdhttp): it uses testdeep package even in its tests, because of its nature, it is a helper so a different package . As anyone can write helpers using testdeep, it seems more than logic to me to write helpers and their tests using testdeep. That's simply the goal! Note that testdeep has a code coverage close to 100%. Very few packages reach this level as it requires a lot of work. Please respect this work and think twice before posting false assertions. Good night! :D
You are not writing back to your slice, you are creating a new slice and backing array. (Slices are like structs, when passed to a function they create a copy). The solution is to pass a pointer instead: [https://play.golang.org/p/nXNE4zrpqey](https://play.golang.org/p/nXNE4zrpqey) Although the better solution would probably be to return the new slice like this: [https://play.golang.org/p/HSol2xBPqPy](https://play.golang.org/p/HSol2xBPqPy)
hi there, sry was a little busy. i got you some pastebin with my tested code. What i did was i switched your docker-compose image to one you have to build yourself. removed all the code in your Dockerfile to the bare minimum tested the watcher with some simple hello-world code which i found in the watcher repo. Hope this clears more stuff up :) https://pastebin.com/v0DjFbyZ 
If you want to help me on [my project](https://github.com/8lall0/liblsdj), you're welcome :)
&gt;you are creating a new slice and backing array It's only copying the slice header. The copied slice header still points to the same backing array, which is the reason why the content of the original slice changes ("bar" is replaced with "baz") but not the length.
`Environment map[string]string`, no struct keyword.
/u/Ikkerens is mostly right, but to expand: Slices are basically structs which contain a pointer to the underlying array. When you pass a slice to a function, the slice is copied, but the underlying array is passed by reference. So mutations to a slice "passed by value" ([]string) might still be reflected outside the function. The reason why it isn't working is because append() will, most of the time, allocate a new slice and thus a new array when its called, then return that slice. There are times when it won't (for example, if you append an element to a slice which already has enough capacity to accommodate it), but in these cases it will return back the same slice you passed in. So the rule is, always use the return result from append(). Assigning the return value to the input slice doesn't work, because its a copy of the slice. So the change is reflected within that function, but not outside of it. As /u/Ikkerens says, the best solution is to return the new array returned from append, then use that array going forward in main(). 
Correct and incorrect. You are indeed only copying the slice header (the reason I said slices are like structs), however the resulting slice actually uses a new backing array as he removed the middle element (you can't remove the middle element if all the slice header contains is a pointer, offset and length).
*Ahem*... lol
Nested conditionals are unreadable AF regardless of which syntax is used to define them.
Be aware of the version of JSON Schema that they support too. Your linked one does claim to support draft-07, but I know there are plenty of libraries out there - for various languages - that are still stuck on draft-04, and draft-08 is expected to be out soon as well.
No, the backing array is still the same. See here: [https://play.golang.org/p/5tZCBYgFXvb](https://play.golang.org/p/5tZCBYgFXvb) The `append(list[:i], list[i+1:]...)` just copies over the data from `list[i+1:]` to `list[i:]`, since `list` has enough capacity to hold all the data from `list[i+1:]`, which is also the reason why the final `fmt.Printf("%#+v", list)` outputs `[]string{"foo", "baz", "baz"}` and not `[]string{"foo", "bar", "baz"}`
I stand corrected!
It looks like the OP is checking to see if any `option`s were provided to the `NewFileServer` func and if not, then initializing `opt` as an empty struct of `Option{}`. If it is, then it just takes the first option and assigns that to `opt`
Well for example in Debian dpkg looks like one giant crappy workaround.
Do you accept 100% remote work?
Wouldn't this need to be \`map\[string\]interface{}\`? not all of the values in the example JSON object are of type string.
I think you have it right on that. Thanks you two.
Thanks. Will try it out.
No idea why you've been downvotes so much?
People really hate medium I guess. 🤷
It seems as though he's just trying to impose his opinion onto you for his own personal reasons. Most likely to make himself feel like he's better than you. Attacking your choice in avatar doesn't really add anything to the conversation, and he's a very active member of this subreddit, so if anything he probably thinks he has a foothold in the community and is flexing his weight around for no good reason. Unfortunately there's guys like him lurking in every programming subreddit, but we're not all like this I swear. Most of us are lurkers that understand common human interaction. Good job on the project, and your avatar is pretty dope. Probably took a long time to make.
Which one isn't a string? I've double-checked my eyeball scan and I could believe there's one I missed, but I still don't see it. Environments tend to be string-&gt;string maps. There are some strings that contain numbers, like `"20"`, but JSON-wise that's a string. If you have a constant set of such things, encoding/json has a mechanism for dealing with that as an integer even so, but if you don't know the keys in advance you have to handle it the old-fashioned way.
&gt;Now, I was told by the company that my code was not idiomatic Go and that it felt more Java-like. Have you failed the interview? And was this an explanation for that?
This one looks promising. Is anyone here using it on production?
I guess however a lot of projects do it so I wouldn't call it opposite because both are very, very common and therefore according to the definition of idiomatic, would be idiomatic.
would this help? &amp;#x200B; [https://app.quicktype.io/](https://app.quicktype.io/) &amp;#x200B; if you use vscode there's a nice extension based on quicktype: &amp;#x200B; [https://marketplace.visualstudio.com/items?itemName=quicktype.quicktype](https://marketplace.visualstudio.com/items?itemName=quicktype.quicktype)
Business guys will not care about the language. They want to feel confident the system can evolve and meet business needs at a reasonable cost. Part of this is to feel confident that the technical choice is not a dead end that will go out of support or hard to recruit for. If you can make persuasive argument about this for golanf, then you should be set.
I can wholeheartedly recommend Jon Calhoun's [Web Development with Go](https://www.usegolang.com/) - among a lot of other things, it includes what you ask for: **How to build an authentication system** Web Development with Go will teach you how to build a proper authentication system including how to hash passwords with bcrypt, creating user sessions, avoiding timing attacks, and so much more. 
Have you tried the walkthrough for writing web applications yet? https://golang.org/doc/articles/wiki/
Linux has pkgsrc as well, for those keen to do source based installs.
This is great, I think I’m going to signup for his course
I'll try 
Companies I've asked to add to the users page [https://micro.mu/docs/users.html](https://micro.mu/docs/users.html)
Don't spill red wine on your shirt; it will stain it.
Schemaless
First, look at JSON Unmarshal: [https://golang.org/pkg/encoding/json/#Unmarshal](https://golang.org/pkg/encoding/json/#Unmarshal) You can use that to populate a struct from the bytes. See this for an example of how to use struct "tags" so that the Unmarshal works correctly: [https://eager.io/blog/go-and-json/](https://eager.io/blog/go-and-json/) Sure, you can unmarshal with a \`map\[string\]string\`, but you'll end up with some crazy code in order to cast to the right types and access nested objects. Just create struct with json tags and unmarshal.
[Prior discussion](https://www.reddit.com/r/golang/comments/agie40/5_open_source_go_tools_for_tuning_up_your_golang/)
Looks pretty cool. I've written a few tools to poll RSS feeds _from_ rerdit e.g. [rss2email](https://github.com/skx/rss2email/), but posting _to_ it is a nice idea.
Be great if they could potentially add a blurb on why/how they are using it as well. 
this: ``` grid := make([][]int, items+1, items+1) grid[0] = make([]int, capacity+1, capacity+1) ``` isn't really memory-locality friendly... you'd probably be better off creating a 1-dim slice of size `(items+1)*(capacity+1)` and implement the proper indexing logic...
Damn. I never buy these kinds of courses. But since I’m doing basically this, and sometimes struggling to find a good pattern for some arcane piece of functionality, this may be a good bet. 
http://www.catb.org/esr/faqs/smart-questions.html
What I've learned is that people using open source tend to just want to get on with using it. Trying to get these companies to even let me put their names on a list was difficult. Contrary to the most popular projects where companies actually want to volunteer their names. 
Yeah I failed it and that was the feedback that they sent me.
ah that is my mistake. I didn't realize the missing piece was about a specific property I thought it was about the top level JSON object.
We’re using it in production (15+ microservices). On the whole we’re very happy, it’s a well built and designed framework and the author is very responsive on Github and Slack. Our principal pain points are around dependency management (author uses `go get` so things can easily break - this is changing though when go 1.12 is released and the framework will adopt `go mod`), and secondly a codec change which has caused a little bit of problems between our older services talking to newer ones (easily fixed though with a dependency update and recompilation).
[http://github.com/purpleidea/mgmt](http://github.com/purpleidea/mgmt) is a next-gen config management tool always looking for new blood. I think /u/purpleidea hangs out here on occasion.
About time
The reason that code exists is to allow the \`options\` argument to be optional. Because Go doesn't implement default argument values, the only real way to make something optional is to make a variadic function, and only utilize the first value. The reason I don't just do the following (which is vastly more readable): \`\`\` opt := Options{} if len(options) &gt; 0 { opt = options\[0\] } \`\`\` Is actually a minor performance improvement on how Go treats variable assignment. \`var opts Options\` only declares the variable to exist, but does not assign it an initial value. \`:=\` would actually assign the value upfront. Doing so, doesn't allow the compiler to optimize for the actual use-case used (ie, if you always passed options, or the opposite). By having the \`if\` statement, the compiler is ultimately able to throw away the unused case, since it never has to use the allocation.
Thanks for the recommendation! I'll check it out.
[removed]
[removed]
[Here's my current approach](https://play.golang.org/p/SUbdUWQ9idd). Improvements are welcome
[removed]
Something more detailed about html / templates , aside from docs 
I did my homework , I even opened official docs for html/templates but they went over my head so I wanted to know where can I find detailed explanation on using templates , a step by step guide 
I would love some feedback on how you'd like to see this implemented. Initially I was going to add that, but here are the following things that I'm concerned about: * Initially, this could simply be offered by allowing people to provide HTTPS certificate information over flags, which if specified, I can plug into an HTTPS server. However, for local development, which is what I imagined this being used for, which `port` to listen on becomes a bit tricky (although can be another flag such as `https-port`). * Then the issue of HTTP vs HTTPS comes up. If they provide certs, should HTTP *not* *listen*? Listen by default, with the option to disable it? Redirect by default? * Then we also have the letsencrypt debacle. Ultimately letsencrypt is amazing, and should be leveraged whenever possible. Do I make this another flag? Should I *only* allow for letsencrypt, and no custom certs? And lastly, given this is also an importable package, comes the library usage of the project. Ultimately, this package just exposes an HTTP handler, which you can attach to whatever server you'd like (http or not). Does it make sense for me to also expose a `server` package that helps with this? Should that be a different package? Perhaps I should make an issue on GitHub about this, but I thought it worth at least mentioning why it's not already there and scouting for your thoughts.
I agree, but still exciting.
From my understanding of golang, \`var opts Options\` is equivalent to \`opts := Options{}\`. Both are zero-value, allocated structs. See [https://play.golang.org/p/qAq2B0CQaME](https://play.golang.org/p/qAq2B0CQaME)
While your usecase, and honestly mine, that is the case, they're [not exactly the same](https://www.youtube.com/watch?v=u-kkf76TDHE#t=18m45s). This is also followed up on a few stackoverflows answers, which is where my statement comes from. * [https://stackoverflow.com/questions/36512919/what-is-the-difference-between-and-in-go/36513229](https://stackoverflow.com/questions/36512919/what-is-the-difference-between-and-in-go/36513229) * [https://stackoverflow.com/questions/21657446/var-vs-in-go](https://stackoverflow.com/questions/21657446/var-vs-in-go) Additionally, \`:=\` allows for redeclaration, and ultimately can lead to bugs: opt := Options{} if len(options) &gt; 0) { opt := options[0] } See: [https://play.golang.org/p/LnzupBaRnqN](https://play.golang.org/p/LnzupBaRnqN) Where as: var opt Options if len(options) &gt; 0 { opt := options[0] } Has compiler protection.
Finally. Go is an excellent fit for cloud functions thanks to the quick startup time for function cold starts. Tested a node.js &amp; Golang function with db connection last year on lambda, went from 3148 ms to 1648 ms cold start.
Pluralsight has a course called "Creating Web Applications with Go." Sign up with a free trial. There may be more too. I felt the course was detailed enough and gave a few different examples and walk throughs. I suppose it depends on your skill level and if you used any sort of templating in other languages(and understood how they worked.
To the compiler point, I did remove that statement as it was an uninformed assumption.
We are using this, and listed on the users list too (as Glue). One of the main reasons why we chose micro over say go kit was because it’s really easy to get started with it. Just look at the huge amounts of code for just a [simple example](https://gokit.io/examples/stringsvc.html). Furthermore, micro has a repo filled with examples which were quite useful trying to learn the framework. As we started using the framework more, we started liking the pluggability. It allows us for example to easily switch between consul and Kubernetes service discovery based on the apps environment. We prefer running consul localhost (building and deploying to Kubernetes locally can take long), and we did not want to also run a consul cluster in our kube setup. Works pretty well! A disclaimer here: I was learning (and still am for that matter) Go, so you’ll have to keep in mind that a comparison by a more experienced Go developer might be more valuable. Finally, the maintainer’s support is legendary. I opened an issue for one of the plugins, and while there were a few user errors we had to go through first, we eventually did find an issue with the framework, which he fixed in a very quick fashion. Throughout the process he was patient with me, while clearly explaining what I did wrong, plus he responded every time within a few minutes. Just wanted to give this guy a shout out, he deserves it and his stuff is definitely worth checking out!
This couldn't have come at a better time.
You can take look at [this](https://github.com/apexskier/httpauth) repo.
Typically I return them if I also close them. The typical scenario is that the writer closes the channel, but if you are doing fan-in, that is of course not a good approach. I would generally expect that the creator also handles closing it, so if I am passed a channel I would expect the caller to close it and maybe give a way to flush. So if you assume that "the caller should close the channel" I would send it as a parameter. A returned channel will be closed when I'm done writing or asked to shut down. That is just my personal way of structuring stuff like this.
Why would one even return a channel? Is there a reason to do so?
It true! Ping us if you're looking to learn more golang, and get a bit of mentoring or just code review.
https://github.com/gorgonia/gorgonia and the various sub repos around the deep learning library Gorgonia is always looking for contributors.
- It allows streaming. It is not always feasible to have all your stuff in memory at once. - Async results. - Easy filter chaining. - Collecting stuff that occurs in the whole lifetime of your app. There are a lot of reasons to use channels. Though I assumed that you had a use case since you asked ;)
That's actually [variable shadowing](https://en.wikipedia.org/wiki/Variable_shadowing), and still isn't the behavior you're expecting. See [https://play.golang.org/p/k4dmIQmfYag](https://play.golang.org/p/k4dmIQmfYag). For the behavior you're expecting, don't use the short-form `:=`, which declares and initializes, but just `=` to set the value, as shown in [https://play.golang.org/p/v0J1Ee41PVY](https://play.golang.org/p/v0J1Ee41PVY). 
Hey there foofoo300, it's ok you don't have to feel rushed, thank you SO much for this pastebin, it helped me to get the watcher working and I'm also understanding the Dockerfile much more now. Holy crap buddy, I also finally managed to fix the GOPATH issue. It was related to the `image` in `docker-compose.yml` \- it was pulling the watcher's image from Dockerhub and I assume that this watcher uses GVM. Then this image was overwritting my Dockerfile. Now I built the "`app`" using `build:` `context: ../build/package` (path to my Dockerfile) &amp;#x200B; and there it goes, GOPATH is correctly set. I couldn't be more grateful to you. I was about to give up. Thank you so much.
I agree, but my question was, why returning one when I can expect one as a parameter?
Depends on the situation, but generally, the less you have to do as a caller, the less code, if you use the function more than once. 
&gt;Sure, you can unmarshal with a `map[string]string`, but you'll end up with some crazy code in order to cast to the right types and access nested objects. An environment really is a map[string]string. It's arbitrary, and won't contain objects. And the value type is specifically string; you can't get more specific in general, nor do you need interface{} because they are going to be strings.
Oh, if we’re just talking about the env, then yeah a map is fine. I saw the nested object on the page and assumed OP was trying to deserialize the whole object.
&gt; proper authentication system including how to hash passwords with bcrypt And that's enough to already question your definition of "proper"...
I think your code is good. I won't make comments about the structure of the project as there are many valuable ideas here; but want to say that it shouldn't be a valid reason for rejecting an application. I believe the important thing is seeing your value and openness to learning. Looking at the project I see you already have those skills.
Looks to be a regexp-based transformation before/after `encoding/json`. Weird, and kinda scary.
I've seen Go as an option on my console for over a month now? 
[removed]
you don't have the guts
For 1 week now I’ve been wondering a lot about this. I needed go support for cloud functions and it seemed to be taking a really long time to come out. Glad to see they’re actually supporting it, adopting cloud functions is now much more possible.
I imagine you've capitalized on the various options and are just banking on our rascality. I was wondering if you had the guts to enlighten us.
On go modules. Yea we're just waiting for this to be fully supported in 2 releases and then we'll adopt it. On the codec point. Its unfortunate to have to make such a breaking change, this was my own fault for using various content-type's early on for things that were not such. It also made things more difficult for direct consumption. Considering we have not made breaking changes in 2-3 years its difficult to do but needed. Thanks for the understanding.
Thank you for the kind words. Very much appreciated! And thank you for choosing micro :)
Great post! I love seeing stuff like this. 
It's been in beta
Take a look at: [https://github.com/go-vgo/robotgo](https://github.com/go-vgo/robotgo) Robotgo looks like it gets close to what you want, but is not quite there (that I can tell). The developer has responded to feature requests in the past.
We've been in a private Alpha since last August. Today is the first day of the public beta. &amp;#x200B; I work at Google and worked on this product.
Maybe you or your organisation were part of the Alpha? Everyone can use it now. :) Disclaimer: I work on GCP.
Yea, the current transformers are regexp-based, but only because they're working on object keys only, at the moment. I could have re-parsed the JSON, but it would have been costly and honestly is unnecessary for the level of transformations that are included in the package. Thanks to the functional API of `[]byte` input and output, though, custom (and future included) transformers can use a JSON parser. Also, the package is well tested and the Go regexp doesn't let you do scary things like look-aheads or look-behinds or anything too overly complex. Finally, the transformed bytes aren't modified in-place, but are instead a copy of the original, tested and all: - https://github.com/Rican7/conjson/blob/v0.1.0/transform/transform.go#L49-L53 - https://github.com/Rican7/conjson/blob/v0.1.0/transform/transform_test.go#L62-L78
You‘re welcome :) Feels great to help someone in need. A lot of people did that for me so this is kinda my part ;) Still though try to implement a ci/cd pipeline with tests for code changes a you will feel more confident to change code when you know it is tested everytime you push code before it gets deployed ;)
I stand corrected. Thanks for linking me. I didn't know an official document existed. I was going by what I saw in big Go projects/communities.
why not just use the [windows package](https://godoc.org/golang.org/x/sys/windows)?
True, but harmless in this case.
One thing I forgot to mention, I've discovered what are those random commands in the Dockerfile. Turns out it was just a copy from the watcher's Dockerfile, and it had those lines installing GVM. So everytime I tried to build my container my docker-compose.yml was pulling it and overwriting. Kinda dummy but it was a great lesson. Absolutely happy, thanks buddy!
[removed]