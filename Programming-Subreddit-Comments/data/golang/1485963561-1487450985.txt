Here is my monstrosity, for reference: https://github.com/skelterjohn/gcloud_apis/blob/master/gcloud_apis_gen/commands_templates.go
If someone wants to write such a article for their own enjoyment, great; but for basic concepts such as stacks, queues, trees, sorts, etc there is no lack of good resources already out there so I don't see why you'd be asking someone to share their knowledge as if that's a missing/needed thing. IMO, it's not up to "those with knowledge" to each put in more effort in to teach those eager to learn; it's up to "those eager to learn" to spend the time using the embarrassment of riches which are the existing resources.
My main dislike of templates is the indention mess. Really easy to miss end-of-block tokens when the indenting is all over the place. Also, as it gets more complex, manually managing the imports block becomes a real headache. Have you used the fmt package? Perhaps there's a condition in the template... if so all that logic somehow needs to be replicated around the fmt import...
I don't even try to keep indentation nice in the template - the generation step is followed by 'go fmt'.
I mean the indenting of the template source... for readability.
Yeah, I read about special team which was created for one purpose. But it still on draft stage. What about `gb` is it popular/useful/better?
Huge fan of gb here, and I'm hoping the new package manager uses some of the gb magic. gb effectively treats your current directory as the GOPATH, so you can have local packages under src/. A typical project for me might have src/cmd/server/server.go, src/http/... for some local http wrapper or something, etc. gb also lets you vendor things with commands like `gb vendor fetch github.com/...`, and lets you externally cache semver-compliant libraries globally (that is, for any gb project) if you so choose. Since everything lives under a single project's root, you can have any number of projects with similar vendored dependencies without worrying about conflicts.
Hi all, author here. I wanted to build my way up to working with WiFi devices on Linux with Go, and as a result, I needed to work with netlink and generic netlink. I was unsatisfied with many of the existing packages for the reasons mentioned in the README, so I took a crack at building my own. The intent of this package is to provide the basic building blocks for working with netlink, so higher level packages (rtnetlink, genetlink, etc.) could be built on top. Generic netlink (genetlink) is also included in a package in this repository, but I may end up moving it out in the future. Hope this is useful for someone! Happy to answer any questions you may have. I plan on doing a full write-up in the near future with everything I've learned while working with netlink, genetlink, and nl80211 from Go.
I need some help on how to run it on Kubernetes or Mesos, which all look very complicated to me.
is there a written tl;dw ? no offense but i assume the meat of this is a couple of slides, don't really want to watch the whole video
It's only 17 minutes; you can watch it at 2x, then it's only 8m30s. The script is available as speaker notes on the slides: go-talks.appspot.com/github.com/dgryski/talks/dotgo-2016/slices.slide . Press `N`.
Ranging over a slice of pointers will do the same thing as a linked-list: all data you actually *need* is somewhere else in memory. I recently got an 18% speedup by moving from pointers to values: https://github.com/dgryski/go-bloomindex/commit/cefa3a15a2975e9cc468e516107789d2ed871bda (References are just pointers, but the dereferencing is hidden from you. We don't really have them in Go, although there are some reference *types*, such as maps, slices, and channels.)
Ahh I mean't values not references. Thanks for answering!
Woah - this is awesome!
That's definitely what I'd recommend if it's a simple project... But as the complexity increases, you'll find that becomes more and more difficult. A couple of major problems I came up against: 1) In the "imports" section... Did I use the "foo" package? The only call to "foo.Bar" might be conditional on some complex logic... It might be conditional in two separate places, with different logic! All that logic will need to somehow be in the imports section too or you'll end up with unused or missing imports. 2) A problem I came up against in the kego project was that the system package: "kego.io/system" has lots of functionality I use in the generated output. So I'm calling functions like "system.Foo()". However, the generated output file has to support being local to the kego.io/system package - in which case the syntax of the function call would simply be "Foo()". In templates, you end up with something like {{ if localPackage ne "kego.io/system" }}system.{{ end }}Foo(), which isn't ideal. If you're starting a code generation project, I'd recommend you have a go with text templates first, and take a look at jennifer if you start to come across problems.
To clarify ovulateworld a bit, this is part of standard library, so you need a tip version (in this case, 1.8 rc) of Go toolchain to build that. Given it's very close to release (in a week?) I think it's quite ok to use it anyway. 
Great answer, thank you.
Does or will this solve the generics problem (to some extent)?
Good luck fellow programmer.
Thanks for this great episode. Please continue! You have a race in the shutdown logic btw: run() defers a bunch of calls that release the resources that are also used by the scene.run() goroutine. You need to make sure to exit from scene.run() before freeing those resources - just sending the "cancel request" isn't enough. The simplest solution is probably to run scene.run() in the main goroutine and do a "go func() { &lt;-time.After(5 * time.Second); cancel() }()" or something similar (optionally using a timer instance to don't leak that...). And it would be great if you can support variable framerates by measuring the time delta between two frames :)
[removed]
For (1) my solution is to emit all possible needed imports and let goimports sort it out :-)
Most of these I agree but you need to add a "// DON'T DO IT!!!" on this example as well: package user // User represents a user in the system. type User struct {...} func QueryUsers(ctx context.Context, q *Query) ([]*User, *Iterator, error) This leads to code stutter like `user.User` and `user.QueryUsers`. Also why is there an Iterator there?
using linked lists instead of slices
&gt; How do you become a developer without knowing what a stack is? o_O Actually, there are two definitions of "stack". 1. Behavioral: A stack is an abstract data type with push and pop methods for storing and retrieving data in a LIFO fashion. No assumption about the actual implementation is made. It could be a linked list, an array, or something else. 2. Technical: A stack is a single memory structure that stores data entities consecutively, next to each other, with no pointers into other parts of the memory. Elements are added and removed at only one end of this structure. A pointer keeps track of the topmost element. (These definitions may oversimplify things, but you get the point.) Obviously, the article is based on the first definition. EDIT: Fixed typo - FIFO -&gt; LIFO
http://stackoverflow.com/questions/12753805/type-converting-slices-of-interfaces-in-go &gt; In Go, there is a general rule that syntax should not hide complex/costly operations. Converting a string to an interface{} is done in O(1) time. Converting a []string to an interface{} is also done in O(1) time since a slice is still one value. However, converting a []string to an []interface{} is O(n) time because each element of the slice must be converted to an interface{}. &gt; The one exception to this rule is converting strings. When converting a string to and from a []byte or a []rune, Go does O(n) work even though conversions are "syntax". 
I really do wish it was possible to get behavior like this more "correctly" in Go though. I quite miss some of the testing output tricks that macros allow in C++.
Infinity loops in the goroutine
or ~/.config/git/ignore
`nil` value inside `interface{}`.
You can always `export GOPATH=$PWD:$PWD/vendor` and most of the tooling I've used kept working as usual.
use Iris framework
On being prescriptive, the problem is that these are important decisions which depend entirely on context and use-case, they are not decisions like the ones that gofmt deals with, which are essentially bike-shedding. There may be no one true package layout for go, and that's ok. A desktop app, a library, and a CRUD app, and a cli app which also exports packages have very different requirements for layout (for example no vendoring in libraries), and I think it's important to allow people to experiment and to define the limits of the world your chosen package layout might be useful for. &gt; users.User, pages.Page, authors.Author etc which might cause import cycles. As I noted above, in practice that doesn't happen, so the stutter you mentioned just isn't a problem, and as problems go, stutter is very minor if not pervasive. Import cycles won't happen if your models don't try to talk directly to each other (and IMO they should not). &gt;A better practice is to keep all those at your root package This leads to a few problems - either all your models and the bulk of your code is in one big package, or all your models are in one place, but methods and code that acts on them is somewhere else (I think that's what he's suggesting?). Also all your models know everything about other models, so they can become deeply intertwined with circular refs between them. Perhaps it would work for some types of project, I haven't found that a useful pattern, but am quite willing to accept that for some types of project it'd be a good way to structure them.
 package main import "fmt" func main() { who:="World" fmt.Println( "Hello, " + who+ "!" ) } 
&gt;In Go, there is a general rule that syntax should not hide complex/costly operations. I see, so it does not do I what thought it would.
main() is a goroutine and http.ListenAndServe is an "infinite" loop according to your logic webservers in go are a bad thing... interesting
This very discussion we are having is a good proof that the problem exists. We need best practices.
flag.IntVar expects a pointer to the variable the parameter value is supposed to be saved into. In other languages this is called "by reference" as you're not passing the value of a variable but the location in memory where it's stored (so the called function can alter it and you have the altered value after the function call in the original variable). Now, what happens when "cnt" ist just "int", you have a variable that can hold any integer value and is stored somewhere in memory (the system takes care of where) and since flag.IntVar expects a pointer the compiler takes care that the actual address, not the current value, is passed to flag.IntVar. However, when you already define "cnt" as "*int", i.e. as a pointer to an integer value rather than "just an integer value" and you do not take care of setting it to a valid memory address the program will crash because flag.IntVar tried to write to a memory location (0x00000000 in this example, to be precise) it is not allowed to access =&gt; SegFault.
Makes sense. Thanks. 
when will it be implemented?
To try and clarify /u/TheRealHellcat's answer a little (or at least explain it a different way): Go initializes variables to 0. When you define it as `*int`, it's being initialized to `*int`'s 0 value. (That is: a pointer to address 0x0.) When you define it as int, it's allocating somewhere in memory for that int, and initializing that memory address to 0. flag.IntVar takes a pointer that it will try to store the flag in. If you pass it a pointer pointing to 0, it's going to try and save the value at address 0x0 (which is set to read-only by your operating system's page table, because it's part of your program's text segment, which is where the code that gets executed goes) When you pass it `&amp;var` for your int, it's the address of `var` (which is an address in your program's data segment, because it's a variable, so that's perfectly valid.)
linked lists in general have negative consequences for caching and data locality. I believe this is what is happening in the following example, https://twitter.com/wefreema/status/438518140813971457, and there are others. linked lists versus slices are a good indicator someone groking the kiss principle. Does someone go the simple built in route for small to medium sized general propose lists using slices or do they reinvent linked lists. I think it's a good indicator of how well a developer will do at maintainable simple readable code. Especially if they can explain the issues behind locality and why micro benchmarks show slices winning in most cases. 
Yeah. I know that. But sometimes it froze the program. When I go to Github and search for the answer, what I got is "This is not an issue." and "Don't use an infinity loop in the goroutine." I have no idea why. I thought that infinity loops are "cheap" in Golang? My program hanged because of the infinity loops in the goroutines, my program works after I removed the goroutine, and this problem happened atleast twice. I still can't figure out why.
&gt; While this proved effective and worked perfectly fine it isn’t very idiomatic in Go. It also felt very dirty to me Why?
I'm sure there are good uses for slices, but there are surely arguments to be made for linked lists. Caching considerations are only important for elements that are used very, very frequently.
https://play.golang.org/p/Zg9ReWxSsQ
No one should use container/list. Just add and remove from a slice, and then if you profile it and that sucks, change it to be a dynamic ring buffer. Container/list pretty much always has worse performance and worse type safety than whatever else you could be doing.
not sure if you are trolling... if you're not: You should avoid goroutine leaks. Loops in goroutines are perfectly fine as long as you know how/when to break the loop and exit the goroutine https://dave.cheney.net/2016/12/22/never-start-a-goroutine-without-knowing-how-it-will-stop
These [links](https://en.wikipedia.org/wiki/Typographic_ligature) should [help](https://github.com/tonsky/FiraCode) =)
You are fantastic. 
Hey php03 aka "post old stuff on reddit"-bot again Setting up a Go Development Environment -&gt; 24 Mar 2013
tl;dr yes, because why not?
Go and Docker have almost nothing to do with each other. Docker is just as relevant in a "Go world" as it is with any other language.
Yes! Definitely continue and finish this game.
My co workers code
"blazingly" ... please, let's not use this stupid meme word.
It is :P though it was used somewhere on their site and sounds catchy
[removed]
What's with the descriptions in that page?
That's useful, however the fields I care about are common to all types and I don't really care about the other data, except not to loose it during my filter process. I'm also challenged because I have to sort the data I'm returning. 
In Vim I just press gqip within a paragraph of the comment or I select the comment and press gq.
Gits simple storage system is a triumph. In libgit2 (C) you can drop-in any simple Backend, to say store objects in Sqlite3, or memory, or any place else. It's incredibly well designed. I'm not sure what go-git is, appears to be native implementation of git without libgit2/c bindings. Nice to see feature parity being maintained.
Segmentation Violation aka SegFault Referring to the second line of the error message produced by OP's code sample
This gave me an idea and I really wish I had seen this. I can just return via the .Call() and .SMS() function the proper response type by asserting what should be before sending back to the end user. Thanks!
I think I will add that to the site.. ;-) https://raw.githubusercontent.com/rogeralsing/gophers/master/png/FlashGopher.PNG
This is my take on flappy thing, but with raylib bindings. https://www.youtube.com/watch?v=3RZZlEFM25E Source: https://github.com/gen2brain/raylib-go/tree/master/examples/games/floppy APK: https://gist.github.com/gen2brain/ae96bc92d2c2e307af35f5583f30ea25 
I've been using Gogland since the first EAP. It's utterly amazing. Keep up the hard work chaps, and thanks.
Excellent question, absolutely correct answer. Thanks, all!
Non-Mobile link: https://en.wikipedia.org/wiki/Polymorphism_(computer_science *** ^HelperBot ^v1.1 ^/r/HelperBot_ ^I ^am ^a ^bot. ^Please ^message ^/u/swim1929 ^with ^any ^feedback ^and/or ^hate. ^Counter: ^26681
Traditional OOP isn't really a great design pattern in Go, so I'm not entirely sure I would use this as a justification for methods.
Absolutely, feel free to take anything that's helpful and would save you time. Yep, it's precisely customized towards my needs, that way it's simple and I don't need to provide any options.
What were you using before? This seems almost identical to using Visual Studio Code with vscode-go. Which is fantastic. I'm really curious and if it's better I would switch. Thanks.
Could you please elaborate on this? Interesting.
Go is not "classical" OO since there are no classes, but I would argue that it is still OO. Polymorphism, encapsulation, and composition are well supported in the traditional definitions and Go's "type embedding" can be seen as an evolution of classical inheritance. Go is not Java or C++, but it's still OO IMO.
Regardless of language, I tend to prefer a regular old for loop. When I see `for i in 0..10` I don't know if 10 is included or not, but by doing `i:=0; i &lt; 10; i++` all of the logic is right there.
Same, with the theme I use (not sure if its in the default theme) it has faint guides on the right and I just use those as guides to justify my comments... I haven't found any differences with how godoc generates from it so...
What about error reporting? Do I still have to click in the outputwindow to go to the location of the error, or is it more integrated; like pressing F2 to jump the next issue?
This is also possible in C, D and C++. It allows to define a scope limit of a variable declared inside. 
As others have noted, there are actual functional differences, for example 1. Implement interfaces 2. Allow you to pass around partially-applied methods that know which struct they came from 3. List the methods through reflection 4. Gain access to the methods when you embed the type However, there's another point to be made. What you're saying here is actually equally true in virtually every object oriented language. Java and C++, methods are like a Go method with a pointer receiver named "this". Python, methods take in "self" as a first, automatically populated parameter, also essentially a pointer receiver. So there is also an answer which is... Whatever reason there is to have methods in other languages.
Why do you think so?
JavaScript as well, with `let` and `const` (ES6+).
I had nothing to do with it, just reporting the great news. Yes, it's a fork of the plugin from about 8 months ago and it builds on top of the plugin adding a bunch of missing features and speed improvements. And since it's a stripped down version of IDEA, it's very snappy, at least in my tests.
Well I would expect the range to be inclusive..exclusive. If you think critically about it, the for loop is no more explicit - it's only by convention that you know that the condition is checked before block execution, and the variable is incremented afterwards. For someone new to programming, and without prior knowledge of c style `for` loop, I think the `for i in 0..10` is much more clear about what it does. In fact, I would bet that in a survey of non-programmers, more people would be able to guess what `for i in 0..10` does than the c style `for`.
It's the first time I see this being requested so I've added this issue on your behalf: https://youtrack.jetbrains.com/issue/GO-3413 Please add any comment to it that would further capture the issue that you are describing. Thank you!
I would bet if you ask non programmers what `i in 1..10` does that at least 25% would assume it includes the 10. No including 10 is something a programmer would assume.
I.e. you want to reuse your table data in several points of a template? If I have correctly understood a question, then here a small [example](https://play.golang.org/p/_JkNKLJDE8) for you.
Firstly, this is tricky because it does depend what kind of project you're working on so this is not one-size fits all advice (and indeed I'm skeptical you can have one size fits all pkg layout). However in the context of web apps, I like each resource in its own package and use this on some quite big apps without problems, in fact it nicely separates the resources which are the most important parts of the domain model and makes it very easy to find code on larger apps. The key to this is to separate handlers (which in larger apps usually pull in a few resources) from the resources themselves - for example a pages handler might need to know about users, tags and pages, but a pages model has no business knowing about users. I typically have something like this: /users /assets (js etc) /views (templates) /actions (user handlers, which might pull in many resources) show.go ... users.go (User + methods on User) ... The advantages are: all code about users is in /users, I quite like having everything for a resource in one place, you might have a different approach with handlers elsewhere, but I think the basic idea of keeping handlers separate from the resources in a separate pkg (in this case sub-pkg) works well and there is no need for circular dependencies if you don't let your resources know all about other resources, indeed circular dependencies forces you to avoid doing that. The disadvantage is: resources don't know about other resources and cannot for example have a list of tags on a page, but I think in many ways this is an advantage, as the alternative tends to creep into every resource depending on and even manipulating many other resources (for example updating created_at on some related resource), and your app is then far harder to reason about and you need to fill in all those lists of page.Tags, page.Images or whatever every time you pull a page - I think I prefer this being explicit in the handlers. 
I don't think they are really comparible. Gogland has context-aware auto completion, inspections, refactorings, code generation, near-perfect "find usages" implementation, semantic highlighting, code coverage for tests and many more features inherited from IDEA. You can see [an overview](https://www.jetbrains.com/go/features/) here.
How do you suggest cross platform applications should be build?
Thanks for this great tool!
&gt; Other editors do have most of this stuff. I've used auto-complete, find-usages, rename and code-coverage extensively in vscode and atom. This is subjective but in my experience, all of these are better implemented in Gogland. Like they are faster because they work in-memory and don't have to invoke external binaries like vscode-go. Rename recognizes docblocks, refactoring between packages (e.g moving a type from A to B) also rewrites imports and renames folders as necessary. What else? It supports jumping to implementations from an interface and it validates interface implementations *without* compiling, which is a godsend on large projects with 10+ seconds compile times. It can format uncompilable code, unlike gofmt. Formatting code doesn't break editor state, like foldings. &gt; It always felt like they were try to put Go in a Java box. How so? I would probably agree with that if Intellij was Java only and they just put Go on top of it, but the IDE exists for half a dozen languages and most of them are very popular in their own ecosystems. If it was truly forcing things into a "Java box", I don't think that would be the case. &gt; Presumably, eventually this application is going to cost money. No need to presume, the initial announcement said it will be a paid product after the beta. However, they will also release the plugin version, which you can use with IDEA Community Edition for free. &gt; When the competition is all free, I don't think it's unreasonable to expect high quality. I agree! There is a reason why a lot of people consider IDEA to be by far the best IDE for a lot of languages, me included :)
fixed
Tried quite a few backup tools before settling on this. Nothing else was anywhere near as quick and easy for some basic cloud backups. Fantastic tool!
With native languages and frameworks. Only this way
Got it, thanks!
I agree loving it aswell
Prefer strongly typed channels to functions of (interface{}) interface{}. Rx is practically useless in Go until Go gets the ability to write functions on multiple strong types at once. :) Related: The uselessness of LINQ implementations in Go. https://godoc.org/github.com/ahmetalpbalkan/go-linq 
Why shouldn't a page know about a user? What if a page needs to limit access based on who is logged in? Doing this means using something like GORMs relationship support won't work ( see http://jinzhu.me/gorm/associations.html#many-to-many ), at least not as smoothly. I'm not saying that there is one size fits all. I think you are right there. I'm just saying that I disagree with the notion that each resource should be isolated with no knowledge of another, and instead prefer to design my code differently to allow for that. As a result, I don't think that belongs in a style guide.
Ah, the version on golang.org instead of the github repo. That's why reddit didn't catch it. Thanks. I'll remove this dup.
I guess bitwise operations sounds less impressive.
Never heard that but you should use this instead: https://github.com/gorilla/websocket
Backtick exists on iOS, you have to get to it by holding down ' key, it'll be one of the alternative similar keys presented.
gofmt doesn't modify the contents of raw strings.
Use PHP as a pre-processor to implement Go generics.
No, channels do not in *any* sense obviate Rx. Even in other languages Rx is immense overkill of that's all you're using it for. 
I'm not the author, but I find this much nicer than GoSublime.
It appears as if this project already uses that library.
GoSublime works, but seems to be largely unmaintained:(
It did in a function like func print_help() { fmt.Println( `first line more lines more lines last line`) } Left-alignment is the whole purpose of formatting it in a function call or const string definition like that.
nice! that's totally a data race and I it makes me think I should write some tests and run them with 'go test -race'!
Wowwwwwwwwwww I just discovered the other insane UX issue I had with cursor movement highlighting entire words it thought was misspelled and general cursor control is fixed by holding down any letter.. which is more useful than typing backticks. Which apparently I can't do or am some sort of idiot. Fairly new to iPhone though. Whatever. Lol. Thanks man :-)
here have mine `
sry you needed another one here `
How do you do UI? If there was a usable Go UI which looked (Material) native, I would use it in a heartbeat. It's sad that the same company that came up with such elegance in Go created such a monstrosity such as Android API.
I think what we are thinking in our heads are different. I have seen this pattern used where the `user` package also includes user specific action/handlers. It basically contains *everything* user related. This comment suggests that you have your handlers elsewhere and they use both the `user` and `page` package, which may work better. I would have to try it and see. Edit: Just realized you had `actions` not `actions.go`, which suggests it is a nested directory (and a different package). Is that what you had in mind?
There's CGI, which is old-school but only runs your app when needed - NGINX doesn't support it though. A newer (relatively) alternative is FastCGI which NGINX *does* support - it behaves similarly to a reverse proxy, in that your Go app stays in memory. Reverse proxy is your best bet, honestly.
Thanks, I'll benchmark that against my current approach of deserializing to a slice of map[string]interface{}. I'm dealing with 750K + objects so I assumed the 2 pass serialization would be slower than a single pass. 
if you are using gomobile bind, your go code is just a library loaded by the java/android app and the UI is created by java (native). Using gomobile build, your go code is in charge of everything (opengl bindings) so an UI is a bit more hard to acomplish (take a look at vulkan api).
And nothing is wrong with that. Reverse proxy is fine.
I've finally figured it out, but thanks!
This has been answered by me and @ThomasJWaldmann (borg author) here: https://www.reddit.com/r/golang/comments/5a5jbz/ann_restic_030_secure_fast_free_deduplicated/d9e7r3q/
The seminal book for this type of stuff is called "Hacker's Delight".
Oh, great! 
This sounds really interesting! Is this an app we can try in either of the app stores? Also any open source bits?
I do the same, but I've also added a feature to my text editor where it highlights the 80 character mark of the buffer to make it easier. (I don't use Atom, but I imagine Atom has a similar feature.)
Lol
Another approach - look for hosting that allows routing between dynamic / static instance. AppEngine for instance would allow you to set certain paths to be served through their CDN (the static files) and others to hit your app instance for processing by Go code. Your Go app doesn't need to be concerned serving up static files then. It's similar to what you could do with Nginx, just built in to the platform.
Unfortunately, every converters works differently, so yes, it will work for one or two models. I used Go to work with an ADS1015 a few months ago. It uses an I²C interface, so you don't have to worry about RPi's GPIO if you're running Linux. You just have to wire it to the Pi like described [here](https://learn.adafruit.com/raspberry-pi-analog-to-digital-converters/ads1015-slash-ads1115). I've modified [Adafruit's Arduino library for ADS1x15](https://github.com/adafruit/Adafruit_ADS1X15) to use Linux API, then translated it to Go. I still have the library itself, but I can't find any working example on my computer.
Vulkan is too low-level for games yet, lol. I'm secretly struggling making a spinning cube with it, I have 2 complete android apps and both can't show me the cube. I don't have time for now, for a third try...
Well in terms of your validation they appear to be two different validations. That being said for your structs you can do something like this type ( User struct { FullName string `db:"full_name" json:"fullName"` Country string `db:"country" json:"country"` Username string `db:"username" json:"username"` } CreateUser struct { User } UpdateUser struct { User } )
Careful with this. The `Username` field has two different tag definitions in OP's post. So it should probably be placed in each type separately, instead of being part of the `User` struct.
Just have your webserver serve the static parts directly, and only forward requests for the dynamic parts to a go app (or more than one of them, if that floats your boat). No need to have everything under one process if you don't want to, and no need to have go do something your webserver can do better.
The best solution often depends on the context. Why do you need two points of fixed precision? If you are dealing with currency (like USD), often the easiest solution is to convert your data to cents - `1.01` becomes `101`, and you can now store it in an integer. Stripe and others do this when dealing with currency values as you only need two points of precision. Another option is to try to determine how much precision you need. For example, if you only need `1e-9` precision you can probably just use floating points and write your code like this: https://play.golang.org/p/55sWUBov2o This will make sure your for loop continues to run until x is at least `1e-9` greater than `1.4`. This method takes a bit more practice to know when to use it, but it can be useful at times.
One problem with go mobile on Apple platforms is that go cannot generate llvm bitcode. For tvOS it is required; it is recommended for iOS currently and could become required in the future. 
ahhh yes, I missed that. You are correct 
You are right. I would never think of your solutions because I work with ABAP. This floating point drifting doesn't happen there. Lately I've been trying some personal programming projects as hobbies, more to gain more knowledge than anything else, and go has been one of the languages I've tried. But I really need to get out of the ABAP mindframe.
Limited/no benefit from Codepush though :(
There's also a point to be made about not polluting your packages namespace
That makes a lot of sense, and explains why I was having trouble. I'm going to hack at it for a while. Thanks for the detailed response!
Would anyone know any DA AD converters for Raspberry that have a working Go library support?
Well, I pushed some trivial, but useful fixes, I think. Starting with the ability to actually build the program, due to migration of one dependency. And added ability to calculate width of unicode filenames correctly.
I've been keeping my eye on restic for a while now, thanks for all the work!
why don't you just combine the DB fields and specify the json type like you have. Not sure I understand you having 2 versions of the same field.
ahh i see, you should pull out the Username field into the CreateUser struct. Basically only have shared fields in the user struct which maybe you should change to 'Shared(something)' or whatever you want. Then for specific values you should include them in their respective structs. Does that make sense? User struct { FullName string `db:"full_name,omitempty" json:"fullName"` Country string `db:"country,omitempty" json:"country"` } type CreateUser struct { User Username string `db:"username,omitempty" json:"username"` } UpdateUser struct { User Nickname string `db:"nickname,omitempty" json:"nickname"` }
My first intuitions are these: a little duplication beats an unwanted abstraction, and just because you /can/ create an abstraction somewhere doesn't mean you automatically /should/. Suppose you have 10K lines, you can add an abstraction and reduce that to 8K but now you have additional complexity in your project. You do that a few times and now the next developer has to learn 7 new abstractions before he's able to work with the code. Compare a big bland piece of work with a highly intricate (shiny!!) one. Now imagine your team has to maintain ten of those. I am /ALWAYS/ /EXTREMELY/ sceptic of /ANY/ additional complexity on top of what your platform (in this case the generous golang stdlib) provides. So from the outset my response would be: yes, just copy and paste the validation code, it's quite simple, it's not hard to maintain, it's fine.
Oh dear god: &gt; Package fcgi implements the FastCGI protocol. Currently only the responder role is supported. The protocol is defined at http://www.fastcgi.com/drupal/node/6?q=node/22 and of course.... &gt; **Not Found** &gt; The requested URL /drupal/node/6 was not found on this server. Drupal, not even once*!!*
The best way to compare floats is to actually wrote a function that looks like this: func tolerance (a, b, e float64) { d := a - b if d &lt; 0 { d = -d } if b != 0 { e = e * b if e &lt; 0 { e = -e } } return d &lt; e } For really close tolerance use 4e-16. For close tolerance use e = 1e-14. For most general cases, 1e-8 is more than enough
The best way to compare floats is to actually write a function that looks like this: func tolerance (a, b, e float64) { d := a - b if d &lt; 0 { d = -d } if b != 0 { e = e * b if e &lt; 0 { e = -e } } return d &lt; e } For really close tolerance use 4e-16. For close tolerance use e = 1e-14. For most general cases, 1e-8 is more than enough Source: I deal with a lot of float issues in machine learning
If speed isn't critical, check out math/big https://golang.org/pkg/math/big/
Hi! xlab I was trying to use your vulkan library. https://github.com/vulkan-go/vulkan I don't understand is it ready for *linux* or not? I tried to build your desktop demo with it. Did you have success with it or it's just a draft?
Because it isn't a language problem but a problem with how floats are represented in general. https://stackoverflow.com/questions/21895756/why-are-floating-point-numbers-inaccurate
It's a business application for paying corporate subscribers and closed source. I'm trying to get time to develop a great open source example for the community.
That's a good tip, I'll definitely try this.
if you need decimal numbers: https://GitHub.com/ericlagergren/decimal
&gt; Rest API (GET, POST, DELETE, PATCH, PUT) It looks like it is a router for CRUD operations. How does this tool helps to build RESTful APIs?
Restic is now my go-to backup tool of choice for personal backups. I recommend it to anyone with some technical chops. I still have a year left on my other backup service's subscription so I'm dual backing up (which I recommend to everyone -- use multiple different backup services) with restic for now.
They are field tags. A relatively obscure feature that's mainly useful for reflection. &gt; A field declaration may be followed by an optional string literal tag, which becomes an attribute for all the fields in the corresponding field declaration. An empty tag string is equivalent to an absent tag. The tags are made visible through a reflection interface and take part in type identity for structs but are otherwise ignored. 
Strings are simply a sequence of abritrary bytes, to count these bytes you may use len(). As you know UTF8 code points may be encoded into a sequence bytes, in Go they are called runes. You may use the utf8 packages RuneCountInString method as you demonstrated above to count them. This is pretty simple and it seems you already got it right. What is not simple is alignment in the context of your screenshot. First I'll say I don't recognize your terminal emulator, but it almost seems like some hanky JavaScript web GUI terminal emulator in a emulator thing. If that's the case alignment isn't even worth trying to pursue, just count runes and be sure your implementation is correct. Check the results without multi byte sequences. Then make sure all your multi byte sequences are valid. Then verify your monospace font is truly valid by using another known correct reader with your inputs. Finally try with a different terminal emulator. At some point you will find where the problem is. Have "fun".. lol
Right answer, every time!
I used go imports on save, but now it says unused imports for each line of imports. Other than that, it is amazing. Kudos to you.
I was literally just dealing with this nonsense an hour ago. And now I find this while laying in bed. Wish I would have procrastinated before :/
I haven't tried it but I'm fairly sure you can define custom struct field tags. What about using those to create update_required and create_required tags? It might reduce repetition at the cost of boilerplate.
I'm trying to send feedback, but it opens a page in my browser that says "You have no permissions to view this page". There is a login-as-guest option, but that doesn't work either.
It's very much mate-terminal with Source Code Pro and non-standard theme, so no JS horror. Further look at the problem shows me that it is still horror, just more primal - ASCII characters are in main font and monospaced, CJK characters aren't mono or multispaced. So trivially - by counting bytes, runes and/or rune widths - the problem can not be solved, because they are integers, when actual screen width can't be measured in whole space width. To solve *this* problem, one needs to ask font rendering engine what it thinks of individual glyphs, then round that to integer and pad to that for alignment. I haven't found a package that can do that, so it could be my participation in wider Go ecosystem...
Floating Point numbers have some imprecision. You can either use one of the methods here to work around the imprecision or alternatively you can use a Decimal library. If the problem is not related to science or machine learning, you might want to consider decimal numbers. Lastly, you can always just multiply until you can represent the numbers as integers.
I am not sure but [this](https://godoc.org/golang.org/x/text/width) package looks like another place to search for a solution.
I am not sure what you want. Do you want to learn programming or producing animation? Also it helps to actually list want you found and why they are not good for you, since we are not mind readers.
Not a significant one, but godoc groups methods on objects whereas it might not for some functions. Using methods also provides a better user experience to people using a Go autocompleter in their editors, as they can easily view the methods that can be performed on an object by looking at autocomplete suggestions, rather than having to go back and forth from the documentation.
So you want to move complexity on user side? Create some unusable interface and force user to se this crap? Just because you think this is not practical... Something definitely wrong with this industry.
Well, go-runewidth tells me when things are narrow or wide, but...
Except the first line, but I guess I can live with this quirk/limitation. This is a case where a comment to have gofmt ignore a function would be useful, but that would contradict gofmt's design.
You can use Nginx to serve all of your static content from a directory on your server, then use a proxy_pass to connect to your Go app for just the dynamic path that you care about. The HTTP module keeps this setup simple, and you're not leaning on Go to serve your static content. 
Not running `gofmt`.
&gt; so we cannot [before this change] do this. &gt; &gt; golint $(go list ./... | grep -v /vendor/) First: golint `go list ./... | grep -v /vendor/` is the more portable version, `$(…)` is a bash-ism. Second, although tools like `golint` really should support package specifications just like `go build|install|test|`etc and changes to bring them closer are appreciated, I wonder why the original poster didn't just do: go list ./... | grep -v /vendor/ | xargs -n 1 golint that works unless you have a package directory name containing white space.
There are also combining glyphs in Unicode. These are counted individually by things like `RuneCountInString` but are (as the name suggests) combined into a single glyph when displayed. See [Strings, bytes, runes and characters in Go](https://blog.golang.org/strings#TOC_5.) and [Text normalization in Go](https://blog.golang.org/normalization) from the Go Blog for more information.
I'd recommend diving into [sdl2](https://github.com/veandco/go-sdl2)
All that matters is your implementation is correct, the local emulator is the responsibility of the user. You would probably end up just causing users more annoyances if you try to hard to accommodate them, since they are likely well adjusted to the nuances you are facing. 
reminiscence of iris go
What? Can you rephrase that nicely? I mean complexity as in the complexity of the features, large programs that you don't want to code multiple times. You can build perfectly cross platform apps in a single code base that are also user friendly. For example, browsers, with few exceptions are cross platform and user friendly.
In your situation I think it's impossible to solve this. To start with, the full rules for how wide Unicode characters theoretically should be depend on the font, are very complicated (see Manish Goregaokar's [Let’s Stop Ascribing Meaning to Code Points](https://manishearth.github.io/blog/2017/01/14/stop-ascribing-meaning-to-unicode-code-points/) for some torture tests), and also depend on the language being rendered, per [this comment by farseerfc](https://utcc.utoronto.ca/~cks/space/blog/unix/XTermFreeTypeCJKFonts?showcomments#comments). Since 'language being rendered' is often not handled well, different fonts can be aimed at different language audiences and have different widths for the same codepoint as a result (the comment gives an example). But the bigger issue is that you don't control the font rendering here; the terminal emulator does, and who knows how any particular one is going to behave and what bugs it's going to have for the more unusual cases in Unicode. There's probably no terminal emulator that handles this completely correctly (partly because it's really complicated), and even then with language-dependent widths you're guessing at what language the terminal emulator is going to assume (or what font it is going to use). I suspect that the best you can do is make some somewhat simplistic assumptions (eg that terminal emulators will render CJK characters in double-width) and provide an option to 9t to turn off attempts to align things. If you have tricky cases (or the energy), you might want to test a number of terminal emulators to see how they behave. I'd pick which terminal emulators to test based partly on which underlying font rendering libraries they use and partly on what's popular among your target audience (which may take a poll).
Ah. So it's the appearance that bothers you? Gotcha. I was saying the output is gonna be the same. 
I don't know much about JWT, but this is worth saying in case anyone is new to web dev: The line `password != "pw"` should not be translated into working code (checking that the password is in the DB). Passwords should not be stored in databases because if they are and a hacker steals your database (for example by getting a database backup from a rogue worker or stealing a laptop), then they will know all your users passwords and be able to try those same username+password combinations on other sites, to check for password reuse. Instead, what you should store in the database is a "salted hash" of the password. Essentially, with a salted hash, a user's password is turned into an opaque string that cannot be reversed back into the plain text. The most popular algorithm for this is bcrypt. There are more details, but that's the minimum anyone dealing with passwords absolutely has to know. Google around and you should be able to find more about constant time comparisons and whatnot.
Thanks, I know about that. Unfortunately for what I want to do I might make a few thousand images. That would get really nasty when I have them in a folder or something.
So basically, they _do_ nothing, but an ORM can use it to look for the db field name, or a serialiser can use it to look for the json field name?
I figured as much, just thought it was better to be safe than sorry. :-)
Hi, that's a bit unfortunate. Please create an account on YouTrack and it should work. Alternatively, you can use this link: https://youtrack.jetbrains.com/issues/GO and then create an account / report the issue there. Or if you are in Gophers Slack, join #gogland.
 // TODO: allow CDATA to iTunes Summary tags (e.g. embed rich html content, such as links) // (OP) Originally I used and built a few itunes podcast feeds from Gorilla's Feeds project. But it seriously fails once you attempt to use it with iTunes - missing all of iTunes flags. I searched for a while and didn't see any other Podcast Generators... Additionally, Gorilla's Feeds forced you through some really funky casting and pointer methods to get the RSS out - that its overrides was not compliant to RSS readers. I forked and fixed a number of issues and Linter faults, only to come up with a number of breaking changes (like allowing an Item Link to be something else than Enclosure.HREF). Therefore, I just wrote this new package that is fully iTunes compliant with rich data, allows overrides with full iTunes specifications (as of 2017/2/1) with 100% code coverage (I always like a challenge of getting to 100% in Go).
Haha no worries, I appreciate the lookout! 
Typically you put the JWT in the Auth header as `Bearer &lt;token&gt;` but you can also pass it as a cookie or as a URL query parameter. I wrote the JWT middleware for Caddy server. Feel free to check it out for some ideas. [https://github.com/BTBurke/caddy-jwt](https://github.com/BTBurke/caddy-jwt)
I love seeing clever posts like this. Thanks!
&gt; I wrote this a few years ago (2012), taking my old lecture notes about Java and network programming and rewriting them in Go. Not the most promising start.
Sorry for the cross-post, but REALLY DON'T FOLLOW THE ADVICE OF THE SECURITY SECTION. Like, don't even read it. https://news.ycombinator.com/item?id=13567055
Just wanted to say good job! Have a star :- )
Just how big could the provided values be? Could you go crazy and, like, put a compressed directory of static html/css/js in like this?
So, you want to put nginx in front of go, ... and now you have 2 problems =) . Just kidding, there's legitimate reasons to do this, and fcgi is one of the options, also there's no reason you couldn't use nginx as a reverse http proxy for some URLs and avoid having to learn fcgi. If you choose to just stick with go, here's a helpful checklist style blog that enumerates some widely considered best practices. https://blog.gopheracademy.com/advent-2016/exposing-go-on-the-internet/ There's similar articles for nginx.
I wonder why http://httpie.org is not mentioned as an inspiration ;-)
There's already a pretty good [NES emulator in Go](https://github.com/fogleman/nes). It might give you some ideas.
I am currently developing a single sign on solution for our various services and did some extensive research on best practice recommendations for jwts. Some good resources were the documentation and blog posts of auth0 (https://auth0.com) and stormpath (https://stormpath.com) as well as the specification of OpenID connect (http://openid.net/connect/). That said, best practice really boil down to your security requirements and to what you want to use jwts for. The basic problem with jwts is, that someone might steel the token and would then be able to login as the user until the jwt expires. Then there is sort of a federation problem: Let's say you have a single-sign-on (like for google) that should allow your users to access multiple services after they have logged in. If you are using oauth, the service would get the user authenticated from single-sign-on and then establish its own session by - for example - using jwts. Now the problem is, that jwts typically only get saved on the client. Hence, it becomes quite tricky to stop the session for all services once the users is login out from the single-sign on. This would require to somehow delete the jwts from all services on the client or require you to have a blacklist on the server - which sort of brings you back to the regular session management before jwts. There are some workarounds, but it does get rather complicated. It becomes simpler, if we focus on a single service. Were to store, respectively check for the jwt basically boils down to three options: - Request header with "Authentication bearer {token}". Really convenient for api calls from the command line. Question would be were the client would save the token - Saving the jwt in local storage - as done by auth0. This gives your frontend code access to the information stored in the jwt. Which is great for example for single page applications that should adapt based on user permissions or show information about the current user. However, there is a certain attach surface for this, as the jwt is accessible with javascript. In addition you must implement the functionality to pass the jwt to the server on every request (i.e. as post parameter or as header token) - Saving the jwt in a cookie - recommended in a blog post from stormpath. This is really convenient, as we can leverage the browser functionality to store and expire jwt-cookies. For security reasons the cookies should be set to httpOnly (no javascript access) and secure (to only be passed over https) Here is the code I am using for a web-application that uses cookies to store the jwt (only example code). jwt "github.com/dgrijalva/jwt-go" "github.com/labstack/echo" "github.com/pkg/errors" "github.com/uber-go/zap" // should be replaced by your custom secret var tokenSecret = []byte("abcdefgh") const tokenIssuer = "your.domain" // define custom token claims type tokenClaims struct { models.User jwt.StandardClaims } func (env *Environment) requireAuthentication(next echo.HandlerFunc) echo.HandlerFunc { return func(ctx echo.Context) error { // check if the users has a jwt token set in the cookie cookie, err := ctx.Cookie(tokenIssuer) if err != nil { env.Logger.Info("could not read token cookie", zap.Error(err)) return ctx.Render(http.StatusOK, "login.html", nil) } // parse the token string from the cookie tokenString := cookie.Value // check if the token is authenticated token, err := jwt.ParseWithClaims(tokenString, &amp;tokenClaims{}, func(token *jwt.Token) (interface{}, error) { // validate that the signig method is correct if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok { return nil, fmt.Errorf("Unexpected signing method: %v", token.Header["alg"]) } return tokenSecret, nil }) if err != nil { env.Logger.Error("jwt token error", zap.Error(err)) return unauthorizedResponse(ctx) } // try to extract our custom claims from the token claims, ok := token.Claims.(*tokenClaims) // check if the token is valid if !ok || token.Valid == false { env.Logger.Info("token is expired", zap.Int64("expired", claims.ExpiresAt)) return unauthorizedResponse(ctx) } // save the user information in the context ctx.Set("user", claims.User) // issue a new cookie for the token err = generateAuthToken(ctx, claims.User) if err != nil { env.Logger.Error("could not generate new token", zap.Error(err)) } // handle the next function in the chain return next(ctx) } } // generateAuthToken will issue a new authentication token func generateAuthToken(ctx echo.Context, user models.User) error { // define the claims for the jwt token claims := tokenClaims{ user, jwt.StandardClaims{ ExpiresAt: time.Now().Add(1 * time.Hour).Unix(), Issuer: tokenIssuer, }, } // create a new token token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims) // sign the token with our secret tokenString, err := token.SignedString(tokenSecret) if err != nil { return errors.Wrap(err, "could not generate the jwt token") } cookie := http.Cookie{} // set the name and value of our token cookie cookie.Name = tokenIssuer cookie.Value = tokenString // expire cookie in an hour cookie.Expires = time.Now().Add(1 * time.Hour) // cookie shall not be accessible by javascript cookie.HttpOnly = true // always require https connections cookie.Secure = true // write the cookie header to the given context ctx.SetCookie(&amp;cookie) return nil } func setExpiredCookie(ctx echo.Context) { cookie := http.Cookie{} // set the name and value of our token cookie cookie.Name = tokenIssuer cookie.Value = "" // expire cookie in an hour cookie.Expires = time.Now().Add(-2 * time.Hour) // cookie shall not be accessible by javascript cookie.HttpOnly = true // always require https connections cookie.Secure = true // write the cookie header to the given context ctx.SetCookie(&amp;cookie) } 
Try SDL again. If delve doesn't work through VSCode, you can still attach it to a running process (\`dlv attach \`pidof foo\`\`).
:smile:
I know. that's why I gave the example of js as well. I've just never had to deal with it before and now I did.
what you are printing is different from the real value. the 1.03 you are printing is, in reality, 1.03000000001 and that is the value that gets used in subsequent operations.
Awesome. I use Anaconda for python support in Sublime. Looking forward to trying this out 
Not sure what it's giving over a pipeline involving curl(1) and various methods of editing and invoking earlier commands.
The videos will be uploaded here : http://video.fosdem.org/2017/H.1302/ (just give them some time to be published) The slides for the first talk (about gomobile) are here https://talks.madriguera.me/2017/fosdem2017.slide#1
...and another sh*t post brought to you by php03 bot post from 1 October 2012 
I love terminal apps like this.
It isn't, but combined with the shell it's invoked in, they form a usefult combo. Still, I fail to fathom how your comment relates to mine: I merely pointed out the tool which is IMO the closest to the one being advertized. If that weren't clear, I did not attempt to compare them.
Bookmarked your Leanpub link :) will deffo be taking a look at that.
You're trying to emulate a system that ran at a clock speed of less than 2Mhz. How slow do you think image/draw is?
Sorry I did somehow miss that there is a reddit inbox.. Anyway. We usually build the docker containers by hand (doing docker build ..) push it to a private docker hub or load the image directly to the server via sftp (you can use "docker save" and "docker load" for that). We will probably create a small utility with go in the next weeks to automate this. But it is fairly simple and very quickly done. In regard to service discovery, there is an internal dns server in docker that will make the services discoverable that are in the same docker network. Of course it is possible to use a more sophisticated discovery system if needed. We explored using consul for this, but opted to stick with simple container names for the time beeing.
Hi there. We sort of solved the problem using the zap logging library from uber together with the package github.com/pkg/errors that allows us to wrap errors.
Here's the discussion: https://github.com/golang/go/issues/16721
How does this differ from sql-migrate?
Probably not an awful amount, but from a quick look it doesn't require a configuration file and doesn't require custom syntax in SQL scripts. I wanted this tool to be as small and convenient as possible for my own personal use case. 
Good. The price will go up as it will be finished, aiming for april/may so until then it's a good time to get it :)
well I dont see that as a bad thing seeing as many libraries now support different languages, I think its fine to have go in the name. plus its easier to google.
I assume it will be here in a few hours/days, the event was streamed: http://video.fosdem.org/2017/H.1302/
Protocol buffers and/or msgpack sounds a lot like what you're doing here, you may be able to use those off the shelf if you have control over the other consumer of the protocol.
There's lots of packages that generate helper functions for your types... These may benefit from using jennifer... But this doesn't solve any generics problem on it's own.
We used to use Jenkins to build Go binaries, but we've switched over to using Concourse CI instead. It uses containers for each job (build, deploy, etc) and we had to set up an appropriate docker image with Go and the other dependencies already installed to be able to build the binaries. I suspect you'll need to do the same if you're using docker images. You can find or build an image that has Go installed and then set up your paths either in that image or in your build jobs.
Thanks, but my client is the consumer of the wire protocol so I don't get to define the serialization representation. Instead, it is parsing a series of bytes as a fixed structure describing fields that may be bit flags, bytes, words, or an array of those. 
I don't really think this is a go-specific problem, I imagine you'd approach this in the same way in any language. The server just needs to keep track of what room each user is in and only broadcast messages which are sent by users in that room to other users within the room. 
I had no trouble when my GOPATH was in my home directory, so maybe running things from shared space cause this? go run works differently, by creating temp directory inside /tmp and launching compiled binary from there, IIRC. Edit: hope -&gt; home
Yes, this is absolutely great. I'd love a version that made tests pass as well!
By your explanation, and from my point of view, it does not matter, if user is already connected to server you can just add him to requested group without adding additional ROOM_ID in url as room will be another channel. One fast google touch: https://github.com/TapirLiu/golang_chat
[removed]
Thanks for the reply! That did it! If I set my GOPATH or write my code inside $HOME but not the shared space, it compiles and runs correctly. I guess Android has safe guards to prevent execution from anything in the shared user space. Now my problem is that I can't use my code editor and file manager in Termux data space without root access.
Bonus fact. `go-fuck-youself` is great for developing `go-fuck-yourself`. All you got to do is: $ cat howto.md | gophersay ------------------------ // get updates go-fuck-yourself get -u github.com/adamryman/go-fuck-yourself // make updates go-fuck-yourself build github.com/adamryman/go-fuck-yourself // or go-fuck-yourself install github.com/adamryman/go-fuck-yourself ------------------------ \ \ \ ,_---~~~~~----._ _,,_,*^____ _____``*g*\"*, / __/ /' ^. / \ ^@q f [ @f | @)) | | @)) l 0 _/ \`/ \~____ / __ \_____/ \ | _l__l_ I } [______] I ] | | | | ] ~ ~ | | | | | And bam!, your new version of `go-fuck-yourself` will build! ~~Plz give a star if you dig~~
Neat, noted for future needs.
[removed]
A possible solution is to define a third struct that contains the common fields. You may then define methods for this common base struct. type Activity struct { ID bson.ObjectId Type string URL string } func (a *Activity) Init(obj string, type string) { a.Type = type a.URL = "/v1/"+obj+"/"+a.ID.Hex()+"/"+type+"/" } type ActivityOrganization struct { Activity Object1 ORganization ... } func ActivityOrganizationMetadata(ao *ActivityOrganization) { ao.Init("organizations", "activity_stream") ... } As you see it is possible to implement the good old object oriented paradigm with inheritance in Go. Note that you could call methods of the common base struct on the derived objects. 
Maybe you could port https://github.com/auchenberg/volkswagen.
no
http://video.fosdem.org/2017/H.1302/go_state.vp8.webm http://video.fosdem.org/2017/H.1302/go_state.mp4
If I get you right this is what you are looking for: https://github.com/kataras/go-websocket
Surprised me that defer is faster. Does it not compile down as simply calling the target function at the end of the current scope?
It's times like these I really appreciate the choice of name for the language.
Around minute 17 he shows this example for sorting: sort.Sort(byName(p)) sort.Sort(byAge(p)) sort.Sort(bySSN(p)) but this is wrong, sort.Sort is not guaranteed to be stable. The later example with sort.Slice is wrong for the same reason. https://play.golang.org/p/CTEYuVwEi6 PS. I guess maybe he doesn't mean those lines as being a sequential block of code...
[removed]
Thank you very much, this will be quite helpful.
Well, I can't say for sure but it seems that spf13 is more widely adopted, most likely not because of some technical difference, but as a measure of respect &amp; popularity. When choosing between two different packages that might do almost the same thing, a factor what to choose is *who* makes it (spf13 has direct affiliation with google and golang, judging from his github profile, and he is obviously well known in the community for the projects you mentioned, as well as hugo). In contrast, codegangsta is a good developer who made some (in my opinion) excellent packages, and some controversial as well (codegangsta/inject). Based on this, very subjective criteria, for my 12fa of docker&amp;go ebook ([leanpub](https://leanpub.com/12fa-docker-golang)) I'm looking at spf13/viper at the moment, even if some other package might better suit my needs. Of course, ultimately the decision to keep it might depend on how large of a portion of the complete package you tend to utilize and any additional needs you have. Also, programmers have preferences. Docker is a huge ship and it's not at least surprising that some of their programmers might have been familiar with either cobra or urfave/codegangsta/cli before and chose that to work within their team. People tend to pick familiar technology to them, unless they are NodeJS developers or something and pick up every shiny new thing that comes their way.
&gt; People tend to pick familiar technology to them, unless they are NodeJS developers or something and pick up every shiny new thing that comes their way. This is good :-)
My WoW is using VIM inside Termux. Furthermore all code is stored in GIT, so it's pretty easy to ship code in and out of the termux environment e.g. you can do your editting on another device.
now you switched to another account. great do you sell it?
Sorry my bad. The example code I provided is a struct composition. Go doesn't indeed support inheritance. See http://spf13.com/post/is-go-object-oriented/.
If you perform sorting in your critical sections, you might not want to forget that `sort.Slice` has slightly [higher cost at runtime](https://talks.golang.org/2017/state-of-go.slide#48).
Hi! We basically use a channel to do accomplish that. Here is a very similar of implementation of just that: http://jmoiron.net/blog/limiting-concurrency-in-go/
Ah ok. The original code spun up goroutines as fast as it could read messages. I would have suspected that it probably also suffered from potentially losing some data on crash because it sets does MarkOffset before it's finished processing the message. At least, I would have suspected that in the case of any issues with submission to Cassandra, you could end up in a non-optimal situation with trying to replay the messages and spinning up more and more goroutines.
Put them in separate packages? Comment out the parts of `bar.go` that were broken by the changes to `foo.go`?
I prefer `urfave/cli` because no code generation is involved.
Nothing critical and did notice this whilst reading the slides - but thank you for the heads up! 
Knowledge about C is certainly not a prerequisite or at all necessary to learning Go. If anything, the opposite is probably more applicable. C is a more complex language than Go, and as such learning Go first would stand you in good stead for learning C. Particularly concepts like pointers, for example. Unless you like diving in at the deep end, of course. Learning C first world indeed make Go seem like a simplistic but powerful language, and you would better understand the reasons why it (and other managed languages like Java and C#) do things the way they do, such as memory management/garbage collection. So it depends on your focus.
If it helps, my JWT authentication library is [on Github](https://github.com/lpar/jwtauth).
Add something like // +build imready To the top of the file you want to hide (it's a build tag). It will no longer be included. Now you can pass in a build tag when you're ready to start including that file, or just remove the line.
You're thinking of it like a http request, but it's not. Have one websocket url that everyone connects to, but when they connect they are in a "lobby" on the server. Then the server sends them a list of rooms, and the client says "connect me to room X". On the server you just say something like `rooms[X].Add(client)`, then the room will start handling the websocket messages instead of the lobby. The room should first send a message to say "I've accepted you", then start sending chats from that room. If someone says something in that room, loop through the other clients in the room and send the message to them.
This sounds like an incredibly bad and unsafe thing to do. I would recommend not doing this at all. There are probably astronomically few situations where this is more useful than a safer, less brittle and more readable and clear solution. 
For us who write perfect code, go-hang-yourself is a huge relief. It wraps an unconditional for-loop around ever statement in you program, so we too can feel the frustration of programs not working properly.
This is pretty much the issue which has kept me from adopting golang. I found this a while ago which purports to be a better error handling method than frequent error code checks: https://davidnix.io/post/error-handling-in-go/ I've not yet had a chance to digest this but I have a a co-worker who I call "Go Pope" because he's somewhat religious about the tech and he seemed impressed with the above although it was new to him. 
To be fair, I believe that spf13/cobra provides code generation as a convenience not a requirement.
The error handling will grow on you. Lack of generics not so much :(
Don't create the regex every time... var preCompiled = regexp.MustCompile(`\A\d{4}(-\d{2}){2}$`) ... validation.Match(preCompiled).Error("Invalid datetime supplied")). ...
I currently use it for the background process / daemon for my chat bot. It sits between the IRC server and my PHP backend and takes care of holding the connection to the server and handling the protocol.
have you ever felt limited by not having access to some of the third party libraries that python has? That is my concern right now as that is a big thing that I enjoy about python. For example, using pandas and matplotlib.
I like [meep](https://github.com/polydawn/meep) for slightly more expressive `error` at least.
I switched from cli to cobra, after a couple of months of dealing with some minor annoyances in cli (one of which - inability to return errors from subcommands - has since been fixed in HEAD). It took very little time to port from one to the other. They're similar in style, though cli is a bit more of an opinionated framework while cobra is marginally more of a toolbox. They're both pretty good. Having now used both, for the same target app, I'm probably going to stick with cobra in the future.
For a project I am working on, I did this: User auths into app, JWT is created, create a session using Gorilla toolkit (securecookie/sessions), store the token value as part of the session. In addition, on every request, I check the header for Authorization Bearer with the token. If you are using a framework like angular on the frontend, you can store the token in sessionStorage and do an http intercept, read the session storage, grab the token and update the headers before the http request goes out. Then on the backend, validate the token via headers. If the cookie exists, I just read the session in the backend, grab the token value, validate it with the jwt library, and redirect. I'm not sure if the cookie thing or how I implemented is bad practice but I had to take this route in the interest of time and frustration (im dealing with a different scenario for auth but i need jwt and cookies/session). The echo framework has JWT receipes that works pretty well. You create unprotected routes for auth, use the JWT middleware, create the token, create protected routes and then just read the context to grab the payload (you don't even need to decode/validate...the framework's middleware seems to handle it, you just have to handle the possible error for grabbing the payload...aka it doesn't exist). 
Thanks I'll take a look
panic(err)
I'm using Go to power backends for web apps and mobile apps. Additionally I develop cross platform SDK's (iOS/Android) with the help of go mobile.
I've encountered these kinds of issues with interfaces too. Nothing is (unfortunately) _the_ solution. For example, I've seen some software use `String()` for non `fmt.Stringer` type things. Making them usable in `fmt.Stringer` places yet with `String` implementations not intended for `fmt.Stringer` places. I try to avoid this if I can, but with implicit interface implementation you can't always know every interface you're potentially implementing. (I mean, tooling wise you could, but I don't know of a tool that does this kind of thing, plus tools can't really determine intent of the implementation vs. intent of yours).
Is there a reliable docker container for Kafka? 
Thank you very much for that straight forward explanation! I think I understand the approach now.
Generics?
It may be obvious, but a lot of time can be saved by writing functions that can't return errors, AKA properly compartmenting code bits to keep error-possible regions excluded from functions that just work.
I work on a basic "RESTful/CRUD" kind of app and the backend is written in go with some microservices to use libraries that are not feasible to port. I've really enjoyed the static types, explicit error handling, and simplicity of the syntax. It has been very productive. That said, I do not use it for scripting. My go-to language for a quick job (e.g. convert a file from one basic format to another basic format) is python. Nothing beats loop comprehensions for me.
That sounds odd. As far as I know this is the idiomatic way to do it. The compiler will warn you if the type changes and the conversion is not possible anymore. It looks quite safe to me. Also I don't see how this is more brittle than passing arguments around one by one. It should be the same in practice. If you change one argument, the program won't compile anymore. As for readability, I can see your point but then again conversions are part of the language. We often have to do type assertions (which have a similar syntax) and conversions. They are every day life with Go. Finally, if this wasn't supposed to be used, I don't think the Go team would bother making the feature even easier to use in Go 1.8. Edit: By the way, I am not saying that this should be spread all over the codebase just because it is possible. This feature is to be used when you have for example the same type coming from your gRPC endpoint and you want to convert it to your normal domain struct with the exact same fields. The gRPC version is only used to get the data inside that's it.
I'm literally using it for everything, but I tend to do front-end work with Vue.js if I can. Also Angular (but prefer Vue). - I'm so much into APIs I wrote a book [API Foundations in Go](https://leanpub.com/api-foundations) - I'm developing 12FA apps with Docker and Go, and [writing a book about that too](https://leanpub.com/12fa-docker-golang) - Started a side-project service which collects some states/metrics for badges (CI metrics) - https://isiton.info/ (DM me if interested) - I write stuff about IoT on my blog (https://scene-si.org), so far I'm tinkering with RPi3 and 8ch+4ch relays, and I got a Novation Mini to output something like 80 LED lights and maybe trigger CI builds from it, - Wrote some fucked up "javascript" playground for webhook automation (ie, github/bitbucket - https://hooks.cdn.si) - the idea is to have smart scripts that can trigger IoT things (relays, lights, webhooks, etc.), a-la IFTTT - Playing with a remote-shell go program that would relay an active session terminal via MITM website for things like remote support without giving out bunches of credentials or opening firewalls (like ngrok, but only for terminals, using xterm.js+websockets, think something like teamviewer) - Wrote a whole deployment system in go for a client (still writing actually) - used PHP with stdlib cgi package which I thought was a nice hack to import a set of existing APIs, - Wrote a discord chat bot which spews out exceptions from a backing service Errbit instance, - Wrote a crontab like project which uses go-cron as the scheduling back-end, but can run and log metrics like time elapsed for 100+ scripts and has some features like run-once and a nice web interface (logs, statistics) - Wrote an integration with Wowza Media Server that allows scheduling of virtual streams (VOD files that show up as live streams at some schedule) which is used for some top-tier global clients (via Yaremedia LLC) There are lots of great community projects like imaginary that serve various needs which I honestly prefer to handle in Go. Every time I pick up Node I cringe. And I'm still doing a lot of PHP. And I'm taking freelance work when I can, I really love solving other peoples problems in the DevOps area where senior experience is welcome. I had a second-round interview at Tumblr just before Yahoo bought them - being rejected was probably the best thing that could happen to me at that time, because it really opened my eyes as to what it takes to run thousands of servers vs. managing a few 100 without ever running consul or chef or ansible or whatever :) I'm very much DIY, and unless it's front-end work or shell scripting (I have become somewhat of a bash aficionado) I just love Go.
In order to improve error handling you need to start thinking of the [errors as values](https://blog.golang.org/errors-are-values) and start programming with them.
But you can't always know which specific errors a function will return, which can limit your options for dealing with them.
The only real place I miss generics is custom containers. It would be nice to have but interfaces does the job just fine in the vast majority of cases. Some might argue that the dynamic dispatch would be avoided with generics, but if you are that performance sensitive maybe go isn't the right language for the job.
Spf13 only recently joined Google. His libraries were popular well before that. 
I just picked up Go a week or two ago, and I've already got a web app, a rest api, a matchmaking server for my game engine which does not have any multiplayer yet... I've kinda gotten carried away. I really like Go so far.
At work: 1)built a web server for calling campaigns that used twilio to dial out several numbers at the same time...stuff for marketers. It would also send out sms messages and email out pdf pamphlets upon request all through go and third-party go libraries. If I were to rewrite this I would consider caddy as a framework to start with. 2)built a microserver that would help configure an appliance to company spec via web browser and rest api. It would also speak with lcd panel hardware via open-source lcdproc. If I were to rewrite this I would consider caddy and grpc as frameworks to start with. 3)most recently a company needed to optimize certain steps in their workflow which were written using bash scripts. I converted some to golang to help speed up the steps. I also have certain aspects parallelized to speed it up even more which take advantage of every cpu core and ounce of network bandwidth they have at their disposal. 4)built a prototype gui using github.com/therecipe/qt to potential replace another gui built with another language and gui framework. The results are fruitful and promising especially on windows/msys2 and linux/archlinux. Oddly enough the binaries can then be brought over to other versions of windows and other versions of linux provided you bring over the entire deploy directory with associated dll's/so's. I would recommend it over any other gui framework for golang. If you value your time, it is worth learning it before other languages. It may not have a uml notation support. It may not have one recommended integrated development environment, but that is a strength. It is a set of command line tools that can run on any os/hardware, but favors intel to build and cross-compile with. 
How could something like this have happened? &gt; [Version **4.7**](http://blog.labix.org/readme.html) &gt; [The REST API is enabled by default on all sites using WordPress **4.7.0** or 4.7.1. If your website is on these versions of WordPress then it is currently vulnerable to this bug.](https://blog.sucuri.net/2017/02/content-injection-vulnerability-wordpress-rest-api.html) Oh.
Kind of off topic, but are there really no good options aside from [mow.cli](https://github.com/jawher/mow.cli) if you want argument validation in Go? I've been wanting to port a cli tool from Python to Go, but all of the cli packages leave a lot to be desired in that respect.
spf13 wrote those packages well before he joined Google. And for what it's worth, spf13 isn't the primary maintainer of cobra. I've used cobra. It's good. It has some oddities, but overall it's good. It's more polished than urfave/cli, but urfave's library is also quite nice. Disclaimer: I now work with spf13 at Google.
How do you use it?
Hi! Thanks for that wonderful library. I found the readme pretty exhaustive, but I didn't find the answer for that question: is it already production ready?
I wrote several PaaS solutions, but I'd use Go for everything. In general: * distributed systems * cuncurrent architectures * microservices using RPC or Rest communication * command line utilities * Virtualization / Containerization/ Linux Appliance software 
It depends - my general advice would be - familiarize yourself with Go. This will give you basic understanding about pointers, heap and stack, networking and so on. You can then dive even further and explore Go assembly and tricks with unsafe, which you should do only if you absolutely sure. Learning C is good advice for any general software developer if you do not want to treat your hardware as a magic box. It will give you some really good insights about internals, which could be useful for you on your day to day development. But if you are coming from high levels languages it may become really tricky at first, and tooling is... well it's work in progress. Also prepare to shoot yourself in the foot. A lot. It's good because you learning but can be/will be frustrating. So - to repeat myself - start with Go. And then, if you really sure about going "low level" or just want to increase your overall competence - learn C. Go will expose you to the many aspects while protecting you from long list of headaches. It is likely you will meet C code in your used libraries (sqlite for example) in form of CGO. You don't, however need to read it and understand it at this point. 
No.
Thank you!
This is actually not a right conclusion imho. Use the right tool for the right job. What makes you more productive ? Using your editor daily or some obscure combination of sed/grep/awk ? It would actually take you longer to think about how to do it in the tools mentioned above. Just master your editor for text manipulation. This is what IT people do everyday. Manipulate text. You can be more proficient in your editor than you will ever be by mastering these sed/grep/awk because you actually use your editor every day! 
Does not seem to work with Vim 8. :-( * The AGIF screencast features NeoVim * The source contains a commented region with the remark, "does not work with Vim 8." * After setting a breakpoint and calling :GoDebug, I get this error message: Error detected while processing function godebug#debug[19]..go#jobcontrol#Spawn[4]..&lt;SNR&gt;142_spawn: line 49: E117: Unknown function: jobstart E15: Invalid expression: jobstart(argv, job) (Apparently this happens because the "Does not work with Vim 8" part of the code is commented out, and the flow enters the NeoVim branch unconditionally.) The author asks for bug fixes via PR only, but I am not a Vimscript coder. Anyone got an idea how to fix this?
You don't need to, the package name is used, not the import path, so I usually use something like useractions for the pkg name, and all is good. This is the only place the handlers are imported also (to assign to routes), so I wouldn't really mind if I had to name imports, but it's not necessary. 
/u/ChristophBerger Hi, I'm the author. Try to have a look at this: https://github.com/fatih/vim-go/blob/master/autoload/go/cmd.vim#L230-L317 It's where I took the inspiration and the implementation details for the vim-godebug plugin. That handles Vim and NeoVim.
Yeah! I'm using Nano for now with great results. Git might be good, but I'm generating some images from my code and it's a pain to copy them to shared space before I can see them in my mobile. Thanks for the help!
Checked exceptions and union types let you know what errors are possible, but come with other weaknesses, specifically brittleness. 
well I related to embedded types. They are kind of inheritance. Depends oh how you would define inheritance. I am glad it's not a very popular feature in Go ;) I also didn't say that the code above is inheritance.
&gt; That sounds odd. As far as I know this is the idiomatic way to do it. The compiler will warn you if the type changes and the conversion is not possible anymore. It looks quite safe to me. Indeed. The non-safe is version is `unsafe.Pointer`, which should definitely be avoided if you can just convert directly.
If I'm honest, the biggest challenge for me recently is getting used to `jq`. It's a brave new world out there.
I hope Go stays as simple as it is. It has all that is needed. What would you consider an improvement ? There are design patterns that can be used to make the code simpler an more readable. I also use "github.com/pkg/errors" which is handy when I need a stack trace. I must still play with it to find the best way to use it. 
What's more important is to don't forget to test an error. It's too easy to forget. I user errcheck for that. 
Depends on your job :p. I use awk daily and sed pretty often, and often call out from my editor to one of those tools. E.g. `sed -i 's/—/-/g' *.txt`. `-i` means in place, `s` means substitute, `g` means global. You could also do it even easier with `tr`. `xargs` is pretty easy to understand, it reads from standard input and then puts each word as an argument to the command you specify. 
Well I try to do everything inside emacs.
I haven't implemented or benchmarked redezvous hashing. My understanding is that it tends to be slower due to needing to hash the key once for each node (although multi-probe consistent hashing has the same issue.) edit: The multi-probe consistent hashing paper doesn't mention rendezvous hashing at all, although the Jump hash paper does. edit2: I have some benchmarks for sharding algorithms at https://github.com/dgryski/go-shardedkv/tree/master/choosers. It wouldn't be hard to add rendezvous hashing and see how it fares. edit3: rendezvous hashing, or at least this implementation of it, is *slow*: https://gist.github.com/dgryski/cff922f5ed8ff6c2b4907c38a1b2f8c0 Edit4: multi-probe consistent hashing uses a speedup to simulate multiple hash functions from just two: https://github.com/dgryski/go-mpchash/commit/8184d090d8449c04aa2b7fbaec50046f53a54181 . The "Less Hashing Same Performance" paper is not directly applicable to rendezvous hashing as the hash function needs to also depend on the node name, but I think the hashing in the implementation I used could be sped up.
Treafik is such an amazing project, it has been running in production for a few months now and every developer that uses it is super happy every time something "just works". Great project and great release!
I found this little library while developing GRPC to FastCGI proxy. The grpc authors didn't include a way to provide custom context for canceling server transport. So - I had to improvise. Luckily somebody already faced something similar in their development, so my life was made a little easier. Basically, I'm creating transport like this: config := &amp;transport.ServerConfig{ MaxStreams: 100, InTapHandle: func(handleCtx context.Context, info *tap.Info) (context.Context, error) { handleCtx, _ = joincontext.Join(parentCtx, handleCtx) return handleCtx, nil }, } and it will cancel either on incoming handleCtx cancellation or on mine parentCtx during application shutdown.
Yep. It's that good.
The syntax is not the problem, and there have been several suggestions already. See https://docs.google.com/document/d/1vrAy9gMpMoS3uaVphB32uVXX4pi-HnNjkMEgyAHX4N4/edit#
I use it at work to build an event processor and micro services orchestration system. It listens to a bunch of SQS queues, and react to messages put on those queues. Some messages are supposed to be routes to other services, some to external ones, some consumed right there in Go code. It has greatly simplified implementation of individual services as they don't know about each other for the most part. They just emit business events and this Go service knows what do with which event. Also using it as a bare bones S3 replacement that serves static sites but protected with JWT authentication. Used in another place as a mock authentication service that engineers use locally to in development. This way they don't have to spin up a full fledged authentication system just to work on their projects. I just ship 2MB binaries for different architectures.
HTTPS https://gist.github.com/denji/12b3a568f092ab951456
Go - wss (https websockets) - mitm server - wss (...) - web client. The traffic on the server can be intercepted in plain text if there's not an additional layer of encryption which only go/web client can crypt/decrypt. What is needed is some additional layer of encryption on the websocket payloads which the server can pass along but not decode. The obvious issue is that it requires two secrets that the server should not be aware of...
Go's http server supports WSS, which will be encrypted. I don't see the problem here do you mean that Go is not running the HTTP server?
It is go. But all the data which is passed along secure websockets would be available here. The time between reading from one wss and writing the payload to the other wss is the issue as sensitive data could be intercepted there. An additional level of encryption is needed so the data on the http server is useless without some private key (end to end encryption)
Kubernetes doesn't surprise me - a lot of the kubernetes components end up importing (parts of) kubernetes. I didn't see (or missed) where the post author tells how he got the data, so I can't check my hypothesis that kubernetes is higher than it "should" be. (Not that kubernetes isn't popular, mind you)
Yes, a TCP proxy (not HTTPS/WSS proxy) is what you need... HAProxy does that (and more)... May I ask "Why the proxy ?" Also, make sure to only use strong ciphers and key exchange... Forward secrecy is a probably a must because of the proxy.
Check out Jennifer (and specifically the genjen package that generates very similar boilerplate code): https://www.reddit.com/r/golang/comments/5rf1no/jennifer_is_a_code_generator_for_go/
You might get a bit more following if people could browse the code online. Something like GitHub may be preferred, but even turning git web on for https://git.lsub.org/clive might help get eyes and feedback.
Super cool deep-dive.
Can anyone tell if this occurs in real programs or just hello world programs?
As long as you care about the speed of a program that does absolutely nothing.
Before reacting to the title of this post, keep in mind that the 20% slowdown is in the "Hello World" web server benchmark. We need to confirm if there's any slowdown at all in long-running, real scenarios before freaking out about the 20% number. For example, what if this is related to the new graceful shutdown logic, in which case the slowdown is not very relevant at all to almost all real life scenarios? **Edit** Looks like it's a constant per request time slowdown (around 0.5µs, that is 0.0005 milliseconds), not a percentage. This means that as the CPU time of a request handler increases, the percentage goes down by a lot. It also seems the issue causing this is unrelated to the graceful shutdown logic, and instead with some cleanup of HTTP/1 context use. I'm not sure if this slowdown applies to HTTP/2 requests.
We also need the results to be reproducible by somebody else.
That's a good argument, but JavaScript also has Promise and what not. It's just another pattern that is more declarative than channels and goroutines.
Do you know about the minimum machine spec (CPU + RAM) for running Kafka? I have gotten so used to running Go services, I have barely ever had to touch the JVM.
&gt; It would be nice to have but interfaces does the job just fine in the vast majority of cases. Nice, can you explain how exactly I can write my own compile time safe container types like a tree with interfaces?
It does look like there is progress being made and at east one person discovered that it may be related to the shutdown logic. Not sure if it will be fixed before 1.8 is released or if it matters much, but at least it's being worked on.
When I starting programming in Go, First I built the universe.
More information has been added to the thread now, but the point was without investigation one of the core team members said it was too late to fix and that the guy should wait until 1.9, 6 months away... without even knowing the full impact.
why not return (uint64, error)?
I really like the name, actually.
An advantage of this proposal is the syntax looks clean.
What problems generics will create? It is abviously that lacking of generics is more a big problem. Go is a language full of tradeoffs. 
A point that is often forgotten. Increased language complexity, compiler slowdown (just to name two problems) need to be dealt with to make generics a useful enhancement.
[removed]
A collection of other subsets is [here](https://appliedgo.net/generics) (an old blog post of mine). 
What does "MITM" mean in this context? Usually, "MITM" == "Man In The Middle" == evil attacker. When replacing "MITM" by "proxy server", the question makes more sense to me. Am I on the right track? If so, then what if the proxy server works at TCP level? It could then forward any WSS data without de- and encrypting the WSS stream. EDIT: Just noticed that /u/TinyBirdperson and /u/chrisdefourire came to the same conclusion 8 hours earlier but a few thread levels deeper.
&gt; Increased language complexity, Not always true for a good generic design. &gt; compiler slowdown false for most generic implementations. 
obviously, none of the **instead** solutions satisfy all of these reqirements: * efficient * clean * extensible * easy managed 
&gt; @codido, thanks for the bisect! Yes, and that's the commit I would suspect too. Good to see confirmation. That was one of the biggest architectural changes in the net/http.Server in quite some time. &gt; **I never did any benchmarking (or optimizations) after that change.** &gt; We can look into it for Go 1.9. amazing
Yeah, I've not once encountered a problem where I've thought "oh damn, I need a test framework here." The stdlib has a very robust testing library. It's intuitive, simple and has everything you need. 
&gt; What problems generics will create? Deep Type Hierarchies, in-transparent code, bloated frameworks, subversion of static analysis… Generics encourage a programming style that I find deeply frustrating and the opposite of what I like about go.
To you perhaps.
There's not a lot of point in having a release cycle unless you're going to stick to it. 1.8 has already been through three RCs, so hopefully it's fairly stable. Say a fix for this bug was rushed out, either you then have to rush the release (which means minimal testing and, in the long term, buggy releases) or you have to delay the release and issue some new RCs (eats in to 1.9 dev time, puts extra burden on people testing out RCs). Regarding my 'hopefully it's fairly stable' comment, the RCs are used internally at google so my suspicion is that this bug is not as serious as initial reports suggest. I would have thought someone at google would have noticed if all their go http servers had a 20% perf drop when they switched to 1.8 Overall, a considered response such as Brad's gives me a lot more confidence than a panicked 'WE NEED TO FIX THIS!!!!' late in the cycle.
You could argue that if the RCs have been used for a month and the issue has only just cropped up, then perhaps it's not a deal breaker.
But it definitely is. How will I tell my boss now that I can't work on my Hello World micro-service using Go now?
&gt; Fortunately, real production workloads might be a lot better in 1.8 "Might be"... Regardless - it doesn't excuse making major changes and doing zero benchmarking. 
This is great! I agree 100% with the premise that you should't be doing this in struct tags, this is much more sane, definitely going to give it a shot on a project I'm building currently!
A question out of genuine interest: What is your favourite language that features generics?
Besides the ones already mentioned in others comments, I could cite code bloat, poor error messages, and debugging nightmare.
yes, numeric lib, data struct and algorithm lib would be the main scenarios (about 60% generic use cases) for generic, and this is really a pain, a big pain, in Go now. Call them a niche is not reasonable.
&gt; Deep Type Hierarchies could you elaborate more. &gt; in-transparent code a bit, not much &gt; bloated frameworks r u kidding? The main goal of generic is just to avoid bloating. &gt; subversion of static analysis not a bad thing. &gt; Generics encourage a programming style that I find deeply frustrating and the opposite of what I like about go. even generic supported in Go, you still can select not to use it. 
I'm sorry, I don't agree with you on every points you mentioned. It depends on how well the compiler is implemented.
&gt; a bit, not much In my experience, this is simply not true. All of Java, C++ and Python (the main languages I worked with in the past) are notorious for that. &gt; r u kidding? The main goal of generic is just to avoid bloating. I disagree and if it is, in my experience, it catastrophically fails that goal. Pretty much every motivational example out there for the need of generics is "say I want to write $framework that hides a lot of code from users". A thing generics try to prevent is code duplication. I also don't really believe that *that* works in any meaningful way and the way it *does*, is by instead encouraging writing frameworks. &gt; not a bad thing. It is fine, if that is your opinion. Other people will feel differently, though. I sure do, strongly. &gt; even generic supported in Go, you still can select not to use it. Only by selecting to not use any code that uses them. The nice thing about go is, that most code out there has a similar base-line in terms of cleanliness. I can dig in and read/debug any code I use, because it doesn't get lost in frameworks and special snowflake ways of doing things (mostly). The "you don't have to use it, if you don't want to" is a non-argument, because it ignores the fact that what I'm concerned about is how *other* people are going to use it.
Because it is a problem much, much bigger than syntax. I recommend you read the document. At the end, it summarizes why generic syntax discussions are frowned upon: &gt;The discussion about which syntax to use is omitted at this moment. Which exact syntax to use adds little value to the main problem of which generics approach to use. This problem can also introduce a lot of unnecessary bike-shedding. The discussion of this subject is suspended until other sections have sufficient quality.
 $ go test -bench . import-path-of-the-model-package or, to run all tests and benchmarks under cwd $ go test -bench . ./... If it's possible to filter the model benchmarks by a regexp $ go test -bench Model ./... # for example 
First line of my comment: &gt; The only real place I miss generics is custom containers. And you are asking me to implement a generic container using interfaces, the exact scenario where I said I miss generics? If I were to write a container that would be used for many different types I would go down the generation route, something like this stack for example: LinkedList.gen: package container type &lt;T&gt;List struct { head *&lt;T&gt;node } type &lt;T&gt;node struct { next *&lt;T&gt;node value &lt;T&gt; } func (l* &lt;T&gt;List) Push(v &lt;T&gt;) { l.head = &amp;&lt;T&gt;node{next: l.head, value:v} } func (l* &lt;T&gt;List) Pop() &lt;T&gt; { var v &lt;T&gt; if l.head != nil { v = l.head.value l.head = l.head.next } return v } that could be generated with something like sed 's/&lt;T&gt;/string/g' LinkedList.gen &gt; stringLinkedList.go I've even used something like this in C++ code that has generics through the template system due to being forced to put the templated code in the header files and their associated slow compilation speed. Maybe I write a go wrapper called gog one day. It could scan the go code, do the substitutions before calling go to build the package. After compilation it could restore the template code. That would be indistinguishable from how C++ does it's templates, and while It's not pure go, from the programmers perspective would effectively have generics. As I said, generics in the language would be nice, but it's not strictly needed. If/when they arrive, I hope they managed keep them simple to understand, like the language so far.
I used MITM for lack of a better word. It's a server that stands between a Go service, and a web browser client, by design however and not some malicious intent :). It's purpose is to resolve some firewall requirements.
I intentionally did not say anything about that proposal, but only replied to the notion that generics create no problems or are that their lack "obviously" outweighs any problems they create.
But why?
:-)
It increases request-processing overhead from around 100 to 120 microseconds, so it's almost completely unlikely to have any effect on real programs, as most application logic will take much longer than 120 microseconds per request.
I wrote a paper on this area a few years back, which MBOI. https://arxiv.org/abs/1503.04988
Very cool!
I've read most of your articles and really enjoy them. I've even got a bookmark to the generics post in my Go folder from when it was first posted. Thanks! I use Gen, your last option, as my generics pain reliever. I don't consider interfaces to be suitable for most situations because Go functions based on interfaces can't return a type. They can only invoke behaviors on types. Interfaces cover a number of situations but not even a majority. In addition, coding generics though interfaces is way more (human) memory intensive and verbose than coding via generics. Coercion of any sort is the opposite of generics so, while useful at times, is not really a good substitute. And I rule out coercion by reflection immediately as I don't want to kick the can down to the runtime and the users. Most every language now has a page showing off their implementation of C#'s 101 LINQ Samples (lambda version, not SQL version). Elixir's is a thing of beauty outdoing even C# itself: (https://github.com/omnibs/elixir-linq-examples). Even Dart's (https://github.com/mythz/dart-linq-examples) is at least as pleasant as C#. Go's best attempt (http://ahmetalpbalkan.github.io/go-linq/) is awkward and uses run-time reflection to achieve what it does. It shows that while you can work around generics you probably shouldn't. I hold 101 LINQ Samples up as an example of the best of generics. It's probably what I miss most when coding Go. (I'm aware many Gophers hold LINQ up as a reason not to have generics. They are wrong ;-) Next, I'd like to go over the often quoted, "The generic dilemma is this: do you want slow programmers, slow compilers and bloated binaries, or slow execution times?" This has been answered many times by all but the devout: **slower compiles!** We(*1) want the path from brain to code to be unencumbered and as fast as possible. Compile speed is a bit of a red herring: it hasn't proven to be a problem in languages that have included generics. But even if there is a 5% hit it's worth it. Remember, your computer is going to get faster with each passing year but your brain is going to get slower. Bloated binaries are also not an issue. Nothing is going to be slower than copy and paste for each type. So even if the compiler does that under the hood then it's no worse than explicit copy and paste. And execution times will likely decrease as no more coercion. Finally, if I'm always sitting back and figuring out if I really need generics or how to reframe things so I don't need generics then I'm wasting valuable time and headspace that I could have avoided simply by using generics in the first place. We have generics as a tool available in our conceptual hardware store, now we(*1) need it in our Go toolbox. *(1) For a subset of "we" that does not include those who are now thinking, "who's this we.")*
When it first came out ... or more so the discussions that lead to this document, cynical me said the intent was to shut people up. I read the intent as, "we don't want your thoughts, we want your implementation. If you don't have an implementation, and one that solves all our paradoxical requirements, then don't bring it up." Lately, that mind set seems to be softening a bit.
Hey, what about all those Hello World startups? Returning &lt;body&gt;&lt;html&gt;Hello World&lt;/body&gt;&lt;/html&gt; is totally legit for them.
which paradoxical requirements the proposal can't solve? what does "have an implementation" mean? Fork the go project and built the generic in? btw, I don't agree on the most opinions in the Problems section of that document. 
 Yes, generics makes compiler much slower is the biggest lie to reject generics. 
I'd say this is valid. The [text/template package's lexer](https://golang.org/src/text/template/parse/lex.go#L146) does much the same, emitting a token via a channel to the parser as it reads them.
Most of your article is not readable on mobile. The font weight is too light.
Obviously I misread your intent. Sorry about that. I'm firmly in the camp that thinks Go should have generics. I agree with you 100%. I think the only thing holding them back at this point are stoical beliefs.
I think that article is incomplete without section "Custom Context types: Pro&amp;Contra". 
We did have a similar problem once and I wrote a blog post on it here: https://medium.com/@tikiatua/symmetric-and-asymmetric-encryption-with-javascript-and-go-240043e56daf#.ddkj9ia03
I'm interested primarily in restful apis. The architecture would be slightly different I suppose because there is no view/UI layer. I presume you could replace the view with the routes with an Api. Im just not 100%. I guess the data and domain would remain relatively similar&gt; what you're looking for, but I'm very happy with and proud of the architecture of my personal site [0], 
Putting "performant" in the title implied to me that it was going to be about performance, but it went all the way from installation to writing json endpoints without really covering anything that. I was expecting to see something on Cassandra table design and some sort of performance requirement or improvement being addressed with numbers.
It is an adjusted c++ template, see the demo for details.
slow compilation can be solved by caching. increase complexity, yes, generic will increase complexity, but just a little. surely, I don't agree on the con-generic.
I remember reading this paper. Do you have Go source code for this?
yeah, I'd love that :)
that's exactly why I posted the question. I was mostly just using it as a replacement for generators for now. I've picked this problem as my first go program because I thought it was a good use case for goroutines
https://play.golang.org/p/QnU1zOZrHJ
You don't need assertions! Just use == and for loops. All these assert libs cast your vars to interface{}, then use reflection to find their concrete type, then make the comparison. Sad! :)
I am trying to push Go at CNRS/IN2P3 (and in High Energy Physics in general). it's slowly starting to click. will you be at the next JDEV (journees des developpeurs)? it would be great to start a french (scientific Go) connection :) BTW, what kind of use would you surmise in CNES? monitoring? slow control of some detector apparatus? data analyses?
Fair enough. There is a somewhat RESTful API component, see https://github.com/shurcooL/home/search?q=api. However, the underlying HTTP implementation is both temporary and an unimportant implementation details, because all my clients/consumers are using the Go client. I can update both the handler and client library at the same time, and while the HTTP API changes, all end consumers are unaffected.
&gt; I want to be able to write function that takes slice of generic type X that satisfies some property, and return slice of that type. Exactly my point.
Online data processing and monitoring.
Code generation works for Push and Pop methods, it obviously doesn't work at all with a list having a Map or Reduce method : func(l List&lt;T&gt;) Map(func(element &lt;T&gt;,index int)&lt;V&gt;)List&lt;V&gt;{ ... } func(l List&lt;T&gt;) Reduce(func(result &lt;V&gt;,element &lt;T&gt;)&lt;V&gt;,first &lt;V&gt;)&lt;V&gt;{...} My point is these kinds of work arounds fail short in practice. Your template wouldn't work with multiple types. it would off course be possible to create a Go++ for Go, that's how C++ started and history might repeat itself and we'll have yet another war between purists and those who want more modern features.
I mention this in the conclusion and explain why they aren't covered yet. I intend to eventually cover them in their own post and link to it from this one.
Thanks! file + test = filet! :D 
Distributed data processing github.com/chrislusf/gleam 
Dynamic field names and self-referential methods feel dirty to me.
ListObjectsPages returns an error object. I'm not really sure how I'm supposed to pass that back, since it's being called in a goroutine. I had started by adding a second error return value to ListS3, but that doesn't make sense, because that only returns the channel, which happens immediately. Should I return the err through the channel? Do you have any examples code for this?
I don't want to be *that* guy, but [this](https://www.reddit.com/r/golang/comments/5rov00/bit_hacking_with_go/) was posted a few days ago
+1 but it still uses too much reflection. The API should be something like the logger of uber-go/zap, just type safe.
&gt; major bugs in released software Which is not what is happening here: minor "issue", not a bug at all.
&gt; slow compilation can be solved by caching. No, it can't. Compilation is the process of producing an artifact from sourcecode, you can not speed that up by caching the artifact after production. The compile process *itself* should be fast, so that edit/compile/test loops have quick turnaround (and also, to a lesser extent, hermetic fresh builds, e.g. in CI, are quick). And if you believe that requirement is overblown, then I suggest reading the repeated threads on reddit and golang-nuts where people complain about the speed of the compiler. &gt; increase complexity, yes, generic will increase complexity, but just a little. Your specific proposal adds a *ton* of new syntax, keywords and extensions to the type system unrelated to the pure problem of adding polymorphism (for example, you use things like `*array` or `numeric`, which currently have no representations in the spec, requiring new language). Yes, in parts that's because you are talking about syntax, instead of ~~documentation~~ implementation/concepts, but they are also omitted details where you just write down something with the assumption of a common understanding what it means, thus hiding all the complexity of what your proposal is *actually* entailing. And re GP: &gt; what does "have an implementation" mean? Fork the go project and built the generic in? That would be one way. A potentially simpler way might be, to write a wrapper, which reads in your flavor of generics-syntax, spits out go code into a temporary directory and then runs the go tool/compiler on that. This has the advantage that it could be done out-of-tree.
&gt; This has been answered many times by all but the devout: slower compiles! Tell that to the hordes who cried bloody murder when compile time went up in Go 1.5.
&gt; scientific Can you cite a source for that? My friends in this area cite as reasons why they couldn't adopt go facts like that it's statically compiled and they can't afford the extra resources to hold several dozens megs of binary in RAM, the general lack of control over heap sizes and allocation patterns or its performance. &gt; game Most people I read about in this sector refute the suitability of go because it is garbage collected and they believe that the pauses lead to frame drops. They also forego most of the higher-level features of C++, FWIW, because virtual methods and the like add too much of a performance penalty. Then there's also the more "casual" sector (e.g. pygame and Löve and the like), which has zero use for generics anyway. &gt; big data I don't believe this claim holds up either. I can tell you that there is a map-reduce implementation in go without any use of generics and even something like Flume would be relatively simple to implement, from a pure API perspective. There is also at least one *big* data application internal to Google which is based on go (and uses only go as its API). I believe the reason go isn't even more widely used in this space is, because it's relatively young and there are already several established OSS tools available for this, so there isn't an immediate need to add a new one.
[removed]
[removed]
[removed]
[removed]
[removed]
[removed]
[removed]
Awesome, thanks!
Please ... not even close to the same thing.
Do you have evidence for that? Until someone actually puts in the (admittedly considerable) effort to create a proof-of-concept, it will be hard to accept any assertion that generics will or won't (significantly) slow down compilation or performance.
[removed]
Check out --- https://github.com/FourSigma/validate Let me know what you think. Uses the functional optional pattern. Still in beta.
I could point you to my books repo, for my [12 Factors of Go and Docker](https://leanpub.com/12fa-docker-golang) book which I'm currently writing: https://github.com/titpetric/books/tree/master/12fa-docker-golang/chapter7 It conforms and provides approaches in line with the https://12factor.net recommendations (listed in the readme). In terms of how I structure my APIs, I hope that I've chosen some kind of loosely coupled package structure. As such, currently I can register/unregister API endpoints with one-line call in main.go - and can copy some standard API implementation between various projects (api/health.go for a "portable" API example). I'm happy with it, but given a few refactoring sprints I suspect I could improve some things (mainly in regards to common/redis.go, functional options, etc.). I hope it helps, and I also welcome comments from Go gurus that might have a look at the code. Edit: linked the book which should in time provide a more broad viewpoint on 12 factor app development. It's already about 50 pages and growing.
&gt; improve some things (mainly in regards to common/redis.go, functional options, etc.). I hope it helps, and I also welcome comments from Go gurus that might have a look at the code. cool. this is all really useful info. cheers bro!
never heard of 12factor.net. ill check it out.
&gt; Python and Lua are both dynamically typed so generics are implicit. This is a non-argument. The interface between the engine and the game is well-defined and perfectly expressible in the current go type system. &gt; Would you cite a source for that? ;-) I coded games in them. They don't need (or, FWIW, use) generics.
It has been claimed that the lack of generics is *the* reason, go hasn't been adopted for games. I've argued why in one sector of the game industry go is being excluded for much stronger reasons (performance/GC) and why in another sector of the game industry it has zero influence. You asked for citations. [This](https://love2d.org/wiki/love) gives you an overview of the Löve API. If you can tell me, where, in any way, a potential go reimplementation would profit from (much less *need* or even use) generics over the current type system in go, I will gladly admit that they might be a contributing factor for go not being adopted in that sector of the industry. Otherwise I simply call BS on the claim that they are what is preventing go from being widely used for games.
Wow, glide seems just like what I would like to use. Thanks!
Never start a goroutine without a plan to end it. If something goes wrong while iterating, the goroutine will stay forever. That's a leak.
I understand that's the Go teams core position, but that doesn't mean it can't be disappointing to me (although in this case it doesn't really matter since it ended up being minor). :) (Although, I hope it'd be in 1.8.1 and not wait for 1.9) Thanks Andrew!
Love to hear that you enjoy the articles. That reminds me to push myself to write more frequently! Thanks for your detailed response. Indeed, I also favor code generation when it comes to creating generic-like functionality. The other options really are meant for the kind of problem that only *looks* like requiring generics but in fact are a good match for one of these options. I must admit I don't know the details of LINQ; I definitely will have a look at the 101 LINQ Samples. I totally understand your point on wasting human time (and brain energy) and how generics save you some of your time and energy. But this can certainly be said about almost any of the features that were added to languages like C++ or Java... and added.. and added... until they ended up as the feature monsters as we know them today. And one more point about human thinking time: You wrote that you spend a lot time trying to figure out how to reframe things so you don't need generics. Could this be partly caused by the fact that you have gotten so used to generics that thinking in non-generic terms became more difficult to you than it is to the folks who rarely or never use generics? 
From what I understand, it should work something like this: 1. Go client connects to Server over WSS, 2. Web client connects to Server over WSS, 3. Go and Web clients have their own private/public key, 4. Server facilitates exchange of public keys and handshake over the WSS channel, 5. Communication between Go/Web client is encrypted and results in what is called "perfect forward secrecy" Basically, the Server itself never has access to private keys used to encrypt and transmit data over the websocket channel, and since we're actually talking AES encryption (and not just payload signatures), it would take some serious processing power to decrypt any one session (let alone thousands of them). So, not so bad? :)
You should be using regular expressions to do that
 [You can't parse \[X\]HTML with regex. Because HTML can't be parsed by regex. Regex is not a tool that can be used to correctly parse HTML.](http://stackoverflow.com/questions/1732348/regex-match-open-tags-except-xhtml-self-contained-tags/1732454#1732454) 
Like other said you shouldn't parse HTML like that. Unlike others I'll provide you the correct way: https://godoc.org/golang.org/x/net/html#example-Parse
Why not just read the std. lib? https://golang.org/pkg/ There are links to the source on every method, type etc. It's not perfect, but it's generally held to a pretty high standard.
I love the noms source code. Great interfaces, solid tests. Well worth the time to read that codebase. And it's bigger than a std lib package, so it shows real-world Go usage rather than the limited subset you see in stdlib.
&gt; https://github.com/CaptainCodeman/clean-go thanks for the sample repo!
https://github.com/attic-labs/noms/tree/master/go is _okay_... the package layout is rather suspect, e.g. packages types, util, etc. And package d is full of antipatterns. But the code itself is pretty clean.
Indeed. I know it may superficially seem more complicated, but it's actually simpler, because the strings.Split based method is actively incorrect. Note in the link that the HTML string has `&lt;scrip&gt;` in it... no "t"! That strings.Split series is only coincidentally working as it is. But using the HTML parser directly for this can be a pain too. I suggest something like this: package main import ( "bytes" "fmt" "github.com/PuerkitoBio/goquery" ) func main() { sample := `test test test &lt;script&gt; {"stuff":"that I want to extract"} &lt;/script&gt; test &lt;script&gt;more stuff&lt;/script&gt; test` doc, _ := goquery.NewDocumentFromReader(bytes.NewBuffer([]byte(sample))) doc.Find("script").Each(func(i int, s *goquery.Selection) { fmt.Println("Extracting: &gt;", s.Text(), "&lt;") }) } Can't put a functional version of this on the playground since it involves github packages, but I'm sure you'll find it worth pulling in this dependency in this case. If you copy and paste the above into a file called `parse.go`, you should be able to run this with `go get github.com/PuerkitoBio/goquery; go run parse.go` . In this case, note I'm not doing anything about the whitespace around the "stuff" in the script tag; it's easy to either strings.Trim it, or if as your sample implies, this is JSON, simply feed it to the JSON parser, which is insensitive to whitespace at the beginning.
C was the first language that I have learnt for C UN*X programming. You can understand very well how computers work in this way and you can use this knowledge for any other programming language. Moving from C to python was a great pleasure, no need to worry about memory, no need to compile, portable and fast development compare to C. I moved from Python to nodejs because my company was only using this technology, nice, but just make things too complicated when you want good performances. But I could learn more about asynchronous programming (which is now amazing with python 3.5+). After a huge battle with my CTO, I have decided to rewrite all my code in Golang, and the result was just wonderful. Before, my colleagues were complaining that the nodejs API was crashing all the time and was too slow. after my rewrite in Go I got this feedback "I don't know what you have done with the backend but we didn't see any crash for 2 weeks, is it normal?" Going back to your question, learning C will make you understand how your system is working (if you write kernel modules for example) but keep in mind that even if C is fast, development and debugging with take you sh*t ton of time. With Go, you will have good performances and you can focus more on your product. Then, what's you use case with C or go? is it for a personal project or for your work?
That's absolutely false. Brad didn't run benchmarks. We run benchmarks that include HTTP servers as part of the release process, as do the people running release candidates. Real workloads don't exhibit a significant slowdown. Only microbenchmarks like this one do. Microbenchmarks are basically useless for a variety of reasons. Real systems are what matter.
Question, how do you like GO so far? We've been using Cassandra for years, but GO is still quite new for us.
Definitely don't look at Docker, lol.
https://github.com/hashicorp/memberlist/blob/master/memberlist.go#L198
Not really as an example of good code, but an example of a good API and good documentation outside the standard library, [andlabs/ui](https://godoc.org/github.com/andlabs/ui).
So basically you're adding a custom encryption layer on top of the WebSocket layer. I guess this requires custom crypto code at both ends. The only problem is that if "Web client" means "standard, off-the-shelf Web browser", your custom crypto code would have to be some JavaScript that needs to be downloaded from some trusted server over a trusted connection. But that's certainly a solvable problem. 
I'm still not arguing against the usefulness of generics in containers. I would like to have generic containers in go (that along with functions who's return value is the same type as its parameters, like min and max). I am showing that manual code generation, while it is not as elegant, can achieve the same result Thanks to you I read up on how generics are implemented in C# and Java, turns out they all do it differently and there are different levels of code generation in all of them. Simplest to understand is probably C++ templates, code for all district template parameters are statically generated. When the static code is compiled it will fail at the point where the type can't be used, which often is somewhere else to where it's called. Java a close second, the compiler generates one class with the base Object as it's generic parameters. Any generic parameters are cast to object, or an interface if a constraint is used, by the compiler. The effect of this is that only methods on Object or the interface constraint can be used without explicit casts. The JVM itself does not support generics. For C#, MS took the hit and make breaking changes in .Net 2.0 by adding generics to the CLR. The generic code is then generated at runtime, separate code for value types and a single block for reference types. As there is only one block of code for reference types you have to, just like with java, either use a constraints so it confirms to an interface or do explicit casts if you want to call methods on the generic types. Like I said earlier, I could write a preprocessor that takes go code annotated a way to identify generic code and generate the necessary code. This is really not different to how C++ templates work. I could take the java route and use interface{} everywhere and generate the type assertions based on annotations in the code. I wouldn't be able to easily do that C# way as it needs runtime support. I hope you see that code generation is involved in all these case, either by the compiler or runtime. The outcome is not functionally different to manual code generation. If I need map reduce for &lt;int,float&gt; I can put that annotation in and run my preprocessor to generate the go code the compiler understands. If I need it for &lt;ComplexStruct1, ComplexStruct2&gt; I add that annotation. Using sed was just a quick and dirty way to show that code generation isn't hard. I would probably still use sed if only need a handful of variations, any more and I might look for something more automated.
Before everyone goes all plugin crazy, keep in mind that plugins are only supported on Linux, so no BSD, macos, windows etc. Fine if you're just deploying for yourself, but if it's something to be distributed then it would effectively restrict the program/package to Linux.
sorry the source code looks like this ..don't know how to format :X.
[removed]
That's not what is generally called a "supervisor", that appears to be something more like cron in Go. Nothing wrong with having a cron in Go, of course, very useful. Just might want to call it something else.
Ah ha, I thought I recognised your handle - we may have even exchanged emails at the time. Yes - I do have Go code for this - a variant of it is essentially the core resource location mechanism in GoshawkDB. https://src.goshawkdb.io/server/file/tip/consistenthash/resolver.go#l49 is the place to start. Here, the positions []uint8 is the input which you're essentially hashing. Bear in mind that because this code is on the critical path of transactions in Gos, it's been pretty heavily microoptimised which may have led it to lose some readability! The tests in the same directory might be useful. EDIT: Just been reminding myself about this code. You need to keep in mind that this code picks up right at the very end of the paper. So that means that: positions[0] \in 0..1; positions[1] \in 0..2; etc (in general, positions[n] \in 0..(n+1) )So the positions slice itself is encoding the path down the tree that I talk about in the paper. A fresh positions slice is created at https://src.goshawkdb.io/server/file/tip/consistenthash/cache.go#l84 in case you're curious about that.
Or [fzf.vim](https://github.com/junegunn/fzf.vim) which is faster.
Unfortunately, I don't know a nice snappy term for this. "Scheduled Job Runner" is the closest. Calling it "cron for Go" would mostly get the point across, though it's inaccurate in some ways. Alas.
Hugo is very well written - https://github.com/spf13/hugo 
That is really interesting. I might have to setup a data pipeline for a new product at a startup I am currently. I am pretty comfy in Go but Casssandra is new to me. I know that a lot depends on how to model around the partition key and then your primary key. But I don't have much practical experience. Can you expand on some of the issues that you has with Python/Java and maybe how you are modelling around Cassandra ? Thanks !
Ya, this is a message bus. I am pretty sure I know ahead of time all the possible different structures, but there are dozens of combinations.
It's not an option to have clients send a header with message type?
so the article says i can pin a dependency to a version number. it seems to indicate these are tied to git tags...is this true? if so, how strict is the parsing? does it accept both v1.1.1 and V1.1.1 etc? anyway, looking forward to this
Friends don't let friends use YAML. :-P
First, just to set expectations, any convenient mechanism for dealing with XML must necessarily fail on some XML. But it sounds to me like you will probably be OK with encoding/xml, because the Decoder object has what seems to be a little-understood feature, which is that it can be used as a hybrid of a SAX parser using `Token` and a struct decoder using `DecodeElement`. See for example https://play.golang.org/p/4RE1JpEqVf . This allows you to examine any wrapper elements up to and including the first element of the thing you want to parse before having to decide on a type, without double-parsing. The downside is you will do a bit of parsing yourself. You may want to write some convenience functions for doing things like "get me the next start element", since `Token` will return all the whitespace as char data, for instance.
No, It's data coming from a Fortune 50 company. Having them change the API is highly unlikely. To top of my frustration, it's a brand new system that was just launched and they decided to use XML instead of JSON.
Reading the source (and its own manifest.json), it appears to use [Masterminds/semver](https://github.com/Masterminds/semver) for version parsing.
Woah, it supports forked versions? I am sold! ps. Happy cakeday
Is there some plaintext you can grep on maybe? Cheaper than double decoding...
that's what I say about XML ;)
As a beginning gopher, sites like this one and Go by Example are a great resource. Thanks for putting in the time! 
&gt; dep init adds the current version of any of the project’s dependencies found in $GOPATH to the manifest.json file I'm not gonna use it. Said it a few times, happy to say it again. GOPATH is a mistake, get rid of it. Now! Go started as a language where they decided to build it from scratch instead of building it on top of something. That's the case. You cannot build a good package management on top of GOPATH. It's like if with npm, you first would install packages with -g and then do something on top of that. That's insane!
Thanks for this! Always grateful for more examples. My wish list of examples would be: * Database and unit test * Migrations * Auth * Templates with auth checks.
I'm against the ~ and ^ syntax. It's redundant to &gt;= a.b.c, &lt; x.y.z and very cryptic and unintuitive.
Couple of thoughts: - remember to use `gofmt` - you can use the shorthand `n &gt;&gt;= 1` - `for (true) {}` == `for {}`
unsure about windows, but for *nix you can just create a file with a "." prefix.
It's just for a personal project and personal growth. I'm trying to decide between Go, Rust and C
I'm actually asking for a function or method from the core library for doing that.
Thanks for that! J just read tutorial and started playing with Go, I'm updating code... 
You can save yourself a ton of storage if you compare hashes rather than full data...
I believe that windows respects the "." Prefix like Unix. So it will make it hidden just the same. Try it. As far as I know; there is no function for it. 
&gt; Scheduled Job Runner It sounds like it sounds great. But, In fact I wanted something like a supervisor to be realized in Go...
Yes, a nicely done oAuth2 example please. With easy to understand explanation.
I don't think that's the issue here. The issue being raised is that you have to run two commands; `go get foo` and then `dep ensure foo` to get a copy of foo; this is clearly ridiculous, since having the right version of your dependency in your GOPATH is already almost certain to be false. dep ensure Should obviously populate your `vendor` folder with all pinned versions, regardless of if the dependency is in your GOPATH already or not. ...but ultimately, that's the intended behaviour as far as I'm aware, so it's not really an issue.
&gt; you have to run two commands; go get foo and then dep ensure foo to get a copy of foo No, you don't. &gt; `dep ensure` should obviously populate your vendor folder with all pinned versions, regardless of if the dependency is in your GOPATH already or no It does.
These are definately on my list. Thanks for your feedback!
This can be done with ``` fuser -k $port/tcp ```
Yes indeed, I just lodged a bug about when it doesn't. The desired behaviour is that that it does. :)
Okay, I really like the versions are coming into the mix. This is shaping better than my first impressions. Still though, ensure... update, upgrade, fetch, get, anything else please :)
I like what gb tool does. It works for me.
Hey this is pretty cool, at a glance I don't see any glaring mistakes. Keep at it!
I am not trying to be a dick but Gleam is pretty cool and I am sure it performs very well as far as distributing the work, and how fast the workers are on the individual nodes, but go is not the best language for data processing, lua is sucky in that regard. Also map reduce is distributed systems for the masses, and is used for a lot of things it shouldn't be used for.
Thanks.
Nice examples, but I don't quite get the use of bcrypt. Used like that, once you know the hash of a string, you've got access to all resources with that string as their password, isn't it? With a dictionary and a bit of patience, you could crack a large number of common passwords.
* json in configuration files (we don't need comments apparently) * magic runes to specify version constraints (reminds me of perl) * ensure will write new dependencies to manifest, lock and vendor but only if manifest and lock already exist. If they don't, you have to use init which writes new dependencies to manifest and lock but not to vendor. Why is state 0 special? It shows that this doesn't come from the go team.
This is the only one so far I didn't know about I skimmed through the source and read it's design description, I share Peter Bourgon's aversion to dealing with consensus/coordination and this is exactly what I was looking for.
`CGO_ENABLED=0 go build ...`or add a file to the project with the build tag cgo that references a non-existent symbol.
Doesn't the std lib use a lot of reflection = bad?
You are looking for the GetFileAttributesEx, GetFileAttributes and SetFileAttributes set of methods in the Win32 API. I do not believe this in the core so you need to learn how to work with windows dlls 
I don't meant to be rude by responding with a link, but can you expand on what is missing from : https://www.docker.com/what-docker
OK, same principle. gb traverses parent directories until it finds an src directory and declares that to be the GOPATH.
It's a super fancy jail, with vendor lock-in as a feature.
What?
Meanwhile, for auth, you can read https://github.com/thewhitetulip/web-dev-golang-anti-textbook/blob/master/manuscript/4.0authentication.md for middlewares https://github.com/thewhitetulip/web-dev-golang-anti-textbook/blob/master/manuscript/7.0middleware.md :-)
Although Docker is written in Go a more suitable subreddit to ask this question would be /r/docker But as a short answer: Docker is a technology to "pack" your applications in a special format to run on various plattforms without targeting those plattforms explicitly in your build process. (Not exactly an ELI5 but a simplification of at least one purpose of Docker) You wont need this technology for your entry level Go Development as Go is already statically compiled (with minor exceptions but those wont affect you).
ever seen a jail built on linux and running on windows? :D
Therefore, docker is only good for testing in different OS, but it can't really do anything about web development. 
Great work, hope you will add more content.
You should not disparage yourself by calling yourself stupid or saying you have a low IQ. Being inexperienced means you have not had the exposure to understand something. This is normal. People learn new things in relation to things they already know. Docker does not make sense yet because you lack experience in the problem space where it provides a solution. Chances are, you don't need to worry about it for a while yet. But, to try to answer your question, Docker allows you to say "my app needs a given OS and these OS packages and dependencies" and then let's you deploy that to varying other OSs with having to worry much. I find docker less compelling for Go development because you can just create a Go binary for the target OS.
&gt; `sudo ln -s /path/to/nkill /usr/bin/nkill` Compared to just setting `$PATH` correctly in the first place; this is very unwise and horrible "advice" to see see anywhere (both linking into `/usr/bin` and even having a `sudo` setup that allows such `ln` usage at all).
I usually go this way. 1. Create a User Store Interface (CRUD) =&gt; UserStore 2. Implement the Methods =&gt; UserStoreImpl 3. Create a UserHandler (handling the routes) On Service start I use facebook inject to inject UserStoreImpl into the Object Graph. In UserHandler I will require UserStore interface and use it's methods, which gets satisfied by UserStoreImpl. You can now write a test and inject a mock object, implementing the UserStore interface into your handler. This way you can test your handlers in isolation. On Top of that, if you decide to use UserStore everywhere else just require the injected Object from the object Graph and you are done. DRY and testable.
The issue title was updated to be more specific and accurate. &gt; net/http: HTTP/1 server got 0.5μs slower in Go 1.8
Be aware: those tiny tiny toy programs show 2 different cases - - default memory usage *pi-digits, fannkuch-redux, fasta, spectral-norm, n-body* - required memory usage *binary-trees, k-nucleotide, mandelbrot, regex-dna, reverse-complement* Be aware: both cases show un-tuned memory usage.
Hahah. It's up there with "Should Go have generics?"
I am adding a SQL layer on top of it, which should be easy for more people to work with it.
Documentation would be good start
For simple web applications, I've been using the following pattern: Define a data layer interface ala [example](https://github.com/boxtown/meirl/blob/master/data/stores.go#L76) The interface can then be implemented specifically for a data source like PostgreSQL, MongoDB, or a mock store for testing. I then define an API/Handler layer through API objects that take in the data layer interface ala [example](https://github.com/boxtown/meirl/blob/master/api/user_api.go#L21). The API objects then define handler functions that interact with the data layer interface and respond appropriately
Good catch, updated README.
I am using the exact same approach and am quite happy with it. Bonus points if your Services and Repository are all interfaces that can be mocked.
&gt; Do you know of a better alternative in Go? No. But reflection / code generation is just fucked up in 2017.
Cool! Thanks for contributing :D
Great Work!!! I believe that a bit bigger explanations (line-by-line, block-by-block) like Go by Example does would be incredible!
Windows does not respect the '.' prefix to hide files, just tested under Win 8.1.
Very interesting optimizations and exposure to internal optimization routines.
Middleware has been added :)
Try to change POINT(%f %f) to POINT(? ?)
Fortunately in this example I am able to convert to a float which sanitizes the values. There's another statement using user inputted text which scares me.
Sorry i meant change POINT($1 $2) to POINT(? ?). Does that work?
Postgres's driver requires $1, $2, $3 etc... ?, ?, ? is for MySQL and I think some others.
Absolutely. Interfaces make the whole thing simple to mock out for testing and local development :)
[That's not padding...](http://www.toptentopia.com/wp-content/uploads/2015/12/thats-no-moon-its-a-space-station.jpg)
Added image transparency support :) - http://github.com/eliukblau/pixterm
I hope it's written better than "go had grew". 
&gt; pq: could not determine data type of parameter $1. Of what data type are the parameters lngF anD latF? Maybe pq needs different types. Did you check the pq repository for any related issues? And what is the simplest query string that fails with this error message? Like, does `select * from table where a = $1` fail? (Try different types for the var that goes into $1)
Why?
It's tempting to save that copy when you often don't need it, but adding that ampersand is ugly and will confuse people reading your code.
Someone showed me that page a week ago when I asked for comments on my repo, so maybe it's also helpful to you: https://goreportcard.com/report/github.com/kamalpy/apiai-go
Almost everyone ranges over slices, not arrays. Ranging over a slice does not require an extra copy.
https://github.com/alioygur/gocart may it help you
Pretty cool. Thanks :)
I learned in life is that what I don't know is probably what I don't need yet. So I think you probably don't need docker yet.
You shouldn't panic everywhere, never panic in a client library to be honest. It is better to return the error to the caller
We are building a high performant open source social and realtime game server in Go - https://github.com/heroiclabs/nakama Friends at Cockroach Labs are building CockroachDB. An open source, survivable, strongly consistent, scale-out SQL database - https://github.com/cockroachdb/cockroach Thing to remember is that Go is like C - in that it is a system language, with similar performance characteristics, that is cross platform and can statically link so you end up with a single binary. This is exceptionally exciting because the barrier to entry is lowered down by a mile. 
A continuous integration pipeline and a smart home controller with Amazon Alexa integration
I'm currently writing a music player with sound cloud and Google music, http://github.com/soon-fm/player it's part of a more distrusted system with scoreboards etc for our office music system. It's early in development, the old player uses Spotify but since libspotify is being shut down this year we need to migrate.
This! I've had so much pain from libraries that: * Panic instead of defining public errors I can check against * Use `map` for JSON deserialisation instead of `struct`s with tags (because it leads to obscure panics elsewhere) Panic is for cases where you really think bad things shouldn't ever happen, and if they do, there's no way it isn't going to end badly for the user of the library. Memory corruption is one case. Data loss or data corruption is another: maybe it's better to panic and save the database if you think your current state jeopardises something important. Otherwise, return the error! 
Does for i, p := range person {...} really copy the array ? It is confusing. I think that what it does is for i := range person { p := person[i] ... } 
Thanks. Do you mean that the map shouldn't be used inside struct which will receive the JSON data via unmarshalling?
Aww yiss, get to post all my Go stuff :) [MailDB](https://maildb.io/) - Current SaaS project. Virtually everything except the front end and MySQL database for member data is written in Go. The server and API are Go, multiple custom packages have been created strictly for the project in Go (some public, such as [mailchimp-go](https://github.com/beeker1121/mailchimp-go)), the main email database uses the [Go port of LevelDB](https://github.com/syndtr/goleveldb), etc. If you or anyone you know spends their time looking for emails, let em know about us! :) [Resounden](http://resounden.com/) ([github](https://github.com/beeker1121/resounden)) - First Go and React web project. Simple SoundCloud music player. **DO NOT follow this app structure**. I was moving from PHP to Go and still trying to think in terms of MVC when structuring it. [goque](https://github.com/beeker1121/goque) - Persistent stacks, queues, and priority queues for Go backed by LevelDB [mailchimp-go](https://github.com/beeker1121/mailchimp-go) - Client for v3 of the MailChimp API (based on Stripe's Go client). [imup](https://github.com/beeker1121/imup) - Image upload handler. [creek](https://github.com/beeker1121/creek) - Simple log rotator. [nosurfctx](https://github.com/beeker1121/nosurfctx) - CSRF protection middleware, using Go 1.7 request context. Lot of other stuff for the MailDB project. Will eventually be building a web crawler and plan to make that public. As you can probably tell, I really like Go. I think it's amazing for web, but I agree that some parts can be a bit tedious. However, once you have a sound structure in place, it becomes much, much easier (minus any possible refactoring from getting it wrong initially). It takes time though. Even with my current app, there's a couple of things I would like to figure out how to structure better. The simplicity of the language though, mixed with the performance gains, standard lib and tools, etc make it amazing for a lot of things not just the web. You have to weigh the pros and cons though and choose the right tool (language) for the job.
If we ignore analyzing job prospects and general marketability in terms of various career paths or analyzing language performance, I personally prefer to write in Go vs JavaScript. * Go is a small language, so it's usually more clear what the best approach to a given problem is and you don't have to waste time learning all the little tricks. * I find Go's syntax to be more readable. * I will always choose the language with a stronger type system. I've found I can code faster in Go and while paying less attention (I.e. while drinking beer, watching TV, or chatting with my wife) because the compiler will catch many of the types of errors you make under those circumstances. * I like the documentation for Go better 
How is MailDB not a spam engine? Sorry if I am misunderstanding, but you seem to scrape or in some way get likely valid email addresses for a domain (like target-company.com), you then create a list like john@target-company.com, jane@, sales@,... Someone then uses an ESP to send their target marketing email to those addresses ("hi, I am offering a new SaaS, and want to reach your sales department"); however, they have never had any business relationship with the target contacts. The contact is completely unsolicited. If that is not the goal, why also provide the ESP lib? Did I completely misinterpret the goal of MailDB?
We are building a bank: https://monzo.com/
I wouldn't make the decision based on speed. /u/Shonucic makes some good points; another point I would make is that Javascript's model for dealing with asynchronous behavior is a bit clunky. Of course, if you're doing web development, you're stuck with it on the browser side, and there's something to be said for doing all your work in a single language. But getting things right on the server side is perhaps even more important than getting them right on the browser side, both from the perspective of security and the perspective of performance. So in that sense, Go may be a better choice. But ultimately it boils down to whether you can get the work you want learning Go or learning Node. For maximum flexibility, learn both. You will want some familiarity with the Node tools anyway because you'll want them for your browser-side code.
For web development, the performance of Go is often not the deciding factor. Go is very close to the metal, so its perfect for system level applications. Node.js is written in JavaScript so it shares the language with the front-end. It has very well documented frameworks and libraries for developing web applications and if you use something like React then isomorphic code is very viable. So the decision comes down to this. Is performance of the web server your primary concern (ie in reducing cost to serve)? Do you know enough JavaScript to write the front-end application? Which one are you more interested in?
Recently, a lot of low level networking things on Linux. Been playing with [netlink](https://github.com/mdlayher/netlink), [nl80211](https://github.com/mdlayher/wifi), and most recently, [AF_ALG](https://github.com/golang/go/issues/19033) sockets in Go, for userspace access to the Kernel's cryptography subsystems.
Large arrays will produce a large unnecessary copy with considerable overhead. passing a pointer to the for construct is necessary to avoid the copy. However, I am a bit confused as to why they passed a pointer of the array while not optimizing further by accessing the array indexes directly instead of creating an extra copy within the for construct. I'd like to also add that pointers are part of the language, they aren't so ugly as you claim.
Why don't you go the middle road? Learn Javascript for the front-end and learn Go for the back-end. You cannot avoid Javascript anyways.
the slice has a pointer to the array backing the slice, so when ranging over a slice the compiler in essence copies the pointer to the backing array in the slice header, similar to passing an array-pointer. So its not about requiring the copy but more about having the option to pass the array or an array-pointer. ranging over slices gives no such options.
Aww :( I love go-kit. First, go-kit is very much production ready, and in use by quite a few orgs. Second, yes, the patterns in go-kit are a bit complex, especially for beginners. Go kit uses interfaces and first class functions to provide a very clean and composable API. The only time that `interface{}` i used in the library is to to accept a request and response struct, which must be provided by the user. Perhaps `interface{}` could be avoided with some code generation, but I'd argue using the empty interface here is a reasonable tradeoff. I've used go-kit quite a bit over the last 2 years, building some microservices, but mostly what I'd call "well structured monoliths". Using go-kit results in clean, reliable and maintainable codebases. I find [this ruby talk](https://www.youtube.com/watch?v=WpkDN78P884) a good example of some of the ideas that you would find in a go-kit codebase. If anyone is looking to try go-kit out, http://gokit.io/examples/stringsvc.html is a great start And the #go-kit channel on slack of course :) 
Thank you for your suggestion! The new way of declaring struct validation rules is implemented. See https://github.com/go-ozzo/ozzo-validation#validating-a-struct-value
A text template tool for quick building use case
You can always try. https://ellie-app.com
queue my usual talking points against ORMs :)
Damn you guys are impressive. I'm just using it for migrations and image processor.
Nevermind I figured it out. &gt; A delightful language for reliable webapps. **Generate JavaScript** with great performance and no runtime exceptions. As I said, you cannot avoid Javascript.
&gt; so you will have to determine the OS &gt; &gt; if runtime.GOOS == "windows" That won't work for this because the Windows implementation will need to use something like `syscall.LoadDLL` which will only compile on windows. For this kind of thing there should be a windows implementation in either a `*_windows.go` file or a source file with a `+build windows` [build constraint](https://golang.org/pkg/go/build/#hdr-Build_Constraints) and then a Unix implementation (or in this case probably just a non-windows implementation) in a source file with another build constraint (e.g. `+build !windows`). IMO it's usually better to use build constraints even for cases that could be implemented with a `runtime.GOOS` check. E.g. something like: in hidden_windows.go [edit: can probably use the `syscall` package]: package hidden import "os" import "syscall" // on windows this gets you the windows version func CreateHiddenFile(namePattern string) (*os.File, error) { name := makeWindowsFileName(namePattern) nameptr, err := syscall.UTF16PtrFromString(name) if err != nil { return nil, err } f, err := os.Create(name) if err != nil { return nil, err } // Do whatever windows calls are needed to change // the file into a hidden file; something like err = syscall.SetFileAttributes(nameptr, syscall.FILE_ATTRIBUTE_HIDDEN) if err != nil { os.Remove(name) // XXX do we want to remove it? check for error f.Close() // XXX check error return err } return f, nil } and hidden_other.go: // +build !windows package hidden import ( "os" "path/filepath" ) func CreateHiddenFile(namePattern string) (*os.File, error) { dir := filepath.Dir(namePattern) base := filepath.Base(namePattern) name := filepath.Join(dir, "."+base) return os.Create(name) } 
It's okay, you do not have to like a library, and constructive criticisms are also okay but this is not that. Do you have some kind of personal problem with the go-kit authors? There are a lot of them, development happens in the open and if you follow the repo, you could see how much effort goes into making it all maintainable, and well-architected. The amount of effort you put into a disparaging post makes me think you do.
I decided to learn go by writing a VLC relauncher that launches VLC for a file with specific arguments (i.e [for showing video on a second monitor](http://superuser.com/a/193342/81940)) and stores it's settings in a json file beside itself. This means a user (of the target Windows system) can right click a video file and choose "Present with VLC". I still haven't been able to get the exe properties (icon and description, etc) to build from go on Ubuntu, so I added them with an external tool.
Have you looked at [moggio](https://mogg.io/)? I used some components of that project and it's really great stuff, could save you a lot of work if you're not already using it. :)
We use both. You will end up using node anyway for building your front-end (webpack, gulp, browserify ...) at least if you use any modern web framework like React, Angular, Vue. We use node for server-side rendering too. Our business logic is fully encapsulated in stateless Go REST-like APIs with JWT tokens. Go excels at this. I have done years of node backend development that I didn't want to do it again for my startup (TJ of node fame came to the same conclusion). Shops like Wal-mart and PayPal apparently do fine with node on the backend. I don't think they've tried Go :)
[ssh-chat](https://github.com/shazow/ssh-chat) is a custom ssh server that is an IRC-style chat room rather than a shell. Give it a quick try: $ ssh chat.shazow.net I really like the idea of providing unexpected experiences with existing clients/protocols, so I set out to build some fun ideas on top of IRC as a corollary which produced [go-irckit](https://github.com/shazow/go-irckit). [go-irckit](https://github.com/shazow/go-irckit) is 85% done, but there are a few outstanding bugs primarily with client compatibility. I recently discovered that there is [a fairly active fork](https://github.com/42wim/mm-go-irckit) which fixes most of the problems but also hardcodes unrelated things—I really wish someone would backport the fixes. For a while I was building a 3d game engine in go using go-mobile: [go-gameblocks](https://github.com/shazow/go-gameblocks). It's maybe 50% finished, but I've found go-mobile too unstable to depend on so the project is shelved. Some good stuff in there though. :) Right now I'm doing unrelated things, but looking forward to write more Go soon!
How is abuse of `interface{}` is not a constructive criticism? 
&gt; func (f *Fpdf) RawWriteBuf(buf *bytes.Buffer) By the way, you should submit an issue/PR for gofpdf to fix their API [edit: [PR was submitted and merged already](https://github.com/jung-kurt/gofpdf/pull/103); replaced inline diff with just the updated method signature]. IMO they should instead have: func (f *Fpdf) RawWriteBuf(r io.Reader) IMO they have no business requiring a `*bytes.Buffer` when they only use it as an `io.Reader`. Further, in your case that allows you hook the two together ~~more easily~~[edit: okay, not really easier] without having to buffer the whole contents at once [edit: and if the reader and writer have processing they need to do while read/writting; some of that can get overlapped] (although because one wants an `io.Writer` and the other an `io.Reader` you'd need to use something like `io.Pipe` to do so).
Abuse? Haha.
When you pass the server address parameter to ListenAndServe, you can do either `:8080`,`0.0.0.0:8080` or `127.0.0.1:8080`, The first 2 are reachable from the network, the third only listens on localhost. And yes, you should use a reverse proxy for multiple applications. nginx and haproxy are good options in production. I also use caddy in some hobby projects. 
YMMV but losing compile time type safety is a problem and a valid point. And `go kit` have this thing in transport, middleware and endpoint levels. This is solvable, just like a writing lot of boilerplate code. Doesn't mean people should not voice their concerns and doubts. And yes - this post is supported by others I know, who had tried go kit and liked it but became disappointed at some point. I think there is room for improvement if your product get criticized (it also means its used by them), don't you think? 
An API for the design and production of genetic tools: [https://serotiny.bio](https://serotiny.bio)
&gt; This is a compiler optimization. In other words, &gt; &gt; for i = range persons { &gt; ... &gt; } &gt; &gt; will be optimized to &gt; &gt; for i = range &amp;persons { &gt; ... &gt; } It's much better (and IMO more accurate) to say it's the same as: for i := 0; i &lt; len(persons); i++ { and since `len(persons)` evaluates to a constant at compile time for arrays, this is all the same as: const N = 3 for i := 0; i &lt; N; i++ {
Perhaps because adding a boolean could be confusing and easy to misinterpret as "failed to delete" vs. "delete successful". If the goal is to make sure that a certain element is no longer in the map, the current API accomplishes that goal without providing any room for misinterpretation. Go tends to prefer clear over clever. As you pointed out, if you'd like to know if an element was actually present before deletion, you can always do a quick lookup on your own.
 "not yet" -&gt; https://github.com/google/grumpy/issues/173
Thanks I'll take a look :)
S3 cache web server. It gets list of S3 keys, zips them from local mirror to a zip "file" (on the fly, to the http response stream' no file really created) and serve it to the user. Very impressive results (70-80 MB/s). Very stable as well - not a single crash after months in production..
the map semantics are haphazard. It is just something a go programmer has to live with since go compatibility guarantee. 
Have a look at http://github.com/plietar/librespot It's an open source Spotify client library i've been writing which works even though libspotify is being shut down. It's written in Rust, but it should be possible to write a Go wrapper library around it
Great, this answers the question. I was under the wrong impression that the go applications are always exposed to the external network even with a reverse proxy.
Well, mostly REST-ish APIs at work, I'm loving it though, after 15 years writing all kind of stuff with PHP (from websites to portable system utilities on embedded devices, not kidding) it's nice to finally have a properly designed language to use. Things that are open-sourced: - [munin-http-timing](https://github.com/DigitalBackstage/munin-http-timing), a munin plugin to monitor detailed request times on specific URLs. - [goof](https://github.com/L-P/goof) the first Go I've ever written, I was unemployed and wanted to toy with the language, never finished it though, I stopped when I had to write JavaScript. I did not did this app enough to write that much JavaScript for it. I'm still amazed I was able to understand everything I wrote when I came back to it one year later, Go is so concise and leaves little room for ambiguity. You can steal the .ics parsing code from it. My work requires me to fill a document with the times I arrived and left the place, I'm too lazy and forgetful to do that so I made a tool that reads uptimed records and writes .xlsx files ready to send. I also have a replacement for my poorly coded [woland](https://github.com/L-P/woland) file browser in the works, I might finish it sometime. 
&gt; 2\. Install nginx/caddy/similar. Here [0] is a simple Go implementation for reference. That said, I'd recommend using Caddy unless you have a good reason not to. [0] https://gist.github.com/shurcooL/d3b1c1c2215bf5b34190
Oh cool, we are using libspotify to stream, I wasn't aware there was an alternative. I'll check it out.
I disagree. Go doesn't copy the array. It only copies the value into v. See here: https://play.golang.org/p/-WfycbMNd_ In this code I do a first value swap, then inside the for loop I swap the last two elements again. The value v is back in the initial order. This mean that the range iterates over the original array. The array is not copied. The last construct maybe useful in many context. If v is a copy of the value, you may still want to know its index to modify the array entry. 
Building a tool to minify and secure Docker images/containers: http://dockersl.im 
The use case is to ensure correct behavior of the program. I need to assert that a deleted value is in the map when deleting it. If it's not there, there is a bug in the program. I know I can do a lookup to verify that the value is in the map before deleting it. That is what I do now. But this costs two lookup. One is a waste of resource. It wouldn't cost much to return the bool value reporting if deleted did something or not. There is an equivalent "problem" with the map assignment operation. It's not possible to know if the value was overwritten or inserted. Such assignment costs two lookup if we need that info along with the assignment. 
At work, ddos mitigation using GoBGP behind a REST API. At home [#18744 runtime/trace](https://github.com/golang/go/issues/18744) I want to get solid enough so I can finish [go-trace](https://github.com/cstockton/go-trace). The I want to make some real time (near) graphs or interesting visuals using d3js or whatever the latest hotness is using the updated trace format. 
No, I don't have anything against the authors, I actually heard him talking in a pod-cast and he sounds very nice and wise. I actually appreciate the effort done and I think there is room to construct an environment for go microservices, and there are a lot of things I think that are really nice in the go-kit library. I tried to make it clear in my gist, I'm sorry you didn't read those parts. Nevertheless, I've felt some downsides of using it, and I wanted to share it and to understand if other people think different. 
It is important to note that your implementation is virtual hosting with different domains resolving to the same host, not routing on path on the same domain, which is why it is relatively complicated.
It may actually be quite costly - not necessarily in CPU cycles, but in code. One could imagine that delete() shares the assignment path for the map. One could then complicate the general assignment path, or have an almost identical assignment path for delete, both of which would be unfortunate. Furthermore, I'd argue that a much more useful feature would be something that fails a value assignment with an error if a value is already present, but this cannot be implemented with the available syntactic sugar. I don't know enough about your program based on the description, but it sounds like you're just implementing an error that can never trigger in a reasonably correct program, and if it triggers, the program cannot recover or act upon it (apart from maybe logging "Your code is broken, yo"). Unless you're debugging, or have good reason to believe that the logic issuing the delete is defective/complicated (which should be verified with unit tests, not asserts), I'd argue that the check is redundant. It also reduces the use-case of the delete return value to an arbitrary, mostly unused assert. I may of course be entirely mistaken, as I only have a short generic paragraph to describe your usecase.
I thought this company sounded familiar! I've watched a few Youtube talks from Matt Heath on microservices at Monzo. Seriously one of the better talks about Go from a practitioner's perspective! 
If you ❤️ back end, learn go. If you ❤️ full stack or front end, learn JS. Full stack, in my opinion, is a siren song. It lures developers by massaging their ego: know it all! It lures developers by calming their fear: you'll get a job! But it also traps you into being a jack-of-all-trades: your pay will be capped because you aren't specialized. If you're just starting LEARN AS MUCH AS YOU CAN. But nobody can really know it all. So when your ❤️ finds its preference, specialize and hone your skills.
(shameless self-promotion) You can use sockets' REUSEPORT option. I made a wrapper for it https://github.com/kavu/go_reuseport. Reverse-proxy with nginx is also an option.
The use of Go at Monzo is only me second favourite thing about the company. The first is definitely the liberal use of Emojis on all official communications.
only slices found in your example. array is not slice.
&gt; although because one wants an `io.Writer` and the other an `io.Reader` you'd need to use something like `io.Pipe` to do so E.g. (with the above change so that `RawWriteBuf` takes an `io.Reader`) you could do something like this: readDone := make(chan struct{}) pr, pw := io.Pipe() go func() { pdf.RawWriteBuf(pr); pr.Close(); close(readDone) }() n, err := c.WriteTo(pw) pw.CloseWithError(err) &lt;- readDone // check n, err and use pdf 
Hah, I love it. Sophisticated bot with large code base, motive: people's amusement. A+
This is cool, I've always been interested in indie game dev, sucking at all things visual keeps it a interest more than a hobby these days. Curious if you have done anything client wise in Go with your game servers?
it's [Elm](http://elm-lang.org/). It's syntax comes mostly from [Haskel](https://www.haskell.org/). It's a great language to build web applications. *edit* To understand it's concepts the [The Elm Architecture](https://guide.elm-lang.org/architecture/) is the best resource. It's also a great way to understand the ideas behind flux+react since it is based on Elm's architecture.
You understood correctly. It's just for checking in my case. But there could be a use cases where a special action must be performed if the value is absent from the map. This requires also two map lookup. The problem with unit test is that it can't be used when the possible data input combination grows to large. I'm used to put assert clauses in my code to detect as early as possible when assumptions are not verified. 
Contact me, if you are allowing remote work!
Yeah, I thought about some similar before, but I wasn't very sure if this is the best approach. It has the benefit of being self-evident in regard to the error labels and can be used in non-struct cases. On the other hand, it involves redundant work in specifying the labels when they are already specified as struct tags (a very common use case when a struct being validated is obtained by unmarshaling user inputs). Having said that, I think with the current implementation, it is still reasonable to have an additional validation method like you proposed. It is best used when you want to validate a list of values and return errors with the corresponding labels. I'm not offended by your feedback at all. This is exactly how open source projects can get better. Thanks!
Here's a quick code snippet that does what you suggested (need to implement the "Filter" function which removes empty values from a map): return vdn.Filter(vdn.Errors{ "street address": vdn.Validate(f.Addr, vdn.Required, vdn.Length(5, 50)), "state/province": vdn.Validate(f.St, vdn.Required, vdn.Match(regexp.MustCompile("^[A-Z]{2}$"))), "city/town": vdn.Validate(f.City, vdn.Required, vdn.Length(5, 50)), "zip code": vdn.Validate(f.Zip, vdn.Required, vdn.Match(regexp.MustCompile("^[0-9]{5}$"))), })
Internal web-based tooling so no GitHub links: * Essentially a grep for output from build and test runs from the past 6 months to a year. Really useful for debugging huge Integration tests. Used by a couple hundred engineers. * A tool for visualizing the dependency graphs of our production systems that are highly distributed.
Probably when it has thousands of stars on github or something like that.
&gt; And with the eventual rise of webasm (hopefully), I'll send it off to be recycled. I have the same hope.
I built an emulator and playground for my 6502 homebrew game system. It is using GopherJS for the frontend website. I can't wait to port it to Vecty once it stabilizes. Behind the scenes it uses cc65 to compile C to 6502 machine code. The 6502 emulator itself is written in Go, and gets transpiled into JavaScript via GopherJS. https://play.dodolabs.io/?code=1fd0b350 https://github.com/peternoyes/dodo-playground
You are wrong, one of the main advantages of statically typed, compiled languages is that the compiler absolutely can be relied upon to check the correct types are passed to functions. If your function signature requires a type what is the point of writing a test that passes a wrong type in? It won't compile. This is why I like programming in Go over Python and JavaScript, I don't have to write tests that check I'm passing the correct type in, or handle types in my functions, or worry about JavaScript's handy automatic type conversions.
I am gonna reply here also for /u/daveddev. Yeah I get it, you try to avoid the ugliness of Javascript by writing something else that compiles to it like Elm of Dart. It's a similar thing with Sass, Less and CSS. My point with "you cannot avoid Javascript" is that when we are talking about serious web developing, you need to know Javascript. Why? When there's that hard to figure out bug that might even start from Elm, how are you gonna reach deep down and solve it? You need to know Javascript. What will you do when you have to use the Chrome/Firefox dev console to debug or test something? You need Javascript. How about if some addon you want to use for your app does not yet exist with Elm/Dart or whatever or maybe it needs only a few modifications so that you can make it work? You still need Javascript. You get the idea. It's the little things and details that you face every day as a web development. Those were just a few from the top of my head, there are many more. If you already know Javascript and you decide that you'd rather write Elm instead, then that's fine. You already have the knowledge to deal with the problems that are going to arise. But going straight to Elm and avoiding Javascript completely, that is not happening. At least not for anything serious. That's all I am saying. Still very high hopes for webasm.
&gt; This requires also two map lookup You can avoid the second lookup like so: n := len(m) delete(m, k) if n == len(m) { /* delete did nothing */ } `len` on maps is O(1) as it just reads the `count` from the `hmap` struct. This also works while adding/editing: n := len(m) m[k] = newValue if n == len(m) { /* value wasn't new, it already existed and was overwritten */ }
I'm not sure this will do what I intended. I'll check it out if you add it.
I've made my own feed aggregator, a bit similar to google reader: https://github.com/urandom/readeef
Opinions can't be wrong, but your free to disagree. I'm not sure how you managed to interpret my comment as a general argument against static type systems, lol. The context is interface abuse in Gokit. My opinion is below and has nothing to do with static typing, it's specific to Go's unique **language** design and empty interfaces. &gt; I think empty interface abuse is pretty much exclusively reserved for functions that take a single type of T or method set / interface, anything else is contentious and hard to measure absolutely If you can give me reasonable counter argument I may change my position though.
I wouldn't code based on what is hot. Rather, what language (tool) feels most comfortable to you. Can you post some of your project specs? It might help aid in determining which is the best tool for the job.
About typing: if you do decide to use nodejs, use Typescript. Totally worth it, well integrated in Visual Studio Code.
Where do you host all your Go app?
&gt; If you are relying on the compiler to catch what types you are sending to your API's.. you have much bigger problems. That's what unit tests are for and you have to write them anyways. I'm not saying that's an argument against static type systems, I'm saying you seem to be missing one of their primary values. &gt; I think empty interface abuse is pretty much exclusively reserved for functions that take a single type of T or method set / interface, anything else is contentious and hard to measure absolutely You're throwing away one of your key advantages, I'd really only do that when I absolutely have to and wouldn't want to use a library which used interface{} on its inbound and outbound API, residually when there are options like codegen to get around it. Basically I don't see the value in the utility of the library over having compile time type checking.
I host everything with Google using the Google Compute Engine platform. It works great and is pretty easy to use, very reliable in my experience. I love too that they handle networking for you, so having machines communicate on an internal network to save on bandwidth is as easy as it gets.
have your applications listening on 127.0.0.1 and use nginx to proxy the public 80 to your applications. this way your applications are not visible to the outside world except through nginx (and you should have a firewall anyways to enforce that only incoming connections to port 80/22 are allowed)
I share the objection to it being potentially confusing. I believe a better path would be, to have the compiler do that optimization for you. i.e. recognize the lookup-delete pattern and then just emit the equivalent of what you want. This would get rid of the cost (which is a somewhat valid argument), should be relatively straightforward to detect and would preserve the readability of the current code. The same goes, btw, for something like a lookup-write (e.g. if you want to prevent a user from registering two names for the same thing or something). And I *thought* I already read something about that at some point…
These arguments seem very flimsy, and guessworky. FWIW, I'd probably guess that read/write/delete all share the same lookup-code, to find the bucket the value is in and then do whatever to it. And given that reads already support ,ok, I don't see how there would be any *technical* reason not to implement this.
&gt; len on maps is O(1) Well, so is a read/write/delete ;) The better point is, that it's just one instruction reading from cached data :)
Please let's not describe technical things with subjective fluff words like "enjoyable". We don't need more artisanal elegant modern frameworks.
Valid point. But yeah, I can't think of a similar one that applies to a builtin.
I am currently building a SaaS on top of CockroachDB, cool product.
COMPLETELY AGREE. Ensure comes in a can for elderly people to drink who don't get enough nutrition. Dep init, then dep install, then dep update. Please!!!
I agree with that, especially the last 2 paragraphs.
But what about receiving from channel or type assertion? Both of this operations can return boolean value that will show the status of operation - in case of the value being false it represents that operation has failed to receive data because of the channel is closed or failed to cast because of the incorrect type. The ok is not universal - sometimes it represents that something isn't there. Sometimes it represents invalid state. 
Returning value on delete can be quite costly, and in general case when you only want to verify that value was there in the first place is redundant. I agree with you on making compiler smarter about check-delete tho. Maybe it's worth raising an issue about that in Go github? 
All this effort just to be able to work with C. We could have a pure Go lib by now.
Here you are (see Example_four): https://godoc.org/github.com/go-ozzo/ozzo-validation
Maybe I'm blind, but I'm browsing the source on my phone and I can't find the kernel or implementation of the Linux syscall interface that it says it provides? Is there somewhere that explains how the code is laid out?
counter argument: maps and slices, and the builtins that operate on them are polymorphic. Those looking to create their own data types have many hoops to jump through. I have a set implementation that is backed by a slice. It is alittle over hundred lines of undocumented code. without some form of polymorphism I'd have to copy/paste those 100+ lines of code then meticulous edit type information within the func signature, and sometimes within the func. Or I could use one of the many third party tools that help solve this problem, but then I would have to provide support for those third party tools to my client for the life of the contract. Luckily, rob pike realized that this is a problem for many and added the go:generate tool to help alleviate the problem. rob took the same approach with the tool as with the language with regard to OOP (object oriented programming). Now I still have some manual setup but it is far less than before. The biggest plus is that go:generate is an official tool with first class support, and the scrutiny of the entire go user base - that removes a metric shit-ton of burden. I believe the term 'generics' to be a catchall for many ideas, this is the crux of the problem, and hinders the adoption of a solution to many separate ideas. These ideas need to be broken down, and separated.
Wow that's really smart.
Sorry. That was not clear. We have released the command line interface so far. The kernel needs a bit of cleaning up and then it will be released. It is a bit messy now and we are following a "release-when-you-are-kind-of-ok-with-it" approach :). Takes another week or two. 
For some reason I read "We are building a tank" and I was really confused when I clicked your link.
Have a look at The Little Go Book. It sounds like it would suit what you're looking for. http://openmymind.net/The-Little-Go-Book/ Also, take a look at the Go by Example website https://gobyexample.com/ IMHO, Go is a great language to get started with as it is quite a "small" language. I suggest that you don't worry too much about Channels and advanced topics until you can read and write simpler Go programs. The concurrency model that Go provides is amazing, but get through more basic concepts first.
Correct me if I'm wrong, but REUSEPORT is only good if you're running multiple instances of the same service on the same port as the underlying code acts like a simple load balancer. However, if one istance stops responding or slows down, any requests in that instances queue will not be rerouted to a different instance. I'd say unless you fit the above criteria and absolutely need the best performance, using Traefik, HAProxy, or similar is a better idea.
I can't compare the two, but I'll give you my reasons why I like using Go for services. 1. The HTTP library is pretty damn good and since Google is a web company, they have a vested interest in making sure it's good. For example, it's pretty easy to get HTTP/2 working in Go, which has improved performance for several apps in our system. 2. Concurrency is pretty good. You can easily spawn off tasks to do things asynchronously. 3. Channels are good for sharing data between goroutines and if you need better performance, you still have access to things like locks/mutexes and atomic operations. 4. Static type checking is great. I don't know if Node.js is as bad, but I was doing some Python work recently and hated some of the bugs that I was getting just because they would have been found in Go/D/others at compile-time vs. runtime. I also use vim + syntastic, which uses calls a program to check your code when you save changes and whatever is used for Python doesn't do a lot of checks. Working with Go makes me happier. 5. Built-in unit testing facilities are nice, though I personally love Goconvey if you want added features. 6. It works nicely with containers. If you statically compile the binary, including any calls to standard C libs, you can run it in a scratch container with has no OS or libs. This means your image sizes will be very small. 7. On the same note, low memory usage is also very beneficial. It will allow you to run more containers on a node. That's all I can think of right now. I hope it helps.
I think my comment was poorly written, probably should have set the context up better. I certainly don't want to throw away type safety. But I also don't want to bloat (and commit to supporting) a public facing API with N* strongly typed methods or functions on the premise of preventing programmer error. To clarify on unit testing you will already have to cover the various call sites for these methods. You may get the same compiler level safety with a single type assertion and know you are meeting your own expectations and understanding of the API. If you send invalid T or the API begins to reject T you will catch it in your CI, which for most all Go devs is in lock step with compilation. Point is I would love to not have a need for interfaces, but until Go provides something to satisfy it we are stuck with empty interfaces or the method nomenclature. I don't think empty interface is by default the worst choice and often is the best. I will say that when I choose this style I make sure it returns a error. Oh and I can't recall a time I ever needed to return interfaces, whenever the return value needs to be inferred by the caller the pattern I prefer is to take a pointer to the out type and have the caller provide it, mutate that reference and return a single error instead. Anyways thanks for the comment and good on you for recognizing how he came to his conclusion even if you wouldn't have done the same. Have a good one!
thx, my main goal is just getting a job with a tool that is easy to learn and easy to use. Let's hope our goal is easy to learn and easy to get a job at Los Angeles or in CA,US.
why would you publish a project saying "A kernel for the Go programming language" and not publish the kernel ?
I wanted to release and thought I can have the cleanup done by then. As usual in IT, I was not really ready and will share as soon as I can. But you are right the description on github was rubbish, so I have changed it to command line interface rather than the kernel itself. Thanks.
&gt; Go by Example website That website was very helpful as I was looking through topics. Thanks for your book suggestion. I will look into it.
You mention not to follow the MVC structure in your app, how do you prefer/think go works best in terms of design patterns?
I read that example and it made me feel panicked. That's *fucking crazy*. Hi, my day job has previously involved Spring + Hibernate + Java, and I find the framework fucking crazy. That's the canary in the coal mine.
He's concerned about the pattern your following, seems to be similar to https://github.com/golang/go/wiki/LockOSThread ? I'm not sure his exact complaint. I'll give you some honest feedback here though, I know your intent here is good so please don't be discouraged or take offense. I think this package pushes a bit too far past the original and minimalistic wrapper rust posted. That synchronization you have in their for return values doesn't seem worth it at all. You are introducing deeper call site, multiple synchronization points for additional contention to on OS thread whole the API is in now at robust enough to alleviate every possible need for the end uses to have their own synchronization mechanisms. They will still likely funnel all their calls to a single point for various delegation and handling. On top of this the if they did decide to use your extra .. value functions you provide for return values they just turned every possible stack vector or (non optimized primitives) into a heap allocation for interface conversion. Add to this the fact that this has potential to be the hottest spot inside any game engine... not worth :-) Calling runtime LockOSThread should be easy enough for someone interacting with a rendering pipeline and GL shaders.
 A classic STOMP client messaging library: https://github.com/gmallard/stompngo With examples at: https://github.com/gmallard/stompngo_examples 
It was incredibly enjoyable to write it in Go. I've written or contributed to several major or business/network critical services in Java, JavaScript, C, and Python in the past five years and this was, with no question, the most enjoyable project I've had in this decade. Go was a big part of that.
One reason is map manipulations are not synchronized. So the returned bool may be not reliable (in Go 1.0). The second reason is map element existence query is fast, so using two statements to do the work is not bad. It is not impossible Go 2 will return a bool for delete.
The materials (github repo, website) don't really say what it is, or why you would use it vs other things that are out there. It would also be nice if you said what your angle is: I assume you are open-sourcing the CLI, then charging for the GUI? Aside: Can you make this a plug-in to Kubernetes, so people don't have to run Docker?
Oh wow, I didn't know it was compiling a different syscall library depending on the system. Thank you for teaching me something. 
Nice work!
You are right. Pushed it out Friday last minute. Documentation is lacking a bit and some people might not understand what it is. Will write a blog post next week to explain what it is and how it works in detail and what to expect in future. Plan is to open source CLI and kernel. There is a high-availability server in the making which stores the different versions and does other things as well incl. multi-tenancy etc. Kubernetes we will check for sure. Just spent a lot of time on the kernel and CLI. 
Made with the `present` tool: https://godoc.org/golang.org/x/tools/cmd/present
Wow. This is smart, or I'm not. Didn't thought of that. Problem solved. Thank you. 
[removed]
/u/faiface /u/smasher164 My knowledge in this domain is indeed limited and quite possibly I am wrong. But please then explain me this: https://github.com/gfx-rs/gfx
Built a few things with Go so far: + A restful service to deliver geospatial data in EWKB and Geojson form from a database - extending this with websockets over the next month + A raster tile package creator to create offline tile packages for use in the Ordnance Survey's map application - this was used to cut the Leisure stack maps. The original was python based, but the Go version gave us much better performance + A home automation system running on a couple of RPis + Currently in the process of testing out an api for https://developers.google.com/streetview/open-spherical-camera/ which I then want to use gomobile to test out - this is purely experimental and been ongoing for a while + Couple of client libraries - one for what3words (https://github.com/devork/w3w), tiny well-known binary (https://github.com/devork/twkb) and one for extended well-known binary (https://github.com/devork/geom) - ignore the OSC one in github - it's all local ATM. + A converter to turn ASC heightmaps into r16 images for import into Unreal and Unity + A hillshader to produce pretty pictures from DEM files + A generator for mapbox vector tiles from a geospatial source - this produces the offline tile packages that can then be consumed by Mapbox GL/JS Go hits a lot of sweet spots for me - mainly serverside stuff and a few client things: I find it ideal to knock something up pretty quickly, esp when my other main language is Java which (although the tooling is pretty good) just doesn't have the turn around time that Go does. HTH!
My experience is that GORM has (or at least had) a pretty weak/buggy support for sqlite, it's more focused on the big boys like pg. Like the other guys is saying, it's usually just easier to write your own SQL (with the sqlx package or similar) and avoid using ORMs when doing more advanced queries than basic CRUD operations.
I think bindless in the context of this library refer to "bindless graphics" http://www.nvidia.com/object/bindless_graphics.html
What would a 'pure' Go lib be ? At the end of the day you need to use some backend to render your result using the graphics hardware, such backends like opengl, directx, vulkan, are written in C/C++ . The graphics api (gfx-rs) you linked to in another post also use these backends written in C/C++ .
A middleware for Caddy web server to process ESI (Edge Side Includes) tags to different backend services like gRPC, HTTP, Redis, Memcache ... https://github.com/SchumacherFM/caddyesi Looking for alpha testers (you must be a self-compiler ;-) )
I have a feeling it's because the parameters are within a string already - I wonder if: ST_GeomFromText('POINT(' || $1 || ' ' || $2 ')', 4326) might work? I'm pretty sure I had to do something similar with PostGIS using the Java driver, but I'd have to go digging through my attic. HTH
Release early, release often! We would be more than happy to see the work in progress! :)
Google don't have a dependency management problem, they use a single monorepo with all their billions of lines of code, hence it never came up. There's a community led effort that has the blessing of the core team, and their GitHub project has links to the context that brought them here, https://github.com/golang/dep it's likely to land in 1.9, although apparently basically usable now.
I tried budgie in my Arch install couple of years ago and I could have sworn ubuntu budgie was not a thing last December. I'll give it a try on my spare partition, I'm currently on Ubuntu GNOME LTS. 
&gt; https://tour.golang.org Thanks /u/schoenobates. It seems we have a nice community here.
I am improving object relational mapping. https://github.com/ngorm/ngorm
Reminds me of this: https://www.destroyallsoftware.com/talks/wat
When you call runtime.LockOSThread(), all you do is that you say "keep this goroutine on this one thread and don't jump it between threads" (Go runtime often jumps goroutines between threads). It doesn't say anything about which thread you want your goroutine to run on. Calling runtime.LockOSThread() in init guarantees that the main function runs on the main thread, which is what we want. The *main thread* is important here. Your code makes that goroutine run on *some thread* but you don't know which one. OSs however require that you run your windowing on the main thread.
You can also present them on any computer if you host the slides on like GitHub. http://go-talks.appspot.com
It's not exactly this : https://golang.org/doc/faq#get_version
In addition to everyone else's suggestions ... for most people just reading a book about a language is a terrible way to learn to program. Write code to actually do something, even if it's something trivial. Write code that uses a new concept you've come across, or that solves an actual problem you have. Most people won't begin to understand and remember an aspect of a language until they've written code that uses it, and made it work. That gradually gets less true as you get comfortable with multiple languages, but very gradually. 
You're correct, I shouldn't have mentioned O(1) and just said that it was a simple variable lookup.
If you are a visual learner, may want to to look at https://www.udemy.com/learn-how-to-code Very good beginners intro to Go.
Excellent stuff mate!
Yeah it's been really smooth so far but yeah all it takes is an update lol but here is I think a good inspirational video. https://youtu.be/IjvjqAVkvYo
this is great, Thanks!
Thanks :)
What about using a sync.Pool?
Humans are arrogant, clumsy, and forgetful. mechanisms like type safety help humans make less programming errors.
[removed]
Yep, that could be an option. You can save the allocation, but getting an object from a pool and putting it back takes about 25ns. ``` func BenchmarkSyncPool(b *testing.B) { type dummy struct { thing int } pool := &amp;sync.Pool{ New: func() interface{} { return &amp;dummy{} }, } b.ReportAllocs() b.ResetTimer() for i := 0; i &lt; b.N; i++ { a := pool.Get().(*dummy) a.thing = i pool.Put(a) } } ``` Results ``` BenchmarkSyncPool-8 50000000 25.0 ns/op 0 B/op 0 allocs/op PASS ```
/u/PlainSight is correct in that "bindless graphics" refers to not having to call glBindBuffer repeatedly in the main loop to signify state changes. Instead, there doesn't need to be a repeated lookup for the addresses of the vertex &amp; element buffers. However, these are all still C functions, and the [window code](https://github.com/gfx-rs/gfx/search?utf8=%E2%9C%93&amp;q=address) in gfx-rs's repo shows that they, like all other OpenGl-dependent libraries call get_proc_address.
OP may not have liked your book, but I absolutely did. It was a great start to Go programming. I also recommend the book to absolute beginners to programming in general.
I prefer your first one, but a type switch is a little cleaner I think: https://play.golang.org/p/zGAA5caVEk
Woah, I didn't expect poetry in this sub. Well done!
What about, in this case assuming PostGIS, using ST_MakePoint? ST_SetSRID(ST_MakePoint($2, $1), 4326) If not that, maybe using quote_literal with the whole 'POINT(x y)' as the argument?
I'll try that, thanks.
Could this be a bug in the driver? From the error message I conclude you use [this driver called pq](https://github.com/lib/pq). If you can replicate this with a really simple test case (to rule out other causes), you might want to consider filing an issue. An alternative explanation: the sql and/or pq packages do not evaluate $1 and $2 because they are enclosed by single quotes. Then the driver passes the un-evaluated string `POINT($1 $2)` to the database, which responds with "could not determine data type of parameter $1", and pq logs this error message. (Which is why we see the prefix pq: in the message.) But this is just guesswork; I am not really familiar with the internals of the sql and pq packages.
The kernel was written mostly in C. We are calling it "The Go Kernel" because right now we only support running Go programs on it.
A CA for ssh: https://github.com/nsheridan/cashier
Great timing - will save me explaining what I wrote during last 2 weekends :-)
Do you mean something like this? https://play.golang.org/p/MvsVPYHrhp
A multidimensional slice is nothing more than a slice of slices. Or a slice of slices of slices. Or... Etc. But different numbers of dimensions are totally different types. With one of dimension n you do the [] operation n times and you get an element, with one of dimension more than n you'd get a slice, with one of dimension less than n you couldn't do it n times in the first place. They don't operate the same. So you can't choose on the fly. So, you have about three options. 1. Implement your own indexing scheme to use a single one dimensional slice as the backing data, but be able to access the correct parts of it with n it's as earthboundkid suggested. 2. Use a slice of interface{}'s, and type-assertions. 3. Reevaluate your approach. If by dimensions you mean attributes, and not all of them have all of them, maps might do you better than slices. 
Thanks for the detailed description. I'll go with option number 2.
&gt; I'm not 100% sure what you're doing, There are systems on the market (e.g. Jedox Palo, IBM Cognos TM1, Infor Olap) that use a multidimensional architectures in order to store data. These systems hold all the data in memory. I want to buid a similar system in Go. &gt; it doesn't take long before your slices are infeasibly large to work with Yes, you are definitely right. Example data could look like this: 2016; 01; Revenue-Account; Legal-Entity-1;1000 2016; 01; Revenue-Account; Legal-Entity-2;1200 2016; 01; Revenue-Account; Legal-Entity-3;900 2016; 02; Revenue-Account; Legal-Entity-1;1300 2016; 02; Revenue-Account; Legal-Entity-2;1500 2016; 02; Revenue-Account; Legal-Entity-3;1700 This data would be represented by a 4 dimensional cube (the last column describes the value that is stored). There could be millions of those values. I would have planned to work with pointers to dimension elements in order to be efficient. &gt; You may need to learn more about sparse representations. Thanks for the advice! &gt; a map that takes slices of integers as a key, Good idea, I'll try that as well. 
&gt; Then the driver passes the un-evaluated string POINT($1 $2) to the database I think this is exactly what is happening.
I also wanted to chime in and say I liked your book. I'm still fairly new to golang, but I've been reading all the material I can, and I'm starting to get the hang of it!
Use package [tensor](https://github.com/chewxy/gorgonia/tree/master/tensor). The best part is you can do what /u/VerilyAMonkey suggests and implement it yourself using the exported `AP` data structure. Here's an example: import . "github.com/chewxy/gorgonia/tensor" func main() { x := New(Of(Float64), WithShape(5, 4)) // 5 rows, 4 cols x, _ = x.Hstack(New(WithBacking([]float64{1,2,3,4,5}), WithShape(5, 1)) // add an additional column } Have more than 2D? No problem x := New(Of(Int), WithShape(2,3,4)) // 2 "layers", 3 rows, 4 cols 
He probably meant array of ints as map keys, they have to be comparable. Keep in mind you can use structs as map keys to pretty cheaply: type myKey struct{ a, b int; c string; d [2]byte } key := myKey{1, 2, "c", [2]byte{1,2}} The main benefit of structs is you can use mixed types in them as long as they are comparable. This can get unruly pretty fast but could be good to POC out your initial design. Ultimately you probably don't want to force this kind of data into higher level containers, specialized tree structures will likely be easier to work with.
Because simple code is good. If caller wants concurrency, let caller manage concurrency. Read the stdlib more, and try to find a channel-using API that isn't meant for the case where the caller is expected to use `select`.
Can I work for you, mate?
I (accidentally) created and now am maintaining the (controversial) ReactiveX [RxGo](https://github.com/reactivex/rxgo). Playing around with WebGL and Go now... (if anyone's interested, ping me ;p)
"A little copying is better than a little dependency." https://go-proverbs.github.io
You can't make a single, general statement like `interface{} is acceptable` or `interface{} is bad`. It's a tool that can be used. It's often overused by folks new to the language. To say more requires context.
Calling code can very easily convert a sync API to async, if async semantics are required. The reverse is not true.
This is preposterously untrue. Converting a sync API to async requires spawning a thread; converting an async API to sync requires declaring a Notification class. Neither is easier than the other, but one is substantially *cheaper* than the other, and it's not the one that spawns a thread.
interface {}, 99% of the time implies reflection, which means no compiler optimization so a radical hit in performance, and obviously the compile time type safety is thrown out of the window. Don't get me started on Go reflection which is so leaky it hurts ( it leaks Go internals ). Now it depends on your background : if you come from C/Ruby/Python/JS/PHP and co : you might not even know what a generic or a type class is, so you might not even care about type correctness at compile time. if you come from C#,C++,Java or any ML language(Ocaml, F#) , it definitely feels extremely nasty,especially when using a library based on interface {} when you are used to types documenting the code. At the same time you'll figure out soon enough you can't write compile time type safe abstractions in Go, especially when it involves containers. Go maintainers definitely belong to the first camp,as they throw in more API with interface {}. &gt; I've heard arguments about this being a bad practices only from the community at large At the end of the day it only matters if you publish open-source libraries and can't take a criticism from random people on the internet. You should care only about what works for you and your team not what pundit X or Z has to say. Go maintainers don't have a problem using interface {} or reflection for convenience. Just know the cost of interface {}.
time.After(). I've used it with and without select.
Thank you for illustrating my point @sseth Just because it's in a list of Go proverbs doesn't make it true all of the time and one which I believe is being misinterpreted. I find people new to the language taking this as gospel and not understanding it's intent. Like I stated in the article dependencies like anything else still need to be used with restraint and if you're using 10 lines of code from a library the proverb may apply, but I am seeing any dependencies at all being perceived as negative as evident by this one line response to an entire subject.
[interface{} says nothing.](https://youtu.be/PAAkCSZUG1c?t=7m40s)
I'm not familiar with jsonlogic, but have you checked out the encoding/gob package? Also, net/rpc?
There is a bit more to it than that I think. Mostly I don't really like libraries that pull in lots of external dependencies where I have no control, that is the real problem for me. I don't mind depending on libraries, but I don't want those libraries to pull in lots of external dependencies either that I may not really care about. For example Chi pulls in 0 external dependencies which I really like, it means I have the power to choose my own external dependencies for things like validation, cli framework, api framework, config library, or whatever else I might need. I have seen other libraries like Gin, Echo, pull in their own validation libraries, or Echo pulls in libraries for interfacing with Google App Engine when I don't actually intend to ever run my app on App Engine, but I am forced to include this library simply by choosing Echo as a web framework, why? The same thing goes for config frameworks, now I know viper is really popular, but it also pulls in many external dependencies for config file formats I don't actually care about like toml, yaml, or hasicorp hcl, this is why I prefer using libraries like kelseyhightower/envconfig as it's simple and pulls in 0 external dependencies.
I don't even agree with the exception. They can always wrap it in a channel themselves for a select. While there *are* cases where it's warranted (see, e.g. the various things in `time` that use channels), it's not worth a general exception :)
I think there's some interesting differences. Hashicorp's plugin package comes with a *huge* cost (new process, new HTTP servers, new sockets, etc, etc, etc, etc) if you're doing frequent calls to plugins. *Calling* a function over the hashicorp plugin mechanism is also insanely "expensive" in terms of absolute instructions. There should be effectively zero overhead for using the dlopen method, since it's effectively a C function pointer (and some type casting, etc). I think because Go is Go, *either* plugin scheme is *more* than fast enough, by a huge margin for most of what we do, but you wouldn't want to call out to a Hashicorp plugin every time you wanted to validate a password or check a hash or something. For what Hashicorp does, and what we by and large do in webdev, hashicorp's "http microservice plugins" are plenty fast enough, and the architecture wins are well-worth the trade-off.
Want to achieve distributed map reduce like functionality? How about Lua/JS?
Use of interface{} does not involve reflection in regular code, mostly type assertions.
&gt; kelseyhightower/envconfig Which uses reflection, which is not clear, which is less good than being clever. Per the Go proverbs.
That's not a multidimensional slice. It's a slice of slices. In a multidimensional slice, all rows are the same length, all columns are the same, etc. With a slice of slices, you could have the first slice be length 2, the next length 5, etc. They have no connection from one slice to the next. For example, a slice of bytes is like a string. You might use a slice of slice of bytes to accumulate characters, and the first slice is h, e, l, l, o, and the second is w, o, r, l, d. 
Thanks for your Feedback! I will create an overview graphic of the internals next week, to visualize the architecture. If you have any suggestions, feature requests etc contact me. I don't think slaying make will succeed, but I wanted to provide a proper alternative at least. As mentioned in the docs, make and Zeus can happily coexist. You can view available targets or migrate the makefile into a Zeus structure in the interactive shell. Cheers
&gt; Goroutines are exceptionally cheap They're not cheaper than instantiating a notification. Go ahead and write the benchmark. &gt; The point is, the cost tradeoffs are very different than what someone familiar with other languages might expect. So? It doesn't change the fact that I'm right. Go isn't magic. Even at their cheapest, spawning a userspace thread will not be cheaper than allocating a word.
Use dependency injection to pass a reference of your DB to your handler type FooHandler struct{ db DB } func(f *FooHandler)ServeHTTP(w http.ResponseWriter, r *http.Request) { f.db.Save("hello, world") }
As a gentle counterpoint to being able to do it - can you not structure the data better so that it's well-typed and has a semantically consistent meaning? I realize that this isn't always possible with other people's APIs etc.
https://goa.design/
encoding/json
Go-kit ha been a great tool to better Go design in many teams I lead as gopher advocated, the reason is that it provides a nice separation of concerns
"business logic" in serializable format ? Not exactly sure what you mean. If you want to transfer structured data via rpc/REST, you can use protobuf for that. I guess calling an rpc function can be termed as business logic. Does that answer your question ?
Why would you expect any algorithmic library to be threadsafe? I wouldn't.
`time.After` without select is just a weird way to call `time.Sleep`, isn't it?
Author here, if you have any questions/comments.
Add a known number of tasks taking a known amount of time, and check whether the run time is within a threshold?
Goroutines are not userspace threads. What is a Notification class? Go doesn't have classes. What are you talking about?
Guess I'm not really adding much to what everyone else is saying but yes it is acceptable. However, if you find yourself using it I'd say it's generally worth a step back to think about if what you're doing can be solved in a better way without it. Sometimes the answer to that will be no; there are perfectly valid usages of it. Most of the time I'd imagine you'll find yourself backtracking on it's usage.
&gt; If your thing isn't concurrent, don't use sync.Pool I don't think this is true. For example the canonical example of a good use for `sync.Pool` is by the `fmt` package. This re-uses buffers when able on both concurrent and non-concurrent uses of the package.
Gave my solution above.
You could definitely use this new language feature to generate go code from the JsonLogic format, write it to disk, and load/execute it on the fly. Check out http://www.youtube.com/watch?v=tY4UKkgb5IY&amp;t=19m53s for a great demo on go plugins. Edit: on second glance, since JsonLogic like don't use eval, you probably could implement a JsonLogic lib in go without plugins, but it'd be hard without duck typing.
&gt; reading from a non-empty buffered channel, are lock-free If you mean they don't explicitly use `sync.Mutex` you may be correct. However channels do have synchronisation (I believe using `sync/atomic` primitives) which effectively amount to the same thing. "lock-free" doesn't mean "free of overhead". &gt; How about … First, and most important, such an implementation of a channel pool would differ from what `sync.Pool` provides. The channel buffer size has to be set at creation time and any items in the buffer stay around forever until/unless they are used. By comparison a `sync.Pool` has no fixed size, it grows as appropriate, and at any time the runtime is free to remove items from the pool to recover memory. Also, an important optimization with `sync.Pool` is that it has a small per-go-routine pool (a single item?) that it can use without synchronization (although it temporarily pins the go-routine). Those features can only be provided by using internals of the runtime which is why `sync.Pool` was added to the standard library rather then leaving users to implement their own with channels. Secondly, run a simple benchmark. A simple implementation of a channel of the appropriate type gives me ~70 ns per OP when used by a single go-routine and falling to ~150 ns, ~270 ns, and ~340 ns when used in parallel by 2, 4, and 8 go-routines respectively (on an 8 processor 4 core Xeon). For `sync.Pool` with [/u/philpearl's benchmark](https://www.reddit.com/r/golang/comments/5tln40/searching_for_levenshtein/ddniw3z/) I got ~25 ns to ~30 ns in both cases (single go-routine or in parallel). Having each parallel go-routine grab two items at time and then return them both dropped to ~90 ns (instead of 2×~30 ns) which probably confirms that the `sync.Pool` per-go-routine optimized storage is indeed a single item. 
&gt; is there an easy way to add regex validation to those structs too We're using [govalidator](https://github.com/asaskevich/govalidator), seems to work quite well. For instance: type Foo struct { Email string `valid:"email,optional"` Name string `valid:"-" ID string `valid:"uuidv4" } ... f := Foo{ Email: "foo@bar.com", Name: "ignored by validator", ID: "123131-1312-123131-1313", } if _, err := govalidator.ValidateStruct(&amp;f); err != nil { // invalid } ... &gt; is the only way to expose this DB to my handlers through a global variable use dependency injection just like in any other language 
What value does TOML add that couldn't be achieved with JSON or XML, both of which can be parsed via the standard library?
It's easier to write as a human being. 
Huh, interesting. I'm not aware of anything that does this in a way like jsonlogic (went and looked it up now), but maybe you could achieve the same sort of thing with reflect? Toy example: https://play.golang.org/p/VJ9-F_x08K
There's [json5](http://json5.org/) for that. (And the trailing comma support is golang-y.) &gt;JSON5 is an extension to JSON that aims to make it easier for humans to write and maintain by hand by adding minimal syntax features directly from ECMAScript 5. &gt; &gt;JSON5 remains a strict subset of JavaScript, adds no new data types, and works with all existing JSON content. Unfortunately, there's not a decent implementation. It's on my `//todo` list. 
Well... we did it, right? We made a synchronous call asynchronous. Wooo! The lesson here being there's no way in Go to prevent the user from calling your code from multiple goroutines. You'd need something like Rust or Haskell to do that. The only thing you can do in Go is document that you shouldn't do that with that API. Maybe you offer another API that does the locking for you. If you can match a good chunk of the API you can even declare an interface that both the safe and unsafe variant can conform to. But you'll still be stuck just documenting "don't do that" with the unsafe variant.
There are several struct tag validation packages. We use https://github.com/go-validator/validator As for DB, I advise having 2 tiers except for trivial projects. Our API has models, controllers subpackages: *controllers* convert to/from HTTP headers/querystring/body. Calls to the models are something like this: func (uc UsersController) Update(w http.ResponseWriter, r *http.Request) { // parse body into your struct var args YourStruct err := api.Parse(r, &amp;args) // If your needs are simple, you could omit models.DB to simplify things and reference // it directly in UpdateByID. Our methods are flexible and can accept a transaction // OR one-off connection and must be passed in. result, err := models.Users.UpdateByID(models.DB, id, args) // reply with result or error } *model* - DB is configured in `init` 
This is awesome! I've been looking for a really detailed explaination of the interactions of Go code and a modern web frontend. Thank you!
I coded in Haskell a bit and I can tell you I wished Go had that kind of solid typeclasses.
Gzip offers a reader, and you can chain readers.
wow, that's impressive. also the https://github.com/cznic/virtual and https://github.com/cznic/ir packages :) what kind of programs is `cznic/ir` supposed to be able to represent? `C/C++` ? `Go` ? others ? any (_ie_ agnostic) ?
This is a project I had for a very long time. I wrote that it can be plugged into any editor, not just vim (just ask your editor maintainer to integrate it or open a pull request yourself. I even created a section on how to integrate into any editor: https://github.com/fatih/gomodifytags#editor-integration). Because I maintain vim-go as well it's already integrated with it. Checkout the vim integration: https://github.com/fatih/vim-go/pull/1204 Any feedback is welcome.
Hello again! I thought about it today and I think I found solution for 4th infinity. Check out here https://gist.github.com/cnaize/c106969508bdd898cc3b5026c110ed65 Any ideas how to increase to 5?
https://golang.org/pkg/crypto/elliptic/ ?
If you'd like common-initialism-sensitive case conversion, please check out https://github.com/codemodus/kace, though, I'm not sure it applies to tags. Also, I wrote it quite a while ago. It works well, but I'd write it differently now.
Have you compared burntsushi toml library vs pelletier/go-toml I noticed burntsushi toml is quite popular and comes up first on a Google search for toml libraries in golang, but it says it's only compliant with TOML 0.2.0 (and has been for a long time) while the pelletier toml library is compliant with TOML 0.4.0, does it matter much?
More specifically: https://golang.org/pkg/crypto/elliptic/#P521
Thanks dave! For now I'm using my own package which already does the conversion: https://github.com/fatih/camelcase I'll definitely check it out if I need something more. 
It doesn't even compile - https://play.golang.org/p/tz8DmEPxsx. Interface type cannot be type of method's receiver. Not sure why do you need such interface. Is it used somewhere else (it's applied to other type)?
I was literally on the verge of writing this today or of necessity. Thanks for sharing. I'm on mobile so I haven't gone through the source yet but my use case is to read/write this file to s3. If there was some sort of hook to add this functionality that would be awesome. 
Why everybody would want to add the `go` and `golang` tags? It's already covered ([look at the sidebar](https://github.com/search?q=topic:tool&amp;type=Repositories)).
&gt; There's also: https://github.com/agl/ed25519 As far as I know https://godoc.org/golang.org/x/crypto/ed25519 is meant to replace that, now that the code has stabilized.
Interfaces provide a compile-time contract that a struct implements the required functions its owners are using. In your example, you'd probably want something like IDeck, aka the Deck interface, which defines the function signatures for its two functions. Then you'd probably want to create a Deck struct, which defines its own implementations of the IDeck contract onterface. Then, anywhere you want to pass Deck, you can use IDeck instead. Then you don't care which Deck, just that it has IDeck's functions. Edit: your example should be: type IDeck interface { Deal() Shuffle() } type Deck struct {} func (d Deck) Shuffle() {} func (d Deck) Deal() {}
The map is the result of getting YAML back from a parser in use by a library that I don't control. Since, by definition, YAML represents arbitrarily structured data, it's hard to get more strongly typed than `map[string]interface{}` without becoming unwieldy.
Just for your information, this looks similar to/like a subset of go-humanize [0]. However, it's more specialized towards byte sizes. [0] https://github.com/dustin/go-humanize
What kinds of implementation applicable as Golang map would have a performance impact?
Thank you! Strangly enouth this didn't showed up in google. Is there a way to use it with ECDSA?
This, plus you do not even have to define IDeck unless the need arises. The beauty of interfaces is that they are satisfied implicitly.
Yes! And algebraic data types. That's all I need in Go.
I'm not sure how much coding experience you have, so please excuse me if this sounds condescending. I'm always happy to see others discover things, and most inquisitive coders go through a phase of testing the limits of their hardware. What you're writing is usually known as a [Fork Bomb](https://en.wikipedia.org/wiki/Fork_bomb) (but in this case the name is slightly inaccurate) and can be written in pretty much any programming language. On Linux (or any Unix, which I presume you're running due to the use of `/bin/sh`) this is usually ameliorated by per-user process limits, defined by `ulimit`, which will hopefully stop the process completely crashing the computer. The inbuilt concurrency primitives of Go make this tempting and easy through the use of the `go` keyword, but remember that goroutines are *really* cheap and don't really count as real threads (`os.Exec` on the other hand, will actually create a true process). Just running `:(){ :|: &amp; };:` from bash will probably rip through your resources faster (for more examples see https://en.wikipedia.org/wiki/Fork_bomb#Examples_of_fork_bombs) It seems that you're interested in infinite recursion, and nested recursion. A question you may want to ask and test is *will nested infinite recursion of such a simple function deplete resources faster than serial infinite recursion of the same function?*. Also, *will the use of the `go` keyword to execute a single OS process deplete resources faster than not using `go`?*. If you're really interested, you should benchmark the various combinations and measure the differences. You'll probably learn a lot about OS process scheduling, the overhead of goroutines, and the inbuilt protections of modern OS's to prevent this kind of program completely crashing your computer.
/u/epiris Big thanks for such exhaustive feedback. I've got your idea regarding *testing.T usage but not quite understand your suggestion on using context.Context in tests. Could you provide some examples? ...and what do you think about snippet below, is it more straightforward? func TestHello_Get(t *testing.T) { // 1. setup test db schema once for whole test run // 2. start db transaction before each test run s := suite.New(t) defer s.Close() // rollback db after each test run s.Factory.SaveOrganization(s.Factory.MakeOrganization()) s.Factory.SaveProject(s.Factory.MakeProject()) s.Factory.SaveTags(s.Factory.MakeTags()...) res, bodyStr, errs := s.Client.Get("http://example.com/hello/").End() assert.Nil(t, errs) assert.JSONEq(t, `{"hello": "world"}`, bodyStr) assert.Equal(t, 200, res.StatusCode) } UPDATE. Here is another version func TestHello_Get(t *testing.T) { // 1. setup test db schema once for whole test run // 2. start db transaction before each test run client, factory := setup(t) defer tearDown(t) // rollback db after each test run factory.SaveOrganization(factory.MakeOrganization()) factory.SaveProject(factory.MakeProject()) factory.SaveTags(factory.MakeTags()...) res, bodyStr, errs := client.Get("http://example.com/hello/").End() assert.Nil(t, errs) assert.JSONEq(t, `{"hello": "world"}`, bodyStr) assert.Equal(t, 200, res.StatusCode) } 
Would really love to see something like [Google X-Ray](http://lists.llvm.org/pipermail/llvm-dev/2016-April/098901.html) which uses NOP sledding to setup trampolines which do some very rudimentary basic tracing (capture function address, args, and timestamp). The cost is negligible when the sleds inactive and about 50-100ns overhead to call the trampoline functions otherwise.
On my iPhone else I would try to run it. Just some ideas; package counter type Counter map[int64]int func New() Counter { c = make(Counter) return c } func (c Counter) isover(id int64, cutoff int) bool { c[id]++ // might also work directly in the if-clause if c[id] &lt; cutoff { return false } return true } func (c Counter) Countover(entry []int64, cutoff int) (over map[int64]interface{}) { for _, v := range entry { if c.isover(v, cutoff) { tryappend(over, v) } } return over } func tryappend(ids map[int64]interface{}, id int64) { if _, ok := ids[id]; !ok { ids[id] = interface{}{} } } Meanwhile, in package main: c := counter.New() over := c.Countover(queryresult, 40) I think the line if i &lt; len(entry) might be superfluous. In general, you want to avoid deploy nested control structures such as this for-if-else-if-for-if. You can usually avoid else-statements entirely by cleverly returning early. However, the most important aspect of the code should be its testability (and the tests themselves); hence packaging. I spend almost as much time refactoring my tests as writing the code (always learning!)
[removed]
Woah, I am impressed with the fact you took criticism eloquently and the results speak for themselves. Your second example is a world more clear to me. Everything I need is right there in the test, I can immediately identify setup code by scanning the first t, then follow it through validation. For context usage, if you have an app that uses context a common pattern is below. Sometimes I'll define a root ctx that has some test common test values in a parent test for use and in subtest or as a global var. Basic example below: TestReq(t *testing.T) { ctx, cancel := context.WithCancel(context.Background()) defer cancel() client, factory := setup(t, ctx) // setup started a goroutine it can end when the test // becomes done so you don't leak resources } There are lots of ways to change the above pattern depending on your needs, sometimes I have a testCtx(t) helper that might return ctx and a cancel func that also cleans up my tests if it makes sense. func testCtx(t) (context.Context, *testCase, func()) { ctx, cancel := context.WithCancel(context.Background) tc := newTestCase() return ctx, tc, func() { defer cancel() // tear down my test } } Lots of ways to play with stuff, just an example. The big thing is just staying local when it's not shared and having a small call stack, least for me. Have a good one! 
I really enjoyed the nuanced bit about when an interface value is actually nil. That seems like a major gotcha of the language, especially considering how error checking is done.
Is the order of the list important? If not then just feed stuff into a map[id]item.
A front-end may only want to show the first error encountered rather than every error in order to simplify return handling. It would also minimize back-end processing. Further, if every error should be shown, enabling the error return to be valid json could be helpful.
&gt; I think the line if i &lt; len(entry) might be superfluous. You may be right. I put it in there because of the following for loop going from i + 1. If already at end of the length of the entry slice, that'd lead to an out of bounds. But now that I think about it, the... for j := i + 1; j &lt; len(entry); j++ ...line won't actually do anything if i is equal to length of the entry slice.
The order is not important in the slightest. I'll sort later anyways. Thanks for that snippet, I'll give it a whirl! Not used map yet, I'm fairly new to Go - having only tinkered with it for about 6-7 months or so.
I'm not sure how common this is (returning the first error only) for validating data in the backend. From REST API design perspective, you would want to indicate every invalid field rather than giving it out one at a time. Anyway, to achieve what you need, it's just a matter of filtering "Errors" and returning only the first error. The "Errors" type already implements "json.Marshaller" which allows it to be serialized into a proper json object.
I wouldn't say anything you do it stupid, but I would add some things to make my life easier. I tend to keep packages self contained. You seem to know what MVC is (in terms of general principle), but you seem to mix the "model" part with whatever is in your database package. On paper, the database package could be reusable between many projects, but in reality it's tightly coupled to your app and doesn't stand on it's own feet. This is why a lot of Go developers seem to recommend just keeping with a no-packages single repo. My advice to you would be to split the actual model part to be more tightly coupled with what you have in handlers. I'd suggest to go with `user.go` and `user_http.go` to separate the model part (database/user) and the http handler (controller/user). Either way, I'd move user.go to the controllers. As an example I can link to a book sample from my 12FA with Docker and Go book: https://github.com/titpetric/books/tree/master/12fa-docker-golang/chapter7 (handlers are in api/, self-contained service clients are in common/ - the naming is poor, but sufficient). There's also the question of how you handle configuration. While I can't say I found "the best" way, generally the best argument is for your code to be testable. This means that the configuration for a database connection should come from main() - either with environment or like the example, using `namsral/flag` (environment/command line flags) or more complex configuration libraries like viper, which also support reloading - https://github.com/spf13/viper - something like this makes your code testable, meaning you can supply configuration from your test code, and not rely on outside files to get credentials from. I know there's something about my example feels wrong - mainly because the Redis struct handles not only the connection to Redis, but also "Save", storing of this connection to be made available to api handlers with `GetRedis`. The "better" way would be to split redis into two parts - a redis connection pool and a redis client. The redis client is by itself nothing else than that. main() would create the connection pool and add the default redis connection, while apis would just get the active (or even named!) connection struct from the pool. The alternative is somehow to make all the connection configuration accessible to apis, however without structuring them (which is possible), I would suspect that it's just more verbose and copy/paste. Duplicating connection setup code in every api is not what I feel comfortable doing, so I'll probably refactor to pool/client I'm mentioning. When it comes to testing, you'd just set up a Mock client into a pool and run your data layer functions as you would. Finally, I'd suggest going with a front-end mvc like Angular or Vue (my vote goes for Vue due to size/docs/simplicity). Go templating while rich is just slower in terms of development time, and templates are quite tightly coupled with what you get from Go code. With Vue you get a richer front-end layer that is popular enough to get developers for it. Imagine you actually built your own Reddit as a company - it's worth it already to enable a different calibre of developer to join your team and split some responsibilities between front and back-end. Maybe it's also my preference because as a Go developer I don't like to mess with HTML in Go code, and vice-versa as a HTML developer I don't want to mess with Go code. Having API driven development practices pays for itself twice over even before the second developer joins the team. I'm drifting into non-code review territory, so this would be a good end to the comment :). Good luck with development in Go, it's really really great. Far more rewarding than Node, anyway :)
 Cool, thank you for the in depth reply! I'm excited to explore your suggestions. &gt;With Vue you get a richer front-end layer that is popular enough to get developers for it. Imagine you actually built your own Reddit as a company - it's worth it already to enable a different calibre of developer to join your team and split some responsibilities between front and back-end. Yeah, I think if I was planning on hiring someone I would use Angular or something. I just personally do not like Javascript, at all, so I'm trying to get away with as little as possible. I'm experimenting with using Go Templates as Components, which has been working ok so far. 
It's a little odd to click the link and then not see who uses it.
The "Motivation" should give an answer to that question. &gt; The generics discussion keeps turning up on the forum with the same points being argued over and over and over and over again. This document tries to summarize all the details, as well as the arguments for and against generics. Things will be added as new comments or suggestions arise. &gt; &gt; This is not a proposal nor is it here to argue for either side of the debate; it is designed to collect all the arguments. This is here so that people can go over the relevant points without digging through hundreds of forum posts and repeating the same statements, questions and answers. If you notice something missing, please add it. tl;dr; It's a "Summary of Go Generics Discussions".
In fairness, I wrote a PHP template engine (https://github.com/titpetric/minitpl) and I like ERB style template engines (or EJS in javascript) which expose the full language syntax with which you're working with. I tried egon in Go for a similar approach (and even patched it up a bit https://github.com/titpetric/egon) but what it does is compile templates with external tooling which I'd love to be able to hook into a simple `go run` or `go build`. I realize that Go is a language that compiles, but coming from a PHP/JS background where "anything" goes, the templating is too restrictive for me. So I tend to keep it where it is flexible, and that is Vue/JS/Front-end in this case. Anyway, I am not very much bothered about it, I seem to have resolved it pretty well, and I ported much of my MiniTPL syntax to EJS as well, so most of the time I'm not even learning a new template syntax - which is why I stay away from things like MustacheJS and similar. Pseudo-templating languages are the worst, and I can only wish to have either the same templating language everywhere, or exposing each programming language primitives and syntax in full, which Go unfortunately doesn't give me with their template packages :(
Hello! Overall, code is pretty reasonable. I think the biggest problems are globals, and use of `util.Check(err)`. - Outside of your `main()` function you should almost never have code like `util.Check(err)`. Code like that takes control flow away from the caller. This is not good for refactoring, reusability or testing. In general you should *always* return errors. - You have a number of of globals, eg. `database.db`, `database.sc`. These are almost never a good idea. They complicate testing, reuse, and reasoning. - Your handlers use globals indirectly via `.Insert()` methods, etc. You can avoid this in two ways: make your handlers be member functions. eg. Instead of `func Boards(w http.ResponseWriter, r *http.Request)` have `func (c *Controllers) Boards(w http.ResponseWriter, r *http.Request)` where `Controllers` is a struct with a `*db.DB` member. Secondly, change all your database access functions to accept a `*db.DB` parameter and use that rather than the global. You could also wrap `*db.DB` in your own `Database` type with these functions as convenience methods. eg. `db := database.New(...); db.GetComment(id)`. You could then use this in your `Controllers` struct instead of a `*db.DB` directly. - Methods on structs should almost always^1 have a pointer receiver. ie. `func (c *Comment) Insert()` rather than `func (c Comment) Insert()`. Why? Because Go passes by value, and the latter will receive a complete copy of the Comment. This is a) slow and b) confusing when you attempt to modify the receiver, as the modifications will not stick. - Similar to the above, struct fields, and slice elements that are structs should almost always be pointers to structs. ie. `Comments []*Comment` not `Comments []Comment`. ^1 - Use `log.Print*` rather than `fmt.Print*`in modules. Only use `fmt.Print*` in your main function, for the operator. - In some places (like [this](https://github.com/brwhale/GoServer/blob/master/database/securecookie.go#L21)) you are not checking errors. Use a static analyser like [errcheck](https://github.com/kisielk/errcheck) (or just use [gometalinter](https://github.com/alecthomas/gometalinter) - shameless plug!) to pick up issues like this, among others. --- 1. There are *occasionally* reasons to not use pointer receivers, but when starting out with Go it just adds confusion. Stick to a simple rule to start with: *always pass structs by pointer, pass everything else by value (slices, maps, string, ints, floats, etc.)*.
I'm on mobile so I might be missing an obvious link, but is wandering lunch on GitHub? Super cool idea, I'd love to see how you pulled it together. 
Ahh! Awesome, that pointer receiver thing actually clears up a big point of confusion, now I should be able to make GetChildComments 3n time instead of the recursive function which takes god knows how long. Also, the globals were intended to become injected dependencies, but I wasn't sure the best way to go about it in Go. This was actually my main reason for this thread. Big thanks for the description! In a few places, like inserting the securecookie, I didn't check the error because I was treating those calls as "fire and forget", in these cases is the best practice to log the error and move on? Thanks super hard by the way!!! This is amazingly helpful.
The name. 👏
Can just link it to `https://godoc.org/{{your project}}?importers`
That is really awesome! :) 
That is true, but the data is user-defined in this case. There is no schema that the application can be aware of because users don't provide one.
Forgot to post this here last week after it's rewrite, so just letting anybody who's uses it, know about the changes. Direct link: https://github.com/radovskyb/watcher.
Wow. Thanks for this
Haven't tried this yet but I can't see why not.
awesome thx. I'll give it a try tomorrow and report back.
&gt; Unfortunately there is no VIM integration available. https://github.com/jodosha/vim-godebug ? [Disclaimer: Haven't used it.]
&gt;What will you do with your extra 330ns and 144 bytes of memory? Bug on any non-ASCII symbols when reversing 
I suspect that `go main.go` won't work.
Correct, updated now
You could add a client, replace curl and add end to end encryption, secure id's and tls. Could be a handy tool to securely send a file somewhere.
This is smart. My first instinct would've been what somebody else posted, which is to create a set of all the distinct IDs then turn that set into a slice, causing multiple passes and another alloc. Nice once.
Thanks, I got this error check from "Go by example" I use other checks occasionally but will try to come up with something better in the future. Nice pointer, I'll try to reduce the indentation. 
Seems not to work for `gopkg.in` import path? We can use the `github.com` one, but I think a smaller number of projects, since `gopkg.in` if more often the recommended way of importing? Anyway, awesome project!
Are you importing "testing" into a non "_test" package/file?
I don't think Russ Cox or Rob Pikes are big fans of C++, that's why they made Go, because they wanted Google engineers to code the C way.
This sounds similar to sendto, a little service I put up last year: https://sendto.click https://github.com/send-to/sendto which has a server and client to send files. The sending client and server don't know how to decrypt, only the final recipient.
Feedback in the spirit of learning Go: 1. There's a lot of places you're skipping over errors. In this little application it may not much matter but in real code this will drive you mad. I suggest running [errcheck](https://github.com/kisielk/errcheck) over your code. 2. You've got an unnecessary reading of the network stream into a byte buffer. Try to rewrite saveFile in terms of `io.Writer` and `io.Reader`. Have a look at [io.Copy](https://golang.org/pkg/io/#Copy). Similarly in the retrieveHandler, you can open the file and the just io.Copy it out rather than having to read it into a buffer. 3. You've got some excessive goroutine spawning; I don't think the `go` on line 43 (as I write this) is doing anything useful. And just as a general note, while flinging a file over `nc` is fine for this sort of thing and I don't mean this as criticism of a "first project" per se, please be aware that on the general network that will fail, in proportion to network congestion and the size of the file, which basically means "quite often". It's also a bit problematic that such a protocol has no room for a file name.
Thanks a lot for the feedback! I was trying to recreate termbin, a similar service, and that's why I was using NC in the example. I really just wanted to mess around with networking in go, as it looked interesting :) 
Interesting approach to tackle the problem with ppk. However this approach has the downside that a public key must exist. Good work though.
exactly as it should be
I think it is fine actually https://play.golang.org/p/0PIdsaL0_R The thing is it reverses it and then it reverses it back. I think it would break if it just reverses it but by reversing it back it makes it all good. Do you have a specific error case?
No, I misunderstood the situation. Thank you.
Thanks for the link. My google-foo seems to be weak these days. Googling for "vim go debug delve" this page doesn't show even 3 pages deep. I will give it a go and report back. 
This is a great package and will be using it. Good to see also a good use for boltdb. 
Far better than the original.
`interface{}`, `interface{}` everywhere.
Yeah it would be really nice if it could merge the # of results for gopkg.in versions and github imports. I suggest my library users to import via gopkg.in, but I've definitely got a mix of importers and it would be nice to see the total #.
I really hope rsc gets the ball rolling on generics in the language. There's quite a few places in the stdlib already where it's obvious such a feature is needed.
[Golearn Examples](https://github.com/sjwhitworth/golearn/tree/master/examples) [Gorgonia Examples](https://github.com/chewxy/gorgonia/tree/master/examples) I also use Gorgonia for a lot of NLP related stuff
How does that reload your code for dev without having to rebuild the container?
I don't have Stack Overflow, but I think io.Copy uses a 32k buffer by default. It doesn't copy a whole file into memory. Also I think there's a copy function for passing in a buffer of custom size. 
So is Gorilla mux ok for production? I've seen some post that it takes a lot of memory and it's not performant. 
And you could make a go generate tool that generates this for you with a line like this `//go:generate syncmapgen mymap -key foo -value bar` 
1. You've hidden all the `interface{}` behind an API, but the itnterfaces are still there and you're still paying the runtime cost for them. Plus a little bit of extra overhead for the wrapper methods. 2. If the best way to accomplish a common task with a library is to copy-paste a screenful of code, someone somewhere has failed to understand the purpose of libraries.
Dotting for follow ups 
Yes, there are several tools for generating Go code using templates that you could use for that. 
io.Pipe and a small goroutine and you're good.
&gt; In a few places, like inserting the securecookie, I didn't check the error because I was treating those calls as "fire and forget", in these cases is the best practice to log the error and move on? Yes, exactly. Sometimes, even if you don't expect something to fail, it can, and you want to know about it when debugging.
How would generics solve this problem? Would you create define a `sync.Map` implementation for every generic?
This looks really cool. Im going to try this in place of the aws cli for quick one-off items as, suggested in the "why". I don't know if I would feel confident managing my infrastructure with the templates, versus terraform. 
[code](https://play.golang.org/p/DYwOcoAQbs) I saw fizzbuzz implemented using maps in Java. I got curious about go lang as well. Yes, access is randomized. 
 mySyncMap := &amp;sync.Map&lt;string,int&gt;{} mySyncMap.Store("foo","bar") // will not compile at first place Just like when you define []string{} , you can't shove an integer in it and expect it to compile. 
The CoC isn't enforced in anyway at first place, which made it useless. All that drama was a waste of time, thanks to people who wanted this...
&gt; You've hidden all the interface{} behind an API, but the itnterfaces are still there and you're still paying the runtime cost for them. There has been, so far, exactly zero indication of what is going to happen in that regards with generics in go. The simplest implementation would just do exactly this. &gt; Plus a little bit of extra overhead for the wrapper methods. They really should get inlined. If they aren't, that should be fixed in the compiler. &gt; If the best way to accomplish a common task with a library is to copy-paste a screenful of code, someone somewhere has failed to understand the purpose of libraries. I neither believe this would be "the best way" (it would just be a way to shut up people who are being pedantic that containers would need type-safety), nor that it would be a misunderstanding of the purpose of libraries. The library is still hiding all the complexity and subtlety of the implementation that makes code-reuse desirable. The wrapper is trivial and pretty much impossible to do wrong, so who cares if it needs to be copy-pasted-string-replaced?
I have an rsync script for this. 
I use https://github.com/pressly/chi and I'm happy with it : * Simple * Uses `context.Context` * Modular and pluggable thanks to a regular `http.Handler` 
Do you mind sharing how you see and deal with conflicts? This is one pain point of mine.
Could it be broken in the case where a second or subsequent byte of a rune == '.'? 
Git for the whole Gopath?
&gt; The simplest implementation would just do exactly this. That would be disappointing to say the least. &gt; They really should get inlined. Except the Range lambda thing. &gt; The wrapper is trivial and pretty much impossible to do wrong, so who cares if it needs to be copy-pasted-string-replaced? That's what the Java guys said, too. Now they use Eclipse as a language crutch to auto-insert their `Calendar calendar = Calendar.getCalendar();`s. 
Oh I see. Well, to be honest, I've never used multipart before. But `os.Stdin` is an `io.File`, which is an `io.Writer`. Instead of using `body` to create the new `Writer` you could just pass in `os.Stdin` directly, eliminating the call to `io.Copy`.
Looks cool. I have just installed it on my Mac but can't figure out how to use profiles with the tool as I do with the AWS CLI. Any input?
No, it shouldn't break in this case either, as the second and subsequent bytes in a UTF sequence are all &gt; 127, so none will match '.'
Why would you sync the entire GOPATH? Just use VCS for your own projects, and use `go get...` to pull your dependencies.
I just updated this issue. We will add very soon the support of other profiles.
I only can recommend mine. ;) We use it in production too. Take a look at https://godoc.org/github.com/tideland/gorest. 
Looks good I was just looking for a cross platform library for FS notifications. Does this package have any advantages over fsnotify? 
anyone tried this? https://github.com/TykTechnologies/tyk
1. Use the "Format" button before sharing play ground code (and use `gofmt` on your own code). 2. You are wastefully creating a new map on each function call. 3. You are not terminating the function after finding a multiple and printing the word. 4. Due to un-ordered map this approach will not work. A slice such as `[]struct{int, string}` could be made to work but see 5. 5. Maps are not the appropriate tool for this problem. E.g. see [a RosettaCode solution](http://rosettacode.org/wiki/FizzBuzz#Go). [Also, [Fix for 1−3](https://play.golang.org/p/oUUDRH7wqG).] 
[Link](https://groups.google.com/d/msg/golang-dev/t__fRKrm2sw/7D7961MnBgAJ) (for those of us who missed it).
Yes, this is a bug. Thanks for reporting it. I created an issue on our tracker (https://github.com/wallix/awless/issues/34) and we will fix it soon. 
what bugs me with this one is that I can't have `/route/one` and `/route/:param` at the same time. EDIT: formatting
That's a feature, not an annoyance!
That and docker makes it easy encapsulate third party packages that your codebase might need. For my particular use case, I store docker containers in AWS ECR and spin up services/tasks when needed compared to paying for a server to always run my binaries. 
`awless` looks pretty impressive, nice. I've been using [terraform](https://www.terraform.io/) for some of the things that `awless` provides — u/hbbio, would you happen to have any comments on whether you'd looked at terraform but ruled it out for some reason?
Yes! these issues have been bothering me for a while: https://beta.golang.org/doc/go1.8#encoding_json
I don't understand your problem. You find it frustating to keep the dependecies of a project in sync across multiple machines? Isn't that where the `vendor` folder is for? 
How do you manage moving your patches to go get-ed repos between your own machines?
That's the most simple idea I heard so far, thank you! That would definitely take care of the syncing. However I find it exciting to try to store the gopath under version control to roll back incase I do something and it does not work anymore.
How do you manage syncing patches you made to your other machines?
I understand your solution, I don't understand the "don't do that". Cause it's too complicated to have lots of git repos managed? Ah let me explain. This repo would hold all the other git repositories and their files. It would add commands like - cmd snapshot - cmd checkout - cmd status etc.
I'm using gorilla mux for my rest api.
&gt; why Dave Cheney "has moved on to other things" according to the official announcement? Source?
 sudo rm -rf /usr/local/go curl https://storage.googleapis.com/golang/go1.8.linux-amd64.tar.gz | sudo tar -C /usr/local -zx 
If you don't mind, I have a package for generic(-enough) tensors . I'd love a linter around that. I've come up with some ideas [here](https://github.com/chewxy/gorgonia/issues/81), but I'd like your input on that
[This](https://github.com/EnterpriseQualityCoding/FizzBuzzEnterpriseEdition) might provide some inspiration.
I'm pretty sure this will make your OS package manager freak out eventually.
That will no longer be AWS ECR cost. ECR is just used to store your docker images, not running them. For your example, you would have to use ECS(Elastic Container Service) which does pricing based on what AWS resources you use. So, if you want to store GB of data, you would probably use an EC2 instance that you configured with x amount of storage. 
I'm using Gorilla/mux. It's super simple and straightforward and does everything I need. Chi looks more complex, so it might be better for a larger more complex Api? The way routing works though in Go, it should be easy to change packages if you want and just drop a different router object into your http.ListenAndServe call or your server setup. see https://github.com/brwhale/GoServer/blob/master/server.go#L50
&gt; you would have to use ECS(Elastic Container Service) which does pricing based on what AWS resources you use. Oh I see. Thanks for the explanation. I always wanted to use AWS but their pricing model is so complicated and there are so many options. It feels like filling up a tax form or something.
&gt; Neither C nor C++ are garbage collected nor safe. Go is memory safe Very much true observations and very much what I said above. &gt; it's a garbage collected C. No, it's a garbage collected Google C++. Honestly, I recommended above and I do it again, to read the Google C++ style guide. You'll see, what I mean and why your assertions simply do not make sense.
Haven't looked into tianon/true, but looks useful. I just like having the same Dockerfile for dev/production so I can use it with with docker-compose to build a multi-service project for dev or production just by changing one command.
Unless you're on OS X, in which case you'll probably piss of homebrew!
:P
Follow the link at the end of : https://groups.google.com/forum/#!topic/golang-nuts/sCOew-884UA which leads to: https://go-review.googlesource.com/#/c/36450/
Thanks I totally missed that!
Yeah, although it sure can get confusing if you also manually install packages in /usr/local! I really wish OS X had a real package manager.
Every one of the days when a Go1 API proves non-ideal is a sad day. I'm looking at you, https://golang.org/pkg/net/http/#Request.Context Now, stuff that has already proven its worth, that's more up to licensing.
No, this was just the commit tag.
Ah. Thank you. Makes sense to drop support when the vendor does.
`rustup update` is for Rust.
&gt; Such a disgrace. I do not like your tone but it is true that Go could use some kind of tool to help automate the update of the installed version. The first step to have a default GOPATH location is done. I think Andrew was brainstorming some kind of tooling that would help less experienced users with the procedure.
Just use `gimme`.
&gt; Just use gimme. What is that?
It's called a "package manager"
This kind of hostile approach to the discussion of generics isn't really helpful. The on going discussion regarding generics makes it patently obvious that people (including Russ --&gt; https://research.swtch.com/go2017) are aware that generics are wanted, but, as before, it's a hard problem with no obvious solution for implementing it in go. I recommend you read the section 'Generics' linked to in the post above. &gt; It’s been a few years since we ventured out and explored the design space. It is probably time to look around again, especially in light of the insight about mutability and the additional examples set by newer languages. I don’t think generics will happen this year, but I’d like to be able to say I understand the solution space better. ...seems like the right way forward, not closing our eyes and clamping our hands over our ears and shouting "go go go go" without listening to what anyone else is saying.
Looks like a top down view of someone on the toilet.
It's very much unlike any other code using context, because of the Go1 API freeze. This is why code goes to stdlib to die; it's hard to evolve it, while retaining the desirable properties of stdlib.
An upper decker.
HTTP request dispatchers (because "routers" are things one mounts in a rack) are just a magpie developer phenomena. Web devs write them because they saw someone else write one, and they can. Once they move on to the next shiny thing, almost all of those projects will bitrot away.
Yeah, their docker services are also not very intuitive, especially if someone has very little experience with how AWS works. 
&gt; Web devs write them because they saw someone else write one, and they can. Once they move on to the next shiny thing, almost all of those projects will bitrot away. Possibly but that doesn't change the fact that they cause fragmentation and the other problems I mention since unfortunately the "standard" way to write Go is to use a 3rd party 'HTTP request dispatcher' and not the standard library one.
Sorry, but... FAIL
&gt; I just ran sudo pacman -Syu and got the update to Go 1.8 and the go tools (godoc, gorename and so on). I do not need it myself necessarily. It is to help newer users. Great you did it with one command. Now tell me that one command for windows and MacOS. That tool would help install and update Go and it would be the same for all platforms. Andrew Gerrand was working on something like that.
Ah, it took me a moment to see it. I like the style. Would like to see more versions.
Are their a lot of developers that use system packages for anything that isn't related to the window manager or desktop environment? Not asking in a snarky way I'm just curious, doesn't seem worth any of the restrictions given how simple it is to setup dev envs for every language.
I'm certainly not wanting to have another generics debate but I've been thinking a lot about the need for some kind of language annotations outside of struct tags. It would be great to not have to use comments for things like this. I have also been thinking that template methods might be the way to go. Annotations could then be used to define constraints for the template. A simple precompile step to generate the needed code based only on the usage could be added to the compiler chain. I can't imagine this would have too big a cost in compile times. 
&gt; Now tell me that one command for windows and MacOS macOS: brew update &amp;&amp; brew upgrade go Windows: choco upgrade golang For Windows I believe OneGet is an option as well, but it requires the Chocolatey provider anyway. 
My intents weren't to kick up a generics debate, I rather not have them in the language unless they are implemented in a simple to understand way (looking at you C++ templates) This came mainly from reading about java generics which essentially just checks the type at compile time before down casting to object to give it type safety (with some caveats). That's not really difference from asserting that a given function/structure field is of a specific type with a linter. I'm not too keen on comment annotations either but they are what we currently have. While I hate how slow heavily templated C++/code can be, I would actually prefer that kind of code generators to the way Java and C# does it. Binary size doesn't bother me too much. We already have generators, they work pretty well. But many nayseyers just don't seem to think that you can do everything with them that you can do with "real" generics. If there was a linter that did it the java way then they have one less reason to go "lol no generics" Of course for the stubborn, the argument will always be "it's a third party tool, not part of go".
I have been got gopher's doll at go1.8 release party. So, I am very happy!! Happy release go1.8!!
Here are the tasks marked for 1.9 so far. This will be in flux, of course, but it's a good place to see where the biggest focus will be. https://github.com/golang/go/milestone/49
I don't see it as hostile. The author of the repo has an opinion, and is expressing it in a cheeky way. To be honest, I agree with the authors sentiment. At this stage, we all have an opinion on the need for generics, but no one has put forward something that fits, yet. Personally I don't see the need for generics in Go, and the simplicity of Go is a huge bonus. I see a lot less "clever" code in Go, than I see in most other languages. I like it as it is. Clear and simple is fantastic to live with, long term.
Yes? How many third-party dependencies do you make changes to that this is an actual problem? How many different machines do you use to work on the same code?
my association is someone inserting an ostrich egg into their rear end…
How many would you change incase it would be effortless?
I use the package manager for everything that isn't go. a) It's annoying to need dev environments and b) it's stupid to opt out of the benefit of other people maintaining your system and applying the updates and security patches. If something isn't packaged I will usually just end up not using it, because ain't nobody got time for that BS.
I'd *really* love to see the standard library support verb + path, I have a hard time recommending it since it's missing such basic functionality.
Do you disagree about the verbosity? How easy is it in your team to create a new endpoint to a service? nobody never complains? Just asking, because I'm really curious how is it working well for other people.
&gt;I'm still investigating trade-offs. https://www.random.org/analysis/dilbert.jpg 
&gt; I'd really love to see the standard library support verb + path Same here more or less. Russ Cox has said before that the aforementioned approach has [problems with scaling](https://groups.google.com/d/msg/golang-nuts/T6lJ5iXwyjw/VxwsrqgcrCUJ) yet I can't help but wonder if there is a better solution. &gt; I have a hard time recommending it since it's missing such basic functionality. I recommend it nonetheless. Slicing the URL path to get the key is just 1 line of code anyways.
It's good to learn and experiment with cryptography, it's just important to do so responsibly. This means adding a disclaimer that it is a learning experiment and not created by a cryptologist so some junior dev doesn't decide to copy paste it for web scale. There are multiple flaws with this and even with them fixed I wouldn't use this. I mean dude.. did you even look at your iv size relative to your buffer? Do you think maybe your web scale performance might have to do with generating block size of rn + 1008 bytes of zeros? Might as well be 1024 zeros as far as security is concerned. Lol :) edit: When I looked at it I could have sworn I saw your IV was 16 bytes- the correct block size for AES whilst the destination buffer was 1024 and it looked like you could end up with short writes to buf, a write to dst that exceeds src would be zeros. Random initialization doesn't change the fact it would be a constant. Regardless whatever the code is now is fine, the len(src) == len(dst) and uses the same buffer. By fine: I mean it is not writing lots of zeros, it still suffers from being a block cipher which does have properties for being suitable for a PRNG, but too nuanced for reliable usage as a CSPRNG- harder to justify usage when you consider that it depends on a reliable CSPRNG for initialization. I think in your use case it's fine though and since you added a disclaimer thumbs up man, have a good night.
entropy tests verify the output is random :) I'm not sure I understand your comment about the IV, the IV has to be the same size as the block, which in this case is 16. I've added initial randomization to the buffer for s3cur1ty even though I'm pretty sure that doesn't affect anything. I've added a disclaimer. anything else?
&gt; Microseconds or Milliseconds don't matter Well, if your concern is about performance, then yes, the unit of measurement and the overall timing do matter :) For example a *100% increase* in latency from 0.0001ms to 0.0002ms wouldn't concern me, but a 10% increase from say 10ms to 11ms might a little more. This slowdown https://github.com/golang/go/issues/18964 is actually a great lesson about just how worthless microbenchmarks are. Not sure if people will learn that lesson though. If this is your only concern about 1.8, I'd jump in - the water's fine, some large sites have been testing it and finding nothing but performance increases (GC and CPU time). 
&gt; IBM is already committing significant resources to Go It looks like, they're also actively working on implementation of packages for backend development in Swift: from HTTP server &amp; web framework [1] to crypto and DB drivers [2]. [1]: https://developer.ibm.com/swift/kitura/ [2]: https://github.com/ibm-swift/
[link to the presentation itself](https://docs.google.com/presentation/d/1OT-dMNbiwOPeaivQOldok2hUUNMTvSC0GJ67JohLt5U/pub?start=false&amp;loop=false&amp;delayms=3000) just skimmed threw it, layout of the slides are quite unreadable...
I wonder if your approach is covered [there](https://docs.google.com/document/d/1vrAy9gMpMoS3uaVphB32uVXX4pi-HnNjkMEgyAHX4N4/edit?pli=1#). If not, maybe it worth adding / discussing it there? The sort-of canonical link to that document is [this](https://github.com/golang/go/wiki/GoVsGenerics).
 int x = 0; while (x &lt; 2000000000) x = plusone(x); In my opinion this benchmark is weak, given the results I'd be batching my C-calls instead of switching to a language with less overhead.
Stack-as-a-service?
Looks like someone in a swimsuit is breeding a giant egg
It's the verb I'm missing more than params...
Hah no :) Would be awesome without CGO but I don't see how given that you need to call proprietary APIs on macOS and Windows.
My different tests indicate 1.7 has x2 overhead compared to 1.8.
Currently trying to generate structs that marshal into compliant xml yes.
But we have to consider that at some point (can't remember if it was 1.4 or later) the overhead had increased substantially and we haven't recover yet. 1.8 is still way slower than earlier versions.
Flagrant misuse of the empty interface detracts from the value of using a static type safe language. Now, the burden becomes runtime problems. Humans are arrogant, clumsy, and forgetful, mechanisms like static type safety help humans(me, but apparently not you, however, the majority of humans) make less programming errors. 
Yeah, you should really measure runtime using the `clock()` function instead of `gettimeofday()`. The result of `clock()` is how much CPU time has elapsed whereas `gettimeofday()` also advances when your process isn't running.
[removed]
Weak in what sense. It's trying to measure FFI times, I think it accomplishes that, and it's not a meaningless metric.
The main benefit of using upper-db over other solutions is our goals: we try to focus on improving productivity. Writing SQL by hand takes time and developer time is expensive, we don't think writing and debugging simple queries by hand is a benefit when you can do the same with less effort. So, upper-db takes the repetitive tasks out of the way and when you really have to come up with some SQL magic upper-db will allow you to do so. We still use SQL everyday but only for complex tasks where spending time writing SQL makes sense, we don't bother anymore with writing SQL by hand for common CRUDs. If you want to see a live example, we have a (read-only) playground here: https://demo.upper.io/p/e0ff798ccff065a08cace708e358d017711c8479 or a list of examples here: https://upper.io/db.v3/examples
What you are looking at peeps, is the recipe for disaster. Honestly, stay away from the shite that is called ElasticSearch and MongoDB.
It is reseeded every run, initial seed/iv provided by crypto/rand.. the AES hardware optimization is what motivated it's creation :)
 __ __ _ \ \ / /__ ___ ___ | | \ \ /\ / / _ \ / _ \ / _ \| | \ V V / (_) | (_) | (_) |_| \_/\_/ \___/ \___/ \___/(_) Edit: * i hate markdown
GET, POST, PUT, DELETE, etc.
Oh I see! Personally I see very little value for verbs. A switch on Request.Method is sufficient. For keys I can understand the need though.
`go forevever alone`
Elasticsearch is pretty good.
A bit off topic but I disagree with the "don't roll your own crypto" sentiment. Sure cryptography is a very demanding field. Sure it is critical and the security implications are very serious. Sure the developers should understand that, and **avoid** improvising when it comes to cryptography in a mission critical environment. But the way this "don't roll your own" meme has prevailed and used almost in all cases when we approach the topic of cryptography it actually discourages people from getting involved and learning about crypto. I believe we should encourage people to cut their teeth in crypto. Lets not end up in a situation where have turned the next generation of developers away from this vital field. Small projects like this is a great way to get someone interested in crypto, even if the design has obvious shortcomings and it is not cryptographically secure it is a useful learning experience.
I'm often shocked by the lack of understanding on the subject by many.That the compiler already does this for the builtin container types, and doing this for non-builtin types shouldn't incur any different compile time penalties. 
https://github.com/kmatt/go-generic/issues/3
&gt; I could probably have feathered the cutout a little better, but a little voice in my head told me that shittier is the way to go here. Gold.
&gt; It's a few keystrokes to git clone &amp;&amp; ./all.bash. The effort is in keeping up to date on *when to do that*. Getting all important updates timely, while avoiding breakages. This is the value added by a package manager, not the difference between typing `apt-get upgrade` and `make &amp;&amp; make install`. &gt; For anything connected to the internet- if you are relying on software updates to stay secure your system is not secure. You can not seriously believe, that updates are irrelevant to security. &gt; Any of my internet facing software packages could have a remote code execution vulnerability in the next hour and I wouldn't care. [You should, though](https://en.wikipedia.org/wiki/Defence_in_depth_(non-military)) &gt; What is my inconvenience for this security? Nothing, I download a prebuilt binary and configured the applications namespaces, cgroups env vars, launcher, whatever other tiny details and run it inside a stateless vm or container. "What is my inconvenience? Nothing. Just this massive amount of work I need to do and tune every time something changes" Again, if that works for you, that is fine. But the answer to your original question &gt; Are their a lot of developers that use system packages for anything that isn't related to the window manager or desktop environment? is "yes". Most people, developers or not, value their own time too much to not accept the convenience of having other people manage their software.
That's not a very Chris attitude.
As a developer ES is fine. As an operator (devops, etc), ES is a *nightmare*. It takes a lot of experience with ES to get it running reliably under load in production. Just reading the docs for 30 minutes and throwing up a cluster is a guaranteed timebomb. Unfortunately there's no great alternative. Solr has it's own issues. Probably a hosted ES service is worth considering for most (AWS, etc). edit: since this is a Go forum, maybe https://github.com/blevesearch/bleve ? But I have no experience with it.
You should benchmark it against the xkcd one, since it's just as trustworthy: func GetRandomNumber() int { return 4 // chosen by fair dice roll. // guaranteed to be random. }
there's an entropy check in the readme?
There are a ton of differences between the Go plugin and the IDE, you can find some here: https://www.jetbrains.com/help/go/1.0/faq.html#d3e52 Among big missing features you can find things like type-aware inspections, completion, interface stubbing for types as well as navigation to / from interface implementation, the recently released support for basic C syntax highlight, run gofmt/goimports on save and a host of others, see: https://blog.jetbrains.com/go/ There's also another component: Gogland is for now in EAP and will only get better, the open-source plugin doesn't get much development these days and there could be some time until the other IDEs get the Gogland-equivalent plugin for them. Hope it helps.
Sure, there's absolutely zero doubt that you could write an entire HTTP package from scratch, on the extremely low-functionality end of the spectrum. :-) Just saying that it's convenient as hell to be able to say "when a PUT is received on this path, run this function." httprouter does a bang up job of that, and is fast as well, and provides path params and query param handling as well. Best part, it's 100% code coverage tested and is stable as hell. Well worth the dependency risk, IMNSHO. :-)
[removed]
I've used opencv haar cascades quite a lot for face-detection (since it's so conveniently available and even comes with a pretrained .xml...) but unfortunately the performance is really not that great... it tends to detect faces where there are none, and often it detects a face in sorta the wrong location etc. I'm using all the different haar cascades for face detection that come with opencv, btw, both the multiple frontal and the profile ones (and then I coalesce multiple overlapping matches into one region) I'll probably be looking to replace it with something based on tensorflow or so at some point in the future...
How would reading the [Fortuna paper](https://www.schneier.com/academic/fortuna/) and implementing it in Go *not* do everything you say? How would doing that not be far superior than throwing together some crypto-primatives and implementing something that appears to "work" but is massively flawed, most likely in ways the implementer would never know or learn about.
Totally agreed about the OpenCV detection. I was at first disappointed that it didn't return confidence factors or any other details about the results, and lots of test images (particularly high res ones) would get some pretty crazy results. That's actually a big reason I went with the "intentionally shitty" aesthetic, with the bad cutouts and such. I've been considering an Amazon Rekognition version, which offers I think 1,000 image analyses for $1, and has some decent metadata about the faces it finds.
Thank you for the info. Is there anything you'd recommend, then, for full-text search?
Isn't the gopher supposed to have 2 teeth?
Now I can't unsee this.
The problem with using AES-CTR and keying it once and starting with a fixed IV means that you will not see any repetitions of 16-byte blocks in your output which means it is distinguishable from random function if you bucket on the block size. However that doesn't really bias the properties when you look at each individual bit or byte. Your design is precisely what djb advocates: https://blog.cr.yp.to/20140205-entropy.html 
I'm just saying that we must move beyond the 'don't roll your own' standardized reply and engage in a more constructive talk. Criticize the design, tear it apart, but with facts and data. Why is it massively flawed? Is the key output of a stream cipher adequate as RNG data? Is the result of repeatedly encrypting the initial state (buffer) and feeding it back to the RNG a proper way to create random data? Is the output really random? Can it be statistically proved as random? Is it cryptographically secure? What are the possible attacks? What it takes to securely turn a stream cipher to a RNG? Can we exploit the AESNI hardware acceleration to have a really fast PRNG, faster than other well established generators (eg Mersenne Twister or Xorshift or PCG)? Why is /dev/urandom slow? These are just some of the things we put aside and we never discuss when we keep repeating the "don't roll your own" meme or we say to people to stop trying and just copy-paste or re-implement established solutions.
Vanilla Lucene on EFS is great if you can accommodate periodically rebuilding the indexes and some latency to the data. 
I hear people saying that chi is preferred nowadays over httprouter. I have never used any of 3rd party router so maybe coding with one of them is much better and I just don't know it.
People are downboating you because you don't know, but no one seems to have explained to you. How familiar are you with Git? Because it has built in tools/utilities for issues such as this. As an example, [have a link.](http://genomewiki.ucsc.edu/index.php/Resolving_merge_conflicts_in_Git) Git is used in environments with multiple developers working on the same code at the same time. As such, one of its bigger selling points is handling conflicts that will almost always arise. Using something like Dropbox is a thing, but it doesn't really track your changes nor work in a team setting where code is constantly changing.
I actually checked with the free go-lang plugin creators on gitter. For now there are missing features that are only available in goland, but once goland goes final they'll start exporting it into an intellij ultimate plug-in 
Your work is wonderful. Sharing with my team on Monday 
The code is good. Uses object orientated programming instead of globals which is the better way of doing it. Even includes tests when most guides don't. Test end up being more important than the actual code in the end, especially in a web app. The pattern of the code is kinda opinionated, but it is an example of a good pattern. For example instead of the app type you could have a server, resource, and repo type. The server type will handle the router and server configurations. The resources type would handle the http handlers and the repo is for handle db related code. This allows for quick usability for future projects as well. 
I would assume it's okay for production. Since it used a lot. A mux isn't really something that you would be worried about when it comes to speed or performance. A mux is a very small part of a web app. Pick one is pretty much based on ease of use and syntax. Unless you obviously care a lot about zero mem alloc all the time. You should be more worried about what sql libraries to use and if they are ready for production. That is where the noticeable slow downs occur.
I have bought it a long time ago (leanpub), not at all expensive. Worthwhile when you start learning Go, it is a set of practical examples (and in an idiomatic Go style) using the Standard Library. I think Daniel Hukstep did a very good job starting this book.
[removed]
Does anyone have experiences wrt GopherJS performance in the browser or nodejs in comparison to writing JavaScript directly? It's obvious that a large number of constructions map very closely, and in those constructions you would expect the exact same performance compared to writing in JavaScript (or TypeScript) directly. But there are a few obvious candidates that have some impact: arrays, "generics" (no need for type inspection in raw JavaScript; TypeScript can guarantee the type without overhead), and inheritance (prototype inheritance is much faster than adding an extra function that calls a function on an embedded struct field). The web doesn't have much to say on real usage cases. There was the surprising case where computing digits of pi was faster using GopherJS than using go run, but I'm interested about the comparison between writing in Go and using GopherJS versus directly writing JavaScript, as it might offer a way towards a better performance for heavy tasks while keeping browser compatibility.
&gt; Personally I prefer writing raw JS even if it means I have to use two languages I'm with you on this. In the end you're running JS on the front end so you might as well work with it. Alternatively you end up learning something else that has its own set of issues, that transpiles down to JS with its set of issues. GopherJS looks interesting, but I can't see myself using it. I'm glad it scratches the itch for the author(s) and community. That's the fantastic thing about open source :) *Please note I'm not ragging on JS, every language, environment, whatever has its own particular issues.*
I recently got pointed to the summary of go generics discussion again: https://docs.google.com/document/d/1vrAy9gMpMoS3uaVphB32uVXX4pi-HnNjkMEgyAHX4N4/edit?pli=1# It goes into varying degree of details of the different approaches pros and cons, including built in generics. I'm against built in generic unless they can come up with a nice way of doing it that doesn't complicate the language too much (ideally not at all) I just like to point out to people who complains about overhead of casting to interface{} and back again, that that's exactly what java does. Granted Java's implementations is probably one of the worst ones so getting built in generics in go using that method would be disappointing.
Sorry to "bump" this but I am genuinely curious if you had something in mind regarding go's expressiveness? Reading some of your comments, you view seems to be fairly close to mine on this topic. I don't want generics (outside of the 2 built in ones) unless they make sense and not make the language too complicated. The simplicity of Go is very refreshing after writing c++ all day.
False dichotomy. There's no context here. Context is important. Depending on your context, you may prefer one or the other. What's the context? 1. Are you learning something new? 1. Are you developing an application from scratch? 1. Are you maintaining an existing application? 1. Do you you have requirements driven by users? 1. Do you have requirements driven by developers? 1. Do you have financial constraints? 1. Are peoples lives at risk if you make mistakes? 1. What's the scope of the project? 1. What's the size of your organization? 1. How difficult/important is it to onboard new programmers? 1. etc.. 1. etc.. 1. etc.. Without answers to those questions, nobody can tell you if you should prefer one or the other. And who knows, you might actually use both!! We have an application that is a Go backend with an Elm (Haskell-Light) frontend. 
The one thing I really appreciated from the presentation (which I agree with @8bitcow, the slides are a cluttered mess and need some help): write test output to help someone who is not you or your team when it fails. This introduced me to https://godoc.org/github.com/kylelemons/godebug/pretty#example-Compare You can get a clean visual diff on an output to more easily identify a diff! { Name: "Spaceship Heart of Gold", Crew: { - Arthur Dent: "Along for the Ride", - Ford Prefect: "A Hoopy Frood", + Rowan Artosok: "Captain", Trillian: "Human", - Zaphod Beeblebrox: "Galactic President", }, Androids: 1, - Stolen: true, + Stolen: false, } [edit: formatting. why can't we just triple back tick?]
The question is predicated on choosing one or the other. It's not a question of whether you should choose one, but, rather, which you would choose if you were choosing one. Apples vs pomegranates is not a good analogy, because you can make different choices different days. But when you organize a software development project, you don't choose a different programming language every day.
Simplicity.
It's for this reason we use `govendor` to run ours. install: - go get github.com/kardianos/govendor github.com/golang/lint/golint script: - golint -set_exit_status $(govendor list -no-status +local) - govendor vet +local - govendor test -v -race +local 
Are you certain that you're going with that name?
Not near a keyboard, and. It 100% certain, but you may be able to convert p to slice of string: strings := []string(p) Then join that...
Nope.
Tried, doesn't work. https://play.golang.org/p/Ozf9yGmIZD
I like how every one liner from Effective Go is becoming a function or type (or package as of 1.7) in the standard library. 
Haha 😅
There is no casting in Go, it's either type conversion or type assertion. There is a significant difference as Go types aren't covariant.
Holy crap, that's amazing. Using go vendor already, but not using those. I do hate installing extra things for the build though.
Thanks! That's a neat trick. I'll follow your advice and avoid it. But it is interesting to see.
[Here](https://blog.pusher.com/golangs-real-time-gc-in-theory-and-practice/) is a write up about Pusher moving one of their services from Haskell to Go that does a decent job of highlighting what they found to be benefits. Most of it seems centered around GC performance.