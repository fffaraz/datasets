Changes like print "Hello" to print("Hello") I suppose?
Generics, when? `Either&lt;R, error&gt;` instead of `(R, error)` - when?
No, they are not, they might cover some use cases, but there are plenty of things you still cannot do. Such as container structure, or functions like find, map, reduce, filter ...
Go works very well on windows. (I develop in both windows and Linux). It's a different story than Ruby that is a mess on Windows. Don't use cygwin or similar. Just use cmd or Git Bash. Also, if you are trying to compile something that needs C, pay attention for which version of MinGW you have. You need MinGW 32 for Go 32 or MinGW 64 for Go 64. This is a common mistake.
Final variables. Useful for types that aren't allowed as const var final ErrNoRows = errors.New("sql: no rows") Of course, this would be allowed in any context, not just in global variables.
I'm developing on windows. For most things everything should work out of the box. Regarding cgo, don't waste your time and just use Bash on Ubuntu on Windows (aka WSL), it works flawlessly. 
Why has other modern languages had this feature for almost a decade? Perhaps this is a pointer as to the fact that it could be an appreciated feature? 
Some non web Go stuff I've done: * https://github.com/thraxil/cyclo - cyclomatic complexity analyzer (it turns out that Go's parse tree is really easy to work with) * https://github.com/thraxil/mediacheck - commandline utility that you point at a web page and it checks that all the embedded media (CSS/JS/images) exist, don't have HTTPS issues, and will all load within a timeout. Runs the checks in parallel. * https://github.com/thraxil/mountwatch - checks the status of mounted drives and logs results to graphite. 
To be honest, python 3.0 did the mistake of sort-of, kind-of breaking things, but it wasn't until 3.5 that it was stable/fast/exciting enough to warrant a change. Lots of distributions are now changing to dual-distributions (python2.7 + 3.5+) or python3 default.
Just like Python 2 to 3.... oh wait, it didnt work that well...
This is something I came to appreciate much more as I used Go more. I value it's simplicity far more than having the occasional convenience of generics, as instead generics can often lead to more complex solutions. I've found the style of programming I use now is a lot different (in a good way) thanks to that, and I go back to languages like Java or PHP and think "why on earth am I dealing with all of this other crap that's not necessary, it could be so much simpler". 
No, it doesn't, in any way, shape or form. Jumps to 3.x and 4.x were because Linus didn't want second number to be bigger
&gt; Everywhere there is a use of interface{} means that Go cannot express the type that is wanted at first place at compile time. No, it doesn't mean such a thing at all. It can simply mean a variable can be of any type, as for example in fmt.Printf. fmt.Printf would not benefit from generics; interface{} is perfectly appropriate there. 
&gt; Printf in go atm is already generic as provided by the runtime. No, it isn't, it's a standard library function anyone can write: https://github.com/golang/go/blob/f3e6216450866f761cc22c042798c88062319867/src/fmt/print.go#L189. 
If you want to develop on windows and need CGO, a really easy drop in gcc to use is this: http://tdm-gcc.tdragon.net/ - just throw the installed location in your path and should be good to go. Have used this to good effect with quite a few beginners to get them into go smoothly. That said, I've used msys2, cygwin and wsl and probably the easiest of these to use is msys2. If you want to cross compile for linux or osx use wsl though, don't bother setting up a cross compiler.
You are not bringing any question to a table, you are proposing a solution to an unknown problem. 
I don't see a point. Looks like it comes down entirely to style. Why change things or add new features just for aesthetics? 
I want "slice with sliced capacity" to become default, ie `a=b[x:y]` to be equivalent to `a=b[x:y:y]`
I wrote an smtp proxy for my old company . It's not public.
Thanks. I believe a good look at the go tool itself may indeed help me out. I should've thought of that right away. 
Run integration tests or continuous tests with a real db. Mocking it is senseless to me, never had a good use case for it.
Russ's blog: https://blog.golang.org/toward-go2 Russ has my vote for the BDFL of Go. At least when Rob abdicates. -jeff
csharp – like the musical note. And as in »I use go and csharp regularly« ;).
Almost all the syntax and standard library changes were pretty easy, actually. The big problem was changing the default string type to unicode, and changing the way that string &lt;-&gt; unicode conversions happened and reported errors. Low level libraries (and their authors) had a hard time, which slowed down everything else.
C++ has done the "still compiles, but works differently" thing, too. They are more careful to avoid common idioms when they do, though. Not much of value was lost by redefining `auto x = 3.14;`.
A GUI library is an answer you need to bring the question /s
Everything works perfectly native you're just a scrub
The argument isn't "I like generics better" it's that interface{} is inherently error-prone. Discussing production failures does little to quantify the risk, nor does it address the problem that "acceptable risk" is largely a matter of personal preference. &gt; That's why I code go and not agda, which would be the epitome of static type safety I know of. Is it because agda is too type safe or because it makes other tradeoffs? In other words, if the next Go compiler (or linter) automatically caught more bugs with no programmer changes, I don't think you would spurn it. There isn't an upper bound on QA, the problem is getting more of it always requires some tradeoffs. So we need to debate tradeoffs instead of debating whether or not more static analysis is useful.
Is there absolutely no way of doing this right now with go?
Actually yes, to make sure the database was called or not, and to mock the result of the query. But never went down to validate the query itself. For that I prefer integration tests against a real db.
&gt; You get a worse Rust. Why? They aren't features of Rust. Enums, generics and nil checking exist in e.g. TypeScript and Kotlin, and the first two in C++ and Java. And in those languages, you can program without using them. I know many people don't like to have multiple ways to write the same. For generics, that's not an issue. And interface{} stays useful for cases where you want different types. Nil checking idem.
Given that Go is a small, statically typed language, I think it should be much easier to make a porting tool than with Python. Besides, I suspect most of the larger changes will be additions to the language (generics, v2 libraries, etc) that won't break compatibility. Python has a harder time because it's fully dynamic.
Impulse? River? (Go with the) Flow?
Yeah, but Crystal is still a new language. I'm loving it as well :)
It ain't strange at all. He announced it to let the community to come with ideas/suggestions. Maybe an online feedback form will help.
Symphony sounds so good :)
 * Standard official debugger. (not delve or gdb); * More low level features; I'm sick of this : *(*type)(unsafe.Pointer(uintptr(ptr) + uintptr(offset))) madness. * Good well written standard documentation for the Go assembly; * Generics;
Using a non-clever name usually makes code easier to read. I would recommend `audio` or `sound`.
Can Go bring its own GUI library to 2.0 without breaking existing code? 
You can run that stuff on a raspberry pi :-) 
&gt; it's that interface{} is inherently error-prone It would seem to me, more and more, that this is empirically false. If it was inherently error-prone, it wouldn't be as impossible to get people to point out actual errors caused by it. Russ painted a very specific picture of the kind of experience reports he is looking for and, so far, no one actually came up with anything like that. So far, all people are saying, is repeating over and over "we want generics" and "interface{} sucks". That might or might not be true, but either case, it's not something that you can use to actually make decisions about how the solution should look. &gt; Is it because agda is too type safe or because it makes other tradeoffs? The former. Just like Haskell or Rust are too type-safe. If I know my code works, I have no patience to convince a machine of it. I want the strictness of the compiler to be *just* enough to help me avoid mistakes, I don't want it to patronize me. &gt; So we need to debate tradeoffs Great. Start by pointing out *what currently doesn't work well*, so we know what the problem is that needs solving. And don't come with "we need a generic set"; even if you consider that answer enough, it's evidently not what's needed to convince other people, so you should recognize the need to rethink your approach.
&gt; First of all I have to say that this experimental is tested and worked only with the [Iris web framework](https://iris-go.com) Is that so?....
Not even the post-1.0 model was 100% computer aided updating. There are a bunch of "you need to go and manually fix your code" breakages after that. We will see, how exactly any potential breakage for go2 will look. I fully trust the go team to do it better than Python 2-&gt;3. But either way, "just break stuff already, people will deal with it" is certainly not the answer, because writing the automated fixers will take *more* work and care, not less.
Twitch chat bot. It logs the chat and just writes the logs as files. It works with gzip and stores a lot of chat data efficiently k would think. I also wrote an IRC proxy for twitch, because the ratelimiting of twitch can be annoying when you start a new project and this way I can just use my proxy to avoid that annoyance. These are the projects: https://github.com/gempir/gempbotgo https://github.com/gempir/relaybroker 
One thing that has always bugged me was `uint32` and `rune`, as well as `uint8` and `byte`, being identical. Until recently, there was no other way that two differently named types could be identical, and I still think alias types should be used sparingly, if at all. They're also semantically different: `uint32` and `uint8` are just numbers of a specific size, there is no reason why it should be possible to cast a slice of them into a string, or the other way around, or even weirder, why you can cast single one of them into a string but get the respective Unicode code point. However, for `byte` and `rune`, those results are what you'd expect. Similarly, one would expect `fmt.Print('A')` to output an `A`, when it in fact prints `65`. They should of course still be castable, and you should still be able to do arithmetic with `byte` and `rune`. But I think there is little gained from treating the types as aliases, as most programmers probably know if they want to use their variable as an unsigned number, a Unicode code point, or a raw byte.
Thanks :-) I only picked up Go on Sunday, so I'm a bit out of the loop. I really like it thus far.
You'd miss all the MyCollectionOfInts, MyCollectionOfStrings, etc.
A meme application that takes photos and adds captions, allows pictures to be juxtaposed, and (soon) lets you put a twitter window around the image. I used golang because the image library made it easy to decode images from the internet (you can download through the application) and put them in a format I wanted. Probably my favorite use of golang so far!
The `print` statement-to-function change was a part of it; I definitely had to get used to typing `print()` instead of `print`. I still see a lot of new programs being written that would work equally well on both Python 2 and 3, except for the `print` statements. But by far the biggest problem in migrating existing programs is the Unicode change (I wrote a [brief explainer of the changes here](https://stackoverflow.com/a/21689447/660921)). Due to Python dynamic nature it is very very hard to completely audit a Python 2 program and verify it can run on Python 3 without problems. Experience shows that in at least a few cases you're going to mix up `str` and `byte` types, resulting in unhandled exceptions or – even worse – the wrong output. The new way of handling Unicode is vastly superior to the old Python 2 way; Python was created at time when Unicode didn't even exist, so it was "tacked on" later. It was a common source of errors in Python 2 (there's an entire FAQ section in the Python 2 manual for it) and Python 3 fixed a lot of that. But migrating existing programs? It's a pain, even for relatively small programs. A second related pain point is that it's very difficult to write programs that work well in both Python 2 and 3. Some things are easy (`from __future__ import print_function`, or `try: import py2_lib_path except ImportError py3_lib_path`), but again, the Unicode thing is hard. The same function will have a different return type, and handling it all correctly in both Python 2 and 3 is full of subtle caveats... 
We just have to train it by doing human reviews on the entire codebase once. To train the AI to do it for the next time we want to debate generics... 
&gt; It would seem to me, more and more, that this is empirically false. If it was inherently error-prone, it wouldn't be as impossible to get people to point out actual errors caused by it. This is staring you right in the face: type-safe collections. Let's say I want a tree that only takes int values. Or strings. Or a certain struct. With interface{} you don't get the compiler telling you that you can't stuff a string value in an int tree and at runtime you _must_ do a type check when pulling values out because there's nothing stopping you from putting that string in at runtime. With a generic solution you get type safety and improved performance. I mean that it's the most obvious, oft-repeated example of where generics come in handy, but the impossible standard the Go developers live by is "well if you can do it another way then generics aren't necessary." Well yeah, you certainly can do it another way but copying and pasting for every data type you need, or code generation but yeesh, it's such an ugly hacked-up way to do something that's so useful.
I think you replied to the wrong comment?
Untrue; the big 2to3 problem was string/bytes/unicode, which cant be fixed by a tool, and broke programs 
Audio terms I can think of quickly now are: - time - note - voice (gives the game a voice) 
No or we'd have finished porting years ago.
No, I did not.
I think this is the best approach to take regarding testing with or w/o a real database. I'd also point out that in your example, you don't verify the query you are passing to the database. There can be value in making assertions that you are getting the variables you expect and that they have been mutated accordingly before being passed to the query. This may not be necessary if you are using an ORM that generates your queries, but at the same, your ORM may require a mock database in order to work within the confines of a unit test (ie it's fast). All that said, if you use a lot of different services you will likely need to mock them in some shape or form that makes the local test incomplete. In order to gain confidence in what you release, spend the time to create ephemeral production like environments and integration tests that can run in that environment. If you can't do that, then that is where you can have a much bigger impact vs whether you mock or not. 
That was never really a problem in Python. The hard problem with python migration was that there was no way to realistically automatically port and statically check certain types of programs, and the string/bytes/unicode change often required a complete rewrite in those programs. The changes in twisted (an async network library) amounted to about 40,000 lines of code. If 3.5+ has been released earlier there would have been much more incentive to port, but 3.0 took a while to get going, and no-one really wants to manually port 40,000 lines of code unless there's good reason.
In what way was his comment not a question/problem?
These days you can write Python code to run on both 2 and 3, using various porting libraries like `six`.
3.6 is really, really good.
Support for python 2 will end in 2020. Many people thought that some big tech company like RedHat would fork the interpreter and carry on supporting it, but RedHat are now busy porting to 3.x. 3.5 is significantly better than the train wreck that was 3.0 VFX might be screwed. Python's built-in to Maya and Maya is on 2.x. They won't able to port until Maya ports, and Maya hasn't (as far I know) said anything about it.
&gt; This is staring you right in the face: type-safe collections. You are, again, just saying "but type-safety", without pointing to any actual *problem* with it. Sure, container/list isn't statically type-safe. Did that ever pose an actual problem to anyone? Except aesthetic dissatisfaction? &gt; but the impossible standard the Go developers live by is "well if you can do it another way then generics aren't necessary." But that is *not* what Russ says. He is saying the exact opposite. He is saying "let us know, what you did instead and why it's not enough and what specific problems it caused". Literally. That is *the exact point* of his talk and post. So why not just do that, instead of repeating over and over again that there is an abstract concern about type-safety? &gt; it's such an ugly hacked-up way to do something And that seems to be the core of the issue. Not actual technical problems, but aesthetics and personal preference. It's really hard to make technical design decisions based on that.
Well, a lot of people are waiting for generics. But I still dont know why they really need it in go. Anyway I think its better to bring enums there. (well, I guest its already sum types, is it same thing ? didnt tried yet). And may be exceptions so it will be less "paper-work" to describe why manual error handling and a lot of "if err != nil" is ok. 
Significant parts of the python community such as VFX are stuck on Python 2 due to using embedded interpreters (in software like Maya). You just don't hear about them as they don't post in r/python. However if you look on computer graphics forums, you will see Python 2 code.
It's also worth noting that you don't have to make one test implementation that does everything for every test, you can make a 'null' implementation that satisfies the interfaces, and then implement only enough test stub to recreate the behaviour you need per test, which simplifies things considerably in some cases. If you find that you have to stub out a lot of calls to get something working for a single test, the surface area of your interaction may be too large.
God I hope they stick to this. I really don't want to have to deal with some python level shit in my favorite language, even moreso now that I use it at work.
My very first project in Go was... in all honestly probably not doing justice to the power of the language. I use a windows laptop issued by work, and I got tired of the icons on the desktop constantly getting shuffled around like a tornado had rolled through. So I wrote a little script that would 1) Save the location of the icons when I had them set up the way I like, and then 2) restore the icons to that saved state later on when the tornado hit. Now I'm writing a tool that'll allow me to define a project by it's code repos, build environment, container config settings, db migrations, etc... and be able to onboard someone into the project with a single command. 
Generics are rather useful for some things like Lists or Tree Datatypes that you want typesafety for. interface{} is *a* solution, albeit not a good one, as is code generation, but a built in language feature to achieve it would be much more comfortable.
It's worth noting you can't test gui or audio applications in Windows 10's Ubuntu.
Strong liquor? Nah, we only drink "tea"... yup.
As if it's not already begging for someone to finish the thought with "...considered harmful"
The "classical approach of generating webpages using templates" is also fine with Go...
I don't think the objection to providing examples is because examples are rare, but because there's no apparent value add. We already know what the primary problem is--the type system can't guarantee correctness for certain abstractions. Providing additional examples isn't going to clarify that at all; the issue now is what (if any) tradeoffs can we make to address that. There are also secondary problems--that `interface{}` is unergonomic, etc. &gt; Just like Haskell or Rust are too type-safe. If I know my code works, I have no patience to convince a machine of it. I want the strictness of the compiler to be just enough to help me avoid mistakes, I don't want it to patronize me. These are tradeoffs. A Sufficiently Smart Type Checker could infer as well as you that your program is correct without additional ceremony and wouldn't get in your way unless you have an error. Your objection isn't to "too much correctness", it's that the additional safety comes at the cost of additional ceremony. The frustration with the "playing dumb about generics" attitude taken by parts of the Go community (including some of the team at various points in time) is legitimate in my opinion.
Well, not saying you can test gui or audio applications, but I was able to get an X Client running to connect from windows. It was working flawlessly and fluently.
Why would you even need a shitty web framework for this. If you need a Go based web server on android , you can run caddy. https://github.com/mholt/caddy/wiki/Running-Caddy-on-Android
The problem with these incompatible upgrades is that the new version needs to be substantially better in ways that make it obvious to drop the old one (including 3rd party library developers, python3 failed here), or you need to do a dick move (gtk, looking at you!) around completely dropping all support and maybe even removing documentation for previous versions to force people to upgrade. People will happily move if the value is there, and they'll regrettably move (or leave) if you just force them to. 
That's true. I'm an old school sysadm and I'm coding for pentest stuffs. Smtp servers and etc. 
OK, so beep won it! https://github.com/faiface/beep
It's not original. [Source](http://poorlydrawnlines.com).
Haha, I was thinking the same from the first time
Exceptions.
Stop the $GOPATH nonsense.
[Sourcier source](http://www.poorlydrawnlines.com/comic/a-message/). (And I suppose I'm asking for someone to post [sourciest source](http://www.poorlydrawnlines.com/wp-content/uploads/2015/03/a-message.png), so I'll just pre-empt that. Better to link the site itself, though.)
If the test talks to the database then it's an integration test, not a unit test. 
How about eliminating empty interface penalty. Reflection costs to almost none. Maybe improve the C FFI a lot faster. Not everything is go out there when it comes to performance. 
They are useful for code generation.
What makes Go great is that it's so far from the CPU. While C++'s std::async and std::thread (on Linux in GCC, this translates to a single thread being spawned per call to either function) is great for high-throughput scientific computing (which is what I do), it takes a lot of effort to use that for low-latency asynchronous IO. Meanwhile goroutines combine waiting for computation to finish on a CPU core with waiting for asynchronous IO with other hardware (network etc.) into a single, unified abstraction. You can spawn as many goroutines as you like without worrying about too many threads locking up the CPU. I criticize Go a lot. But if I wrote server software, I would quite possibly choose Go over C++ or Haskell, just for that. Oh, also, if you know how C++ generics work (Rust does it the same way), you'd know that generics (aka 'parametric polymorphism') can get you a lot closer to the CPU than other similar abstractions, such as dynamically dispatched subtype polymorphism (which most languages including Go use).
If you're looking for existing examples of the "important" return value, the `#[must_use]` annotation on the `Result` type in Rust is basically this.
I agree. *KISS* and try to stick with `flag` if you can. Remember that you can use multiple FlagSets, e.g. a common one and then one for each sub-command. There's also quite a few alternative parsing libs that are more powerful, but a bit more verbose. Perhaps have a look around here to get inspired: https://github.com/avelino/awesome-go#standard-cli
backend of a realtime pvp mobile game; it's doing stuff like running the game simulation (we want to be server-authoratative to prevent cheating) and communicating w/ clients via udp. various api servers over tcp. small command line utilties, e.g., parsing excel spreadsheets into game configurations. for some really cool open source stuff (not mine!), check out https://github.com/fogleman - primitive, creates art by recreating photos using simple geometric primitives (available on the appstore) - an nes emulator - a software opengl implementation - lots of other stuff...
Thanks! I didn't know about this
Per RSC requests, here are most of real problems that my team had/have: 1. There is a need for thread-safe collection data structure. `sync.Map` is a step in the right direction, what about `sync.Slice`? 2. There is a need for generic collection types. Just the other day we needed a generic typed Bloom Filter and Deque. I care less about true generics, but not having generic containers is a real problem. 3. Panic on close channel trips a lot of people. We are currently resorting in closing channel and assigning it to nil to avoid panics. But that's a hack. Maybe Go 2 can do away with this panic behavior. 4. The other day, `github.com/Sirupsen/logrus` library changed its name to `github.com/sirupsen/logrus`. That caused a lot of chaos in the community. It would be nice to have import alias to avoid this problem in the future. 5. How can we resolve vendor dependencies of our vendored libraries? Example: We vendored `github.com/aaa/bbb`. That thing vendored `github.com/zzz/yyy`. But we also use older version of `github.com/zzz/yyy`. Which `zzz/yyy` does Go pick? Perhaps vendoring can support tags/branches so we can pin-point the exact dependency. Example: `github.com/zzz/yyy:v1.3.1` 6. We are copy and pasting same functions for `int`, `int64`, `float32`, `float64`. If generics is never going to happen, can we get a `Numeric` interface?
That's what I don't like: internals being treated specially. Internals get to be treated generically, internals get to iterate. I don't even care about these issues as "I should get to do that, too!”, I just want consistent syntax, so that I don't need to ask, separately: ”how do I do this with a built-in type?" Or "how do I do this when I don't have a built-in type?"
The contents of a comment are just text.
He just can't stop...
I don't see why you would expect content aware parsing for a multi-line comment. The contents are whatever you happen to want to put in there, so the "string" has no meaning.
[The last set of stats I saw](https://www.jetbrains.com/pycharm/python-developers-survey-2016/) said that 40% of Python programmers are using Python 3 the most. But however you look at it, outside of embedded interpreters, it's clearly growing and version 3 may even be the majority for 2017.
Gonna pin it!
Comment parsing can definitely take into account string literals and ignore the contents of the string literal. Without regex I'd say that it probably shouldn't do that, but you offer a good use case. I think it makes sense for the parser to ignore the string contents while parsing the comment.
&gt; but because there's no apparent value add. So, convincing people who could actually fix your problem doesn't add value? Again, you might consider it unreasonable, but Russ has told you what's needed if you want to convince them and help them come up with a good solution. If you want generics to happen, sooner rather than later, it should be apparent what has to happen. That it doesn't, seems to illustrate that it's not that important that it happens soon after all (it's not important enough to put aside one's pride and actually go through the steps one was told, after all). &gt; Providing additional examples isn't going to clarify that at all "additional" would imply that there was one. So far, from what I can tell, there was none (in the spirit that Russ laid out in his talk and that I laid out here repeatedly). Instead, people are repeating the abstract advantages of generics again and again and insisting that it wouldn't help, if they'd provide experience reports demonstrating actual real conflicts with go's design goals and how the current solutions proofed to be not enough. &gt; the issue now is what (if any) tradeoffs can we make to address that. But for that you need to actually *demonstrate the problem to be solved*. It is impossible to talk solutions, if the problem isn't actually clear. And, for better or for worse, a) the decision makers have made clear that this is not the case to them and b) they have lined out clear and direct steps of *how* you can make it clear. &gt; These are tradeoffs. That is literally the opposite of what you said before, which is "more is always better". It being a tradeoff is literally my point. &gt; The frustration with the "playing dumb about generics" attitude taken by parts of the Go community (including some of the team at various points in time) is legitimate in my opinion. No one is playing dumb. There have been clear instructions. Instead of arguing about those requirements being dumb on reddit, why not just invest 10% of that effort into actually following them? Would be less frustrating for literally everyone involved.
The point isn't which is better for programming, it's that the Ruby 1.x to 2.x transition went smoothly, and nobody uses Ruby 1.x any more -- whereas the Python 2.x to 3.x transition was a disaster, and lots of people still use Python 2.x and refuse to switch.
Just like Java did? _sigh_
i did not say that 2to3 would rewrite your code; only that it made grepping for simple syntax changes unnecessary
Honestly, I'd like to see all variables and method arguments be immutable by default, with some sort of annotation to make them mutable. But I know that'll never fly with the Go dev team, so I'm not even gonna propose it.
Re: 4, it'd also be nice to have an adequate core logging library so that people didn't all have to import their own logging libraries. I wouldn't mind not getting full generics as long as we got parametric polymorphism. At least then we could write collection classes that worked with multiple types with the same methods.
Getters and setters are also where I find the lack of parametric polymorphism _really_ annoying. I end up with `SetFromInt`, `SetFromString` etc.
&gt; generic typed Bloom Filter Curious about this one? What types would need to go in it other than string/[]byte? Integers?
+1
I really hope that they finalize an official package manager, go get works to an extent but it needs something much more integrated, especially for specifying the exact versions of libraries to use. Currently there are a lot of different tools for this but nothing official. All Go 2 needs is an official tool akin to setup.py for Python or package.json for Node.
The built in datastructures cover 90% of ones needs if not more. They did solve the problem mostly. "Hacks" are a solution. You are engaging in circular logic or tunnelvision failing to see the problem that was to be solved.
Concur. I use MSYS2 on Windows and with rare exceptions (a couple of instances in the past) packages with cgo compile and work.
* [Ebiten](https://hajimehoshi.github.io/ebiten/): A 2D game engine * [Clock of Atonement](http://blockbros.net/tsugunai/): A mobile game written with Ebiten (not open-source) * [Oto](https://github.com/hajimehoshi/oto): A multi-platform audio playback * [go-mp3](https://github.com/hajimehoshi/go-mp3): An MP3 Decoder
&gt; If there aren't any backwards-incompatible changes, why call it Go 2? If you can use Kotlin from Java and Java from Kotlin, why are they different languages? Because they're not source-compatible; it's just that the Kotlin compiler knows how to import from Java and can produce class files that javac can deal with.
Oh, I see where you're coming from. Not much to be done about a difference in how we read it haha
C doesn't have generics. 
I still hope the fragmentation won't kill go
I have never really needed generics. I can work around them. 
Well, `fmt.Println("Stuff...")` saves you the additional `\n`: `fmt.Printf("Stuff...\n")`. Check https://golang.org/pkg/fmt/ And it's easy to print multiple whitespace separated strings with `fmt.Println("Stuff...", "Something else", "Wow")`
Yeah, Python folks should have just stopped maintaining 2.x when the 3.x was released, and removed the downloads, and deleted the source code for 2.x. Their soft approach was a huge mistake, allowing 2.x to live for a day longer.
The problem is when I want to comment out a sequence of instructions, and there is a string in these instructions that contains */. It is a problem if the compiler interpret the */ in the strings as comment end. I don't have a C compiler to check how it handles */ in strings. I have never seen this problem before. 
You are right, it would be tricky to write a single regex rule to parse multi-line comments by skipping */ inside double or back ticked strings.
This is how almost all programming languages behave. A scant few support nested comments. Even fewer have code comments. 
It was funny only first 25 times...
Well, the way you'd probably do it is by having a parser state which was "String in Comment". The problem would be ignoring parse errors in the string (i.e. unterminated strings).
`auto` had a different (see https://msdn.microsoft.com/en-us/library/6k3ybftz(v=vs.80).aspx ) syntax back then. What you would do is: auto int i = 0; // Explicitly declared as auto. which is a [syntax error](https://stackoverflow.com/questions/12093717/why-old-usage-c03-of-auto-does-not-compile-under-c11) in c++11
What fragmentation are you talking about? 
You seem to be confused. The generics vs no generics debate is about balancing tradeoffs between type-safety, expressiveness, consistency, ergonomics, etc. No serious person disagrees that more type-safety is a bad thing if there were no tradeoffs to be made--you think you do, but your justification was just enumerating tradeoffs made by particular languages; you're simply confused. The problem is well understood and entirely uncontroversial, and more examples aren't going to persuade anyone that type safety is important nor will they inform what sorts of tradeoffs to make.
&gt; without pointing to any actual problem with it. The problem is the non-negligible probability of runtime error, the borked support for tooling, and the poor ergonomics of `interface{}`. If you (universal) can believe that static typing adds some value, then the problem is clear to you, and you're just playing dumb. &gt; So why not just do that, instead of repeating over and over again that there is an abstract concern about type-safety? Because it's more constructive than providing pointless case studies? &gt; And that seems to be the core of the issue. Not actual technical problems, but aesthetics and personal preference. It's really hard to make technical design decisions based on that. See my first paragraph.
C doesn't have data structures or garbage collection either so maybe we should get rid of those too.
Print() and Println() lets you print strings with formatting characters without escaping them.
This makes my evening right now. Always great to be of some help :) 
What? https://en.wikipedia.org/wiki/Struct_(C_programming_language)
**Struct (C programming language)** A struct in the C programming language (and many derivatives) is a composite data type declaration that defines a physically grouped list of variables to be placed under one name in a block of memory, allowing the different variables to be accessed via a single pointer, or the struct declared name which returns the same address. The struct can contain many other complex and simple data types in an association, so is a natural organizing type for records like the mixed data types in lists of directory entries reading a hard drive (file length, name, extension, physical (cylinder, disk, head indexes) address, etc.), or other mixed record type (patient names, address, telephone... insurance codes, balance, etc.). The C struct directly references a contiguous block of physical memory, usually delimited (sized) by word-length boundaries. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/golang/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.24
https://play.golang.org/p/c-2-VlH4kA Print and Println both work when you don't know the exact number of args that you're printing. Println in the example also prevents having to make a second call to Print just to output the newline after all the arguments.
I don't remember any manual fixes but I didn't have any major projects pre-1.0, so gofix only had to handle my small test/learning code. I mainly remember the evolution from the Makefile setup to the go tools. I'm betting in the end they will have automated fixers that handle the majority of what's out there along with a backward compatibility mode for the rest, maybe set with a build flag or something. 
s/Benchmarking/Optimizing/
&gt; The problem is the non-negligible probability of runtime error Seems pretty negligible to me, honestly. Otherwise I'd expect someone to be able to actually tell me a story. There are millions of lines of go-code using interface{} executed every second, probably. If no one can point to one of them causing a problem, that's the definition of a negligible probability. &gt; If you (universal) can believe that static typing adds some value, then the problem is clear to you That is a fallacy. Static typing adds some value, but that doesn't imply "more is always better". There is, for example, the well-known law of diminishing return; going from 0% statically typed behavior to 20% is probably going to give you a lot more benefit than going from 70% to 90%. Static typing *in general* being a good thing, doesn't mean it *always* being a good thing; there might be cases, where you can add type-annotations, which does not add any benefit or even have negative benefits. From observation, I am assuming that replacing the remaining usages of interface{}-typed containers with generically typed containers is probably diminishing over 90% of the behavior of go code already being statically typed. And from my experience with java, I see a significant cost related to adding them. Want to prove me wrong? *Quantify those costs* by writing an experience report. I don't understand how I have to repeat that over and over again. &gt; Because it's more constructive than providing pointless case studies? Proven by the collective wasted time in this thread? By just repeating the same unsubstantiated claims over and over again? When even 10% of that could be used to write convincing experience reports that actually have the chance of changing something? Seems pretty unconstructive to me, TBH. Again, "they would convince people of your standpoint" is a pretty clear benefit, making them *not* pointless. They can only seem pointless to you, if you are unable to acknowledge other people's view points and consider yourself categorically right, above the need to actually demonstrate that. Anyway. This isn't going anywhere. I won't be able to convince you to demonstrate your view point and to actually move generics forward, instead of just continuing to walk in circles…
It's funny how the thread at /r/programming has 4x the comments of this one, but you can unflatteringly summarize the whole thing as "my geneircs reeeeeeeeeeee".
&gt; You seem to be confused. Then you are misreading me. &gt; you think you do Because I am. Don't put thoughts into my head, that's just rude. I know what I'm talking about and I know that better than you; that should be the default assumption, everything else is just being a jerk.
Sure. I assume something like that too. But that's going to be seen in the future; we definitely can't just make the bold claim that everything's going to be backwards compatible :)
No fragmentation is an explicit design goal, so I'm pretty confident they'll find a good solution.
I like to think of go as a pragmatists language. It was made for specific solutions (hence the lack of generics), while still allowing moderate flexibility when it's called for. As it turns out, a lot of these generic solutions never live up to their promises. There are always subtle differences between implementation to implementation that makes or breaks an application. If there werent, someone would have automated it by now and we'd all be out of work. I have embraced the fact that today's business problems might not be tomorrow's, and I'm probably going to throw away an implementation or two (Fred Brooks anyone?) until the problem is complete solved, at which point it only needs maintanence.
1. They don't share the same performance. Look at internals: [`doPrintf`](https://golang.org/src/fmt/print.go?h=doPrintf#L946), [`doPrint `](https://golang.org/src/fmt/print.go?h=doPrint#L1118) and [`doPrintln `](https://golang.org/src/fmt/print.go?h=doPrintln#L1133). We see that `fmt.Println` doesn't use reflection and `fmt.Printf` is so overkill to just print a string, with no other argument. 2. `fmt.Print`and `fmt.Println` handle spaces between arguments differently: https://play.golang.org/p/z0PTMGQNj-
I'm not picking on Rust personally, it just happens to be seen right now as an "anti-Go" - compiled (unlike Java/C#), with a decent dependency system (unlike C++), came out around the same time, and (due to misunderstandings) is viewed as a "competitor". But in reality, every language has its culture, and just as one wouldn't demand OOP from Rust, one shouldn't demand non-Go idioms in Go. It's not that they're _bad_, they just don't fit the language. PS. (Not addressed to you personally, but more to the "let's ban Go" crowd on HN) What I don't understand is the frequent "why can't Go be more modern" complaints. Go happens to be one of the more insular communities I found, which practices practically no evangelism. The culture seems to be one of "You like the language, use it. You don't, fine, use something else". It's not a "corporate language" like Java or C# (where the more people use the language, the more money/visibility mother-ship makes). It seems right now that Dart is much more of "Google's language" than Go. What happened was that a few engineers in Google made a language which would fit their needs, and open sourced it. They never _promised_ generics, they never _promised_ enums, they explicitly said that the language was meant for _their_ use-cases. Don't like it? Doesn't fit your use-case? Can't accept their compromises? No one is forcing the language on anyone. But guess what, people like it and use it. 
Difficult to adopt Go in a locked down corporate environment, due to its insistence on pulling dependencies directly from git, instead of artifacts. This is unlike dep mgmt in all other modern languages (Java = Maven/Gradle, Rust = Cargo, Ruby = Bundler, Python = pip). Makes SOC2 compliance really hard. Recommendation I got from Go experts was to check in dependency source code directly into our project. That generated laughter from my existing Java devs. 
People who care about generics have probably already left the Go language. Why would they add it now? I'm not really a Go developer anymore, although I did use it for a few projects a year ago. 
For what you suggest to be true the stuff inside a comment section would need to be parsed, thus. would need to be parsable. This is well known in C/C++, the usual workaround is to use #if 0 instead. For other languages use an editor that supports adding "//" comments markers easily to every line in a selection.
"Angular 2".
Very annoying to use atm. without arrow keys, for history, and copy/paste doesn't work. But those should be easy to solve. The purple box showing "completions" also seems a bit weird given you can't select them.
I spawn an in-memory SQLite database and talk to that.
There is the Plugin build mode, but it only works on Linux, and you can only load it in other Go code. There is also a c-shared buildmode, but it's very hacky, and requires Clang or GCC, and also doesn't work on Windows. So no, there is no real easy or native way to do it with Go right now.
When Go 2 lands, you'll have a split between projects still on the old version and projects already on the new one. If everything goes right, that transition phase will be over in a few months. If not, well… look at where Python is now.
I think you're confusing cause and effect. They're not built in data structures because they solve 90% of the problems, they're people's go to data structure because they're built in. If this were lisp or Haskell you'd be claiming lists are all you need, in C you'd probably be advocating trees, and in javascript you wouldn't see any need for much more than an object type. Pointing out that Go itself has needed some form of "generics" internally without exposing it to others isn't circular logic, it's a use case--which is what they're looking for. Take Go before the built ins, and describe the detailed, concrete problems that the built in functions were added to the language for which justified changing the language spec over. It's an exercise that only /u/rsc (and maybe 4 other people) can do, but it should be the first step in analyzing adding generics to Go.
That pain point was the key thing rsc was trying to avoid.
In that case, interface{} works too, right? :-D
Unterminated strings is the "feature killer" here actually - What if I want a multi line comment about string delimiters that deliberately includes unterminated strings (or single quote/backtick markers - will my comment never be "closed"?
To be fair, that's only one data structure. Not structures.
Considering your goal is to combine a queue and dropping data rather than blocking, what is your advantage or difference over simply using: select { case ch&lt;-foo: default: // Skip logic, if necessary, or nothing } To me it seems like you're accomplishing the same goal, but in more complex way. I'm happy to hear use cases where your method is preferably though :)
&gt; What is your opinion about it ? Working as intended and in accordance with the specs. &gt; This is the behavior I would expect. Me not. I prefer a tokenizer that never attempts to interpret the comment content in any way. 
The dude said Data Structures, not structs. You can't import a list from the stdlib that's his point
Okay interesting, I've just started my golang journey. Looks like I'm in for some adventurous times.
That's not how Go 2 will come about. Watch the talk Russ gave at GopherCon. 
There's a difference between *trying* and *succeeding*. Python *tried* as well, and fucked up.
I'll rather wait until Go 2 actually lands. They don't even know yet what the scope of Go 2 will be.
Aye, this is what I was saying. Previously it declared x as an int with the value of three (and ideally a compiler warning!). Now x is a float with a value of 3.14 This is bad, but the former code is incredibly uncommon, confusing, and definitely horrible code. 
&gt; Don't put thoughts into my head, that's just rude. I know what I'm talking about and I know that better than you; that should be the default assumption, everything else is just being a jerk. How am I putting thoughts in your head? I'm only reiterating things you've said or at least appear to have said. If it makes you happier, feel free to s/you think/you may think. I have been terse because you're being obtuse; I'm frankly disinterested in debating unambiguous, simple points. Don't mistake that as a personal slight--I agree with most of what you post and I often find you thoughtful, thorough, and articulate; I just lost hope that you were participating in this conversation in good faith.
High level how would you say this differs from Kubernetes?
So is anything available right now?
I don't disagree but that requires even more boilerplate which apparently the OP hates.
Yeah okay then toss me a hashmap genius oh wait no you can't because there isn't one and you can't have lists either or any other *data structures* because you have to write everything from scratch for every single possible data type.
You really are missing all the points. 
You are correct For some reason I thought I had written a parser that had this logic before, but I went back and it does not, for this reason
integers or simple structs, basically any type that can be a map key
The two main advantages are: 1. The diodes shed old data instead of new data. 2. Zero push back for producer. If using a polling method to read data is used, then any goroutine writing never has to touch a lock.
You are a soucerer.
unsafe.Pointer for the win
Tuples (structs) are also the most rudimentary of the bunch.
When I comment out code with multi line comments it's because I don't want to think at all about what is inside while I focus on something else. These are never permanently applied. I use // from r permanent comments almost exclusively and the two main methods I use to write Go (vim and atom) both support easy multi line comments. Best solution for you would be getting accustomed to relying on your editor to do this, it's a menial task not worth thinking about much while writing software.
How about an experience of "we didn't port this service to Go because it was a pain in the ass because of boilerplate"? That's not something people write reports about because it doesn't help them in any way.
There was a recent regression that broke arrow keys and history. Currently digging into it
The preprocessor would disagree with you.
You think all the people that might try go over the next 10 years have already tried it and moved on? Not likely. And people that have tried it and liked it except for generics would be more likely to come back if they heard it was added. 
&gt;And people that have tried it and liked it except for generics would be more likely to come back if they heard it was added. Nah, I have a feeling most people found greatness in other languages and probably won't come back.
Don't forget that Python is dynamically typed while Go is statically typed. Go already has gofix. It would be alot easier to fix language differences between Go1 and Go2 automatically, than it is to fix Python code. Also Python 2 vs 3 can encounter runtime issues depending on which interpreter is available and tries to run the code. Go is compiled ahead of time. 
TBF, the Python core devs did go full retard. They broke almost all existing code while offering almost nothing in return, and the new version is based on a model that's fundamentally incompatible with reality. Even a decade later, Py3 can't do stuff Py2 could because it's *still* half-baked.
At my studio, besides web based services, we use it for other solutions like environment management process bootstrapping, and image processing and caching. 
Yeah, but what Python tried was fundamentally broken from the start. "All text is Unicode" is a wonderful idea, but that isn't the world we live in. 
**Re generics**: A few people have misinterpreted the part of my talk mentioning generics as saying I don't know any possible use cases for generics, sometimes followed up by talking about how important type-safe containers are. Obviously I know about type-safe containers. The point in that paragraph, which was brief due to time reasons, was that if you don't have specific use cases in front of you, you can't tell whether the design covers them. Even "type-safe containers" is not very specific. If all we need is type-safe map/set/etc then a very basic polymorphism is OK and we can skip generic methods. But something like Java 8 streams or Apache BEAM needs generic methods for the functional methods like Map (a Collection&lt;T&gt; has a generic Map&lt;U&gt;(func(T)U) method returning Collection&lt;U&gt;. If we miss this use case, then we miss the requirement for generic methods and maybe don't solve that problem. There are probably other interesting cases I am completely missing right now as well.
&gt; Linux and go is comparing apples to oranges. Linux has a massive workforce and every 8 weeks a huge set of bug fixes/features is ready to go. Go does not have as many developers and those releases would be smaller. I also mentioned GitLab, and there's the Rust release train, too. Team size has nothing to do with it. And who said anything has to be rushed? I specifically said: &gt; Set a timetable, and cut a release with whatever is ready at the time. The goal isn't to push things out the door quicker for the sake of it, but to tighten the feedback loop.
Agreed, however, considering the conservative approach they've taken thus far I have a high degree of confidence that they'll be able to manage it.
This made me lol (and want to upvote x100)
I do love Go a lot(even without Generics) AlienLang ---------- A few alien explorers from a galaxy far away visit Earth, and they want to communicate with us humans, for which they need a language. They could have used sign language but they don’t. It’s not clear whether it’s a cultural thing or that they might want to exchange more than the usual cry of “Bob” while pointing a body appendage towards self and then towards you(at which point you say your name or faint). So these ultra intelligent life forms that have traveled inter-stellar distances to meet with us folks set out to create a new language which can be easily understood by both alien and human. The only problem is that the alien is advanced to human by more than a million and close to a billion years. So they sit down and form a committee. As you can see they are not so different after all. You can imagine them to be a group of three. Two middle-aged aliens and a wise old alien. They are all very chummy and stuff and they fight and debate and come up with a specification for the aforesaid language and christen it, “the mighty gopher hates coffee beans and loves big snakes of the sea” as per their customary traditional practice of naming new languages. The meeting went something like this. “So we all agree that the language should have the basic constructs to allow these puny humans to understand our vast alien knowledge”, said Bob “Yes, we can’t really talk to them in our conventional multi-dimensional speech now, can we”, piped in Pipeson. “Yep, the last mud world we tried teaching our galaxy language to, misunderstood us for invaders. Invaders! We are only glorified geologists for universe sake”, said Grizzly while scratching his second head with his fifth arm. “The language is barely published and there are mass humans protests all across Earth accusing us of duplicity. Just yesterday, I walked by a group of ugly humans holding placards saying, “We are not dumb!” and “We are intelligent too!” and stuff like that. I didn’t get the, “Stomp the cockroach” one, whatever that means”, said Pipeson. “See, we all know in our vast alien intelligence that lesser building blocks for a language is a good thing. I don’t think they will ever understand. In any case, I think we have enough humans convinced to progress the language”, exclaimed Bob. “What about the rest of the puny humans?”, asked Grizzly. “Ah, I don’t know, shoot them with our atomizer guns?” “Well, the biologists are looking for specimens”. Meanwhile a group of red-orange aliens are about to begin their landing cycle in crate shaped ships whilst a bunch of engineers from Planet D are still fueling their ship at the last stopover. 
You're right. We should just use C instead of Go.
I just wrote a [clone](https://github.com/osteele/gojekyll) of the Jekyll blogging engine. This was going to be my weekend project for learning Go, and I got carried away. It was about 6x faster than the Ruby version without parallelism (but without any attempt at optimization either). Parallelizing it was near-trivial, and ended up about 20x faster than Ruby / 3x faster than single-threaded version. ([Benchmarks here](https://github.com/osteele/gojekyll/blob/master/docs/benchmarks.md).) In order to get this to work, I ended up [implementing the Liquid template engine](https://github.com/osteele/liquid) too. This was my first experience with Go. Between the tooling, language, and compile speed, I found it completely pleasant.
I care about generics and I use Go. Just because a language doesn't have a feature I really want doesn't mean I won't use it. I use Go because it makes my life better, not because it's the perfect language (it's definitely not).
If program structure is: * do all map initialization from data files * only read from map Then you will only need to serialize access to the map during initialization. if the map will be updated after initialization, you would need locking around reads and writes. here is an example of what I think you are trying to do: https://play.golang.org/p/lWl9vmiy6O (it won't run on playground since it accesses files and has the golang.org/x/sync/errgroup package, but the code runs fine on my laptop)
This will most probably happen before Go 2: https://github.com/golang/dep/wiki/Roadmap And it's indeed official. they closed GopherCon today with advising everyone to switch to `dep`.
You can do this without a channel. Just wrap the map in a struct that has a sync.Mutex and lock the methods to set/read the values. So, spin up your 50 goroutines, but have them all try to do a myStruct.Write(data ). That method would then be guarded by a mutex. Also yeah you'll also need to guard reads to the map with the same mutex. You could use a RWMutex here if you wanted, as well.
You don't want to use both a channel and a mutex, you should use one or the other. A channel that takes in the data to put in the map, and is only accepted from in one goroutine would be a way to approach this, if you pass around pointers. So each reader goroutine would only get to send off its data when the writer goroutine was ready for the next input.
I feel like I stopped hearing about generics for a while... But now it's back. 
How does that make sense considering Go is a garbage collected language and Rust has deterministic allocation/deallocation? 
You can point Windows and wsl gopaths to the same directory. That way you won't get missing package errors. Your linters should work too. This does require two installed copies of go though: one windows, one linux. Make sure the gopath is accessible to windows, then you can just use /mnt/c/$REST_OF_PATH as your gopath. You can even use multiple paths in your gopath so that your project dirs remain clean (go get will install to the first path in the list).
Agree.One of biggest reasons not to upgrade to Python 3 was lack of big incentives. 
I do it on windows, but I don't develop *for* windows. All go code is in a Vagrant box and is built there. I just use shared directories and Gogland and when it comes to compile time it's done in the box for linux.
It has go style channels but true multithreading is still in the pipeline.
Hmm, didn't really think they would be interchangable like that with cgo. I'll have to give it a try, thanks!
i hope it succeeds. its a nice language
Having a modern GUI framework to write cross-platform apps for android and ios(web and desktop,etc). I can do this in JavaScript nowadays but I prefer to do that in Go if possible.IMO,AOT compiled, GC optimized for latency and lower memory footprint make Go a good language for writing apps and even games.
Lol, Go is even more anal than Python 3. For Go, all text is UTF-8!
Yes, and people go to great extents to work around that like using `void *` (like `interface{}`) or [using the preprocessor to generate them](https://stackoverflow.com/a/11035347/49018). 
Thats why i use javascript. Go took a page from the "worse is better" playbook. 
So, the ability to import code from elsewhere is what makes it a "data structure"? If that's his point, he made it poorly. 
Thank you so much slimsag! helps me a lot ))
Go programming is all about simplicity and readability. In some case config struct is all we need and it is simple and efficient (e.g. Sync.Pool to pass a function!), sometime the config pattern using first class functions is simpler (e.g. for the parameters in the zap logger). The config patter is very powerful and impressive, but this power is not always needed and simpler code should then be favored for readabiliy and simplicity (the implementation). The main difference is that with the option patterns the options can do actions. Theses actions are encapsulated in the option parameter so that the object accepting these parameters may remain simple. It is then also easier to add a new option without needing to modifying the underlying object which is always good to avoid introducing bugs. There is no need for a religion war between both pattern preference. The only rational that should drive our code writing is to keep our code readable and simple, and to keep the API intuitive and simple.
That's the usual intent, no? 🤔
proxy: https://github.com/nadoo/glider
For cgo, it won't be interchangable, but at least your linters will mostly run and not complain too much while you're building on wsl.
Is Windows support on the horizon? 
Or you could use a channel. [This is a Go proverb, after all](https://go-proverbs.github.io)
Right answer! [Here's an example I just whipped up.](https://github.com/tmornini/async-file-processing-go) You may need to adjust the location of the words file on your system, and it reads the same file (words) for all readers, but it should make it clear enough how to make this fully async.
I wrote a small post om how to use your own tensorflow-model in go: https://nilsmagnus.github.io/post/go-tensorflow/
Any plans on doing an UI for this? I would love to have a tool like this for my parents and family to backup their stuff. 
Sure. I was paraphrasing criticism on the request for generics.
No. No, no. Definitely no. Completely, absolutely no.
Fine, but these features can make life easier. I like go's simplicity. It a sort of anti-C++. But I just don't think adding two or three features will make Go a worse Rust.
I agree with you. interface{} could mean. 1. I don't have a type for this. 2. I can't create a type for this 3. I want this to allow any type at all.
I never write them from scratch. There's plenty of well worn libraries already e.g. Glib, CCAN, or https://fragglet.github.io/c-algorithms/
That's not any old spear they're throwing either. That's a Rob Pike.
Go ahead, educate me, or do you prefer to just knee-jerk downvote everyone who doesn't fit to your echo chamber?
Instead of a config file, you might use [os.Getenv\(\)](https://golang.org/src/os/env.go)
Ok. This nails it. Thank you. I never bother to use this feature until now and relied only on the /* ... */ comments. 
Code duplication to work around the type system is the biggest pain for me, e.g. when handling database queries to get entities from a database (i.e. classic web backend stuff) we have to repeat the same function that is 99% identical to all the others functions in the package, but just use a different type from each other. This was highlighted perfectly by this twitter post: https://twitter.com/yogthos/status/883058510275149826 The "solutions" of reflection and writing self-generating code just don't really work for the teams I am working in (i.e. loosely-coupled, distributed teams working semi-independently on the same codebase). These approaches require too much coordination &amp; maintenance and are too brittle and easy to break. There are some third party libraries that abstract away the database stuff sure, but a) the database example is an example (i.e. this occurs with non-database code too), and b) not all databases can use the common third party libraries for various reasons. Right now the copy-paste approach that appears to be the de facto "work around" has its own problems by people just blindly copying chunks around without double-checking what they are copying which can lead to subtle bugs if the logic is not checked. I dont really care what name is used ("generics" or otherwise), but **some way of allowing a method to operate on objects of various types while providing compile-time type safety** would make my life in Go a lot nicer. In my experience of working with people who are coming to Go but are used to other languages, the lack of a way to operate on objects of various types whole providing compile-time type safety is a *major* stumbling block to them getting up to speed. As mentioned in the blog post, it is hard to "unlearn" the more sophisticated type systems from other common, widely used languages so people struggle getting their head around Go.
He did made his point in a bad way, however it's not about being able to import it, it's about being available from the get go instead having you coding them when you want them. Sure you can import them from somewhere but you're never 100% sure they're bulletproof
Wat. Confused
This is an interesting project and a nice short post about what you've learned. I'd add a little code example of what you've changed though. 
Limit connections in what way? As in max number of connections per second? If so, you're looking at implementing a basic rate limiter. There is a trivial but good learning example here: https://gobyexample.com/rate-limiting For config files, depends what you prefer doing. In my case, I use the excellent [godotenv](https://github.com/joho/godotenv) with a `.env` file at the root of my project. I then use `os.Getenv()` to fetch the value, as suggested previously
The fact that it's dynamic typed has nothing to do with its stability and how gofix can work. 
I already said it, wait for the video. Or read this: https://blog.golang.org/toward-go2
removal of named return values.
Why not? Isn't it much more difficult to transform a python program when you can't even assert types properly? 
Gonna pit it!
Why is there a UUID generator in the Linux kernel?
https://youtu.be/LSzR0VEraWw 31:10 Shows renamed types as unexported keys type when adding values to Conext to avoid clashing with anyone who has access to that Conext instance. 
The onus is on your regexp to check that. A parser can never guess your intentions. If you want to avoid this problem, prefix all lines with //
Not as yet; my plan was to set it up for my family members instead of writing a UI.
&gt; The problem is when I want to comment out a sequence of instructions But that is not what comments are for. They are for commenting your code. And if you want to use it for that purpose, `//` is much better suited for this exact reason. &gt; it is a problem if the compiler interpret the */ in the strings as comment end. But that is not what is happening. There is no "string" here, just a comment. Inside the comment, there are no strings or other go concept, because it's just text. And multi-line comments end on `*/`. You mention that it's not a problem with `//`, but the situation there is opposite: You have go code, containing a string and the content of that string is ignored by the tokenizer. &gt; I don't have a C compiler to check how it handles */ in strings. You also don't have a go compiler doing that. But also, any old C compiler does exactly the same thing. [Try compiling this](http://sprunge.us/dYbB).
As I said, I don't have a C or C++ compiler now to test it. But I now fully agree with you. It all make sense. Using /* ... */ to comment out code is an anti pattern. Thank you for taking the time to help me understand this. 
I personally use https://github.com/satori/go.uuid, it can generate all the different versions of UUID and it works on Windows.
block devices. Eg. your hard disk is represent by uuid which is stored in the superblock - same goes with plug and play devices.
Re 1: I'm sorry but I don't understand what you need from a sync.Slice. What is the context where a sync.Mutex+regular slice is not good enough? For sync.Map the context was that you had maps for memoization and one goroutine looking up an already-computed input was blocked waiting for a goroutine working on a different input. sync.Map separates those two so they don't interfere with each other. But different elements of a slice are already OK to access concurrently, and if you're doing things like append you just need a lock. 
It's funny because I don't understand. 
Your database example _sounds_ interesting and worth looking at, but you didn't give any details. That Twitter post is kind of useless. If the only thing you need from "generics" is the ability to write Min, then I can solve that problem in another way, like having a package min, or with a minimal generics that allows parameterized functions (like min) but not parameterized types (like Set&lt;T&gt;). Or if all I need is containers then maybe I can stop at parameterized types and not have generic methods. And so on. Real examples help define exactly how complex a generic system we are talking about. Min doesn't help. 
&gt; Bit backing is that supposed to be Bit Packing? 
Good idea, done!
get out of here kataras making new accounts to post this 
Funny enough most Py2-&gt;3 migration tutorials start with "print is now function, don't forget ()" like it was that easy. Little later they mention unicode is now default, and strings are little different. A lot of time later, lost nerves and **run time** problems encountered, you see that fixing all those "simple" string/encoding issues are just not worth it in most cases. That was last straw that made me quit interpreted languages for any complex projects, stick with Py2 for legacy stuff and keep away from Py3.
That would doom a lot of Linux distros that depended on Py2 at the time (a lot of them still do). D did something similar with 1-&gt;2 but didn't end well either. And MS finally dumped support for XP and started uploading malicious ("discouraging") patches years ago via updates but significant number of people steel keep XP around. Good things tend to stay alive.
By: Liz Rice Publisher: O'Reilly Media, Inc. Pub. Date: July 11, 2017 Many people use container systems like Docker, but how do they work? What do people mean when they mention cgroups and namespaces, or when they describe a container as a “lightweight virtual machine”? In this course designed for the intermediate level programmer (any language), you’ll discover exactly what a container is by writing one with a surprisingly small amount of Go code. Along the way, you’ll lose your fear of syscalls and learn that a container is really just a Linux process with its view of the world limited through namespaces, cgroups, and chroot. Gain an in-depth understanding of what containers are and how they work Learn how to build your own container engine using Go Master the ability to run containers with confidence Liz Rice is a technology evangelist for Acqua Security, the CEO of Microscaling Systems, and one of the developers of MicroBadger, the tool for managing container metadata. An in-demand speaker at O’ReillyOSCON and Velocity conferences, Liz has 25+ years of software development, team management, and product management experience working with network protocols, distributed systems, and digital technology in sectors like VOD, music, and VoIP. http://my.safaribooksonline.com/9781491988404
&gt; Also it doesn’t make a lot of sense to have to declare default behavior as a mode. The default functional option shouldn't take arguments. It's an explicit indication of what's being established. It ~~does~~ can make sense, but not as implemented. Apologies if I've misunderstood your code or standpoint.
Is that last part a Rust reference?
Python literally changed it's function syntax. They did not "try." 
Im curious, which part of my post do you object to? The part where i anchor go to javascript, or the part where i said go as a language subscribes to the "worse is better" philosophy?
This brings up two important issues. - O'Reilly no longer sells non-DRM epub books (which is a great shame - they were the best distributor). - Kataras' behavior while leading Iris can best be described as cancerous. Edit to add: Apologies to Liz Rice. I do suggest not downvoting the opening post in order to avoid giving any appearance of dissatisfaction with what Liz has put together (unless that is one's assessment of Liz's communication).
Honestly, I would prefer things like: - Enforce nil checking, idioms are ok, but allow the compiler to check if errors are not handled for me would be better - Interfaces with default methods implementation - Extensions, ala Swift Than generics…
[removed]
Hey. Looks like the project is not "aquired" anymore... 
This package also seems quite a bit slower: ➜ uuid_bench go test -bench=. ./ BenchmarkSatoriUUID 1000000 1784 ns/op BenchmarkYbubnovUUID 300000 5917 ns/op PASS ok _/home/connor/uuid_bench 3.645s Source: https://play.golang.org/p/c3OH7DDDat
You shouldn't put things back into a sync.Pool until you're done with them; another routine could pick them up in the meantime and you'd end up with a data race. If a result is being returned from the function, you wouldn't want to put that result back into a sync.Pool since you can't tell if the caller is still using it when it's retrieved; sync.Pool isn't made for this situation. The most common use cases are around scenarios where you want to reuse intermediate data structures or slices. For example, in one server I wrote, I want to gzip outgoing messages. I use a sync.Pool that stores structs containing input buffers and [gzip.Writers](https://golang.org/pkg/compress/gzip/#Writer) that point to those buffers for their output. When messages come in, I ask for a writer and buffer pair from the pool, write my message and read it out from the buffer, then [Reset](https://golang.org/pkg/compress/gzip/#Writer.Reset) the writer and buffer before returning them to the pool. While the output data must be copied out of the buffer, this lets us reuse the core data structures instead of allocating them anew each time.
Never got a confirmation email.
sure :)
username checks out
[removed]
Hi Russ, Thank you for replying. The problem is that people can make a humanly mistake in forgetting to wrap the data structure with Lock(), Unlock(). Why take that chance if the language API can prevent that.
The sad O'Reilly DRM story aside, is the Iris project and it's shoddy maintenance history really relevant? 
I would guess /u/daveddev is taking shots at OP who is the owner of said project.
The actual number of connection. So if I run the code right now, my other machines can `telnet $hostname $port`. If i limit the connection to 1 for example. My first machine can do the telnet but other will get the connection refuse until my first machine abort the connection.
Absolutely. The referenced behavior should be kept in the light so that others do not get swept up in Kataras' [~~exploits~~ exploitations](https://www.reddit.com/r/golang/comments/57w79c/why_you_really_should_stop_using_iris/).
Easy example. Everything in this repo would be type safe: https://github.com/emirpasic/gods
I still fail to see how it's relevant in this post. Is /u/iris-go and Liz Rice the same person? 
Cool, now lets see if we can get some examples of how that might look using different with ideas for how generic could work in Go.
Lol...I know what that's like. I think having a UI would make it easier for a lot more users to use it though.
How would this look like using go generate?
The justification for my comment being off-topic has been stated. Your failure to see how it's relevant in this post is irrelevant to me. *Edited to exchange sarcasm for curtness.
It would look horrible. You would have N structs and N*M functions (where M is the number of methods of the datastructure) for N different data types and 99% of it would be redundant, ugly code duplication.
I don't think anyone is saying you don't know any possible use cases for generics. If you're referring to my comment(s) the point I was trying to make is perhaps not as clear as I intended. By pointing out the internal builtins which have generic forms, I was pointing out that you already have (some) concrete examples and you know the reasons for them better than anyone in the community. As a thought experiment: remove make, new, print, etc from the language spec in Go 2.0. Maybe forbid interface{} too. Instead of readding them, add a section on a proposed generics implementation. Are the use cases that the builtins were created for covered? Can they be implemented by anyone, without special compiler support or further changes to the language? In my opinion, this should be the first step in evaluating how a proposed generics implementation would affect the future of Go.
For 1 - You could also use a flag with a default value port := flag.String("p","2000","port to listen on") flag.Parse() startsocket(":" + *port ) For 2 - you'd need to stop and start the listener once the current connections reached/went below the limit. it would be a bit simpler (and easier to troubleshoot) to always accept connections, but return an error message and close the connection immediately if you are over the high-water mark.
I'm not sure what you are asking? Syntax maybe? Just replace `interface{}` with, say,`T`: type Set&lt;T&gt; struct { Add(element T) Remove(element T) Contains(elements T) bool } func main() { mySet := new(Set&lt;int&gt;) mySet.Add(1) // works mySet.Add("1") // compile error var foo interface{} foo = 1 mySet.Add(foo) // also compile error mySet.Add(foo.(int)) // compiles and works fine, but potentially a panic risk at runtime } Obviously syntax can be whatever, but you get the basic idea.
As the time passes, Go will become more and more mature. With Go 2, people might have to learn/unlearn some things and possibly new stuffs will be added. Most people like Go because it's very easy to learn and simple to work with (I like it because it compiles directly to machine code, has a very good standard lib and so on), but as a developer with a c++ background, I would really like Go2 to deliver a lot more low level stuffs that would offer better performance and scalability. At the end of the day, if the creators of the Go decide to implement new features (I'm not saying generics) that will offer better performance and maybe will make the language harder to learn I'll take the deal. Maybe you don't realize it yet, but when working in production, you'll see that Go still needs improvements.. 
I'd rather avoid this here. Weighing the differences between generics and code generation is both important and complex, but there are other discussions already started. The repo provided is a good case for consideration. I'd like to see submissions showing how it might be adapted to work with generics and I wouldn't be opposed to submissions comparing that code generation. But I really think we keep this a collection of examples and let the discussions happen elsewhere.
Good job but I think you meant mySet.Add("1") // compile error 
Thanks. That's what we're looking for. It's a good example of one way it could be done.
So I guess library makers could have some problem, because their library should cover as many situation as possible. (safely) On the other side, application makers maybe not that bother. Because they have very specific problem.
&gt; I'd like to see submissions showing how it might be adapted to work with generics I agree, I've given one such example above. By the way, I'm curious what you mean by this: &gt; I need to see a model that is highly readable across most cases and many skill levels. As far as I'm concerned, there is only one "skill level" here. Those who have learned Go, and those who have not. Otherwise, we'd go down an endless rabbit hole. What skill level does `make` target? How about `new`? Or how about pointers `*`? The point is, you either learn them - and hence use them - or you don't. On readability I agree with you. Though I would consider generics implementations like Java and C# to be readable enough.
Yes, sorry. Fixed.
No need to apologize mate :)
Even in applications, if I have a method that needs to work with integers, I'd still like it to work - in a type safe manner - with int8, int16, int32, int64 and int without code duplication.
Skill level varies. Not everyone is a great programmer and that is ok. It's important that code written by below-average developers is still easy to read and maintain because statistically, half of us are below average. Only considering the best case would look like is mis-guided, we need to consider what the majority of code will look like.
Here is an example of sending an error message and closing the connection when you are at the conn limit: https://play.golang.org/p/vMk3YbnCay
&gt; Though I would consider generics implementations like Java and C# to be readable enough. public static &lt;I, O&gt; ListenableFuture&lt;O&gt; chain (ListenableFuture&lt;I&gt; input, Function&lt;? super I, ? extends ListenableFuture&lt;? extends O&gt;&gt; function) [dear god make it stop](https://youtu.be/5kj5ApnhPAE?t=2m8s)
&gt; It's important that code written by below-average developers is still easy to read and maintain But wouldn't that also mean if a feature is "too complex" for below average developers, they would either: - not use it - use an already implemented solution by people who know better There is a reason "do not invent your own crypto" is a thing. Most developers can't write high quality crypto code and that's perfectly fine. Every software, every feature has its *users* and *developers* and there is nothing wrong with that. 
That's a funny example, and yes it's possible in those languages, but it doesn't have to be like that for Go. Just `type Foo&lt;T&gt; struct` would cover 90%+ of the cases.
I think you raise a good point. I feel like data structures are generally when I feel the pain of lack of generics in Go because Go forces me to write boilerplate and doesn't give me type safety that I want from a statically typed language. For applications, it would be an extraordinary scenario for me to genuinely need generics which is maybe why most gophers don't feel like they need generics. I would even argue that liberal use of generics in applications generally makes code harder to understand, so I see the appeal of wanting to keep it out of the language. Maybe a good compromise would be to have a standard library of all of the commonly used data structures be implemented generically like slices and maps.
I don't think the problem here is generics exactly? Part of why this looks so horrible is that Java decided to implement Functions using generics. Another part is the confusing nature of inheritance and wildcards in Java, so the keywords like ?, super and extends make this very hard to read. This particular example wouldn't look nearly as bad in Go.
If it's harder to learn it's not more Go...
I agree that it's important that code written by below-average developers is easy to read and maintain, but below-average developers will always make bizarre design decisions and abuse features and make code hard to read. I think Go is a really simple language and I love Go because of it, but an ex-coworker of mine still managed to write a lot of totally unmaintainable and unreadable code.
It's not because a problem can be resolved with generics that it's the only way to do it. With closure for example, with interface (i don't mean interface{})... For this kind of features it's maybe better to add them in the stdlib like map and slice than add generics for everything. I think the difficulties when we come from a language where we use generics, or dynamic language, is that we want to do exactly the same. But when we can think a little bit different we can find other ways and maybe better way. Generics has a lot of advantages but it's also very difficult to maintain in the long term.
C doesn't have mandatory garbage collection.
&gt; find example in public repos of code other people wrote that you think could be improved by generics Great idea. Perhaps better if limited to the standard library.
Curious: How many people use Gods in practice in production code? Were it possible to use with generics how many of you would actually use this package? [Rob Pike's rule of programming](http://users.ece.utexas.edu/~adnan/pike.html) seems pretty profound for promoting Go's traditional universal comprehensibility. If you haven't read this before, I would encourage you to do so. Kind of hits at the problem of day-to-day industrial usage as opposed to hypothetical missed opportunities.
Go does not subscribe to worse is better. Go has less because less is exponentially more: https://commandcenter.blogspot.ch/2012/06/less-is-exponentially-more.html
just use a global `var active bool` that you check against when a new connection comes in? If `active` is false accept the connection, otherwise bail.
&gt; With closure for example, with interface &gt; But when we can think a little bit different we can find other ways and maybe better way Can you give some for examples for this? I would be really interested to see what an alternative to generics would be that keeps the baseline properties: - compile time type safety - no code duplication
&gt; How many people use Gods in practice in production code? A [fair bit](https://github.com/search?q=%22github.com%2Femirpasic%2Fgods%22&amp;type=Code&amp;utf8=%E2%9C%93) actually and this is just open source projects on one website. &gt; Were it possible to use with generics how many of you would actually use this package? Many, many more. See how popular datastructures libraries in other languages are. Hell, some of them include it in their standard libraries. &gt; Rob Pike's rule of programming seems pretty profound I really find these appeals to authority, these "more royalist than the king" attitudes, really confusing. Even Pike himself admits there are many design mistakes in Go. What makes you so sure that he was wrong about all those mistakes but is actually right on this one? Can you present technical arguments, without reaching for "profound quotes", why generics would impose some insurmountable comprehension problem?
Some of the data structure libraries I wrote would be so much cleaner with proper generics. Right now I have to use codegen to achieve proper type safety (with optimal speed)
[removed]
First they laugh at you, then they fight you, then they join you.
Task is a simple task runner / build tool written in Go. I started this because I dislike Make odd syntax and weak support for Windows. A lot of improvements were made since I first posted the first version here in /r/golang * support for task templating and variables * use of concurrency to run dependencies for faster builds * it now uses a pure Go sh interpreter, so commands should work on Windows without having to fallback to cmd * experimental watch * a lot of internal improvements and performance optimizations (still a work in progress) * others
&gt; I would really like Go2 to deliver a lot more low level stuffs that would offer better performance and scalability. I'm not sure Go is the language you should be looking at for that. Go is an attempt to get as close as possible to systems-level performance without going down the complexity hill that languages like C++ and Rust have to deal with to get there, yet without the verbosity of Java or the ceremony of Haskell (or rather, the ceremony of GHC to get those sweet optimizations). If you want more power without the traditional pitfalls of systems languages, Rust is your best bet. Otherwise, do make sure that Go *really* makes it too hard to hit the performance requirements your project has.
I would suggest using git describe (--tags) to get a nicer version string 
The point of the thread it's to provide examples of code code other people wrote. This comment does neither. It belongs in one of the many other threads on the subject.
We use it in production and the lack of type safety is really annoying. It's not as big of a problem if you have an IDE, I suppose, but not everyone at my workplace uses one. I don't disagree with the quote, but I don't see how that's relevant... There are still very legitimate reasons to use binary trees/heaps/LRU-caches/etc to improve performance without writing fancy algorithms.
not to mention that the lack compile time safety comes with small runtime overhead
I'm still waiting for someone to at least remember that any non-stack interface value is creating additional pressure on GC and ruins cache locality. This is why writing lock free or fast data structures is currently relying on code generation. However - the code generation doesn't allow you to implement the proper set of constraints on the type before allowing you to place it inside function or struct (or more precisely it would require some non standard thinking - see taylorchu GitHub for solution). And now try to create cache of caches... 
That sounds like worse is better to me. https://en.m.wikipedia.org/wiki/Worse_is_better. Can you explain the difference?
**Worse is better** Worse is better, also called New Jersey style, was conceived by Richard P. Gabriel in an essay "Worse is better" to describe the dynamics of software acceptance, but it has broader application. It is the idea that quality does not necessarily increase with functionality—that there is a point where less functionality ("worse") is a preferable option ("better") in terms of practicality and usability. Software that is limited, but simple to use, may be more appealing to the user and market than the reverse. As to the oxymoronic title, Gabriel calls it a caricature, declaring the style bad in comparison with "The Right Thing". *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/golang/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.24
In an ideal world, one benchmarks and is already satisfied. Most of the content was about the optimizing part, not the benchmarking part. Benchmarking is tricky on its own.
Happy birthday! Tbh, I feel c++ easier than rust, but that's just me ;)
Would the go ast package be simpler with generics?
Seconded. Java was my daily driver before coming to Go. Each time I have to touch a piece of code that is Future-heavy, my remaining joy for the language dissipates rapidly.
The obvious first case is reusable data structures.
I doubt it's that interesting to you, but I put some ideas in that area into: https://github.com/Redundancy/jobless 
It's "it depends" question. Depends on size of your project, stage of your project, how many people are involved. Reality is that those things evolve as things progress. Trying to do create perfect setup from the start is a mistake. I start with only dev. It takes a bit of time and programming before a project is ready to be deployed in production at all. When that time comes, I write a deploy script, to automate deployment. Usually I develop on mac and deploy to Linux, either Ubuntu or CoreOS (https://blog.kowalczyk.info/article/5/blueprint-for-deploying-web-apps-on-coreos.html). If the project doesn't need complicated setup, there's nothing to do for dev - it's just running executable on my mac. I don't complicate things with staging. If my website requires a database, for dev I set it up locally, with docker (https://blog.kowalczyk.info/article/w4re/using-mysql-in-docker-for-local-testing-in-go.html). If things are getting more complicated, I might go full docker for dev setup, to make it more like production. At this point there's infinite variety possible. If you have tens of programmers, a complicated setup, you'll need someone dedicated just to setting up and managing dev/staging/production. There's no unification at this point because there are too many variations and unique demands and too many possible services to use (GCP vs. AWS vs. Azure vs. Digital Ocean, datadog vs. new relic vs. prometheus etc.) 
I think generics is ALSO a way to fix tedious error handling. Instead of: func process() int, error { myNum, err := numFromDb() if error != nil { return nil, err } index, err:= storeInDb(myNum+ 1) if error != nil { return nil, err } return index, nil; } you could have: func process() result&lt;int, error&gt; { return numFromDb().map(func (int myNum) { return storeInDb(myNum + 1); }); } that with minimal sugar a la rust/async-await syntax, would become very easy to read, something like: func process() result&lt;int, error&gt; { myNum := try numFromDb(); return try storeInDb(myNum + 1); } And of course, some type-safe FP classic constructs, like that one I just used (map), are also a nice add.
It depends on what your program tries to do. Say for example that you need to find if a string contains a certain character or phrase. You probably don't want to write that algorithm yourself and most languages offer it on their standard library. Go does as well with [strings.Contain](https://golang.org/pkg/strings/#Contains). So in this case you have to use the [`strings`](https://golang.org/pkg/strings/) package. Say you wanted to convert a string to an integer, then you will need the [`strconv`](https://golang.org/pkg/strconv/) package. If you want to write a web application you will need the [`net/http`](https://golang.org/pkg/net/http/). Need to work with a database? There's [`database/sql`](https://golang.org/pkg/database/sql/). Need to work with JSON? there's [`encoding/json`](https://golang.org/pkg/encoding/json/). And the list goes on. Just focus on what you want your program to achieve and eventually you will find out which packages you need. Google is your friend and you can always ask a more specific question here or at the [bridge forum](https://forum.golangbridge.org/).
Unfortunately, Go is not designed with generics in mind. If you wanted generics to work well, you'd have to design them into the language from the ground up. Just look at what happened to Java.
Great example of what not to do, IMO. If you want to code in Rust, you can always try Rust! What you did kills readability IMO (in the sense that now there's some magic I need to understand before knowing how errors are handled - maybe it would be clearer for me if I knew Rust?)
I think in order to have an in-depth debate about parametric polymorphism, it is a good idea to become familiar with not just the popular approaches used by Java and C++, but also with well-understood alternative forms. Most importantly: 1. Modules parameterized by modules (ML functors, Ada generic packages, Modula-3 generic modules). Especially as they have a solid history in system programming languages. 2. Typeclasses (Haskell's version in particular). Note while they are popular in functional programming, they are not inherently tied to functional programming in any way, shape, or form. Java generics and C++ templates have very specific and idiosyncratic characteristics that one should not generalize for all kinds of parametric polymorphism.
We should just think about "what is likely to be copied and pasted from Stack Overflow questions to the most frequent cases".
Or on the Slack channel https://invite.slack.golangbridge.org/
You can have a read here about generics in Go https://github.com/golang/go/issues/15292 However, before jumping to the solution, make sure you define the problem, the examples show the problem (and are not forced to show it but rather they are natural, from code itself), think about solution and the ramifications of that solution.
If you want to test this 110%, create an integration test for `kataras`.
&gt; I'd really like to hear some thoughts about what are going to be my headaches during the process. The headache you should be worried about is the maintenance 6 months after you write it.
More speed, smaller executables
I think that's actually a fairly easy abstraction. But of course I might be wrong. It's shown in Rust but also in many other languages, like C# or JavaScript. I don't think there should be any problem about taking inspiration from other languages, you should get used to hear references like that in these kind of threads. Telling somebody to go try X sounds a bit rude IMO
Agree. I don't see the point of adding this mental overhead when reading code just to avoid typing a few lines. Go gets this right at the moment. I hope it doesn't change.
I apologize for it, I didn't mean to sound rude at all - what I meant by it is that different languages have different idioms that stem from the nature of the language (like using macros for error handling, etc) - like I've seen people needlessly use callbacks for things due to them coming from JS/Node. Go's error handling (tedious as it is, and I agree) is how it is because the language values explicit behavior over implicit behavior (i.e., less expressiveness at the cost of higher readability). No matter how comfortable you are with the "try" idiom from Rust, an explicit "if err != nil {}" will always be clearer, specially to a newcomer to the language. Imagine now if every framework decides to have their "try-like" idioms for error handling! It doesn't happen with Rust because that was already formalized from its inception, which is not the case with Go.
A couple of thoughts. Go and its community tends to stay close to simplicity and pragmatism. First you should ask yourself if such a generalized, powerful and complex configuration system is really needed. I believe the existing configuration "solutions" like using JSON, TOML, YAML in combination with flags and environmental variables can get the job done just fine. Also take a look at how the Upspin team use a very simple, custom [configuration format](https://github.com/upspin/upspin/blob/master/config/initconfig.go#L103-L110). On the other hand if you feel passionate about this project or if it is a learning exercise then that's a different case. In the end, from the Go community's perspective, any port from X to Go is always nice to have. Going away from the "if you should" question, my advice is to avoid "translating" the Java implementation to Go. They are very different languages with very different programming styles. Something that might be relevant and could probably give you some inspiration is Rob Pike's [talk](https://talks.golang.org/2011/lex.slide#1) on [lexical scanning](https://www.youtube.com/watch?v=HxaD_trXwRE). Cheers.
I see. So I guess his point was C doesn't come with provided data structure libraries? that's a far cry from what he said, but sure. Oh, upvote for keeping it civil; thanks for that.
We have an automated process to build, Dockerize, and test our microservices. We get identical results locally on MacOS X and Travis CI. Travis further builds AWS CloudFormation ECS environments per branch (upon request via a git comments) and deploys the tested containers into said environment. It's been really great to have a history of our infrastructure right in git.
I don't need this, show me an example where I can't use an interface.
You have to try them out. It's the only way to learn any. The most popular beginner one is bufio https://godoc.org/bufio Go core https://golang.org/pkg Most popular https://godoc.org Wiki list https://github.com/golang/go/wiki/Projects
Please could you give more details about tools you use to automate maybe you do that with capistrano, or Fabric... and what you use as built engine ?
Your tool has a very similar idea to Task. Task at this point is a bit more advanced, since it got a few users and contributors. I found a few small tools in this area actually (see "Alternatives" in the README), but most of them missing some aspect I'd like to have. This shows how some people miss something strong for task running. Thanks for sharing!
https://github.com/emirpasic/gods
&gt; Even Pike himself admits there are many design mistakes in Go To my knowledge, not having generics is not one of those. &gt; I really find these appeals to authority, these "more royalist than the king" attitudes, really confusing What confuses me is when people throw popular logical fallacies out there and then somehow think they've made a point. Appealing to the authority when the said person is very clearly an authority can be very useful, and is certainly not a fallacy in the correct context. The American Justice system, for example, can be viewed as a system built on appealing to authorities. When a lower district or circuit court cannot decide a case, it quite literally appeals to authority. When no one can decide, it is place upon the ultimate judicial authority in the Union, the Supreme court. &gt; The valid form of [the appeal to authority] argument is one in which a recognized and knowledgeable authority on the relevant subject is appealed to by citing a statement by that authority. Just like the slippery slope fallacy is not always a fallacy, and sometimes appeal to emotion is often the only mechanism to get human beings to move and achieve something -- we are not robots with infallible logic, and sometimes we need to take shortcuts -- and there are contexts where those shortcuts are necessary, cogent, and valid.
I don't see why it would be complicated for Go to support something like CUDA or SIMD operations for users that want to dig into a library to gain that performance. Can you give an example of the added complexity you expect?
Damn it, already forgot all this crap...
Yes; This was addressed explicitly. I make no apology for my comments being off-topic. And even less so to those who are rallied by vulgar expressions.
Sure. I agree with you on that. It's just that reading some comments here (and more on HN), it seems that people don't get https://en.wikipedia.org/wiki/Ship_of_Theseus
**Ship of Theseus** The ship of Theseus, also known as Theseus's paradox, is a thought experiment that raises the question of whether an object that has had all of its components replaced remains fundamentally the same object. The paradox is most notably recorded by Plutarch in Life of Theseus from the late first century. Plutarch asked whether a ship that had been restored by replacing every single wooden part remained the same ship. The paradox had been discussed by other ancient philosophers such as Heraclitus and Plato prior to Plutarch's writings, and more recently by Thomas Hobbes and John Locke. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/golang/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.24
that method will only limit my code to have one connection. My ultimate idea is to have a config file specify the port, max num of connection, rate etc... have my code parse it and act accordingly. Just like a system software. 
Looks like a cool project to me. You can probably reduce the amount of code duplication for the 3 different anltr entrypoints by using a single function for lexing onwards as the streams are all the same interface. I would also restructure the project a little bit so that you can keep generated code separate from regular code, and you probably don't need tests for the generated code only how you use it. It might also be worth looking at hand writing a parser for something like this at a later point, though I appreciate that is a pain. Take a look at the go template library implementation for a novel way of doing it. I think the other comment on this topic mentions a talk about it as well. 
the above is exactly what I wish to do. I got a few questions. 1) why the function echo need to take `count *int64` as one of the argument. Isn't the count the maximum number of connection? if so why does that functions need that parameter? 2) Inside the echo function why do you need `c.Close()`? Is that even neccesary? the closing of the connection is either the program stops, or the machine that's connected to it stopped, or there's more than the maximum number of connection have reached which is handled by the c.Close() in `overLimit`'s c.Close() clause. 
Do you know if this parser acts like strict mode Liquid or original relaxed Liquid? The original parser was regex based and basically accepts anything and tries to interpret it. For example, there is no way to cause a syntax error in variable interpolation, and if statements silently ignore anything after invalid characters, so using '&amp;&amp;' instead of 'and' will silently do the wrong thing. Implementations of Liquid have a choice between being strict and having sensible parsing with proper errors, and not breaking on existing templates that messed up but happen to mostly work. Which did you choose?
Thanks for pointing us to this course. If anyone wants an "executive summary", here is a [video](https://youtu.be/Utf-A4rODH8) (also by Liz Rice) that shows how to build a container in about 60 lines of code and within 20 minutes. (Might be a good teaser for the course if you are not sure whether you want to spend the time.) (I wrote down the code from the video [here](https://gist.github.com/christophberger/58505418133d474486a88f958d8ea14b).)
Video linked by /u/ChristophBerger: Title|Channel|Published|Duration|Likes|Total Views :----------:|:----------:|:----------:|:----------:|:----------:|:----------: [Building a container from scratch in Go - Liz Rice (Microscaling Systems)](https://youtu.be/Utf-A4rODH8)|Container Camp|2016-10-13|0:19:04|63+ (94%)|2,745 &gt; Everyone has heard of Docker, but what is a container? Is... --- [^Info](https://np.reddit.com/r/youtubot/wiki/index) ^| [^/u/ChristophBerger ^can ^delete](https://np.reddit.com/message/compose/?to=_youtubot_&amp;subject=delete\%20comment&amp;message=dka8u1g\%0A\%0AReason\%3A\%20\%2A\%2Aplease+help+us+improve\%2A\%2A) ^| ^v1.1.3b
Why this much zealotry against generics ? Of course you can use an interface but in many cases it's just a hack : it's not type-safe, it can't be optimized (monomorphization + inlining) then it has a performance overhead. Generics are not more difficult to use than interfaces, it's just a better version of it most of the time. You should use generics almost all the time, and use interface only when you want type dynamism (you want to opt-out type-safety).
One thing I like to see in Go 2.0 - and like it more than generics - is the ability to assign an instance of a type to an instance of a second type, in which, the set of the fields of the second type, is a subset of the set of the fields of the first type. It is preferred to not overload the equal sign for this. Maybe a &lt;== b?
"Don't worry about the future. Or worry, but know that worrying is as effective as trying to solve an algebra equation by chewing bubble gum. The real troubles in your life are apt to be things that never crossed your worried mind, the kind that blindside you at 4 p.m. on some idle Tuesday." (From [this Mary Schmich column](http://www.chicagotribune.com/news/columnists/chi-schmich-sunscreen-column-column.html) that later was turned into the famous "Sunscreen Song".)
And if they are going to generics, I prefer package wide type variables. For example one could have a generic package this way: package gpkg type T type U And in the package we use it, we could fix down T and U: import "gpkg" type gpkg.T int type gpkg.U SomeStruct 
Or extend the copy function to do this.
For example https://golang.org/pkg/sort/#Sort 
You're right! That would be the most rational.
Question to the r/golang moderators: If you're going to insist that people follow the Code of Conduct, then why isn't that rule being enforced here (and elsewhere)?
Then simply increment the connections on a counter variable and define a maxConnections that gets loaded from your configuration file. You can even set it to a default value if no value is set on the config file. I’d do all this in the init function!
That only satisfies one of the conditions (compile time type safety), not the other (no code duplication).
Pretty sure you can do this with the powershell command [Set-NetFirewallRule](https://technet.microsoft.com/en-us/itpro/powershell/windows/netsecurity/set-netfirewallrule) using the os/exec package to invoke powershell. Probably need to have elevated privileges though. 
You mean code duplication in Len, Less and Swap ?
Yes. If you have 3 types (say, `int16`, `int32` and `int64`) you need to write 9 functions, whereas a generic solution would only have 3.
What if you wanted to use the same package twice, with different types, in the same function?
Do you use generics in your .net microservices?
What do you find unreadable about this? It looks perfectly readable to me
It would be simpler with sum types.
Nice find. I actually feel sorry for the guy.
oh yes, all the time, like for collection classes.
Do not invent your crypto isn't because developers can't write quality code, but because that code hasn't been in wild long enough getting dissected by large number of smarter and more motivated people searching for holes in it. Even crypto designed by most capable cryptologist don't mean much before it is time tested by peers.
&gt; Do not invent your crypto isn't because developers can't write quality code, but because that code hasn't been in wild long enough getting dissected by large number of smarter and more motivated people searching for holes in it. Oh it's definitely for both. The sheer number of "secure password libraries" (where, by "secure" they mean double md5 etc.) you can find online is proof of that.
Double MD5 is not quality code. In this context quality has more to do with developers understanding of cryptology than with programming practices used to write source code.
Thanks for that. Had no idea that forum existed and it's great. :) 
Do you frequently use more complicated collections than maps and lists?
`Min` and `Max` functions. 
**Learn it if you're gonna use it.** If you came here just to ask if you should use Go, you probably don't need it unless you have a real use case. I'm not trying to stop you from learning Go, at the end of the day, you decide what fits the best for you ;)
I didn't really think this through. It just seems (IMHO) this way compiler would be able to provide smarter assistant. Maybe those type definitions could move right before where they are used? Inside a *with* statement? I just have a feeling that with how interfaces work in Go, adding classic (C#, Java, ...) generics might not be something that straightforward.
You're right. But "a little copying is better than a big dependency"... I see a problem with duplication of "sort" algorithm because if there is a bug in it or an enhancement it's better to correct it one time. But for Less, Len and Swap i don't see a problem when they are duplicate. Or they are so simple that everybody can understand and it's very easy to copy, or they are not simples then it's better if they are not part of the sort algorithm. 
Guys, problem first solution later. This thread is unfortunately not about the problems we want to solve, instead the focus is on one solution which is great in some languages but a little bit awkward in go imho.
This does raise a potential source of problems, though. Right now, we get the benefit of compile-time checking of types so for example int8(1) &amp; 0xFF00 results in a compile error (constant 65280 overflows int8). If one were to make a generic function that accepted all sorts of ints as an input but was expected to result int8, int16 etc, you would lose that type checking and I can see that causing bugs down the road. The other option would be that the compiler would enforce it through generics, too, but then you'd still have to pretty much write all the separate versions anyway, but through a type-switch I imagine? 
&gt; However the notification is never displayed. Check and handle errors.
C# is an everything and the kitchen sink language. Go isn't and, hopefully, never will be. Developers need languages that are easy to understand and master. We need a feature set that's sufficient to be expressive and powerful enough to implement efficient software. Go strikes a really nice middle ground here. Most other languages are focused on doing as much as possible, regardless of the cognitive burden placed on developers. In particular C# has within it radically different programming paradigms: C-like imperative constructs, Java OOP, Generics, standard Threads and the radically different async/await, a completely separate asynchronous mechanism via the now-archaic events, dynamically-typed objects for interoperability with other programming languages, ... Perhaps the quintessential example is LINQ. They actually implemented an entire DSL within C# so that you don't have to write SQL in strings anymore. C# is really a dozen programming languages mashed together. As a developer it means understand C# programs in the wild can be quite difficult, and when you're writing them you're left with so many choices you don't know where to begin or the tradeoffs inherit in each approach. C++ is cursed with this exact same problem. Go is popular because its a getting-things-done language where developers feel like they can build powerful programs quickly. The simplicity and minimal feel of the language is what makes this possible. I'm all for features when they make sense, but you've got to assess the cost of them. I'm scared a Go 2.0 will end up killing the golden goose.
If a programming language used to develop Docker and Kubernetes can't be considered mature, I'm not sure much else can :)
i log those errors in my code, i just remove it here for brevity. there's no error logged when i ran it though.
I don't use `interface{}` either, deal with it.
&gt; Most other languages are focused on doing as much as possible, regardless of the cognitive burden placed on developers. Great reply!
You probably just need to wait for the termination goroutines to finish before exiting the main function. I'd probably do this with a sync.WaitGroup Could pass a *sync.Waitgroup into your function, call Add(1) on it, and call Done() on it in the goroutine as it returns. Then just call Wait() after your loop in main.
Everything not mentioned was written by us. Unfortunately, not yet open source.
1. Your main function is likely terminating before the go routine gets scheduled. If you need to use goroutines, consider using a sync.WaitGroup in terminateBrowser. 2. You're not running the command. See the examples in the go docs of os/exec for how to use exec.Command
1. the `main` function is not terminating since it has a `ticker` that ticks every five seconds. if you run the code, you'll see that it doesn't exit unless you press `CTRL+C`. I'll try to add a `sync.WaitGroup`. 2 . didn't you see the `Run()` call at the end?
Oh, sorry. reddit cut off the Run call in the div on mobile unless you manually scroll over. It literally cut it off at the `)` after the Command argument..
no worries fam
If you like .net then please keep using it. I like Golang and keep using that. I do not think there can be one language that can please all. We need different languages for different people and different use-cases. Think of cars: if I look outside my window I see many different brands, models and colors. And if not anything else, people like to be a bit different then the rest ;-)
If languages are cars, Go is simple as a bike and so fast in current city from door to door without consuming a lot of energy even with an army of bikers :-) Please don't put an engine, two wheels more and a top just because in an other life you transported an heavy load on the rain it will become a truck in traffic... 
I am a long-time C# developer that uses generics (and LINQ) a lot. I also have several Go projects - cli, web sites, and services - no generics and loving it. A lot of C# libraries with generics are overengineered. I could do without LINQ easily too, although that would result into some more boilerplate code. But I could write more efficient SQL than LINQ.
What's wrong with being able to pass a string to a math function and have it be assumed to be an integer? I see no problem there.
what about implementation of the actual methods? that's a struct type, but it defines no fields, and it defined methods in its type declaration? That looks an awful lot like an interface type. 
It implements only strict mode. I’ve updated the README with this.
I suggest you read part 1 as well, and let me know how I can improve the series :) I still have a few things to write for pt. 3
You think the reactions are for no reason?
1) echo's count parameter is the number of current connections (limit passed to overLimit is the max number of connections). It gets passed as a *int64 so the atomic.AddInt64 can be used to correctly modify the value when multiple goroutines may be accessing it at once. Slightly modified var names to make it clearer: https://play.golang.org/p/6tkojLh_W- 2) It is good practice to close resources when they are not needed. In trivial programs it might not matter, but get in the habit so you won't be troubleshooting resource leaks as the programs get more complicated. 
&gt; it now uses a pure Go sh interpreter, so commands should work on Windows without having to fallback to cmd That's a neat feature, nice work!
There is also #go-nuts on freenode IRC.
&gt; Go is even more **anal** than Python 3 Because it doesn't insist on decoding the undecodeable into Frankenstein Unicode that explodes when you try to encode it? I think the word you're looking for is "correct". &gt; For Go, all text is UTF-8! *By default*, yes. And UTF-8 is a much better default that Python 3's ASCII. 
Thank you for the apology, that's very appreciated for having a healthy discussion. I disagree about which idiom is clearer. One problem about go error handling is that a little modification in the "if" idiom is IMO easy to overlook, and that could be a source of frustration, also because tedious typing is a common source of typos. But I get your point, current solution is indeed very explicit. Don't buy the equivalence between explicitness and clarity, though. Could you imagine how much bigger would your code look with a more explicit version of goroutines where u would have to manually pin down all the low level mechanisms involved in the magic of concurrency? I agree, though, that having result types would not be really useful for all the existing API that use multiple return values. I still hope that something can be done in order to ease error handling somehow.
Thanks! Credits to mvdan that made an awesome work on the interpreter. https://github.com/mvdan/sh
Trees. Lots of trees. I've recently designed a tree structure for usage as a key-value database. The problem is that I had to resort to using byte-slices as backing store, there is no way I can reliably and with type-safety make a Tree structure, with disk-paging, without having access to generics. Sadly, the code isn't public (yet), but I think having special datastructures being type-safe would be a huge improvement. Simple maps or slices don't cover nearly all use-cases with good performance.
oh wait, what do you mean by you feel sorry for the guy? Are his points about Go in the video not valid? This guy seems pretty smart .. check out this blog post from a year ago. https://blog.rendle.io/what-ive-learned-about-dotnet-native/ tldr; "This all means that C# is about to enter Go territory – a cross-platform, natively-compiled, garbage-collected programming language. Except, of course, that C# has modern language features like generics, async/await, etc."
I'm new to Go too. In web development at least, I google the problem, along with the language I am programming in. It should return the snippet you need and link to the required library. In php, for example, there is usually a function for it. 
You can already kind of do this, no? import ( "fmt" ) type foo struct { x int y string } type bar struct { foo z float64 } func main() { var a = foo{x: 1, y: "a"} var b = bar{z: 2.5} b.x = 2 b.y = "b" fmt.Println(b.x, b.y, b.z) b.foo = a fmt.Println(b.x, b.y, b.z) }
sorry, my intention is not to start a flame war, I just want to understand objectively if moving to Go is justified by the reasons people mention. There are people who make judgement calls against languages that they do not fully understand. For example c# has a rich roadmap. https://www.infoq.com/news/2017/06/CSharp-7.2 But I am not sure the roadmap for Golang. I guess if we are speaking about bikes vs cars, we can also discuss carbon footprint .. yes a bike is better, but so is a Tesla. However, I'm not sure how this analogy is relevant. But I am not here to ask which language is better. I guess I just want to know if anyone with context and experience with rich languages such as C# have valid reasons to move to Go, since it seems from the video I posted, C# has all the features of Go and more. And no I am not that guy in the video. 
I don't know much about the Angular side of things, but I know of this article: https://nathanleclaire.com/blog/2013/11/30/fear-and-loathing-with-golang-and-angular-js/ The author has put out some pretty good content overall, so I'd assume it's worth the read.
And honestly, the same thing should be said of ints to string functions. Something that REALLY irks me in python is the fact that I can't do i = 2 s = "This is Python version " print s + i But rather I have to print s + str(i) (or format or printf), but I still can't see why integers (or anything with \_\_str__) can't be passed to print 
Why did you declare your variables via flag and pass in the pointers explicitly? Is there some best practice reason behind it? This is how I do it [currently](https://play.golang.org/p/1Khq7jXBr5)
Seems like this is going to be downvoted. Here are some reasons why: * Angular has nothing to do with the question. It will consume an API written in whatever language/framework you want. * There are many threads about web/api frameworks for Go already. Asking again is probably not going to provide any new insights.
Well on strings that only contain ascii its fairly ok to do so, but then there are those asian fuck tons of characters :D
I would probably not be using python if + was supported like that.. It's just an endless source of bugs everywhere when things like that is allowed You still have several string printing functions to choose from which does the job just fine like `print("{}{}".format("string", 123)))` 
Definitely - Go makes it easy to cut a build, but I didn't have access to a Windows box to do all the tests. https://github.com/rykov/paperboy/issues/4
I think that the most problematic thing about adding some kind of templates/polymorphic support is that it will be overused when interfaces (not emtpy ones) are good enough or better. Especially by people coming from C++-like languages. And it's not hard at all to show examples since there is a very good recent one in the standard library now: `sync.Map`.
It's me i'm sorry, my english is so poor that it's difficult to make some humor ! I've no doubt your question is valid. More seriously, what I want to say is that the main goal of Go is simplicity (less is more). For example you can read and understand all the specifications of Go in one day and make your first program the next day. We have `for` and we don't want to have `while`, we have `if` and we don't want to have ternary operator and so on... Not because we are masochist but because we want to read the code of anybody else (can be us in some years) without thinking about a magic feature of the language that we forgot to learn. When i compare with bike it doesn't mean that it's better, it means that the use are so different that it's impossible to compare feature by feature, even if we are on the same road... To answer your question, yes Go is mature, so mature that it will not change (or very few, just if somebody can show that something is really broken). It's easy to see by yourself, I invite you to just try.
Set of fields of *foo* is a subset of set of fields of *bar*, but we can not assign an instance of *bar* to an instance of *foo* - like as suggested by @comrade_donkey using some statement like *copy(_bar, _foo)* for avoiding overloading *=* sign - but we have to explicitly say *_foo = _bar.foo*.
I do use format() for most things, but it's a little annoying I can see where some confusion may be initially seen from it, but after you learn about it could be easily adopted. I don't see how any interpretation from str+int could be seen **unless** it's a str of "5" + 3 which then you could as should it return int(8), str(8), str("5 + 3"), or str("53") but I think if you could adopt an official stance it would be beneficail
I rather handle parsing and math separately because of what happens when the assumption fails or what the returned type might be. `value:=Max("asdf")`: If there is only one return value this has to panic which is very special case usage which can be implemented in application code when and if it's needed. `value, err := Max("3.14")`: The type of `value` cannot be statically inferred because it can be either an int or float. IMHO both of those examples shows that it's easier to handle number parsing and max'ing in separate steps in your program because otherwise would have to keep track of too many permutations of Max behavior. 
Do it the go way: 1. Spawn a goroutine for each file that reads, processes it, and sends results down a result channel. 2. In your main goroutine, for range over the result channel and add to a map as needed. No mutex is necessary. Edit: sorry for bold... On mobile.
For me it's not so much about confusion, primarily it's about security and identifying bugs.. I want my code to fail as early as possible if a string by accident or malice has made it's way into some number computation code.
Ah I didn't think about security, but I don't think I wrote my last comment right. Strings would **never** be converted to ints (I agree with that!!), but rather ints would be converted to strings when in a print (or other output) function. Something close to: def print(*args): final_str = "" for arg in args: if not isinstance(arg, str): try: final_str+=arg.__str__ except: pass else: final_str+=arg return final_str Or something 
Have you ever had to actually maintain someone else's LINQ code? It's an absolute nightmare. I wouldn't wish on my worst enemy to have to work in a cookie-cutter .NET shop. edit: Sorry, I should add, what I mean by "LINQ code" is a .NET developer who makes judicious usage of LINQ everywhere you can just because they can(when they should of just a simple collection and a for each iterator) because it makes them feel like a "real developer" and that they've developed an "elegant" solution, meanwhile it has become impossibly impossible to follow the flow of data through their code. 
I'm a C# developer and I started learning/working with go for small personal projects a year ago. I haven't had to use complex data structure for my projects where generics would have saved me headache and development time. The only thing that made/makes the learning experience difficult is moving from an OOP language to a ~~functional~~ procedural one.
Okay... This doesn't seem like that big of a deal to me compared to generics.
Great question.
Yes, that's basically pseudo code, I didn't want to write down the actual implementations (because they are pretty basic for a set), but imagine something like this: type Set&lt;T&gt; struct {} func (s *Set) Add(e element&lt;T&gt;) { // do stuff } Hope this clarifies things a bit.
The top comment shows a very real problem, and a few comments down we have a very real potential answer. I think this thread is pretty much on point, especially since most of the objections are mere variations of "bit awkard imho". Personally, I'd much rather see *technical* objections, like effects on the compiler, the runtime etc.
Assuming you are not being sarcastic, the idea here is really simple yet Java makes it seem like something very complicated is happening. In Haskell, this would look something like this: chain :: ListenableFuture i -&gt; (i -&gt; ListenableFuture o) -&gt; ListenableFuture o And the type signature almost tells you what the function definition is going to be.
I second this. Would be great to see some examples and hear about libraries and technologies used. RemindMe! 3 days.
&gt; print s + int(i) You mean: print s + str(i)
&gt; type Set&lt;T&gt; struct { &gt; Add(element T) &gt; Remove(element T) &gt; Contains(elements T) bool &gt; } &gt; &gt; func main() { &gt; mySet := new(Set&lt;int&gt;) &gt; &gt; mySet.Add(1) // works &gt; mySet.Add("1") // compile error &gt; &gt; var foo interface{} &gt; foo = 1 &gt; mySet.Add(foo) // also compile error &gt; &gt; mySet.Add(foo.(int)) // compiles and works fine, but potentially a panic risk at runtime &gt; } type Set[T] struct { Add(element T) Remove(element T) Contains(elements T) bool } func main() { mySet := new(Set[int]) mySet.Add(1) // works mySet.Add("1") // compile error var foo interface{} foo = 1 mySet.Add(foo) // also compile error mySet.Add(foo.(int)) // compiles and works fine, but potentially a panic risk at runtime } &lt;&gt; template/generic parameters proved to be highly unreadable
The whole time I was reading that I was going "That's not form data, why would you treat it as form data" Glad the author finally admitted it was their own mistake and detailed how it actually works, but that was kind of a weird way to write about the issue and has a pretty misleading title. 
I've used generics in java and c++ and c#, I'm not confused about that.
I think it's a great exemple of why there need good use cases before implementing generics. And more importantly, stick to it. The repo given by the OP is one set of problem: containers and algorithms. Yet, the solution proposed (full generics) is really complicated and uneeded if you want to solve that specific problem. A better solution to that problem would more coarse generics, restricted to the package definition. How would it work? Define the generics type for the package like this: package list { Value interface{} } Here you define a type that is exported and the value can be used through the list package as if you would have defined `type Value interface{}` Then to use it in another package you would specialize it in the import section like this : import "container/list" { Value : int } I really like this implementation over full generics like in java because * It doesn't change the current way you code in go * Most of the code would be unchanged, only the package line and the import would have to be changed * It's really simple to understand and has a really low cognitive load. * You don't have to understand ten's of different function with slightly different generic signature for a package, when you define a generic package, it has to have a clear meaning * It is more orthogonal: It would be far easier to implement in the compiler and have way less impact with the different feature of go If 80% of the use cases with generics in go are data structure, I really think that would be the way to go.
Not my project but [de](https://github.com/driusan/de/blob/master/README.md) stood out to me because it was implemented using using exp/shiny rather than bindings to some UI framework. I tried to use exp/shiny for a [simple read only LastPass alternative to the browser add on](https://github.com/alexzorin/lpass-ui) but realised that it's very far from usable as an alternative to e.g qml (which it uses instead) - there aren't (or weren't at the time) basic controls like editable text fields. So de is all the more impressive for its accomplishment. At that point of realisation I probably should just have used qml with python or something, cgo just spoils Go for me, though I do use my program daily so it's not a total wash.
&gt; This means that the style should be consistent with the original author, not how you would have written it. That would be different if they had generics. 
Go isn't a functional language. Go is Procedural. Something like Haskell is functional.
Was that a chat command?? Reddit has chat commands??
&gt; oh wait, what do you mean by you feel sorry for the guy? &gt; Are his points about Go in the video not valid? In my opinion they really are not. He is one of the many that doesn't "get" Go. &gt; This guy seems pretty smart .. check out this blog post from a year ago. https://blog.rendle.io/what-ive-learned-about-dotnet-native/ &gt; tldr; "This all means that C# is about to enter Go territory – a cross-platform, natively-compiled, garbage-collected programming language. Except, of course, that C# has modern language features like generics, async/await, etc." I never doubted how smart he is. But that article you just linked confirmed my suspictions. He really thinks that "more is better" while I believe that [less is more](https://commandcenter.blogspot.gr/2012/06/less-is-exponentially-more.html). If you read that article carefully, you will also get the answer to your question about if generics would help attract C# developers. Also I think /u/cdoxsey's [answer](https://www.reddit.com/r/golang/comments/6nlc4r/would_generics_help_c_developers_move_to_go/dkafu7c/) summarized it very well.
It's a bot ;)
&gt; Hi, I'm looking for an golang framework to use Just because you need the Angular framework to write your frontend, that does not mean that you need a framework to write your Go backend. Use the standard library. Write a few handlers that receive and return JSON. Keep it simple.
"matured with more features" is a phrase which will make Gophers very unhappy. Go is mature because it has so few features. Generics are the first thing folks want from other languages. After having programmed in Go for some time, I never miss generics. I don't want or need Go to be more like other languages. The beauty of go is that you can learn all the syntax in an afternoon. And then, almost every program you write will use almost all of the available syntax - you don't have to go look at a document to remember how to use some obscure feature - you used all the features in your last program. Yes, I've drunk the Go Kool-aid - but it's Go's lack of baggage from other languages which makes it such an elegant language to learn, program, and most importantly, read. 
&gt; but I still can't see why integers (or anything with \_\_str__) can't be passed to print They can, but that's not what you're doing here: you're adding a string to an int, the print has nothing to do with it. 
why not just write in c then, man.
why not just write in c then, man.
why not just write in c then, man.
Give [Appveyor](https://www.appveyor.com/) a try.
Go does not have a roadmap because Go is not about adding. Go is about what's possible today and what will make just that better. So do the Go tour. Read Effective Go. Those will show you show you what Go is good at. If you want to do that then use Go. If not, that's ok too. Jeff
To extend the thought - those who day "Go lacks generics" already have a solution in mind without articulating the actual goal. After asking vendors for features for much of my career, I've learned to stop saying "it must be red, have four doors, four wheels, have a Max speed of 80mph, get 30mpg, and an automatic transmission" and rather to say "I need to get from New York to Los Angeles". Often, the vendor can give me a private jet, which is far better than what I had in mind. 
When using the flag package, you can either use flag.Int() /flag.String() and get back pointers, or declare vars ahead of time and use flag.IntVar()/flag.StringVar(). I chose the simpler method and passed the pointer in since it was less lines than declaring the vars ahead of time. I'm not a fan of the readconfig func, it doesn't have defaults and doesn't give a helpful message if the values aren't there. Using the flag package you get output like the following if you pass -h: Usage of ./yourprogram: -a string listen addr (default "127.0.0.1:2000") -c int max connections (default 1) For programs that have a bunch of options, I'll typically switch to using a configuration file.
Apologies if I'm missing the mark on your need.. but I use (and wrote) [Ponzu](https://ponzu-cms.org) to do just this. Typically I work with React/Typescript on the front end which talks directly to the Ponzu server via HTTP using its built in JSON API. Ponzu has a useful CLI which you can use to generate most of the Go code you'd need to get the HTTP server, a CMS, the API and various useful middleware (GZIP, Auth, CORS, Caching, etc). I use Ponzu as a kind of blended Rails/Wordpress system that has no concept of the "front end" - just a JSON API. There is also a "Go struct-to-JS" type generator tool written by another Go community memeber called [Typewriter](https://github.com/natdm/typewriter) which might be useful and has a variety of JS flavors to pick from. I haven't used Angular with Ponzu yet, so if you end up trying it, please let me know how it goes!
Wow, that definitely looks like an interesting solution. I do hope something like that would *also* be considered, along with my Java-esque one above. Though one thing I worry about with your implementation, is that the imports would get messy very quickly, for example: import ( intList "container/list" { Value : int } int32List "container/list" { Value : int32 } int64List "container/list" { Value : int64 } // ... and so on )
As I understand the situation, Golang will compile numeric code involving floats to IEEE-754 compliant code on the architectures that support it; architectures that do not support IEEE-754 or offer "different"-precision operations are a little more open ended. Golang's [math.big](https://golang.org/pkg/math/big/) library offers arbitrary precision Floats and in theory that code might be compiled to use special instruction sets on CPUs that support it. Disclaimer: Not a Golang core developer or CPU architect. Perhaps your question could be more meaningfully answered if you narrowed down your query. What exactly is the problem you're having, or trying to solve? Do you have some sample code to look at? A minimal reproducing case would be helpful as a starting point.
I'm sure you have a underlying motivation for asking which you probably should include. But a direct answer would be yes, Go implements the baseline recommendations in [ieee-754](https://golang.org/pkg/builtin/#float64). But you will want to probably read up on Go specification (its short and simple) around numeric conversions I'm sure they will become relevant in real world usage of them.
&gt; Perhaps the quintessential example is LINQ. They actually implemented an entire DSL within C# so that you don't have to write SQL in strings anymore. &gt; C# is really a dozen programming languages mashed together. This is utter bullshit. LINQ queries *can* be translated into SQL *if* you explicitly use an ORM that does this for you like EntityFramework. Otherwise it's just a handy library of methods that makes common operations like mapping, aggregation and filtering available over *generic* collections in an easy to use manner.
I thought this was cool until I read the readme.. &gt; Avoid using any external libraries, including the standard library. Avoid using external libraries by using external library! Serious note: avoiding standard library is not a "plus" side for anyone. &gt; Zero dependencies. Neither the standard GO library is present PURE GO. I don't understand why this is a selling point? Perhaps you have a use case that provides some rationale for wanting to avoid the standard library..? &gt; No error checking. Not a selling point for a regular expression library man, it's fine for things with useful zero values but even your compile method has no error checking. At a quick glance I see zero error propagation, bounds checks, or anything that would prevent this thing from having major security implications in real world usage. Just some food for thought, I think this is cool but the Go regexp engine is one of the best implementions I've seen from a security and design perspective and has pretty good performance. I think to sell your implementation you should focus on concrete facts about what it excels in, everything you listed is subjective or disingenuous. 
(google translate es ==&gt; en (corrections welcome)) thanks for the interest, I hope you find the code interesting has no error checking, because it is not for children... is more an edicational project than a performance monster, although it has a good performance and while less dependencies better performance has some very useful features for me, how to deliver the index of a catch and a nice sintax
LINQ is clearly influenced by SQL. It came from a Microsoft research project. Of the many goals of that project, one of them was to introduce type safety into SQL Database interaction: https://www.microsoft.com/en-us/research/project/comega/ &gt; The current situation with regard to external data is just as bad. Most web-based (and many non-web-based) applications are basically thin interface-generating layers over relational databases (the `3-tier’ model). Yet dealing with relational data from within current languages is messy, error-prone and dangerous. APIs for database access typically construct SQL queries as strings and return results as untyped collection objects which are deconstructed imperatively. This makes code lengthy and unreadable, negates much of the benefit of working in a language with strong static safety guarantees and loses much of the advantage of the underlying declarative query language. Worse still, it is insecure: when query strings are derived from user input, preventing script-injection attacks requires very careful coding. Yes LINQ can be used for things besides SQL. Sorry if I wasn't clear. (FWIW a more go-like approach to this particular problem would be a tool like `go vet` that can inspect SQL expressions and validate their correctness. Tools can fill in a gap like this without making the language more complex.)
RemindMe! 2 days
I will be messaging you on [**2017-07-18 22:50:51 UTC**](http://www.wolframalpha.com/input/?i=2017-07-18 22:50:51 UTC To Local Time) to remind you of [**this link.**](https://www.reddit.com/r/golang/comments/6nnywi/desktopgui_apps/dkb5ibf) [**7 OTHERS CLICKED THIS LINK**](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[https://www.reddit.com/r/golang/comments/6nnywi/desktopgui_apps/dkb5ibf]%0A%0ARemindMe! 2 days) to send a PM to also be reminded and to reduce spam. ^(Parent commenter can ) [^(delete this message to hide from others.)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Delete Comment&amp;message=Delete! dkb5ipk) _____ |[^(FAQs)](http://np.reddit.com/r/RemindMeBot/comments/24duzp/remindmebot_info/)|[^(Custom)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[LINK INSIDE SQUARE BRACKETS else default to FAQs]%0A%0ANOTE: Don't forget to add the time options after the command.%0A%0ARemindMe!)|[^(Your Reminders)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=List Of Reminders&amp;message=MyReminders!)|[^(Feedback)](http://np.reddit.com/message/compose/?to=RemindMeBotWrangler&amp;subject=Feedback)|[^(Code)](https://github.com/SIlver--/remindmebot-reddit)|[^(Browser Extensions)](https://np.reddit.com/r/RemindMeBot/comments/4kldad/remindmebot_extensions/) |-|-|-|-|-|-|
Yes, that could be a problem. That's why the go team asked for real word examples so you could have some hints if it's just a minor point or if it snowball into a pile of mess.
Here's an example of something I can do in Object Pascal (which has my favorite take on generics out of all compiled languages that implement them): unit Example; interface uses Classes, Generics.Collections; type TExampleRecord = record IntegerField: Integer; StringField: String; BooleanField: Boolean; end; TExampleRecordRecord = record InternalExampleRecord: TExampleRecord; end; TExampleRecordList = class(specialize TList&lt;TExampleRecord&gt;) end; TExampleRecordRecordList = class(specialize TList&lt;TExampleRecordRecord&gt;) end; implementation end. That code (which is somewhat silly by design to show that generics allow for easy handling of complex structures) gives me two fully functional list classes that have all the necessary methods (i.e. Add, Remove, Insert, Sort, IndexOf, e.t.c.) implicitly pre-implemented and that automatically return (and take) the correct types from and to each of those methods. (As in, if you try to add a TExampleRecordRecord to a TExampleRecordList, the application will simply fail to compile due to the incorrect type. There is absolutely no risk of the boogeyman "type unsafety" that some people seem to think is a thing that actually exists with properly implemented generics.) Now, think about how you'd implement something like the above in Go... suffice to say it would take a *little more work*, at the very least. **TLDR:** The introduction of generics into any given language will never have any downsides when done by developers who are remotely competent. It's not like you even *have* to use them if/when available! The fact that we're actually at a point where we're needing to have this ridiculous discussion about providing "real use cases" is, well, ridiculous.
You must see world in binary where error checking is for children? Seems like you are a genius programmer, so glad I came across you during my lifetime. 
You're totally right! I don't know what I was thinking :)
Where as the commit log was the first thing *I* saw, and that was enough to close the tab: ¸.·´¯`·.´¯`·.¸¸.·´¯`·.¸&gt;&lt;(((º&gt; nasciiboy committed 2 hours ago ¸.·´¯`·.´¯`·.¸¸.·´¯`·.¸&gt;&lt;(((º&gt; nasciiboy committed 2 hours ago ======================================================= … nasciiboy committed 21 hours ago
Shit, sorry you are right. I did meant procedural.
`sync.Map` uses `interface{}` for all keys and values and is not type safe: https://github.com/golang/go/blob/master/src/sync/map.go
Below average developers won't be implementing data structure libraries so they don't need to know the details of generics. They only need to know how to use libraries that use generics, and they already do because it's the same as arrays of a type T. In fact, generics would make their life easier. I don't think anybody would argue that below average developers are better served by having all their arrays be of type interface{}, because that makes code unreadable, not type safe, and slow. The same applies to other uses of generics.
And probably the right version of Powershell installed
If this is a program that is intended to be distributed, then I suggest leaving firewall configuration to the user. Personally and professionally I'd prefer not to have applications automatically punch holes through firewalls. In any case, powershell via os/exec is your best plan of action. Unless you're willing to have a .NET stub purely for the purposes of opening the firewall. But then I guess then you can only open the port and not tie it to a specific program.. hmm
because it's shit?
[The last generics proposal](https://github.com/golang/proposal/blob/master/design/15292/2013-12-type-params.md) is basically this. The summary at the end talks about why they didn't implement it.
No need to check for error if you never code any errors! /s
what makes it so shit
Ye, C also doesn't have a GC so it balances things out.
Honestly, it may disagree, but its counter itself isn't particularly attractive. I'll take a void or char pointer most of the time.
and it missed the target :/
just watching you code, I'll see if I'm a genius
This is coming from my own experience, so please take my thoughts with a grain of salt. I think a library I wrote awhile back is a great example of what Rob Pike and others are trying to allude to when they're asking the community to show real world use cases of generics. I wrote [goque](https://github.com/beeker1121/goque), which is centered around embedded and persistent stacks and queues. Since the stacks and queues are persistent and not memory based, the Go port of LevelDB which is a simple key-value store is used for that. LevelDB is awesome in that both keys and values (both in Go and other language implementations, afaik) are treated as arbitrary length byte slices. In a way, this is really just a... generic... way of storing data. Storing an integer, string, or a complete struct is possible by simply converting it to a byte slice representation. Real world, this package as well as the LevelDB package do not require generics. Let's say too that I absolutely needed to store a definitive type using Go and LevelDB. Well, even then, my real world use case of it being used in production in our custom web crawler, I'm only storing strings, nothing else. All of the methods I use could just take strings as parameters. I think this is more what the Go devs are referring to. It seems like it would be nice to have generics just for the options, but in reality, would the majority of uses cases would simply copy the code over from the GoDS source and replace `interface{}` with whatever type they need? Again, own personal real world example, not meant to take away from the use cases of anyone else.
 you do not like fish?
The introduction of an abstract type would solve almost all use cases. Lets call the abstract building block 'model'. This model type would define traits. Go already has the notion of traits. The idea of a model based on traits could be modeled around the already existing and feature-rich reflection library. Interfaces, conversion and assertion provide runtime polymorphism. Now, what is needed is a compile time equivalent. A zero cost runtime mechanism, with full costs realized at compile time. The two concepts should complement each other without overlap. people have suggested something along the lines of: type Set&lt;T&gt; struct { Add(element T) Remove(element T) Contains(elements T) bool } func main() { mySet := new(Set&lt;int&gt;) mySet.Add(1) // works mySet.Add("1") // compile error var foo interface{} foo = 1 mySet.Add(foo) // also compile error mySet.Add(foo.(int)) // compiles and works fine, but potentially a panic risk at runtime } But nobody has given much thought how one might define 'T'. The constraints on 'T'. Without a clear definition of the constraints on 'T', then this new mechanism is no better than empty interfaces with regard to type safety. This set type is a very simple use case where the algorithm within the func/methods would be easy to define in the language with comparable, but what about very complex container types which must define there own definition of comparable or orderable, etc. The fmt package gives a good starting point about how to define func/methods to help define behavior. 
It does not make sense to lose cycles reviewing data that must be correct
In a language where so much of the feature set relies on pointers, cache locality doesn't seem like much of a concern. consider how slices are implemented, or how maps are really just pointers, and interfaces. It just doesn't seem like cache locality is much a concern.
How do will the algorithm determine if the data is correct or not? 
This is a very broad question. Like another user said just pull in a package and see if it fits your use case. Also, if you're trying to solve a very common problem (I.e connecting to a database, processing credit cards, processing images etc) look for a package to do it for you
It's fishy when the commit message does not tell you what happened in that commit.
It blows in your face before you know it every single time.
I'm going to give you the benefit of the doubt that the es -&gt; en translation is causing your tone in your replies here to not convey properly. I think you did a good thing here, you wrote a good bit of documentation, examples and is [well tested](https://github.com/nasciiboy/regexp4/blob/master/regexp4_test.go)! The main takeaway from my post is focus on the concrete things about your package like the things I just mentioned as well as the algorithm itself. Since you mention this was in part for the learning experience you will probably find [rsc's regexp](https://swtch.com/~rsc/regexp/) page lead to some interesting write ups like [this](https://swtch.com/~rsc/regexp/regexp1.html). I hope you continue to enjoy Go.
That's sort of a poor argument for something that is compiled once isn't it? Cycles are so cheap it's a round-to-zero cost in comparison programmer time, which a lot is wasted if I don't find out my regexp is invalid until after a period of time goes by and nothing matches.
I don't need to provide examples if I say data structure. Hash map, linked list, btree, you name it. If you want to write ANY data structure without codegen, you're fucked. 
Are you guys serious? The only "specific use case" needed is "not having eight million list implementations that are completely identical besides their type, all of which were generated via some hacky script, which is fine because code generation is totally a perfectly normal and acceptable thing to have to do when coding in a supposedly modern language."
For that is the development, to see if it works or not
thanks for the benefit of the doubt, I am not a versed in programming, algorithm or math... I had already seen the things of russ cox, and I do not understand them Does not follow any algorithm, I do not know any algorithm to solve regex. I program the engine as simple possible for my understanding, following my instinct. I know it works and obviously I thikn it's the best of the universe... If someone finds it interesting and tells me if its good (or whatever), it will make me very happy
When there is nothing relevant (typo or a doc update) I do not put any relevant message, in any case you can make a `git diff` and `git show`
This is what interfaces are for. You have functions accept interfaces instead of strict struct types, so you can pass in `bar` to anything you want to accept `foo` because `bar` implements all the interfaces that `foo` does.
this algonithm assumes that the data is correct my algorithm solves regexp, does not check data (see https://github.com/nasciiboy/regexp4#flow-diagram)
One of the nice things about Shiny is that, at least on Linux, doesn't have any C usage thanks to [BurntSushi's XGB package](https://github.com/BurntSushi/xgb). Statically-compiled, and thus dependencyless, GUI apps. 
It also has no dependencies for windows. The problem with shiny, though, is that it is really bare-bones in terms of features and it gets very little attention from the people maintaining it.
&gt; It also has no dependencies for windows. That's good to hear. &gt; The problem with shiny, though, is that it is really bare-bones in terms of features and it gets very little attention from the people maintaining it. Tell me about it... I've been waiting for fullscreen support for something like two years now...
Harassment is harassment regardless of the excuse you come up with as your justification.
I saw [app](https://github.com/murlokswarm/app) and wanted to try it, but the example provided happened to not work - the name property was not updating when modifying the text input. I didn't have much time available to play with it, but I hope it'll get big, because it looks awesome. 
I just noticed that earlier... And I seem to recall it being held up on a design decision which nobody is 100 percent sure about.
The community for Go in China is huge and it would be nice if any chinese user could re-post it somewhere in China and let us know the opinion of their community.
Thank you intermernet! You did show me the way through out :))
It's for internal usage. i got some computers to set configs including network settings automately, and i think powershell can make it done :)) gonna try soon. if not works, maybe i need to try with c# again... thanks for reply bandicoon
[removed]
Yes, interfaces can be used for matching *behavior*, as you mentioned, for what a struct *does* not *has*. Here we are talking about the *fields* that hold data, not *behavior*. 
[removed]
So you want an interface equivalent for the fields a struct has? I'm not sure what you're getting at-- you can get the component parts of a struct when you need them, but you want to avoid writing`Get_()` boilerplate so you want to implement new syntax so you can cast types down to types they are composed of? All to replace the `.foo` portion of syntax that already exists? So if I do this: var b bar var f foo f &lt;== b What information is stored in `f`? Does it know that it is not actually a `foo` but it is a `bar`? Can it be cast back to `bar`? As far as I can tell, you're really proposing making Go's type system like ML's type system which is painfully complicated to learn and has multiple ways of achieving the same functionality all over the place. Otherwise, you're trying to turn the `struct` keyword into `class`. Look, I admit I've wanted this feature for a long time too! It looks like it'd be really nice to have and would make some things a lot neater, but everything it can do can already be done through interfaces, and if you're composing your types anyway you already have syntax that lets you do this without the additional questions rising about what type this new construct has to be. What about this: type Bar struct { Foo Biz } type Biz struct { Foo } type Foo struct { field int } var b Bar var f Foo f &lt;== b From what type does f come? `Bar.Foo` or `Bar.Biz.Foo`? Interfaces solve this by requiring that you specify subtypes in ambiguous cases. Does this operator also require specifying subtypes? Then, because we want to be able to cast back to `Bar`, we need syntax for that subtype specification that isn't a cast or a field access. If you can't cast back to `Bar`, then its just renaming `f = b.Foo` to `f &lt;== b`, except this syntax actually is less useful! with the `.Foo` syntax we can say `f := b.Foo` so we don't need to care about / import types, but in this system you need to know the type of what you're pulling, because `b` could be composed of multiple things and there's no way to know what sub-struct you want to pull in a `:=` equivalent. 
You probably don't need a framework, I'd recommend looking at starting something with Go beforehand and seeing where you get to with a test project. There are lots of nice libraries to solve common problems like routing, etc.
Exactly, that was my point.. sync.Map is a great example of where some kind of templates-like feature would be useful. Rather than having "generics" in the compiler I would be interested in more exploration of go generate first. One exmple which I don't know if anyone has explored is an `eg` like tool for go generate which instead of doing an in place refactoring copies an implementation changing it's types or something based on example code.. You could then have `syncmap_generate.go` or something which contains some example code which copies and transforms the original source. I can't say I have thought about all the potential pitfalls of this yet but one of them is probably types/members private to another package. As long as something ends up inside the go tool chain at some point I will be happy, it doesn't have to be compile time as long as it can be statically verified in some way.. 
Why not C++? C++ can give you single binary and better performance. ;) If you check https://benchmarksgame.alioth.debian.org/u64q/compare.php?lang=csharpcore&amp;lang2=go you can see that the performance is not so different or not different enough to make the change just for performance reasons. The reason for changing are wrong in my opinion. You should consider changing the language if the language is more suited for your job. First you should learn the new language and then decide if it makes sense. Every case is different. BTW we have a big project (1M LoC) written in C#. It is really hard for me to imagine writing the application in go since: 1. go has no generics and other stuff it would be a lot more than 1M LoC probably 2M LoC 2. Working with VS (debugging etc) is ... you know 3. Dependency management comes OOTB, still waiting for dep which should be present since 1.0 4. I think that go will some time in the future add stuff to it. Generics are in Go 2.0 or was it a hoax? One observation: The languages and the developers tend to get smarter. 20 years ago the languages where simple (not easy). Nowadays the languages are getting smarter and give the developer more with fewer lines of code. Language complexity is a problem but we are getting smarter too (or not). Take for example F# and do not mind about the functional aspect of the language. 1. Pattern matching is a killer feature 2. The advanced type system is fantastic 3. You can make the same program in F# with a lot less LoC, which is the advertisement (less lines of code, less bugs, more code in your screen etc) If the language can convey more in a easy way with less code i am all for it! I personally do like complex languages. After a while you get to read complex statements easier and thank god that you do not have to see 5 screens in order to understand how things work. BTW: Most liked language in a StackOverflow report https://insights.stackoverflow.com/survey/2017#most-loved-dreaded-and-wanted are complex languages. Check top 10 to see.
&gt; LINQ is clearly influenced by SQL. It came from a Microsoft research project. Of the many goals of that project, one of them was to introduce type safety into SQL Database interaction: https://www.microsoft.com/en-us/research/project/comega/ LINQ has a SQL-like syntax that is *entirely optional*, and not its main selling point. At its core, LINQ is just a library of extension methods that help reduce boilerplate and verbosity when working with collections. For example, imagine a JSON array you've deserialized from a web request, you can perform the following operations on it using LINQ but *without* its query-like syntax: var results = webRequestResults.Where(item =&gt; item.Price &lt; 50.0).OrderBy(item =&gt; item.Name).ThenBy(item =&gt; item.Price); SQL never enters into this, *ever*. LINQ queries are being performed over generic collections, that's all. &gt; Yes LINQ can be used for things besides SQL. Sorry if I wasn't clear. Sounded more like you read the first page of some MSDN docs and decided that "hey guys, LINQ is SQL in C# lol". Here's some documentation you should find interesting, and help clear up your misconceptions: https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/linq/query-syntax-and-method-syntax-in-linq Regardless of your personal opinion, LINQ's SQL-like syntax also does provide a huge productivity boost when working with a multitude of collections where several set operations are required (joins, unions, etc) to obtain the desired result, and where the data isn't coming from a DB. 
I think this is true except for when you are doing a lot of intensive algorithmic work with these types of data structures. I tried building some [computational geometry tools](https://github.com/200sc/go-compgeo), and the interfaces for searchable trees is terrible without generics. I had to use BSTs for a lot of types and I didn't want to duplicate the code five times so I tried doing it a Go way and it fell over constantly due to the lack of type safety. 
&gt; Storing an integer, string, or a complete struct is possible by simply converting it to a byte slice representation. For a persisent store, like in your use case, this is pretty much unavoidable (and therefore acceptable), but for in-memory lists/sets/trees converting values to/from `[]byte` usually involves allocating memory which might not be acceptable on hot paths.
When you get some real world experience it will be quite painful for you, good luck and know you will improve
Does that mean that you never use `fmt.Sprintf`, `json.Unmarshal`, ..., ...? `interface{}` is very useful in the right places.
you're gonna have to bring forth more than that, man. generally speaking, making the claim that something is "shit" warrants some concrete evidence of shittyness. 
C# has generics on functions as well and it doesn't look as bad as java does.
why not just write in c then, man. 
&gt; Sounded more like you read the first page of some MSDN docs and decided that "hey guys, LINQ is SQL in C# lol". I don't think this tone is warranted. It's certainly not appreciated. You know nothing about me or my experience. In my opinion you are deliberately misrepresenting what I said and implied, so I'm not going to respond except to this, where you stumbled into my main point: &gt; Regardless of your personal opinion, LINQ's SQL-like syntax also does provide a huge productivity boost when working with a multitude of collections where several set operations are required (joins, unions, etc) to obtain the desired result, and where the data isn't coming from a DB. Absolutely. LINQ is a useful and powerful feature. I never said otherwise. On the contrary, I argued that despite their usefulness, we should be cautious about adding features to Go, because there's often an unnoticed cost to adding new syntax, keywords and paradigms to a language. It seems obvious to me that a feature like LINQ would not be in keeping with the spirit of Go, and doesn't satisfy the cost of that trade-off. (and maybe a feature like generics does satisfy the cost... but it needs to considered) I don't expect C# or C++ developers to share this opinion. Like I said, Go is unusual in this regard. Less is more is fundamental to its design philosophy. If you don't agree with it, maybe you should look into using a different programming language, like C# or Scala. There are certainly plenty to go around.
Easiest way is to call powershell or cmds. Otherwise you need bindings to some lowe-level win32 api
ML type system is far more complicated and has a different purpose. I'm not looking for that. `f &lt;== b` simply means `b` has all fields of `f`, nothing more. And that can be checked at compile time, by the Go compiler; nothing runtime here.
~~So this is something that replaces composition?~~ What about the diamond problem? I don't think I said anything about runtime versus compile time. If you mean casting, then how is this different than b.Foo? Alright, I understand you weren't really thinking about composition. But the problem with this proposal is the diamond problem: what happens when Bar has access to multiple fields named the same thing with the same type? If this doesn't work on composed structs, then I'd recommend going and looking up composition in Go, it is extremely powerful and if this doesn't work for them this feature is worth very little. This is also unintuitive: type Position struct { x, y int } type AlphabetRepresentation struct { a,b,c,d...,x,y,z int } var ar AlphabetRepresentation var p Position p &lt;== ar // I shouldn't be able to do this, but I can To demonstrate the diamond issue: type ScreenAlphabet struct { Position AlphabetRepresentation } var sa ScreenAlphabet p &lt;== sa // What happens here? Using `sa.Position` or whatever isn't sufficient either. Consider: type HasX struct { x int } type HasY struct { y int } type Amalgam struct { HasX x int y int } var am Amalgam p &lt;== Amalgam // What happens here? This can actually get even more confusing, if we follow current Go rules for ambiguous selectors type SecondPosition struct { Position x, y int } sp := SecondPosition{Position{5,5},0,0} p &lt;== sp // This will have {0,0}, not {5,5}!
&gt; I won't waste time explaining why/what I hate about those. Why not? That would make it easier to think about how to fix them. The first one, I'd say, is a pretty common example of lack of custom types. It could probably be fixed pretty easily by introducing one or few newtypes / custom classes. The second one seems to be a generic type for an FSM. Defining FSMs generically is always going to be complex, that's not a problem with generics being complex but rather the problem itself being complex. People also use code generators to generate FMSs and they are complex too even when they use no generics. Also, the example is a generic definition, which is typically more complex than it's actual usage. So, I guess the corollary is "not a problem with generics". Sure, the first one is needlessly nested, but then again you can needlessly nest functions or modules or other things as well. Not to mention that the first one can _already_ be rewritten in Go verbatim :D The second is pretty complex indeed, but that's not something that can be feasibly avoided IMHO other than by shifting the objective. 
It doesn't look like `app` support anything else but Mac OS X, does it?
I think the (non-empty) interface idiom is very important in Go. Define the behaviour of your type! As such it would be nice to make it work with arrays more easily. Something along the following lines, the main idea is that the compiler can handle arrays of interfaces more naturally. package main import "fmt" type Animal interface{} type Barker interface { Bark() } type Dog struct{} func (a *Dog) Bark() { fmt.Println("BARK!") } type Cat struct{} func (a *Cat) Miauw() { fmt.Println("Miauw?") } func main() { x := []Animal{&amp;Dog{}, &amp;Dog{}} bark(x) // works, implicit cast because all elements implement Barker y := []Animal{&amp;Dog{}, &amp;Cat{}} bark(y) // compile error, not all elements implement Barker } func bark(barkers []Barker) { // do something } This doesn't cover all generics use cases though, but I feel like Go shouldn't implement generics a la Java.
Make the function a method. func (o *Object) EditObj() { // ... }
It totally depends on your use-case. Your first option will copy the object and duplicate its memory used. It will also be used if you do not want the "consumer" to be able to modify the "original" object.
No, I cannot explain better than what Rob wrote in his blog posting. If you've read that and disagree with me, OK, fine. If you haven't gotten around to reading what Rob says about why Go doesn't have your favorite feature, please do. Then if you have more questions, find a conference where Rob is present and buy him a beer and ask him to explain it in person.
Function where i'm passing my object is a method to other object :)
It's not always possible to have `bar.Foo` like when it's defined in another package; not containing our `foo`, explicitly, as an embedded part. And it happens plumbing big structs become cumbersome at some point. There are many packages with big structs out there. About the Diamond problem; you are right. I did not thought about that.
How would you handle the declaration for Add for T in [int,string]? Overloading? select e.(type)? Yes, I know it's pseudo code, I'm just interested in your thoughts :D
Can you update your question then? You didn't say that.
As always the answer is "it depends". If you need to create a copy of the object, you might be better with the first notation. Here's an [example of such functional options](https://scene-si.org/2017/02/22/store-config-in-the-environment/#best-practices), or you should read this article: [Functional options for friendly APIs - Dave Cheney](https://dave.cheney.net/2014/10/17/functional-options-for-friendly-apis). Judging by your first sentence, "I have object which I need to be changed in function" - you don't need a copy (no allocations), and you would use something like your second function to modify it.
That's a pretty good question actually. I would *prefer* overloading because the code would look much cleaner, but I think the Go developers would prefer a type switch, simply because it would be easier to read. But honestly, I'm fine with both :)
&gt; you'd still have to pretty much write all the separate versions anyway, but through a type-switch I imagine? Yes, I think you are right, but personally I would still prefer to have a single type switch instead of many different functions.
You give it a struct with a `String() string` function (what's behind `fmt.Stringer`) and a `Name() string` function, and that struct implicitly satisfies the `AuthMethod` interface. 
I've seen this package in reddit like 6 times at least, but did anyone make something with this yet? Any example? Is it possible to build a social website (like Facebook) with this? Does it fit?
/u/dgryski I've reported this as spam for multiple times. It's annoying as hell to see this posted every week or so.
Removed.
Docker and Kubernetes cannot really be considered a benchmark. I mean really...docker?
&gt; They actually implemented an entire DSL within C# so that you don't have to write SQL in strings anymore. That was your entire summary of LINQ. &gt;a more go-like approach to this particular problem would be a tool like go vet that can inspect SQL expressions and validate their correctness. This is the problem you think LINQ solves. His tone is not unwarranted. Go and actually, you know, use it before you start talking about LINQ more. 
I'm not sure I follow you. So, I have to create some `type myauth struct` for which I implement the `Stringer()` and `Name()` functions? And then I'd create a variable of the type `myauth` and then I'd pass that? I mean there's no `Name()` implementation anywhere. And what would I write anyway, like `return "ssh"`? Totally confused. I guess I don't understand what to pass here: _, err := git.PlainClone("git/repo", false, &amp;git.CloneOptions{ URL: "muh.git", // Auth: transport.AuthMethod, &lt;----- ??? RecurseSubmodules: git.DefaultSubmoduleRecursionDepth, Progress: os.Stdout, })
Yeah, it's got something to do with a whale or something. Apparently quite popular...
Could you link the chinese GUI packages? Thank you!
xcgui.com You can find the go bindings somewhere on github
OK I dug through files and can be a bit more helpful. Auth is finally used in places like [this](https://github.com/src-d/go-git/blob/v4/plumbing/transport/git/common.go#L22). Git does not support ANY auth, is what it is saying, so it wants you to not populate that field. HTTP on the other hand expects you to pass in its own private `AuthMethod` interface, like [BasicAuth](https://github.com/src-d/go-git/blob/v4/plumbing/transport/http/common.go#L158)
The ssh package has [a set of `AuthMethod`s that you can use](https://godoc.org/golang.org/x/crypto/ssh#AuthMethod). Try passing one of those.
Is that full open source cuz I've doubts about it..
&gt; That was your entire summary of LINQ. It's called rhetoric. Would you prefer: They actually implemented an entire DSL within C# so that you don't have to write SQL in strings anymore (as well as many other wonderful things you can do with LINQ) &gt; This is the problem you think LINQ solves. This is *one* of the problems I think LINQ solves. It's also one of the problems Microsoft tried to solve. I have used C# and LINQ extensively. It solves problems and is useful technology. How many times can I repeat this.
I don't know about his use-case, however, the container types I usually find helpful in my projects are arrays, lists, maps, sets, and sometimes even different types of caches (LRU/LFU caches for example), of which, Go only provides generics for arrays and maps. To get around this, I either use generated code or write the code by hand. For example, when I need unique values, I use them as map keys then iterate, then, if keep order is necessary, there's more code for that. I agree that the type of generics provided by C#/Java/C++ are overkill for Go. However, having access to simple container types that only need one generalized type would be a godsend.
this is why gophers are mocked! [DELETE THIS NEPHEW](https://i.imgur.com/zlHQuHH_d.jpg)
To my understanding the lib is free but you can pay for their designer studio app
All Im saying is "less is more" sounds like it is precisely "worse is better." And thrre seems to be disagreement with that (read the thread above). I don't care if go has generics, or any other feature.
Good project, a few notes; I would embed the Reader in Scanner rather than giving it a named field. Often, if a struct has a single field, that's a sign it should be either an alias or embedded. In this case, it should be embedded because you want access to the methods on the reader. As a bonus, you'll be able to drop your unread method and just call UnreadRune directly on the scanner. Also, Scanner isn't used outside the parse package so I wouldn't export it (change it to "scanner"). The parse package would also be a great place to add some tests. And testing is pretty tightly integrated with Go for a reason, it is idiomatic. Don't worry about getting perfect test coverage, just get enough to show how the code works and test some of the main paths. You may want to look at [assert](https://godoc.org/github.com/stretchr/testify/assert), it's a good test helper package. You could also have your Token constants be runes (and the Token type be a rune) which could simplify some of the switch logic. In parse.go, you've got the question "What are we actually doing here?", not sure if you meant that literally, but I'll answer and hope it's useful. The "task.Day{}" part is initializing a Day struct with everything set to it's zero value. And the &amp; takes the address, returning a pointer. In this case, I wouldn't use a pointer. Through the rest of the code, Day is not a pointer, so I'd make it consistent. After that, I'd change the line to var taskDay task.Day Which is idiomatic (when initializing a zero value, non pointer object). In the task package, TodoList and DayList should both be type aliases. The last thing I'd recommend is to grab [golint](https://github.com/golang/lint) and use that. I hope that's helpful.
If you're using switch, you can create your own generics implementation (*ahem, at least for this example*) today, here's a [playground link](https://play.golang.org/p/4DLhRqjnQ6). If you would literally have to implement the same body for generics, what does it change if there's an `T` instead of `interface{}` there? If you miss-type a field in the Capsule case, you still get type safety and a compile-time error, [playground example](https://play.golang.org/p/n5EC2vop_7), so I'm still missing a real answer for "what's the point?". Best guess: If you had overloading it would give you a compile-time error for a method that wouldn't be declared for any &lt;T&gt; based struct which you create. This would beat the switch/default: panic() and move the error of an unsupported type from runtime to compile time. Also, it would give you a way to *extend* generic structures from external packages supporting your own concrete T's. Not that you couldn't do some of this with embedding? Maybe there's a finer/bigger point that I'm missing? Edit: *yes, I'm aware that this might be a limited example of what the generics discussion as a whole is about, so please don't rip me a new one*. Edit 2: added extend/concrete T's line on end of second paragraph.
&gt; &gt; Hello there, Thank you for the comments, this helps a lot. I did not know that you simply could embed single fields but a quick search gave me a good idea what it is. That sounds really good. I think writing tests is the next thing I will do, before adding the remaining functionality I want. The commend "What are we actually doing here?" was meant quite litereally as at the time of writting I did not understand why I needed a pointer there. I kinda figured it out now and just forgot the comment but I also think your suggestions are a big improvement. I will also have a look at golint :-) Thank you for your time, it helps tons. I appreciate it a lot :-) 
From what I read CoreRT still has pretty huge performance "problems" as compared to how Go works.
I think it is not the generics that would make .net developers to switch. .NET/C# has a huge ecosystem going on and a lot of it just does not exist in Go world.
I've seen my share of LINQ used "judiciously". LINQ code can be maintainable and unmaintainable and so can be a lot of SQL strings in code. There was an article on this subreddit about some company practices using `sqlx` library and maintaining a lot of query strings in `go`. Edit: found a link https://www.reddit.com/r/golang/comments/6ew65l/our_go_is_fine_but_our_sql_is_great/
&gt; Best guess: If you had overloading it would give you a compile-time error for a method that wouldn't be declared for any &lt;T&gt; based struct which you create Yes, [exactly](https://play.golang.org/p/GLvCnTadxI). &gt; This would beat the switch/default: panic() and move the error of an unsupported type from runtime to compile time. Yes, and compile time type safety is the single most important feature of generics, in all languages. &gt; so please don't rip me a new one. Heh, no worries. I actually think this is a very useful discussion.
thanks for sharing, that's a good article. Love the highlighted quote
Thanks dad, when you program something nice you come back
I'm a neophyte at programming. New to Go and this proposal, in my opinion, is a simple solution that I understand. I like it. 
Pattern matching is not so much a feature as a necessity to be able to work with sum types efficiently. And sum types are often a crutch to overcome single return value limitation of functional languages. Sometimes these features are great but it's not always sunshine. LoC, while a useful metric, can only apply when you compare apples to apples, so to speak, i.e. code in the same language. Even for the same language, say Perl, one can have very compact code but try maintaining that. Consistent and clear syntax is more important. I am still fond of Pascal and don't mind its verbouseness at all.
She had a great talk abouth this now at Gophercon in Denver. Hopefully videos of all the talks will be up soon.
In the construction phase: https://www.instagram.com/p/BWmlld2DV9j/?taken-by=sille_handicraft
I do not have code yet, I am still in the "gathering options" phase. I will need my code to run perfectly reproducible with the exact same output on multiple different pcs. My current options are: 1) Implement everything using fixed point arithmetic. Would be lots of extra work I would like to avoid. 2) Make use of fp-determinism in golang (if it exists). A big problem with fp determinism is, that while the same calculation always gets the same result in ieee-754, a compiler might make optimisations. (a+b)+c != a+(b+c) after all (when floats are considered). As it stands now, I will write some test-suite to check if fp-operations are deterministic in golang. Something like a guarantee / test from someone else would have helped here and is what I was going for when asking the question.
That's a tough one. A lot of the appeal ( or perhaps even the "point" ) of Golang is that it allows you to think at a high level and the Golang language and compiler deal with abstracting it down into an efficient program on-metal. Perhaps inlining ASM code would provide a suitable amount of control over your mathematical operations; I have no direct knowledge of the feature so I may be off base. The Golang ASM is an 'abstracted'/generalized version of ASM that ALSO gets compiled down more intelligently. Another option might be to write your numerical code in C and leverage that from your Golang project. I imagine you can very strictly control handling at the C level. I'm not sure exactly what your project involves but hypothetically, if you just define add, subtract, divide, multiply, modulo, and then leverage those "fundamentals" in your Go code you could provide determinism, i.e. once you have add() and divide() you could write a fp-deterministic avg() function in *Golang* allowing for type safety and the associated optimizations without losing your determinism. Most of this is wild-ish speculation, I've got little experience worrying about things like this but I would like to think I've got a decent grasp of abstracting your project into meaningful, useful components. Edit: I also forgot that you can embed FORTRAN in your Golang code as well; that may be an avenue worth pursuing. I found [this](https://randomascii.wordpress.com/2013/07/16/floating-point-determinism/) article that waxes quite poetic about all the potential pitfalls and conditions involved in fp-determinism.
My day job is mostly web or APIs and my hobby time is only desktop dev on occasion, but [wxGo](https://github.com/dontpanic92/wxGo) is an excellent wrapper of wxWidgets, and I've compiled the example code. It compares favorably with QT and GTK in terms of features, though QT is probably the most featureful ui framework on the planet. Though I don't have a project to mention at the moment, the licensing is also great. QT and GTK are more troublesome if you want to create a commercial application. The wxWindows Licence is basically LGPL with a linking exception that states you may distribute the code in any compiled form without it affecting your license of your product. If you need merely a few buttons, I recommend [andlabs/ui](https://github.com/andlabs/ui) because it can be an order of magnitude smaller than other frameworks. It wraps native UI features native to operating systems, but suffers a few bugs and is developed slowly. I have hope for it because it's quite excellent despite some crashes (currently the enter key crashes it if a text field is highlighted) and would use it for a very very simple app, but for anything else, [wxGo](https://github.com/dontpanic92/wxGo) is superior due to stability, author responsiveness (though he's finishing his master's thesis this summer and has promised to return to development afterwards), and features.
I think he means an interface not an interface{} 
You would use named import, here is an example with a list and a different syntax: import ( listInt "container/list" {Value:int} listString "container/list" {Value:string} listlistString "container/list" {Value:listString.List} "container/syncmap" {Key:int, Value:string} )
I do write in C, when it's the best fit. I also write in Go, Rust, Python and JavaScript.
Then that method might want to prepare a set of arguments, then pass it to a method on o. Objects modifying other objects is generally a code smell, at the very least. There's a few exceptions where it's worth it, but they're somewhat rare.
I tend to shy away from making copies in Go because the shallow copy you get can be complicated to understand if it has anything other than simpler days types. Better to just mutate, and be very careful about what you pass between goroutine boundaries.
Your rudeness is quite unwarranted. Adult professionals don't go making personal insults while trying to strut their understanding of something. Getting emotionally involved in a technical discussion should be embarrassing. cdoxsey agrees that Linq is useful, powerful, and is used for SQL and other things. His point is that an additional DSL (regardless if you choose to use it) is another thing to know because you'll come across it and need to understand it. Whether this is always used for SQL is very unimportant to his point. There are countless powerful features in C#, and a lot of them also come with additional language syntax. How many hobby-only programmers pick C#? It's a lot less than other languages because you need to be using it every week to stay on top of new developments. My team hired half a dozen developers straight out of college in the last year. When they learn the 25 keywords in Go, they can write decent code and understand our codebase a day after learning. We use more C# than Go, but when a junior developer uses C#, they have a ton to learn. ASP.Net, ADO, concurrency, boxing / unboxing, generics, etc burn up a lot of training and code review hours. To the OP: Go ahead and learn Go. You can use it only once and a while without getting rusty because the simplicity of expression is its biggest strength. I use C# for a lot too, but for single-binary commandline apps, the experience with Go far outshines C#, in my opinion. For micro-services, I tend to use C# and [Dapper](https://github.com/StackExchange/Dapper) when I'm talking to SQL a lot, and if I can use a memory mapped file for my data store, I use Go with [Storm](https://github.com/asdine/storm). Personally, I love both languages, but I enjoy that C# focuses on a complex, full featureset, whereas Go focuses on absolute simplicity--even when it costs in lines of code and sometimes at the expense of a use case. Neither approach is "better", but I think Go adding complexity to gain more powerful syntax is bad just like I think C# should continue to do so.
Thanks though I know about these pkgs. That's why I have specifically asked for projects using them :-)
Go is so unique and it dosen't have Generics, I fear it will mass destroy the language, my only argument.
It all comes down to experience, the more you'll use packages, the more you'll know which ones to use, which ones to avoid.. without that, asking here or forum or slack is the optimal way to see what people would use in that specific use case. I rely a lot on https://godoc.org, and stars and imports offer the way to determine the actual package usage.
I wrote this library to help with the problem of parsing my environment configuration into a struct. I was unable to find any other libraries that did everything I wanted it to do, so I wrote my own. Any comments/suggestions/contributions would be appreciated.
&gt; for two reasons, single binary and better performance. &gt; .net can have single binary and cross compile similar to Go; and faster compilation and runtime now I think you should stick to C# unless you really need something Go has that C# does not or unless you find working with Go more fun.
I think the original implementation added a keyword and now it doesn't, which gives less risk of something somewhere breaking when Go is upgraded.
Thank you. This clarifies it. 
That's a distinct interface from the transport.AuthMethod in OP's question, unfortunately.
Labstack Echo is all right.
One more question. If I make TodoList and DayList aliases instead structs the way I made them, I cannot change them in place in functions like "InsertTodo" or is there another way I am missing?
[Talks should be on YouTube within two weeks.](https://twitter.com/bketelsen/status/886962250824732674)
Thanks for the enlightening me! That is exactly what I needed to see. Will edit the post.
The OP was perhaps less than clear about LINQ; why are you responding like he insulted your mother?
In order to modify them, you'll need something like this: https://play.golang.org/p/vwnmnUHRWW but beware of this https://play.golang.org/p/lfdvrQpfX1 The other option is to have any method that modifies the slice return a slice, which matches the behavior of append. But it's a matter of taste and circumstance.
Why is docker not a good benchmark? It's a large, widely used code-base. Whether or not it is the best tool for its stated purpose (if that's what you're even driving at) is unrelated.
That seems odd, since git works over ssh. You sure? I can't really check on my phone.
You really will only need something like https://github.com/go-chi/chi (or gorilla/mux) to give you just enough sugar on top of net/http. I bet you'll spend more time with a "framework" like buffalo/gin/echo/goa/gokit/... learning and getting it setup than you will just with a router and net/http.
Yup, I'm sure. OPs linked interface has exported methods, your linked interface only has unexported methods.
Thanks, I use telegram and am learning Go, so this is really interesting. 
But aren't they in the same package? Or is it a different `transport`?
Any http router would do. I use Chi on all of my personal and work related projects. Even the standard library can do what you need. I don't know about Angular but I have a neat hobby project using Go as the backend and Ember as the frontend. Seems to work out fine as long as you don't expect things to just wire themselves up. It's gonna take at least a little effort.
She also built a simple container from scratch in less than 100 lines of Go at GolangUK. In my opinion, one of the most entertaining and informative talks at that conference.
Different. OP is looking at `github.com/src-d/go-git/blob/master/plumbing/transport.AuthMethod`, you're looking at `golang.org/x/crypto/ssh.AuthMethod`
The Compile func should absolutely return an error if the re is invalid. You could add a MustCompile if you want to have one that panics instead of it isn't valid.
You can program one ... or not send invalid data &gt; For all its power, the computer is a harsh taskmaster –sicp
This is still kind a WIP, but with all the talk on generics going on I wanted to start writing down some thoughts on what can be done without them. I think this is important so that when we start comparing solutions that do use generics we have something to compare it to. We can easily look at code generation vs the generics version and decide, "which of these is actually easier for developers to use?"
I wrote https://github.com/zpatrick/fireball to help me quickly write rest services for work/personal use. I usually copy the [api example](https://github.com/zpatrick/fireball/tree/master/examples/api) and go from there. 
great article! looking forward to see more `usr/bin` stuff ported to go, even just for proof-of-concept only.
That article was a lot to make it through, but the writing is very easy to understand, and the information was quite interesting!
For a pure Go audio library, have you looked at [faiface/beep](https://github.com/faiface/beep)? While early in the process, the author has a reputation for following through and being productive (same author as the PIXEL game lib). It might be a good place to combine forces.
What would you want to work together on? An ALSA driver? It's worth noting that users of oak don't need to use the built in audio library if they don't want to. Batch loading as it currently stands won't work with other libraries but that's a feature that needs to be reworked a little bit anyway to be more extensible. 
The long format reminds me of https://github.com/rentzsch/lich. Come to think of it, Lich might be a good log format. 
Does Object contain any pointers (or pointer-like types -- maps, slices, or channels)? Then definitely pass a pointer and mutate. Otherwise, either way. If you find yourself wanting to keep both copies, then maybe prefer making a copy. Otherwise, the mutate form is also fine.
I've been using goa for a year now and yeah it takes some getting used to especially since it have its own language to generate the code. However, it pretty much handle all responses, params, error checking...90% of the stuff that I care about. It also generate the swagger file which my end users can use to automatically generate a client in the language of their choices. However, it's a bit of a pain to get any contributors since they have no clue how to use it and it's also harder to set up. I'll be looking for a simpler framework for my next major release.
lmao
&gt; Why do closed channel writes panic? What else would you expect them to do? &gt; aren't channels supposed to be synchronization helpers? Sure they are. A sync helper that lets you know that your messages will never be accepted is very helpful! &gt; It seems like saying this car has no reverse gear because it is supposed to drive forward Because processors, like Don Draper's life, only go in one direction -- forward. 😎 &gt; Why are unused variables and imports errors by default? You said it, clean code. The variables can be annoying, but the imports issue is 100% resolved with good editor integration with Go imports. &gt; Why are there so many bad std lib apis with stupid stuff Patches appreciated. I'm not certain, but I believe many of the crypto examples you gave have to do with crypto safety, i.e. avoiding common gotchas. if len(src)%x.blockSize != 0 { panic("crypto/cipher: input not full blocks") } Is that really from the stdlib? I'm pretty surprised to see a panic down there rather than an error return, but I'm willing to bet it's not a simple mistake, but instead a carefully made decision.
You have to understand, after reading the intro documentation to Go, that it is a very opinionated language stemming from the real life frustrations observed in real production situations. The goal was to create a language that is simple, powerful, and also tried to guard against bad habits and bugs that cause headaches in production. Once you understand that, it might be easier to know why certain decisions were made. &gt;* Why do closed channel writes panic? &gt;The explanation goes like "there's a bug in your code if something writes to a closed channel". Because it implies that you have a bug in your code where you aren't controlling your producers properly and probably have a race in deciding when multiple producers should stop producing. Only a single goroutine is meant to decide when a channel should be closed. And if you want to spread that control across your producers then you have to synchronise it yourself as something like a sync.Once &gt;* Why are unused variables and imports errors by default? It has been stated before, regarding this question, that history shows people just ignore the warnings and flags and the check ends up being pointless. It is also not just about you knowing your code or adding bloat to the binary size. It adds cognitive load to other people looking at your code to figure out what is used or not. Once can't just read the code and know. They would have to compile it with your "production" flag. So as a result, no unused variables or imports. And just make use of linters and goimport &gt;* Why are there so many bad std lib apis with stupid stuff and just forced redundancy everywhere Well that is just an opinion that people can't answer unless you identify every package you take issue with, like you did with crypto &gt;It feels like the language tries to babysit its own developers and does a really bad job with that. &gt;... &gt;There is no amount of babysitting that can prevent dumb stuff from happening or being written anyway. &gt; Go does a nice job of at least trying to mitigate some of it. &gt;Many people start arguing "just use c or asm then" in response. &gt;Why is it forbidden to have the wish for performance and convenience in the same toolkit especially if it is not a technical limitation but just ideological? I wouldn't say this. I feel the response you would likely hear is that if you don't appreciate the opinionated stance Go has taken in an effort to be a simple, productive, performant, and maintainable language, then it might not be the right tool for you. I'm unbiased as to what other language you should use instead. 
Standard lib and httprouter fit the bill for our project.
&gt;What else would you expect them to do? I would expect to maybe be able to select onto a channel write and get a default behaviour on a closed channel like non-blocking reads. Even a very good editor cant take the decisions for unused variables from you and depending on the size of your refactor you may waste 10%-20% of your work time just to please the compiler while investigating a rare edge case somewhere especially because you may need to comment out/in all these variables in multiple files over and over again. btw the std https://golang.org/src/crypto/cipher/cbc.go#L55
&gt; I would expect to maybe be able to select onto a channel write and get a default behaviour on a closed channel like non-blocking reads Do you feel the same way about file I/O? Should reading from or writing to a closed file be OK? &gt; depending on the size of your refactor you may waste 10%-20% of your work time just to please the compiler while investigating a rare edge case somewhere especially because you may need to comment out/in all these variables in multiple files over and over again. Your code must be a lot harder to debug than mine. In fact, given that you think it makes sense to proceed on a read or write to a closed channel, I'm quite certain of it.
no you shouldn't but you can at least check for it. And reading from a closed channel is possible as you know. why should that be so asymmetrical?
And then what? Panic?
Unused variables being an error is annoying to me - even being a total newb - as well. But I do like how clean the code is because of that. But I also always get a heart attack when there's an error again...
Why is it a panic to communicate production stop through the production channel itself? If you allocate extra synchronization primitives for that you just increased complexity. Even separation of concerns is a weak argument here. It would just be a very flexible and widely applicable synchronization mechanic. Regarding the unused variables, I'm totally with you that you should be e.g. forced to only commit clean code and you could accomplish that with a "go build --production" git hook for example. But its even enforced in work-in-progress situations with possibly a lot of back and forth.
are you serious? return a bool or like I suggested a special select mechanic just like non-blocking reads on channels have.
Maybe you can check Drolls source code to have ideas on how you can implement it. I am afraid you will not be able to avoid going into AST, parsers, etc. Or maybe you can do something using existing Lua or JavaScript parsers made in pure Go.
&gt; are you serious? Well, my response was a bit tongue-in-cheek, but yes, I'm serious. It's entirely possible to write code that will NEVER put itself into the clearly insane state of attempting to use a closed channel. Code written that way if far easier to reason about, and that's a VERY GOOD THING. Go is about simplicity, not about doing everything possible in every possible permutation. I want to write, maintain, and contribute to code bases that are so incredibly clever that they're not clever at all. I don't want to have to think "what if this channel is closed?" each time I use one. Processors are simple. Languages have grown distressingly complex. Go is a breath of fresh air. Question: how many years have you been writing code?
regarding your edit about refactoring time, I'm talking about over 1mb .go files alone and to be honest I just boiled over after I just wasted over half an hour just cleaning up all the variables of an big experimental change that revealed himself to be fundamentally flawed after it finally compiled.
But you don't have to. You could just panic in the default or don't use my proposed select syntax at all. And where is the difference to "what if this synchronization primitive preventing channel writes is set?" anyway? The logic complexity of a given problem doesn't change. Just the code gets easier to follow. I'm not about proposing every syntactic sugar python came up with ever here. I was even ok with the old problem with multiple assignment and reassignment that only worked for the special error var. I'm just talking about something that is not only annoying to me and would increase the symmetry. edit: I'm writing code roughly for 10 years and am working with go since before 1.0.
Thats the path which looks likely . Drools has a ebnf file which I will port to Go. https://github.com/kiegroup/drools/blob/5.6.x/drools-docs/drools-expert-docs/src/main/docbook/en-US/Chapter-LanguageReference/drl.ebnf
As an inspiration, I have been looking into https://github.com/mattn/anko
&gt; Just the code gets easier to follow I could not disagree more. No code is better than no code...
&gt;No code is better than no code... that's exactly what **I am** arguing. Extra synchronization primitives are unnecessary code. Maybe we should talk in a little bit more specific examples here. I'm pretty sure we both have examples in our heads right now that emphasizes our position. Can you explain why you argue that a consumer shouldn't communicate production stop to the producers per design or why one producer should not be able to shut down the chain if he encounters bad data that makes progressing impossible without crashing the whole program?
You may consider it as joke: https://gist.github.com/funny-falcon/7d6d01e19cc7072e58ee
I've said none of those things, and Go has good ways of handling all of those without adding any complexity to the language. The difference is that IF and WHEN that is the design, it should be explicit. What you're proposing would make it impossible to tell if that was the plan -- or whether the code is simply foobar.
Interesting topic and wel written!
but itsn't that true for e.g. accidentally set locks or atomics too? Where's the difference between explicit channel closing and explicit sync setting?
Pattern Matching and sum types are great, sorry to disagree. Check out this video https://vimeo.com/97507575 where Scott shows how to create a domain model just by using types, making invalid model state unrepresentable with the types he chooses. LoC was mentioned just that there will be more code to maintain. Maybe simpler but still more code (which can mean more bugs). Who would say that the following statement is hard to maintain (C#)? var list = new int[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }; var sum = list.Sum(); What would the equivalent code in go be? (At least twice that) Every language has it's value and every developer has to decide what that is.
&gt; If you need to drive backwards Unlike driving a car backwards, writing to a closed channel is clearly an error. Consider that only a sender, but never a receiver, should close a channel. And after the sender closes the channel, it makes no sense to continue to write to that channel. So this is clearly a code design error, and the runtime should better panic rather than hiding the coding error by switching to some default action that only may trigger more erroneous behavior at run time that becomes hard to track down. 
Make sure to check the side to side binary sizes and memory footprints too. 
It is! And it's LONG been known that those are the source of many bugs in every language that implements them. Which is why Go encourages the use of easier-to-get-right channels.
Why isn't it feasible that a consumer communicates to the producer to stop throwing shit at him through the channel? You just claim that's somehow wrong for some reason but I have yet to see a good explanation for that claim.
Neither can I remember a case where that happened to me nor can I recall a big argument about it anywhere due to a big problem in a big code base like Linux kernel or gcc. All the go people (and I am not counting myself because despite me using it extensively I always was quiet critical of the design decisions) just claim that this is a big issue and i have yet to see a good example of a case where this could be a problem without plain stupidity that would result in the same mistake on explicit syncros.
Because if the consumer closes the channel, it has no chance to consume any unread items anymore. Better use an out-of-band backlink to tell the producer to stop producing and then continue to read from the channel until it is empty (using the "comma, ok" idiom).
Thanks, man, but I figured it out. See Post edit.
That's right. Still trying to get used to orient myself within the source file layout of a typical go project. Thanks for the input tho!
Your anecdotal evidence has convinced me that decades of crashing software actually worked perfectly and that fully utilizing multi-core CPUs is child's play. Again I ask: how long have you been a developer?
Seeing a lot of code in the last 20 years or so, good/readable code happens either because you are anal and everybody hates you for it when code reviews happen, or because of automated tooling that cleans up shit (linters, code formatters like go fmt or even go build in this case of unused variables). For one, I'm for less friction between developers and more tooling that quickly identifies code smells so they can be resolved.
I already answered that in an older reply, again, roughly 10 years and i worked with go since before 1.0. How is your claim that many crashing programs are caused by not properly handling multi-threaded producer-consumer pipeline closing caused by ambiguous synchronization syntax stronger than my statement that this never happened to me or any project that made it to general news even without panicing channel writes? That's just not a productive argument to have. I've never seen an actual example from any go programmer ever that was objectively more expressive and less ambiguous than the same example with a way to write to a closed channel without a panic. Everyone who is against this idiom is rejecting go and everyone who has no problems with it just keeps repeating "you are doing it wrong". Its kinda stupid tbh. I would really like to see an actual argument with real examples from both sides that result in one of 4 possibilities. 1. it may really just not matter at all 2. write panic wins 3. write no-panic wins 4. there are scenarios for both cases where one is clearly superior which you could rate as win against panic. I strongly believe that 4. would be the final result.
&gt; It feels like the language tries to babysit its own developers and does a really bad job with that. A programming language is arguably the most powerful tool on earth right now and programmers need to shoulder the implications. There is no amount of babysitting that can prevent dumb stuff from happening or being written anyway. why not just write in c then, man.
Since Go-2 is going to be real, why don't you make a proposal about you desired behavior and discuss it in the large?
You just assumed that the channel is buffered and that the consumer wants to process all the data in the buffer. In that single case you are completely right and you could easily resolve the matter like before. What about an early exit because the consumer found what he was looking for or maybe an error occurred or an unscheduled program shutdown or whatever? There are so many other scenarios in which an early shutdown that propagates to the producer would be really useful. You could even use it as an error handling channel without crashing the runtime. In other words, why is it ok to propagate a channel shutdown from the producer to the consumer and not the reverse even tho channels are bidirectional by nature?
Can you give an example?
you actually read all of that? respect. I'm not good with these kinds of things and I am sure that there already are hot discussions regarding this topic but as I said, my reason for this whole thread was the assumption that I got something wrong and I really expected to get a good argument that I was just too stupid to figure it out myself. I normally expect people around me to have way better reasons for doing things than they seem to at the surface and I think that's an important attitude to have especially on the internet.
I'm completely with you as long as we are talking about committing work onto a general codebase but I don't think that this should be necessary for local debugging and developing steps before that.
The behavior of append was what I started out with but I did not like the feel of it as I felt like I manually had to copy in different places even after I inserted my new Element. Can the second behavior be explained by saying that everything is call by value in go and that you can only mimic call by reference when you use pointers? Is there such a thing as call by reference in Go? Thanks for the examples
&gt; You just assumed that the channel is buffered and that the consumer wants to process all the data in the buffer. Yes, because in a procucer/consumer model, data is usually buffered between producer and consumer, and not consuming processed data means data loss. An unbuffered channel is merely a means for synchronization. &gt; What about an early exit because the consumer found what he was searching for or maybe an error occurred or a unscheduled program shutdown or whatever? Use a separate channel, a WaitGroup, or an ErrGroup for these cases. &gt; In other words, why is it ok to propagate a channel shutdown from the producer to the consumer and not the reverse even tho channels are bidirectional by nature? A channel is bidirectional at creation time, but usually you will want to pass it as a read-only channel to the consumer (by using the `&lt;-chan` syntax when passing the channel to the receiving goroutine). Why? Because it make the data flow clearer. If a channel's purpose is to pass data from producer to consumer, then the consumer has no business writing to that channel. Any backward communication should be made clear by using separate communication. [This blog post](https://blog.golang.org/pipelines) explains some of the typical pipeline patterns in Go. (Edit: typo)
"The key point here is our programmers are Googlers, they’re not researchers. They’re typically, fairly young, fresh out of school, probably learned Java, maybe learned C or C++, probably learned Python. They’re not capable of understanding a brilliant language but we want to use them to build good software. So, the language that we give them has to be easy for them to understand and easy to adopt." – Rob Pike 1 "It must be familiar, roughly C-like. Programmers working at Google are early in their careers and are most familiar with procedural languages, particularly from the C family. The need to get programmers productive quickly in a new language means that the language cannot be too radical." – Rob Pike 2 So here's your answer why there are so much stupid decisions in go ... it's build to reduce complexity at all costs because it's developed for idiots.
This is all circular reasoning. Nothing of these things are defined like that except through a in my view unreasonable limitation of the language. I'm not asking how I could solve this with the limitation (I get that) but why it is there in the first place? There are specific scenarios in which it would be stupid to allow a reader to randomly close the channel and I understand that and there are even specs already in the language like one-way channels to deal with them but this just ignores all the scenarios in which you need to work around an unnecessary limitation with additional synchronization primitives. Fundamentally a channel is a bidirectional synchronization and communication tool that can be limited if it makes sense. But it acts limited even in its origin state for no apparent reason and limits its applications to a mere subset of its potential. The question is just **why**?
And why do all newcomers run into the panicing closed channel write if not explicitly explained in advanced? Doesn't that seem kind of the opposite? Both these quotes are well said and really smart and I can't do anything but agree but the actual language doesn't seem to represent that in many ways.
You should take a look at https://github.com/go-chi/chi ... 
Thank you. Ok, why? :) So far, I like: &gt; The key considerations of chi's design are: project structure, maintainability, standard http handlers (stdlib-only), developer productivity, and deconstructing a large system into many small parts.
I dislike all the ceremonial and god-like dogmatism of Rob pike. .
&gt; Why do closed channel writes panic What should a closed file write do, or a pop from an empty list? Let's not silently ignore errors. &gt; Why are unused variables and imports errors by default That's correct behavior for a compiler, for a language that cares about correctness. By the way, this can be "trivially" worked around by an IDE. Even in a language that's hard to statically analyse, like Python, an IDE can automatically remove unused imports. &gt; Why are there so many bad std lib apis with stupid stuff and just forced redundancy everywhere Yea, that can and should be fixed, but the problem is compatibility. Maybe it's something for Go 2 to address, when it's done self-destructing over generics. :-) BTW I can't think of a well used language that is free of this, and Go is better than most at it.
Let's step back for a moment and take a broader look at this. Here is a truth that should be obvious to everyone: No programming language is perfect. Designing a new programming language is hard, and you have to make a lot of design decisions along the way, and most of them are about finding a good compromise between various different requirements (syntax, compile time speed, runtime speed, etc.), so whatever language you are looking at, you always will find shortcomings. Usually, there are pragmatic solutions to these shortcomings, like those I mentioned for the "closed channel" case. And this is true for any language. Some 20 years ago I was like you, always looking for the perfect programming language and not accepting language features or shortcomings that appeared to make no sense to me. I learned that such a language does not exist, and never will. If you have the freedom, pick the language you are most comfortable with. If you have to use a particular language, try to embrace the good things and avoid or work around the bad things (like I successfully did even with JavaScript, thanks to the awesome book "JavaScript - The Good Parts"). In the end, you have to choose between pragmatism and purism. I chose the former and have lived happily ever since. :)
idiot != inexperienced
&gt;BTW I can't think of a well used language that is free of this, and Go is better than most at it. That's the whole reason I'm so frustrated by these things. &gt;Let's not silently ignore errors. I would never suggest such a mortal sin. I already argued my stance to this in other replies. I think it should behave similar to a closed read. Its a bidirectional structure after all and there's no reason to handle writing differently than reading in such an asymmetric way. Some other way of error handling/checking that you can use if you expect someone to close the channel but still panic as default behavior if necessary. You could for example handle the close inside a select case similarly to non-blocking channel reads/writes. &gt;By the way, this can be "trivially" worked around by an IDE. Even in a language that's hard to statically analyse, like Python, an IDE can automatically remove unused imports. True but I mainly talk about unused variables while developing see here https://www.reddit.com/r/golang/comments/6nyo5i/can_you_explain_all_the_annoying_stuff_in_go_to_me/dkdb2b1/ 
How does it compare to math/big (speed-wise)?
I mean, yeah in the debugging phase it's sometimes a bother to comment out / uncomment variables as you bring them in and out, but there's several go editors that actually make this really easy for you to do.
Well, there's always git tools to deal with reverting changes that didn't work out. 
I thought I already arrived at the same conclusion about programming languages some time ago and despite many shortcomings of go that I didn't even mention here it generally feels like a potent language. Most of the problems that go has have good arguments with technical limitations, considerations and extensive implications that seem like choosing between the devil and the deep blue sea. I'm willing to accept these because I can at least partly comprehend the thought that went into them and that the alternatives wouldn't have been any better in the end. But these things that I'm frustrated by don't seem to have any of that. They just seem like unnecessary limitations that don't help anyone. I guess I would be happy with the answer that there is no deeper reasoning and this just went wrong, end of story.
Beep beep im a sheep
&gt; True but I mainly talk about unused variables while developing see here Wow. Do you not use version control?
&gt; And why do all newcomers run into the panicing closed channel write if not explicitly explained in advanced? Because that, in my opinion, is a very dumb design and works against the expectations of the user.
They stay inexperienced with such a dumped down language. I really like the appeal of Go and it was a joy to write in it but it's hacked together and lacks anything from the last 30 years. It's C with concurrency and for me that's not enough in the 21st century. Pattern matching, would reduce boiler plate code, make it more readable, error handling explicit. Generics, Go has them but only for build-in types because compiler magic. Etc etc etc.
I'm not frustrated about reverting, I'm frustrated about half an hour already gone just because of the stupid compiler complaining about unused variables before I could even recognize the flaw at runtime in the first place.
May I ask how important is it to have zero dependencies for a game engine? I'm assuming that you're going to need some kind of specific stuff for input (controllers) and to integrate with appstores such as steam, and you're going pick up dependencies from there.
Thanks for bringing up GraphQL, that is exactly what I was looking for! I have been switching between a couple of multiplexers, see also https://github.com/avelino/awesome-go#routers for a more complete list. My own experience is that I dislike frameworks, they never seem to play nice with other packages that I want to use. Replacing `http.Handler` is a big no-no for me. In that respect I like `httprouter`, but `chi` looks nice too. At the end of the day, if it works it works. Just go with whatever you feel comfortable with.
someone else pointed the out the same thing. its not about reverting (ofc I use vc wtf) its about the half hour that is already wasted just to please the compiler in the first place. It still would've been frustrating without that but at least I wouln't have wasted all the time just to find my mistake in the first place.
It would be better to say the goal of the engine is to have zero dependencies outside of Go. Obviously games will pull in Go packages, and if games want to pull in C libraries and compile them we aren't going to stop them but it's frustrating to have an additional installation step beyond `go get` for working with any Go library, and I don't think game engines should be an exception. Ideally steam and controller libraries would also be in Go!
&gt; They just seem like unnecessary limitations that don't help anyone. And there are easy and straightforward and pragmatic workarounds, so in practice there is no limitation. &gt; I guess I would be happy with the answer that there is no deeper reasoning and this just went wrong, end of story. This is what perhaps only the language designers can answer.
&gt; They stay inexperienced with such a dumped down language And there I was thinking speed-to-ship, being a debugging god, or being able to design complex architecture was how we distinguished great engineers from the average.
I totally agree with the frameworks. This way, it is very easy to switch multiplexers if the requirements change.
OK, but I'm surprised there's no IDE that can do this. Maybe tools on Go are still nascent? I'm not convinced it's a fault of the language design, and in fact, I support it. Unused vars are latent bugs, or a sign of poor code quality.
My IDE (vscode) does tell me about unused variables and they aren't a hassle to deal with 
My IDE does too and go build prints every line with a unused variable at one compile try too. The issue arises if there are just so many of them that just the time you need to work through them all gets ridiculous. This mainly happens because if you comment out one statement with an unused variable this can cause another unused variable somewhere else.
I've worked with SML, Go, and an offshoot of Haskell that adds more complexity to it as my primary languages in the past few months. Its true that I've learned more from working with SML and the Haskell-offshoot, but I've produced 10 to 100 times the useful productive code in Go than in the other languages, and when I see challenges ahead, in Go I embrace them. In the other languages, I say "That's going to take way too long to debug and get the compilers to be happy with a neat way to do this" and put it off. Go lets programmers be productive without having to juggle inheritance of modules, monads, pattern matching, pure IO, compilers trying to be too smart and let you not type half your variables and get everything wrong when you don't (see SML). Error handling in particular is very explicit in Go, but is not explicit in either of those languages which you would probably call 'better'. 
&gt; How does it compare to math/big (speed-wise)? Not well b/c math/big calls assembler routines and thus avoids range checks. BenchmarkAdd/big_1000+1000_bits-4 30000000 40.1 ns/op 0 B/op 0 allocs/op BenchmarkAdd/gmp_1000+1000_bits-4 10000000 165 ns/op 8 B/op 1 allocs/op BenchmarkAdd/big_10000+10000_bits-4 10000000 174 ns/op 0 B/op 0 allocs/op BenchmarkAdd/gmp_10000+10000_bits-4 2000000 932 ns/op 8 B/op 1 allocs/op BenchmarkAdd/big_100000+100000_bits-4 1000000 1904 ns/op 0 B/op 0 allocs/op BenchmarkAdd/gmp_100000+100000_bits-4 200000 8888 ns/op 8 B/op 1 allocs/op BenchmarkAdd/big_1000000+1000000_bits-4 100000 19112 ns/op 1 B/op 0 allocs/op BenchmarkAdd/gmp_1000000+1000000_bits-4 20000 86743 ns/op 8 B/op 1 allocs/op BenchmarkSub/big_1000-1000_bits-4 30000000 46.2 ns/op 0 B/op 0 allocs/op BenchmarkSub/gmp_1000-1000_bits-4 10000000 177 ns/op 8 B/op 1 allocs/op BenchmarkSub/big_10000-10000_bits-4 10000000 180 ns/op 0 B/op 0 allocs/op BenchmarkSub/gmp_10000-10000_bits-4 2000000 936 ns/op 8 B/op 1 allocs/op BenchmarkSub/big_100000-100000_bits-4 1000000 1915 ns/op 0 B/op 0 allocs/op BenchmarkSub/gmp_100000-100000_bits-4 200000 8576 ns/op 8 B/op 1 allocs/op BenchmarkSub/big_1000000-1000000_bits-4 100000 19131 ns/op 1 B/op 0 allocs/op BenchmarkSub/gmp_1000000-1000000_bits-4 20000 83854 ns/op 8 B/op 1 allocs/op BenchmarkMul/big_1000*1000_bits-4 2000000 752 ns/op 0 B/op 0 allocs/op BenchmarkMul/gmp_1000*1000_bits-4 500000 2992 ns/op 8 B/op 1 allocs/op BenchmarkMul/big_10000*10000_bits-4 50000 38969 ns/op 1408 B/op 1 allocs/op BenchmarkMul/gmp_10000*10000_bits-4 10000 229189 ns/op 8 B/op 1 allocs/op BenchmarkMul/big_100000*100000_bits-4 1000 1569143 ns/op 13649 B/op 1 allocs/op BenchmarkMul/gmp_100000*100000_bits-4 100 22437345 ns/op 8 B/op 1 allocs/op BenchmarkMul/big_1000000*1000000_bits-4 20 63995349 ns/op 207769 B/op 8 allocs/op BenchmarkMul/gmp_1000000*1000000_bits-4 1 2241657949 ns/op 8 B/op 1 allocs/op BenchmarkDiv/big_1000/500_bits-4 1000000 1027 ns/op 176 B/op 1 allocs/op BenchmarkDiv/gmp_1000/500_bits-4 1000000 1397 ns/op 0 B/op 0 allocs/op BenchmarkDiv/big_10000/5000_bits-4 100000 21175 ns/op 1408 B/op 1 allocs/op BenchmarkDiv/gmp_10000/5000_bits-4 30000 58539 ns/op 0 B/op 0 allocs/op BenchmarkDiv/big_100000/50000_bits-4 1000 1636243 ns/op 13617 B/op 1 allocs/op BenchmarkDiv/gmp_100000/50000_bits-4 300 5544318 ns/op 0 B/op 0 allocs/op BenchmarkDiv/big_1000000/500000_bits-4 10 163576948 ns/op 157441 B/op 2 allocs/op BenchmarkDiv/gmp_1000000/500000_bits-4 2 558114619 ns/op 0 B/op 0 allocs/op BenchmarkRem/big_1000%500_bits-4 2000000 975 ns/op 112 B/op 1 allocs/op BenchmarkRem/gmp_1000%500_bits-4 1000000 1252 ns/op 0 B/op 0 allocs/op BenchmarkRem/big_10000%5000_bits-4 100000 20844 ns/op 704 B/op 1 allocs/op BenchmarkRem/gmp_10000%5000_bits-4 30000 59146 ns/op 0 B/op 0 allocs/op BenchmarkRem/big_100000%50000_bits-4 1000 1642758 ns/op 6583 B/op 1 allocs/op BenchmarkRem/gmp_100000%50000_bits-4 300 5541698 ns/op 0 B/op 0 allocs/op BenchmarkRem/big_1000000%500000_bits-4 10 162648875 ns/op 91829 B/op 1 allocs/op BenchmarkRem/gmp_1000000%500000_bits-4 2 556512561 ns/op 0 B/op 0 allocs/op PASS ok github.com/cznic/minigmp 118.484s Looks like it's time for CCGOASM. edit s/Look's/Looks/ 
I think you're just doing too many things without checking that your code is correct? Did you write all of this half hour of code and then check for unused variables?
I already answered that in another reply: &gt;I'm totally with you that you should be e.g. forced to only commit clean code and you could accomplish that with a "go build --production" git hook for example. But its even enforced in work-in-progress situations with possibly a lot of back and forth.
I think this is one of the challenging trade offs the language designers made. While leaving temporary variables around when debugging can be useful, it almost never makes sense for them to go into prod. It's worth noting that while it's becoming more of a community directed language, it's still very controlled by Google and it makes the most sense for them to avoid anything silly making it into prod because that means you need to clean it up later. You'll see this all over the place in the language. It almost seems like it doesn't care about the programmer's time, but the idea is just to front-load the effort. This doesn't work all the time, but at least in my experience it generally saves time in the long run. 
So people who write Go and don't use git should be allowed to write bad code? What if they don't include the flag? Go isn't git, and this (and go fmt) prevents there from being hard to read code getting out there.
Currently it doesn't, but hopefully it will in the future, with the help of user base.
Nice. One of my projects uses a discord bot as log. All the logs are send into a channel which makes them available for everyone who has access to the channel. If something bad happens the bot can tag the whole Channel so everyone gets a notification on mobile or desktop + discord has some basic markdown, so nice formatting is also possible. Sure... Thats not a enterprise solution, but it's fun and easy to program.
Just configure your editor to call goimports on save. Got variables you can either comment it out it use the blank identifier. It's really not a big enough issue during development to justify removing the aforementioned benefits.
the only thing that will inevitably happen is https://stackoverflow.com/questions/21743841/how-to-avoid-annoying-error-declared-and-not-used-from-golang and this kind of quality check should be best practice regardless of the language used and is widely adopted across many version systems. If you don't use any sophisticated version system and start writing shitty code no one will care and you would probably code in python anyway.
There's a small chance that the OP is working on spaghetti where you can't just replace functions. Even good code gets that way sometimes when you have to deal with the business/domain logic. However my current opinion is in line with yours.
As I said I think its really cool that go has this feature to begin with and I understand its purpose but there should be a way to turn it off for local debugging purposes or even better be opt-in with a flag that the project maintainers can enforce for contributors if they want to.
Sometimes it takes a lot of changes to implement a core logic change that actually compiles and runs. I spent half an hour tracking down all the variables and imports that are not used anymore but there were some frustration xkcd visits here and there.
Firstly its not only my code and second there are indeed some medium level spaghetti functions involved (for which I am only a small part responsible for) which I would've despagettified in the process of the rework. In fact the attempt to force better code by go caused worse code and more time necessary to work it out in the end.
Its mainly about unused variables that cause other variables to become unused when commenting them out and so on.
The problem with having an option to disable that is that you *know* some people would build everything with that option and turn it on in production... then you have people running into different bugs because they're building with different options. Plus there are complications, like this example: ``` func main() { x := somethingWithSideEffects() } ``` There's an unused variable there, but how coult that automatically be cleaned up with an option to disable it? If you completely remove the variable definition (and in extension, the call to somethingWithSideEffects) there's some code which won't be run which could potentially cause problems elsewhere. Alternatively, if the compiler just ignores the unused variable (and leaves in the call to somethingWithSideEffects), it's something that could easily be missed when you get around to cleaning it up and you could remove the call by accident. Forcing the user to do something here removes the problem of knowing that some code will either be skipped or run depending on what the compiler thinks is right and lets the user make sure the right thing happens. Less options and less complexity can be valuable by themselves, to avoid option hell (See: JIRA for an example).
BTW, have you read the Feathers book on legacy code? It's pretty damn good and helped me a lot. I'm not saying you're a bad developer. What I am saying is that Feathers is a rare genius. edit: https://www.amazon.com/Working-Effectively-Legacy-Michael-Feathers/dp/0131177052 (There might be a newer edition)
&gt;turn it on in production... In production there is a boss who is supposed to take care of these kinds of things. He even gets payed for it in most cases. In open source repositories there are maintainers too that should do the job. &gt;it's something that could easily be missed when you get around to cleaning it up and you could remove the call by accident. I think the probability of this kind of code getting accidentally removed is even higher if you always cleanup your code on autopilot on every compile to please the compiler and on top of that is such code considered bad practice anyway and we could go even one step further and say the compiler should deny compiling it Kappa. The only thing you can accomplish with this kind of forcing users to something you personally think is the best ends in something like that https://stackoverflow.com/questions/21743841/how-to-avoid-annoying-error-declared-and-not-used-from-golang Option hell is mainly a question of good documentation and common sense and should not be a go to tool to reject proposal.
That is not how real-world works unfortunately
But how are you supposed to write perfect regexps? Mistakes happen there 
I understand most of the trade offs you're mentioning, but in my experience they're worth it to make code more maintainable in the long run, with the expectation that it might take a bit longer to get it up to the expected standard. I've worked with just a few too many co-workers who say they'll clean up stuff later and never do because they get busy with other things. This language decision forces them to either do hacky things (which won't make it through code review) or fix the actual problems where they happen. That's why I like it... I don't have to waste time arguing with coworkers about it, similar to gofmt. The language enforces it so that's how it is. No disagreements about temp variables which might be used later which means less to think about for me when reviewing. The other reasons are just additional things that have come up in other conversations about this in the past... Anyway, like it or not, I doubt this conversation will change anyone's mind, but I hope I've at least done a decent job of explaining where some people see value here, even if not everyone likes it. :)
So this is basically the same thing as Rust's [Rayon](https://github.com/nikomatsakis/rayon#how-it-works-work-stealing), right? Coming from Java where people still spin a new Thread for all the useless crap, I'm so happy that this practice of work stealing is becoming more popular.
I have had actual bugs pointed out by the unused variable error many times.
It's been explained elsewhere in this thread... It helps avoid race conditions. I'd challenge you to write an example which consumers can ask the producers to stop which wouldn't have a huge risk for a data race. How do you handle multiple consumers both processing bad data (and trying to shut everything down) at the same time in a way which doesn't cause a race and doesn't (as you put it) use any additional synchronization primitives?
Like it or not, that particular quote does a decent job of explaining why quite a few of the stranger design decisions were made. :)
Many users coming to go are coming from languages like Python and Ruby where it's almost impossible to have a real data race. Go is a language which places a big emphasis on concurrency so it makes sense that there will be a number of relevant pain points.
Using a pointer as a method receiver is doing a call by value. Here are a few cases to help explain: https://play.golang.org/p/EE4X-Prww4 A slice is kind of like a struct with a length, capacity and pointer to an array. So when we set f2 = f, it makes of copy of those values, but because it's a pointer to an array, it doesn't make a copy of the data. One of the results of this is that many slices of different lengths can point to the same array. Changing the values will change it for all slices sharing a reference to that array. So the data is always passed by reference, but the length is not. It's also important to understand how append works. Append will check the capacity and if there is enough room left in the array, it increases the length of the slice. If there is not, it will allocate a new array and copy the data there. So after an append you may not know if two slices share an underlying array. The 3rd part of the example shows one of the dangers of this. If two slices both try to append to the same array, one will clobber the other. In practice, these issues don't come up that often and with a little understanding (and some tests) they're easy to work with. If you haven't read it yet, [this](https://blog.golang.org/go-slices-usage-and-internals) has some great details.
There's a couple of theoretical points to keep in mind: * A "rule" is a [declarative program](https://en.wikipedia.org/wiki/Declarative_programming). * A rule language is translated into an automaton (e.g. a [finite state machine](https://en.wikipedia.org/wiki/Finite-state_machine) or [pushdown automaton](https://en.wikipedia.org/wiki/Pushdown_automaton)). A naïve unbounded rule language may become turing complete, at which point its halting is impossible to prove i.e. it may run forever (and that's bad for hosted execution). So keep the power of the automaton bounded. Furthermore, you don't need to define a new language for your rule engine. You can embed your semantics into an existing format (e.g. JSON or XML) and compile your automaton from that.
**Declarative programming** In computer science, declarative programming is a programming paradigm—a style of building the structure and elements of computer programs—that expresses the logic of a computation without describing its control flow. Many languages that apply this style attempt to minimize or eliminate side effects by describing what the program must accomplish in terms of the problem domain, rather than describe how to accomplish it as a sequence of the programming language primitives (the how being left up to the language's implementation). This is in contrast with imperative programming, which implements algorithms in explicit steps. Declarative programming often considers programs as theories of a formal logic, and computations as deductions in that logic space. *** **Finite-state machine** A finite-state machine (FSM) or finite-state automaton (FSA, plural: automata), finite automaton, or simply a state machine, is a mathematical model of computation. It is an abstract machine that can be in exactly one of a finite number of states at any given time. The FSM can change from one state to another in response to some external inputs; the change from one state to another is called a transition. An FSM is defined by a list of its states, its initial state, and the conditions for each transition. *** **Pushdown automaton** In computer science, a pushdown automaton (PDA) is a type of automaton that employs a stack. Pushdown automata are used in theories about what can be computed by machines. They are more capable than finite-state machines but less capable than Turing machines. Deterministic pushdown automata can recognize all deterministic context-free languages while nondeterministic ones can recognize all context-free languages, with the former often used in parser design. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/golang/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.24
That may be the case but has nothing to do with this discussion. I never suggested that it would be a good idea to remove that feature and you could still use it as much as you want if it helps you. I only ever talked about the enforcement without exception.
Dude, really? Slow Tuesday and you just need to light a fire and watch the world burn? Anyway, welcome to our community. Stay if you want, but you'll probably be happier somewhere else. Hope you find that place.
When I started with Go the "unused variables are errors" thing drove me crazy. But then I noticed that it was also catching a lot of things that would have been bugs. Now I think of it as a good exchange - it's mildly annoying 90% of the time and immensely helpful 10%.
I work with someone who likes to talk about how we shouldn't use Salesforce because a rules engine would be so easy to write. If management ever believes him, it better be him assigned to it and not me...
Thank you, this helps a lot. I think I got it now :-)
&gt;Anyway, like it or not, I doubt this conversation will change anyone's mind you may be right there. &gt; This language decision forces them to either do hacky things (which won't make it through code review) or fix the actual problems where they happen. I see this kind of argumentation again and again and it is just not true. It is very easy to prevent someone from committing at all without running a check like "go build --strict" or something like that. There are powerful git features that can actually refuse commits that are not properly checked with actual crypto and I am pretty sure similar things exist in other VC systems too. It should be the job of the repository maintainer(s) to enforce standards and not the language and there are fully automated ways of doing that. You get the same or even better repository maintenance depending on the restrictions and tools you use and people can do what they want locally and if they're done they have to cleanup and commit/push/whatever. And if someone feels masochistic no one stops him from running go with an alias that always enforces strict code standards on compile. I just don't get this attitude that they just have to enforce a specific behaviour that they think is the "right" way onto a gigantic world-spanning community. that seems just megalomaniacal and sophomoric to me.
This basically allows you to build an “insert or update” procedure which is often very useful. For example, consider a database for some storage management software. The table maps items to how often they are in your storage room. When you get an item, you want to (a) create a new entry for this item type if this is the first item of its kind or (b) increment the number of items of this type. `LoadOrStore` allows you to achieve this behaviour: Prepare a blank item record, then `LoadOrStore` it. Now increment the number of items for the record `LoadOrStore` returned (of course, while locking that record). Without a `LoadOrStore` operation, this would be very hard to implement correctly.
channels are threadsafe and already use locks internally. so there are no race conditions. There can be multiple consumers and multiple producers on a single channel so your proclaimed race condition can happen anyway if you allow closing a channel at all and that doesn't happen either. edit: ahh you are talking about mutiple threads calling close on the channel...
Read my comment carefully. I use `LoadOrStore` in my example to initialize the record if it doesn't exist. If I would just use `Store`, I couldn't increment the counter in the record without a race condition otherwise. The pseudo code is roughly this: 1. record ← map.LoadOrStore(item, blankRecord) 2. record.Lock() 3. record.Counter++ 4. record.Unlock() 
&gt; So this is basically the same thing as Rust's Rayon, right? it's the same overall concept, but there seem to be some differences, ~~like having a global work queue and local work queues, where I think Rayon just has a global work queue.~~ Go's implementation of coroutines also maybe allows it to context switch into a new piece of work faster, possibly? Rayon also provides lots of convenience functions that are generic over iterators and containers, which is not really possible in Go. But yeah, very similar.
Yes, you're right. Thanks for adding the lock and unlock on the record in the pseudo-code too, it's an important thing to understand.
I don't mean I want to work on it because I don't have a need for sound. I was reacting to your laments in the README.md that you need a C dep in Linux, and since you mentioned writing your own, I figured I'd point out a project that might be starting what you need. Since I don't work with that sort of thing, I don't know if it is an ALSA driver, but faiface commented in an issue on go-audio that, "...we switched to ALSA backend for Linux and that enabled us to have millisecond(-ish) latency. Data is only copied to temporary on-stack buffers when we need to do mixing, other than that, data is copied directly to the lowest-level."
write carefully, and see if it is correct
I had my own frustrations early on, but I kept an open mind like you are doing here and ultimately it earned its place as my favorite language. So unused variables / imports is the FIRST thing that annoys everyone .. but I actually understood it immediately. The biggest thing to remember is that Go was designed to be as minimal as possible to give engineers at the beginning of their careers the best opportunity to produce maintainable production quality code. We have already been shown that using compilers warnings for discouraging practices ends up.. in a bombardment of dozens of warnings of various severity but all classified the same over the years. Experience tends to lead you to compiling with Werror in something like c, but isn't it annoying when working on a code base that doesn't follow the same conventions? I've ran into this with so many Gnome and desktop gtk apps I've fixed bugs for over the years. I end up having to sift through piles of warning for meaningful issues with my changes. Really I don't need to sell why unused variables are bad, you already know, pointless cognitive load while reading code can tldr that. The real point I'm trying to make really applies to most of your complaints. Warnings will be ignored by many people. Try to remember not everyone is "you", language designers must also design code for "them" .. who will not always do the best thing. Go gives them no choice which is great when they didn't know better to begin with, like me 15 years ago.. I know I have makefiles from my oldest C code that hides all warnings. In my mind it was simple.. I was struggling to get the thing to run, anything that didn't prevent it from running was not important. I never ever cared about having to come back to it later, I was overwhelmed solving all these brand new problems just to make it run in that moment. When I remember this the mild annoyance turns into satisfaction. I NEVER read Go code with the annoying feeling like I'm navigating some guys discovery of a new language feature implemented in the worst, most unintuitive way. I never have to grep for globalMutex to just find its unused. Reading Go code never sucks, stuff is always intuitive, even visibility is immediately apparent by the first letter. Brilliant really. A language designed to keep people from writing shitty code, a price people who were going to write good code anyways have to pay. Big ROI if you ask me. Btw Crypto pkgs contains all low level primitives. Just write a struct or function to reduce he boilerplate for your use case like any other language. The bottom line is that the block interface function does not return an error, it has very few failure paths and would be pointless IF it forced error checking for a single case when buf was not a multiple of block size. In most code bases this will be covered by other invariants leading to the crypto call. Really you should be very careful around your crypto buffers, know exactly the size of bud you read into and pass to the block cipher. Again if it bothers you make a simple struct helper type myblock struct { cipher.Block } func (myblock) Encrypt(dst, src []byte) { if m.BlockSize() % len(src) != 0 { whatever ... } return m.Encrypt(...) Now you satisfy a block cipher still with the same interface and can use it for any block cipher you would like. While not muddying up ththe API for every user who doesn't need it. Edit: I take back the open mind part after reading your responses here. People are explaining the design decisions behind things but your choosing not to accept those decisions. Do you really think that at this point in your career you are seeing something that was overlooked by the collective experience that led to Go's design? Ken Thompson was involved in this languages design, do you think you have some experience about CSP paradigms that him and the other designers didn't consider? Come on man, get real here. **Don't post here pretending you want to understand the damn language designers reasoning, when your actually here to ignore every reason while defending your narrow experience with the language. It's a waste of everyone's time. Give it five minutes, man.**
I don't think in the intended use case you would be providing a value per se, but rather a function or a constructor. So if there's already a value stored for this key, return that value, otherwise construct a new value or obtain a new value by executing a function and store it. It's a convenience, and I suppose it may have some performance benefits if the constructor/function is expensive.
what do you think about https://play.golang.org/p/dUWPJG23bC ? Is this too hacky? I can imagine that you could solve that way more elegant regarding the channel management but you get the point right?
in the real world, you will not find a regexp engine (fully funtional) more simple to understand and modify that this
It's not really a convenience, it's a necessity. Try implementing `LoadOrStore()` yourself and you'll see.
If you don't enforce rules no one follow them. I better have errors while compiling rather than having to use a flag that pretty much no one will use. As for the std lib it's pretty clean overall, have you compare to other std lib ...
*Somebody* implemented LoadOrStore, so *anybody* could implement LoadOrStore. It's *convenient* to have it in the standard lib, implemented well, rather than making everybody who wants that functionality have to implement it themselves, in a probably worse manner, or implement more cumbersome workarounds. Convenience is pretty much the definition of 80% or more of the things found in any standard lib.
You can only implement `LoadOrStore` using functionality not present in the interface (i.e. using details of the implementation). It's not possible to get the same effect as `LoadOrStore` using any of the other functions in the `Map` interface. That's what I am trying to say and that's why `LoadOrStore` is a necessity.
a required git hook can in fact enforce a successful compile with the flag and refuses the commit otherwise.
Have you seen the entry level for Google dev? It's not your average programmer, they're pretty good with not that much experience.
&gt;It should be the job of the repository maintainer(s) to enforce standards and not the language and there are fully automated ways of doing that. And yet among all the languages I've used, Go seems to be the only one where these things are consistently applied across an entire community. The "opinionatedness" can be frustrating, understandably, but there are upsides to it too.
You don't design a language based on the version control you might use.
I guess. You *can* achieve the same outcome, you just have to use a lock and some tests and if-then clauses. The way it's always been done before sync.map and LoadOrStore. I guess you could say LoadOrStore is a necessity if you want to do it as a one-liner in a safe manner—which, again, is the *definition* of a *convenience* function.
Thank you for the info
But that's the point, it's hard to write complex regular expressions correctly. I guess we aren't all as gifted as you are... 
Go ensures that you will never see unused imports or variables in working code, great. First you introduced a new (admittedly very stupid) error source that looks like that https://stackoverflow.com/questions/21743841/how-to-avoid-annoying-error-declared-and-not-used-from-golang and second you really annoyed me and I am obviously the most important programmer on the planet Kappa. I still firmly believe that at least a flag that disables the behaviour and enforcing mechanisms (e.g. git hooks) for well maintained repositories would've been enough. I just don't think that people who are intentionally damaging themselves by doing everything they can to avoid clarity can produce valuable code in the first place even with these really aggressive enforcements. Regarding the crypt lib there are in fact 2 different panics and a silent "error" on top func (x *cbcDecrypter) CryptBlocks(dst, src []byte) { if len(src)%x.blockSize != 0 { panic("crypto/cipher: input not full blocks") } if len(dst) &lt; len(src) { panic("crypto/cipher: output smaller than input") } if len(src) == 0 { return } A single modulo operation isn't particularly expensive especially because you can crypt multiple blocks at once but still; the library forces me to do a calculation and calculates it itself again anyway. Wrapping it is possible and no big deal. Even the 3 lines of boilerplate won't kill a seal pup but its just unnecessary. The gzip example is way more stupid but its kinda hard to explain without going through the whole thing and I am too lazy and no one would read it anyway. Edit: that sounds kinda hostile tbh, I really didn't intend to just piss people off but instead of just writing hostile blog-posts about how much I hate go like a lot of way smarter people with a lot more experience than me did, I tried to ask for reasons but instead got a whole lot of the stuff I already argued against in the initial post. I tried to frame my arguments in a more explicit way and to challenge weak arguments until I got responses that actually answered my questions. ChristophBerger for example helped me a lot to understand. I don't intend of quitting since I am kinda forced to work with go anyway and do so since before 1.0 but because of the project size and scope I rarely got exposed to the discussed problems until a few weeks ago.
also this engine has a porticular syntax.. but no, I also have to write calefully and check that it is correct [**edit**] when you know the scope and limitations of your creature, it is not so complex
I guess that's true but I'm sure every decent VC has something similar so I think its fair to consider this universal. Correct me if I'm wrong.
Yes—you'd have to use a lock over the whole map (or some other kind of external synchronization), defeating the entire purpose of `sync.Map`, namely, allowing *concurrent access* to the same map. That's why `LoadOrStore` is necessary. You can't do the same thing without this function.
The last thing I remember reading on the beep issue on pixel was that they were looking at using [oto](https://github.com/hajimehoshi/oto), which does use some ALSA C libraries. I'll look into this a little more. The library we're using was actually made because oto didn't have dependency-less windows audio, but as soon as I finished implementing that, oto also had it, so who knows.
I guess you are right. Still doesn't protect from bad apis even in the std tho. To be fair its kinda hard to get these kind of things right in go.
&gt; Because Oak wants to have as few dependencies as possible, Oak does not use OpenGL or GLFW. We're open to adding support for these in the future for performance gains, but we always want an alternative that requires zero or near-zero dependencies. (We are very sad about the linux audio dependency and are considering writing an audio driver just to get rid of it.) This is exactly the attitude the community needs for developing high quality Go libraries! Congratulations. I really wish I could upvote this more. May this library be a great inspiration for the other gophers.
This is not how it works in real life, whether you accept it or not.
Any reason you have rejected the standard library multiplexer?
Just the feeling of needing convinient URL-Parameters.
for me it works, the code is there, it is free software and you can learn from it, critize my decisions or whatever the only thing that does not do (do not have to) is meet your expectations
Perhaps, but then we get to questions of personal preference and I'd have to say that's not a great argument for generics. One of the strengths of Go, I feel, is that there is only one way of doing (most) thinks and doing things that way is very much encouraged (go fmt etc). Introducing generics just because of personal preference would break that philosophy, I think.
[Here](https://github.com/golang/go/blob/f3e6216450866f761cc22c042798c88062319867/src/fmt/print.go#L946) and [here](https://github.com/golang/go/blob/f3e6216450866f761cc22c042798c88062319867/src/fmt/print.go#L604) is where the magic happens.
Why not https://go-macaron.com actually has really nice json control and uses others middleware. It's more of a framework then a package. I also like the multiple method routes.
My point was your tone in ALL of your responses isn't someone trying to understand a languages design, because that isn't your motive. You wanted to vent about things new and annoying to you, you already decided they annoyed you and are defending your already chosen position rather than looking to educate yourself properly before you choose a position to begin with. I'm sure your a sharp guy, which is why I know your defending a position and not pursuing one. **You already answered your own question about your biggest gripe**. &gt; Sometimes it takes a lot of changes to implement a core logic change that actually compiles and runs. I spent half an hour tracking down all the variables and imports that are not used anymore but there were some frustration xkcd visits here and there. You spent a half hour checking for unused variables and imports and you wrote the damn code!!!! What on earth makes you think I want to in two years after you leave my company? Side note: the fact it took you 30 minutes to do this hints your workflow is completely botched. I rarely type imports, only for internal packages on occasion which is usually a yy p of the line above with a small edit at end of repo path. You should trigger goimports on each save as well as go build for compiler errors. The panguag builds so fast.. don't let all the unused vars accumulate over hours .. yes it would take hours of not compiling to accumulate 30 minutes of unused vars or your being dramatic, that stubborn justification of a position. Soldiers and scouts, man :-)
Well, it's a tradeoff. There are two ways to have generics for this specific example: Either you use something like a type switch (which is verbose and Go-like), or you let it be the runtime's problem (which is what Java does). I think either option is better than not having generics at all.
So if you were to simply `Store` a value there's a chance another goroutine may have beaten you to it during the `Store` operation, causing a data race. `LoadOrStore` would return that value (which, say, beat your `Store` by 1us) ensuring the value you want to increment is in fact the one that 'got there first'. Is that correct? 
add `-v` to `go get` and `go build` to get verbose output - it might offer some clue. 
That's what I have done now. Though it works, the code is incomprehensible to the point of being faulty.
Haha. Don't see how writing a rules engine can be easy. Maybe for trivial use cases.
Thanks! True, math/big even does loop unrolling. OTOH, it uses fairly simple algorithms for multiplication, GCD, ... so for larger inputs a more complicated implementation might catch up. You could also try to without bound checking "-b" as documented here: https://dave.cheney.net/2012/10/07/notes-on-exploring-the-compiler-flags-in-the-go-compiler-suite
Kinda. However, the only case where you actually want to `Store` in the example I gave is when this is the first item of its kind. So without `LoadOrStore`, the code would look something like this: 1. check if `item` is already present 2. if it is, load the entry for `item` 3. if it is not, store an empty record for `item` 4. increment value for `item` This doesn't work, just think what happens when two threads want to register the first item of a kind at the same time. One update would be lost.
&gt; Processors are simple. Says a guy who has last seen a CPU up close around year 1980. You really haven't learned anything from the last flamewar have you? Processors are **not** simple. Their implementations are extremely complex. Their interfaces to the programmer (ISAs) are very complex as well. Their memory architecture is typically complex (unless you're dealing with bare-bones embedded stuff, but there are other complexities to that). There is no aspect of modern CPUs that is simple. Savvy? &gt; I don't want to have to think "what if this channel is closed?" each time I use one. Yeah, except in a situation where using a closed channel causes a panic, you have to think about it even more... 
&gt;You spent a half hour checking for unused variables and imports and you wrote the damn code!!!! What on earth makes you think I want to in two years after you leave my company? I would be quiet unreasonable of me to accuse you of not reading but you quoted a reply just one line away seemingly intentional out of this context: &gt;*Firstly its not only my code* and second there are indeed some medium level spaghetti functions involved (for which I am only a small part responsible for) which I would've despagettified in the process of the rework. In fact the attempt to force better code by go caused worse code and more time necessary to work it out in the end. &gt;don't let all the unused vars accumulate over hours .. The work that goes into cleaning unused variables stays the same regardless of when you do it if you have a half-decent IDE anyway. Why are you reading meaning into things that I didn't write and let it look like its just my stubbornness? I don't see how this is not intentional shittalk. To clear things up: * I didn't write most of the code that was initially partly spaghetti. * I reworked core logic to get rid of the spaghetti because I had a seemingly smart idea. * While reworking core logic you are typically not able to compile until you are done. * In the process a lot of old code got redundant but still cluttered my experimental code * For a quick test of my idea it would've been enough to let the clutter be clutter and just compile and run it and do the cleanup after I am sure it worked out as planned * In go I had to cleanup everything before even being able to run the first test run * after I was done I encountered an edge case that I was previously not able to see because of all the bad code (excuses) * I had no good way of solving the problem and now wasted all the time to cleanup the code that is now completely useless I could've been smarter and recognized the edge case from the beginning but the time wasted is almost 1/4 more now because I needed to cleanup my experiment fist. I asked for the reason I had to go through this suffering and wanted to know if it was worth it. I initially was convinced that there was no way and was convinced that this was just objectively stupid design but now I am at a point where I can recognize that It is way more opinion based than I initially though. I don't need to like this design decision to acknowledge the benefit. (see [here](https://www.reddit.com/r/golang/comments/6nyo5i/can_you_explain_all_the_annoying_stuff_in_go_to_me/dkdlef3/) ) 
I get now! Thanks a lot FUZxxl.
Nice write-up :)
What do you mean by "local"? Console, authenticating against `/etc/passwd`?
It's my pleasure!
Given [how cheap](http://herman.asia/efficient-string-concatenation-in-go) appending one byte to a [Buffer](https://golang.org/pkg/bytes/#Buffer) is, I'm very skeptical that you'll get any speedup by having pre-build 2, 3, 4 and 5 byte sequences. In fact, given modern CPU architectures, I suspect that appending one byte to a buffer 5 times is going to be faster than going out to main memory to fetch a sequence of 5 bytes you created at compile time.
How would you go about writing libraries like that in pure go?
&gt; Why is it a panic to communicate production stop through the production channel itself? It isn't, you just have to do it via some method other than closing the channel. Like, for example, including an EOF boolean flag in the objects you send down the channel. The point is, the channel shouldn't be _closed_ until you're actually _finished with it_. And if you're writing data to it, you're clearly not finished with it.
The cache is not optimal as a array since the code will have to look up the pointer to the value every time. I don't think you are earning any performance with all these lookups. The cache should be a constant (if used at all). Try using string.Repeat() with a single space instead of a for-loop and use a slice to get the length you want. Should be cleaner and safer code. 
Email, Password authentication
I can't speak for steam, but I have looked into controller support. It wouldn't be a very easy job; controller support more or less amounts to usb drivers (after that, parsing signals for specific controllers isn't difficult) and libusb is the standard here. There are several Go wrappers for libusb but I'm not aware of an attempt to rewrite it in Go, and it would be difficult to keep the input delay down in such a rewrite.
I can't imagine why you'd expect to be able to write data to a closed channel, any more than I can imagine why you'd expect to be able to write data to a closed file.
&gt; The key point here is our programmers are Googlers, they’re not researchers. They’re typically, fairly young, fresh out of school, probably learned Java, maybe learned C or C++, probably learned Python. They’re not capable of understanding a brilliant language but we want to use them to build good software. So, the language that we give them has to be easy for them to understand and easy to adopt. – Rob Pike : http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/From-Parallel-to-Concurrent &gt; It must be familiar, roughly C-like. Programmers working at Google are early in their careers and are most familiar with procedural languages, particularly from the C family. The need to get programmers productive quickly in a new language means that the language cannot be too radical. – Rob Pike : http://talks.golang.org/2012/splash.article
That's why C and C++ projects never produce compiler warnings when you build them, right? Because nobody would ever release something without going through the quality checks...
So, SMTP or IMAP authentication, checked against /etc/passwd? There are some [passwd packages](https://golanglibs.com/top?q=passwd), but I don't know how good they are. You might need to implement it yourself using [wrappers](https://github.com/incredlabs/goGetent) to the underlying C routines, `getent`/`getpwnam`. (You could read the files directly, but that's not a good idea because systems could be using LDAP or some other name service for system authentication.) Or do you mean the credentials are going to be e-mail and password? That wasn't what I was asking about, I was asking about the protocol you're trying to add authentication to, and where the master credentials are going to be stored.
I wasn't trying to take anything out of context.. I thought emphasizing the time you spent cleaning them would give you insight to the value of the restriction. At the end of the day my point stands, you seem to have already formed an opinion on it and your posts are defending that position. I truly think that is ignorant, sorry. You modify one piece of spaghetti code someone else wrote and are frustrated, so you come here and start a hissy fit about the design "seemingly stupid and enrages you". Guess what, you aren't experienced enough with the language to debate them strongly. I wasn't ether for the first N months, no one is.. for any language. You have to have a holistic view of the entire design and real experience in all portions of the sdlc to see where it shines and falters. It's natural to have a disposition but you should be using that to help curate a meaningful opinion. One formed from first hand experience over a large enough sampling. You should argue against your opinion constantly to ensure it still holds up. Without this process you're robbing yourself of a fantastic experience you only get to have one time.
Are you getting down voted, because you mentioned Rust or what?
GENERICS!!!
If the consumer decides he is finished with a channel and closes it and the producer detects that when writing to it why is it not enough to just get an error state returned and be able to react to the fact that the consumer decided that this channel will no longer be read? It is just something someone somewhere decided and everyone is repeating this dogma like it is the only truth. If neither a write to a closed channel nor closing a closed channel again would cause a panic it would be possible to write a arbitrarily sized multi-producer multi-consumer structure with early exit on either end with just a single channel for data and synchronization. No special channel sends or tricks required. Why is everyone so intent on keeping this genius synchronization tool crippled like that?
How can I write a reusable algorithm library? ...oh that's right, I can't.
&gt; In the other languages, I say "That's going to take way too long to debug and get the compilers to be happy with a neat way to do this" and put it off. Those who call pattern matching and similars "complexity" are mostly the ones who are pretty much newbies in compsci and will spend the rest of their lives making repetitive websites and reimplement toy libraries. Such people don't know that different problems require different tools and that using the same fucking hammer for everything will leave behind nothing but destruction. &gt; but I've produced 10 to 100 times the useful productive code in Go Nonsense, you could have written the *same* code in those languages. You're talking about *usefulness* and not *quality* or *efficiency* which kinda makes your argument pointless. If a language is turing-complete then you can write *useful* code in it - but just because someone has written something useful in language X it doesn't justify the creation of X. &gt; In the other languages, I say "That's going to take way too long to debug and get the compilers to be happy with a neat way to do this" and put it off. In go you don't even have stack traces, let alone a decent type system to track down errors early. You're just lost in the endless garbage code and commits which may look good for the clueless management. golang is for those who stuck with C and fizzbuzz level coding and never have experienced the issues of maintaining large amounts of C code - or anything. &gt; Error handling in particular is very explicit in Go, but is not explicit in either of those languages which you would probably call 'better'. "Error handling" is retarded in golang - because it doesn't exist. Of course it's appealing for beginners who don't have any experience and just want their fizzbuzz to work... &gt; but is not explicit in either of those languages which you would probably call 'better'. You don't know what's explicit error management, do you? In haskell you *need* to manage errors explicitly - work with the errors as values or prevent them and use data structures which can encode erroneous state - except that hs and similars provide *comfortable* and *efficient* tools to manage the errors. Explicit error management has its place, but in production you need implicit too otherwise your productivity will die - handling every error and not having stack straces is a terrible way to code. Of course, if you're ok with copy-pasting or generating code instead of using generics and macros it's already pointless to talk about productivity...
When was it proven ?
It was my mistake, in node.js they call it local authetication meaning email/password credentials. Just looking for something similar to PassportJS..
Beep uses Oto as its interface to audio hardware and I implemented the ALSA backend for Oto. Now we're working on going low-level on all platforms in Oto to get the same latency (which is, from my experience, unmatchable from OpenAL). Beep is pure Go with a 'speaker extension package' (which, due to Oto uses CGO on most platforms) which allows to play audio through the actual speakers.
are you aware that /u/Yojihito already [posted both quotes](https://www.reddit.com/r/golang/comments/6nyo5i/can_you_explain_all_the_annoying_stuff_in_go_to_me/dkde2h2/) 8 hours ago? I will just refer to my answer there.
I've been using Chocolately to make Docker containers that can built windows images FROM microsoft/windowsservercore RUN powershell iex ((New-Object System.Net.WebClient).DownloadString('https://chocolatey.org/install.ps1')) RUN choco install git -y RUN choco install golang -y
Btw, regarding graphics and audio, there are two options: 1. Use CGO, which allows for static linking of non-preinstalled libraries. 2. Use syscalls to call functions from DLLs on the system, which are C libraries. This prevents static linking, but if you only call standard pre-installed libraries, it's fine. I believe Shiny uses the second option.
Well no, Pattern matching isn't particulary complex, but it and every other functional programming tool that these languages add create more overhead to think about the code. I made a pull request for the project in the second language and was told that I should avoid foldr and make sure to use zipWith and flatMap, and the fact that I couldn't even find any of those functions in the documentation for either language despite looking exactly for those functions is a big problem. And no, almost everything I've done in Go recently would have been a nightmare to put together in SML. A low level audio library? A graphical window? Pure languages hate these things because they have side effects, and you can accidentally ruin your performance by using the language utilities in a way that looks just like a more performant way but for some reason isn't. Also yes go has stack traces.
I can't deny that but a direct comparison to c++ kinda unfair. If you look at the evolution of the c++ standard its only natural that there is a huge community which works on vastly different standards triggering all kinds of warnings along the way that didn't even exist at the time the coder coded the stuff or learned the code patterns he is still using. legacy code is just hard to deal with regardless of the compiler or the language as /u/itsmoppy already pointed out [here](https://www.reddit.com/r/golang/comments/6nyo5i/can_you_explain_all_the_annoying_stuff_in_go_to_me/dkdiy1f/). Most of these legacy code-bases would never have been written that way with today's standards even in c++. And on top of that I expect that it probably is almost impossible to reliably detect unused imports or variables in c++. So a fair comparison isn't even possible because the necessary analytic tools can't be made. In comparison to python for example where you can do almost every bs that you can even imagine it is already quiet common to see type annotations in modern python3.6 projects without anyone enforcing anything and despite them hardly having any use at runtime (except for cython maybe). If coders without enforced guidelines would be even a fraction as messy as their degree of freedom in the corresponding programming language allows them to be, then python should be a unsalvageable hell of doom in terms of code tidiness. But that's not the case. For some reason the typical c++ codebase is way worse even tho the risks of bad code are typically way more serious there too.
&gt; You really haven't learned anything from the last flamewar have you? I've learned not be concerned with your response to my point. 👍🏻
Yes, and it looks like that `cached` is faster With "Cache": BenchmarkPad-8 300000 3673 ns/op Without: BenchmarkPad-8 300000 4579 ns/op You can find my benchmark test here: https://github.com/Rhymond/gopad/blob/master/gopad_test.go
I though the same before, but I made benchmarks: With "Cache": BenchmarkPad-8 300000 3673 ns/op Without: BenchmarkPad-8 300000 4579 ns/op You can find my benchmark test here: https://github.com/Rhymond/gopad/blob/master/gopad_test.go
&gt;You should argue against your opinion constantly to ensure it still holds up. Without this process you're robbing yourself of a fantastic experience you only get to have one time. And at the same time you label exactly that as ignorant. Well played. I get the feeling I'm not the ignorant one here.
There is duplicated logic for printing out the Todo structs. I suggest adding something like: func (t Todo) String() string { if t.Done { return "[X] " + t.Description } return "[ ] " + t.Description } and then you can just pass a Todo to fmt.Println() and it will print correctly, allowing you to clean up https://github.com/FChris/godo/blob/master/cmd/godo.go#L121-L125 and https://github.com/FChris/godo/blob/master/cmd/godo.go#L266-L271 Also spend some time on error handling, looks like you have a couple of // FIXME, but I think that funcs that can have an error should return it back, or at least print it nicer and then exit vs calling panic, which isn't a great user experience. Cheers!
No, because I mentioned Java. Rust is fine, Java is evil :))
&gt; Well no, Pattern matching isn't particulary complex, but it and every other functional programming tool that these languages add create more overhead to think about the code. Excuse me, I'm not really into hs or the pure-fp crap but reading such code is definitely not complex. Operators are just like functions and most language features can be explained in 1-2 sentences while they can spare *days* of work each. If you want to see complex code then go and read some bash or APL. &gt; I made a pull request for the project in the second language... If you don't know the language then why send PRs? &gt; ...and was told that I should avoid foldr and make sure to use zipWith and flatMap, foldr = fold from the right - yes, you *should* avoid it, it's pretty logical to not start processing linked lists *from the end*... &gt; and the fact that I couldn't even find any of those functions in the documentation for either language despite looking exactly for those functions is a big problem. LoL no [google haskell List](http://lmgtfy.com/?q=haskell+List) or use [hoogle](https://www.haskell.org/hoogle/?hoogle=foldr)? Also, flatMap is not a haskell thing. &gt; And no, almost everything I've done in Go recently would have been a nightmare to put together in SML. What are you working on? &gt; A low level audio library? 1. You can do [such things in hs](https://wiki.haskell.org/Applications_and_libraries/Music_and_sound) 2. you definitely shouldn't code such things in either golang or haskell: for low level programming use something like C/C++ or Rust. &gt; A graphical window? [Here.](https://wiki.haskell.org/Applications_and_libraries/GUI_libraries). &gt; Pure languages hate these things because they have side effects, False, pure languages handle side effects *explicitly* - which gives you more safety, that's their point. &gt; and you can accidentally ruin your performance by using the language utilities in a way that looks just like a more performant way but for some reason isn't. How are they "look like" more performant ways? Until you have benchmarks it's pointless to assume. &gt; Also yes go has stack traces. Where? If your app runs into an error can you print the full stack trace into the logs and see where did the error came from? Is this the official way to handle errors?
Yeah. But, as the post explains, if you're on AMD64, we now have constant-time assembly implementations, so, provided you configure the server correctly, Go is fast enough to serve itself now.
What I don't get is how you would write the low level drivers in Go without embedding C or something
I came across this in the [bridge forum](https://forum.golangbridge.org/t/we-have-just-released-pargo-a-library-for-parallel-programming-in-go/5981). The API seems to support easy parallelization of tasks (although this would not exactly match my definition of "parallel", but let's not be overly picky here) and comes with parallel sort and map functionality included. Guess I'll give it a try when time permits... *(Edit: link, typo)*
Since you mentioned me to /u/metamatic: Just to be clear: I fully support declared but unused variables being an error in almost any programming language. The only time I'd be happy with it, is in some of kind DSL made for non-programmers to do some simple job related task. Like for the golf club to make Excel spreadsheet macros to track their player scores.
Valid point, but I do find some use in features already implemented in nginx :) not saying any server in go needs to have parity, just saying it's comfortable to have a battle tested caching reverse proxy with many useful features in front of it. Early adoption is fine, if you can afford it.
&gt; Excuse me, I'm not really into hs or the pure-fp crap but reading such code is definitely not complex. Operators are just like functions and most language features can be explained in 1-2 sentences while they can spare days of work each. If you want to see complex code then go and read some bash or APL. Wait, you think .sh files are complex? &gt; &gt; If you don't know the language then why send PRs? &gt; I am one of the only two-dozen ish people who know this language. It is not Haskell, it is an offshoot of Haskell. &gt; foldr = fold from the right - yes, you should avoid it, it's pretty logical to not start processing linked lists from the end... &gt; Why? Because it's less performant? How do I know that? If it is obvious and should never be used, why is the tool provided? &gt; LoL no google haskell List or use hoogle? Also, flatMap is not a haskell thing. &gt; It's a good thing I'm not using Haskell then &gt; You can do such things in hs 2. you definitely shouldn't code such things in either golang or haskell: for low level programming use something like C/C++ or Rust. Here.. That doesn't look like SML to me. And too bad, I did do those things and they are performant in Go. &gt; False, pure languages handle side effects explicitly - which gives you more safety, that's their point. &gt; No, pure languages disallow side effects, that's the whole point of them being pure, that's what pure means, there are no side effects. &gt; How are they "look like" more performant ways? Until you have benchmarks it's pointless to assume. &gt; They're both one-liners that do the same thing, and their implementations are both one-liners that look the same. It's easy to evaluate the complexity of an operation in imperative languages because you see every instruction and every loop. It is not easy to do the same in functional languages, and is even harder in lazy languages because you don't even know if certain fields will need to be evaluated so you don't know if that code will ever run. It isn't worse, it just takes more cognitive effort to evaluate. It takes longer to code because it takes longer to reason about. That's all I'm really trying to say here. &gt; Where? If your app runs into an error can you print the full stack trace into the logs and see where did the error came from? Is this the official way to handle errors? Yeah, this happens automatically if A) something crashes or B) if you use the `pkg/errors` package for cascading errors.
Maybe you can't, I didn't really try to look deeper into the usb driver thing since sometime last year.
I think it depends strongly on what general environment you work in. The best situation you can put yourself in is not to have maintain lots of auth against lots of machines, and not to have to pass passwords in the clear to any server across http (or https). So, based on that, I would suggest considering Kerberos (https://github.com/jcmturner/gokrb5), ADFS or some other third party SSO like Okta, Google auth, Facebook etc. HTTPS would make things easier, since you can use something simple like JWT if you wanted to.
The point being? Seems to me like there's none, you're just attempting to justify spreading the "simplicity" meme with processors... 
Rayon has local queues too. I don't think an implementation of "work stealing" that only has a global work queue would count as work *stealing*, since no one thread owns any particular jobs, they're all just pulling them off the front of the global queue on demand. In any case, having per-thread queues is the key pieces of mechanical sympathy that makes work stealing efficient, as it minimises contention.
Check out https://github.com/Knetic/govaluate
I didn't call you ignorant, I specifically referred to the act of forming strong opinions (technical positions) without being properly curated (internal debate against past experiences as you integrate with new ones). I didn't use as explicit verbiage as I did in prior posts.. but you use that as an opportunity for pedantry and see an opening to actually call me ignorant instead of digest the general takeaway. But sure, the person who spent months slowly forming a strong opinion about Go and over four years curating that opinion and tried to advocate the same is ignorant. The one who spends a sessions in some sphagetti code and starts ranting about the first things they noticed being stupid and enraging them is certainly not just another developer young in his career soldier stancing every single topic and viewpoint because they lack the experience to understand how much they don't yet have. Nope. Not you, your special. If only you were there to guide the former inventors of utf8 as they designed Go under a strict and structured consensus with very specific design objectives amongst their century or more of computer science experience. You could have prevented them from failing to quantify the costs of these language design decisions. Clearly they didn't have the experience (hours) thinking about the language like you have. Stupid and enraging.. these mistakes!! Rarrrr! They each had been software engineers longer than you have been alive, some doubly or nearly triply so... but they had not yet learned to give things five minutes and think carefully about the overall design of an undertaking as large as a programming language. Nope! They jumped right in and now we have this mess where you can't ignore unused variables in sphagetti code and it makes us all so angry. I wanna do what I want to. Wahhhhh. Everyone is being big old stupid heads. I'm the best. **Hodor. Hodor. Hodor. Hol da or. hol da ror. Hold da ror. Hold da error. HOLD DA ERRROR. ME FIX LATER.**
I've removed two posts from this thread already. The "get out of here" post ... *maybe* should have been removed as well. That's not the way our community should act, and those without backstory on the situation might misunderstand what's going on. However, I also understand that a lot of people are fed up with the Iris maintainer (the upvotes on that comment prove it). 
I'm working on the OSX implementation for Oto using AudioHAL, which is compatible with any Mac with OSX ~10.5 or higher and could be made to use deprecated calls for OS's pre 10.5 - it is a dependency but it exists on modern systems implicitly, so compilation on a Mac/using go get does not require any additional steps. If you're looking to implement Audio playback on a Mac without binding to C, you're going to have a very bad time. Similarly, with windows, you absolutely are calling C code using the lazy DLL method, you just don't have to interact with it using CGO headers directly. I'm completely in support of going all the way to the metal directly, but that's going to require hardware specific implementations that will be very difficult, and I'm not sure you can get the information you need from the kernel without a few opaque calls to C. You can also try to use syscalls, but those are mostly opaque as well, and porting them over to Go structures and reading them in with the binary reader will require a _LOT_ of header diving into all three platforms. The three of us that are working on oto are also involved in pixel audio (now beep), so the two projects aren't completely separate. Beep is the high level library that's handling decoding, mixing, effects, etc, and oto is the low level library that binds to OS specific libs and writes data to the hardware abstraction layers on each platform to actually play audio out of a device. Feel free to join us on gitter if you have any questions!
&gt; Question: how many years have you been writing code? Don't be a jerk Tom.
This is how I would have done it: https://play.golang.org/p/tUm0lshX6Q Advantages: * No usage of reflect (it's relatively slow) * No possibility of double closing channels (actually no calls to close() at all - the channels will be gc'd) * Uses 2 channels, rather than n+1 * Less code Possible disadvantages: * Making a mistake in this pattern can cause a goroutine leak, but that's something you get used to. * You're forced to use unbuffered channels (at least for the `outChan`) here to ensure the goroutines send all their values before the program exits. Here's another way of doing it which starts to show why go can be awesome for this sort of thing (though it does take more code): https://play.golang.org/p/POgLpOU__X That lets you scale up the number of consumers and producers by just changing a variable, but the code is still relatively simple to follow.
Prolog is a perfect system for this. I have not seen any interface to SWI Prolog for Go, but there is a C api, so it would be possible. There is also golog a prolog interpreter in Go, but I do not think it is ISO yet https://github.com/mndrix/golog 
Interesting. I'm surprised that (a) it's faster and (b) by that much. Would be interesting to look at the generated code, if I knew X86 assembler... I did some more tests, and it's even faster if you just keep the buffer around and reset it, rather than creating a new buffer every time. I'm also inclined to optimize for the common case of only wanting to pad with a single rune; I don't think I've ever wanted to pad with more than one. var buff bytes.Buffer func spad(s string, l int, ch rune, isl bool) string { buff.Reset() sl := utf8.RuneCountInString(s) n := l - sl if n &lt;= 1 || l &lt; 1 { return s } if !isl { buff.WriteString(s) } for ; n &gt; 0; n-- { buff.WriteRune(ch) } if isl { buff.WriteString(s) } return buff.String() } 
&gt; But this seems prone to accidental hanging channels, as you end up with a sort of dependancy graph of channels. One tee could block the other, delaying sending, and worse potentially not close the channel properly. But this is the inevitable consequence of teeing, isn't it?
Seems like I should provide a link to an old project I wrote that is up the same alley: https://github.com/nullstyle/go-codegen edit: I should probably "de-gb" the project to make it easier for others to use.
Thank you for the suggestion. I did not know this works. This is actually great to know as it makes printing any type so much easier. Improving the error handling is the next thing I want to spend time on after setting up the open source documents. Thanks again and all the best :-)
what formats are you looking for?
I never called you ignorant anywhere as far as i can see, you should really give up this bs game here and I can only recommend to you to not pretend to be the experienced, mature and wise guy. you are failing miserably. As I repeatedly mentioned all over the place, I'm working with go since before 1.0 now and then and I did a lot of revisits including a bunch of medium sized projects over time and I am programming for almost 10 years in total now. You really should stop looking down on people like that. You are really going off topic and even wrote a whole section just to insult some inferior programmer who is wrong on the internet in your opinion and you even start blatantly insulting people. Just cut the crap and get back on topic. And refresh your memory [here](https://www.reddit.com/wiki/reddiquette), you are a disgrace.
OK, so auth0, goji/httpauth, [fernet](https://github.com/fernet/fernet-go), many other options. Depends more precisely how you want it implemented and how you want it to behave.
I don't think that the feeling of discomfort is that you're fighting Go, it's that you have to think _very carefully_ about the behaviour that you want / need. I even remember this sort of example being mentioned in something about advanced usage. How much can you buffer before you should block etc?
Read this https://golang.org/pkg/time/#pkg-constants
You aren't listening to what others have been saying. It's a source of bugs, so by disallowing send to closed channel you are preemptively identifying bugs instead of sweeping them under the rug. You aren't going to get a scientific dissertation or formal proof that this is the one true way. Those don't exist to my knowledge. This was a choice made by the Golang devs based on their past experience writing this kind of software. You don't have to like this answer, but it's still the answer. In my anecdotal experience, I believe they made the right choice. Every time I've run into this it's been an indicator that my logic was *wrong* and instead of beating a square peg into a round hole, addressing the underlying structural deficiencies made my code better. 
Can someone explain how this is different from Dropbox? I mean specifically in relation to the talk Rob Pike gave. He said a drawback of Dropbox was that it copied everything everywhere. How does upspin work differently? Files still need to be copied right?! 
&gt; I never called you ignorant anywhere as far as i can see &gt;&gt; I get the feeling I'm not the ignorant one here. I guess it was unreasonable to assume you were referring to me as "one". &gt; As I repeatedly mentioned all over the place, I'm working with go since before 1.0 now and then and I did a lot of revisits including a bunch of medium sized projects over time and I am programming for almost 10 years in total now. Please man, you're not fooling anyone but yourself. Someone writing Go since 1.0 would NOT need the reasoning behind the issues you mentioned explained. WHICH IS WHAT YOU ORIGINALLY ASKED. To explain the reasoning behind design decisions, it's what you continuously asked. But you refused the reasons for the design decisions rather than accept them and understand that you quantify the impact on the language from these decisions differently, meaning the language may not be for you. I find it amusing that you link me to the code of conduct for a reply directly after calling me ignorant ... directly before I tried to take time explaining why there is value in taking time to digest the languages design decisions..... in a thread that had you saying the languages design was stupid and had you enraged in the first sentence. Lol... I'm done here man good luck. 
Absolutely. But I'm just saying that performance concerns are no longer an issue unless you're serving on a weird arch.
&gt; and it's even faster if you just keep the buffer around and reset it But then you're not thread-safe unless you control access to the buffer, which will slow you right back down. Or you can make the caller provide the buffer, but that's an inconvenience and a bit of a leaky abstraction. Tradeoffs.
&gt; Wait, you think .sh files are complex? Have you seen a bash script in production yet? Also, if you think hs and similars are complex then I don't know what to think. &gt; I am one of the only two-dozen ish people who know this language. It is not Haskell, it is an offshoot of Haskell. Well, if you use an inbred language then it's the problem of your company and not the problem of fp languages... &gt; Why? Because it's less performant? How do I know that? If it is obvious and should never be used, why is the tool provided? Do you know what is a linked list? &gt; It's a good thing I'm not using Haskell then Because it has docs and a specific site designed to search for functions? &gt; That doesn't look like SML to me. SML is an academic language. Haskell is an ML language used in production. &gt; And too bad, I did do those things and they are performant in Go. Proof? Btw, who in its right mind would use a garbage collected language for low level stuff? &gt; No, pure languages disallow side effects, Nope. They allow it - you'll get information about them *on the type-level*. &gt; that's the whole point of them being pure, that's what pure means, there are no side effects. Correction: no *hidden* side effects. Also, with pure functions we can emulate state and still get the safety. Purely functional means mostly using pure mathematical functions to code - and such functions are capable of encoding side effects, but in a safe way. &gt; They're both one-liners that do the same thing, and their implementations are both one-liners that look the same. You seem to talk about some specific code here without sharing it... &gt; It's easy to evaluate the complexity of an operation in imperative languages because you see every instruction and every loop. LoL nope! Big O often lies and if you think you can assume the performance just from the "looks" I've bad news for you. Also, if we're here what do you think about iterating linked lists from the end? :D &gt; It is not easy to do the same in functional languages, Quite the opposite - functional languages' performance are almost transparent because they use high-level constructs mostly. But if you look at low level languages you can't guess how each feature has been implemented and what will be its cost. For example, most FP languages are garbage collected with pass-by-reference and they used to implement persistent data structures - you can easily assume how each data structure compare to each other but if you take imperative languages you'll find that the cost of allocation and how the language handles references will matter more than our assumptions by big O. &gt; and is even harder in lazy languages because you don't even know if certain fields will need to be evaluated so you don't know if that code will ever run. That's the point - automatically adding lazyness instead of hard-coding it with `if`s. &gt; It isn't worse, it just takes more cognitive effort to evaluate. It takes longer to code because it takes longer to reason about. That's all I'm really trying to say here. golang is so verbose that most of your code will be 10-20 times more - and that's pretty hard to read or maintain. By not having generics it just increases the complexity of merge requests and commit tracking + adds failure points for bug fixing. If I read from a random repository with fp code in it each source is quite simple and they don't try to tell their entire tales - they've larger vocabularies which means they can communicate more effectively. At work in our project there are modules written in C - and while we do have code reviews I often see that the lack of generics and the presence of code generation and preprocessors make the language much more problematic and the repetitive nature of the code makes it much harder to do a bug fix or refactor. Having an *easy* language has the cost of loosing *simplicity* and that's not good. &gt; Yeah, this happens automatically if A) something crashes or B) if you use the pkg/errors package for cascading errors. So 1) you can't decide what to do with them: handle or fail and 2) it's unofficial.
&gt;Question: how many years have you been writing code? I've been writing C++ for 10 years working on legacy Win32 apps with MFC. What's it to you, bro?
An interesting data point that helps me compare out experiences.
Asking a question isn't being a jerk. If I got the answer and dismissed him as inexperienced, that might qualify as being a jerk.
My point is the same this time as before. I understand your point. I explained that several times previously. You've never once, as far as I can tell, considered the fact that we BOTH could be right, you're 100% adversarial and 0% dialoguing on this issue, so there's no point continuing the discussion with you.
&gt; I really expected to get a good argument that I was just too stupid to figure it out myself. I don't see stupidity, I see lack of empathy for the clear and concise answer given. &gt; I normally expect people around me to have way better reasons for doing things than the It seems to me you dismiss the deeper reasons of the advantages of simplicity, deterministic behavior, and lack of optionality.
Very often it's a mistake to make your API (certainly public, sometimes private) deal in channels directly. Can you model it as io.Readers and Writers instead? If you need to tokenize (i.e. if you need discrete strings), you can use bufio.Scanners on the read side, and write with newlines. Then you can use io.TeeReader or io.MultiWriter directly. But observe that MultiWriter has the same blocking semantics as your channel solution above, and it's harder to do buffering...
so basically everyone who has not the same opinion on a topic than you and your go overlord must be clueless or plain stupid. That an easy world you live in. regarding calling someone ignorant, I just referred to your statement there. &gt; I truly think that is ignorant, sorry. 
IMO, building a generic solution for this is problematic. It would probably be better to tailor the teeing to each use-case. That said: To prevent the first write from blocking the second, you could perform the writes inside their own goroutine. To facilitate buffering, you would probably want another pair of channels (not exposed) that have a large enough buffer to perform the initial write to (and never block), then a separate goroutine for each that reads from the internal channel and writes to the exposed output channel (and blocks as necessary). The output channels should be unbuffered so they can be closed safely. If they are buffered, closing them before the reader is done reading will destroy any values in the channel. Of course, this still leaves several problems such as channels that will never be read from (and so never finish) and duplicating all of the data several times and keeping it in memory in a buffer channel.
So basically the only reason for these poor channels is "Rob said so"? I could've avoided a lot of trouble if someone had told me that earlier. That sounds way rougher than I mean it. If someone just told me from the start that this is just a decision someone else made and they just accepted it. That is completely cool. Why is everybody so roundabout about and defensive about it?
Indeed. And the whole thing's an exercise in premature optimization to start with.
The readconf function is my way of having configuration file. It was a suggestion from one of the guys who answer my OP. Are you suggesting there is a proper way of doing config file than the current way I am doing? if so can you point me to the right direction? I google search a bit before posting. Alternative solution is [this](https://stackoverflow.com/questions/16465705/how-to-handle-configuration-in-go). However, I feel it's a bit overstretch when forcing users to write configuration in json. OR i can simply write a parser but it will be too much work for me. Parsing is one of the more difficult discipline in computer science; it could take ages to include all the edges cases. Another way is to use TOML suggested in the same post. But that will require me to define the struct ahead of time. So adding a new params will require me to edit the struct and the function. There might be some security concern by using getEnv(). Since everything is set as environment variable. There might be some way a hacker be able to echo the environment variables and steal info. 
Well it depends. If this string padding function is going to get called all the time then OP's idea is a good move. If it's just used occasionally and not in a hot path? Who cares.
and how do you deal with early exit after the consumer received the desired data? how do you signal a early exit from a producer to the consumer/other producers in either of them? btw the first causes your main thread to spin doesn't it? You are right, reflections aren't fast and there's no apparent way to recycle either in my example. But it seemed to be the best way of proving my point of unnecessary complexity caused by limited channel functionality to prevent supposedly wrong code somehow. Is my proposal so bad? What about this is wrong? Except that a single channel would start to bottleneck pretty hard on a certain scale because it internally just uses locks after all. btw especially your first example is a really good example of the beauty of go. It seems such a waste tho to just stop there and not go further with this pattern.
I think the slice of channels sounds much simpler than a tree of channels. Here's a couple of actions that illustrate the complexity I'm thinking of: Add Subscriber: TeeTree: you need to find where you want to attach this new channel, as the tree grows there could more and more options for placement. Slice: append a new channel on to the end of the slice Remove Subscriber: TeeTree: you will need to remove the channel and re-wire the parent/children to keep the tree intact. Slice: remove the channel element from the slice 
Not looking for third party like auth0, just wanna do email registration.. 
You could use select to not block when sending to the tee'd channels, although you'll need to figure out what you want the behavior to be. func TeeCh(source chan string) (tee1, tee2 chan string) { tee1 = make(chan string) tee2 = make(chan string) go func() { for s := range source { select { case tee1 &lt;- s: case default: // log.Println("blocked sending to tee1") } select { case tee2 &lt;- s: case default: // log.Println("blocked sending to tee2") } } close(tee1) close(tee2) }() return tee1, tee2 } 
Not sure if I get your point or not, but when I was using gRPC in Golang, I treat the gRPC-generated struct like a "**payload object**" instead of a "**model struct**" (*which means I only use it for transferring the data between client and the server.*). So normally I would make a "convertor function" (like: `toItem(in *pb.Item) out &amp;Item`) for it, when I received the gRPC struct, I convert them into a local struct type. It sounds might be stupid but, hell. You are going to use `Id` instead of `ID` with the gRPC-generated struct in Golang when everything other is named as `ID`. And you can't even add the custom struct tag in `.proto` file (*which is not recommended by the official*), it's a pain for me when there're so many packages that require you to specify the struct tags.
That's exactly what I'm doing at the moment, but because it's a NoSQL database, there's 3 levels of nesting, so I have to write an iterator for each of those maps to convert each entity into the pb format. It just feels totally wrong and like I'm not really getting any benefit of gRPC's performance, if I have to do a bunch of serialisation of my own before it gets serialised into binary! I wish there was a plugin to just include mongodb friendly tags somehow, or some kind of quick serialise method. Ah well, at least it's not just me, I guess! 
I'd like it to format to mm/dd/yyyy automatically from Json and back iso for mgo interface
Well, not auth0 then, but there are [many other examples](https://github.com/avelino/awesome-go#authentication--oauth) of HTTP middleware for authentication.
There are some really good talks which go over this sort of thing. https://blog.golang.org/pipelines https://blog.golang.org/advanced-go-concurrency-patterns Usually, to get clean shutdowns, you have a `closeChan chan struct{}` which isn't used for ever sending data. If you close that channel, everyone who has access to that can see that it's been closed, so you can use that to stop a bunch of workers with something like the following: ``` select { case _, ok := &lt;-closeChan: if !ok { return } default: } ``` If you want to be able to close it from multiple places, you still need to protect it with some other sort of synchronization primitive, but there's really not a great way to get around that. Also, the first example does not cause the main thread to spin. Selecting on channels is fairly efficient and doesn't cause busy waiting. If there was a `default` case it would spin because it would use that if neither channel could be read from. I don't know if your proposal is bad, but there are already design patterns for the things you've described and they work fairly well. And to change how channels work would mess with those already established patterns. A single channel isn't usually a huge bottleneck because (at least with unbuffered channels) each side needs to wait for the other side to be ready. If you need more performance, you can always use buffered channels (which does require tweaking the code), or tweak how many producers and consumers you have.
&gt;That sounds way rougher than I mean it. Honestly, I think that's 98% of the problem right there. From your initial post through many of your replies you come off as rather... aggressive. That's unfortunate because you have unintentionally poisoned the well before ever even taking a sip from it. This doesn't justify the response of some of the others in this thread, but if you wave a big stick around you should not be surprised when somebody else waves a big stick back at you. A better approach would be: &gt; Hey, I'm having trouble dealing with this problem. I have this scenario that makes sense in my head where I need to send to a closed channel but the language prevents me from doing that. Here's some example code. Can somebody help me come up with a more idiomatic approach? That presents the problem in a more constructive fashion thus leading you towards the pit of success instead of the pit of failure where we ended up this time. Everybody can work together to find a solution to the problem that we are all happy with, and you can learn something, and maybe other members in the community can learn something as well. You also need to understand, this community has been kicked by outsiders too many times. They worked hard to build something they are proud of, and random people show up at their door all the time telling them they "suck" or they are "wrong" or they are "idiots". That does not mean you are guilty of doing this, BUT, when it's happened too many times to count human nature kicks in and some people who don't have thick skin will become overly defensive. 
&gt; Processors are simple. The i7 is a simple processor? The Cell is a simple processor?
How about this? func Blocking(dst chan&lt;- string, s string) { dst &lt;- s } func NonBlocking(dst chan&lt;- string, s string) { select { case dst &lt;- s: default: } } func TeeChan(src &lt;-chan string, fn func(chan&lt;- string, string)) func(...chan&lt;- string) { return func(dsts ...chan&lt;- string) { go func() { for s := range src { for _, d := range dsts { fn(d, s) } } for _, d := range dsts { close(d) } }() } } func TeeChan2(src &lt;-chan string, fn func(chan&lt;- string, string)) (&lt;-chan string, &lt;-chan string) { tee1 := make(chan string) tee2 := make(chan string) go func() { for s := range src { fn(tee1, s) fn(tee2, s) } close(tee1) close(tee2) }() return tee1, tee2 } This provides the ability to take a variadic amount of out channels and let's you configure blocking or non-blocking options. edit: TeeChan2 provides maybe a cleaner way to do this?
A little off topic, but did you give a talk at Gophercon about functional programing?
That generally a good advice but no one was willing to answer me anything else but the same circular argument over and over again that you can read in every post/doc/blog about channels ever. I asked a question over and over again and everyone was writing novels but no one seemed to actually want to address my question. With whom am I supposed to work with there? I said that there are things that could've been done and that the result maybe more useful for everyone and everyone immediately just started to tell me that I am writing fundamentally bad and wrong code just because I dared to think about it. How am I supposed to react? Just look at [this](https://www.reddit.com/r/golang/comments/6nyo5i/can_you_explain_all_the_annoying_stuff_in_go_to_me/dke36yu/?context=3) and you understand what I am talking about. Every time the conversation is at the brink of an answer something like this last post happens. I know that he is not doing it on purpose. People are just so caught up in this pattern that they can't stop.
Noted 👌
He sure did! And it was great, I want to write everything in FP now!
I came in with the same acquisition and was astonished how Go and Kubernetes oriented the team is. It's really amazing to be honest.
&gt; You could also try to without bound checking "-b" as documented here: I tried and only then I realized I was mistaken. The translated C code has some bound checks, but very few of them and they're *not* the problem. I think the [README-MINI-GMP](https://github.com/cznic/minigmp/blob/f416c13fb3d7ea758a379356a188562692696c48/README-MINI-GMP) has a better explanation: &gt; The performance target for mini-gmp is to be at most 10 times slower than the real GMP library, for numbers of size up to a few hundred bits. No asymptotically fast algorithms are included in mini-gmp, so it will be many orders of magnitude slower than GMP for very large numbers. So ~~not~~ it's not time for CCGOASM, but for the real GMP library with the better algorithms.
&gt; You've never once, as far as I can tell, considered the fact that we BOTH could be right Well, since your claim is that "Processors are simple" and mine is "That's not true", I don't really see how we could both be right. You enumerated ways in which CPUs are supposedly simple and I explained why that's not the case in each aspect. The ones we discussed are: 1) implementations (we agreed it is complex), 2) interface (I provided evidence of its complexity, not sure what your reaction to that was) 3) CPU complexity vs language complexity, which is hard to argue with (how do you even compare those?), but I tried to provide reasons why I think the complexities match. Seems to me like you keep claiming CPU simplicity without providing any real evidence or reasoning for such a claim. You complain I am avdersial, yet you ask _repeatedly_ other people about how long they have been coding. 
Here are my slides too https://github.com/gophercon/2017-talks/blob/master/KrisNova-OverEngineeringTheCoreOfKubernetesKops/slides.pdf
&gt; And there I was thinking speed-to-ship doesn't matter if the product is shit &gt; being a debugging god "look how fast he presses 'next breakpoint' so much skill!" - srsly, just learn how the language works - especially how it manages memory and you're ok. &gt; or being able to design complex architecture I prefer *simple* architectures, thanks. "There are two ways of constructing a software design. One way is to make it so simple that there are obviously no deficiencies. And the other way is to make it so complicated that there are no obvious deficiencies. The first method is far more difficult. It demands the same skill, devotion, insight, and even inspiration as the discovery of the simple physical laws which underlie the complex phenomena of nature." - C.A.R. Hoare &gt; how we distinguished great engineers from the average. unfortunately, we distinguish them by *raw reputation*. These "great" engineers get famous by creating mediocre websites which get widespread and they bless us with medium spam. Or they were just parts of big projects like 20-30 years ago and now they think about their own thoughts as scientific laws...
&gt; Again I ask: how long have you been a developer? Just to provide some context to this arrogant question, the one who asks this has been coding in: _"BASIC, assembly language (6502 and Z80), C, Postscript, Perl, Ruby, and now Go."_ As far as I could tell, no relevant experience with multi-threaded code outside of Go. 
Videos will be out 2 weeks after then end date of the con.
I do not condone many of the responses in this thread, some people are clearly wrong or ignorant. However, just because they are that way does not relieve you of your part in this. There are plenty of people willing to answer here when things aren't so acidic, but don't expect that we will always have the answer you are looking for (or even an answer)! I almost didn't wade in when I first saw the thread knowing full well how it would turn out, but for whatever reason I chose to anyway. If I saw a thread titled "Help me solve this concurrency issue", I would dive right in. But as soon as I see "all the annoying stuff" I'm checking out because I know it's too late, the thread is already sunk. I suspect many of the people who you would actually want to have a dialog with are like me. Personally, I'd ignore the unhelpful comments instead of going toe-to-toe with them. It's not worth the fight. Let the down-vote system do it's job and if you don't get any traction try again from a different angle or a different venue. 
&gt;If there was a default case it would spin That's what my tired brain wanted to see even tho there really was a case doneChan. &gt;A single channel isn't usually a huge bottleneck because [...] That completely depends on the amount of producers/consumers and the data throughput. As far as I know do channel just simple locking to achieve thread safety and even if the rest is really fast a big number of goroutines blasting data through a mutual exclusive lock will bottleneck considerably. I am not looking for a practical solution to these problems, I know they exist and you get pelted with advanced concurrency guides on every corner. I actually want to know why channels are capped far below their potential like that with seemingly everyone being just fine with it. Is there another good reason besides "important people said so"?
At least with writing to closed channels... I'd assume it's for a simplicity of implementation reason... as well as consistency. If you open a file object and close it, you wouldn't expect to be able to write to it - you'd expect an error. In C this would probably cause a segfault, which is only slightly less recoverable than a panic... so it's about the level of error I'd expect.
Is your team remote friendly? If not globally, at least US or close timezone? Just for clarity:^I ^am ^not ^asking ^this ^because ^I'm ^interested ^in ^the ^job ^just ^curious ^about ^team ^composition.
&gt; Just to provide some context to this arrogant question There are no arrogant questions, but there are arrogant questions. Whatever arrogance you "felt" in that question is your ego in action.
Thanks again for the good advice. At least now I learned that an empty topic with a boring title is way better than a flooded one with rage and anger. I expected a little bit of attention with this rather edgy topic but I certainly didn't expect THAT.
&gt; Again I ask: how long have you been a developer? Over how many machines and cores has software you've written had to run with a minimum of downtime? Perhaps thats a more pertinent question than "how long have your been shitting out code lol?" Since you maintain that processors are simple (pfffff Cell, whats that?) and keep pestering participants for the length of their careers, go on, regale us with your stories of coding over the centuries. How was is in the good old days, when CPUs had 2^4 transistors?
I've made it clear in previous threads that processor implementations are complex, but at the end of the day, what they do is rather simple. The point is that languages have added an ever larger set of abstractions above the processor operations. It's clear that some processors are easier to code for than others, and that modern processors are more complex than older processors. My point is, was, and always will be that **I believe** (i.e. it's just my opinion, man...) that Go is a nice step back toward the fundamental simplicity of the [Von Neuman Architecture](https://en.wikipedia.org/wiki/Von_Neumann_architecture) that defines modern computing.
&gt; Seems to me like you keep claiming CPU simplicity without providing any real evidence or reasoning for such a claim [Please see this response](https://www.reddit.com/r/golang/comments/6nyo5i/can_you_explain_all_the_annoying_stuff_in_go_to_me/dkefhzd/?utm_content=permalink&amp;utm_medium=api&amp;utm_source=reddit&amp;utm_name=frontpage) &gt; You complain I am avdersial You are, because I've repeatedly attempted to find common ground with you, yet you continue to avoid the context I've given. &gt; yet you ask repeatedly other people about how long they have been coding There is nothing adversarial about asking questions.
&gt;The point is that languages have added an ever larger set of abstractions above the processor operations. Go has a fucking garbage collector, don't tell me it's "close to the metal". And its garbage collector isn't even decent for high-throughput workloads. &gt; It's clear that some processors are easier to code for than others, and that modern processors are more complex than older processors. Modern processors are *several orders of magnitude* more complex than their predecessors. They're definitely not "simple" as you keep claiming. &gt; My point is, was, and always will be that I believe (i.e. it's just my opinion, man...) that Go is a nice step back toward the fundamental simplicity of the (Von Neuman Architecture) The Von Neuman architecture is a terrible model for modern computing. The number of hoops a compiler has to jump through just to translate and optimise your shitcode to run on a modern processor makes this argument completely obsolete. 
&gt; Over how many machines low hundreds &gt; and cores high hundreds &gt; has software you've written had to run with a minimum of downtime? I've had systems that ran for over a decade with no bugs reported and no downtime due to software issues. &gt; keep pestering participants for the length of their careers I asked ONE person this question twice (by accident).
&gt; The Von Neuman architecture is a terrible model for modern computing. The number of hoops a compiler has to jump through just to translate and optimise Do tell. Compiler optimizations have zero relevance to whether the processor architecture is Von Neuman, or not. &gt; your shitcode Yeah, we're done here.
&gt; Compiler optimizations have zero relevance to whether the processor architecture is Von Neuman, or not. Run a disassembler on your binaries sometime, and see if it looks like you're programming a machine with a linear memory and a single core. Especially if you use extensions like OpenMP or you're writing code for a heterogeneous environment using OpenCL. Let me know how closely that maps to the original Von Neuman arch. &gt; Yeah, we're done here. We most certainly are.
&gt; An interesting data point that helps me compare out experiences. You're missing the point, which is that length without significant and continuous growth becomes meaningless. Someone who's been coding for 3 years and has an awesome portfolio of varying degrees and challenges is a lot more versatile than the 7 year .NET guy who's experience hasn't amounted to much beyond minimal evolution with C# and various other .NET tech. Or, consider the PHP programmer who's world resides in working with various CMSes and has been that way since 2008. In a nutshell, you can't use years as a valid metric in this context. To be frank, it's actually the weakest form of metric in terms of skill comparison because different kinds of programming require different kinds of skill sets and thought processes, and that's not just in terms of niche. It's also in terms of approach, one's ability to think critically, and one's desire to learn as well as what they desire *to* learn. /rant
When I originally experimented with GO, i was unsure due to its opinionated ways, however, after working with it and writing production code, the opinionated ways in how it works are the best thing that has ever happened to a language. Making a decision on a language feature due to how it behaves when "researching" or "experimenting" is not a reason to make a language feature decision, there are languages for that kind of work, GO has clear goals, and has proven to be the correct way so far for its intended design, hence its uptake and proven ability in such a short time. I would suggest that if you don't like parts about the language and find it annoying, there is plenty of other languages that may suite your needs better, don't try and bend a language to suite your style when its not welcomed by its design. Actually, after reading alot of previous discussions above, the answers have been made, I would say you are also choosing not to listen to so many smart people in the forum that have tried to help you understand. I would suggest you take a step back, re-read all the forum and take on board a lot of very intelligent answers. 
&gt; You're missing the point I don't think I am. I agree with nearly everything you say, certainly that years of development experience is not equivalent to skill. But to suggest it has zero validity is a bit of an overstatement, don't you think? How many times have you learned something new, only to later realize that you hadn't grasped it entirely, or a new use-case put your existing knowledge into a wider context. In addition, surely we can agree that there are a range of answers to my question that would be generally indicative of skill. What if the answer was "1 year?" Can we agree that a person with 1 year of programming experience is incredibly unlikely to be a skilled developer? Of course, skilled or not, the statements they make stand on their own in questions of fact -- there's no denying that -- but this thread is all about opinions. I find it fascinating that several people chose to believe that I was asking that question with an intent to expose the person I asked the question as unskilled or less skilled than I. I've learned a TON from younger developers, and appreciate the new ways they look at things. I asked the question to better understand the vantage point of the person I asked. &gt; It's also in terms of approach, one's ability to think critically, and one's desire to learn as well as what they desire to learn. On that we can absolutely agree. I'm hopeful we can also agree that learning is the first step toward a deeper understanding that often develops as you continue to think about the things you've learned in the past.
if protobuf support field tags, will this pain go away?
I think the way /u/yami_odymel recommends is our best bet. This is also [how the upspin team does it](https://github.com/upspin/upspin/blob/62ed57d0abd779585114757c9ab9b123bd6a34cb/upspin/proto/proto.go#L38). It is very unfortunate that the protobuf team [have decided not to fix](https://github.com/golang/protobuf/issues/156) the non idiomatic field names like Id.
&gt; However, I am running into problems with parsing HTML and input type date's and vice versa. What exactly are you trying to parse? The `time` package is actually very flexible and powerful. It just doesn't parse and format the same way that the other languages do.
Yeah... a little context of what exactly this is would be nice. I hope it's a new book or something along those lines and not just a joke.
The input dumps out mm/dd/yyyy. This far, I've had to modify each back and forth in JavaScript. Just looking to save a step.
In the browser I use Moment, and in go I created a new type based on time.Time as follows (ensuring I use RFC3339) type CustomTime time.Time func (t CustomTime) MarshalJSON() ([]byte, error) { stamp := fmt.Sprintf("\"%s\"", time.Time(t).Format(time.RFC3339)) return []byte(stamp), nil } func (t *CustomTime) UnmarshalJSON(data []byte) error { // for legacy, you could probably ignore this. s := strings.Trim(string(data), "\"") if s == "null" { *t = CustomTime(time.Time{}) return nil } // if we fail to parse the RFC3339, fall back to the Nano version temp, err := time.Parse(time.RFC3339, s) if err != nil { temp, err = time.Parse(time.RFC3339Nano, s) if err != nil { *t = CustomTime(time.Time{}) return nil } } *t = CustomTime(temp) return nil } Not sure if this is the best solution in the world, but works great for me. Cheers 
Thanks. Hate doing repetition unnecessarily. I'll give this a try
You can parse that with `time.Parse("01/02/2006")`. I do not understand why you need a 3rd party package for.
I'm marshalling a struct that contains the time.Time type. I then turn it around after a few checks and update/insert into a mongo database. 
I don't have any security concerns for these values coming from env vars since there isn't anything particularly sensitive at this point. I stand by my previous statement that the readconfig func doesn't have defaults and doesn't give any help to a user what needs to be set if values are missing. It is 16 lines and seems to be overly complex compared to the 3 lines if using the flag library. I'm not clear on what the advantage is with using that func.
Eventually computer science is the C-equivalent of [turtles all the way down](https://en.wikipedia.org/wiki/Turtles_all_the_way_down) till you hit metal. Below you somewhere lies C-code (except where ASM).
&gt; I'm marshalling a struct that contains the time.Time type. I then turn it around after a few checks and update/insert into a mongo database. That does not answer my question of why you need a 3rd party package for that. But in any case from what I understand using a custom type like /u/janderssen suggested fixes your problem. Another solution might be that instead of using `time.Time` in your struct to use `int64` and keep a Unix time. You are probably losing the nanoseconds anyways when you convert to/from JSON.
Looking for third party to avoid reinventing the wheel. But otherwise, yes I would agree with why would I need a third party library.
did reddit just hug Microsoft.com ?
if it's about the struct tags I think gogo/protobuf has an extension for that? https://github.com/gogo/protobuf/
exemple: https://github.com/gogo/protobuf/blob/master/test/tags/tags.proto
I'm really amazed at how complicated stuff can be at this hiring level. Even feedback seems like a burden. Please hire UX for the feedback area.
Look, it's clear you don't know much about pure languages or Go so I'm not sure why you started this fight but I don't appreciate your attitude at all.
Do you guys still do stack ranking performance reviews? 
I've had great luck with https://github.com/araddon/dateparse to try to parse just about any format.
Me too! Here's a little writeup preview of his talk: https://about.sourcegraph.com/go/functional-programming-in-go
If it looks shit, but makes you a ton of money, it's probably not shit. I can only assume you've never seen those hard to fix bugs that take weeks to fix? I also prefer simple architecture. I wrote that post a bit quick, and meant turning complex problem into simple architecture. Why do you distinguish your good programmers by their shitty websites? For me is the ones that work fast and can fix the hard bugs, or they're the tech leads who do the architecture.
This is just a practice for me. My ultimate goal is to be able to write system services in golang, package it and deploy it. I haven't populate what my `dowork` functino yet; one possibility can be accessing a pgsqldb; it may require `user` and `pw` in the config file. Then having it as an environment variable will become a security concern right? Then how can I properly create a configuration file while not compromise security? I edited my [code](https://play.golang.org/p/C_HJvN5I_N) and incorporate the `flag` i'm still keeping the configfile though. This is just a skeleton code of a system service that I wish to write in the future. The user who install my software should be able to access a config file to tune the software like any other system software out there. 
We use go-swagger to generate a rest server from the swagger definition. It's fairly heavy honestly but the validity of the swagger as an API contract is very important to us and so it's worth it for our use case. It does allow you to be focused on the business logic as it abstracts away most of the routing and other http details (sometimes overly so), but it also take a little bit of time to get used to exactly how it's doing things. 
This guy followed you from another discussion just for pedantic squabbling and you remain so polite! Much less delicious troll food than I, I'll learn one day ... :)
I don't want to spend more time on this topic. If you aren't a member already of the Gophers slack, I highly recommend joining it. You can get an automated invite at: https://invite.slack.golangbridge.org/ There are tons of people on there happy to talk all things go and also a newbie channel. Good luck!
Woah, that's a big public API. Do you maybe have a good bit of internal details in there? I saw you asked a about Unicode testing, Luckily working with UTF8 is super easy in Go, I love it. There is 4 unicode code points that I use for all my tests, 0x41, 0xc0, 0xFf21 0x1d400 check the last one I always have to look it up. They have properties that I think are great for testing. - They all should look lok a capital A but distinct enough to tell apart - each range is linear to Z from that code point. I.e. 'A' + 32 = a - above invariant is nice because you can convert regular asci sentences to utf8 sentences of various length by generating a simple lookup table you can index from zero and lookup with w4['A'-runeVal] // 0x1d400 - it covers the 4 utf8 widths (1-4 bytes) so it covers all the issues you run into when iterating as bytes like off by ones and such 
It looks like you need to familiarize yourself with the Go syntax. Luckily it's the simplest language syntactically you're going to find. the golang tour and gobyexample.com site should get you up and running in no time.
Well first of all this doesn't look like Go code. &gt; but I can seem to come up with the words to write a program. How do I come up with those words? What words? What are you talking about? You learn the basic keywords of the language. For example in Go when you want to make a struct you use `type XXX struct`. If you are talking about words used to name the XXX struct the that depends entirely on the problem you are trying to solve.
anything for entry level career?
Java has work stealing scheduler since JDK 7 :) - https://www.reddit.com/r/programming/comments/6nwgvp/gos_workstealing_scheduler/dkdh3fs/
Actually, I did check this out. Didn't find the API user friendly so moved on. But I am going to look at it again and see if anything can be done about that. Thanks for the reminder!
[MarStr](https://github.com/marstr) here, I work on the [Azure SDK for Go](https://github.com/Azure/azure-sdk-for-go) and have worked at MSFT for about four years. Stack ranking was done away with shortly after I joined as a full-timer. Now we have a system that just asks you to write a paragraph about your coworkers and rate from one to five their ability to get stuff done, help others get stuff done, and mentor others. I've heard horror stories about stack ranking causing weird back stabbing and competitiveness, but haven't experienced anything like that personally now that it's gone. Edit: Adding links
&gt; How do I come up with those words? Tip: Read and learn from existing code. Tip inside the tip: Have a look at [rosettacode.org](http://rosettacode.org/wiki/Rosetta_Code). They collect code for all sorts of algorithms, data structures, etc. and for all sorts of languages. Here is the [Go category](http://rosettacode.org/wiki/Category:Go), or browse the [Programming Tasks](http://rosettacode.org/wiki/Category:Programming_Tasks), or do a search for the particular example you are interested in.
You want some ice, fam?
&gt;Luckily it's the simplest language syntactically you're going to find. Bro, do you even Python? Can you Lisp, dawg? Hey guys I come from Python what's this star thingy it crashed my code 
Turns out, getting someone's honest opinion when there are financial incentives at stake is actually a really hard problem to solve.
&gt; but I would rather have a stronger time value that can handle more date formats. why not just write in c then, man. 
Are you suggesting the person I was taking to burned me? I mean, they insulted me a whole lot for no good reason, that's true.
And again, this is not my question. Everyone just writes vague stuff like that but there is no explanation. No one seems to be able to describe why this is supposed to be good. Regarding other languages, I'm of the opinion that there are no other languages out there like go. Go has many pretty unique concepts with its explicit exception management, an actual compiler but with gc at the same time. It avoids oop hell like java suffers from in a clever way of giving you just enough tools to work with but not entangle yourself. On top of that it has a really potent concurrency system that at the same time takes care of everything in the background while still giving you all the necessary flexibility. It is for these reasons and many others a really productive language. There is really nothing out there that is comparable and many of the design decisions are things I'm frustrated about in many other languages for many years now. I *want* to stay with go. But then there are these rather minor things that could easily be improved in many different ways and a lot of way smarter people than me already called go out for it many times. Some are obsessively ideological but many have good points that seem to just run into a brick wall of &gt;GO has clear goals, and has proven to be the correct way so far for its intended design, hence its uptake and proven ability in such a short time. to explain away any and every criticism regardless of its validity and very good examples. I just don't get why every fan roots for go in that way but at the same time can't even explain why they think the decisions of go are the right way to go if someone challenges them.
&gt; I've removed two posts from this thread already. The "get out of here" post ... maybe should have been removed as well. That's not the way our community should act, and those without backstory on the situation might misunderstand what's going on. I don't know about others, but I know all about the back-story. I complained because you see this treatment on most these posts, even the ones that have nothing to do with Iris. If that doesn't fit the definition of harassment, then I honestly don't know what does. I should also add that I'm not affiliated with the author of Iris and have never even been to their github page... &gt; However, I also understand that a lot of people are fed up with the Iris maintainer (the upvotes on that comment prove it). That's no excuse. By that logic, I should now be able to follow the Go devs around and harass them about the time they wanted to delete this sub because *&lt;insert back-story here&gt;*, etc. 
Is simplicity a part of his way of life or only when he talk about Go ?
&gt; &gt; Why? Because it's less performant? How do I know that? If it is obvious and should never be used, why is the tool provided? &gt; Do you know what is a linked list? Prelude&gt; foldr (\n a -&gt; if n &gt; 10 then n else a+n) 0 [0..] 66 Hum, do you think it processed my infinite list from the end? Not sure how it is implemented in `go`, but it should process linked lists from head to tail. `r` and `l` describe how the passed function associates. 
Make it juicy. Ask him what he thinks about this subreddit. ([Spoiler alert](https://groups.google.com/forum/#!msg/golang-nuts/XoOhzUClDPs/f2DsVJA8CAAJ)).
Ask him what he thinks of 'Go 2'.
I came here hoping to see people hating on the insane format specifiers. I did read through format.go, which is pretty efficient-looking, and am a little curious if pre-constructed formatter objects are any better. Maybe not as much of a benefit as pre-constructing regular expressions. *Edit* the real money is in merging parser patterns so I don't have to write a parser for each possible number of fractional digits.
&gt; There are no arrogant questions Sure there are. Yours was a good example. 
Hey guys i come from go and i copied some code from stackoverflow with weird indentation and it crashed my program
&gt; My point is, was, and always will be that I believe (i.e. it's just my opinion, man...) that Go is a nice step back toward the fundamental simplicity of the Von Neuman Architecture that defines modern computing. The Von Neuman Architecture is more of a historical background rather than a model of modern CPUs. As a model for modern computing, Von Neuman Architecture is terribly inaccurate, as already pointed out by the other answer. Many of the assumptions of Von Neuman aren't true any more, such as unified pathway for instructions and data (they are separate on modern CPUs). It also doesn't deal with multi-core, which is one of the reasons Go exists in the first place... 
Change the last line to: *a = b You want to change what `a` is pointing to.
[foldr, applied to a binary operator, a starting value (typically the right-identity of the operator), and a list, reduces the list using the binary operator, **from right to left:**](https://www.haskell.org/hoogle/?hoogle=foldr) foldr f z [x1, x2, ..., xn] == x1 `f` (x2 `f` ... (xn `f` z)...) The function will *walk* to the end of the list *recursively* and *evaluate that long expression from right to left - because that's how calling functions recursively work* - simply (1 + (2 + (3 + 4))). `foldr` can either mean `foldRight` or `foldRecursively` and `foldl` can mean either `foldLeft` or `foldLinear`. `foldl` will walk from the left and be evaluated from the left because it's *tail-recursive* and the compiler will optimize it to be a simple while loop(by TCO). Your example uses *lazy evaluation* which means the elements will be picked up from the left *while your expression makes sense* and the resulted call-chains will be evaluated backwards.
Probably because I (and maybe the other go programmers) love GO the way it is, I most certainly don't want to change any of the issues you have brought to the table, I like the fact an unused variable is an error, spot on, and so it should be after the atrocious code bases I have had to deal with. I like even bad comments are highlighted as a possible issue, again, perfect. Coding standard is enforced, once again perfect, I don't know how many companies I have worked in and can you get 10 programmers too all agree to a standard... not at all, because everyone has the perfect coding standard apparently, and GO takes this issue out of the discussions. I most certainly don't want these features changed at all, they are in my eyes, perfect the way it is. I like it that writing to a closed channel is a Panic, why, because I know I have done something wrong, and need to address the issue. So again I guess, these are the kinds of things I like about go, you obviously don't, and thats cool. Ill just keep on programming and enjoying it the way it is, why, cause I like its ideology above all else.
Oh... I don't know why I thought I could change the address of the pointer. Evidently I hadn't internalised what was going on under the scenes of things like `json.Unmarshal` and it felt like I was re-assigning the address. Thanks though, this clears up a lot of uncertainties I had :) 