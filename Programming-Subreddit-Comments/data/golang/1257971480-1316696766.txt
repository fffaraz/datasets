Just do `apt-get install mercurial` or similar..
Windows and Mac don't have apt built in . On Mac, it's far easier to use these than fink / apt port way if easy_install is slow .
&gt; you can make a strong argument that it's so damned broken that you should find a way to do without. Particularly in a language like Go, where you can return multiple values from functions, you can do things like return both a result and a status code, and handle errors via status codes. . . . &gt; So if you're not sure that x implements Y, you can write "y, ok := x.(Y)". That never fails; if x implements Y, then y gets the casted value, and ok is true. If x doesn't implement Y, then y get assigned nil, and ok is set to false. Once again, having a way of catching an error is OK for the language designers, but not for anyone else. What?!?
I'm not sure what he is talking about, y, ok := x.(Y) is fine syntax.
it's under the [bufio]( http://golang.org/pkg/bufio/#tmp_106) package: " func (b *Reader) ReadRune() (rune int, size int, err os.Error) ReadRune reads a single UTF-8 encoded Unicode character and returns the rune and its size in bytes. "
The issue here is that in your own code you cannot behave differently depending on whether the caller reads one or two values from your program. y := x.(Y) and y, ok := x.(Y) actually behave differently (in the case where `x` does not implement interface `Y`).
It seems a curious omission that the author did not touch upon the concurrency aspects of Go, as that seems to be one of its biggest strengths.
You know, I was actually planning to reply to myself with that, you are totally correct.
Smashing! Thanks! I knew it must be there somewhere.
&gt; what doesn't it have? Well, libraries. And what are those [packages](http://golang.org/pkg/)? I call those things libraries: tar, asn1, bignum, gzip, crypto, json, xml, net, a lot of useful things to me.
For the codereview plugin, you need Mercurial 1.3 or higher. On Ubuntu 9.04, you get 1.1.2; Debian lenny has 1.0.1. Ubuntu 9.10 probably has 1.3, I'm guessing a lot of people haven't upgraded yet. I had to install via easy_install.
God, some moron that has not programmed in his life, spouts his worthless opinion based on some stupid comments made by some 'programmer' friend of his. What a waste of bytes.
It's absolutely a waste of text. If you break it down: Blah blah blah. VMs are bad. Blah blah blah. Google's using the programmer community to take over the world. It's not finished and limited. Blah blah blah.
&gt; He had his own distaste for Clojure ("LISP in a VM", as he put it) No offence, but his programmer friend is an idiot.
The listed program in the link doesn't do anything, it just sets up some empty loops that will run until ctrl-c'd. Here's an example that will sum an arithmetic series in parallel (*slightly* more practical): package main import "fmt" import "runtime" const ( reps = 100; num_cores = 2; ) type result struct { rep int; val int64; } func calc(rep int, ch chan&lt;- result) { var i, sum int64; sum = 0; for i = 0; i &lt; 10000000; i++ { sum += i; } // Send results through channel ch &lt;- result{rep, sum}; } func main() { // Tells go to use more than one core runtime.GOMAXPROCS(num_cores); // Buffered channel ch := make(chan result, reps); for i := 0; i &lt; reps; i++ { // Fire off goroutines go calc(i, ch); } for i := 0; i &lt; reps; i++ { // Receive results from channel result := &lt;-ch; fmt.Printf("%d, %d\n", result.rep, result.val); if i != result.rep { fmt.Printf("%d received out of order\n", i); } } } Timed averages over 3 runs: Average runtime with num_cores = 1: 7.236s Average runtime with num_cores = 2: 4.418s So 2 cores is ~60% faster. Note, compilation is fast with program this size so you can happily run $ 8g parallel.go &amp;&amp; 8l parallel.8 &amp;&amp; time ./8.out 
This is clearly the most important part about Go. It gives me hope for a better erlang, something I've been wanting for a long time.
This moron is comparing a whole bunch of VM-based languages with a compiled language for no other reason that they are "new." &gt; What Google is trying to do, I thought, is use open source, and Google's existing programmer's fanbase, to create a community around the language Exactly, it's the open-source spirit and we love it! &gt; so that it can be expanded for them without them having to do the lion's share of the work No, that's still open-source, if you want to participate (bug reports, change code), you're free to do it! You can be active for once, how can you hate that? &gt; the real problems programmers face today aren't going to be solved **my** new programming languages I hope you were trolling, or get fired tomorrow. That's what I expect from a guy who just discovered Blogspot, not some guy who pretends to be a "Senior Editor." My conclusion: you suck.
Why all of the down mods? Are you voting against the article or that someone brought it to your attention? I think the article is completely uninformed but I'm glad that someone linked me to it.
&gt; What’s a systems programming language? It’s the kind of language you use when writing a new OS. Or a device driver. Or an I/O stack. Or a piece of networking middleware. Or a very fast web serve Um, who is writing garbage-collected device drivers?
This is exactly what I was looking for!
Since hg doesn't really need any dependency no need to `easy_install`, you can even use `make local` in the source tarball it doesn't mess with anything else in the system and ./hg is already usable.
[Indeed](http://el-6.electric-loft.org/wp/?p=1430). Although to be fair, Go is a full coroutine whereas Termite's only running a thunk. OTOH, Termite has richer semantics overall, including pattern matching on receive.
this is a silly benchmark. This point of spawning 100,000 goroutines in the video was to show that spawning goroutines is cheap. Not to show that Go spawned co-routines faster than everything else. What is stackless pythons co-routine model? are they multiplexed on to pthreads?
Except that stackless, while great, doesn't even have a `select` construct, so it is quite useless for any serious CSP hacking. Also this 'benchmark' sounds quite suspect.
I don't know the details of stackless coroutine model, but I do know they have no `select` (or in Limbo parlance `alt`), so it is impossible to send/receive on multiple channels at once, which to me makes the whole thing *much* less useful. Edit: Apparently in stackless you can't do any blocking operation either, while in Go, if a goroutine blocks, other goruoutines will be run.
He can't even get the loop syntax from Go right, so he just did some random copy-pasting and a silly showing syntax side by side (again, getting the Go syntax wrong in many places), and he calls that a comparison? pfff...
&gt; There's a big difference between a good programming language and an effective programming language. Just look at Java. Is Java good or effective? I can't tell what's his opinion, and I hate Java. &gt; we're getting excited about a language that is less good than... It's not worse, it's simpler, and that's why I'm excited, simple (and maybe bigger) system tools will be fun to write again. &gt; New technology has been very slow to migrate over to the procedural programming world Functional programming is not a VIP club, anyone can download GHC and use it. &gt; This would have been the perfect opportunity to go and find all those new techniques You don't want *all* the techniques in just one language, it would be a real mess and no one would use it. For the rest I agree with uriel, the code has neither been verified nor compiled.
That is a major reason why I like it as well .
Why put named return values all the time if you don't use the feature in the functions. For example: func (h *Statement) Step() (err string) { C.sqlite3_step(h.cptr); return ""; } I'm just curious.
Heh. Looks like that's a pretty common first program to write in Go. [I made one](http://stackoverflow.com/questions/1735073/what-can-you-do-in-30-lines-of-go-can-you-create-a-useful-complete-program-that/1739625#1739625), there's this one, and a couple of the samples I've seen floating around IRC have also been simple little chat servers.
Implementing select() in Stackless based on existing primitives was a matter of about 1 minutes of thought: http://www.stackless.com/pipermail/stackless/2009-November/004395.html . Thing is, after 9 years of people using Stackless, its lack doesn't seem that important. Just how useful is having the ability to send/receive on multiple channels?
1) that is not really the same a 'select'. 2) I myself asked about the lack of alt/select in stackless when I was astounded to find out it lacked something so basic. 3) for 100th time, what your non-benchmark is measuring is the setup and teardown of two completely different kinds of things, it is still totally and completely meaningless. Oh, and to expand on 1): it is still pretty much useless if you can't even have any of your 'tasklets' block without having the whole program block. 
1) why not? It's the same behavior, yes? 2) somehow there are large applications built on Stackless, and 3) *shrug*, the user sees no difference so that's an implementation choice. And 1) wouldn't Go using FFI on a blocking function also block the rest of the program? Stackless can also do pthreads if you really need to deal with something which blocks.
 type ByteArray []byte This is as bad as the old: #define BEGIN_FOR for { Please stop redefining pretty standard and simple stuff with your own layer of nothing.
Very cool.. great job and great use of Go's channel feature
Does your select work when one channel is blocking? Does it make a pseudo-random choice when more than one channels are available? Does your example actually work? FFI with gccgo is experimental, but it would not seem to block: "If xxx is a C function, then cgo rewrites C.xxx into a new function _C_xxx that calls the C xxx in a standard pthread."
&gt; Functional programming is not a VIP club, anyone can download GHC and use it. this.
"When one channel is blocking" meaning when it's blocked in a system call? No, since Stackless doesn't support that automatically. If you need to call something which blocks, you could always use a pthread for it. That would be like a Twisted deferToThread. It does work when some of the N channels do not have data, and the choice of channel depends on the scheduler, so it's round-robin and not pseudo-random. Why would you want pseudo-random? Given N busy channels, round-robin says there's a 50% chance of getting data from a channel in N/2 selects, with 100% in N selects, while for pseudo-random it takes about 0.7*N requests for a 50% chance of getting data from a channel and 3*N for a 95% chance. I didn't consider that each FFI call might defer to a thread. I figured the overhead for doing that would be too much to be realistic, given the number of C libraries I might talk to. But I suppose that's the cost to guarantee never blocking.
The whole point about select is that it works when some channels are not available, e.g. when its writer is blocked in a syscall and hasn't got anything to send over yet. The whole point about goroutine is that they are muxed into pthreads when one blocks. It makes writing multi-threaded program so much easier. A pseudo-random choice is made only between the available channels. The Go mailing list had a discussion of fair choice vs. priority choice. The FFI is very experimental, but it is possible to lock a goroutine to a single pthread, thus forcing C functions to be executed there, if needed.
The select I sketched out for Stackless works when some channels are not available, e.g., when the tasklet on the other side of the channel is still doing something but is yielding time cooperatively. If that tasklet blocks on a system call then, yes, Stackless blocks and everything else in that pthread freezes. That's not a limitation of select(), that's a limitation of how Stackless interacts with blocking calls. If you want to get around that you'll have to write your own dispatch-to-pthread code. I'm almost tempted to write a helper function for Stackless just to make my point. As for how choices are made, that's up to the scheduler. Right now Stackless uses round-robin. There's a proposed change to handle priority tasks, but it's not a big push for it. I do realize there are entire PhD theses on how to do prioritization. My comment was to say that an acceptable select, waiting on a set of input channels, does not require pseudo-random choice.
There is no way to attach methods to primitive types other than creating aliases for them in this manner.
That is a fun trick, still I'm not sure it usually has any advantage over buffered channels in case you want to non-blockingly read or write to a channel.
Buffered what now? *Looks in language spec* Ooooh, I see. That looks a lot more straightforward! I can give two reasons why the approach outlined in my post might be preferred in some cases, although the buffered channel thingy does look better: * It works on any channel. * It will always be asynchronous. The first can be addressed by creating a buffered channel and a goroutine threading items through. Given that channels have a finite size, you could still end up blocking on a buffered one. Every waiting send and receive operation in the scheme outlined in my post has its own goroutine, which might be viewed as wasteful.
Yea, I guess in some cases where for some other reasons you have a blocking channel your trick would be useful, just pointing out that in the usual case it is not needed, but I agree it is a nice example of how neat and flexible goruoutines are.
Nicely written code from a person that looks to have done it other languages as well. It would be good to provide a couple of tests along with the implementation to prove that compilation and install went correct .
Great idiom. I am learning Go idioms and will see if I can write an article on them.
An example of how much fun low-hanging performance optimization fruit there is for picking in the Go libraries.
Yay. I hope the author submits this for inclusion in Go. I like NCurses.
Thank *goodness*. The Go libraries can be shockingly slow - see the Atof functions in strconv...something like 10x slower than the usual libc one.
This gives you non-local return, essentially. Which is nice.
pretty sweet!
EARTH! FIRE! WIND! WATER! HEART! GO PLANET!!
WTF is that?
Quoting the author from the mailing list: &gt;It's a bit rough and doesn't have all the packages you'd expect but it can at least run the examples in the go tutorial. Better than nothing and should provide hours of fun.
So it uses a "goroutine" (I don't like using that word) to run the body of the try block and escapes using Goexit() which presumably exits the "goroutine". Kind of reminds me of [this](http://www.cs.indiana.edu/~dyb/pubs/LaSC-10-3-pp223-236.pdf). Similar to the way Erlang treats exceptions (they kill the process and send a signal to another error handler process).
What is the FFI like in Go? It seems to import a module called "C" and just calls the ncurses functions in that module. Do you just like the any library and the functions will magically appear in the "C" module?
I don't like having to create a "goroutine" just to send or receive once from a channel. It seems wasteful, but it's probably not too bad. If you used a queue so other processes could insert onto the queue without blocking it would be better, but if you already have a shared async queue then you don't need to use this technique anyway unless you're interacting with code that's written with sync channels that can't be changed.
OK, I'll use this thread to vent my little annoyance with the Go distribution. When I run the installation as documented, it puts a load of crap in my ~/bin directory. Not cool guys. That's for my binaries, not yours. Are they assuming all users have ~/bin in their PATH anyway?
Anyone working on Win32 bindings?
Looks like a load of miscellaneous weird stuff.
What is miscellaneous weird stuff? Rob Pike's photos, or Renee French's drawins? ;P
When I visited the site that is the first thing I saw. There is not filtering for Go-related posts so I have to wade through photographs of parsnips, strange pencil drawings, Python code, articles on Canadian immigration, SSL/TLS, insurance, web identity, and large blocks of Japanese text with bits of Go code in between in that horrible font that Japanese sites use for English text.
That's because you neglected to read the install guide. Where does your GOBIN env variable point to? 
Well, it is not supposed to be very serious, just a fun place to see what is going on in the Go community, not any different from [other planet sites](http://www.planetplanet.org/). In other words, it is not meant to be an authoritative source of news or anything like that.
Moved [here](http://www.cs.hmc.edu/~me/go/arrays/).
I did read it, but not very thoroughly. I didn't set GOBIN.
I really don't like the naming convention for the compiler toolchain binaries. What happens when they need to support more architectures? Assign arbitrary numbers to them?
Not quite. The comments immediately preceding **import "C"** are also significant, plus you'll have to write a C "shim" of sorts to define anything that would not be in a post-processed C source file (mostly macro definitions, I think). For instance, IINM: #define TRUE 1 #define FALSE 0 should be defined in a C shim as: enum { $TRUE = 1, $FALSE = 0 }; which would then be processed by **godefs**. For the gory details, see the [cgo man page](http://golang.org/cmd/cgo/), the [godefs man page](http://golang.org/cmd/godefs/) and the example source code under $GOROOT/misc/cgo. EDIT: A better example of what would go in the shim can be found in **curses.c** of this very ncurses binding. This maps the various magic constants embedded in ncurses.h to enumerated constants for use in your Go code.
That's pretty good that you can include C headers without having to write function definitions. No wonder new C library bindings are appearing so quickly. I'm not sure why the "shim" is needed, but I guess you don't want all #defines included by default.
&gt; I'm not sure why the "shim" is needed, but I guess you don't want all #defines included by default. No, I think it's more basic than that. A fast skim of the **cgo** sources suggest that it uses GCC to construct an AST of all the C headers and source defined before the "C" pseudo-import, then parses that AST to figure out type definitions and stuff. It's been 20 years since my university compiler class, but I'm pretty sure all that would be "post-CPP", hence my original comment (emphasis added): &gt; you'll have to write a C "shim" of sorts to define anything that would not be in a **post-processed C source file** (mostly macro definitions, I think) Of course, I could be way off-base, and I'm sure someone more knowledgable would come along soon enough to thwack me upside the head for impudent guesswork...
Thanks, I think I understand now. The AST has lost all the #define information due to preprocessing, so you need to explicitly name preprocessor constants again.
This is very good for us who are stuck with windows @work. So thanx alot.. Im also looking forward to the cygwin port of Go
[see environment variables](http://golang.org/doc/install.html)
ehhh, I think it's a bit early for Go. Give it some time to mature more. Nice language and all, but I don't think jumping the gun to support it in app engine is a very wise thing to do.
Uhu? Why would that be 'jumping the gun'? Obviously Go is not quite ready to run on App Engine, that is the point of the issue, to ask that the work needed to bring Go to app engine to be done.
For a slightly more complicated take on a similar idea, see [http://gopaste.org/view/jE2B4](http://gopaste.org/view/jE2B4).
Yes.
Anybody read the source? Hmm … 
Be careful about exiting the loop midstream, though - the channel/goroutine will stay open and keep sending data, which could definitely cause memory leaks. I experienced this with gopaste, where an apache bench ate up all my RAM and effectively brought my system to a crawl. (It's fixed now of course - I changed it to loop over `.Data()`.) An issue has already been filed, but it seems like kind of a hard thing to fix; the ticket's status is LanguageChange.
Good to know.
&lt;heresy&gt;What about having C macros (or something resembling them) and a typeof operator à la GCC&lt;/heresy&gt;
Nice. Everyone's come to expect a REPL from any recent language.
Looks like they haven't changed all that much...which is great because I won't have to muck around too much with my code. The regexp speed improvements were sorely needed. I wonder if they've improved the Atof functions at all?
I'm so glad they added the new slice notation a = b[10:] is a lot easier than: a = b[10:len(b)] Next they need negative indexes a = b[10:-5] 
I had hoped that Go wouldn't require semi-colons at newlines from the very beginning. This is almost as good, and it seems that it should still be easy to write tools that parse Go on their own.
I don't see what's so bad about semicolons myself. At the same time func example(x int) int { f := func(y int) int { return x + y } return f } giving me a parse error on line 4 is kind of unexpected.
So that just needs a new rule "...and they can be omitted after } when it terminates a function literal or composite literal".
Yeah, Pike's proposal would appear to correct this issue. Which was sort of my point.
All dogs for what?
I don't know Go enough but after reading the tutorial, I couldn't tell where semicolons were mandatory, and where they were optional. Removing semicolons would be a good thing, fixing the tutorial would be good too.
Oh, I misread the new rules, didn't see the } in there with ). But now I see [] seems to have been left out. Does `b := c[i:j]` need a semicolon?
Actually it seems that it will be even simpler! Win win!
I hope not, might be an oversight in rob's mail...
I dont like that gofmt changes { doSomething(); } to: { doSomething() } Then i add one call, and i get syntax error { doSomething() doSomethingElse(); } I think they should leave them as they are in most c-like languages, or remove them almost completly. 
I believe that this would not generate a syntax error with the proposed changes. They are almost completely removed. They are fully optional -- I think one of the stages of the compiler adds them into the correct places. The article has the specific rules, it looks pretty good to me.
That will be fine with the new changes.
All or nothing.
Maybe. I think it depends how big your "system" is.
Just out of interest, what's so bad about the first lot of C code? &gt; /* Or worse... */ &gt; &gt; if (result = someCall()) &lt; 0 { &gt; /* Handle Error */ &gt;} else { &gt; /* Do something with result */ &gt;}
Nothing really wrong, but it needs the parens around the assignment (ugly) and it's easy to forget those parens (probably a bug). Also notice it's not valid C. He forgot the parents around the if condition--probably already gotten used to Go syntax! 
&gt; As can be seen from benchmarks, Go remains far from being competitive with C and C++. Runtime optimization is not a primary goal right now. &gt; One of the primary reasons for this is garbage collection. The current garbage collector system is slated to be replaced. That's what the golang.org pages said the day it was made public. 
Is there a good reason why kernels don't usually have GC? Is it just a speed thing?
It *is* a speed thing. Both in terms of latency and throughput.
I think the author's criticism with C in this regard is that the return value *must* have an out of bound value for the function to return an error. An example situation where this is a problem would be when the return value could be any value from -\infty to + \infty, but the input is out of range: x = tan(pi/2) I'm not sure how the C math library handles this, but x is undefined for pi/2 and not the same value when approaching from the left as it is when approaching from the right. This is a simplistic example, but hopefully you get the idea. 
While I find all his counter arguments missing the point, I guess that is to be expected when the original article does the same thing, I can't believe he screwed this explanation up: "... the author of the article clearly had nearly no comprehension of the FAQ. He suggests that the Go authors decided not to include the features because they couldn’t figure out how to implement them. When the truth is, Go is incomplete and they cannot figure out how to include exceptions or generics yet and are open to suggestions." His truth says that they didn't know how to implement them and need suggestions!!! WTF. Ok the true truth is that they did not know how to implement generics in a manner that works with Go's philosophy.
 $ uname -a Linux bob-desktop 2.6.31-16-generic #52-Ubuntu SMP Thu Dec 3 22:07:16 UTC 2009 x86_64 GNU/Linux $ cat &gt; trig.c &lt;&lt;EOF #include &lt;stdio.h&gt; #include &lt;math.h&gt; void main() { printf("%f\n", tan(acos(0))); } EOF $ gcc trig.c $ ./a.out 16331239353195370.000000 
One good reason is that, in order for there to be garbage collection, there must be a memory allocator. Which is one of the things a kernel should implement.
Mmm, I was just wondering why &gt;(if (result = someCall() ) )&lt; 0 was considered worse than &gt;result = someCall(); &gt;if (result &lt; 0) Just for readability reasons, right? 
The kernel could in principle as easily use its own GC as use its own C-style allocator.
So those things just appear out of the aether?
Here's the code if you want to avoid my blog spam [genetic algorithm in go](http://github.com/jbrownlee/learning-go/blob/master/geneticalgorithm.go)
Why not link [directly to the roadmap](http://go.googlecode.com/hg/doc/devel/roadmap.html)?
Your "Recent Updates" box could use a facelift. My eyes initially skipped right over it, thinking it was a text ad, though I'm not really sure why exactly my brain thinks it's an ad.
Probably because manual memory management in an kernel is not very hard to figure out. In fact some microkernels preallocate the memory they need once and have no further allocations (other than allocating slots in a preallocated table). That, and the lack of determinism in most GCs.
Why have they decided to use reference counting? Won't that cause a lot of slowdown with multiple threads atomically updating reference counts?
Why put "criticisms" in scare quotes? Are they not actually criticisms, but something else? Propositions? Solicitations? Bear in mind that scare quotes are very transparent as a method of painting the opposition as unreasonable. Anyway, "I don't like generics" and "C doesn't have exceptions" are not very useful responses to criticisms that point out their lack.
I am not sure, but Ian Taylor (one of the developers) was asked this question on the Gonuts-ML and his reply was: "We think that a reference counting approach will take better advantage of multicore and permit the program to run without pausing. This remains an area of investigation." And in an earlier discussion Rob Pike pointed people to this [IBM research paper.](http://docs.google.com/viewer?url=http://www.research.ibm.com/people/d/dfb/papers/Bacon01Concurrent.pdf)
Link doesn't work.
BTW, I found the link on cat-v.org. Thanks uriel!!
+1 for variant types
EMACS! In the go sdk - go-mode.el
uhm no thanks, emacs is a great operating system, but it lacks a decent editor :P
Boo to you. :)
Oh wow, someone read the tutorial.
Here's the Arc Challenge stuff in an executable form: package main import ( "http"; "io"; "./apage"; ) func said(c *http.Conn, r *http.Request) { io.WriteString( c, `&lt;form method="POST" action="` + apage.Create(func(d *http.Conn, s *http.Request) { io.WriteString( d, `&lt;a href="` + apage.Create(func(e *http.Conn, t *http.Request) { io.WriteString( e, `you said: ` + s.FormValue("foo") ); }) + `"&gt;click here&lt;/a&gt;` ); }) + `"&gt; &lt;input type="text" name="foo"&gt;&lt;/input&gt; &lt;input type="submit"&gt;&lt;/input&gt; &lt;/form&gt;` ); } func main() { http.Handle("/said", http.HandlerFunc(said)); http.ListenAndServe(":12345", nil); } Put that in a main.go and you're off
What does this offer over the "http" package?
http://www.getwebgo.com/tutorial It seems to be targeting the same level of features as web.py and others.
So... regex page paths, and that's it.
Internal server error?
Tsk :-|
This could be a significant step for Go. If Go code is able to be run on a 'bare metal' system, with no OS, it has a real possibility to replace C &amp; C++ for embedded development. I'm not sure how goroutines would be implemented, (maybe a mandatory requirement for a 'tick' timer interrupt to allow context switching), but if successful I would seriously consider using Go rather than C for many projects...
Whew. Finally someone wrote what we've all been needing
I wonder if it is possible to export the Go scheduler itself so that we can spawn goroutine remotely (communicating back via netchan's). That would be pure awesomeness.
If networked channels operate along the same lines as non-networked channels, your request is unnecessary. func SpawnilyWawnily(ctrl chan func(chan interface{}), comm chan chan interface{}) { for { f := &lt;- ctrl c := make(chan interface{}) go f(c) comm &lt;- c } } 
Decent article. Comments also mention slices in Vector and the upcoming Iterable package.
I saw on the Google Group that David Roundy (of Darcs fame) was working on templates. http://github.com/droundy/gotgo
He's also on go-gtk (along with mattn): http://github.com/mattn/go-gtk/
There has been quite a bit of stuff (including a few Go releases, and I had to add over a dozen [new libs](http://go-lang.cat-v.org/pure-go-libs) and [other packages](http://go-lang.cat-v.org/go-code)), a cool new toy is [goinstall](http://groups.google.com/group/golang-nuts/browse_thread/thread/f091704771128e32/303bed8870daf055). I'm thinking of adding a 'news blog' to http://go-lang.cat-v.org but have been too busy with other things, if anyone wants to help with posting news items please let me know.
What about generics? Have they made any announcement regarding them?
See the answer about templates.
There seems to be a lack of consensus about what to do (if anything) about generics. Some people don't see the need, and most of the people that have been writing code in Go for a while don't seem to be the ones asking for them...
Not to say somebody isn't thinking of it long-term, but Go is not nearly mature enough to do this yet, and I don't see it becoming mature enough anytime soon. I imagine Chromium is occupying most of Google's OS-building brainpower, anyway.
Part of me believes that Go is a way for Google to keep really smart people from the Plan 9 arena aboard. Though the idea of implementing the Plan 9 ports again in Go sounds interesting.. http://code.google.com/p/go/source/browse/?r=release#hg/doc/progs
At the end of the day, Google is an advertising company that gets its "eyeballs" from search. Doing search well requires trawling through mountains of data. Trawling through mountains of data well involves high performance multi-threaded systems programming. Systems programming is difficult and expensive. Go is an experiment where Google is risking a certain amount of money on a different approach to this set of problems in the hope that this work will reduce long-term costs or increase long term flexibility. It's a fairly low-risk move for them, since even if this completely bombs, they haven't lost anything critical. That's my take on it, anyway...
Go is related to plan9 in that the same people are working on it and a lot of the standard libs and the compiler structure are directly ported from plan9. Go also statically links against the plan9 libc. It was originally a 20% time project of the people involved, but it seems google now sees it as a possible replacement for something like Java. Having their own programming language and not having to rely on Sun(well I guess it's oracle now) is a big thing. 
&gt; but it seems google now sees it as a possible replacement for something like Java I consider the people involved and the progression in the languages they've developed (e.g., ..., C, Alef, Limbo, ..., Go) - with those after C being meant for distributed systems [1,3] (i.e., Plan 9). Interestingly, both [2,4] mention being inspired by Hoare's CSP. My point is that it is not really *just a replacement for Java - but perhaps Google is finally giving Plan 9 it's day. That's my take - and I just find it neato. My curiosity is piqued because while the clues seem to be all over, there's no unifying treatise on the topic that I can find. [1] http://plan9.bell-labs.com/sys/doc/9.html [2] http://golang.org/doc/go_lang_faq.html [3] http://en.wikipedia.org/wiki/Alef_programming_language [4] http://en.wikipedia.org/wiki/Limbo_programming_language
I was mostly referring to the fact that Google uses Java for a lot of things because in it's field (statically strongly typed compiled language that can be safe and do fast data processing) there really isn't any other options for them. So creating their own is a great idea.
Are there any plans to get rid of the `} else {` syntax, or at least provide a workaround? 
Google is huge, there is a lot of available brainpower.
Just a clarification: the Go compilers statically link against pieces of the plan9 libc, but the binaries generated for Go programs do not. 
The full list of ignored keywords: notwithstanding thetruthofthematter despiteallobjections whereas insofaras
In other words... sometime the box you think in is useful for modeling a solution, but the compiler is allowed to break that abstraction and go outside the box. Functional programming languages that disallow certain kinds of variable updates (except in very controlled ways, as Haskell does it) still at some point end up generating what is a very imperative program. It's easy to lose the fact that the language one expresses a solution has rules that don't exist at the lowest levels of the actual running code. I think this broken abstraction idea is on the same page.
The term 'duck typing' has been on the tip of my tongue for months trying to explain this concept to people coming from C. Thanks.
I use Go in what is currently just a prototype at work, but it's performing so well, that I'm flirting with production usage now, and possibly shipping it as a cog in a bigger management machine. Awesome language.
I had enough trouble with the simple numerical analysis thing I wrote in Go with goroutines that I reimplemented it in C with MPI. It reads a ton of data from disk and Go really didn't want to release memory from no-longer-used buffers back to the OS. So eventually all the memory on the machine would be eaten. The C version is also considerably faster for the same number of CPUs (the limiting factor in performance is small inner loops with no function calls). But these are implementation problems, not inherent problems with the language design. To me, Go is still a neat toy at this point, but I think it will evolve into a solid, robust language.
I don't know, I'm not sure if I buy that it's not a fair benchmark because C or some of its compilers allows 'tricks' that Go doesn't allow. That's a conscious decision about Go's design is it not?
I see ReadRune has been added to Reader. Good stuff.
this does not make a lot of sense: java and C# have interfaces too and this would have been solved in the same way: add an interface ServerEnc, and let the two classes implement it.
and c++ has multiple inheritance, which can be used to the same compositional effect.
There might have been a minor advantage here, in that the implementing types didn't need to be touched when the interface was defined.
Re: destructors running at exit, and the time needed to release memory, I think a better solution is to make sure you write and flush whatever needs saving, and then have the program send itself a SIGKILL. The OS can clean up memory, close files and sockets for you.
&gt; **Do you have plans to implement generics?** &gt; [..] the more Go code we write (and thus the better we learn how to write Go code ourselves), the less we feel the need for such a language feature. WTF
I was reading into Scala the last few days. And while I think it's possible for me to learn enough of it to be productive and to learn the rest later, it feels wrong. So I gave up. I managed to avoid the JVM for some time now and Scala isn't winning me over. (Unless I change my mind again. Can happen. Programming languages and me, a complicated story.) I like the answer to the question "How suitable is Go for production systems?". Maybe I should give it a try. 
To be fair, a great number of Scala's functionalities are provided by its libraries and are not built into the language.
I'm a mere novice, but I don't feel like this article tells us much.
Question for the knowledgeable: why does Go have non-snapshot closures? Is that intentional, unconsidered, or a bug?
What is a snapshot closure? 
See the PDF - closures are more powerful when local variables get copied in, rather than shared. Otherwise, closures can break their encapsulation by changing each other's variables.
Sorry for being dense, I still don't get it. Is this what you want? f1 := func (x int) int { int c = counter; c += x; return c }; It's the first time I hear the term "snapshot closure"? Where does it come from? And what does "more powerful" mean? Can you refer me to some literature?
These are called snapshot closures? Not broken closures?
I will basically post any ideas for cool projects I run across and think would make good go apps in this sub-reddit. I hope others will do the same.
Very interesting approach to the problem. It uses quite a lot of goroutines though. I will have to get used to the low weight of each goroutine.
Anyone have a link to his go talk afterward?
Main String Args
This blog contains executed example for GO language with explanation. This blog is created to help those people who is trying to learn this new programming language. Since its new language and books are not available for reference this website can be used as reference. 
Interesting thread. And [Andrew Gerrand says](http://groups.google.com/group/golang-nuts/msg/cae13235bacfd422): &gt; Go is still under development, but the language is stable. We're using it at Google for production work, so we're committed to furthering its development. 
They must have a very loose definition of stable, because in every update changes are made to the API that end up breaking something. 
Screencast demo of gocode doing its thing: http://nsf.110mb.com/gocode-demo.swf
great idea. makes it more consistent.
&gt;How suitable is Go for production systems? &gt;Go is ready and stable now. We are pleased to report that Google is using Go for some production systems, and they are performing well. Stable my ass. 
Stable does not mean immutable. Look at Java, C#, Python, Perl, PHP, C, C++, Clojure or Haskell; they're all changing, they're all fixing their respective flaws.
The code there is wrong with the current "strings" package. For one, "Bytes" no longer exists. Also, he probably wants strings.Split("..", ":", -1) (-1 instead of 0).
This is mostly about CSP. Slides are here: http://www.oscon.com/oscon2010/public/schedule/detail/15464
The sound is broken for the MP4 versions. At least in the 2 big ones. :-( Only the introduction is heard. Tried it with QuickTime, VLC, and mplayer. Mac OS X 10.6. 
The 640x360 version works fine. The video only has Rob talking--no slides. Open up the slides in a separate window and follow along.
Language != API.
I didn't know you could use scientific notation for integer literals, that's pretty neat.
Shamelessly upvoting one of my hobby projects :)
Does this mean that previously unavailable-to-Go C++ libraries are now usable from Go (once you "SWIG" them)? Before this, Go could only use C libraries.
Yes, that is the whole point.
Was wondering what was taking you to long to do this ;P
the "arbitrary precision constants that gain a real precision only when assigned to variables" model is really beautiful.
Rumpetroll [tadpole]... suuuuuure, tadpoles are black, these are white.
My browser (from 2009) is sadly too old school to use this website. What am I missing here?
It is nice that the tone is not too religious, but one doesn't get the impression that he has actually written much Go code, if any. As usual, Go is not about feature checklists or theoretical fanciness, it is about practical and useful compromises and a small set of clearly defined features that complement each other and work well together.
I thought he brought up a lot of good points, and especially like his attitude from the last paragraph: &gt; Meanwhile, if there’s anything here that the Go community is interested in, I’m more than up for the challenge of actually implementing it. 
Still it would be nice if he actually used the language before making proposals to change it.
&gt; one doesn't get the impression that he has actually written much Go code, if any. You're correct. I've probably written about 100 lines. I've just read a lot. I find the "you don't get to have an opinion until you've written 5,000 lines of Go code" party line which I hear frequently to be a pretty shoddy counter-argument. It shuts down discussion without either side learning anything. Is there some mysterious enlightenment I'll receive on line 4,999? If so, why can't some experienced Go programmer explain it in a way that makes sense to we unwashed masses? I don't hear this argument coming from other languages' communities. The idea that Go is harder to grok than Haskell is pretty silly, but when people say, "Hey, aren't typeclasses just like interfaces?" I don't hear many Haskellers going, "Well you'll just have to write 1,000 lines of Haskell to find out". Instead, they do their best to make the language as approachable as they can. I understand that Go seems to field a lot more "why doesn't Go X" questions than most other languages, so it probably gets frustrating after a while. But maybe it's worth considering that those questions get repeated so frequently for valid reasons. Maybe Go really does need serious work if it's going to be more than a niche language. (On the other hand, if Go *does* want to remain a weird little niche language, more power to it.)
I understand that nothing replaces experiential knowledge, but what could I expect to learn by doing so? Did I get anything wrong in the article?
&gt; Keyword args: There are some times where it would be nice, some times where it would be abused, but mostly I couldn't care less, if I really need it I can pass a map. I don't know how much nicer this would make the language, but I don't see how it would make nice enough to justify the addition. &gt; Block args: I suppose the sugar would be nice but you yourself proved that you can already do exactly that without any extra complexity in the language and one of the very nice thing about simplicity is that you don't have to worry about remembering a bunch of ways to do similiar things--there's a way and when you want to do it you just do it. I also prefer the passing a function thing because sometimes you don't want to pass closure because you already have a function somewhere that you can plug in without having to implicitly create a closure around it. &gt; Operator overloading: First, I loved your spoof of the arguments against it. I have to problems with operator overloading, personally: * I can't tell whether a + b is a simple add ax, bx or an O(n^2) operation, but that's been covered elsewhere. All I can add is that I prefer knowing what code does just by looking at. Not an argument, just preference. * There aren't enough operators. Op overloading in most language tries to shoehorn in stuff like A*B != B*A and even if you know A and B are of a type with an overloaded operator you still don't know what invariants that imply. This can be handled in a language that lets you define your own operators, but I don't like going "half way" like most languages do. I don't even particularly like a + b for string concatenation, but it's a common enough special case and useful so I don't *really* mind it, except on some principle, but sometimes pragmatism has to come before principle. &gt; Tuples: I've thought about this, too. But as pure as it would make the language, I don't see a great benefit over multiple return value or simple structs other than a few cosmetic nicities. That is, your example point := 1, 2 is nice but ultimately doesn't offer much over type Pt struct { x, y int } point := Pt{1, 2} other than a few less keystrokes. I love Python but I tend to avoid using tuples for anything other than multiple return values because stuff like x, y = point tends to be fragile and prone to human error (I absofrickinlutely love the python 3 head, *tail = alist thing, but who says people have to be rigourously consitient ;)) &gt; Unions: I agree with you on this one to some extent. See my post here for how I pictured it: http://groups.google.com/group/golang-nuts/msg/9ae4ab3733707af8 &gt; Constructors: Your examples of: pt := Point(2, 3) pt := new Point(2, 3) is exactly the same as: pt := Point{2, 3} pt := &amp;Point{2, 3} I know you'll say "future proofing!" here but see my comments on "Uniform access" below. The Go way is that if the zero-value is wrong, you don't allow a zero-value to be created. If the struct contains inexported fields it cannot be copied (but a pointer to it can be) so you create a function called `NewPoint(x, y int) *Point` that creates a valid Point and returns a pointer to it. It doesn't require anything more in the language than what is already there and you can pass it around like any other function. Go's features play well together. You can already do everything you proposed without changing the language at all. &gt; Eliminating Nil: This seems to produce a lot of heat. I like languages that "fix it"--option types are fantastic--but don't mind if they don't as long as they're mindful that it's an issue and produce good diagnostics when you dereference a nil pointer. &gt; Exceptions: Russ Cox posted these articles on the mailing list in reply to your article: * http://blogs.msdn.com/b/oldnewthing/archive/2004/04/22/118161.aspx * http://blogs.msdn.com/b/oldnewthing/archive/2005/01/14/352949.aspx I personally love error codes and optional stack unwinding with panic. I've seen all the arguments for try-catch exceptions always but I do not buy it and you'll never convince me otherwise because in my mind it's a hack and the only valid arguments revolve around having a single return value but Go has multiple return values. &gt; Generics: It would be nice but I like that the Go author's are taking their time and making sure that it fits with the language instead of bowing under the pressure of the clamor. I'd rather have generics that fit perfectly with the language and compliment the other features without stepping on their toes rather than "well they kinda work but you have to be careful that" and "oops dammit they're turing complete". I do wish they'd be a little more open about the design critera and what they've considered and why they're no longer considering that approach, etc. I think that would calm down some of the furor, lead to more helpful suggestions, and just be very interesting in general. Go's interfaces take care of lot of the situations where I'd otherwise reach for a template, on the other hand and the only time I say "man I wish I had generics" is when I'm resizing a slice and they'll be introducing an append built in that will take care of that, so I'm in no rush. &gt; Uniform access: I don't agree with future proofing in general. You cannot predict the future. Maybe your future proofing will pay off but maybe it won't at all and you'll have to refactor anyway. This is primarily philosophical but my approach is handle today's problems today and refactor tomorrow, when you need it. If it never comes up you've never wasted any effort, and if you do need to do it you keep your code spry and clean. Also, properties go against the "what you see on the page is what happens" philosophy Go promotes. &gt; 5000 LOC: I agree that it's dismissive and rude to say this. The closest phenomenom to this I've seen is people saying they refuse to Python because of its indentation rules. The only reply to that is "if you actually write code you'll see that it is not a problem and quickly forget it because you were going to indent your code anyway". Not 100% analagous by any means but similiar enough to mention. It is kind of true though. Reading the feature list of Go you think what about this what about that, but when you actually write the code you start to think aha that's how they fit together--I don't need X because I can just combine A and B! People complain that Go isn't revolutionary, but when you get your hands dirty **everything just fits together**. It may not be the state of the art in language research but it's marvelously well engineered. It's not perfect, nothing is, but it's fun to program in and you don't need to worry about a lot other than solving the problem you're trying to solve. I was very worried about the lack of generics but I wanted to try it anyway and eventually I forgot that it didn't have generics because it simply never came up. I still think they'd make certain things easier but it's not a showstopper. I think when people say write 5000 lines of code they (generally) don't mean "write 5kloc or stfu" they mean "trust me, write 5kloc and you will enjoy it and see how nicely everything works together". I don't know how to articulate it better than that, but I hope I made it a little clearer at least. &gt; "Why doesn't Go X": A lot of the time when I see this it actually does do X. I know people are really caught up on "no exceptions" but really it's "no try/catch syntax". It's not so much a lack of a feature as way of exposing the feature that you're not used to. Some times it doesn't do it directly, but by judicious combination of features. Go tends to be sugar free. Some of the time there was a design decision and a decision was made, no more no less. I don't agree with everything in Go but I do enjoy coding in it and ultimately what more do you want in a language than that? e: fmt
&gt; I also prefer the passing a function thing because sometimes you don't want to pass closure because you already have a function somewhere that you can plug in without having to implicitly create a closure around it. That's a good point. Any block argument syntactic sugar should also degrade to allowing an existing function there too. For example, Magpie allows: foo with print("hi") end Where `with` creates a function out the following block and then passes it to `foo`. But you can also do: foo(someFnRefIAlreadyHave) which accomplishes the same thing. &gt; so you create a function called NewPoint(x, y int) *Point that creates a valid Point and returns a pointer to it. That's a smart solution, but doesn't that mean you've given up the ability to have value semantics for that type? Seems like a big sacrifice (especially since Go lacks immutability) just to get initialization. &gt; I love Python but I tend to avoid using tuples for anything other than multiple return values I agree that I don't stick tuples in variables very often, but the idea behind adding them to the type system is that you'd use them any time you called a function: argument lists themselves would just be a tuple. Magpie works that way, and I find it simplifies a lot of things in the language (for example function types). &gt; I personally love error codes and optional stack unwinding with panic. I think we're actually in agreement here: error codes for common errors, unwinding for rare ones. &gt; Russ Cox posted these articles on the mailing list in reply to your article: Yeah, I didn't find them particularly relevant. &gt; I don't agree with future proofing in general. Agreed, I hate it! That's why I want languages that let me avoid it. Properties in C# are one good example of a feature that helps address that. &gt; People complain that Go isn't revolutionary, but when you get your hands dirty everything just fits together. At some point, I would actually like to get my hands dirty, but I have so little time to do so that I have to economize. &gt; I don't agree with everything in Go but I do enjoy coding in it and ultimately what more do you want in a language than that? Good point. Some people definitely dig it, and I'm happy for them. :)
I like your block-function correspondence there. I just don't see it "fitting" with the rest of Go and Go's strongest point is everything fitting naturally together instead of having a lot of sugar. &gt; I agree that I don't stick tuples in variables very often, but the idea behind adding them to the type system is that you'd use them any time you called a function: argument lists themselves would just be a tuple. Magpie works that way, and I find it simplifies a lot of things in the language (for example function types). That was kind of my point, it creates a purity but what's the point other than that? The language is theoretically simpler but now you have a feature that most of the time you want to avoid and rarely get to make good use of. Of course to point my own hypocrisy I should mention that all the functions in my language take a single list parameter :) But that's a different language with very different rationales and goals. &gt; [a factory function as constructor] is a smart solution, but doesn't that mean you've given up the ability to have value semantics for that type? Seems like a big sacrifice (especially since Go lacks immutability) just to get initialization. Yes, but in the "Tao of Go" you try hard to make the zero-value of an object meaningful. Take bytes.Buffer as an example. If you do: buf := &amp;bytes.Buffer{} then `buf` is simply an empty buffer ready to use. If you have something that can have an always-bad state you **want** to give up value semantics so you can ensure that you never have that bad value. &gt; Agreed, I hate it! That's why I want languages that let me avoid it. Properties in C# are one good example of a feature that helps address that. I know where you're coming from. I've used them in Python and they work well there, but it violates the "what's on the page is what happens" principle that go strives for. It's easy enough to refactor in that case because it's a statically typed language and you don't end up accidentially taking a function pointer when you want an int; that is: type X struct { M, N int } //old a = anX.N changes to: type X struct { M int } //new func (*X) N() int { ... } a = anX.N will fail to compile because a is an `int` not a `func(*X)int`, and if you're making changes to `X` like that you'll probably find something else that has to change around there too. It's a little more work but there's no magic involved at any point. To clarify since I'm starting to ramble, I'm not against magic in programming languages. I'm against programming languages that can't make a decision between magic or no magic. Python chooses magic. Fine, valid. Go chooses no magic. Fine, valid.
To bump this post: I'm the author of this package, and I've just pushed up a change which makes this notably faster than the 'toy' regexp language already in Go.
It's an interesting post. I find his comments on unions amusing though. He proposes: func ParseInt(text string) int | *Error { //... snip ... } // later: parsed := ParseInt("123") switch parsed { case int as i: Which you can almost do, replacing "int | *Error" with "interface{}", and then doing a switch type assertion (switch x := parsed.(type)).
&gt; Which you can almost do, replacing "int | *Error" with "interface{}" True, but you lose type safety. The goal here is to be able to say "this returns an int or an error *but nothing else*". `interface{}` is a free-for-all. &gt; then doing a switch type assertion (switch x := parsed.(type)). Huh, I don't remember noticing that you could bind the value to a variable of the matched type in a type switch before. Thanks for pointing that out.
I'd be more interested in a scenario like this: type String union { S string F func() string I interface { String() string } } func (s String) ToString() (r string) { swich t := s.(type) { case string: r = t case func() string: r = t() case interface{ String() string }: r = t.String() } return } //an army of funcs that take a String and call its ToString method 
Well, I suppose that would be (more) type-safe, but I can't see how it would be implemented internally in a way that would be any faster/different than just using an interface{}. So, I do kind of miss unions, but I've probably drunk the cool-aid too: I can't really think of a case where they would be strictly better than any other traditional Go-like approach. Maybe for struct packing. 
No, I don't think they would be more efficient either. It's a silly little dream feature. Everyone's got them, I suppose, and this seemed like the forum. The only two uses I can see would be (1) instead of taking an interface{} and documenting the types that can go there you just define a union and all of the union's types are assignment compatiable to it and (2) it would clean up the "go/ast" package significantly because a lot of the methods on AST nodes return vague interfaces that can only hold a fixed set of data (if you look at the source, the interfaces just have methods like _tag() that are empty functions). Of course that particular package would be cleaner simply if all those interfaces documented the structs that satisfy them since it is a finite, specfic set of types. I suppose I see them as half way between structs and interfaces--they can contain types that satisfy a contract but that contract is the type itself and not its method set, but they can also be the reciever of methods--although I can't think of any examples that wouldn't just be type converters so maybe that's useless since you could just define func's that take them and return one of their types but maybe I'm not thinking of something. As far as performance, I imagine they'd be implemented much like interfaces but I'm thinking of it less like C unions and more a way to easily express a case that's cumbersome in the language as is. 
It seems good but a preview in PDF would be better as I doubt we all have the tools needed to compile it. Edit: there's an auto-generated PDF here: http://www.miek.nl/files/go/
type interface_item interface { IsLessThan(interface_item) bool } type item struct { id int value string } func (i1 item)IsLessThan(i2 item) bool { return i1.id&lt;i2.id } Why item cannot be of type interface_item? A method can accept a value of the receiver's type as argument or return value, why can't a interface type? 
I like that you *can* do this with Go, I'm not sure I want to though. I like knowing my shit will crash if it's broken.
Let me guess, you aren't losing significant money while it's crashed?
I'm the author. There are PDF (nightly build available). See: http://miek.nl/files/go/
&gt; The goroutine will be ended after the error handling and can't reset itself. Is this really true? I can't see the language feature which would require such a behavior.
This pretty much removes my need for container/vector. Good stuff.
This is slightly outdated, there has already been further progress since it was posted Also there is a patch that adds Windows PE support that is being reviewed, and I suspect will be merged any day now.
The only reason I posted this here is because someone posted in /r/programming and the discussion left a fair bit to be desired. I was hoping for something more enlightening here.
I feel your pain.
As someone on the baduk, golang, and dwarffortress subreddits, I was very confused for at least a minute by this headline.
Hahaha..
Also check out [the slides from the GCC Summit talk](http://gcc.gnu.org/wiki/summit2010?action=AttachFile&amp;do=get&amp;target=gccgo-2010.pdf).
Cool! Do you know if that talk was recorded?
From the presentation I get that currently gcc internals are neither thoroughly documented nor completely straightforward.
I didn't actually attend, but unfortunately I don't believe they record the talks.
does this frontend issue errors when having unused imports and vars just like the original go comp?
I hope so. Why would it do anything else?
because the other gcc,g++ issues warnings in those cases. probably all other compilers do this javac, scalac, csc ,clang etc.. it is just go compiler that has this behavior. it interrupts the workflow when writing code incrementally and compiling often. why should go handle this differently than all of the other major compilers? is this in reallity a workaround for some other problem?
&gt; why should go handle this differently than all of the other major compilers? is this in reallity a workaround for some other problem? Errors on unused imports are likely because those drag down compile times. If you've lived in really huge codebases, you've experienced the sea of unnecessary `#include` statements and that painfully huge dependency graphs and slow builds it causes. If I remember right, the error for unused vars was because the implicit declaration syntax `:=` made it too easy to accidentally declare a shadowed variable when you intended to assign to one in an outer scope. Making sure you always use the variable will catch some of those errors. (This seems like a hack to fix bad syntax to me, but they have their own aesthetic.)
&gt; because the other gcc,g++ issues warnings in those cases. probably all other compilers do this javac, scalac, csc ,clang etc.. it is just go compiler that has this behavior. Because Go is another language, duh! &gt; it interrupts the workflow when writing code incrementally and compiling often. why should go handle this differently than all of the other major compilers? is this in reallity a workaround for some other problem? Because, again, it is a different language, different rules. You could just as well ask why `{ }` are required in `if` statements, or why C and other languages requires `;` when Go doesn't. The reason has been explained before. As Rob put it: it is important enough to generate a Warning, it is important enough to be an Error. And plenty of 'workarounds' have been provided (eg., assigning to `_`). I also found this a bit annoying at first, but really, it is a non-issue after the first twenty minutes of using the language.
&gt; If I remember right, the error for unused vars was because the implicit declaration syntax := made it too easy to accidentally declare a shadowed variable when you intended to assign to one in an outer scope. Making sure you always use the variable will catch some of those errors. (This seems like a hack to fix bad syntax to me, but they have their own aesthetic.) While this reasons are partially true, as far as I remember the main reason is to help keep code clean and uncluttered by unused leftovers. The reason it is not 'just a Warning', is because Go has no Warnings, period. As Rob put it: if it is important enough to issue a Warning, it is important enough to issue an Error.
&gt; I remember the main reason is to help keep code clean and uncluttered by unused leftovers. I agree with the sentiment: unused vars are dumb, and I clean them up in my code. But, ideally, the syntax would be such that users weren't often accidentally creating them to begin with. &gt; As Rob put it: if it is important to issue a Warning, it is important enough to issue an Error. That's a nice rule for code you're about to check in, but it's kind of a pain while you're hacking something together.
I guess the question is this: why do you need Go for this application? Go is pretty clearly intended for systems.
Step 1: Write a GUI library in Go.
http://go-lang.cat-v.org/library-bindings couldn't tell you "best" though the most natural way in the language is "serve html"
I'm writing XLib bindings at the moment. Currently (two days into the project) they're complete enough to write what is essentially xev. Yes, I know trying to write a gui in pure XLib is like trying to write a novel with only articles and pronouns. But it's still better than trying to write a novel without any words at all!
But then your front end isn't go anymore, it is html + css + javascript :(
Hey, I don't like it any better than you, but it's an option v:)v
http://code.google.com/p/x-go-binding/ there's also this
Primary intention of authors isn't always what programming language end up to be used for. Just take a look at Java which started as embedded language. Go is nice, performant, and I want to use it for desktop applications. There's no single reason why it shouldn't be used for that purpose except for the lack of libraries. And I hope libraries will come.
Yeah, but unfortunately that's XCB, not XLib. And, I didn't bother to research why, there's no mention of the composite extension in that source; whether that's because xcb doesnt handle the composite extension or because x-go-binding hasn't "bound" it yet, it's not there. I need the composite extension for my upcoming work, so I'm writing my own cgo binding for XLib
Did you look at all the libraries I linked to? Rereading my message it was a little ambiguous and sounds like I was linking to ways to serve html.
I don't know why it's XCB, or for that matter why XCB exists at all, but it's written by some of the inner cadre of the Go project so I have a feeling that it may become more canonical as time goes by, though with any luck only as a backend for a plan9ish draw library.
&gt; As Rob put it: if it is important enough to issue a Warning, it is important enough to issue an Error. Or in other words: we do not have the time/effort/resources to implement warnings so we blame the user for not doing it right 
&gt; That's a nice rule for code you're about to check in, but it's kind of a pain while you're hacking something together. Spot On!
I'm not saying it's not a wonderful thing - I'm just saying that it doesn't fulfill my needs for the project at hand, so I'm writing bindings for what does :D
I already saw that link (thanks anyways), and looking at the libraries there I think what you say (serving html) is currently indeed the best approach to gui app in Go :( 
Er... implementing something like Warnings is beyond trivial, it could be done in twenty minutes. You might agree or disagree with the concept, but there are plenty of people that honestly think warnings are a bad idea. Edit: I wonder if a possible solution to this particularly controversial case might not be to delegate the task of removing/rejecting unused imports/variables to gofmt, at least that is what makes most sense to me, but the whole issue smells too strongly of a bike shed argument and I'm happy to let the language designers decide either way they think is best.
If you want a 'traditional' widget kit probably the best option right now is [go-gtk](https://github.com/mattn/go-gtk). If you want a more from-scratch kind of GUI, you can build something on top of one of the various SDL bindings. There is SWIG support now, so creating bindings for something like Qt should be feasible too, but i don't think anyone has done it yet. I know of a couple of people that are building their own custom 'widget kits' on top of exp/draw, but that is all still way too experimental. For other bindings you might find useful see [the unofficial list of library bindings](http://go-lang.cat-v.org/library-bindings). 
If I was you, I would just develop a daemon in pure Go, and a gui in C with gtk and just do communication between each other. For me separating gui from core code in two (or more) separate process has always been helpful and clean.
Sounds like you're trying to track an IP address. I'd recommend going with Visual Basic; it's a lot more powerful for this sort of thing.
HTML [edit] Serious suggestion. HTML5, JS, web sockets, and you have enough flexibility for a great many kinds of GUI application, without needing to bind to a platform specific GUI library. The downside, of course, is needing to ask the user to connect to a (localhost) URL to control the app.
There's another benefit of the error for unused vars; when you say m, ok := f() you need to do *something* with `ok`. If you just forget to check `ok`, you get a compile error, as if you'd left off a `try{}` in Java. (But it's less annoying because you don't have to change the `ok` handling when `f()` acquires a new kind of error.) There's an explicit way to ignore it: m, _ = f() but it's harder to ignore it by accident.
True, that is nice, though I'd prefer union types, which give you the same benefit without leaving a lingering zombie value in the case of an error.
I think I agree that ML-style sum types are probably slightly more convenient and less error-prone. I imagine multiple return values could be more efficient, since you could just return them in registers, but I'm not sure how they're actually implemented.
Seems like it is quite mature given it is only a year old. Just keep up the good work, and good luck. The only thing I would change is stopping marketing it a system programming language, since it is quite capable of beeing general programming language.
And the documentation generator that was used for generating this doc: http://github.com/nsf/gortfm
Glen(da) Jr.
It used to be called Gordon. ~/go/doc $ hg log gopher changeset: 5469:e9851761a7a5 user: Andrew Gerrand &lt;adg@golang.org&gt; date: Thu May 13 11:53:44 2010 -0700 summary: rename 'gordon' to 'gopher' 
How about [McCabe](http://en.wikipedia.org/wiki/Go_\(programming_language\)#Naming_dispute)?
I have the start of an FLTK2 binding here: https://github.com/zot/go-fltk It statically links FLTK2 into the go library, so you won't suffer from DLL-hell. Simplicity and ease-of-use are some of the goals. It should be pretty easy to extend for what you need and I'll take submissions from people who extend it.
[For those that didn't understand the reference](http://glenda.cat-v.org).
Looks really promissing. I'll give it a try fi I succeed compiling it on windows.
I'm holding out for wx bindings..
why not call the gopher archie
Yes, but then you are programming in 4 different languages, have huge deployment and configuration problems, and makes your application more complex then necessary. I *want* to create small GUI app in Go, not in Go+JS+HTML+CSS+(json or xml) + ....
My HTML is a little hazy, but couldn't you hide the connection behind a static html page?
By connect I mean, they either have to type your app's URL into a browser, or you have to figure out how to launch a new tab in their browser from the command line.
XCB is an attempt to do XLib over in a more modern, fast, efficient way. I believe the current versions of XLib in Xorg are actually a wrapper around XCB.
You have to include the code! Otherwise, who knows? 
Without providing the code it is impossible to comment. But my bet is that you are just comparing Perl's heavily optimized regexp implementation written in **C** (and i think even some asm), with the standard pure Go very naive and totally unoptimized regexp lib. Use Go bindings for re2 (or the sre2 'port' of re2 to pure Go), and you will get very different results. But again, without providing code, it is impossible if you are even comparing the same functionality.
No regexps: package main import ( "os" "fmt" "bufio" ) func main() { ftotal, e := os.Open("total", os.O_RDONLY, 0) if e != nil { return } defer ftotal.Close() totalfile := bufio.NewReader(ftotal) var i, j, si, sj int for { _, e := fmt.Fscanln(totalfile, &amp;i, &amp;j) if e != nil { break } si += i sj += j fmt.Printf("i: %d - j: %d - i+j: %d\n", si, sj, i+j) } return } and #!/usr/bin/perl use strict; use warnings; open(my $fh, '&lt;', 'total'); my ($i, $j, $si, $sj) = (0,0,0,0); while(&lt;$fh&gt;) { ($i,$j) = split(' ',$_); $si += $i; $sj += $j; print "i: $si - j:$sj - i+j:",$i+$j,"\n"; } I'm really just curious, because go seems like a very good choice for a systems modelling project I have in mind, but speed is a key. This was really just a (very) naive attempt to see how go compares to languages that I commonly use. An comments about my approach will be graciously accepted.
Provided [here](http://www.reddit.com/r/golang/comments/e9als/tiny_golang_benchmark_curious_results/c16d38e).
Fscanln really isn't comparable to Perl's split(), try string.Split() instead. I'm not sure about the print/Printf part, but there might be non-obvious differences, I would both try commenting it out and using the print() builtin and see how much of a big difference it makes, my suspicion is that there might be some buffering differences. And a small nit which should not matter for performance, but your Go code is not idiomatic, you usually would do something like: if _, err := fmt.Fscanln(totalfile, &amp;i, &amp;j); err { return } 
Changing printf to print brings it down to ~70s, so you're probably right about the buffering overhead - the break is there because this is a snippet that would use that in the normal context (ie not a function that would return but a small loop within a function). I'm not sure how reading as a string and then using string.split() would save time, since that is essentially what scan is going to be doing - though I may be completely missing something here (also - is there a readline function somewhere - I can't find one anywhere).
Fscanln does lots of 'smart' (and somewhat expensive, specially if done for each line) reflection tricks and stuff to figure out the types of its arguments and so on. You can probably use something like [ReadString](http://golang.org/pkg/bufio/#Reader.ReadString) and even do away with the need for split(). Also note that probably both printf and print are doing some amount of reflection tricks that probably could be avoided too, and simply replacing printf with print doesn't mean that you avoided all buffering differences, removing the print altogether is probably a good idea if you want a meaningful benchmark.
Thanks for that. It's been very helpful.
Seems a bit odd, but I can't think of any real situation where it might be problem, that you can treat nil slices as empty is kind of neat but seems like a bit of the special case, it might make sense to extend it to maps, but there might be reasons not to (and it is nowhere nearly as useful as with slices IMHO). Still, probably would be best to ask about this in golang-dev or gonuts mailinglist .
On my machine, with the print moved out of the inner loop, the Perl and the Go run at pretty much the exact same speed. For fun, I tweaked the Go a bit, and got it to run 4x faster. Mostly, it was a matter of going from Fscanln to ReadSlice, bytes.IndexByte and a couple strconv.Atoi calls. With a custom atoi to avoid the string conversions (and thus some allocations), I was able to get ~14x faster than the original, but that felt dirty. 
Cool, thanks.
I'm rusty since I last looked at Go, but the first part seems to be about interfaces not maps. You store a value in an interface type, it is no longer nil. The interface {} value being nil isn't necessarily the same thing as the unboxed value being nil. Likewise with the second part, it isn't at all clear that an uninitialised map *ought* to behave like an initialised one. Trying to use something that hasn't been set up right looks like a programming error. (You understand, I'm sure, that line 23 is just initialisation syntax, and the compiler is calling make behind the scenes). My intuition would say that trying to do anything with an uninitialised map wouldn't work and you shouldn't expect it to.
Go seriously needed something like this. I'm sure I have one or two unspecified ad-hoc testing libraries I made because of the *ahem* lean nature *ahem* of the testing package.
Not speaking to your other points, but you're right on one thing: as far as modern programming languages go, Go and Ruby are about as philosophically different as possible.
I haven't followed go for a long time, this seems like big news to me, but will a person with a gcc install simply be able to use go? Will they have the standard go libs via gcc ?
I think that you will still have to build the standard library yourself. If there is one included, it is likely to be an old version. The standard packages are progressing rapidly.
Very nice.. this is good news for Go and it will help the adoption of go within the comunity. Can anybody get the gcc trunk to compile.. i get: ../.././libgo/runtime/go-go.c: In function ‘__go_run_goroutine_gc’: ../.././libgo/runtime/go-go.c:355:1: error: bp cannot be used in asm here 
All the documentation has links to the source code. Just click the function names. Examples would be nice for somethings, but a lot of them already exist in various blogs.
Nice summary. I have yet to find any case when using container/vector instead of slices directly would be a good idea. You are better off always using slices and forgetting that Vector exists.
You can leave the 0 off in all the `[0:` formulations. Now if only they'd deprecate `container/vector` so I'd stop being lazy and replace everything with `append`.
Thanks for the 0 info.
&gt; Now if only they'd deprecate container/vector so I'd stop being lazy and replace everything with append. And also would stop newbies from being confused/misled/frustrated by it and would force them to learn to do things the Go way.
Not to jump on the pedant bus, but you ought to change the tagline to "library to draw 2D geometrical images with Go" instead of "on Go" because right now... well it's sort of confusing.
except it says "on Go images," not just "on Go," meaning you can use it with the exp/draw package and all the image librarires
That is defensible reasoning, but I am still of the opinion that the phrasing is confusing.
Strangely enough, there seem to be quite a few rubysts interested in Go.
Yeah, it's really frustrating.
this will do good for the benchmarks in the benchmark game.
And there seems to be plenty of low hanging fruit still to pick. Also Russ Cox has some garbage collector optimizations in the pipeline that should help with a couple of other benchmarks.
The diff is kind of interesting. Pointers to structs instead of using interfaces seems to be the majority of the change.
What's a content addressable store and when would I use one?
What's interesting but kind of sad is how much of that diff is just going from: inst.next().index() to: inst.next.kind Or: inst.setNext(unNop(inst.next())) to: inst.next = unNop(inst.next) I don't understand how that doesn't seem like a language failure that you're required to do busywork like that.
I wonder if GCCgo has the same problem? This seems like fairly low hanging fruit for an optimizing compiler. I'd test but I'm... deathly afraid of installing new versions of GCC.
while many points are true, but did he say something about the same speed as C/C++/Fortran? I demand a simple benchmark of adding, and multiply a chain of 10 matrices of doubles with dimensions of at least (1024, 1024) and whatever library, concurrency/parallel model, compiler, CPU you like. The point of this benchmark is that it is * Number Crunching * Embarrassing Parallelisable * SIMD Friendly * Reasonable sized for single machine * High chance of cache misses * Existing highly tuned library for such task for comparison * Demonstration of code expressiveness If Go is on par with C/C++/Fortran in this benchmark then Go might enter the league. Compile time might be fast... but scientific coding is a place where enough optimisation can reduce a lot of runtime to make up the C++ insane compiled time. 
My 6g says &gt; too many arguments to append when compiling something like your insert function. I've tried append(append(a[:i], x), a[i:]...) but a is corrupted in nested append, so I've duplicated the slice: tmp := make([]T, len(a[:i])) copy(tmp, a[:i]) append(append(tmp, x), a[i:]) and this has worked. I don't understand why can't use append the way you do. Any suggestions? Thanks
Is a = make([]T, 0) the correct way to reset a slice? Thanks
Right yeah, I messed up there, as `append` changes the slice in place. What you need to do is this: append(a[:i], append([]T{x}, a[i:]...)...) and you should no longer have those corruptions (as it's a temporary slice that's being changed first). Your way works too.
That, or a = []T{}
If you read the readme (which is part of the linked page) you will find your answer.
I couldn't agree more. If I have the choice between one week and two weeks of runtime, I rather debug and compile a few weeks more but then I'm able to do the double amount of experiments. God, I'd really love to use it instead of C++.
Exactly! You learn a programming language by making programs with it, not reading a book or what others have said about it. Need problems to solve? [Project Euler](http://projecteuler.net/) has unlimited amounts.
or fix bugs in an open source project
Yes! Is just what I need. Very clean, thanks 
Wait, what? GDB works with Golang? I thought they didn't have a debugger yet..
speaking of the regexp pkg...how do I get around this: ReplaceAllString returns a copy of src in which all matches for the Regexp have been replaced by repl. **No support is provided for expressions (e.g. \1 or $1) in the replacement string.**
Don't ignore exec.Run's error.
I suppose the package documentation for exec is rather terse, but as ptrb said you'll get further if you don't ignore error returns. The name string should just be the name of the binary. Then the arguments (including php's program name for argv\[0\], remember) and environment variables are slices of strings. And you probably need to specify the working directory too. So your invocation would be more like: cmd, err := exec.Run("/usr/bin/php", []string{"php", "test.php"}, nil, "/home/Aries9", exec.DevNull, exec.PassThrough, exec.PassThrough) Hope this helps!
very nice!
Thank you for the response, it worked! While we're on the subject. Any idea how to set the 3rd argument (the environment variables) so as to be able to pass in $_GET? 
Sure, you pass in a slice of strings containing the environment you want as key=value pairs. e.g. []string{"$_GET=whatever"} By the way, I'd never tried this before, just looked at the package docs and tried a few things with a minimal program. I suggest you do the same, start with a minimal php script and get that working first. For example, here is the test program I used to check the key=value thing. file exec.go: package main import ( "fmt" "exec" "bytes" ) func main() { cmd, err := exec.Run("/bin/bash", []string{"bash", "test.sh"}, []string{"HELLO=Hello"}, "/home/rob/golang", exec.DevNull, exec.Pipe, exec.Pipe) // note edit if err != nil { fmt.Print(err) return } var b bytes.Buffer // re-edit: this works once you get the files piped to your program _, _ = b.ReadFrom(cmd.Stdout) fmt.Println(b.String()) } file test.sh #!/bin/bash echo Bash. echo $HELLO echo End. 
Ah-ha! I just noticed something else about your code, you want the stdout to be piped to your program with exec.Pipe, not just passed through to your program's stdout with exec.PassThrough. See edit in the code in my other comment.
The Pipe works for making the PHP run but putting $\_GET or \_GET into the environment variables doesn't do anything :/ I'm using os.Setenv instead of passing it as the 3rd argument so the code to print out what's in the environment variables can show it. This sets up a server on port 8080. To test, visit http://IPADDR:8080/test.php?test=showmesomething package main import ( "fmt" "http" "log" "os" "exec" "bytes" ) func HelloServer(w http.ResponseWriter, req *http.Request) { // os.Setenv("GATEWAY_INTERFACE", "CGI/1.1") // os.Setenv("REQUEST_METHOD", "GET") // os.Setenv("QUERY_STRING", req.URL.RawQuery) // os.Setenv("PATH_TRANSLATED", "test.php") os.Setenv("_GET", "test=200") // print env variables a := os.Environ() for i := 0; i &lt; len(a); i++ { fmt.Println(a[i]) } pwd, _ := os.Getwd() p, _ := exec.Run("/usr/bin/php", []string{"php", "--file", "test.php"}, nil, pwd, exec.DevNull, exec.Pipe, exec.Pipe) var b bytes.Buffer _, _ = b.ReadFrom(p.Stdout) w.Write([]byte(b.String())) } func main() { http.HandleFunc("/", HelloServer) err := http.ListenAndServe(":8080", nil) // can't use :80 unless root or use sudo. NOTE: browsers request favicon.ico by default for the first request if port 80 if err != nil { log.Exit("ListenAndServe: ", err.String()) } } test.php &lt;?php echo &lt;&lt;&lt;END GET: {$_GET['test']} END; ?&gt;
Have you tried passing the environment variables in the function call instead? Maybe the exec'ed process doesn't inherit the environment.
yes I have, no dice. If you look at the exec.Run code it shows that passing nil just causes os.Environ to be used.
You're right. I think the environment variables are being passed to php okay, it's just a case of doing whatever php wants so that the things you want end up in the $\_GET array. Does [this help](http://serverfault.com/questions/187025/how-to-pass-get-variables-to-a-php-script-via-the-command-line)?
yeah I googled too. Came across that and a lot more but there doesn't seem to be any good data. I think I'll have to get into Apache's source code and see how they do it. I don't think the superglobal $\_GET array in PHP is being filled in by the environment variable $\_GET or \_GET. I need to findout how Apache passes $\_GET, $\_POST, etc to PHP. tried this on apache with http://IPADDR/test.php?somevar=33 foreach ($_ENV as $key =&gt; $value) { echo "Key: $key =&gt; Value: $value&lt;br /&gt;"; } output doesnt show $\_GET as an environment variable: Key: TERM =&gt; Value: xterm Key: PATH =&gt; Value: /sbin:/usr/sbin:/bin:/usr/bin Key: PWD =&gt; Value: / Key: LANG =&gt; Value: C Key: SHLVL =&gt; Value: 2 Key: \_ =&gt; Value: /usr/sbin/httpd http://www.php.net/manual/en/reserved.variables.environment.php I came across this (see the post near the bottom marked Nov 18 2009, 4:19 am) maybe it provides some insight? It's someone using Go to access FastCGI written in C to set some environment variables. http://groups.google.com/group/golang-nuts/browse_thread/thread/e1d3275d58e0137b?pli=1
Yeah, $\_GET seems to be an array within php, not an environment variable. I *think* what happens is that the web server populates an environment variable called QUERY\_STRING with the parameters of an http get, in the form "foo=a&amp;bar=b&amp;baz=c" and the cgi program has to parse this. If you're writing CGIs in C you'd have to do this yourself, I would guess php is meant to do it to populate $\_GET on startup. How you make it do so, I don't know.
This would be much more interesting if it included details about what Go compilers were used (8g, 8g, or ggccgo), and also which Go release was used.
And if there were an explanation for why very specific matrix dimensions cause ridiculous performance increases. If it were a power-of-2 thing, you'd expect more than 1 insane spike per graph.
I'll try the QUERY\_STRING but someone posted in one of the things I read that they tried that and it didn't work. I will confirm.
The author needs to increase the iterations of the test enough times that the time to execute the function isn't completely dominated by the overhead of reading the clock and the resolution available. Getting sub-millisecond timings from the kernel required special patches the last time I looked at that problem. And even 10000 multiplies (mv for the 10x10) is only a few micro-seconds as long as the data stays in the processor cache.
confirmed QUERY_STRING doesn't do anything. I'm thinking the Go FastCGI projects are the way to go now instead since they're supposedly a lot faster than having to load up php each time you have a request. I looked through their code and don't see them setting environment variables though. I'm not really sure how they interface with PHP or any other CGI app though. http://code.google.com/p/go-fastcgi/ and https://github.com/jldailey/fcgigo/wiki 
Agreed, sad, but it's more of a compiler failure. gc doesn't do any inlining, so tiny methods aren't free (often, they also have a stack size check). Also, I believe most of the methods used there are interface methods, meaning that they can't effectively be inlined at compile time, dynamic dispatch and all. So, this change (I think) moves some things that would be dynamic dispatch to simple member access (it could move to methods, but the compiler isn't smart enough for that to be free, and it doesn't do much good). I think this optimization would be reasonable for any statically compiled language. The real slowdown in the regexp package, if I'm not mistaken comes from a) slow memory management and b) Predictable but simplistic algorithm. There is some not-entirely-fancy special casing that could be done that would give much better than 30% improvements for a lot of common patterns, but nobody has gotten around to adding them yet. I hope they do sometime; it'll be a good measure of Go's capacity as a systems language, imho.
&gt; So, this change (I think) moves some things that would be dynamic dispatch to simple member access (it could move to methods, but the compiler isn't smart enough for that to be free, and it doesn't do much good). My complaint here isn't about performance. It's that it's really lame that changing something from an interface call to a field access (an implementation detail) forces you to change every single call site. I'm trying to think of a single language out that that *doesn't* have properties or plans to add them, and all I can think of is, C, C++ and Java. Almost every new or actively growing language supports them for just this reason.
Nice introductory level post. It left me wondering though, exactly how much append allocates when it grows a slice. (I found the answer in src/pkg/runtime/slice.c.) Also, glad to see a post at all--it had been so long since the last one!
Heh, very interesting, I wrote a little test program and found it doubles for appending a single value. But slice.c tells the whole story. I hope the go blog continues to make posts like this, just expanding and clarifying different aspects of the language.
If you know your data structures the doubling shouldn't be surprising.
I've been reading the CGI/1.1 specs and it says you need the following: os.Setenv("REDIRECT_STATUS", "200") // if cgi.force_redirect = 1 in your php.ini os.Setenv("GATEWAY_INTERFACE", "CGI/1.1") os.Setenv("QUERY_STRING", req.URL.RawQuery) os.Setenv("REQUEST_METHOD", "GET") os.Setenv("SCRIPT_NAME", "/test.php") // not sure this is necessary os.Setenv("SCRIPT_FILENAME", "/home/myuser/mydir") // not sure this is necessary still doesn't work though :/ I've tried both php and php-cgi
If I were you I'd hit up a php channel on IRC and ask someone about it. I think you must be nearly there, and someone who knows a bit more about invoking the php interpreter can probably tell you the last few steps to take. But in the end, you'll only have ended up able to invoke php as a CGI. CGI seems to be frowned upon nowadays, as you said elsethread, for being inefficient, starting a new process each time. They still get used quite a bit of course, but sites that get heavy traffic tend to not use them. Still, best of luck.
Yeah I imagine I'll end up using fastcgi.go Anyway I did discover that it's populating QUERY_STRING correctly. There must just be some PHP setting somewhere that causes GET to not be auto populated. If I find an answer I'll post it here.
Actually, I like to know that when I do foo.bar I'm accessing a member, not implicitly doing an interface method call. One of the things I love about Go is that *it does what it says in the page*. It makes reading code and knowing exactly what is going on *way* easier.
Correct me if I'm wrong, but I don't believe you need to check if the channel is closed when using range, as it already does those checks for you. From the language specification: 4. For channels, the iteration values produced are the successive values sent on the channel until the channel is closed; it does not produce the zero value sent before the channel is closed So you do not have to worry about that when using range to iterate over the values received on a channel!
Nice.. my favourite: runtime/cgo: Add callbacks to support SWIG
Unable to clone the git repository: Permission denied (publickey). fatal: The remote end hung up unexpectedly fetch-pack from 'git@github.com:c141charlie/ds.git' failed. 
"There are the obvious things that remove the need for programmers to attend to details, things like garbage collection and other automated bookkeeping features." Agreed. It's amazing how so many people still insist on juggling their own pointers around, for "performance" reasons, even though the app spends 99.999% of its time waiting on the DB to respond. I can't imagine the nightmare you would have to endure to implement something like Go's channels on a non-GC'd language...
Why not use the built-in template package for templates?
From the web.go tutorial: &gt; Web.go doesn't include a templating library. However, there are several good ones available, such as mustache.go. The template package in Go is not recommended for web.go because it doesn't allow templates to be embedded within each other, which causes a lot of duplicated text.
[Direct video link](http://blip.tv/file/get/Linuxconfau-PracticalGoProgramming228.ogv)
The package explanation was pretty nice, I bookmarked it for later. So far most of my projects in Go are OneBigFile (TM), which I'd like to break out of the right way.
It would help if you mentioned how you installed Go to begin with. 
If you installed Go in the usual way, then everything should be in the directory where you put Go. Just delete that directory. 
There are probably also a few binaries in $GOBIN.
Which by default is in $GOROOT...which is where you put Go.
There isn't really any installation involved with go. The installation guide just tells you how to download the source code, build it and then add the path where the binaries are installed to PATH. All the files should be found in some folders in your home folder, and then it's just a matter of removing the directory from PATH.
Yeah, I looked for binaries, but I couldn't find any. Also, it's missing from the documentation. I mostly just wanted to make sure that nothing was added to other directories (other than my home directory) that I didn't know about. 
Thanks! This is what I figured, but wasn't quite sure. 
I installed it by following the instructions in the documentation.
Thanks for your help!
I hope they know about the windows binaries at gomingw
I know this is an old thread, but it's called os.StartProcess now!
Could you expand on that. what is called os.StartProcess now?
Can't really see the slides. 
Won't the select mean the channel receives are non blocking, leaving the forloop looping at full speed, using loads of cpu?
The "question" about concurrency at the end of the talk was just BLISTERING. I was just watching the video, but *I* was offended.
Negative. You can get that effect by having a default statement in the select block, otherwise select will sit there happily waiting until it can do a send or recieve in on of its cases.
The speaker handled it very well though as he spun it into a real question instead of the collection of insults it was.
Go to the corresponding youtube page and try it in higher res format like 720p.
 Q: Do tail calls grow the stack? A: Sometimes, with some compilers A2: Use goto or a loop [Paraphrased from](http://groups.google.com/group/golang-nuts/browse_thread/thread/d282193c786b0f36/ffb0a5936d972f32?lnk=raot). Of course, that thread is really old. Does anyone know where to find the latest word on tail calls in go?
The Go language doesn't have any requirement of tail call elimination. But some of the compilers do tail call optimisation. It's just an optimisation in Go, so you shouldn't base your code around it.
That's what I got out of the 2009 thread. Tail call elimination is another thing I would have included in a dialog about whether or not Go is a functional language. Edit: typos
Standard ML lacks tail calls, too. The notion of tail calls is quite difficult in non-strict languages. This does not seem to be a useful criterion at all.
I'm able to find very little information about SML and tail calls, so I have to assume you are right. I don't have tons of personal experience with ML. Do you happen to know if SML/NJ supports tail calls? If it doesn't, I wonder why tail recursion seems to be a recommended style. As far as non-strict languages go, ECMAScript is likely to get [tail call elimination](http://wiki.ecmascript.org/doku.php?id=proposals:proper_tail_calls), and that language is about as non-strict as it gets. Some variants of Python have tail calls, too. (I do realize you said "difficult" and not "unheard of." :) )
SML/NJ converts the program to continuation-passing style, so the space effects of non-tail calls are not observable even if SML/NJ does not reuse the stack frame directly. Ecmascript is not non-strict (lazy). Tail calls are actually easier to implement in dynamic languages because there is just a single callable type. No return value adjustment is needed which could interfere with tail calls.
Thanks for explaining.
is there an HTML version?
dunno, but there is a git repo of the TeX source, so perhaps it would be possible to generate html out of it instead of pdf...
I meant online.
[Accepted and implemented](https://groups.google.com/d/topic/golang-dev/BEL9eShtMhw/discussion). os: New Open API. We replace the current Open with: OpenFile(name, flag, perm) // same as old Open Open(name) // same as old Open(name, O_RDONLY, 0) Create(name) // same as old Open(name, O_RDWR|O_TRUNC|O_CREAT, 0666) 
I would like to see O_CLOEXEC added by default too, since that is what you want 99% of the time. Sadly I think only Linux has that--it would have to be fcntl()ed on the other unices.
Related: https://github.com/remogatto/gospeccy
Cool. This package was really unclear. I guess that FileInfo will continue to describe a file and File an open file, but really this all-in-one function with too many parameters made it too complex to make small things (this and golang team's habit to reduce comments to the minimum and to leave readers the task to guess their conventions and error handling).
I'd wish Google would buy the company and release the code as free and open source software. :-) 
For extra fun, call Set twice on the same future and then read from it multiple times.
Why is it wrapping a channel in a struct? Surely the implication is that a channel is *already* a future. 
Made me boggle slightly too. You want to read from something, having it block until another goroutine has written to it? Isn't that called a *channel*? 
No. With a Future, you want it to *still have the value* after reading it, with a naive channel solution you can only read the value you put into it once. Hence the article. The extra boilerplate is just to have a prettier interface to the Future.
Okay, thanks.
Hm. If I _really_ wanted a Future type, I'd probably do something like this: http://pastie.org/1841590 It doesn't allow you to check if it's done, but that's fairly trivial to add. It's more of an exercise, because as other commenters have noted, 95% of the time a channel works as well or better.
The entire concept of a future or promise still seems to be a little out of place in Go, though. While adding a tiny bit of functionality over native Go constructs, we seem to sacrifice (if we were to use it wherever we wanted to synchronize while communicating) a great deal of both performance and simplicity. This seems to be just the kind of concurrency boilerplate I can avoid by choosing Go in the first place, by simply making use of its native concepts.
Sorry, should have lined to the changelog page: &lt;http://golang.org/doc/devel/release.html#r57&gt;
You don't need that, still. Just a goroutine that reads the in channel (value produced once), closes it, and then spins in a loop writing that value to the out channel until closed (value read n times).
yay!
Am I missing something obvious, or is there now no way to detect if writing a channel will panic?
This article is full of cringe-inducingly awful errors. Here are some quotes that were particularly painful to read: &gt; Go is object-oriented, but it's not type-oriented. &gt; for the most part, variable types are strictly checked at compile time. But Go automatically manages memory with garbage collection &gt; betraying a bit of a soft spot for pure programming theory. &gt; Go is rooted in a 1978 researcher paper &gt; It's no coincidence that Robert Griesemer, one of the original Go architects, also worked on Chubby. &gt; concurrency that runs close the metal &gt; Goroutines aren't threads &gt; Goroutines use very small kilobytes of memory &gt; the channel setup is conducive to communication across a network. Pike points to a channel's ability to send a channel However, it's interesting that the Register thinks Golang is spongeworthy.
Goroutines aren't threads
Ow. You're inducing me to cringe with your awful error.
maybe he just knows gccgo ...
I have two questions: * Instead of defining empty structs, can't you just return the function itself in the visitor and thus define a stateless visitor? * Is it necessary to copy all the import specs, or can you just use 'append' to add one extra import spec to the existing ones.
In the article it sounds like this is special to go routines started inside a for-loop, but it also holds for closures created inside a for-loop: type Closure func () func main() { closures := make([]Closure, 0) for i := 0; i &lt; 4; i++ { f := func() { fmt.Println(i) } closures = append(closures, f) } for _ , c := range closures { c() } } also prints: 4 4 4 4
If you relied on closed(ch) before, you already had a race in your program. Now your bug is just more obvious. You probably need to adjust your design. close(ch) is generally just a signal that writes use to signal their end to the reader. It's not a way for the reader to communicate upstream to the writer. Use another channel for that... they're cheap.
MAKE HIM STOP!
Would have been nice if it noted that this example actually uses svgo.
I think the 1978 paper may be "Communicating Sequential Processes" by C. A. R. Hoare, Pike mentions it in a Google talk about Newsqueak.
It was. The article named it. The reasons that sentence made me cringe are as follows: * wtf is a "researcher paper"? I think they mean "research paper". * basically all concurrency work since then is "rooted in" that paper, but * Go's concurrency model is substantially richer than the one in Hoare's paper, like basically all concurrency work since then.
I've only used 8g.
Wouldn't that: http://pastie.org/1895965 be a simpler version than what the original poster built?
Even simpler: http://pastie.org/1897965 Edit: Or an alternative approach: http://pastie.org/1898519
Closing a channel allows it to broadcast continuously without requiring a pump. You just need to store the value somewhere. When a channel receive operation completes, you know that the value has been set. http://pastie.org/1897965
Yeah, this is where a sync.Once would come in handy...
It's always nice to see something high up on Reddit that I was physically present at :D
You too? I was over on house right, about 4 rows back.
You could just have a: type VisitorFunc func(node ast.Node) (w ast.Visitor) func (v VisitorFunc) Visit(node ast.Node) (w ast.Visitor) { return v(node) } The type is necessary to satisfy the filepath.Visitor interface. Then just define a function for each kind of visitor and convert it to type VisitorFunc. And yes, you could just use append. Actually, it would probably be more efficient.
It is hard to take most of what the tech press writes seriously, given that most of it is obvious garbage. Also, russ, unlike the people writing this kinds of articles, probably understands the difference between designing a language and implementing it. Not to diminish Russ contributions in any way, most of his work has been on the implementation, not on the language itself, and note that by now there are at least a couple or three alternative implementations of Go. P.S.: "I suggest we tie him to Plan9"? "Plan9"? really? I expected you to know it is "Plan 9" or perhaps "plan9", never "Plan9" ;P
when I heard they were giving away those gophers I wished I had been there :(
Are goroutines truly cheap enough to spawn when all you do is shove a word into a channel? Furthermore, why not have the first call to `Get` store the value in a field and set a flag, then return that field's content on further calls? Why involve a goroutine in `Set` at all?
yeah I love my Go gopher :D
Were there no forward references for recursive types earlier? Maybe I got lucky when I wrote http://rosettacode.org/wiki/Y_combinator#Go ? Specifically, the line: type RecursiveFunc func (RecursiveFunc) Func Regardless, thanks for the contribution!
The solution is overly complex. Its a neat solution, but it seems like they just kept fixing the next issue rather than reconsidering whether this was the right way to go about it. You almost hit the mark on how to do it. The problem is the "setting the flag". Someone has to check the flag, and if they check it before they can see that it has changed (which could be never without proper synchronization) they'll block on the channel, and never see the flag. The solution is to close the channel. And once you're storing the value somewhere, there's no point sending it down the channel. And since you aren't choosing between a value sent down a channel and a stored value, there's no point having a flag. You end up with: [http://pastie.org/1897965](http://pastie.org/1897965) You can also take an alternative approach: [http://pastie.org/1898519](http://pastie.org/1898519) 
Let's see how fast this baby can go.
I remember owning a copy of that in 1998... and then I replaced it with Borland JBuilder. Thanks for the nostalgia!
please back up your settings if you try this out - no promises on not screwing your environment up :) [https://files.me.com/mprorock/8ttsv1](https://files.me.com/mprorock/8ttsv1)
yeah, I still like it alot despite the advent of newer and "better" things, primarily bc it is damn fast without all of the overkill of a traditional ide. I do write most of my java code in eclipse, but for quick editing and c/c++ projects I have yet to find something I am quite as comfortable with, and as a very configurable editor it is working out really well for go so far.
why $ANOTHEREDITOR when there's vim and emacs?
Indeed, there's a synchronization issue with multiple concurrent consumers. That's not to say one didn't exist with channels and their closedness, but I won't claim one does without looking into the matter. I'd also have a hard time imagining it being more convenient to type `future.Get()` each time the value is required, than `val := &lt;-future` once and then just `val`. Especially when a future would be visible outside the current goroutine, which seems to be the real use case anyhow ("here's a value, but it might not have got here quite yet...").
crashes for me :(
Canonical
Textmate feels a lot like abandonware at this point. There was a minor update back in November last year but TextMate 2 has been "in development" for years with no end in sight. When people start making ["Has X happened yet"](http://wastm2released.com/) sites about your product then really that should be enough of a signal to you to at least update people on what the progress is.
Textmate is clearly not developed anymore. My opinion on the subject is that the TextMate authors does not want to release a new version, because they might not be interested in the subject anymore and if for some reason a new version does not make people happy, they will lose the sales for the version 2 *and* the original version, which i think, still makes a good load of money. The funny part is that, in order to maintain TextMate 1 sales, they *have* to tell people there is a v2 under development.
This would actually be useful alongside Vicoapp (http://www.vicoapp.com/), which can use TextMate bundles. It's actually a really nice editor!
"e" is a nice TextMate clone for windows, allows me to use the same bundles at home and at work. The problem is that many bundles have filenames with colons or other disallowed DOS/Windows characters. I haven't tried this Go bundle, but I saw at least one : in there.
Change the layout variable, it looks like. Using the built in RFC3339 format, I fiddled with it until I got layout := "2006-01-02T15:04Z" which successfully parses the "Combined date and time in UTC" example on Wikipedia. Hopefully this is what you're looking for. If not, the included layout constants in the time package can probably help you format to your needs. http://golang.org/pkg/time/#Constants
There is no synchronization issue with channels and their closedness. When a channel is closed, all existing and future receive operations on that channel evaluate to the zero value of the element type. Closing a channel and receiving on the closed channel counts as a synchronization event, so all Gets are guaranteed to see the write by Set. The only benefit I see from using a future over a channel is if you want to hand off a future value to several other goroutines that may (or may not, perhaps) check that value later in their execution. Of course, the implementation is so simple that you could probably get away with just letting the user access the channel and the value (via a pointer) directly, rather than encapsulating them.
Oh is a cute name, but gosh wouldn't gosh be better? Props to the author for doing it regardless. 
AFAIK, editor support is welcomed in the Go tree -- there are a few of them in the `misc` directory. Feel free to submit yours http://golang.org/doc/contribute.html
How do you know it is the fastest? 
Conceivably, there could be a faster one out there, but to my knowledge there are only two other Markdown libraries for Go: * [A native implementation of peg-markdown](https://github.com/knieriem/markdown); the author claims this to be 3.5x slower than the C implementation (and from what I understand, Upskirt is faster than PEG anyway). * [Goskirt](https://github.com/madari/goskirt), another Upskirt binding which, incidentally, was apparently written one day before mine :P. Between Goskirt and Upskirt.Go, the difference is most likely negligible; but my glue code is all C aside from a one-line return statement Go function, whereas Goskirt is made of significantly more actual Go code and generally has a more complicated design. Based on this, it can be reasonably concluded that Upskirt.Go has a slight edge, but when I made this post I actually hadn't yet learned of Goskirt (it was published to Upskirt's readme at the same time as Upskirt.Go). --- That said, more important than practically non-existent performance differences is the different purposes intended by their respective designs. Upskirt.Go is designed to allow users to render a specific flavour of Markdown with no hassles; Goskirt is designed to expose much more of the full Upskirt functionality to users (at the cost of some simplicity).
Ok, so no benchmarks, but pretty reasonable theory. Fair enough. (I think yours requires more buffer copying than Goskirt for many use cases as a result of being a func(string) string, but I have no idea if that makes a notable difference).
Interesting, though to do the same thing in Goskirt with `skirt.WriteHTML` seems like it would involve a bit more overhead, as it would need to go through some sort of File type representing a string (assuming this can be done in Go). Edit: For what it's worth, a few hours ago I added `-O3` to the Cgo gcc compilation flags. Not sure how exactly that will affect performance, but it may help a bit.
I tried to understand this and it only sunk in half way so far. It seems brilliant. It seems very convenient. Maybe I'll have the same sudden realization I had when I first started list comprehensions.
Hi Uriel - maht here - this is my new reddit accnt I'm still not using Go and every time I read an article about it, I feel guilty :) 
Erm, same thing was posted a few hours ago.
The entire blog post consists of two very simple and very short sentences, links and citations. I consider that blogspam. Granted, you don't have ads. But still.
After I saw this, I went and ported upskirt into pure Go. The result is called blackfriday: http://github.com/russross/blackfriday This has the advantage of being usable on Google App Engine since there are no C dependencies.
I understand all that--this is not my first Go program. I used Go as one of the case studies in my programming languages class last year and I've done a few other private projects with it. I think that I understand its idioms reasonably well, but this project had an entirely different motivation. The first pass (which is what this code currently represents) was a direct translation of the C code, hence the ugliness you have pointed out. I'd like to start rewriting it gradually, but I wanted it to be working and complete before then. My main purpose was to get something as quickly as possible that I could use with Google App Engine (which rules out bindings to C libraries). I don't know how familiar you are with Markdown, but it is a mess to parse, with lots of ugly and inconsistent rules. I opted to start with a respected C implementation that I could port quickly rather than spending the time to make it idiomatic (is that term going to be as abused by the Go community as "pythonic" is by Python users?) and rediscover all of the corner cases that Markdown imposes. I also thought it would be interesting to see how performance would compare with something that is as close to apples-to-apples as I could get. There is very little I/O or anything like that; most of this is direct manipulation of simple data structures. It appears that the Go penalty incurred here is around an 8x slowdown over the C original. As for the unicode issue, I believe it will still handle utf-8 input without problems (though I have not tested it much). The code works on bytes, not runes, and it always marks boundaries by looking for specific ASCII characters, so the bytes that make up code points &gt; 127 will be processed blindly. They will never be chopped up or anything, though. Also, markdown's rules make no mention of non-ASCII characters; all formatting is dictated entirely by ASCII characters, and everything else is just passed through to the HTML. Also, all constants are intentionally exported. Anyone writing a new backend (to output LaTeX, for example), needs access to flag values for the callback functions. Many of the names are still very C-ish, but that seems like a pretty minor issue. I wanted to push the code out for people to use as soon as it was working rather than waiting until it was pretty. The names that begin with char_ are callback functions triggered because a specific character was found by the parser. They are not Hungarian notation as you seemed to infer. Once again, a direct translation of the C code. 
Awesome; that's really cool.
in the end of the day you have a markdown parser and he hasn't. you don't need to justify yourself.
In the end, everyone has a markdown processor. 
&gt; I also thought it would be interesting to see how performance would compare with something that is as close to apples-to-apples as I could get. I don't think writing code in such unidiomatic ways that are directly translated from optimized C code is really apples-to-apples. It is more like biological-apples-to-plastic-apples, the shape and look might be the same, but the substance is completely different.
I don't get it. I see no code and don't even see what exactly is benchmarked. How are we supposed to conclude something from that ?
I agree. I have the same "problem" : I'm still no Go master (fun fact : I began yesterday to trash my vector code as I just discovered the append function) but I have working programs and I don't see other way to learn than to make. And when you make software, sometimes you have to grab old pieces of code. But the discussion is interesting so I'll give an upvote to all three of you ! 
I think that when learning a new language, it is best that start from scratch on a small project that you have perhaps solved in another language before, but not to look at the implementations in other languages at all, they will bias you and give you the wrong expectations regarding what to do. And yay for more Vector code getting trashed and replaced with append() :)
Aside point : Where do you find go news so that you don't learn so late that there is a function so important (a function that didn't exist when I've read the documentation) ? There's go-nuts mailing list of course, but it's so difficult to read when you cannot spend half an hour every day following it...
I just checked in a very basic LaTeX backend. It works for basic documents, but makes almost no attempt to sanitize input.
If your goal is to learn a language, that's great. Hopefully Go is getting to the point now that people are using it for real work, not just creating tutorials and exploring the language's idioms. Haskell was stuck in a ghetto for a long time because everyone focused on writing beautiful Haskell code (and let's face it: Haskell is still about the most beautiful languages there is) and ignore practicalities. It's nice to see at least a few real projects in Haskell these days, but it is still mostly a language playground. Seeing significant amounts of ugly Go code enter the mainstream will be painful signal of success. It will show that people are paying attention to the work they need to get done instead of just paying attention to the shiny new language.
Reading the (mostly) weekly change notes is a good idea, at the top of each release any major language/library changes are explained: http://golang.org/doc/devel/weekly.html And now also there are proper 'stable' releases, and the release notes should mention any major changes too: http://golang.org/doc/devel/release.html Still, things like append() are usually posted here in /r/golang too.
Go itself is extremely practical, writing 'proper' Go isn't for the most part an esoteric activity, it is just matter of following some conventions, not trying to shoehorn other programming models into Go, and using neat tools like gofmt. And there are already plenty of [organizations using Go in the real world](http://go-lang.cat-v.org/organizations-using-go).
I've had a chance now to clean up some of the naming conventions; would you mind having a look at it again and pointing out which parts still look the most un-Go-like to you? The utf-8 issues are still a work in progress. I did a simple update to expandTabs to count runes instead of bytes (to find the current column number) and it added about 1/3 to the overall runtime, so I'm going to give those issues some more thought before fixing them. So ignore isspace and friends for now. Any other suggestions would certainly be appreciated!
For this particular library, performance is one of my principal goals. I'd appreciate any suggestions you could offer on how to do it in a more Go-like fashion without sacrificing performance. It appears that performance is currently dominated by parsing, which currently involves scanning []byte buffers in a very C-like fashion. That, and bytes.Buffer management seem to be the slowest parts (if I'm reading 6prof output correctly). Many parsing functions would be much nicer looking if I used regular expressions, and I wouldn't have to think too hard about unicode support if I started using the utf8 package to pull runes out, but I suspect both options will add to the runtime. That's what my "apple-to-apples" remark was about. I'm trying to keep it as fast as possible by using low-level loops and careful memory management (just like the C code did), rather than rewriting everything to look prettier and then claiming "Go made it 10x slower". It currently runs about 3-3.5x slower than the optimized C code. As an example, switching one inside loop to use utf8.DecodeRune to count characters (which it really ought to do) instead of just counting bytes (and getting the character count wrong for multi-byte unicode codepoints) added about 1/3 to the overall end-to-end runtime. Once again, suggestions for improvement are certainly welcome!
I guess I'm just confused about what I'm doing that is such a violation to the rules of proper Go programming. Was it the C function names? Retaining them made porting *much* easier; a few regular expressions later and they are mostly gone now. Is it re-writing a few low-level functions rather than using those from the standard library? Using my C-like attrEscape function cuts the end-to-end runtime in half compared to using html.Escape in its place. Rob Pike spoke recently about how one of Go's strengths is letting you retain low-level control over memory. Is actually doing that a violation of Go style? My goal in this project was to get something written quickly that performs well so that Google App Engine users (in particular, others in general) would have a markdown engine that is nice to use. Porting an existing, fast, widely-used library seemed like a smart approach. The only feedback I've gotten from the Go community is a barrage of non-specific criticism that seems to suggest my approach was not so much flawed as sinful.
I gave it a try. The first part is actually checking for up to 3 spaces, not exactly. Definitely needed a comment to clarify that. I tested with exactly 3 spaces so I could leave the code as-is. I'm not entirely convinced by the switch with '0'..'9' to check for a digit. That seems like it's well into personal preference territory. I guess I've just seen enough code comparing ranges of ASCII characters that it seems pretty natural and clear to do it that way. Just for fun, I tried a micro benchmark (the worst kind!) to see how they compare, since the ugliness is all about performance. Parsing a single line of valid input 100,000,000 times in a row I get: 1. Original code: 3.413s 2. With switches &amp; slices: 9.001s 3. Original with loop &amp; if statement consolidated (what is now checked in): 3.062s This function is not an inner loop, so the performance isn't as critical as in a few other functions I'm looking at, but a 3x slowdown is still enough to make me pause. I wonder if there are any good idioms for working with unicode runes. It seems that when you want to look at a rune at a time, the options aren't great. You can convert the whole thing into a []int, but then you don't have much in the way of library support (methods like HasPrefix and the like, much less first-class support like the string type). If you decode a rune at a time, it's a bit cumbersome and really quite inefficient (you have to take a slice for every rune). I think utf8 is brilliant, but sometimes a string of 32-bit ints or something similar would be awfully handy. I ended up with this is expandTabs to find tab characters and track both the column (in runes) and the index (in bytes): for i &lt; len(line) &amp;&amp; line[i] != '\t' { _, size := utf8.DecodeRune(line[i:]) i += size column++ } Not horrendous, but not exactly graceful, either. It's also pretty slow. I worked around it by checking for common cases where I didn't have to count runes; otherwise the operation of expanding tabs took up about 1/3 of the overall runtime (now it's around 5%).
&gt; It seems that when you want to look at a rune at a time, the options aren't great. Isn't that what range on an string is for?
How did I miss that? Thanks!
Oh, sessions. Nice. I wonder why so many frameworks don't have any. 
Sessions are always at best a kludgy hack, they just don't fit the model of HTTP.
&gt; Sessions are always at best a kludgy hack Sorry, I hate this statement. We all know it, but we need sessions nevertheless. How do you code a login and current status without sessions? All those new frameworks everywhere (see the flood of micro frameworks for Python) don't have any support for sessions. So you have to implement it yourself and make all the same mistakes again that others have made before you. Like storing the session inside the cookie, as you can see in Mango's `session.go`. :-( 
Sessions are just an abstraction on top of cookies (or other even worse hacks), an abstraction that gives false illusions regarding how the web work. I can't even remember the last time I used 'sessions', they just hide what is actually going on and when stuff breaks they make things much worse. It is way better to use cookies directly yourself, and try to keep as little state on the server as possible (ideally none at all, which in most cases is possible, and sessions make impossible).
I'm going to have to change so much code :( by greatly simplifying it :)
I did that to my project today. It felt good to delete so much code! http://camlistore.org/code/?p=camlistore.git;a=commitdiff;h=9b3280ce10397cfed71acc97e129ea425c79689e
http://uwedeportivo.tumblr.com/post/5945728057/kindi-encryption-tool NOT FOUND The URL you requested could not be found. 
Weird, seems that the post was deleted.
More work to protect against CSRF without state on the server.
This is a self post. I think you meant link to the article in question.
There seem to be a few errors in this post (eg., how many times one has to repeat that Go's ; insertion is **not** like the broken hack in JS? *sigh*), but oh well.
without a link// pls....
Posted a link to the actual article here: http://www.reddit.com/r/golang/comments/hudul/dynamic_method_invocation_using_interfaces_and/
Oops, sorry, my mistake. Follow link of uriel or go directly to http://www.tideland.biz/articles/coding-in-go/dynamic-method-invocation.
The point on pass-by-value calls being sometimes more efficient, and on data location in memory is interesting. It let me think that as an old java programer I may have bad habits and use a little too often pointers when I should use direct values. 
I wrote one too https://github.com/tm1rbrt/Tracer It's undoubtedly worse than this one.
I'm particularly excited by the promotion of exp/draw (I hope the bits in exp/gui will be promoted too), and the preliminar work on escape analysis optimizations for the compilers. Also the rewritten regexp package is coming! 
I think it should be called shed/bike
shed/bike***s*** is more accurate, a single shed can contain multiple bikes.
No, because then the contents wold be called as bikes.something instead of shed.something.
wtf?!
&gt; Mentioning Go appears to send some people into a rage judging by the sort of comments that arise Welcome to our world matey, Plan9 ftw Great work with PGP, now I can work it into my email backend, thanks very muchly.
Hmm, I can't tell you what the "most proper" method is. I only can tell you how I handle it: My app is daemon and does its work within a goroutine. In my main I have a for/select loop that catches signals and reacts (performs cleanup) to them. You can take a look at the code here: https://github.com/jsz/mbpfand/blob/master/main.go#L100 I simply return from main on hup/quit etc, which will trigger the deferred "set speed to default". Without handling the signals my program would just get terminated and the deferred code wouldn't get executed. (I have found out that after getting a catchable termination signal channels seem to stop working.)
Awesome, this is certainly a perfect example for what I need. Really appreciate you taking the time to post.
There are also many other ['unofficially' supported Go text editors](http://go-lang.cat-v.org/text-editors/).
Go the next Java? God! I hope not! I like Go too much for that.
After writing for-loops to handle signals a few times, I ended up abstracting the signal handling functionality into a package: * [https://github.com/tav/ampify/blob/master/src/amp/runtime/runtime.go](https://github.com/tav/ampify/blob/master/src/amp/runtime/runtime.go) It provides `RegisterSignalHandler` which you can use to register a handler function for a specific signal, e.g. runtime.RegisterSignalHandler(signal.SIGUSR1, yourHandler) &amp;nbsp; The registered handler will then be called whenever the specified signal is received. This is all handled automatically by a goroutine that is started when the `runtime` package is initialised, so there's no need to listen to incoming signals — just focus on writing handlers for specific signals! &amp;nbsp; Also, by default, an `exitProcess` function is registered for `SIGINT` and `SIGTERM` which do "the right thing", i.e. call `os.Exit()`. They also call any handlers registered via `RegisterExitHandler`. Anyway, I hope the code/explanation was helpful. It's all public domain, so feel free to appropriate any of it if it proves useful. &amp;nbsp; 
Yea, the title of the post is rather silly, still the contents are quite interesting.
&gt; ... bleat .. generics .... shush
|Think about this. The code spawned 300,000 processes and retrieved the results in 2 seconds. That’s totally awesome! It most certainly did *not* spawn 300K processes :) Goroutine != process. But still cool. 
Right. By default they all run on one thread. You can export GOMAXPROCS=N to put them on different threads, but any setting there other than 1 made his program run ~2x slower for me, around 4 seconds. On the other hand, removing the goroutines and converting the program to a simple loop brings its runtime down to 0.06 seconds. The moral of the story is that goroutines cost too much for such fine-grained parallelism.
I remember watching a video interview with Rob Pike where he was discussing how we confuse the terms "parallelism" and "concurrency". I think the idea of Goroutines is to express "concurrency" in an elegant fashion, *not* to improve performance. 
Well, there's no reason they can't do both. I've just posted a new version of the program as a comment on blog that brings the runtime down to 0.02s when using 4 cores by limiting the number of goroutines used. I agree it's great to be able to express concurrency succinctly. I love goroutines for this. But it is important to be aware of the limitations of goroutines; while they're cheap, they're not free. As we've seen here, applying them naively gave a ~33x slowdown over non-concurrent code.
What is a bike/shed?
I don't suppose anyone could explain in simple terms just what this is all about?
"not as superlative" ??? &amp;#3232;\_&amp;#3232; 
I don't see generics as such a great feature gap since you can always use a preprocessor to expand the source code. C++'s templates, unlike the awful java generic, is just a compile-time trick after all.
Which makes separate compilation impossible and bloats code size. Thanks, but no thanks.
&gt; You can summarize the Go programming language in one word. Simple. LOL. Implement a polymorphic fold and get back to me when you are done.
What would you like this online class to look like, and what specifically would you like to learn? Web programming, algorithms, systems level programming, or something else? What format would work best for you?
http://bikeshed.org/
I have found that I learn most effectively when I have written information actually printed out; which I follow a teacher presenting the material; and I write down notes. That might sound old school, hell it probably is old school, that’s OK though, I am old. I need to read it, hear it, see it, and write it… and in this case compile and debug it. Screen casts are really helpful (and I wish there were more at the Go site). Codewalks also seem like a good idea but that section never got added to since the original creation. Honestly, I did not have much interest in web programming until I heard a more nuanced explanation of the “cloud” and heard Bruce Perens’ &amp; Eben Moglen’s ideas of personal ownership of the “cloud” infrastructure; and Go. Now that I am paying attention, I see that things get very complicated, very quickly and I am completely overwhelmed. I would be happy making a Google App Engine App, or re-implementing a BSD User-Land app, or iterating through some existing algorithm classes and using Go instead whatever the old presentation used. Or all of the above. I’ve been through most of the material available on the official Go site and, for me at least, it is suboptimal for education purposes for the following reasons. 1) Their primary purpose is introduction &amp; evangelism and I’m already introduced &amp; converted. So they all contain a lot of repetition. 2) They are geared to professional &amp; highly skilled developers. So many important details get glossed over. I am not a completely naive or unskilled developer, I have worked on teams with software developers for decades. Off &amp; on I’ve maintained ANSI C code on embedded devices. My problem is that I know the concepts but struggle to make the step to an original implementation. Due to time constraints in the presentation, this is what often gets skipped. 3) I suspect that some of the examples are somewhat contrived and are used simply to illustrate a particular capability of Go. Because everyone in the room is experienced (and currently actively developing and thinking in these way) they all understand &amp; appreciate the contrivance. I really need to clearly see things like “this is a simple problem, so we use this simple solution; while this is a complex problem, so we use this complex solution” 
Did you try irc://irc.freenode.org/#go-nuts or the golang mailing list ? 
I lurk there...
You could also try and skim read the Plan9 stuff http://9fans.net/ like the Plan9 papers etc. I know it's not directly Go related but it's where Denis &amp; Rob &amp; Russ (and I and Rog &amp; Uriel and many more Go people) came from so you might get more of a feel for the mindset. You can also find some of us in #plan9 For informal stuff see #cat-v but bring your flame proof suit, it can get hot :) 
Thanks, that's a valuable read. This link should be right in the reddit FAQ. Or maybe in every forum's FAQ.
I don't know Scala well enough but it seems that a few comments of this article make it look silly. Especially this one : &gt; If you only want to distribute the work on different threads/actors you could use Futures: &gt; import scala.actors.Futures._ &gt;// Create the 300'000 Actors which each compute one step &gt;val f = 0.to(300000).map{i =&gt; future(4.0 * (1 - (i % 2) * 2) / (2 * i + 1))} &gt;// Wait for all futures to finish and sum them up &gt;val pi = f.map{e =&gt; e()}.sum &gt;=&gt; pi = 3.14159598691202 Can a Scala programer confirm that this solution is valid ?
it's pure genius, the guy who wrote it is also a pure genius, i've met him a couple of times while he presented some software he wrote for a company i worked for. everyone who ever posts to a mailing list should have read it, the golang-nuts forum is no exception. i'm impressed with some of the core contributors to this language, the ones who have been answering the same questions, or reposting links to the answer non-stop for a year and a half now.. especially *search the forum before posting* is something which should be understood by all members of a community. at first the golang-nuts was kind of interesting with debates over language features to include (or not), but then it happened there as well. it became a mix of stackoverflow and *my version of so-and-so library is better then your version of so-and-so library*, which is pretty pointless, since the author typically seems to favour his own library ☺, and who cares anyway? but yeah, it's certainly a worthwhile read, and a website dedicated to an email says something about the quality of the email. 
It seems like Minecraft would be a great world for building bots; I find the plethora of servers and clients deeply confusing. Can someone provide an introduction to the various options and, possible, the Minecraft protocol write-up?
This is a great project and I wish I could contribute more than just praising it. I hope it goes well because I quit minecraft due to the server software taking too much resources to run locally and the client was close to that. 
This is a pretty good writeup. I am in process of porting several thousand lines of code from java to go, and extending the functionality as the port continues and It has been very straightforward, not quite as easy as going from c to go, but close enough for comfort. One of the harder mental blocks for me was getting my mind around how to effectively use interfaces properly and in place of abstract classes.
&gt; You can feed that into gpg -c and decrypt with the passphrase golang if you like. This of course must be *gpg -d* for decrypt.
Seconded. I find it's easier to understand the idioms of a programming language if you understand the mindset and culture that it came from. A lot of the "why"'s in Go can be explained by reading up on Plan 9. Heck, everything from the compiler/linker/libc, to naming conventions, to mascot, to style &amp; "terseness" of written code, to the deafening silence when you ask why every binary is statically linked...it's all Plan 9. I see Go as a nefarious plan to bring back the ideas of Plan 9/Limbo that didn't get wide acceptance before :) 
And, of course, the bedrock of the whole thing is CSP http://en.wikipedia.org/wiki/Communicating_sequential_processes The actual progeny is : Squeak -&gt; Newsqueak -&gt; Alef -&gt; Limbo -&gt; Go 
First we have: &gt; ***Speed and memory efficiency*** &gt;I haven’t measured. Generally speaking, Go is compiled to assembly code and its data structures don’t suffer Python’s terrible per-object overhead, so it should be more efficient in both speed and memory usage. Then we conclude: &gt; ***Conclusion*** &gt;Overall, the experience was positive and I would seriously consider using Go for writing server side of web applications as ***it provides a right balance between speed and memory efficiency*** of the running code (much closer to C than to e.g. Python) and speed of development (much closer to Python than to C). If you aren't going to measure something, you can't really use it in your conclusions. That said, Go probably (but not necessary) smoked Python but you need the numbers to back up this assertion. 
run the command godoc -http=:8080 you can then access it from http://localhost:8080/ This is an even better option as you get the actual documentation for your installation which is likely not the same as on golang.org EDIT: ofcourse you can also just use the godoc command directly godoc http Client see http://golang.org/cmd/godoc/
RTFM
it was a circular joke, the answer is already above ^^
I wonder if a clever runtime could catch onto the fact that this allocation can be done once and cached. Maybe not the first few times, but if it sees that some set of allocations is done together, used, cleaned, and done again the same way, it might decide to put them aside for the next time.
awesome profiling.
Thank you so much! I really appreciate it. 
picking up the ladies ***B-D*** **** in all honesty, i think it's a very valuable statically typed language that leaves with you the same duck-type feeling of python. It's a great bridge between interpreted languages and super statically-typed languages like C/C++/Java. I believe that the more paradigms that you know and intuitively understand, the better off you are. As far as direct comparisons, there are certain tasks which a "system level" language will be faster. Not all situations. As VM tech becomes smarter, the theory is, they will surpass compiled languages because they can make more intelligent optimizations at runtime than compile time. We haven't gotten there yet for all situations. ***edit:*** duck/duct
&gt; As far as direct comparisons, ... In general, how does Go currently compare to Python, performance-wise? 
I'm glad I'm not the only one... Mid way through my second read I found myself wondering if there was a version in crayon available.
I have heard Rob Pike make vague assertions like faster than python slower than C. Also having just read the post here about optimizing the code used in some benchmark paper, I would be extremely reticent to get too attached to any benchmarking claims.
See [here](http://shootout.alioth.debian.org/u64/benchmark.php?test=all&amp;lang=go&amp;lang2=python3). tl;dr: between 5x and 50x faster for most things, and there are still many low hanging fruit optimizations for the Go compilers that have not been picked yet. (Note that the regexp benchmark really compares the regexp engine written in C that python uses which has decades of optimizations, with a toy-implementation of regexps written in Go, a must faster regexp engine for Go is in the works by no other than Russ Cox).
While I've never done any threading/concurrency/parallelism in python, I can't imagine it being as simple and elegant as in go.
Threading in python is well known for being badly broken.
Heh. I'll remember never to touch it then
My friends and I hang on an IRC channel and we used to have a Python bot that would log the channel, log the URLs we pasted, etc. However, due to a problem on the hosting machine, we don't have that bot anymore. We also found that it was too heavy (you needed to authenticate, it had a LOT of commands, etc.) for our needs, so I've been meaning to write a new bot from scratch for a while as a hobby project. When it came time to choose a language, I went with Go. Here's why I didn't pick other languages: OCaml: very cool language, very solid and I like it a lot, but it has no built-in support for Unicode and it doesn't have a nice concurrency programming model; either fork or os threads. Scala: another very cool language, and the actor model for concurrency was very attractive for my needs. However I needed an SQLite database and I couldn't find a simple binding, I had to go through JDBC. Also, Scala requires the JVM to be installed plus a big jar with all the scala libraries. I wanted a simple-to-deploy program, so I left Scala out. Python: I don't really fancy dynamic typing anymore and it doesn't do concurrency too well. So I went with Go. I don't think it's the best language in the world, I think that its authors ignored a lot important PL research, but it supports Unicode, its concurrency model allows me to spawn a new goroutine for every incoming message, it does static linking (which makes the object program a single executable file). So this is what I'll be using.
&gt; its authors ignored a lot important PL research Many of us are quite happy that they ignored all that "important" research and instead kept the language simple, clean and specially ***useful***.
I don't see how having generics or sum types makes a language less useful.
Making the language more complicated, and hurting what makes the language great makes it less useful. All features are a tradeoff, to pretend they are not [leads to C++](http://harmful.cat-v.org/software/c++/). Yes, some things would be nice, if and when a way to make the tradeoff worth it is found. Note that this is completely different from the silly claim that "Go ignores PL research", Go simply is carefully selective in what and *how* it adopts features. Also simply complaining about Go failing to tick one box in a feature checklist misses the point of how those features are so badly needed in other languages because they lack some of the characteristics that make Go great (eg., Go's interfaces obviate many of the common uses of generics in other languages, this doesn't mean that generics are useless in Go, but that they are not as useful or essential as in other languages.)
&gt; I think that its authors ignored a lot [of] important PL research Just because you don't go with someone's suggestion it doesn't necessarily mean you are ignoring it.
Can't wait for the first benchmarks ... Although, my expectation would be higher if that were Henry Spencer in the author field...
I'm a huge fan of Henry Spencer (both of his code and his many very interesting posts), but this might change your mind: http://swtch.com/~rsc/regexp/regexp1.html
Thanks, I knew that article before. It's a nice read but if you're a huge fan of him, you surely know his hybrid, unicode capable regex engine which is included in TCL. It's highly praised and (as long as it was included) bet everything in the benchmark game (regex-dna). That article, though very nice, seems to completely ignore that.
&gt; bet everything in the benchmark game I would never bet much on a single arbitrary micro-benchmark.
Well, that's right, of course. Yet, the regex-dna is much more "real-world" than the "pathological regexes" which are the main argument of the article you linked...
Yes. It's hard to get much performance gain from Python threads. The `multiprocessing` library is helpful however. I heartily agree with what @uriel said above about trade-offs. Everything has pros and cons. The art of coding is to choose the right trade-offs for your application. Most popular languages have useful trade-offs in some areas. In my opinion, Go competes with -- and dominates -- Perl. Both Python and Ruby are very useful languages for many tasks. Actually, Perl is still useful in its original domain: as a replacement for sed/awk/grep on the command-line. C still has plenty of uses as well. For the OP, Python has these trade-offs vs. Go: * +Faster coding (a little) * +Larger installed library * +Easy OOP (but consider Ruby if you need this) * +Easy portability * +Easy debugging * -weak concurrency * -no static type-checking * -kinda slow I'd use Go for mission-critical systems programming, and Python for glue-logic and command-line utilities. Golang's `upload.py` (for code reviews) is a good example of where Python is strong: It will run anywhere; it's fast enough; and if you have a problem with it, you can debug it yourself.
Also in http://www.reddit.com/r/programming/comments/iedca/google_go_strikes_back_with_c_bakeoff/
meh, reading programming posts on el Reg is like the financial advice in The Sun. The comments are pure drivel too. My Reg t-shirt just got slighty more shameful. What is a Goolger anyway ? 
A quick search on github points to https://github.com/silas/bcrypt.go It seems to be a cgo binding for OpenBSD bcrypt, but the author recommends you don't use it because of security concern.
I suggest you alsa make yourself familiar with [pbkdf#2](http://en.wikipedia.org/wiki/PBKDF2) which basically solves the same problem, and is documented and well defined. :)
The Go standard library uses scripts (shell, Perl or Python) to generate such files. For example, the syscall implementation files are autogenerated by a shell script.
Any scripting language ought to work okay for that. Here-documents will make you happy; you want to be able to write something like cat &lt;&lt;EOF for i := 0; i &lt; len(s); i++ { s[i] = upcase_char(s[i]) } EOF instead of something like fmt.Printf("for i := 0; i &lt; len(s); i++ {\n") fmt.Printf(" s[i] = upcase_char(s[i])\n") fmt.Printf("}\n") If you're not sure how to get started, you can start by writing a program that emits a short version of your desired program as a single here-document, then factor out duplication as you add to it. If you really feel the need for text-macro-ey goodness, there's always m4. But I swear you'll regret it.
Using the C preprocessor is a valid option. cpp IS a standalone program that you can just call independent of the C/C++ compiler. 
I'm confused. What are you trying to do? What functionality are you trying to enable? I'm wondering if there is a different or more "go-y" way of doing it.
It does look like I'll have to do that, yes.
That's not exactly what I meant. I think you're thinking I'm trying to make a language-to-Go translator+compiler, but that's not the case. It's for a text mud engine that interprets code input at run time by users. e.g: say upcase(hello) -&gt; You say, "HELLO". The FUNCTION(...) macro serves two purposes: It gives all functions for the interpreter the same signature (so the interpreter can pass 'em all the same args), and it lets me grep for FUNCTION(...) strings with another script to build the lookup table for the interpreter. A sorta-third purpose: It's a clear indication that "This is for the interpreted language to use, not for the Go programmer to use."
It does look like CPP (Or even a quick sed s/FUNCTION/.../) is the simplest real solution at this point. I'd have preferred a more Go-y solution because: 1) While in this case the FUNCTION macro is replaced with a single line, it can throw off the line numbers for 6g, and as I understand it from searching the Go newsgroups, there's no yet defined standard for //linenum filename 2) In the event that other Go-ers want to participate, having something commonly recognized in Go would be nicer than a readme explaining how FUNCTION(...) { ... } works.
More in-depth answers about what I'm trying to do above. I'm looking for a Go-y way to do this, too! =).
No, I understood what you meant. But you want a source language to program in that allows you to factor out the duplication in a way that Go, apparently, does not. (You might be able to use Go's native facilities for this, though.) You could think of "C preprocessor" as a limited "programming language" in which the usual meaning of a line like f(x(3, y)); is fmt.Printf("f(x(3, y));") but where you have the freedom to have it mean something like fmt.Printf(f("x(3, y)") + ";") if you like. From that angle, what you're doing with the C preprocessor is writing a program (in a weak language) that writes your program. About "using Go's native facilities": instead of generating the boilerplate with a script, could you write code to make something like this work? define_function("upcase", func(args Args) { s := args.args[0] var buf [len(s)]byte for i := 0; i &lt; len(s); i++ { buf[i] = upcase_char(s[i]) } args.returnval = buf }) Your `define_function` could populate the lookup table for the interpreter. Edit: I'm pretty sure that the above isn't the right way to write the code for the upcase function in Golang, but the interface provided by `define_function` seems reasonable.
Ah, I see what you mean now. Yes, it would be a language spitting out a Go program, but what I'm looking for here is an ideal way to do it without mangling Go too much, and still be able to keep Go syntax. If I make gen_string_funs.pl that spits out the upcase function, I'd be writing Go in perl quotes - Having to deal with extra backslashes, lack of syntax highlighting, etc. That define_function is closer to what I'm looking for, but it would basically require linkage into the file, e.g: // string_funs.go func init_string_funs() { define_function("upcase", func(args []string, icontext itp.InterpreterContext, user UserInfo, . . .) { }); } So in essence, the define_function bit only solves the "generating a table" bit, and keeps the "Changing 300 lines if I add a new parameter" issue.
TLDR : * Rule 1 : Stick to your initial choice : *release* or *weekly* * Rule 2 : If you're on *weekly*, things will break (but don't go to *release* : rule 1 forbids it) 
TIL: //line filename.go:123 is recognized by 6g. So for now, I'm using cpp, passed through a quick script to convert # 123 "foo.c" to //line foo.c:123 Also TIL: multi-line #defines just have the newlines removed. So any Go code in #defines need explicit ;s.
Found thanks to this discussion: http://comments.gmane.org/gmane.comp.lang.go.general/32498 Also make sure you have the latest version from the branch *default*, not release: cd go/src hg pull hg update default Else you might run into some bugs introduced in latest Xcode 4 with gcc4.2.
&gt; Rule 1 : Stick to your initial choice : release or weekly Or `tip` ;) (Although switching between weekly and tip is usually painless.)
&gt; I'd be writing Go in perl quotes - Having to deal with extra backslashes, lack of syntax highlighting, etc. That's why you want a language with here-documents, such as Perl. Or you can use gcc -E or m4, but I promise you'll regret it. A way to avoid changing 300 lines if you add a new parameter is to put the parameters into a single object, as I implicitly suggested in my comment. You don't even have to put all the parameters in there; if you're typing `args.args` or `a.args` so often that it becomes a pain, you can put all the parameters *except args* into the object.
As I mentioned in a different comment's thread, I ended up using the C Preprocessor, then just replacing # linenum "filename" with Go-compatible //line filename:linenum - It works just fine. I've tweaked my Makefile and written a script that basically amounts to "cpp infile.go | s@^# (\d+) "(.*)"@//line $2:$1@ | 6g /dev/stdin" - but done as a script so it can capture and pass -I args to both cpp and 6g, as well as passing the rest of the args to 6g (-c, -o, etc) It doesn't feel Go-y, and I'm distracted with the thought of writing something that feels closer to Go than to C. (Lisp macros -&gt; Go macros, maybe?). The issue then becomes how to make said macros available across multiple files.
Am I the only one that [expected something to do with this](http://en.wikipedia.org/wiki/Gopher_(protocol%29) and that got disappointed?
In the Go subreddit? Probably. Especially so in 2011. I ran one of the few existing gopher sites for a while, but I took it down when support for the protocol was removed from Firefox.
All you are doing is creating a map between a set of functions and their textual name, and making them have the same function signature. There's nothing particularly interesting about the function name. It seems like you could do this with a map: type FuncType func(int, []string) func fun_upcase(args int, vars []string) { fmt.Print(strings.ToUpper(vars[0])) } func main() { funclist := map[string]FuncType{ "foo": fun_upcase, } funclist["foo"](1, []string{"foo"}) }
Yes, a map is what I'm using to map "upcase" to fun_upcase. What I'm looking for a Go-y way to do is: 1) to ensure that all the fun_* have the same function signature - even if I change or add parameters at some time in the future. 2) Have a string name -&gt; fun_name mapping that is ideally close to the function location. Sure, I can try something like putting meta-info next to the function in the comments. 3) A grep to find all instances of it and auto-generate the 'funclist' map. Maintaining the list separately would be error prone.
Reading the comments in the cross post to /r/programming was a bit of an eye opener, I didn't realize there was so much seemingly blind hatred for the language. Not to mention personal attacks on the developers. o.O
I'd love to have it in Brazil :(
I'm interested to hear whether my prediction that you'll regret it eventually comes true.
The reason I've posted this here is because I think a Go framework can replace Ruby-on-Rails, or even PHP. I haven't outlined the entire idea in the blog because it's a few layers. The `print` statements are to keep the example simple. The idea would be to think of the templates as code-generation description files, similar to lex/yacc. To deploy a Go app, you would first compile the templates into .go files, and then compile all Go files together, including those from the templates. It would all be automatic. People are already starting to use Ocaml for web frameworks, and I really think Go is a better choice, partly because of the value of embedded code in templates. I envision a Go-Rails front-end which would auto-generate unit-tests, templates, and Go code for RESTful routing. It would be much faster and safer than any Ruby, Perl, or Python web engine. Mango could be the foundation.
Another advantage is that the choice of template-engine becomes very flexible, since it would be a completely separate executable. For example, some people prefer Haml to Erb. In fact, one drawback of Haml is that it's a little slower than Erb, but as a pre-deployment step that small difference would not matter. And if template-inversion is done only when a template is altered, the runtime impact during development (when unit-tests are run repeatedly) would be insignificant.
(Reflection won't work for the solution--deleted previous post) package main import ( "fmt" "strings" ) type FuncType func([]string) var builtin = map[string]FuncType{ "tolower": func(args []string) { fmt.Println(strings.ToLower(args[0])) }, "toupper": func(args []string) { fmt.Println(strings.ToUpper(args[0])) }, } func main() { builtin["tolower"]([]string{"FooBar"}) builtin["toupper"]([]string{"FooBar"}) } I believe that this code will meet your stated requirements: &gt; 1) Ensure that all the fun_* have the same function signature The FuncType type defines the method signature. If you attempt to add a function to the map that doesn't have the proper type signature, such as: builtin = .... { .... "bad": func(args []int) { fmt.Println(args[0]) }, } You will get the following error at compile time: cannot use func literal (type func(args []int)) as type FuncType in map value &gt; 2) Have a string name -&gt; fun_name mapping that is ideally close to the function location The name and the definition of the function are just as close as they are in the existing C code, and you can't add a function without adding the name. &gt; 3) A grep to find all instances of it and auto-generate the 'funclist' map. Not needed since the compiler builds the map for you.
the anonymous nature of this beast generates some offensive remarks language debates are useless IMO when choices are present, i.e. Javascript is open for debate. :)
I love how the most self righteous always like to cite "formal language theory". Oh, what an enigmatic beast!
It's because of this kind of thing that I think they should replace new(T) with make(\*T). Not that the author's arguments are valid: they show a clear misunderstanding of key concepts. However, I think the confusion arises from the fact that new(T) doesn't look like it involves pointers, and *does* look like it should call a constructor, based on other languages. make(\*T) makes it clear you are making a pointer, and there's no questioning the distinction between it and make(T). Of course this is merely cosmetic, but it makes more sense from the language perspective, even though it doesn't from the implementation perspective.
Actually, this is how many template engines work. For example, Jinja2 (template engine for python) generates Python AST and compiles it to real function when you load a template.
~~Of course, for Python there is not much advantage, if any.~~ Do you know whether Microsoft MVC works this way? Many people oppose embedding code into templates. I sympathize with that sentiment, but I'm trying to be realistic. People use Rails and PHP because they're so ****ing easy to use. EDIT: As @russross says, Python does have a speed-up from this, although I don't know whether it's from pre-compilation or not having to load the template file. Perl's [Template Toolkit](http://template-toolkit.org/about.html) pre-compiles embedded code too. And of course, [JSP](http://en.wikipedia.org/wiki/JavaServer_Pages) works this way too.
No, I don't know about ASP.NET MVC. What I mean is that indeed you could just generate code from templates to have them run faster instead of doing that in runtime.
All the fastest Python template systems work this way. I suspect there is an advantage, or else it is a grand coincidence.
Just to add: using a named struct type to capture your arguments would prevent you from having to change every function signature in the list. Of course, you will have to change any functions that rely(-ied) on the changed parameters, regardless of how you do it. I really think you should do this in Go rather than using a preprocessor.
Corrected. BTW, I like your [markdown parser](http://www.reddit.com/r/golang/comments/hmmod/black_friday_a_new_fast_markdown_processor_in).
Why does this use FUSE? Security? Speed?
I hate that I can't scroll the article with my cursor keys. on the "omg it sucks" part: use another language if go is not the tool for you. I don't need esoteric constructs in my system programming language. for that I have my 800mb haskell runtime. tl;dr - another FP fanboy crying because people still dare to use and create imperative languages.
every time i read a good, informed article on go, i can't help but think it's sad they went for a better c rather than a closer-to-the-metal ml :(
&gt; It's important to make a better C. Believe me - I've been programming in C for **the last month**. *laughs* I mean, the language is clearly not aimed at him, or anyone else who shares his background and perspective. And while I appreciate his language/electricity metaphor, I'm not convinced the disciplines are as closely related as he claims.
A closer-to-the-metal ml wouldn't have a user base. If you want to create a language that people are actually going to use in large enough number to be relevant you can't make it functional. 
&gt;And the "comma OK" pattern? Isn't that a broken version of the maybe type? No, it's a working version of the Either monad. Composably, either your computation runs to the end or it returns the first exception.
Jonathan Wright's response in that page regarding 'monolithic'-languages vs. 'micro'-languages is very insightful.
well, say something like bitc but with google's weight thrown behind it. it might have worked.
a functional language coming from the Go developers would be kind of strange given their background(decades of operating systems and C like languages) and I would go so far as to say Thompson and Pike writing a functional language would be a complete disaster. 
I don't know that he was saying that he's *only* been programming in C for the last month--just that he's had to program a great deal in C for the last month. Like if I said "I've been eating Spaghetti for the last month"--you wouldn't assume that I'd never eaten spaghetti before.
"If you don't like this language you can **GIT OUT**"? Whatever happened to wanting to make a positive effect on the tools you use? He makes a few fair points on the restrictive nature of hash keys and make. You shouldn't dismiss him just because he comes from a different background than you.
Thanks. Sadly because I added the comment late I doubt many will see it. :-)
no, i'm not telling him to get out. i'm just saying he should use the right tool. if you try to cram every paradigm there is into a language the result will be something like c++.
like buzz and wave worked out because of google's weight? FP is hyped in academia - but most practical developers can't get warm with it.
Clearly the case when you look at his CV - he marks C experience from 1991 to 2001.
Hi, uriel. I was going to make a comment about you being the white-knight of Go, though that term has negative connotations that I don't mean to imply at all. A lot of response to queries about go or go features include "read the spec", which is fine. Go is one of the only specs I've attempt to wrap my head around. I'm used to higher level languages where implementation details are nearly insignificant. Much of the make/new discussion I've read on the mailing list seems to focus on the idea of NOT hiding things from the developer for "magic" purposes. I'm curious how this alines with the discussion that I read on HN and the original post that indictes the Go compiler and runtime of having "magical" access that can't be reached from Go itself. What sort of limitations are there surrounding this, and are they by design (aka, permanent and unlikely to be exposed to developers) ?
The first response here regarding 'micro' vs. 'monolithic' languages is quite relevant: http://acooke.org/cute/GoRocksHow0.html And I think you are confusing two different kinds of 'magic', make() and the types that require it are special, but it is not particularly 'magical'. 
Though I must say, I'd prefer it if it were determined by a keyword (like `x, ok := try v.(int)`). Having a context dependent number of return values adds some odd quirks to the language (you can't pass the multivalued form directly to a function, for one), and limits the possibility of some useful potential features, like multivalued channels.
Anything a system can do that code hosted by that system cannot can be called magical. Without modifying the Go runtime, I cannot write new types that behave like the built-in types, so they are 'magical.' In language design, special and magical are the same thing. I'm not saying that having special types is necessarily a problem. That's an entirely different discussion. :)
Multiple return values could have been made first class as tuples, and destructured with pattern matching. Then `x,ok` would simply be an example of a tuple as an lvalue in a pattern match. Alas, they didn't do that.
As I said, I think he is confusing two somewhat (perhaps subtly) different meanings for 'magic'. &gt; Without modifying the Go runtime, I cannot write new types that behave like the built-in types, so they are 'magical.' You also can not write new keywords, operators, control structures, and a thousand other things, that doesn't make, say, `for` particularly *magical*, 'technically' yes, but it is simply is another part of the language.
but the trend is for the number and variety of those magical things to decrease. an obvious example is "print" in python - one big change from python 2 to 3 was making print like an ordinary function you or i could define, rather than a magical statement like "for". and, as i described, there are ways to provide the user with the power to add control structures (via coroutines). and many languages allow users to define new operators, etc. etc. but what's important is not those particular examples. what is important is *why* this is happening - because people are better understanding the theory behind languages. when you do that, and see the underlying unification, you don't *need* to hide so much away. another way of saying the same thing is that, for some given complexity of the language, you can empower your users more. of course, you can take this too far, as the reply said. this is really apparent in scheme, where the language *only* provided the scaffolding, which meant that everyone invented their own versions of OO, of exceptions, etc, and it was a mess. but that doesn't argue against the general point - it only suggests that once you have the basic, general features in place you should also provide some good defaults. the idea isn't to force people to re-implement "for", but to give them the ability to implement some cool new control that no-one has thought of yet...
Exceptions enhance readabillity... works great in java and c#.. Is there really any good advantages for the user to not having exceptions 
Exceptions have the potential to enhance readability at the cost of explicit, fine-grained control flow. Go allows for this mechanism with panic/recover, but often handling an error condition immediately and explicitly is both the right thing to do *and* more readable.
Not necessarily improving readability. Without exceptions, you can be sure your code executes in the predictable manner line by line. But with exceptions, you have to keep in mind, with every line you write, what if this method/function I'm calling is going to throw an exception? Is it OK if some code gets skipped before a prior line threw an exception? When you start adding try/catch/finally, the code can be damn hard to read.
&gt; Exceptions enhance readabillity.. About as much as COMEFROM enhances readability. Exceptions are a hideous, verbose and clumsy way to handle errors, and they make following control flow close to impossible. Just say no.
You can focus on the happy paths first and then deal with the exceptional paths. Similar errors errors can be dealt with the same way without repeating the same error handling code.
You could have try catch at any fine grained level you want ex around each method call.. But who would want error handling after each and every method call.. Not useful
&gt; You can focus on the happy paths first and then deal with the exceptional paths. This is a great way to make sure errors are never handled properly. One more reason why exceptions suck.
That is not true.. When you focus on the error paths you can really make sure that it is done correctly. If you have error handling after each call then chances are that you will just copy n paste. 
&gt; But who would want error handling after each and every method call.. Not useful It's useful if you want to handle each potential error in a meaningful way. Clearly you don't consider this an important task.
With exceptions i can do that if i want. Since exception handling supports multiple catch blocks then i have exact contol over specific exception types and how they are handled. And if there is a specific case i could put a try catch around a specific method call. 
&gt; And if there is a specific case i could put a try catch around a specific method call. And each time you do that, guaranteeing predictable control flow, your code becomes far less readable than the equivalent Go code.
You are absolutely correct. But the only time that this can occur is when the following happens: * Two or more methods throws the same kind of exception (ex IOException) AND * For some reason i want to handle them differently How often does this happen for you? Normally one type of exception is handled the same way. So instead of : try { someCall(); } catch(IOException e) { // error handling } try { anotherCallCall(); } catch(IOException e) { // different error handling } becomes: try { someCall() anotherCallCall(); } catch(IOException e) { // same error handling for this type of exception }
&gt; // same error handling for this type of exception That's what you're not getting. Treating errors from several different calls regardless of control flow, exactly the same way, is not something everybody thinks is a fine-and-dandy idea, *especially* in a systems programming language.
If you have a fine grained exception hierarchy this never becomes a problem but if you only throw a primitive generic exception like go's os.Error i can see that this will become a problem. With exceptions you normally have a nice hierarchy so that you would expect exceptions of the same type to be handled the same way. 
&gt; but if you only throw a primitive generic exception like go's os.Error i can see that this will become a problem aaaaand now it's clear you didn't even read the article and may never have even used Go. `os.Error` is an interface.
To avoid confusing people, we're no longer calling the weeklies "releases". They're now "weekly snapshot". We'll only use the word "release" for the ~monthly tags (of a good recent-ish weekly)
This particular subthread is NOT about the article! Please follow it to the top and you can see that it originates from my question about any advantages of not having exceptions. I have used GO .. written at least a thousand lines or so and read about it alot. I was wrong about the os.Error but the point is still clear if you do not have a fine grained exception hierarchy you will have a problem when dealing with exceptions in different ways if you have exception handling. So if you have multiple calls that all throws one type chances are that you would handle them in the same catch block.
The concurrency models are always improving. If you are using Python2 then you can always use Twisted. I've have great success with parallelizing simple problems.
In Go, errors are as fine grained as you want them to be. They don't need to be hierarchical, though they can be, if you want (though, in the context of Go, I think "categorial" would be a better term). When a code path is truly exceptional (i.e. *not* EOF, file not found, or "incorrect user input", which can totally be expected to happen), then you can use defer/panic/recover to pull it out. You can also pull out repetitive error checking within your package, and write a catch function for handling the errors.
If a system can be composed of idempotent or commutative tasks that can fail and restart cleanly, top level exception handling is great. But when dealing with networks, filesystems, or communication protocols there are often resources that need finer-grained error handling. Top level error handling sufficient to return a system to a correct state is often not possible. There are partially read or written streams that need protocol-level handling, opened files that must be closed, db transactions that need to be rolled back... Catching these errors with exceptions in my experience requires RAII to handle the fine grained work. This implies a very OO design. Adding exceptions to a language as the main error handling method means introducing destructors, RAII and object design, in my experience. I'd welcome learning about a counter-example, though. On a tangent, I wish we didn't use the word "error" so much .. most errors aren't really errors in the sense of being wrong or incorrect. They're only errors in the sense that we didn't get what we wanted - programmers being like 2 year olds when it comes to desiring the happy path :-) I can't really think of a good replacement word, though.
Interesting article. Some comments: - With your hashset impl, you check for containment with "_, exists = this.data[value]". Since you have a map of bools, and a miss will give the zero-value for a bool (false), you could just say "exists = this.data[value]". - It might have been interesting to try a straight lookup table. With the current go implementations, the size of a slice is limited to 2^32-1, so your larger benchmarks wouldn't have worked (and even with the largest, that's a lot of memory), but for the smaller sizes this would be quite fast :) Showing the speed/space tradeoff would have been interesting. - The remove-duplicates process can happen in n log n time, where you used an algorithm that ran in n^2.
I hope it works on Wine ! (maht btw, I said some shit I shouldn't have &amp; deleted myself again :)
You can easily cross-compile it under another OS (I am using Darwin/amd64). You just have to rebuild the compiler and standard library once with GOOS=windows, GOARCH=386 and cgo disabled (DISABLE_CGO=1 iirc). As for running, I heard it works on Wine, though I never actually tried.
The specific explanation of the problem of implicit integer conversion in the following mail may be more interesting than Rob's general stance.
This looks awesome; I think I'll actually use it for my current project.
Not be confused with SkyOS' networking stack SkyNet.
&gt; Each process in SkyNet receives its configuration from a centralized configuration repository OK. So here's the "Kill Skynet" button ?
If I'm not mistaken, that conf might be provided by doozer server, which in itself is a highly available distributed storage. Still, I'm sure there's a weak point, heh.
If I want to learn about the internals I would go the following path: C, Assembler then Go. 
what do you mean by internals? 
Heh, I had to [look up](http://en.wikipedia.org/wiki/Trabant) Trabant-I heard a story from my German friends about families in the East German block who had to wait ten years for their car... I wonder if the story was referring to Trabant! I like this answer because like everyone I have a bit of a lazy streak - if I don't have to learn C when why should I? I'm a number of units into CarlHprogramming's lessons and I learned a little. A lot of programming concepts are already familiar to me but I learned about pointers - which I had heard of but never looked into - and a neat little infoid that the numeral [1 0] converts to the actual base number of whatever number system you're using (ie in hex 10 = 16(base10)). I guess I never really thought about that. You really think I won't miss much by skipping C? 
heh so I'm a guinea pig eh? *\*squeak squeak\**
the inside of your computer
Better still, learn computer programming. 
One thing that's missing from OP is what he knows already -- whether he knows some other languages or whether he's just learning how to program. But starting with C is simply a bad idea. I've taught programming at all levels, and the number of hoops and trip-wires in C make it far less conducive to learning to program than a higher level programming language. I've not thought much about starting with Go. My advice has been starting with Ruby or Python. There's enough to learn about programming without having to manage memory, use pointers, etc., and higher level languages allow you to focus on the more fundamental concepts of programming.
that's a good point, I have studied other languages from good ol BASIC on my own on an XT to fortran at high school, a little RPG, PHP, MYSQL, Java and Javascript. But as they say, jack of all trades, master of none. theory of boolean logic operators I understand, as well as the basics of loops, arrays, functions and basic architecture of a program. but I've never gone into great detail with any of them - just enough for the task at hand and if I read source I can generally figure out what's going on. but when it comes to creating full programs I really need to put a lot of effort in.
but what if I don't really want to go the internals route? I won't be programming operating systems and contributing to the next flavour of linux... 
to be quick, I'll copy-pasta my answer to Brocklee: &gt;that's a good point, I have studied other languages from good ol BASIC on my own on an XT to fortran at high school, a little RPG, PHP, MYSQL, Java and Javascript. &gt;But as they say, jack of all trades, master of none. &gt;theory of boolean logic operators I understand, as well as the basics of loops, arrays, functions and basic architecture of a program. &gt;but I've never gone into great detail with any of them - just enough for the task at hand and if I read source I can generally figure out what's going on. but when it comes to creating full programs I really need to put a lot of effort in. I think that's a fair background to attempt learning C and Go, don't you?
I guess but what will you do with the rest of the weekend ?
Same thing I do [every weekend...](http://cheekycannibal.files.wordpress.com/2011/01/20071001-pinky20brain.gif)
Choose your own path but why are you asking for advice about which systems programming language to learn if you don't want to do systems programming ? 
Well, whatever you choose, don't catch GNU brain damage. If you want to learn C, learn from the masters. On Lunix systems that means installing Plan 9 from User Space http://swtch.com/plan9port/ and using Ken C. The reason Go exists is because after Plan 9 the team found themselves in the Linux / OSX wastelands and it was either fight the natives or found a new religion.
Well, looking into it I thought that C and Go were able to program more than "simply" OSes. I'd like to desktop apps and AppEngine apps. If I'm looking at the wrong language, please tell me. I do know that there are better higher-level programming languages for desktop apps, and Java for programming the AppEngine but I can see Go filling both those needs. Am I wrong?
wow, that's deep. I know a guy that would really tear that apart!
&gt; when it comes to creating full programs we really need to put a lot of effort in. FTFY
First of all, you will probably not learn c, nor Go, very well unless you have some sort of problem -- a project one might say -- which needs solving. This is how I learned to program: Christmas 2009 I decided I wanted to learn C. I knew some Java on beforehand, but now I wanted to learn the basics. So I went through a decent amount of the Programming Paradigm(http://www.youtube.com/watch?v=Ps8jOj7diA0) lectures on Youtube by Jerry Cain. They are excellent. After a month passed I stopped using C and I can't say I learned it thoroughly. There were no reasons for me to use C at the point and I had no problems which were required to be solved with C. I also began to looking at Go, since it was in the wind at the time, but I never got to use it more than write a few algorithms as exercise. I did however learn Python the same winter as it gave me the opportunity to get a job as a web developer. During the summer 2010 Python was the language knew the best while Go and C were slightly more forgotten as the days went by. Python became my go to language as it was the most sensible language to solve the problems I had at the point in time. On several occations I tried to pickup both Go and C again, but after a night I lost motivation since I had no where to go with the languages. They did not require me and I had no use for them. Today, in the summer of 2011 I know both Go, C and Python. The only reason is because I during the last year started a couple projects which required me to use both languages, respectivly. I wrote a Redis client in Go and I wrote a C for a microprocessor(Atmel) as well as some graphics code. The moral of the story is that no matter how much you might want to learn either language I don't think you'll be able to enjoy Go or C without using the languages to solve real problems in your life. Obviously my advice sucks somewhat. I usually don't have any problems or projects which need solving and still try to learn a bunch of things simply because I want to learn it. Like learning c in the first place will definitely make you better at several things which are utterly useful. Mostly it will give you a good understand of several basic concepts which you can apply to any programming language. And I would argue that C is the best language to learn about memory and data structures. I would also argue that learning C before Go is recommended in general, but I'll leave that for a different post :p
I have a pet project (vpn, networking, sockets, ui) that I've used to teach myself C++, Java and now Go. By far, it's been most pleasant to write in Go, and the mistakes I've made so far have been because I'm programming with a C-mindset. Also, this has been the best experience porting to Windows. I gave up in frustration using C++, WinPcap and Autotools in Widnows in the past... and I've already got my project building in all three major OSes with the exact same codebase and Go utilities and NO dependencies on cygwin. I'm quite ecstatic. BTW, thanks again to those that helped me get a pcap wrapper working with cgo.
&gt;I would also argue that learning C before Go is recommended in general, but I'll leave that for a different post :p no, no - argue away! I have in mind a project that will use app engine ideally, with a web interface. I was looking into using gwt and developing it through java/eclipse, and that may still be the way to go, if at least for the gui. I'm interested in Go simply because of the backend functionality on google app engine, and if I were to look into developing a desktop app.
&gt; I wonder if the story was referring to Trabant! Most certainly. The Trabant was the only car in east germany you could get as a normal person. Well, you could order it. Getting one was a different thing.
If you look closly at Go many concepts are from C. Knowing C will make it much easier for you to (1) learn the language (2) understand why things are the way they are in Go. The second point is espcially important as it applies to the first point as well. Lets say you see this code in a go program: data := make([]byte, len) You then lookup the built-in function `make` in the specification and read the following: &gt; Slices, maps and channels are reference types that do not &gt; require the extra indirection of an allocation with new. The &gt; built-in function make takes a type T, which must be a &gt; slice, map or channel type, optionally followed by a &gt; type-specific list of expressions. It returns a value of &gt; type T (not *T). The memory is initialized as described in &gt; the section on initial values. If you knew C you would know much about what to expect from the make function in the example, what kind of implications it might have to call make and what make does for you. You understand how the memory layout for the []byte slice will be and you know what kind of performance charcteristics you can expect from the given slice. You also understand what `copy()` does and why we need the copy function to extend the capactity of our slice. If you know C on beforehand you'll have a much easier time understanding basic types and builtins. You will understand Go better. 
&gt; If I'm looking at the wrong language, please tell me You're asking on the wrong r/reddit that's for sure. These are mostly people so convinced that Go is the savior language that they are not reasonable. Try asking on a more general reddit whether you should learn C or Go. Why learn Go? What's the advantage to you? Yeah you can kind of use it on App Engine because some developers at Google are pushing Go and pulled some strings to get it in there. But even so nobody else uses it and a knowledge of Go is not valuable. You probably think you'll learn something new by learning Go, but you won't learn anything that you wouldn't even in mastering JavaScript. If you just want to dick around with something new for new's sake you might still consider Go, but otherwise no way does it make sense. Learning C gives you a foundation for C++ and Objective C, both very marketable skills. C++ if nothing else will be around forever since nothing else has anywhere close to the same performance (except for D) while also being productive. Since you know some Java and JavaScript learning C will mostly be teaching you about the machine level of programming, which is useful to know (you won't learn anything about this in Go). So as far as learning for learning's sake and learning for marketability's sake C is a much better language than Go. But really what you should consider is actually mastering JavaScript and use node.js. For a number of good reasons JavaScript is and will be the new "C" language (at least for the near future) ie the 'main' language everything else revolves around. As a template-based language like Self you'll learn as much mastering JavaScript as any other language, and far more than you would learning Go. Another good alternative is to learn Lua. Lua is a very impressive scripting language and used all over the place. For desktop apps as somebody without a huge desire to put in tons of effort, Python + C (if needed) will let you create nice looking, responsive apps without much effort. Tons of GUI apps are written in Python and are cross platform, for instance MusicBrainz Picard. tl;dr Go is probably the worst language to use for what you've said you are interested in... if the choice is between C and Go, at least with C you learn something new (machine level coding). But really you should use Python for desktop apps, Java/JavaScript for web apps, or learn Lua to learn a new, useful language.
If you want to develop desktop apps then forget Go for quite a while. First question, what operating system? If Mac OSX, then you better learn C instead (and Objective-C which is a superset). If Windows then learn C++ or C#. If linux then your options are much better. Web apps, don't know.
Wow you really gave me a lot to think about here. I'm going to have to do more investigating. Oh, and by the way, I'm honoured that you made a throwaway account... the name has *huge* potential!
Another thing to look at is Clojure... you can compile to java classes and deploy on AppServer or anywhere else.
Your definition of "systems programming" seems narrower than mine.
"You probably think you'll learn something new by learning Go, but you won't learn anything that you wouldn't even in mastering JavaScript." Tripe. I stopped reading at that point.
Go isn't really suitable for desktop apps yet, it's true. Still waiting on a good standard windowing kit.
That's a valid concern, but for fuck's sake, add parametric fucking polymorphism *please*. I would love Go if it but had that.
Well, there is Go-Gtk, and Walk for Windows. They seem pretty good.
I wouldn't pay too much attention to what was said in given post. He/she makes some points about marketable skills, but other than that its mostly bullshit. Even the point about what a marketable skill is, is very subjective and depends on many different factors. Some languages are more popular than others and in these days JavaScript and Objective C are both much used. I don't think such things should affect one's choice about what language to learn/use to solve a given problem. Also, the last point wrong-reddit makes about Go being the worst language and with C you learn machine-level coding, is a fantasy. Lookup machine-code(http://en.wikipedia.org/wiki/Machine_code) and you'll see it has nothing to do with writing C.
What's the mathematical formula for malloc ?
I know lots of people.
You could have learned enough of both of them to decide for yourself by now :)
You don't think Python is *the* language to use for a single developer for desktop apps, especially one not entirely committed to it? You guys don't think JavaScript has more expressiveness and more variety of constructs than Go does? You think semantic games like "machine code" vs "machine level code" (what I said) is worth playing? If you think I'm wrong, saying "he's wrong" isn't good enough, unless maybe if you are preaching to the choir. Chrunchy, consider all options subjectively. It may be that Go is a good language for you, but justify the decision even if it's something like 'I think it'll be more fun'. For web apps maybe, for desktop apps your best bet is Python.
I don't know, C certainly has a lot of tripwires, but I think pointers are important to understand. Go has them, but they're safer and less tricky than C's. I'd also say that the transition from static to dynamic is easier than the other way around. Dynamic languages tend to support features that create bad habits if used without first having experience in more rigid languages.
If you use Go for a while you will realize it is not an issue, and actually the lack of parametric polymorphism makes APIs much more clear and easy to understand.
&gt; Because Go incorporated tuples from the beginning, you can easily return two objects from a function call: Go doesn't have tuples. I wish it did.
If this is just about learning a programming language: If you only want to ever learn one language in your life, learn a high-level language that has a large community and get stuck in there. But no real generalist programmer gets stuck in one language. Each language has their place, their advantages and disadvantages. My personal recommendation is this: If you aren't comfortable with the concepts of programming, pick a language for which you have the materials for, have the friends who know the language, has a reasonably large community, and is fairly high-level so you don't have to care about too many details. But I'm an idiot who started his foray into programming with QBasic as his first language followed by C++ as his second, so what the hell do I know.
If Go had tuples, you could have multi-value channels. That's the main reason I wish Go had tuples. How about you?
That's exactly where I went... dammit, I wish we had tuples. And then proceeded to make a type that was roughly equivalent to being a tuple. (Was there a different/better approach I could've used?)
Multivalued channels could be supported by the language, like multivalued functions. The obstacle is readability in comparison with the comma-ok idiom. While it is a useful form, a contextually dependent number of return values is awkward and limiting. Which is why I'd prefer a keyword: `v, ok := try &lt;-c`.
So what would it look like... var ch chan (int, int, string) ch &lt;- (1, 2, "hi") Right now the same thing is type Tuple struct { a, b int; c string } var ch chan Tuple ch &lt;- Tuple{1, 2, "hi"} I guess it's nice to not have to name the tuple type, but I don't think it's a big deal.
It's similar to calling a function with multiple arguments. If you would indulge my analogy, the situation with channels is like a language in which all functions only took one argument. In order to define a function that takes two arguments, you would have to first have a type like Tuple. It would work, but it wouldn't be convenient. Anyway, it's not a _huge_ deal, but it would be nice to have tuples.
I don't really think tuples are necessary to support this feature. Go already has multiple assignment. It would just have to be made to work with channels. The problem is the comma-ok idiom, which gets in the way no matter how you do it.
True. I think that since comma-ok is just syntax, it would be possible to make it unambiguous. I imagine that this issue would have been discussed to death on the mailing list, but I haven't found anything in a cursory search. Does anyone have a link?
The only remotely related discussion I've seen is: http://groups.google.com/group/golang-nuts/browse_frm/thread/2daabc37620ad0f8/e3329767cabc8f4e If this kind of discussion came up again, I would definitely mention having a keyword to disambiguate the two cases, and back up the suggestion by mentioning that it would free up space for multivalued channels. I'll keep looking. I think it might have been brought up once in passing, and people just said they'd use a struct, but I haven't found it yet. It sort of was mentioned here (actually by me) but there was no discussion about it: http://groups.google.com/group/golang-nuts/browse_frm/thread/7a30265105d538da/fae4bb189d753af4 It was sort of discussed here, but never in the context of changing the language: http://groups.google.com/group/golang-nuts/browse_frm/thread/740ac8ccb3cf0309/ Edits: added more links
Hard to find a compiled language with built-in support for sockets/http,json and crypto.I suggest you join the golang mailing list and feel things out.
Guido van Rossum (Python creator) recently blogged about his early years of programming, I thought you might like to read this little snippet : &gt; Eventually I learned assembly programming, which explained the memory model of a computer for the first time. I realized that a pointer was just an address. Then I finally understood them. http://neopythonic.blogspot.com/2011/07/before-python.html
No. Read a lot about other fundamental languages (C, assembly) but don't learn them : it's better to go on with go, as long as you don't encounter blocking problems. Don't worry, if you're interested in programming you'll fast end with the practice of half a dozen ones but really you should concentrate on your first program before trying to learn everything.
`print`'s evaluation rules are the same as a function though, so the ultimate change for people using Python is to stick some brackets round it and call it a day. If you changed the iteration construct `for` to be a function, the syntax would change, but you'd also have to pass a function in, which would be a real pain in Python.
Probably not what you meant, but this will print 3: package main import "fmt" func G() (a, b int) { return 1, 2 } func F(a, b int) int { return a + b } func main() { fmt.Println(F(G())) } 
Yes, this is one of the limitations of having context dependent return values: you cannot pass the checked form of the operation to a function: func F(v int, ok bool) { } ... F(v.(int)) // not enough arguments to call F Having an explicit keyword would allow you to do this: F(try v.(int)) The same as with your `F(G())`.
Learn C thoroughly. In 10 years, Go will either be here or in the archives, if you still want it. C is, so far, eternal. Edit: but for fuck's sake, if you were about to learn Python on the side, substitute for that with Go. Be glad you did.
Congratulations on finding the web's worst font. The colored highlighting is really kinda cool though. I hope more people start doing that. I'm curious about this: var c *Collada = new(Collada) err = xml.Unmarshal(file, &amp;c) Why would you pass the address of the address of a struct? I think I read something about that, but I cannot find it right now.
True. Except for the highlighting.
:)
You're right. I don't know why I did that but I changed it. It works either way, however. 
Very nice read - I have been working with XML &amp; Go and found that it's rather different than doing the same in clojure or python for example. Once you get the hang of how the XML library is structured though, its pretty painless. One thing that might be useful to include is how you can flatten the XML in your internal struct reference by using the `xml:"foo&gt;bar"` annotations. Also I think c := new(Collada) might be more idiomatic than var c *Collada = new(Collada) Edit: added 'flatten'
I got mine in the mail last week, and it looks great. The cloth is a bit thin... but the gopher is great.
I would love to be able to contribute. Alas.
@hsaliak, you left a word out ("how you can the XML") I think. What did you mean to say? @idobi, thanks for writing this! It's timely and useful for me.
You mention minecraft in this article, are you aware of [chunkymonkey multi-player minecraft server written in Go](https://github.com/huin/chunkymonkey/)?
Actually, no. I don't play that often, however. Mostly on lazy days that come around a couple times a month. I read so much about it, however, that I felt compelled to see what all the fuss was about. My daughter enjoys it more than I do, but she rarely plays by herself. 
I took your advice and changed the c init statement to: c := new(Collada)
you're welcome
Sorry I accidentally the word 'flatten'.
Is the lack of coloring on *func* or *fallthrough* keywords due to Google Code not being aware of go ?
That's reddit for you. I suppose Firefox was written in JavaScript as well.
Well, now I'm a go CONTRIBUTOR, so how long before that makes its way over to the wiki contributor list?
I think you just have to ask for it.
I've made this for Project Euler (not exactly the same): https://github.com/franciscosouza/euler/blob/master/problem_028/28.go#L119
OpenBSD support? F(@# yeah!
I started the wiki very conservatively. Email me (bradfitz golang org) with details. Anybody who's signed the CLA can get edit access. I plan to open it up further as time goes on. We're kinda taking a wait &amp; see approach to it.
Improvements to GoInstall.... Finally!
Kicking the tyres on goroutines
I like that Go got better at scheduling go-routines (mainly due to the work of Dmitry Vyukov maintainer of http://www.1024cores.net/). Last year when I used go-routines I had trouble getting 4 HT cores to 100% utilization on fairly easy problems.
&gt; parallelism-related performance optimizations and fixes Wonder if 6g generated code scales past 3 cores yet.
The whole "get to work right away" thing is one of my major draws to Go, as well. I don't really even take advantage of the built-in concurrency that much - I use it as a general purpose language for machine learning experimentation stuff.
I don't think parallelism has that much to do with the generated code, it has much more to do with the runtime. And Go code has always been able to scale well beyond 3 cores, but yes, the runtime has much room for improvement, and some of those improvements are starting to happen.
What improvements to goinstall are there? The stuff about protocols didn't seem that exciting.
http://pastebin.com/Y3J0EtG5 This inelegant benchmark calculates pi to lots of decimal places 4 times in a row using GOMAXPROCS 1-4. On my Debian 64bit, quad core i5 with cpu scaling disabled I get the following output. FINISHED in 4234 ms using GOMAXPROCS 1 ( 1 times faster) FINISHED in 2823 ms using GOMAXPROCS 2 ( 1.4998228834573148 times faster) FINISHED in 1884 ms using GOMAXPROCS 3 ( 2.2473460721868364 times faster) FINISHED in 1881 ms using GOMAXPROCS 4 ( 2.250930356193514 times faster) There's no IO and barely any channel usage so what am I doing wrong? EDIT: I suppose I'm assuming i5s scale linearly to begin with.
I like that it has less support, less features, and retains an archaic syntax. I particularly like that it's so hard to integrate with existing code as compared with Python.
the Google Store, on their main campus.
Are you sure you're not at least partially suffering from the inevitable performance degradation that comes from using multiple threads? Eg from context switches. Also I'm not up to date on the i5 but if it's the same as the i3 then i imagine that increasing the number of real threads pass two won't gain much as there's only two physical cores. Not four. This really shows on cpu bound tasks like this
The i5 I've got doesn't have hyperthreading http://ark.intel.com/products/48496/Intel-Core-i5-760-Processor-(8M-Cache-2_80-GHz) It's seems excessive that with just 2 threads I'm already suffering a 50% overhead from context switches! I'll try the same test with C. 
I reduced the calcPI(10000) to calcPI(1000) so I didn't have to wait on my crappy i3 the following are 3 tests I ran. the code unchanged FINISHED in 1887 ms using GOMAXPROCS 1 ( 1 times faster) FINISHED in 1130 ms using GOMAXPROCS 2 ( 1.6699115044247788 times faster) FINISHED in 830 ms using GOMAXPROCS 3 ( 2.2734939759036146 times faster) FINISHED in 829 ms using GOMAXPROCS 4 ( 2.2762364294330517 times faster) i noticed that the "done" signal on the channel is being executed after each iteration in hard() (i probably mis-understood the code but as far as i can see, that doesn't look right because you call `go hard(c) 4 times, the loop runs 4 times and thus send 4 signal.. the waiting side reads 4 signals which means that 12? sends on the channel ends up blocking`) blah blah.... long story short, i made the sync chan buffered to a constant 100 (arbitrary large number so we never have a goroutine waiting on the channel send) (not x, with x it's possible for the buffer to become full) FINISHED in 4496 ms using GOMAXPROCS 1 ( 1 times faster) FINISHED in 2281 ms using GOMAXPROCS 2 ( 1.9710653222270933 times faster) FINISHED in 1295 ms using GOMAXPROCS 3 ( 3.4718146718146716 times faster) FINISHED in 1240 ms using GOMAXPROCS 4 ( 3.6258064516129034 times faster) replacing the sync channel with a sync.WaitGroup for comparison FINISHED in 4559 ms using GOMAXPROCS 1 ( 1 times faster) FINISHED in 2299 ms using GOMAXPROCS 2 ( 1.9830361026533276 times faster) FINISHED in 2275 ms using GOMAXPROCS 3 ( 2.0039560439560438 times faster) FINISHED in 1303 ms using GOMAXPROCS 4 ( 3.498848810437452 times faster) i hope that made sense - my mind is all over the place
Good spot! There was no reason for the loop in hard. I now get. FINISHED in 3317 ms using GOMAXPROCS 1 ( 1 times faster) FINISHED in 1671 ms using GOMAXPROCS 2 ( 1.9850388988629564 times faster) FINISHED in 941 ms using GOMAXPROCS 3 ( 3.524973432518597 times faster) FINISHED in 1768 ms using GOMAXPROCS 4 ( 1.876131221719457 times faster) Fourth thread causes it to tank. Interesting that your 2 real core i3 benefits from the 3rd and fourth thread. 
After removing the loop from hard() I see similar behaviour (a sharp drop when we get to 4) observations of the code at that point: c := make(chan int, x) results in blocking goroutines as the buffer is likely to become full at some point because x will be smaller than the number of goroutines that are running and thus when they finish, they have to wait on the channel. for i := 0; i &lt; x; i++ { &lt;-c } again x is relative and what it means is that we're only reading x signals so after the loop ends there are `4 - x` goroutines blocked waiting. These two cases, particularly the latter seems to explain the sharp drop as setting a more reasonable buffer on the channel and/reading all data sent to it results in: FINISHED in 1514 ms using GOMAXPROCS 1 ( 1 times faster) FINISHED in 762 ms using GOMAXPROCS 2 ( 1.9868766404199476 times faster) FINISHED in 765 ms using GOMAXPROCS 3 ( 1.9790849673202615 times faster) FINISHED in 491 ms using GOMAXPROCS 4 ( 3.0835030549898166 times faster)
I don't believe you followed instructions... the assignment asks for the score of the best possible set of pairings... your code (lines 100-112) does not seem to do this. Unless you're doing something clever that I'm not catching on to. The brute force method would involve checking n!m! different possibilities, for n products and m customers. Your loop has n*m iterations, so if you're being clever than kudos, but I don't see it. Oh, I see what you're doing. And I don't think it's correct. The way you have it set up, two customers could be assigned to the same product.
Here's what I came up with. I didn't bother doing anything to ensure that the lines fit into my buffer, though. http://pastebin.com/Batin7Px
Oops - you only need to permute one of the lists, so instead of n!^2, the runtime is just n!. http://pastebin.com/NuqvH3uJ
Oh, haha... I'm an idiot. I didn't even read that part of the question. Thanks for your implementation -- I see a lot of things I could do differently.
Notice that most Ruby templates *are* precompiled as well. Rails for example, transforms templates into Ruby code and compile them to methods, so most VMs actually optimize it.
First thing that pops up at me: DO NOT USE CONTAINER/VECTOR. See http://code.google.com/p/go-wiki/wiki/SliceTricks
And just in case you do want to, no need to import vector "container/vector" Since the package is already named vector.
First thing I noticed is that you're using C-style variable_names instead of camelCase, which is the convention in Go. In the function declaration on line 51, you can reduce the verbosity of the argument list a bit by only having one 'int' declaration and shortening the names: num_prod_letters int, num_cust_vowels int, num_cust_consonants int becomes numLetters, numVowels, numConsonants int The same applies for the declaration on line 35, and maybe somewhere else that I've missed. Also, lines 118 and 119 could be improved by moving the os.Open call to its own line instead of embedding it in the if statement, because then you don't have to declare the file variable ahead of time. The if-initialization is a cool feature, but if the result is needed outside of the block then it should probably be done more traditionally: var file *os.File if file, err = os.Open(path); err != nil { return } becomes file, err := os.Open(path) if err != nil { return }
I approve of this idea. I like to think we've drawn people into Plan9 in this way over the years, by keeping up the comments on reddit / slashdot / hn / other places. When Uriel and I and a couple of others started #plan9 on freenode it was just us, just now there were 73 people. Ok not 10,000 but I like to think we've managed to evangelise enough to attract users. The problem I seem to face is that by the time the programmers and system integrators are hired, someone has already decided the platform - leading to quite a few "grr, if they'd used Postgres instead of MySQL this would be easy" moments.
x, a = a[len(a)-1], a[:len(a)-1] / append(a, x) is kind of awkward compared to x = pop(a) / push(a,x).
You can always define your own pop() push() methods on your slice type if you use that so often, but in practice that is rare.
Just a note that #cat-v in freenode recently passed #plan9 in number of people ;) This shows that there is space for multiple communities with multiple styles and cultures all using the same underlying technologies. Any Gophers that enjoy anarchic mayhem with plenty of trolling and counter trolling and a total lack of respect for all that is sacred are very welcome in #cat-v, all spiced with some serious ass kicking code by bad ass hackers like aiju and cinap ^_^
plan9 is dead
Long live [9front](http://code.google.com/p/plan9front/)! ;P
Perhaps, but container/vector is a []interface{}, which isn't as nice to deal with as []MyType.
&gt; The useful thing about the "empty interface" is that all types satisfy it... This makes it useful for storing abitrary types in collections... But not very useful for extracting types from collections. Painful lack of generics.
He wrote *arbitrary types*, if you only want to store one type, slices/arrays/maps work fine. Yes, some times you need other containers, but it is quite rare.
I didn't say lack of templates, I said lack of generics. I'm not touching Go until it has proper generics.
It is sad and funny to see all the people who never used Go swearing that until Go has generics it is unusable, while all the people who are actually using Go every day realize Go's unique set of features makes generics not very necessary, useful perhaps, but certainly not essential. (Actually I know quite a few Go programmers that are happy that Go has no generics and don't want them, of course their minds might be changed if a good proposal for generics ever comes up).
&gt; It is sad and funny to see all the people who never used Go swearing that until Go has generics it is unusable, while all the people who are actually using Go every day realize Go's unique set of features makes generics not very necessary, useful perhaps, but certainly not essential. You're suffering from the cherry picking fallacy. The people who use Go every day have no need for generics in their programs, and thus do not terribly miss the exclusion of this feature, otherwise they wouldn't use that language in the first place.
People who don't use Go at all have no clue if they will need generics when using Go. The pretense that all languages are the same, and that features are interchangeable across languages is silly and probably a product of how homogeneous the programming languages monoculture has become. Some times it seems that the only thing that differentiates most languages is the flavour of sugar they are covered in. (Often km deep and dense layers of sugar) And then people keep claiming that is impossible to do error handling without exceptions and code reuse without inheritance. So very sad.
I've used Go and found the lack of generics to be enough to draw me away from it. I most definitely have a clue if I ~~need~~ want generics.
Can you please explain what you used Go for and where did you find the lack of generics to be an issue? Honestly I'm quite interested.
Whenever using the container package with my own types. Just look at [vector](http://golang.org/pkg/container/vector/).
Nobody should use container/vector, certainly not since append() was added little after Go was first announced. It is a bit sad that it is still in the stdlib, and many people think it should be removed because it just confuses people into using it instead of using slices.
The main reason I miss the lack of generics is that it doesn't allow people to play around with different implementations of, say, map, without losing type safety. In fact I have often needed maps that could have arbitrary key types (that could be equal despite residing at different memory locations), so I made gohash. As it happens, compile-time type safety with containers is really not super necessary. The code has always made it obvious to me what type belonged in a certain hashmap, and I have literally *never* sent in the wrong type only to find out when the running program panics. The downside is I have to do a .(MyType) after every .Get() call. It's an annoyance, but not a hindrance.
MUD!
I second this. Open source it so that you can easily get help with things.
Basically, a chat room with monsters.
a chat room is probably the simplest. Card games require handling the state of the game, updating and keeping in sync, managing beginning and end of the matches etc, is far more involved. After you build your chat room, maybe you could evolve it into a very simple mud, i guarantee it will be fun :)
"go in her face" dehihi
the only thing this article says is that the author has a very poor understanding of how exceptions work.
why not something fun and useful? make a siege clone :) (for testing websites under load)
This is more along the lines I was looking for. Thank you. Any other ideas?
IRC Bot http://tools.ietf.org/html/rfc2812
Why is this good news?
Because it is almost never a good idea to use container/vector instead of a slice. It harkens from the time before the append() built-in. Now that it's out of the core libs (except for its own container/vector package), it stands a chance at being removed entirely at some point. 
http://www.iron.io Comic Sans?
What is? Certainly not the font they used there.
It is a fully functional IDE :). Go here and see: http://go-ide.com/2011/08/09/goide_release_1_0_darwin.html (I am the author). 
I started as a plugin but recently i have used the Intellij Platform to build it a standalone IDE. You should check it out. Most of the functionality it's still available as a plugin for Intellij IDEA.
My mistake, looks very cool. Deleted my original comment to not pollute this submission.
It is in Chrome/Win7: http://i.imgur.com/QW42U.gif, though the font they reference is "Wallpoet" http://www.google.com/webfonts/specimen/Wallpoet
Thank you :)
This inspired me to take another look at Go. I'm disappointed. :(
Any reason why? Or were you just hoping for C++ with go style syntax?
Actually I was hoping for C with Python-like syntax. The language provides some slightly tighter typing, some ill-designed built-in containers, and a handful of concurrency primitives that are easily obtained in more mainstream languages. All of this with a syntax that's somehow harder to read than C, not easier.
See also [the announcement in the Anchor blog](http://www.anchor.com.au/blog/2011/08/the-automation-waltz/).
In a couple of days yes :). I plan to make a release supporting full cycle go app engine development. 
&gt; a syntax that's somehow harder to read than C Maybe you just need to get used to it.
Here's the guy's 3 "rants" about Go: &gt; * Api stability. Go guys please don’t change the API’s so often, it makes people nervous. It makes serious comercial development problematic. I know it’s a new language and a lot of things are changing which is normal, but keep in mind that people like me who need to get their shit done fast will think twice before building a real world product without a api ‘stability’. &gt; * Debugger – I hear there is one in development right now. No language is worth much without a usable debugger. I’m sorry.. I’m just too lazy to look at my code to figure out what’s the problem. I want a usable debugger right now. &gt; * Too little zen of python in some third party libraries. import this. Please… Reasonable complaints, but I think he's absolutely wrong with the first one. If you want API stability, pick a release of Go and stick with it. One of the benefits of new languages is the ability to evolve fast, and this means breaking existing APIs and even language syntax. I applaud the Go team's willingness to make backwards-incompatible changes in the name of producing a better language and core libraries. Naturally, at some point this willingness to break existing code is going to not have enough of a benefit to be worth doing anymore, and I expect that at that point Go will become relatively stable, API-wise. But by making API changes now, we can end up with a far better "stable" language in the future. I'm also not quite sure what he means by the third "rant". Is he complaining about not having 3rd-party libraries that does what he wants, or does he just not think the 3rd-party libraries are "python-like" enough?
Go is not Python. Your Go-code smells Python-code.
Add a comment to the post. Not sure if he'll read this.
I find it ironic that a python fan complains about changing APIs (or the language itself). 
I agree, and you would think Python people would appreciate this, because the Python stdlib is such a horrible mess, the Go stdlib is much more clean and consistent, still has a way to go, but you can also see how it is slowly stabilizing. Also gofix works quite well, better than people coming from other languages might expect.
&gt; Reasonable complaints, but I think he's absolutely wrong with the first one How is it reasonable if I'm absolutely wrong? Not only that, but you seem to say almost the same thing. We both acknowledge that it's a new language and the changes are natural and we both assume a future api stability. I guess the difference is that I'm a lot more impatient. In python *import this* outputs ['The Zen of Python, by Tim Peters '](http://www.python.org/dev/peps/pep-0020/) which are a few nice things to remember when developing software - but that's my preference. I know about a few API decisions in python which might be considered harmful, also I know that there is no way around them all and at some point you'll have to make sacrifices in order to have a stable API. When is the right time? Let's take a look at the [changelog](http://golang.org/doc/devel/release.html) of the recent releases or the [weekly changelog](http://golang.org/doc/devel/weekly.html). There are loads of changes, to the stdlib apis and to the language. gofix can fix a lot of then, but some work is still required. Good: The language improves, the API mistakes are fixed. Bad: People that write libraries/products have to update their code often in order to keep up with the new go releases. Sticking with a specific golang release makes it hard to use possible *future* libraries. Take a look at this list: http://gopkgdoc.appspot.com/ - it keeps getting bigger and bigger fast. Those people and their users depend on the 'stability' of the API.
Could you elaborate on the horrible mess in contrast with clean and consistent? Examples maybe? 
The respective unit testing and url fetch APIs are the first examples to come to mind, but there are many others. That the python stdlib is a horrible inconsistent mess is a well known issue, which thankfully is slowly being addressed in Python 3, but without something like gofix it will take a long time and will cause considerable breakage.
This is almost a chicken-egg problem. Go is new and needs breakage to evolve. This **is** a downside and, I guess, a considerable negative point for those weighting some serious use, but unavoidable. (I'm arriving now and one of the first things I noticed is that some code I've took from the web a few months ago don't work anymore. Not a general rule, but common to happen.)
I'm still not convinced. I think you can hardly prove it to me that the python stdlib is a horrible mess by saying :"unit testing!", "url fetching!". What is broken there? Concrete examples sir.. &gt;the python stdlib is a horrible inconsistent mess is a well known issue Yet you bring no examples of why it is inconsistent. If inconsistent means having contradictory elements then show what they are. You could have shown for example that the type function in python does two different things (type checking for an object, and class generation) - which is considered a BAD API decision. You can argue that timeit has an unpythonic (another word for inconsistent in python) API because you have to pass the benchmarked function/code as a string to the Timer. Of course there are others, but that still doesn't make the stdlib a 'horrible mess'.
Interesting, but the code he draws comparison from does not really show off either language. How less readable would his example look if it were written in C? Not very.
IMHO is more of an issue for people learning and taking random code from the web than for doing serious work with Go, this is unfortunate, but as you pointed out, unavoidable with any young technology. But anyone doing serious work will stick with a `Release` version and from time to time update their code using gofix, which while mildly annoying is not a big problem in practice, specially when APIs improve (see for example [this comment](http://www.reddit.com/r/golang/comments/hqcf5/new_exec_package/c1xhaiv) when a new exec package with a completely new API was introduced).
* The tls support in the python smtplib package has been broken for a long time. * What's up with urllib and urllib2, shouldn't there be just one? * cookielib and cookie? why are these separate? and why do they look like they should be the same thing? * argparse,optparse, getopt all seem to cover the same functionality. * time,datetime,calender cover similar functionality. * email, rfc822, mimetools cover the same functionality * HTMLParser, htmllib too. The modules have different naming conventions, some lower-case, some upper-case, some camel-case, some end in 'lib' and some don't. Some functions have underscores between words, others use camel-case, some have no separator at all. This comes from years of neglect and a general resistance to break anything to make the situation better and now these problems have been there for so long that it's unlikely anyone will ever actually fix them because too much code relies on it. 
Thanks for writing up a summary of some of the worst offenders, I thought this stuff was common-knowledge/obvious in python circles. To be fair, they are trying to address some of this issues in new Python 3 releases, but it is still quite a mess, and you didn't even go into the very different API styles: some are functional-ish, with callbacks, others rely on inheritance and/or mixins, others are plain C-style procedural, others are byzantine OO-meta-frameworks, and on and on. I think one can see the cost of Python's flexibility and 'features' in the stdlib, from a high level there are way too many different ways to structure and design an API (metaclasses, multiple inheritance and operator overloading are some of the obvious culpits, but named-optional arguments are also a problem because they encourage endless lists of parameters nobody can ever dream of remembering and which rarely get cleaned up but often are expanded).
Most of the libs you chose have been refactored into python3 or deprecated since python2.3 or 2.4 (almost no one uses those). This might be interesting as well: http://py3ksupport.appspot.com/ * The tls support is a bug and cannot be part of this discussion. * urllib and urllib2 merged into urlib.* in py3 * cookielib and cookie are not the same. (refactored into py3) * time, datetime, calendar don't cover similar functionality. * email, rfc822(deprecated since 2.3 in favor of email), mimetools (same) * argparse, optparse(deprecated in favor of argparse), getopt - what's wrong with having different style of parsers? * HTMLParser, htmllib - refactored into py3 The reason they are kept in deprecation status is that people should be allowed to migrate gracefully to the next version. It allows them some time to pack their bags ok? I think it's better than just breaking their code. I think that deprecation is a good solution to address these 'mistakes'. It's hard to get a good API ok? Everybody knows that. Go will have the same problems once it grows and gets more people involved. Breaking backwards compatibility is not an universal solution. Remember that python is 20 years old. A lot of knowledge we have today was not known or well understood on the course of developing python. Things change fast.
I did mention things are improving in Python 3, but most people are still stuck using various variants of Python 2 (some as old as 2.5 as in App Engine). Just because something was deprecated and replaced in Python 3 doesn't mean you can actually use it in your projects.
Don't get me wrong, I quite like python and I realise they are finally breaking compatibility for python3 to fix these issues and that's great. But this was the original point. The python2 stdlib is a mess because they didn't clean it up so as to avoid breaking anything and you have to break compatibility to fix those kind of problems. Go does this often and early to avoid having 20 years of code depend on a messy stdlib. In 20 years I hope the Go team is still willing to break code in order to keep the stdlib neat. Although, breaking compatibility is far eaiser when you have a statically typed language and a statically linked executable. 
Perhaps, but if Bruce Eckel has a very poor understanding of how exceptions work, then exceptions are really fucking insane shit.
I now have golang on my Windows box, with an IDE. I am impressed!
I must say that the credit is to the golang team for making it easy to compile to a target platform different than the host (the rest is Java so there's no problem there). We're actually running Linux (the main author of the go plugin) and Mac OS X (myself, occasional contributor). This is one of the great qualities of the go-sdk :)
Hmm, the only feature I'd like doesn't work: code completion for packages. :(
The irony; Go IDE in Java
I honestly believe IntelliJ is just a nice platform to support other programming languages and it happens to be written in Java. I think you'll find the same irony in PyCharm (for python), RubyMine (for Ruby), etc, right? 
Hi there, Can you elaborate a little on what doesn't work ? Completion for your local packages ? This is being currently worked out in the next version because the last one had a lot of issues ;). And i'm sorry it doesn't work for you yet :( 
I'm not sure I see the irony... My Golang runtime is written in C. My Golang editor is written in C. Back in the day when I touched Java my editor there was written in C. My C editor written in C++. ... The list goes on.
IIRC Java itself is mostly written in C++ and assembler.
***ibm_ericvh***: &gt;[2011/08/16][19:24:54] &gt; Spending a couple weeks trying to get [*&amp;#35;golang*](http://twitter.com/search/%23golang 'twitter tag search') working on [*&amp;#35;ppc*](http://twitter.com/search/%23ppc 'twitter tag search') so we can play with it on [*&amp;#35;bluegene*](http://twitter.com/search/%23bluegene 'twitter tag search'). ____ *[This comment was posted by a bot](http://www.reddit.com/help/faqs/tweet_poster 'tweet_poster FAQ'). [***Did I get it wrong?***](http://www.reddit.com/message/compose/?to=tweet_poster&amp;message=[Oops!](http://reddit.com/r/golang/comments/jm29w 'send a message to tweet_poster'\))*
Now that is just plain cool
will there be debugger support soon? That would definitely make my day.
If they just ported it to Plan 9 it would already work on Blue Gene. \#AnotherWastedOpportunity
It's the port to PPC that's the real job. Being a native compiler, you'll have to make the go compiler produce ppc code. Which you have to do anyway in addition to porting it to Plan 9 if you want it to run on Blue Gene 
Blue Gene uses PowerPC ISA, the Plan9 Go port is IA-32e only. The gc Go tools support only IA-32(e) (32 and 64 bit) and ARM at the moment. 
Sorry, but you are doubly wrong on this one, as others have pointed out the work is to get it to run on PPC, and the Plan 9 already works (as you should know it is part of [9front](http://code.google.com/p/plan9front/) :))
hmm, maybe it's my slow computer but when I type "fmt." I'd expect the code completion popup to show me methods/interfaces from that package . &gt; And i'm sorry it doesn't work for you yet :( no need. it's free and open source - if I have a problem with it I'd better fix it myself. :)
That it's supposed to work: types and method names completion from imported sdk packages. Can you try to invalidate the caches (File -&gt; invalidate cache) and to make sure you have a proper go sdk attached to either the module or the project ?
good for me
It is planned but it we will begin working on it after we complete the app engine support :). And also it seems like only platforms with gdb 7 will be able to use it. 
I've always been intrigued with the basic idea of Bluegene... This is so different than all the other platforms Go works on. I guess it does sound like the sort of thing Go might be well suited for... at least from listening to Rob and Andrew's presentations. Lots of small cores, cheap threads. It would be great if this works out well.
Thanks for putting this up!
but I'm a Plan9 user not a 9front user
Seconded. I maintain several projects and update them regularly with the new releases. Out of many thousands of lines of code I'll typically have to modify 5-10 lines in a trivial way. The only time I had to completely rewrite things was with the exec update and when I moved to the new template package. In both cases it was not really burdensome.
Awesome resource. Thanks for the effort.
Yeah, you're going to need to tell me what font that is, asap
Given you're on the Go team, do you have any thoughts on the direction of Go as a language? I know people ask for generics relentlessly, but what about niceties such as list/collection comprehensions? Other functional-style things could easily be added via library support if/when generics are implemented. What's the next big thing for Go? What's the team most concerned about regarding the language's future? (Heh, this is sounding like an interview.. my apologies, I just like Go and am interested/excited. Heck, working on Go in Sydney/Mountain View would be awesome)
Any one working on Go for Android Apps? I don't mean compiling it for the platform - I mean actual APKs
I think if you like Python, there is a lot you will like about Go. Go follows some of the same principles found in the Zen of Python. "Simple is better than complex" and "There should be one... way" come to mind. I agree that programming languages are not religions, but perhaps comparing Go with PEP 20 might help proselytize some in the audience.
terminus apt-get install xfonts-terminus
How about "Calling Go from Python and how you can speed up your critical sections without having to use C"
:D you can't. it's my #1 gripe. you'd have to call python from go instead, via the C api
I've not looked any further than this post about calling go from C http://groups.google.com/group/golang-nuts/browse_thread/thread/3c74b4a91fc614f8 So it *might* be possible to build a Python &lt;-&gt; C &lt;-&gt; Go trampoline.
You'd have to do significant under-the-hood work to make it happen. Then, ideally, you'd share your work with the rest of the world :) In short, this isn't supported yet.
Embeddable Go would be a wonderful thing. There's no technical reason it can't be done, it's just a lot of work.
&gt; do you have any thoughts on the direction of Go as a language? The language is pretty stable now. I think the development of new libraries and tools is the most interesting thing about Go at the moment. &gt; I know people ask for generics relentlessly, but what about niceties such as list/collection comprehensions? You mean as built-ins like append? Not going to happen. It's almost always more efficient to write a loop and it's rarely appreciably easier to use some fancy functional syntax. Less keystrokes, maybe, but we'd be abstracting away a lot of stuff that the programmer probably should be aware of. Go rarely prioritizes convenience over transparency. &gt; Other functional-style things could easily be added via library support if/when generics are implemented. It's for this reason that generics would hugely transform the language. That's why we're thinking long and hard about generics. Go works very well now. Even small changes have drastic effects on a language. Generics would be a huge change, and not one to be made lightly. &gt; What's the next big thing for Go? What's the team most concerned about regarding the language's future? Efficiency. Some great work is being done on compiler optimizations in gc and work continues on gccgo. Over the past six months we've seen 2x speed-ups in some areas and there's still a lot of low-hanging fruit. Productivity. Work continues on the standard library and tools. Go's standard library is one of the best I've seen in any language,and it's still early days yet. Stability. We're trying to reach a point where we can issue a stable release that will stick around for a while (longer than the 1-2 month release cycle we have now). Think something along the lines of Ubuntu's LTS releases.
I like godag, I like gb and I like goinstall. Can't we all be friends? I keep trying to hold off and wait for goinstall to be the go-to tool. Does gb have a future alongside goinstall?
"It had to be done."
True story. Writing a Gopher server was one of the first things I did with Go, too. It's just too punny to pass up, even if the protocol is now useless. Should I have polished it up and published it? Perhaps. Kudos to bradfitz for doing so.
The dev team has shown zero interest. They'd have to start maintaining my code, after all. They are working on their own version, based off of goinstall, that will be the new gomake some day. 
My question more was, is gb a stop-gap for gomake/goinstall? Do you anticipate using it in X months after those "official" tools are more mature?
Docs formatted thanks to gopkgdoc! =) http://gopkgdoc.appspot.com/pkg/github.com/moraes/gorilla/src/gorilla/mux
http://logik.li/projects/godwulf/ - 2009-12-22
I'd have to see how gomake turns out. If it does everything that gb does, I'll use gomake. gb has a lot of features, though - and works anywhere that goinstall does for local projects (and invokes goinstall for remote packages). I also think it's unlikely for gomake/goinstall to become as easy to use as gb, on the current trajectory. The reliance on $GOPATH for specifying a project's source root is very clunky, imo. It's my intention to continue having gb work wherever the official tools do, but in a more friendly way. Will *I* use it once gomake/goinstall is mature? I think so, probably. Typing "gb" in your project root to build everything will always be easier than "gomake X/W; gomake X/Y; gomake X/Z". Unless gomake mirrors that functionality from gb, godag, which is possible. I still don't like having to set $GOPATH, though! It's nice for separating your downloaded package repository from the core packages, and I use it for that, but it's too clunky to use for multiple independent projects.
He also forgot how certain built-in types are references in disguise. `string`, maps, channels... And how some of these built-ins enjoy parametric polymorphism in a way that your own types won't. And how tuples are only permitted in passing parameters and multiple return values. And how, if you forget the pointer from a base type declaration (as in for a method), changes to the object apply to an ephemeral copy only. And so on and so forth. Hopefully they'll do better in v2.
I've got http://carboni.ca serving up the blog and projects pages on gopher as well: gopher://carboni.ca/ It's written in Ruby, though I've been porting it to Go on the side. It needs to handle database access and such, though, so I'll need to keep plodding along.
I use gb for a personal project because it's just way easier to use than Makefiles.
I haven't used gb yet but I've been meaning to. One thing I'm a bit confused about is the description of using a project root. What if I'm not using a project root, but rather I just have a folder somewhere with go code that I want to compile. Do I have to use the `target.gb` file or the `//target:` comment? One of the nice aspects of gobuild was how it would use the current directory's name, so I could just run `gobuild` in my source dir and it would build for me.
In this situation gb will use the name of the current directory.
seems like it might be more useful to just post your dotfiles and comment within.
And I had already done it. ;-) http://github.com/nf/gogopherd
So, I posted a blurb about setting up GoClipse to work with the Google App Engine SDK. 
Go should have dramatically lower memory usage and much faster start up time for new instances. CPU usage is probably in line with Java, a bit lower for some things, a bit higher for others.
some benchmarks would be nice
My time is priceless
&gt; Share by communicating, don’t communicate by sharing. Go's mantra is a bit snappier than : **Key Idea:** in occam variables are used for storing values, while channels are used for communicating values. - *A tutorial introduction to occam programming, Dick Pountain and David May (c) INMOS 1987* 
Someone - "Can you write the output to a file?" Rob - "Of course, it is a programming language you can write to a file whenever you want..... I need to bail, these people have no idea what is going on....."
Did he actually say that? What time?
No, but he said something similar but nicer at the end of the talk.
Did anyone else understand why it's important that the lexer be able to run during initialization? One of the audience questions was whether you could put the lexer into a separate stage that runs after initialization but before the rest of the code runs, and stick with the concurrent goroutine design and Rob said, no you wouldn't want to do that. But why not? Is there something that has to happen during initialization that requires templates?
Imagine a library with a function that does a little formatting. The format function is not allowed to be slow the first time it is called. The template would have to be processed before the function is ever called. The natural location to do the setup before the library can be used is in the init function as it is not possible for any of the library's functions to be called before init completes.
The more natural way to do it is to make that function a method on a data structure that results from running the lexer. Now you got rid of a global variable *and* initialization complication.
Either setup is done automatically in an init function and the result stored in a package variable, or the setup is done manually before being used. Like you, I would naturally lean towards doing the setup manually. However that was not the question. Rob explicitly said that it was important and natural to setup the templates from the init function and store the result in a package variable. It goes against what I first though, and caused ocrow to ask why someone might want to do things this way.
Either setup is done automatically in an init function and the result stored in a package variable, or the setup is done manually before being used. Like you, I would naturally lean towards doing the setup manually. However that was not the question. Rob explicitly said that it was important and natural to setup the templates from the init function and store the result in a package variable. It goes against what I first though, and caused ocrow to ask why someone might want to do things this way.
The cuddle demo shows some useful aspects of GAE &amp; Go &amp; JS together. However, remember that the pieces are billable, making that memcache not only faster but cheaper too Channel API 100 channels opened then $0.01 / 100 channels opened Datastore API 50k operations then $0.01 / 10k operations Memcache API $0 
Seems pretty dead... It'd be nice if it merged with http://www.gophertimes.com/ which is struggling a bit lately https://groups.google.com/forum/#!topic/golang-nuts/yWWQ0gQ0kkw .
Yes it does, it operates on a slice, which is a reference type.
excellent explanation/example
Sorry, but that was already posted [8 hours before](http://www.reddit.com/r/golang/comments/k5ntp/gos_sort_package/).
I would just like to point out that the main function can be simplified: func main(){ a := People{{"pete", 20}, {"dave", 22}, {"sarah", 19}} sort.Sort(PeopleByName{a}) //a is now sorted by name. fmt.Println(a) }
Go = ROFL. "Note to use make when only declaring a map: monthdays := make(map[string]int)" Learning Go page 53.
Why.. uh, not? It makes perfect sense to use sometimes.
Where do you get off thinking you must obviously know better about PL design than some people with well-appreciated and well-deserved credentials in the area? Your goto hate is unfounded; everyone jumped on the hate bandwagon when they read Dijkstra's "GOTO Considered Harmful", but it seems only a few bothered to read the follow-ups; here's [Knuth](http://pplab.snu.ac.kr/courses/adv_pl05/papers/p261-knuth.pdf), [Torvalds](http://kerneltrap.org/node/553), [McConnell in Code Complete](http://www.stevemcconnell.com/ccgoto.htm). Go has some pretty unique properties that combine to make it awesome in a wide range of uses. Don't dismiss it out-of-hand because of some hate you might've read, or prejudices gained. What's so damn funny about using make when only declaring a map? I'll be shameless and note I looked at your post history to see where you're coming from. Smalltalk: Dictionary new. Haskell: Map.empty. What's so wrong about make(map[X]Y)?
&gt; They both allow multiple return values to be consumed by another function which takes the same values as arguments.... Lua goes a little further and will add the multiple returned values to the end of the argument list of a function; that is, this will also work I wonder why they didn't allow this in Go? Even more so, why not allow arbitrary forwarding of return values to arguments as in: func multiple1() (first, second, third int) { return 10, 20, 30 } func multiple2() (first, second int) { return 50, 60 } fmt.Printf("%v %v %v %v %v %v %v %v\n", multiple2(), 40, multiple3(), 60, 70); 
Do many people think that languages should be designed to disallow developers from doing "dumb" things? I'd rather have a flexible, powerful language that I have to learn to be proficient with than be limited because of the lowest common denominator. (In reference to the first comment on this piece.)
Goto gets some bad press but there are many rare places where the normal callstack, switch, for and if aren't flexible enough flow control. In complicated flow situations gotos can make your code far easier to read. Just as knuth's comments on optimisation are commonly misunderstood, Dijkstra's comments on 'Goto' are similarly misunderstood. 
You can also just use an empty map literal eg. monthdays := map[string]int {} make() adds extra flexibility since you can also specify a default size. eg. monthdays := make(map[string]int,7) This reduces allocations required to expand the size of the map later. 
Why store the history "internally" rather than letting the user managed it in their own way? Seems like a decent use for a string splice?
It would, but the underlying C library needs to be able to see it so it can present it to the user during input. If you can think of a way I'm all ears though.
Ooooh. Gotcha.
Nothing's wrong with make, I was just loling at the horrible English explanation of make. And Go sucks. It has two syntaxes for assignment, postfix types for no reason, complicated compilation (use _this_ compiler on your arch but _that_ compiler on my arch), bugs regarding _if_ syntax--yes _if_ syntax. Read "Learning Go", it's all there.
I've read it, and I've developed [non-trivial software in Go](https://github.com/celtic/golex), so not only do I know about what makes Go great, I also know its warts (as any PL has them). And you know what? *All* that shit you mention; *none* of it matters. Two syntaxes for assignment? No; one to *assign and declare*, another to reassign. I hear C++11 has the former; it's called the `auto` keyword! Postfix types for no reason? Gosh, what a shame! I hear all those other PLs have *prefix* types for no reason! Can you believe it? Turns out postfix types are really nice when you're writing higher-order funs; here's a terrible tutorial-style example: func makeAdder(x int) func(int) int { return func(y int) int { return x + y } } func useAdder(f func(int) int, y int) int { return f(y) } Contrast C for useAdder (as I can't write makeAdder trivially in C): int useAdder(int (*f)(int), int y) { return f(y); } What was that other PL that uses post-fix types to great effect? .. oh yeah, that's right: makeAdder :: Int -&gt; (Int -&gt; Int) makeAdder = (+) useAdder :: (Int -&gt; Int) -&gt; Int -&gt; Int useAdder = id Putting the Go and Haskell types next to each other is pretty revealing: var makeAdder func(int) func(int) int makeAdder :: Int -&gt; Int -&gt; Int var useAdder func(func(int) int, int) int useAdder :: (Int -&gt; Int) -&gt; Int -&gt; Int You're concentrating on syntax, syntax and a different manner of tooling to what you're used to (hint: use a Makefile), and say nothing about the structure, type system.. or really anything important, at all, about the language. Have a nice day!
Ehm, doesn't it just have a better optimizer that takes that simple loop out of the program? Is the result of the loop stored somewhere? Is it easy to predict the outcome (precompute) the loop?
It gets really confusing figuring out which arguments come from which expressions. If your functions weren't called multiple2 and multiple3, I'd have no idea what to expect that statement to do.
Any dumb thing the language prevents me from doing is a dumb thing I won't spend an obscene amount of my time debugging. On that note, it is useful to distinguish between dumb things that are easy to debug, and dumb things that are difficult to debug.
In my contrived example yes, but imagine it being used with discipline for something that is actually useful. You could also extend your comment by saying that Go is confusing without the named arguments that Python enjoys. The point is, given the right documentation it's only as confusing as you choose it to be, otherwise it's useful.
Let's find out. I just wrote this program (loop.go): package main func main() { for i := 0; i &lt; 1e9; i++ { } } 6g loop.go; 6l loop.6; time ./6.out gives: real 0m0.602s user 0m0.600s sys 0m0.001s 6g -S (omitting irrelevant sections): --- prog list "main" --- 0000 (loop.go:3) TEXT main+0(SB),$0-0 0001 (loop.go:4) MOVL $0,AX 0002 (loop.go:4) JMP ,5 0003 (loop.go:4) JMP ,8 0004 (loop.go:4) INCL ,AX 0005 (loop.go:4) CMPL AX,$1000000000 0006 (loop.go:4) JGE ,3 0007 (loop.go:4) JMP ,4 0008 (loop.go:6) RET , As I read that, it's a pretty direct translation of the loop. Initialize AX to 0, then compare it to 1e9. If it's greater or equal, return. If not, increment and compare again. So I'm going to call it that the original author is essentially right. 6g is a fast, rather literal compiler. It's not clever but it makes up for it by compiling to native code. The more I look, the more basic the compiler seems. If I were writing this loop, it'd be something like this (though with any modern processor I'm sure it will run just the same): 0000 (loop.go:3) TEXT main+0(SB),$0-0 0001 (loop.go:4) MOVL $0,AX 0002 (loop.go:4) JMP ,4 0003 (loop.go:4) INCL ,AX 0004 (loop.go:4) CMPL AX,$1000000000 0005 (loop.go:4) JL ,3 0006 (loop.go:6) RET , 
Interesting. Ignoring why it would jump at all instead of fall through, why would it JGE ,3 only to JMP ,8 and exit?
My guess is that it's just a standard construction it uses that's generalized for when there is code to run inside the loop and code to run after the loop. I'd guess the inside-loop code goes between the JGE and the JMP. That, at least, explains why it didn't fall through.
And things that might be dumb but are sometimes really useful and hard to do in other ways, and things that are dumb most of the time and not very useful anyway.
Great job!
I think it was at least partially built for use with the [termite](https://github.com/hanwen/termite) distributed compilation system.
bah, I upgraded too soon and now my Mongo isn't working. Is there anything I can do myself? I wouldn't want to bug the Mgo/Gobson dev Gustavo
I encouraged him a lot. :)
This looks like an excellent write up of how Go approaches algorithms vs data. I actually prefer this approach most of the time. It allows you to think about the algorithm without getting tangled up in the data structures implementation details along the way. Clear interfaces are a much better way to go than inheritance and the interactions just feel like they are more explicit.
 Object-oriented design is the Roman numerals of computing - Rob Pike
This post is an instant classic.
I still don't feel comfortable with Go's sorting implementation. Attaching the comparator to the container rather than the objects to be compared seems like a kludge to work around Go's lack of parametric polymorphism. I can't help but be partial to C++'s iterator interface (or D's improved Range interface), which allows the *complete* separation of algorithms and containers.
Kludge? Maybe. Useful? Hell yes. It means that, to change the ordering, you need only convert between container types, rather than converting all the elements of the container.
&gt; It means that, to change the ordering, you need only convert between container types, rather than converting all the elements of the container. Huh? In OCaml or Haskell or even C++ I can change the order of the elements of a container by passing in a comparator function. Go's type system doesn't permit such flexibility, so they use the sort.Interface kludge. The order the elements should be put into is not properly a property of the container itself.
What's this "should" you're referring to? There is absolutely 0 practical benefit to the approach you're suggesting, except that it fits nicely into the functional style of Haskell and ML derivatives. There's also nothing stopping you from doing it that way in Go, it would just be less elegant since that's not the way Go is designed to be used (and definitely *would* be kludgey). sort.Interface isn't particularly kludgey (any more than anything in any programming language is a kludge), it just happens to be different from what you've been indoctrinated with.
&gt; What's this "should" you're referring to? You know what the word means. &gt; There is absolutely 0 practical benefit to the approach you're suggesting, except that it fits nicely into the functional style of Haskell and ML derivatives. Don't forget C, C++, Java, *and practically every other significant language*. &gt; There's also nothing stopping you from doing it that way in Go Yes, there is: its lack of parametric polymorphism. &gt; sort.Interface isn't particularly kludgey (any more than anything in any programming language is a kludge), it just happens to be different from what you've been indoctrinated with. Bullshit. The day Go's type system supports the polymorphism necessary to implement sort in the same way `std::sort` and `qsort` are implemented, it will be implemented that way, and will become the standard way. gofix will likely update code from the current way to the new way. And "indoctrinated"? Fuck you.
&gt; You know what the word means. Yes. I was hoping you could provide a *reason* why it should be done a certain way. You have yet to. &gt; Don't forget C, C++, Java, and practically every other significant language. Java doesn't even have first class functions... &gt; Yes, there is: its lack of parametric polymorphism. func LessInt(v1, v2 interface{}) bool { return v1.(int) &lt; v2.(int) } The difference between this and a C implementation is that this one is type safe.
C++, it just doesn't work
But [C++ creates work](http://harmful.cat-v.org/software/c++/I_did_it_for_you_all)!
That must be why we're all broke Uriel, we're too good at this programming lark
Speak for yourself...
Damn, how real is this? It's believable because it's true, and this is great evidence to shoot down some people's ideas.
Not only does it work but it works fast, from compilation to execution. There still are big occasional WTF, like the US-centric time parsing, but a lot of things are so easier to code, and I too remarked that in go I almost never have bugs in my code once it worked the first time : it's very rare to have bugs in production.
It's nice to be notified of nearly every error at compile-time, and 95% of the time being able to compile and run it to see it Just Work (TM). The only issue I've really had with Go so far is how it handles large integers, but this is for a very niche problem set (Project Euler). `big.NewInt(int64(10)).Exp(big.NewInt(int64(29), big.NewInt(int64(20)))` feels so wrong and unnatural (although I understand that there's a reason it's designed this way: Less ambiguity and better performance). Compared to Python, where ints are converted from int32 to int64 to bigint seamlessly, this is rather tedious. Other than that, it is a gorgeous language, and I've pretty much abandoned Python for it now. Edit: I thought I would miss list comprehensions a lot, but I find that their absence results in cleaner code that is easier to understand even when compared to relatively simple list comprehensions.
I know Uriel afk, so myself is exactly who I was speaking for
DEAR SIR, REQUEST FOR YOUR CO-OPERATION/ASSISTANCE MAY I CRAVE YOUR INDULGENCE TO OPEN THIS BUSINESS DISCUSSION BY A FORMAL LETTER OF THIS SORT. IT IS PERTINENT THAT BUSINESS OF THIS MAGNITUDE SHOULD HAVE COMMENCED PROPERLY WITH A FORMAL MEETING OF YOU AND US TO ENABLE US KNOW OURSELVES, HAVE A FORE KNOWLEDGE OF THE NATURE OF THE BUSINESS, DISCUSS AND ACQUAINT OURSELVES WITH THE RESPONSIBILITIES AND FUNCTIONS OF PARTIES CONCERNED, AND APPROPRIATE SHARES ACCORDINGLY. HOWEVER, FOR TIME FACTOR, CONFIDENTIALITY AND PERSONALITY OF PEOPLE INVOLVED HERE IN NIGERIA, WE CHOSE THIS APPROACH FOR THE REMITTANCE OF FIFTEEN MILLION, FIVE HUNDRED THOUSAND U.S DOLLARS (US$15.5M), PLEASE BEAR...
Exactly. Every time somebody asks if the interview is "real" they are proving the point it makes.
It's ugly but it ain't that bad :p - for constants, the int64 conversion is not needed but anyway it's trivial to write a wrapper function which saves you the horror of having to write that out: package main import ( "big" "fmt" ) func b(n int) *big.Int { return big.NewInt(int64(n)) } func main() { n := b(0) n = n.Add(b(1), b(2)) fmt.Println(n) } 
True; that's quite a lot prettier, if still a little "unnatural". Actually, the aspect that annoys me the most is that, as soon as I dive into Big, I can throw all of the operators and "standard" functions away: I'll have to use functions attached to the BigInt type. I understand it's necessary if you don't want to throw the static typing/performance out of the window, but compare the Python and Go solutions to problem 48 of Project Euler (find the last ten digits of the series, 1^1 + 2^2 + 3^3 + ... + 1000^1000) -- my apologies in advance for the crappy Go code: Python #1: print(str(sum(x**x for x in range(1, 1001)))[-10:]) Python #2 (no cheating): sum = 0 for x in range(1, 1001): sum += x**x print(str(sum)[-10:]) Go #1: func Euler048() string { sum := big.NewInt(0) pow := big.NewInt(0) num := big.NewInt(0) for i := int64(1); i &lt; 1001; i++ { num.SetInt64(i) pow.Exp(num, num, nil) sum.Add(sum, pow) } str := sum.String() l := len(str) return str[l-10 : l] } Go #2 (faster, no BigInt): func ModPow(base, ex, mod int64) int64 { acc := int64(1) for ex &gt; 0 { acc *= base acc %= mod if acc &lt;= 0 { return 0 } ex-- } return acc } func Euler048() int64 { acc := int64(0) for i := int64(1); i &lt; 1001; i++ { acc += ModPow(i, i, 10000000000) } return acc % 10000000000 } Now, I *do* appreciate how much more control I have in Go, and both of the solutions above are significantly faster than the Python ones (and, arguably, the solution using modpow is the "right" one), but, sometimes when I'm doing fast prototyping of ideas, I can still hear Python beckon in the distance. I know these are pretty much unsolvable problems, but alas...
I can't help but feel generics would help here
try harder
Go is certainly suitable for game development, but you might find yourself spending a lot of time re-implementing things that just exist as libraries for more established languages like C++
Library-based services need a fair amount of orchestration -- after all, someone has to call them. To begin with, one could use Go as an orchestration language. You can gradually reimplement missing pieces in Go itself. See [pygame](http://pygame.org/) for inspiration. 
Fake and gay
What do you mean? Who needs to map things other than floats?
Operator overloading and overloaded functions are not incompatible with static typing. See C++.
Please open-source your work asap. Others may help you to finish/improve it faster.
Yes, but with two different languages, not only do you need the orchestration code, but you would need an extra layer of language binding across the two languages---not to mention also the impedance mismatch between datatypes. 
I haven't decided anything yet. Just evaluating Go and see if it fits the bill.
It is true that there is an extra layer of language binding, but it is not an issue in practice. It (the binding) can be automated or simplified (as with Go's [cgo](http://golang.org/cmd/cgo/). Once that is done, the orchestration code can use all the higher level syntactic and semantic juiciness such as collections, garbage collection, timers, higher-order functions, multiple return values and so on, all in a portable fashion. It is especially worth it if the API's surface area is huge. 
Do you want it to run on windows? Go support from what I can tell, is pretty spotty on win32 so far.
Wondering about your Box2D port: are you going to change it around a bit or just do a 1:1 port? Most notably, Box2D's collision detection and mapping to custom objects is very messy, with void*'s for userData. Ideally, there'd be a way to use Go's interfaces to make this much neater, right? Couldn't each body be an interface that you could add to your own objects? That sort of thing would be neat.
The result would at least be faster than Python bindings are...
If you want to port box2d, you should use the XNA version as the starting point. XNA is a garbage collected platform, and this box2d version works hard to minimize allocations. I don't know if an interface makes sense for a box2d body - the way the code is structured, the body just has some data, no behavior of its own. It would just be a set of getter() methods. Might as well have a struct with the data and an interface{} to hold programmer data. Like box2d already does :)
Go+opengl is a special pain on windows. Early this summer I tried go+banthar's opengl+exch's/jteeuwen's glfw and had no luck at all. Linking issues.
Actually the Windows port is in pretty good shape this days. Of course there are still things being worked on, but has been usable for a while.
Really depends on what you want to do. I use go as the server side part on web games (and web extensions) due to the efficient and simple json and http packages, the general speed and stability. The only external component that I have to use in this context is GoMySql (you can guess from its name what it's for).
While it may be in pretty good shape overall, FFI/cgo are not working that well. I had problems some time ago to make go-sdl work on windows and gave up and went with LuaJIT instead.
AFAIK even for core parts of the stdlib on Windows it is required to call dlls, so I'm quite sure this works quite well. The issue might be that people who write bindings for existing non-Windows C libraries don't test them on Windows (eg., go-sdl), but I don't think this is due to any limitation in Go's FFI/cgo.
Are there any numbers/data to show how fast and stable Go is?
Very useful. Does it have any benchmark inside?
I google'd a few OpenGL bindings for Go, but most of them are either dead or not up-to-date. So which one are you referring to?
I was not referring to any OpenGL bindings, I was referring to Go.
What kind of "numbers/data" would tell you that? [Here you can see some orgs using Go in production](http://go-lang.cat-v.org/organizations-using-go) for reference, it includes at least one game company.
A number of benchmarks were done but this exercise is always difficult and subject to bias. What can be said without risk is that, *regarding core code*, go is almost as fast as C and much much faster than java, C#, PHP, etc. And it's much faster to compile and deploy. But your favorite library may very well still not be ported or not optimized. I have no information regarding the efficiency of desktop GUI libraries. 
It was a year or so ago. I remember that my messing with go-sdl resulted in a bug report related to cgo on windows and something about callbacks not working. I suppose it is fixed by now, I just stopped caring about Go. I may revisit Go when Go core team decide that Windows is first class platform. In the meantime, there are a lot of fine languages that support all four major platforms out of the box.
A *lot* has changed in the last year, including a complete overhaul of cgo.
What did you mean by /dev/draw?
http://man.cat-v.org/plan_9/3/draw
Thanks. Does that mean that the Go image library provides a similar API to Plan 9's /dev/draw, or that Plan 9 could use the library to implement /dev/draw (does Go compile on Plan 9?)?
I just meant the arguments look similar. There is a Go for Plan9 afaik, though not official There is also Plan9 for unix - http://swtch.com/plan9port/ 