Darwin's version of this change has also been landed: https://codereview.appspot.com/7569043/ I believe that the refactoring was designed to make it easy to port to the other supported operating systems as well.
I haven't dug out my RPi yet, but looking at the current `PKGBUILD`, I'm almost positive I changed this: if test "$CARCH" == x86_64 ; then LC_ALL=C GOROOT_FINAL=/opt/go ./make.bash else LC_ALL=C GOROOT_FINAL=/opt/go GOARCH=386 GOHOSTARCH=386 ./make.bash fi To just this: LC_ALL=C GOROOT_FINAL=/opt/go ./make.bash Since `ARM` isn't `x86_64`, it will otherwise try to compile with `386` flags. Which is fine for the AUR since only `x86` and `x86_64` architectures are supported.
Thanks for sharing. I'm new to go and reading others' source code is always enlightening. Coming from ruby, where everything is an object, it's interesting to see the use of composition instead of inheritance.
That seemed to do the trick! It's still compiling but I think it did the trick. Thanks a lot!
If Sybase SQL Anywhere support ADODB driver, go-adodb maybe candidate for that: https://github.com/mattn/go-adodb
Having just started with Go, and frequently needing to connect to SQL Anywhere databases, yes, I would say keep it up. 
I hope not.
Thanks, that's encouraging! I know SQL Anywhere is probably used more often in a commercial setting so there's little interest in the open-source. Which platform are you using it from?
How would you declare a block without {}? Python gets away with it because it doesn't have block scopes.
I agree - it is also possible (I believe it comes with ADO support), but it's the same as with ODBC - you could also opt for ODBC - it's just a matter of preference: a generic solution over a native binding - both have cons and pros.
Mostly Windows servers, both 32 &amp; 64 bit.
Windows will not be a problem - it is currently the main dev target. I'm not sure about linux though (or OS X for that matter) - whether it's the same low-level C library or will it require the TDS protocol (and the use of something like FreeTDS) - that I don't know.
Looking at your code, I have made some changes http://play.golang.org/p/yA7AsXnwz_. None of it is tested since I don't have database server. Accept it at your own risk.
Nice API... Maybe two things though: You should add a function Fatalf, it comes really handy when messing around in a program's main function. A function Printf would also come handy because people (like me) using 50% of the day "log", I cannot stop typing Printf when working on projects that use a logger that does not have it. Ok, and a third thing :D I personally prefer Errorf over Errf, but I guess that's a matter of taste... Don't forget to add your package to the Go Dashboard, unlike others might state, there are only 2 log packages: log4go (~log4j) and syslog, a syslog server framework package.. ;-)
Hey, thanks for the feedback :) log.Printf should still work just like the standard log package. In fact, anything I didnt expressly set should still work. Adding the Fatal functions is on my to-do list as well, so I'll have you covered there. Regarding Errorf versus Errf, I almost did that, but I decided to keep the naming consistent with the log levels to avoid confustion. You could always write your own log package that extends this one, hah!
I agree - the article said they dropped cassandra in favor of go. That doesn't compute. Like you, I looked for Go bindings too and was surprised that they didn't exist. Strange to promote your usage of Go and then not help to promote Go usage among others.
Never heard of it. /s
I know this is a kind of trolling question to ask, but is there any good reason to use MySQL besides legacy? I've heard a lot of people bitch about it, but never heard anyone say anything good besides it's pre-installed a lot of places. 
it's fast. Often it's fast by being incorrect, but it's still fast. It's a good trade off if you largely use the database as a dumb relational store. It's great for web apps that do nothing but load and store data. (ie. 99% of them)
Cool! I was actually thinking about doing this recently, but was busy with school. Good job!
Are you still pre 1.0? Software changes it's name all the time, I figure it's definitely legit to change it if it's early enough.. Just depends on wether you want to put in the work.. If you do decide to do it, I'll be your find-and-replace monkey! :)
What makes this one special?
There's absolutely no reason you can't have block scopes without {}.
The development language... go
It's been a while since I used this. It would be nice with a high-level change log for this project.
What I'd really like is a standardized engine to deploy apps of many flavors on rather than having to create new chef scripts to deploy everything I write. I essentially want something that works like heroku as far as ease of use for deployment/scaling, accommodates many different application types, and is easy for me to spin up in a 2-4 node cluster on my own VPSes. Every time I have a new app to deploy I just push it to the cluster and I'm done, adding additional VPSes as it starts to get full. I'm hoping this is such a thing, but I haven't tried it just yet, so I can't say for sure. CloudFoundry, OpenShift, etc. seem pretty heavyweight and more meant for service providers or large corporate private clouds. If they can be used like I describe too could anyone provide some links to docs/blogs about it? I haven't found it so far.
Not only this. It also supports different provisioners. It can run with Amazon EC2, lxc and is backed by a [Go interface](http://godoc.org/github.com/globocom/tsuru/provision#Provisioner). To add others provisioners to tsuru, you just need to implement that interface, register it and change the configuration.
That looks like a nice idea, adding environments to apps. Currently, we have tsuru running in a private cloud, and people use different apps for different apps, but they aren't able to migrate data between environments. Regarding the roadmap, we're now preparing it to run large scale websites. We're working in a varnish-as-a-service API, that will be attached to apps.
Hi, thanks for your feedback. We're actually working on getting tsuru to work with [lxc](http://lxc.sf.net), so you will be able to create new containers on your cluster. We're building it to work on a single machine, them manage clusters (load balancing containers, integrating with frontend services like varnish and squid, etc.). At the moment, tsuru is heavyweight too, because it uses one EC2 instance per app unit, we're working hard to get it simpler! :)
Good luck with this. It's annoying to me how few people seem to think that dependency management isn't a huge missing piece in the Go tooling. You were right on in your post: the fact that few people depend on packages that they don't own is a strong indicator of the problem. Right now at work we have to deal with lots of vendored code and git submodules and it's way more annoying than just having a proper dependency management tool. I feel confident that within a few years there will be a widely accepted solution to this issue -- whether it's nut or something else -- and we'll all laugh at the primitive ways we used to manage library dependencies.
Link is dead :(
Is there the same without dead link inside ? It looks like the base of all hrefs is wrong. 
Yeah the repo file is not meant for online viewing but for generating documentation. Here's the same file in hosted enviroment: http://tip.golang.org/doc/go1.1
I agree that a lot of flashy new DBs come with hidden downsides, but wouldn't PostgreSQL have a lot of the same upsides as MySQL?
Thanks, this is much clearer with the links, especially regarding the syntax of [method values](http://tip.golang.org/ref/spec#Method_values). This is especially elegant and obvious now...
`Second, the go get command no longer allows $GOROOT as the default destination when downloading package source. To use the go get command, a valid $GOPATH is now required.` Maybe now I'll stop making the mistake of switching $GOROOT and $GOPATH every time I install go on a new machine.
&gt;Typical [performance] improvements relative to Go 1.0 seem to be about 30%-40%, sometimes much more, but occasionally less or even non-existent. Nice!
It's a good thing I hadn't really used method closures in Go before; this is how I thought they already worked. Speaks well for its design.
Generics in Go 1.2 (pity it is not there yet :(), please please please! ;)
Can you help me understand why you are using runtime.LockOSThread() in func (p *Handle) ReadPacketData()? Would it be possible to achieve the same thread safety with a sync.Mutex, or is there some thread-local-storage allocated by libpcap that you are accessing?
Does anyone know if there are any changes to the scheduler?
significant changes to the scheduler are included. Most impressive is the change that ties scheduling more directly to network polling, allowing much more efficient scheduling when waiting on IO.
cool, good to know, thanks!
It's hard to implement type safe data structures in Go. You basically implement it for each individual type. 
Do most gophers not run tip anyways? I never dared in other languages or programs but Go is solid and I've never encountered any issues. 
Oh, there are plenty of good things that come with generic. First is mentioned type-safe data structures. Second, as FP-guy I miss filter (or .Where in .NET) and map (or .Select in .NET) which allow clean and idiomatic code. Having to write a creation of list, a loop for single selection based on predicate is tedious and generates a lot of noise. Third are universal (polymorphic? not good word) algorithms. Interfaces are not good anwser to that need because od boxing/unboxing and reflecfion in case of map/filter. There is a reason why so many (modern) languages have generics and escaping from this idea is not good. And yes, generics add complexity to the type system but there is no free lunch :(. Lack of generics is the only thing that holds me from wide adoption of Go in production.
If you are honest: How many different data structures do you use on any typical project which do not boil down to the builtin slices or maps (which *are* type safe)? And how many types have to be stored in them? And if you really need fibonacci trees, red-black trees, B*-trees and tries, all specialized for 15 types: Why not generate these specializations (cpp, m4, go run gen.go, got)?
`map` and `filter` are convenient to have, but they're not a huge conceptual leap. It only takes an extra couple of lines to write `for _, item := range items { if cond(item) { results = append(results, f(item))}}` instead of `results = map(f, filter(cond, items))`. I think it would be nice if Go had a unified iterator protocol instead of just a lot of ad hoc ways to do it though.
I don't want to simply because I want to support (library-wise) what golang.org is telling people to download, which is 1.0.3. Maybe I'm being old-fashioned.
No, keep it that way!
Well, yes it is not that hard but still, extra lines for such simple task is extra noise in the code. Btw. in your go code you probably need additional line to declare results variable, so another extra line ;)
&gt; Why not generate these specializations (cpp, m4, go run gen.go, got)? Didn't you say in another post, "One of the good parts of Go is its clearness and how easy it is to read and understand code." Generating code, especially from an external language, adds a layer of complexity and make code harder to read and understand. More so than generics. Recently I've been working on generating D code from a Protocol Buffer definition. Being able to compile the generated code at the same time I'm building the compiler and even unit test the class/struct all during compile time, has been awesome! Why should my build and unit testing script be more complicated than dmd -unittest [pbcompiler files...] ?
Don't hold your breadth. The creators of Go wish to maintain ~~compressibility~~ composability. If you want generic code, then generate it. Personally the lack of generics is just an indicator that their goals for language design don't match the design of a language I'd want to use.
I believe they hoped the end of March. Go 1 was released the same time last year IIRC
Type erasure retains compactness. 
Generating specialized data structures and algorithms clearly isn't an ideal solution, even if done in Go alone, e.g. by use of text/template. But again: How many of those do you need in typical project? I found that the type safe maps and slices accommodate for most of my code. 
sorry wrong correction selection. I meant composability, which is now in my dictionary.
Implementing the algorithms common in compilers is a lot easier with iterators and various sequence types.
[sort](http://dlang.org/phobos/std_algorithm.html#sort) There are some really nice things about this implementation but I'm going over the return type "SortedRange!(Range, less)" This sort will return a container of SortedRange, this allows algorithms to require that only SortedRanges be passed in. It doesn't matter the transformations I place on this when all is said and done I'll have a Range that returns the Element I'm storing and not some Interface which must be cast back to my expected type.
I think the perspective is different here. Generics allows for writing composable libraries. However the feature is not a composable feature. I was also thinking of a pipeline more than composition. code generate =&gt; application compilation I couldn't find the email list I was reading but basically if you can create a program to do it for you the designers don't see a reason to make it a language feature.
Hmmmm, that's an interesting idea.
I agree that "cleverness" in code which makes it all one-liners is not good thing. But well, being able to "compress" 4 line of clear code into 1 line of clear code (filter/map are well-known concepts) is certainly desirable. It makes code more readable by making it shorter. And let's stress that it is true for map/filter constructs (which I ask for) and may not be true for other syntactic sugar. Many people mention that Java is very verbose and thus many lines-long and it is not advantage of this language. Oh and mixing Perl in the discussion is far too much :)
It isn't. This was the approach used by the C Pre-Processor (cpp). gcc =&gt; cpp =&gt; gcc =&gt; ld
Please provide a reference. I use versioned dependency management every day and it's a fine solution the kind of problems I deal with using Go libraries.
Slide 9 is a busy loop, no?
Could not see one of the last slides - to download you need to login. Anyone interested in downloading then sharing the slide deck?
Another really cool concurrency model I wrote the other day is an embarrassingly parallel recursive function. https://github.com/mortdeus/gowl/blob/master/generator/generate.go#L49
To add on to this. Go does not have duck typing! Go is structurally typed. In python lets say you have a function call def quack(duck): duck.quack() and you pass in a goose as an argument. quack(gabby_the_goose) gabby is always a goose in this situation, and if gabby cant quack because gabby isnt a duck then you have a runtime type error. Go on the other hand is different because an interface is an explicit type. package main type duck interface{ quack() } type goose struct{} func (*goose) honk(){ println("honk!") } type mallard struct{} func (mallard) quack(){ println("quack") } func main(){ /* This block of code will not compile because for gabby to be passed in as a duck, she needs to know how to quack. Since gc statically sanity checks whether structs passed in as an interfaces are valid, it will throw a compile time error, rather than a runtime error like python. gabby := new(goose) quack(gabby) */ daffy := new(mallard) quack(daffy) } func quack(d duck){ /*To make it further clear why this is obviously different than duck typing. In python when passing in daffy, d == type mallard. In go d == type duck. In python it is assumed that if a type can walk and talk like a duck, then as far as anybody is concerned its a duck and can be treated like one. If a goose decides it wants to be a duck but cant quack or walk like a duck. Who cares? If it wants to be a duck then its a damn special case duck that can honk. In go the compiler makes sure that no matter what, if we pass in a goose, this goose better be a duck. Otherwise too bad gabby, you are **** outta luck. */ d.quack() } The only feature that is somewhat like "duck typing" is when using an interface{} as a type with the reflect package. You can pass in any type, however as I said before, in python your type is still the type it was before. In go, the passed in value is now interface{}. Which means you have to assert the type of the interface{} if you want to interact with the type's fields or call it' methods. Monkey patching is a key feature of what python can do, but go cant because go doesnt have duck typing. 
What is go operation, and which questions do you have? Perhaps we can help.
Ah, and I was wondering what possible use for this there could be..
`&lt;&lt;` and `&gt;&gt;` do the same thing in Python as they do in Go. :-)
plus fibonacci offers the opportunity to show multiple assignment http://play.golang.org/p/o4Ew0vBTyb
It might not be duck typing, though Russ describes it this way, but it's not strictly structural either. It's really a mix of the two and if you force it, you can do a waddle. type Duck interface { Quack() } func Quack(b interface{}) (ok bool) { d, ok := b.(Duck) if ok { d.Quack() } return ok }
No, absolutely; really it's Go typing which is both more flexible than structural typing and more structured than duck typing. But I prefer to call it duck typing, because I like ducks.
If you can run it with `go run` then who cares if it's "compiled" or "interpreted" -- that's just an implementation detail :)
Indeed, nice one :-) 
I used Go to write a simple web scraper the other day. I could have just read through the man file for curl or wget, but using Go was more fun. :-)
 | shuf -n1
3 commands: xdg-open "$(find ~/Videos/ -type f | shuf -n1)"
... assuming you're on 'nix. I'm sure most people here *are*, but the OP has the advantage of being cross-platform.
Try this: [http://play.golang.org/p/czZd_aNtOr](http://play.golang.org/p/czZd_aNtOr). This exhibits a common idiom: a function that creates one or more channels, then spawns a goroutine that communicates on those channels and returns the channels to the caller. This effectively opens a gateway to the spawned goroutine to the caller via those channels. So now with two channels, we can either set that value or get the value. And everything is thread safe. :-)
hey so I think i got your example working, I initialized channel outside of your setter function (In the global scope) var channel = make(chan int) [play](http://play.golang.org/p/EciMAuD05v), When I run it I get messaging Num is 123 messaging Which is what I think you were trying to get.
As I replied to burntsushi, I don't believer either term is strictly correct - "duck" being incorrect for the reason you point out, but "structural" being incorrect because it is possible to perform runtime assertions to a limited interface and call a method on that interface value. As an example, I could write the snippet I provided earlier in a way that operates almost exactly as a python duck-typed call. Behind the scenes there will be a statically typed value that is being called, but for the purposes of the caller it is ask for forgiveness, not permission. func Quack(b interface{}) (ok bool) { defer func() { ok = recover() == nil }() type Duck interface { Quack() } b.(Duck).Quack() } The upshot of this is that really neither "duck" nor "structural" should be used since both mislead; Go does this Go's way. I'm torn because it's pretty clear a new term is needed, but the last thing the commnity needs is a new term to argue over. I'd love to see Rob's comments on this that you mentioned, can you point to them? 
I'm a newbie, too, but I think this should fix your problem: line 21 `channel := make(chan int)` should be `channel = make(chan int)` The reason (I think) is that := will initialize a locally scoped "channel", whereas = will assign the globally scoped "channel".
&gt; no freedom to write go code anywhere in your file system Assuming you only have 1 static GOPATH. Then yes. Although even with this setup all you need is a symlink into a directory in the GOPATH for it to work. &gt; no support for setting up a reproducible development environment or packaging a locally set up environment The elaboration in the paragraph makes it seem that this must be talking about dynamic C library dependencies. AFAIK there is no language that handles this perfectly. &gt; no support for managing dependency versions Yes. I'd like to see this addressed. &gt; URL-ish looking imports in your code Not sure I see the problem with this. A matter of taste I suppose. 
Can't Virtualenv (probably with some slight modifications) be used to create different workspaces?
https://groups.google.com/d/msg/golang-dev/FKSzZHLylq8/n2XFJ-ORlQEJ
1 . The URL-ish looking imports allows go get to auto fetch dependencies. When I first started using Go I suggested this to be cleaned up because it bugged me, but a year later after understanding many of the decisions used for the features of Go. I find it an appropriate solution. Also if we really wanted to clean up the import string we can register a website url and use app engine for an essentially free way to proxy go get github. I plan to do this with my gocos2d pkg when its ready for production. import "gocos2d.org" is alot cleaner than import "github.com/mortdeus/gocos2d.org" Its also alot cleaner than creating an organization that shares the same name as the project. import "github.com/gocos2d/ (then what, gocos2d/gocos2d? gocos2d/pkg? gocos2d/lib? gocos2d/main?) " All options in my opinion are ugly, and annonying. Plus im not a huge fan of advertising other sites. Although I love github, and wish for developers to support and use it. I didnt like the fact that I felt forced to tie their brand to my brand. Also my project aims to support 3rd party plugins for the gocos2d engine. I didnt like the fact that the import paths didnt immediately provide a uniform way to associate the plugin was for gocos2d. If developers create plugins hosted on their own repos, other developers who imported those dependencies would see "github.com/developer/plugin". I dont want to maintain "github.com/gocos2d/plugin" repos. A better solution would be to let developers create github like project pages on gocos2d.org that will allow developer to point go get to their projects. So after learning about being able to use a meta tag to directly proxy go, then all my problems with URL-ish looking imports went away. I realized how simple and obviously powerful the mechanic is and how all other options are essentially broken by design. 2 . In terms of dependency management across versions. I have mixed feeling about this. I believe bleeding edge code should just work. In many cases my experience with using go is that changes in dependency's done by other developers typically lead to better code and hardly any sort of regressions. The same goes for my changes and typically I encourage developers to use and have faith in my master build. Just like Go's standard library design, I do alot of thinking about designing my project's API that is exposed to the developer before writing code so I dont have to ever introduce backwards incompatible changes. Though im not a perfect designer, I do feel confident that a consistent and idiomatic method of writing go functions will lead to less changes in the api as a consequence of thoughtful design. On the other hand, there is a theoretical chain of trust issue if packages import packages that import packages that import even more packages all from remote sources. There is no telling at any given moment when a developer imports a dependency nuke. Its very easy for our projects to get blamed for a malicious change in a dependency import that all of a sudden erases saved game files, or something else malicious like spying on the user just because of the way dependencies are not immediately visible to the developer. Though we can investigate the issue and point our fingers at the real culprit, the damage on our reputation and reliability has already been done. I assume projects like http://www.gonuts.io/ aim to make these kind of issues with bleeding edge package dependency less of a pain, though its not a bad idea to just self contain your package and only import from packages developed by somebody you can trust. 
 import "gocos2d.org/v1" You'll be glad when you want to deprecate that API.
You probably want something more like [smartcd](https://github.com/cxreg/smartcd) or [directory specific shell configuration with ZSH](http://michael-prokop.at/blog/2009/05/30/directory-specific-shell-configuration-with-zsh/) to set a local `GOPATH` after `cd`-ing into a directory.
 import gocos2d "gocos2d.org/v1" To keep the code clear.
This looks pretty interesting.
I guess you're right actually.
I'm using this [makefile](https://gist.github.com/lukaszkorecki/5281267) and it works fine for me - no need for hard-coding GOPATH in my zshrc (or bashrc)
From that discussion, and the linked WP page that Rob cites, you would say that most idiomatic Go is not duck typed. Any use of reflect and you get the potential for duck typing and it is possible, as I show above to have duck typing behaviour. At best it's a ducky structural typing.
Fair enough. 
As I stated above interfaces and reflection do in many ways blur the differences between python's duck typing and go's interfaces. However that doesn't mean go isnt by definition structural typed. It just structural typed with reflection. The difference becomes self evident when we examine how python allows the user of an api to modify the 3rd party source at runtime without breaking other code that depends on the default behavior of code by using a technique called monkey patching. This is something we cannot do in a statically compiled language without compiling the source. Though the rate go compiles code makes a way to emulate this feature practical its a hack. Just like your method is a hack. Just like there are projects out there that attempt to hack generics into the language. Just because we can write hacks to simulate other language features, that doesn't change what the type system looks like as far as the compiler and runtime is concerned. Saying go is duck typed or saying it is kinda duck typed is wrong as far as computer science theory is concerned. I think that is because the name of the type system is too broad. If it walks like a duck it is a duck isn't really how duck typing systems view the types. Like I said earlier its more like a if it walks like a duck but is actually a goose, who cares? If it can act like a duck it can be treated it like a duck. 
The funny thing about abstractions is that you get to choose where to make them. I think we are largely in agreement, but I think you are being overly strict; duck typing does not require that you be able to change the behaviour of a value at runtime, just that you be able to test at runtime. This is the case for Go. Just because interpretable languages are able to monkey patch and use that in conjunction with duck typing does not make duck typing dependent on the existence of monkey patching in the language. The point that I was making with the previous comment is that you don't get to choose which parts of the language are the parts that get included, the language spec/implementation do that. Go can behave as if it were duck typed, this satisfies a meta-duck analysis. Go looks and behaves like a duck typed language when used in particular ways, that makes it a duck typed language - when used in those ways. They may not be idiomatic, but they exist. I'm not really sure where you're going with your last paragraph.
&gt;No I used monkey patching as an example of what can be done in duck typing systems that can't be done in structural type systems. It may well be true that it can't be done in structural type systems, but that it can't be done in system X does not show that system X is structurally typed. &gt;Its not even kinda duck typed. And yet this code is legal Go: func Quack(b interface{}) (ok bool) { type Duck interface { Quack() } b.(Duck).Quack() } This can be called with any type as a parameter and will behave as duck typed code in python even doing the near equivalent of an exception when given the wrong type; the assertion check is indeed performed at run time. True, there is a static check that the value resulting from the assertion is capable of having Quack() called, but that does not diminish the fact that there are runtime checks on the value's capacity to satisfy the assertion based on behaviour. If there were no run time checking here, a lot of the complaints about lack of generics would go away (i.e. performance). &gt;Interfaces are static types checked by the method structure of a type during compilation. Duck typing checks during runtime. Yes, Go interfaces are static types, but assertions are run time checks. &gt;Its like comparing a tad pole to a minnow. They are perhaps similar and may be mistaken for each other. That doesn't change the fact that a frog is way different than a fish. Saying a frog is a fish doesn't make any logical sense. Saying it is a fishy frog just because a frog can swim is even sillier. Are we fishy people because we can swim? No, it's very much not like saying that. We can however make a run time assertion that all of these - and any other type (though others may fail this assertion) - are Swimmers, or even interface{ Swim(); } if we don't feel like giving it a name. &gt;The fact is saying Go is duck typed results in people not understanding scientific terminology. There shouldn't be any misunderstanding about this discussion. Ontology and semantics are hard. The issue, I believe is more subtle than you are allowing. &gt;Pointing out the difference educates others so that they know there is a significant difference between Go's interface types and python's duck type system. Yes, they are different, as I've said. They are also, however, similar. The subtlety that Go gives here is one of the very nice things about it. The balance of compile time checking in most of the places where you might want it in conjunction with the capacity to do these kinds of things - which you disagree are duck typing - makes it beautiful.
I'd love to see something like this land in the official 'go' tool. Depending on random environment variables to build things always drives me nuts. In the mean time I usually just drop a Makefile into my top level directory (above src/...) with: all: @GOPATH=`pwd` go install -v ./... test: @GOPATH=`pwd` go test ./... fmt: @GOPATH=`pwd` go fmt ./... clean: rm -rf pkg bin 
I set it when I downloaded Go, and I haven't changed it since. What could be easier? :-P More seriously, if you depend on a library outside of your control, fork it. You have no way of knowing if its future evolution will work for your project or not. Just fork it and pull changes as needed.
Couldn't you achieve the same thing with the following in an alias or something GOPATH=$(dirname $(pwd | grep -o '.*/src/')) go or even GOPATH=$GOPATH:$(dirname $(pwd | grep -o '.*/src/') go to pick up existing, possibly shared GOPATHs . No need take a step back with adding useless files to the project. And it also works in shells that aren't bash. And why do I need to set some arbitrary **static** env var(`GOTOOL`) .. in fact, I'm pretty sure those install instructions don't work, because it essentially hard-codes a directory into my *global* env, so if I change project I must source `.bashrc` again. and every time I do that my `PATH` grows with the duplicated paths for no apparent reason. Please correct me if I'm wrong. I didn't take my meds today.
Yes. Yes. Import paths can be a bit of a pain though.
If you're just hacking on your own, just running 'go get foobar' is great. However, if you're working on a larger project, I believe it is better to mirror the repositories, and then install them in your src/github.com/foo/bar directory yourself. We're currently experimenting with git submodules.
When you have to maintain more than one Go project, that share some dependencies, there is no way to specify different dep versions for each project. That's why many people, me including, have separate GOPATH for each projects. This tiny wrapper makes managing those GOPATH easier.
You could achieve similar behavior with that alias, yes, although the wrapper deal with some other cases, like no .goproj file. The reason a .goproj file is used is to ensure that automatically setting the GOPATH is a conscious choice. For example, "src" is a very common name that could easily be somewhere up in the directory tree. Also, the GOTOOL env variable points to the original go tool binary which won't change so it's ok to be set to a static value. The GOPATH is set for each command invokation on the wrapper, so it won't be necessary to reload your bash config.
Right now, only bash is supported but I definitely have plans on extending it to support ZSH. Feel free to make a pull request if you're feeling compeled to do it, though :) It's a very tiny wrapper, I'm sure it can be adapter to zsh without much trouble.
&gt; The laptop will 'go install' to $GOPATH/bin, and the desktop complains 'no install location for command-line-arguments'. It will build to the local directory, but won't install. I can't understand it. If you post the commands you're trying along with the output to a pasty or something, perhaps someone can help you. :-) (Please also include the results of `env | grep '^GO'`.)
I am working on a Ruby project right now and I had to spend all day understanding how to set up and work with this rbenv/RVM, Gemset, bundler, etc fuckery. Only after working with this crap one can appreciate and love the simplicity and beauty of the Go toolset.
I wrote almost the same exact thing a few months ago: https://github.com/cespare/go-localpath
This is OK if you're working alone, but if you're working with a team you'll need some way of ensuring that you have the exact same dependency code. At work we're using git submodules in combination with per-project GOPATHs to accomplish this. IMO a real dependency versioning system would be better.
If you run that snippet, your .bashrc (or .bash_profile) should contain the expanded values of that. It should look similar to this: export GOTOOL="/Users/divoxx/Projects/goproj/bin/go" export PATH="/Users/divoxx/Projects/goproj/bin:${PATH}" Is the variables not being interpolated for you?
Ah, yes, you're right about that. This script does not attempt to solve the lack of proper dependency management. It just try to give a simpler way to isolate the repos and manage multiple go paths.
&gt;It doesn't feel like a language designed for traditional web applications such as Rails As you said yourself: Rails is a framework, Go is a language. Go's net/http package is all right, but there is nothing preventing you from making frameworks like Rails for Go.
There are already a few projects cropping up that are doing just that. Gorilla Toolkit looks like a great resource for instance (http://www.gorillatoolkit.org/)
Your alright.
It seems like every week someone announces a new Go web framework. If I had to say what Go is the "best" tool for, I would say, writing web servers.
Adding frameworks worries me in that I think it will end up negating the performance benefit many people are finding by switching to Go. By avoiding frameworks and using simple toolkits a Go application avoids all the cruft that isn't necessary
&gt;Adding frameworks worries me in that I think it will end up negating the performance benefit many people are finding by switching to Go. Even if the framework is slow (i.e., inefficient), it will probably still be faster than Rails, as Go is (much) faster than Ruby.
From the [source](https://github.com/fern4lvarez/gonverter/blob/master/gonverter.go): // Converts a `string` into a `int`, error handler func StoIE(s string) (int, error) { i, err := strconv.Atoi(s) return i, err } I hate to be negative, but this library appears to be a renamed strconv.Atoi and a very sloppy boolean definition... it's nothing but trouble waiting to happen. Sloppy booleans are a mistake; don't port them from other languages, learn how to use the more strict ones correctly, it'll save you in the end.
Wow, this is excellent advice! A couple of these items will require me to think a bit before I can make the changes (example: using a struct instead of makeHandler function). Thanks for taking the time to look into it, and even highlight the lines you're referring to. I'll begin to make the changes that I understand and start to think about the changes that I do not yet understand.
No worries, I feel like your comment is more constructive than negative. I'm the author of this library, and as you can guess, it is not a big deal. Indeed, it is my first Go library I've ever written (just started with golang 1 or 2 weeks ago), only wanted to start with something simple and kind of useful a the same time. Of course Go already provides type conversion out of the box, although I saw that sometimes is not that easy to find the right methods (not all type conversions are within strconv). My approach is put together most type conversions within the same library, having a consistent interface, based on patterns (B for bool, S for string, and so on), so the developer doesn't have to worry about where to find the right methods for that, it just works (based on the conversion specs). Or even useful for check the code in order to know what's the easiest way to achieve some conversions ( int(3.4) will be always simpler than gnv.FtoI(3.4) ). So, I will keep working on this as a playground library, extend the documentation to reflect my here explained approach, trying to cover the most of the type conversions (even if some of them make no sense) and hoping to get further feedback or (much better) direct contributions to the repo.
Nor should they. false to string =&gt; "false" "false" to bool =&gt; true Each of those conversions make sense. If you were to preserve round trip it means that "false" would become false, which means you have a magic string, which is just inviting bugs and security problems.
http://swtch.com/~rsc/go11.html https://www.google.com/search?q=Go+1.1
http://swtch.com/~rsc/go11.html
You can test it agains 1.0.3 with this awesome tool - https://github.com/davecheney/autobench
Thanks! I don't know why, but it didn't even occur to me for a second that I could just google it o_0
Because Go is hard to google for :(
Would love to see more documentation or examples about these new Method values, I don't get their point 100% yet.
I just tried this but I get the following compile error: /home/X/dragons/autobench/work/go.103/src/cmd/cc/funct.c: In function 'dclfunct': /home/X/dragons/autobench/work/go.103/src/cmd/cc/funct.c:273:13: error: iteration 94u invokes undefined behavior [-Werror=aggressive-loop-optimizations] f-&gt;sym[o] = S; ^ /home/X/dragons/autobench/work/go.103/src/cmd/cc/funct.c:272:2: note: containing loop for(o=0; o&lt;sizeof(f-&gt;sym); o++) ^ cc1: all warnings being treated as errors ---- Edit: In `work/go.103/src/cmd/dist/build.c` add the following to the array `proto_gccargs` in line 379: -fno-aggressive-loop-optimizations
I suspect that the new method values have more profound implications because of the change in the underlying representation, but from a user point of view, it's just convenient currying. In Go 1.0.x: st := SomeType{} DoSomethingElse(func() { st.DoSomething() }) Is equivalent to this in Go 1.1: st := SomeType{} DoSomethingElse(st.DoSomething) (Assuming appropriate definitions of `SomeType` and `DoSomethingElse`.)
Unfortunately it's currying limited to a single "parameter". That is, only the receiver can be bound in advance. More general (implicit) currying like the following still wouldn't be possible: func curried(a, b int) int { return a + b } var plus10 func(int)int = curried(10) fmt.Println(plus10(5)) // prints 15 
I wonder if the google guys added some hack/rule/whatever enable googling "golang" as an alias for "go", or is it something organic. But it's the only way to get meaningful results.
It is? Where did you see this news at?
I wouldn't call that a bottleneck. 
Tried: http://godoc.org/github.com/tcard/functional#Curry
Just put the examples in a sub-directory, instead of in the Readme, and just put more comments in those. Don't worry about telling people how to set the GOPATH, they will figure it out for themselves. Looks OK so far, keep going!
Quite a bit of discussion about the general pros/cons of Go over at [Hacker News](https://news.ycombinator.com/item?id=5491104).
I doubt it, it's too specific to zsh
There's already some zsh tab completion support in Go: https://code.google.com/p/go/source/browse/misc/zsh/go
cool, I'll see what they say over at go-nuts.
Just doing: go test -race mypkg makes me feel all warm and fuzzy inside
Hum, it's strange I missed reflect.NumIn when I wrote that!
We did not. It's not our job to make search work well for Go. It's search's job to work well for anything. 
looks good, congrats. i &lt;3 go, its understandable at a glance. so cool. cant you do w.header() .add('content-type: asdf') .add('http header') probably reference this when i build my first http app. gj
If you want to skip to the more interesting tidbits, see the `Examples` section for the [github.com/BurntSushi/ty/fun package docs](http://godoc.org/github.com/BurntSushi/ty/fun).
Silly author. Everybody knows that generics are unnecessary and can easily be replaced with external code generators. On a serious note: Are there such generators out there?
&gt; Are there such generators out there? The only one I know of is [gotgo](https://github.com/droundy/gotgo). It's really cool and great work, but it's still a WIP.
I think this is the aim of the [gotgo](https://github.com/droundy/gotgo) project. I would have loved to embark on something similar, but this was all I had time for unfortunately. (The investment would be so large that I'd sooner use a different language for the job if I wanted different kinds of polymorphism that badly.)
Or, you know, add generics.
&gt; One nuance to note between the aforementioned extension and the gotgo approach (as far as I understand it) is that in the former, directly-compilable go code is present in both steps. Ah! I misunderstood. The problem is getting at the parametric types. I'm almost certain it would have to be done via convention. For example, `Map` is defined as: `func Map(f, xs interface{}) interface{}`, which doesn't give any hints as to what *any* concrete definition would look like. In my package docs, I've adopted a convention to describe the parametric type, but this could obviously become stale at any point. If you solve that problem, then you still have another one: dispatch. The invocation of a generic function either has to change (say, from `Map` to something like `mapIntToString`) or `Map` has to be changed itself to do some sort of dynamic dispatch based on the types of the arguments. Both have their costs... The former keeps things fast but mangles more code. The latter slows things down but mangles less code (in fact, it would only mangle the code of type parametric functions). [EDIT] Thought of another problem: with my package, the client needs to type assert the result of a type parametric function.
Ah, right. Doy. It's still a little hand-wavy (multiple returns?), but if you banged on it long enough... :-)
&gt;if you banged on it long enough... :-) Indeed! I think this probably falls under the category of "fun to think about but not particularly likely to be a worthwhile investment for the expected (uncertain) gains in productivity."
I have a simple one included in my build helper https://github.com/metaleap/go-buildrun but that would only help if you choose to build with said build helper..
It also looks rather stagnant - no modification in the last five months.
&gt; I tried to name routines and variables like in the paper, which explains the now outdated upper-case names. Similarly, I tried to make the function signatures as similar to the paper as possible, so we mostly work directly with channels, where one would hide this implementation detail in real-world code. The ugly name prefixes like "S33_" make godoc order the types by section of the paper. I really like this. It shows the intent of code-as-an-example.
Link directly to the code: https://github.com/thomas11/csp/blob/master/csp.go
I realize this is probably not a big deal with 1.1 coming out, but I'm wondering why 1.0.3 **FreeBSD 386** is missing? 1.0.2 **FreeBSD 386** is there in the deprecated downloads. Why was nothing built for 1.0.3? EDIT: Specifically, FreeBSD 386
[The 1.0.3 builds *are* there and tagged as featured when I view it.](http://i.imgur.com/dFQdlcw.png)
Brainfart, I neglected to mention FreeBSD 386 specifically.
I really like that he wrote the tests, too. (well most of them anyways) &gt; Most of the examples have tests, although I have not taken a lot of care to test corner cases. " Direct link to tests: https://github.com/thomas11/csp/blob/master/csp_test.go How do you create a code coverage report? I tried using https://lincolnloop.com/blog/2013/jan/4/test-coverage-go/ but did not get very far. 
[Link to the paper](https://www.google.co.uk/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=1&amp;ved=0CDQQFjAA&amp;url=http%3A%2F%2Fciteseerx.ist.psu.edu%2Fviewdoc%2Fdownload%3Fdoi%3D10.1.1.132.6772%26rep%3Drep1%26type%3Dpdf&amp;ei=anNiUbjiL4HcOpW_gKAE&amp;usg=AFQjCNHuwKolmrUqHuz-QaHg8BMjVeYsWg)
Dunno why yet, but gocov doesn't like TestIntSet. Edit: it works fine with Go tip. I think it's probably due to an order-of-initialisation bug fixed in Go after 1.0.3. Edit2: http://pastebin.com/RseZQngS
what about merging this on the "official" golang zsh plugin? https://github.com/robbyrussell/oh-my-zsh/blob/master/plugins/golang/golang.plugin.zsh
Sorry for being a total noob here, but how do I install this? I have oh-my-zsh installed if that changes anything.
I skimmed through the tour, then read the [spec](http://tip.golang.org/ref/spec), but most of my learning was done by jumping in with both feet and writing small real-world programs right away.
Not to be pedantic but the best way to learn is to jump right into the fire. Do the tour, open up the documentation and start writing code. I tried watching a few talks but as the community is pretty much Google at this point, there really aren't a lot of conference videos or stuff like that to point you to. There really aren't a lot of best practices besides what team has put out. Personally, I've found the go source to be one of the easiest to understand standard libraries / language implementations I've read. It might be worthwhile for you to jump straight to reading the code from the standard lib. Pick out a library / package you like and re-implement in a different way. Or, find something lacking in the standard lib and write a package for it. Just jump in and start writing code. =)
Like others mentioned, reading the Go std lib code is a really good way to learn both the language and good practices. When I started it was pretty much the official documentation but now there is a lot of resources out there. The mailing list and IRC channel are also a great place to hangout, you can ask question and learn from other people questions. You can find some good resources: * https://code.google.com/p/go-wiki/wiki/Books * https://code.google.com/p/go-wiki/wiki/GoTalks * https://code.google.com/p/go-wiki/wiki/Articles * https://github.com/alco/gostart * http://www.golangweekly.com/ I recently stumbled upon this and since you mentioned Python it might help you: http://s3.amazonaws.com/golangweekly/go_for_pythonistas.pdf Hope this helps :)
A mixture of http://www.golang-book.com/ and the tour. Nothing beats experience though - I wrote a highly concurrent TCP logging daemon, and a small script to concurrently poll status of a bunch of Mercurial repositories on disk. 
I worked through the entire tour. The exercises were pretty enlightening and gave me a good feel for the language.
It's official! "Your Organization Application for 'M-Lab' in Google Summer of Code 2013 has been accepted." Interested students should start getting their applications/proposals together :-)
This is what I'm doing to learn Go: 1) I'm reading [The Way To Go - A Thorough Introduction To The Go Programming Language](http://www.amazon.com/Way-Go-Thorough-Introduction-Programming/dp/1469769166) - I got the Kindle version but the formatting sucks, so I found a PDF version online, much better to read on a tablet. I wish Amazon had an option to buy PDFs for technical books. I'd like to read the book first, before coding, so I'll know exactly what the language is about, what can be done, how to do it, and the "Go" way to do things, to avoid many of the common mistakes that we do when we first start with a language. 2) Then I'll read the entire documentation of the standard library - every function, what it does, how/when to use it - both to learn the standard library itself, as well as learn the "Go way of doing things" according to the language creators; 3) I'll check out the most common Go web frameworks and choose one (the most feature-rich) to focus on. I'll adopt it on my own web projects and contribute to it; 4) Next I plan to create my own web framework (basically a Drupal-ish port to Go, called "Grupal").
I don't expect it to 'stick' by just reading the book. I'm reading it to get a thorough overview of the language and all it can do, and how. Then, it will stick once I start putting it into practice. It would be akin to using unix sockets to do IPC between goroutines because I didn't know about channels, because I haven't read about it yet. Now imagine this same issue but applied to a more obscure feature of Go. The same thing happened to me, for example, when I was learning Python and I wrote my own function to walk down a filesystem path because I didn't know os.walk() existed, because I hadn't taken the time to read the standard library. It's quite ok to go little by little and making these little mistakes when you're a newbie and want to learn the language by yourself, but I work professionally and I would hate to make the same mistakes on production code. That's why I first get a thorough understanding of the language and library before I start *coding away* on production stuff. Also, once you're proficient in a half dozen languages, the idea of "little by little" makes little sense - a lot of the language's behavior can be inferred just by reading the code, then you only need to *play* with more obscure things (channels, channels of channels, marshalling complex nested structures, etc).
Another example would be me writing my own profiling stuff, not knowing that http://golang.org/pkg/runtime/pprof/ exists - that's a lot of time that could be saved. It takes less time to read pprof's documentation than it would take to write my own implementation. So if I'm doing something and I need to profile it, I'll remember that there's already a package for that on the standard library (because I read about it) and I can consult the documentation for the specifics on how to use it properly. Of course I could gung-ho it and just Google every single question that I come across ("how to profile Go code") and that works too - it's just not that comprehensive or optimal when you want to optimize for quality and development time.
project euler and rewriting [my blog](http://jmoiron.net) (again)
Ah, nothing graphical or fancy. Command line interface for configuration, and external hardware with buttons, switches and LEDs for calling for the elevator and such.
These slides are written by Rob Pike and are slightly out of date, but they were the my main reference in the pre-1.0 days. http://go.googlecode.com/hg-history/release-branch.r60/doc/GoCourseDay1.pdf http://go.googlecode.com/hg-history/release-branch.r60/doc/GoCourseDay2.pdf http://go.googlecode.com/hg-history/release-branch.r60/doc/GoCourseDay3.pdf I still think they are the best guides out there, despite being a bit dated. They were invaluable when I jumped in and wrote a small first project in Go two years ago. Additional as a reference, run godoc locally for a super fast reference manual: godoc -http=:6060 open http://localhost:6060
I have to use it as part of a course in school in concurrent programming. Have learned to love it.
OK, we're talking about different things. I mean that you should be making little toy programs as you go to make sure you've got the basics down. You're talking about how to write real programs. Those are different goals.
How do you measure your progress? That could change our answer drastically.
I strongly recommend following that up with John Repy's very accessible paper, "[CML: A higher concurrent language](http://dl.acm.org.ezproxy.library.tufts.edu/citation.cfm?id=113470)" (1991). It has an amazingly simple and straight-forward form of compositional concurrency that I would *love* to see in a language today. PM me if you need help getting the paper.
I read the docs, started following the mailing list, and jumped in and just wrote some code. If you've programmed in another C-like language before it's quite easy to learn Go. My first project was porting some Node.js code to get a feel for the language. 
I started with it when the tour and resources weren't around. I read the Spec and watched a few of the videos that Russ and Andrew did. They were surprisingly helpful, and the Spec is really readable. After that, I just started writing in it. It was pretty natural. I had the largest problem with pointers, as I had never understood them, coming from languages like javascript and visual basic. I had tried learning C before, but it got very confusing very fast, and I couldn't get pointers (which made it impossible).
What kind of programs did you write?
I had a little tool which used a google doc spreadsheet that I wanted to do some heavier processing on and had run across the google drive API in go. What began as a simple downloader quickly got out of hand and turned into an entire dedicated web application. Writing web apps in go turned out to be surprisingly straightforward.
I used it to write http://github.com/burke/zeus. The code is complete garbage and I feel bad about barely touching it since, but it got me into the swing of writing Go code. The stuff I've written since has been much less bad. Basically, pick a project and run with it. Watch Rob Pike's talk on concurrency patterns in Go and then just start writing code. Google and golang.org are your friends. Make sure you google with "golang" rather than "go".
Agreed! Anyways, making *toy programs* are definitely more fun!
Because we lost our 386 FreeBSD machine just before 1.0.3 was released, and only got a new one recently. Barely anyone was using it. You're the first to notice, I believe.
Not to nitpick, this is something I do when learning something new (sometime work sometime don't). But before writing a profiler, wouldn't you ask Google god?
The profiler thing was just an example. Sometimes there's something simple enough that you just assume won't be in the standard library (like os.walk() in python) and you just go ahead and implement it yourself.
I got right on it. After going through the tour I started looking for a pet project to build. It just so happens that at workana.com we were having a problem that needed solving: we were using Google's goo.gl service for shortening URLs and when we issued a bunch of API requests on a short time span we would see some of those requests fail with a rate limit exception. This was insane since the daily limit is set to one million requests and we were nowhere near that. I thought to myself: now I have something to build. I did see a couple of other shorteners built in Go but none of them satisfied my needs: it should track statistics the same way goo.gl does, it should use Redis as a backend, and it should offer a goo.gl compatible REST API. So I got right on it and built https://github.com/mariano/goshorty At first it was meant to be a backup for those cases on which goo.gl was failing, but we were so happy with its performance that it became our main tool for shortening. Its published at http://gos.io So look for a problem you are having. It doesn't have to be an original problem. Just look for something you need solved a certain way. Then, once you know what you need to build, go through the documentation and start applying what you read to your own pet project. Hope this helps
I wrote bindings to the X protocol. I don't recommend taking the same path. :-)
Not OP but I write things like url redirectors: It's always annoyed me the way chrome handles local urls as-if they were searches so wrote a little server that will check the url query and if it looks like a local url i redirect to it, otherwise I redirect to a search engine. Soon after that it occurred to me that I often mistype things and press enter before the completion has a chance to display . so it now checks for common typos as well. I grew sick of cygwin's broken ssl so i wrote a download util to replace curl. it handles remote urls as well as files, etc. i got sick of fossil's crappy cui so i wrote a wrapper around it that simplifies its use along with sublime text. the whole fossil ui thing got old pretty fast, now i setup a url in my proxy server written in Go, to proxy the url `fs.l` to fossil via cgi, etc. etc.
Riding the bus for 2 hours a day, frustrated at how terrible the Android build system was.
I started with that tour, couldn't finished because I just wanted to do real stuff. I started to read real Go code, such as this IRC client: https://github.com/fluffle/goirc While reading, I found many points in the syntax I didn't know, so I looked for them and learned them. Then I started to read another simple Go libraries I was finding on GitHub or through godoc.org. Then I continue the tour, coding stuff by my own and really liking it. Then I implemented a super simple command line calculator and a type converter which is my first library: https://github.com/fern4lvarez/gonverter Then, reading lots of articles from different sources (this video is mandatory: https://www.youtube.com/watch?v=XCsL89YtqCs), until I started to read officially Effective Go. For me, the best Go book ever written, and for free, of course! You can even get it as a PDF or ePub on this repo: https://github.com/gokyle/gopherref Now I'm in the middle of this read, but it's hard because many ideas doesn't stop to come to my mind to be implemented and I feel like wanting to code. I try to find the time for all of it. This story is just 3 weeks old, never loved a language before in such a short space of time. Enjoy!
I had the docs handy while writing code for Stipe CTF 2.0's last challenge. Fun, great in the end when it worked, and damn it was fast!
I definitively think that's true. However I don't see the problem in reading the books first and learning what is available in the language. It help to know which feature are available and what to look for when you hit a problem.
Read the spec and Effective Go and wrote a lot of simple stuff. My favorite was a server emulator for an mmorpg.
https://google-melange.appspot.com/gsoc/org/google/gsoc2013/m_lab
Which game did you write the server emulator for, how did you find the info to do that?
I would like to toss out a link for [Learning Go](http://www.miek.nl/projects/learninggo/) and [Let's learn Go!](http://go-book.appspot.com/).
Legend has it that Go is not the best option for realtime stuff because the garbage collector creeping up at random times. Just a heads up, before you decide to start using Go to control cruise missiles!
Florensia Online. I got most of the information by reverse engineering the client and analyzing traffic with Wireshark. Some information on random game hacking forums were helpful too. The most annoying part is to figure out how the traffic is encrypted and the project didn't get too far before the encryption was changed. Never found time to figure it out again. If you can't find it on the internet and have no interest in reverse engineering, you're going to have bad time.
Oh I don't have any interest in actually doing it. I was just curious about how you did it. Emulators and reverse engineering are fascinating subjects. I just don't have time for much.
I used Project Euler like others to get the syntax down. After that I highly recommend picking a small project, and just going for it. If you have written a slightly larger than trivial project in another language, then rewrite that. Rewriting things you have done in other languages is great for me, because I can focus specifically on how to do it the GO WAY. Not figure out Go and the problem domain. Also, the IRC channel freenode.net#go-nuts is invaluable when documentation and other sources fail.
Why are url shorteners popular for local sites? Surely you know the referrers for links coming into your site. I'm not a web dev or webby person so I'm not too sure on the value of a lot of this stuff so it's a real question and not sarcasm. Thanks
We needed them for a referral program where people would share an indeed LONG url on different platforms (twitter / facebook / email / others). As such we wanted a short URL someone could easily copy and paste, that would not break on dumb-ass email clients that tend to do that for long URLs, and avoid such issues.
You could try to adapt OMeta to Go. That would give you a lot of power in many domains, including code transformers.
Yes, yes, "add generics"...but which ones? There's something like a dozen possible polymorphic static type system extensions, starting with the pitiful C# "halfway-generics", all the way up to Haskell GADT+a-few-other-goodies, capable of encoding generic functions with ad-hoc extensions (http://www.haskell.org/haskellwiki/Generics)
So in the dinning philosophers you have made the room check that no more than 4 people are in the room. How would you implement one of these solutions: http://en.wikipedia.org/wiki/Dining_philosophers_problem#Solutions
a lot of people still use windows xp, and the xp market is almost completely 32bit. In the linux market there are plenty of 32bit users aswell, whether they are using old hardware or trying to squeeze out some extra memory. I have no clue about mac tho. Really though, it takes a few seconds to compile a binary in go, so why not just do both and give your users the choice?
I'd settle for the C++ ones thanks.
Except for cgo related packages correct, or has this changed? I remember with 1.0.2 a go package which used cgo I wasn't able to find a good way to build cross platform bins. I think the net package also has this issue, but there is a flag that can be set so go build links the pure go networking library instead of the native library via cgo. 
Apple only ever sold a few Intel 32 chips, and they're not supported by Apple anymore. You can effectively ignore it.
Unfortunately still no... http://code.google.com/p/go/issues/detail?id=4714 https://groups.google.com/forum/#!msg/golang-nuts/lnJDQ1x6CVQ/UmIqFxH4lQsJ
You'll find a lot of people running 512MiB or less VPSes with i386 userspace.
The first thing I wrote was [a solution](https://gist.github.com/titanous/3526951) to the [final level](https://github.com/stripe-ctf/stripe-ctf-2.0/tree/master/levels/8) of Stripe CTF 2.0. After that I wrote a domain checker that checks the availability of a list of domains based using DNS and WHOIS. Now I've moved on to writing larger projects for work, and I've been open sourcing a bunch of the components and libraries.
I updated it and added some instructions
Only if you could import "github.com/user/repo/tagname" in the sources.
Thanks, now it works! You're awesome! 
I'd use a channel for page views, another for hrefs, and push records to be written to them. Nd have two goroutines, each Inserting records continuously as read from the channel. This way you avoid the recurring goroutine creation and statement creation. The batching can be done at any end.
Can someone link to a description of what is meant by "real stacks"?
I've been wondering about this as well!
I'm a bit confused about this too. Java has had escape analysis for a while now. I'm not sure that Go would have a huge lead in this area.
Shouldn't all of the "g.Connect" lines in graph_test be "ok=g.Connect"? (except for the first one of course) edited (for more testing and comments below) Also, add some tests for Len(), Get(), GetAll(), Disconnect() and GetNeighbors(). I don't see an "Adjacent()" method. I'd think that would be a pretty standard method for a graph class. Did you test with "-race" option of test? (just recently heard about it)
from the wikipedia link: adjacent(G, x, y): tests whether there is an edge from node x to node y. neighbors(G, x): lists all nodes y such that there is an edge from x to y. -race is a new option on the 1.1 release or go tip (use it to test race conditions) The benchmark options are there now, too. You can run benchmarking like this: go test -test.bench="." Lots of really neat things to write solid code.
nice. go-html-transform author here. :-) I've hesitated to update the go1 tag since the api changed quite a bit I was going to wait for go1.1. Perhaps I should rethink that a little.
I didn't even know there are lock free algorithms for this. Do you have more material about that?
my english has many bugs and you just reported one of them, thanks! I'll change it.
I'm confused about lines 28-30 of graph.go It seems the read-lock protects from v.edges being re-assigned, however because maps are pointer types it doesn't look like there is any protection against v.edges being mutated as lines 32-34 are executing. Am I missing some subtlety of the program? Example of what I mean by pointer type: http://play.golang.org/p/yAdQlx-ouy
I think it means `[]MyObj` is stored inline, unlike `[]*MyObj` which is scattered across the heap. If you have memory pressure problems, you can just make a backing array of a certain size and then keep reusing it, so you never need to pause for GC.
Scraping, not scrapping. Sorry about that.
Hey, thanks for answering! As you like, I was just working with the h5 library and I think the last version is ready for production. Don't know about html/transform, but I guess it's the same. For me is totally fine the keep this way, since I got to make my CI builds to pass and write the right steps on the documentation to install it. I guess when go1.1 comes, it's time for all of us to put our libraries up-to-date. I'd say until that times comes (seems to be soon), we're fine.
Nice library. Your first example would have saved me a little time. (I think that's the most common use case.) I was playing with go and pipes when I came across this: https://gist.github.com/1477401 Pulled your lib down on mac v1.0.3 and got this: (when I did the "go get ..." statement) pipe.go:612: function ends without a return statement When I went to run the test, I get: $ go test # labix.org/v1/pipe pipe_test.go:8:2: import "launchpad.net/gocheck": cannot find package Not a big deal, but perhaps the doc should state running "go get launchpad.net/gocheck". So, test fails for the return statement problem: $ go test # labix.org/v1/pipe ./pipe.go:612: function ends without a return statement FAIL labix.org/v1/pipe [build failed] If I add a "return nil" line just to get it to run like this: if eof { return nil } } return nil // not sure if we need this line (but added to stop compiler from complaining) }) } I get a lot of failed tests: $ go test ---------------------------------------------------------------------- FAIL: pipe_test.go:264: S.TestChDir pipe_test.go:278: c.Assert(string(output), Equals, subdir+"\n") ... obtained string = "/private/var/folders/jy/gl5j039n2gq_d8n1sgc5072h0000gn/T/gocheck-1597969999/0/subdir\n" ... expected string = "/var/folders/jy/gl5j039n2gq_d8n1sgc5072h0000gn/T/gocheck-1597969999/0/subdir\n" ---------------------------------------------------------------------- FAIL: pipe_test.go:305: S.TestEcho pipe_test.go:312: c.Assert(string(output), Equals, "hekko") ... obtained string = "hekko\n" ... expected string = "hekko" ---------------------------------------------------------------------- FAIL: pipe_test.go:219: S.TestLineIsolatesDir pipe_test.go:231: c.Assert(string(output), Equals, dir1+"\n") ... obtained string = "/private/var/folders/jy/gl5j039n2gq_d8n1sgc5072h0000gn/T/gocheck-1597969999/2\n" ... expected string = "/var/folders/jy/gl5j039n2gq_d8n1sgc5072h0000gn/T/gocheck-1597969999/2\n" ---------------------------------------------------------------------- FAIL: pipe_test.go:234: S.TestLineNesting pipe_test.go:246: c.Assert(b.String(), Equals, "hekko") ... obtained string = "hekko\n" ... expected string = "hekko" ---------------------------------------------------------------------- FAIL: pipe_test.go:285: S.TestMkDir pipe_test.go:298: c.Assert(string(output), Equals, subsubdir+"\n") ... obtained string = "/private/var/folders/jy/gl5j039n2gq_d8n1sgc5072h0000gn/T/gocheck-1597969999/4/subdir/subsubdir\n" ... expected string = "/var/folders/jy/gl5j039n2gq_d8n1sgc5072h0000gn/T/gocheck-1597969999/4/subdir/subsubdir\n" ---------------------------------------------------------------------- FAIL: pipe_test.go:315: S.TestRead pipe_test.go:322: c.Assert(string(output), Equals, "hekko") ... obtained string = "hekko\n" ... expected string = "hekko" ---------------------------------------------------------------------- FAIL: pipe_test.go:362: S.TestReadFileAbsolute pipe_test.go:374: c.Assert(string(output), Equals, "hekko") ... obtained string = "hekko\n" ... expected string = "hekko" ---------------------------------------------------------------------- FAIL: pipe_test.go:377: S.TestReadFileRelative pipe_test.go:389: c.Assert(string(output), Equals, "hekko") ... obtained string = "hekko\n" ... expected string = "hekko" ---------------------------------------------------------------------- FAIL: pipe_test.go:191: S.TestScriptIsolatesDir pipe_test.go:203: c.Assert(string(output), Equals, dir1+"\n") ... obtained string = "/private/var/folders/jy/gl5j039n2gq_d8n1sgc5072h0000gn/T/gocheck-1597969999/8\n" ... expected string = "/var/folders/jy/gl5j039n2gq_d8n1sgc5072h0000gn/T/gocheck-1597969999/8\n" ---------------------------------------------------------------------- FAIL: pipe_test.go:249: S.TestScriptNesting pipe_test.go:261: c.Assert(b.String(), Equals, "worldhekko") ... obtained string = "worldhekko\n" ... expected string = "worldhekko" ---------------------------------------------------------------------- FAIL: pipe_test.go:349: S.TestTee pipe_test.go:358: c.Assert(string(output), Equals, "hekko") ... obtained string = "hekko\n" ... expected string = "hekko" ---------------------------------------------------------------------- FAIL: pipe_test.go:450: S.TestTeeFileAbsolute pipe_test.go:459: c.Assert(string(output), Equals, "hekko") ... obtained string = "hekko\n" ... expected string = "hekko" ---------------------------------------------------------------------- FAIL: pipe_test.go:470: S.TestTeeFileRelative pipe_test.go:481: c.Assert(string(output), Equals, "hekko") ... obtained string = "hekko\n" ... expected string = "hekko" ---------------------------------------------------------------------- FAIL: pipe_test.go:325: S.TestWrite pipe_test.go:335: c.Assert(b.String(), Equals, "hekko") ... obtained string = "hekko\n" ... expected string = "hekko" ---------------------------------------------------------------------- FAIL: pipe_test.go:403: S.TestWriteFileAbsolute pipe_test.go:416: c.Assert(string(data), Equals, "hekko") ... obtained string = "hekko\n" ... expected string = "hekko" ---------------------------------------------------------------------- FAIL: pipe_test.go:419: S.TestWriteFileRelative pipe_test.go:436: c.Assert(string(data), Equals, "hekko") ... obtained string = "hekko\n" ... expected string = "hekko" OOPS: 21 passed, 16 FAILED --- FAIL: Test (0.12 seconds) FAIL exit status 1 FAIL labix.org/v1/pipe 0.138s I think most (all?) of those failures are bugs not in this pipe code, perhaps in gocheck? (not 100% sure) Just looking at it, I am guessing the testing would not work under Windows. (lots of /bin/sh and the chmod checks) Ever consider adding Benchmarking? 
Gah, misuse of cat in first example. cat article.ps | lpr should be lpr &lt; article.ps 
It doesn't because your example isn't. Edit: Slices to non-pointer types are still stored on the heap, but in a single contiguous block. There's just less fragmentation. What they mean by real stacks is that stuff can exist purely on the stack at all, and that is fixed-sized arrays, and other non-variably sized data.
I prefer "cat a | b" because the flow is left to right. "b &lt; a" seems backwards to us folk with left-to-right languages.
You can write it the other way too; `&lt;a b` is legal.
I like that. And didn't know it before. Thanks!
Ha, I was genuinely worried that I was missing something, thank you for clearing that up :)
Some questions/suggestions based on the documentation: * Why is Scraper exported? I can't instantiate it, I can't do anything with it. * What can I expect from the Compatibility map? Some documentation or constant key values will help. * Images() and Links() supposedly give a list of URLs. Are they fully qualified? * What is RootURL. An example might help, but see my next point. * If you write your example as a func ExampleMetaInspector() in your test package, you get an automatic regression test *and* a nice example within your godoc . For an example, look at http://golang.org/pkg/bytes/#example_Buffer too see what I mean. * As far as I know, "go get" is recursive. This makes steps 1, 2 and 4 unnecessary to document. 
Not my package, but I wonder if it compiles under tip. Go 1.1 will loosen requirements for ending with a return statement. 
Hey, * You're right. I don't want the *Scraper* to be exported, so in the next release it will be just *scraper*. I will rename the constructor method from *NewMetaInspector* to *New* as well. * *Compatibility()* maybe is not the best name. It just extracts the [X-UA-Compatible](http://msdn.microsoft.com/en-us/library/ie/ms533876) meta-tag. I'm thinking about get rid of this field since this tag is mainly IE focused. * Images() and Links() give a list of URLs **as strings*. Not sure what you mean exactly with "fully qualified", but I would say they are. It scraps all links and images urls in the document, some are extern links, others are internal. These ones are appended to the Root URL (see next point). * So, we have for example "http://www.reddit.com/r/golang/comments/1ccg15". Making things simple we can say that *http* is the scheme, *www.reddit.com* the host and the rest is the path. The Root URL is just the scheme and the host. Update the documentation to make things clear is a priority. * This is a **supertip**, didn't know this, awesome! * You are probably right, the problem was about outdated dependencies. Now is fixed and a simple *go get* will be enough. Thank you so much, really nice feedback :) 
Three slides with Go code; I'm sold!
Wastes a process and all the associated startup costs; wastes memory bandwidth with `cat` copying between stdin and stdout; etc. Overall not a big performance issue but I object on principle and because I tend to find that people over-using cat are the same ones making larger more noticeable performance blunders.
actually that looks even more backwards
Same guess. Plus all the failures are just whether or not the string terminates with '\n'. Probably a small lib change or bugfix or consistency move, etc.
Update to the latest go git. For example, those return statements are no longer required.
How would you propose to give a talk about a bioinformatics toolkit to a mixed audience of bioinformaticians, biologists, mathematicians, statisticians and a couple of bioinformatics programmers?
A few more examples really wouldn't have hurt, you must admit.
Adjacent() method is now implemented. I also improved the tests a bit. I didn't try go 1.1 yet, so I haven't tested the -race switch yet. Edit: I just tested "go test -race" with the go1.1beta2: $ go test -race PASS ok github.com/sauerbraten/graph 1.025s I don't know what that proves though, since I did not write any parrallel tests at all.
&gt;To make parallel software applications ubiquitous, we will need to make parallel hardware accessible to all programmers, create much more productive parallel programming methods, and convert all serial programmers to parallel programmers. &gt;[the platform reference design and drivers are now available](http://www.parallella.org/2013/04/02/open-parallella-hardware-platform/)
That would mean locking up the whole graph for every small change though; the way it is now it only locks one or two vertexes if you are not doing big changes, e.g. when getting the neighbors of a vertex or checking adjacency of two vertexes. I'd have to think about the advantages I guess.
If my understanding is correct, it doesn't prove anything and writing parallel tests is necessary to take advantage of the -race function. Perhaps an error should be thrown when the -race flag is used but there are no parallel tests.
And what does this have to do with Go? It'd be nice if a compiler gets written for it, but I wouldn't expect that to happen any time soon.
If the talk had been to bioinformatic programmers for the main part, sure. Otherwise (i.e. in reality), absolutetly not. A talk with a greater focus on syntax would have completely missed the audience. But what do I know?
from the reference link: &gt;"we will support the development of open source languages, frameworks and applications that are able to unlock the potential of massively parallel computing architectures." from [Multi-Core Parallel Programming in Go](http://www.ualr.edu/pxtang/papers/ACC10.pdf): &gt;"In this paper, we present two multi-core parallel programs in Go and their performances on an octal-core microprocessor, to demonstrate the ease of multi-core parallel programming in Go and the efficiency of parallel Go code."
[Ideas List | Parallella](http://www.parallella.org/ideas/) &gt;1.2. Go Language Many-Core Accelerator Support &gt;Summary: Go support for many-core accelerators would be a significant performance/energy-efficiency boost for applications. The project would use the Parallella hardware platform and many-core programming infrastructure as a test and development vehicle. &gt;Expected results: support that allows Go applications running on the host to offload tsks to many-core accelerators like the Epiphany processor on the Parallella platform. &gt;Knowledge prerequisite: C/C++, OpenCL, Go. &gt;Mentor: Yaniv Sapir, Adapteva.
The brute force method of trial and error. 
I've written a password generator in Go based on the [one passphrase concept](https://en.wikipedia.org/wiki/Passphrase), inspired by [OneShallPass](https://github.com/maxtaco/oneshallpass). I'd be interested in hearing what people here think, especially crypto experts on my using [scrypt](http://www.tarsnap.com/scrypt.html) instead of [PBKDF2](http://en.wikipedia.org/wiki/PBKDF2) for generating the shared private key. On that point, I was more than a little amused to see the guys at [1Password say](http://blog.agilebits.com/2013/04/16/1password-hashcat-strong-master-passwords/) they should probably stop using PBKDF2 and scrypt is a possible successor, but they're not going to do anything about it now. Also, it would be nice to have binaries for different operating systems, so if people on Windows and Mac (amd64) could contribute, I'd appreciate it.
&gt;Also, it would be nice to have binaries for different operating systems, so if people on Windows and Mac (amd64) could contribute, I'd appreciate it. As long as you're not using cgo, it's pretty easy to cross-compile in Go, whatever platform you're on. I've written a simple tool for doing this based on golang-crosscompile (davecheney): https://github.com/robertkrimen/gxc To cross-compile something: go get github.com/robertkrimen/gxc/gxc cd go-one-password gxc build # Build for windows, linux, darwin, freebsd, etc. This is one of the really strong points of Go, IMHO. EDIT: This is for go 1.0.3: $ gxc build # Build: go-one-password-darwin-386 # Build: go-one-password-darwin-amd64 # Build: go-one-password-freebsd-386 # Build: go-one-password-freebsd-amd64 # Build: go-one-password-linux-386 # Build: go-one-password-linux-amd64 # Build: go-one-password-linux-arm # Build: go-one-password-openbsd-386 # Build: go-one-password-openbsd-amd64 # Build: go-one-password-windows-386 # Build: go-one-password-windows-amd64
Not sure, not getting that behavior. From the commandline it works.
Check out the answers to [this question on SO](http://stackoverflow.com/questions/5051529/hmac-vs-simple-md5-hash)
Thank you! In my perusals I also found this: https://github.com/maxtaco/oneshallpass#what-is-the-crypto-behind-one-shall-pass
Please don't recommend that people 'sudo go get ...'. It is not necessary and leaves the user's installation in a confused state.
Well, I tried plain 'go get .../scrypt' initially, but it didn't work for me. Could you explain why? I'm on ubuntu 12.10 (amd64) and I installed go via apt, i.e., using 'apt-get install golang'.
That's great, thanks!
I meant latest go from the go hg repository.
make a folder like ~/projects/go and set your GOPATH enviroment variable: http://golang.org/doc/code.html#tmp_2
Ah, got it! My personal $GOPATH value is undefined b/c I'm the only one who codes on my personal machine, and so I always add pkgs to the global env, but point taken. Thanks for clarifying that; I'll update the readme.
I've been using this way to manage password for a while. Here's some problems I encountered: * using command line to generate the password is inconvenience, a fast accessible GUI application can solve this problem * you will need to generate the password on mobile devices * some website require special/up/low characters, some stupid ones do not allow special characters (for those stupid ones, you may need to try again after the first failed login) * if a website is hacked, you still have to change the password on that website (One Shall Pass uses generation and can save that on its server, so I think this can solve the problem) The mobile device requirement drives me to use Lua for the password generation.
We don't disagree.
&gt; The main algorithm works by compressing the image using PNG's average filter. It quantizes the output bytes of the PNG file, but since the image is decoded using the average filter, the pixel color values are not quantized and have full range. The resulting artifacts are less noticable than traditional quantization in color space. I feel like this could be expanded into a very intriguing blog post on quantization and image formats.
http://pineapple.io/tags/go-language
One thing: you should really follow the go style guide; or just do like everyone else does: `gofmt`. It makes the code infinitely more readable just because I don't have to adjust to your way of writing.
I wrote a ZX Spectrum emulator but... don't do that as your first project in Go! :) https://github.com/remogatto/gospeccy 
Reviews accepted. It's not a big deal, just coded in few minutes. Don't be rude :)
I didn't look at your code, but it's already been implemented in a semi-official package [here](http://godoc.org/code.google.com/p/go.crypto/ssh/terminal#ReadPassword).
I do run gofmt. What am I doing differently than other people? I would like to write standard Go style but I must be doing something that gofmt does not fix. Is it because I like to break long statements across multiple lines?
I was thinking about how you split some of the function definitions. You put all of the arguments on a new line. 
You didn't really create much of a password flag. You make a boolean flag. What would it mean if it were false? In your example, you don't even check. Essentially, you've created a useless boolean flag, and then cut right to gcmurphy/getpass's code.
The example is simplified, the point would be assign the flag to a *bool value and later check if it's true, so the password request will be prompted. 
It's a *very* nice looking presentation, but "realtime" is a pretty loaded term...
That's one damn horrible presentation format.
This presentation should come with instructions.
https://github.com/nf/go11
&gt;locking for a boolean yes = true is atomic. 
~~I'm pretty sure echo simply doesn't write EOF unless explicitly done.~~ Apparently that wasn't the problem.
The more interesting question is why it works interactively at all, since you're trying to copy stdout to stdin! (think about that for a second) This works fine: package main import ( "io" "os" "fmt" ) func main() { io.Copy(os.Stdout, os.Stdin) fmt.Println("Got EOF -- bye") } If you look at the docs for `io.Copy`, its first argument is the destination and the second argument is the source. You had it backwards.
Yep, that's it. Ugh. I know there aren't any hard and fast rules, but coming from any shell (or just about any other copy function), I'm very used to the source -&gt; destination look. Why did Go use the opposite? **[Update]** The other question is why Stdin fit in the Writer side and Stdout fit in the Reader side (of Copy). (It's because they're both File, and that implements both instead of each implementing only either Reader or Writer.) **[Edit]** Yeah, I can see the C-pattern now (it's been a few years since coding in C full time). thx all!
Perhaps a pattern of putting the object(s) you modify first in the list of arguments? That's how I like to do things, unsure where I picked it up from though.
I enjoyed the presentation after realising you needed to press down rather than right
What if anything did this have to do with realtime?
&gt; Why did Go use the opposite? Convention from C, most likely.
This is how pretty much everything that deals with strings and (to a lesser degree) streams works in the C standard library. I cannot think of any function that writes to a string or file that does not have that destination as the first argument (while checking on this I found that fwrite and fputs have the same argument order as fread and fgets, which results in the contents of their first argument being written to their last argument. I believe this is to share the argument order of their more frequently used complementary function). Prototypes of commonly used functions that demonstrate this pattern: From stdio.h: size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream); char *fgets(char *str, int n, FILE *stream); int fprintf(FILE *stream, const char *format, ...); int sprintf(char *str, const char *format, ...); char *fgets(char *s, int size, FILE *stream); From string.h: char *strncat(char *dest, const char *src, size_t n); char *strncpy(char *dest, const char *src, size_t n); Edit: Forgot my point. Go was authored by people who were heavily involved in the development of C. It should be unsurprising that they decided to maintain the patterns used therein.
I believe this is the [bug](https://code.google.com/p/go/issues/detail?id=5323) that was filed about it. AFAIK, immaturity of the database library led to many sql connections being opened when prepared statements were being used under high concurrency. 
It matches the way assignment works normally in the language. Foo := Bar is Bar being copied into Foo. Thats my guess anyway
Thanks for the link to the bug, by the way. Very informative. I'll keep an eye on this to see how it pans out, and maybe offer a pull req that skips prepared queries just for curiosity's sake.
I've written a fair-ish amount of Go code and I still stub my toe on this every once in a while...
Would a proper tl;dr be "Equivalence checks panic when deep checks would be required"?
GETs and POSTs are mapped by using http.HandleFunc, which registers the URL in the default [ServeMux](http://golang.org/pkg/net/http/#ServeMux). I'd *strongly* recommend looking at Gorilla's "mux" package to handle routing though, as it gives you rails-style url variables.
That's because of empty slice([]byte). isn't it?
Exactly. There's [reflect.DeepEqual](http://golang.org/pkg/reflect/#DeepEqual) for deep checks if you really need it.
I think it's quite a nice idea for bigger presentations - say you are pressed for time, it's easier to decide which sections to skip.
Does this panic happen because you can't compare slices with each other? Because this: package main func main() { var b []byte var c []byte println(b == c) } outputs: prog.go:6: invalid operation: b == c (slice can only be compared to nil) ?
Gorilla's `mux` package is absolutely awesome. Antoher strong recommendation here.
Indeed. Here's how I set up the routes in my crudapi framework: https://github.com/sauerbraten/crudapi/blob/master/api.go#L50
github.com/hoisie/web is also nice
It's because of the `[]byte` yes. It being empty or not doesn't matter. (Although, you may compare any slice to `nil`.)
regarding the overhead of additional goroutines, I think you're fine unless you use gccgo where AFAIK goroutines are mapped to real threads. At the same time, it's probably still wasteful if you're doing a very small amount of work in each one. The example I posted was obviously contrived and I would not recommend using a goroutine for such a menial task as checking the length of a string.
requests are only routed by path; you have to roll your own router or use the Gorilla mux. I rolled my own, it wasn't a big deal.
Interesting pattern, but this will definitely bite you if you're expecting any sort of determinism.
I played around with the idea of making a package like this, but I gave up when I decided there was no point in doing it without generics. 
Amn brother. 
No it doesn't. Channel communication and thread execution is done in the IO Monad (at least all channel communication is), and once you're in the IO Monad, you lose guaranteed determinism. However, due to Haskell's immutability, it's worlds easier to get guaranteed determinism than it is in an impure language like Go. EDIT: Having looked over the Gist, it would be trivial to write their final function in Haskell with guaranteed determinism. However, as far as I know there are no ways to parallelize it like it is in the Go version without dropping into either the IO or STM monads. However, is the Go version actually non-deterministic? If each function is running in a single go-routine, and with a single channel for each its input and output, you should get everything out in the same order every time, as each "handler" can't proceed to the next input until it's done with the current one (including the final one).
yepp
I find it's more common for people to hit this with maps, like: http://play.golang.org/p/s9DIJ1w4cu 
Ah, yeah, I could see myself doing that. One of the benefits of storing pointers to complex structures in maps instead of the complex structures themselves.
Cross compiling is "built-in" with Go.
And yet, in go, you can add `x + y` rather than the more consistent error handling approach of `tmp, err = x + y`. 
I'm not saying that you will overload your system, but you won't see any performance gains by doing tiny things like that concurrently.
Ah.. this reminds me.. I started working on an IRC bot using this to spur out random blarg, didn't get to finish it yet, though 
Well when people use go for real work, performance is one of the main concerns. If I didn't care about how fast my code was I would much rather use something like lisp or python. 
I have almost no Haskell knowledge but I think that the channels in the example are pretty deterministic as long as they're not buffered.
go let's you do this pretty straightforwardly. I think the only part I see where you have to fight the language is that you can't use either slices or arrays of strings as keys to a map, in fact, the only arbitrary length data type allowed as a key are strings. But defining a String() method that losslessly renders your desired key type as a string is a decent workaround (and a popular one too: people using languages like awk and lua do this too).
Arrays of strings can be used as map keys http://play.golang.org/p/AbSWH-N1xP. Did I mis-understand you? 
Just use the encoding/csv package in the go version.
Nice, but I'm not sure this example is a good comparator for language productivity, it's so small. Go would probably shine on very large code bases. Also, this example screams for an 2sec spreadsheet solution...
Also, it's most definitely NOT "Google Go".
I think golang is more Google friendly.
Here's an example on Go Playground: http://play.golang.org/p/EW7ZsVKkBf
The only "error" which can happen in addition in Go is overflow. However, this is not always considered an error. It depends on your application. Plus, you can detect overflow without having an error code as long as the return value allows it - which Go does. If Go returned an error, it would make implemented something like A+B+C much more difficult.
I would stick with a relational DB and start with an index on time. I've personally had good experiences using postgresql with Go (using [pq](http://godoc.org/github.com/lib/pq) package), but many people use mysql as well. If you're not expecting this data to easily fit in memory, don't even try something like redis.
Yes, this is why I dont like calling it just plain "Go"
Yep, I agree that an RDB is the way to go for this. From what's been described, the data being handled really is within the expertise of relational databases. Having a "ton" of data isn't really a problem here. Go + something like https://github.com/bmizerany/pq (to interface with Postgres) would do the trick. 
You don't need to trim out the +. It's a valid part of a floating point number. http://play.golang.org/p/pjbFY3agvM
You working on what I think you're working on?
Don't be afraid of Redis - it's excellent for this sort of stuff, really easy to learn and a great tool in general. Plus it has an excellent community and solid Go libraries. I would only suggest against redis if the data will ever grow beyond what can be held on a several dozens of gigabytes. 
That was also my first thought :)
Do you have any estimation of the expected total size (1k/10k/100k/1M rec/sec)? I've been working in that very business for a few years and I've never crossed, or heard about, a cost/perf efficient sql based setup for such a use case. I would give a try to leveldb, or hdf5 (which is another option), but I guess you'll ultimately have to go for a more tailored (custom) solution that will over-optimize your very specific access/persistence pattern to the detriment of all the other ones..
At 5 rows per second being saved, thats about 2.5 TB for a month's worth of data, and we would like to have many months on hand eventually. Granted, that's estimating towards the high end, like 200 characters per row being inserted every time, which probably wont happen, but it could.. Other than saving the data we could be accessing it as it's being saved, so say maybe 100 requests per second; not much. I'm more concerned about being able to pull data out of such a huge database easily and quickly.
There's a good chance it will :-/
of course you can always shard the data.
I use MongoDB for a similar task. http://labix.org/mgo
Where are you getting your data?
This is my slightly smaller version in PHP: $fp = fopen(./CSVData.csv, r); while ($d = fgetcsv($fp)) $totalVal += $d[1]; echo Total: {$totalVal}\n; 
Pretty good example of what expvar does as well: [http://isgo1point1outyet.com/debug/vars](http://isgo1point1outyet.com/debug/vars)
This seems more like a general problem rather then anything related to go. There are some attempts at time series databases but none of them are that great and if you have gigs of data a day most of these databases fall over or become clunky unless your willing to shell out on a cluster. 
The read/write load you describe is totally possible with Postgres, especially if things like async commit is enabled (if you don't mind losing a small amount of recent data on power outage) http://www.postgresql.org/docs/9.2/static/wal-async-commit.html The only hard part would be partitioning your data which is needed once your table size would otherwise be huge. You could maybe partition your data along time, one table per month of data. http://www.postgresql.org/docs/9.2/static/ddl-partitioning.html Finally, Postgres is a DB that scales up well (with a good disk controller + raid 10 for instance) and is not constrained to only scaling out as opposed to a lot of the nosql DBs out there (mongo and cassandra come to ind). It's something to consider when figuring out your hosting.
icholy is awesome. i used his fork of masonry to get drag and drop'able masonry tiles. can you explain how to use this - not too sure what the 2nd and 3rd lines do.
Take a look at this: http://skydb.io/. It uses levelDB. In my opinion, you need something like it.
I believe the lock is used because the Go spec doesn't guarantee it to be atomic.
The second line finds `//debugger` comments in source files and outputs breakpoint descriptions for gdb to a file (.breakpoints). The third line then runs gdb using those descriptions, passing any script arguments into ~~gdb~~ _the application_ as well. Check out the demo URL listed at the top of the gist, it should give you a better idea of the process. 
&gt; At 5 rows per second being saved (...) Five updates per millisecond, for a single liquid stock, would be a more realistic estimation for a full order book. Any mainstream index falls in the 50 (SX5E) to 500 (SPX) components range, which actually means of lot of data, and may change a few of the here-around conclusions.. Efficiently pulling all that data out of your storage layer is indeed the core issue. All in all, this is definitely closer to "video streaming" than SQL stuff.
I tried using the runtime package, but I couldn't get the behaviour I wanted. Most likely It's just a stupid mistake on my part. However, one of the advantages of my hack is that you can have different sets of breakpoints named different things and then just change the search pattern.
Summary of talk by Paul Dix: Node and Scala are quickly becoming languages of choice for building scalable, asynchronous web services and applications. However, Go, the language designed and in use at Google, presents a compelling alternative with few of the warts of Node and Scala. While Node and Scala are specifically targeting developers as the tools of choice for server side architecture, Go is actually a better tool for the job and will prove to be the ultimate winner. In this talk I'll draw from my recent experience building a scalable architecture for storing time series data in real-time for errplane.com. The Errplane API started as a Scala-based service that was recently rewritten in Go. I'll talk about my specific experience writing a scalable server architecture in the two languages and the road blocks to learning and working with each. I'll then contrast the philosophical and stylistic differences between Node, Scala, and Go with specifics on how Go is superior for concurrency, understandability, code sharing, and learning curve.
I will go for Go anyday :P
No offense, but you seem to have misunderstood the actual performance argument for node: V8 is *fast*. It's much faster than any Ruby interpreter and *most* Python interpreters, and often competitive with Java.
I'm not sure what V8 being faster than Ruby has to do with V8 vs Go. Go is already quite fast and getting faster (as of GC improvements in 1.1).
Functional languages are immune to criticism?
My mistake! Thanks for pointing that out. 
very cool - thanks.
"based on 6 months of scala, no node, 1 month of go experience." i hate these retard hipster "coders"
Ah sorry I misread your post.
i think go stands to gain more ground vs php and c#. node is great with websockets and there are tons of javascript frameworks for game development. it makes sense to have the backend in javascript as well. i dont think node will go away.
right, that part of the talk was comparing node to Python and Ruby though. FWIW I agree with the *conclusion* given in the talk (Go is awesome and can be a better choice than Node or Scala) but the evidence and reasons provided are weak.
I do wish Go offered dynamic dispatch for object methods. I understand why they do it. It's just a little annoying to wrap everything in functions-over-interfaces if I want to modify/decorate a given method of an embedded type and have the result affect other methods that would call that given method.
If it takes you 6 months to be productive in Go, you're doing something wrong. If you dismiss a language with 6 words, you're doing something wrong.
gist of his argument vs Scala: "scala is not c. this scares me. go is much more like c. me likey" Functional languages are certainly not immune from criticism, but this isn't criticism so much as complaining about Scala for doing things differently than he's used to. I'd have to heard what he'd have to say about Clojure, for example.
next time if you're quoting someone, put the quote in quotes!
There's a world of difference between Python and Java. 
The title is a real linkbait, nevertheless this guy rises a couple of valid points: Scala has a problem with dependencies and Scala is complex. From the other hand he completely misses that all the matters raised are fixable, the world is not web only, and a second system effect. Also, I personally would avoid making such a broad generalization out of a single specific case. 
I wouldn't call Scala "functional". It's one of those "let's throw in everything and the kitchen sink, oh, and 3 rusty bathtubs and see what sticks" languages, like C++. You can "do" functional programming in it, slightly better than you can in C++, but again - I don't know if it's *functional*, the way Haskell and Clojure are functional. Heck, I might as well call C# "functional" at this point - it's got anon functions/closures so why not. 
You didn't, he/she used words like "_I'll_ draw from _my_..." it was fair to assume that the OP was the subject of the post.
I am having no issues with it, but my biggest advice is to make sure to set up your go path correctly. I was trying to develop with projects strewn all around, and it worked ok, but always felt hacky. Set up a defined GOPATH with src, pkg, and bin folders and you will have no issues. I have not ran into a single package that has not worked, nor have I had issues working on my code in windows and moving to linux or vice versa
No your last paragraph is right. Tis is like chaining together a load of commands with pipes in unix. They're running concurrently, but each step is waiting on the previous one for every iteration. 
Works fine, I do most of my Go programming on Windows 8 x64. I write code both for running on Windows (GOOS=windows, GOARCH=amd64) and for various ARM/Linux based devices (GOOS=linux, GOARCH=arm) using Go cross-compiling with all the compiling done on Windows and it all Just Works. There's also a ton of stuff in the syscall package that makes it easy to interact with Windows and do things like consume external DLLs on Windows. This is actually nicer in some ways than Go on linux because you can do things like load DLLs and map the functions in them dynamically, which gcgo doesn't directly support on Linux (with *.so files). Of course, this makes your Go code non-cross-platform, but if you're in the situation where you want to call some external code and don't care about OS portability all you have is a DLL and no headers/lib to work from, you can load the DLL into dependency walker (to get a list of the func names, etc) and then pretty easily create a Go wrapper which consumes that DLL (YMMV if the DLL is C++ or otherwise uses name mangling, I'm assuming a more standard C interface here). 
Oh. my. god. yes. Thank you. Wonderful.
This is a totally nitpicky thing, but is there any reason to use a pointer to a WaitGroup here instead of just a direct wg?
we hope we can get the source code into shape sooner rather than later so you go fans can have a look :-)
Great! Noting this for later review.
As usual, quite a bit of discussion on [Hacker News](https://news.ycombinator.com/item?id=5638383) about the new features of this release.
I understand why Go has this rule, but I hate it when anyways. Thanks for this!
I dunno about the author, but I tend to *always* use a pointer even when it's obviously not required because I know it will be branded in muscle memory. i.e. at some point I will(already started) start to declare WGs without thinking about it and when I do that I want to make sure that it's not `func(wg sync.Waitgroup)`. It also helps that in most cases the wg is being created in order to be passed to a named function
Pretty cool.
The downside of always using a pointer though is that you have to remember to look out for nils. If you have `var wg sync.WaitGroup`, it's ready to go automatically.
Does gofmt have an option to remove unused imports and variables? Seems like something easily automated so it should be.
I personally like that go doesn't let you get away with writing sloppy code (in this one respect)... That being said, I still think this is still a pretty cool project and I know that it will make some users happy.
No need to check for nil, and it's IMHO a bad idea in the first place because if the wg is nil it most likely means you're about to mask a programmer error. I guess I'm spoilt but I don't tend to write code like `var wg sync.WaitGroup`, I initialize the variable in-place wherever I can e.g. `wg := &amp;sync.WaitGroup{}`
I'm not suggesting getting rid of the compiler error - that would still exist and alert you to the existence of unused variables and imports. Nor should gofmt automatically remove unused variables and imports, but it could have a mode that does it, so when you do get the error and you can trivially see that you left in stuff you should have removed, just run gofmt in that mode and it is cleaned up.
This is great. Solve programming workflow problems with better tools, not by changing the language. Nice work.
That makes the path of least resistance to just gofmt code before you compile to remove unused variables and imports. This increases the likelihood of bugs being missed because it doesn't require the developer to actually look at the code. The go tools have a tendency to not help you be lazy now at future expense.
The thing I've noticed is you have to be careful what third-party libraries you use. Even though Go itself is cross-platform, you'll definitely find some libraries that have linux dependencies, or assumptions of unix-like environment (/proc, syscall, ...) being available (especially from users that use OSX/Linux exclusively). Not earth-shattering, but something to watch out for.
Petition to delete this post. If you have a tool that can run a Go file, feel free to add shebang support to it. As for petitioning to create a repl... I'm not sure what that's about. It's as-if you're trying to pretend that if enough people vote, then a repl will magically manifest itself.
What a dumbass. Leave the post here so we can mock him/her.
what's that `must` function doing there?
Hey. Just some preliminary comments from a first glance, not exhaustive: * Whitespace nit: use "go fmt" to automatically format your code. This makes it look similar to other people's code who do the same thing. * In https://github.com/denkyl08/GoEuler/blob/master/poker.go#L41 - Unless you wanted to implement bubblesort, implement sort.Interface on the Hand struct and then use Go's sort.Sort(fooHand) on it (http://golang.org/pkg/sort/#example_Interface) * https://github.com/denkyl08/GoEuler/blob/master/poker.go#L52 - it's uncommon to start method-scoped variables with an upper-case letter in Go. In the package and struct scopes, upper-cased identifiers tell Go that these fields/consts/variables are accessible to other packages. Within a method, this wouldn't do anything, but is still uncommon in Go (at least I've never seen it). * I would extract Straight(), Flush(), etc. into separate methods of struct Hand. * https://github.com/denkyl08/GoEuler/blob/master/poker.go#L92 - use switch/case. * https://github.com/denkyl08/GoEuler/blob/master/poker.go#L91 - use "for _, kindsCount := range kindsCountArray" (or similar) instead of explicitly counting up an index if you don't actually need to. Even if you do need the index, you could use "for i, kindsCount := range kindsCountArray". EDIT: * https://github.com/denkyl08/GoEuler/blob/master/poker.go#L191 - if you use "%v", Printf will automatically format the time for you on "time.Since(beginning)". Or just call String() on the duration yourself to achieve the same. * https://github.com/denkyl08/GoEuler/blob/master/poker.go#L176 - at least print an error or something :) * https://github.com/denkyl08/GoEuler/blob/master/poker.go#L127 - I'd extract this ordered value list to a common place instead of duplicating it. Please note I didn't actually look at much of the logic itself, or even at the original Project Euler problem.
Thanks for all the tips. Range like quite useful.
No worries. The way Go does sorting can be a bit confusing at first. sort.Sort() allows you to sort any type by any aspect. Your type to be sorted just needs to implement sort.Interface, i.e. the Len(), Less(), and Swap() methods. Within Less() you define how the actual comparison between elements works. In your example, you'd define these methods on Hand and then call sort.Sort(myHand): https://gist.github.com/anonymous/216385f45b080c407291 (code from memory, not checked) So you might ask, how would you sort the same data in different ways in Go when you can only attach one interface implementation to it? The trick in that case is to define multiple types which each wrap your data to be sorted and each type can implement their own way of sorting said data. "byValueSorter", "byTimeSorter", etc.
Okay, I see that now. The int they are referring to is the index in the array, not the type in the comparison. I can't thank you enough for taking the time to explain this, have an awesome Saturday!
No problem, welcome to Go! :)
Or use `iota`!
Forgot to add, where are your unit tests?
Do this instead: type Kind byte const ( HIGH_CARD Kind = iota // highest card ONE_PAIR // two cards of same value TWO_PAIRS // two different pairs THREE_OF_A_KIN // three cards of same value STRAIGHT // all cards are in consecutive values FLUSH // all cards of same suit FULL_HOUSE // three of a kind and a pair FOUR_OF_A_KIND // four cards of same value STRAIGHT_FLUSH // all cards consecutive and same suit ROYAL_FLUSH // Ten, Jack, Queen, King, Ace, in same suit ) type CardValue byte type Value struct { Kind CardValue } func (hand Hand) Value() Value { 
Doh! Good call.
Here's a start: var valueTests = []struct { in string out int }{ { "2D 4S 5D 6D 7D", HIGH_CARD}, { "4C 4S 5D 6D 7D", ONE_PAIR}, { "4C 4S 5D 5H 7D", TWO_PAIRS}, { "4C 4S 4D 5H 7D", THREE_OF_A_KIND}, { "2D 3S 4D 5D 6D", STRAIGHT }, { "2D 4D 5D 6D 7D", FLUSH}, { "2D 3D 4D 5D 6D", STRAIGHT_FLUSH }, { "TD JD QD KD AD", ROYAL_FLUSH }, } func TestValue(t *testing.T) { for _, h := range valueTests { tmphand := StringToByteHand(h.in) tmpValue, _ := tmphand.Value() if (tmpValue != h.out) { t.Errorf("hand:%s did not produce expected value(got %d expected %d)", h.in, tmpValue, h.out) } } } Good news is that your code passes that test.
Another style nitpick: names of constants are usually in CamelCase in Go, not ALL_CAPS. It helps to browse through some of the code in Go's standard library. It is usually vert clean and easy to follow, and will give you a good idea of what is considered good style, besides the parts enforced by the `gofmt `tool.
Ah, right! That's why it felt weird. Thanks!
I got really excited because I thought this was going to be about deterministic execution, and then I read the slides... 
Nice! I could hand written it so much faster if I had been using this test.
What's the testing.T pointer referring to?
The `go test` tool calls your test functions with `*testing.T` as an argument. Your test then calls t.Error("Error X happened in Y!") to tell the tool that the test failed. If no errors are reported, the test passes. Nothing too fancy. &gt; T is a type passed to Test functions to manage test state and support formatted test logs. Logs are accumulated during execution and dumped to standard error when done. See [`testing.T`](http://golang.org/pkg/testing/#T) in Go package docs.
Quickly checked your code and found these errors: * You seem to have a data race on line 167 where you increment the amount of wining hands the player has from multiple goroutines. See [sync.Mutex](http://golang.org/pkg/sync/#Mutex) or [use channels](http://play.golang.org/p/mkpwqYDtN7). * You don't wait for all the `HighestHand` goroutines started on line 187 to finish. See [sync.WaitGroup](http://golang.org/pkg/sync/#WaitGroup). * You use the string read from file before checking whether there was an error. Lines 181 and 188. The first two are related to concurrency and you might not see the errors in action when the code runs on a single thread. Set GOMAXPROCS to 2 to higher. You can use [`runtime.GOMAXPROCS()`](http://golang.org/pkg/runtime/#GOMAXPROCS) and [`runtime.NumCPU()`](http://golang.org/pkg/runtime/#NumCPU) at the start of `main` function (or [the `init` function](http://golang.org/ref/spec#Program_execution)) to do it. The concurrency issues were revealed consistently on my machine by setting GOMAXPROCS and running the computation many times. If you add `&lt;-time.After(1000)` in the HighestHand function to simulate longer processing time, the result varies a lot. [The error is pretty bad.](http://pastebin.com/sNd1K5qZ) Errors like these are PITA at first but they are fairly easy to detect after a while of concurrent programming. :)
To filter out any edge cases, maybe run your code against the poker-hands machine-learning dataset: http://archive.ics.uci.edu/ml/datasets/Poker+Hand ?
That's an answer for a different question. He's not asking about the rule for exporting, but what the convention is in a `package main` situation.
It doesn't matter. I went back and forth on this for a while (initially doing the same as you, but it became messy since every export was only a "maybe I'll put this in another package some day"), and finally settled on lowercasing everything. As far as I can tell, the latter is the convention in most packages. If you think you're going to export chunks of it later, it may be best to add it in a separate package to begin with--then it's easy to export only the things you actually need, and you won't be making so many guesses.
Here's a rule of thumb: forget for a second that it's a package main, and ask yourself what you would do if it were a library. Stupid little detail? Lowercase. Stable API? Uppercase. Bonus: easy to migrate to be a library later. But even if not, the case is a good signal even within package main about which functions are intended for use and which exist just to help implement the uppercase ones.
Upvoted, but I think cleaning up unused variables and packages is generally *very* easy, and can be done pretty quickly.
This may apply to unused variables, but unused imports? How would that imply a bug?
Might want to say "Diplomacy the Board Game ..." next time. I initially thought this might be some load balancer or job scheduler or something like that. :-)
Duly noted :D
I thought i was passing a slice to HighestHand, and that slices were a reference type, removing the race conditions. Is that wrong? Edit: or are you saying that I'm not blocking after the loop to ensure that the counter slice is completely done?
Very cool. I was reading the paper on this not that long ago.
&gt; I thought i was passing a slice to HighestHand, and that slices were a reference type, removing the race conditions. Is that wrong? Slices are reference types but it implies nothing about thread safety. Slices are not thread safe. &gt; Edit: or are you saying that I'm not blocking after the loop to ensure that the counter slice is completely done? That too. The main function could return without HighestHands ever even running under different circumnstances if you don't explicitly wait for them.
Importing `main` is sometimes useful for bundling multiple tools together (like busybox). With Juju, we reduced the bootstrap tools size (that needed to be downloaded on every node) by a factor of almost three by bundling the tools into a single binary by importing the individual `main` packages and switching on `os.Args[0]`. You can't call main directly (since it's not exported), but you can easily create `func Main() { main() }`. 
It's no surprise that the site is similar to godoc.org. The author [copied several godoc.org source files](https://github.com/Unknwon/gowalker/blob/master/FileChangeLog.md). 
It would be worth evaluating the 2 or 3 third-party REPLs and 2 third-party shebang tools. Then maybe recommending for inclusion in a future version of Go on the golang-nuts list: https://groups.google.com/forum/#!forum/golang-nuts
| Developed by Google as a means of combatting the flaws and shortcomings of current languages such as Java and C++ when it comes to highly concurrent requirements Can't say much for C++, but Java has a pretty formidable and highly optimized set of concurrency primitives at every level of abstraction starting at atomic memory operations and ending up at high-level thread pools and [CompletionService](http://docs.oracle.com/javase/6/docs/api/java/util/concurrent/CompletionService.html)s. Go's approach to concurrency is different rather than better. The main advantages of Go's approach are: (a) simplicity; (b) ease of forking execution paths via the go keyword and goroutines; (c) channels as a first-class synchronization primitive. It's nice that you can probably mimic any Java functionality such as wait()/notify() and synchronized blocks with Go's channels and locks, but channels do not solve every problem of concurrency. On the other hand, locks in Go are more rudimentary and are non-reentrant. | makes it extremely easy to develop concurrent applications There is less overhead to creating a concurrent application in Go. It could also be more complex to manage a highly concurrent application in Go, depending on requirements for various reasons. 
Why don't you download it &amp; give it a *go* :) You'll answer all these questions yourself in ~5 minutes. It will help if you play around the language yourself. Take the [tour](http://tour.golang.org/) &amp; check out the [docs](http://golang.org/doc/).
[Here's the spec](http://id3.org/id3v2.3.0). Doesn't seem like it'd be too hard to write a library from scratch. [Here's a C++ library](http://id3lib.sourceforge.net/).
I don't particularly like make, and the map declaration syntax is a little odd. The array declaration also seems a little wonky to me, but maybe I just haven't gotten far enough to know why "arr := [8]int" isn't allowable (arr initialized as an array of 8 integers). Makes me wonder how you would easily make a pointer to an empty array.
You want 'arr := [8]int{}' http://golang.org/ref/spec#Composite_literals You can have a pointer to that array with 'attr := &amp;[8]{}' But you'd be better off with a 'slice' than an array in this case. http://golang.org/ref/spec#Slice_types 
1. Not sure what you mean by custom libraries, but yes. Since Go has built-in concurrency and garbage collector, many C/C++ libraries won't work as-is, so you need to make a wrapper (aka bindings) or a new library. 2. Yes, you can call C code from Go code and even create Go callbacks which are called from C code. No languages can use C++ traditionally, because C++ ABI (application binary interface) is not specified. C's is not specified either, but C is simpler in general and it's easier to figure one out. As (1) says, you'll also need bindings to use these, because runtimes are different, type systems are quite different as well. 3. The biggest difference is the automatic semicolon insertion and type declarations look backwards (pascal-style). Despite that, Go has a very simple grammar, easy to learn. 4. Yes, Go uses garbage collection. At the moment GC is fast and parallel and almost completely precise, but still does stop-the-world thing. 5. Go is a compiled language yes. More than that, the main compiler (the so called gc) in many cases produces 100% statically linked binaries. The binaries are huge as a result, but that's ok. 6. At the moment I know no solid GUI bindings and that could be a problem. But Go has enough syntax sugar and runtime facilities to make GUI building as easy as in python for example. 7. Well, one thing to know right now is that Go 1.1 is almost there, will be released in few weeks most likely. I suggest start using it right now (the latest release candidate version or the hg tip itself). It has many performance improvements and tweaks/features.
There's 2 taglib libraries on godoc.org, either should be able to be extended to use the setter functions from taglib to do what you want.
Ah alright, as I mentioned, my main language is Java. In java it is either type[]{v1,v2,v3} or type[n]. So I didn't think to try that. But good to know. Why is a slice better then an pointer to an array? 
Because the slice will do bounds checking as well as automatically grow the underlying array for you.
I am going through the tour.
Very cool. Can't wait to see it. Question in your framework and other frameworks do you feel that routing is something everyone reinvents. I seen every framework has it own way to trie URL/URI to functions. I'm thinking of creating a lib just to handle routing with high level features such as rails routing. Do you think this is a good idea and worth creating?
Does the routing lib define the parameters pass to the function? that can not be decoupled from a framework.
Neat intro, but *consumeString* doesn't work quite right. The returned slice includes the opening delimiter but not the closing one, and it's not really handling escape sequences properly (right now it basically just removes all '\' characters from the input and ignores delim if it appears after one or more slashes). Something like this for the loop body should solve both problems: accum = append(accum, b) if b == delim &amp;&amp; !skip { return i + 2, accum, nil } skip = !skip &amp;&amp; b == '\\' This adds the closing delimiter and just copies through the slashes, properly handling cases like "foo\\" vs "foo\"". 
Well, functions will usually take slices as arguments instead of arrays so they can handle variable lengths (array types are tied to their length - [8]int and [3]int are incompatible types). Because of this you almost never see explicit arrays in Go code. If you use arrays you will just need to slice it to pass it to functions anyway. Just use slices. [This article](http://research.swtch.com/godata) helped me more with this than the official docs.
So your saying you can't have a function that takes a []int argument? Or did I misunderstand your explination?
Note that you can combine those x/y updates like so if you want: x, y := fcall() x, y = x + 1, y + 2 You can absolutely have single return values in Go if you want, but if/when you need to return more than one thing you can do so directly instead of having to use some sort of ref/out parameter like you would in most other languages.
You misunderstood. `[]int` (without a number between the square brackets) is a slice type. If you include the length it's an array type instead, and array types are incompatible with other length arrays. So functions that take a `[]int` argument will not accept your `[8]int` argument unless you slice it first like this: array := [8]int{0, 1, 2, 3, 4, 5, 6, 7} slice := array[:] // (you don't really need a new var for this) f(slice)
If you need a fixed size and will never grow it, then yes an array is the correct tool. A slice is a "view" into an underlying array, not a list. So like a Java list you can append to it and get the bounds checking, but it still has array-like properties. In particular, iteration is O(N) but indexed access is O(1).
I think I understand now. A slice is like a pointer to an array and a length wrapped up in an easy to use structure that can be passed around on the stack.
Other Java refugee here. I found the syntax to be a *huge* relief from Java and very easy to pick up. For some reason I find Go to be naturally readable; I had very little trouble getting into it. I'm still a full-time professional Java programmer (using Go in my spare time) but I would really like to switch to Go in the future. Unfortunately, local shops using it are rather sparse.
Still trying to get into it myself, still a good bit I don't understand yet. I am trying a few test programs first. There are a few things in the syntax that 'blow my mind' as it were.
As another Go newbie, I agree that make (and new) seem out of place compared to the rest of the language. First, I think "make" should have been called "new" and "new" should have been called "alloc". If I create a custom type that needs a constructor, the idiomatic way to do that is with a factory method names "NewFoo". So, "make" is the equivalent for built-in reference types, but the naming differs. Alternatively, I suppose factory methods have been standardized as "MakeFoo" instead. Second, I feel like "new" should be de-emphasized in the tutorials and docs. It seems to me that 99% of the time it would be better to write "new(T)" as "&amp;T{}" and therefore most people probably never even need to use "new". I realize that there are some things you can do with new that you can't with the literal syntax, such as "new(int)" or "new(*T)", but I can't think of a case that requires new and might pop up in a typical program very often. Literal syntax has the benefit of also working as a simple constructor and is even a few characters shorter to type, so I'm not sure why you wouldn't use it if you could. Third, I think that new and make are the best example of why Go needs to add generics eventually. They are both essentially generic functions that take a type as their first argument and return a value of that same type. The key thing to note here is that all 3 built-in reference types supported by make are collections (slice, map, and channel). If I wanted to add some other collection type (set, queue, etc) in a reusable way, I'm pretty much out of luck right now. I could make separate StringSet and IntSet implementations, with lots of duplicate code, or I could make a Set that stores interface{} objects that basically just turns type-checking off. The language designers realized that neither of these options is ideal, so they added just enough generics to the language to support new/make and the built-in reference types. Hopefully some day the rest of us will have that power for custom types as well.
Thanks! Didn't even see this site. I'll definitely see if I can write a pure Go solution then. Also: `&lt;&lt;TableOfContents: execution failed [Argument "maxdepth" must be an integer value, not "[maxdepth]"] (see also the log)&gt;&gt;` Was in the page. Kinda funny.
Ah, gotcha.
http://www.codinghorror.com/blog/2006/08/a-spec-tacular-failure.html
This is my first real attempt at using Go to write anything. Tell me if I botched anything to badly.
Yup, you got it.
Thanks for the link! I found [go-taglib](http://godoc.org/github.com/wtolson/go-taglib) on godoc, made a few edits, and now I've got it writing things. [link if you're curious](https://github.com/landr0id/go-taglib/tree/development)
You should write them to conform with Go's std lib [Hash interface](http://golang.org/pkg/hash)
Good catch. The code was written in less than 30 minutes without a lot of deep thought.
There is an implementation of fnv in the standard library you can compare with. Also, I've implemented a number of hash functions here, including Jenkins: https://github.com/dgryski/dgohash
Here, is this better? https://gist.github.com/Chase-san/5557228
I have a Makefile that creates a .deb file (Debian package) that gets installed with dpkg. The package installs into /opt/xxx where xxx is the name of the webapp. In that there's a "bin" directory with the single binary and a "static" directory with static files (css, html, js). You'd normally have a "template" directory with your HTML templates, except that I compile those into Go using a pre-processor I wrote. (I like static typing.) The binary uses the standard library's web server to dispatch to page-serving functions, and the whole thing is reverse proxied by Apache or Nginx. Let me know if there's any part of that you want more details about.
That pre processor that compiles html sounds interesting. More details?
It's here: https://github.com/lkesteloot/gpp It supports more than that README lets on. I'll update that. You can include other templates and have "if" and "for" statements. EDIT: There, you've shamed me into updating the docs.
&gt; First, I think "make" should have been called "new" and "new" should have been called "alloc". If I create a custom type that needs a constructor, the idiomatic way to do that is with a factory method names "NewFoo". So, "make" is the equivalent for built-in reference types, but the naming differs. Alternatively, I suppose factory methods have been standardized as "MakeFoo" instead. It is a little weird, but I suspect the reason is that something like obj := new(Object) is emphasized in the standard library as a way to create "new" things. The trick is that all of the methods attached to `Object` are designed to handle zero values of type `Object`. For example, `buf := new(bytes.Buffer)` is all you need. &gt; Literal syntax has the benefit of also working as a simple constructor and is even a few characters shorter to type, so I'm not sure why you wouldn't use it if you could. It just depends on what you're trying to express. When I see `new` used, it is typically a sign post that the methods can handle a zero value so that no initialization in the API is needed. &gt; The language designers realized that neither of these options is ideal, so they added just enough generics to the language to support new/make and the built-in reference types. Hopefully some day the rest of us will have that power for custom types as well. Indeed. There is a really important idea being tested right now: is a little bit of generics blessed by the language design sufficient to cover most use cases so that full-blown generics aren't missed so much? So far, it *seems* like most people that have programmed in Go extensively tend to agree. In my experience, the most vociferous folks about Go not having generics are programmers that haven't tried it in earnest. This may of course be self-selecting, but as of right now, Go is growing rather rapidly. So I think the future is uncertain. In the mean time, since you're interested in generics in Go, [I'll just leave this here for you](http://blog.burntsushi.net/type-parametric-functions-golang).
&gt; It is a little weird, but I suspect the reason is that something like &gt; obj := new(Object) &gt; is emphasized in the standard library as a way to create "new" things. The trick is that all of the methods attached to Object are designed to handle zero values of type `Object`. For example, `buf := new(bytes.Buffer)` is all you need. But why not write that as `buf := &amp;bytes.Buffer{}` instead? Using `new` might read a little better when all you want is a blank value, but if you use struct literals to set values elsewhere then you end up using different syntax to do essentially the same thing. Certainly not the end of the world, but it rubs me the wrong way. &gt; It just depends on what you're trying to express. When I see `new` used, it is typically a sign post that the methods can handle a zero value so that no initialization in the API is needed. But if initialization is required, then the package should have a `NewFoo(...)` function that handles that right? But why is this called `NewFoo(...)` and not `MakeFoo(...)`? Doesn't `new` mean you get an empty instance an `make` gives you an initialized one? Again, not something that makes Go any harder to use, it just seems like a design wart. &gt; Indeed. There is a really important idea being tested right now: is a little bit of generics blessed by the language design sufficient to cover most use cases so that full-blown generics aren't missed so much? So far, it seems like most people that have programmed in Go extensively tend to agree. In my experience, the most vociferous folks about Go not having generics are programmers that haven't tried it in earnest. This may of course be self-selecting, but as of right now, Go is growing rather rapidly. So I think the future is uncertain. It seems to me that Go will have to add generics at some point, just like C# and Java did before it. One of its big selling points is type safety, but you just can't currently create reusable data structures that will be type safe at compile time. So, saying that generics aren't needed seems like the same thing as saying slices and maps are all the reusable data structures anyone will ever need. I'm just not sold on that idea, but maybe I'm wrong. &gt; In the mean time, since you're interested in generics in Go, [I'll just leave this here for you](http://blog.burntsushi.net/type-parametric-functions-golang). That's super cool, but totally unpractical. Personally, I'd much rather throw something together with the template package so I could write Go code "templates" with {{T}} placeholders that could be swapped out for whatever type I actually need.
Re new vs. struct literals. I actually don't completely disagree with you. Just lending some extra perspective. :-) &gt; It seems to me that Go will have to add generics at some point, just like C# and Java did before it. One of its big selling points is type safety, but you just can't currently create reusable data structures that will be type safe at compile time. Like I said, the future is uncertain. As far as we know, the minds of the Go developers still aren't made up yet. I've personally written an ungodly amount of Go code (libraries and applications), and I haven't missed parametric polymorphism as much as I thought I would. Sure, I miss it some times. But I could definitely see Go continue into the future and never add generics (and I'd probably still use the language). With that said, I'd also welcome some form of parametric polymorphism into the language. But I'm 100% with the Go devs on this one: it has to meld with the existing design well, and that is *hard*. &gt; So, saying that generics aren't needed seems like the same thing as saying slices and maps are all the reusable data structures anyone will ever need. I'm just not sold on that idea, but maybe I'm wrong. I don't think anyone actually believes that vectors and hash tables are the only things you'll ever need. I think it's more like, "Vectors and hash tables cover so many uses of data structures that we can get away with not providing generics to users of Go." Namely, reduce the pain from code reuse but not eliminate it in exchange for keeping the language simple and straight-forward. Keep in mind that struct embedding and interfaces are additional (compile time safe) ways to reduce code duplication in Go. &gt; That's super cool, but totally unpractical. *Almost* totally unpractical. I acknowledged as much at the end in my analysis of the benchmarks. The `Map` example sucks, but there are a couple nifty examples that could conceivably be used. Of particular note is an unbounded asynchronous channel. &gt; Personally, I'd much rather throw something together with the template package so I could write Go code "templates" with {{T}} placeholders that could be swapped out for whatever type I actually need. I guess [this would interest you](https://github.com/droundy/gotgo). But the project doesn't appear too active.
To expand a bit more on this to OP, from my experience (which is limited): there are several web "frameworks" out there at the moment. There are a couple of really noble efforts in the works ([Revel](https://github.com/robfig/revel) comes to mind) but whether or not you like these is a matter of personal opinion. I've used (and contributed to) Revel, but I have also equally enjoyed going framework-less. In fact, the more experienced I get with Go the more I like not using a pre-defined framework and going raw net/http instead. Why? Well, I think that *a lot* of the common, reusable features you'd want in a web framework are relatively easily implemented yourself. For example: * Want a config file? Write JSON in a file and unmarshal it when your app starts. Everything's already in stdlib to do this with minimal effort. * Need request interceptors? Simple: write your own or wrap the existing [handler function](http://golang.org/pkg/net/http/#HandlerFunc) to apply them. * Need flexible routing? Plug-in the [Gorilla](http://www.gorillatoolkit.org/) mux package. After a while, you'll have your own little framework which you can reuse and expand upon whenever you want. This is not to say that web frameworks are useless, I'm sure most of them are really handy. But you might not need a framework at all. Just keep it simple.
We're currently putting together an example app with details of how we built our REST API in Go. We use mux with some other packages. I'll post it here when done. It's purely an API - there's no frontend code (that's all django - [see here](https://github.com/microcosm-cc/microweb)), so no HTML templating. One point worth mentioning, though: I'm not actually sure what proportion of Go programmers use Go for web development. At a meetup group recently I got the impression that building an API put us in the minority. Though I'm not saying you shouldn't use it for that purpose, of course -- but it might explain why there aren't that many articles on the matter.
&gt; I recommend you use Google App Engine. They have walkthroughs that will help you through the steps. To be more accurate, there is only one solid Go tutorial for GAE at the moment, and it's fairly basic. I also didn't get the feeling that the time "saved" by going down the GAE route was worth the lock-in, or that it truly saved much time at all. Gorilla Toolkit (mux, schema, sessions, etc) and/or [go.auth](https://github.com/bradrydzewski/go.auth) can take care of routes/authentication/sessions just as easily as GAE can (which will only make Google sign-in easy), and there are a multitude of SQL and noSQL drivers that make backing on to a DB pretty straightforward. I'm using go.auth for Google/GitHub auth, gorilla mux for routes, and the Go [RethinkDB driver](https://github.com/christopherhesse/rethinkgo) for a NoSQL data store (that's better than MongoDB, IMO).
Just thought I'd note, for funzies, that your sentiments seems to almost echo the same way that PHP is going. PHP has really had a dividing era: before and after composer. Composer being PHP's de-facto package manager and retriever, like python's pip / ruby's bundler / go get (I believe). BC (before composer), full-stack frameworks were the bees' knees, the forefront of PHP development. And there's actually nothing wrong with that, I mean you can't look at Rails or Symfony or Django and tell me they're all doing something wrong. But AC (after composer), people have finally been able to start implementing packages of contained functionality, things like custom loggers, routers, or even split full stack frameworks apart into their components (look at symfony 2 or laravel 4 for examples). So to finally conclude my note, there are some PHPers doing exactly what you suggest, pick and choose functionality and modularity (go has a much better designed standard library than PHP's, so there's less you need to pick 3rd-party to do this) and just glue it neatly together in the way you like best. It's interesting to see the way web development evolves, and how the same practices have paralled across languages (even from a web-focused, single-serving, interpreted language to a compiled, general, systems focused language!).
Well it does make it easier to read of course. :)
For the few I've made, I've built the binary on my dev machine or a dedicated build machine, then scp'd it to production, rsync'd static files, and use upstart to keep the server running. The server generally reads in a config file, either json, or recently toml, that tells it what port to listen on, how to connect to the database, where to store files, where the static files live, etc. Then an nginx reverse proxy goes in front of it. As primarily a Python/Django developer, it's a pretty nice change to be able to pretty much just copy over a single binary and restart a service, not really worrying about complex dynamic dependencies. I usually set up a quick and dirty Makefile that has a 'deploy' section that just does the "go build", rsync, and restart commands, but that's about as fancy as I've gotten. Also, the Go web apps I've built so far have been relatively small and single purpose (compared to a typical Django app), and I've generally opted for just inlining the templates straight into the source code so the binary doesn't even have to go out to the filesystem to find them in production. That's not necessarily sustainable as they get larger, but so far the tradeoff of not having so many movable parts has been nice.
It's been a while for me with GL under Go, but: I never warmed to Go-GL and always had good success with chsc/GoGL glfw under Win7 64-bit (and OSX and Linux too). Also liked the "raw, pure C binding" nature of chsc/GoGL much better than the "let's try to wrap GL idiomatically" approach of Go-GL. I was going to recommend gogl to you, but seeing as you already found it, I just wanted to reinforce my opinion here---gogl is the win, go-gl is the lesser choice imho.
You could try [gothic](https://github.com/nsf/gothic) for a Tk interface.
This could be good. I didn't know about the themed widgets introduced in Tk 8.5 until now. I have had a long-standing prejudice against Tcl/tk apps for being ugly, but it might not be a problem any more.
Yeah, probably tcl/tk (where you have to write a lot of tcl anyway) or html (html/css/javascript) are the way to go at the moment. Producing good quality gtk or qt bindings requires a lot of work which isn't exactly fun. I did [gothic](https://github.com/nsf/gothic) and [gogobject](https://github.com/nsf/gogobject). But frankly I wouldn't suggest using gogobject. It may work or not, but it's incomplete for sure and I don't work on it anymore. Partly because I've lost interest, partly because there are some annoying issues with Go and no easy way to fix them. If you're curious the current issues are: 1. Go doesn't handle signals which originate from a thread created by the C code. It happens to be a case somewhere deep inside the gtk3 file or applications dialog code. It's unclear if I can fix that. 2. Go bloats binaries. It's not a big deal for small libraries with a couple of hundreds functions. But if we talk about gtk3, it's more than 4000 functions and methods. The reason for this is that due to runtime reflection and an ability to reach a lot of functions through reflect api, Go compiler has to include all the unused bindings code even if it has no callee/caller dependencies in-between. Typical Go gtk app will easily reach 20 megs or more and that doesn't include the libraries you have to carry with you (all the .so mess gtk pulls in). From that perspective (and I'm a perfectionist), I decided to stop working on gtk stuff. Tcl/tk bindings should work, but tcl/tk has other issues. Hopefully that describes the state of GUI in Go. 
&gt; I would be interested to know your reasons for choosing go-gl over gogl. It was the first one I found, really. I can really only play with this stuff occasionally. I will look at that other gl binding tonight, hopefully.
Yes indeed. I think stopping GTK is smart. You've probably seen all the gnashing of teeth in the blogosphere in relation to GTK3 API instability (tied heavily to full GNOME releases) and portability issues, and GTK2 is officially unmaintained. I'm not sure GNOME is interested in GTK3 being a cross-platform UI toolkit in the way GTK2 was. These days I like declarative UI configuration. I don't need classes for all the widget types if I can have a nice lightweight binding from the declarative configuration to my own "native" code. (I'm thinking about QtQuick/QML and such.) On that subject, I very much like the binding in [your channels example](https://github.com/nsf/gothic/blob/master/_examples/channels.go). &gt; tcl/tk has other issues Any in specific that are important to keep in mind if starting a GUI project with gothic + tcl/tk?
I'm not sure what you mean by using lua to allow "the logic of the application to be altered". If you mean you want to implement plugins in lua, that makes sense. If you mean you want to use lua to manipulate compiled go code. . .well, I have no idea why you'd want to do that and it will probably be painful. [Golua](https://github.com/afitz/golua) seems very relevant to your interests.
Sorry, I just mean I want to call Lua from Go and handle the returned results, that's all. The library I linked above is a more up-to-date fork of the one you posted.
Well, the main problem of tcl/tk is that it's quite limited in performance. When it comes to writing custom widgets there's a very limited amount of things you can do with that. Qt and GTK are both a much better quality GUI toolkits. Yes, tcl/tk has somewhat superior OOP-less design, I like that too, but I would prefer using GTK or Qt for real stuff.
Awesome find, thank you! Looks like they're relying on cgo, which is a nice vote of confidence.
Thanks for the awesome work!
And here's the mailing list thread: https://groups.google.com/forum/?fromgroups=#!topic/golang-nuts/BwMNUlOmZao
I'm not sure how to feel about this, mainly because I'm not sure where I'd use it outside of using 'untrusted' code, which honestly I haven't done a lot of yet in Go(so please don't take that as a slight). When I read the proposals for, example, changing the arguments of Compare to receive these views - this would seem to bring more work/typing as it seems like I'd have to cast things I've already built just for the sake of it - unless the compiler was smart enough to do this type of inference for me. Regarding syntax, I found the . notation awkward and confusing, since it seems reserved for 'methods' otherwise. It almost feels like it should be a shorthand keyword or simple wrapper used at pass time that lets the compiler know that it is illegal for the receiving method to change the value, rather than a whole new type. Just using # as the marker for now - x := []string{"hello"} y := [].string(y) dosomething(y) //vs x := []string{"hello"} dosomething(#x) Something along these lines would also require no changes to the std library arguments, since both are passed the same datatype. A function like Compare should only care about the underlying data, not necessarily whether it's a mutable or immatuble slice, in my opinion. Is there some other use case I'm not thinking of?
The dot notation is a placeholder. Please ignore syntax for now.
The benchmarks game page needs to update their numbers stat! 
Those are some unfortunately close names for similar packages.
According to the [post on the mailing list](https://groups.google.com/forum/?fromgroups=#!topic/golang-nuts/Q-nTxiJ0xz0), the tentative schedule is April 25-26 2014 in Denver.
Wow heka lua setup looks good https://github.com/mozilla-services/heka/tree/master/sandbox
It looks like they've been updated. I'm super impressed. Go is very nearly on par with most languages in the shootout sans C/C++. (And Go certainly holds its own in that comparison.)
If you're interested in doing "modern" GL (shader-based, no fixed-function pipeline) --- 1. Here's the "minimal (modern) gogl program" with GLFW: https://github.com/go3d/go-opengl/blob/master/cmd/gogl-minimal-app/main.go 2. Here's a highly incomplete, sadly temporarily abandoned engine project: https://github.com/go3d/go-ngine (It uses a drop-in replacement of gogl but that's just a gogl clone with identical GL core profile API so good enough to dig into some code although it has become quite convoluted despite not even doing much in terms of sophisticated rendering per-se.....)
Honestly, I have no idea. If you pressed me to guess, then it could be due to the scheduling of goroutines in the runtime or perhaps the way the benchmark was written itself. Or the value of `GOMAXPROCS` that was used. Tough to know without more info. Perhaps someone else in-the-know could chime in.
For the people like me who did not know this existed: http://benchmarksgame.alioth.debian.org/
It could have to do with Java's GC and other runtime threads multiplexing poorly to the single core (at least compared to Go's lighterweight concurrency model).
I tend to agree. If you're making a desktop app, you should bite the bullet and use the native language for it. If you want something crossplatform, why not use the web? Or at least a thin wrapper around a webserver.
Thanks to the Go devs! Over the past year Go has become one of my two favorite languages (the other one being Python). Trying out this release, seeing some of my code just speeding up by a factor two without anything breaking in the transition - is just fucking awesome. Keep it up!
Go does not support concurrency. It is not an actor model, it's a sham. It's also a SHAME that people these days want concurrency but aren't willing to learn what it means and what it requires. Go delivers NONE of what is required (namely notification at the failure of a routine) You don't need a new language-- erlang has everything you need. I think the popularity of Go over erlang comes from two things: 1. Go is from Google and so much of the "tech" community these days is made up of google cultists. 2. Erlang has a syntax that is not like C. And since C-like languages are what people are used to, they can't be bothered to take a week to learn an actual new language. It's fucking laziness, is what it is. Or incompetence.
You're right, Go is designed for CSP rather than an actor model. The remainder of your post is subjective or unsupported--often both. 
if you get into operating system work - you find pretty quickly that going multiple-CPU (multi-core) in the same application introduces a lot more issues. An obvious one is the 3 or 4 layers of cache you have on a CPU. There are thresholds where code size and OS go beyond a cache size and the performance can change dramatically. Concurrency helped a lot of apps long before multiple cores came along.
Erlang has a horrid syntax and your statement that Go does not support concurrency is laughable.
There was also this (imo) interesting 'native' Go GUI in development (uik): but it seems it's currently developing at a very slow pace. Something to keep an eye on for the future though. https://github.com/skelterjohn/go.uik
The binary-tree benchmark primarily tests allocation speed, IIRC, and Go's GC is still rather basic, I think. That awesome IBM GC hasn't (yet? ever?) come to fruition.
Thanks for the laugh! Good stuff. 
Erlang does not have a horrible syntax, it's just different, and like lisp, you get used to it very quickly if you give it a chance. 
&gt; Go delivers NONE of what is required (namely notification at the failure of a routine) http://play.golang.org/p/8EAXth6t_E
A likely aid to further debugging is the Sysinternals suite of Windows introspection utilities; for this issue, I would start with [Handle](http://technet.microsoft.com/en-us/sysinternals/bb896655).
Ahw thank you, that's place to start. I've to travel a bit now, but I'll test it as soon as possible.
You say it can be `run`. What does the program do? chances are that it maybe hung for a while. E.g. if it's making any network connections it may have hung waiting for DNS, etc.
Sorry, will update.
Thanks, I hope I'll never need it but it is appreciated :)
Did you refresh the web browser cache? The first set of updated measurements was posted 4 hours after the Go binaries were uploaded to the code.google download page; the fourth was posted 3 1/2 hours later.
"For each named benchmark, measurements of *the fastest* Go program are shown for comparison against measurements of *the fastest* Java 7 program." Maybe there are both Java programs written for multi core that are the fastest Java programs on multi core, and different Java programs written for single core that are the fastest Java programs on single core. 
Hmm, wouldn't the easiest choice for interested parties be simply to write a Lua implementation in Go? Given all the nice stuff, I'd think that it would turn out to be much smaller than the reference implementation.
&gt;The link to the issue in question returns a 403 Forbidden error. Was accidentally deleted.
I actually think it's nice. Sections are horizontal, subsections are vertical. That way if you know what Go is (for example) you can skip the section about "What is Go?"
This had nothing to do with realtime programming in Go? It just seemed to talk about Go in general. I wanted to here about deterministic execution; I wanted to see if someone was mentioning how the garbage collector impacts realtime application performance; I didn't want to be told what Go was again.
If you're letting erlangs different, yet elegant, syntax put you off of learning the language, then you're not skilled enough to be worthy of the language.
OMG, really? If the co-routine crashes, you never get the notification. El Stupido. In fact, this makes my point. It also makes the point that go programmers are so ignorant of what's necessary for distributed processing that they don't even realize how bad they've got it. Also, since you're so intolerant that I'm forced to wait 9 minutes to reply, I'm going to make this response much longer than it would have been anyway. Your responses tell me that go programmers are ignorant assed google fanboys who are into the language simply because it comes from google. And despite having no morals (eg: you worship a company whose business model is abusing people's privacy) you're also such piss poor programmers (probably piss poor thinkers) that you can't even tell when someone points out a problem with your language. Certainly, given that level of incompetence and mindless ideology, I should not, in the least bit be surprised that you don't know enough about concurrency to know what's required of a sufficiently robust language. I predict decades of shit produced by you guys, much like the shit cargo-cultists are now producing in node.js and the shit mindless idiots like you produced from java in the past. This is one of the reasons not everyone should learn to code- too many of you lot are not enough in the habit of thinking... thus you're wrecking havoc wherever you go with your ignorant choices (and certainly incompetent code.) I'm sure brains addled by years of carefully learning how to not think will not be open or receptive to these points-- as the evidence so far shows-- but its not my job to make you aware. I do enjoy pointing out precisely how stupid you are and how amusing I find it to do so. " The remainder of your post is subjective or unsupported--often both." Only subjective if you aren't enough of an engineer to know the correct solutions... and unsupported only if you don't know the basic facts of the situation at hand. I think it's hilarious that you're so stupid that you think this is a rebuttal. You just assert things about my argument and to your unthinking mind you think that wins you some points. You lost the debate the moment you chose to play for the crowd rather than pursue the truth-- in that instant you became a bafoon of no integrity, not even a man (or woman) but an animal, clowning around.... because by calling my argument names you admit you don't have the reasoning ability to find faults with itl (or the knowledge)... but that you also don't have the integrity to admit as much. Pathetic. 
So basically Go proving that it's pretty darn good at doing what it was designed for: easily writing fast servers with non-trivial computational complexity. Well, it's great to see that it excels at its foremost use-case.
[Here](http://www.tkdocs.com/tutorial/intro.html) is a good modern Tk tutorial if you are interested.
I can't tell if you're being sarcastic or not. :-) Either way, it's good that a thing has a use.
No sarcasm at all :)
The link isn't working at all for me, and Google's cached version just says the contents are being withheld a few weeks until Go 1.1 is released... so I'm assuming the cache is out of date.
That's weird. Still works for me.
&gt; OMG, really? If the co-routine crashes, you never get the notification. A Goroutine crashes with a panic. The panic is recovered in the defer block, and the notification is sent. Of course you get the notification. The rest of your drivel is utter bullshit.
Interaction of full GC sweeps with virtual memory has historically been a problem. I believe that the only solutions so far that have avoided the problem involved GC-aware OS kernels. (Lisp Machines in the 1980's had a memory management module that did this - [read this](http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.125.2438&amp;rep=rep1&amp;type=pdf)
In time, it might be possible to run Go stuff in the Chromium Embedded Framework.
*Almost totally unpractical. I acknowledged as much at the end in my analysis of the benchmarks. The Map example sucks, but there are a couple nifty examples that could conceivably be used.* The performance problem could conceivably be alleviated if the compiler did 1) eager inlining of functions using reflection on their interface parameters, 2) special treatment of reflection functions in the intermediate code, and 3) extensive copy propagation, constant folding and dead code elimination. This probably wouldn't reduce the performance pressure in all cases, but I imagine that many reflection calls would get eliminated by this approach. One of the benefits would be that this wouldn't require any language change at all to make the generic code more flexible.
I would just like to support this. I am planning on using go on my RPi, but dev on my windows machine. I'm not 100% on the cross-compiling (you might be), but I'll just push the .go file and "go run" will compile it and run on the RPi.
I am. I will read this. Thanks.
In the eyes of someone who hasn't used functional programming languages, it's just plain horrible. Sure Erlang is great for many things but being easily approachable by the average Java/Python/whatever programmer isn't one of the its advantages. Giving it a go for some small hobby project is worth it though!
IMO, too much reliance on pattern matching places a lot of cognitive overhead in reading Erlang code. I can get used to ugly syntax (*cough* Objective-C *cough*), but following the code flow is not straight-forward.
I don't think the post even attempts to be an apples to apples comparison. It's just another Go success story and an example of good use case for Go.
It's back now, sorry for the noise.
The benefit came from how easy out was to write a long-running process in go versus in cpp, in short
That's *wreaking* havoc, not wrecking havoc, mr. smart guy.
Yes, I'm using Go 1.1. Most of my allocations are []byte and []float64 so that explains why the GC still runs quickly even when I'm out of memory! I had no idea those were exempt from collection, thanks.
no, it's all mine
Sure, I like Go as much as the next guy, but the headline is link bait, as the author admits in the very first paragraph.
The headline is quite accurate.
It depends on what terminal shell you're using, but I'll assume it's bash. In that case, you need to set your `$GOPATH` in your `~/.bash_profile`. The one for my Mac says: export GOROOT="/usr/local/go" export GOPATH="$HOME/Documents/Code/Golang" PATH="$GOPATH/bin:${PATH}" You, apparently, should have a different `$GOROOT`. Everyone should have a different `$GOPATH`, since it's the directory where you personally are storing your projects. It will probably be in some part of your home directory. Make sure to read http://golang.org/doc/code.html for a general overview.
Don't set $GOROOT. The go compiler already knows where is it. 
&gt; I know I now have to set my $PATH variable to be able to use go, but I can't understand how. I'm just blocked. Why do you think that? From the looks of it (you posted the output of `go env`) `go` is already in your `$PATH`. i.e. it's probably installed at `/usr/bin/go` so there's nothing more to be done
First obvious comment: make it Go gettable: &gt; go get github.com/dradtke/go-allegro/... &gt; package allegro: unrecognized import path "allegro" &gt; package allegro/image: unrecognized import path "allegro/image" Second obvious comment: link to the Allegro site in README.MD. Anyway, I'll try it out later and see if I can give more constructive feedback :).
It's BSD right now, is there a real difference with MIT? I don't mind, just out of curiosity, or maybe you've missed the license.
The fact that you can run "go env" means your PATH is set correctly. Create a simple hello word go source file named hello.go, then run "go build hello.go" in that directory. You should get a "hello" executable file in the same directory. This is sufficient to play around with go. Once you start writing bigger go programs, you'll want to set your GOPATH. You should read (or watch the screencast) "How to Write Go Code" - http://golang.org/doc/code.html as another poster suggests. This describes how to write go programs in the standard way. Then set GOPATH in your .bash_profile (or .bashrc if your source that from your .bash_profile) as is appropriate for you. 
The package is now go-gettable, and a link to the Allegro website has been added in the README.
Great job. No constructive criticism yet, but I'll give it a try today evening.
No spaces. It's GOPATH=/path/to/your/go/workspace. Also, it's better to change your local .bash files rather than the global ones.
Oh, that makes sense. For some reason, I thought you had to set it yourself, but when I was playing around with fish shell last night I noticed that it worked without setting GOROOT. That explains why.
It used to be necessary.
So I tried installing Allegro on Windows... [fuck it](http://www.gaia-gis.it/spatialite-3.0.0-BETA/mingw_how_to.html), I'll reboot to Linux. EDIT: But didn't remember to build Allegro with SHARED=false... d'oh!
I don't develop on Windows, but it looks like you should be able to just download the binaries [here](https://www.allegro.cc/files/).
Well, it's already running on Linux now. If you want me to test, I can try out Windows again later.
Not for a really long time...
Ill just leave this here. https://plus.google.com/+golang/posts/ZmRNsQ3gMRo
Cool. You missed a golden opportunity to add [gobs program](https://www.youtube.com/watch?v=JbnjusltDHk) as a fun easter egg command line option though 
gahhhh why didn't I think of that, heads up for a commit in the next few seconds
done.
I like the idea and will certainly try it (although I mostly use IntelliJ's excellent plugin which does that already). One thing though - why did you choose the name gob? It's sort of confusing with the already existing gob package in the standard library.
I started this before I knew of libgob but I don't really think there should be a confusion between a library and cli. But hey I can change it pretty easily if it becomes a problem.
I'd change it, just so that if your project becomes popular, no one would ever be embarrassed by someone else saying: "so you're using Gob for that, right?" - "uhmmm... no... wait, WHAT? how the hell does gob have to do with [project management/serialization]?" :) 
Excellent.
...you know that having a GOPATH per "project" is [considered bad practice and actively discouraged](https://groups.google.com/forum/#!msg/golang-nuts/dxOFYPpJEXo/mpQ5CwBuj-EJ), right?
I realize and have read about this opinion but I have also read and experienced the blunders of trying to share and manage project code in this manner. This may be considered opinionated software I suppose, so don't use if this doesn't fit your workflow. I also appreciate you citing rather that just stating. Cheers! edit: instances like [this](http://forums.thedailywtf.com/forums/t/27755.aspx) are the reason I changed my workflow also I came from the node.js community where it is common to commit you libraries to source control, and the ruby community where it regulates the versions of libraries.
So the talk that wasn't streamed is now on Youtube, but I still can't find "Fireside Chat with the Go Team" which was streamed :/
This was good and informative talk. Great example problem too. Even I (re)learned something; I didn't remember at all that nil channels are simply ignored in selects.
Keep in mind AB/siege/etc can be inaccurate, depending on your file &amp; port tuning. You can often hit OS limits before you hit application limits. The nice thing about Go is that HTTP requests get their own goroutine (i.e. concurrency with no work on your behalf). PS: Depending on what you're doing, RethinkDB can be a solid alternative to Mongo if you need consistency &amp; proper joins. 
Mostly you are benchmarking TCP connection establishment (add -k).
https://www.youtube.com/watch?v=p9VUCp98ay4
Where is the source code for the example RSS client in the talk? Does anyone have a link?
I'm going to watch it anyway, but did you notice anyone asking if the team has read up on Stepanov's Elements of Programming, with respect to the type system evolution, or whether any similar endeavor is being pursued?
Sameer Ajmani said "We're working on it; there will be a post soon. " on the Go Google+ page. https://plus.google.com/117585488707006432442/posts/FSi7K9Pc6EQ
No, nothing about types at all, really. Or generics. It is worth listening to, for sure. Concerning potential performance gains, everybody believed there was still a lot of low-hanging fruit.
tl;dw: Really cool demonstration on how you could process massive sensor data sets and interface with users' browsers using Google's mapping APIs, WebGL, etc. This talk focused on location data from tens of thousands of ships.The Go angle (which they go into starting at around 22m into the video) is how you get any kind of responsiveness when mucking around with such huge data sets. They went into a little detail on how they could use select among goroutines that were attempting to retrieve query results from memcache vs. data store vs. actually calculating the answer from a 70 GB massaged data set...I presume also using Go.
Using HTML5/CSS/Javascript seems like a smart idea, however, are there any pointers as how to wrap a webapp into a standalone "app? My only experience with GUI programming is (sadly) Java's Swing library. Any pointers? I'd probably have to learn how to write javascript from scratch as well.
What do you mean by "the doc"? The spec clearly says that ranging over maps is in an undefined order: "The iteration order over maps is not specified and is not guaranteed to be the same from one iteration to the next. If map entries that have not yet been reached are removed during iteration, the corresponding iteration values will not be produced. If map entries are created during iteration, that entry may be produced during the iteration or may be skipped. The choice may vary for each entry created and from one iteration to the next. If the map is nil, the number of iterations is 0."
I'm sorry, I meant to link to the document I was looking at. I was looking at the [text/template](http://golang.org/pkg/text/template/) document. Perhaps I'm using the wrong type here then. edit: yeah, I just went with an array and added a "Key" field to my struct. However, using a map would be a lot easier.
For context, [golang-dev discussion](https://groups.google.com/d/topic/golang-dev/WyoohU08z5M/discussion) and [related document](https://docs.google.com/document/d/106hMEZj58L9nq9N9p7Zll_WKfo-oyZHFyI6MttuZmBU/edit)
"Go *Broject* Management"  you know some folks will think this means you have a spray tan, right?
"These dates are non-negotiable hard limits." seems strange to me; is this an attempt to be a more mature project? Or has it always been like this behind the scenes anyway.
It's the opposing strategy to "let's add this features regardless how long it takes". They don't promise which features will be in the releases, only when the releases will happen.
I like this release cycle. The hard date are a nice touch.
You can wrap the map into a channel iterator: http://play.golang.org/p/vsrElIsznV But why?
*Actually Dec 1, not Jan.
It's also the opposite of their old rolling release method. Go used to be officially run from the head of the repository, so anytime something new was committed you had a new Go, which means everyone was literally working on different versions. With gofix that wasn't a huge problem, but still annoying. I'm also happy for a 6 month release cycle.
Basically I'm using it for a collection of nav items on my website. I had a map setup so I could quickly reference items without having to iterate through the collection. Since it's for a nav bar, I want them in the order in which I defined them. I just ended up adding a "Key" field to my NavStruct since iterating over a small array is really no big deal.
While this article is already excellent, an improvement could be done : linking more to the bench source : the point about "BenchmarkAppend" is clearer when you see [what is benchmarked](https://github.com/davecheney/autobench/blob/master/src/bench/runtime/append_test.go#L10). A link from the image would be ideal.
Haha, yeah It was kind of a play on the whole Gob Bluthe thing, but I figured it would get taken that way as well.
Thanks!
It seems like there are so many of these things, it is hard to know which ones are truly more secure than the others. For instance, there is pwdhash.com, oneshallpass.com, longpw.com, 1password, supergenpass.com, http://angel.net/~nic/passwd.current.html It would be nice if a list of these were compiled somewhere, and/or, if someone with knowledge of the algorithms that all of these and many others are using, so that it would be easier to tell which ones are more secure than the others.
[pwdhash](http://www.pwdhash.com) *^if ^this ^link ^is ^offensive ^or ^incorrect, ^reply ^with ^"remove". ^\(Abusers ^will ^be ^banned ^from ^removing.)*
I'd definitely be interested in seeing your implementation of a REST API.
Hehe, everyone seems to be misinterpreting the question. OP is specifically talking about the range directive in text/template, *not* the range keyword in the language itself. This does indeed visit a map in sorted key order (if the keys are comparable). A standard solution would be to keep the keys in the order you want in a separate slice for iteration.
Using a global GOPATH when you're sharing code with a team and you need to have hermetic builds just doesn't work. How do you imagine they build Go code at Google? They check in dependencies into their internal version control; I imagine that the build system manages the GOPATH for them at that point. Using a global GOPATH (and 'go get', for that matter), is really only for hobby stuff and individual projects, as far as I'm concerned. At work we've got a bunch of projects with per-project GOPATHs and vendored dependencies and it works very well.
Vendoring dependencies is an okay strategy, but every mature community moves beyond that into more robust dependency management. As the Go community grows -- and I expect it to grow explosively in the next 2 to 3 years -- this need will become more obvious.
I think the discussion of the topic is fine, it's just the guy who post it is such an *******. To him, I want to say "Sod off from this mailing list, please"
Yeah, the title could be a little more clear. There are many really helpful and interesting posts in there. He started a potentially productive discussion but the attitude is horribly annoying.
yes, the tone of this particular thread is annoying. On the other hand it is also somewhat frustrating that the official attitude on generics still seems to be that no "perfect" implementation has yet been proposed, therefore no time should be wasted adding anything less than perfect. Every discussion on generics I've read is a mix of "we're happy enough without them" and "go ahead, try proposing something, and we can tell you why it doesn't work". Most language features require tradeoffs of some sorts. The point is that with generics you'd have a language that is harder to parse (well, it certainly can't get much easier than the current go...) and/or longer to compile which I understand are two of the main gripes the creators of go had against c/c++ when they decided to create go. I can accept that. I would just like better to hear that "barring a breakthrough in computer science that will allow us to have our cake and eat it too with regards to generics, we will never add them to the language", than reading "yes we do like them but..." over and over again.
If Lua is all that you need, then go for LuaJIT, there's no question about that. If, however, plan on customizing the language in a substantial way, good luck with rewriting the LuaJIT native compiler, which makes a lot of Lua-only assumptions. Also, the Go&lt;-&gt;Lua bridging would be much less natural in LuaJIT, so if what you need is a lot of simple callbacks for customizing something, you may lose most of the LuaJIT performance boost due to Go&lt;-&gt;C&lt;-&gt;Lua switches. I guess it's all about your goals, and not even Luaists use the language for one thing only.
Why the hell did I not think of this? Really good idea! That's exactly the type of solution I want. Thanks!
1. You don't get new features in an OS project by demanding them. You participate in the development. 2. Every language doesn't need every feature. Sure there are times in go when I wish I had generics. But more often than not, I can solve the problem in another standard 'Go' way.
FWIW, I think this kind of thing could be solved with gentle moderation. Just make the first post from any person go through a queue before it hits the list, and (kindly) tell this person that their mail will not have a productive result before it wastes the time of everyone else on the list.
Is there an example yet (honest question) of someone raising this question and actually starting with something like "My proposed solution for Generics in Go!", or is it always someone having an underhanded stab at Pike, Thompson and Griesemer for apparently not understanding the basics of modern language design?
No, plenty of valid suggestions have been made. Most of the people that can make them quickly retreat from the wall of stoney faces and "try harder" responses received from teh core developers.
He's only frustrated, and rightly so. Go was publicly available from late 2009, find me a mainstream language that doesn't have generics. The last one was released in the early 1970s...
It doesn't even have to be a perfect solution, just one that resolves this dilemma that rsc wrote about: http://research.swtch.com/generic
I've been using Go on AppEngine for small projects at home. I can't speak to performance, but working with AppEngine is a real treat.
So your solution is to censor dissenting opinions?
There's a difference between censoring dissenting voices and moderating disruptive people, trolls and wind-up merchants.
I understand his frustration but his attitude towards the reasoning is bad regardless. Just like being functional is part of Haskell's design, being careful with adding features is part of Go's design. Also see [jewishobo's comment](http://www.reddit.com/r/golang/comments/1etujr/probably_the_most_annyoing_discussion_about_the/ca3qj67). 
They specifically say that they just want generics whose benefits outweigh the tradeoff. Seems reasonable.
Well, the ones I've seen have tended to propose syntax, which doesn't seem to be the issue for the core developers - they seem worried about implementation. (If there's an implementation proposal out there, link me please :-) )
The only good thing I saw in that thread was the recommendation to look at how the [sort](http://golang.org/pkg/sort/) module does its thing.
Where are those valid suggestions which have been met by 'stoney faces' and 'try harder' from the core developers? Even this rather obvious troll have been met with explanations as to why generics proposition X isn't a good fit for Go (see Ian Lance Taylor's responses).
He's just this guy: http://www.youtube.com/watch?v=2-pPAvqyluI#t=56m40s Snobby Aspergers British Syndrome.
Wow. That was horrible.
It was accepted, yes! It's going to ISMB in Berlin this summer. I don't think the paper is publicly available yet, but it will be soon. I'll try to remember to come back and send you a link. I'll probably also submit it for everyone to look at too.
Once upon a time there was this most amazing thing called Usenet, which you would read using something called a newsreader, of which the prototypical example was likely the program rn. The most amazing thing about it was that, at least from time to time, the world's foremost authorities on some topic would participate in discussions in specific newsgroups. This was incredibly valuable, even for (or especially for) spectators, known then as now as "lurkers". But over time, it all went south. The killing blow was probably the birth of really aggressive and stupid spam, but the downhill spiral started when new correspondents would hop into a newsgroup and ask some FAQ that had literally been asked 100 times in the past month, which was bad enough, but then make matters work by acting like (or appearing to act like...the difference is marginal) a complete dick, reigniting some flame war or other until the people who really added something basically all left. Moderation was tried, and it helped for a time, but in the end the barbarians won. Anyway, the issue is not so much censorship but the fact that when anybody can say anything to everybody, nobody ends up being able to say anything useful. It is not an easily solved problem.
Well once you add a feature to the language you have to support it for a really long time. It's better to consider it carefully than to rush in just so you can add another item to the feature list. 
I don't get why anyone would do that.
I had the post you linked in mind but could not find it, thanks! Interesting read (including the comments)
I'm so glad Golang Weekly started up again. Thanking for do this and keep up the good work.
Thanks for the encouragement :)
&gt; keeping a separate frozen view of the world that is updated only when the developer feels a package new version is safe to use or keeping note of external packages working revisions. Is it that hard? Yes. It is hard, or at least not obvious, and some people will get burned. If keeping a separate frozen view of the world is really that easy then it should be part of "How to Write Go Code." The current recommendation of simultaneously pulling from several github heads is nuts. Or at least someone should call out more prominently that the "url" that you specify in the import should point somewhere besides a development tip. Perhaps Go library authors should tag more frequently and prominent examples should show tagged urls. But I think it's ultimately safer and clearer if the programmer can specify her intent explicitly. i.e. I want github.com/darrint/gothing with commit ref 3ea274. Ruby's bundler set a high bar. Programmer specifies intent, however loosely she wishes. Running bundler acquires/builds packages and records in a separate file, exactly what it got. Between those two files, bundler can exactly reproduce what it gave her on any machine. That is so handy when going to production. 
Sometimes, I feel like I am the only person who really loves the way go does dependency handling. It just works the way every (large) application I have worked on (large being 250k+ LOC, 5+ developers) ends up working. You can't depend on outside systems, github, NPM, CPAN -- it is a pointless risk that you shouldn't do. Yet, when you get a package from there, it is nice to remember its source. Go does both of these things perfectly, it localizes (puts in under src, which is what you check in for your project) and you use the address it came from to reference it! It never autoupdates a library under you, you have to use go get -u ... this is as it should be! I pull in deps, then I manage them in a sane way in my version control system, the only thing something needs to build my go app is to check out my go app and build it, they don't have to run cpan commands, npm commands, have an internet connection, etc. EDIT: The fact that it can work with a vast array of source control systems, doesn't have a centralized point of breakage (mirrors are just copies of a centralized failure point). 
I also did some work on this. It's mostly complete except callback functions: https://github.com/tapir/allegro I also did not find a good way to port mac os x "al_run_main" workaround
That'll be great. You should know that I was told that the journals tend to ban scientist from publising articles with them in the future, if they publish "their" articles for everyone to see  and thus cheat them of revenue.
Totally. In my research field (computational biology), most articles are freely available to the public (part of NIH funding, I think). I can't remember if the ISMB conference is like that though. Regardless, if it's closed, I can send the article privately to those interested. Most gophers would only be interested in the code, if at all, anyway. :-)
Aha, I had a feeling I was missing something obvious! Thanks!
Thanks for sharing this. This is nice code to read and learn from.
How did you get go on your Pi in the first place? If I "apt-get install golang" on wheezy I get a "go" binary that crashes (illegal instruction).
You don't need Go on your Pi. You cross-compile it on your Linux/OSX box, etc. At any rate: http://dave.cheney.net/2012/09/25/installing-go-on-the-raspberry-pi
go compiles to a native binary, like C or C++ does. edit: if you really want go on your pi, go here: http://dave.cheney.net/unofficial-arm-tarballs
As someone who's worked a lot on [similar projects](http://github.com/jmoiron/sqlx), can you explain how you've achieved 60-130% faster speeds for those dbs if you're still relying on database/sql? As an aside, there are about 5 good implementations of `QueryStruct` / `StructScan` out there in the wild now. `database/sql` imports reflect anyway, so perhaps it's time to create a version for the standard library.
I am trying to port hub(https://github.com/defunkt/hub) to Go
This seems like a really fun project. I'm surprised that you can measure a difference given that the network round trip and github api response times should be substantial in comparison to the client side computation. 
You can take a look at my Angular / Go seed project on [github](https://github.com/campbel/gap-ng-seed). As far as serving up templates goes, you have 2 options. * Have 1 go file handle the serving for all routes. * Create a different package for each handler. The first options should be simple enough to understand. You have the root package load in all of the templates and perform routing based on the request url. The second option I think is cleaner. Take a look at the app/api/user of the code I linked. You can see that in api/user/user.go there is a handler for api/user. This example is a rest interface, but you could just as easily serve up your http. The downside of this method is there is a bit more boilerplate needed for each file being served. 
&lt;3 Persona and &lt;3 Go. Thanks for blazing a trail!
GAE seems to be the best platform for Go. The angular-seed project is written with the expectation of Node. Go's templating and GAE operate differently enough that a modified seed was needed. I also wanted to include some of the non obvious stuff for GAE, such as a common code file and how to split your handlers across different packages.
&gt;GAE seems to be the best platform for Go. You mean for a managed environment like Go? I find it far too easy to cross compile and throw the binary on any old server, but I suppose it all depends on if you're tied into the GAE ecosystem. anyhow, thanks again for the code and the elaboration.
Comparing the time it takes to print the version is pretty lame.
Thanks, this is exactly the kind of example I'm looking for. The way you split out the handler `user.go` is how I'm doing it so far; that's encouraging. One question though, how/where are you importing your `/api` package into the app.go? In my app I am doing a side-effect only import of my handler (routes) package so that the `http.HandlerFunc()` can be registered by the `init()` functions in my handler files. import ( _ "path/to/my/app/routes" ) I don't see where your `app.go` or `common.go` files import the `/api` package so I'm not sure how the `user.go`'s `init()` func is ever called. Does GAE automatically load all packages, or am I missing something?
Generally, go is pretty relaxed on this front. Here's a work in progress, that generally reflects the way I like to organize our go web-apps: https://github.com/SupportLocal/TEDxMileHigh Working on it should be as simple as: * git clone https://github.com/SupportLocal/TEDxMileHigh.git * cp TEDxMileHigh.toml.example TEDxMileHigh.toml * $EDITOR TEDxMileHigh.toml # dial config in for your environment * bundle * rake develop * open http://localhost:9000 # assuming you stuck with :9000 in the config At this stage, you should be able to edit pretty much anything, and watch your browser load the changes. And yes, the development environment has ruby dependencies. It simply has mature tools for automating a development environment. Go binaries and static assets are the only thing that make it into production.
Haha, thanks, but that's what it's comparable at the moment...so far only creating pull request is done which is not good for comparison hence it involves multiple steps (opening a editor etc.). I am implementing getting the ci-status which will be a good comparison target. Comparing the time it takes to print the version looks lame but it proves that with the similar number of characters printed to the console, how long it takes for a Go implementation without a VM vesus a Ruby implementation with a VM 
Just realized -- I'm not doing anything useful with server side templates in this application yet. I'll clean that up over the next few days. I generally introduce some layout helpers, and stick to the template/html package.
You are correct, GAE is doing this automatically. It builds every package in the /app directory and calls init on all of them. You'll also notice there is no "main" package spelled out, this doesn't make sense outside of GAE. You would need to create a main package that imports all of the route handlers and then calls some sort of initialization function. OR you can specify the routes in a centralized location and call the handlerFunction from your other packages. /u/levicook does something similar to this second option in his example code.
Yes, for managed hosting. I don't use GAE for anything business related though, so I can't speak to a cost for value when you start needing more bandwidth.
I'm not sure this is exactly how I'd lay out a web application today, but here's how my blog (written in go) is laid out: http://github.com/jmoiron/monet
Thanks a lot :) It took a lot of work to get it to look so simple!
What do you expect? 26ms seems pretty good to me.
How are you benchmarking? with http://golang.org/pkg/testing/#hdr-Benchmarks?
I compiled it and ran it on my 2011 MBP: ~/tmp&gt; time ./inv 10 sueteres so feitos de linho real 0m0.013s user 0m0.007s sys 0m0.006s 
There's a layer of view stuff in play now.
God, those comments are depressing..
Urgh, I opened the article just to see what you meant. The article is not great, but the comments make it a whole lot worse.
Eh, they're not that bad, this will make your eyes bleed: http://forums.thedailywtf.com/forums/t/27755.aspx
Interesting work. It's useful to note that the standard library's implementation is a doubly linked list. I've written my own [singly and doubly linked lists](https://github.com/billderose/linkedlists) that make use of unbuffered channels as semaphores. I chose to include a length variable in my lists and attempted to genericize the implementation using interface values as well. I'm curious as to why AddToHead() returns anything if it always returns true. Would it be more useful to return the added value? I've abstracted my own methods to make using the semaphore easier, but you get thread safety in return. Excited to see more!
You're absolutely right, AddToHead doesn't need to return anything. I'm hoping that with more experimentation and learning I will be able to use __interface__ as the data field of the node. Thanks for your comment much appreciated ! 
Yeah, I compiled it and hot this time: real 0m0.010s user 0m0.003s sys 0m0.002s
&gt; So basically, the way Go handles dependencies like headers is to hardcode a path to a github repo that has the header you want then download a local copy of that header so you can edit it independently of the repo author because all Go programmers are enlightened perfect angels and this could never cause dependency problems ever. Argh... &gt; Here's a short list: 1. A programming language should not require people to use a *commercial* website for a particular feature to work (and yes GitHub is a commercial website, it's not some fru-fru happy smiling dolphin gift from heaven-- they're in it to make money) 2. Even if you disagree with the above, you must agree it should not require people to use a single commercial website-- either you support *all* code hosting websites or *none* 3. Similarly, it should support either *all* source control systems or *none* 4. Repos can be deleted or made private without the main developer even noticing (since they are working off the cache) 5. (if you accept the tag idea:) tags can be deleted without the main developer even noticing (since they are working off the cache) Aaaaargh! What?! It's not tied to a site ffs, it just supports it!
I would have done: type LinkedList struct { head *node } func (ll *LinkedList) AddToHead(data int) { ll.head = &amp;node{data: data, next: ll.head} } You don't need to check for `nil`; it still works.
I would like to see a comparison between this and the articles about Java in Forbes and Fortunes in the late '90s. This isn't great, but I'd be shocked if the old articles weren't much, much worse.
For micro-applications like this, how much of the time is spent in reading the rather large binaries, setting up, and tearing down versus the actual core application logic? Do GC costs even get involved in this type of application? 
&gt;There are only two kinds of programming languages: those people always bitch about and those nobody uses. -- Bjarne Stroustrup (?)
The font for regular text and see through background aren't that enjoyable :(
You either like it or you don't. Just like every other language. People gotta bitch though.
is the code used in this presentation available online somewhere? EDIT: found it: https://code.google.com/p/go/source/browse/2013/advconc/realmain/realmain.go?repo=talks
Nice work! I have plans to build something with this exact same stack! What are you building?
A [Twitch TV](http://twitch.tv) client is my for fun project. http://live.awfulboots.com
I'd love to hear a little more about this too. I think that's one of the bits of friction keeping a number of people from jumping in. I realize I'm speaking for myself mostly but I'm sure I'm not alone.
I remember those. The Java hype was unbearably in-your-face. The people complaining about how Go is hyped have no idea what hype is.
[Here you go](http://readable.tastefulwords.com/) Scroll down, click "Setup", create the bookmarklet that provides the one-click CSS override of your dreams!
It worked for me. Wait til you see it with some context to judge. :)
Put on the glasses and check it out again.
It was presented at http://realtimeconf.eu. It fit their definition of realtime. The point was to show that realtime is, at its core, a concurrent problem, and how Go can help make that simple to work with.
Oooh, sorry. I didn't post it here, or I would've added some context. Realtime is a totally loaded term, but in the context I gave the talk in, it was the appropriate term.
Ah, that makes quite a difference.
[Hacker News discussion on layout and web sockets](https://news.ycombinator.com/item?id=5799022).
It takes that long because all you're measuring is your system, not the program. e.g. * the binary must be loaded from which depends on how fast your disc is and how much other processes are accessing it * you're writing to stdout which will slow things down. this program isn't write-heavy but I wanted to point it out so you are aware of it next time. Usually you'd pipe the output to `/dev/null` * you should actually measure the time the code itself takes: http://play.golang.org/p/uiAgQ2OHWv . I see this *mistake* with other languages and runtimes as well, e.g. someone measure the spead of Python by using `time python test.py` * ask yourself how much of that is essentially a constant overhead. tip: compile a `C` program that does nothing time that and you will observe that it will repeatably take an almost constant amount of time to run every time 
I get "panic: runtime error: index out of range" right away. Quite possibly related to the race conditions from /u/henryheikkinen Once you think you've fixed the race conditions, run with `go run -race` and you may find a few more :)
Nice! I'm currently writing my first Go package which will be a discogs API library that uses JSON too. This is definitely going to help me out, so thanks! First question: in jsonutil.go you say that Go assumes that the JSON is map[string]interface{}, but can't you form a struct with types to organize the data? For example, from [this](http://api.discogs.com/artists/1373) query I know that the profile key will always be a string, so I can make a struct: type Artist struct { Profile string } And then unmarshall the JSON response into that struct: //Query an artist. res, _ := http.Get("http://api.discogs.com/artists/1373") temp, _ := ioutil.ReadAll(res.Body) var artist Artist err := json.Unmarshal(temp, &amp;artist) fmt.Println(artist.Name) [Here's a full example](https://gist.github.com/dmikalova/5693142), is there any reason you didn't do it that way?
BTW, there is a file in the repo called jsonutils.go that makes it a lot easier to interact with JSON if you don't want to dump it into a specific Go struct (or if you interacting with an API where the object structure varies a lot).
Ah, cool. Yeah I'm currently wondering what to do with queries that return some fields blank.
Pretty sure you can make the fields pointers and if the JSON doesn't contain that field it will remain nil, otherwise it will allocate and assign the field automatically. Lets you have a dedicated go struct while easily dealing with omitted fields.
There are several reasons that I chose not to write it that way. I had started out with quite large structs describing the server side structure however most of the information was not in a form relevant to me - Instagram's API contains a lot of information in very varied data structures where only one standard one is really required. Secondly, consistency varies wildly. For example, in some places a User object will contain the field 'full_name' whereas elsewhere in other responses it will contain 'first_name' and 'last_name' so by putting it into a data structure myself I can ensure some consistency. Thirdly, I don't have to worry about empty values as much as I would otherwise - my utility returns defaults. On the other hand I am (relatively) new to Go, so I've probably ended up doing it in a slightly inefficient way.
Actually, your blog design is what sucks. Since you are *asking* for something you published to be read and given feedback on, you should have respect for a reader's time and make it actually legible. 
But if everyone knew realtime practices, and the focus would be realtime programming with Go, the target audience would want to know Go's ability to be used in realtime... correct? Therefore I am the target audience - because realtime people need a real reason to use a **forced** GC language that ensures they aren't having huge, non-deterministic pauses. Or using a big runtime behind the scenes which causes them -again- non-deterministic execution time and resource consumption. I'm not saying that your presentation was bad at all! It did show a lot about Go, I'm saying that your presentation wasn't quite aimed at the right people (I'm assuming that RealtimeConf EU was full of professionals in either soft or hard real time programming?). Realtime programmers (such as myself) would love new languages, but the barrier to entry isn't syntax or language features - it's much, much more that modern languages refuse to allow either completely deterministic or completely controlled environments. And that's what needs to be talked about in a presentation called "Realtime and Go". EDIT: Especially when Go has a very primitive and resources hungry stop-the-world GC with no changes coming in the foreseeable future. Or that it doesn't dynamically link at all. Or do dead code elimination (from what I can tell). Or make use of many optimizations because they'd rather it compile fast than run fast. Also, I'm assuming we're talking about real time applications. Not servers. Just because servers aren't exactly realtime in my book. Very, very soft realtime, if at all.
Check out the "fireside chat" from I/O. They talk about how 'go get' should only be used to give a package a first look, not as part of your production build process.
[For the lazy](http://www.youtube.com/watch?v=p9VUCp98ay4)
There're more benchmark available on the README page, more is coming: https://github.com/jingweno/gh/blob/master/README.md
What should one do to manage packages and versions in a production build process?
At the very least, make sure you're always using a known version (point to a particular SHA1 or git tag) -- that's if you're sure the repository will always be there. To be really safe, you probably want to make a copy of the repo so that you can still build your entire project from scratch even if their repo disappears or becomes inaccessible.
it sounds less than ideal to fork every dependency one wants to use. 
You can make a shallow clone because it's not that important to have the full history.
&gt; But if everyone knew realtime practices, and the focus would be realtime programming with Go, the target audience would want to know Go's ability to be used in realtime... correct? The focus was on realtime web development. The conference defined realtime as anything that helped get information to users faster--push notifications, websockets, Redis, etc. I understand it's a contentious and loose definition, and it may not be the term you would've used, but it was a convenient enough handle for the organisers to use to lump the community they were trying to attract together. Which, after all, was their goal. My talk was structured as a walkthrough on how to create a websocket server using Go, but my thesis was that realtime software (at least in the context we're using realtime in) is a concurrent problem by nature, and that Go's concurrency primitives make working on realtime software less painful than, e.g., Node's callbacks. Seeing as all my audience was familiar with websockets/push notifications/the other specific technologies used to achieve the realtime functionality we were discussing, I instead focused the talk on enough of an introduction to Go that it would pique the audience's interest and provide them a basic understanding of the language, while focusing on the gains made to clarity by using Go's primitives. The goal of the talk was to help people to see why I love writing Go so much, to try and spread my passion for the language. It's not an appropriate language for every task or every person, but I love it, and I wanted to share why, and the organizers were nice enough to give me a platform to do that from. Obviously, I didn't anticipate the slides would be put on Reddit without context, or I would've listed the presentation with some background and context in a webpage and linked to that (as I do on http://paddy.io/talks) So nope, you're not the target audience--the GC bothers you, you're talking about non-deterministic pauses, and completely controlled environments. None of that is relevant in the definition of "Realtime" the talk was made to address. The talk was given in a specific context, so I had no qualms about using a loaded term that has many different meanings ("realtime"), and didn't really see a problem with the title of the talk--in context. Out of context, of course, some issues come up. But nobody in Lyon expected me to talk about deterministic execution time or completely controlled environments; they expected to hear about websockets. So I'd say I achieved my goal there. Were I to give a talk to the audience you're referencing--the audience you'd be a part of... well, I wouldn't give that talk, because I'm totally unqualified to talk about it. But were I in a more mixed setting (a Go conference, or a general programming conference) I'd probably title the talk something like "The Realtime Web and Go". Or something.
You obviously want your own local copy of all your dependencies. It's no good knowing the version you want if the author pulls a _why and deletes all their code or just gets bored with a project and removes it after a few years. 
True, but managing it through a git repo for each dependency doesn't sound good to me. 
It would be nice to see some examples of how this differs from go fmt
It's totally different. It doesn't reformat code, for one. It just issues warnings about potentially bad style, like undocumented exported methods for example.
Thanks for the pointers! As mentioned in a previous comment, I'm quite new to Go so I haven't come across all the standards yet.
gofmt is syntax, golint is semantics and stuff that will probably require human intervention to fix.
No, it's probably because it was started by someone that happens to be on the team, but is not part of the official project, at least not yet. It may also be that that person uses git and Github whereas the official Go branch uses mercurial.
Anyone know how to make this work in Sublime Text?
Except this uses an organization, which it otherwise would not.
I do it and so far it's pretty painless...
&gt;If we were using an Object Oriented language like Python then we could &gt;just create a class to represent the node. But Go is a procedural language &gt;and it does not have classes. That's not completely precise ;) http://golang.org/doc/faq#Is_Go_an_object-oriented_language
I stand corrected. Thanks for the link to FAQ much appreciated. 
I think he means that it is hosted by the golang organization on github: https://github.com/golang
If you're referring to GoSublime, see https://github.com/DisposaBoy/GoSublime/blob/master/articles/golint.md
What's the alternative? I guess I don't really see the issue, you already have your code under version control (or so I think), so you just check in your dependencies. Most of the popular ones, hg, git, bzr, etc. are capable of importing from each other so you don't even need to be using git.
Except govet is for flagging programming errors. golint is for style. 
I think the person is.referring to golint integration into sublime text. PS thank you for GoSublime!
Something like bundler from ruby or maven from java
&gt;The package name should match the last element of the import path. that's a convention, it's not a requirement. One of the most used packages, mgo, does not do this; the final part is the version number. 
sweet! I wrote [one of these](https://github.com/jordanorelli/go-instagram) myself. Point of feedback: don't do that whole JSON thing you're doing, just bite the bullet and learn to use encoding/json properly. It's not really a matter of that being such an awful sin that it should be punished, but learning how to use encoding/json properly illuminates a good amount about how to write decent Go, and it will do most of the heavy lifting for you. Also, your error suppression is... going to cause a lot of silent failure. You definitely don't want to ignore the error [like that in api.DoRequest](https://github.com/programmingthomas/instago/blob/master/instago.go#L91); it'll bite you in the long run. Similarly, json.Unmarshal can fail; you ignore that [here](https://github.com/programmingthomas/instago/blob/master/instago.go#L100). `error` never appears in your code. Not... not once. `interface` only appears in your code when using `interface{}`. I would say that's... less than idiomatic. Like in your demos, what if the instagram API is down [here](https://github.com/programmingthomas/instago/blob/master/demos/userdemo.go#L23)? That totally happens, and needs to be handled gracefully. "I couldn't get users because something is broken" is very different from "there are no users for that query".
And how does that solve the issue for your users(developers)? keeping in mind that depending on a third party to store the required version isn't a reasonable option IMHO.
*Go
Looking forward to this being added to syntastic.
I was very happy to see that; I wish to see more of the language being hosted on GitHub. It'd make contributing and following its development easier.
You're reading a bit too far into it. Hosting golint on GitHub is mainly an experiment in a very different workflow. I do indeed have a preference for Git over Hg as teratomata mentioned, but that's a secondary effect. (I'm on the Go team, but this isn't part of the official Go tree.)
Yeah, that's a reasonable summary. The latest version of https://github.com/golang/lint/blob/master/README contrasts golint and govet.
GO implies it's an acronym, which it isn't. Don't use GO.
I know that "go get" supports git and hg, but does it support Maven-style dependencies? While working in Java-land, I've had a local Nexus repo into which all our dependencies (and their transitive dependencies) got proxied through automatically. It would be nice to have that same facility in Go.
Cool idea. Adding and removing event listeners does not appear to be threadsafe. just saying
Go-inception
Zeus is a language neutral programmer's editor/IDE for the Windows platform. This latest version includes some improvements for the Go language including support for the latest Go 1.1 version. NOTE: Zeus is shareware, runs natively on the Windows platform and runs on Linux using Wine. *Jussi Jumppanen* *Author: Zeus IDE* 
Also see [similar example](https://github.com/elazarl/goproxy/blob/master/examples/httpdump/httpdump.go)
Robert, Thanks for dogbag! It seems like it is very useful package.
Is this code doing the same thing as [Goagain](https://github.com/rcrowley/goagain)? If so, why not use Goagain?
for the lazy: /r/goplaybook
Sheesh.. I wonder why you can successfully load your *index.html* template file just fine, yet my similarly simple setup fails to load my *templates/main.html* template file --- [but fails only remotely at GAE / appspot.com, while it works fine locally with GAE SDK](https://groups.google.com/d/msg/google-appengine-go/dxRMYfKIqgM/rPu_-grTcksJ)! :D Anyway, thanks for posting this, it helped me grok just exactly how the yaml file and the .go source module with init() is supposed to work on GAE (as opposed to having the local package main I was used to).
Ok, I downloaded it and will take a look. Syntax highlight and running thetools is no problem. But code completion with the Dart analyzer is something else. There is a Dart plugin for WebStorm and Sublime Text 2 but not for Notepad++ which I use a lot. I've been collecting IDE and editor links for a year now and this is the first I'm, hearing of Zeus which is surprising to me. 
Comparing a staticly-linked, compiled, staticly-typed, general systems language with a scripted, dynamically interpreted, dynamic extension language focused [originally] on serving http requests? I mean, it's harder to pick a more apples-oranges comparison to do. I also don't like the comparison of PHP-syntax-as-templating, vs a library-package-as-templating. Come on, one is a library, one is not. If you wish to use a library, there are plenty of PHP libraries that provide elegant templating for PHP. It should be a "native extension?" Well, use the phalcon extension with [volt](http://docs.phalconphp.com/en/latest/reference/volt.html). It's possible to write bad code with any language; and sure, it can be argued that "it's easier" to do so with PHP. But if I'm reading comparisons, I want to see the best of a language vs the best of another. I want to see how *well* I can do something, not how *shittily*, because I really don't care about doing anything shittily in any language whatsoever. &gt; PHP will let you litter your source with unused variables and functions. Go will not. This is the kind of blatant generalisation of *worst of language A* vs *best of language B* that tells me a comparison is out to shit on something, rather than try to make a good comparison. PHP has namespaces, and object-oriented code that uses them will not "litter your source". Good PHP coders are separating concerns, modelling application data, and separating UI / view code and logic admirably. They're not, in any shape or form, writing spaghetti code. Don't point at PHP code from 6 years ago either, and say "Hah! look at that!", because A) you have no Go code from 6 years ago to compare it to and B) things have changed, and I'm writing code now, not in the past. In conclusion: a rather useless comparison, and badly done to boot. If I want a quick CMS site, I'll probably use something like Drupal ontop of PHP, which is far more mature and featureful than anything Go has to offer. If, on the other hand, I need a custom server to handle data communication for a super-popular game I'm going to write, then Go will definitely be on my shortlist of languages to use. Use the fucking tool for the job; PHP and Go have mostly completely disparate target audiences.
Uhhhh yes, I have indeed written Go before. It's the implication that this is practically a logical consequence of writing something in PHP. As PHP has included class autoloading for years, it's perfectly possible to automate the same process in PHP, if you feel the need. Also, since PHP isn't compiled in the first place, this particular comparison loses a lot of relevance. "Do you use go build? You monster, littering your file structure with compiled binaries. PHP always runs straight from source!" (yes, that is satire, and yes, it is intended to reflect the ignorance of the author in that it's ignored the existence of go run)
And I believe Go doesn't throw an error when you import fmt and don't use one of its methods. What's the fundamental difference that makes these situations different?
&gt; first I'm hearing of Zeus which is surprising to me The reality is Zeus has been around for many years, in fact decades. It was first created as a Windows replacement for the DOS based Brief editor: http://www.zeusedit.com/awards.html
I was talking about the methods (or member functions? Not exactly sure of proper jargon for Go) of fmt, not the module itself. Wtih autoloading, PHP won't load classes not used. It skips the need for listing imports in the first place. Is that a feature (removing the need for imports) which is pragmatic and minimalist, purportedly in the style of Go? Or is that an unacceptable source of compilation/execution slowdown, which systems programmers should know *as a matter of course* and reject in choosing a language? There's arguments both ways.
I'm planning on adding most of these soon and sorting out the JSON parsing so it is a bit simpler. I also plan to add pagination and error support soon but I quite like the simplicity of just being able to get an array, so I'll probably include the error optionally as well with requests.
you cannot declare variables in php, because it's utter fucking shit.
That error is caused by importing fmt and not using any functions/methods from the project. which is exactly what you said Go *didn't* do.
Here are some details on how to do the basic setup: http://www.zeusedit.com/zforum/viewtopic.php?t=6923
&gt; But code completion with the Dart analyzer is something else. I had a look into this and with a few more tweaks it is also possible to get some form of code completion to work. This is what I did: http://www.zeusedit.com/zforum/viewtopic.php?t=6924 With that tweak the *Goto declaration* and *Goto definition* menu items in the popup menu will also work.
Probably not the comparison I would have made or the parts of the language I would have compared -- but that's in part what made the post interesting to me. I appreciated the different point of view... clearly some thought went in to what was important to compare from the writer's perspective. Hearing what is important to him was interesting to me.
Excellent! I'll try it out tomorrow.
The problem I see with PHP--and this is coming from someone who has not programmed in it before--is that I hear that experienced PHPers do so and so, but it just sounds to me like they're fighting the language. It sounds like a many-headed beast that needs to be beheaded repeatedly before it can be ridden.
I don't get that impression at all, just that its use has evolved as time as passed.
&gt;It's possible to write bad code with any language; and sure, it can be argued that "it's easier" to do so with PHP. But if I'm reading comparisons, I want to see the best of a language vs the best of another. I want to see how well I can do something, not how shittily, because I really don't care about doing anything shittily in any language whatsoever. Ohh, no no no no no. That a language sets a lower bound on the level shittiness a developer is allowed to write is possibly the most important reason programming languages should exist. Because once in a while, every one of us writes shit and the easier your tools let that shit pass, so much faster you'll be swimming in it. 
Oh well, I guess you can speak for the experience of all experienced PHPers; I'm sorry, I wasn't aware.
Do you have screenshots?
&gt; What surprises me is that almost nobody complains about the lack of generics. Could it be, because everyone who did complain about generics didn't bother to continue using the language, and moved elsewhere? Sort of a selection bias.
Hehe, it's awesome to witness how open source actually works. Initial LLVM bindings were written by me, then axw forked it and continued improving/maintaining for his llgo work and now you see people do interesting things with it. Amazing. Sorry for being a little bit selfish in this comment, I know my part is very small, but still it's a part. :D
so that's what nsf stands for. Many thanks to you as well as axw.
Is there a backstory here that I'm not getting?
That's fucked up... So, what's the canonical Go-SDL package now?
You can use my fork if you want: https://github.com/fmota/Go-SDL You can also fork it yourself.
For a little more context,  (or 'atom symbol' or just 'atom') did not only have a lot of useful Github Go repos, he was also an active contributor to the core language and project as well. Looks like he has 53 commits that've made it into Go.
I think that the way he did it was beneficial to the community. This is an example of what happens when you rely on repositories that you do not control. It's something that's repeated again and again, but some people just need to learn the hard way. Aside from that silver lining, it's a bummer ...
https://github.com/neagix/Go-SDL This is a fork with some more current development to it, might be interesting
If atom wants to take a time out from the Internet, that is his right. If you're are put out by his decision please remember that open source is driven by sweat equity, so this is your cue to roll up your sleeves.
Excellent. I will try it out.
From what I gather he wanted to (temporarily?) cut himself off from the internet or at least 'wipe the slate clean' in terms of his internet presence as 'atom'. While I'm sad to see a Go contributor leave and remove his personal repositories, there's no reason to second-guess his choice.
Well if you are 'go get'-ing a repo you will end up with a local version which won't disappear just because the upstream version does. Also if you are dependent on say a github repo then why not fork it? In this case there are many forks of his SDL-bindings and likely his other github Go projects aswell.
Isn't golang-stable 1.1 on https://launchpad.net/~gophers/+archive/go ?
Which Ubuntu version are you using? It seems the version wasn't updated for maverick, natty and oneiric.
I've noticed the same, running Ubuntu 12.04. It shows the 1.1 package there, but I'm at 1.0.3 according to `go version`
Noice! Wir sollten uns zusammentun und eine Berlin Go User Group grnden.. oder gibs schon eine?
Ja, das ist eine Super Idee! Schreib mir doch mal eine Email. (fuz@fuz.su)
~~I'm on it!~~ Done.
You might like to join me on freenode (IRC). I'm in the channel #linuxworks my nick is FUZxxl.
The writer complains about Go failing miserably in the "safety" department because he doesn't check the errors? How is that fair? That isn't even safety, that's just shitty error-checking. &gt;These languages cannot distinguish between values and null at compile time. What about nil? The writer uses the language badly, doesn't know half of it and then complains that Go isn't up for the task? He made a list of languages and decided which one he wanted to use before denouncing all other choices. I'm a bit lazy at the moment so I don't want to analyze the article to point out every reason as to why he's wrong, but the author really needs to avoid benchmarking code if he's not going to do it properly.
&lt;conspiracy&gt; is Edward Snowden&lt;/conspiracy&gt;
The author expects portability for dynamically linked binaries so I'd take his benchmarks with a grain of salt.
&gt; The writer complains about Go failing miserably in the "safety" department because he doesn't check the errors? How is that fair? That isn't even safety, that's just shitty error-checking. His reasoning, which seems understandable, is thus: &gt; My experience is that programmers usually do the simplest thing that seems to work, so I prefer a language where the simplest thing is usually the safe thing too. &gt; [...] &gt; Maybe Go programmers are better. But I can't help but notice many instances of incorrect error handing in the examples on Go's "Effective Go" page (intended as a show-case of well-written Go). Note the calls to "fmt.Printf", with the errors ignored. Or, the "defer dst.Close()" in http://golang.org/doc/articles/defer_panic_recover.html - these mistakes are too easy to make. &gt; 0install is more than 20,000 lines of code. Can we write 20,000 lines of production Go code better than the Go authors can write their tutorial examples? You may disagree, but that doesn't seem specious. &gt; What about nil? nil is null, it's not detected at compile-time, Go will not tell you that a pointer may be null (nil) and that you have to check it. Neither will Python or C#. The rest will[0]. &gt; He made a list of languages and decided which one he wanted to use before denouncing all other choices. That really isn't the feeling I got from the article. If anything, it looked like he was very interested in ATS yet ATS ended up in the bottom half of the pile. [0] to an extent, if you're using pattern-matching on a `Maybe` (which you probably should not, better to use combinators) GHC will need `-fwarn-incomplete-patterns` (which is included in both `-W` and `-Wall`). On the other hand, Haskell will still require that you explicitly unpack the value out of the maybe so you'll likely realize you should check for `Nothing` (or use the right function for whatever it is you need to do).
Author is clearly an idiot. For instance, calculating the python file as "0.18kb" but not adding on the several 10s of MB of interpreter needed to run it.
&gt;Go does not prevent unsafe communication between threads (e.g. via shared variables). an author that makes a statement like this clearly has not spent much time with the language. edit: s/statement/criticism would have probably been better. The statement itself isn't a false statement, but it is a weak criticism that shows a lack of understanding of Go's concurrency model.
Not sure why, as far as I know the author is correct: Go won't warn (let alone stop) you if you share a pointer to a mutable struct across goroutines, whether by design or mistake. (and you'll note the author did not dock points for this, merely noted it in passing) Could you explain why you think the author is wrong?
This is a good point, and not made clear in the post. There are three ways you might be running 0install code: 1. A package from your distribution. Dynamic linking is useful and handled by the distribution's package manager. 2. Binaries installed manually from 0install.net initially. These would most likely need to be linked statically, except for very common libraries (e.g. glibc). 3. As a library downloaded by (a different version of) 0install itself, with 0install handling the dependencies. Case 3 is where portable dynamically linked binaries are possible and useful.
Im pretty sure that was done to keep the examples compact, and that this was stated in the article.
Nope it doesnt. Go will let you hang yourself, but it gives you all of the tools to avoid it and detect most cases where youve made a mistake.
&gt; Im pretty sure that was done to keep the examples compact What was?
Are you contending that they cared about binary size due to *disk* constraints? That's preposterous. The only reason to care about binary size is for memory (RAM) constraints, and in that case, they do need to account for the resident size of the Python interpreter as well as the data structures representing the parsed bytecode of that 0.18kb file (which cannot be shared between processes, fwiw).
They seem to be looking at both, and they do account for python's interpreter in the text, but not in the graphic. It does not strike me as the most convincing part of the article, though.
of course Go will let you hang yourself. A rope that you can't hang yourself with is scarcely a rope at all.
A mitigating feature of Go is that nil references are sometimes completely valid objects in their own right. And if you or the library author did the necessary work then calling a method on a nil reference doesn't have to be a panic. This of course assumes that they/you did the work but it's good to know that nil doesn't have to cause a panic every time. Also nil is only possible for reference types so if you are using a value it's a total non-issue.
ROFL. Most non-sense language comparison ever.
This is an interest case study of someone looking at a number of languages for a task, but I think his method of assigning points is extremely subjective and non-sensical. First, he just adds up all the points for each case, thereby equating "Ease of Coding" with a questionable diagnostic test "Environment Variable". Second, his score assignment seems odd. For example, in scoring async code support, he gives OCaml a 5/5 because it has a LWT package that is "untested, but looks good" and then gives Go 5/5 for its language-supported concurrency support. Ridiculous. Using this criteria, he should look at each language and see if there's any ad-hoc, user-created package that solves one of his issue and that should be sufficient to give it 5/5. 
&gt; The statement itself isn't a false statement, but it is a weak criticism that shows a lack of understanding of Go's concurrency model. Or it shows that they understand it (witness the true statement), and that they have determined it wasn't fit for their purpose (being among other, at least minimally idiot-proof). 
&gt; What about nil? A.K.A The Billion Dollar Mistake, by the creator of null references himself: http://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare
given [this thread](http://roscidus.com/blog/blog/2013/06/09/choosing-a-python-replacement-for-0install/#comment-925154531), wherein the author confounds [data hiding](http://en.wikipedia.org/wiki/Information_hiding) with [immutability](http://en.wikipedia.org/wiki/Immutable_object), I'm not really convinced that it is the case that the author is a wizened, sage gopher who has since defected. also from the article: &gt;despite my plan to add error handling only if the compiler told me to that's just... not at all how you do it. &gt;Next, what does each of the sample programs do if the environment variable isnt set? The program should abort with an error message when it tries to read the environment variable. it says [right in the documentation](http://golang.org/pkg/os/#Getenv) that os.Getenv "returns the value, which will be empty if the variable is not present". A missing environment variable is not an exceptional situation; that's a core use case. Go is not without its flaws, and certainly one could level criticisms against it, but I don't find this line of argument to be particularly compelling. The argument is basically "concurrency doesn't work in Go the same way it works in other languages", which is by design, and "Go doesn't have exceptions", which is also by design. These specific design decisions are, in effect, dragged through the mud as if they are mistakes, rather than being described as what they are: an opinion on language design that differs from the author's.
unfortunately the dialog about Go on the internet has a lot of misinformation and FUD. I fully expect the downvotes, since there are significantly more people that do *not* understand how to use Go than there are people that *do* know how to use Go. I will never be silent for fear of downvotes.
That is true of every language with null, including C.
That error handling (in Effective Go or Defer, Panic, and Recover) is not incorrect. It's completely normal to ignore errors in a few circumstances, such as fmt.Printf or f.Close (f is an os.File). For example, with a file, you try to close it -- if that fails, there's nothing else to do (and you usually want to continue execution). In these cases, if you really do want to handle the error, you are free to do so. But most of the time you just ignore it. In most other languages, errors printing to stdout or closing a file will either be silent or crash with an exception. Either might be incorrect for some particular circumstance.
For this particular function, I would think the [`testing/quick`](http://golang.org/pkg/testing/quick/) package would be a great way to test it. Something like func TestFib(t *testing.T) { f := func(x int) bool { return Fib(x) + Fib(x+1) == Fib(x+2) } if err := quick.Check(f, nil); err != nil { t.Error(err) } } Granted, this test is almost identical to the implementation (which is always a bad sign) but if (for some reason) you needed to calculate Fibonacci numbers in production, you'd probably replace Fib with a more clever implementation, but keep the same test in order to ensure that it still gave correct results. Okay, I know `Fib` was just an example. I just think that Quickcheck is super cool and I'm really happy that idea made its way into the Go standard library.
I'd be curious what the advantages/differences are over the [existing implementations](http://godoc.org/code.google.com/p/go.net/websocket). The API and approach seem very similar.
&gt; The lack of error handling Then you're wrong. He said quite clearly that he only added explicit error handling where the compiler or runtime would ask for it. And the ATS example is downright huge, even if partially cut down.
&gt; his method of assigning points is extremely subjective You don't say?
The thing that immediately stood out to me is that clients are done totally differently. Existing API client is just a ReadWriteCloser and you have to manage things yourself. I actually wrote a websockets client last night. Wish I'd seen this then. Edit: Oh, no. That's a JS client, too. Dammit.
&gt;Another core use case is that the variable is present but empty. Writing a program that treats a nonexistant environment variable and an empty string environment variable differently is needlessly obtuse. Yes, those *are* different things to a machine. It is "correct" in an extremely mechanical, robotic sense, completely divorced from humanity. In reality, depending on this distinction means you are writing programs that are extremely unfriendly to users. I'm not saying you're empirically wrong; I'm saying that depending on those features leads to bad, unusable programs. If you're going to make an environment variable required, then actually make it required. To allow an empty string to pass an existence test is broken validation. $: unset FOO $: echo $FOO $: test $FOO; echo $? 1 $: if [ -z "$FOO" ]; then echo "foo is empty"; else echo "foo is non-empty"; fi; foo is empty $: echo ${FOO?"foo is not set"} -bash: FOO: foo is not set $: echo ${FOO:?"foo is DEFINITELY not set"} -bash: FOO: foo is DEFINITELY not set $: export FOO= $: echo $FOO $: test $FOO; echo $? 1 $: if [ -z "$FOO" ]; then echo "foo is empty"; else echo "foo is non-empty"; fi; foo is empty $: echo ${FOO?"foo is not set"} $: echo ${FOO:?"foo is DEFINITELY not set"} -bash: FOO: foo is DEFINITELY not set now, of all these, the only one that distinguishes nonexistant from empty string is parameter expansion. Everywhere else, the distinction doesn't matter. Most sane programs *do* ignore the difference, and I'd argue that the vast majority of users would agree that this behavior is correct. Using test and shell tests is how normal human beings actually use programs. Using parameter expansion to differentiate nonexistant and empty environment variables should not be considered normal; it is an amusing parlor trick, but it is not something you should expect of your users. The only reason that computer programs exist is to service humans. If you want to sit around and wank off all day to the distinction between empty and nonexistant environment variables, you have been blinded by your own pedantry. A programmer *should* be pedantic, but only up to some limit. In the world of programming, pedantry is a virtue, but virtue itself turns vice, being misapplied. Anyway, [syscall.Getenv](http://golang.org/pkg/syscall/#Getenv) will let you differentiate between an existing but empty environment variable and a nonexistant environment variable, so the whole thing is a moot point.
can't wait to dig into this...
Agreed. I went through the slides from 2011, but the project could definitely benefit from some examples in the readme file on github. I've been wanting a bit of Go programming on the side, and this seems like something I could get behind.. Hoping to take a look later in the week to figure out precisely what this thing can already do and where it is heading..
http://camlistore.org/docs/uses
Great. Now, that I finally have my file server re-built, I can finally get started using Camlistore seriously for my photos. I'm really excited to use the three-legged sync! :-)
I haven't seen any, but I'll keep an eye out. I think it's inspired by the Haskell library [QuickCheck](http://www.haskell.org/haskellwiki/Introduction_to_QuickCheck) so Google around for articles/posts about that (there's a bunch of links at the bottom of that link too). Not sure if I can explain it that well, but the idea is that you can test *properties* of a function instead of just specific inputs/outputs. If you want to say "no matter what input this function receives, the output should always be an even number" or "the return value of this function should always be a slice with a length of at least 2" you write a function to express that property. Then it'll generate random values to feed into your function, and alert you if it finds an input value where the property isn't true. So it's likely to find corner cases that you didn't test for explicitly (because you didn't think of them). Is there a way to search all the open-source Go code out there and see who's importing "`testing/quick`"? I'd be interested in seeing how well it's caught on among Go programmers.
Why limit the numbers of listeners ?
[Announcement blog post](http://pauladamsmith.com/blog/2013/06/gogeos.html).
I struggled with this initially as well. Short of reading the docs, no, I don't believe you can "auto-discover" things like this. You have to accept that this is a "feature" of the language - you don't have to create a type hierarchy and you can extract out interfaces *after* you notice that certain behavior can be described by one, without breaking any existing code. Having said that, I do have a crazy idea....using go/ast, loop through the source, parsing out exported interfaces and types, then create a go program that will attempt to do a type assertion on an instance of each type to each interface - full permutation - and watch for compiler errors....
It's a trade-off. Having implicit interfaces allows to retro-fit things, meaning you can define interfaces based on implementations as well and not only implement existing interfaces, which is quite handy once you understand the potential. That said, there is not way to get a list of some interface implementations. But since Go incentives the definition os small interfaces, usually one method, its quite easy to see the interface definition (i.e. Read(p []byte) (n int, err error)). At first, it might be a little difficult but soon you see that it's very consistent and any I/O stuff, does implement io interfaces, even non std packages. If they don't, it probably a poor-designed 3rd party pkg.
It shouldn't be hard to create something like that. Sounds like a fun weekend proj.
Looks interesting. Nice work.
Remeber go is much younger and there is definitely a lot that can be improved in the tooling. For example, as you wrongly mentioned, now go1.1 now does link parameters :) http://tip.golang.org/pkg/net/http/#HandlerFunc.ServeHTTP
The reflect package has some functions that tell you if a struct implements an interface or not. I wonder if runtime checking of this is possible.
You can do it in runtime with the Implements method but you can't use that to parse all pkgs unless you statically import and compile all of them. A better approach would be to use go/ast (http://tip.golang.org/pkg/go/ast/) to parse the files and check. But since you would have to do that for each combination of custom type and interface, it would be expensive. You probably could make it work if you find a good data structure to cache the interfaces and quickly compare types against it though.
There's GoQT and GoGL, however I can't vet for their quality and I know that GoQT isn't complete.
I've just started using Go, and I am following the algorithms track to learn more. Probably the best feature is that after your submission passes, you can look at what others have done. I've used that multiple times to learn different features and functions of the language as well as better ways to format my code.
Couldn't resist, what with the thread title -- had to repost here: http://askgolang.com/thread/115
Sorry, Mathieu and I were rushing out the release before I had to leave Grenoble, so we didn't get all the docs written. I wrote a bunch more on the plane: http://camlistore.org/ is updated with links and there's now http://camlistore.org/docs/overview too. Blog posts and videos forthcoming.
Your example is very strange. You start with no intention and just follow the types. This isn't how anyone writes software, it doesn't make any sense. You would start with an intention and then figure out how to write a program to do that. Your intention here is to buffer the request for replay later, so the question is 'what interface does the request and the buffer agree on?' and the answer is 'io.Writer'. You would have to do the same thing in Java and any other language.
Really nice, thanks for publishing this. It would be cool to see this in pure Go one day, but this will do nicely in the meantime.
all code in the standard library is run through fmt, which means you can reliably regex search the code. egrep -rn 'func \(.*Read\(.*\[\]byte\) \(.*int,.*error\) {' /usr/local/go/src/pkg pretty shitty regex, but it works and doesn't take much thought. edit: I love how I get downvoted despite being the only person that presented a runnable solution. Nice!
Such a tool existed once - at least. Something like-minded is mentioned by Brad Fitz... I really swear I remember a web interface that provided this online but can't re-find it... https://groups.google.com/d/msg/golang-nuts/xIo5ihS0fHc/1olpYf5mXqcJ https://codereview.appspot.com/5552051 (Edit: see also this conversation .. http://www.swageroo.com/wordpress/googles-go-and-implicit-interface-declaration/ )
Assuming "error-free" is a property of quality code, Go is in the former category not the latter. And you're trying to find excuses for it. 
An observation of your actions is not "going personal". 
Oh, not bad. I'm going to investigate that.
GoGL works pretty well, if not perfectly (this one: https://github.com/go-gl). I was more wondering whether any Go bindings for existing GUI libraries included the OpenGL widgets of these libraries.
And... I just finished manually deploying 1.1 on some workstations. That'll teach me not to automate the process. :-)
Congrats to the Go team! I love the work you guys are doing, keep it up! I've chosen Go + App Engine for my upcoming cloud app. The Go App Engine docs are (were?) incomplete, I'm not using a nice IDE or a debugger, yet somehow I'm more productive and having more fun than I ever thought I would. Thanks for the hard work!
Having worked in the geospatial world for a long time I have a beautiful dream that one way we will have a spatial library that: 1. Works with both cartesian and geoid spatial contexts. 2. Works with 2D, 3D, and M shapes and coordinates. 3. Provides a C API so that it can be integrated into any programming language (like GEOS). Go seems like one possible candidate for such a dream as it's concurrency model lends itself to many spatial operations that can be parallelized. However, I'm not sure if Go would be considered "low level" enough for this, and it seems as though Go providing a C interface for other programming languages is an awkward proposition (correct me if I'm wrong on this). Current competitors to this would be spatial4j (java) and GEOS (C++), but they all fall short in some of the points listed above.
[Ouch!](https://code.google.com/p/go/source/detail?r=b88e87d911e1bbe2531b9097a0d69a6752c2e204&amp;name=release-branch.go1.1) I'd say, if you've upgraded to 1.1, definitely upgrade again to 1.1.1.
Even without a debugger it seems to just work with GDB. (Although I haven't tried threads)
GDB is a debugger
This is cool. But this doesn't work when running with GOMAXPROCS&gt;1 since you are using a single global GEOS handle. 
&gt; crypto/blowfish: invalid key size 2 I tried a password of length 1. Is that error supposed to be there? I'm mostly interested because it looks like an info-leak
Make sure that your path includes the Go bin directory; from those settings, it looks like it should be in /usr/local/go/bin. So make sure your PATH is set accordingly.
[You don't need to set GOROOT, really](http://dave.cheney.net/2013/06/14/you-dont-need-to-set-goroot-really). I'd unset all of those variables but GOPATH and try again.
I saw the bazil.org guy's talk at the recent Go meetup in LA. I think he said that rsc isn't working on his anymore, so the bazil.org one should be considered more or less the "official" one.
No, input from new users regularly appears at mailing lists and on irc. Often no research is done first and questions and discussions are repeated. They are definitely both present and vocal, no selection bias there. 
* `unset GOBIN` * inspect `env | grep ^GO`, ideally, only `$GOPATH` should be set * `$GOPATH` is set to `/Users/phpnoob/gogo` but in your message you say the working dir is `/phpnoob/gogo` . is that a typo? if not, what you mean by `working dir` * most importantly: what do you mean when you say it doesn't work and why do you think it's a `$GOPATH` issue
How have you been setting your environmental variables? Presumably you modified your ~/.bashrc or ~/.bash_profile at some point. What's in them now?
I think it's pretty standard practice for folks distributing binaries on unix to have the main entry point to their application be a small shell script which detects library and configuration paths and sets environment variables or command line arguments to pass them into the main exectuable, so the end user doesn't have to worry about it. For example, on my ubuntu system, /usr/bin/firefox is a shell script which executes /usr/lib/firefox/firefox which is the main executable. So anyways, you can keep doing pretty much as you are with your current solution, and rely on a script for setting up LD_LIBRARY_PATH relative to where it's been unpacked.
Why can't you just compile libglfw as a static library? At worst, if the regular Go compiler won't link with it, gccgo and ld should definitely be able to.
I'm not sure how I would go about doing this to be honest, I've never worked with gccgo before. Also as [part of the go-gl/glfw documentation](https://github.com/go-gl/glfw#dependencies), it states that libglfw should be installed as a shared library &gt; Important: libglfw builds/installs itself as a static library by default. This does not work well with go. Eventhough the building of this package may succeed without problems, any application you use it in will likely throw up a range of symbol lookup errors. **It is therefor strongly recommended to build libglfw as a SHARED library instead.** See the libglfw README and makefiles on how to do this.
This is a question that you might get better answers on the official mailing list. https://groups.google.com/forum/?fromgroups#!forum/golang-nuts Cheers
For Windows, it's as easy as distributing glfw.dll alongside your binary .exe inside the same directory. Pretty awesome deployment model. So if you have both a 32-bit and a 64-bit .exe build, be sure to put the proper glfw.dll alongside. For other OS-es, welcome to the joys of package bundling and dependency scripting. Not too knowledable in this area, if it was me and the app isn't "mainstream-audience commercial", I'd tell those Unix-ers (incl OSX-ers) to "apt-get or homebrew or whathaveyou it themselves"..
Huh? I think you're missing the parent's point. Languages like Java and C++ don't support calling a method on a null object. Sure, you can pass a null as a function argument, but it can't be the method receiver in those languages.
I installed Go 1.1.1 using the OSX package installer, but did not remove any past settings. Do you think I should delete and re-install?
Here is my ~/.bash_profile export PATH=/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin:/usr/local/git/bin:/usr/local/go/bin:/usr/local/mysql/bin I have no ~/.bashrc file.
1. I unset GOBIN. 2. Here is what I get from env | grep ^GO: GOPATH=/Users/phpnoob/gogo 3. The directory I would work in (before updating) is Users/phpnoob/gogo. That used to work. Meaning, that is where I would compile my Go programs and go get packages. 4. Here is the response I get when I try to go get a package: package github.com/go-sql-driver/mysql: cannot download, $GOPATH not set. For more details see: go help gopath I seem to be working in the wrong dir, but I'm lost. 
I fixed the issue. Thank you for your help. (:
I fixed the issue. Thank you for your help. (:
I fixed the issue. Thank you for your help. (:
I fixed the issue. Thank you for your help. (:
I fixed the issue. Thank you for your help. (:
Go doesn't support object methods, instead it is a normal method which means instead of getting an error at the call from null the error is even further down in the code when it is being used. This is similar to C, but it doesn't have syntactic sugar to allow a.b() and requires b(a).
Package your application with the package manager used by your target distribution. You can specify the dependencies this way.
Maybe a stupid question; but why is this only for Linux?
[fsnotify](https://github.com/howeyc/fsnotify)
This sounds cool and all... But either those instructions to run it are not correct or I am not a smart man. I'm thinking the latter because I just can't figure out how to start it to test out the web IDE part.
That README is pre-1.1. Go 1.1 enabled the use of the host linker (gcc) to link the final executable, which supports linking static libraries just fine.
Did you run the 'go get' and 'golab -http' commands mentioned in the README? (I haven't tried them yet; perhaps there is something missing in the instructions) (edit: you need go &gt;= v1.1)
I was planning on creating something like this to teach myself go. Looks like I'll have to contribute to this one instead :) I was going to skip operational transform, though - I was thinking of preventing users from making edits within 2 lines of another's cursor. Or using differential synchronization, since its author says it is more robust.
The names of the types in the standard library tell you what interface they implement. They all are XXXXer. The w *http.ResponseWriter is a pointer to something that implements a ResponseWriter interface, the io.Writer is a interface to something that has a Write method and so on. I'm new to Go also but after a project or two it begins to feel obvious. You should also respect the same naming convention yourself
&gt; After a few painful instances of searching for things like go array literals and go repl I got into the habit of sticking with Golang; and so will this diary. Those searches actually work just fine. Google search is pretty good. "golang" is a search keyword, *not* the name of the language, and it's a little annoying to read a whole post where the language is referenced by this name. &gt; The second big gripe is that Golang has neither an IDE nor a REPL. I dont think, in 2013, that I should insult my readers intelligence by explaining why these are good things for a programming language to have. I don't use an IDE for any language. I used to write Java, which at the time I found easier with an IDE, but since then I've only used better languages and found that a good text editor + unix tools make a far better development environment. A REPL would, of course, be nice. There are several attempts out there (although last time I tried them, they all had significant shortcomings). &gt; Golang isnt object-oriented. So while nothing is an object, anything can be the target of a method. I would argue (and the Go authors and community usually say) that it *is* very much object-oriented (and the fact that the author refers to methods should be some kind of clue). It's just not class- or hierarchy-oriented. switch { case value &lt; 0.0: signum[i] = -1 case value == 0.0: signum[i] = 0 case value &gt; 0.0: signum[i] = 1 } &gt; Isnt that a nice compact switch idiom? Definitely C-done-right. Except that gofmt is going to split that onto multiple lines... &gt; Yeah, its statically typed, so you have casting. Im not sure why it was a good idea to invent a new syntax, but this one seems OK. It's not casting, and the syntax is not the same because...it's not casting. It's a type conversion. &gt; See, because you named the return values in the declaration, you dont need to mention them explicitly here. Just a personal opinion, but I think that not naming return variables is actually pretty mistake-prone and I never do it. I think I've heard a few of the Go authors also express the opinion that this was a bad idea (too lazy to dig up the references atm).
&gt; Just a personal opinion, but I think that not naming return variables is actually pretty mistake-prone and I never do it. I think I've heard a few of the Go authors also express the opinion that this was a bad idea (too lazy to dig up the references atm). In the fireside chat they talk about this, can't remember at what point: http://www.youtube.com/watch?v=p9VUCp98ay4 I quite like being able to just use "return" if I've named the return variables in the function signature, but maybe that's because I haven't written enough go to be bitten by this.
I was playing with load balancers this past weekend. Some Go code that came out of it. https://github.com/darkhelmet/balance
Tim Bray is a pretty smart guy, but this article is pretty shallow. The things he complains about a superficial, and the things he praises (implied returns) are mostly non-issues or even misfeatures! I'd be much more interested to hear what he has to say in a couple months. Re: No REPL, I just experiment with play.golang.org.
Yeah, that's a nice way to sum it up. I couldn't quite figure out how to phrase it concisely, so I just ticked off a few points that didn't sit well.
If I'm reading your source right, you can only save the title and artist right? But that can easily be extended by just writing out more tags?
Yep! It does only save the title and artist, but you can easily extend that by looking at the header file and extending it. I really only extended it that far for a simple project I was working on, but if you'd like I can work on adding further support.
This is Rob Pike's "Go Concurrency Patterns" talk from Google I/O 2012, in French.
This is excellent work, Thanks for the write up!
Mm, good catch. I opened a [bug](https://github.com/paulsmith/gogeos/issues/5).
Very cool. Keep it up please, this looks like a good resource for learning Go. Thanks ;)
Nice! It's worth noting that Dmitry Vyukov is a big contributor to Go, doing great work on the runtime, namely the garbage collector and scheduler.
Probably not too much. I do think Go is beginning to approach critical mass though. In the last 3-4 months I've heard about it non-stop from random places. One thing it seems it's under-utilezed for is game engines. I've worked in C++ on engines for quite some time, and Go naturally solves a lot of the problems you encounter. I'm in the process of creating a generalized high performance 3d engine for go, hopefully that can help open more doors for the language.
And I wonder if someone uses Go (except Google of course). Great idea, but they don't even have a port for Android AFAIK
Android is not the target platform for Go, it's system programming for servers and scalable systems. Google uses it and also provides it as platform in their App Engine. Another example of Go software is Juju by Ubuntu, see http://juju.ubuntu.com, a software for the provisioning and configuration of clouds.
[His website](http://www.1024cores.net/) is also a pretty neat resource: &gt; My name is Dmitry Vyukov, and I'm going to share here various information about lockfree, waitfree, obstructionfree synchronization algorithms and data structures, scalability-oriented architecture, multicore/multiprocessor design patterns, high-performance computing, threading technologies and libraries (OpenMP, TBB, PPL), message-passing systems and related topics. &gt; I'm mostly interested in shared-memory system, so if you are looking for information about clusters, web-farms, distributed databases and the like, it's the wrong place. I am also not going to write about GPU-related things.
Here is a good list: http://go-lang.cat-v.org/organizations-using-go
Yes, I should have mentioned that. By the way, the original talk can be seen here: http://www.youtube.com/watch?v=f6kdp27TYZs
Oh, thanks! Great list. Clouds seem like a good fit. I know that Android is not the target platform for Go, however, it'd probably be the best way to get to the masses...
The GoUsers page on the go-wiki is a slightly more up-to-date resource. It's missing _what_ the various companies have done, but hey, it's a wiki, feel free to contribute. https://code.google.com/p/go-wiki/wiki/GoUsers
dvyukov is a man with beastly knowledge when it comes to all things parallel/lock-free/multi-threaded/concurrent/etc. His contributions to the runtime are *way* above my head but he's definitely a core Go runtime developer. For the longest time I actually thought he was a Google employee, just by the amount of contributed code to the project. [This reply](https://groups.google.com/d/msg/golang-nuts/oouY4JM5ea8/T6217B2fKrYJ) to someone's question on the "necessities of garbage collection" blew me away - a way to safely read/write values from/to a map from multiple goroutines without locking, using copy-on-write techniques instead. Just when I thought I had a good handle on Go concurrency too...
In addition to juju the ntp pool use a go based dns server. dotcloud have a go based active server checker. cloudflare has a significant investment in a go based tool for their platform and i know i've forgotten a few. http://go-lang.cat-v.org/organizations-using-go &lt;-- decent list
GC is an issue, but not a dealbreaker. Java has some nice engines/frameworks, like libgdx
Dupe.
Lines 60 &amp; 61 in the Go program really baffle me a great deal. Copying from src to dst and from dst to src in parallel with no locking --- *WHY*?
Could someone explain why GC causes real time performance issues?
Yeah, I got totally fucked by python's GC once when I embedded it as a scripting language in a c++ engine I was working on. My gameplay guy decided he wanted to do all the things in python, so when the GC hit it was devastating to our frame rate. I solved this simply by running the GC once per frame. This kind of works in the case of the GO engine I'm working on, but I'm also playing with manually managing memory pools to get some additional speed. EDIT: I'll make sure to post it on this subreddit once it's in a usable state :D
&gt; allocate a blob of memory and manage it yourself Funny thing is that that's how it was done in the past: allocate everything when you load a level (and I guess garbage collect at the end of it). I've also seen this technique advised for JavaScript games for the very same reason.
All the XNA games on XBox uses a GC (C#), aswell as the Mono C# MonoTouch/Mono for Android offerings. Judging by the 'language benchmarks game' Go is somewhat faster than Mono for mainly computational tasks, while somewhat slower for runtime oriented benchmarks. As such I'd wager that anything the aforementioned XNA / MonoTouch / MonoAndroid can do in terms of games, so can Go (as in performance). Garbage collection performance problems caused by pauses can be mitigated by minimizing or entirely omitting allocation during performance critical stages. So for games you'd want to avoid allocating and dereferencing lots of objects during actual gameplay. What Go lacks however, is a mature game oriented framework, which is not that surprising given that it's still quite young and also since it has been quite geared at web development. Hopefully we'll see something like pygame, lve, flashpunk, flixel etc, emerge for Go, meanwhile there's lots of Go bindings available for game development subsystems like sdl, allegro, glfw, sfml et al.
This is fixed in master.
I don't think I'd ever write code like that but I believe it's guaranteed to work by http://golang.org/pkg/net/#Conn . specifically &gt; Multiple goroutines may invoke methods on a Conn simultaneously. From a quick glance at the code, the locking is also being done
I've abandoned this for the time being, but seen this (not so) old project of mine? http://github.com/go3d/go-ngine Maybe it will interest you or save you some code snippets. All demos should be immediately runnable with *go run* once go-gl/glfw is installed. It has a number of neat features and largely custom allocators (still annoying GC times of around 1-3 ms so may not want to have realtime GC every frame or sec "in production") --- which might make the core package somewhat painful to read and grok. But all in all I'm still fond of this work, tho' I currently have no motivation in this space.
Well, than it is an instance of the common "I want to do A which I can archieve through B, but I don't know how to B, so how to do B?" where B is something really obscure. You have a point.
This is probably "The Go way" to solve this problem if this problem is defined as "How do I determine the exact numeric type inside a type switch?" Then yes, that would be the Go way. Since we have no *idea* what *actual* problem the dude is trying to solve, we cannot possibly provide a better solution, much less a better Go solution. 
In this case "A" is function overloading or implicit casting. Both of these were left out of the language for a reason (disambiguation). So bending the language to get similar behaviour is definitely not the "Go way".
I think this is not his A; this might be his B and he applied the principle twice to get his current question (C). The original question was probably: How can I make my interface more general?
And the answer to that question is "don't do that; that's not your package's problem."
blog.appscale.com with zero links back to appscale.com \&gt;_&lt; looks cool though!
The [XY Problem](http://www.perlmonks.org/?node_id=542341).
Yeah it's just a matter of when you do GC. My ambition was "all the time so no garbage ever piles up and it's always fast" but it doesn't work like that, as more memory is used, more time is taken by GC for more space to walk over and inspect, even if no garbage is detected. So instead, better to disable GC and then run it in all "Loading" or "Settings" or some such screens. Then there aren't any "issues" GC-wise
It supports the Python, Java, and Go Google App Engine platforms.
&gt; it *supports* so just to double-check, this *does* mean &gt; yes, a Go developer can re-use his existing `import "appengine"` clauses with *no* code changes whatsoever amirite? If so, that's pretty neat.
I like the idea, but it feels weird to be database/*sql if it does not support sql since all the api design was conceived based on the notion of sql, table and rows.
Agreed, might as well just use a JSON store and to work behind your CRUD operations. Wire in the DB later.
Agreed, this is exactly how the project got started. Then I thought, wait, why not put my simple json loads and saves behind a *pretend* "sql/driver"--makes prototyping apps a little more "realistic" --&gt; fewer code changes later on..
I just clicked on the giant "App Scale" logo on the left...
They changed it ;)
Just a pure curiosity. Why answer with text/plain like this https://github.com/mkaz/bongoapp/blob/master/app/bongo.go#L116 ?
It even looks incorrect (or maybe you were referring to that). `post`'s `{'OK'}` doesn't have leading apostrophe but `put`'s, `archive`'s and `update`'s have. (`'{'OK'}`) String constant somewhere would make it instantly clear whether that is intentional or not.
Just curious, why not have a live version that someone could click on just to check it out?
good suggestion, I'll need to setup a data cleanser but that would be useful
The handleConnection goroutine goes away (I wrote that copy method to ensure things get closed without any extra synchronization), and it needs to copy back and forth at the same time. If there's a different/better way to do it, I'm up for suggestions :)
Never write code like that, as in you have another way in mind, or...? Can you elaborate? I'm genuinely curious. Always trying to learn :)
gource is one of my favourite procrastination tools.
Garbage collection seems hard...
I don't think that is necessarily considered a bug, just a property of imprecise garbage collectors.
You are techincally correct - the best kind of correct. However I'd consider it a bug if the standard library triggers that unwanted situation too often.
+1 for the Futurama reference.
*Now* I get it! This is damn smart once the reasoning is known. In "production" you may want copy() to keep track of any errors resulting from io.Copy, but this is definitely a really neat pattern.
I meant that at first glance, the code looks buggy. That is, until you actually think about it. Just a couple weeks ago I saw some code that looked like it was simulating `ceil()` but it wasn't clear why, because the `ceil()` function exists in the particular stdlib. My conclusion was that the code was so *obviously* wrong, that it must be doing something I just don't understand.
Hey guys, Started learning go recently and I'm in love. I'm using it for a production-level app now. I was looking for a laptop sticker with the gopher mascot we all know and love, but couldn't find anything. So yesterday I made this site for anyone else who might be looking for them. Cheers!
These look great but $5 is pretty steep for the size sticker, even being die-cut. :\
An interesting post. I really appreaciate how much an emphasis the Go community puts on a rich understanding of the language
I work with the CodeEval team and wanted to let you know that CodeEval now supports the GO community and we'd love to invite everyone to join. CodeEval is a great place to compete against fellow developers as well as have fun solving challenges. Please let your friends know or tweet about it! 
Do all the profits go to you?
It's a decent sized sticker, high quality, with shipping and handling, and with all of the costs associated with setting up the site and doing the work of counting your stickers, putting it in an envelope, and sending it to you. Also, it's a cup of starbucks that will last on your laptop for at least 3 years. That's half a penny a day.
Wow, those bugs are horrifying. I could easily see myself writing that timer bug and being confused for a long while.
Updated to return json object on success and all api calls to return application/json content type