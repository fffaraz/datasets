Yes, that's correct.
This should have improved in the last couple of versions. The reason it doesn't work of of the box with very large files is that it slow down a few functions. Can you please let me know if this still happens and I'll be happy to report it and give you a workaround meanwhile? Thanks! 
Your proposal has been discussed before. The main reason it has been rejected is because of import path rewrites.
To be honest, I did not find vfsgen, perhaps my googlefoo not that mighty as I was hoping :/ Basically I searched something with * Support for http.FileSystem * Should also be easy to load HTML templates * No generated code to check in I really like the cleanup part of packr, it just works and is completely invisible. Next start of a project I will give a try with vfsgen :) 
It's a really nice package. But, trying to integrate it into gonum/plot, I can say it's too much filename oriented and not enough io.Reader/io.Writer oriented. I hope to be able to upstream a few PR fixing this little deficiency :)
Do people actually pay $120 dollars for something you can learn for free? I'm baffled
GoLand is a superset of WebStorm + support for Go. Support for the Go plugin in WebStorm has stopped a few months ago, much like there's no PHP support in WebStorm. I would advise you to use GoLand.
Awesome, thanks.
Why are they the best?
I miss that 'g' :(
acme editor!
Timing is everything and the intelij guys are way too late to the party. Why would somebody want to pay for this when you can use vscode for free? I am a former webstorm user.
I asked their sales team over e-mail. They said it won't.
I haven't seen any slowness, use it for all my coding and works great. Only time I have issues is when opening massive file's lol
No problem. It turns out I didn't even have packr listed under https://github.com/shurcooL/vfsgen#alternatives; I'll add it there now. It looks like a good solution, and there's definitely way more than one good project in this space. vfsgen should hit the first two bullet points really well. It was designed all around the http.FileSystem interface as its key abstraction. For loading HTTP templates, I made http.FileSystem-aware copies of html template loading functions at https://godoc.org/github.com/shurcooL/httpfs/html/vfstemplate. I'm not quire sure what you mean by 3rd bullet point, no generated code to check in? Don't you want the assets to be available as part of the final binary you create? I plan to rework the vfsgen README to cover high level usage and more usage tips at the top, rather than it being a very low level tool as it is now. Hopefully that'll help make the tool more accessible and helpful to more people.
So cool seeing stuff like this being done in Go!
Sweet thanks 
"You may not need a web framework if you design a small application for yourself, but if you’re going production then you definitely will need one, a good one." ?? My understanding is that one huge benefit of go is that you don't have to mess with a bunch extra add-ons to build "production quality" systems. I'm guessing there's a tiny, tiny fraction of go developers who'd agree with this opening assertion. Am I confused?
&gt;Don't you want the assets to be available as part of the final binary you create? Of course! But I have them already in my repository as the original assets. So the generated go code is redundant and does not contain any more information, just the same data in another format. Packr builds your binary, and removes everything generated afterwards, this is what I tried to say with "invisible"
I'm not so sure, the name GoLand isn't much better, but then most of the recommended names were terrible so I guess I don't mind. One thing I find annoying as well is not every update can be done in the IDE by simply clicking "update and restart", sometimes you have to re-download the whole thing again. They should really solve that, PyCharm has the same issue.
LOVE seeing the Acme text system in this!
Thanks for taking the time to critique! Useful suggestions, and the article is helpful as well, cheers
I see. The issue with that, as I understand, is that it makes your Go package no longer `go get`table. Other people can't just `go get` it and run the binary. They'd have to `go get`, potentially get additional tools needed for asset generation/processing/minification, then run `packr`, etc. I'm sure that's fine for many use cases though.
You are right, the trade-off is a hard dependency to packr at compile time... For tool or library development not the best option ;)
iirc the plug-in will not be updated for free licenses I believe the plug-in will still be good for paid versions of IDEA
usually updates fine for me. I only have to redownload when they change the name.
Are you trying to get hired by the core team or something?
Can you share the code? a gist maybe?
Yes, no problem. data:=[]byte(string(n)) f, err := os.OpenFile(filename, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 644) if err != nil { return err } n, err := f.Write(data) if err == nil &amp;&amp; n &lt; len(data) { err = io.ErrShortWrite } if err1 := f.Close(); err == nil { err = err1 } return err } Any feedback is appreciated
Interfaces don't "stack"; they have the the interface type, and the underlying type. When you pass `reflect.TypeOf` a value to examine, the value gets assigned to an argument of type `interface{}`. In this case, the underlying type of that value is `Y`.
You can, however, get an interface `reflect.Type`. The easiest way to do it is to pass it a pointer to an interface and then get the element type of the pointer type.
[removed]
It does it every time there is a major version update too, I've been using PyCharm for 3-4 years now so this is nothing new.
damn that sucks.
It also migrates your config over, over the years you build up multiple copies of config directories unless you delete them: .PyCharm20/ .PyCharm2016.1/ .PyCharm2016.2/ .PyCharm2016.3/ .PyCharm2017.1/ .PyCharm2017.2/ .PyCharm30/ .PyCharm40/ .PyCharm50/ .PyCharmCE2016.3/ Looks like I need to do a bit of a tidyup myself, ugh, these directories are really big sometimes too.
Nice! Started using this a few days, didn't realized it was done in Go.
Typed interface with value nil: https://play.golang.org/p/Wsy1rys527
I don't think you can os.CREATE that file. I don't know what the right flags are because I don't have a Mac, but play with those flags a bit.
I don't believe any person with a strong CS background would frequent the Go mailing list.
Sure, but I learned that trying to create mock with testify: type X interface {} func (m *mock) method() X { args := m.Called() return args.Get(0).(X) } var t X mock.On("method").Return(t); And I was surprise a little bit. I manage this, but still something not obvious.
[removed]
Your error looks like it's coming from write, not from open, but you don't add context from your error messages before returning them. I'd suggest doing that and posting a playground link or a gist with the full code you're using in Go and the working Python script.
[removed]
Everything in sysfs is exported in kernel space, the /sys/class directory is going to be a symlink to /sys/devices which are all owned by root. The devices that support writes will be root in all cases I can think of. So I would add the script to your /etc/sudoers for your user and alias it in your bash/zsh/whatever if it's more convenient. The only flag you want to provide is os.O_WRONLY and nothing else. Have fun.
Whats wrong with: echo "data" &gt; /sys/class/backlight/intel_backlight/brightness You can write this in go or any other language, but why?
It is probably done conditionally, perhaps it reads values first and does smoothing or something which wouldn't be very fun in sh. Regardless "why not" is a question of similar merit though.
[removed]
you are absolutely right. Still, my bash script skill's are non-existent and i didn't want to call the command from go. But... maybe this time bash script makes more sense 
Sorry for the delay - didn't see this message! It's trivial to implement a new API... Take a look at the httpworker package: https://github.com/dave/blast/blob/master/httpworker/httpworker.go ... it just has a "Send" method, but you can also add "Start" and "Stop" methods if the worker needs setup/teardown functionality. You can create a command that includes your new protocol plugin by copying main.go, and adding your worker type here: https://github.com/dave/blast/blob/master/main.go#L32
Most of those pseudofiles give you an `EINVAL` ("invalid argument") error if the data you give them isn't in the format they expect.
Just use https://golang.org/pkg/html/template/ ... It is really good. 
You're probably not sending a newline, and it probably wants one. As /u/tv64738 says, the handlers for the pseudo-files in /sys, /proc, etc. can respond with anything they like to a write op, and they will usually error EINVAL if the data isn't in the format they expect.
Since you are coming from PHP, there is a golang port for Twig: https://github.com/tyler-sommer/stick Twig is one of the better PHP template engines: https://twig.symfony.com
Yeah, I'm not sure if the spec is completely explicit about this (I thought it was, but I can't find it now), but the section on comparison does say that two interfaces compare equal if both contain the value `nil`, so the *sensible* extension of this is that there's only one representation of a `nil` interface, with no particular type.
I've been using beego which uses it's own customized/tweaked engine, but first use the default, html/template package. It's what most frameworks are based around and it's useful to learn.
I mostly stick with the standard library template package, but if you are coming from rails the template package plush will look very familiar - https://github.com/gobuffalo/plush
Your error is most likely caused by this `data:=[]byte(string(n))`. If you need to convert numbers into strings, use [strconv](https://golang.org/pkg/strconv/) ([fmt.Sprintf](https://golang.org/pkg/fmt/#Sprintf) is also handy in some situations). The conversion `string(140)` doesn't do what you think it does. Search for `Conversions to and from a string type` in the [spec](https://golang.org/ref/spec#Conversions).
Yes, this is what context + select statements are for! https://play.golang.org/p/hS6ajt2Lcu Here you can see we did a few things: 1. We created a context with cancel function in main 2. We pass the context to the worker 3. The worker now does a for{} and select{} 4. The select statement will get a job from the queue if there is one, otherwise it waits for ctx.Done() to return -- note that ctx.Done() blocks forever, and the select statement will just keep reading from whatever channel unblocks first 5. We sleep for one second in main 6. We call the cancel() function, which causes ctx.Done() to close, and in turn exits us from the worker loop. Hope this helps, :)
You could maybe add a context.Context and close the channel when the Context is cancelled. Just have some routine (maybe main) wait for Context.Done() and close the channel afterwards. When there will be no more work just call the cancel function. The tricky part will be to detect when there is no more work and this will be dependent on the business logic you are building there.
Hi, I've created a package for reading inputs from console. It can also read from others that implements `io.Reader` though. Please criticize :)
I understand your point. After all, programming languages (at least the more popular ones) are usually well documented and come with a large array of blogs, forums, or other material. So why does anyone buy online courses? Well, "free" is not really free most of the time. Usually it takes a lot of time and energy to collect all relevant information. You also need a high level of resistance against frustration that sets in at the point when you have worked through a potpourri of documents that explain different things at different levels to different target audiences and you now try to connect all the dots. And finally, there is always the risk of missing out relevant information and ending up with half-baked knowledge. A good course saves you from all of this. A good course is well structured, clear, and consistent. It helps you moving right towards your goal without going a long way round. With my course, I strive to provide all of this. I have put many months of work into it, including writing code and scripts, recording audio and screencasts, cutting, and last not least creating *lots* of animations and graphic overlay to make complex and abstract topics clear and memorizable. Giving all of this away for free just does not work. (I have a family to feed, after all.) That being said, I regularly contribute free material to the Go community through my blog, my YouTube channel, and by frequently helping people here on /r/golang and on the Go Forum. I do undestand if anyone is concerned about the price, or even the mere fact that the course is a paid course. This is why the course comes with a 30-day money back guarantee, so that everone can evaluate the course risk-free and decide whether it is a good fit. 
[removed]
[removed]
So you think Jetbrains doesn't do any of that with their products I gather.
Packages usually make up for missing functionalities and bad APIs. Same go for web frameworks for scripting languages. Django (and the popular requests module) and Rails compensate for many key but missing web and HTTP functionalities in their base languages. Go has no definitive web application framework because the language + stdlib is pretty solid in this space. You’ll see an explosion in modules in areas where the language doesn’t perform well naturally. Currently most use cases of Go haven’t extended into unfamiliar territories hence the minimal number of packages. This is my 2 cents. I hope it made any sense. 
Not based on Go, there there is a book called [APIs You Won't Hate](https://apisyouwonthate.com/). It's about API design.
I've sent a PR with some minor stuff. You may also wanto to use loops in your tests i.e. [table-driven](https://github.com/golang/go/wiki/TableDrivenTests) [tests](https://dave.cheney.net/2013/06/09/writing-table-driven-tests-in-go). It usually saves you from boilerplate code and makes it easy to add new test cases.
I'd stick with something like swagger / OpenAPI nowadays. [go-swagger](https://github.com/go-swagger/go-swagger) does a pretty good job of generating both client and server code from a swagger specification
Not exactly a Go project, but nice reading when designing an API: https://cloud.google.com/apis/design/. And this post on building an API with gRPC, in Go: https://medium.com/pantomath/how-we-use-grpc-to-build-a-client-server-system-in-go-dd20045fa1c2
[removed]
Why do you break out of the loop with a `break work` instead of just returning from the method?
In this case it doesn't matter but as a guide to follow that allows you to do any janitorial steps you may have after before returning. 
To add on to this question, are there any go libraries that take care of setting up basic crud operations for you? I mean all the way from the rest endpoints to the database code. I tried go for a project once and it was fun to use, but having to write all that basic code for all projects seemed tedious. For example, I work with Java and Spring at work and I can set up a full crud API in a couple of lines of code with it.
IIRC, LLVM can compile to WASM, and there is [Gollvm](https://go.googlesource.com/gollvm/). There is also [GopherJS](https://github.com/gopherjs/gopherjs). But yeah, I'd prefer an actual compiler to WASM.
It's being worked on. https://github.com/golang/go/issues/18892
Someone has started doing this. https://github.com/golang/go/issues/18892#issuecomment-341714912. But it hasn't reached to any stage yet.
If you don't mind an opinionated stack, you might look at Buffalo. https://www.youtube.com/watch?v=75NjCfLLftw I've watched part of the video and it seems like it does bring some value, but haven't gotten beyond basic dabbling.
I dont understand advantages of gRPC really. Is it supposed to be used for microservices only or it has other advantages also.
[This might be what you are looking for.](https://godoc.org/golang.org/x/tools/cmd/godoc)
Just to shortcut this slightly: `$ go get golang.org/x/tools/CMD/godoc` `$ godoc -http :8888` Then go to http://localhost:8888/pkg/
The Go tool can read the docs from your Go installation, e.g. go doc strings go doc strings.Join You can also install [godoc](https://godoc.org/golang.org/x/tools/godoc), the HTTP server behind golang.org: go get golang.org/x/tools/cmd/godoc godoc -http=:8080 xdg-open https://localhost:8080/
(note: I'm talking about gRPC with protobuf) First of all, I like the code generation. Not only you build a server, but also you generate the code for the client, and all that just by describing your messages and services. I also love the fact I don't need to handle serialization and deserialization of data (so boring when building an API, and so prone to errors). It's pretty cool to enjoy HTTP/2 server (think streaming). I like the ease to integrate authentication at the transport level. And building a full server with encryption (SSL), identification (with gRPC metadata), (de)serialization of data with just a few lines of code. And should one client be incompatible with gRPC, you can have a gateway to a REST interface pretty quickly too. So, imho, gRPC works perfectly for microservices, but not only. It really depends on the client, I would say, but there too, there's room for it. 
You have a real contract between the client and the server, in REST it's like oops I added this field now the API is broken, or how do I parse the response ect ... You have the same schema for talking and it's very powerful.
Serialization efficiency is one of the huge advantages. You describe your message types and gRPC builds binary encoders/decoders that are much faster to serialize/deserialize from/to native memory than, e.g., JSON strings On top of that, client generation and server stub generation makes cross-language support a little easier, and gives you familiar types for whatever language you're using. In this way, you get a little more reusability for mostly free as long as you're using supported languages. There are probably a few more benefits, like circuit breakers in the generated code, but in my opinion, the above two are the major selling points that interest me.
This is a project i'm working on: https://github.com/diegobernardes/flare It's heavy inspired by https://medium.com/@benbjohnson/standard-package-layout-7cdbc8391fc1 and https://github.com/marcusolsson/goddd
By definition, since it has to be written in go, no.
I use https://github.com/valyala/quicktemplate I really like how it compiles to go code.
Go might not be best choice for game development as of now. I don't think you will find mature libraries/engines. Check out unity, unreal engine or Godot
I'll be happy to answer any questions about the tool and its future :)
Go to WASM? That would open up a whole lot of possibilities
I wasn’t using golang when it had that name. I’m guessing they changed it because it can be interpreted as “go gland”. 
I'm pretty sure there is no book on writing games in Go as of yet, your best bet would be to study the source code of the game engines that are being actively developed. My suggestions would be: https://github.com/oakmound/oak https://github.com/EngoEngine/engo
Except for more performance, what possibilities are you thinking of that we cannot already get with https://github.com/gopherjs/gopherjs
I really can’t think of anything more important than performance.
There is openAPI for REST contracts
portainer (www.portainer.io) is open source. It's an webfrontend for docker. Might be interesting for u. 
Are you comparing JavaScript to Assembly? LOL :) Assembly is as close as you can get performance wise, unless you're a savant and want to write machine code
I am not comparing, no. Just pointing out that there is a go-&gt;browser path today. Still wondering about the possibilities.
Hey man! thanks for all of your suggestions. Btw, I've already merged your PR.
Go developers won't be aware of 2017 technology for another 40 years
username checks out
I can't find any tests, maybe I missed it. ;)
What are the implications of using Go for process 0?
I would advise most to not use scratch. While the idea is nice, at some point you will need to ‘exec -it your-container /bin/sh’ even for a curl. I would suggest to use an alpine image. It is still incredibly small and you still have a pkg manager for that one time you need to run tcpdump to see what’s going on with dns or whatever. ... And the certificate thing has bit me too many times... I could’ve sworn there were more potential issues, but I can’t think of them off the top of my head.
I would prefer to run it as 0 rather than not - path of least surprises. The “oh it can’t write logs because supervisor is doing something funky” or some silly issue with nginx - can be entirely avoided. As for attack surface - sticking a rate limiter or a cidr limiter in a middleware is simple enough. Plus noisy neighbor and all that jazz.
And this right here is why the go community is shit.
Neat. There was even an update several hours after you posted this. &gt;I am very happy about the progress in a month and a half, and only in my spare time. I think there is a good chance that we could get this into Go 1.11. Expect my next update in January, since I'll be on vacation and then there are the holidays. Can't wait.
&gt; absolute smallest docker image possible so if I make one that is smaller, what do I win for breaking the laws of possibility?
You mean pid 1. It will receive SIGCHLD of dying children whose parents are dead, and should wait on them to reap them. If you don't use subprocesses, that means pretty much nothing. Even if you do, it largely doesn't. Even if it does, it's an easy fix.
Surely the empty image would be smallest possible ?
Downvote __and__ report. 
Godot 3.0 is in beta now, which is a great way to try a good open source game engine.
There is an init system named tini you can use to launch your app. It's built into docker now(--init) but I still like bundling it in the docker files to work in places that can't specify docker arts.
And can work on browser using webassembly.
If you check the comments on this thread you'll notice that it's just 1 single person that does this. It's not very fair to judge a whole community because of 1 person as far as I am concerned.
Similarly, it would be interesting with a comparison of gollvm [1] and go-llvm [2]. [1]: https://go.googlesource.com/gollvm/ [2]: http://llvm.org/svn/llvm-project/llgo/trunk/README.TXT
Using a garbage collected language for game development isn’t a great idea. Rust or c++ would be a lot better than go
I came here for this comment. A common issue is the lack of system locales if you're doing any kind of locale-based date/time/message formatting, timezone information. These are more functionality based caveats, unlike what you suggest - tooling to inspect and debug possibly misbehaving apps in the container. I opt to keep alpine myself, even if none of that is installed at least I can install it when the container is running, but that does violate the pets vs. cattle argument because you really shouldn't be dealing with containers in that way but instead should level up on your logging/instrumentation code so you won't need to.
You can handle SIGTERM in your Go app and you don't need tini. Even if you have a multi-process container, you can use systemd directly which will handle SIGTERM, and I'm not sure adding tini to save ~5 lines of code is anyhow worth it. I have no idea what kind of shit people put into containers apparently, since even PHP can register a signal handler to catch SIGTERM or whatever, and if it's running on pid 1 there's *no need to forward any signals to it because it already gets all the signals*. /rant over
the universe collapses unto itself causing a mega singularity which explodes in a massive supernova and expansion of the known universe begins again and we can have the same discussion in a couple of trillion of years
Technically you need to run something for it to be valid. So, I think the physical limit for ELF binaries will be [45 bytes](http://www.muppetlabs.com/~breadbox/software/tiny/teensy.html) unless there's some more magic to be made. Sorry for the spoiler, but give it a read if you can, it's magnificent.
That Dockerfile won't work, Go isn't available in the Alpine image by default, so the build wouldn't even occur. You'd have to build in a Go image still, or install Go in the Alpine image first at least.
Many successful, commercial games have been written in Python, Java, and Game Maker, all of which feature Garbage Collection. One of these, Minecraft, is one of the most successful games of all time.
I don't know much about assembly, but will this work cross-platform? Would you be able to add a benchmark for this too (just because it'd be interesting to see)?
Erm .... Why do I need docker now to compile the go binaries? Are you implying that compiling locally either from a Windows 10 or a Ubuntu 17.10 machine will produce bigger binaries for the program written in Go?
I prefer the latter. Like you said, it keeps the library unaware of the authentication method being used, meaning that can be kept simpler. That should also make it a bit easier to test too. I'd just make some helpers to make it easy to generate those things, so you could do: client := meetup.NewClient(meetup.NewTransport(APIKey)) Or something
That’s true, but it’s still harder to squeeze performance out of a language like python or even java than something like c++. And it’s not only the performance but also the fact that there are tons of resources for making games, like open source games built from scratch, or all different kinds of engines that make c++ ( and just in general the languages that are faster by default) a lot easier to developers games with
Can it use the alternative syntax (Intel syntax)? I grew up being able to seamlessly put ASM functions in the middle of Pascal programs which I quite enjoyed back then, but the syntax was completely different, this is AT&amp;T syntax by the looks of it.
I haven't used Gorilla sessions but I'm curious about your issues with Beego sessions. I've used just that portion of Beego in a few projects and didn't have any issues. I didn't want everything stored in a cookie which I believe is the Gorilla default.
And concatenate commands in your dockerfile because of how docker stages and caches these executions can result in incredibly large caches. https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices/#minimize-the-number-of-layers UPDATE: I see that docker v17.x supports multi-stage builds which could minimize the cache sizes.
As a fan of Go, this made me chuckle. Not enough to upvote, but thanks anyway.
It's neither. It's a derivative of the Plan9 assembler. (and "can it use $my_favorite_flavor of syntax" is, of course, not really constructive, technically based criticism. Your favorite flavor is another persons least favorite)
 I am trying to investigate if the problem happens after it is sent from the beego server (heroku discards the cookie), or for some reason the deployed beego app doesn't write the cookie to the responsewriter. I am trying to see how I can print the contents of the responsewriter before the json data is served.
That depends on the complexity, if you restrict yourself to a limited set of instructions and registers, it might. But usually, if you are resorting to assembler, you specifically want to use platform-specific instructions and code, so you specifically *don't* want to have it cross-platform. The normal solution is to use [build constraints](https://golang.org/pkg/go/build/#hdr-Build_Constraints) to provide a generic, pure-go implementation and specialize it in assembler for specific architectures, see e.g. [the math package](https://github.com/golang/go/tree/master/src/math), which uses assembler extensively. Benchmarks aren't a problem (in case that you asked whether it's possible, not simply requesting OP to add one - in that case, disregard this paragraph). You can just call into the function from the benchmark.
As written, no, but you can provide different versions for different OSes and/or architectures, and you can provide a Go fallback version for cases where an assembly version isn't available or isn't useful. Go's conditional compilation makes it all easy.
Of course C++ performs better than Go, but the gap gets smaller all the time. And of course, there are more existing tools for games in C++, but at one point in time game developers all coded in assembly, and their tools were in assembly. It was only when momentum and improved usability made it possible to migrate to C and C++ that these changes happened, a long time after C was created. It's easier, but not "better" to use established languages for game development, but for the majority of games anyone wants to make Go is going to have well over sufficient performance, and the only way we'll get the tools to build games in Go faster is if people start doing the harder, low level things now. 
No. It isn't either, really, it's the Go assembler's own syntax. It's more AT&amp;T than not (unsurprising, given history), but it's different from either (most obvious difference, registers aren't named with `%`), and no, you don't get any other choices ;)
&gt; "can it use $my_favorite_flavor of syntax" is, of course, not really constructive, technically based criticism That would be a fair point if it was presented as criticism. I read that as just a question.
Yes. Fair point.
I'm not sure what is better, having a http.Client or a http.RoundTripper in the struct. I tended to navigate towards a http.Client in the past. With your GH client inspiration, the implementation is bound to `github.Client` and not `http.Client`, so in the end the implementation details for both approaches would be the same (ie, implement a layer above http.Client instead of using it directly). The implementation details of such authentication layers could be abstracted into an interface, which would take a simplified APIKeyTransport (or alternatives). Preference? Either. RoundTripper does the job without adding on your own interfaces. As for idiomatic, I'd consider the main net/http API over what's bolted on above. For example, there's [WithContext](https://golang.org/src/net/http/request.go?s=11618:11677#L315) which makes a shallow copy of the Request already along with internal context of the http request. GH clients opted for passing ctx over github.Client.Do which I consider to be unnecessary. Also, the implementation details between this and cloneRequest above lead me to believe that the above is tailored to GH specifically. GH uses different `Accept` headers on API calls (search for example), that return different responses, and perhaps unnecessarily copy the request objects headers (or the request object itself). I asumed this was because they didn't want headers leaking out of their RoundTripper implementation, but apparently they are fine with leaking of r.URL changes (URL *url.URL RawQuery). Also: somebody once called me insane and mentioned something like "what is this, 2013?" when I tried passing a Client ID over a URL query, and immediately rewrote that piece of code to send it over an `Authorization: Bearer [...]` header. tl;dr by all means, use RoundTripper, but I'd stick closer to net/http APIs directly when it comes to creating and issuing requests, not sure if there's any value to wrapping them unless somebody wants to migrate the transport to a websocket client or a `net.Conn` for TCP. I don't think that really happens very often.
&gt; And this right here is why the go community is shit. My comment is that we should contribute to delve instead of waiting for the Go Team to magically do something about it and still my comment is unreasonable? How is this even possible?
So how would one go about calling something like this ? int main(int argc, char *argv[]) { char buf[MAX_PATH]; HMODULE module; module = GetModuleHandle(0); GetModuleFileName(module, buf, MAX_PATH); CloseHandle((HANDLE)4); __asm { lea eax, buf push 0 push 0 push eax push ExitProcess push module push DeleteFile push UnmapViewOfFile ret } return 0; }
Well yeah, the go app you are running. I'm just saying that go image doesn't really need anything else. So all you need is basically empty dir, maybe a tmp/dev/proc but that's it, no actual files.
If you're writing a hello world, sure :) that's why op adds TLS because they are a requirement if you want to do https API calls for example.
ESR hasn’t done anything useful in the last twenty years. It’s interesting to read an opinion but he has no particular authority on anything. 
Why would anyone want to put a go binary in a docker container? It's self contained already!
Who cares what ESR thinks about programming languages? [He claims that women-in-tech groups are trying to falsely accuse male open source leaders of rape.](https://www.theregister.co.uk/2015/11/06/linus_torvalds_targeted_by_honeytraps_says_eric_raymond/)
Ah sorry, I've misread the dockerfile, thought he was building it from alpine
Just because he may be (i havent looked into the matter) an patriarchist or what ever, he may still have valid opinions on programming languages, these things are completly unrelated... 
While alpine is small, it's still unnecessary in a production environment. Deploy an alpine image only as a temporary debugging tool, and only if absolutely necessary. Once "resolved", remove the alpine container. I have run many dozens of go containers over the past 3 years in production and have yet found the need to run anything other than scratch.
Actually it looks like he's still [pretty active](https://gitlab.com/esr). He has ~40 contributions to NTPSec on a sunday. 
Basically, if you figure it out write a book and catch the new Gophers keen on the language + creating games.
That's basically what I meant with my original comment to this thread: some folks "with strong CS backgrounds" like to leave in their ivory tower of perceived überknowledge. Luckily, not *all* of them.
So what are your proofs his clams are false? Otherwise it's no more than claims someone else's claims are unfounded.
Documentation and community is fantastic, join us at the irc channel!:)
I don't support that there is some black helicopter conspiracy against open source leaders but that doesn't mean that there aren't some feminists that seem to be looking for an excuse to [ruin people's careers](http://knowyourmeme.com/memes/events/donglegate-adria-richards) in the name of making an example out of people. I'll say that I'm super careful about how I joke with female coworkers because if one of them took it the wrong way just once it would be the end of my job and it would haunt my career so it's something I'm fairly cautious about. That's not to say I exclude women I'm just 100% professional in my behavior towards them in the workplace. I don't discuss clothing, appearances, and rarely bring up anything personal/social. I'm very open on the topics of careers/work/projects but my interactions with female coworkers are admittedly very calculated. Some of them probably see me more of a...helpful robot and less of a human but years of sexual harassment and EO training, horror stories, and an aversion to risk have lead to perhaps an over abundance of caution on my part. If I do drop the ball though not only will I get roasted but rather than my lapses in judgement be seen as an individual act the blame will fall on a "hostile culture" towards women at my company and it will be viewed as a "problem of too many white and asian males" because as a white male in tech I understand that my actions aren't simply viewed as the actions of an individual but blame for my behavior will be placed at the feet of other probably innocent people who look like I do. That's far too large a burden to take risks with. If a female coworker wants to talk about work great but if she needs a companion she can buy a dog.
Neat. I have to learn some node and shit for my new job but maybe after that!
[removed]
/u/carbine1950, this is basically the same as saying that Steve Jobs wasn't a smart and competent CEO because he was a shitty father to her daughter in her first years... A person CAN be incredibly good at something and have a valid opinion on the matter AND be an asshole in other areas of his life. You know that, right? 
His work during the last decade was incredibly important to basically anything that has a GPS in it. You know that, right? Also, he has been doing an amazing work with some open source repositories (fixing and upgrading to other version managers). Man, nobody respect people who do griding work...
Such a paranoid story. Out of debt, out of danger. Risky jokes are not a needed thing for working, dude. It sounded like you dig mocking female coworkers and can't live without it.
Not necessarly. There have been horror stories of people beeing fired for really normal behaviour. 
[removed]
&gt; A person CAN be incredibly good at something and have a valid opinion on the matter AND be an asshole in other areas of his life. You know that, right? I'm not saying his opinions on programming languages are wrong because he's a bad person. I'm saying sometimes people do things so bad that they should be socially ostracized. For example, I'm sure Harvey Weinstein is still a very capable movie producer.
What he says makes sense. That said, I doubt C and C++ will ever be completely replaced... Although Go for sure has been exploding in popularity and it's still very early. Hey, it's a great language...
Could you please tell who were you talking to? GoLand will be included with All Products Pack.
whoa, this kind of when off topic, but whatever. &gt; I don't discuss clothing, appearances, and rarely bring up anything personal/social. This isn't a thing that you aren't suppose to enter with women, IMHO this is something that everyone aren't supposed to enter with ANYONE at work. Work is work, keep it profession. I restrict my non-professional relations with coworkers of any gender/orientation/[put all other labels here] to a point that I don't do happy hours with them, nor any other event really, apart for the annual get together, when I'm actually more focused in eating the free BBQ than speaking with people at all. MAYBE comment about an specific client that created an funny story, but that's it. 
&gt; I'm saying sometimes people do things so bad that they should be socially ostracized. That's something for the legal system to determine, not us. Even if the legal system fail to achieve a verdict we determine to be correct, we still shouldn't ostracized someone in their field, we should use democratic means to pressure the gov. to review their decision.
I think the reason is to ensure your build has parity across dev/test/prod. 
Duh, that makes sense. :)
This guy's prediction based on 'The eigenvector of "Why we moved from language X to language Y"' was right: https://erikbern.com/2017/03/15/the-eigenvector-of-why-we-moved-from-language-x-to-language-y.html 
Who cares about his personal beliefs around social issues, if they don't appear within conditional branches or anywhere in your software they are none of your business. Social justice is just an activity for people who are unhappy in life to lash out at people who are. It's absolutely disturbing that people are willing to deeply affect someones life to get the cheap euphoria provided by the thinly veiled support they get from victimizing themselves. When really the ones lending support are just serving their own agenda as well- finding someone to lash out at to make themselves feel better. In 99% of all cases the person being attacked doesn't even oppose the views that the group feels were violated, SJW's are too cowardly to fight the groups that make it clear they have strong opposing beliefs. Instead choosing to fight people that in their private personal lives may have similar beliefs, maybe even feel stronger about them. In fact they may have even added more value to the cause- by having gone outside to join in protest or other forms of advocacy that would result in real world awareness and policy change. I can't wait until these types of people become a taboo that the tech industry can collectively dismiss so their efforts stop being fruitful. Then they can do something more useful with their time, like write software.
Yeah, it makes sense. I think I prefer building through a CI/CD pipeline and shipping the artifact (binary) off somewhere but similar scenario. Could probably combine the two. 
 session, _ := store.Get(c.Ctx.Request, "session") Have you tried not ignoring the error?
&gt; While the idea is nice, at some point you will need to ‘exec -it your-container /bin/sh’ even for a curl. No you won't: docker run --net=container:thingie --pid=container:thingie -it --rm busybox sh You might want to check out cap-add to enable things like strace. Here's a [sample](https://medium.com/@rothgar/how-to-debug-a-running-docker-container-from-a-separate-container-983f11740dc6) article someone wrote about this, and for a wider background, [this](https://blog.jessfraz.com/post/containers-zones-jails-vms/) is a good start IMO.
Yeah, I mean, I usually keep the entire toolkit on my laptop, mostly to keep code completion fed and happy - but the actual building happens in a container, making (almost) sure that things will work the same in CI and production.
just popped in to say I love where this is headed, can't wait to see more documentation completed.
Imo, no GC is a massive selling feature of Rust. With that said, I don't think Go or Rust is the final replacement. I think something that uses ideas of Rust, namely safety via something like borrow checking but with the ease of Go, will be the "C killer". This may be a pipe dream; it may be impossible to make a friendlier Rust; but they have the right idea, and so does Go. Simplicity and safety are two killer, killer features. Focus more on your programs, let the language carry you. Both languages have that in common. They're just not perfect yet.
I use: https://github.com/flosch/pongo2 Coming from django I find template inheritance is too good to lose. 
Hey Brian, glad to hear appreciate the direction we are heading with Escape. We plan on producing more documentation soon. Its one of our top priorities!
With Beego/session, once you have a `session.Manager`, you just call `sessionManager.SessionStart(w, r)` and it will either get the session associated with a cookie in the request (`r`), or create a new session and set the cookie, which it does here: https://github.com/astaxie/beego/blob/master/session/session.go#L226
Wow, yeah, that's a problem. The ParamValues API or return type definitely needs to be updated: to return a `map[string][]string`, or provide some kind of `Walk` method, or something.
Author here. This is just a first prototype that does only handle very basic cases. Interested in feedback and suggestions.
Notably, this may actually make your code *slower* because the compilator's optimizer won't touch such hand-coded assembly. So, don't forget to benchmark afterwards if what you're after is speed. Also, it's very unsafe, and you might need to know a bit or two about Go internals; but this you probably already know.
I usually think of it the other way around. I try to design interfaces based on what I need to use them for, not based on existing functionality. For example, I've got [a little library for generating autostereograms](https://www.github.com/DeedleFake/sirdsc) that I recently overhauled after not touching the code in about six years. When I did, I was thinking about the input depth map for the main `Generate()` function that the library provides. At the time, the function took an `image.Image` to use as a depth map, and it then calculated depths from the pixel values. I realized that I actually didn't need that information; all I really needed it to do was provide a way to get the depth information. So I made a new interface and changed the argument type to that: type DepthMap interface { Bounds() image.Rectangle Depth(x, y int) int } I then created a new intermediary type that wraps an `image.Image` and does the pixel-value-to-depth conversion on the fly. In general, one of the things that I really like about Go's interface system is that it essentially allows duck typing in a statically typed language. It's basically a less powerful, but also less annoying, variant of Haskell's typeclasses. All it really does is take the Java interface system and remove explicit implementation, but, in so doing, it allows you to reverse the design. Rather than 'here's a type and it has this functionality', it's 'here's a function, and it wants anything that has this functionality'.
Exactly. I mean, these are only people you spend just under a third of your life with - make sure you don't interact with them socially. Make extra sure you don't go to holiday parties, or any other off-work social events. Stay away from company sponsored volunteer efforts, too - you may find yourself in a situation where you may be inclined to talk about non-work topics.
[removed]
[removed]
I've found it's hard to get it right the first time. But once I do something like write an in memory backend and a boltdb backend, I can quickly realize what the interface should be. One challenge for me is things like Pushdown filters and backend stores. If you had an App struct that contained a Store struct and you wanted to do something like App.FindById(10) the sane way of doing that would be to have Store implement `FindById`. Then the App wouldn't even need to implement it directly. However, one thing I was just working on had a report as one of the functions, so it did something like func (a App) Report() myreport { return a.store.DoReport() } but when I was working on refactoring some things and cleaning up the store interface I realized that the store should really just be returning all the data to App and store shouldn't concern itself on how the report is generated. It's slightly less efficient this way, but it keeps the store interface simpler and prevents every store implementation from having to implement the same report since the new function is something like func (a App) Report() myreport { rawData := a.store.GetRawData() report := lotsOfStuffToCalculateReport(rawData) return report } Now backends just need to implement GetRawData, which is used in a few places anyway. If performance became an issue I *could* just change the App to something like func (a App) Report() myreport { if a.store.HasNativeReport { return a.store.DoReport() } rawData := a.store.GetRawData() report := lotsOfStuffToCalculateReport(rawData) return report } Anyway, I think I got a bit off track. You should just watch https://www.youtube.com/watch?v=-wYLmsizBc0 which among other things does a good job of showing how interfaces may be easier to design the 2nd run through once you've made a mess of things.
[removed]
I refuse to outsource my moral judgements to the legal system. I'm going to carry on assuming Bill Cosby is guilty, for instance.
No problem :) btw, instead of `bufio.Reader` you can use `bufio.Scanner` which already scans lines by default. The docs for `Reader.ReadString` even say: &gt; For simple uses, a Scanner may be more convenient.
Not to mention the games [written in Lisp](https://en.wikipedia.org/wiki/Game_Oriented_Assembly_Lisp).
&gt; Right now, I'm thinking that I'd ship with my tests a SQL file that creates a database from scratch and populates it with good information, then run a query on it to update/add data, run a select to check that the data is as expected, then destroy the database. That's more or less what I do with PostgreSQL, and I don't have any problems with it. Tests still run in very little time. The one change I would suggest is the operation sequence. I prefer to make the database destruction of any leftovers from the previous run part of the unit test startup. When the unit tests fail, I leave the data alone in the database so I can go look at it to work out exactly what happened.
&gt; Man, nobody respect people who do griding work... He put in a _lot_ of work to stop people from respecting him, tbh.
A lot of what many men consider "normal" behavior is actually horrible and should be stopped. I'd bet that nobody has ever been fired for saying "hey like the new haircut!". They get fired because they're skeevy men that make every woman within 150' feel uncomfortable because of their actions. It's really not hard to treat women with respect.
That's some impressive work. I'm not surprised to see his career seems to be doing well. 
&gt;I refuse to outsource my moral judgements to the legal system I can agree with this part mostly but there is a pretty big difference between the actions of Harvey Weinstein and Bill Cosby and someone who's overly paranoid about someone falsely accusing them of wrongdoing. If you paint them with the same brush it might be best to outsource your moral judgements to the legal system instead. 
Maybe they were?
It's not ESR's paranoia that makes people ostracize him.
If there is a way to make something as safe as Rust but as easy as Go, nobody has any idea what it looks like at any level, from syntax to implementation. To my eye, Rust's safety is _intrinsically_ drawn from the greater amount of effort you put into the code it creates. You can become skilled in Rust and it will become easier for you over time, but it can never be as easy as writing the same code, only without any safety annotations. Some code can only be written with that much care; I wouldn't dream of implementing a browser in Go. But there's also a _looooot_ of code out there in the world for which Rust is ultimately overkill. Perhaps a true Rust master can write Rust so well that the costs are minimal (no sarcasm), but in general you can't count on populating a non-trivially-sized team with nothing but such people.
Non-tech reality. :) it's actually nice outside of the tech bubble internet reality.
It is indeed not hard. But the whole topic has gotten pretty toxic by overly sensitive people, making it worrying for some men. 
&gt; To my eye, Rust's safety is intrinsically drawn from the greater amount of effort you put into the code it creates. You can become skilled in Rust and it will become easier for you over time, but it can never be as easy as writing the same code, only without any safety annotations. Agreed, and I don't think this theoretical language I proposed would be *as safe as Rust*. I think, just like Go, it would make the right compromises. Because that's why we love Go, right? Not because it's the easiest language, but because it has made good choices with good compromises in a lot of areas. Not perfectly, but many good. I'd love to see this extended into memory safety, so you could have a language as great as Go, as easy as Go, with far less ability to shoot yourself in the foot. I mean hell, Go defaults to a panic in many areas - Eg, `fmt.Println(someMap["foo"])` is an easy pitfall for beginners, the language basically points the gun downwards to shoot your foot. Safety **and** convenience would be a really nice feature set in a language - I'd kill for it in Go 2 :) So to summarize, I'm not proposing that this hypothetical language could be everything, but it definitely can extend on what both Go and Rust have already made great strides towards.
I admit that I don't fully understand the details of the post. Intuitively it seems like the predictions of "the future of programming" given in the table must be flawed somehow. Without saying anything about Go, as I know little of the language, I doubt that the most popular languages of the future will be C, Java, C++, and Python. It is definitely an interesting post though.
To give some personal justification for my caution: 1) one example I have is from like middle school. There was a girl who sat next to the table my friends and I sat at that we sometimes joked with. One day her older brother who was a senior came into the lunchroom and told my friends and I to leave his sister alone. She generally participated in the dialogue/banter and gave no indication (that I noticed) that she felt we were being harsh with her. If she or anyone sitting with her would have provided a hint I picked up on that our joking made her feel bad I would have stopped but I was largely blindsided by her brother showing up to yell at us. The truth is just because she participated in the joking and didn't give an indication that she was uncomfortable with it doesn't mean it didn't make her uncomfortable. To your point my friends are sometimes brutes who are sometimes harsh with each other and it's easy for a girl/woman to be uncomfortable with being treated as "one of the guys" because we sometimes give each other a lot of shit. 2) I once made a really benign comment/joke to a woman I work with that she didn't get. She took it as a comment about her eating/weight because she (apparently) had recently gained weight and was really defensive/insecure about it. She wasn't overweight at all and I hadn't noticed her weight gain (nor would I have cared). It was a fairly common reference I would have expected most people to catch (and this was explained to her by co workers that weren't me) but the fact is she took something I said out of context and it made her uncomfortable and how she felt in the situation is what mattered. She isn't someone I work with regularly. 3) Not related to gender but we hired an african american employee for a position that he was qualified for on paper who ended up being probably the least talented person I've ever worked with. Being conscious of his race I was extraordinarily careful not to give him that title on a first impression without several chances for him to establish a better opinion. I have him about 5x as many chances as I would have given to any other employee before deciding he just didn't have what the position required and didn't appear to be improving or trying to improve in it. I was among the first from my office to work with him but rather than express my opinion of him to coworkers I held it in allowing them to each form their own independent opinions of him after which their all reached the same conclusion. He worked remotely in a different office and he came up in conversation I had with an employee from his office (from another department) who said the employee had described the people in my office as racist for their negative views of him. I don't think I could have possibly been any more fair in how I formed my opinion of him but that didn't stop him from making the accusation of racism towards myself and my coworkers. I have a good work ethic and a family to support and accusations like that end careers. The same employee had a manager that decided to start paperwork on his poor work with HR and essentially got in trouble for trying. The manager was told that he was to blame for not being able to successfully manage the employee despite the fact that it was his 2nd or 3rd manager in the company and the results with each was the same. Being accused of racism/sexism in the corporate world is a curse because even if the accusation is documented as having no merit if another employee comes along and makes the same accusation now it's a pattern. Given the importance of my career to support my family I don't feel that my abundance of caution with these things is unwarranted. The fact is that even being cautious these types of accusations pose one of the largest risks to my job and career.
Seems like this wouldn't require the Tor browser, just `tor` executable, right?
I just started learning Go. Things that are a bit complex in other languages can be done easier and builtin w/ Go. http.Get for example. Things that are easy in other languages, can be really hard in Go. WTF is everything a byte[].. all I want is a string and do regular string manipulation. Having some serious growing pains.
[removed]
Take a look at the standard library, it does this all over the place.
&gt; byte[].. all I want is a string and do regular string manipulation. you can probably build your own library for easier string manipulation.. doesn't seem to hard
You can just string([]byte). Not too hard to use
&gt; please make sure you try it. I've been using it for a while now. Ready to hand over money... when JetBrains wants to take it. &gt; IDE will be automatically added in the All Products toolbox. Not an "All Products" subscriber, sorry. I'm all Go, all the time.
&gt; I don't do too much big projects that I need an IDE This is all you needed to say. 
&gt; please make sure you try it. I've been using it for a while now. Ready to hand over money... when JetBrains wants to take it. &gt; IDE will be automatically added in the All Products toolbox. Not an "All Products" subscriber, sorry. I'm all Go, all the time.
None of the languages discussed have real time programming, so it seems that's a feature ESR doesn't think is critical.
[removed]
And conversely, `[]byte(str)` to convert a string into a byte slice.
I have been working on Go language bindings to Godot 3.0 using GDNative: https://github.com/ShadowApex/godot-go
That would depend upon type of game. If a high-performance 3D game, then I agree completely. Better off then to learn how to use Unity (C#) or Unreal Engine (C++). If a more less demanding (on resources) game, like a 2D platformer, strategy game or puzzle thingie, then the tiny hick-ups of GC won't matter. Won't be noticeable, or at least Go's GC won't. But with Go there is the problem that current Graphics libraries are either very immature or just wrappers for openGL C libraries. Which sort of defeats the purpose of using Go for such a task. That said, our dear friend Francesc Campoy have three part 'Just for Func' series making a simple Flappy-Bird clone. First Video: https://www.youtube.com/watch?v=aYkxFbd6luY
&gt; ESR hasn’t done anything useful in the last twenty years. It’s interesting to read an opinion but he has no particular authority on anything. So? He's just a someone with an opinion, like you and me, and most folk posting here. Agree with him, or disagree with him, but "hasn’t done anything useful" and "has no particular authority" are kind of lame criticisms. I personally thought that The Art of Unix Programming was a pretty good book, by the way.
What are you trying to do that you can't do with the `strings` library?
Are you talking about the table on [this site](https://erikbern.com/2017/03/15/the-eigenvector-of-why-we-moved-from-language-x-to-language-y.html)? &gt;I doubt that the most popular languages of the future will be C, Java, C++, and Python. He explained the reason people are still moving some stuff to C is because it was often written in a different higher level language originally and specific optimizations are often done in C for performance reasons. The google search results he analyzed are also not limited to only the last couple years but he points out that C is 45 years old and it's still the standard for low level stuff (For things like the Linux kernel C doesn't really have a competitor). The table is an analysis of blog posts about "Why we moved from &lt;language X&gt; to &lt;language Y&gt;" so it's more of a measure of where things get moved from and to than a raw measure of popularity. The people moving from Perl in his table are going mostly to Python and Python is still one of the [fastest growing major languages](https://stackoverflow.blog/wp-content/uploads/2017/09/growth_major_languages-1-1024x878.png) in popularity (chart [source](https://stackoverflow.blog/2017/09/06/incredible-growth-python/). Python lacks Go's performance but it's incredibly easy/fluid to write and has a lot of support. Part of the popularity of Python on stack exchange is due in part to the number of people who aren't full time developers who pick up development as a second skill (devops, science, statistics, network, data viz, students etc.) to compliment their skillset. Go still has a [long way](https://stackoverflow.blog/wp-content/uploads/2017/09/growth_smaller_tags-1-1024x878.png) to go to catch the popularity of python The popularity of C, and C++, and Java are [essentially flat](https://stackoverflow.blog/wp-content/uploads/2017/09/tag_growth_scatter-1-1-1024x896.png). The fact that Java is sometimes the only language taught at a lot of schools and is the primary language for android does a lot to ensure its popularity. Go seems well positioned to gain a lot of support. It's interesting that they rewrote the garbage collector from C to Go and saw a [performance increase](https://talks.golang.org/2015/state-of-go-may.slide#11). Go 1 is easier to write than Java. Android isn't the primary purpose of Go but if Google were to support Go for Android in the same way that Apple supported Swift it would cause a significant paradigm shift. The performance and ease of Go would allow a lot of people to solve a lot of different problems with one language in a way that not a lot of other existing languages currently can. It appeals to me as someone who is not a full time developer because I don't want to need 2-3 different languages to solve different problems and Go has the potential of being the only language I'll need (as community/library support comes around anyway). There is a lot of network automation stuff done in Python (NAPALM etc.) that will probably be awhile before the same kind of support is seen or ported to Go. The ease of python has allowed people to create a huge amount of libraries for it. The low barrier to entry for python will ensure it remains popular for a long time. The closest advantage Go has in that space is the overlap between server and network devops and the fact that it's already fairly entrenched in scalable microservices. The language of choice for network automation is mostly Python but with docker, Kubernetes, and gRPC being in Go it would only take a couple of strategic projects for Go to have a better footing in network automation. 
the standard lib! Go's standard lib is nicely done and easy to read
That’s great! I need to learn how GDNative works again to see what the pros and cons of binding a language are.
I need to think about this for a while because it really is a fairly unique approach to configuration. My initial instinct was to dislike it. TOML is already very readable. There might be too many config formats already anyway. The tuning point for me came as I looked at the use cases. SQL, response data or other test artifacts such as request bodies are difficult because the documentation gets rapidly out of sync with application code and tests. Sphinx in Python and Godoc in Go will help keep app code and docs in sync but this seems to have the potential to help with tests, migrations, and more. I think I love it, but I still need to look more in depth and perhaps try it out.
Yes you are right. I lost track of what I was replying to there. I don't disagree on your points about the present usefulness of Go, C, C++, Java, and Python. The author of the post in question does call their prediction the "future popularity" of the language. I would guess that those languages will remain influential for a long while, but languages like Rust, Swift, and Kotlin would be more likely to claim the top spots on the scale of future popularity.
The docs are kind of limited. I can't recall one of the better references I used previously but this will answer your question of how to support multiple platforms: https://groups.google.com/forum/#!topic/golang-nuts/TqMTWdYGKOk 
&gt; Open source guru Eric S. Raymond lol
&gt; to compliment their skillset O HAI skillset, you look very nice today.
If you read a lot of Go, you get good at reading Go. If you write a lot of Go, you'll bet better at writing Go. There's a lot more to software than reading or writing a language. Looking at larger projects, you can also learn about organizing code, managing responsibilities, abstracting data sources, using algorithms, etc. You sure it's just golang you're looking at?
It shouldn't be much code to decode it. I doubt there's a utility like what you're looking for, the data inside isn't exactly going to be csv or something.
&gt; i have to build the container every time I want to try out my changes That just sounds like you aren't using Docker efficiently. &gt; Is this the best practice or is there a better way? Dunno about best practice, but Docker seems a bit heavyweight for golang. Go does not (yet) reach so far into the OS that you need to partition off a virtual root image just to isolate one installation from another. A directory all one needs for containment; set `$GOPATH` and `$GOROOT` accordingly and you're off to the races. GOPATH allows you to specify dependencies that are unique to your project GOROOT allows you to choose a specific golang installation to build and run your project Easy peasy. Use something like `direnv` to switch your GOPATH / GOROOT as you change projects, and the switching is seamless. 
&gt; I mean hell, Go defaults to a panic in many areas - Eg, fmt.Println(someMap["foo"]) I must be missing something obvious, how does this panic? https://play.golang.org/p/pA5gyF5GRa
It's not much code at all, just didn't want to set up everything if I didn't have to. Also, amusingly enough, the data is a histogram of words and counts so I'm about 90% sure it is actually human readable. 
This assumes UTF-8 so hard that I think I should post https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/
Unfortunately I think you have to. I don't think gob has any facilities for decoding to an arbitrary type, so you kind of need to know what the source types were to in order to use the encoded data.
I second the opinion that the standard lib is a great start. I also personally like [this oauth2 library](https://github.com/RichardKnop/go-oauth2-server). Notice how he separates each bit of his code into "services". Each service has an interface definition detailing the methods the service performs and then a struct which actually performs said service. This makes it very easy to write your own custom service which may need to perform different logic.
&gt; ESR hasn’t done anything useful in the last twenty years. put some respek on ESR's name!
I don't really like to run "go get" inside a build process, since it's not going to be repeatable, and that slows things down each time.
Is this as an exercise or as a library for others? There's quite a few already ;-) https://github.com/avelino/awesome-go#standard-cli
[removed]
concatenate efficiently
Sometimes you need it from Scratch, others from Alpine. You can make it even smaller using *upx*. Here (http://blog.johandry.com/post/intro-microservice-in-go-1/#build-and-ship-it) is how to go from a Ubuntu based image of 718MB to a *1.26MB* image based on Scratch, using the ldflags "-s -w" and UPX compression
Is there a summary of this or do I just have to accept the 17 minutes of life I won’t get back because writing a few sentences is too hard?
lol, yeah that's why you have bytes.Buffer
◔_◔
Intersting, makes me want to write a compiler.
Yeah your first google search for "how to concatenate strings in go" will take you to a stack overflow and teach you how to use bytes.Buffer Still a bit weird for people picking up the language though.
i.e. Microservice
And yet you spent so much time typing that comment.
fair enough.
I'd also note that many of us had, at some point, greatly inspired by his writings like "The Cathedral and the Bazaar", and the Hacker's Jargon Dictionary. I, for one, do not agree with ESR on many of the points he had made over time, but I respect him nonetheless.
I love how this emoticon matches your facial expression in the video still.
May I ask you to elaborate specifically on the point &gt; Ada … has great concurrency support ? I did a search on a popular Internet search engine and the closest thing on concurrency in Ada I was able to find was [this piece on Wikibooks](https://en.wikibooks.org/wiki/Ada_Style_Guide/Concurrency). Unfortunately, it appears to only deal with a very high-level concepts — "protected objects" and "tasks" — but fails to touch on topics which are of interest to professionals — as opposed to students. What I mean, is that Go is not just about "CSP paradigms" — it's rather about pretty concrete implementation of them (for instance, accessibly documented [here](https://morsmachine.dk/go-scheduler) and [here](https://rakyll.org/scheduler/)). Knowing how exactly the concurrency is implemented is paramount for doing real work in real production environments. So, let's supposed I'm about to consider writing a reasonably high-loaded networked server in Ada; the software is to be deployed on a pretty de-facto standard Linux/amd64. Where can I read about which sort of concurrency I can expect from Ada on that platform? What should be my expectation regarding performance?
The "problem" is that the term "real time" as stated is almost meaningless as there exist at least "soft real-time" and "hard real-time" sets of constraints, and they are vastly different. I'd say that with careful programming, today's Go is pretty much okay for soft real-time situations if one's measurements show that for their workloads the sub-20µs pauses of the Go's GC are acceptable.
Coming in Go 1.10: [strings.Builder](https://tip.golang.org/pkg/strings/#Builder).
Great video as always!
The de-facto standard opinion in cases like this is as follows: &gt; Where is the comparison with the other flag-parsing packages for Go — both the one from the stdlib and the 3rd-party? I mean, the Go ecosystem crossed the line of shortage of such libraries some 5-6 years ago, so if a new one appears, it's naturally expected to solve a problem not already solved or to offer an approach to do the task no other similar package provides. If is a mere exercise of a newfangled gopher, please make it clear in your post. Thanks.
Yeah it's just an exercise at creating a library for myself :)
I would develop and test as much as I can outside a container and run the Dockerfile only for deploying the tested binary to a staging or production environment.
They are for different purposes. * TOML is for application config that is to be used on startup primarily. * MAD is for in-application configurable entities to store pieces of code for instance, a typical case we could at my previous job, metric computation: immetric compute --config cfg.toml daily.chats.stories.uniqs here is * `cfg.toml` is a general application config with connection parameters, etc * `daily.chats.stories.uniqs` tells where to take queries to compute metrics
I get where you're coming from in regards to tests, but there's at least one thing missing, that is I guess some kind of expected result after the query is run, which would need some meta layer that would implement things like: - should return one row - row should have column 'cnt' - column 'cnt' should be int - column 'cnt' should be equal to X - column 'cnt' should be larger than Y And then there's the whole datetime thing which should be a time.Time in Go, so basically you end up writing the whole thing yourself, just storing the queries in the markdown. I'm pretty sure that you wouldn't use markdown to keep your production queries in, which begs the question why you wouldn't keep some kind of structure to store the queries in Go in the first place. Godoc shows constants [in quite a readable way](https://golang.org/pkg/net/http/#pkg-constants) while they are still usable from code and tests without adding something like this project into the mix... Of course, you could use them for code generation and generate those constants. It seems like the author was just going after the syntax highlighting features of markdown code blocks.
Great! That's a good practice project.
It can't. OP likely meant a write to a nil map. In fact, it looks like fmt.Println can never panic. The documentation says: &gt; If an Error or String method triggers a panic when called by a print routine, the fmt package reformats the error message from the panic, decorating it with an indication that it came through the fmt package.
I'm afraid you'd have to elaborate (assuming your comment intends to be informative at all?)
v
Went briefly through the docs and I like it. The flow quite similar to what I have in mind except for the dependence on inventory. Maybe there's could be a light mode, where the build can be pushed straight into target without the need of inventory. Our current deploy script for example just produce the tarball on the fly before pushing it into target deployment.
Not a fan of the oauth2 library to be honest. Names like `health.ServiceInterface` aren't very idiomatic, and suggest that the interface has been made solely for the sake of there being an interface. Bear in mind, you can make an interface for the methods you use on a concretion _where you use it_. That's one of the most powerful aspects of Go's type system. It avoids these naming smells too.
I think a lot of people just don't develop in a Docker container. If you are really set on doing it, I'd look into mounting your code in a running container as a volume, and using some kind of file-watcher that triggers a rebuild and a restart of a process, otherwise you're going to be hampering your productivity. Have tests, run them in your Docker container when you build it, and then otherwise develop locally is what I'd recommend. Unless of course you're testing something that's Linux-specific and you work on a Mac say, then I'd go with what I said in the paragraph above. People may argue that that would be doing it "wrong" because you wouldn't be using the same image as what you'd use in production. I try to find a balance. Get as close as possible without impacting productivity. So, if possible, I'd use the same base image, same Go version, etc. and the rest would be "close enough" whilst remaining a productive environment to work in.
Gosh... metacasts you are right. that answers the question. My bad... i don't know how i missed it. Thanks for your answer. Thank you peterbourgon as well!
&gt; If you read a lot of Go, you get good at reading Go. &gt; If you write a lot of Go, you'll bet better at writing Go. Kind of true, but not the whole picture imho: When you are coding you naturally develop certain patterns to do certain things. Over time, you stop thinking about these patterns because you get used to them become like muscel memory. But maybe there are other, smarter ways of doing things you may never have thought of, which you'll have to discover in other ways then just writing more of the same style of cid. This connection is missing in your statements.
Ok, I'll start there. Mabe it really is the best to just start looking at code, where I know what it does, but probably not how.
[removed]
Thanks. I'll give this a read in the morning!
Depending on what your definition of "efficiently" means: b := new(bytes.Buffer) b.Write([]byte("string")) Or: a := make([]string) a = append(a, "string") strings.Join(a, " ") Or: c := "string" c += "another string" 
[removed]
&gt; I'm pretty sure that you wouldn't use markdown to keep your production queries in the thing was done to enforce structure on markdown in order to use it as a storage for "production" queries
[removed]
That will hopefully mute the JS fanboys for a while. For that I thank you, Go community !
Was posted a few month back here. https://github.com/drosseau/degob
&gt; aren’t simply viewed as the actions of an individual Way off topic but the irony is too thick to ignore. You realize that this is the experience of every minority in daily life dont you? Try being a black male in tech, or in college or at the park or at the local bar. Hell a pickup softball game even. Your every action must be above reproach. Heck, things have dramatically improved in the last few years but the stuff I’ve seen female colleagues have to deal with as developers is truly shameful. 
Hey there, one of the authors here. Yeah that makes sense. You can actually use Escape without the inventory and use `escape run release --skip-push` to just package it up. You'll lose the power to auto version and pull dependencies from the Inventory, but it is doable. We're looking for improvements in this area so feel free to raise an issue on our repo. Thanks for the feedback!
This is terrible. It expects you to use the go docker images as a base for your pod. Never use this tool.
Or this: https://github.com/flosch/pongo2 Django-syntax like template-engine for Go, bearing in mind Twig was based on Django's template syntax too, and Pongo2 is a bit more battle tested.
Maybe leave some nicer feedback, everyone is at different levels and experiences. A polite explanation as to why something is a bad idea is more productive for everyone and calling something 'terrible'. 
My second paragraph explains my realization of exactly what you typed. I'm still not 100% convinced, but I am a fan of this experiment.
I don't disagree. I'm not sure the package currently adds enough value without additional development, but I think the thought experiment has potential to lead to something good. I'm not sure yet if the use cases are common or not. I think one very good use case would be an application with and embedded scripting language for defining certain types of actions. The default logic for "save document" might back up the document to all the registered block storage resources. This script should probably be in source control. However, the business using the product might decide that only documents with metadata tagging the document as "critical" should be saved in multiple places. This shouldn't be compiled as a constant in that case. That said, I'm not convinced that storing this type of information in Markdown is better than flatfiles or a database. If you want to generate documents or display it with syntax highlighting somewhere, the implementation of such a feature is probably trivial enough that you don't need to go through having Markdown as a storage medium. BUT... it's creative thoughts like this that might lead to better linking of tests, docs, and app code.
Yeah, basically, yes. It worked out for me great for many years. Being clear that I'm not rude nor "dry" when speaking to anyone. If someone feel comfortable with sharing things with me, I'll not judge them. I however, refrain from doing so, doing only when necessary, like "family member is sick, will have to be absent for some time to take care of that." This is the same reason I don't have facebook, twitter, and other social networks where people usually overshare personal info.
What is it then? Because from what I saw so far, he is a damm good C coder (just take a look on his GPS module code for instance), who works alone and don't care about exposing his opinions on his own blog (like so many professionals everywhere this days). The problem with his opinions is that a lot of people disagree with them, but if that is the point, well don't hire him as an opinion writer or journalist, keep it as a C coder.
If you use dep, there's no need to switch GOPATH between projects, because all your dependencies' code is in the vendor subdirectory. There's never a reason to touch GOROOT unless you're developing Go itself and have multiple versions installed.
This blog post maybe help: [Code to Read When Learning Go](https://www.somethingsimilar.com/2013/12/26/code-to-read-when-learning-go/)
In your linear solution you have to sort your input first. Could it be that this makes the benchmark slower? Just a guess after a peek, as I can't try it out right now at work.
No need to `mkdir`. [From the docs](https://docs.docker.com/engine/reference/builder/#workdir): &gt; If the `WORKDIR` doesn’t exist, it will be created even if it’s not used in any subsequent `Dockerfile` instruction. 
I didn't look too long (5 minutes or so) but it looks like you've swapped the Linear and Binary Search implementations.
Algorithmic complexity begins to matter when n is very large. In many cases, especially when n is small, a simpler solution with less overhead can be much faster. I notice your benchmarks are only using a slice of 50k items. This makes your n 50k. Try increasing n substantially. There will likely be a value of n when the less algorithmic complexity solution is faster. 
This is perfect. Thank you! 
You're right, I was misinterpreting the person I responded to as referring to, essentially, having a REPL or being able to hotswap code. I didn't connect real time programming == real time computing
This is a great perspective that I hadn't thought of. Thank you for your insight.
Get to know some female hackers in the circles he moves in and you'll hear the stories about what people object to. They're not my stories to tell.
I mean, my projects usually deal with small components like small services, lite servers for specific tasks, etc, that eventually join up to make up a larger system. At most I ever work with a few services at a time to see how they interact. The rest of the work of testing is done in an staging environment. 
Possibly, but the link in OP suggests it should be faster; &gt; We can use sorting to solve it in lesser time complexity. We can sort the array in O(nLogn) time. Once the array is sorted, then all we need to do is a linear scan of the array. So this approach takes O(nLogn + n) time which is O(nLogn). Maybe I am just using too small arrays to notice, as /u/ImLopshire noticed
I’ve seen the comments above. A good use case would be single-query microservices which you wouldn’t need additional logic or recompilation, just a reload. I agree it’s interesting just not for the monolitic fat app, maybe...
First, your implementation contains many errors. I fixed the most obvious ones. Your "BinarySearch" is essentially the "naive" algorithm? For n = 25000000 BenchmarkSolutionLinear-4 1 19230408500 ns/op BenchmarkSolutionHashing-4 1 14998439500 ns/op BenchmarkSolutionNaive-4 1 11039920000 ns/op Results might be a bit off because of potential thermal throttling. I'd assume that for some larger n Hashing might be faster. However, it seems that the Naive algorithm works best for most cases here. Unless there's another unspotted bug or performance improvement possible within the respective algorithms. https://play.golang.org/p/P9g58_VNYt
Can you explain your point about "making an interface for the methods on a concretion", please? I don't understand. Thanks!
&gt; I notice your benchmarks are only using a slice of 50k items. This makes your n 50k. Try increasing n substantially. There will likely be a value of n when the less algorithmic complexity solution is faster. I increased them to 5 million, still seeing the same pattern: $ go test -bench=. -benchtime=30s BenchmarkSolutionLinear-8 100 411649700 ns/op BenchmarkSolutionHashing-8 10000 3728741 ns/op BenchmarkSolutionBinarySearch-8 20000 3070626 ns/op 
You're probably right, I am fumbling here :-) That said, I tried following the descriptions from [1] for binary search: &gt; search all positive integers, starting from 1 in the given array. We may have to search at most n+1 numbers in the given array. So this solution takes O(n^2) in worst case. which i tried to implement in SolutionBinarySearch(), and linear: &gt; We can sort the array in O(nLogn) time. Once the array is sorted, then all we need to do is a linear scan of the array. So this approach takes O(nLogn + n) time which is O(nLogn). which I tried to implement in SolutionLinear() 1: http://www.geeksforgeeks.org/find-the-smallest-positive-number-missing-from-an-unsorted-array/
Fatih recently gave a talk about how Digital Ocean manages a monorepo of mostly Go packages. He mentions that they wrote a tool in house to solve this, however I don’t believe they have released it as open source (yet). The general idea is for your build/test tool to run against only packages which have been modified in the current change set. The only real trick is to recursively check any of your own internal or “common” packages that your modified packages import. https://speakerdeck.com/farslan/go-at-digitalocean
A few possibilities: - You have infrastructure already in place for deploying docker containers regardless of the underlying technology. - Docker is generally easier for some people. Running multiple instances of things without making systemd unit files for each one can be appealing. Mapping network ports, service registration/discovery, and monitoring, are sometimes nicer with the docker management layer coordinating things. - Building in a docker container removes need to install go directly on build server. This allows different applications to choose which version of the go compiler they target, and there is no worry of conflict / upgrade timing issues, etc. I think you kinda hit on a big point this kind of article makes though. We don't need to build very much on top of a go binary at all. There is no point in adding all of the OS libs and things, since the binary is (mostly) static. I see a scratch image like this mostly as an adapter shim to let you use go binaries with other docker infrastructure. 
Fun story about upx: I started using it to compress binaries that we were including in a git repo (don't ask, is made sense at the time). Turns out compressing the binary made it harder for git to pack it into the repo, and my repository size *increased* as a result of doing my own binary compression. I'm not sure what my point is in this context, other than "are you sure it is worth it for a marginal gain that may or may not be mitigated in other ways?"
I take the other stance on this. I have written dozens of apps that use the githib api. Every single one of those has the same ~15 lines of faked up http.Transport hackery to make a client suitable for use with a given access token. It is getting old. I agree that accepting the http.Client is the most flexible way for sure. By all means, provide that. But please please please provide a `NewClientWithAuthToken` in addition to save your users from having to dance with low level stdlib stuff to use your ting.
I'm not sure if this is 100% true, but a brief stab at the command line says Go building is deterministic. Therefore, it should suffice only to test executables whose hashes have changed. It is still possible for executables to change even if they haven't been "changed", because Go IIRC does no dead code removal, so if you have a module that adds a constant that some executable ends up not using, it will still change the hash of the new executable. At this point, though, you start getting into some pretty philosophical questions about what exactly is worth QA'ing. If certain pieces of certain modules are changing a lot, but only some executables need them, you could break them up.
The standard library is excellent. To read it sanely, use golang.org/pkg and click functions to jump to the source. You can also use godoc.org/github.com/pkg/sftp etc.
I believe then naming convention comes from build constraints defined here. https://golang.org/pkg/go/build/ As such, you would have to have another file which holds the fallback code in go with build tags which exclude all platforms for which there is a special implementation in another file. This prevent multiple define of the same function. 
Given that this is an exercise for yourself, you may not care about this, but you have no README.md and the [godoc](https://godoc.org/github.com/Juici/cli) is quite unhelpful for getting started. If I were a coworker I would have no entry point into your library.
If you are running a monolithic application you don't need a container but if you are building microservices you need to build them in containers. Then push them in a orchestrator like Kubernetes, Docker Compose, RancherOS, OpenShift, ... You can start developing/building the microservice in your computer (not in a container) but eventually it has to go in a container. Some pages that may be useful: https://nordicapis.com/writing-microservices-in-go/ http://callistaenterprise.se/blogg/teknik/2017/02/17/go-blog-series-part1/ And I recommend this book: https://www.amazon.com/Building-Microservices-Go-Nic-Jackson/dp/1786468662 
Wow, thanks for sharing, it makes sense and I never thought about it in that way. I think you still can use `upx` for containers, considering the binary (container or go binary) won't be pushed to GitHub. Your makefile can build the container and push it to Docker Hub.
17 minutes, 17 points. Lol
About the O() notation, the math may become clearer when looking at the related function plots for n^2, log(n), 2^n, etc. [Here](https://appliedgo.net/big-o/) is a blog post I wrote about this a while ago.
The Go compiler does dead code removal.
Have you tried how go tip/master/trunk performs for you? Because the [new cache in Go 1.10](https://tip.golang.org/doc/go1.10#build) may help your use case.
That's for if you pass a random object that has the String() method. If String() panics then println will NOT. There's no protection against `println(s o.String())`, only `println(o)`
I think it's a mistake to disregard the benefit of reading quality code for learning to write quality code. Just as great writers of prose tend to be great readers, we learn not only by doing, but by example - this is why examples are such a huge part of any programming tutorial, API documentation, or other learning resource. Writing Go code in a vacuum, without reading others' code, will not get you the kind of well-rounded exposure you need to be highly effective, nor will it help you to learn Go idioms and best practices. It's important to *both read and write* code to learn well.
Exposing an object, rather than just functions, gives users of an API the opportunity to stub/mock it in their tests, though. It doesn't hurt to expose both.
Thank you for the link!
&gt; Your "BinarySearch" is essentially the "naive" algorithm? Yes. I guess this means I don't know what a binary search is! Very interesting profiling results. PS, you can increase the time the benchmark is run with `-benchtime=30s` or something, to get more accurate results with long running benchmarks. The default is 1 second. I'll have a look at your version, I am very curious of all them errors I made :-) Thank you so much for your detailed feedback!
There are a number of problems I see: First, you're generating a test set that doesn't contain any negative numbers because rand.Int returns non-negative values. Having them in would very drastically affect the performance of the naive solution, so that benchmark is artificially sped up with your current benchmarking code. Second, you're not actually handling the problem description correctly in some of your solutions. It specifies that negative numbers can be present in the array, but for example SolutionLinear will always return 1 on any array containing a negative number, whether or not 1 is present. This will make it artificially slightly faster once your test set contains negative numbers, although it would still be nLogn due to the sorting happening first. Third, you are handling the problem description incorrectly in another way by capping the values you search for i at 1 million in SolutionBinarySearch and SolutionHashing. This makes SolutionBinarySearch artificially fast at n&gt;1000000 because its complexity caps at 1000000*n rather than n squared. So I think most of the discrepancy you're seeing is a discrepancy in what you thought you were testing vs what you were actually testing.
A more updated version (fixed/improved the way benchmarks are done): https://play.golang.org/p/Yym9hqQLW7
You can also use gotools.org to view the entire package on one page, with Jump To Identifier functionality. E.g., https://gotools.org/encoding/json#Decoder.Decode.
Your test set generation, while improved from the way OP was doing it, doesn't insert any negative numbers. This artificially boosts the naive solution
This isn't so much Go, as general software engineering, I think. If you have a repository where anything can change, and any change could affect any of your potential builds and tools in that repository... then you're in a situation where any change could break anything, and need to respond accordingly. If you don't have automated tests you can trust to cover things it can be very painful. This is a push model, where anyone can submit a change that's effectively "pushed" to all projects instantly. It means that everything can be updated "atomically" (assuming simultaneous deployment), but it also means that you're fragile to breakage from people outside of your team. You might be able to do a bit better with https://dave.cheney.net/2014/09/14/go-list-your-swiss-army-knife by listing dependencies for each executable and comparing against the change-set. A "pull" model is where each tool is isolated, and only decides to get changes when they're valuable. You control and pin your dependencies to avoid unexpected change and breakage, but you can't assume that a change to a library will propagate, and have to isolate assumptions and version to control for that. It's also more work, because you have to coordinate and convince teams to pull updates. I've worked in a large version of a mono-repository with multiple teams and some shared "util" libraries that made this a nightmare. Things breaking left right and center because people picked up functionality they found and used it, others who didn't know who was using it changed stuff. If you want safety, and don't have great automated test coverage, I'd really suggest managing your dependencies. If you have something where every tool always needs to be updated simultaneously because of changes to it, it can be a real red-flag.
Sure thing. Let's say you're using a struct from a library in some of your own functions / methods, then you can create an interface that only contains the methods that you use on that type, where you use that type: https://play.golang.org/p/ZkPuJd6Xdm (More [info here](https://github.com/golang/go/wiki/CodeReviewComments#interfaces)) Despite what it does say in that link above, this can be useful can whilst testing, because if you only use a couple of methods from something that actually has say 10 methods, you can make an interface with those couple of methods instead, allowing you to mock those 2 methods for a test instead of 10. These kinds of interfaces can be trickier to name though, because they aren't full implementations of the type you're trying to mock. Sometimes, this isn't always possible though. Some libraries will expect you to pass around an interface they give you because they want you to be able to implement some functionality that plugs into their library. In which case, if they give you both an interface _and_ a concretion for that interface, then there must be some purpose for that concretion's existence (i.e. the interface should be _a thing_, then the type should be _a specialised thing_), or alternatively; the concretion should not be exported, and the interface should be all that is exported, and any constructors for it should return that interface as the type ([see here](https://golang.org/doc/effective_go.html#generality)). This still leaves you able to implement custom versions of that interface, without giving you naming headaches.
Negative numbers have no effect and do not favor the *naive* solution (just tested it to verified it). More important is the density of the slice, i.e., how many iterations **k** are required. Thus, it highly depends on the input. Is it sparse? -&gt; *naive* Is it dense? -&gt; *hashing*. Using random numbers as done by OP will most likely favor *naive*.
I'd consider keeping the code out of the infra repo and using a Makefile to curl down a binary. I do this sort of thing to download a tool I wrote called withenv that helps manage runtime configuration (https://github.com/ionrock/we). PATH=./bin/;$PATH withenv: ifeq (, $(shell which we)) get_withenv.sh endif run: withenv we -e env.yml foo In your case, you'd just need an artifact repository of sorts that you can pull from. Docker does provide one mechanism for this as well, but sometimes it can be tricky depending on what you need to do. For example, if you're automating terraform and ansible, it might be difficult to normalize how your configuring your ssh config or any credentials terraform needs. In your docker container. At the same time, you do get to avoid worrying about different operating systems, assuming your team all use docker reasonably well. 
Correct! But that’s not special to `fmt.Println`. The program would panic evaluating `o.String()` before `fmt.Println` is even called. Calling`foo(o.String())`, for some arbitrary function foo, would panic as well. But _once_ fmt.Println has been called after successfully evaluating the arguments, it won’t panic. 
This is obviously written with sarcasm, but it's everywhere to the point that I can't make out what the author actually thinks about anything they're writing
&gt; Edit: Also, go has a map type which is basically a hash table already. You'd probably see better performance out of the hashing solution as well as not having to allocate a specific size up front by switching to using that rather than using a slice. Did try this initially, using map[int]bool, but it was considerably slower than the solution used in the OP.
Yup :) 
Did another test regarding using map. It seems to be much slower: BenchmarkSolutionHashing-8 300 3999395 ns/op BenchmarkSolutionHashingMap-8 2 851445038 ns/op Where SolutionHashingMap() is by /u/CHAOSFISCH // uses hasing, O(n) func SolutionHashing(A []int) int { hash := make([]bool, 1000000) for _, val := range A { if val &gt; 0 &amp;&amp; val &lt; 100000 { hash[val] = true } } for i := 1; i &lt; len(A)+1; i++ { if !hash[i] { return i } } return len(A) + 1 } // uses hasing, O(n), with map func SolutionHashingMap(A []int) int { var a struct{} hash := make(map[int]struct{}, len(A)) for _, val := range A { hash[val] = a } for i := 1; i &lt; len(A)+1; i++ { if _, ok := hash[i]; !ok { return i } } return len(A) + 1 }
Was getting worried go-llvm has died. Nice to see gollvm. 
The gofrontend apparently still has GC issues as said in README here (https://github.com/golang/gofrontend/tree/master/go). Based on this quite simplistic benchmark (https://github.com/slimsag/cgo-batching/blob/master/batched.go), gccgo (v1.8 from GCC7) is 6 times slower than gc (v1.9) in executing Go code but is twice as fast in executing C code (cuz GCC).
Well, sure the solution you propose using a fixed size *[]bool* is faster. To some extent you're cheating. My solutions work for all numbers *MinInt64* to *MaxInt64*. You're limiting it to 100000.
No matter what Lennart says, Linux != D-BUS.
So pretty much equivalent to javascript promises? 
&gt; PS &gt; If you made it all the way to the end and didn’t realize this was written with intentional sarcasm… ¯\_(ツ)_/¯
&gt; This is obviously written with sarcasm
I don't know too much about JS promises, but if they behave like a Try, I feel sorry for JS developers.
Just as an example, you can continue this chain. promise.then(function(val) { console.log(val); // 1 return val + 2; }).then(function(val) { console.log(val); // 3 })
Oh, equivalent as in they are composable. In that way, yes. The difference with Promise/Future values is that they represent a computation that has likely not yet happened. So functions called on them are deferred (not executed within the current context). Try's are not asynchronous and execute within the same context. But yeah, when you get into this functional style, the pattern for how things are used is/can-look very similar. I actually have a detailed post on building Futures/Promises from scratch if you're curious: http://www.johnmurray.io/log/2017/06/22/The-Futures-Abstraction.html.
\\?
&gt; gofrontend What's that?
It takes a little bit, the learning curve appears steep at first glance, but just give yourself 3 solid months to tinker around with interfaces, structs, channels and goroutines. It's not as arduous as it may look right now. Tons of amazing examples online via the usual methods. The hardest thing IMHO was changing my workflow habits in regards to having a gopath setup, but it's not to be confused with python's virtualenv; in fact most of the heavy lifting is done by some of my vim plugins (including running go-fmt on save *swoon*). Google created the language, along with Ken Thompson as one of the co-creators. Seriously, your resume and the time you'll save will thank you in the long run. My $0.02USD.
&gt; There's never a reason to touch GOROOT... You're forgetting when one develops services written against multiple versions of Go. Ideally, we'd all run the latest and greatest, but we can't pivot Go versions on a dime...
&gt; When you are coding you naturally develop certain patterns... Process? Design patterns? Architecture? There are names for these concepts, all of which are orthogonal to the language in which one programs. There's no need to connect the language to the concept, unless that's the only way one can learn...
Go has a linker, so functions that are trivially not used will normally not appear in the final executable and thus it won't change if they do. Dead code within functions is more subtle; change in line numbers and so forth may still alter the final executable even if the actual instructions haven't. That sort of thing is unlikely to be your biggest concern in CI though (if it is, you're doing pretty well...).
But each binary should know where its own root is, no? I thought that was baked into the build. 
You joke, but this actually kind of similar to a pattern suggested in [a Go Blog post about errors from a while back](https://blog.golang.org/errors-are-values). You've attempted to generecize it a bit, though, and in so doing you've kind of destroyed it.
True. The 100k limit is enforced by https://codility.com/demo/take-sample-test/, not the description posted in OP.
Yeahbut, this isn't 1998. Most everything *is* UTF8. Maybe if you're parsing random text documents from godknowswhat, then things might not be utf8. I haven't ever seen or heard an encoding problem in 5 years of writing go 40 hours a week.
Huh? A binary doesn't need a root.
GO_ROOT is baked into `go` AFAIK. 
The "nsnitch" feature is also at https://www.mapper.ntppool.org/ -- https://www.mapper.ntppool.org/json (code at https://github.com/devel/dnsmapper ) 
This is generally the format I will use when writing a backend in Go, optionally with some logging for unexpected errors. What do you guys think? I'd love some feedback, thanks!
I don't have the time this evening for a fair look at code quality, so while I understand that this was an exercise to learn (good work!), I will give a stricter response based upon how I'd reply to a utility meant for use by others... While you have tests and short comments for use in Godoc, I tend to not look at libraries that don't have a README stating the minimum how to install, the basic use (in this case, why it is better or different than the standard library on one end of the spectrum and cobra on the other). I tend to mention the license choice in the README with a pointer to LICENSE.txt, but that is not as universal. A simple usage example is good too. That last part might also refer the user to the examples / samples / demos folder for a larger range of examples.
Actually I would love to have support for this sort of pattern in go.
According to the readme, it's sample Dockerfile using go base image, and you can add one as you wish.
It is a compiler agnostic framework(?) to parse Go source code into object representation for the compiler to compile against, initially written only for GCC, now as per the link by /u/mewkiz, the first link uses this frontend for LLVM too.
How does it work? It parses into a GCC and LLVM AST?
You can write the fallback in Go, then use build tags to not build that particular go file on platforms that you've implemented it in asm on.
It is never wrong to feel sorry for JavaScript developers. It's a tragedy such a language ended up being so ubiquitous.
You're right. I was on the train and saw this and wanted to make sure everyone knew they should not use this tool. Let me clarify. 1. A k8s deployment template is trivial. 1. The tool is poorly written; it fills in a name and port into a pre-defined in code kubernetes deployment template, but does not use templating; instead uses printf. 1. The example dockerfile is terrible for a couple reasons; dont include the go runtime into an image you are going to run, no need to install since `go build` installs things for you 1. It does nothing to simplify anything, and if anything makes things MORE complex by obfuscation. 1. It has been created by someone who clearly has very little experience with kubernetes, go, or distributed systems. 1. It was posted here either for feedback or for promotion. Bad projects should be labeled as such otherwise those without experience will think they are good projects and USE them. So please DO NOT USE THIS PROJECT EVER. Everyone should experiment and learn, but we need to call things out as we see them or others will think this is the right way to do things. I have yet to see anyone else provide any feedback on this project here, and I think that is telling. 
Cayley author here: significantly faster is a misnomer; it's mostly based on your choice of backend. The dgraph benchmarks are.... tainted to say the least. Happy to help in Slack or Discourse!
This is clean and well done. I would recommend breaking your “app logic” (ie. create todo, etc...) into separate reusable functions. Then have your http handlers call the app logic. That was you can 1. reuse your code if necessary 2. Have a separation between your http code and your “logic” which makes testing easier and cleaner. Would definitely recommend writing unit tests for all your app logic and also your http handlers. 
Thanks! That's a great idea! Would the "logic" part include json decoding and encoding as well and setting http headers as well as calling the store methods? I really should write some tests for the http handlers, I just dislike writing tests for http so I didn't do it. Thanks again for the feedback!
Http handlers should handle json/headers. You could write middleware to do any repetitive stuff like headers or stats reporting. My http handlers tests mock out my app logic and then check to make sure the handlers respond with the correct info given a mocked response from the app logic. Look into mockery for mocking out the database client. 
👌 will do!
I looked a little more and it seems like your store is essentially the app logic here so there isn’t much need to change much. Usually I have 3 layers: http, app, client/db. You combine the app and db layers here but I don’t think that’s a bad thing. If you separated out the app and db layers you would have 2 functions doing the same exact thing. Sometimes you will have your app createTodo function also do something else like update a cache and also create the record in the db and also send out a web socket message. Then you would want the separation. 
&gt;Way off topic but the irony is too thick to ignore. You realize that this is the experience of every minority in daily life dont you? I don't think I'm saying stereotyping of women and AA's doesn't happen, of course it does. The difference between it is when Roy Price from Amazon LA studio sexually harasses a woman you see articles like this one: &gt;[It's 2017 and Amazon only has one woman among its 18 most powerful executives](https://www.recode.net/2017/10/21/16512448/amazon-gender-diversity-leadership-executives-jeff-bezos) quote &gt;as Amazon deals with the aftermath of a sexual harassment scandal involving its now-former studio head Roy Price, new questions are being raised internally about how the company can justify having so few women in top leadership programs. With articles like that journalists openly take an individual act by one employee and paint the rest of the men in the organization with that brush. I think the difference is if a person of color did something at a company if a journalist published an article that said "It's because he's black and they should limit hiring more black people if they don't want this result" it would be considered hate speech and it would be their last day of employment. I don't care if Amazon has mostly male execs or not it's not fair to lay the blame of Roy Price's actions at the feet of the other men that work there because they happen to also be male. It's not as though Roy Price came to them and said "Is it cool if I sexually harass women?" and they were like "Sure, lets take a vote on it, looks like the majority of us are men so by extension we are cool with your harassing behavior" Tech is seen as having a "boys club" culture and the implication of such is that things like sexual harassment is acceptable behavior? That's funny because I don't remember being involved nor signing a permission slip for the behavior. I don't think it's fair to for me to be painted with the same brush simply because of my gender. So yes of course stereotyping exists for women and PoC but the difference is doing so isn't openly considered acceptable and even encouraged as it is when a white male does something. To leave you with another point take the definition of political correctness from the oxford english dictionary: &gt;The avoidance of forms of expression or action that are perceived to exclude, marginalize, or insult **groups of people who are socially disadvantaged or discriminated against**. So it's easy to discard my views as paranoid rambling but there is an exception in the **dictionary** permitting such behavior to be carried out against people who are not considered disadvantaged. And of course "people who are not considered disadvantaged" has nothing to do with my upbringing or history in this world but rather it's based on my skin color and gender. Rather than a blanket rule against racism and sexism there are exceptions made when that person isn't considered a member of a disadvantaged group. I'm not saying that racism and sexism towards others doesn't exist and isn't also a problem I'm simply pointing out that when it happens it isn't openly considered acceptable.
Yup, I totally get why that seperation is helpful, for example before I used patchTodo I was getting the Todo and updating the fields, which I could easily do because of separation.
Do you mind if I use this as base for my future projects?
Don't mind at all! Feel free to use and mess around with it, and if you notice something that could be done better feel free to send a PR or create an issue!
Y U No tests?
I don't know "exactly" how they work. Have a look at the frontend's and llvm-go's READMEs as they try to explain it at a top level. 
Someone posted about this not long ago, and I agree with [their suggestions for a directory structure](https://www.reddit.com/r/golang/comments/7e5xuk/the_golang_project_directory_structure/) a lot more. Usually I do something similar with regards to directories: cmd/ todo/ main.go internal/ handlers/ ... store/ postgres/ ... vendor/ ... Using the `cmd/` folder allows you to have multiple binaries for one project. It's not always necessary, but it's a nice convention to use because it can show up in other projects. `internal/` is _very_ nice, I've found, because it helps to keep your GOPATH free from noise. IDEs like IntelliJ, or tools like `goimports` like to try pull in things from packages with the same name. Meaning if you have a bunch of similarly named packages and functions across projects (which can definitely happen very easily if you're working on things like microservices, where you will copy and paste little bits of code, or just happen to name things the same) then you can end up with the wrong import name being added, and it's sometimes difficult to notice this happen, because at times your code can still work! `internal/` also has some semantic meaning, i.e. that the code in there is specific to the application, not to be shared or exposed with the rest of your GOPATH. Other common folders: * `examples/`: More useful for libraries. Runnable examples, maybe your examples span multiple files. * `pkg/`: Maybe your application has something that can be shared amongst other code? Maybe it should be a separate library then, but maybe not in some cases. * `scripts/`: Bash scripts and the like. As others have mentioned, testing is important too. Also, it's not as necessary with Go, but I try to always have an `.editorconfig` file in any project I work on personally. It can help with the consistency of your non-Go code.
I do not like way you're doing migrations(todoTableCreationQuery), i would use independent package for migrations, like [migrate](https://github.com/mattes/migrate) or [sqlmigrate](https://github.com/rubenv/sql-migrate). Camelcase in sql columns names feels weird. What's the reason for keeping date in bigint format instead of timestamp? 
Postgres package contains tests.
What I tend to do instead of `json.NewEncoder(w).Encode(response)` is provide an utility function that takes an interface, tries to resolve it to an error value and format the error message accordingly for the http response there. Here's my current version [on the go playground](https://play.golang.org/p/upwAtC5pjO), and there's the relevant article which I wrote about it: [Error handling in Go](https://scene-si.org/2017/11/13/error-handling-in-go/)
If you're interested in a similar tool see [go-bindata-assetfs](https://github.com/elazarl/go-bindata-assetfs), which works together with [go-bindata](https://github.com/jteeuwen/go-bindata).
It should be a [keyword](https://www.reddit.com/r/golang/comments/6vt3el/the_try_keyword_proofofconcept/).
Some non Go related feedback on townsourced: I go to the site and I see a signup page. It feels like with the site behind a signup wall it's hard to dig much deeper. So what is there for me to do? I click a city to dig deeper from one of the options on the front page: Charleston. I click through the topics and each category says "No posts found" OK, so during my visit I wasn't able to see any kind of demo or example of what the site has to offer and then I closed my browser and moved on. I bring this up because my user experience is probably most other people's user experience too. Maybe create a fake town with fake events so people can click it from the main page as a demo for the website? I have a billion logins to different websites. I need a really compelling reason to create another one.
When doing method bases routing in the Gorilla mux, I prefer the [Gorilla handlers](https://godoc.org/github.com/gorilla/handlers) package: router.Handle("/todo/{id}", handlers.MethodHandler{ "GET": http.HandlerFunc(s.getTodo), "PUT": http.HandlerFunc(s.putTodo), "PATCH": http.HandlerFunc(s.patchTodo), "DELETE": http.HandlerFunc(s.deleteTodo), }) I think it looks cleaner, and you get the added benefit of having unsupported methods returning `HTTP 405` as well as an extra handler for `OPTIONS` requests.
What's the intended use case for this? Why does it matter to me if a package is bundled up in a single file or not?
Looks good to me. A minor complain is the `server` package. I believe generic names such as server are not the best choice. I also think that the project uses way too many dependencies for its current scope (simple backend) but I digress. 
Any idea when Language server is coming to Windows?
Yeah, I think that on average, you'll be totally fine to assume UTF-8, and at least it won't be like the days of working out how to upgrade ascii all the way through your stack, since Go strings are unicode. But you are making an assumption, and it can bite you, and it seems only fair to ensure that people are aware of that around advice like that.
This is nice! Didn't know it exists..
I'd love to use this in https://takeoff.sh - at the moment I only ship one blueprint, with a node backend - but would love to have a Go-based blueprint too. Mostly I haven't due to time.
Yep, I appreciate the feedback. Nearly the whole site is accessible without a login, unlike sites like Pinterest. Unfortunately everything is location based and there isn't anything to look at in your location. The goal of this post wasn't to promote Townsourced and try to get more users, but if I was still chasing down funding and pushing to do something more with this site, then I'd continue seeding it with content as we released to specific areas.
That's awesome! Thanks for sharing, I'll add that asap.
I like that structure! I thought cmd was mostly only for building CLI's but it makes a lot of sense in this case too. I really should be testing more. Thanks the tips and the feedback! Will add asap.
Those packages look useful, much nicer than what I'm doing. Oh I've just seen camelcase, what is more common/better? And for bigint I just found timestamp has some issues with precision that have been annoying in other projects compared to just storing a bigint Unix timestamp. Thank you for the feedback!
That's super nice, I like how consistent it is! Will add asap. Thanks for the feedback!
The http handlers don't have tests because I'm lazy and don't like writing handler tests, but you're absolutely right that I should be. Thanks!
Use it all you want! Just be aware it might be changing as I implement these people's feedback 😂
Very good point.
That's fine, I'll probably not get around to it. If you're taking on suggestions, one thing I would suggest is maybe provide User auth + JWT out the box? :)
I could! JWT is pretty dang easy to integrate with a go project, but I don't know if it's really necessary for something as simple as this.
The problem here isn't the pattern or using monads and the like, the problem is that Go is terrible at supporting monads. If the language had generics/templates then this would be a viable pattern for people who like functional programming. Something being different doesn't make it bad.
Go could learn a few things from Ada when it comes to generic programming. You don't need templates or type erasure to implement them. Ada basically does this at compile time : type Foo struct {} type DoFoo = DoGeneric(param Foo) where do DoGeneric is declared in its own package such as generic t // t is private func DoGeneric(a t){} Go could use function overloading as well. so that type DoFoo = DoGeneric(param Foo) type DoFoo = DoGeneric(param string) is valid. It's compile time safe and I don't think anybody can argue that this is difficult to understand or unreadable. 
Don't forget to do if err := rows.Err(); err != nil { return nil, err } here https://github.com/fharding1/todo/blob/40df5b00e7e99786e0189ec8025e65d29e3e99ba/store/postgres/postgres.go#L87
Would be great to have this in golang to reduce those if err != nil verbosity and make code clearer
Also, you don't have to rows.Close() as rows.Next() will do that for you: https://golang.org/src/database/sql/sql.go?s=68445:68472#L2445
have you reported this in the user experience in golang could argue why generics are so important because it solves the err != nil fatigue problem
Sure. I personally enjoy functional-style programming. :-)
Lol. Thanks for the link, I enjoyed the read.
The UI looks pretty cool. Did you use any known JS framework to make it?
&gt;This allows the programmer to write code that describes the “happy path”, dealing with errors at the last possible moment (just like real life). …which is exactly why it's a bad thing. I want to log and deal with errors as soon as possible, not leave them for some distant piece of code to deal with.
Ah, thanks! Will add asap!
That's handy! Thanks.
Check out https://gophers.slack.com/archives/C02A3DRK6/p1511966571000770
something like that ? https://salzmann.to/2017/10/13/responsive-golang-webapp-without-javascript.html
The responses may be the same, but the ratio/number of each response will provide interesting point of comparison data. Are generics more or less desired a year later? Does delve solve the debugging issue (reducing the number of responses requesting debugging), or is the desire for debugging just as strong?
It's generics, but restricted to builtins. Similar to `make`.
Thanks. I used https://ractive.js.org/
It’s a language builtin, so the [type system](https://golang.org/src/go/types/builtins.go) is aware of its semantics and validates the calls are well formed. The compiler then implements the behavior as described in the language spec. Meaning you can not replicate the behavior because they are not normal function calls bound by the type system, but special cased throughout the entire Go tool chain.
The implementation of append is on line 77 [here](https://github.com/golang/go/blob/9c850958cea35d019142f8341beacb4151e1511b/src/go/types/builtins.go). If you do [here](https://github.com/golang/go/blob/9c850958cea35d019142f8341beacb4151e1511b/src/go/types/universe.go) you'll see how append, and the rest of the built-in functions that are in the universal scope, are declared.
What's the issue number?
[21700](https://github.com/golang/go/issues/21700)
Really nice! Another one that seems to be used less often is the [pat router](http://www.gorillatoolkit.org/pkg/pat)
That signature is from the `builtin` package, whose description states &gt; The items documented here are not actually in package builtin but their descriptions here allow godoc to present documentation for the language's special identifiers.
I guess it's tricky to figure out when to praise Go and when not to. I remember when I first got started with go and I was playing around with Beego and Revel, only to learn "Go is so great! Don't use a third-party framework for web! Use the standard lib!". As I progressed as a go dev, I also learned the mantra of "be very picky adding dependencies; this isn't node." I think we are all trying to figure out the balance of when something that is core to development should be provided by the go team itself vs a nice-to-have from the community. Personally, I wholeheartedly disagree with the suggestion that community may be full of freeloaders. That's ignorant. One thing I try to remember when developing is to do things "the go way". That's something that is always talked about in the go community. It's a benefit of the ecosystem. There usually aren't a million ways to do something or be clever in your code; there's typically a very straightforward, idiomatic go way of doing something. Hell, it's even exemplified in the go tools: go fmt formatting your code for you! Surely this feature could have been implemented by the community, but I bet there's a reason the go team provided it. I see no difference in the team owning go fmt (or any other go tool) and the go team providing a debugger/package manager. These are equally core developer features that should have a "go way" of being done. Why suddenly pawn off the effort to the community and using that as somehow justification of freeloading? The community is in no way more of a freeloader requesting this from Google, than Google would be to request it from the community. Good day.
Perhaps, but maybe all the people who wanted those features got fed up after a year of inaction and moved to TypeScript, Rust, etc.
I like it overall. Some thoughts from a quick look: - Probably unnecessary to export `server.Server`, especially since all the fields are hidden. - Several places where returned errors aren't being handled/returned, such as `json.NewEncoder(w).Encode(...)` lines. - I agree with others about splitting out the core logic into a separate package which doesn't need to know about HTTP in any way. This will make testing easier, and make it reusable as a library (e.g. if I want to plug it into a different transport, such as gRPC). - store: Nullable vs not nullable duplication is strange, any reason to not just have nullable and handle the distinction in the store driver?
1. Hmm, I get an error when I don't export it, saying that can be annoying to use. 2. I figure if I can't send a response I can't set an error code or anything, do I still need to try to handle it with setting the http status? 3. I agree! There isn't actually really any logic beyond CRUDing the todos but I would definitely do that on a more complicated one that has more logic. 4. I used nullable vs normal because in a create or anything but patchTodo all the fields are NOT NULL so they *cannot be null*, but it makes sense to have null values if we just want to update certain fields (eg. patchTodo).
Woah, you just changed my life with this. O_O
You can specify length and capacity for slices. `make([]int, 6, 2)`
make for slices *does* allow number args (`make([]int, 0, 10)`, for example). Make for map probably doesn't, and I would guess that's because hashmap size depends on the hashmap contents.
`make()` for map does allow a single integer -- it's a "capacity hint", not exactly size. See https://golang.org/ref/spec#Map_types and https://play.golang.org/p/whtLqZmaZd
If Ada were going to overtake C or C++, it would have done so already, but it failed to do so in spite of the DoD Ada mandate. I actually like Ada compared to C++, but I'd rather use Rust for a whole variety of reasons (no cruft from the 80s, no design-by-committee feel, familiar syntax, an actual community, libraries for projects that I work on, reasonable open source tools, etc, etc, etc).
Hmm, interesting. I didn't know that. Thanks for the pointer.
My point is that make([]int) and []int{} are equivalent, so why do we need the former?
My point is that make([]int) and []int{} are equivalent, so why do we need the former?
Is this tool solving a problem that people actually have?
There are lots of things that are equivalent, that are part of the language. `new(T)` and `&amp;T{}` are equivalent, for many `T`. In the most extreme, 1+1 and 2 are equivalent, so why allow constant expressions! This one in particular is so superficial it's likely not worth the cost of changing it.
go generate lines in go generate output? Eww.
Yes, they are redundant. Yes, they *could* be removed. It will likely be talked about in the context of the whole "we need fewer/more consistent ways to create values" discussion around `new`, `:=`, `var`, `make`, `&amp;T{…}`, `&amp;int{42}`,… FWIW, I usually use `make` for maps and I never create empty slices (`nil` is fine for slices).
I understand what you are saying and maybe you are a genius whose is able to find the correct abstractions and analysis right away. If you look at context driven development, even this to you universally true concepts are debated. I don't always (or probably most of the time) get the abstractions right and may accidently apply antipatterns. Maybe I am no good programmer, but I am pretty sure it is a pointless discussion. I've learned tons for my own coding style by reading code, if you can figure this out by yourself, good job. 
What are you all talking about? `make([]int)` is not valid! https://play.golang.org/p/nlKYkdCj86 ``` tmp/sandbox530749640/main.go:8:11: missing len argument to make([]int) ```
1. More of a warning than an error. It only really makes sense when you have exported fields or use the type as an input elsewhere. (golint has a lot of extraneous warnings, it's not built to be definitive) 2. I believe there are other things that can go wrong there other than not being able to send a response (namely, things with the JSON encoder). In the past, I pulled out the encoding piece into a separate helper which rendered errors and whatever else, then reused it in handlers. 3. If the purpose of the project is to serve as an example of what a good backend layout looks like, I would say it's worth updating it for the sake of other people using it as a reference. :) 4. Right, but I feel that distinction should be captured in the respective function rather than in the two different types. You're very welcome, thank you for sharing your work!
Can we have sequential tests, though?
Yes, you can.
What is your struct code? Also I am pretty sure, you can't just have to key-value-pairs by themself, you probably need at least surrounding curly braces.
How? Go is still non existant compated to js, and like literally in a lot of countries. 
What makes this so challenging that it's "hopefully" coming?
It's been merged into the core. It'll probably be in Go 1.10.
For arrays, make([]type, len[, cap]) and []type{} serve different purposes. The former allows the user to create a slice with a given length and capacity in circumstances where the contents of that slice should just be the zero value for that type. The latter allows the user to specify what's in the slice.
Here is an example reading in the JSON output you pasted: https://play.golang.org/p/HPTW9PuFl0 Depends on what your input data is though.
You can use [this site](https://mholt.github.io/json-to-go/) to generate a quick and dirty struct for Go from JSON input: { "nodes":[ { "id":"1.1.1.1" }, { "id":"2.2.2.2" } ], "links":[ { "source":"1.1.1.1", "destination":"2.2.2.2" } ] } type AutoGenerated struct { Nodes []struct { ID string `json:"id"` } `json:"nodes"` Links []struct { Source string `json:"source"` Destination string `json:"destination"` } `json:"links"` }
1. Ah alright, will update to not be exported! 2. Oh that makes sense. Having a helper for sending the response and an error if that goes wrong seems like it could be useful. 3. Can't argue with that. 4. I'm trying to make the user (well, user of the package at least) think about what fields need to be set though, for example I don't want the user to be able to leave a field null if it shouldn't be left null. I think it could be useful to deal with it in the respective function, or at least simpler since there is only one todo, but then the person might think that it's okay to leave a field nil.
4. Right, I understand, but I'm not sure it has the desired effect and it comes with a cost of having 2 copies of each struct which is also confusing and an opportunity for bugs to creep up from inconsistencies. For one, you can encode some of that metadata (whether it's nullable) in a struct tag (like json metadata), if the goal is to provide in-line documentation. Additionally, you're not really stopping the user from creating instances of the struct with empty fields either way. t1 := Todo{} t2 := NullableTodo{} Only difference is that one ends up with a zero-value and the other ends up with a nil pointer. There is nothing statically stopping you from not setting any values. Either way, you'll only find out what you did wrong when the function you're calling returns an error.
I guess I was wrong when I thought it would mute JS fanboys.
It's not very likely to happen, but I made it to fix a real-life occurrence of the problem. It typically happens when you have code like: import fe "frontend" func A(s fe.Server) {} and you add something like: func B(c frontend.Client) {} and your IDE/goimports adds unnamed `"frontend"` as an import.
In a vrey roundabout way, yes.
Looking at the `Todo` and `NullableTodo` structs in your `store` package, it feels wrong/out of place to define your JSON serialization tags there since that functionality is only really pertinent to the HTTP handler layer. What if you had a versioned API where the Todo JSON structure had to change, but also had to use the same store? I'd recommend defining some DTO (https://en.wikipedia.org/wiki/Data_transfer_object) structs in your controller layer that you can convert to/from your storage layer object.
Thank you all for replying. Very helpful!
You can run sequential tests with t.Run right now already. And the new flag will respect that too. Are you asking something else?
Create a struct as follows type Node struct { ID string `json:"id"` } type Link struct { Source string `json:"source"` Destination string `json:"destination"` } type Device struct { Links []Link `json:"links"` } Next populate it and when done convert it to JSON as follows : data := &amp;Device{} data.Source = append(data.Source, ......) data.Links = append(data.Links, ......) jsonBytes, err := json.MarshalIndent(data, "", " ") // nice formatting fmt.Printf("%s\r\n", string(jsonBytes)) Cheers 
One question, so what is the "logic"? Isn't the logic really just the the store methods? I could see there being more logic in a more complicated project that would require you to separate the handlers from the logic, but is it necessary in this small of a project? Thanks!
make([]int) isn't valid in Go, at first place : https://play.golang.org/p/pN34851u9S What the hell are you talking about? 
Keep the rows.Close() in case the scan fails. The sql package's Query example also has it. See https://golang.org/pkg/database/sql/#example_DB_Query
However, if the Scan call fails, then the rows will not be closed if he does not defer rows.Close().
because the former allows you to specify a length, and also a capacity for the slice if you'd like. this helps in the hot loop to prevent a lot of array allocation and copying to grow a slice when you know the capacity of the slice ahead of time.
Should be the default behavior.
That makes sense to me, I will implement that! I can also just replace NullableTodo with that.
My bad. Odd, when I started to write tests I googled for something like this for a long time only to fail miserably. Thanks for pointing out I'm mistaken. 
The syntax I gave is exact. I didn’t leave out any len or cap arguments by mistake. You can call make with just a slice or map type and no other argument, and it will return a new instance. That’s also what their composite literals (`T{}`) do. They appear to be equivalent, so why have both?
The syntax I gave is exact, except for the title. I didn’t leave out any len or cap arguments by mistake. You can call make with just a slice or map type and no other argument, and it will return a new instance. That’s also what their composite literals (`T{}`) do. They appear to be equivalent, so why have both?
Oops, you’re right! I must have been thinking of just maps then.
Nice work. I'm sort of surprised they allowed it, to be honest.
This is the right answer. 
Why? Encountering a test failure is no indication that subsequent tests will fail. At least you know exactly which test(s) are failing and which one(s) are not, at the end of test execution. I think the "keep going" approach is best; especially in table driven tests. I'm super thankful of subtests for letting people write t.Fatal() without affecting subsequent tests. 
what？ 
&gt; Is there a summary of this or do I just have to accept the 17 minutes of life I won’t get back because writing a few sentences is too hard? The draw of the video is that question, yes, but the point of the video is to learn about how you'd go about answering that question. I'm sure you have the dexterity to seek to the end of the video, if you're only interested in the answer.
I second this. What are we meant to be looking at here?
People who say this have never taken the time to figure out other ways of error handling in Go, all energy seems to go into to begging for the familliar pattern of exception handling (closely seconded by whining about generics). Go provides other ways of handling errors that is less repetitive, but I (and I would hope many others) see that the simple approach to error handling in Go is pretty neat; most notably because it's easy to see exactly where errors occur and how they are handled. Go is verbose in its handling of errors, yes; but it more than makes up for by being terse in other aspects compared to many other languages.
Hmm, `make([]int)` is not a valid initialization. Could you explain more furthur?
It seems pretty self explanatory to me. Did you read the readme?
Even with maps, you can do different things with each. The `make` initializer can take a "capacity hint" which allows the user to give the runtime some idea of how big the map will be for what I assume are performance reasons. The map[type][type]{} initializer can take in initial values to fill the map with. To be fair, the difference is less compelling here than with slices. I actually didn't know about the capacity hint thing until someone in another comment pointed it out.
As someone who uses aliases a bunch, I think this is really cool!
Most definitely should not
Kinda. Yes, errors should be handled as close to source but littering code with `if err != nil {return nil, err)` isn't exactly pretty. something like try err { s, err := configLoad() c, err := getDbConnection(s) r, err := queryForData(c) return r, nil } else { return nil, err } would be pretty readable *AND* handle errors as close as possible (directly after failure) but it would require a bunch of magic (adding a check for `err` value in every assignment inside try block) from the compiler and the nice thing about Go is that there isn't much of unobvious "magic"
I apologise. I'm on mobile, and the readme shows as a single line. I didn't realise it expanded, so it made no sense to me. Visiting their website didn't provide any clarity. I understand now.
Nice, ill have to try it out 
My point, though, is that the map capacity parameter is optional. Why is it optional, when composite literals do the same thing (construct without an initial capacity)? Why not require the parameter so there aren’t multiple ways to do the same thing?
I misremembered, it’s only map types that I should be asking about, not slices. Sorry. The same question still stands for maps.
👍🏻
Yea, and I told you why. You must be a big stoopid fanboi yourself to come up with that. Np, it will pass
Try this one: https://play.golang.org/p/qKD7LDSveG Just be careful to not name your property names with lowercase. That makes them private and the json package can't access them to extract their values.
+1 to this. It does all the work you'd need it to.
If you really want an answer to this, you should ask on [golang-nuts](https://groups.google.com/forum/#!forum/golang-nuts) if you haven't already.
No,you.
True, same stands for other test suites like phpunit which has: --stop-on-error Stop execution upon first error. If you're aiming for code coverage and the like, you'd likely want to finish all tests, because the code coverage reports wouldn't be reliable anymore if you'd stop the testing on the first error.
js or go?
Go brings interesting stuff IMO. And JS is quite nice for quick and dirty stuff. So what's not laughing material to you ?
Java, C, C#, Python. &gt; Go brings interesting stuff IMO. Literally the most boring and basic (more basic than... Visual Basic) language 🤔🤔🤔
Just looked at this again now - your handlers do look clean and free of business logic. It's looking nice! Your handlers are small enough to pull off being attached to the same type. I'd still personally split the routing off from that though, but even then, this is a small application, and that's an easy refactor. Nice one.
I'm glad it helped.
This looks really neat. I have a tool where I've done some annoying one-offs to get something similar, but its incredibly hardcoded for my use-case and this is much nicer. Thanks!
I wrote https://github.com/carlmjohnson/rank-em the other afternoon. I should make it use the select option. 
It’s new in the last year or so. When did you look?
Does it work on Windows? Can't find Windows specific code.
Why do you make us sign up to get it. Give it away without making people sign up to show the quality of your work and maybe people might choose to sign up for your other material. I'm not going to sign up when I'm not even sure how good your content is compared to what I can find elsewhere.
Seems expensive. How does it compare to Atom with all the Go plugins?
JS is currently the only way to speak native to the browser and Go is an excellent solution for backend code. So why not learn both?
FYI, it's £69 (or the equivalent in Euro / USD / currency of choice) per year, or £6.9 / month. It also becomes £41 / year in the third year of continuous usage. Not sure if that's in your budget range or not, please see: https://i.imgur.com/OwErjhc.png
Again, feedback hugely welcome :) this one was a tricky one you write! 
Use spacemacs
Congrats guys on reaching a full release. It's a solid product and has a lot of great features.
We started the project a little less than year ago or so. So i think i just failed on googling
Bought a print copy recently. Its actually really good. I expect it will date quite quickly because it makes a lot of use of current packages, but for right now it's one of the best tutorials ive seen. It skips programming basics and focuses on what's unique to go.
Hi, one of the authors here. We are using https://github.com/chzyer/readline that provides Windows support. Let us know / create an issue if something for Windows doesn't work for you and we can take a look.
Bought it. I’ve used everything from the plugin to each EAP release and I’ve been happy seeing the IDE progress that much, now its a huge part of my workday. You’ve earned my money JetBrains! Good job 
Thanks!
So jealous, this looks like a great IDE! Shame I'm addicted to term editors (Kakoune specifically), the vim emulation in IDEs like that are never a comparison. But man the features of GoLand are tempting. Great job guys!
It’s a good one. I bought this months ago.
Feedback hugely welcome as usual :) This was a really tricky one to write, so bear with me! 
I think it's mostly just a wart. They're identical for all purposes. Some people like using make because it's makes it very obvious you're constructing a new, empty map. Some people prefer to use the map literal version because it's less clutter without the make keyword. I tend to only use make when I need to set a size. There's no good reason for both to exist... probably the empty make should go away, but it's not really a big deal.
&gt; So to avoid blocking requests, mgo allows you to Copy() or Clone() a session, so that you have a concurrent connection for each request. You will notice that I've mentioned Copy and Clone methods, these are very similar, but have a subtle, but important difference. Clone re-uses the same socket as master. Which reduces the overhead of spawning an entirely new socket. Which is perfect for fast write performance. However, longer operations, such as more complex queries or big data jobs etc, may cause blocking in other go routines attempting to use this socket. I've had to make sure people are aware of this when using mgo. Thank you so much for covering it!
This suffers the same problem as exceptions... in that you can't know what failed. And it prevents you from adding more context in the error. I very often customize every error return, so I'm not just returning error, I'm returning fmt.Errorf("failed to loadFoobarConfig: %v", err) that way, if two functions happen to return the same error, I know what is going on. 
There's a vim plugin for the IDE which is said to be the closest to VIM there is. As I'm not a VIM user I cannot say for sure but give it a try and see if it's any better or not.
This may be helpful for this scenario: https://golang.org/pkg/net/rpc/
Sure but for cases when you are using library that has not shit error messages that's just extra fluff and not always necessary to have good error messages Often I want to chain few calls to same lib, say new-&gt;connect-&gt;login-&gt;get some basic data. Making error message from `AMQP error: connection refused` to `AMQP connect() error: connection refused` isn't changing amount of information provided. And for else, maybe having try generate an struct that contains that extra info ? Say } else errCtx { log.Debugf("Error at %s:%d: %s", errCtx.FileName, errCtx.FileLine, err) return nil, err } but again, that's more magic... 
I feel like this is a lost opportunity to call it 'goop' ;)
Free if you're a student!
I prefer SublimeGo. (Haven't tried GoLand)
* I have paid $200 for CLion and, frankly, it doesn't worth it although nice (it is damn slow sometimes, BTW). I am afraid I cannot justify another $200 (this time wasted) on another very similar IDE which is just marginally better than free competition. 
Better, but not much.
Really enjoying Goland over the past year or so it was in development. Luckily I was still eligible for the student license, I'll probably move to the open source developer licence next year if that's still available ;). Are there any changes compared to the RC? I assume not since the time window was so short but I didn't see it listed.
&gt; If Ada were going to overtake C or C++ Ignorance is bliss. Concurrency and parallelism paradigm has changed the game. The rapid adoption of the Go language is a demonstration of that fact. The C cargo-culting isn't going to last forever.
The Vim plugin for IntelliJ is actually really good. I've been a Vim user for half a decade and it's the closest to the real thing you'll get.
I see what you're saying. That's a good point and I don't really have an answer for you.
&gt; I'll probably move to the open source developer licence next year if that's still available ;) JetBrains always supported Open-Source developers, the core platform is Open-Source https://github.com/JetBrains/intellij-community/ , so it's unlikely that's going to change. &gt; Are there any changes compared to the RC? I assume not since the time window was so short but I didn't see it listed. There are some small quality of life fixes but no major feature since EAP 20. I guess more will come up in the next EAP / nightly release ;)
&gt; Ignorance is bliss. Oh come now, you're the one holding out for an Ada revival. If anyone is blissfully ignorant, it's you. &gt; The rapid adoption of the Go language is a demonstration of that fact. The C cargo-culting isn't going to last forever. My point wasn't that C is unreplaceable; only that if Ada were going to replace it, it would have already done so by now. The answer to safe, maximum performance parallelism is increasingly becoming Rust. Sure, Ada might be more appropriate for mission critical realtime applications, but that's largely just a matter of maturity. As Rust grows in maturity and popularity, it will eventually break into critical realtime systems.
Then I encourage you to try other editors. For me, both VSCode and GoLand a _much_ more powerful.
[removed]
I've used IntelliJ IDEA with the IdeaVim plugin and, while it is very impressive for what it is, certain issues I have with it keep it from being an enjoyable experience for me even though it comes admirably close. I've heard that work on RPC with Neovim should allow IDEs to hook into it for text editing functionality. I don't know how well that would interact with other aspects of the IDE but I'm interested to see some experimentation on that front.
From what I've tried, VSCode has the best vim plugin. I still use vim most of the time, but VSCode is nice for certain things.
I saw a tweet in the thread when JetBrains announced this GoLand release from a guy saying he'd go back to VS Code because GoLand wasn't free anymore. I pay for the Toolbox subscription every month, and love all of JetBrains tooling, so I was actually totally surprised that he wouldn't just buy it because he looks to be a professional developer from what I saw on his profile. GoLand is one of the best Go IDEs out there, but I guess it's not worth the money to some people, even software developers who make a lot of money no matter how you look at it.
If he’s a professional and not willing to pay for an IDE, that’s his prerogative, but I think one should be willing to put his money where his mouth is. What’s 50 a year given how much time the IDE saves me? The live templates are phenomenal, the debugger support is top notch, I use the database tools a lot as well. I have no problem paying for quality. At the end of the day it’s different strokes for different folks 
Go definitely doesn't need an IDE, but GoLand feels lightweight. It doesn't offer any of the code generation stuff more robust Java IDEs provide life generating your Maven/Gradle project structure, configuring Tomcat, or anything else that's a lot of work to get a Java project stood up. GoLand has really nice convenience features like parameter labeling, quick documentation pop-ups, auto gofmt/goimports, jumping to definitions, and some other features that are right at your fingertips without installing any plugins or doing anything else.
&gt; go has a large number of cli tools that provide code quality, static analysis and co. It's not Java where an IDE is mandatory to keep one's sanity If you need to combine all those tools in an editor like VIM or others, those editors become the IDE. GoLand allows you to have all of that out of the box, with no extra steps needed from you. Download Go, download GoLand and get working, hence Integrated Development Environment.
[removed]
Yeah, I was going to say... vim with vim-go and vscode with the go plugin are all pretty darn similar. It doesn't really matter what you call it. IDE has become a dirty word in some circles to mean a bloated, slow piece of software. But honestly, the difference between the functionality in eclipse for java or visual studio for C# or any of the various major go editors is pretty small.... The main difference being the Go ones are all fairly lightweight in comparison to those two behemoths. So... meh, let's not argue semantics.
I've been really happy with it since it first came out and was named Gogland. The best alternative for Go if you can't get your hands on this is LiteIDE.
Here's a tweet: https://twitter.com/AWSreInvent/status/936301451566972930
FINALLY!
&gt; `make(map[int]int)` &gt; It’s redundant with the composite literal syntax: &gt; `map[int]int{}` &gt; Any reason to keep it around in Go 2? You could go a step further and ask about the `map` keyword itself. If `[]` means a slice and `[n]` means an array for some constant integer n, and if an integer is an invalid type, then `[T]` could stand in for `map[T]` for some type T in Go 2. Then you'd just write `[int]int{}` to initialize your map. 
But not available yet on console
Wheeeeeee
Just keep hitting refresh...
The idea is not bad, and the API is not bad, but I believe the internal code is far more complicated than it needs to be. You should be able to write this as a generalized [decorator](https://en.wikipedia.org/wiki/Decorator_pattern) on top of an `io.Writer`, and you should find you don't need `os.Pipe` at all, and that actually it can easily be used with any `io.Writer` at all. You should find that your code reduces down to the point that you begin to wonder if it's worth having a library at all. I do not mean that as a criticism per se, but as a milestone for how far down you should find you can get this code. It should be just a couple screenfuls of code, tops. (A potentially useful library that you could still write at that point is a collection of such decorators that does things like usefully print things as they go by, which would be useful for things like debugging network protocols. You should find you don't need to define a "framework" for it, the decorator pattern itself is the framework, but a useful debugged collection of the things I often bash out inline in my code would be useful.)
Totally awesome! Go is such a great fit for Lambda!
Thank you!
promptui.Select does not work on Windows. Keyboard selection does not respond. Environment: Windows 10 and command prompt.
Uh, this article is not about exceptions. It's about taking Go's approach to error handling (errors as values) and improving its composability (in the hypothetical world where Go had the syntax to support it).
Let's agree to disagree.
Is it? Go being a compiled language seems like a weird fit for Lambda - the compile step is surely going to hurt performance.
It supports Java currently
I'm sure you'll cross compile the go binary for linux and deploy it as a zip file like you do now with the JS shim in place... or maybe not! Go compilation is incredibly fast and only has to be done when the function is updated, not when it is run.
I don't think you read my post correctly. Without studying a concept like "design pattern" how do you know you're even seeing one while reading source code? No need to "figure this out by yourself"... there are plenty of books that can help you.
I actually use VS Code now for everything (incl. Go stuff) except simple text editing. Sublime is much less "workspace centric" and works better for text editing, plus "saves" unsaved files without committing them to disk, which is really convenient. Just meant to convey the message that SublimeGo &gt; Atom's Go plugins.
I really hope it is binary only, not depending on source code
Isn't it 200 per year?
It was a bit obscured, but on the announcement slide this was labeled as a "pre-announce". It is not available yet :( Still, this is like the best thing ever. I personally was not a fan of the programming selection we had (only two typed languages, and Java is a bit too heavyweight for me) and when I heard this was happening, I got super excited. ** Disclaimer: I work for Lambda, but this is my own opinion and not that of AWS.
It has a lot of useful functionality without installing tons of plugins. I was using Atom before, started using GoLand at my new job and fell in love.
sounds like you want a for{ select { } } with one of the cases being a default or being a ticker from the time package
This and Kubernetes are the big announcements I was hoping for this year. Heck yeah
That's for company licensing, there's also personal licensing which is much cheaper.
https://golangbot.com/channels/
The [personal license](https://www.jetbrains.com/go/buy/#edition=personal) (which can be used professionally, it's just one you buy as an individual rather than a business) starts at 89/y, and 53/y from year 3. 200 is the [*business* license](https://www.jetbrains.com/go/buy/#edition=commercial) for year one (goes down to 119 by year 3), I believe that's also what the "startup" program (50% off) applies to.
I must be doing something wrong (and I hope I am), as I really like the IDE, but find the debugger very buggy, slow, and it just halts my program. I really want to use this IDE, and the one thing that is preventing me from using it is the debugger, I kind of figured that VSCode will do what I need for now. Now, after saying this, if I can get the debugger working great, I will have no problems purchasing this IDE, as every other aspect is awesome. Any tips on making the debugger work better, please please please!!!
Here's a really bare bones attempt to show how you might do this. https://play.golang.org/p/0bqMNnDOK1 The crux of this is that you can actually call `len(mychannel)` to query the length of your work queue before attempting to read from it. So don't use the `&lt;-` operator if the length of the queue is zero. A few other things to think about which I note in my example: * It caps the max number of jobs at 5, so any other jobs added before the game loop can process some will be lost. Generally speaking you'll put this number much higher and it shouldn't be an issue unless something is really really wrong, but you don't want it to grow to infinity. The "producer" code won't add any more work if the channel is full, so it won't block either. * I added a boolean function "HasTimeToProcessJob" which is in the loop that tries to process jobs from the queue. It's probably a good idea to limit the amount of time each frame can spend processing jobs so that you don't skip frames doing non-drawing work. For instance maybe you only want to dedicate 5ms per frame on jobs even if there's more work - that will get done next frame. My implementation returns 'true' so we'll always process the entire queue, but you might want some better logic. Otherwise, this isn't meant to be a serious game engine implementation, but hopefully you get a feel for how you can integrate a work queue into your standard game loop flow.
Nice idea, horrible details. Go has "range" keyword, use it! Use strings.TrimPrefix to remove path prefix, not strings.Replace! Use ioutil.ReadDir, not filepath.Glob with * as "filter". unqiueName ? Why path, why not path/filepath? Woul be more cross-platform. gometalinter would sort out these errors!
Thank you! Yeah I've made this mistake myself, that's why I made such a point of explaining it. Hopefully I've stopped a few more! It's a really over-looked design pattern with mgo. It's really fundamental in fact
Yes, maybe. The thing is that this was not really what I tried to find out. Ofc there are design patterns, but those could be done in any kind of language as you said yourself. If I try to learn more specifically about go, those are not the most useful.
I can't say I've ever seen this pattern used in Go. Usually you see a `select` to do non-blocking channel ops; the implementation is simpler and clearer, doesn't risk races when you have multiple consumers, and uses the existing logic for checking a channel that's built into the runtime rather than recreating it.
sorry, i am a noob. But can anyone explain to me what is this lambda thing ? 
lambda is a function as a service on AWS. you upload the code (usually zip) and it will be executed when its called, usually via a web hook(http) or AWS internal triggers. so, instead of uploading code to your own VM (ec2), you just upload the code. The benefit is that you do not pay a cent when these functions arent running, but within limit (eg a single cycle cannot go over 5min, memory of 1.5G, etc) AWS lambda supports node.js, java, .net, python. So previsouly if you wanted to run Go or any other language, you had to upload it inside the wrapper (eg node.js to execute go binary) not only AWS but Azure and google compute is also doing serverless 
Can you please open an issue on the tracker, https://youtrack.jetbrains.com/issues/Go GoLand uses the same debugger as everyone else, delve, so there shouldn't be any issues with it. Also please make sure you are using the latest Go version as that will make a big difference in terms of debugging quality.
what was the Kubernetes announcement? i think i missed that.
Why would this not be ready for a serious engine? What would you do this instead?
How would you do this instead?
did you take a look at [goquery](https://github.com/PuerkitoBio/goquery)? would save a lot of time I haven't seen a way to setup timeout and redirect handling
That's a good point. In this case I don't worry about the multiple consumers because this is being used in a game loop where I presume they're running in a single-threaded manner. But you're right that the select does provide some additional clarity and actually makes short circuiting the loop when you run out of time this frame much easier to implement. Here's an updated version that's hopefully a bit more idiomatic in that respect: https://play.golang.org/p/U618DON5Hv Thanks for the feedback - and for being civil about it :)
how about libraries? what if your code needs to import them ? where are they uploaded or made available ?
It was more a comment about the fact that my game loop was just a counter from 1-100 and I hard-coded DeltaTime to about 60 frames per second rather than actually figuring out how much time elapsed since the previous frame. For most games this basic setup is more than sufficient, so keep doing what you're doing. For advanced cases, it's not uncommon to have multiple different types of timers. You have Update() that is called once per frame, but some other callback that occurs with a more fixed timer (independent of frame rate) for things like physics calculations that are less tolerant of large gaps in time. Here's Unity's documentation for some of the ways they slice and dice the game loop: https://docs.unity3d.com/Manual/ExecutionOrder.html 
EKS: https://aws.amazon.com/eks/ -- Amazon Elastic Container Service for Kubernetes
https://aws.amazon.com/eks/ 
AWS announces Elastic Kubernetes Service (EKS) which is essentially container orchestration managed by AWS with k8s It is priced similar to Azure Kontainer Service (AKS), free to spin up clusters, pay only for nodes running in the cluster
Today, the main mechanism we see when it comes to multiple file uploads (e.g. bringing in node modules, configs, etc.) is uploading a single zipped file (or jar in java's case) that has all of those necessities bundled in it. Currently, the total aggregate upload size is capped at 250mb unzipped in total.
Unity is a good example, especially because it's so well documented on their site, and it's so widely used you can find discussion and explanation of how it works everywhere online.
https://aws.amazon.com/lambda/
Is there an announced date for general availability?
I’ve thought that the map keyword could be omitted, too. It would be simpler, and you could actually have variables called map. It’s fine if the parser can’t tell whether the index is a type or a constant integer; the type checker has one type for both slices and arrays, with an optional length field, anyway. The parser could simply collect the syntax info and the type checker can figure it out later. If the index is an identifier, then simply check whether it’s a constant or a type.
for nodejs, you zip node_modules and source code, then upload
The call to len is totally race-y. It’s not a great idea. 
[removed]
What the thing does, how often it talks and what other constraints or requirements you have makes a difference for what the right answer is. It sounds like you are just starting out though, so ... just get typing and try it out. It can work and if it's not quite the right solution in the end, you'll for sure have learned a bunch and will have some empirical experience to apply next time you are trying to match a solution to your problem.
Why would I want to switch to this from vscode + go plugin? What are the advantages?
good for you? stick it to the man? ok?
Do you guys find it weird that Google Cloud Functions doesn't support Go ? only nodejs at the moment.
Sorry man, I personally do not know any publicly announced date :(
https://venturebeat.com/2017/11/30/aws-lambda-gets-go-support-and-a-tool-for-sharing-serverless-apps/
I have practically every JetBrains IDE because of this. CLion and IntelliJ got me through some of my harder CS classes, the debugger and ease of use is better than *anything*.
This made my day!!!!
Racey, yes, but with the caveat that you won't get a partial read. adg (or somebody else) confirmed it on the mailing list a while back. You might get a stale read or double up, but that's it.
How are you dealing with HTTP response codes with this error handling technique?
[removed]
[removed]
[removed]
.go-version support?
[removed]
You can define it as a slice and then "make" the array (allocate at runtime). https://play.golang.org/p/G7xuk8hiJu But it will still fail because your i+j causes an array out-of-bounds access.
The only surefire advantage is better refactoring with renaming methods and variables. 
GCF is really behind on this front :(
Just call the go program from a JS wrapper.
Combine this with Far Gate and we have a stellar solution https://aws.amazon.com/blogs/aws/aws-fargate/
If you have a web server that compiled everything into a single binary, could you just upload that binary? Or would they defeat the purpose of this since it would be running all the time (listening for requests?)
ROFL... There's no way they'll compile the go app each time an API is called. 
This would be interesting, because if it's just a binary that means you could in theory use it with any language that can compile to one. There might be some protocol reverse engineering or something, but it could work.
Have you ever tried to use it for anything more or less complex? Bugs are numerous! The most evident one is cursor jumping somewhere it should not then back.
1. Lambda does not run a fresh container/instance on every invocation. It keeps the program running for some time and re-uses the same instance on new requests. Then kills off the instance if it doesn't get requests for some time. AWS has not disclosed these numbers yet. 2. Even if they did boot up a new instance on every call, why would they compile from source every single time? That needs to happen only on new deployments/code-changes and then they can just invoke pre-built binary every time they need to run the function.
Not really. Google is quite a diverse group engineering wise and we've seen many times how one group would not necessarily favor tech from another just because they are both from Google. GCF is just doing what makes sense from market perspective. Get the most common languages supported first and then move to other less common ones. 
You vendor in the libs and push them as part of your deployment. Many tools automate this by bundling your virtual env or node_modules inside a zip file. Then you just upload that file. Only real limitation right now is that the file cannot exceed 50mb in size.
Not exactly, but it isn't difficult. We have HTTP API's that we have now deployed as Lambda functions behind API Gateway. The projects are built so that we can run them as a "normal" HTTP server, or we can deploy it as a Lambda function. If the layers in your services are decoupled it isn't very hard. I found this post helpful in working out how to get it up and running https://medium.com/capital-one-developers/building-a-serverless-rest-api-in-go-3ffcb549ef2 It will be really nice not to worry about the shim.
At my last job we ran a Go binary in Lambda via NodeJS. Node would handle the request and execute the Go binary (Hugo). Pretty easy since go runs anywhere. I'm assuming this will let you just run the go code directly. Though I'm sure it will compile it on upload rather than in each request.
Had a search, and found this fixed it for me : https://youtrack.jetbrains.com/issue/GO-3511 Thanks heaps, looks like Ill be purchasing it in the next few days now after all!!!! Would be good to get this fixed though!! Thanks!! 
azure did not support .net core either at the beginning but aws did... 
Let me recommend this blogpost as a good introduction on what each type of channel means. It really clarified a bunch of stuff for me: https://www.goinggo.net/2017/10/the-behavior-of-channels.html
&gt; If you need to combine all those tools in an editor like VIM or others, those editors become the IDE. GoLand allows you to have all of that out of the box, with no extra steps needed from you. Download Go, download GoLand and get working, hence Integrated Development Environment. In this case, JetBrains handled all that integration, in your case, you did that manually. It's not that many manual steps: 1. Install Vim 2. Install vim-go 3. Run :GoInstallBinaries
I'm using it daily for the past year, and I never seen that issue nor have I seen it reported by anyone so far. It would be great if you could report this so it can be tracked down and fixed because otherwise I can see how the developers could ever fix a problem they aren't aware of.
[removed]
Unfortunately that's a tricky one for the IDE to apply automatically as for some it doesn't work with the same system as for those that work. I've still not been able to track it down and fix it but hopefully, as Go evolves, this will become less of an issue. I'm happy you've managed to find it and that you are happy with the IDE, if you need any further help / have any issues, feel free to open up an issue. As they say: Develop with pleasure!
Can you please expand the question? What is .go-version? Is that a tool? I've never heard of it before. Thank you.
So how is VIM not an IDE then? 
I never said it wasn't – if you ask me the entire IDE/editor distinction is mostly silly – I just said that setting up Vim for Go is not very hard and that it doesn't require a lot of manual steps.
Fun thought: since lambdas work best as microservices with very little code, compiling a typical go lambda will probably take less time than launching a JVM on the same instance.
Damn, missed this, any chance to get the copy?
[removed]
- [Array Types](https://golang.org/ref/spec#Array_types) - [Slice Types](https://golang.org/ref/spec#Slice_types)
So, as it turns out, Go's database/sql driver cannot support NullUint64 because the driver only supports int64: https://github.com/go-sql-driver/mysql/issues/715
&gt; Go provides other ways of handling errors that is less repetitive Do tell.
I personally set the HTTP response to 200, and respond with an error payload as seen above. You can extend this error payload [towards this](https://cloud.google.com/storage/docs/json_api/v1/status-codes) so it includes a code in the response (usually the HTTP code value which you're after). I'm gonna get shot for saying this, but in the land of reverse proxies, *most* of the HTTP errors and response codes should be issued by the reverse proxy or middleware (400, 403, 404, 500, 503,...). Unless you're making an authentication API or a storage API. Most of the world cares only about: - 200 ok - 301/302 redirects - 400 bad request (validation errors) - 403 need auth (might be wrong about this one, I'm writing from memory) - 500 internal server error - 503 back-end service error Of course, it depends on your API, but most likely your errors would be in the 400/500/503 territory, so limited to validation errors (400?), or an error reported by either your own issues (like index out of range panic, 500 internal server error), or an error which comes from a back-end service (sql, redis, whatever - 503). If you're doing something like S3, then other responses like 206/404 become more important. If you're behind a reverse proxy, technically all your errors would fall into 503 from the view point of the reverse proxy :) While I know that I'm generalizing, if you really need to handle HTTP response codes in this detail with a high accuracy, you shouldn't take my above example as gospel, but instead find a way how to add HTTP response codes to your error objects. Looking around, [this seems to be a good reference point](https://elithrar.github.io/article/http-handler-error-handling-revisited/) for doing something like that, or just stick to the usual net/http APIs, WriteHeader or whatever.
&gt; The most evident one is cursor jumping somewhere it should not then back. The root cause of this is the SSA backend of the compiler either filling out the instruction/line association wrong, or (over-)optimizing your program. The proximate cause can vary: * If you are compiling the program yourself (which you probably are not, if you are using GoLand) you need to disable optimizations * If you are using 1.8 or older, optimizations won't be reliably disabled for any package other than main * If neither applies you probably found a compiler bug, it seems that nobody is reporting those bugs besides /u/dlsniper and me, and what's not reported and investigated doesn't get fixed. While I'm here, /u/dlsniper the gcflags for 1.10 should be `all=-N -l`.
Thank you /u/aarzilli, I'll add that to the tracker. Support for Go 1.10 debugging was not added yet as it's tracking https://github.com/derekparker/delve/pull/1027. Thank you for all your hard work on this, it's really appreciated.
Tnx
Wow. Detailed replay. Thanks! I'm new to Go and trying frantically to learn all the idioms so I don't constantly paint myself into a corner and I'd like to avoid making enemies of Gophers if I can too (the Go community is less than forgiving from what I've gathered). It's been a struggle to find the most practical patterns that I can apply. Obviously the HTTP middleware pattern is important but I see it repeated and showcased endlessly everywhere. It's harder to find more obscure patterns. I'm familiar with that article you linked and had implemented it in a toy REST API app that I am working on. It seemed helpful at first but I didn't like how the convention of returning a custom error value suddenly wasn't as smooth when using Negroni middleware for example, so I abandoned it. I'm a stickler for consistency. What I came up with instead is akin to the builder pattern. Example: // responding with error newResponse(). Status(http.StatusBadRequest). Error(someErrValue). Respond(w, r) // &lt;- standard http.ResponseWriter and *http.Request return // or: newResponse(). Status(http.StatusOK). Payload(SomeJSONableStruct). Respond(w, r) // I set it up for some convenience too so something like: newResponse(). Payload(SomeJSONableStruct). Respond(w, r) // Which just sends 200 "OK" if no status code was specified // or 204 "No Content" if no status code OR payload is provided: newResponse().Respond(w, r) All error handling/differentiation is taken care of by "Respond" as well as setting the right response headers and all that. I work in the HTTP status code stuff because I'm trying to follow REST API "best practices". I'm also assuming that any app that I create would be accessible directly and not behind a proxy though that's clearly subject to change. Honestly I see so many approaches to this sort of thing that I have no idea if I am doing it right at all. There seems to be a lot of discrepancy among the go community over how to structure the internals of HTTP handlers. I suppose that's good because it fosters experimentation and refinement (hopefully) but as I said, it's difficult finding the sweet spot in terms of structuring a simple REST API.
I'm a proponent of "there is no right way", but that being said, once you do something a 100 or 1000 times over, your implementation will gravitate towards something consistent. I have rarely met anybody who is 100% out of the gate. Even the response utility which I added to the comment above (2 days ago) has been modified as recently as yesterday, so as long as you see all code as work in progress, you'll get to the point where you'll be happy with it. Eventually :)
[removed]
I like this a lot but it conflicts with the ability to name routes (which is a requirement of mine) among other route specific concerns. :-/
I suggest you look up what IDE actually means because vim and code are both too if you start integrating tools to cater and optimize the work flow of the language your work with. 
Even as a second class citizen, Go with [apex](https://github.com/apex/apex) isn't half bad, but I'll be happy to drop the shim.
They don’t even support IPv6 on their EC2 competitor.
I like this as a rubric: &gt; The 'Happy' path through your webapp (2xx response) shouldn't have any logging on it. The only things you care about here are how often it was hit and how long it took to serve a response.
why was it rejected?
Hi, how often it talks really depends. The ideal scenario is to have a node (for example) app sending commands (json) to the remote raspberry pi, so it doesn't have to check itself. It might be the case to have a socket, but not sure.
&gt; As a practical matter, the myriad ways to tune GC will not be accepted. The code tunes GC. So this alone would probably count as legit a rejection reason.
It also does [arena allocation](https://github.com/victorldb/binary-trees/blob/a11aa061bb0b937f6091b8672b9b66a1ea3e5d7b/main.go#L86), which is [explicitly forbidden](http://benchmarksgame.alioth.debian.org/u64q/binarytrees-description.html#binarytrees). And it does a bunch of unsafe-magic, though I don't understand why, it shouldn't have any advantages. Basically, the point of benchmarksgame (if any) is to compare programming languages and the point of this benchmark is to compare GC implementations. Circumventing the GC or doing things wholly unnatural to the language is, of course, subverting the goal of the game.
I agree except for the debugger being too notch. I’ve tried using it 3 times now and it crashes every time. Otherwise, it’s a fantastic tool and I’m already subbed.
I use the go plugins in emacs, but the one thing I can’t figure out is how to find usage references to a variable or function
This is odd, I've never really had issues with it, at least on the last few EAP's. What's been the issue for you?
well the Rust implementation even uses a type called "Arena" and the C implementation has a memory pool, is that allowed? The JVM takes all your memory by default so it's probably not even collecting the garbage. Very unfair game I'd say. 
All I was doing was setting a breakpoint . Very simple debugging. I’ll try it again with the latest reeelase, but quite frankly the only reason I really bought goland is to debug. My emacs setup is fine.
Hm, I have some opinions :) 1. Seems is a good idea, in general (if nothing else, to reduce volume). I would still, probably, log at Debug level. Because a bug will make the happy path unhappy and then you'll be really glad you have more detailed logs when trying to track down that bug. 2. I disagree with. There are good reasons to have more levels. Warning logs have helped me several times troubleshooting production issues; and no, that's not due to a lack of error handling, quite the opposite. For example, several times, optional backends where unavailable, causing a warning message and a graceful degradation. Later, this degradation lead to errors (after all, if it wouldn't, we wouldn't need the backend at all), which we could troubleshoot with the help from the warnings. Similarly, Debug logs have a very valid use-case - debugging. Log copiously at debug level but discard them ASAP in production. When you get test-failures or are reproducing a bug locally, you'll be happy to have the debug logs. 3. Seems like a bad idea to me. For (textual) logging to be useful, it has to have some kind of tracing function. It should give me a view into the temporal sequence of things happening, while serving a request. That means the log-message has to be generated close to the code where things happened. 4. To me, none of these (except the timestamp) belongs into a textual log. All of these are things labeling a request, not a log message. The annotation of requests and the textual debug-logging is often conflated, but shouldn't be, IMO. Add these as labels to a request-trace and/or store them in a separate system (like BigQuery) for aggregation/analysis, but don't add them to each and every log line. (Textual) logging is for human consumption. 5. Is a great practice. Use this request ID in conjunction with the separate system from 4 to get a full view into "how was $request handled". Looking up the request ID should give you a stream of log-messages generated by this request, a trace and all the annotations; system-wide. To me, most of the ideas here (just like "structured logging") seem underpinned by the conflation of "request-scoped data that we want to collect and have available" and "textual logs for human consumption, to get a temporally sequenced view into the behavior of the system (when handling a request)". The two are very different functions to me and both are very important. Conflating the two leads to practices that ultimately reduces logs significantly (making them useless) and creates overly complicated log-aggregation pipelines…
&gt; is that allowed? I don't know, I don't run the game. From a pure rules perspective: They *do* allow to use a library for custom allocators; but not writing “your own custom "arena" or "memory pool" or "free list"”, which the Go code in question does: It knows a priori how much memory it needs and allocates exactly that upfront. Use of `sync.Pool`, for example, would probably be fine (but probably won't help). &gt; The JVM takes all your memory by default so it's probably not even collecting the garbage. Meaning it is, in this particular benchmark, the JVM has a leg up. So? &gt; Very unfair game I'd say. Only if you give it more meaning than it should have. It's just a way to say "under these specific conditions, these languages compare like this". It's pretty much a neutral statement. The intellectual honest thing is to accept that in this particular benchmark Go just might not compare well to some other languages. That doesn't mean Go isn't a great language or worse than others. It just means that if these are the conditions you are looking for, Go might not be the right tool.
Thanks, I will give that a read. Good info.
Not if amazon wants to earn more money ;)
could do the same thing to get Go on AWS Lambda now that you mention it...
And that’s exactly what the apex library does
The full, relevant rules: &gt; Use default GC, use per node allocation or use a library memory pool. &gt; &gt; As a practical matter, the myriad ways to tune GC will not be accepted. &gt; &gt; As a practical matter, the myriad ways to custom allocate memory will not be accepted. &gt; &gt; Please don't implement your own custom "arena" or "memory pool" or "free list" - they will not be accepted. Tuning the GC definitely violates the very first three words in the rules. As far as the Rust implementation goes, it's using the "standard" Arena crate in the Rust ecosystem. It isn't custom-implementing an Arena that's optimized for this exact case. It actually isn't even using the Arena optimally, since it isn't telling the Arena exactly how much memory is needed ahead of time, unlike the Go code that OP provided, which is allocating precisely the right amount of memory.
I used to really look forward to it, but now feel like this announcement is a bit lacklustre, given that [other solutions](https://github.com/eawsy/aws-lambda-go) (nearly as good as native) already exist, so this seems like an incremental improvement without other enhancements. Disclaimer: we have moved on from Lambda for unrelated reasons. They really ought to fix things like 1. no DB connection pooling due to processes not getting reused, 2. awkward configuration management, 3. or having to pay for a NAT gateway if you want a function to talk to VPC resources and the internet at the same time. But even then, given their Kubernetes announcement, I feel like we can just run our ex-Lambda stuff as Kubernetes jobs and use uniform tooling, so there is no reason for us to consider Lambda.
Damn I'm so excited to try GoLand out
How do you deal with IDE shortcuts conflicting with vim commands?? I've tried using IdeaVim in the past and keep running into this issue. (I'm a vim newbie though)
&gt; Very unfair game I'd say. If you sit down and try, you will find it is impossible to write "fair" rules that everyone will agree is fair. There have to be _some_ sort of restrictions, otherwise everyone just ends up writing the solution in assembler and wrapping whatever minimum shim is necessary around the assembler to be "in" the target language. That said, I find that for all the people who'd like to believe otherwise, the numbers I see coming out of the current benchmark game tend to fairly accurately reflect my own personal experiences with the various languages in question, so I think the current rule set is probably pretty decent.
&gt;only nodejs at the moment. As much as I like statically-typed languages in general, one legit advantage that the dynamically-typed languages tend to have is that it really is easier to just load in a new chunk of text that is the new program code you want to run, with the new code every bit as much as integrated with the rest of the program as any other code is, since that's how _all_ the code is loaded. Go has a much harder time with that. Yes, I am aware that it can be done, I could with some weeks allocated write the system to do it myself on a local scale. But "with some weeks allocated" is rather more than "feed the text to `eval`", and that's still my estimate for something that work for me _locally_; I'm not sure what "cloud scale" would take, because the long tail of issues you encounter in that case gets pretty long. So, honestly, the weird thing to me is that _Go_ is supported at all, not that a dynamic language is supported first.
[removed]
Out of curiosity, the price of the license go down on the second and third year of subscription. What happens if after paying for 3 years you skip one year? Do you go back to the full price of the first year?
./app &gt; app.log ?
What you just described sounds like the proper use of exceptions. At least in Java, you can wrap your exception with more details and pass it back up the chain which not only includes whatever string message you want to include but the causing exception which is all printed out in a stack trace. Proper error handling in Go doesn't look all that different than proper error handling with exceptions in Java. The main difference is that it's not _required_ to for you to handle anything in Java (however you still have to declare checked exceptions), but really that's the same thing as doing this in Go if err != nil { return nil, err } You're right that simply propagating errors without additional context can be bad, but it's not always necessary. Say for example you are writing a function that is a collection of data-validations, each of which returns a descriptive error that is not enhanced by anything you'd add in your utility function which simply groups all of these together.
The rules against custom arena should forbid the usage of [APR](https://benchmarksgame.alioth.debian.org/u64q/program.php?test=binarytrees&amp;lang=gcc&amp;id=3) in the C++ program and pretty much every other one aside from maybe RUST since it is a part of the standard library in my opinion. The [C++](https://benchmarksgame.alioth.debian.org/u64q/program.php?test=binarytrees&amp;lang=gpp&amp;id=2) (36 seconds) program is the first one without an arena and that fairly compares to the [Go](https://benchmarksgame.alioth.debian.org/u64q/program.php?test=binarytrees&amp;lang=go&amp;id=4) program (34 seconds). If op wanted to he could simply make an external package that implements the exact same thing as APR to circumvent the rule. Import "github.com/user/unsafepool" is no different than #include &lt;apr_pools.h&gt;. Regardless the games themselves measure the last thing most people value in software engineering, python is sitting at 90 seconds but it does't stop people from using it effectively in resilient production systems. I'll take 90 seconds of python over [the unbearable C/C++ ecosystem](https://www.reddit.com/r/golang/comments/70rm8t/is_golang_at_all_useful_for_writing_packages_for/dn5ibjh/) and the endless security nightmare it brings with it.
I think you're confusing several topics here. There's a big difference between a dynamically typed language and an interpreted language. That you can (only) move code around in text form is not particularly interesting here. I regularly load code (as text) in haskell, your web browser loaded external compiled C code when you started using it, and everything that does anything with java is dynamically loading an intermediate form of code all the time. Python code is typically loaded from source form, but it doesn't need to be. I'm not that familiar with AWS Lambda, but if they have any sort of ABI, then all languages are on equal footing. Go compiles to many targets and nacl. Something like Lambda would require heavy isolation (which processes provide naturally), so "run process on x64 that expects this input and provides that output" would be a pretty natural way to do things. In any case, static vs. dynamic is not particularly interesting here. IME, dynamic types are mostly just useful for surprising yourself and your users with errors much later in the development process.
&gt; I regularly load code (as text) in haskell, Not in production you don't. GHCI is not performant enough for that. This is not a coincidence. &gt; your web browser loaded external compiled C code when you started using it From an effectively-static list of pre-existing C code modules. This is not comparable to how Lambda works. &gt; and everything that does anything with java is dynamically loading an intermediate form of code all the time Which is, unsurprisingly, "in between" in the complexity of loading it in real time between the fully-compiled languages and the dynamic languages. &gt; I'm not that familiar with AWS Lambda With all due respect, that is a problem for you in this argument, yes.
Google is startlingly far behind in every cloud product they offer, both in depth and breadth. I could make a list a mile long; GCPS doesn't support FIFO queues without involving Dataproc, Cloud Monitoring's strange reliance on the old StackDriver interface, Postgres still being beta in CloudSQL... AWS isn't perfect, but they're incomprehensibly far ahead in the cloud game. Like, playing on a totally different planet while GCP is still learning rocketry 101. But they will throw $200k at any startup that wants to use them.
I wish I had a good answer for you. This is one of the issues that keep me from using IdeaVim. This may just be a natural consequence of trying to use two different editor paradigms at once.
There is no arena in the Erlang implementation (7.63 seconds) or the C# implementation (8.26 seconds).
As far as the concurrent map situation goes I'd use a mutex. It's also really common to see people using channels to coordinate stuff like this but imo that can quickly get messy. If you look at the Go standard library code this is the kind of thing where a mutex tends to be used because it's more concise and efficient. Using the sync.Map implementation seems messier to me because it loses the type safety by being defined as empty interfaces. Yuck. If, however, you find yourself adding more state changes like this it might make sense to have one goroutine process them all and then communicate with that goroutine using channels as a form of internal API to synchronize those changes. But given your current problem I'd vote on using a mutex. For websocket connects I would suggest Gorilla Websockets: http://www.gorillatoolkit.org/pkg/websocket
&gt; Seems is a good idea, in general (if nothing else, to reduce volume). I would still, probably, log at Debug level. Because a bug will make the happy path unhappy and then you'll be really glad you have more detailed logs when trying to track down that bug. That was my exact thought as well.
Benchmark your workload and see what's the best. There are multiple ways to do it, and it depends on what you're doing which way will perform optimally.
&gt; There is no arena in the Erlang implementation (4.95 seconds) or the C# implementation (8.26 seconds). They are faster due to the same thing thing, since they are using vms they are aggressively allocating large..... "pools of memory". Strace either one of them and I am certain you will see an initial batch of larger mmaps or brk's. Since they are running with in vms you will also notice far less (as in a hundred thousand or so) syscalls for synchronization than a Go program. Is there a point to the statement though, I don't recall mentioning either one of those things due to the reason above. &gt; Also, APR itself is not a custom-tailored arena implementation made for the purpose of defeating this benchmark. It is a well-established arena library for general purpose usage. Sure and I could write the exact same library for Go, nothing about the language prevents someone from doing so. I can easily allocate blocks of memory outside the knowledge of the garbage collector in 50~ or so lines of code and suddenly make([]Node, ..) becomes multiple calls to Get(unsafe..) but to the same affect- tens of thousands of less system calls to facilitate the aggressive collection of garbage that is well suited for real world programs. Which is why I disagree with the rule, this arbitrary restriction imposes showing how you can write efficient programs arbitrarily, favoring C/C++ which can use arenas because "it's standard to do so" and VMS which aggressively front load pools of memory and do not immediately release newly allocated memory back to the system. I imagine with GOGC=off even the rather inefficient implementation that takes 34 seconds would run in at least the same amount of time as the C#, even if the to the tune of a couple gb of ram. &gt; EDIT: and furthermore, that C++ one that you cherry-picked is only using a single core. So, it takes about the same amount of time, but it uses one-fourth of the CPU to do it... so, not exactly the most compelling argument. Would you care to link me a C++ one that does not use a pool that is faster (hint there isn't one). We could exchange nits about what we find fair to measure all day, but at the end of the day I find the benchmarks more or less pointless as I already said so it's not really worth debating over. We can agree to disagree, most software should no longer be written in C or C++ that is my stance and it can't be changed.
forever := make(chan bool) // do asynchronous code in goroutine to call the API here &lt;-forever
Looks to be similar with what we started out with Gizmo's pubsub package: https://godoc.org/github.com/NYTimes/gizmo/pubsub At the moment we have implementations for AWS (SNS/SQS), GCP (PubSub), Kafka and a couple other implementations that help with testing and running services locally.
I’m not sure because I’m only on the second year of my subscription.
This seems like it can be summed up as 1) Don't log when there isn't an exception 2) Log (copiously) when there is one and at the point with the most information 3) Use unique request IDs to trace throughout the system
https://godoc.org/golang.org/x/tools/cmd/guru and install emacs package `go-guru` use `go-guru-referrers` then
What is GoLand missing compared to your emacs setup? Or it's just habit that doesn't allow you to migrate to it for the code editing?
The ways you suggest are the easier ways to do it. In the future, a way to do this would be to define the functions you want to be able to add more parameters to as taking in a variadic set of [functional options](https://dave.cheney.net/2014/10/17/functional-options-for-friendly-apis). This involves more boilerplate on your part.
I've tried to update visualization of go packages using http://go-search.org/ . I love how it looks like - very rich, and very large. I just realized that http://go-search.org/ was last updated 290 days ago, so the universe is likely even bigger now. Need to get latest index to see how it looks...
Can you please report debugger issues on the tracker https://youtrack.jetbrains.com/issues/Go otherwise we can't know if it's an IDE issue, a delve issue, or (more likely) a Go issue. Are you using Go 1.9.2? If not, can you please upgrade and try again? Thank you!
&gt; The C++ (36 seconds) program is the first one without an arena and that fairly compares to the Go program (34 seconds). Presumably someone could implement a C++ that did not use a pool but did use multi-core, like the [C gcc #5 program](http://benchmarksgame.alioth.debian.org/u64q/program.php?test=binarytrees&amp;lang=gcc&amp;id=5) (19.05 secs).
Thank you! I didn’t know about this 
Try this on a mobile device, it's amazing.
Not too much go specific but I use emacs for lots of other things including running it via ssh to work on code on aws servers. Magit and org mode are great as well.
I definitely will file a report next time I have an issue. 
Go land and webstorm are definitely superior to emacs for html/js editing though which I forgot to mention is another reason I am using goland 
&gt; Magit and org mode are great as well. While I'm not familiar with those modes, try installing the Remote Hosts Plugin from the IDE and then you can clone the code locally and the IDE will upload it from your machine to the remote one. See https://confluence.jetbrains.com/display/PhpStorm/Sync+changes+and+automatic+upload+to+a+deployment+server+in+PhpStorm to give you some ideas on what the plugin can do (even if it's for the "wrong" IDE. Hope it helps.
There is already a package with a similar functionality, but it didn't work well for me. So I decided to implement my own. It uses t.Helper() feature to provide the only one line on failure without a full stack.
This is wonderful, thank you! I've been working on something similar... But perhaps I'll just adapt / extend (and contribute back to!) this for another backend.
Will do! I’m a subscriber to your total products package . I really like your tools. Thanks for the tips 
Do you mean a client library, that makes calls to a remote service? Plenty of those around, not much of a "pattern" there. Rate limiting is pretty simple, https://godoc.org/golang.org/x/time/rate and call Wait before you make a remote call. We don't subscribe to the Gang of Four that much, you're probably better off asking about the concrete things you want, not about how to apply some Java Pattern in Go.
Saving you a click: ftest.New(t).Eq(2, 2). Contains("FooBarBaz", "Bar"). PanicsSubstr(func() { panic("Foo") }, "Foo") 
Awesome work!
I guess so...oh well, I still get plenty of practice with vim in the command line, so not being able to use it in Intellij is not that big of a deal : )
Sorry if my terminology is not quite right, I believe that you are correct. My aim is basically to create a package that I can use to easily call someone else's RESTful API. I am from an OO background, so I'm probably still thinking about things in more of an OO way. I will do some searching for client libraries, thanks for the pointer.
Up the ante and fire this up in VR. 😍
Have you given vim with vim-go a shot? It's not IntelliJ level but you get a ton of Go features.
I got lost outside the no-dependency oort cloud
Will check it out :)
Setting $GOPATH isn’t required, it will default to a reasonable path, and I don’t think this the source of your contention. For example, you probably let NPM use its own default paths and you just get on with your work. You can have your Go source anywhere and be fine. Then for managing dependencies you can use a third party solution; Glide and GB comes to mind.
This comment might have as many words as the post itself!
On that note of tests, i wonder if we could extend Godoc to be a bit more advanced with tests? Eg, currently we can put tests in Godoc, but could it be extended i wonder? If so, how? What's missing? etc
I'm pretty sure it is required if you want a user workspace. You also have to manually set $GOBIN if you want all the standard toolchain to work correctly ie: go install. I completely understand the pain of /u/tyteen4a03 . All of these extra configuration steps are especially a pain on windows when you expect an installer to configure everything for you or at least give you the option to configure them. Installed go on a new machine? Nope. You got to figure out how to correctly set whichever envar needs to be set and the installation guide on https://golang.org is incomplete in that regard.
GOPATH now defaults to $HOME/go, and so therefore binaries default to install to $HOME/go/bin. You don't have to set GOPATH or GOBIN to get work done. You do have to work in $HOME/go if you don't set GOPATH, though. GOPATH was a decent idea in 2011, but it hasn't aged well. In https://research.swtch.com/go2017#build, written almost a year ago, I listed three problems with the go build system: * All builds should be as incremental as possible. * Test results should be cached. * Work outside GOPATH should be supported nearly as well as work inside GOPATH. The first two are done for Go 1.10, and my hope is that the third will happen for Go 1.11. So hang in there /u/tyteen4a03, and for now please just set GOPATH and accept my apologies. Thanks.
Swift used Apache apr. I would argue that is unnatural in Swift, however it has been allowed. Go ahead and create a binding to that and see how Go performs.
wow,wonderful!
If you see my repo can you send my love?
amazing!
Startled me once I realized what it was doing. Incredibly smooth. 
&gt; You don't need levels if you are only logging errors. Ah, I see you're a man of culture as well. Also: https://peter.bourgon.org/go-best-practices-2016/#logging-and-instrumentation
GOPATH isn't exactly a unique concept. It's very much the same in Python (PYTHONPATH). Both accept colon separated search paths for dependencies. And both communities have 3rd party options for managing multiple project environments. Go has vendor directories for projects, which kind of feels similar to how python will also check the current relative directory if you want. Many people vendor their dependencies to solve the exact problem you mentioned. And the story is improving as we speak. 
[removed]
While waiting for Go 1.11, there are several inofficial workarounds available, including [virtualgo](https://github.com/GetStream/vg) or [using direnv](https://direnv.net/). I use direnv whenever I want to break out from the standard GOPATH, by simply creating a `.envrc` file in the new GOPATH root dir, with the contents `export GOPATH=$PWD`. This works quite well as long as you work from the command line exclusively. GUI tools would be unaware of any .envrc, but some, like Visual Studio Code (with the Go extension installed), can be set to determine the current GOPATH without reading `$GOPATH`. The combo of `direnv` and VSCode works quite well for me.
Do you plan a follow up with updates to your "My Go Resolutions for 2017" post in the new year? Would love to see one!
Wasn’t the README.md clear? I don’t remember having any difficulty with it. From memory: ‘dep init’ once to initialize your project for use with dep. ‘dep ensure -add’ to vendor a package. ‘dep ensue’ to restore (if you don’t check in your vendor did) or ‘dep ensure -update’ to update vendored packages. There’s also a ‘dep ensure -prune’ command to remove unneeded dependencies. 
&gt; It seems to encourage developers to do all their development in a single workspace. Yes, that is the point of GOPATH. People seem to suffer from the illusion, that they don't have to care about upgrades to their dependencies; just vendor them and don't bother with actual maintenance. But, in the end, someone will *always* have to figure out a compatible set of package-versions - if in doubt, it's going to be the maintainers of the linux-distribution packages. It is, for example, absolute hell to manage a security fix to a library, if every project out there just vendors *some* version of it - you don't know who gets the fix and if a project uses too old a version, timely upgrades might be alltogether untennable. The underappreciated brilliance of GOPATH is, that it does away with the illusion that you can just isolate yourself from the world and don't have to care about maintaining your software. In an ecosystem where working from HEAD is normal, so the thought, they won't introduce as many breakages and make the overall set of packages more compatible and closer to a common, fresh version.
Beautiful.
GOPATH is unrelated to dependency management.
What really annoys me about gopath is the absolute of it. If my program is like github.com/user/stuff and I want to use my sub package "cmd" I always have to declare it absolute. Like import github.com/user/stuff/cmd That is so annoying... I just want to be able to say import ./cmd or something like that. Relative to the current project.
https://golang.org/doc/install &gt; # Windows &gt; &gt; The Go project provides two installation options for Windows users (besides installing from source): a zip archive that requires you to set some environment variables and an MSI installer that configures your installation automatically.
But repeatable builds... vanilla go makes this kinda hard (we use glide to work around this). This one tho is easier to solve than porting patches to library versions per project!
What have you been struggling with in particular? I can help you workout some of the issues you may be running into, I just need to know where you are getting stuck!
Full disclaimer, I don't work for JetBrains, I just love their products. But they are reading this so I'm sure they appreciate your feedback ;)
Let's not use node modules for comparison, shall we? It has enough problems now, and has had a lot in the past.
&gt; GOPATH was a decent idea in 2011, but it hasn't aged well. Why do you think so? Since GOPATH exists, I have set it to $HOME and never had nor needed to touch it again. What problems do I miss? The two first you've listed above don't seem to me like GOPATH related and wrt the third one: reliably/exactly resolving an import path to a specific directory should never be a guesswork, but for non-stdlib imports that's what gonna happen outside GOPATH, like when assuming GOPATH equals $PWD or any other solution. I see no principal difference between PATH, CLASSPATH, GOPATH, etc. Without them everyone has to do a lot more typing, flag passing etc. Even C has its "CPATH". It's just the C compiler knows where to look for system headers, even when that's more an analogue of GOROOT. Also, if really needed, there's no substantial difference between `GOPATH=whatever go build` and `gcc -Iwhatever *.c`, for example. Disclaimer: I am employed as a full-time Go programmer since 2010. 
I disagree with this one, actually. Some happy logs may help retrace the path to failure, when each individual request is stateless and one of them fails. In a webapp example, if you get a failed request (non-2xx), you can deduce what the user was doing/trying to do leading up to it.
This is absolutely amazing! I am huge visualization junkie! Kudos man!
It is awkward for people to have to install all the different binaries. I'd switch to using the spf13/viper package and build a single binary 'sc' that people could invoke that would offer all the same features. ex: sc confirm-phone .... ex: sc create-account ... https://github.com/cheikhshift/go-securechain/blob/master/global_definitions.go#L44 don't use named returns, there are a lot of these, but inconsistent https://github.com/cheikhshift/go-securechain/blob/master/global_definitions.go#L31-L34 use https://golang.org/pkg/path/filepath/#Join https://github.com/cheikhshift/go-securechain/blob/master/cmd/sc-decrypt/main.go#L69 else keyword is not needed https://github.com/cheikhshift/go-securechain/blob/master/cmd/sc-decrypt/main.go#L84 switch the ordering to check for the error case first and handle that. See https://medium.com/@matryer/line-of-sight-in-code-186dd7cdea88 
have you ever tried goimports?
Here's a list of things the IDE can do vs other editors (in no specific order): - better completion - better refactoring support (rename, extract / inline refactoring) - no need for external tools - doesn't break every time you upgrade Go (and works with multiple versions of Go out of the box, configurable per project) - language injections (so that you can edit any language it supports with all the features in any string) - text/template and html/template support - templated code generation - smart type completion - database integration - as you type, in-memory, code analysis - type / call hierarchy support - go to / from interface support (allows you to navigate from the interface to the types implementing it and from the type to the interfaces it implements) - multiple projects in the same window support (some editors might finally do this as well) - search including / excluding vendor folder - better performance on non-Hello World projects for completion, inspections - quickfixes for a bunch of issues (with more to come in upcoming versions) - plus all the goodies in WebStorm (for html/js/typescript support) and DataGrip (for SQL Database interaction) Oh and I've forgot a big one: it does all of that while working on broken/incomplement source code. So if you are in the middle of a refactoring/moving code around, you'll still get as much assistance as possible from the editor.
See my answer here: https://www.reddit.com/r/golang/comments/7gm9ne/goland_20173/dqnkzjt/ (I'd rather not spam this)
https://github.com/OpenSourceZombie/lwapi/blob/master/lw.go#L44 should just be return vsl,err https://github.com/OpenSourceZombie/lwapi/blob/master/lw.go#L50 https://github.com/OpenSourceZombie/lwapi/blob/master/lw.go#L84 https://github.com/OpenSourceZombie/lwapi/blob/master/lw.go#L132 https://github.com/OpenSourceZombie/lwapi/blob/master/lw.go#L152 https://github.com/OpenSourceZombie/lwapi/blob/master/lw.go#L198 https://github.com/OpenSourceZombie/lwapi/blob/master/lw.go#L209 doesn't return err if it was ! nil https://github.com/OpenSourceZombie/lwapi/blob/master/lw.go#L112 return asyncResp, err https://github.com/OpenSourceZombie/lwapi/blob/master/lw.go#L146 don't start error string with capital letters, see https://github.com/golang/go/wiki/CodeReviewComments#error-strings https://github.com/OpenSourceZombie/lwapi/blob/master/lw.go#L181 should be returning the error here if ! nil https://github.com/OpenSourceZombie/lwapi/blob/master/strucs.go do you want this named structs.go? https://github.com/OpenSourceZombie/lwapi/blob/master/lw.go#L18 don't use all caps - see https://github.com/golang/go/wiki/CodeReviewComments#mixed-caps 
Thank you so much, I'll fix all these :)
Yeah I have used it in the past. But it doesn't really solve the problem it just makes it easier to deal with.
Laitkor offers Golang development services which consists of an wide open source program writing language.It helps reliable software programs using really small amount of code.
[removed]
"Understanding Golang Also called Go Go, also called Golang" :D
Is there a way to view the package names in this?
You can click on a package or type its name in the search box (which accepts regexp)
What's this and why? https://github.com/cheikhshift/go-securechain/blob/cdad7bb86a353215b6fd6339c9438f09d445f52f/cmd/sc-decrypt/main.go#L6
For an encryption tool, it sure is hard to find how it encrypts anything.
It imports the securechain go library. It has some utility functions, constants and variables.
What's that then? Why does a "file encryption tool" seem to talk over HTTP to a website hosted by someone I don't know?
OHH I missed that one, updated :) on a side note : The benefits of using the server to encrypt is that you can share the file to someone without giving them your key. You just need their email on your SecureChain (list of emails) to give them access. The server encrypts the data and does not save it anywhere. The server is hosted by me, however there are standalone options available to enterprise.
I've seen you start several projects on here and you seem very enthusiastic about Go, so I don't want to discourage that because I think it's great so keep that in mind while reading my feedback. Security in general can be a fascinating topic so it's only natural to spin up projects to experiment with, this is great and I encourage it. But It's important to do so responsibly by disclosing that the project is a learning experiment and should not be used. Reason being how would you feel if someone using your project had very personal details revealed due to a vulnerability in your software? Now consider the potential for countries with oppressive governments or intolerant religious climates where a intimate personal detail could go as far as costing someones life. The chances of these cases are likely rare, with such extremes being near-zero. But in that off chance most people yourself included would probably feel devastated. It's easy to lose sight of the consequences of the security related software you are writing when you're focused on how fun the engineering is. This doesn't mean only cryptologist or infosec people can write security related software, it just means that you need to follow a process that leaves you ignorant rather than negligent in the event of a major security vulnerability. There isn't a template to this process but to summarize I believe the core tenet here is peer review by a SME. Obviously second pair of eyes in an official peer review puts the professional reputation of the reviewer on the line, so it's much more then someone browsing your github for at most the duration of the time it took them to take a shit. More importantly than the review itself is the amount of effort it will require the code author(s) to make the code high enough quality where someone would be willing to take the time to even review it. This means: - The features have been carefully designed, with as narrow of a scope as possible. Every feature that is not CRITICAL to achieve the high level goal has been pruned. - References to the primitives you used and why you chose them. Including any citations from white papers you may have came across or documentation from other well reviewed cryptographic libraries like open ssl. While this serves the reviewer to get up to speed quickly on your frame of thinking, it is meant to serve as an exercise for the program authors. It forces real consideration of the implementation, you need to justify why you chose method Y for encrypting a file. This brings you face to face with the many nuances of file encryption and will allow you to form stronger statements around your security guarantees. - It's idiomatic to the language you have written in, follows the conventions and best practices while being fully documented. - All usage of cryptographic primitives are outlined and separated from any general feature library code, with very clear inputs. Having as few entry points into security sensitive context means you may form very strong invariants and makes testing much simpler. This also leaves much less surface area to audit, the inputs are well defined so the auditor can focus on the interactions around the crypto primitives in use. - I could go on here- but anything else is elaboration of the general spirit here. Define your use cases, document them and ensure your implementation is correct, resilient and as simple as possible. If that sounds like someone you would be willing to do here than go for it and feel free to PM me if you ever have a question about my feedback here. But to be very honest with you from what I see here it looks like you are aiming for quantity over quality with your projects, this is absolutely fine for anything outside security related software. But for this code it's a long way from being something worth auditing because it's not even clear what it's purpose is. Even if it was I couldn't even take a cursory glance because all of the core logic is in a [private repository](github.com/cheikhshift/securechain-cmd). So all that said my general summary is that this code is **insecure**, since there is no evidence to support it may be correct, or what the purpose is to form an assertion to begin with.
reported as SPAM
So, why would anyone trust you?
I don’t see a single Go project at https://github.com/laitkor?tab=repositories - have you produced code so small it doesn’t exist? :)
https://github.com/kindermoumoute/adventofcode2017
I am personally liable for any damages.
Hello gophers (and others), After reading a post submitted here 3 weeks ago ([LINK](https://www.reddit.com/r/golang/comments/7bcf8l/after_reading_about_go_list_i_made_a_small/)), I decided I should rewrite this in Go (some other commenters mentioned this too). I’ve recently switched jobs (from Java to Go). For the past few months I wanted to write a OSS library in Go, to get a better grasp of it. I’ve rewritten the powershell script in Go, and added lots of additional futures (as explained in the repo). I'm looking for tips on how to improve the code and what functionality could be added to it. Thanks! 
I did exactly this and published a library today - [glice](https://github.com/ribice/glice)
I've rewritten in it Go and published it today on GitHub ([repo url](https://github.com/ribice/glice))
Suggestions: - Use the [go/build](https://godoc.org/go/build) package directly instead of invoking it through the `go list` command. - Get license info from the license files in the source tree. This will work independent of where the source code came from. 
extensively covered in: https://www.reddit.com/r/golang/comments/7gogdy/aws_lambda_to_fully_support_go/
Hey, For go/build I'll take a look and see whether I can implement it. For the second part, you can see from my comment above that I wanted to rewrite a redditor's powershell script in Go. Hence the Github API query. I believe there are other tools on GitHub that do exactly that, go trough source code and get the licenses (or at least try to guess it). A problem I see with it is if the user cloned the project, the dependencies wouldn't be in the gopath.
https://github.com/ajgrf/advent
Yes, here's a tool for getting the license: https://github.com/ryanuber/go-license If a dependency is not on GOAPTH, then print a warning. 
not a single one of these items is being worked on by the Go team
As you can see, it tries to 'naively guess' the license, by pattern matching content in License.MD compared to standard content in license files. GitHub API (and others) returns the license just fine.
&gt; most notably because it's easy to see exactly where errors occur and how they are handled. Because we can't see where and how we catch exceptions? &gt; but it more than makes up for by being terse in other aspects compared to many other languages. Where's go terse exactly?
It is a issue for two reasons. First, environment variable are transparent and an issue to Windows developers. I've set some in the past to make certain command be available from the CLI. Other than that, never. Go is the only thing that I use which required me to set up specific envvar as if I was manually installing something on a Linux machine. As for the second reason, which I already described in my original comment, https://golang.org/doc/install do not tell you which envar to set and to what value if you want your workspace **in a different location**. Common usage: You don't want to work from ``%USERPROFILE%\go`` because it's not easily accessible, you want to work from ``%USERPROFILE%\My Documents\go`` where you actually got all your stuff. * You read the paragraph on Windows where it says it should do it automatically but it doesn't give you the option to configure a workspace. * Turns out, there's a tiny link under *Test your installation* that talk about creating your custom [workspace](https://github.com/golang/go/wiki/SettingGOPATH). **Why is it under Test and not installation**? * Alright, so we set ``GOPATH``..oh wait some commands doesn't work, why is that? You also need to set ``GOBIN`` to ``%GOPATH%\bin``and add ``%GOBIN%`` to ``PATH`` but that's not documented for the Windows paragraph. My complain can be summarized like so: * The installer doesn't give you the option to set the location of your workspace for you. * The instruction for setting up the location of your workspace is not well labeled. * The instruction for setting up the location of your workspace on Windows is incomplete. I do have a certain experience with Linux and how things are installed there so at least it's a tiny bit tolerable for me but I'd admit that when setting up a new Go installation I usually search for awhile on stackoverflow to know how to correctly set it up. Think about the developers who never worked on Linux, their first experience with Go will be a disaster. It's a hard sell trying to get my colleges to try Go when they can't immediately start coding after using the installer.
Can your vim do something like auto complete without importing some package first? GoLand can do that...
There is a buch of them in here: https://github.com/kodsnack/advent_of_code_2017
The Github API also [guesses](https://github.com/benbalter/licensee) using pattern matching and other fancy stuff.
Not the most graceful pieces of code, but they work https://github.com/fbegyn/AoC2017
Google's behind in the cloud period. Now that Amazon has EKS, good luck to Google and Microsoft on catching up.
Not only that. . . now there's a runtime continuum in AWS. Want to run a function, Lambda. Want to scale up a basic or simple service in Docker, run Fargate. Need more flexibility and power, run ECS. What's that you need to run hybrid/bare metal or don't want vendor lock-in? Run EKS. Hey, containers just don't cut it for my use case. . . nbd, EC2 is still there and still improving. Never mind how much better all the built-in services are becoming. . . AWS is killing it in the cloud. I'm a huge fan and occasional critic - there are rough spots and inconsistencies here and there, but it's also getting a bit scary. Amazon is everywhere.
https://github.com/colezlaw/advent2017 - I'll warn you, my responses are not the most concise because I'm trying to make sure I've tested everything as much as possible before submitting my answers. I don't stay up late enough to even possibly end up on the leaderboard, so I'm trying to write good code, not get my solution done the quickest.
`$GOPATH` is literally where you store your dependencies.
This is great ! Glad to see some apache projects getting Go clients.
I am the same way - I'm using it as an opportunity to try different ways of implementing the solutions and benchmarking their performance. I'm printing simple performance reports to text files for each puzzle, it might be fun to try and build some simple UI in Go to display them later.
I had the same thought. The googs and msft are getting left in the dust. 
Yes: `let g:go_gocode_unimported_packages = 1` 
It [sends a HTTP request to this](https://github.com/cheikhshift/go-securechain/blob/680993ef7dceb00528894160208f6c89ee19a78e/api_utils.go#L13). Yeah :-/
It's up to you there is no right answer, you never have to write any unit tests at all if you don't want, but typically is a good idea to give some insurance against breaking changes in future
If you want to think of this in programming terms, use this: ``` expectedCost := costIfError * probabilityOfError if expectedCost &gt; costToWriteTest { // Write a test! } else { // Probably don't need to write a test } ``` This obviously ignores the fact that errors can be reintroduced etc, but thats the basic idea. Writing tests for use cases that simply won't hurt you much is a waste of time. For example, if someone signs up with an invalid email address and your app returns a 500 status code instead of a 4xx, is it really a big issue? Sure, you might want to fix it eventually, but the user still has invalid data and chances are they'll still see an error message in the UI and figure out what is going on, so does this bug actually cost you much? On the other hand, bugs where you might lose sales could be a much bigger issue and might require many more tests to ensure they don't happen, so perhaps you want to test your `Create` for orders and shopping carts a little more thoroughly than your `Create` for your user resource.
Sure, just small ones, why not?
So your reassurance that you aren't stealing all of your user's data is that, if they catch you, you'll say sorry?
I don't think liability disappears with sorry. If I get this straight I wrote a service just to look at people's thoughts? I have twitter already.
Presumably, people are using security services to handle *secure* data, not things they post on Twitter, but your deflections are meaningless if you don't respond to the concerns raised by epiris regardless.
Epiris will has his concerns and I welcome them wholly. Think of the cost per month to even log information to a server at scale. Sometimes you have to think about your arguments, like the thought of me putting a malevolent server online so I can have more hosting bills to pay? and hope one day this phishing scheme gets me information? from people I don't know? Some advice : villains are representations of past trauma.
https://github.com/dubyte/adventofcode2017
Your users (and I) are unaware of your financial situation, log capacity, etc, and have yet no reason to believe you when you say we shouldn't be worried about it because you are incapable of being malevolent.
The idea of a villain in ones head .) The idea that people's first intent is evil. If I had trauma I would not build this, my fear of something bad happening would be too great. My financial situation $0, unemployed and living at my moms house, trying to build a new occupation. https://www.linkedin.com/in/cheikh-seck-336826131/
Again, we have no reason to believe you. A better way to give your users confidence would be to open source the server and offer it to be run by users themselves through docker.
Putting it out as OSS will also mean releasing it for free, and like I said I am trying to build an occupation and provide something to the market. PS : Ok you got me I'm Dr.Octopus.
[removed]
 lwclient := lwapi.LW{} lwclient.AuthToken = " ****-****-****-****" lwclient := lwapi.LW{ AuthToken = " ****-****-****-****" } https://golang.org/doc/effective_go.html https://github.com/golang/go/wiki/CodeReviewComments
You might want to reconsider the name "lwapi". "lw" is so short that it's meaningless, and "api" is kinda imlied. "leaseweb"?
&gt; d.1) Proceed on failures and return last error That's usually the *first* error, and that's much more meaningful.
The way this sort of tool is monetized is through support contracts and commercial licenses. It isn't even important if you are malevolent or not, you could just be foolish and holding the data in an insecure manner on your servers for someone else to pick out and use against your users instead, and again, you being liable isn't a vote of confidence.
Agreed. *on my Kubernetes cluster. 
Store dependencies != manage dependencies.
stopping on first error is d) Error as part of the state of execution The function tracks internally the presence of an error, and halts when one is found.
So smooth on a phone!
Okay, so is the point of this collection is to collect the bad ideas too? Note that d.1 has no examples, while the reasonable thing (d) has.
the point is to collect the patterns I saw in the wild. Thanks for pointing the lack of example - I saw d.1 in couple of places, I will look for and add an example.
https://github.com/benjic/adventofcode I coached kids in programming and am using using AoC with them. I'm going for testable and concise to help teach patterns. 
Go's approach to error handling would be fine if it had an Either type. The fact that you have to ask for the result and an error instead of a result _or_ an error is the problem with Go error handling.
They announced [concurrency limits for Lambda](https://aws.amazon.com/about-aws/whats-new/2017/11/set-concurrency-limits-on-individual-aws-lambda-functions/) too. So now you can have each function open and hold a single DB connection for its lifetime. Pooling of functions takes the place of the connection pool and you can limit the number of connections with the concurrency limit. What do you find awkward about configuration management? [Environment variables](http://docs.aws.amazon.com/lambda/latest/dg/env_variables.html) don't work for you?
To be clear I have never experienced a tramautic personal security event. But I am a security engineer with 15~ years professional experience who has designed and implemented a variety of crypto related systems. Over these years I’ve had countless rigorous peer reviews as well as surgical external audits where no stone was left unturned. These experiences led me to get a better understanding of writing security related software, which led me to my conclusion on your project. You claim you wouldn’t log information because it would be too expensive- then why on earth are you wasting the bandwidth to send the data at all? Why not simply encrypt it on the users machine? In your pm your excuse was that it originally came from a chrome extension because aes is too computationally expensive for browsers. Which is also false, but this is not a browser it is another project written in Go which support encrypting on the users machine without using your bandwidth, violating their right to privacy or massively increasing the surface area for a potential compromise. Your arguments are not well formed and have no merit, so you are either negligent or malevolent since having this discussion removes ignorance- you now know your current design is unacceptable. No business could accept such risk. Even if they wanted to they would fail audits for any systems within scope of Sarbanes-Oxley, PCI or any other Infosec related compliance requirments. What I said originally though still stands I like your enthusiasm and I hope you don’t take my criticism personally. If you decide to continue making a product in this problem space I hope you slow down a little and curate your ideas through some of the bullet points I listed. When you have a collection of design documents I would be glad to provide a sanity check before you began a true stab at a proper implementation. Good luck either way and I hope you continue to enjoy writing Go code.
This. Look /u/cheikhseck based on your comments in this post your aim is to sell this as a service. As someone who works in infosec no company is going to buy what you're trying to sell. Why would someone use your service over proven technologies that are cheaper, more trustworthy and likely more reliable? I'm not here to say you can't do the job but that it would be nearly impossible given the competition. Also, what you've designed is an anti-pattern in terms of security. You have made zero guarantees that you are actually encrypting the data on your end and if you are encrypting the data on your end that means you are the owner of the private side of the equation which by default is not secure. That plus the fact that your services are behind cloudfare is also nebulous at best. If you want to learn that's perfectly fine and I agree with nearly everything /u/epiris says in that respect. However give your replies so far, the code you have published and how you've architected your application you come across as someone who's doing everything he can to obtain secret information from others (which again, there are *far* better and more subtle ways of doing).
VScode with vim plugin &lt;3
VS Code or nvim w/ vim-go.
Atom, Goland, and VSCode are all great with Go. I assume vim and emacs are as well since many use both but I don't know for certain. If you use one of these already you will probably be fine. Sublime text is mediocre at best, as it seems the developer working on the go plug-in stopped a while ago and I haven't seen a good replacement. I say this as someone who actually likes sublime more than Atom but still uses Atom for Go.
I’ve been using repl.it but this has inspired me to create a repo
I usually write a test for every handler and each middleware, it’s pretty low cost copy paste. Even if it may not catch many issues while writing the code, it makes it easier to come back to in N months and drop in a new feature without any regressions.
Acme
Vim
Goland
VScode
VScode
GoLand, but will go back to VSCode soon because of the price. I love GoLand, but it’s not worth it when I barely has more features than the free alternatives.
Goland
- https://github.com/mdwhatcott/advent-of-code-2017 - https://github.com/mdwhatcott/advent-of-code-2016 - https://github.com/mdwhatcott/advent-of-code-2015 (still not finished!) - https://github.com/mdwhatcott/advent-of-code (utilities) Feel free to fork the 2017 repo and checkout the "blank" branch to get started with some helpful scaffolding already in place.
Who the heck is downvoting everyone in this thread? :/
Emacs
Vim + vim-go. 
&gt; So now you can have each function open and hold a single DB connection for its lifetime. That's not solving the problem, though. You are reopening and closing a connection each time, so you still have no connection pooling. You already have to do that even now, regardless of concurrency limit. The original problem was that after execution, a Lambda process does not necessarily terminate, it may be frozen and still consume a DB connection, so unless you close it explicitly at the end of the request, so eventually you may run out of connections. There doesn't appear to be any rhyme or reason in a way the processes are created or destroyed. &gt; What do you find awkward about configuration management? Environment variables don't work for you? Environment variables are not enough for doing anything more complex than key-value pair map of basic values. I have a nested config (a map of string -&gt; section, each section with its set of key-value pairs).
Goland but it's too costly. May switch to atom in future.
VSCode, switching to GoLand soon
Atom
Emacs
vscode
Vim when writing anything.
Atom
Also see [Go 2016 Survey Results](https://blog.golang.org/survey2016-results), which asked this question.
Goland stuff? 
Golaff. *** ^(Bleep-bloop, I'm a bot. This )^[portmanteau](https://en.wikipedia.org/wiki/Portmanteau) ^( was created from the phrase 'Goland staff?'. To learn more about me, check out this )^[FAQ](https://www.reddit.com/78ilq0).
Emacs
VSCode and sometimes Sublime text 3.
Emacs
I suppose people get really enthusiastic about their choice of editor, I don't really care because people have a right to choose. Which one is getting voted down? I know VSCode is popular in the Go community for example, but I won't touch Microsoft apps if I can avoid it because of their history I find it hard to trust them, but no I didn't downvote anything :)
VS Code. It works ever so slightly better than vim-go (which is astoundingly good on its own) and the debugging is what won me over for good. That's testament to how good it is, coming from someone who's been a hardcore Vim user for the best part of a decade.
Exciting! Can't wait to take it for a spin after it stabilises. The RFC was a great read.
good‡ ol' emacs ‡it's not good, but it's addictively customizable. someone needs to make a better emacs.
liteide
vi 'til i die
vim + vim-go.
Sublime. I'm surprised to be the only one here. 
This is pretty fun. I'm struggling to use the container/ring package. I can't seems to be able to construct the ring in order. :(
https://github.com/marz619/aoc2017
I used to use it and I prefer the editor over many others, but last I checked it's go support was pretty bad.
+1 to functional opt at this point. It is also way more customizable in the future.
Emacs
Emacs or IntelliJ + the Go plugin, in emacs mode. I need IntelliJ because I use Java and Python quite a bit, and sometimes other languages like Groovy and Ruby. For quick/small projects, I just use emacs.
I am getting a few errors: init failed: unable to determine the import path for the root project /home/tristan957/Desktop/dep: /home/tristan957/Desktop/dep is not within any GOPATH/src init failed: unable to detect the containing GOPATH: /home/tristan957/Desktop/dep is not within a known GOPATH/src My folder structure is like this root/src/hound/
Last week AWS announced native Go support in Lambda: https://venturebeat.com/2017/11/30/aws-lambda-gets-go-support-and-a-tool-for-sharing-serverless-apps/
Emacs all the way. It's the only way to fly!
Thanks!
Thanks! I swear I spend 50% of the time trying to come up with variables names 😭
^^^^
They did. It’s called Vim _incites flame war while just trying to make a joke :P_
i've tried vim a bit, i did not find it to be as easily customizable as emacs, and it didn't fix some of the things i really want fixed -- like really good large file support. (there's worlds of difference here between something like sublime and emacs or vim...and i think a sufficiently clever editor could be even better.) "but dilap why do you care about large files?" it happens. you want to look at a log file. or you end up digging into some generated source.
Honestly I’ve never put the time into trying to make emacs as customized as I have my Vim setup. I find that the plugin managers are easy enough to work with and command syntax is easy once you jump the learning curve. I found basic movement in emacs to be a bit of a turnoff, but that was before I swapped to using CAPS as CTRL. I haven’t read into the source too much or the issues that it might solve, but NeoVim is supposed to be a rewrite of Vim that fixes some of its quirks. Might have that larger file support you need.
NeoVim is interesting. I should look into it. No contest that vim has smarter shortcuts. Swapping control and capslock does make emacs decent, but yeah, it's not thought out at all. Totally haphazard. Like, to go to the next and previous line in emacs is Control-N (for next) and Control-P (for previous). That's not smart! Common commands should be chosen to be easy to type, not for some stupid mnemonic. Probably the number-1 thing that keeps me on emacs is how easy it is to run a shell *inside* emacs. I've got quick shortcuts to launch a shell in any directory and swap between them rapidly, and combined w/ the ability to seamlessly use an editor on the shell output...oh man, it's addictive.
I have been struggling with the GOPATH and initializing I am getting a few errors: init failed: unable to determine the import path for the root project /home/tristan957/Desktop/dep: /home/tristan957/Desktop/dep is not within any GOPATH/src init failed: unable to detect the containing GOPATH: /home/tristan957/Desktop/dep is not within a known GOPATH/src My folder structure is like this root/src/hound/.
sublime text
SublimeText + GoSublime
I use a blend of tmux and Vim which works well for my shell needs. NeoVim does offer the ability to run a shell within a split though. 
Yes, but pip doesn't force you to put your source code in site-packages to use it.
Uhh oh hi, this is me. That was quite unexpected. 
I love sublime, use a mix of gum, sublime, IntelliJ. 
Used Emacs at the start of the year. Switched to GoLand.
Gogland
Micro, it's written in Go,
nano ^^/s
Gogland
vim + vim-go
vscode
Vim.
Eclipse I am programming in several languages and Eclipse supports them all.
LiteIde
Seriously, the debugger implementation is amazing.
[removed]
VSCode.
I originally started using vim cause it's on all servers with a workable default config, I knew it well enough to bumble around in it, and I knew it'd be there to help me on servers. Over time, I learned how to be pretty effective in that default config, but I've never strayed too far (never tried powerline, plugins, etc) cause I know it won't be there 90% of the time when I use vim. I tried Sublime from there a while back (pre-Atom), and switched to it from vim for local editing. To this day I still miss editing large files in Sublime - like with Sublime I could open a multi-gig SQL dump and edit it, vim chokes on something like that from time to time. When Atom first came out, I tried it, and it was slow at first cause of poor choices. Those have since been corrected, but it turned me off of it. I didn't jump on the VSCode bandwagon right away, but saw JustForFunc suggest it in a few videos, and gave it a try. Jumped ship from Sublime to VSCode once I tried it. A couple of years later (I think), I'm still happy with VSCode, and make do with other options when I need to open something large (but avoid it when I can). I'm curious to hear what Goland offers over Vscode though, and I'd be open to looking at switching. I'd really like to find a faster VSCode - like maybe C/C++ like Sublime instead of webview, but the features of VSCode beat out the speed of Sublime for me.
Nice! I am using it to try out different approaches and test their speed. Not the most elegant AoC repo, but I'm learning from it.
somethings about the debugger that annoy me. Mainly posting this incase there are work arounds that someone knows about. 1. Can't view objects deeper than 2 levels. 2. So much noise from the debugger into the output window 3. Sometimes I get odd errors where the debugger will stall and nothing will happen. What I like about the debugger: Everything else, it really is an incredible piece of software and makes debugging difficult problems orders of magnitude easier.
Unfortunately I won't be enjoying my Go coding, I'll be writing these design docs. Google cloud does not charge bandwith (after a certain threshold). I do plan on taking this to enterprise with a solution that can work behind their firewall. As Sythe2o0 pointed out a docker image could make that possible.
Acme
I have been using GoLand 
If you prefer vim keys why don't you try evil mode for Emacs? 
Put your code under `$GOPATH/src`, dep under `$GOPATH/bin` and everything will work. Please read [How to Write Go Code](https://golang.org/doc/code.html).
I am using Cloudflare to get free TLS. Cloudflare talks to the API servers over TLS as well. Any enterprise that would ever want to run this will receive a docker image of this API, with compiled binaries of it. :) Now I must go back to the exciting career of being a criminal.
For quick edits; neovim with the vim-go plugin. For lengthy coding sessions; Intellij IDEA with the Go plugin.
Cool, I just joined. I am not really competitive with it though, just doing the puzzles in my own time and trying different kinds of solutions.
In particular Emacs with go-mode and flycheck is pretty good. 
IntelliJ IDEA with the Go plugin and PHP plugin because I haven’t moved away from PHP completely just yet and I want one app that handles both, well. 
I've tried a bit, but I found it was too much work fighting with all the other modes that wanted normal keystrokes. (Maybe it's better now and there's some sort of automatic remapping...) Plus, also, there's just getting over the learning curve. It's hard when you've been typing emacs keystrokes for, like, forever. :-) Still, I'll probably give it another go at some point.
Emacs for most time, VS code when I need to debug.
[removed]
Okay, i get your point. But this seems to be just a convenience method, which is IMO a really good trade off. With this you build support for auth into the lib, but keep it away from the specific method implementation itself. Thanks for your feedback. Quite valuable for me.
VS Code, nano
vscode and vim
[removed]
neovim + vim-go, atom when i need to show people stuff
visual studio code and sublime text
If you customize the launch.json you can disable debugger output. That way you only get the initial 2 lines and then the debugger won't post in between. 
Go has OO it's quite nice actually I really like the way it's done. You can't do inheritance though, composition is how go does it and it seems to make for simpler code. For your case you'd probably have a struct with the fields holding your instance variables. Then your struct methods make use of http.Get etc. So you can still make a NewClient() func and get back an object that wraps your API.
Oh trust me, so is mine. I just submitted my first messy brute force iteration of day 3 part 1. Going to clean it up and try some other approaches after part 2 is done. I am not looking at the solutions in the other repos posted here until after getting at least one solution of my own that I'm satisfied with (so not peeking at anything day 3 related yet). There is always a bit of a facepalm moment when I open some of the other approaches and see ways of doing it that I hadn't even thought of.
GoLand
Vim + vim-go.
Emacs (Spacemacs technically, but before that I used a very customised emacs+evil so now I have a mildly customised spacemacs)
Also do use it from time to time, is not a bad editor for Go given how easy to run the Go toolset from the menu bar
&gt;For smaller organizations hosting a server to run a slackbot 24⁄7 is quite unreasonable Not knocking the project itself, because I really like the concept, but the only thing unreasonable here is the statement that spending as little as $5/month for a server to host random utility jobs on is unreasonable for any organisation that does actual business.
Notepad++
No.
Vim and atom
I think your question is dealing with two types of tests - internal (unit tests) - external (integration test, e2e tests,...) It is important to automate testing, so I don't think using Postman by hand to issue requests is good enough. A change in your application might reasonably produce unexpected changes in various API endpoints, and having an automated way to check validity is priceless. Write those few unit tests which are absolutely required, preferably sooner than later. If you think TDD is tiring, then most likely you're not dedicating enough time to planning your development. Most unit tests that are written should only be written once, and adjusted for changes in specifications.
&gt; People seem to suffer from the illusion, that they don't have to care about upgrades to their dependencies; Who seems to suffer from this? Most languages have great package managers that handle your dependencies for you. 
Acme. 
But Postman is able to do automate testing and it's pretty simple to set up.
"handle your dependencies" is a euphemism for "giving you the illusion that you don't have to care about them". The whole *point* of vendoring/locking is so you can pretend that upstream won't change.
[Atom](https://atom.io/) with [go-plus](https://atom.io/packages/go-plus) and [go-debug](https://atom.io/packages/go-debug).
Atom
vscode
Vscode and Gogland, still deciding.
Emacs. The go-mode with all the things is top notch, and... easily opening a buffer in a new window is a killer feature when using a tiling window manager.
Vim
Geany
Never used electron (I really want to !) but cannot you use something like go-bindata ? There are other libs as well that do the same thing.
I use the self hosted version of cloud9, built into a docker container running next to a gogs container.
Never used electron (I really want to !) but cannot you use something like go-bindata ? There are other libs as well that do the same thing.
One feature does not have that VSCode has is the spy-what-i-do-and-report-to-MS feature. I can do without ! More seriously I feel that comparing VSCode to Goland is like comparing VSCode to Visual Studio.
&gt; Goland If anything, it is slower than vscode. Has more refactoring features though. vscode is catching up, thanks to language server protocol, see https://github.com/sourcegraph/go-langserver 
BigQuery, DataFlow and BigTable are the only services I've seen from GCP that seem to be much better than what the others are currently providing 
Atom, but I intend to switch.
Vim.
So I could embed the Lib into the exe and extract it at runtime to load it?
I don't understand the down votes. I've never used Electron but embedding assets in a Go binary is trivial with libs like go-bindata. It's worth investigating, op.
Probably because i sent the post twice by accident.
Same here
Emacs
You can write a native node.js add-on but it’s not trivial. When I did that, I compiled Go code as a c-archive, wrapped in node.js C++ code and distributed as an npm module. Building a c-archive may seem difficult but all you need to do is to write some C functions you’d like to export. Happy to tell more about this approach if it sounds interesting.
&gt; One feature Goland does not have that VSCode has is the spy-what-i-do-and-report-to-MS feature How does it spy? Isn't it OSS?
[removed]
For two small services which I've written at work I use https://github.com/jmoiron/sqlx. It's not an ORM, just a simple "extension" of the stdlib sql package. So I write raw queries most of the time. But I feel you, coming from Laravel, too.
VSCode, largely because I spend my non-Go time in C# and TypeScript.
Ye ,I already thought about it. But that doesn't solve my problem I I'm not mistaken. To use taglib bindings, the user needs to have the Lib installed. But I cannot come up with anything user friendly that allows me.to bundle the dll/so file so that users do not have to install them. I'm fine if I can just have the dll alongside the exe and load it from go so that taglib bindings can resolve the c symbols. But Google doesn't show anything useful on this topic.
Cheers! This looks a bit better already! Not yet exactly what I was hoping for, but at least it makes more sense than Gorm.
Yes but it has an on-by-default telemetry option which is not obvious to everyone. It can however now be disabled by following [these instructions](https://code.visualstudio.com/docs/supporting/faq#_how-to-disable-telemetry-reporting). I'm not completely against telemetry but * 1) the fact that data is being sent back to a privately held company should not be hidden in the options, it should be stated clearly and openly to everyone at the launch of the software. * 2) i don't trust MS with my data as I see no other reason other than data collection to why they gave VSCode to the world.
I totally missed that.
Well, you could also take a look at https://github.com/upper/db. But I don't like to recommend things I haven't used myself, yet.
I used to develop Go stuff with Atom, but switched to vscode a few months ago. Working debugger, and also faster.
Currently i'm using Gorm for SQL queries and sql-migrate for migrations. AFAIK Gorm is sql injection-proof, but i'm not 100% sure. 
Same. Vim, always vim.
VSCode. Go integration is pretty slick!
Acme with Go Fonts https://www.reddit.com/r/Acme/comments/7dbxl2/acme_with_the_new_go_fonts_awesome/
vscode but looking into cloud9 on AWS for group programming. 
I just recently started using vscode about a week ago. I've been using Goland for about 6 months now with zero issues but when I'm on laptop battery I'd like to use vscode since its much more lightweight. One thing I don't like in vscode is it only shows the function signature and package informatin for the highlighted signature in the autocomplete list; What I'm referring to is this; vscode: https://i.imgur.com/XxskBvZ.png goland: https://i.imgur.com/DsVJElY.png If I could figure this out I might even move to vscode fulltime. And do you have any other settings or plugins you'd recommend? This is what I have right now. "go.lintTool": "gometalinter --enable-gc", "go.formatTool": "goimports", "go.useLanguageServer": true, "go.useCodeSnippetsOnFunctionSuggest": true, "go.gotoSymbol.includeImports": true, "go.autocompleteUnimportedPackages": true, "go.liveErrors": { "enabled": true, "delay": 1000 }, I'd really appreciate any help!
I totally agree with this, but the project that inspired this post was for a couple of coding communities, not businesses. So for me to host this bot for my community without having to pay was a big plus. But if I end up making one for work cost wouldn't be as big of an issue for sure 
I use sqlx also and some helper functions for simple insert/update of a struct.
Micro is my primary $EDITOR at work for miscellaneous text, sh, and config files. I didn't think Micro helped much with the language in regards to IDE-like settings. Has that changed?
[removed]
&gt; without me having to worry about stuff such as SQL injection As long as you use query parameters in `database/sql` you don't have to worry about SQL injection.
emacs
Lmao what? Just like ordering a package gives you the illusion that you don't have to drive to the store? I really don't get this. Manual dependency management is an issue of the past. They should adopt the way Rust handles it and move on. Versioning in Go is a nightmare. 
Has anyone noticed the plugins being overactive? You start typing a line and it indents quickly and puts your cursor on the next line and generally annoying in the way it interferes with writing code.
I also use Sublime and I am also surprised at how few other people do. 
I don't use ORMs, I just make a simple module that does the actual SQL commands I need (as prepared statements of course)
[Kakoune](kakoune.org). Lacks in plugins, but I'm slowly adding functionality (source error highlights, integrated debug, etc)
Good enough, I asumed it was just some sort of web console to issue api requests by hand.
&gt; Lmao what? Just like ordering a package gives you the illusion that you don't have to drive to the store? No, that is not an illusion. You don't have to drive to the store. And yes, by vendoring you will isolate *yourself* from breakages of your imports. But that just means you are offloading that work to *your* downstreams. It's, in a way, a pyramid-scheme. Every single person in the dependency chain takes the position of "oh well, if I just pin the version, the problem is solved, no breakages", *also* takes the position of "oh well, we can break things, downstream can just pin a version, no big deal". Et cetera, until the point where someone wants to actually *use* the software and reconcile all those breakages, to get an interoperable and supportable set of software (companies, distributions, end-users…). Where your analogy breaks down is, that in the case of the delivery driver, you are *saving* total work; one driver can deliver many packages and thus amortize the total work of getting items to customers. In the vendoring-situation, you are *increasing* total work; every vendored dependency needs to be, at some point, resolved again and the further down the dependency that happens, the more duplicate work you get. If you are maintaining a Go program that is present in 5 linux distributions, vendoring will mean 5 people need to figure out how to take your program, resolve all your imports to a version-set compatible with the rest of their respective distributions and try and fix any breakages occuring. If, instead, *you* are keeping your code up-to-date with a reasonably fresh version of the software, one person is doing that work. And that person is far more familiar with the codebase, than the 5 downstream package maintainers. Again: A maintainable system that is capable of getting security patches *needs* to limit the complexity by disallowing vendoring and having one (or a very limited set of) canonical version of every package. The end-state *will need to resolve any conflicts*. Doing it as far up the tree as possible is simply the most sane, best thing you can do and GOPATH encourages that. &gt; Manual dependency management is an issue of the past. If you believe that, I encourage you to take ownership of any binary in a linux distribution of your choice. You will find out that this is very much untrue.
If you could bundle it all together as a static lib, then you could distribute it as a single binary. You can take a look at node-pre-gyp project. How do you call taglib from Go? 
You can avoid SQL injection just by using parameterize queries. It's not a reason to use an ORM, and you'll _generally_ end up with better database code if you don't rely too heavily on an ORM. As for which library might be a good choice to use to access the database, that depends on what database you're using. If you're using PostgreSQL (a good choice) I'd look at [jackc/pgx](https://github.com/jackc/pgx) and [xo/xo](https://github.com/xo/xo).
I have been searching for the web for a feature. Maybe you will know...how do you move between various window focus? I can show/hide the terminal window using Ctrl + ` but I just want to move/shift through the window focus. I cannot find a keyboard short cut for it for the life of me.
+1 Package dependency management can be either automatic or correct. Pick one.
I have this conversation with lots of developers where I work and in the wild often. ORMs are a crutch. Learning a little SQL and understanding 3rd normal form is not difficult. It does not take that much longer (if at all) to write you query and scan in the result in your go code. The investment in learning SQL should be obvious; you may change from node to go or to java or c# or rust; but your RDB will 99.9% of the time be SQL based. As the top voted comment also suggest; sqlx is a great add on. 
I use the go-taglib library by wtolson. I would post a link but am currently on mobile. So if I would somehow link it statically the library would basically be inside the exe?
It requires you to put your code somewhere on the PYTHONPATH to use it. GOPATH is not equivalent to Python's site-packages location. That is just an automatic path that gets added to your PYTHONPATH. 