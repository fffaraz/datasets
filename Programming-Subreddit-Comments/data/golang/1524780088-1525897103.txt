looks terrible. really bad.
not on that page, though. i can't get over how bad the Go with zoomy marks looks.
seriously, why? 
I think this is a great idea. The gopher is fun, and has its place, but it can be hard to put on a presentation and sell as something professional when necessary. This gives the language a professional look to go along with its fun mascot. 
Do we have to pull a vs code blue icon to bring back the gopher?
Yeah stay with Java because the logo is better...
[removed]
I‚Äôm reminded of every single time we redesigned the front end to a very popular news site and the process was always the same. People were *used to* the old version and were grumpy when the change happened. In the end it‚Äôs only about what people are used to, and not actually what the redesign tries to achieve. It‚Äôs a weird thing which is hard to measure, because it‚Äôs so subjective I guess?
More likely the design agency had no clue what Go is, but hey its related to software somehow so that must mean apps right?
"our beloved Gopher Mascot remains at the center of our brand." literally at the top of the page
same, for some reason people think they're killing gopher when it says "our beloved Gopher Mascot remains at the center of our brand." at the top of the page.
Awesome.
Who cares about a logo, why is it this important? Also, who paid for this? Is Golang still controlled by Google? 
[removed]
It‚Äôs the letters G and O
[removed]
Take a look at this first https://golang.org/pkg/encoding/json/#example_Decoder Something that is confusing for me is that JSON is a serialization format, not an object or struct type. There is no "asset" in your code, only `t *SimpleAsset` where t is unused. I am guessing `result` is a JSON string, but it does look like you need to process it at all. You might want to go to a Hyperledger subriddit since I have no clue how that interface works.
Neat story. I remember your videos. Really kinda shined a light on some of its power. However, I feel some how the community really hasn't addressed the really technical parts of go in books or video. There is one book that goes far, "The Go Programming Language" but as much as there a lot of diamonds in it, it really is a book you have to drive into the forest and lock yourself down to read. That's why your stuff is great but there needs to be a middle book/video. Like idk, taking the reader interface and making your own and modifying it and adding other types or something really deep.
Think about it this way, developers are already sold on go, now it's just a matter of convincing the big wigs to migrate from java or c#. Enterprise branding is a good way to achieve that
If you don't care about branding, that's totally fine: ignore this and go back to writing awesome Go programs. If you're already using Go, you're probably not the target audience for this, and that's 100% OK. Beware knee-jerk negative reactions. It's always easy to be a quick critic. It takes more time to absorb something new and different and give it a fair evaluation. The fact (like it or not) is that branding and a professional look will help with not turning away other Go developers, not to mention the people they have to convince to let them use Go at work. Replacing the 1995-esque web design we've been using (which was mostly my doing) is a positive thing for more Go adoption, which grows the Go community and helps everyone. Also, in case everyone forgot, this was the old Go logo: https://golang.org/doc/go-logo-white.png. The new one captures the same spirit but ends up being a bit more versatile.
The version with the gopher's teeth is the best, it actually shows the two rounded letters are eyes, without it it looks a flag on a racetrack.
I am confused. I thought all variable names are in UTF-8 encoding, as is all Go source code. 
Certainly not our intent. I will ask /u/spf13 to check on this. Either we'll get clarification that the license doesn't imply that, or we'll change the license. 
Actually Microsoft's is a box thingie with four colors in it, but really I just think you're reading into this a little bit. The logo is fine
IIRC from art class, "logos" have to have letters, so the Windows squares are an "emblem", not a "logo", for Microsoft.
The new logo doesn‚Äôt wow me, but the gopher just looked so amateurish (sorry, downvote if you must :) ) So net gain I guess.
Why can't this be an official target like wasm?
This is the kind of logo I'd come up with after a week struggling for a better idea. Also, almost as good as the Windows logo redesign. huehue.
Cool, thanks for the info :)
My shirt is so perfect as a response to this. https://imgur.com/a/ZzIISHE
^(Hi, I'm a bot for linking direct images of albums with only 1 image) **https://i.imgur.com/fuzauAD.jpg** ^^[Source](https://github.com/AUTplayed/imguralbumbot) ^^| ^^[Why?](https://github.com/AUTplayed/imguralbumbot/blob/master/README.md) ^^| ^^[Creator](https://np.reddit.com/user/AUTplayed/) ^^| ^^[ignoreme](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=ignoreme&amp;message=ignoreme) ^^| ^^[deletthis](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=delet%20this&amp;message=delet%20this%20dy1axfe) 
That‚Äôs Windows. Microsoft is the word ‚ÄúMicrosoft‚Äù.
Wait until the sub's logo gets updated
The G makes it look like a stick figure dude touching himself inappropriately if looked at sideways.
Ehh‚Ä¶ we'd need a graphical interface to get people from both Java and C#
Pretty cool. I typically end up with a small mess in my main function, spawning a bunch of goroutines for various services then cleaning up in reverse order when it's time to quit. This makes it much cleaner.
Oh man the VSCode drama. I was so shocked when I saw my icon orange that I went Insider, with a green logo.
It is both good and bad. It obviously isn't funny or cute so it fails as a community building hacker icon. But consider someone with a background in business or marketing who buys their wine and clothes by the label and knows even less about programming. Imagine such a person sitting in their office and their boss tells them to choose a new courier company and they are handed a brochure from *=GO* and one with a cute animal on it. Which is the safe option? Those people are going to hire people with this logo on their resumes. They are going to buy services with this logo in their marketing materials. I think the gopher is awesome but the new logo is an acknowledgement of the craptastic world we truly live in where safety and mediocrity win, not unlike Go itself in some ways. Anyway the gopher is a mascot, not a logo. It can still be the mascot.
Wow, that's a stretch... *ba-dum-tssh*!
I hope this isn't a sign of Google strangling the Bell Labs-iness out of Go. But whatever, it's a logo. I'll always love the gopher, but I don't care that much.
Hey wjkohnen latest commits on develop achieve the deletion of pointers not changing the semantic of the SyslogMessage' fields neither the public API, at the meantime. This also brings (clearly) some significant performance improvements (ns/op &amp; particularly allocations). To do so I have used an intermediate private struct within which the machine stores data. The hydration within the final SyslogMessage is done at the end with the help of some smart flags within the intermediate instance. Let me know what you think about it. Bye, l.
Heh, that tweet popped up in my feed and it reminded me of a blog Cloudflare did analysing the cryptography performance on ARM, and basically saying it wasn‚Äôt optimised. I thought to myself, ‚ÄúCloudflare will be pleased that someone‚Äôs done that, bet it improves their benchmarks‚Äù and only subsequently did I realise the guy tweeting was Cloudflare CTO.
It may very well be but if we wish to minimize such responses we must react correctly. With that being said it's not your responsibility to do so. I've seen many responses like yours that are less valid and it has always irked me. So I thought I'd speak up this time. 
... I want a printed Go handbook, i think it looks cool haha
Guy who did it works for Intel
&gt; encoding It does encode/decode UTF-8. Will add some tests so you can have a look... Yes there are some missing escaped characters cases if looking at RFC which we are working on adding, but parsing UTF-8 strings does work. Or maybe you can be more specific :)
Too much work and overhead, not enough benefit to justify it. Once the wasm target gets mature and optimized, it'll be the best way for Go to run in browsers.
the person jgc was referring to is also the writer of that blog post :)
I‚Äôd start simple: rest and json. Once you have you have your stuff running, evaluate and see if you need something different. 
Some other decoders also use unsafe package... even `strings.Builder` in standard package uses it: https://golang.org/src/strings/builder.go
This is an unofficial subreddit, the gopher can stay.
Yes, it will affect performance if one of them is encountered, if no, it will not, or not much. 
Won't this panic if w is not an http.CloseNotifier? I'd prefer the request context.
That's not how escaping works. You still have to do comparisons against the entire input sequence to determine if any action is needed, which is a lot more expensive than just copying strings around. If you have to escape a string, then that will be enormously more costly than even just validating it.
Why do you care about those low-level details and implementation if you just decided what language to go for? Also, strictly speaking, microservice is not an architecture. If you want to scale, Google cloud can handle that for you pretty well, unless you have very special requirements for your project. Whether to choose RPC or REST API should be postponed as long as you can. Spending more time on reducing the technical debt should really be the priority imo.
Is there a way to provide feedback / corrections to the brand book? Maybe it's unimportant, but I believe English describing Go should be simple and precise, just like Go itself: &gt; "However, when appropriate, it can and should be used on communications that are Go branded, but should not be used in place of our logo, nor should it be placed too closely around the logo, so as to infer it's an alternate logo." "Infer" means to guess or deduce. I think the word they wanted was "imply," which means to suggest.
I'm trying to figure out what series of decisions lead them here. What is the question to which the answer is "we should talk to a brand agency about a professional logo for our programming language"? 
&gt; It looks a little throwback 90s Plan 9-ish Have you even seen plan 9? Plan 9 used light, almost-white, pastels, medium grey and medium weight fonts. Look at the yellow and fuchsia in the palette of this thing? Does that look pastel to you? And the font is the same ultralight round webfont every "designed-for-iMac" website has these days. It looks nothing like Plan 9.
You could go to almost any bathroom, pull a piece of used toilet paper out of the shitter, and have a better logo. This logo isn't garbage, its shit. 
I feel like you can't win with reddit. I think it as time they updated their brand and website. New stuff looks good in my opinion, the gopher is also here to stay. So where exactly is the problem reddit? Go needed a simple text based logo 
The CLs show plenty of ARM64 updates
&gt;Also, in case everyone forgot, this was the old Go logo: https://golang.org/doc/go-logo-white.png Having trouble seeing the white-on-transparent logo? Have a look at https://blog.golang.org/gopher/logo.png instead.
This is the correct answer. Dont spend ages evaluating every little detail. If you have a skilled team you should be able to iterate towards what you need if you use Java, Go or whatever. 
it was sarcasm man
So the GO logo is sanitized and given some rules to prioritize branding over ... not branding? 2/3 of the last three pages of the brand book cover the Gopher: How it's not a logo and **a model sheet to create one's own gopher** So it's still respectful of what matters. I'm in.
So bad. I hope they didnt pay a lot for this
Jesus the blog post about what happened was like 20 pages.
I also like vanilla, one scoop
Go is a nice language and high quality tool set. If only we could keep marketing people away from it. Also product advocates, code conductors and similar, for that matter.
Ctrl-F generic Didn't say no!
Netlify even has proxying support built-in specifically for working around CORS issues: https://www.netlify.com/docs/redirects/#proxying So you wouldn‚Äôt even need Lambda - just a one line config file. Looks like this would be perfect for your use case, OP: static content hosting and a CORS proxy for the Medium API.
Unfortunately you would need tests for the API and separately tests for the UI. Which is pretty tiring, I know. You can think of the separation between your frontend and API in the same way you would with a mobile app and the API. Both need to be tested separately and together. Speaking of which - one advantage of doing so is if you actually do need a mobile app, hey, the API is already there, available and tested.
Well, it depends. You don‚Äôt necessarily have an additional 10 minutes of ‚Äúeverything is permitted access‚Äù. For most routes, you do have access, true. But if you try to write (e.g. post a comment here), we already need to query the DB to get the user (e.g. update karma), we might as well double check if access was revoked at that point. But for most routes we avoid querying the db and avoid a lot of load. This would work for Reddit. It wouldn‚Äôt work for online banking. (Or would it? If you can still see the accounts for X minutes but get rejected as soon as you try to make a transfer / change anything, maybe it‚Äôs an acceptable trade off)
The thing that freaks me out with JWT is the notion of having a ‚Äúmaster key‚Äù (depending on the signing algorithm). Basically, if it leaks somehow (e.g. you load it from an env var and for some weird reason it‚Äôs exposed in your crash logs), you‚Äôre done. With the key out there, you can generate tokens at will and impersonate any user. If you encode a role in the token (e.g. admin), it gets even worse. And that will go on and on until you realize it and rotate the key (if you ever realize it). What I haven‚Äôt seen around is an easy way to do automated and periodical key rotation. Which is a bit tricky to do as soon as you have multiple API servers around (need to be able to accept old and new signature at the same time while all API servers are being updated).
What the hell? Looks like a sports drink logo... 
Hopefully a manager that makes decisions based on brands wouldn‚Äôt last long in tech. But, experience tends to tell otherwise...
Take a pretty common use case 90% of web apps out there need: registering users, authenticating them and providing password resets. The amount of work needed to do that in Go is unbelievable. Throw OAuth into the mix (e.g. FB auth), 2fa and recaptcha and you‚Äôve got yourself a *massive* effort ahead. The sad part is: once you‚Äôve accomplished all of this, you‚Äôve got nothing: an empty app where you can sign in and out. The only good example I ever came across is Netlify‚Äôs gotrue project: https://github.com/netlify/gotrue It‚Äôs not a library though - it‚Äôs a standalone app. So you can just look into what they‚Äôre doing and replicate parts of it.
With logos you have the same difficult task as with code: simple is hard. The most important things for a logo in my opinion is to be simple (eg. no fine details, no gradients and such), recognisable and delivering an idea. This new logo does all of those things very well. And this is no easy thing to do. I think they did a great job.
The new logo reminds of that of New Balance.
In this case, less is not more.
oh god what the fuck did I just read...
You screwed me lol
http://www.maximumfun.org/shows/jordan-jesse-go
* Have you calmed down now? * Did it make you feel better?
You are complaining about the reaction here and on HN but this is really a spirit you and Pike fostered by being extremely dismissive about new ideas in relation to the language, at least at first. You encouraged a bunch of people who only swear by the std lib, who hate creative ideas, who are dismissive of others and even publicly humiliate library creators to be the head of that community. You didn't create a diverse and inclusive environment but an extremely conservative and rigid one. These reactions are definitely the product of a community mindset you and Pike favored. That's why each time something new is brought to Go, let it be aliases or go.mod or even a new logo (which is good by the way), the same bunch of people starts complaining it's not their "good ol' language" anymore. This behavior have been extremely tiring for some of us in the Go community who want to move the language forward, not because they want to turn it into Enterprise Java, but because the competition is not resting on their laurels.
I'm checking it out, seems cool
I don't like it at all, it does not look new and different but totally conventional and boring to me. But that is just an opinion and maybe, as you say, I will appreciate the new look when I get used to it. What really makes me sad is that this is a very clear statement in favor of Go as a Google product instead of Go as a community driven project. The image of the project is a very important decision and the involvement of the community in it was zero.
Gopher is a fork of Go, but keeps the cute Gopher logo FOREVER. ;) LONG LIVE GOPHER! Our homepage: http://gopher.gg or https://github.com/gopher-lang/gopher 
APPLY for Maintainer!
When I'm in presenting my architecture design to the management team, to get them to buy into the project, its plan, and most of all the budget that will pay the team's mortgages for the coming year, I will now be able to print that brand catalogue out, and pass it around at the same time as I'm saying: "one of the major expenses incurred this year will be to re-implement some of our key NodeJS services using the Go language as we have identified the following advantages: long term cost savings, performance etc etc etc". The very first question will be "what's Go?", and thats when they get to see that catalogue, and the Go logo. If they *never* see the Gopher I will be quite happy. Why? Because people with millions don't give them over to budgets represented by a cartoon.
Disappointing, when it could have evolved the cat-v way! http://gofy.cat-v.org/_imgs/mascosts.jpg 
What was the reason behind forking ?
Did you even read the blog post and the brand guide? The gopher mascot is untouched by the new brand guide. The logo, however, changes from https://blog.golang.org/gopher/logo.png to https://blog.golang.org/go-brand/logos.jpg
Math gets away with mostly one letter variables. Why programming would not?
It just feels like a parody
[Yes](https://giphy.com/gifs/yes-nod-robert-redford-xKy2w6LehxxHa)
It seems that your comment contains 1 or more links that are hard to tap for mobile users. I will extend those so they're easier for our sausage fingers to click! [Here is link number 1](https://giphy.com/gifs/yes-nod-robert-redford-xKy2w6LehxxHa) - Previous text "Yes" ---- ^Please ^PM ^/u/eganwall ^with ^issues ^or ^feedback! ^| ^[Delete](https://reddit.com/message/compose/?to=FatFingerHelperBot&amp;subject=delete&amp;message=delete%20ID_HERE) 
I miss the gopher. 
While it may like Go is sacrificing it's old brand to appeal to corporations, surprisingly, I'm excited. The way I see it, there are two paths for Go's adoption. 1. Go keeps it's old brand and loses adoption from corporations, but keeps Gophers happy. However, less adoption from corporations means less adoption overall, so Gophers are less likely to work with the language they love at work. 2. Go sacrifices it's old brand in favor of a new brand that appeals to corporations and potentially gains massive adoption from corporations. Gophers are a bit sad at first. Did we lose our identity? However, fast forward a few months or years, as more corporations adopt Go, Gophers are much more likely to find Go jobs. Gophers are happy.
This is awesome!
–ì–æ—Ñ–µ—Ä —Å–æ—Å–∞—Ç–±
Yeah at least they are able to be productive compared to the Linux guy who is busy compiling his drivers and the Windows 10 guys PC which is forcibly installing updates.
While the new brand looks unfamiliar, I believe we should be excited. See my comment at https://www.reddit.com/r/golang/comments/8f5n19/gos_new_brand_the_go_blog/dy21058/
That's what I said.
I have never once seen an investor that even cared about the programming language(s) we use at the company, let alone endorse one based on its logo. Maybe we just have better investors ¬Ø\\\_(„ÉÑ)_/¬Ø
The Gopher is dead. Long live the Gopher.
If this was a post about "Maps in Go", with no contextual hints, yes, specify what you mean because **that** is ambiguous. Everything in the list is a data structure though, it makes sense that this is a post about maps in the context of data structures just like arrays and slices are. 
I tried to see the global picture I guess, even though I am a developer. 
See "Maps in Go" alone would to me be less obscure than "Arrays, Slices And Maps In Go" I read, arrays, bits of arrays, and creating new arrays. The link went from my mind when I clicked through. I was just excited to read about something, to have it be a different thing. 
No, the new one ends up scaring even more folks away. 
I don't mean the fonts used in the OS; I mean the marketing materials. https://en.wikipedia.org/wiki/File:Bell\_Laboratories\_logo.svg https://commons.wikimedia.org/wiki/File:Glenda\_bunny\_mascot\_of\_plan\_9\_from\_bell\_black.jpg They used a bold sans serif. The new logo is bold, italic sans serif. The italic is maybe more reminiscent of 90s Microsoft. https://commons.wikimedia.org/wiki/File:Microsoft\_logo\_\(1987\).svg The pastels are not AT&amp;T\-like, but it's a part of the current 90s nostalgia boom, which like all nostalgia booms is distorting what things were actually like at the time.
&gt; JSON is a serialization format, not an object or struct type Forgive me, I said that wrong. [I am making go structs from a JSON array like this](https://transform.now.sh/json-to-go/). Then I am just using the names of those structs to name my CRUD operations. I am told these structs are going to be my assests. I am only an intern so I get it if I sound like I don't have a clue haha. 
Ah, I see what you mean by maps. Functions are first class citizens of Go, but it's not a particularly functional language. And being a strongly typed language without generics, I'm not familiar with any manner of accomplishing the map function that doesn't simply abstract the underlying imperative style implementation of idiomatic Go. Arrays, slices, and maps are the only data structures included in Go by default, and seeing them listed together that's what I assume it's about. 
You can just [read it](https://github.com/golang/tools/blob/master/cmd/present/static/slides.js) yourself. The code has no consistent formatting. It's polyfilling classList in case we need to support IE4 or something. (There is no scenario where present needs support before Edge.) There are random, JS illiterate semicolons like this: ```js function hideHelpText() { document.getElementById('help').style.display = 'none'; }; ``` I dunno, it might be fixable, but for something of this complexity, it's probably easier to rewrite it in Vue or something.
Boy, do I have good news for you. https://github.com/mjl-/duit
Yeah, in professional presentations, on the "technologies we used" slide, the gopher always stood out, but in a bad way. "Made with javascript, sqlite and something that looks like a funny, hand-drawn animal".
The gopher is a cool mascot but a bad logo, IMO.
You changed my mind. Thank you.
I counted 6 gophers on that site. The gopher is safe. I declare today's PETA meeting adjourned.
&gt; being a strongly typed language without generics, I'm not familiar with any manner of accomplishing the map function that doesn't simply abstract the underlying imperative style implementation of idiomatic Go. I'm not sure any other language have particularly fantastic ways of doing this either. It's something I've semi solved (although I don't need it, it's just learning how to approach in golang). Quite a lot of my work involves either lists or collections so these sorts of things are essential. 
Thanks for all the details. This helps a lot and I share a lot of your insights as well. My biggest concern is that we do need something simple right now so REST/JSON might be good. However, we are currently processing around 1200 queries/second. That's why I want to have binary formats prototyped. I have heard of Twirp and I liked how it makes it simple with HTTP 1 and HTTP 2 out of the box. Did you have any other experience with it? 
Super embarrassing. Will get it fixed.
This is exactly what I had in mind too. But our current monolithic application handles about 1200 requests / second. So I am worried that adding REST/JSON processing on top of that will result in a performance loss. I want to start simple and then prototype. But the team is new to Go and I am hoping to give guidelines. 
I am working on mine (https://github.com/aboukirev/ouro), right now implementing HLS and MPEG-2 TS streaming in particular. Gotta make something usable before I push to Github. It also lacks some things like handling Annex B NALs. And it is aimed at streaming, not health checks. For health checks you don't need RTP/RTCP, stream parsing, etc. Most of the experimental RTSP code on Github handles RTSP and digest authentication. That's all you need, I believe.
I see what you mean, and yes, they surprised us all with that decision, and not necessarily in a good way.
 WARNING: this library is work in progress. backwards incompatible changes will be made. Doesn't inspire a lot of confidence...
Whatever
Yikes. It looks like a logo of some Chinese copy brand of low cost running shoes.
Awesome! I'll take a crack at reading through it next week. I'm sure you'll have better feedback before then, but regardless, thanks for the writeup.
Since you have a number, I‚Äôd come up with a prototype that‚Äôs specific to your scenario (you don‚Äôt want to run a generic rest/grpc comparison as grpc will be faster). Another thing to keep in my is that microservices are by design more chatty, so you might have some latency coming from that as well. I‚Äôve used Fortio before to do something similar: https://github.com/istio/fortio 
Since you have a number, I‚Äôd come up with a prototype that‚Äôs specific to your scenario (you don‚Äôt want to run a generic rest/grpc comparison as grpc will be faster). Another thing to keep in my is that microservices are by design more chatty, so you might have some latency coming from that as well. I‚Äôve used Fortio before to do something similar: https://github.com/istio/fortio
Depends on your application. If it‚Äôs a small amount of traffic you might not need much of that. Even a script that restarts your application could be enough to get started. Start having problems? Start implementing more sophisticated controls and redundancies. 
That new logo belongs on some bargain basement running shoes.. it's *really* not what I would expect.
This question has such wide scope that one could write books on the topic... I would start by reading the DO best practices: https://www.digitalocean.com/community/tutorials/building-for-production-web-applications-overview. Most of the patterns there (observability, availability, scalability, security, recoverability) can be applied to any language.
Hooray!
It came out 10 days ago. Relax.
If it's a simple app, maybe just create systemd integration scripts for start/stop/status etc. Then maybe integrate digital ocean monitoring to check for uptime. Make sure only the required services are allowed through the firewall and you should be good.
Packr.
Yeah, if your OS of choice has systemd, use that or docker if you feel more comfortable with that solution. Since go binaries are statically compiled docker is mostly handy if you need control over a lot of different services and be able to move them between OS'es and container orchestration systems. A very simple systemd setup is creating a file /etc/systemd/system/myservice.service [Unit] Description=my service [Service] Type=simple User=root # or rather a specific system user for your service, you can also tell systemd to create a temporary user which is only valid for the session but that might not be convenient if your application has private data on the file system. EnvironmentFile=-/etc/myservice # if you want to automatically import settings into the enviornment EnvironmentFile=-/etc/myservice.d/* ExecStart=/usr/local/bin/myservice -log_dir /var/log/myservice -flag -flag -flag... Restart=always # read the systemd docs to understand (re)start options... # RestartSec=5 # StartLimitInterval=300 # StartLimitBurst=3 A somehwat annoying thing with systemd is that it's config format has changes a bit over time so your OS might not have the exact same keywords as I used.. and then activate it: systemctl daemon-reload 
Having been a professional programmer for almost 20 years now, I have a lot of experience dealing with management and decision makers all the way up the chain to the executive level, and one thing you're not considering is that it's not just the flash that gets them, it's the dedication it shows to the cause and appearing professional. It communicates that the language takes itself seriously and intends to grow its community. They consider it a bellwether of maturity and market impact.
Nobody mentioned goa, so I'll do that. https://goa.design
Not sure if you've checked out Gizmo, but the guys at The New York Times have put together a great microservice toolkit, just for reference! https://github.com/NYTimes/gizmo
Hi, Thank you for detailed answer. Today I wrote an easy tool for checking of RTSP server by network connection state and headers. This source is fully satisfy of all mine requiments. I just added this to Zabbix and have fun. But. After my little win I thinking about full-flavour monitoring tool :) I mean that I want check the consistense and validity of RTSP-stream by capture of the one frame from stream periodically. Can I use your solution in this case? Is it very difficult? :)
üôÑ
Everyone in the comment : &gt;I hate this logo , it's no the real Go ! Do you guys realize Go has to compete with language like Java / Node / C# which are very well established ? This change of logo is needed to make Go more "mainstream" currently go is mainly use for large scale applications ( Uber , Stripe , Twitch ), cloud native apps ( with docker ) etc... If Go wants to compete with all the others it need this change to appeal to a broader audience , and build a bigger community . I can't deny this is somewhat a sacrifice in the identity of the language . The Go community isn't well represented with this logo I think.
I think it's reasonable to assume that when a Gopher tries to convince management to pick Go, at least some managers would be more likely to approve if they've read the Brand Book. I would argue that the Brand Book would generally appeal to managers more than visiting golang.org would.
I'll take that as a yes
&gt; Then again, maybe a new logo is a good idea, the Gopher itself isn't much of a logo as such, more of a mascot Yeah, the gopher is the mascot, and one that does not seem to be disappearing. The Go logo itself has always been a [written Go with lines to the left](https://i.imgur.com/ERcvRAp.jpg). This just cleans it up so it doesn't look like it is hand sketched.
Internal budgets are seldom seen by investors, it took quite a lot to get the head of engineering, the CFO and CEO to buy into not using Java, and to go for NodeJS. Sure we saw the benefits of the rapid development, but now those cloud servers are incurring operating costs that are far greater than budgeted. A tech spike demonstrated the cost savings to switch from NodeJS to Go, and these savings will be essential if the system is to scale. So any tool at my disposal will be handy to convince them to fund the switch in technology when they would far rather be paying money to get more features demanded by sales and product managers. In short, its a competitive internal market, and you bring out your best guns. That brochure is going to be printed out and left on my desk.
Thanks. That's a nice framework. I'll look in to it. 
Please.
Not very excited about the new logo. It is boring and sterile in design (at least that's my first reaction, emphasized by the linked video where other logos where showed that were actually more interesting to me). &amp;nbsp; On the other hand the entire design package looks much better than what we have now. I'm excited for the official website's upcoming design. &amp;nbsp; Overall, I think it will increase Go's adoption. I know people that got turned away from Go because of the landing site (which should never be the case, but it still happens).
Maybe it would be more efficient/easier to grok with more descriptive names?
You can write FORTRAN in any language.
For screenshots it might be easier to get static images from cameras. Most support just giving you JPEG. Alternatively, if cameras can stream MJPEG, it's just a sequence of JPEG images with a special text separator - easy to parse. As for getting screenshots from RTSP, you could start with my solution and get just the IDR packet that contains full frame. But... you'll have to decode that frame into an image, which requires h264/h265 decoder. I am not aware of any implemented in Go. Have not searched thoroughly though.
Thanks for the thorough response!
Thanks for a thorough answer!
Thanks! There was a lot of good info there
This is a local place that delivers food and has an uber-like ride service, check out their logo: https://www.gocargo.io/carryout.html They're in the floor above me and we're all on the same slack channel. They think it's hilarious. 
Go's logo has the speed stripe (JJG doesn't). JJG has an exclamation mark (Go doesn't). They're both italicized san serif, but they're also clearly different fonts/weights. It's similar in that it is the word "GO", but other than that not that similar.
Doesn't inspire a lot of confidence.
I like the calling conventions, i might adopt it into a scheduler I wrote. Maybe make the "something" a defined func and accept a context, so that way the something can be canceled if the scheduler is stopped. type JobFunc func(context.Context) My problem was i had thousands of things to do every few minutes so my scheduler works on "time slots" and spreads each Do(something) over the time period. This way each scheduler uses 1 timer and each "tick" progresses through a map of the functions to perform in that time period. Everytime another Do(something) is added, it is either put into an empty slot, the time period is split into smaller segments and then added to an empty slot, or if it has already been divided to 100ms, the function gets added to an existing time slot so every "tick" performs multiple something's. My scheduler doesn't guarantee something happens exactly every x amount of time but it's close enough. My next planned improvement is to add weights so if one Do(something) takes a long time, it gets moved to an earlier slot and consecutive Do(somethings) get moved to further slots.
Why tho? It's new. Like, that's how development goes for the first bit of the life of a new package. So it's not mature and API stable yet. Don't use it if you need something in production, but like, this is the first cross platform GUI lib we've gotten that doesn't depend on GTK or Qt. That's super cool in my book, and very welcome.
https://blog.golang.org/constants Look at the last section under "Numbers"
The references to "untyped constants" should interest you here: https://blog.golang.org/constants
Thanks so much for doing this, it is greatly appreciated!
Niave question but much of these prs are ASM implementations of crypto functions. Does that mean that the compiler isn't generating very efficient ASM for arm? What's stopping this from being written in go?
Cool, I'll try it this weekend!
Friday, April 27, 2018 - Google announces their new "Go" parcel service
Seems like a generic logo.
Cool advertisement bro, you're not doing yourself any favours.
Looks like they deleted my post...
Small idea, if you make the Every\(\) function variadic, then you could do: Schedule().Every().Second().Do(something) Which would let you eliminate the EverySingle\(\) function, and still have a readable api, with one less function.
Been using [twirp](https://blog.twitch.tv/twirp-a-sweet-new-rpc-framework-for-go-5f2febbf35f) at work recently as we are slowly transitioning some of our REST endpoints to services. Twirp uses HTTP 1.1 and allows for sending JSON to your service endpoints which is nice for curl and Postman requests. However, it sounds like you might be falling victim to cargo cult development practices. There's no need to lock yourself into one framework, language, or "architecture". Software is a living thing, and living things evolve. First you make it work. Then you make it better.
[removed]
at least they can't introduce memory leaks in Go... I have seen so many memory leaks in C++ code that I suspect came from Java programmers.
Everyone can introduce leaks in C++ code :) It's quite easy to not forget to free resources correctly in Go as well. Any go-routine which is fired off and never completes due to an io-wait or something is a kind of a memory leak. I accidentally allocated a new time.Ticker each 200ms instead of just using one instance.. The memory leak is small but when I saw that the cpu usage increased somewhere around a % per day even though the request rate was about the same I looked it up and I had maybe (don't remember) hundreds of thousands of tickers being scheduled all the time :) I'm not sure if that leak would be fixed even today since the allocations were small enough to go by unnoticed if it weren't also messing with CPU time.
That is actually a great idea. Its what I'll do next.
[removed]
I think you need math/big for crypto
So if I‚Äôm reading this properly, this adds vgo support? Neat. Slightly related topic: I‚Äôve been wondering if it‚Äôs time for people to start trying to take a crack at writing a new gocode that uses the source files directly. Given that you clearly have some knowledge of gocode, what do you think? 
What?
Yeah, you're right. I didn't want to sound harsh (still the code I was talking about was very bad, many uses of new and no delete). I've certainly made mistakes in Go and C++ too. There are some particular things in Go, that are still pretty alien/unintuitive to me, and sometimes mistakes happen because I'm working with different programming languages. E.g. the other day, a colleague wrote a for loop which contained a switch statement (it might have been select, but the following should apply to both). I knew Go had the fallthrough statement so you don't need to write 'break' at the end of case-clauses. I assumed that break would break out of the for loop, which wasn't the case. We wrote a quick example at Go Playground to be sure. In one of my Go programs I forgot a defer file.Close(); so most of the time it worked well (if you used it on directories that contained few files), but once I reached the limit for open file descriptors the program crashed. 
It's probably no coincidence that a member of the initial Go team proposed this change: require explicit labels for break, continue ( https://github.com/golang/go/issues/8591 ).. I think I agree with Robert on this one.. I almost always add labels when I need break/continue just to make it extra clear to read the code.
That's exactly what /u/mdempsky's gocode fork (that I forked) does! That's why it doesn't break every other Go release, it uses the official golang.org/x/* repos to parse the packages' source rather than using a custom binary package parser that's forked from internal go code. It is noticeably slower than nsf/gocode with big packages, but can't really use nsf/gocode with go tip right now it's either slow or none. Also I'd like to point out that all credit goes to mdempsky and tiborvass, I just merged the PRs and fixed few conflicts here and there.
Lol why is the thumbnail spike from cowboy bebop? 
tl;dr chose vfsgen: https://github.com/shurcooL/vfsgen because it doesn't require an executable, and it allows you to directly serve the gzipped content.
&gt; I‚Äôve been structuring my Go projects against mage instead. For anyone else who might be tempted to search for this on the Web: &lt;https://magefile.org/&gt;, which is definitely not a mage build for Skyrim.
I hope you didn't waste your time and money on this expecting some form of popular reception or something...a project fork isn't a joke in the real world.
It's a nice looking brand book, but I so want to take a red marker to it. pg 5. Does "exemplified" need to be repeated in both columns? pg 6. What's with all the periods? "Thoughtful." "Simple." etc. pg 8. "~~3~~ **three** key" pg 8. "These segments ~~has~~ **have** different..." pg 17. "text over 36px" vs. pg 18. "14 pt or larger" pick a unit? pg 21. "~~infer~~ **imply**" (as above) pg 22. "~~guideance~~ **guidance**" pg 22. The YouTube link is linking but not to the video
Honestly the only reason I clicked on this 
Russ Cox (vgo), Sam Boyer (dep), and Jess Frazelle (dep) did this Hangout the same week that vgo was announced. https://www.youtube.com/watch?v=sbrZfPgNmfw
Can‚Äôt the `time` lib already do that?
What is the difference between the dictionary.txt and the zh/dict.txt? The first seems to have some insanely long compound words in it. I note that it ignores words (for Chinese and Japanese) that aren't in the dictionary so they don't get added to []Segment Is that by design? If I wanted to segment concatenated English words such as "Goefficienttextsegmentation", what would I need to do? Create a dictionary of English words with word frequencies? Thanks for the work 
Nice! Would be handy to set the schedules times and named tasks from a config file
At some point Python moved away from this with the 0o12 syntax (letter o for octal, similar to x for hexadecimal). https://www.python.org/dev/peps/pep-3127/ The change was proposed for Go, but declined. https://github.com/golang/go/issues/12711
Nice, nice! Well thanks for posting this then, I hadn‚Äôt heard about it personally. I‚Äôll be giving it a shot. Do you think your changes are likely to be merged upstream into mdempsky‚Äôs project? If not, are you planning to maintain your fork? Having autocomplete is a subject near and dear to my heart so I‚Äôm interested to help, just haven‚Äôt really been clear on how best to help so far. 
nit: &gt; A Finite Field over p is a set of elements from {0...p-1} There are actually finite fields for any prime-*power* - that you can get by taking the quotient ring `F_p[X] / (X^n - 1)`. And these are often important in crypto too.
Dict.txt is much smaller than dictionary.txt. Of course, you can customize the dictionary, and you can easily load multiple dictionaries.
Thanks for your praise.
**Thanks.**
A dirty idea: If rotating the logo towards left for 90 degree, what do you think?üòÇüòÇ
To add to this, using constants for rule types would be a lot better as well. That would give a nice predefined list of rule types. Having to type magic words like "alpha" as pure string is error prone!
I come from a C# background, so maybe it's just a cultural difference. But it's been bashed into my head, especially by books like 'Clean Code', that's it's always preferable to have descriptive variable names, without abbreviations. I respect that other people feel differently and I totally understand that's it's a very subjective thing. However, it still surprises me that this is a general thing for golang? My argument for it, which is very much the same as given in Clean Code, is that any time spent on figuring out what a variable means or a function does, is completely wasted time. If I am making it harder to read code, then I am doing a disfavour to myself and my colleagues. However, I guess the real important thing, is just to find what works best for yourself and whoever is also working on the code base....
The name is very unfortunate as it clashes with [`github.com/jonboulle/clockwork`](https://github.com/jonboulle/clockwork). 
I just wrote my own scheduler in go! Its called krongo! I see you've used strings like "8:00" to specify the time durations. I used the time.Time for that instead, I felt the parsing of the time would be better left outside the library's scope, but I like how your API is readable.
The logo is not as cool as the language...
I also thought about defining field elements as part of a Galois Field GF(2^w) 
Bug fixes are also happening at the same time, and you did not raise an issue and describe the issue clearly, the platform and who they are?
Golang has a lightweight syntax , the syntax itself inherits ideas from C such as pointers . Golang has a pass by value (Object) or pass by reference (*Object) a C progammer ( reflection on myself 2 years ago) I always (most of the time) used pointers to pass structs because it's faster than pass by value . Alas in Golang things are different , and a mistake or misunderstanding that C programmers or C++ have is that passing by reference is faster ... Spoiler Alert : Not so much ,For example in Golang Maps and Slices are actually reference so they should be passed by value there is no need to pass them by using pointers , Golang uses escape analysis to figure out if an Object can be allocated on the stack which is much cheaper than allocating on the heap . TLDR; Use Pass by value often for structs and always for maps and slices 
If the method take a pointer receiver, the compiler will always use a pointer. If you use a value it will pass a pointer to it. Play with this behaviour : https://tour.golang.org/methods/4
If a method takes a pointer receiver then ``` value.Method() ``` is a syntactic sugar for ``` (&amp;value).Method() ``` Vice-versa, if a method takes a value receiver, then ``` pointer.Method() ``` is a syntactic sugar for ``` (*pointer).Method() ```
Actually looks like he's been updating it since yesterday. I'll maintain my fork for a bit though.
ELI5: What does this mean for Go developers specifically?
You can safely switch to gccgo from go compiler. GCCGO is better at optimizing things.
Ohh, shiny.
Interesting, thanks!
The way it usually goes is that for a single type you either have all methods with a pointer receiver or all with a value receiver. The choice depends. For me, the most important consideration is semantics of the type. For example, in my Pixel game library, Vec (vector) and Matrix types have value receivers, because that's how they should be treated. They are sort of like compound numbers and numbers are values, right? On the other hand, if you have an object which can mutate and "travel" through a space of possible states, a pointer receiver is the right choice. Also, when your type is big, a pointer receiver is better because of performace. With a value receiver, every method call makes a copy and that can be slow for big types.
This is super interesting, last time I benchmarked go vs gccgo, go was the overall winner, but that was before gccgo had escape analysis.
???? why ? 
this is a used logo, It feels like I have seen this logo several times before. i just don't remember where!. what comes to my mind when thinking about this logo is a courier service or a shopping site. I just can't squeeze it out of my mind 
https://godoc.org/bufio#Scanner 
i found that it still uses copies if you dont use the pointer receiver. func \(b bar\) Method\(\) will not modify your struct func \(b \*bar\) Method\(\) will modify your struct. but disclaimer: i may be wrong.. 
It is normal that the value-receiver will act as a copy of the sent value. As said in the comments above, compiler will dereference the data before sending. This is, it won't be able to alter the underlying data without its memory address and will require one to return the altered-copy of it.
No. No. No. Please don't use gccgo as direct replacement for Go unless you have a very specific reason (a lot of cgo calls for example). The goroutines are not cheap, but rather full fledged OS threads and synchronization primitives like channels and mutexes will have a very different costs. Unless you application is Really CPU bound or has a lot of cgo calls - stick to regular compiler. 
Being rude wasn't my intention, and I'm sorry if you felt offended. Gccgo is very solid software, and it's actually used to verify that standard compiler conforms to spec (and vice-versa). My intention was to warn people against using different compiler without understanding the costs of doing so. Gcc backend may produce a better optimizations in some cases, but gccgo runtime doesn't know about every GC root on stack and has to be conservative. Which may result in slowdowns and more memory usage in another cases. 
One mistake is not using enough copying. Passing pointers around a lot is not as much of a performance or ease of writing thing in Go as it is in C or C++. Passing around copies of moderately sized data structures is surprisingly fast and makes code often easier to reason about and prove correct.
&gt; GCCGO is better at optimizing things. nit: It is better at optimizing some things and worse at others. I got a significant (~2x) slowdown in a simple ray tracer I wrote when compiling with gccgo vs. gc. Yes, I found it surprising too.
All data in the world can be described as a slice/array of some sort (this is true, or your computer simply won't work). So if you have an array of something, say something that looks like that: [ "hello", "there,", "/u/duck_r" ] And let's say `hello there` belongs together semantically. How are you going to extract two parts of the array (`hello there` and `/u/duck_r`)? First you need to iterate through the data, then coalesce where necessary. Iterating through the data, you get: 1. `hello` 2. `there` 3. `/u/duck_r` You can write a function to actually read the contents of what you iterated and decide that `hello` and `there` should be together. This is essentially what the concept of a scanner is. It iterates through data, and hides away the nasty things you don't necessarily want to touch. In the case of `fmt.Scanln` for example, the data that you are scanning for is the StdIn, which is a pseudo-file. The `text/scanner` and `go/scanner` packages provide scanners that abstracts scanning over large amounts of text/go source code (which are in files). The `bufio.Scanner` type actually does what I mentioned - you have to provide it rules though.
According to [this](https://golang.org/doc/install/gccgo#Gold), the only option available is segmented stacks and with explicit usage of binutils gold linker. Currently it also just a Linux X86 (tho I suppose amd64 would also fall in this category). 
If each goroutine still maps to an OS thread that only solves (maybe?) half the problem.
I would recommend https://micro.mu I‚Äôm using it for my bachelor project and they did a great job. Lots of examples, documentation, active slack channel etc Definitely worth a try 
No hard feelings.
This is one of the reasons I love Go, the documentation is so well done and easy to read. 
I was surprised at the magnitude of this change when I made it, to be honest.
IMO the intro. should really point to [issue 24876](https://github.com/golang/go/issues/24876) which fixes the optimizer in 1.11.
A language is not its implementation, a language is its spec. Unless gccgo doesn't implement the spec correctly it's 0% fair to say gccgo isn't the same language as Go.
This looks pretty cool, but i would recommend to write an example without the gui stuff. It is somewhat annoying to find the places where fuzzy is actually used. 
that thing was last touched in 2014 lol. Any unofficial implementation I've seen doesn't look like I could rely on it. I'd feel much better if it was part of an officially maintained lib, ie. std.
What is a "user package"?
Looks fine to me. Logos aren't exactly high art. They just need to be simple and visually easily distinguishable from other logos. The gopher being used for this purpose did sort of make go look like a toy language. Like scratch or something.
sorry but I don't understand your issue either. I would have only fixed space too. 
&gt; Slightly related topic: I‚Äôve been wondering if it‚Äôs time for people to start trying to take a crack at writing a new gocode that uses the source files directly. Not sure what you mean by "uses the source files directly." Regardless, I think the next big step for gocode is to become part of guru and/or go-langserver. The logic for coming up with completions is relatively easy. The real trickiness is integrating with an IDE in a correct and efficient way (e.g., handling unsaved file changes, parsing syntactically invalid files, caching partial work). This is all stuff that an LSP needs to handle anyway.
Does anyone know if there are any plans to have real goroutines in GCCGo ?
With this release, GCC 8.
Including the scheduler ?
great, any documents?
Not yet, but i do plan on adding them
FYI `filepath.Walk` is known not to be the fastest way; https://github.com/golang/go/issues/16399 is the upstream issue although it looks like it's unlikely to be fixed given the current interface. https://github.com/karrick/godirwalk implements a faster version with a similar but not identical interface; might be interesting to benchmark against that as well.
Yeah, the speed killer is the stat call per file that has to fetch inode data from disk. Not every filesystem on Linux supports getting the file type from dirents instead of doing a stat, but for the ones that can, that method should be a lot faster.
Are goroutines green threads or native? Spawning an arbitrarily large number of threads can tax OS resources.
Micro is the other one we are looking at. 
How many times did you run the benchmark before collecting numbers? The range is a bit surprising and I think you may be seeing the difference between the files being in the OS disk cache and not. 
For the sql package I'm using this: https://github.com/DATA-DOG/go-sqlmock Works like a charm. Of course this doesn't end to end test the interaction with a database but this is another story. In case the DAO works 100% as expected the only thing you need to verify together with a real database is if the db schema exactly reflects what your were testing with the unit tests.
I wouldn't call this a fake REST API, btw. Sometimes, it'd be nice to have an API for some semi-static data. This looks like a nice, simple to understand, useful utility written in Go!
I really hate depending on librdkafka. Do ANY of the pure-go client libraries support consumer groups properly yet?
Not quite the only thing. Also need to prove that the queries being executed are correct - it's easily done that they aren't and you don't find out until too late. However, this looks very helpful. Thank you :-)
I think Go only has pass by value, pointers are also pass by value, not pass by reference (obviously the pointed value doesn't change when passing a pointer).
Instead of Kafka, you might want to try out NATS Streaming. It's simple and fast and based on NATS, which is written in Go and part of the Cloud Native Computing Foundation (CNCF). 
I do something very similar, but in my case I made the CLI layer so small that I start the application itself from the godog run in a before hook. I was also able to pack everything into regular go tests, so my acceptance tests run as part of the go test invocation.
I admit I'm an amateur and could be wrong (actually if I am wrong that would be fantastic), so that in mind: My experience to date with various ui and graphics wrappers is any calls to those libraries/wrappers either are made with a program where gomaxprocs is set to 1, or you use some tricks to guarantee that any go threads will make their system calls from the main thread. (One wrapper has a do function you're supposed to use with go routines to bind them to the main thread) The reasons given are always issues with how some os's don't like system calls made outside the main thread of an application. Now I'm new, I'll admit maybe I misread, perhaps this is limited to ui/graphics calls If I am wrong, this would be great for at least one project.
I use this: https://github.com/ory/dockertest Works like a charm. An example is available here: https://github.com/ribice/gorsk
I believe most of the implementations are able to work without an installed executable the same way as vfsgen does, it's simply not documented.
Well it's not as good of news as I hoped, it's nice to know that a little clearer. Thank you.
Uses CGo to access tcsetattr(3) and friends. You could do these with https://godoc.org/golang.org/x/sys/unix#IoctlGetTermios https://godoc.org/golang.org/x/sys/unix#IoctlSetTermios For example: https://godoc.org/github.com/u-root/u-root/pkg/termios#TTY.Raw
What does that mean?
Mock the sql layer than test that the correct SQL is sent. There‚Äôs zero benefit to actually touch a DB for unit tests ‚Äî your integration tests should handle that ‚Äî and should run from a ‚Äúclean‚Äù database in any case.
wat Go has some nice FP features (and I would be pleased to see more of the primary mechanisms brought in), but Go is a "pragmatism first" sort of language and generally eschews the level of abstraction that defines FP. For a similarly conservative yet truly functional starting point, /r/elm might be useful.
This is a great answer üëçüèª
Off on a tangent, but why not just use SQL insert statements?
when a language or library provides a "thread" abstraction where the "thread" is scheduled on a pool of actual OS threads by the library/runtime, it is sometimes called "Green threads". So the runtime may keep a pool of say, 8 actual OS threads, you can then spawn a million coroutines and Go takes care of scheduling them intelligently on the 8 actual OS threads (or whatever it decides). OS threads have a lot of overhead so you wouldn't ever want to make a million of them. Abstraction like go-routines allow you to not have to worry about thread overhead (as much) but can reduce how much low level control you have. You can force goroutines onto actual threads if you need to though. 
Great! I think the term is maybe a "stub" rest api? I like "fake" as well tho :)
[removed]
Woohoo, my fork didn't live long but I don't even mind! Thanks!
This is not a Go question, but a Docker question. Do you have a Dockerfile? What command are you running to get this error that you're pasting? Can you paste that command exactly?
We use [https://github.com/segmentio/kafka\-go](https://github.com/segmentio/kafka-go) with consumer groups for some of our applications.
Like u/tmornini said mock dependencies but make sure you actually have integration tests that hit the database. I have used drone ci and goose successfully for this (MySQL though, shouldn‚Äôt matter). A container is started before the tests run , before each test case, I run goose to perform the database migrations, then have something like defer teardown which ‚ÄúDrops‚Äù the database..
jobsPostHandler should never panic, return a 500 instead. Invalid JSON shouldn‚Äôt return a 500, use a 400 instead. Finally, a success on an asynchronous endpoint should return a 202 in this case, or a 204 had they not chosen to echo the entity back. What is the semantic meaning attached d to a variable that begins with _?
It will be good if you provide some documentation to do same in an integration test in go itself rather than cli. Otherwise looks good for starters
What about testfixtures?: https://github.com/go-testfixtures/testfixtures You have to use it together with a migration library, though. The idea is: you use a migration library to either create the schema in a clean database (CI) or make an existing one up-to-date. Then you use testfixtures to clean and load fixtures before each test run. This kind of mimic how Ruby on Rails deals with tests.
You are correct: [NATS](https://github.com/nats-io/go-nats) is a PubSub system that offers TCP reliability and at-most-once delivery. However, I am talking about [NATS Streaming](https://github.com/nats-io/nats-streaming-server), which is based on NATS, but very different. NATS Streaming is a simple log-based messaging system, with publish and delivery acknowledgements. Because of this, it allows for at-least-once delivery. For availability, NATS (and NATS Streaming) rely on clustering and fault-tolerance. To keep logs up-to-date, they leverage the RAFT protocol. Because of these properties (and because it is an interesting Go project), I would say: check it out. I think NATS Streaming (or even NATS) could fit the use case this post is about. I am not a NATS developer, just an interested party. For more information, you could start with the [FAQ](https://nats.io/documentation/faq/). 
[removed]
This combined with dockertest that was mentioned elsewhere seems like it's got a lot of potential :-)
I'm not sure how this affects availability. State is replicated across nodes using RAFT. If a node is unavailable, another node can be used. Could you perhaps elaborate in more detail how this is handled in Kafka and how this differs in NATS Streaming? That being said how does all this justify the claim that they are very different beasts? To me, their delivery guarantees and storage strategies are similar enough for the aforementioned use case.
Thanks! I agree, and I've used both Go and Elm. Have you studied FP outside of Go, e.g., by focusing on a specific language (Elm, Haskell, ...)?
Oh! That could be it....I have no idea how to turn off caching in Windows to test it though.
This is a simple file based log writer(WIP), written in Go, writes log files based on timestamps
There are other performance improvements that godirwalk has built in, so even when a program still does a stat it still gets a boost because of the other optimizations. I definitely recommend setting up a scratch buffer for a reduction in GC. If your program also does not care about the order the directory items are enumerated in, set Unsorted to true for an additional performance boost, affecting large directories more than small ones.
Reported bug on github repo. They are good about going through that list frequently and thoroughly. [https://github.com/golang/go/issues/25174](https://github.com/golang/go/issues/25174)
What Docker Go client are you referring to? Do you have a link? Also, it looks like your gist is an incomplete snippet w/just 2 funcs. Can you share the entire codebase that's giving you the error? It looks like you're trying to do a `docker build` but you aren't supplying any Dockerfile for the image (whether that `Dockerfile` text needs to be written to a file or can be passed via string is another story, because I don't know how you're trying to build the image).
I compared it with the others, here's the results: **Linux 8-core SSD:** Num files: | 213 | 1,081,321 :---|:--:|---: ListFilesFileWalk | 59,187 files/s | 71,121 files/s ListFilesInParallel | 24,165 files/s | 155,636 files/s ListFilesUsingC | 72,927 files/s | 191,782 files/s ListFilesGodirwalk | 56,287 files/s | 65,284 files/s **Windows 8-core SSD:** Num files: | 233 | 380,226 :---|:--:|---: ListFilesFileWalk | 9,700 files/s | 14,524files/s ListFilesInParallel | 58,206 files/s | 228,174 files/s ListFilesUsingC | 383 files/s | 2,675 files/s ListFilesGodirwalk | 11,640 files/s | 14,283 files/s 
The entire thing is those two functions. You need to make a tarball with the Docker file and send it to the Docker daemon which is what I am doing, well trying to do. Somewhere in those two functions I am doing something wrong and Im not sure what. Im using the docker go client. https://godoc.org/github.com/docker/docker/client#Client.ImageBuild
It sounds like the other libraries are working for you, and that‚Äôs great. Would you mind posting the godirwalk version of the code?
Sure, its already incorporated into the package: [schollz/listfiles](https://github.com/schollz/listfiles). Here's [the lines for the godirwalk version](https://github.com/schollz/listfiles/blob/master/listfiles.go#L144-L171).
You could use `math.Floor` or `math.Ceil` to convert it to float, but you‚Äôll have to discard everything behind the decimal point either way.
thanks
Here's one place you can get them. http://www.unixstickers.com/index.php?route=product/search&amp;filter_name=golang
Kafka has replication built-in and NATS does not, I guess that's the point here?
See https://www.gopherguides.com/courses/preparing-your-environment-for-go-development/modules/setting-up-windows-module
Thank you
 import "uuiddep/user" in main.go is a local import. Don't do this. This is your own fault. So: not a bug, works as intended.
The documentation is confusing. As I understand it, you have two alternative modes: Clustering (Raft with state replicated to all nodes), or fault tolerance (groups of servers where one is designated "active" and the others are warm standbys; this requires that you use a network file system such as NFS, Ceoh, Lustre or similar that supports file locking, and that you provide the replication/durability of this file system). The two modes are different, but will both give you high availability. They come with different pros/cons: Raft requires at least 3 nodes, but is almost entirely automatic, whereas the fault tolerance mode requires just 2 nodes, but requires more ops resources to deploy. Raft also requires writes to be synced to disk constantly in order to maintain the consistency of its log, something which isn't needed for the networked file system.
also off on a tangent \- it may help you with tests as well as others wanting to contribute/maintain if you write very clear tests \- the idiom is starting to become table\-driven tests, [see here!](https://github.com/golang/go/wiki/TableDrivenTests)
check out point 1 here https://medium.com/@benbjohnson/structuring-applications-in-go-3b04be4ff091
Yup, and if you really want to "mock a server" because you don't care about the actual round trip, mock the `Transport` instead (`http.RoundTripper`).
I think the main reason here is simplicity and 'futureproofness', you as a programmer know what/how X can be parallelized, then you don't need to know what computer you are running on and any performance optimisations since this will be language specific. Then your program will also be able to adapt to most machine type and use the most if its resources without the need of optimizing. Here's a nice video about it: https://www.youtube.com/watch?v=cN_DpYBzKso 
[removed]
I think you are right that there is no technical benefit for either option. But the go keyword is a pretty good unique selling point for the language so thats probably good. 
I can see that having goroutines as first class citizens in a language does promote writing concurrent applications. However, it promotes a specific model for concurrency (namely goroutines). From the article [1] it seems that there might be better ways of managing concurrency than goroutines. By choosing to implement goroutines as first class citizens in Golang it seems to me that the developers have needlessly cemented a model for concurrency into the language that might not be the best. If it were a library someone could make an alternative library using a different model. The goroutines model might turn out to not be the best model for concurrency and it will not be possible to change Go to use a better model. Because of the problem that first class features in a language a very hard to change in the future I was thinking that there must be a very good reason to bake goroutines directly into the language and thus inhibit developing alternative models for concurrency in Go. [1] https://vorpus.org/blog/notes-on-structured-concurrency-or-go-statement-considered-harmful/
Would have to agree. First class means you know your environment variables already and so does the engineering of the language. 
No I haven't, thanks for the link though!
I wrote this package, as I personally like the systemd time specs (`man systemd.time`). I'd like to my Go CLIs to use the same format. An example: `$ mygocli --since='-2days'` Perhaps others may find this useful as well.
&gt; Couldn't goroutines be just as easily implemented as a library? No. Well, yes, goroutines could live in packages. But there is more to goroutines than just "run concurrently": `select` and this one cannot be implemented in a package (at least not without help of the language). And: Nobody asks why `int` must be part of the language: It could be implemented as a library. Just because something could be packed externaly doesn't mean it is a good idea.
Well, I'm actually arguing that if they are equally powerfull, there are technical reasons to prefer a library -- more general, allows implementing alternative concurrency models, ...
Just as an aside, if you ever find yourself having to create a bit of a mess, or add a bunch of code, to avoid one of the rules of thumb of programming, you might consider just breaking the rule. I don't know if this is one of those cases, just keep that in mind. 
https://www.gotransit.com/
OK, `select` may be an example of why it is good to have native goroutine and channels, thanks. Although I am still not sure it couldn't be done differently. And: Nobody asks why a GUI system isn't part of every language: It could be implemented as a language feature. But having a GUI system baked into the language would probably cause problems, i.e., do we choose native Windows APIs, Cocoa, GTK, Qt, Electron, ... Just because something could be packed internally doesn't mean it is a good idea. An `int` is so ubiquitous that it is most likely a good idea to have it in the language, a specific GUI system maybe not so much. I am not sure where goroutines fall on the line from a good to a bad idea to have included in the language.
Reading the article: You could have a go nursery package that uses goroutines; this would be just an abstraction on top of goroutines. To me, the go statement is the simplest form of concurrency/parallelism without having to think about hardware and I pretty much trust goroutines to use up all my resources. The go scheduler will do all it can to have the less possible idle time. Now the way you clean up/manage things is entirely up to programmer. On this topic I agree that it can get messy and trial &amp; error is often what I do to get out of things in a nice way.
Ah i see. I guess having one and just one adds to the simplicity that the go devs want to achieve. But you are still right. 
You might find my video on setting up a whole dev environment useful: https://www.youtube.com/watch?v=9D4yH7e_ea8&amp;index=1&amp;list=PLDZujg-VgQlZUy1iCqBbe5faZLMkA3g2x 
You can still just ignore it and provide alternative concurrency models via libraries. 
For a transit company, I think it works great! It looks like railways. 
Libraries, even standard ones, have to abide by the rules and context the language gives them. Imagine asking that same question for maps or arrays; a statement like `make([]int, 10)` is impossible to write in the language, even with access to unsafe memory allocation functions, because the very call signature of the function isn't even allowed in the language. In the context of Goroutines, I challenge you to write a `go` function using the language as it stands today. Feel free to ignore the fact that it spawns threads; just try to write a function which takes another function as its argument, the capability of transferring arguments to that function, and calling it. What you'll find is something core to the language: for example, `func(int)` cannot be assigned to `func(...interface{})`. That pretty much makes forming a generic `go` function impossible, if not type unsafe. 
I'd remove `AdjustTime`, unexport `UnitToDuration`, and rename `ToDuration` to `Parse`. Also, the project layout is more complex than it needs to be. Id flatten everything into the repo root and update the repo url to match the package name.
Yup; just kill the cookie if that's an issue.
I remember having asked why Python didn't have an equivalent of goroutines, and Guido answered that it would be difficult without changing the language and the compiler, one of the reason being that `select`can't be implemented in Python without changing the language. https://groups.google.com/d/topic/python-tulip/BO3KPIgQ_x4/discussion
&gt; I just started looking into golang Fine! Welcome. Now get used to the language, read more about it, do some work and consult the literature (e.g. Hoare's CSP). Then it is the time to judge language design ideas as bad. BTW: I don't know why you are talking about GUI systems. And the language is called just Go.
So I'm actually interested in this use case. A 5GB lookup table is incredibly large just for storing probabilities, so I'm guessing they don't fit a distribution otherwise you'd just calculate them online for the negligible speed penalty. These are probabilities tied to an entity then? What was the need for this amount of speed? Good stuff on the investigation btw.
Constants have special rules around type conversion. The full nitty gritty is here: https://golang.org/ref/spec#Conversions But you can also get a little bit of detail from the [blog post on constants](https://blog.golang.org/constants).
The blog post was supposed to be funny, not deeply informative. It touches on some go primitives (channels, goroutines, etc.) by making a nonsensical "Hello world" implementation.
&gt; The blog post was supposed to be funny What lead you to this conclusion? If that's the case, well, if you gotta explain a joke...
I love posts/lists like these. I wish more people would write about the little tools they've written.
&gt; is an open source distributed scalable Hybrid Transactional and Analytical Processing (HTAP) database built by PingCAP. Inspired by the design of Google F1 and Google Spanner, TiDB features infinite horizontal scalability, strong consistency, and high availability. The goal of TiDB is to serve as a one-stop solution for both OLTP (Online Transactional Processing) and OLAP (Online Analytical Processing). Even better, what software does this replace for me or how should I be using this? It looks like a Cassandra competitor (SQL-like): https://pingcap.com/docs/QUICKSTART/
Yes, but no one has (or will?) do it. FFMPEG is a large library and the best you can expect is someone who will figure out how to statically bind the lib for Go binaries. I'm hoping for this some day. Right now most people use FFMPEG in Go with dynamic binding.
FFMPEG is enormous. Reading sources to understand its internals is very difficult. And it's in C. There are a lot of "magic" workarounds and nuances. It would be easier to build a specialized subset than rewrite FFMPEG. What exactly do you need? 
I think you'd be better off finding a way to reuse ffmpeg from Go. For example, use cgo or SWIG to call directly into ffmpeg binaries, or have a helper process to stream media data to/from for processing.
I agree, it seems to be "for fun". A not so serious illustration of goroutines for beginners. A point which merits more details here is the cost of synchronisation. 
ffmpeg has a GIF encoder. You can just transcode from video to GIF entirely within ffmpeg. Alternatively, have ffmpeg output [https://www.ffmpeg.org/ffmpeg-formats.html#rawvideo](rawvideo) and then process the frames within Go.
If you do not need to support just about any video codec look for specialized decoding libraries and respective bindings. Also, if you are converting video files on disk, you should be able to just launch FFMPEG sub-process with parameters from a Go application.
Goddamit. I just clicked on it. Wasted my free view for this month
[removed]
Thank you! This is a great feedback! We have already incorporated it. Check it out: https://www.pingcap.com/blog/tidb-2-0-announcement/
&gt;And no, I couldn‚Äôt ‚Äújust use postgres‚Äù for this What about redis? 
I am sorry, I didn't mean to judge the ideas as bad. I was just trying to understand the design decisions behind Go. The idea of having concurrency built into the language was new to me and I just wanted to understand what are the benefits of doing it like that. Answers in this thread (especially from /u/joushou and /u/kemitche, thanks!) helped a lot. BTW: I don't know why you were talking about `int`s. Kidding aside, my point about GUI systems was that they are, much like models for concurrency, much more complicated than `int`s and I was trying to understand why include a specific way of doing concurrency directly into the language. (In my mind that was the same as including a specific GUI toolkit directly in the language.) Anyway, I know that I shouldn't judge something that I just started to look into, but I was just researching Go and got stuck trying to understand the reasons behind this design decision. I was probably being very difficult by arguing with you great folks, but I never mean't to judge Go -- I was just trying to understand it.
How does this compare to VsCode?
Well, the biggest problem with trying to learn FP in Go would be [the lack of tail call optimization](https://github.com/golang/go/issues/16798).
I will say, at least in the case of json-tidy: [`jq`](https://stedolan.github.io/jq/) is something every develoepr should have installed, and works flawlessly. 
Yep, although there are other FP principles you can apply (pure functions, the way you organise code and modules, etc.). Do you use FP in other languages?
I've written Lisp and Scheme and enjoyed it.
Nice - Lisp (well, Scheme) is my favourite programming language :-)
So I created this library as I was finding that I was writing a lot of crawlers using libraries like goquery (which is a fantastic tool), and found I was creating a lot of the same code again and again. Goquery can still do a lot more, but I believe this can solve quite a few simple cases. So, is this a good idea? It solves a problem. Should you really be treating the html as an api source? No, but sometimes services don‚Äôt have an api, and you just have to make do. Is this library dangerous to use? Yep, first time I have ever really written anything that does reflection in golang, so probably still a lot of unforeseen issues laying around the corner. Could I use some help? Yep, if you know reflection, I would love some help with tissue \#1, as I have no idea how to work with pointers in arrays. Should you believe you have the solution, there is a test for it in the encoding_test file, which is currently being ignored.
I'd kill for an API to write behavior into GoLang backed by different editors. Ie, GoLang where every keystroke and buffer change was initiated by Vim, or Emacs, or Kakoune - any editor server you want. I'm planning on contributing to https://www.onivim.io to try and get GoLang level features, but GoLang has done so much work - it sucks reinventing the wheel. All I want is the ability to use Vim/etc in full, and not just knockoff keybindings.
I learned about jq after I had already written json-tidy, so I never got into it. I can see why it's good for other people but it never scratched my itch.
[removed]
Maybe it's just me, but I often resorted towards writing the spinup/shutdown in bash. Here's an example of a live setup/teardown for a mysql container, along with a healthcheck which will wait until the mysql instance actually is ready before continuing: [gist snippet](https://gist.github.com/titpetric/c5e4bf5cfe66161f0b68512bb3eda218). There are things that are wrong even with this approach: 1. testing isn't really elastic, it doesn't create an unique instance for your test run that would be isolated (ie, lines 23-33), but if you run your tests in Travis or something like DIND, then you'd get that from your CI tooling, 2. it's a hacky devops script which still requires things like container cleanup, but it also does allow container reuse if you write some additional checks (ie, conditional container startup). there's probably other things wrong, but battery low (feel free to add some in comments) 
These articles will explain how to organize your Go packages: - https://rakyll.org/style-packages/ - https://medium.com/@benbjohnson/standard-package-layout-7cdbc8391fc1#.ds38va3pp - https://peter.bourgon.org/go-best-practices-2016/#repository-structure This article will help you understand the design philosophy for packages: https://www.goinggo.net/2017/02/design-philosophy-on-packaging.html -------------------------- from https://invite.slack.golangbridge.org/ (highly recommended)
&gt; With VSCode you can use gometalinter in real-time and Goland‚Äôs inspections are nowhere near it in their capabilities. You can use gometalinter with GoLand as well. Head to Settings | Tools | File Watchers | + | goimports and the IDE will run goimports on save. We are aware that there are some shortcomings on the inspections that the IDE provides so we would appreciate feedback as to what's important to have in order to help us prioritize them. &gt; JetBrains editor uses too wide intervals between lines and this cannot be modified Have you tried Settings | Editor | Font | Line Spacing and it wasn't enough? If so, can you please raise an issue on our tracker? https://youtrack.jetbrains.com/issues/Go &gt; Syntax highlighting is anything but sane in JetBrains editors: there‚Äôs no option to highlight types of function parameters, variable declarations, etc. You need to choose color for local types of a package, color for foreign types from external packages, color for package names, etc. Type names are not highlighted by default. Stupid, yes. I'm not sure I understand this, can you please explain what you would expect to see/do and what's not there today? Thank you for the feedback, we'll try to improve things in the future versions.
Appreciate it; am editing and elaborating.
If you want to learn both follow this guy. https://twitter.com/dwhitena?s=09 To be honest there isn't much built out for go but the benefit is big Data sets can be compiled quickly but also they are not really done with library language specific cpu's. Some languages have libs that work well for big Data sets and vectors and with certain chipsets designed for them. Go does not. So it's up to you.
I like where your head is at. This is a perfect use case for Docker Compose to handle the setup, tear down, and unique parameterization and I‚Äôve had a lot of success replacing the script you wrote with YML for this
There is no best-at-everything programming language, Go sure have its limitations too. I recommend you to create little projects to learn Go and get used to it before thinking about full rewrites. Also keep in mind that you can easily create a multi-language backend with grpc. The learning curve is steep, but it pay off a lot in the long run. 
IdeaVim is pretty good. you should try it
&gt; It's nothing that needs doing &gt; future proofing the code &gt; write everything in Vanilla Go (pretty much)... the dependencies of my python projects, they are rather large &gt; just ship compiled binaries to my servers &gt; a rewrite would definitely help Seems like you understand your situation. If you proceed with a rewrite, Go would be a great option (if the special behavior you require is available in libraries). Since it is normally common for ORMs to be leveraged (not that it is forbidden in Go), you might want to consider using code generation to speed up development. If that is still too foreign for you, there are ORMs and ORM-like tools available.
I don't understand. What are you future proofing against? You're the only one working with the code, and it seems all your needs are met? I will say that it's unlikely that you'll want to do it all in vanilla Go. It's just too easy to use an API framework. There are parts of Go that make writing an API in Go nice. Like how easy it is to make types that you can directly pull from SQL queries with sqlx. Then Marshal that same type into JSON. I will say that I don't think Go lends itself to easy web dev nearly as much as Python though.
For a backend/frontend web project this is an amazing example: [https://github.com/vkuznecovas/mouthful](https://github.com/vkuznecovas/mouthful)
Goroutines are rarely used in isolation. They are very truly concurrency **primitives**, and should be composed as such. 
I'm a go dev but wouldn't do a rewrite if I were you. It sounds like your python setup does everything you need. Try go on some other project. Check out gin.
There are a couple things Go does better than Python for basic rest API stuff and you touched on the obvious ones (speed and ease of deployment). But with a known-working codebase it doesn't sound like you really have a whole lot of reason to move. Anytime you rewrite a mature project you are taking on a significant risk -- there *will* be bugs -- so you should only do it with a clear objective in mind. &gt; When I look at the dependencies of my python projects, they are rather large and I worry about some package eventually holding me back, E.g reportlab. This is going to be a problem no matter what language you use. Both Go and Python have good tools for expressing dependencies on particular versions of things, and that can help you stay in place when you don't want a surprise upgrade, but it doesn't fix the problem when your dependencies no longer work together. I'm not saying don't do it, just understand why you're doing it and whether the risk is worth it. Even if the reason is "because I want to learn how to do it" or "because it'll be fun". For comparison, a project I recently rewrote had a large number of problems including: * Bad performance * Lots of copy-pasted code * Difficult to prove that it was secure * Business logic smeared all over the place * Poor management of database connections * Written in PHP * Slightly different code in dev/test/prod and no source control (... yeah) So as you can see, that rewrite was a serious win.
Go is great! We've got [Gorgonia](https://gorgonia.org/gorgonia) which has to date shipped over a hundred production level neural networks that I am aware of (most of which are LSTM/RNN based, with a few here and there that are convolutional neural network). More remarkably, Go as a language to use means that you have very stable stuff. The oldest ML system in production with Gorgonia is a little over 3 years old. Of course, being stable also leads to some funny business like [this](https://twitter.com/chewxy/status/985313556546506752). And we're always looking for people to contribute new examples !
As far as I know, you can allocate a huge byte slice with no GC penalty, as the GC won't look inside it. The slice, as a reference type, will be GC'd but the individual contents won't be. Or, more like for your string usage, a uint16 slice. Then you're free to treat that byte slice however you wish, without resorting to a bunch of unsafe calls and pointer arithmetic. Is there a reason this wasn't considered, perhaps I'm wrong?
Here's a quick start guide: * [gorgonia](https://gorgonia.org/gorgonia) - your bog standard graph computation library, like a bastard child of Tensorflow and Pytorch. Comes with multiple modes of execution of graph (dynamic and static and in the future, again, stacks). Infinitely extensible. It is pretty low level but writing things like a parameter server in Go is trivial, so no libraries are necessary for that. * [gorgonia/tensor](https://gorgonia.org/tensor) - storage library for Gorgonia. Compatible with gonum matrices, and raw standard Go slices. Also compatible with CUDA memory. A `*tensor.Dense` can represent all of those. Decent serialization story, about to get better with the upcoming version. * [gorgonia/cu](https://gorgonia.org/cu) - CUDA libraries for Go, but Gorgonia relies heavily on it (though the default is CPU), and you gotta write your own kernels in CUDA - the basic library only provides a handful. With these three libraries, you can make literally any neural network-based AI you can think of. 
Don't do a rewrite
[removed]
It sounds like everything is more or less fine, and you're considering rewriting everything? Have you ever gone through a rewrite of an entire project? It's usually a terrible idea. It's a massive and risky undertaking. You should have a very strong argument for why it makes more sense than keeping what you have, and even then it is still highly questionable. It kind of sounds like you're bored and trying to find excuses to change things up a bit. Oldie but a goodie: https://www.joelonsoftware.com/2000/04/06/things-you-should-never-do-part-i/
[removed]
Is part of your question missing, maybe? Streaming an mp3 over TCP is just transferring data over TCP.
Hey Mike, Nice work, I'd love to chat with you about this and maybe compare notes. I've been doing some stuff with the Graph API and it turns out to be a beast of an endeavor. Are you on any of the Go Slack channels? 
It's always 'open to personal opinion' even if there's an official structure :) The repo you referenced captures the project structure best practices used by the top golang projects, it represents a set of defacto community standards. 
You're right. This is my first week of using go, so I was having trouble understanding how functions implement other interfaces. I just ended up writing the data to a stream and it plays on the other end. 
Thanks! I was close to choosing Python just because everyone seems to be using it. But now I think I will learn Go instead. I have coded in MATLAB and C++ before, and really feel like C++ is more of my thing than MATLAB. So I‚Äôm really interested in picking up Go rather than Python. I already feel like I will be using those libraries you mention a lot:) Thanks again, much appreciated!
Familiar with Bogo sort at all?
All that is available in vscode btw, every single thing you said. \&gt; I picked up goland as an ide because I was going to learn go. Searching for things is easy. Implementing interfaces is automated, refactoring is automated. Ctrl clicking method calls takes you to the code. Imports are automated. 
Please also feel free to contribute. We don't have a newbies guide and may seem scary and intimidating, but that's really not the case. We really enjoy contributions.
One option is to use assember \(cgo would be too slow\) to call from Go into Rust‚Äôs HashMap, which is backed by jemalloc or the system malloc. That way, you bypass the Go GC, and you get to use a battle tested implementation that you did not need to write.
That's fair. As I said I hadn't used vscode in this context I was comparing it to my experiences in other languages. In my head I have it down as a similar comparison as between vscode for .Net core vs Visual studio for .net core. I'm a big fan of vscode, I suppose I just wanted to try something new. There was a go time podcast not that long ago with one of the pms. He probably does a better job than me. http://pca.st/episode/860f1de5-ad43-4234-ba25-6614002a656b Use what works best for you in your context. The goal is velocity most people don't care how you get there. 
what is a magefile?
I wasted so much time on this. I was just playing with Kafka and thought it would be better to use a native go implementation, which I then had to bolt on another package for rebalancing support. I wanted to do consumer-based offset tracking, but that wasn‚Äôt supported. Fast forward and I‚Äôm now rebuilding in Confluent, using librdkafka in a nice small alpine docker image. Works well.
It's for a build tool (alternative to using makefiles to build your binaries) https://github.com/magefile/mage
NoSQL is the typical term for what you're describing. You can certainly create your own indexes using a KV store though - just create a bucket for the field you're interested in and store the value to be indexed as the key, and the primary key for your main bucket as the value.
I love how you're required to read 5 blog pages on proper folder structure before compiling "Hello World" for fuck sakes
It's a bit tongue in cheek but... https://github.com/EnterpriseQualityCoding/FizzBuzzEnterpriseEdition To be serious though. I'd rather have 5 blog posts that explain the WHY of it then have it enforced arbitrarily. 
[removed]
gometalinter needs all the files to be saved on disk before running. This is a constraint for which we don't have any solution except implement the inspections ourselves. The bonus from doing that is that we can also build fixes so that we not only tell you there's a problem in the code, but also offer ways to fix it. The window that the IDE pop-up panel contains the link to each issue found by the metalinter so you can quickly navigate to these issues. Sorry I don't have a better answer right now.
Great to know about the keyboard shortcuts - I'll check it out.
Personally I dislike heavt dependency injection in golang. It is often harder to do and complicats the API of your application. Overtime I have come to prefer to write unit like integration tests instead of pure unit tests. This is where you mock out what the function you require uses using thing like the reader and writer interfaces and the httptest utilities. Naturally there is no one size fits all for this and where required I do still make use of traits when it makes life easier and does not complicate the external API. Passing in first level functions tends to be my last resort in this case. But generally I try to write side effect free functions so dependency injection is required less and this become easier to add true unit tests. So really I would worry less about making your stuff unit testable until you learn how to unit test in go. It is not the same as a lot of other languages and you can often make more mistakes trying to fit patterns for other languages in to go.
For readability I would go for option 2), the interfaces. To me creating a bunch of function type definitions makes code harder to understand/read, as you see a variable but don't immediately know what to expect from it. I am personally also rather inclined to assume a variable passed to a function is just an object, not a function.
Goland Also has a "class" structure, so you can select the function you are interested in and click on it to get directly there. This is not supported in VScode and the ticket for that is open for a couple of years with no fix in sight.
Hello First of all, shameless promotion time: [https://quii.gitbook.io/learn\-go\-with\-tests/](https://quii.gitbook.io/learn-go-with-tests/) \([https://github.com/quii/learn\-go\-with\-tests](https://github.com/quii/learn-go-with-tests)\) \&gt; I maybe don't have the time to write tests today, but later down the road, I might want to add tests. I would say, make the time. Writing tests in Go is a joy and is very easy. Trying to make code that can hypotehtically be testable is harder than actually testing it! Besides while what you write might be suitable it could end up being a nuisance. If you have real tests you know your code is definitely testable, by virtue of it being tested. \&gt; Right? As a developer, you always want to write code that doesn't need to be changed, just to make it testable/mockable, right? I tend to think the opposite of that, change is inevitable. Embrace it :\) To address your worries about structs vs functions. I wouldn't worry too much, there isn't a hard rule \(although generally structs &amp; interfaces are favoured\). But you can also make functions implement interfaces. [https://play.golang.org/p/\_GQcsxKTmZV](https://play.golang.org/p/_GQcsxKTmZV)
It actually isn't. Goland's ctrl+click on variables/functions is more complete than VSCode's. VSCode only travels 1-way, i.e. to the source. There's no variable/function usage find built-in for it. That's one that really, really bugs me about VSCode.
Step back and think a bit deeper about what you are trying to do. Why do you want to mock functions at all? If you have specific services that you have to mock (because the default implementation requires online connection or something like that) then you just need to mock the interface for that particular service. But in your post you seem to be trying to mock every single function? I don't understand your motivation here. If you have a render function that needs to first "search" the database, then "sort", then "render", what you can do is split out the internal "render" part into its own function that takes an already sorted list. This way you don't need to mock searching a database with a fake database. In other words, to make more parts of your code testable, make them functions that take specific inputs and spit back specific output, as plain data. This is probably the easiest way to make things testable and also readable. The more you can avoid dealing with "black box" objects, the better.
[removed]
&gt; Syntax highlighting is anything but sane in JetBrains editors I just tried it. I didn't find a simple option to disable syntax highlighting. I literally had to create a new "Scheme" and manually set the color of each syntax construct to none.
&gt; Syntax highlighting is anything but sane in JetBrains editors I didn't find a simple option to disable syntax highlighting. I literally had to create a new "Scheme" and manually set the color of each syntax construct to none.
Thank you for your suggestion, I've filed this request: https://youtrack.jetbrains.com/issue/IDEA-191244 
Is that a relaxo lama in the picture? 
A function that returns the same output when you pass the same input can be described as having [referential transparency](https://en.wikipedia.org/wiki/Referential_transparency). Functions like that are easier to test, along with pure functions.
Share a gist, let me give it a few test runs and see if it actually works as expected. I want to see mainly how you do the healthcheck for mysql actually listening on TCP, I suppose that's still needed with compose.
https://blog.golang.org/go-brand
BoltDB is an embeddable K/V database: https://github.com/boltdb/bolt You can use Storm as ORM: https://github.com/asdine/storm
What I am concerned about would be the data types. If keys are byte slices, then storing doubles or even ints and them looping them would be stringish, isn‚Äôt that right? e.g. 1,10,2
Well, no, your keys wouldn't be stringish, they'd be bytes (see the `encoding/binary`, and `bytes` packages for related material on encoding/comparison), and boltdb, for example, stores keys in byte-order, which lets you do a number of sensible things (see the boltdb docs for examples).
&gt; In most cases, if the way you normally write code is explicitly impossible to test, you are writing bad code. Exactly
I think a big part of his point is that mocks are a tool to test dependencies. They aren't required for every test. If you have dependencies you should have a struct or be passing them in as it is a good practice and that is a place to inject fakes. Otherwise you can fully write testable package functions without mocking and should. Mocking too much is as much of a code smell as untestable code. 
He mentions ML: Machine Learning. It then most likely is the result of training. I must say 5GB is large. I'm not sure the performance would be hurt by reducing the dimensions, but it's not something you want to compute online.
Oh, no no. I meant (almost) always go for interfaces/structs! They make your code readable, and they allow for easy testing.
I usually make everything structs with th e intention of using them as interfaces later. It's no hassle to test a struct. But if I want to test a struct that should have an instance of another struct as one of it's fields, then I'll make that field an interface and use the counterfeiter tool to generate a mock for testing. That way I'm testing the functionality of the struct and not one of the instances that the struct contains. The only time I use first class funcs is usually inside some function to simplify some repeatable task or as a callback, never as a global var. In general I find first class funcs less useful purely for the reason you alluded to... You can't duck type them with an interface.
Bingo! *Now* I give a shit about the announcement ;) (Thanks for graciously accepting the feedback.)
I tired it but I was not able to activate. I want to get the title of winmerge but i couldn't do it. What am I doing wrong? a, b := robotgo.FindIds("winmerge") if b == nil { robotgo.ActivePID(a[0]) fmt.Println(robotgo.GetTitle()) }
I would second the idea that you should write tests now. Go can be opinionated in ways that may feel unexpected at first, so the more hands-on time you get with the language, the better. If you don't write tests now, it will only be harder to write them later. And after having worked on a couple of larger code bases in Go, I've found code organization to be a larger obstruction to writing good test than function pointers vs interfaces. I wish I had seen William Kennedy's "Package Oriented Design" talk back before we built our first large service in go: https://www.youtube.com/watch?v=spKM5CyBwJA This also appears to be in a non-video blog form here (although I do recommend the video): https://www.ardanlabs.com/blog/2017/02/package-oriented-design.html We had brought over a lot of code organization techniques from other languages, and later on in the life of the project, it was a nightmare to work with, because we were constantly fighting against the language itself. We had built a monolith package that housed all our dependencies, and because Go prevents circular package dependencies, it was very hard to build new systems outside of this monolithic package. This also made tests hard to write. I would definitely suggest spending some time with Go before trying to build anything meaningful, and especially if you intend to port something from another language, you need to realize that Go may fight against that if you aren't keeping in mind how Go wants you to organize things.
In your example, you could write 'render' as something which takes data (people) and returns data (the view). You can then write a test around that. And you have a 'pure' function, which is a marvellous thing. (It's testable, memoisable, and easy to reason about since it doesn't touch anything apart from it's arguments)
Thanks everyone for taking the time to read and respond, I'll stick as I am for now. I've written a few small applications in Go and being an isolated one man team, it's hard to know if your the only one still doing X. I think for now I'll just do a full code audit, and improve test coverage to 100%.Like I said (and others mentioned) there is no problem with my code, but the attitude from other devs I talk to in irc/gitter is always 'oh know one is doing Web in &lt;foo&gt; anymore you need to use &lt;bar&gt;. 
Hire someone else? Would be nice, that list isn't even everything I am responsible for. 
I found William Kennedy's "Package Oriented Design" to be hugely helpful for this: https://www.youtube.com/watch?v=spKM5CyBwJA
I agree to use interfaces. This might be different for you cause even Rob Pike said the engineers at Google wrote it wrong at first because they were doing it the Java way. I think you should really dig deep into them and realize how you can reuse them. For instance the Reader interface. Just looks like a regular old interface but the methods you get with it are a lot and when this is implemented with other packages it gets a lot easier. This just shows the basic usage. https://tour.golang.org/methods/21 Doesn't look like much but it's a lot. type Reader interface { Read(p []byte) (n int, err error) } And The Reader type There is a lot to the Reader type and interface. https://golang.org/pkg/strings/#NewReader You get all those methods when you use the strings package Reader type. A Reader implements the io.Reader, io.ReaderAt, io.Seeker, io.WriterTo, io.ByteScanner, and io.RuneScanner interfaces by reading from a string. When you want to use the Reader interface you can utilize a lot with it. Testing packages even use this interface: https://www.google.com/amp/s/blog.alexellis.io/golang-writing-unit-tests/amp/ https://golang.org/pkg/testing/iotest/ Using readers: https://medium.com/go-walkthrough/go-walkthrough-io-package-8ac5e95a9fbd https://jrub.in/golang-interface-pitfalls-and-io-reader-a57e2d8842a2 Importance of using it. https://www.ardanlabs.com/blog/2018/03/interface-values-are-valueless.html Example of testing: https://spino.tech/blog/important-go-interfaces/ Just it takes time to dig deeper but so does going from a dynamic languages to static ones. Some might think it's a waste to use bytes but the value is enormous. You get to control the data, varify it, and in a sense use it to control data types by going lower. This is all exactly why I think using generics in most use cases is kinda a weird question because the Reader interface is pretty much generic. 
Yup, that sounds about right. 
Well to ndo have to put your code in GOPATH, that is enforced arbitrarily. 
Use this referral code https://www.stickermule.com/unlock?ref_id=5433090701 and buy samples. I recommend this guy https://imgur.com/gallery/x3GY2
At the moment there are no plans for a Community edition. You can get a free license if you are a student, teacher, or open source contributor.
[Colly](http://go-colly.org/) is a pretty good crawler framework as well.
One thing that really stood out to me that I haven‚Äôt seen mentioned is: &gt; I maybe don't have the time to write tests today, but later down the road, I might want to add tests. &gt; However, I don't want to rewrite code just to make it testable or mockable. Right? As a developer, you always want to write code that doesn't need to be changed, just to make it testable/mockable, right? Conflicting goals here, testable code without writing tests. I follow my own derivative of TDD (I leave a lot of wiggle room for adjustments as needed) and so many design issues are exposed while writing tests. It makes you think about how your callers need to use your API, if your struggle to prove the implementation correct they will face that difficulty magnified. But one thing that this tells me, is if you plan to add tests later that means you are running your code without go test. Which means you are using `go run` during development. Don‚Äôt. Ever. If you limit executing your program to only go test you immediately build good habits. You force yourself to think about your API at the pkg level without abstractions changing the way you perceive inputs and outputs. You become less likely to pass around large structures across package boundaries because you have to deal with those structures during testing. Who wants to mock out a giant struct just to update a XYZ struct field? So the XYZ sub pkg is born, has no idea what has an XYZ- it only has to create and prove an XYZ to be correct. Every time you feel overwhelmed to try to setup a test it usually means one thing: subpackage. I have so many sub packages early in a projects development- most of the time with a single struct. As a project comes further along its easy to move packages and has so many benefits. I find it prevents bugs and race conditions as well because you are forced to interact with each structure through its public api. It prevents accessing a stucts private field because it‚Äôs easier in that exact moment. Finally small subpackages will help with cyclic imports which you may start to face as a project grows. Point here is force yourself to write tests during development, as arduous as it may be at first. Use all the sub packages you want to force minimal public API‚Äôs which naturally tightens inputs and ouputs, making it easier to prove they are correct.
I've just began working on a minimal embedded database powered by BadgerDB. I'm calling it [bow](https://github.com/zippoxer/bow) and while it's not ready for use yet, you can look at bow_test.go to see how to use it.
It seems that your comment contains 1 or more links that are hard to tap for mobile users. I will extend those so they're easier for our sausage fingers to click! [Here is link number 1](https://github.com/zippoxer/bow) - Previous text "bow" ---- ^Please ^PM ^/u/eganwall ^with ^issues ^or ^feedback! ^| ^[Delete](https://reddit.com/message/compose/?to=FatFingerHelperBot&amp;subject=delete&amp;message=delete%20ID_HERE) 
We already have [this](https://blog.golang.org/go-slices-usage-and-internals) and [this](https://blog.golang.org/slices) for ages; what's the point in rehashing the same information over and over again?
&gt; compare one piece of code on different numbers of processors/architectures Why? Architecture is largely virtual these days. Benchmarking is good for finding and solving order-of-magnitude problems, but if you're looking to shave cycles, well... those improvements are going to disappear in the noise of running in a virtual environment. Please, do tell your requirements that are leading you to such a benchmarking exercise. That would give you a more meaningful answer to your question.
Note there is already [`echo.HTTPError`](https://godoc.org/github.com/labstack/echo#HTTPError); so if you use `echo` (as mentioned in the README) then I'm not sure if this really adds anything? --- We have the [`guru`](https://github.com/Teamwork/guru) package btw, which is less opinionated about what error codes are supposed to mean; they *could* be HTTP status codes, but could also be other internal codes, MySQL error codes, or anything else. The original name was `httperr`, but I changed this a few weeks ago as using `httperr.New(..)` in code that has nothing to do with HTTP (e.g. cron jobs, mail delivery) is rather strange. It's also built on top of https://github.com/pkg/errors ‚Äì so you have all the advantages that brings, and using a `coder` interface means we can do stuff [like this](https://github.com/Teamwork/validate/blob/master/validate.go#L59-L63).
That's not "Linux pipe" because it's not Linux, and it's not pipe. First, a [pipe](http://man7.org/linux/man-pages/man7/pipe.7.html) is a particular mechanism of [IPC](https://en.wikipedia.org/wiki/IPC) *provided by an OS.* Clearly you're not (re-)implementing an OS pipe‚Äîyou're implementing a *concept* resembling so-called *process pipelines.* Second, the pipe as an OS IPC concept [appeared in Unix V3 in 1973](https://en.wikipedia.org/wiki/Pipeline_(Unix)) and was later [standardized by POSIX](http://pubs.opengroup.org/onlinepubs/009696799/functions/pipe.html), so it is not in any way Linux-specific. 
On a side note, it worth mentioning that the Go's standard library contains an implementation of [an in-memory pipe](https://golang.org/pkg/io/#Pipe) and a set of supporting wiring around it. It can be directly used for creating pipelines of goroutines processing raw data (chunks of `[]byte`).
GraphQL on Go, in general, is very rough due to limitations in the type system. As for realtime, I know less on that topic. If you represent a company who is looking to deploy GraphQL, a better method for today is to spin up an Apollo or Vesper "proxy" as your API, which could even do authentication as well, then have it make requests to a Go backend via a more traditional protocol like REST or RPC. If you're just a person looking to experiment, there are certainly GraphQL libraries for Go, but its a real pain. Another option is to use AWS AppSync, then write lambda function resolvers in Go. But otherwise: GraphQL is much more mature on Node, Rust, and Elixir. That's where a lot of the development is happening today. 
Another one that bit me last week: ``` select { case cmdErr := cmd.Wait(): // ... case &lt;-done: // kill process, cleanup... } ``` This will immediately select the first `case` because although `cmd.Wait()` _does_ block, it can be _invoked_ immediately. Thus even closing the `done` channel will never be recognized and will leave this goroutine dangling.
Optional, and they cause unnecessary delays. You still need about ten secs before mysql accepts connections and you can do any tests. Without having an agressive healthcheck there‚Äôs going to be 10+ seconds of delay here, which is not great. Hence, bash :) Or write the connect/reconnect logic in your go tests, but that also puts the ‚Äúpopulate the database‚Äù in the domain of Go. Not sure I want that either üòÇ anyway, nothing bad with either way, just as soon as you‚Äôre a bit particular as to how you want to run integration tests, compose will most likely not cut it, or you‚Äôll depend on external containers very fast (ie, compose external keyword), but in that case you‚Äôre already running just one container so you can issue a docker run command? Compose is sort of all or nothing, and it‚Äôs quickly nothing.
I'm relatively new to Go, and in an attempt to better understand the native hashmap implementation I built this barebones implementation. However, initial benchmarking shows that this approach is more efficient, but that can't be true...right?
You probably haven‚Äôt taken into account all the corner cases. That would be my guess. Look at the native implementation.
You're definitely right, it's much more complex and very dense. I'll update as I understand more. Thanks.
This was a lot more tricky before they added CommandContext.
[removed]
This article is in bad need of some editing. I've re-read it twice now, and I still have no idea what it's really trying to say. It reads halfway between a generalized treatise on abstraction and an entreaty to use interfaces more, but the examples are odd and abstruse, and it lacks a central case or series of cases to orbit the thesis around (whatever that thesis might be).
When you get the dumbhash results, you're running `foo +=` each value. That's O(n^2) as the string gets longer, which isn't great for a benchmark anyhow, but then you don't clear foo out before getting the keys from the native map. You should find that if you just do the checks in the other order the results will flip. What you've got there is a benchmark of the speed of += on strings, which is well known to not be fast, hence the recent introduction of [strings.Builder](https://golang.org/pkg/strings/#Builder).
Ah! Is there a better way to benchmark the retrieval of values? Go won't let me compile if I do nothing with the expression result or if I assign it to _.
Please feel free to suggest anything that could help us improve the IDE. And to give you some insight into how the IDE works. Nothing needs to be saved in order for it to work, it can/needs to work with file(s) in-memory, using data that was just added to the file(s), everything (from completion to inspections to quick fixes) works even on broken sources that otherwise cannot be compiled (at which point many of the tools included in gometalinter would simply abort the execution). Not only that, but you can inject various languages in string literals, including Go itself, and at that point none of the static analysis tools today are aware of what's happening in those strings. As I said, please let us know what checks do you specifically miss/need for and we'll do our best to prioritize them. Thank you.
The core concept isn't bad, it's just strings that are a problem. You could increment ints, or just set foo to the most recent value instead of concatenating them. Either way it's very cheap, setting foo is technically just a pointer operation, I think.
Didn't see the last part of your initial comment, good point, I'll set the value same as the key.
How about the [Go Playground](https://play.golang.org/p/_DZDcJgmgUJ)? The version on play.golang.org is likely to timeout before your benchmarks finish, but you could also install your own copy and [define your own limits](https://github.com/golang/playground/blob/0cf5f3c26a052bbbbb37ea3ee739d474b27c98bf/sandbox.go#L38).
&gt; Well yeah but I'm only benchmarking Get and Set, so those things shouldn't be a factor. Of course they are. The code is still there. It still requires doing checks and calculating expressions. And it *definitely* requires actually doing all the shuffling around and rehashing on resizes. &gt; but the Set still stands. No, it doesn't. All the stuff you left out is cost that is incurred on insertion, that only pays off on retrieval. i.e. you are borrowing time during insertion and then not pay it back during retrieval (as that benchmark is screwed up).
Ctrl+~
I wrote a hashmap that outperforms your hashmap whilst being thread-safe (and nearly as fast as the Go builtin thread-unsafe map and faster than sync.Map): https://github.com/cornelk/hashmap/ ``` go test -bench . BenchmarkReadHashMapString-8 200000 7782 ns/op BenchmarkReadDumpHashMapString-8 50000 24173 ns/op BenchmarkReadGoMapStringUnsafe-8 200000 6385 ns/op BenchmarkReadGoMapStringMutex-8 30000 42686 ns/op BenchmarkReadSyncMapString-8 100000 12779 ns/op ``` You can find the benchmark here: https://github.com/cornelk/hashmap/blob/dumbhashmap/benchmark_test.go 
I wiped up a solution testing database in transaction mode. [GITHUB](https://github.com/YoussefKaib/example_testing_application_transaction_state/blob/master/main_test.go#L24)
I don‚Äôt agree with some of those points based on past experience, as sometimes the overhead of a full health check is extremely useful (esp when it‚Äôs ten seconds of initialization to ensure a clean run of a 15 minute integration test suite for example) but I do appreciate the response !
This looks great, and definitely more approachable than the native implementation's source. Thanks for the link.
hmmm, I don't see gometa anywhere in keymap. Under Tools/Go Tools I see: Go fmt file Go fmt project Go imports file Go generate file Go type directory Go vet file (this is the closest, but not metalinter)
Hi Everyone, I apologize to those of you who have been waiting for the article on Go web application structure from me - it's taken longer than I expected (as usual). However, I recently finished what I think is a good basis for the GitHub project that will accompany the article, and I wanted to share it ASAP. This project is todo application that implements an HTTP based API, written of course in Go. The goal is to provide an example and, in a sense, a barebones project you can create your own application from. Whether you decide to mirror the structure exactly, take certain ideas, or just learn from it, is completely up to you. This structure used by this project is one I use for my own SaaS company, but with a lot of improvements. While there is still a lot to implement and explain (mainly testing), I would love to hear your feedback. Thanks!
Oh, you mean "more goroutines more better"?
[removed]
[removed]
[removed]
I have been out of the loop recently, So, Can someone tell me why are there two versions released at the same time? What's the difference? 
Nice comic touch on this article.
[removed]
Was this done with other releases in the past? I don't remember Golang devs releasing two versions at the same time. 
I think so. I guess we could find it in the release notes.
Example of how I use scanner. Line feeds are stripped and 1 line of the file is processed at a time. Example reads from a file, not from user input though. input, err := os.Open("data.txt") scanner := bufio.NewScanner(input) for scanner.Scan() { line := scanner.Text() recType := line[0:3] if recType == "001" { company := line[4:30] continue } customer := line[4:30] ... }
View \-\&gt; integrated Terminal
To answer your question, different number of processors is useful for analyzing whether goroutines are efficient (sometimes they can have too much overhead), different architectures are more for curiosity because of optimizations in amd64. I should also mention different OSes are also useful to benchmark on, because there can be major differences (for example in windows Stat, Linux has a much faster Stat call (lsat) that can be used for directory listing). In general, there are usually two+ ways to write a function. I like the idea of a Go playground for benchmarking where you can quickly see which way is faster. 
I get the impression you have a solution in search of a problem... &gt; whether goroutines are efficient You're not going to find much that's more efficient. They have none of the overhead of processes or threads. Dunno what you're on about with "too much overhead". &gt; optimizations in amd64 For 99.9% of apps, that's going to disappear in the noise of a virtual environment. &gt; different OSes Again, noise in the virtual environment. &gt; there are usually two+ ways to write a function Doing a big-O analysis is your best line of defense here. Much quicker than benchmarking.
[removed]
For versioning, check out vgo (https://research.swtch.com/vgo-repro). So that feature will be available in the immediate future. I'm supportive of having go get do it all, although I'm not sure about having the defaults be optimized for release.
You should check out https://github.com/vektah/gqlgen#feature-comparison for a comparison of the top 4 libraries. gqlgen works around go's lack of generics by using code generation. Take a look at https://gqlgen.com/getting-started/ Disclaimer: author of gqlgen, may be a little biased.
Very few things will natively do sql and a plaintext format on disk, largely because most things just implement sql care about performance and thus store things in a way that helps for doing relational queries and doing them fast, which a human readable plain text format is not good for. Sqlite is C and not plain text but can easily give a csv file with a sql query. You could look at textql which may let you build something closer to what you‚Äôre looking for. It‚Äôs written in Go so you can just reuse some of its packages. Besides that I cannot think of anything that will do what you want without a good amount of effort or compromising. 
Also interested.
You might be right, but I'd really like something that writes to human-readable/editable files that users can easily make use of in other programs, pipe around in scripts, etc. if they want to.
Also, thanks for Caddy! I've been using it for about a year now for all my personal projects and love it.
Also, thanks for Caddy! I've been using it for about a year now for all my personal projects and love it. 
Thank you very much for sharing this, but I have a few questions about your architecture and implementation. First of all, why do you define you domain types in the database package \(instead of an independent package\)? Granted, this is a very small app and architecture doesn't matter. But if someone builds a large and complex business application by using this architecture, such tight coupling between domain layer and data access layer is a sign of code smell to me. On top of it, you mentioned that the service package handles the application logic, but why is the domain logic has dependency on the persistence?? I think this architecture is barely okay if the sole purpose is to serve CRUD operations through the web, but I would not use this as a template for applications that actually have domain logic. Secondly, how will you test things, especially the service package? I noticed that you mentioned that the service package is for handling "application logic" \(instead of "domain logic"\). If this is purely for application logic, then I would be okay with it. If you are going to add more complex logic in this layer, I would question the testability of this package as it is so tightly coupled with persistence. In addition, you have a lot of script that manages server setting up and environment configurations. While I believe it is essential for a full\-stack developer to learn all these and understand how to configure infrastructures, old\-fashioned operation like this is being slowly replaced by DevOps and cloud computing \(like AWS or GCP\). So why not write one that is more future\-oriented to DevOps? I am not trying to give you are hard time here \(in fact, I learned something from this small project, so...thank you! :\) \), but I find this setup questionable and I would like your clarification if you don't mind.
Check out https://github.com/schollz/listfiles It shows big differences in using goroutines on different OSes. In windows they are incredibly efficient. in Linux not so much. 
It's probably https://github.com/gocarina/gocsv Obviously this won't give you SQL functionality, but with only a few hundred objects you'd probably do just as well to do query/sort/filter/etc. with plain Go.
I don't see how the article relates to the content
I like the font on this page, lol.
There are way to many variables in those tests to derive any kind of conclusion from them.
No problem and thank you. The article by the time I'm done with it is probably going to be a mini 30+ page book, and I think it will answer a lot of these questions, and it's due to a change of perspective in a way. Fair warning, I only have superficial experience implementing a true DDD structure. I explain my thoughts on it more [in this comment](https://www.reddit.com/r/golang/comments/878e2n/golang_restful_starter_kit_gorsk/dwcbvaz/?context=1). &gt; First of all, why do you define you domain types in the database package (instead of an independent package)? It's really a change of perspective. In this structure, the `database` package (or domain) is strictly concerned with interacting with the backend database. For example, for the members table of our database, we have the `database/members` package. This package is only concerned with creating, reading, updating, and deleting rows in the members table, and nothing else - it has no concern over what the API does, how it uses its defined types, or anything - its types are defined strictly based on the table, because that is all this domain cares about. Now, in the next level up, the `services` package, this is where we build out the application logic. The main goal of our application, and in most web applications, will be to use a backend database to save and pull data to make a dynamic web application. The reason we don't just use the `database` package for this is because it's possible part of the application logic may involve multiple tables of our database. For example, say we wanted to track the IP address and datetime of each login attempt. We could create a new `login_attempts` table in our database, and hence, a new sub-package in our `database` domain named `loginattempts` that implements the database interaction. Now, in our `services/members` package, we simply need to modify the `LoginParams` type to include the proper fields (IP and datetime), then we could call our new `s.db.LoginAttempts.New(params)` method within the `Login` service method. Our database domain is a clear separation still, nothing changes, something is only added. Our service domain implements the core application logic again. Our API domain just needs to pass new parameters in the /api/v1/login route. The reason we don't use the `database` types directly is because say we wanted to include the last 5 attempts as part of the `Member` type. This would not be compatible with our database type, but would be fine as the service type. The main benefits I see to this are clear logic separation, and really, it should be possible to have multiple people work on separate parts and easily tie them together this way. So long as the database types are defined and the core logic is obvious, things can be mocked on the service side while the database side is being built. Keeping a completely separate service structure that still implements the core application logic also provides the added benefit of being able to use said services outside of the API application. For example, say you need to create an application that will run some data on the current todos. You can create a new `cmd` application, and this can simply use the already made services domain, no API or existing server or logic copying needed. &gt; Secondly, how will you test things, especially the service package? I still need to implement this. Basically, it would depend on how in depth you want testing to be. The fact though that everything is split up and as modular as it can be without imho over-complicating everything, makes testing relatively straight forward. Testing of the `database` domain could be via a mock MySQL implementation (I still have to look into this). Or, create a separate `gotodoapi_test` database that is created, tested on, and deleted for each sub-package (`members` and `todos`). The database could then be tested on the next level up (within the main `database` folder) as a whole or as that alone if wanted. The `services` domain can then be tested via a mock implementation of the `database` domain. This is sort of reflected in the de-facto Go DDD example itself, [goddd](https://github.com/marcusolsson/goddd/blob/master/mock/mock.go). The `api` domain can then be tested via a mock implementation of the `services` domain. Each API handler as well is separated into its own package. All they need is an API `Context` type containing the mocks or real implementations of the services, and then a test HTTP server to verify responses. Then, this could all be tested with an actual test database as mentioned for the `database` domain, using the real database and services, just on our test database. &gt; In addition, you have a lot of script that manages server setting up and environment configurations. While I believe it is essential for a full-stack developer to learn all these and understand how to configure infrastructures, old-fashioned operation like this is being slowly replaced by DevOps and cloud computing (like AWS or GCP). So why not write one that is more future-oriented to DevOps? That's the main reason. I want this to be as barebones as possible, and while I think the shell scripts and explanations themselves are somewhat complicated, especially for newer developers, it shows one possible, low-level way of running the application in production. In the article I may include how to deploy using other methods, but I want to keep the GitHub project itself as simple and low-level as possible. Sorry for the novel :)
Have you tried CockroachDB?
I don't think you're listening to me... guess it's time for me to stop posting.
You can always just execute the mysql cli tools using os/exec
It seems that your comment contains 1 or more links that are hard to tap for mobile users. I will extend those so they're easier for our sausage fingers to click! [Here is link number 1](https://en.wikipedia.org/wiki/Parsing_expression_grammar) - Previous text "PEG" ---- ^Please ^PM ^/u/eganwall ^with ^issues ^or ^feedback! ^| ^[Delete](https://reddit.com/message/compose/?to=FatFingerHelperBot&amp;subject=delete&amp;message=delete%20ID_HERE) 
You don't have referential integrity in your two database tables. Can you show how you would do this?
Woah, cool! I had no idea that existed
As far as I know, this would just consist of setting a foreign key index on the `member_id` field of the `todos` table, referencing the `id` field of the `members` table.
To give you more things to look at: - Rob Pike's lexer talk: https://www.youtube.com/watch?v=HxaD_trXwRE - Some parser/lexer libraries: - https://github.com/goccmack/gocc - https://github.com/pointlander/peg - https://github.com/prataprc/goparsec Some of that might be useful, but some not. gocc is great, and does let you generate just a lexer. I was writing my own parser-combinator without codegen, but never released it. Maybe I should finish it, someday...
https://github.com/murphy214/protoscan/
thanks, though even with multistatements enabled, I'm a little confused how SQL scripts with backticks get escaped.
If you mean true real-time, golang isn‚Äôt gonna cut it. But for the ‚Äúreal time web‚Äù you could certainly use go with some web sockets and graph the points client side. 
It surely is the implementation of the concept of pipes in linux, no one writes kernel code in Go fyi, so it is pretty self explanatory.
The in-memory pipe is just a one way channel to transfer bytes. This implementation enables a person to obey an interface and create a n level chaining mechanism
Not hard to implement. Read the file in as a string, ex3cute query string. Profit.
The second case should be run some of the time. If two cases are available in a `select`, [one is chosen at random](https://golang.org/ref/spec#Select_statements).
Yes, this has always been the policy. See for e.g https://groups.google.com/forum/#!topic/golang-announce/2lP5z9i9ySY and https://groups.google.com/forum/#!topic/golang-announce/s_hLxKF9ApA
&gt;This article is in desperate need of some editing. I've re\-read it twice now, and I still have no idea what it's really trying to say. It's stiltedly\-written and reads halfway between a generalized treatise on abstraction and an entreaty to use interfaces more, but the examples are terse and abstruse, and it lacks a central case or series of cases to orbit a thesis around. \(Author\) The article might get improved, employing your suggestions. But to be more precise, which examples are terse and abstruse?
[removed]
Unfortunately, the visual identity of this groups post seems inconsistent with the =*Go* BrandGuidelines¬Æ; don't think I'll be updating this one anytime soon.
The only reason people write these kind of articles is that Go makes mocking extremely hard compared to other languages. You wouldn't be writing this when it comes to java or nodejs. This is the very definition of a cop out. Mocks are tests, that's what make them different from fakes.
I think I've looked at your library before, and while impressive at getting things up and running quickly, it uses the neelance library (now `graph-gophers/graphql-go` I believe?). Under the hood, this is still using a ton of reflection, so despite being able to generate a lot of nice looking strongly-typed code on the surface, it's still using a lot of reflection to figure out how to work with those types, right? Interestingly, I did some benchmarks fairly recently and saw that `graphql-go/graphql` had taken the lead in terms of performance (at least for what I was testing it with). Me and a friend have started our own GraphQL parser, and so far we're seeing really promising results. We've go the fastest lexer we've tested by quite a long way, and are moving onto the parser now. From there of course we'd still have the same issue as anything else doing GraphQL in Go - reflection of some kind. So, we plan on writing a code generator too, to generate the whole server with specific types in mind. It won't be a library like neelance's or the others, it will specifically make a server for your schema, and will actually be type safe, with no reflection - if we manage to pull it off. All in all, that should mean it's extremely fast too.
I honestly fail to see how fakes are different than mocks of the interface? They seems pretty identical, with the exception that with these fakes you have to write them yourself.
I thought about naming it "Installation of Tools written in Go Language can be Simpler" but I felt like it was redundant.
I think it was mostly inspired by [bettermotherfuckingwebsite](http://bettermotherfuckingwebsite.com/) :)
Afaik it's only using the parser from graph-gophers, looks like all the actual runtime code is without reflection. I've not benchmaked it, but given it supports parallel execution of resolvers and doesn't rely on reflection, I'd be willing to bet it's pretty quick in most cases. 
Rats. I guess that means I failed to convey my point. Mocks can increase coupling which is bad for unit testing. Someone recently sent me this talk, and maybe it is better at communicating a similar point: https://www.youtube.com/watch?v=URSWYvyc42M
Is your parser available anywhere? I think there's a fair bit missing from the gophers parser atm. It'd be nice to have a shared contract at the parser level so these projects could share some code etc
I was thinking `vgo` was mostly about being explicit about dependency versions but now I see how it can be relevant to what I mention. It would be great if versions could be displayed from the binary itself by simply passing a `-version` flag somehow.
Aha, I'll have to give this thing a proper looking at. Just tried the getting started tutorial but got some errors.
I, for one, am very glad that we can't just mock everything like in Java and NodeJS. I can't stand magic and decorators and patterns and whatever level of abstraction you add to your program. Fakes (or whatever the name) are not really fakes to the system under test. For them, they are very real. The data they provide might be fake to you. IMHO they are used only to narrow down to the absolute minimum what's running to test the thing you want to test.
Its using the same parser as graph-gophers, but because its in internal I cant reference it directly. https://github.com/vektah/gqlgen/tree/master/neelance It fallen behind the current schema spec, and there are a few open issues on both repos. We are currently looking at getting the parser up to spec and I'm hoping we can push it out into its own repo.
That's a shame, I'll get it fixed. Unfortunately, because there is so much codegen involved godoc examples don't work so well. 
A lot of devs \(including myself\) who write Java/Node whatever actually dont like to use mocking frameworks for the reasons you state, they often add a lot of complexity and magic which can make things difficult to debug.
Thanks!
Yes, for patches, AFAIK, they always did.
that is by design. Imports are only for the current file. If you want to use `Foo` elsewhere, you need to import the package it is defined in.
So what would doing joins look like?
Okay, Thanks for providing the links.
https://martinfowler.com/articles/mocksArentStubs.html or https://blog.pragmatists.com/test-doubles-fakes-mocks-and-stubs-1a7491dfa3da Mocks verify behaviour - "X was called". A fake isn't really intended to record calls, just return things to make it look like there might have been a functional dependency there - eg. A user store that can be updated, but exists in memory rather than the DB, or an io.Writer that doesn't go to disk perhaps. The difference (as far as I understand it anyway) comes in how you test with them - Given a fake, you run the functionality you have under test and assert on the state of your object under test, return values or fake afterwards - how it got there is not a concern. Given a Mock, you're asserting against calls made against that object. Because you're asserting against that behaviour, you have a pretty close coupling to the implementation, rather than the end result and functionality, which can make your test much more brittle to changes and refactoring. Any time you create tests that are based in the implementation rather than the functionality, you're much more likely to be creating tests that calcify your code and resist change, imo, which I believe was the point of the article.
As a Google project, I wonder if this work is related to crostini containers in chromeos? Crostini has the potential to displace a lot of Linux laptops with Chromebooks.
Note that I think the statement that it "selects" the first case is wrong - it evaluates the Wait() immediately, causing it to block until that produces a result. Note that this is based on step 1 of the select statement execution in the language spec (evaluation of right hand side expressions). I don't think that has any connection to which case statement it eventually selects, which is step 2 and should be pseudo-random. I mean that with Wait being a synchronous blocking call (on exec.Cmd), there's a lot more work on the user to try and implement this sort of functionality correctly. You had to have one goroutine waiting, another that would wait for the timeout and kill the process, and then collect those together and do the right thing. CommandContext is far simpler to use correctly.
expression evaluation order related? https://go101.org/article/evaluation-orders.html
Mmm, wrong sub parhaps?
A few more things, with the error handling, you can't do Add(Add(a, b), c) see [here](https://stackoverflow.com/questions/50136113/go-error-checking-and-chaining/50136380#50136380) also, you are adding FieldElement but returning a pointer, so you have to do result, err := Add(a, b) result2, err2 := Add(FieldElement{result.n, result.p}, c) where it would make sense to be able to do result2, err2 := Add(result, c) I am new to go, so maybe explicitly creating a new element is preferred for some reason, idk
I think you meant to say "thank you for doing my job for me"
More like https://github.com/dinedal/textql
Here's my theory: This will provide just-enough linux compatibility under Fuchsia.
&gt; crostini containers I think it could be much wider . Fuschia OS and Google Cloud could be also affected . Potentially this opens up an entire spectrum of Sandboxing and emulation for unix based application on OS that will support this tech. For the cloud it could allow for HyperContainerizing there is only one implementation of it as of now . Which would mean cheaper cloud hosting. 
For what it's worth, I don't particularly agree with your abstractions - type RemoteFetcher interface { GetRemoteMessage(accessKey, accessSecret, host, bucket, key string) (io.ReadCloser, error) } Your abstraction is now tied to a security implementation, hosts and buckets. These things could have been encapsulated in the *instance*, not the interface. I would probably have aimed for a single interface like Get(key string) (io.ReadCloser, error) and your s3Getter would have had the access information as well as bucket etc.
[removed]
I misunderstood. I thought the problem they were having was one where the error channel was buffered and it would write to it after waiting for the process. I didn't see the 'kill process' comment and didn't think he was trying to use `done` to cancel the whole thing.
It's not obvious. Have you read [The Little Mocker](https://8thlight.com/blog/uncle-bob/2014/05/14/TheLittleMocker.html)?
Out of curiosity: what is this thing the OP failed to name when were asking their question?
this is correct
The last section seems a good summary of the author's points: &gt; It is not abstract -&gt; understand -&gt; simplify - which leaks too much overloaded "helper" concepts into the code. It is simplify -&gt; understand -&gt; abstract. 
I use ¬µ from https://stackoverflow.com/a/41266753 in my code very successfully 
Wow what a hack. What do you have ¬µ bound to in your editor?
Please don't do this. Trying to be clever just to save yourself one line of code, ends up making for a needlessly complicated and unmaintainable mess. Future you, or whomever has to inevitably read the code later on, will thank you.
Would this also work on Windows with the win10 Ubuntu subsystem? 
You cannot.
I'll take the opportunity to just close my eyes and think about how lovely go ecosystem is.
That ‚Äúone goroutine waiting‚Äù was the ‚Äúmore goroutines‚Äù I was pithily attempting to reference. 
Why not both? 
Change your `foo` to ``` func foo(i int, s string) { //do stuff } ```
&gt; `env CGO_ENABLED=0 go build` &gt; &gt; Unfortunately, there is no way to specify this within the source code where I think this information really belongs. The environmental variable allows the user to make choices. Hard coding it into the source removes the possibility to make the choice. Why do you think it belongs to the source code? 
Same reason /u/kormoc got a bunch of downvotes even though he answered the question ... it trades programer read performance for write performance, which Go is against in general. In the above StacOverflow thread the top post talks about a Must() type assertion which is much easier to follow (assuming the value you want to throw away can be thought of in those terms).
SpaCy, Gensim, NLTK, Dr. QA, Tensorflow, and other great libs are python only. Learn python for NLP or ML as everyone else already uses it. Learn Go when it's time to make a actual user-facing app that needs to be solid and performant. (I write Go and Python)
It‚Äôs Visual Studio Code :)
This isn't a real answer.
HN comments with responses from project devs: https://news.ycombinator.com/item?id=16975706
solid observation. Should be easy to refactor given the implementation :p
For our project, `net` package is only used for interprocess communication. Name resolution is not performed at all on unix, and only performed for `localhost` on windows. So in our case, linking against C libraries only serves to break static linking and introduce a slight delay to launch, brief but noticeable. I don't expect users to know how `net` package is used in the code to build or install the tool properly. Same goes with developers who are not familiar with the codebase. This information is within the source itself, so the decision should also be explicit in the source. For other projects, I think you can also make similar arguments. Regarding the user choice, I think it should be possible to implement a mechanism to specify the default choice for the use of cgo in the source code and also allow overriding this choice by setting an environmental variable.
I was expecting something that was more about the specifics of the costs of abstraction in Go, but this seems to be able premature / overenthusiastic abstraction? You cover some good things, like the idea that interfaces are to communicate what you accept, not what you provide. But the whole article does not really work from start to finish to draw the reader to a clear conclusion about a concrete idea, it seems to meander around general things to do with abstractions and then end entirely philosophically. I'm not sure if this article is for or against io.Reader, for example. Why did we look at that Go code for config? Did you reach the conclusion that the elixir code for that was bad because of implicit flows? Why did we go into cognitive load? Because abstraction is good or bad? It feels like you're making 10 observations weakly, rather than one conclusion strongly supported by a clear arc of argument. $0.02
I see you've updated the results. The delta between the dumbhashmap's store and get is now suspiciously large. Given the, well, dumbness of the dumbhashmap I can believe the get will take longer because in generally it'll be traversing more than set necessarily did, but still, that's a suspiciously large delta. I'm thinking the Get might be two or three times slower than set, not 150 times. (And I say that not because Get is cheap, but because Set should be roughly as expensive, plus Set has to deal with allocations.) You may want to google profiling go and see if something jumps out at you.
Have you looked at my Get implementation? dumbhashmap is fixed at 256 buckets, so with 150000 entries that's roughly 580 entries per bucket, which are being fully iterated over with each Get operation (buckets are essentially just arrays).
I'm going to plug my own project https://github.com/adamcolton/parlex. [This lexer](https://github.com/AdamColton/parlex/tree/master/lexer/stacklexer) may be useful to you. And if you have any questions, or find any issues, I'll do what I can to help.
Wow! That's kind of like magic.
https://www.youtube.com/watch?v=TJJT8wc0T_c Here's a link to a demo. It seems to me like at least part of its intended use is to replace the default docker runtime, which has its known potential security flaws in its design.
Correct, you just missed `go install` =)
Not really needed after the first compilation in the Go 1.10+ world, but yes. 
After some research, i decided to wrap dlopen and use that to export fields/funcs i need. The topic may be considered as closed. 
The release notes make it pretty clear that the fixes are not security fixes, so no need to light your hair on fire.
What do you suggest for doing \`go get ./...\`?
Go strives to avoid that kind of magic as much as possible. For the sake of argument, assume you CAN do this. What are the rules? Does it only work with a unary function calling an n-coarity function, from which it takes only the first return value? What happens if the signature of return values changes? Everything breaks, and the reason might not be immediately apparent. Signatures need to match up to avoid weakening the type system more than it already is. This seems verbose, but it‚Äôs a good thing. 
The best answer I got was "no it can't" and then someone explained why. Changes my question doesn't answer my question.
I guess I'll answer my own question. Here's [a &lt;30 line program that wraps git](https://github.com/schollz/git-shallow). So you can just do: ``` go get github.com/schollz/git-shallow alias git=$GOPATH/bin/git-shallow ``` which will set `depth==1` whenever you do a pull/clone with git. This should work with `go get ./...`.
I provide what I hope is a better answer below. 
The only usage we use it for is for putting together testing tables. It‚Äôs silly to force a complicated test table init routine when you can just wrap static calls with something like that to simplify the test table 
Try https://www.reddit.com/r/programmingcirclejerk/comments/8ggyty/lol_go_generics/
&gt;For the sake of argument, assume you CAN do this. What are the rules? I mean, /u/kormoc's hack is pretty unambiguous and that's basically how it works when returning tuples in python. I get /u/nevyn's answer about readability, and that's reasonable enough, but it's not like it's impossible.
Thanks for being patronising! It's DSN btw, not dns. Thankfully we don't work together.
As a rule of thumb, when you want to use it once and once *only*.
I think installation with Go is already quite simple compare to most of the other languages. This article feels like it has to say something instead of having something to say.
[removed]
You're an incompetent piece of shit
For what you describe, I think you'll like storm. It's pretty great. :)
[removed]
It *is*impossible as asked. It cannot be done without runtime type assertions. While it‚Äôs unambiguous syntactically, and you can muck about with return values at runtime like the example shows, I‚Äôd hardly call it straightforward, and it bypasses any typechecking. You cannot do `foo(bar())` Without changing bar‚Äôs signature.
"You can't" is the answer. If go had tuples/destructuring assignment instead of multiple return types things would have been very different.
Whoops. I'll get that updated. Thanks!
Sorry if it was unclear. I hoped the context from the rest of the post would make the variables and functions clear. That snippet was intended as a "test-lite" where the whole set up would not be needed to get at the idea being proposed. A little after that snippet, there is a link to a runnable test: https://github.com/sendgrid/filegetter/blob/master/getter/getter_test.go#L136 You can actually pull down the code and Go-To-Declaration in your editor of choice and explore things, and maybe that will help.
 type ReqOne struct { ID int `json:"fromID"` } // or type ReqTwo struct { ID int `json:"userID"` } Writing this is correct but I feel it makes my code less readable. I go for anonymous structures if they aren't used anywhere else on my code base.
Thanks! Starred. I will be using this in a prototype. 
From a recent discussion with someone else: &gt; I have [tons](https://www.reddit.com/r/golang/comments/7tbvxl/so_just_how_fast_are_channels_anyway/dtc12xm/) of [posts](https://www.reddit.com/r/golang/comments/799of8/how_to_implement_a_lock_free_array/dp0pbhv/) in my [post](https://www.reddit.com/r/golang/comments/799of8/how_to_implement_a_lock_free_array/dp21urm/) [history](https://www.reddit.com/r/golang/comments/6l6poq/a_c_developer_looks_at_go_the_programming/djs3d4g/) [about](https://www.reddit.com/r/golang/comments/6l6poq/a_c_developer_looks_at_go_the_programming/djshpoz/) lock free algorithms. To [summarize](https://www.reddit.com/r/golang/comments/6dpwyp/lockfree_mrmw_ring_buffer/di4pfs4/) I feel that even thinking about using these kinds of algorithms should be avoided. It's a great learning excersize and I'm sure you have fun making it, I just wanted to post this in case someone thinks it's a good idea to actually use it in software they write. These are difficult to implement and just glancing at your implementation I see sufficient evidence of at least one [race condition](https://github.com/pltr/onering/blob/master/mpsc.go#L60)- though I could be wrong since I'm sure you ran benchmarks with -race. Your benchmarks also appear to be flawed, for example the usage of runtime.LockOSThread and using b.N instead of a constant. But I am certain that this would perform much worst while using more resources in a real application that had real world scheduler pressure.
Could you expand on why you think using `.LockOSThread` and b.N in a benchmark is "flawed"? And why you think it would perform "much worst"?
&gt; Could you expand on why you think using .LockOSThread and b.N in a benchmark is "flawed"? Yes, LockOSThread is adding a constraint that will not be present by the users of your library. The use of b.N over a constant is introducing variance which may or may not favor one implementation over the over. For example if one algorithm has a quick spin up but begins to slow down under larger sizes it would be punished by design as the future b.N's would be larger. You also have [ResetTimer](https://github.com/pltr/onering/blob/master/ring_test.go#L57) for the ring benchmarks but not the [chan](https://github.com/pltr/onering/blob/master/ring_test.go#L212). As for why I think it would perform worst, there is sufficient material in the posts I linked.
This sounds interesting, but why BadgerDB? I‚Äôve been running into BoltDB everywhere I look.
Excuse me, but could you be more specific on what you think is going to happen without .LockOSThread and why it's going to degrade something? If anything, it will improve performance in many case. The only reason why it's there is to make it more real world like (many low latency/real time application will have it locked to keep their caches hot). What quick spin were you talking about, all of the queues there are starvation free/spin free. I'm not seeing anything specific in any of the links you provided, just a lot of general/philosophical stuff. By the way, could you also expand a bit on why you think the line you linked in your first comment contains a race condition? Just please, be specific. What exact condition would cause stores be reordered there etc. P.S I added a reset timer for chan, it changed nothing
Hey folks, had a great time [last week](https://www.youtube.com/watch?v=TaAqal2iEWs). We're doing it again! [Here's a tweet you can RT/like](https://twitter.com/broady/status/991809709651902464) if you want to spread the love. You can follow on Twitch to get notifications for when we go live.
The filesystem portion of the article was quite interesting!
Nope. This was done once, and then rolled back. https://github.com/golang/go/issues/13078.
&gt; Excuse me, but could you be more specific on what you think is going to happen without .LockOSThread and why it's going to degrade something? I never said it degrades anything, I said it adds a constraint that won't be present by users of your library. I came to this conclusion by considering the fact you make no mention of it anywhere on your readme. &gt; By the way, could you also expand a bit on why you think the line you linked in your first comment contains a race condition? Just please, be specific. What exact condition would cause stores be reordered there etc. As I said in my original post it was speculation: I saw no immediate proofs that the bits yielded by your AND operation could not potentially clobber a previously en-queued item. So I took 10 seconds and: .../github.com/pltr$ mkdir $GOPATH/src/github.com/pltr .../github.com/pltr$ cd $GOPATH/src/github.com/pltr .../github.com/pltr$ git clone git@github.com:pltr/onering.git Cloning into 'onering'... remote: Counting objects: 251, done. remote: Compressing objects: 100% (155/155), done. remote: Total 251 (delta 158), reused 186 (delta 94), pack-reused 0 Receiving objects: 100% (251/251), 40.88 KiB | 0 bytes/s, done. Resolving deltas: 100% (158/158), done. Checking connectivity... done. .../github.com/pltr$ cd onering .../pltr/onering$ go test -bench . -race And 800 lines of [race conditions](https://gist.githubusercontent.com/cstockton/08628ab142634b46f080d01b5e595172/raw/2c001482477130085b2ecced609207517b3bca95/pltr-onering.md) at the very line I suspected: WARNING: DATA RACE Write at 0x00c4202dac10 by goroutine 151: github.com/pltr/onering.(*MPSC).Put() /ws/cws/src/github.com/pltr/onering/mpsc.go:60 +0x153 I know you just wrote this software, you're excited about it and that's great. I feel at this point the conversation is degenerating because you may feel like something you have created is under attack. But you are not under attack, I am simply doing the thing you specifically asked me to do: &gt; Comments/bug reports are very welcome. Especially the ones that find flaws in the algorithms. I notified you of potential bug report (the race condition) then I let you know that I found your algorithm flawed by supplying you with comments I've made in this space. I knew where this was going when you responded within ten minutes to dispute a technical position I spent **years** arguing myself into. I won't regurgitate anymore of it here or further criticize your library, I'm sorry if I offended you and I"m sure the library will polish up nicely. I was only trying to help, happy coding.
It already does. We developed gVisor specifically for Cloud Functions and other cloud services.
Well, that escalated quickly.. Please reconsider your wording.
&gt; I notified you of potential bug report (the race condition) Excuse me, but that is not what you did. You said you saw a race condition because you *looked at the code*, implying that you actually understand how the code works and what it does. If you just said that it appeared in the race detector, there wouldn't have been any issues there. Yes there was a data race report at the time when you looked. No it's not an actual data race, it was an unfortunate typo on my part after refactoring. But to make it clear: the reason for that race data race report has nothing to do with the line 60 in that file. It was just a typo in the batched consumer and that race report disappeared after I fixed it. Totally unrelated to that line, race detector just happened to pick it up there: https://github.com/pltr/onering/blob/master/mpsc.go#L43 - was `==` instead of `&lt;=` You can confirm it by fetching master and rerunning And I'm not being hostile, I'm actually really interested in hearing if anyone can find flaws in the thing, because it's likely that at some point I am going to be using it in production. Would rather avoid $100m loss because of a race condition, that's why I immediately jump on such reports. That said, I'd rather not spend a lot of time on discussing philosophy etc. Anyway, I did indeed ask for reports and you did provide one. And I promised random numbers for anyone who does in that repo. Here's yours: 7406409499465810786 - take a good care of it! &gt; I know you just wrote this software, you're excited about it and that's great &gt; I spent years arguing myself into. I really would rather not make it personal or start comparing records and make it a competition. I'm really only interested in making it work and maybe even helping people in the process. Not doing it for sport or self gratification.
&gt; Excuse me, but that is not what you did. You said you saw a race condition because you looked at the code, implying that you actually understand how the code works and what it does. If you just said that it appeared in the race detector, there wouldn't have been any issues there. Classy. Yea- I didn't notify you of a potential race condition while leaving room to concede graciously because it was only a static analysis. I didn't then later after you INSISTED on showing you a race condition take an entire 5 seconds to download **YOUR CODE** and run it with **-race** like **you should have done** to prevent a lengthy debate from occurring. The reality is the second I saw your repo I realized it was far beyond my understanding so I ran it with the race flag. I was overcome with joy when I saw the potential to present this as something I observed statically so I could setup an opportunity to assert my technical dominance 3 comments later when I printed the output from it. &gt; No it's not an actual data race, it was an unfortunate typo on my part after refactoring. ? &gt; But to make it clear: the reason for that race data race report has nothing to do with the line 60 in that file. It was just a typo in the batched consumer and that race report disappeared after I fixed it. Totally unrelated to that line, race detector just happened to pick it up there: https://github.com/pltr/onering/blob/master/mpsc.go#L43 - was == instead of &lt;= You can confirm it by fetching master and rerunning There was a race condition, so what it's a normal occurrence of software engineering no one here thinks twice about it. It's not until you start making absurd statements like you've done here that people give it a second thought. Such as claiming the data race has nothing to do with the line the race detector reports simply to try to reinforce your prior sleight to me. Anyways I'm done here / concede / you win / I'm an idiot etc. Bye.
I think this is based off of how gcloud works. Gcloud runs everything in containers and they‚Äôve probably taken the tech behind that and open sourced it into gVisor. 
&gt; I didn't notify you of a potential race condition while leaving room to concede graciously because it was only a static analysis. ... " These are difficult to implement and just glancing at your implementation I see sufficient evidence of at least one race condition" Is what you actually sad. &gt; leaving room to concede graciously What is this even? &gt; to download YOUR CODE and run it with -race like you should have done Talk about class. You just can't resist making condescending and denigrating comments can you?
Yes, what about CockroachDB? It have postgres-like interface, cluster-ready out of the box, have an interface to view load (for nodes and in common) and databases, have (of course) tools to dump a data and a schema to files.
Thanks. Will definitely be helpful.
Abstracting things for the sake of abstracting \(like using more inheritance, more generic solutions, writing more tests\) in hope of finally understand the problem at some point, magically is bad. That's what we are used to \- from C# land to PHP land. Because it seems that just by writing some code, things become clear \- that's the problem, code coming before understanding. And we understand a project/product in iterations and at each iteration a hard coded assumption about a solution that covers the future cases \(premature generalization\) is the worst. At each iteration we have to write down what we understand and nothing more. That's why we refactor from time to time when a bigger picture emerges. The bulkier previous code/abstractions are, the harder it gets to refactor it. And a huge amount of Cognitive Load will be spent over keeping a clear understanding of old baggage, in a team. And simpler our tools consume less Cognitive Load which now can be spent over understanding/solving the problem, instead of babysitting our tools and keeping in mind every hidden corner of it's syntax/semantic/settings/etc. I like Go, because it is designed to go through that path \(Of\-course I like less of some cultural aspects of Go\). Staying away from keyboard, in times, pays back in big. The same problem can be solved in any programming language. So the thing that solves the problem, is not the abstractions that are made to stuff concepts into a programming language, but those that came from a deep understanding. The last paragraph sums it up pretty much.
I basically never use them. It adds friction to adding methods to them by requiring you to move the struct first and possibly twiddle with several points where it is used, and I find my structs almost always grow methods. Making it slightly easier for a couple of things at the point of use at the cost of inhibiting method addition is not a good trade, in my opinion. It affords bad code. So I generally just default to naming them.
Damn coolÔºÅ 
There isnt a sensible generic way and you cant simplify the bar method then if its a method you are calling alot \(say an API or library\) you could write a simple wrapper in your own code to simplify the intergration: `func IntBar(i int) int {` `_, i := bar()` `return i` `}`
Hey, my\_guitar\_played\_me, just a quick heads-up: **alot** is actually spelled **a lot**. You can remember it by **it is one lot, 'a lot'**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
delete
Can method B be an interface? type IDGenerator interface { GenID(time.Time) string } If you can have a property on your struct that is of type IDGenerator, then you can supply a fakeIDGen that matches the interface and always returns an expected value for tests. In the production code, you would pass a 'real' IDGenerator that actually uses the passed in time to generate the ID. Not sure that this would work for your problem without more context. The other suggestion of supplying the time function works too.
It's interesting to see that they have "generics" in there: https://github.com/google/gvisor/tree/797cda301677abc8523d5a2a8d731312cc43bce4/tools/go_generics
I started programming in Golang with SublimeText \+ GoSublime, and I almost like it, but if I write my custom package I don't see tips about this package in another go\-files. What should I do to config correct tips?
FWIW, I have downloaded your repo and am running your test, and I'm getting errors. Are you sure it's runnable? # github.com/filegetter/getter /Users/me/Code/go/src/github.com/filegetter/getter/getter.go:90:30: not enough arguments in call to client.GetObject have (string, string) want (string, string, minio.GetObjectOptions) FAIL github.com/filegetter/getter [build failed] Error: Tests failed.
it is a three-index slice form.
What's the benefit of the extra :0 in this usage?
Enlightenment can do this and it's wonderful. I miss this functionality in gnome 3
used `dep` to vendor the version of minio and such used in the example.
Does Go work on fascia
The talk starts out pretty slow. The main takeaways, for me, was the link to [golearn](https://github.com/sjwhitworth/golearn).
I appreciate the link! I've never liked watching videos to learn personally.
https://fuchsia.googlesource.com/third_party/go/
That would be good for *reading* specifically, if this were a web service. What I'm working on is a command line tool and I'd like users to be able to really easily open up the database file in their text editor and make changes to it when the changes they want to make are more suited to a text editor than a command line command.
The kubecon slides are up: https://schd.ws/hosted_files/kccnceu18/47/Container%20Isolation%20at%20Scale.pdf Sadly, no video at this time. The only really interesting nugget there is &gt; ‚Ä¢ Save/Restore is a first-class citizen
If you do it that way, you'd better implement version control with merge-conflict handling. :-) APIs can modify data the same way they can read them. It seems like a google docs spreadsheet may be more suitable for your needs...
I appreciate the suggestion, and for a lot of applications, you'd be right, but the kind of users I'm targeting are a lot more comfortable using vim or emacs to make quick changes than opening up a Google Sheet.
The people using vim and emacs don't know how to use curl?
They do, but it would be an unnecessary step. Maybe I'm not making clear what I have in mind: Have you ever used Taskwarrior? The way it stores users' task data is what I have in mind, and the taskwarrior community loves it. Tasks are stored in a plain text file (~/.task/pending.data by default) in a format similar to JSON. Having the ability to edit task attributes in seconds (with "vim .task/pending.data", for example), is incredibly useful. Why would you want to add in something involving curl?
How do you decide when to use numeric literals vs named constants?
I don't quite understand what you mean. Got a blog post link handy?
Yeah, I really thought he would mention [Gorgonia](https://github.com/gorgonia/gorgonia). I haven't watched most of the QA though
I have to discourage this kind of thing. As someone pointed out, this is clever, but for what purpose? It's such an indirect method of expressing your required functionality. append(a[:0:0], a...) :0 indeed.
r/beetlejuicing 
* Using inheritance over composition * Being pedantic about OO terms ("umm, this is actually a factory/adapter/constructor blah blah blah); failing to use Go naming conventions (e.g. it's not "IReader", it's just "Reader") * They tend to have a hard time dealing with proper error handling * Declaring all of the function's variables at the top of the function * Failing to understand/utilize zero-values correctly func foo(input map[string]string) error { if input == nil { return fmt.Errorf("...") } } * This may just be my experience, but when they write code they seem to stop at "does it work?"; where I tend to see Go developers stop at "does it work AND read well?"
&gt; Google eventually stepped in and solved the issue once and for all by adding versioning support for Go with vgo While I do love vgo and what it does, it was not made by Google. It was started by Goland core dev. And if I remember correctly, Golang is not tied to Google anymore? And saying they solved it is a lie, vgo is currently in prototype state, official resources advice you to steer away from it for production use... On the main subject, I don't feel like using a Java based solution for this. Everything provided by that closed source bloatware can be solved with Gopherpit &amp; SSH access management. Thanks for the ad but I think I will stick to what I already have, all open-source too. 
Validation and remote access.
This is a change into standard library implementation of sort. It's already under review by the inner Go team. I checked the implementation, and the code still needs some work towards readability. With that said, I don't believe that reddit is the appropriate place to rally support for this CL. 
no mention? :(
When I see stuff like this that I realize that I don‚Äôt understand anything about algorithms 
&gt; A coworker wanted to know how large his React app was. (It was large.) &lt;sarcasm&gt;I am surprised&lt;/sarcasm&gt;
&gt; I come from a MVC background What is a MVC background? just curious. What is the "repo pattern" as well? The first thing I see is that you don't even stick to the basics [1]. There iis no need for a src folder or a doc folder [2] [1] https://golang.org/doc/code.html [2] https://blog.golang.org/godoc-documenting-go-code 
Hi, author here. The jsgo playground is an extension of jsgo compiler. The compiler allows you to easily compile Go to JS using GopherJS, and automatically host the results in an aggressively cached CDN. The playground adds an online editor and many other features (share, deploy etc.). The unique feature of the jsgo playground is that it supports arbitrary import paths. Other Go playgrounds are limited to just the Go standard library. For more for more info: jsgo compiler: https://github.com/dave/jsgo jsgo playground: https://github.com/dave/play Take a look at some of these demos: Here's the simplest demo - it just writes to the console and to the page: https://play.jsgo.io/github.com/dave/jstest Here's a couple of simple demos that accept files by drag and drop. The first compresses dropped files to a zip. The second compresses images to jpg. They use the Go standard library zip / image libraries, which work flawlessly in the browser: https://play.jsgo.io/github.com/dave/zip https://play.jsgo.io/github.com/dave/img The amazing ebiten 2D games library is a perfect example of the power of Go in the browser. Here's some demos: https://play.jsgo.io/github.com/hajimehoshi/ebiten/examples/2048 https://play.jsgo.io/github.com/hajimehoshi/go-inovation https://play.jsgo.io/github.com/hajimehoshi/ebiten/examples/flappy Check out the help page in the playground or the github page https://github.com/dave/play for a full explanation of all the features. Let me know if you have any questions, bugs or feature suggestions... I really hope you have fun exploring and I hope it's useful! 
**UPDATE (2018/05/04):** `len([]rune(s))` optimization is already done: https://go-review.googlesource.com/c/go/+/108985
https://github.com/golang-standards/project-layout provides some useful opinionated guidelines.
Well done!
Not sure can it help with searching appropriate library for you case, but I prefer use systemd or upstart to daemonize services, written in Go. Docker is another way. 
looks good to me. 
I agree. Run your programs in the foreground and let systemd handle all the service stuff. Here's a simple service unit file: https://gist.github.com/chrj/47a1e66bad15a25d7aa3e89fbc507c9b Place it in `/etc/systemd/system/yourservice.service` Now you can manage it with: systemctl start|stop|restart yourservice` Check the status of your service with: systemctl status yourservice I would also recommend logging to stdout and let journald collect the logs. Then you can check the logs with: journalctl -u yourservice.service 
This is good advice, although I would mention a few extra things: This makes a "simple" type of service, meaning systemd considers the binary started right away which might not be something that's expected Type=notify will let the daemon control readiness and there are a few extra perks too, albeit with the fact that you have to add systemd specific code to your project Readiness matters because dependencies of your service might depend on your service being available, if it's not a concern just go with the defaults.
Stable inplace sorting is an absolute exotic niche. I doubt there are more than let's say 200 people altogether who ever worked professionally on that subject.
1 folder == 1 package, Sorry but your package structure is just wrong. src or doc aren't meaningful package names.
I own this book. It is really quite bad. It forces GoF design patterns inside Go And doesn't explain them at all. It suffers from useless examples like Cars and Animals as objects and is just drab. Think about skipping this one even if free.
JavaScript: Global Offensive Seriously though that's really cool!
Cool. Thanks for sharing. Quite an empty area shows that community is yet to arrive. Soon..
Hooking this up to AWS XRay would be awesome!
like I said please ignore the src/docs folders and just look in src Is having the folders like models and repos correct?
You asked for feedback I gave the obvious issues with your repository, this is not a good Go package architecture, period.
way beyond my pay grade, but it's really cool to see people adding state of the art algorithms to the go std library! good luck with code review :-)
Thank you for quick answers! Options by control of applications over by systemd sounds a wise. Just because this way can decrease the size of the source code :\) Meanwhile in this case... Should I write a wrapper for handling of system signals for a log rotate procedure? Or I just send of all messages to journald \(syslog\)?
Nope they have an app. 
I remembered seeing someone porting supervisord (python) to Go. Maybe you can use that?
Is there a good one you could recommend instead? So that it could be not about the language, but architecture and design patterns in the context of go. I'm just starting to learn go and when I saw this post I really thought that a book like that could help a lot.
I believe this is just a flaw in the description of the install steps. Just create the path, then cd into it and follow the instructions.
hi, Thanks for replying. I followed the install steps. now I have got the following error &gt;fatal: Not a git repository (or any of the parent directories): .git I appreciate for helping me out 
It sounds like using systemd is a good enough solution for you, and if so, you should use that. In the worst case, which I encountered in one of my projects, you'll have to write a wrapper program that will execute the target program with the desired characteristics. We ended up just using C (as much as I loathe it, even C can be safely written when it's less than a screenful of code and scanned by some static analysis tools), but you can use Go. You'll need to dig somewhat deeply into the parameter to the Cmd object, but everything I know about is in there. (The worst case is something like "I have a user on the shell using my program interactively, and it needs to escalate privileges briefly to do something, but then drop them again because I don't want this running as root." In my case, "do something" was "read a TLS certificate that I don't want the users to be able to walk away with" and as the program is a file transfer program and thus has capability to write arbitrary files with arbitrary content, it's imperative that it drop back down to the user's privileges afterwards. For that, you don't have a choice in Go but to use a wrapper program. There is no safe way in Go to drop privileges like that in Linux.)
It seems strange to have to provide a Wait Group. I would expect the pool to handle all of that transparently.
Agreed. It's not far off from just being Java written in Go. Not sure what book to suggest for good Go design patterns as most of the lessons I've found have been through tutorials or looking at repos like stripe-go and docker.. and avoiding aws-sdk-go.
https://www.reddit.com/r/golang/comments/46f5gi/best_book_to_pick_up_go_for_an_advanced_developer/d04k4d1/ Really, just that.
If you decide to use systemd it will handle log rotation for you automagically.\(when it reach SystemMaxFileSize value\). So just log to stdout. 8\)
Sorry, what color do you want to paint the bike shed, OP?
I worry that the OP didn't ask for design input, not did he provide enough information for you to give any. 
I see what you mean, although the workers are long running and designed to run for the lifetime of an application. The reason for the wait group in this case is to end execution once all names have been printed. Does that make sense?
This is dope!
Will you use the ZMQ encrypted CurveZMQ protocol? (I implemented something like it a while ago: https://github.com/Rudd-O/curvetls )
[removed]
&gt; I come from a MVC background But your code is not mvc, it is not even uses dependency managment, take a look at Iris' mvc examples there: https://github.com/kataras/iris/tree/master/_examples/mvc . Raise any issues, I'm here for you.
[removed]
Hey that's actually perfect! I'm going to look into that more and see if I can make use of it. Thanks!
Thanks mate that's good of you. Is the structure of the project (ignore the MVC pattern for now) ok in general? I shall look into that link now Thanks again
I used this: https://github.com/bxcodec/go-clean-arch as my reference
Unfortunately no-one has implemented a parser for it in Go.
&gt; It's already under review by the inner Go team. There is only one guy who may start seriously reviewing the code. It is great that he is doing that, but what if he runs out of free time or something? It seems like a good idea to try to reach out to more people willing to invest their time in getting this into the standard library (by reading it, getting to understand it, reviewing it; it takes a lot of time).
Search for "C++" to see how my code beats std::stable_sort :)
Thoughts: * Low latency, maybe an edge toward Go because the GC is optimized for that * Fancy UI - edge toward C# as there is way more ecosystem for that there. * Performance - Maaaybe overall edge to C# right now, .NET core 2.1 has made huge strides, but hard to say. It will be similar either way. Both Go and C# will be better than node. * Pointers - C# and Go both have similar constructs here. In C# you can think of every class as being a pointer to a thing, and structs are values. In Go, you can get a pointer or value for any struct. So, if you want to get the best performance, you have to come to grips with memory, in either language. * SIMD - you can do SIMD in go with go assembler, I'm not sure how much is exposed. You can do some very basic SIMD in C# right now, but a more complete API is on the way. If/when that drops it will be a huge perf opportunity. 
You said about the really hard case. My situation looks like an example from a book by Golang. I want to write an application for filtering of HTTP\-requests based by IP address of the client. This feature implemented in Nginx, Apache 2 since the middle ages :\) In particular, like a support the client authorization based on the result of a subrequest. My idea is a creation of a tool for an quick checking of incoming requests \(subrequests in general\) from web servers by the access contol list. ACLs store in Tarantool database. All of this are need because the numers of zones for the testing and for the developing are over two dozens and all those need for securing care manually. Isn't the best wall, but so much better of an open URLs for CRUD to the general database :\) \(In at an ideal world all services hidden by firewalls and available only by VPNs\).
I didn't know about the SIMD lib coming to .net! wow, thank you for an honest and unbias answer! :) I'm learning towards C# right now for sure. I think I'll learn Go for the next web app I have to create, though, as I refuse to run a web server. haha. thank you!!! much appreciated 
The same SIMD capabitlities may be in Go already, you just have to use Go assembler which is hard. But the new SIMD stuff coming for C# will be instrinsic-like, so, a bit hard there too. 
You probably talk about https://github.com/ochinchina/supervisord
I was told we could keep the gopher...
can you reduce it down to something you can put on the go playground, so we can repro the problem?
What does fmt.Printf(‚Äú%v, %v\n‚Äù, var1, var2) show? Where var1 is your slice and var2 is your struct?
Hi there, what is GOF? 
Gang Of Four https://en.wikipedia.org/wiki/Design_Patterns
https://gotools.org
Hi. yes I will use curvezmq to provide the channel encryption. thank you for the link. will check it out.
&gt; JavaScript: Global**ly** Offensive FTFY
I don't know anything about the book, but I'd start with https://tour.golang.com to get a basic understanding of the language. Also https://youtu.be/CF9S4QZuV30 to get an overview
I guess I really have no excuse to not try out GopherJS now! I wonder if it would work pretty well with https://github.com/zserge/webview
Very cool! 
vgo doesn't require your projects to reside in $GOPATH (see https://research.swtch.com/vgo-cmd, "Working outside GOPATH"). It currently stores the downloaded packages in `$GOPATH/src/v/` so under the hood it still does make use of $GOPATH, but you are free to store your Go projects wherever you would like on your machine when using vgo.
blue
As someone who wrote quite a bit of ultra low latency go code, here's a few notes: * Go GC can be truly horrible, despite the claims it's not really low latency. For example, it will forcibly run every 2 minutes and and will stop the world during that time for at least 20us even with an empty heap. * Dealing with pointers is the least of your worries when writing low latency code, prepare to deal with hidden heaps, arenas, uintptr's, all sort of unsafe tricks all of which needs to happen to hide data from the GC * Go's GC being concurrent is a double edge sword. It means it scans the heap in the background slowing the whole system down. It also means a lot of code the compiler generates needs to have memory barriers, for example. * Prepare to be unable to use 99.9&amp;#37; of go libraries in existence. The vast majority of them allocate memory or are otherwise latency oblivious. I had to write my own json parser, FIX parser, a lot of low level network stuff, synchronization primitives, allocators, message passing interface \- the whole bunch. Although I suspect it's the same situation with any other "high level" language. * At the end of the day, though, when you strip Go of its standard library, it can be quite nice, I'm still more productive in it than I would be in C\+\+, I think. Of course all of that is only really applicable, when you need truly low latency \(like executing trades in under 1us\). Not sure what your requirements are. Here's a WIP library of mine, that is a real time queue: [https://github.com/pltr/onering/](https://github.com/pltr/onering/) I want to opensource my json parser too in time, it's significantly faster than any other json parser i've seen in go. Sorry, it only supports sending pointers at this moment :\) And it gets to peak of its latency guarantees at a significant load \(a few million messages/second\). 
Thanks a lot. finally it worked 
The Bootcamp book seems to be still current. The language and the standard library have been stable for 6 years.
Thanks! 
I wish it comes earlier ...
Or maybe in Go 1.39916800!
I'll do one more, later.
Ummm, that thumbnail?
39916800!
I understand that. The above is the structure I generally use for projects now. What I am wondering is how to best break that structure up into modules for using with vgo
Go code example returns LoginInfo* instead of *LoginInfo
The Go assembly is not portable by any reasonable definition of the world portable. What problem are you trying to solve? 
I'd also recommend joining the Gopher Slack, there is a golang\-newbies channel which is a great place to ask realtime questions for people just starting out. To join the Gophers Slack go to [https://invite.slack.golangbridge.org/](https://invite.slack.golangbridge.org/)
It seems there's no mature cross-platform GUI solution for Golang. Take a look at https://korok.io/, it has a imgui based GUI system, I have used it to write a gif viewer https://github.com/ntop001/xgif.
No problem, just curious.
I had made changes to the code before copying it, so I manually edited and got it wrong :) Thanks for pointing out, fixed now.
Awesome!
Hi, author here. Happy to answer any questions (although maybe with a delay, as I‚Äôm still without home internet due to a recent storm).
A quick search on google yields this page which has a lot of results.
Users authentication in Go, have the same concepts than authentication in other languages like Python, Nodejs, Java, ... maybe this link help: http://lmgtfy.com/?q=golang+authentication+tutorial usually people use JWT (JSON Web Tokens) https://jwt.io/
Do you have any experience with vecty? I tried astilelectron and found some issues regarding to debugging and in general it was a pain to build a 200 mb source file.
[This](https://crackstation.net/hashing-security.htm) article really helped me understand the topic better.
Hey, that's what I'm doing at my job
We have a bounty on our peer-to-peer ecommerce app for adding self-signed TLS certificate generation: https://github.com/OpenBazaar/openbazaar-go/issues/868 We have a number of other (non-bountied) open issues but I picked something that was self-contained and should be relatively straightforward. 
Thank you for this amazing tool. Got to know about it in the video by adg &amp; cbro on twitch.
File IO and http requests depend on syscalls so they‚Äôre not really something related to the portability of assembly language. Random number generation is also CPU and OS specific, so it‚Äôs also a bad candidate for writing semi-portable assembly. 
Please for the love of Christmas pudding follow the MySQL docs and [DO NOT USE THE PASSWORD() FUNCTION FOR USER PASSWORDS](https://dev.mysql.com/doc/refman/5.5/en/encryption-functions.html#function_password). I apologise for the capitals but I cannot stress this enough, it is just two rounds of MD5. A better suggestion would be to use bcrypt, PKBDF2, or any of the other numerous dedicated password salting and hashing functions. There's a [go port of passlib](https://github.com/hlandau/passlib) which is pretty good for this (my PKBDF2 PR is pending), and the upstream [python passlib](https://passlib.readthedocs.io/en/stable/) is really good for explaining things and the different algorithms. 
[Gorgonia](https://github.com/gorgonia) is a family of libraries dedicated to machine learning and deep learning in Go. Currently our focus is on improving CUDA connections. But along the way there are other improvements to be made too, like redesigning the VMs to take into account concurrency and the like. Challenging but ultimately fun problemss
It would be better for you to contribute to something you already use. It makes no sense to contribute to a random project you don't even know to begin with. 
&gt; How expressive are the abstract, cross-platform assembler instructions available to Go assembler? I wasn't aware abstract assembler instructions existed. I thought assembly was always specific to the cpu architecture's instruction set. In face I'm quite sure of it. &gt; Now, must the developer always write some platform specific Go assembler to do anything practical (file I/O, exit status, http methods, random number generation). No you don't need to write anything platform specific for those things. You simply compile based on your destination. https://github.com/mitchellh/gox 
I don't know much about Go web authentication libraries but I do greatly recommend not reinventing the wheel. Do something that someone else has done before. There are many mistakes one can make, use the experience of others that have already made those mistakes to your advantage. The basic login mechanism is: get username and password from user, hash their password, compare the hash to the hashes in your DB and if you successfully make the lookup, issue that user a cookie you signed. When checking if a user is logged in, you check the sig on their cookie and if it's valid and the cookie is not expired, they are authenticated.
This is thoroughly worth the time: https://www.youtube.com/watch?v=KINIAgRpkDA The OP has initialized some concepts with conflation enabled. File access, etc. are related to the OS (GOOS) while ASM is related to the architecture (GOARCH).
I have two thoughts on the topic. Lately it seems a lot more sites are moving towards passwordless mechanisms.. in particular, a magentic link like how Slack allows you to get a link via email, then just auto-log in when you start slack up. Using a cookie in a browser or the newer html5 storage mechanism to send the token in on each request but also have it have some sort of configurable configuration period would at least allow a quicker/faster/easier (though it does take on 2 trips to get the link after entering email to then be able to log in). Some will use that method for every login..e.g. no cookie/storage cache.. every time you just enter email get the link then log in that way. I like the idea somewhat.. but not quite sure if the long live magic link process is safe or not. The other thought.. and sorry this isnt an implementation thing..but LastPass and such are really good password managers these days, and work across devices. So using a tried/tested way some other replies have provided.. and maybe hint at the use of LastPass to manage passwords and provide strong odd passwords instead of the user entering simple ones (enforce it even), is a better way to go. I too would like to know if there is some better way to avoid username/password logins though. Why I like the first passwordless option is that for a consumer site, it gets you "signed up" faster because they enter their email which not only is now used as a username (and is unique), but it also gets them logged in soon as they check email and verify the email by clicking on the link.. you sort of kill two birds with one stone and the consumer gets in and uses your site sooner. 
Use [bcrypt](https://gowebexamples.com/password-hashing/) instead of SHA 256. SHA's are not sufficient password hashing algorithms; they're too fast. Additionally, modern password hashing algorithms like bcrypt and scrypt handle the lower level details like salting for you so you don't have to deal with it and can't screw it up.
Nice work! Just a few things I noticed: - Run gofmt every time you save. Your imports hadn't been properly formatted, although this is pretty minor. The rest of the code was properly formatted, which is what matters. - [line 49](https://github.com/monkeyworknet/mc-afk-nuke/blob/1ddd6875030cf2c9509ccad7a3ca1e4bd5bfbcf5/main.go#L49): Defer statements are run after the function returns, not at the end of the block. This means that the file will only be closed after your program exits, but you could just be closing it here since you don't use this file handle. It doesn't really matter for a short-lived program, but these kinds of things might start mattering later. - You don't need to export the struct types to be able to unmarshal json, if you're exporting them for that reason. All you need is the fields to be exported. - Just a side note, efer statements are not run if the program exits by os.Exit. I guess it doesn't really matter since only Close()s will be affected. - [line 120](https://github.com/monkeyworknet/mc-afk-nuke/blob/1ddd6875030cf2c9509ccad7a3ca1e4bd5bfbcf5/main.go#L120): You already exited with os.Exit(0) above if playercount == 0, this feels unnecessary unless the player count can go negative. You could just omit the entire if statement and just have the for loop. - [line 179](https://github.com/monkeyworknet/mc-afk-nuke/blob/1ddd6875030cf2c9509ccad7a3ca1e4bd5bfbcf5/main.go#L179): Don't do this. It severely lowers readability. I would suggest using something like fmt.Sprintf("%s-%s[...].json", args). Using names like index1 and hyphen is not useful. - [line 154](https://github.com/monkeyworknet/mc-afk-nuke/blob/1ddd6875030cf2c9509ccad7a3ca1e4bd5bfbcf5/main.go#L154): Remember to close this response body. - Instead of returning empty values on error for getUUID or playerMovementStats, try replacing/wrapping the errors with more information and returning the errors. Instead of the return value being (string, string), make it (string, string, error) and do the logging at the caller if an error occurred, in this case at the main() function. Same with the playerMovementStats function. - I would suggest the same thing as above in the kickPlayer function. Return the error (with more info, if needed), then do the logging at the caller. Do not silence errors like in [line 115](https://github.com/monkeyworknet/mc-afk-nuke/blob/1ddd6875030cf2c9509ccad7a3ca1e4bd5bfbcf5/main.go#L115), log them, handle them, but don't throw them away. If you are going to silence them, you can just omit the assignment and just do kickPlayer(), no need to set it to `_`, unless some tool is complaining about not handling errors? - [line 138](https://github.com/monkeyworknet/mc-afk-nuke/blob/1ddd6875030cf2c9509ccad7a3ca1e4bd5bfbcf5/main.go#L138): Do you need to re-open the database on every user, separately? Otherwise, you might as well create the database in main() and pass it in as an argument to this function.
Here's a description with code... note that bcrypt is recommended over SHAs
In my humble opinion... I don‚Äôt really agree with naming the package `html` with the repository named `encoding-html`. 1. Directory name and package name don‚Äôt match 2. Clashes with standard library `encoding/html` I feel you should‚Äôve just given it an unrelated and catchy name like `ekko` or something.
Trust me, I would love to name it something more catchy, but my naming sense for things like these are horrible, but people always seem to come up with something, given a bit of time. But I'm all up for ideas? And the reason why I didn't just name the repo html is that it would be horribly confusing to just have a repo named html.
Nice. Although it's a lot of work for very little benefits. &gt; Long story short: the type limitations imposed by gomobile are still very crippling. time.Time is not supported, collections (such as map and slices) are not supported, uint8 (or any unsigned type) is not supported... struct return-values are supported only if returning a pointer (i.e. *MyStruct rather than MyStruct). So basically no Go package can be supported as-is. 
Well I can't really say how secure is secure but here is a basic break down. I love his code cause so readable. I'm sure not production ready but a good start. https://github.com/GoesToEleven/golang-web-dev/tree/master/030_sessions Or take his class. https://www.greatercommons.com Really really really nice guy. Or just message him on Twitter.
Didn't found anything interesting in this 16 videos, a lot of them has almost nothing to do with Go (speakers mentions go maybe in 30-60 seconds of 25 minute talk).
I'll check this our and work on an example using this using Go! Thanks for the idea
&gt;Thanks for the comment. I'll update the code when I have time. Wouldn't mind a pull request to the repo as well :\) &gt; &gt;Re underscore in my example doesn't mean anything. Still new to Go and yes I agree it should have some semantic meaning. 
No problem! Have fun!
Russ' talk is very good.
Didn't found anything interesting in the first 10 words of your post and a lot of your sentence is full of grammar mistakes (you don't mention anything about go at all in your comment)
I suggest `ekko`. Or if you want something more relevant then `htmldecode` or `decodehtml` might do it.
Re-writing your Go code in Dart (and keeping the 2 code-bases in sync so bug fixes from one codebase are also applied to the other) may cost a lot more than working around the gomobile limitations.
&gt; Didn't found anything interesting in the first 10 words of your comment and a lot of your sentence is full of grammar mistakes (you don't mention anything about go at all in your comment) \#2edgy
Read my article. I explain that all I wanted to do was write a mobile GUI for a Go app. And that's what I did.
I guess these confs are more interesting for their workshops than their talks. And aside from versioning, it's not like anything new is really happening with the language, no new tools, or new syntax.
&gt; Read my article. I explain that all I wanted to do was write a mobile GUI for a Go app. And that's what I did. Well, you didn't create a mobile GUI in Go, you used Flutter. And you went through insane oops to integrate some trivial code. 
yeah, my contributions to projects is always self serving. I add/fix things because I need them.
I'm sorry, you misunderstood what I wrote. I meant I already have a Go codebase, and wanted it to run on a phone with a mobile GUI on top, not that I wanted to create a mobile GUI in Go. Do you understand now? The Go codebase was not trivial. It uses advanced cryptography including new algorithms like Argon2. Doing this in Dart/Flutter should not be considered trivial even by a cryptography expert. 
&gt; it only has C# bindings from what I can see. From the documentation you linked to, it looks like it also has C bindings, which will probably be easier than using the C# bindings (unless there's a way to compile Go to .NET CLR).
If you have a DLL, you can use the methods detailed here: https://github.com/golang/go/wiki/WindowsDLLs
Found this https://www.welovegolang.com. Not sure if they have SEA jobs there
[removed]
Well, your main function isn't that large, but it does make some things easier. It would help with the defers being run properly, for one, if each thing that needs to be closed lives in its own function and is cleaned up when the function returns. Plus smaller functions are generally easier to read and maintain.
There's two ways to think about this. The cynical way and the less cynical way. The cynical way: conferences are mostly about self promotion (of the speakers) and networking. If you think about it, it's preposterous to expect more than one novel idea per year in a single programming community. If you go by that rule a conference is good if it has one single good talk. And there are ~10 go-related conferences every year at this point, so in a good year 90% of them will not be good. The less cynical way is that human ignorance knows no bounds and something that's old to you will still be news to somebody else.
This is great! I haven‚Äôt seen it before but I‚Äôll use it on another project for sure. It should work great with jsgo...
what is the impact of generating it multiple times? like you said not a big deal on this program as it only generates a single random number but just want to understand the reasoning behind that. 
When I interviewed for a mid-level level Go Engineer role, the hiring manager gave me the following as a test. A mid-level should complete the following in one day to two days. I need an online address book exposed as a REST API. The data includes the following fields: First Name, Last Name, Email, Telephone Number. The API should have the standard REST semantics to 1) retrieve all entries, 2) retrieve one particular entry, 3) add an entry, 4) update an existing entry, 5) delete an existing entry. The Address Book should have typical Go tests that demonstrate how to exercise all operations of this service. Finally, this service should have endpoints that can import and export the address book data in a CSV format. If the API depends on an external database or other service, provide a thorough README file on how to configure such settings. Good luck! Hope this project will push your skills to the limit! 
So, is there any news about vendor integration with vgo?
Depends on what your last information is.
Actually quite a good project, have experimented a bit writing non rest API's in python and to be honest it is quite tedious and difficult.
Why go with Mongo instead of a traditional database?
I don't believe this is a good test or practice for Go, as there are relatively few Go concepts here. Good practice projects would include, at least: long-lived Goroutines, inter-goroutine communications, good error handling, maybe a bit of locking, caching, and object re-use.
The evolving pictures project I did on my stream a while back I think is a really nice intermediate project. It includes: * 2D Rendering and mouse/keyboard input with SDL2 * Working with trees in interesting ways * Working with interfaces * Genetic Algorithms * Lexing and parsing * Abstract syntax trees * cool graphics/math! Starts at 19 minutes into this video: https://youtu.be/7YvStSI0FIk?t=19m38s You will want to do the SDL2 setup as a prereq: https://www.youtube.com/watch?v=OXSMx45kayw&amp;list=PLDZujg-VgQlZUy1iCqBbe5faZLMkA3g2x&amp;index=6 And we use simplex noise during it, you can roll/grab your own or go through episode 9 and 10: https://www.youtube.com/watch?v=C_fbO5GAwXY&amp;list=PLDZujg-VgQlZUy1iCqBbe5faZLMkA3g2x&amp;index=9 
I'm not sure that this assignment is much to push any coding capability limits, more so to make sure prospective hires are able to write clear, maintainable code that is well-tested and well-documented.
Thanks!
Hashing a password is like 1 of 50 steps required in a truly secure authentication system, and if you skip any of the other 49 steps you risk creating an insecure system and screwing your users by leaking data in one form another. Find a good, comprehensive course, book, or LONG tutorial and read it all. Learn how the entire authentication process works, and make sure you understand it all as you write your code. In Rails Tutorial (https://www.railstutorial.org/book - the HTML version is free) the authentication system you build spans like 3 or 4 chapters, and thats with built-in helpers provided by Rails that you likely won't have in your Go application. My point isn't that you shouldn't try to learn - you definitely should! - my bigger point is that there is a ton to learn and you shouldn't just wing it because 99 times out of 100 you miss some step and have an insecure setup without ever realizing it until its too late. Sometimes that just means users can log in as other users and create silly tweets, but other times it means you could leak passwords and all sorts of other potentially sensitive information. I don't know what free resources to suggest unfortunately. There are a lot out there, but most talk about things in a complex manner and it isn't always clear how to translate what they are saying into Go code, so even using one of those you can make a mistake. The rails tutorial book is a good tutorial to follow if you know rails, as translating the code into Go isn't TOO hard, but my guess is you don't know Rails so it won't help :( I do have a course &amp; book that covers all this with real code examples (you build a complete web app w/ a secure auth system from the ground up), but I don't want this to come across as a sales pitch. It isn't. I don't care if you use my course, I just don't want you to build an insecure system and then let real users sign up putting their information and passwords at risk. Worse yet, I don't want you to sell insecure software to yet another company that will use it blindly. I guess the best I can do is say if you have trouble reach out if you can't find any useful resources - &lt;jon@calhoun.io&gt; - and I'll try to see what I can do to help.
Thanks for the link. It is great news that they are keeping support for it. Not doing so would have definitely split the community and resulted in multiple, incompatible tools.
It may not be go specific very much, but for someone beyond entry level of programming wanting a toy exercise, this is decent. For someone with experience building basic rest APIs, it's something that can be thrown together in a couple hours and exercise types, struts, web endpoints, error handling, database connections, and unit and integration testing practices using Go (or any other language for that matter). And if it was an exercise for a job interview that was a lot of CRUD style API development, it's a relevant test of knowledge related to the main job responsibilities. 
It‚Äôs schemaless so you can change the structure of your data anytime.
You have an implicit schema in Go, even if it‚Äôs not enforced by the database. But Go is statically typed, so why not carry that through all the way to your database?
This is great stuff. I've never been totally comfortable with the throw-a-sat-solver-at-it feel that a lot of package managers have, but I didn't understand my discomfort until Russ broke it down.
I wrote this experiment a long time ago but it was targeting .NET Core on Linux/OSX: https://github.com/matiasinsaurralde/go-dotnet
I really like that he tackled head-on how vgo could also break in the same way as "traditional" package managers would in some scenarios. The great part about minimum version selection is that it can never break randomly, only when either a new dependency is added or an existing dependency is updated. Versioning is still a bit of a headache for now, but I appreciate how much effort is being put towards getting it right.
You need to export an identifier (function, type, vars...) only when they need to be used in another package, when you are writing a library that will be imported by some other code. Generally, you never need to export stuff in the main package except struct fields if you're using packages like encoding/json, or for readability reasons.
Sure, which is why I clarified it as not being good "for Go". 
Interesting. I was there, and I thought Katrina Owen has a refreshing view on refactoring Go code, Hana Kim was stupidly awesome at showing off Go 1.11 tracing. I also thought Bill's talk to be slightly unnerving. Russ as usual is good when he talks. 
I think I remember that game - it was an online coding adventure that introduced Go by having the player complete some Go code snippets in order to unlock the next "room". I searched on Google, GitHub, and in my own bookmarks but did not find anything. It seems as if this adventure has been taken offline and even has disappeared from Google's search index. Would love to hear if anyone is able to recover this coding adventure game.
Regex is a poor solution for this need, and custom http handler funcs should be a last resort where compatibility/usability are a concern. Here is an alternative approach to accessing path params while avoiding both custom http handler funcs and regex: https://github.com/codemodus/parth The parth API size makes the library look more complex than it actually is to use. Since the path is already being passed via the http.Request type, parth function calls make segment access extremely cheap compared to passing special data structures via custom func def or even simply passing the data via the request context. It's also worth understanding that this allows one to wrap their favorite router and drop special func defs so that http routers are interchangeable with little to no effort.
Interesting... I'm just starting up with Go, and I've been looking into implementing web apps in Go and there's always this thread on httprouter and Gorilla mux. But digging into their code shows complex recursion on the request path which I do not like. I kinda implemented this solution on mine by looking into their code and trying to simplify their implementation. You are correct, since request is already being passed we can just capture the path variable based on the specific location in the path and no need for the custom handler that extracts the path variable then passing it again to the function call. Thanks for your input. :\-\)
MicroCorruption is similar and very fun, but not golang.
What does it add to [this classic piece](https://blog.golang.org/go-maps-in-action)?
[An obligatory reference](https://blog.merovius.de/2017/06/18/how-not-to-use-an-http-router.html) for this kind of posts.
With all due respect, I'm inclined to think it's a waste of resources (except serving for self-education). Here's why: - The project's name is really unfortunate: [`gvm`](https://github.com/moovweb/gvm)‚Äîa tool enabling running several Go environments in parallel‚Äîexists since forever and is reasonably visible in the community. You appear to know about that project and even link to it in the README without any further ado. I cannot understand this attitude, though: you create certain confusion and even admit it. Why? - In this day and age all the excitement in the community is concentrated on the [`vgo` tool](https://github.com/golang/go/wiki/vgo) being developed by the Go team at Google, and which draft implementation is targeted for inclusion in Go 1.11 (and the stable version‚Äîin 1.12). That latter bit is particularly important, IMO: until there was an *official* tool to deal with versioning, 3rd-party implementations did really compete between each other; they came and went, some stayed and persisted. Then the `dep` experiment came, and for some time it provided an impression it would have been *the* versioning tool. Then `vgo` came, and now it appears that the question about which tool will dominate this "market" appears to be essentially closed. Not because `vgo` is somehow orders of magnitude better than the others but merely because *choice is hard* and people naturally tend to use whatever is considered as "the standard". So, alas, I cannot forsee any considerable traction for your tool: it might be good but `vgo` is also good and it will be "in the core". 
It seems that your comment contains 1 or more links that are hard to tap for mobile users. I will extend those so they're easier for our sausage fingers to click! [Here is link number 1](https://github.com/moovweb/gvm) - Previous text "gvm" ---- ^Please ^PM ^/u/eganwall ^with ^issues ^or ^feedback! ^| ^[Delete](https://reddit.com/message/compose/?to=FatFingerHelperBot&amp;subject=delete&amp;message=delete%20ID_HERE) 
I think it was https://www.reddit.com/r/golang/comments/2veiht/operation_go_a_routine_mission/ but it's not available anymore, and the repo is gone. Here is a fork I found on GitHub though: https://github.com/andreapavoni/operation-go
DAE `map[string]interface{}` 
[Gitea](https://github.com/go-gitea/gitea)
Admittedly just nitpicking here, but it's so weird to me: you wrote the name of the language correctly in your title and than you capitalized it in the body of your post. Why? ^^If ^^it's ^^to ^^trigger ^^people ^^with ^^OCD, ^^well ^^played ^^:)
Thanks, I've edited that one :\). Wasn't thinking about those details I guess. 
isn't it www.codingame.com ?
Ewwww.......
Some poking around and reading the [slices](https://blog.golang.org/go-slices-usage-and-internals) blog post has unstuck me some, but now my lack of knowledge of how memory works at a low level is killing me (I think). Because the underlying type is `int`, and not `*int`, go is re-using the memory location when ranging over the entity. I wrote [this](https://play.golang.org/p/LbvH0MmWOnT) playground to test this theory. The second one makes sense, I am explicitly creating and adding new values (int is a primitive and I was too lazy to create a dummy struct so I had to that nasty little step of assigning and taking the address after the fact). I'm pretty much floundering my way through this so any reading material and such would be greatly appreciated. 
There's #go-nuts on Freenode IRC. There's also a Golang Slack. I'm in the both if you want to chat.
I‚Äôve built a few small things with some of those in GoLang. Angular 5/ GoLang/ Mongodb stack. I thinks that‚Äôs a pretty good stack. I would love to talk about it.
To avoid confusion, since the range operator returns and "index,value" you might change "i" to "v", it will be more natural for others to read. Ok, so since the array/slice if of value types (ints) and not pointers (*ints) when you get the value you get a *copy* of the value, stored in i. Go is reusing the same memory to store those copies are you iterate over the array. That may not be something you can count on, if it isn't in the spec, but in this case that is what is happening. If you wanted pointers into the array of values, you effectively would get that buy using the "index" instead of the value. for i,v := range myArray { myArray[i] = 5 // myArray is a pointer to the start of the array, i offsets that pointer to the ith element in it }
http://devs.cloudimmunity.com/gotchas-and-common-mistakes-in-go-golang/index.html#closure_for_it_vars
May not be challenging enough for you, but they may help - Gophercises.com
Np. And if I can ever help feel free to get in touch with questions. I just didn't want you to get half of it right only to still have a bug :)
Delve doesn't support plugins [yet](https://github.com/derekparker/delve/issues/865) as it depends on [missing debug information](https://github.com/golang/go/issues/23733) that Go upstream needs to fix first.
Ok, that makes sense. Thanks!
Ahhh thank you!! That painted the picture I was trying to create with the playground lol, much appreciated 
It all sounds so obvious now but I was so shocked and tripped up by this lol. Thank you. 
I don't disagree but it's not even the 5th time this week that I've seen someone rolling their own JSON pretty printer. `jq`... The letters alone don't really tell you what it does if you think about it. It's like a bad variable name lol. I've done my own variation of this in as long as it to remember `jq` exists and what cli flags I've needed. I think that speaks more to Go's JSON ease of use then "hey there is this neat tool that already exists". 
Ok, that makes sense. Thanks!
You could take a look at other users on [GoDoc](https://godoc.org/plugin?importers). That said, in general I've seen the the tendency in the Go community is to statically compile everything, even if you have some kind of plugin architecture internally. [Telegraf](https://github.com/influxdata/telegraf) is a good example of this pattern. Plugin libraries may be nice for some use cases, but static builds are very convenient for distribution/deployment. Perhaps folks here will be able to give better advice if you describe the problem you're trying to solve with plugin.
Telegraf is a solid example, thanks for sharing. It's on a track of what we are trying to build. The idea is to have a binary that would connect to the server and download plugins that it needs. Thus not deploying 15 plugins everywhere if only 3 are needed for example. And as with Telegraf to have a minimal memory footprint.
The spec actually says about `range`: &gt; The iteration values are assigned to the respective iteration variables as in an assignment statement. Which implies that is iteration variables are used, their memory is rewritten on each assignment performed by each iteration of the `range` statement.
Hey! Could you elaborate on why you prefer CockroachDB? I just started a little go microservice project using postgres because... you know... open source and it's not made by Microsoft haha. Should I make the switch?
Another logger :/ What's the benefit vs Zap that is already super fast and battle tested + feature full?
Completely agree with this guy. Skip frameworks, use gRPC for anything that doesn't need to deal with JavaScript. When you absolutely have to, websockets are a great alternative for streaming. 
Just a quick followup to my own reply. I have actually tried vecty today and it's purely browser based, in contrast to astilectron which gets you standalone executables. So for me personally, vecty isn't a solution after all. I'll probably stick with astilectron and try to incorporate it with [golymer](https://github.com/microo8/golymer). Building is a pain with astilectron indeed, but with e.g. Qt you have the same pains probably.
The Gopher slack group is a terrific community of GoLang developers. Come join us! https://invite.slack.golangbridge.org/
This one is faster when disabled.
I'm already there. I've posted there the same message to the #golang-newbies channel, but people not happy about it. They are ready to discuss my questions in text form, but don't want to do it by voice. I haven't found any channels like #introduce_yourself there, so I don't know what channels are suitable for such messages. For example, on discord server "Discord Gophers" they have deleted my the same message like a spam. So I believe in power of Reddit :) 
I think best practice around it is probably not to use it in production, not quite yet. It's _almost_ there, at least on Linux, but not quite. For dynamically loaded - rather than embedded at compile time - plugins I'd look at Hashicorp's [go-plugin](https://github.com/hashicorp/go-plugin) as an alternative, one that runs plugins out-of-process. It's grpc-based, so the plugins don't even need to be written in Go. Though if you're looking to minimize footprint that's probably the wrong direction.
It looks like _this_ `gvm` also does what the other `gvm` does, and manages your installed and active Go version(s) for you. It doesn't look to be an alternative to `dep` or `vgo` once it's integrated with the official toolchain. Also, the other `gvm` linked in this project's readme hasn't seen any commits for over a year, and that's not for a lack of open issues or pull requests either - it just looks like it may be abandoned. In which case, maybe this tool would be useful for people who did use `gvm`, if it isn't working for them anymore. Allllll of that being said, I don't personally see the benefit of using a tool like this. I think the Go team has done an excellent job with backwards compatibility, and any breaking changes have been particularly minor as far as I've known. I'd rather just stay at the latest version. At work we use Docker and just update the build image we use when a new version comes out. We have tests to verify things still work.
 var modelType = reflect.TypeOf(Model{}) func callback(v interface{}) { rv := reflect.ValueOf(v).Elem() if t, ok := rv.Type().FieldByName("Model"); ok &amp;&amp; t.Type == modelType { pv := reflect.New(rv.Type()) pv.Elem().Set(rv) pv.Elem().FieldByName("Model").Set(reflect.Zero(modelType)) v = pv.Interface() } fmt.Printf("[redacted:cpy]\t%T:\t%+v\n", v, v) } 
If the benchmarks here are taken from zap, as the readme suggests, then they're giving `zerolog` a bad shake: https://github.com/uber-go/zap/pull/484
The main component is written in Go. The part that does all the networking, IPFS interaction, contract management, wallet, etc. The desktop client is Electron, the web version will be pure JS, the mobile apps will be native clients talking to an embedded Go server. Back in 2015 it was a Python app. I originally got involved in the project development because I wanted to rewrite the Python to Go, but then it ended up that we wanted to rearchitect to utilize IPFS anyways.
Posting this in /r/golang because you can write AWS Lambda functions in Go.
aaah THANKS a lot! so the trick is to make an addressable value using reflect.New() and copy by using `.Elem().Set()` on that. 
alias pp='python -m json.tool'. 
Yeah, but there's also already [jsonpp](https://github.com/jmhodges/jsonpp) (also Go, and 2 years old) and [json_pp](https://www.systutorials.com/docs/linux/man/1-json_pp/) (Perl, probably even older). Sometimes people write things for self education; in this case I think it's just a matter of being too lazy to do some basic research before diving into something.
The magic is in here: https://github.com/francoispqt/gojay ( fast JSON lib )
No.
I would not do this, it may panic and is destined to leak the data you are trying to protect one day. Creating a stronger interface between you and your logging is the safest change here. That means changing `callback(interface{})` to `callback(log.Entry)` and declare `type log.Entry interface { Entry() T }` where `T` could be a `[]byte`, `string`, or maybe `json.Marshaller`- whatever the behavior the logger needs to create a log entry. Then if you want to log something you have to create a `Entry() T` method on the model. There is lots of ways to structure this and it depends what methods your models have now, but here is a basic example: type log.Entry interface{ Entry() T } type Model struct { ID uint; Foo string; When time.Time } func (m Model) Redacted() Model { m.Foo = ""; return m } type Bird struct { Model Size uint } func (b *Bird) Entry() T { cpy := *b // fast local copy // now maybe you json.Marshal cpy, or json.Marshaller if your models // already implement it, whatever makes sense. An interface{} would // even be okay- but your log already has to serialize or take some // baseline representation so it's best to use that. cpy.Model = cpy.Model.Redacted() return cpy } There are other ways to approach this, but hopefully this serves as food for thought for a safer implementation.
Suppose for sake of argument you had a struct with 1000 receiver methods on it, or 100 large ones. *Perhaps* you would break up the methods into different files and group them by some logic, to make it easier to find things. But generally it is probably a bad idea to break them up yes. Don't ever feel like guidelines of this kind are rules you *have* to follow, any time following them makes your life worse, stop! 
&gt; is it acceptable for methods of a type to be in different files? Absolutely. A file should preferably group similar functionality and methods may come in groups in that point of view.
Can you note what's missing to be "production" ready? I really need it to have footprint as small as possible and performance is really important. Plugins will and can be written in GO, that's not a problem. 
Heaven forbid someone try to contribute something to the community
You may also use https://github.com/DATA-DOG/go-txdb to isolate all scenarios in transaction. Just open tx-db in beforeScenario hook and close it afterScenario so that transaction is rolled back, that will reset all the changes in db on every scenario and is a proper and recommended way to use with **godog** or any integration tests, since each test should not depend on any global state. And transactions will be very fast to run integration tests on database. Postgresdb even supports table changes within transactions.
How does that performance compare to sending logs to dev/null
 %‚ñ∂ where jq zsh: exit 1 
Yeah, GitHub would be a good place for that.
Yup
awesome. Please keep it up to date :)
Seems like they are yes, at least when logging extra fields. Will submit pull request to add onelog logs. 
You're right most of it is done there
I work in a company with high traffic and we're going to use it. So it will be battle tested as well. Also, it is faster when logging additional fields and when disabled.
I didn't know that I wanted this, but I do.
Feedbacks are welcome.
https://codebuddies.org/
This looks awesome! I'm going to add it to my daily flow.
What if I need to perform some data transformation prior to import? Would it be more efficient to do it, write it out to json/csv and then use this tool or simply call the function above? 
Working great for me so far! I really like it, thanks!
This is the last missing feature for me in VS Code. 
Looks cool, but after installing it it shows "Go-Outliner: Install Missing Tool" Source: Go Outliner (Extension) with an Install button that doesn't seem to do what it needs to do. Any ideas?
Windows
Awesome, thanks a lot
Statically checking that `*defaultValidator` implements the `StructValidator` interface.
Thank you! 
A compile-time equivalent of: ``` func TestDefaultValidator(t *testing.T) { dv := &amp;defaultValidator{} _, ok := dv.(StructValidator) if !ok { t.Errorf("*defaultValidator does not implement StructValidator interface") } } ```
Seems broken. Are there mirrors?
This will help get up to speed until it lands in go compiler itself: https://blog.gopheracademy.com/advent-2017/go-wasm/ https://web.archive.org/web/20171223081434/https://blog.gopheracademy.com/advent-2017/go-wasm/ Although these are doing c++ to wasm, it shows what's possible with wasm now: https://floooh.github.io/oryol/ http://kripken.github.io/emscripten-site/docs/compiling/WebAssembly.html#webassembly 
Same here. I made sure to run "go get -u github.com/766b/go-outliner" in advance and did what I could but the message doesn't go away.
Thanks for the responses. Followup question: I assume this is a good thing to do? Are there books or other resources with a collection of best practices like these?
For anyone who wants to try this, I used these steps: git clone https://github.com/andreapavoni/operation-go cd operation-go go get golang.org/x/tools/present go build golang.org/x/tools/cmd/present ./present -base=. Then it fails when you try to login via github oauth. However, it seems like if you just set a cookie from the browser dev console it will work since it was only using github to get your name, avatar and email values to store in a cookie ([line 122 in app.js](https://github.com/andreapavoni/operation-go/blob/master/static/js/app.js#L122)). document.cookie="user=MonkeeSage|monkeesage@gmail.com|monkeesage@gmail.com;path='/'"; Then reload the page. Not sure if anything else is broken, but that let me start the first mission at least.
&gt; these folks call it ‚ÄúVariadic functions‚Äù Just FYI, Rubyists also call them ["Variable-Length Arguments"](https://ruby-doc.com/docs/ProgrammingRuby/html/tut_methods.html#UA) (*varargs*) or "Variadic Functions", which is a carry-over from [the name given to them in C](https://www.gnu.org/software/libc/manual/html_node/Variadic-Functions.html).
&gt; I assume this is a good thing to do? It's missing the point of Go implicit interfaces IMHO. It's going back to Java's class Foo implements Bar {} 
\+1 If you want to test for that, write a test like @[sh41](https://www.reddit.com/user/sh41) says
Wow, this is cool. I'm glad that even after a decade of Ruby programming I can find empty spaces in the knowledge. Thanks a lot! If you don't mind, I'll add this note into the article.
I'm also in favor of splitting methods into multiple files if it makes sense for navigating through your code. Just be sure to name your files something that's easy to understand, perhaps with a prefix of sorts. For example if my API's "handlers.go" would get too bloated, I split them into "handlers_users.go" and "handlers_companies.go" for example, if I were to support those 2 data types in my API.
Question... Why aren't you using atom? It will change your life
Or just use the generic "Code Outline" extension which will work for other languages as well.
Worked for me on Linux, fwiw.
I literally clapped at this post and my girlfriend is looking at me weird.
It's far easier to keep track of them when they're nearby once you've got a few hundred of them. And once you've used a code generator that searches for interface implementations to decide what to generate, you'll get a bit sick of the consequences of forgetting. Pragmatism &gt; dogma, which is really the point of Go.
Not OP but anyway... Atom is slow and clunky. VS Code is IMO simply a better tool.
sorry, answer is "it depends" lots of people will leverage sql to do their data manipulation after import we coded our own kafka consumer gooang project which leverages insertion techniques as seen in pgfutter, and we do some 'light' data manipulation in our code, before insertion. (putting elements into an array, changing one number to another)
&gt; It's missing the point of Go implicit interfaces IMHO. Although the [core team themselves](https://github.com/upspin/upspin/blob/487594a6a8b8bd6de4236d5f59c8ecd840f7379c/store/server/server.go#L32) do it. &gt; It's going back to Java's Is that a bad thing when you know you want to explicitly conform to an interface? The trouble with implements is when you don't already know you want to conform to an interface, which hasn't been taken away in Go.
IIUC, the OP meant a DLL containing a .NET assembly. While files containing both kinds of such DLLs have the common filename extension and contain a PE header, their contents and approach to call into it differ drastically‚Äî.NET assemblies require a working CLR runtime to be of any use. 
I found someone who had done it in java : http://blog.chapagain.com.np/display-google-map-with-marker-using-latitude-longitude-coordinates/
How well does this handle multiple loggers writing to stdout? I ask because I don't see a way to handle `logger.New(difLogLevel)`, which is something we enjoy using to pass through a new more verbose logger on specific requests. Would that be possible with this logger?
go-outline works on per file basis. so it will only output outline for given file, and not whole project.
That line _is_ the test. 
Right, but it's weird (hence this post) and in the production code. Whereas a test documents the intent clearer and doesn't pollute production code
How would one send a http request in Go? https://golang.org/pkg/net/http/
This talk is so cool!
It's not weird, it's idiomatic. Writing an entire test function to assert that a type implements an interface ridiculous.
im using golang
&gt; I'm not sure who gets to decide what's idiomatic or not. No one decides. It's idiomatic because everyone does it this way.
Are you going to add omemo support? I'm curious bc I'm working on an Omemo client and wanted to see how someone else implemented it. 
http://www.catb.org/esr/faqs/smart-questions.html
Meh still use logrus for all its plugins. Though if this is modular and can do the same faster, I‚Äôll definitely look to switch! 
Android go has go code. https://github.com/xlab/android-go https://www.google.com/amp/s/www.androidauthority.com/android-go-773037/amp/ But you are asking two different things. Backend socially means on a server. Android can connect to a server but usually it's development is on the phone. You can simply make a web page and view it on the phone. You can use Android libraries and connect to a backend. You hopefully soon can drop Android libraries into a web pages wasm wrapping and get almost native Android speed, explained here by Google. https://youtu.be/6v4E6oksar0 You can use native script that interacts with a go backend. Then they have go development on mobile. https://github.com/golang/go/wiki/Mobile Depends what you mean? 
Wouldn‚Äôt the compiler throw an error if a struct doesn‚Äôt implement an interface regardless. Is there a point to writing such a test in production code? 
Well after some discussion on the gopher slack i have come around to the idea a bit :\)
So currently I could use Go and get a nice native looking app on both iOS and Android?
Step 1: Do the simplest thing, which would probably be sync.Map. Step 2: measure. If you've achieved your goals there is no step 3. Step 3: act on your measurements. If muted contention is less important than something else, go fix that instead.
So I could take my HTML5 Canvas knowledge and write desktop displays with this or is this just a abstraction that spits out Javascript?
Yeah, that is my actual code, I'm not assigning any value to resp earlier on. fmt.Printf prints this: { } 
What do you mean by backend? you can basically use Go the same way you use C or C++ on Android and iOS... 
what exactly are you doing when you do this read+modify+write step? can you just implement that in a single place and put a channel in wront of it, and then just send update requests to this channel?
Maybe [https://github.com/microo8/gowebview](https://github.com/microo8/gowebview)
Oh, I see this struct defines a GoString, which goes to some generic Prettify function in the AWS. The [Prettify function](https://github.com/aws/aws-sdk-go/blob/master/aws/awsutil/prettify.go) appears to treat structs where all the values are the zero value that way. It starts by trying to traverse the pointers with [reflect.Value's Elem method](https://golang.org/pkg/reflect/#Value.Elem), which will return the zero value of a struct for a nil pointer to the struct, so that function writes the { and the } and nothing in between. So what is getting printed is indeed an empty struct. So a nil pointer of type *PutRecordBatchOutput will print as `{ }` (minus whitespace), but should still be == nil. If this still does not resolve the mystery to your satisfaction, and I'm not sure it does or should, the next step is to get violent with unsafe and reflect and start dumping out actual memory.
From the docs, it looks like PutRecordBatchOutput's FailedPutCount is itself a pointer: type PutRecordBatchOutput struct { FailedPutCount *int64 RequestResponses []*PutRecordBatchResponseEntry } So if you're getting back a non-nil PutRecordBatchOutput, it looks like its FailedPutCount is nil, and dereferencing that will panic. You'll need to check if `resp.FailedPutCount != nil` first.
Go is more like a server side language. It's used to create websites/web apps. If you want to jump into mobile development then here are a few multi platform "frameworks": * Ionic - it's a Cordova based frameworks that create a native look but not truly native. (Uses angular and typescript) * Nativescript - native based framework which uses JS or Typescript (Angular) * Xaramin Forms - truly native apps written in C# * Flutter - written in dart and runs on the unreleased Google OS. When writing the backend, you will be better off creating a RESTful API. If you already know PHP then you will be better off learning Laravel, if your up for a challenge then Go. Things that you need to be weary of is learning a new language efficiently is hard work and takes many hours. If your used to a dynamically typed language you might struggle with a strictly typed language like Go and C#; it's a long road ahead but try and get the programming fundamentals nailed at least then you will learn the design patterns of any language because each one has its on way of dealing with a problem. 
I did a talk about this at FOSDEM last year, here's the [video](https://www.youtube.com/watch?v=OaSkOjew1D4), and here the [slides of the talk](https://talks.madriguera.me/2017/fosdem2017.slide#1) and some useful repositories [one](https://github.com/conejoninja/MyGoApplication) and [two](https://github.com/conejoninja/gobindings) . There have been some changes in gomobile, so maybe something is a little outdated, but it should be easy to adapt. I talk mostly about Android, but it should be similar with iOS (I do not have an iOS device). (and here the [app](https://play.google.com/store/apps/details?id=me.madriguera.pma) I talk about in the talk released on the play store, source code is also available) In short, you could write you app with "full" native or use react native and bind it to your go code, or write everything in go (the interface will be in openGL). Accessing some features (usb, camera, storage,...) may be a little complicated, as you are required to ask for permission to perform some actions (in java) and pass the data to go.
I think you need a Walker to be an interface You could make MammalWalker implement the interface for Cat and Dog if you don't want to repeat yourself. Then do not include Walker in robot, and have robot implement that interface directly, and differently, or make a robotwalker that you embed, which implements it. Of course you might also just consider repeating yourself a bit to avoid the complexity of all of that. 
Thanks mate that works nicely, I think you might be right about just repeating myself though especially if the method is simple
This is brilliant. I'm bookmarking this project. Thanks!
There's also the option of using channels to serialize access.
I had close to this problem. I loaded and stored, in-memory, the entire config from my database as a single Go struct, allowing all my goroutines to use it freely. In my case, only 1 goroutine was writing. It would create an entirely new struct, initialize it complete, then use an atomic store to swap it out. All other goroutines would use an atomic load to get it when needed. They could even keep that reference for a while, until they were done with their job. The GC would clean up the old map eventually. The trick with high-reader low-writer is to be fairly optimistic. You could have many writers, too - they would need to load the map, create a new map, copy every value over to the new map, make their changes, and Compare-and-Swap the pointer. If some other goroutine changed it before you finished your work just repeat the process. You can have dozens of goroutines trying to write to the map, and every goroutine that reads it will get a reference to it at some point.
https://golang.org/pkg/strconv/#ParseFloat
Considering that libraries can use unsafe, include assembler code and use cgo... I don't really see what you can achieve with your proposal.
Ok , that really help me First when i searched i found all time the inverse. Sorry to waste your time because of my bad research on google. Thank a lot
Compile-type constraints can make any of those fail at compile-time without the reference to GOOS. It's barely a real type - it's just a compile-type requirement that needs to be tossed into a few functions, just to validate you have permission. It really encompasses permissions, more so than actual pointers. If you had a GOOS reference, cgo would be allowed by default, unsafe would be allowed by default, but you could also create a subset GOOS that only has permission to use unsafe, or cgo, or assembler code, etc.
How many CPU cores does your environment have? That's what govern the contention instead of the number of goroutines.
I've periodically wished for something like this. Not for security reasons, but for code clarity and explicitness of inputs. It would be a very different language from what Go is now. I don't think the benefits outweigh the cost, though.
My latter suggestion would break very little code, comparatively. Decorating imports would be a quick, and entirely automated transition, I think. Though technically it does violate the compatibility rules.
Yes, that should be possible... But then why not just use react native for the entire app, unless by "the rest of the application" you mean a server side go application.
Oh right. If all their work can only be done in the critical region. I incorrectly assumed that's just one tiny portion of the work load.
Zoinks! Yep, thanks.
Excellent, thanks!
This is in conflict with deadline and time-efficiency requirements. If the functionality is small and simple, it's unlikely I'd need a library. The functionality needed is often large and complicated, which means vetting every line would take even longer. I can't even just look for files that import certain packages, as any potentially nefarious code can be in another file entirely.
What you're describing is [capabilities based security](https://en.wikipedia.org/wiki/Capability-based_security?wprov=sfla1), and, yes, it's very desirable. Some operating systems are built around this; I agree it'd be spectacular to be able to enable this in go code. 
you can meet deadlines and be time-efficient, or you can be secure and understand the code you are writing.
Thanks for the educational resource! I think I'm paranoid because I also use node/npm, and it's a minefield out there. Even Python just got bit by a malicious pip package stealing credentials. It's insane to me that a package can be doing anything (and with Go's default import method of grabbing latest commit) and there's almost no way of statically or automatically checking. I'm sure I'm in the minority - I also don't think Go should have globals (because it complicates package re-use when there is package-level state), which no one else agrees with.
For people who want to try SDL2 out, episode 6 of my games with go series shows how to get it set up and started: https://www.youtube.com/watch?v=OXSMx45kayw 
There are a lot of options for polymorphism with structural interfaces: https://play.golang.org/p/Iq5jjY3iwmQ
Static builds, am I dreaming?!
I've always been shocked how many people don't do this. I thought that was the point behind vendoring libraries...?
@loga1nx HackerRank supports go \- how about using that? [https://pasteboard.co/HkkzXtK.png](https://pasteboard.co/HkkzXtK.png)
codewars.com exercism.io
Presumably these files contain build tags and only one of them is actually included in the build.
&gt; There is also sync.Map. Haven't used it at all and I'm not quite sure how to use it for read-&gt;modify-&gt;write back case. It doesn't look to be made for that. It doesn't have an interface for key-level locking, or compare-and-swap, or anything else that would make it possible for multiple goroutines to share access to a single key. As its docs imply, it's only really great for the situation where each key in the map is only written by a *single* goroutine. If you follow that pattern, then `sync.Map` will let you do it without having to contend on the whole map, but it doesn't do anything for you if your access pattern is basically random. But... thinking about it, I don't know anything about your use case, but is it possible for you to divvy the work up so that all accesses (or at least all modifications) to a given key *can* be guaranteed to come from the same goroutine? Because if you can do that you have a nice solution available.
I guess that the files you are referring to are these ones. [command_win.go](https://github.com/spf13/cobra/blob/master/command_win.go) // +build windows package cobra ... var preExecHookFn = preExecHook ... [notwin.go](https://github.com/spf13/cobra/blob/master/command_notwin.go) // +build !windows package cobra var preExecHookFn func(*Command) The first-line comment in each of the files ensures that only one of them will be compiled for a build. They are special comments known as build tags. Dave Cheney's article [How to use conditional compilation with the go build tool](https://dave.cheney.net/2013/10/12/how-to-use-conditional-compilation-with-the-go-build-tool) explains them. In the case of these two files, the one that is selected to be compiled will be determined by whether the build target is Windows or not.
Excellent work, keeping an eye on this project.
Whoever frequently misses their deadlines is soon an ex-employee or a freelancer without clients. And reading 3rd-party code once or twice cannot reveal all the security holes contained in there. It could easily take days of analyzing and testing to get confident enough about the trustworthiness of that code. (Plus, you would have to have decent security knowledge and skills under your belt to run reliable code audits.) (But yes, reading the third-party code you are going to use is still a good idea.) Capability based security seems a quite pragmatic approach of bringing those two diametral goals - efficient coding vs secure coding - a bit closer together.
&gt; and with Go's default import method of grabbing latest commit Well it's not "on import" but on manual `go get` package-install action.. and yeah if your project isn't a throwaway, scrutinizing and reviewing your 3rd-party stuff (and their updates) is part of your mature dev mission, regardless of language/ecosystem. I do it already merely out of paranoia that other pkg devs might be too sloppy or performance-insensitive to allow that dep into the codebase, but wearing security glasses as well in the process is entirely doable too. 
I pushed new version that should hopefully solve this issue.
I pushed new version that should hopefully solve this issue.
That's actually pretty interesting extension for its use case :D I remember always breaking google-fu and searching for online hex converters, when I had to deal with hex strings :) Good job.
I pushed few updates recently, hopefully that solved this issue. Also tried to test latest version on Windows/Debian/Mac and it seems to work OK. From what I read, sometimes VSCode just doesn't want to install extensions, from what I gather, mostly due to network issues.
`FailedPutCount` is a nil-pointer, that you are dereferencing. `resp` itself is valid. Change your code to if (err != nil) || (resp.FailedPutCount != nil &amp;&amp; *res.FailedPutCount &gt; 0) { //do stuff } and/or complain to the author of that package that they are making this a pointer (it very likely shouldn't be one) and not initializing it.
Thank you for info I'll try that.
Thanks I'll look into them
I thought i should do practice first and then go for projects. Any ideas about newbies project.
To build stuff i need to be sure that i can do that. For this i was asking for practice platform.
I can confirm that `0.1.12` is working fine.
Spoken like a student or a security-engineer who thinks it's acceptable to require a sudo for a printer. ;) I'm joking of course, but the point stands: most code isn't secure because business considerations make time scarce. There's no wishing that away.
I like how elaborate and detailed your answer is. Actually, in use case(s) I meant the read/write ratio is something like 50/50, I think (or close to that). So, it's not really an option to recreate the whole map and then discard it in case it were modified in between. Too many allocations to my taste. Here, I wrote [a bit of code](https://play.golang.org/p/WEEY_jJGANO) to illustrate the variation of this problem I faced (you can ignore the part with readers, it's there just for the output).
Yes, forgot the elephant in the room. If you meant something like: "Have goroutines write to the channel and then some other goroutine will read values from the channel and modify the map", ‚Äî then sure, it can be solved this way, but this approach were quite slow (or slower) in my use case (which looks something like [this](https://play.golang.org/p/WEEY_jJGANO)).
FWIW, there is [this project](https://github.com/HogLang/hog) which purports to fork Go to make this possible. I am not optimistic about their success, though. But if you really want this, you can invest your energy in this fork.
Yes, I chose [sharding](https://github.com/codesenberg/concurrent/blob/master/generic/histogram/histogram.go#L19-L27) at the time. Well, in my actual use case keys themselves were data and there wasn't such thing as `maxKey`, but nice attempt anyway.
Do really small projects. I'm not sure what you're interested in, but here are a few ideas: * CLI tool for counting source code lines (like cloc or tokei); bonus points for comments and blank lines in the summary * Simple time tracker (start &amp; stop a task, compute summary) like time warrior * IRC/Slack/Riot bot * To-do list The possibilities are endless. Either build something simple that you want, or rebuild something simple that you use periodically. Keep it so simple that you can see results in a day and finish your initial set of features in a week or so.
Oh yes, C++ is much better when it comes to custom allocators or anything related to memory management for that matter. It's just memory management is a very small part of my codebase, overall I can move much faster with go than with C++. As for the STW - i didn't. I mean the ultimate goal is to just run everything with GOGC=off, but for now I just let it run. Knowing the exact timings for it helps.
The AWS SDK is awful about using pointers where it should not. It‚Äôs just a nightmare of useless pointers. 
No the point of vendoring is to pin the version of a lib downloaded. It has nothing to do with auditing 3rd party code. I don't believe one seconde people read every line of every package they import from the internet.
Yeah that is pretty wild! 
What is your question? Are you looking for flag icons?
I'd re-iterate jeffrallen's point, as I'm not sure I've seen you share that yet. One other thing that comes to mind is that if _modification_ is the most common case, the easiest thing to do is a sync'ed map where the values are pointers into a struct that have a mutex. Then to modify you take a lock on the final value, as granular as it can get, and you only need to lock the map with a read/writer lock at the top. There are [packages for RW mutexes](https://godoc.org/github.com/jonhoo/drwmutex) that scale better than the one in the core, if you need it. This can be combined with a sharding approach too pretty trivially. After this, you're going to start getting into crazytown, where you allocate an expanse of the value as a slice and start doing your own map data structure. At that point you can pretty much construct any characteristics you want, within reason. But it's a hard journey, full of bugs.
I've been doing this for a while now. Qml and go, with as minimal java bridges as I can afford. Framework and instructions here. Also means same code base for all my apps across all platforms. https://github.com/amlwwalker/got-qt
I always write a blogging platform backend as practice of any new language. Blogs -&gt; Posts -&gt; Comments And a shared "Author" across them all. Gives good experience in design using DDD or CQRS (or not!). I stumbled a lot and wrote a lot of wasted code in GoLang using strict DDD and CQRS until I just learned to let it go and do simple constucts. Boy has my life changed ever since!
I'm pretty new to go myself but have been studying on the side working through the Go book. Mainly fluent in Python. Also doing blockchain dev work. If you wanted to team up on a crypto go project id be down. I'm on discord 
Looks good. Will check this out 
Don't do this. You're rubbing against the Go idiom of explicit is better than implicit. You're abstracting your types and then forcing readers to go looking to see what your types are.
Please message me on discord: maxblock#1713
Yeah I was constantly googling conversions too... until I had to do it one to many times!
In addition to the previous comments, best practices for Go package design recommend avoiding the kind of repetition in names that you are avoiding here. That suggests that it would be difficult to find a shorter name that carries the same information as `os.File` or even `jquery.Event` would for example.
If I were you, I'd look up examples. Cause every appraoch has drawbacks. If you abstract then no one wants to touch it. If you write everything out, then 3 years from now you'll be using ctr+f a ton. It's a matter of knowing what you want this to look like later. That is determined by knowing fundamentals and the data. But also, keeping in mind that others may not. I think this article is a good start. https://syslog.ravelin.com/what-is-an-interface-ee67b3cc9e97 And watch how these guys write readable code. https://github.com/GoesToEleven?tab=repositories And https://www.goinggo.net There's a lot in naming. You really gotta understand your data and how your code will grow. Think 7 years from now. Will anyone after all those updates want to even touch your code? Even if you never seen a big file of code in go or other languages you have to think about all these sides. I am starting to pick apart go data and reading packages because these are your future. 
Hey guys, just changed Gojay's pooling implementation and as a result it made Onelog ultra fast (3 times faster). It is now by far the fastest JSON logger with the least allocs. On top of that I just added a chaining syntax a la zerolog. Feedbacks welcome :)
Yes. In idiomatic Go code you should not have to check whether a pointer is nil.
I compiled all static libraries there, and contributed that `-tags static` part, if you have any problems with static building just file a new issue and I will try to help. 
Go is already pretty fast, and if your goal is to write something to hit APIs like Binance and execute trades, you should be fine without too much optimization. I think most bots are written in Python, so you should have a leg up already. 
And the gorilla/sockets package is a great socket client. You can stick to native net http for your router for speed. It most likely does what you need, it doesn't have native url query parsing but you can write that in a single line. 
I have used to to redefine long and hard to type basic types, mainly when converting JSON to unstructured bags: type jmap = map[string]interface{} type jarray = []interface{} 
Please lose the splash screen and take us straight to the repos. That's tacky and annoying. I'm not sure what I'm supposed to make of these examples. There isn't any documentation explaining what they're supposed to accomplish, nor are the examples written very clearly. One place that's crying for help: the flags passed in to each executable. The help strings don't give me any help! Am I supposed to type a file name, absolute path or relative path, a number, is it seconds or milliseconds? Completely useless! I'd spend some time cleaning up the code, add a docstring to each function header, run everything through `goimports`, at the bare minimum, before sharing. This looks like it was just thrown together with no thought for your audience.
Just a small thing. Your release notes say: &gt; `go get -v -tags static https://github.com/veandco/go-sdl2/sdl` It is however an URL not a go package in the example. You probably just copied the URL and copypasta did that automatically.
Congratulations mate! 
I literally had your github open from the other thread and then saw this. Cool stuff and kudos. I'm looking for a logger and will be trying it out.
I love seeing the constant race to have the fastest logger. This is cool though, I haven't used sync.Pool before - didn't know it was so fast! I've been using buffered channels for similar use cases. Just a couple questions about it if you don't mind: * How do you deal with the fact that getting an item from a pool is in arbitrary order? Does onelog not maintain ordering of output? * How does it know when new items are added to the pool? As in, what does it do when there's nothing to log?
Thanks I'll look into themüòÄ
Thanks, I fixed that in release notes. Detailed instructions will be added to README (you need to initialize git submodule for go-sdl2-libs repo before `-tags static`) I have commit access to repo since recently there. I just added static flags and libraries, but I do like and care about go-sdl2 package, and I will try to maintain it in future, to update libs on every new release etc.
Nice idea but i am not the backend guy
Related to the topic an excellent video on GO performance and an explanation why Sync.pool is that fast: https://www.youtube.com/watch?v=DJ4d_PZ6Gns&amp;feature=youtu.be&amp;t=22m47s
Make it super simple. You don't want it to be so big that you get discouraged, but make it substantial enough that it's interesting. Good luck! Go is a fairly simple language, but it does have its own set of idioms and I think you'll learn those best by building something real instead of practice problems.
Are you comparing using zap's benchmarks, or zerolog's benchmarks? Like I pointed out in the last thread you opened on onelog, zap's benchmarks refuse to update to allow zerolog to have its performance: https://github.com/uber-go/zap/pull/484
Congrats on pumping out stuff! I notice that it depends on your `gojay` which received [a great deal of constructive criticism](https://www.reddit.com/r/golang/comments/8eznr8/very_fast_json_encoderdecoder_for_go_currently/) not 2 weeks ago. So much so that I deferred into some future point putting it in my "mature libs" category. Have these all been addressed already? If not, do keep us all updated when it gets there, my team for one will then be very interested in giving both a deeper look! Rock on =)
Yes, but the root issue is not knowing which library calls are going to contain IO, so having to send every single lib call over RPC would hurt.
Hello, I would like to share with you a small application I made to make my life easier. Goffli allows you to write FFmpeg conversion scripts using the Lua language and then to store/share it on GitHub Gist. It has a user friendly CLI UI, prompts, progress bars, debug mode and allows you to safely allocate temporary files. It is for the community. If you would like to contribute a snippet please do and please share any feedback you have on the application. 
I have also done that, but I'm not sure if it's bad and I should feel bad. Another trick which I have not done yet is \`type none = struct{}; type set = map\[T\]none\`. I mostly just use map\[T\]bool instead.
Stdout logging is not really what we optimize for; it's more important to be able to trigger listeners for any event. Another take on logging as an event bus: https://github.com/blend/go-sdk/tree/master/logger
Good idea to use tags and git submodules, they aren't used much unfortunately but are very powerful.
The key here is to use ${SRCDIR} in CFLAGS and LDFLAGS. Not sure since when is that available but I only recently discovered that. go-sdl2-libs repo is 30M in size, but considering that many arches are included I guess it is not that big, but still, it should not be by default in main repo. I have several `cgo` wrappers/libraries where I prefer to include .c files in build, so you can just `go get` the package. SDL is the beast, didn't tried but I don't think it is easy to package it together with Go lib like that. Anyway, I think that if more libraries that use cgo provide some easy way to build, or are just go getable with .c files included, the complaints "this is crap, not native Go" will stop. The fact is, there will always be parts of systems you must access via C, e.g. GL.
I use it and I like it. It's barely noticeable.
This! If you could run your benchmarks with the same methodology as zap/zerolog, and match the output, it would sure make the comparison easier. Very excited about this. I have a service that runs in excess of 20k simultaneous goroutines and produces a lot of debug logging, so every alloc'ed byte and nanosecond counts.
In this example I‚Äôm relying on Terraform for the deploy step, and to deploy new versions, incrementing the version variable will suffice. But outside this example, I‚Äôd deploy w/o terraform and use Lambda‚Äôs built in version publishing. Re: testing, easy enough to deploy a dev environment with Terraform!