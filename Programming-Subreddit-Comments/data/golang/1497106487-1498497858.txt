U WANT SUM DOT C? As always, great video :)
Well, here we are: [arthurwhite/go-http-routing-benchmark](https://github.com/arthurwhite/go-http-routing-benchmark). In this bench suite, [julienschmidt/httprouter](https://github.com/julienschmidt/httprouter) keeps the crown by far. I also made my own [little bench](https://github.com/arthurwhite/go-http-bench): BenchmarkParamsChi-8 100000 14591 ns/op 25283 B/op 53 allocs/op BenchmarkParamsFastRoute-8 100000 13146 ns/op 23801 B/op 43 allocs/op BenchmarkParamsGowwwRouter-8 100000 13642 ns/op 26282 B/op 64 allocs/op BenchmarkParamsHTTPRouter-8 100000 13501 ns/op 23890 B/op 48 allocs/op BenchmarkStaticChi-8 50000 27661 ns/op 50507 B/op 103 allocs/op BenchmarkStaticFastRoute-8 100000 24039 ns/op 47438 B/op 83 allocs/op BenchmarkStaticGowwwRouter-8 100000 21408 ns/op 47299 B/op 80 allocs/op BenchmarkStaticHTTPRouter-8 50000 24705 ns/op 47452 B/op 84 allocs/op For static routes, and when I also compare code complexity, I'm pretty happy with the result. For parameterized routes, there is room for improvement, for sure… But I suspect the standard [context](https://golang.org/pkg/context/#Context) playing hard against that. :/ In any case, I will always prefer a short, clean and idiomatic code. Let's see how far it goes…
Bad advice, I've been dong this 25 years and go is the perfect language to learn as a first language.
Here is another great video that kinda explains the concepts of go and regular programming. Honestly it's kinda dry but as you can see, many don't watch and read these things and so they get their information mixed up. https://youtu.be/ABGF_ryhFzM A great article that explains maybe why go more is this way. https://commandcenter.blogspot.com/2012/06/less-is-exponentially-more.html?m=1 Go is very quickly getting talked about in the world as you can see. But that bump took about 7 years to come to be. https://www.tiobe.com/tiobe-index Really it comes down to a couple things from what I see. - Readability = maintanability - Uncoupled from traditional OOP -Less to memorize - Gives you understanding of reusable interface types. Don't couple your code with inheritance if possible but through what the structures have in common as far as what they "do". This way your code can be like water. - Gives you kinda access to low level procedures like pointers, core go code, and fundamental understanding of types. - Errors are values. Basically instead of try catches you would store the error inside a variable. Which is nice for adaption. - The advocates are really really helpful and real people. Look them up on Twitter! - If you see a big code base they end up looking nice. Look at Rob Pike's code. You can actually understand the best programmers code! - Im burned out personally from the million php core methods, js libraries, and Python frameworks. Go doesn't concrete itself on these giant monoliths that have no code visibility. - For fun it installs on almost any infrustructure and actually tells you what's wrong. It let's you drill down to it's core code and let's you reuse it's guts. 
In general I agree. I am curious, since things like `sql.DB` or `http.Client` should be reused, they need to be stored as a global somewhere, even if you inject them. Where would you choose to store those variables and at what point do you inject them?
I don't code in JavaScript but does it have generics? And what do you mean by "new generics"? And why do you consider generics bad? And why do you think that people should memorize a language instead of learning it through exercise? 
I miss, from VSCode Go, the easy right-click -&gt; Peek Definition/Implementation/Find Definition functionality. While find definition exists in Gogland, I have found that I much appreciate the ability not to context switch from what I am working on and have an in-line sort of "i-frame" of the definition/implementation/etc to look at instead of shifting my entire view over, or using a side-by-side view which can be cumbersome on smaller screens. I think the Gogland version of finding definition/implementation/etc unintuitive to invoke. It should be just as easy to work with a mouse-driven workflow as it is a keyboard shortcut ninja one. Features being hidden behind keyboard gymnastics is nonsensical when faced with the rather clusterfuck UI Gogland offers. Why offer such a huge array of things to be mouse-driven but then not include that oddly specific thing from a right-click context menu. External linter support, gometalinter, go vet, etc. I get an array of green underline hints in VSCode Go to help me keep to style guidelines and conventions, to remind me to document exported things, dead code checks, etc. Sure, you can use the "Go Tools" menu, but in VSCode Go this just happens automatically and is integrated into the workflow without having to break context and go run a tool. It runs them for you when you save the file and takes the output of those tools and highlights the relevant sections of code. Generating tests. I can click on a function and have VSCode Go generate a test file with a ton of boiler plate worked out for me, with just a spot for me to start filling in test cases. This is quite the time saver and helps to soften the roughness of writing tests so that I am more inclined to do it. Automatic json struct tag generation. Writing struct tags is extremely tedious. I can just right click a struct field in VSCode Go and click "add struct tags", it swoops in and magically does it all for me with generally acceptable naming conventions. Simplistic UI. VSCode Go has just the right amount of simplicity without being too simple (the left-hand tabs that offer a contextual set of interactions keeps them intuitively organized and out of the way). Gogland is just so packed with menus and things that aren't very well organized for someone new to the IDE to ever have a chance in hell of finding something specific intuitively. It's a high learning curve. I feel it was much easier to take up and become proficient in using the features available to me with VSCode. 
Sorry for the slang. That was a mistake. This example should be what I should of sent instead. https://youtu.be/sBzRwzY7G-k Which lead to this. https://hackernoon.com/how-it-feels-to-learn-javascript-in-2016-d3a717dd577f Really, I almost had a meltdown lol. 
It's either should **HAVE** or should**'VE**, but never should **OF**. See [Grammar Errors](http://www.grammarerrors.com/grammar/could-of-would-of-should-of/) for more information.
SECTION | CONTENT :--|:-- Title | 2016/2017 MUST-KNOW WEB DEVELOPMENT TECH - Watch this if you want to be a web developer Description | What should you learn in 2016/2017? This video gives you a complete roadmap! View the mindmap: https://coggle.it/diagram/Vz9LvW8byvN0I38x The Docker Course!: shop.oreilly.com/product/0636920051343.do Length | 0:22:52 **** ^(I am a bot, this is an auto-generated reply | )^[Info](https://www.reddit.com/u/video_descriptionbot) ^| ^[Feedback](https://www.reddit.com/message/compose/?to=video_descriptionbot&amp;subject=Feedback) ^| ^(Reply STOP to opt out permanently)
Videos in this thread: [Watch Playlist &amp;#9654;](http://subtletv.com/_r6gev9p?feature=playlist) VIDEO|COMMENT -|- [Go Talk &amp; Ask Me Anything With William Kennedy](http://www.youtube.com/watch?v=7YcLIbG1ekM)|[+3](https://www.reddit.com/r/golang/comments/6gev9p/_/dipr0gf?context=10#dipr0gf) - I would study error handling in great detail. Cause every language you need to check your errors like as if you wouldnt even trust Jesus with your inputs. Also, study the heck out of interfaces and multiple types cause that's where go shines. Go i... [Go-Miami: Object Oriented Programming in Go](http://www.youtube.com/watch?v=ABGF_ryhFzM)|[+2](https://www.reddit.com/r/golang/comments/6gev9p/_/dipynvi?context=10#dipynvi) - Here is another great video that kinda explains the concepts of go and regular programming. Honestly it's kinda dry but as you can see, many don't watch and read these things and so they get their information mixed up. A great article that explain... [2016/2017 MUST-KNOW WEB DEVELOPMENT TECH - Watch this if you want to be a web developer](http://www.youtube.com/watch?v=sBzRwzY7G-k)|[+1](https://www.reddit.com/r/golang/comments/6gev9p/_/diq6w6e?context=10#diq6w6e) - Sorry for the slang. That was a mistake. This example should be what I should of sent instead. Which lead to this. Really, I almost had a meltdown lol. I'm a bot working hard to help Redditors find related videos to watch. I'll keep this updated as long as I can. *** [Play All](http://subtletv.com/_r6gev9p?feature=playlist&amp;ftrlnk=1) | [Info](https://np.reddit.com/r/SubtleTV/wiki/mentioned_videos) | Get me on [Chrome](https://chrome.google.com/webstore/detail/mentioned-videos-for-redd/fiimkmdalmgffhibfdjnhljpnigcmohf) / [Firefox](https://addons.mozilla.org/en-US/firefox/addon/mentioned-videos-for-reddit)
You didn't really answered my questions.
I did, it's actually slower: $ time cat /var/log/kern.log.1 | oi -p patterns.txt real 0m0.049s user 0m0.039s sys 0m0.046s $ time cat /var/log/kern.log.1 | fgrep -f patterns.txt real 0m0.014s user 0m0.009s sys 0m0.014s
I also don't get the same results: $ cat auth.log | ./oi/oi -p patterns.txt | wc -l 1 $ cat auth.log | fgrep -f patterns.txt | wc -l 346 grep (GNU grep) 2.27 oi: ded219a434c6cf6aa67507ecb85e1e7c663a15ab 
This is lovely... I used to joke that I should make a browser plugin that blocks MSDN from search results so that I can find good documentation faster, but Microsoft seems to be hiring very sharp new coders the last few years and the results are visible both in the products and the docs.
The documentation says that is by design.
Sure, but comparing the timings of apples and bananas is wrong. Note: from the design, you could compare timings of fgrep --max-count 1 and the other tool as long as you only have 1 pattern.
https://docs.google.com/document/d/1vrAy9gMpMoS3uaVphB32uVXX4pi-HnNjkMEgyAHX4N4/mobilebasic
You may want to check out http://jmoiron.github.io/sqlx/
Just For Func is a great series of simple coding screencasts by Francesc Campoy (dev at google) - it includes code reviews and short projects which definitely delve into the go-specific features and reasoning for certain patterns, definitely recommend for once you've gone over the basics in the Tour or Go and Go By Example!
This so much. I am currently in university and some guys i know are struggling so hard with c and java because all the funky hacks that worked in js now do not work anymore and they have to think in totally different ways now. Also a language where something like jsfuck is possible cannot be a good language for a beginner as they will most likley pick up some bad habits on the way. 
I agree, I was just pointing out *why* the results weren't the same.
 &gt; This one has been discussed a bit but the general benefit of any JetBrains IDE is that you don't have to deal with external linters since inspections will run as you type, without having to save the files and so on. If you / anyone else finds anything missing that's crucial for their workflow, please report it at: https://youtrack.jetbrains.com/issues/Go Meanwhile, you can still run external tools via: Settings | Tools | &gt; External Tools and while this documentation https://www.jetbrains.com/help/idea/2017.1/external-tools.html is for IDEA, the same applies to Gogland as well. If you prefer to run these on save, there's a plugin called File Watchers which enables you to have this functionality. I was aware of this functionality, but it's not the same. The way the external linters/tools integrate into VSCode Go is similar to the inspections that Gogland has. I have no idea how I'd go about making any use of them via file watcher, as they are designed with the intent to be integrated such as with vim-go or how VSCode Go handles them as being the "backing intelligence" for their equivalent of inspections. The inspections I find are rather surprisingly lacking in general suggestions/linting that things like, say... [Go Report card](https://goreportcard.com/) has, similarly, the much more in-depth suggestions provided by the linter suite of [gometalinter](https://github.com/alecthomas/gometalinter). Which even includes things like security mistakes (such as pointing out I was using math/rand instead of crypt/rand which popped up on me in a recent personal project, despite it not being a concern for the application, I wasn't aware they'd added a linting tool with a security focus and immediately appreciated that they had). Yes, it's nice that I don't have to rely on external tools to -provide- that functionality, but having to rely on Gogland's inspections to be comprehensive with no real way to extend them in an agnostic way is not what I would call user-friendly, and would leave me with a taste of vendor lock-in.
You can also just install GNU Grep with `brew install grep` (and `--with-default-names` to avoid having to write `ggrep`). The problem with old BSD grep implementations isn't just Unicode, it's that their regular expression matching algorithm is [inefficient](http://blog.erratasec.com/2015/12/some-notes-on-fast-grep.html). Some good notes by Russ Cox [here](https://swtch.com/~rsc/regexp/regexp1.html).
sqlx uses the lowercase field name. `id` in sql maps to `Person{}.ID`. So either do: SELECT u.person_id as id Or: type Person { ID int `db:"person_id"` } That's for filling the struct. For using it as an argument: db.NamedQuery(`SELECT ...... AND u.id = :id`, User{ID: 1234}) The docs kpurdon mentions explain this in more detail.
I'm currently pursuing my second degree but started programming since I was about 12. I see all of these fellow students using Javascript because they are too damn lazy to struggle through the seemingly hard part. They have no idea how to operate in a team or with large project and then you get the community Javascript has: libraries left and right and people reinventing the wheel every day.
No init? I usually don't use it, but had to once, to solve a executable size and high memory usage bug with Go.
And to this specific point: &gt; I believe the ok = true could be placed anywhere in the top level function Sure, in particular, it can be placed immediately before the return. In particular, that would be equivalent with just using `return true`, except that the latter is more explicit. And if you do that (place it after the `ch &lt;- v`, that is), it turns out that the `ok = false` is actually redundant. And suddenly, you got my `trySend` ;) &gt; but that looks like the cleanest and most explicit way. I disagree, but as I said, doesn't matter, really.
you two seem to have a tight bond. Might be the reason you let /u/shovelpost attack others users without consequences. Lets use this thread to review the attacks made by /u/shovelpost that weren't reprimanded, and the posts made by others that were met with the iron fists of /u/dgryski and his goons.
It doesn't need them because it's dynamically typed.
You'll probably have to give it some hints and manually scan into a struct.. You can write it ambigulously if you want and it will scan in order of the fields... rows, err := sqlx.Query(` SELECT u.id, u.name, p.id, p.name FROM users as u, persons as p WHERE p.id = u.person_id AND u.id = ?; `) if err != nil ..... var user Users rows.Scan(&amp;user.ID, &amp;user.Name, &amp;user.Person.ID, &amp;user.Person.Name) You could create a custom struct to hold it and use the `db:"field_name"` tags as well. 
I can understand his English just fine. With an exception of UK people I believe the rest won't have trouble either and I believe that shows as he is generally beloved for his videos/talks.
&gt; My question is: how important is optimizing single functions? Almost completely and utterly useless unless that function was a bottleneck. See [Amdahl's Law](https://en.wikipedia.org/wiki/Amdahl%27s_law). &gt; Do you optimize every function Never. &gt; or are you trying to find way to optimize your application in general? As others have pointed out, trying to optimize everything is a bad thing. Optimization often makes your code more complex and brittle to changes in the future. The only way to measure optimization is to look at the ROI. If you go from 10ms to 8ms, how much extra money are you going to make? If you can't answer that, then maybe you shouldn't bother. If you still think it's important to optimize, then the best way is to have a performance budget. "I want the user to get an answer within 100ms". Ok, so start dividing it up: I'll give 20ms for the packet to go over the Internet to my data center. Then 10ms for it to be routed to the correct server, then 20ms for the database query, then 5ms to construct the response, etc. Now measure, and if something is over it's budget, you can optimize it -- but only until it's under the budget. Spending additional time making it faster will probably take more time than shaving off a little somewhere else.
I seriously doubt this to be true. Lots of it is propaganda pushed by the thousands of zombies(googlers) forced to do the bidding of their overlords(their employer- google). I'd watch a thousand TED talks before I sat through one talk by campoy. The thing is that he gets paid to do what he does, and he doesn't do that very well at all. If google is going to pay someone to engage English speaking people then they should atleast get someone who can speak English well.
A generic is the concept of decoupling logic to the data type. Js does that implicitly because everything is an object type except primitives.
I think this is really great. Along with OP, I'm completely new to coding and the philosophy behind Golang has really caught my attention. How can I learn about the things this guy is talking about: like code coverage, best practices, and things like that especially when I don't come from a coding background? Thank you so much in advance. I'm really excited about learning this but I really want to learn it the right way.
Most people seem to be able to understand his English just fine. Sure it's not perfect but it gets the job done. I am surprised you have so much trouble. Are you from UK by any chance?
If "generic" is just a concept of separating logic from it's data type... Then js pretty much already does that by definition. Because everything except primitives are considered object types. But on Reddit if you use the wrong semantics you'll be burned at the stake.
a generic is a concept of separating logic from a data type. In javascript everything is an object type except primitives. So javascript does this implicitly.
I really do agree that importing a package for its side effects feels like a code smell and it shouldn't exist, much less on standard library, because it IS magic, and magic was the biggest reason I moved away from Ruby and RoR. But then, changing how these things are structured at this point is probably something that we can only hope for Go 2, since it is a pretty big change and would probably break a lot of packages. Just my 2 cents.
Modifying, thanks for agreeing. I though the article was going to be about a weakness in gits checksumming model that your found a way to abuse somehow!
`$ GOOS=windows GOARCH=386`
I should of double checked my code. I had commented out the email send portion out to log some things out to the console so when I built it, it was just logging and terminating super fast and never triggering a the email process shouldn't be programming at 330 AM =( thanks for the help though
I'm about to be getting into RoR, how bad is the magic there?
I'm going to pretend go isn't as popular on SO because the language is so simple, and is more popular on GitHub because people are actually using it.
All of this post reads like dogma to me. He claims &gt; Firstly, public var declarations should be eschewed. This is not a controversial conclusion But I strongly disagree with this conclusion and do not understand what the basis of the claim is, that it's uncontroversial. Public package variables have a place in the world. For example, if I want people to be able to provide a debug logger or something, I can use a global variable for that and use that for logging. Sure, if it gets modified concurrently or "magically" at runtime, that will lead to problems. But this seems like a mostly academic concern to me. It seems pretty obvious, that you shouldn't do that and IMO "don't do that, then" is a perfectly reasonably response here. And sure, I could also plumb it through every function call and add a pointer to every struct. But a package scoped variable provides a simple, convenient and clear way to achieve what I want. It's tradeoffs all the way down. I think if you just apply common sense, there are good and convenient ways to use package-level public variables; even as *variables*.
&gt; frameworks are basically generics bruh do u even computer science?
"I need a data structure. It has the following requirements: 1. It must not be expressible in go. Conclusion: I can't express this conveniently in go, which is really frustrating". Go doesn't have immutability. But immutability is not a "requirement" for a data-structure. The requirement, if anything, is that it isn't mutated and language-level immutability is *one way* to achieve that. A different way is to not mutate it. The question whether something like `const` is necessary is an age-old discussion. But it's a red herring. It is akin to rust-programmers saying go sucks because it doesn't even have sum-types or pattern matching or borrowing or language-level enforced race-freedom or… None of these belong in the "requirement" section, the requirement section is reserved for the actual semantic behavior of your program and the problem it solves and those are just tools you can (not "need") use to solve a problem in a way that you can make sense of. *Requiring* them is forgetting that programs are ultimately a tool to solve problems, not an academic study object. And go, expressly, is optimized for the "problem-solving" goal, not the "paper-writing" goal of programming.
If you can live with the message being delivered 1:M, and only one message needs to be delivered, you could use a ready channel semantic to signal to its subscribers. package main import ( "fmt" "sync" "time" ) type Message struct { ready chan struct{} val int } func NewMessage() *Message { return &amp;Message{ready: make(chan struct{})} } func (m *Message) Set(v int) { m.val = v close(m.ready) } func (m *Message) Get() int { &lt;-m.ready return m.val } func main() { var wg sync.WaitGroup oneShot := NewMessage() for i := 0; i &lt; 5; i++ { wg.Add(1) go func(i int) { fmt.Println(i, "got value", oneShot.Get()) wg.Done() }(i) } time.Sleep(time.Second) oneShot.Set(42) wg.Wait() } https://play.golang.org/p/0peNcHo2SJ If, however, you need to send multiple message or have a N:M model, you could use a [condition variable](https://en.wikipedia.org/wiki/Monitor_\(synchronization\)#Condition_variables), which you have here in the standard library: https://golang.org/pkg/sync/#Cond. Alternatively, each subscriber could have a dedicated channel that a single publisher/writer manages for you. Then you need to consider message delivery tolerances (e.g., what if the receiver is not ready, and must all receivers conceivably receive the message at about the same time)?
Because go has Garbage collection and usable, safe array data-structures, which C lacks. Lists are pretty much *universally* bad and inefficient. [But don't take my word for it](https://www.youtube.com/watch?v=YQs6IC-vgmo). C programmers like to use linked lists, because it's a data structure that is easily expressible in C and other data structures aren't, really. But it's a bad data structure.
SECTION | CONTENT :--|:-- Title | Bjarne Stroustrup: Why you should avoid Linked Lists Description | The part in Bjarne Stroustrup's keynote in GoingNative 2012 where he explains the reason that linked lists, and linked structures, are so bad for performance, even in the scenarios that programmers think that linked lists would be good. Length | 0:07:46 **** ^(I am a bot, this is an auto-generated reply | )^[Info](https://www.reddit.com/u/video_descriptionbot) ^| ^[Feedback](https://www.reddit.com/message/compose/?to=video_descriptionbot&amp;subject=Feedback) ^| ^(Reply STOP to opt out permanently)
Or with `interface{}`. Nothing wrong with that either.
Well, I'm new to both JS and Go, but I know C++ and C# and I know what their generics are. By saying "new generics of C++/C#/JS" you had just confused me to death. It's like saying "eh, mutable, imutable, same thing really, who cares about semantics?". 
Ah, apologies, I didn't realise you had implemented that method. Carry on! And thanks for your patience...
A lot of external Ruby gems add methods to the global scope, and it gets worse on RoR because RoR imports gems automatically for you without an explicit call to `import`, not to mention that Ruby is a language that allows monkeypatching which is something that's just prone to creating even more magic. You'll get used to it if you really have to use it, but the more I used it, the more I hated some of the things it does, and I'm glad I don't have to work with it anymore. Edit: wording
What do you get from a package-level variable that you couldn't get another method? For example, what do we get from package `rand`'s var Reader io.Reader that we couldn't get from func Read(p []byte) (int, error) { return unexportedReader.Read(p) } // in case you need to pass an io.Reader that's a CSPRNG... func Reader() io.Reader { return cryptoReader{} } or from using the `const` method? In my experience, I could probably count on one hand the number of times I've needed a mutable, exported variable. Every other time I've just needed to export some static data. Mutable global state—especially exported global state—is just more points of failure and likely makes the compiler's life harder, too.
Exactly. The whole discussion reads like someone has forgotten the old maxim that perfect is the enemy of the good and just good enough.
How about testing? The very simple idiom of // For faking in tests. var timeNow = time.Now now becomes unusable.
Hmm why is this posted in this subreddit? Is it written in Go? Any details on the backend?
You have no idea what you're talking about. Generics are parametric polymorphism, and Javascript obviously doesn't have type parameters.
any functions that depend on time can explicitly be passed the time needed during tests. i.e. func doSomeTimeDependentThing(t time.Time) {} instead of the same function that depends on the state of a global variable. Same goes for just about anything you write
The default bufio.Scanner reads lines of text, ending with a newline. The password prompt doesn't end with a newline, so it's still in the buffer. You'll probably need to use a plain io.Read on the connection, and handle newlines etc. yourself.
&gt; out, err := session.StdoutPipe() &gt; if err != nil { &gt; log.Fatal(err) &gt; } &gt; &gt; go func(out io.Reader) { &gt; r := bufio.NewScanner(out) &gt; for r.Scan() { &gt; fmt.Println(r.Text()) &gt; } &gt; }(out) io.ReadFull(r io.Reader, buf []byte) (n int, err error) Do you mean io.ReadFull?
Actually, using your suggestion I did manage to receive the message `[sudo] password for gues: `
Really bad.
Hm? Those aren't variables. They are not variable. [edit: to be clear: Answering the question "what do I get from vars that I don't get from…". I explicitly stated, that I think variables have a place, as variables] If you are referring to a different argument/use case (e.g. one of the ones Dave talked about, like having de-facto constants) my answer is "it's more convenient to write and has no real disadvantages". But I wasn't really talking about that, I was talking about his claim that exported var declarations should be frowned upon. I disagree.
&gt; Most people pushing for this type of behavior are working on projects where correctness and testability are incredibly important. Eg working on the standard library would fall under this category, but so do many other projects. I don't think what you are refering to "this type of behavior". On the one hand, you are referring to "correctness and testability" and while correctness is a red herring, testability definitely favors *not* having global vars. On the other hand, the stdlib is a project, which has a lot of global vars and you call that out as falling under that category, meaning that "this type of behavior" would have to refer to having global vars. The stdlib, indeed, is full of perfectly fine examples of "there is a tradeoff and it's totally fine, to choose exported global variables here". &gt; Peter and Dave trying to educate others on alternative approaches is a good thing. On this, I view them very differently; Dave expresses himself much more dogmatically. I dislike Dogma. In particular, I disagree with his opinion, that a) exported package-levels vars are generally bad and b) that this is an uncontroversial opinion. I think the stdlib demonstrates perfectly well, that a) isn't as straight forward as he claims and the fact that at least some people of the go team not only write/accept them, but actively lobby for them having uses seems to disprove b).
How will write the password? Just print to stout? 
Fixed here: https://www.youtube.com/watch?v=yuW6BwOS8Eg
SECTION | CONTENT :--|:-- Title | justforfunc #13: more text to speech with cgo and Docker multistage builds! (4k) Description | Last episode we built a "say" command that used cmuflite.org by forking to a new command. In this episode we replace that with a call to the C library using cgo! Also, we explain multistage builds in Docker and we use them on Google Cloud Container Builder! cgo: https://golang.org/cmd/cgo/ flite: cmuflite.org Container Builder: https://cloud.google.com/container-builder/docs/ Length | 0:45:46 **** ^(I am a bot, this is an auto-generated reply | )^[Info](https://www.reddit.com/u/video_descriptionbot) ^| ^[Feedback](https://www.reddit.com/message/compose/?to=video_descriptionbot&amp;subject=Feedback) ^| ^(Reply STOP to opt out permanently)
&gt; The stdlib, indeed, is full of perfectly fine examples of "there is a tradeoff and it's totally fine, to choose exported global variables here". I agree with you, but the stdlib also has examples of globals being used poorly (eg the `sql` package) so I think educating people about alternative approaches is useful. I would also argue that one of the primary reasons that many errors are vars instead of constants is actually because nobody thought to use `type myError string` so that their errors could indeed be constants, not because it was harder to write the code. Again, education is useful. &gt; Dave expresses himself much more dogmatically. I dislike Dogma. Understandable. I tend to ignore that aspect of Dave's writing when I disagree, but I could see how it could irk others who disagree with some of his opinions. And to be clear, I DID NOT claim that everyone working on those projects advocates for no global vars. A = Devs who advocate no globals B = Devs involved with large projects (stdlib etc) I claimed A is often a subset of B, but your post makes me think you took me to mean that B is a subset of A. I think you made the point to try to disprove Dave's point, but I just wanted to clarify my own view.
Interesting how perceptions differ. I though Peter's post was far more dogmatic than Dave's, which was more of a thought experiment and concluded with saying that removing global vars probably isn't desirable or practical. 
As the usual joke goes, the answer is "a for loop". https://github.com/tv42/topic
You want to start a company? Then first of all you need to identify the problem you'll solve, or define the service you'll provide. Only __after__ that do you need to consider the technology involved. 
I am a huge proponent of dependent injection as THE way to get testability, and Go's micro-interfaces make that really easy. The flip side of the coin, though, is debug, especially "debug by code inspection". Proliferation of interfaces makes it much harder to trace code back from log-line up the call-stack.
Can you paste your exact build command? Are you saying no part of your code runs on windows? or just some parts fail?
Well, one problem is that it's not type safe. It's possible to put a bunch of unrelated types into the same map. If you want to make it type safe, you're back to adding boilerplate code for every type you might want to store.
Isn't it Apples and Penguins? :trollface:
&gt; Well, one problem is that it's not type safe. a) That is just plain wrong. It's perfectly type safe, the safety is just dynamic. And b) it's at best academic pedantry; in practice, you add a bunch of type assertions that'll never panic whenever you use that container and it's perfectly fine. I agree that compile-time type-checks are very useful. I just don't think that they need to be universal to be useful (otherwise I'd write ML) and for containers in particular, claiming that it's a source of bugs or problems is just FUD. In practice, there won't be confusion around what's actually in your container and it's completely fine to live with that. &gt; It's possible to put a bunch of unrelated types into the same map. Yes. And I claim that there is, in practice, no question about whether that is supposed to be done or not, `interface{}` or not. It's perfectly clear, that `encoding/json` can cope with arbitrary values. It's perfectly clear, that `var people map[string]interface{}` is *not* supposed to store database connections. Believe it or not, there are *large* programs written in python or javascript even, which has zero compile time safety. I'm not saying it's a *good* thing or that the lack of static types isn't becoming a problem when a project grows. But it *does* conclusively show, that the whole "I use `interface{}` for a container in my program, now it will just crash left and right, never work, I can't refactor it ever and it could just as well eat my hard drive as doing what it's supposed to" is just plain FUD. You are going to be fine using an `interface{}` here and there, believe me.
You're right. I should have said that it is not statically type safe. I am simply saying that there *are* costs you have to weigh when deciding to use interface{}. Your original statement is that there is "nothing wrong with that". I added that there are, in fact, costs to going this route. You lose the ability to statically detect certain kinds of errors. Whether this is important for you and your project, you'll have to make that call yourself. Probably it won't eat your hard drive, but thanks for strawmanning me.
&gt; Which I'm saying isn't really necessary in most (all?) cases, since if you need the variable's methods (like rand.Reader) you can just export functions or constants that do the same thing. But… I can't. *They* are supposed to set the debug logger, if they want to debug. As it's unclear: package foo var Debug = log.New(ioutil.Discard, "", 0) func Frobnicate(host string) error { Debug.Printf("Starting to frobnicate %q", host) if err := doSomeFrobnication(host); err != nil { return err } Debug.Printf("Looking good, fnording") fnord() return nil } package main func main() { debug = flag.Bool("debug", false, "Dump debug information") flag.Parse() if *debug { foo.Debug = log.New(os.Stderr, "[foo] ", 0) } if err := foo.Frobnicate("example.com"); err != nil { log.Fatal(err) } } This (and similar usages) is a useful, convenient pattern. It requires global, mutable state to work that way. It can't be solved by providing any functions or const's in `foo`. Definitionally. &gt; But, that could be rewritten as Allow me to quote myself: &gt; And sure, I could also plumb it through every function call and add a pointer to every struct. But a package scoped variable provides a simple, convenient and clear way to achieve what I want. Adding all of this to all my structs (and not everything my packages do is a method on a struct, BTW) is just a lot of hassle and a lot of hoops to jump through just to avoid a var-declaration that some textbook says is bad. Doing it this way is just throwing out the baby with the bathwater. It's needlessly complicating your life (and, at some point, also compromising performance) based on a purely academic, theoretical concern. Exported and unexported package level variables (as in "variables", not as in "a replacement for a different concept, that go can't map, so we're using var-declarations instead") have their place and you can just apply common sense on a specific case, whether it's worth to use them or instead be overly clean. &gt; Again, I'm not saying exporting variables is bad Okay, cool. But Dave *is* saying that and this particular thread is about me strongly contesting that opinion and even more strongly contesting the claim that it's uncontroversial. So, if you are not holding it, I'm not sure why you're even arguing with me.
Pretty cool! One small (but potentially important) correction: you shouldn't have the if c.totalLoad == 0 { c.totalLoad = 1 } in `loadOK`; instead you should be using `(c.totalLoad + 1) / int64(len(c.loadMap))` in the `avgLoadPerNode` calculation, unconditionally. By comparing the load of the server in question with one request added, to the average load of the whole pool with one request added, you make sure that the invariant stays true when we do add that request, and that `ErrExhausted` is mathematically impossible. Your current calculation will occasionally reject a server that should be accepted. Also, shouldn't `Done` be decrementing `totalLoad` so that it's a mirror image of `Inc`? As it is, I don't see `totalLoad` ever going down.
Exporting a variable becomes an interface (in the API sense) and restricts what you can do in the future with it. For example, it means you cannot know when a client app is changing it. So you cannot control the lifecycle of that variable. Let's say you have a variable "var Logger LogEmitter" or whatever defined. That means you're stuck with that interface as long as you don't want to break it. If you had a "SetLogger" then internally you could wrap it in a compatibility interface if you needed to use a different interface internally. But if it's a specific interface, declared as a variable, you're pretty much stuck with it.
&gt; Also, shouldn't Done be decrementing totalLoad so that it's a mirror image of Inc? it was pretty late at night when i was writing it, i don't know how i missed that! if c.totalLoad == 0 { c.totalLoad = 1 } will be: if c.totalLoad &lt; 0 { c.totalLoad = 0 } as a safety measure for when one calls Done more than needed. i'll fix the issues you pointed out, thanks! also your medium article and the hangout session were very helpful, when i needed to learn the algorithm. thanks. ------------- update: the issues are fixed now :)
Hmm I see, that is disappointing. In that case I think the admins should remove it. /u/dgryski
I've lately started leveraging a lot of the private global registry pattern so I can provide multiple backends that implement say a datastore and allow them to be chosen at runtime via config. So have init() function calls in each implementation package that registers that particular backend, via a public function, with the global registry that sits in the same package as the interface for say the datastore. This obviously goes against what was said here. Especially considering I'm forced to do some 'magic' imports in the main package so that everything registers. What's the alternative approach to something like this?
&gt; Eg working on the standard library would fall under this category, but so do many other projects. the standard library has global package vars in it already, so no 
&gt; I would also argue that ~~one of~~ the primary reason~~s~~ that ~~m~~any errors are vars instead of constants is actually ... because Go does not allow you to express errors as constants???
&gt; what do you get from exported var declarations that you couldn't get from writing it in a more functional (i.e. through func or const) style? sanity? Go is not FP. Even if you move your error matching code to functions, you still only have the ability to move your error state to functions with ints or strings....is that progress? moving `if err == pkg.MyError` to `if IsMyError(err)` only works with pure constant (compile-time) state if you encode a constant in your error...you can only do that with numeric or string values...is that progress?
I'm not following. You could write type MyError struct{ ... } func (e MyError) Error() string { return ... } which allows you to encode state in the error without having a package-level variable. The user just switches on the type of error or on what interfaces it implements. Then there's no need for `io.EOF` to be a variable—you just write something like: type EOF struct{} func (e EOF) Error() string { return "EOF" } and you have a zero-sized error without a package-level variable. Or the constant route: type IOError int func (e IOError) Error() string { switch e { case EOF: return "EOF" ... } } const EOF IOError = -1 
Incorrect. See https://play.golang.org/p/6sBH3CdXy_
I think you misunderstood me, so I'm going to try to elaborate a bit. First, I said that many people pushing this type of behavior work on large projects that value correctness and testability over many other things. &gt; Most people pushing for this type of behavior are working on projects where correctness and testability are incredibly important. I didn't say everyone working on the large projects values this behavior. Obviously not everyone working on the stdlib does. What I did say is that of all the Go developers out there, ones who would advocate for more testable code via no package vars are more likely to work on a large project where testing is very important. I then said that working on the standard library would be an example of working on a large project that values correctness and testability. &gt; Eg working on the standard library would fall under this category, but so do many other projects. Again, I'm not stating that everyone working on the stdlib is advocating for the removal of global package vars. I am instead stating that you are more likely to find developers who agree with Dave or Peter among the stdlib core team than among team members of a photo sharing startup where they "move fast and break things". 
The Go Blog has [a post about useful concurrency patterns](https://blog.golang.org/pipelines), including the fan-out pattern, which is what you need for passing a message to multiple receivers simultaneously.
sudo checks whether stdin is a terminal and only allows you to enter a password if that's the case (so that it can disable echo and the like). So, what you need to do is making sure, that the sshd on the remote side allocates a terminal (what `ssh -t` does). But, more likely, you just don't want to use sudo. The best option, would be to ssh directly into the root account and to use public key authentication for that. Using password-less sudo (as /u/singron suggested) would be an alternative, but depending on *what* commands you want allow, end up being equivalent to ssh'ing into the root account anyway.
Might be related: https://github.com/cznic/sqlite/issues/12
[Good job building a thing, but you don't have to repost it every week.](https://www.reddit.com/r/golang/comments/6dmkzp/an_authorization_library_that_supports_access/di412z8/)
I would checkout ripgrep if I were you. It's faster than `pt` in a couple of cases: http://blog.burntsushi.net/ripgrep/
It seems you already request a PTY. So, my theory of why it doesn't work appears to be wrong :) The rest of my comment still holds. That is a bad preference. Use public/private key auth. If you don't want to use root (why not? If it's an administrative task, that's perfectly fine), but need more privileges than a regular user, create a dedicated service account and give them only the rights they need. If you need sudo to achieve that granularity, give the service account the right to use it without a password. Storing a username/password and passing that around and circumventing sudo's sanity checks is a bad idea.
Why not just use a crazy large channel size? c := make(chan int, (1&lt;&lt;16)-1) Unbounded channels are a code smell to me. You should pick a size that gives you good performance and otherwise leave it as tight as possible. This is for a few reasons: 1. Fundamentally an unbounded channel is impossible. You are limited by the amount of memory on your computer. Unbounded channels lead to memory leaks which result in your program crashing. 2. An unbounded channel hides performance degradation and errors. You might think things are running smoothly, but you've actually got a queue of thousands and thousands of items waiting to be processed. For a system like Kafka, it's important to apply backpressure so that you can easily see that you're behind in processing. 3. Channels aren't merely a message passing mechanism, they are also a synchronization mechanism. An unbounded channel between two goroutines makes the sender think the receiver is always ready, even if its not. This eventually leads to poor scheduling performance. It's better to use a `select` with cases that accurately reflect whether or not each goroutine is ready for work. (For example you can implement a timeout on send, detect that we're overloaded, and react accordingly)
1) pretty sure the implementation isn't leaky unless there's an underlying problem with how Go manages memory, but I do think that it's not really alloc optimized (append/slices will hit the heap a lot), 2) you can have visibility into the queue size just by providing a len() on the slice (vs. providing a len() on the channel with a large channel buffer) - backpressure is an add-on in both approaches (ie, there's no solve for backpressure just because you suggest to increase the channel buffer), 3) Go supports a range loop over a channel receiver, basically flushing the whole channel queue - this is usable for example when you'd run the reader once a minute and want to map/reduce whatever is on the channel queue up until that point. At that point it would be questionable just why you would use channels at all, TBH. But you could use them anyway. For example: you could write http access logs as they come in to a buffered channel, and produce a reader that would flush them every X seconds, etc. - predicting an upper-length buffer size in those cases is not practical. Channels still make a good abstraction for a growing slice, versus implementing mutex logic on a slice to flush it. I like non-blocking writes here. I'm pretty sure I can hit those 64k entries in about 6 seconds in a prod server, and whatever time it takes to flush them shouldn't affect how the log entries are collected (locked mutex would wait for unlock). Edit: whitespace, example, better example...
Post a link to the actual damn thing! It's a static site generator for those like me who had no frelling clue. http://gohugo.io/
https://pastebin.com/1uVcusXM - That's my final code I'm using. Are you asking for one of your own projects? or just curious?
There is also an implementation of Pearson https://godoc.org/github.com/gonum/stat#Correlation
Getting pretty annoyed seeing this being posted again and again for no obvious reason, as is pretty much evident when [looking at the post history](https://www.reddit.com/user/hsluoyz/submitted/)
Actually its becoming a bigger and bigger thing. Just went to a talk where a guy's company is using c++ to make their own languages. He wanted to convince his team to use go for that because its just way quicker to do. https://ruslanspivak.com/archives.html 
As far as we could tell there was no tool that solved the problems we were having with the vendor directory in such a light weight way as this does. We built this tool mainly for the second and third reason in the README: &gt;- You want to depend on a specific version of an executable package, such as a linter or a codegen tool. You find out that the vendor directory only works for libraries. - You work on two projects, A and B. Both of them contain a vendor directory. You want to use project A from your GOPATH when compiling B. To do this you remove A from the vendor directory of B, so it will fall back to import A from GOPATH. Suddenly you get a lot of weird import errors. We ran into the first issue when we needed to have a pinned version of tools like protoc-gen-go. We into the second one, because we were using multiple repos, some of which import each other, and we wanted to use the local version sometimes to test new changes. 
I am from the east coast of the United States. The population in this region is historically known to have accent neutral speech. However his accent is only part of his problems with English. His statements are not well formed. And please refrain from using multiple accounts to upvote your comments.
It's a good thing people defer their closes, it prevents more bugs by leaky file descriptors I imagine than causes. Reads are more common than writes, it is harmless in the read case. I think what should be advocated here is to fsync your writes, I.e. Replace your close calls with sync.. besides it's really not a good idea to rely on Close() to sync uncommitted changes. Close should be thought of for one thing, cleaning up the file descriptor. Also if you really want to handle the Close() error specifically, it's harmless to: f, err := f.Open() defer f.Close() // double close just causes a cheap, harmless EINVAL // ... return f.Close()
How are you compensated? What are your motives for investing your time into this project? What type of return do you expect for your contributions?
Yikes - what should we do then? Call `file.Sync()` explicitly in addition to `Close()`?
My question will seem stupid, but why would I go through js dependency management? until now I just downloaded js files like jquery or bootstrap ones and put them in the same folder. Are things more complicated than I think?
[removed]
As `quil` mentions, you instantiate them in your main package, and then pass them along as needed. Your main package can then pass the DB along as needed to whatever needs it; and any functions that need a DB should take one (or an interface matching what you need) as an argument.
I was planning to write a "fabric" alternative in Go (just the functionality to execute arbitrary commands in parallel) and I thought that your code will give me a good start. Thanks! 
left shift https://golang.org/pkg/math/big/#Int.Lsh right shift https://golang.org/pkg/math/big/#Int.Rsh Operators (e.g. `+`, `-`, etc.) can only be used on builtin types like `uint` and `string`.
Wow. Can't believe I missed this. Thanks!
When you get into React or other frameworks, you start to get into "JS Build systems" which is just tons of "tooling" that traspiles, shims older browsers, and hooks things together. It is all hideously overcomplicated and generally unnecessary. Sometimes it feels like there are folks that simply enjoy the chain of incantations that make them appear to have achieved greater mastery. Just seems silly to me. I use jQuery for DOM manipulation (which is now generally frowned upon by the cool kids) and either PHP or Go for the backend. There's nothing wrong with this, and has served me well for years. I'm very productive with the "stack" I choose to use, and it eliminates dependencies apart from jQuery and sometimes Bootstrap. My rule for tools is "if the instructions mention node.js, I'm out". All that said, I'm happier working on the back-end than front-end. I'm certainly not a designer, so YMMV.
So, overall bad design choice from author :) would definitely choose your pattern in 3) for readability!
The community seems to dislike named return values, and they are not used very often. So perhaps it would make sense to read named return values as a sentinal for using this pattern, since it wouldn't seem to conflict with anything else. It matches my own code already.
Yes. If you are writing a file and need to be 100% sure it was sync'd to disk this is exactly what you should do.
Hi! Me behind the plush here. I wrote about this a few months ago: https://www.reddit.com/r/golang/comments/5npdzx/practical_golang_gopher_plush/ and have now made it available to you! I hope you like it. Let me know if there are any questions. 
Thank you for sharing your experience, it really means a lot to me!
aw, I got all excited thinking there was a re-release of the [original plush gophers](https://blog.golang.org/gopher/plush.jpg) Either way, wish you all the best!
I think that's not correct. At the POSIX level, a double close on a fd is very harmful as the file descriptor might already been reused for a different file from a different thread (I actually had to debug a big like this last year, in a C program, and it was very nasty). I think Go has been lately changed to avoid this and return a proper "file already closed" error, preserving the abstraction. Not sure if it's Go 1.8 or tip/1.9 
TLDR: Frozen can mean any of the following: *stable*, *complete* or *we won't touch this because it doesn't belong in the standard library anyway and we don't want to be bothered*
I changed the title to say "modifying". Thanks for the feedback.
Between Hackernews and Reddit, I'm sure everyone is excited for a README infusion. ;)
I still don't understand *why* packages are being frozen.
Link to the source?
That's awesome you tried it out! I think the strongly typed plus the very efficient transfer of data using protobufs and http/2 would be pretty big advantages, did you see any negatives?
this package is part of the standard library which is covered by the go compatibility promise. the Go core encourage people to not even use this package but instead wish you to use those provided in /x. This is simply trying to remedy an oversight in design that can't be fix because of go1compat. EDIT:You downvote me without rebuttal. I wish I could find the link to the conversions provided by the core team about this subject - might act as lubricate to help remove the stick from your ass.
https://github.com/golang/go/issues/15557#issuecomment-217524503
&gt; Close returns errors for ~~two~~ three reasons 1. [...] 2. [...] 3. Because NFS is a stupid filesystem ...at least IIRC this was always given as the reason to do it to me, as local FSes never failed on close.
What version of Go was that added that? The above code has been in production since Go 1.1 I think. :)
True. I keep swapping out NFS out of my head. NFS can give EINTR on close if you have a soft mount. It's a marginal problem though. Unless the EINTR was caused by a signal that wasn't meant to interrupt the close and it now has caused an exploitable security problem (if you wanted to close your file descriptors before exec for example), which is why all reasonable systems actually close the file even when close returns an error. Of course there's a possibility of some new horror show introduced by kerberos and NFS 4 which I'm not aware of (I have not studied NFS 4).
i didn't downvote you! :) from links provided by other comments, it seems like there's not really any agreement on what a 'frozen' package means.
Without seeing the real code or having more details it's a bit hard to say, but you will likely be able to make all of your requests concurrently. Googling "golang concurrent http requests" should get you some good examples of doing this.
Well, they are actually "almost" the same value :) 2090088131 = hex 07C9436C3 6385055427 = hex 17C9436C3 
Is the "c" printf truncating at 32 bits ? Try printf("%ld\n", h);
is the linter open source?
Obvious advice: if a linter causes you to do shit like this, it's not a good linter for you! Stop running it! :)
If the 3rd party API can "scale" and you can collect the responses out of order, you should get some benefit in sending multiple (2 to 10?) requests in parallel. With the sequential requests you have a lot of "idle time" waiting for the external service to reply. To do this you should "spawn" you can change your current code (where you iterate over the slice) to put the request info on a channel, and have a pool of goroutines that read from the channel and send the request to the 3rd party service. 
It's good because it forces me to document why I'm ignoring return values and catches mistakes like in the OP.
https://godoc.org/golang.org/x/sync/errgroup or go func() { defer wg.Done() foo() }() 
Use a DeferClose function like this one: https://github.com/carlmjohnson/json-tidy/blob/master/json-tidy.go#L91:L96
Slightly less ugly version of the same: https://github.com/carlmjohnson/json-tidy/blob/master/json-tidy.go#L91:L96
just ordered 2 :-)
I have to admit, I can't really see the tangible improvement over just using: export GOPATH=`pwd` Seems like it does a whole pile of infrastructure stuff in a way that makes your code less portable... 
That use of variadic functions made me cringe. 
That was it! Thank you.
awesome! any idea of delivery timelines? week? weeks, months? Not particularly worried as mainly just wanted to support, but it would be nice to have at least a ballpark on the website.
But if you may think about planning a relaunch of the original one, i would order some.
7-10 days is what it should take, as that is the estimates I get and why I picked that shipping service. Low price, and not so bad delivery times. And tracking info. If it goes above, do let me know, as if it happens too often I would look into it.
Yeah, that would be cool, but Google has copyright on that one. It would have been cool to work something out with Google to do it though. But for now, I want to avoid violating their copyright. :)
cool I'll let you know when they come in!
Perfect! I'm eager to know what you think about it when you get it. I hope you will like it. :)
No, but I have implemented read/write for the related XLSX format. There's probably a way to do this fairly easily so long as you just want to fill in fields on existing documents. The trick would be to do it without loading all the XML and then rewriting it (which is what we do in https://github.com/tealeg/xlsx ), but rather to know what needs to be inserted into each file and where, and do that as a basic seek/write/close.
This is quite simple *given requests are independent*, that is you don't need the results of a previous request as part of the next. Given it seems like you already have a slice of data, I do not think that is the case. The key is to do the requests in goroutines, such that while waiting for the response it is not blocking. Here is an example: http://blog.narenarya.in/concurrent-http-in-go.html Likewise, please make sure you don't go too crazy with an api. They will often have certain rate limits in place. Take a look at: http://jmoiron.net/blog/limiting-concurrency-in-go/ You can use a semaphore (that is the term you can look up) to only allow a certain number of requests to be actively done at a time. This can be thought of like a worker pool. Eg if you had 100 urls to request, and set the limit at like 10, it would request 1-10 immediately, then as each finished, another would be kicked off, so no more then 10 were done at a given time. I'd suggest not doing more than 20 concurrent requests.
`io.Reader` is a good example: it takes a slice (the container) and returns the bytes read count and an error. Same thing could be done with a string. Like a function that extracts something into the string and returns a pair "where it found it and an error". IDK. Strings are immutable though so maybe the only reason to do it with a string is to not return 3 parameters. Edit: written -&gt; read 
Is there any report on the slow syntax highlighting?
To each their own, but I still don't get why people do things like this. What drives someone to look at a totally readable for loop and think, "we should have a 2nd syntax which is 100% equivalent but involves everyone memorizing an extra built in." I get that they are used to the way python does it, but being used to something doesn't make it better. To quote the Zen of python &gt;There should be one-- and preferably only one --obvious way to do it. This is the exact opposite of that. /rant 
errgroup seems like a much worse name, but the usage seems nicer.
GOS, I'm calling it!
um... no... I mean, yes you can do this, but it's not the Go way. Create an interface for the functionality you need to implement on multiple types. Use that interface as the handle on the implementation in the calling routine. Then implement support for that functionality for the types you need. Boom. done. The second half of the article, about Sort, is the exact opposite of how this is supposed to work. Creating a new type and implementing the Sort interface on it is actually less hassle, more readable and relies less on side-effects (which the author noted) than the closure method presented there. Sort is the classic example of how Go treats problems that would normally require generics (by using an interface). Yes, it looks weird and strange if you're used to OO languages. But once you get used to it, it's completely natural and makes total sense.
Nothing intrinsically wrong with them. But they shouldn't be used as a replacement for default values. 
It's basically useless to try a linguistic analysis of what "frozen" could mean in this context. It means just "is not accepting new features" as written literally in the documentation. The package's state is frozen. No new features. This package won't go away while Go 1 is maintained (Go 1 compatibility guarantee) but it also won't see any new features. That's all. That's simple and it does not really matter whether you call this state "frozen", "fixed", "immutable" or "foobangibarish".
It helps avoid multiple **sources of truth**. Suppose you have a bank machine that can withdraw from an account, assuming the account has the funds... cash, newAmt := bank.Withdraw(100).From(account.Amount) account.Amount -= cash Versus cash := bank.Withdraw(100).From(&amp;account.Amount) You can see how, in the first example, you might forget to withdraw the funds from the account. It reduces bugs and complexity if functions start and end in valid states, where possible.
No, the whole point is to get a warning you that you're ignoring a return value. In *most* cases the linter is right. An even here it is arguably useful, in that it forces you to document the fact that you are ignoring a return value; you can't see from a single "Close" call whether it is a "void" function or one that returns values. I rather wish Go would make unused/unassigned return values an error. It throws up if you don't use an import, so why not a return value? Arguably more important. Go is curiously inconsistent about its strictness. Go is happy with shadowing variables, for example. Most of my semantic whoopsies come from bad shadowing (and nils, why do we have those again?).
I'm not sure how you get your export trick to work, because I don't see how your current project will still be on the correct place in your `GOPATH`. Do you commit the whole src directory and have a symlink in it to the current directory? When using `vg` you don't have to commit the dependencies, just the `Gopkg.toml` and `Gopkg.lock` files, which decreases repo size and avoids merge conflicts. Apart from this two big improvements are that this also changes `PATH` and does all of this automatically when cd'ing to a directory (so no mental overhead). I'm also not sure why you think `vg` makes your code less portable? You're not required to use `vg` to work on a project. You can still use the vendor based approach by just using `dep` instead if you don't need the automatic binary installs.
What is the preferred way to use sqlx.Select and sqlx.Get with named parameters and postgresql ?
&gt; admonishment Great word - thanks!
This can happen because of many causes, so even if it would be, chances are it would be for different issues. Can you please have a look here https://intellij-support.jetbrains.com/hc/en-us/articles/207241235-Reporting-performance-problems and open up an issue with the attached snapshot? Thank you.
Yeah, you are right I was misreading, I was reading fclose. I got as far as closef but couldn't find it's implementation. Seems like golang and the POSIX standard are both pretty lose with how data is flushed from a file handle and how the error is raised, out side of their respective flush functions.
You just install any binaries you need into your local bin\ folder, just like normal. My point is just... why? It's another tool to install and it gives you what? &gt; When running go test ./... the tests in your vendor directory are executed. https://github.com/golang/go/issues/19090 This is already being addressed. &gt; You want to depend on a specific version of an executable package, such as a linter or a codegen tool. You find out that the vendor directory only works for libraries. Just use a custom GOPATH for your project. `export GOPATH=pwd; go get -u github.com/nsf/gocod`. Done. &gt; You work on two projects, A and B. Both of them contain a vendor directory. You want to use project A from your GOPATH when compiling B. To do this you remove A from the vendor directory of B, so it will fall back to import A from GOPATH. Suddenly you get a lot of weird import errors. ... &gt; ... You want to use project A from your GOPATH when compiling B ... No, I don't. If B depends on a snapshot of A, B is a dependency of A and goes in B's vendor folder, installed by dep. Nothing goes into the GOPATH. &gt; You want to vendor plug-ins and run into issues: https://github.com/akutz/gpd This seems like a valid use case, but plugins are half baked anyway; they don't work on windows and you can't unload them. I don't need this. So.... I'm just saying, I can't see any benefit, for me, in using this. It's just another tool for the sake of it; and like the various package managers like glide, godep, etc. if your package requires it to build (eg. for plugins), then its another thing that needs to be installed. If its just a ... productivity tools? ...then it doesn't provide anything I find particularly useful. &gt; I'm not sure how you get your export trick to work, because I don't see how your current project will still be on the correct place in your GOPATH That's the point. The GOPATH is largely made irrelevant by dep; there's no such thing as wanting something to be 'on my GOPATH'; I want my GOPATH to *not be shared* between projects. &gt; When using vg you don't have to commit the dependencies, just the Gopkg.toml and Gopkg.lock That's exactly the situation without using vg as well, just using dep. 
The code could be better, especially when you claim something is "advanced". Take a look at io.TeeReader, io.Copy and io.MultiWriter.
I can also add on here, modern JS is very complicated, and can also confirm, something like jQuery, or what you already do is fine. That being said, there are also pretty huge advantages to using something like Angular or React over jQuery for and entirely frontend JS client. Things like routing, and handling browser interaction and navigation will be easier, templating too. You may find you have a more organised folder structure, and that there are clearer definitions of the components that comprise your application. All in all, it's a tradeoff - but it is also a pretty steep learning curve. Use what you feel most comfortable with if you're pushed for time, if you have tons of time, then maybe just try something like Angular or React out. For Angular, there are things like Angular CLI that will help you start a project very easily. If you've not done much NodeJS stuff before (like using Gulp / Grunt, etc.) then I'd definitely recommend that you use [NVM](https://github.com/creationix/nvm) to manage your NodeJS installation. You can switch versions easily, and handling installing things like LTS releases is easy, e.g. `$ nvm install lts/boron`. You can also use `.nvmrc` files in repositories to make it easy to switch versions per-project (just use `$ nvm use` in a directory where that file exists and it will detect the version and use it, if it's not already installed, you can just run `$ nvm install` in that directory to install it, then use it after).
Thanks for the lengthy explanation. I understand that `vg` might not be for you, but I would like to go into some of your points and explain why I thing `vg` might still be useful. I would like to start of by stating that `vg` really doesn't really do anything special, it is a productivity tool. It's just a super easy wrapper around already existing shell/go commands. &gt; https://github.com/golang/go/issues/19090 This is already being addressed. Yes, in the next version of go. But this fixes it now. This is mostly by accident anyway. &gt;Just use a custom GOPATH for your project. `export GOPATH=pwd; go get -u github.com/nsf/gocod`. Done. This is basically what `vg` does. The big difference is that your version does not use a pinned version of `gocod`, to do that you would have to do: export GOPATH=`pwd` export PATH=`pwd`/bin:$PATH cd vendor/github.com/nsf/gocod go install . You would have to do this each time you did `dep ensure` because maybe the pinned version was updated. The main goal of `vg` is to do these steps automatically based on your Gopkg.toml &gt;No, I don't. &gt;If B depends on a snapshot of A, B is a dependency of A and goes in B's vendor folder, installed by dep. Nothing goes into the GOPATH. I think this is a part of the README that could be improved. I agree that you want it in the vendor folder... usually. The case where I wanted to use a locally checked out version of a dependency was when I was changing that dependency. In that case I wanted to test out the changed version in project A in project B, without pushing it, because I wanted to make sure my changed project A would have the desired effect in project B. Having a `vendor` directory in both projects really breaks all the imports in this case. 
couldnt resist either...
This is a thing with Go that you realistacally can't do this fancy stuff like in other languages. For better or worse. For traversing complex data structures I suggest using default for loop with custom iterator of that structure. For example like this: iter := tree.InOrder() for key, value := iter.First(); value != nil; key, value = iter.Next() { fmt.Println(key, value) } You could use range with channel like you did in your code but you won't get key (index) and it is slower.
All built-ins are "not Go". arrays, hashmaps &amp; channels are generic. make is overloaded function (or has default parameters). new takes types instead of values, etc... This is just a feature of Go. "Complex" stuff is only few exceptions in the language/stdlib and in regular Go you can't do that. I get it why creators of Go decided like that. Personally I'm not fond of it, but what can you do. Only move to another language.
&gt; or at least would have prevented By introducing new kind of problems or bugs. You can't just add immutability to Go and don't sacrifice something else (simplicity, readability, etc). Language design is all about tradeoffs. 
Haha. ;)
You should definitely clean up and consolidate `Makefile` and `build.sh`.
Cool but you got the name of the language wrong. It's Go.
I recall this pattern as being briefly promoted semi-officially some long time ago, but quickly deprecated because of: 1. memory/resource leaks in case of `break` or `return` in the loop before the channel is exhausted (see also [issue 19702](https://golang.org/issue/19702)) 2. worse performance (locking &amp; context switch, etc.) compared to non-`range` for loop. Currently I'm aware of 2 "semi-official" replacement patterns: - the one used in [bufio.Scanner](https://golang.org/pkg/bufio/#Scanner) &amp;mdash; i.e. `for scanner.Scan() {` - or something similar like in case of [xml.Decoder](https://golang.org/pkg/encoding/xml/#Decoder.Token) &amp;mdash; `for t, err := d.Token(); ; t, err = d.Token() {` &amp;mdash; though in such case it's usually cleaner to do it as: `for { t, err := d.Token(); ... }`
No
golf, https://github.com/TapirLiu/golf, is a similar but simpler one.
What is going on with the voting here? Seems people really like this or really don't. Not sure what is going on, but the number goes up and down a lot.
I once copied and modified the code for a bytes.Reader - that was being passed to a library for format parsing - to increment an integer via a pointer so that the current offset of the data could be recorded for a resumable save state.
You can do type assertion instead, like so err := foo() if err, ok := err.(*BadValueError); ok { // ... } 
Just use type assertions: _, ok := err.(*MyErr); ok
I tried to order, but Paypal says no (they neither let me log into my account and use that to pay, nor to pay with a credit card without an account)… So, I guess there just isn't a workable payment method available to me :(
Make one without a hole in its stomach too?
I would instant buy two of them completely without the hole :)
I guess very much people didn't like the hole in the stomach like me :(. Any chance you make a version without the hole?
This was done on the public issue tracker. It went through the official proposal process. Yes, they *are* different, but it was seen as gRPC was better and more versatile going forward. Feel free to look on this thread for the issue or search for it yourself. The explanation of why is there.
The `switch` circumlocution avoids having to have types themselves being first-class citizens within the language, which comes with a host of implications, most of them contrary to Go's spirit of simplicity. If you want to manipulate types directly, you can get types as values wrapped in Go objects from the `reflect` package, but be sure you need to before you do that. reflect isolates these concerns and keeps them out of the base language by wrapping them behind otherwise-normal Go objects, but this comes at a complexity price; you end up writing very detailed and verbose code to handle these cases.
dope thx
I bought one. I'd buy another without the hole if you ever make one like that.
That is something that will most likely be made if this version sells. I couldn't this time, as there is a minimum order limit to have it made and I already invested a lot of time and money into this version one already.
Well, first off, thank you for your support. It's actually now one step closer for me to being able to make a version without the hole. :)
Yes, that is the plan with reinvesting what I make from selling this one. Unfortunately I couldn't do it this time around, but my hope is that this versions sells enough as where I can reinvest and make one without the hole.
Makes sense, thank you, just wanted to make sure variadic functions werent disregarded in general.
Yeah, it's due to their whatever-detection thinking I'm not me. Or refusing to accept that I moved countries. Or whatever their strange motivations might be. Strip would hopefully work better; AFAIK they don't require an account to make payments.
github : https://github.com/ReconfigureIO doc: http://docs.reconfigure.io/ "Why use Go? The Go language has a number of features that are ideally suited to writing code in which many functions run in parallel: * Goroutines are functions that can run concurrently with other functions. * Channels are pipelines through which Goroutines can communicate and synchronize their operation. * Select statements help organize the process of switching between channels and give programmers the ability to control when parallel operations can run. **Reconfigure.io then seamlessly transforms your Go code to run on the parallel architecture of the FPGA.** " 
&gt;and nils, why do we have those again Because optionals need Rails oriented programming, which goes against Go's ethos.
order by convert(datetime, mycol) ?
Assuming this is a relational database, yes, this is SQL question, not a Go specific question. What is your database?
MySQL is what i am using
Yes, then your sql statement would be `select top 1 * order by convert(&lt;col&gt;, datetime) from &lt;table&gt;`
Dev/prod parity, perhaps 
The official name of the language is Go. Maybe they've used golang.org as URL because go.org is already in use. Also in the Documentation they only refer to Go as the language. Never Golang or anything else. Also golang is often used because it's easier to google than go. 
Hey It is right that the hole in the stomach is a little weird at first, but withe the part that can be scratched in and out, it is not so bad, so I ordered two and I hope this will help you to make another version in the future that could be more like the original one, with a darker blue. I would buy another like that aswell. 
I wouldn't call it a dev server. Seems more like a "here I have some files I want to share with you" server. At least that's how I've always used Python's SimpleHTTPServer. So it would be nice if those can be encrypted in transit if you want your friend downloading them.
&gt; And look on the official website, the url is golang.org :) Keep calm and use rust-lang ;-)
Sure, but Let's Encrypt needs a domain name to issue a certificate. So you can't use Let's Encrypt to share files over a local network or with your public IP address. If you have a domain name, you likely have already an HTTP server running.
Crap, Stripe won't work atm. Anything else? There are so many to pick from. I contacted Skrill. Wirecard? checkout.com? Paymill?
Then, because of Let's Encrypt policies about renewals rate limiting, this might be a bad idea. Let's Encrypt is not for servers which are started and stopped frequently without caching.
Ok great. I use Paypal because it was quick to get going.
Looks cool, and I love programming in Go and work at an IoT startup but I'm still not sure by the info on your website what an FPGA is at a base level, how it can be applied by me successfully and what I stand to benefit from it. We already use goroutines and multi threaded applications, what's the core difference?
I am using an SSH package and I'm sending commands to a server and I want to check if the error is not nil, and if it's type of *ExitError. That's why I needed to check.
FPGA stands for field programmable gate array. The core premise is that it allows you to create new hardware structures as opposed to everything going through a CPU. 
I guess there are some edge cases where this is an issue, but I've never had to change a name half way through a build breaking change where fixing compilation was not something I needed to do anyway.
Ordered. I hope this goes well for you and we see more. My take on the stomach hole is a little different: I want to give this a shot as a phone holder, so for me, I would actually prefer a version with the hole, but without the velcro. Curious about the blue/pink ratio. You mentioned the possibility of producing 500 of each in your other post, but I would expect you to get far more blue orders than pink.
The can be used to accelerate computations by performing computations in massive parallel. In much the same way in which a GPU accelerates certain computation. An FPGA is more flexible than a GPU in terms of the computations it can parallelize.
Give me an example from a business perspective 
For the sake of argument, there are two ways to run a computation: * Write a program for a general purpose CPU, run it. This is incredibly cheap (because the CPU is general purpose, you can produce millions of it, which is cheap and use them for everything), but relatively slow (because the CPU is general purpose, it needs to "emulate" your computation; decode an instruction, load it's arguments from RAM, send them to the correct circuit to evaluate them… and all of these steps need to be orchestrated, which means they happen in lockstep at a certain frequency, the clock-speed of your CPU. That bounds the speed you can do stuff at, even if the circuit would be quicker). * Create a hardware circuit (ASIC) to do that computation. This is incredibly expensive (the ASIC can only do this one computation, so every use case needs to go through the expensive hardware design phase and as you only need a few of them, production is more expensive per unit) but incredibly fast (the arguments to your computation are just fixed wires, which are fed into the correct logic gates and circuits to make the computation, no orchestration in lockstep required…). FPGAs are somewhere in the middle; they are an Array of tiny, general purpose blocks, that you can reconfigure into logic gates and wire up as desired, in hardware, after production. Meaning, you can produce them in larger charges, making them cheaper than ASICs, but they can wire the computation in hardware, making them faster than CPUs. Now, this only matters to you, if what you are doing is heavily Compute-bound. That does not apply to the vast majority of software these days. But things like machine learning, datamining, image/video processing… are. And if what you are doing is compute bound (as opposed to memory-bound, IO-bound…), you can massively speed it up, by running it on an FPGA; it computes a lot quicker. That can drive down your cost (you may need, say, only one FPGA to do the same that 10 CPUs are doing in the same time) and/or time needed. Usually, this still isn't *really* worth it, for most applications; you need to write the code for your problem in a special-case hardware description language like VHDL or Verilog, so that it can be programmed into an FPGA and as only very few things are that compute-bound *and* large enough that the savings from using FPGAs are significant enough and people who can do these hardware things are expensive, it's usually not worth it. Reconfigure.io is thus important, because a) you may be able to just run your normal go code un- or only slightly modified and b) you don't need to find people who understand both your domain and know VHDL. So, suddenly, the tradeoff becomes a lot more favorable towards FPGAs. I'd still say that for &gt;95% of applications today this isn't really providing a lot of value, but it's cool either way :)
I literally *only* need to change names during the build being broken.
We have very different dev styles then :) I generally stub out methods etc as I call them, so that my build is usually broken for a very limited amount of time. If I'm going to implement a new method ProcessStrings I'll either not call it from anywhere, or will do something like func ProcessString(s string) (string, error) { return s, nil } in my code so that I can still build etc. 
Nobody would be shouting at you for doing so. 20 years old, so im pretty unlikely to win :/
I don't think this is very telling. I do the same thing, but it's not, what I'm talking about. I'm talking about realizing, while writing actual code (not stubs) that I named something stupidly. If my code builds, the things are probably named ok; after all, you only realize, that something is named stupidly, if you're trying to use it. Now, I *could* just live with the stupid name until my code builds again and make a note to rename the thing later. But that's just not how my brain wants to work, my brain wants to fix things, when it realizes, that they are broken. It also doesn't help, if you need to export a previously unexported identifier, to make your code work. Lastly, I always have a ton of unfinished projects in my GOPATH in various stages of brokennes; gorename not only compiles approximately all of my GOPATH (taking *forever*) it will then also crap out, whenever it can't compile something. `sed -i -e "s/fooer/Fooer/g" **/*.go` works like a charm in a single project, no matter what happens elsewhere in my GOPATH, it's quick and it *usually* does the right thing (or can be modified quickly to do the right thing, if it doesn't). Again, I *could* have clean an always clean GOPATH, or a separate GOPATH per project/commit… but that's just not how I prefer to work. And I want my tools to fit themselves to my workflow, not the other way around :) So, yes, we obviously have different styles :) To me, gorename is pretty much only useful for a very limited use-case of renaming, where you begin your work-for-today with "I guess I need to rename this identifier", which I rarely come across. To me, renaming identifiers usually happens on-the-spot.
This is where you can learn everything about writing kernels: http://wiki.osdev.org/
I think i finally made myself familiar with sqlx. And i like it. What do you need to use Get and Select: 1) Struct fields exported (i.e. with Capitalized Names) 2) SQL table names actually doesn't matter. Sqlx easily reads from tables `users` and `persons` to structs User and Person 3) Field names does matter: you need to have SQL column names to be lowercased versions of struct field names 4) Sqlx easily reads from complex SQL queries to embedded structs which represent foreign key hierarchy. (but in case of Go it's kinda class hierarchy which is reversed to foreign keys) 5) You should have you database schema normalized. It is not only good from SQL point of view, it also gives you a side effect: you more likely don't have ambiguous struct field names in Go as representing normalized schema with structs you will have only unique fields (except maybe ID for which see below) 6) In case of ambiguous fields you can name them differently in Go (e.g. change ID to PID for Person struct and change it in SQL schema accordingly) OR 7) You may use struct tag `db:"pid"` for the same ID field in Person struct (which is included in my case in almost all structs representing humans). In such case you need to use `AS` in SQL queries. Like this: `SELECT id as pid from persons WHERE...` What is even more pleasant is if you do have ambiguous struct fields (with the same name at whatever level of embedded structs) and all of them already have values sqlx will set ambiguous column value from SQL query to that field in Go which don't have a value yet. But it will more likely be a rare case so i think you should use #6 or #7 anyway.
Absolutely. I have been playing around with [ClickHouse](https://clickhouse.yandex/) for the past couple of weeks and building a dashboard for business users with [Superset](https://github.com/airbnb/superset). Its extremely simple to reason about and can handle large datasets quite easily. I would definitely recommend clickhouse for your analytical needs.
Many languages have "lang" as a suffix on the end of the domain. "Golang" is a useful way to search, but the language is indeed just called "Go". Notice they call it "Go" everywhere on the site's homepage: http://i.imgur.com/0TKrHdH.png E: Examples of other languages that do that with the domain in no particular order: * http://scala-lang.org/ * https://www.rust-lang.org/ * http://elm-lang.org/ * https://elixir-lang.org/ * https://www.ruby-lang.org/ * https://kotlinlang.org/ * http://groovy-lang.org/ Yet you would never call any of those languages "&lt;language&gt;-lang" - it's the same story in Go. Go is just an unfortunately short name - but like I said, "Golang" is more for searching, or tagging things with so people can find it. You might tag a Go repository on Github with "Golang", but you would say in your README "made with Go".
Thanks for sharing! Slides are almost unreadable, though :/
Awesome! Great explanation, thank you.
I have collected some links here: https://github.com/gophersgang/go-non-trivial-apps You might find something interesting for you. 
Love your enthusiasm, but this stinks out loud.
That's the last thing I'd recommend. It's a really gnarly codebase and build infrastructure. Besides, OP is looking for _web_ golang projects. OP: [koding/kite](https://github.com/koding/kite) comes to mind. 
Want me to give you access to the code used in my course (usegolang.com)? I could do that for free when it is 100% complete (plan to open source anyway). It is designed to go with the book so some decisions won't make as much sense without that context and the code will evolve over time but it should help you figure things out and give you some ideas. Just email me your gitlab (not GitHub) username - jon@calhoun.io
Actually this is something I am working on as well. How I am going to go about this is first create a basic contract, something that just moves tokens around, then see if I can start interfacing with it via a geth node. Im just figuring out what I dont know on the way and doing research on it. Ive read through the geth documentation and am currently downloading the testnet so im not paying anything. I dont now of any specific resources but I am wishing you all the luck!
Gotcha, sounds solid. I've used exec a bunch for a bunch of XML garbage in the past it "just works." 
This is why he's asking. See your site: "2017-06-01 Beta 1 issued" That date is 2 weeks ago, so your chart doesn't answer his question but is instead why he's asking. Thanks though--it's certainly a great chart when there isn't deviation from the plan.
Sure have. There's a lot that can be done with the native net/http package but I've been using [goa](https://goa.design/) a lot and I really like it. You use their DSL to define your inputs and outputs and goa generates interfaces/bootstrap logic and stubs out handlers. It's marketed as a microservice architecture but I use it at work for both microservices and our web API
So I used to work for a company that would run image processing algorithms in real-time on some embedded hardware. The hardware team would have to take matlab algorithms and implement them in VHDL. Is this something that would be suitable for embedded, real-time systems? Might save some of my friends a lot of work. I take it that this is more for running on cloud based FPGAs.
&gt; there are no side effects, just effects that result from our flawed understanding of the system ugh..."side-effects" are not just a state-of-mind, they are are real thing and Go allows them. if your function mutates the state of something outside of its scope other than its return values, there are side-effects
I knew why he was asking, that's why I pointed out the links instead of the schedule. Anyway, I adjusted the copy to indicate the release schedule is what is planned. Sadly I don't know when things will be released. If I did I would share :) I could probably do some predictive work like I did for https://pocketgophers.com/when-should-you-upgrade-go/, but I don't know that its worth the effort.
Agree, though we are working in it. Kubernetes pushes the limits of what Go's build and tools can handle well.
Some context: The article was meant to be primarily about mental models and then morphed a bit into a Go vs Java piece, neglecting actual code examples. Will do better next time.
&gt; Don't you find you're fighting a losing battle with Go No, not really. Go is pretty good for modeling how I think. Go might have opinions, but they are, to me, just correct opinions or about stuff I don't really care about :) Whenever I do disagree with things, they are usually pretty minor details that are easy to ignore or work around. It's not perfect, but it's the best I've seen so far.
I guess at 26 I'm the winner so far
I'm not really getting the "for DevOps" bit.
They have web app examples in the standard library?
For the record, regular expression on parameter is now possible.
Also interested in this. Only just started with Go - happy to see its seemingly large presence in the development of blockchain-related applications. So is the general idea that you build a smart contract with Solidity and then use go-ethereum to build the DApp that uses the smart contract? On a side note, while I was looking into some of this stuff I tried using Mist but had issues downloading the full Ethereum blockchain. Is this even necessary to start messing about with testnet? 
Concurrency, not parallelism. From the start, Node was big on "non-blocking IO" which essentially meant you passed in a callback that would get fired at some point later on. Then came promises, and so on. This way it could handle multiple requests concurrently, though it seems to be, even now, limited to one core per Node process. To your other question, I certainly didn't have more than one core 15 years ago. I had a Pentium 4 with hyper-threading, but almost nothing was made to utilize it.
Awesome!
Thanks Golang team, you make every release something to celebrate!
Type aliases!
Wouldn't that be considered a regression? In which case https://golang.org/issue/new?
Code generation is nice, but only under two conditions: 1. It happens automatically on compile time (like in any other language - C, C++, or Java) 2. It can interact properly with language tools (such as vi-go or VSCode's go plugin).
You ended the article with saying how you miss using Go daily. Why don't you now? I introduced Go into every project that I worked on and could benefit it.
Nobody worked on it for 1.9 so it's not going to be there. As for 1.10,same issue 
I have a hard time considering a project serious with ZERO test...
https://dave.cheney.net/2016/10/25/introducing-go-2-0
echo is great, how to connect with mysql, write raw sql query?
&gt; But there is equally no question that adding these features to Go would make it more complex. Yes, there is. Many people just repeat over and over that generics increase complexity. In many cases, it is true. One thing is that generics increase _compiler_ complexity (and compilation time). Another thing is that some people like to go nuts on generics and create types that are needlessly general (although this can in many cases be alleviated by sane defaults, aliases and whatnot). On the other hand, quite often generics actually make things _simpler_. Consider the built-int Go `map` type (which is generic) versus the new [`sync.map`](https://godoc.org/golang.org/x/sync/syncmap), which uses `interface{}`. I'd like to posit that the generic one is _much_ easier to use, not to mention it's safer in terms of runtime errors. If generics are teamed up with type inferrence, things can get even simpler. In some other languages (which I would like to avoid mentioning as I don't want to start a flamewar) you can use generic functions and types without even knowing they are generic half the time because the types are inferred for you. But of course OTOH you still need to understand generics at least on some basic level when reading documentation (and more so when creating custom generic types). But then again, Go documentation _already_ involves generic types and people seem to be just fine with that. And so while this whole _"Generics make languages more complex, mmkay"_ meme is based on some truth, I definitely don't like it being accepted unconditionally without any thought like in this blog. 
&gt;not putting *_test.go in your gitignore in C U R R E N T Y E A R to tease the noobs Weak
I want to thank you all for supporting me. All orders so far have been dealt with and should take 7-10 days to arrive. Contact me if there are any issues. Also, let me know what you think about it when you have it. And, please do share if you take some cool photos with it. :)
&gt; In my free time I work on a library to generate code from an AST rather then the string writing approach You may be interested by https://github.com/dave/jennifer
You should use [sqlx](https://github.com/jmoiron/sqlx) for that. This would be a [short example of using sqlx to query a mysql database](https://github.com/titpetric/books/blob/master/api-foundations/chapter6b/main_sqlx.go) from my book [API Foundations in Go](https://leanpub.com/api-foundations). You can check other samples from the book in the github repo.
To add to this, Python had event-driven APIs (like Twisted) since nearly forever, and certainly longer than Node.js's around. Node.js didn't bring any new tech, just a new attitude that sold the approach to devs better.
Does it do any string replacement in the templates? Let's say I have a default structure of my projects and want my import paths to be automatically set to the name of the new project. Right now I do a recursive grep |xargs sed -i thing but would like something a bit better.
Currently, the template directories are simply copied. For the first release I will integrate go templates, to insert the project name, creation date etc into the project files. Also tab completion for the template names will be added via the bash-completion package. Cheers
##QUIC QUIC (Quick UDP Internet Connections, pronounced quick) is an experimental transport layer network protocol designed by Jim Roskind at Google, initially implemented in 2012, and announced publicly in 2013 as experimentation broadened. QUIC supports a set of multiplexed connections between two endpoints over User Datagram Protocol (UDP), and was designed to provide security protection equivalent to TLS/SSL, along with reduced connection and transport latency, and bandwidth estimation in each direction to avoid congestion. QUIC's main goal is to improve perceived performance of connection-oriented web applications that are currently using TCP. It also provides a venue for rapid iteration of congestion avoidance algorithms, placing control into application space at both endpoints, rather than (the relatively slow to evolve) kernel space. In June 2015, an Internet Draft of a specification for QUIC was submitted to the IETF for standardization. A QUIC working group was established in 2016.The QUIC working group foresees multipath support and optional forward error correction (FEC) as the next step. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/golang/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^] ^Downvote ^to ^remove ^| ^v0.2
&gt; Second you don't have to wait until runtime to find out you were using an incompatible dependency. That wasn't really an issue. The Py3 clusterfuck was primarily due to Py3 breaking almost all existing code while *giving you nothing in return*. There was essentially zero benefit to rewriting working Py2 for Py3, and the core devs even deliberately broke Py3 for a whole class of tasks by removing the bytestring APIs instead of just flipping the default to Unicode. They even managed to miss the UTF8-everywhere boat, and Py3 still defaults to ASCII, which is why is explodes so often. \*_shakes head_\* 
Node does have a much faster VM than Python, offers the ability to run the same language on the backend as on the frontend, and I dare say the event-driven model is more familiar to JavaScript devs than most Python coders. Callback hell isn't half as hellish when your language supports anonymous functions. Also, Twisted has always been extremely difficult to get into thanks to its idiosyncratic terminology and documentation that (even after 15 years) still does a truly rotten job of explaining how to use it. 
&gt; One thing is that generics increase compiler complexity (and compilation time). I've always argued that a dumb, mechanical template implementation (simplistically: compiler-aided code generation) would be in sync with Go's "philosophy" against magic and deep abstractions. My point: it would not even have a big complexity impact on the compiler. So far I've never gotten a good counter-argument. Can anybody tell me why this could not be a good idea?
I don't know whether it's a good idea or not. From what I can tell, the downsides would be that the compiler would have to generate an implementation from the template for every type, which would probably bring in a very small performance penalty, but will increase the already large binary size, and would probably make stack traces unreadable, unless they do some kind of magic like for the inlining stuff.
I hate the fact that the whole discussion seems to focus on Generics... In the next few years memory safety and ownership semantics is the thing that will matter more and more. Maybe not to you specifically, but to the guy who is going to build that great next library you will be using and loving. I mean, just look at language like Rust, at the newest C++ standards and at any popular new JVM language (Scala, Groovy, Kotlin ...etc). A big part of what they promise is memory safety and better understanding of ownership... and those features are amazing because they are mainly compile time, there's no extra code involved whatsoever. Making the distinction between mutable and immutable variable can be free in terms of generated code, just warnings at compile time if you break the contract and try to mutate the immutable. Borrow checking and thread access analysis is free, its just the compiler looking at how and when a data structure is accessed and warning you against undefined behavior. Why are those things not in golang ? I do not know... especially since go has some good ideas about pass by value vs pass by reference and communication using messages... these kind of compilers check would literally enforce the writing of good go code. If go took the rust approach and made variables constant by default (with the mut keyword to mutate) it would probably take a day of refactoring to get a quality go codebase compiling with 2.0. And another thing, why the fuck are there no garbage collected atomic pointers o&gt;O ? Like, what year do we live in currently ? Every other language that I can think of that's worth a damn has an atomic wrapper over its pointer (or the equivalent to pointers) ?... it wouldn't be rocket-science to implement that, I'm quite sure, unsafe atomic pointers work just fine. ...... Also, to showcase my point about what I mean when i say go needs memory safety and mutability&amp;immutability semantics, lets look at the following function signature: func append(slice []Type, elems ...Type) []Type (coincidentally this is black magic rather than a function because it can't be user written without generics) Now, we know that append modified the memory of the underlying slice, sometimes... other time it just reallocates the whole thing in a new block. But what does an outsider to the language know ? He may well see that append returns a "new slice" and take that to mean the whole thing has been reallocated and the new slice is still there. Here's a better signature for that method: func append(slice mut []Type, elems ...const Type) []Type Suddenly we know that the function will modify the slice and that it will not mess around with any of the value pointed to inside the appendes we pass. This involves no extra code and is quite easy to comperhand. Even better we could add compiler warnings if the user tries to access "slice" afterward, we could even "delete" the original slice and invalidate the variable once append is called... all sort of compile time magic to save years of debugging. ... How hard would this be to implement ? I don't know, I don't build compilers, but from a programmers perspective this is very helpful.
You wouldnt really use a tool that can nuke your system, if the only guarantee you have is: it didnt blow up just yet. 
Title says it all really - I accidentally d-clicked a go file and this popped up: so TIL! edit spelling
FYI not 100% sure if you know this yet, but you can use range to iterate any type with an underlying irritable type. For example: type T []string for index, value := range T{"foo", ..} { ... } type T map[string]int // etc I only mention this because wanting a "range" anything construct is usually something that exposes itself to users as a side effect of being new to the language. Like creating a container object struct with a set of children inside it rather than a type SliceT []T That said here's a tip for your implementation, rather than start a goroutine make(chan int, N) where n is your total iteration count and then prefill it with your values and close it before returning it. You already understand why you shouldn't, sharing just to illustrate language feature to you. Happy coding.
&gt; Isn't this arguably what they did Not really. It's significantly more difficult to work with bytestrings in Py3 than with Unicode in Py2. The interpreter does all this "magic" decoding for you, but it doesn't give you the tools to undo it when you need to or it has fucked up. When they can't decode input, several APIs silently hand you `str` objects that aren't real Unicode. They contain surrogate escapes, and your program will die in flames if you try to encode one. These strings are not marked in any way, nor is there (usually) any way to get the original bytes that the API has mangled. Thanks to all this one-way magic, if you want to write a program that plays nice with other command-line programs, like `grep` or `find`, on Linux (where filenames are explicitly bytes), Py3 fights you all the way. &gt; This is not true. Yes, it is. If no locale is set, such as when launching a program via `cron`, `launchd` etc., Python 3 defaults to ASCII: $ env -i /usr/local/bin/python3 Python 3.6.1 (default, May 15 2017, 23:04:45) [GCC 4.2.1 Compatible Apple LLVM 8.0.0 (clang-800.0.42.1)] on darwin Type "help", "copyright", "credits" or "license" for more information. &gt;&gt;&gt; import sys &gt;&gt;&gt; sys.stdout.encoding 'US-ASCII' UTF-8 *has* to be a better choice in that situation in 2017, but Python 3 is still somehow stuck in 1990. It also dies in flames if you try to run a program via `ssh` on a server that doesn't support the locale on your *local* machine. In Python 2, encoding is something you have to worry about while *writing* a program. In Python 3, it's something you have to worry about while *running* it. In this sense, Python 3 increases developer-friendliness at the expense of user-friendliness. I think that is a terrible trade-off. 
&gt; I don't really care much about the "same language" thing. Especially as it is JS. I know what you mean—especially the JS aspect—but it is damn handy being able to run the same libraries and code on the server and client. No need to write one validation library for the browser and another for your backend. And then keep them in sync.
I was trying to show that you could use a buffered channel to avoid starting a Goroutine for.. a loop iteration, i.e.: ch := make(chan int, (stop-start+((stop-start)%step))/step) // fill ch with same loops before returning close(ch) Now you won't leak a goroutine if you break early and it will be around 4x as fast I imagine and you keep an identical API. It does't work well when the size is "infinite".. but lets be real, why on earth would you not type: maybethisisinfinitelol := 200000000 for n := range IntRange(maybethisisinfinitelol, 0, -1) { for n := maybethisisinfinitelol; n &gt; 0; n-- { ... } Gains: * more characters! * 1000x slower (rough guess) * leaks go routines
interesting, no one complained about my library not having tests ( ͡° ͜ʖ ͡°)
Cool, I like the emphasis on participation.
I'm not sure if I'm missing something but why some functions has an underscore in the name?
Nice one! I was inspired to do something similar a while ago after seeing a post on writing a userspace tcp/ip impl. I got as far as being able to respond to arping (although no vlan tag support), in rust https://github.com/rthomas/rust_net (it is rough code...) - unfortunately work and travel have sapped any momentum I had.
We're building an engine on top of [exp/shiny](https://godoc.org/golang.org/x/exp/shiny/screen).
&gt; Many people just repeat over and over that generics increase complexity. In many cases, it is true. One thing is that generics increase compiler complexity (and compilation time). Another thing is that some people like to go nuts on generics and create types that are needlessly general (although this can in many cases be alleviated by sane defaults, aliases and whatnot). Let's not forget the extra cognitive load adding any new feature to a language brings, especially something like generics that must combine nicely with all the other features of the language (or create a big chunk of corner cases that you have to keep in mind whenever you're programming).
&gt; We're building an engine on top of exp/shiny. I'd be very interested to see that. Is it open source?
What part of it do you want to see? This is a particle demo application that I wrote recently: [code](https://github.com/200sc/particle-demo/blob/master/demo.go), [gif](http://imgur.com/a/M1CVa#1HBCljq) This is a text demo: [code](https://github.com/200sc/rainbow-text/blob/master/core.go), [gif](http://imgur.com/a/a3uKt) There's a much larger application with available binaries [here](https://github.com/200sc/go-compgeo/tree/master/demo), but the version of oak being used there is a few months old (there's only one severe bug fixed since then, in that the engine might be cripplingly slow on machines with less than 5 cores) and even the binaries in the package are not up to date with the rest of the package: A game (with binaries) [here](https://bitbucket.org/StephenPatrick/cliffracers/overview), even older than the last demo [Flappy bird](https://gist.github.com/200sc/707ea930a718930499d176fd55ffc6d8) [Pong](https://gist.github.com/200sc/6c8e9c1c79f0157bbe6c183164065d22) (very old) 
Another interesting project - going to have a nose at that one. Thanks!
Sad, I guess. There's no one really maintaining shiny and no one's using it on windows, so there's been a number of bugs we've run into that we had to raise issues to fix, and it looks like the recent work into shiny hasn't been, say, adding full-screen support or window scaling options or basic window management features but instead work with flex boxes. Shiny also has it's coordinates completely flipped from what makes sense (quadrant 4 is negative x, negative y), so to draw anything in shiny you need to convert all x and y values to be negative, which is confusing
I have written a number of apps with backend API's with it yes. According to me it is the easiest to understand and most powerful one between itself, React and Angular. See their skeleton app here: https://github.com/aurelia/skeleton-navigationi would recommend the "skeleton-typescript-webpack" option. 
I'm not OP, but I've used both and both work fine.
Personally I don't agree. When Im programming I find I have to think about the best way to achieve things in a given language, and if that language has a large surface area that I need to consider it can make programming more fiddly.
It's only a step or two from here to an MPLS implementation...
I know enough to say that Meteor is a full stack framework, allowing developers to use same langage (Javascript) and codebase for back-end and front-end. It stores data in a Mongo database, synchronized in frontend with a minimongo. This way, you can code the data saving in front-end, in a [reactive](https://en.wikipedia.org/wiki/Reactive_programming) way, and it will be synchronized to the backend afterwards. It's a nice choice if you want an all-in-one package, but not the right one if you wanted to create your backend in Go. Besides, I'm not a Meteor expert at all, but it's fairly possible that this kind of application is not easily scalable. 
Ok Nostradamus
My recommendation is to stay native and use Web Components. A great library to help with creating them is [Polymer](https://www.polymer-project.org/). I think Polymer is very close to the mantra of Go as it is a library (not a framework). It attempts to use web standards everywhere and become smaller and smaller as browsers implement more of the specs. The idea is to stay native to the browser and use the platform as much as possible. The tooling is also great as they have created a command line tool that includes building, linting and testing so everything is pretty much streamlined like when you are working with the Go tool. There's also official plugins for vscode and Atom that provide you autocomplete, viewing docs and jumping to definitions. Recent success story: [All McDonald's menus in US are made with Polymer.](https://twitter.com/AJStacy06/status/857628546507968512) Recent talk from Google IO 2017: https://www.youtube.com/watch?v=cuoZenpQveQ
SECTION | CONTENT :--|:-- Title | Future, Faster: Unlock the Power of Web Components with Polymer (Google I/O '17) Description | It took a few years and a couple of trips around the block, but Web Components have truly arrived: they’re natively supported in Chrome and Safari today, with other browsers joining the party soon. Polymer is still the most popular way to build your own Web Components. Polymer 2.0 has been updated to the final v1 Web Components specs, getting leaner, faster and more modular along the way – and offering a seamless upgrade path from Polymer 1. In this session, you will learn how Web Components and... Length | 0:43:04 **** ^(I am a bot, this is an auto-generated reply | )^[Info](https://www.reddit.com/u/video_descriptionbot) ^| ^[Feedback](https://www.reddit.com/message/compose/?to=video_descriptionbot&amp;subject=Feedback) ^| ^(Reply STOP to opt out permanently)
If you are trying to create a shop check this out https://www.polymer-project.org/2.0/toolbox/case-study
&gt; https://echo.labstack.com/ Does it not bug you the router doesn't use http.HandlerFunc? 
&gt; I'm not sure if I'm missing something but why some functions has an underscore in the name? _XXX is provided from Windows APIs named as XXX. And I don't want to make it public.
I like this blog post I wrote: https://blog.carlmjohnson.net/post/share-memory-by-communicating/ To boil it down, try to keep your variables local to one goroutine where practical. Don't be afraid to have a single "dispatcher" routine that handles coordinating work among a number of workers that are essentially synchronous. The async comes from the coordination, not the workers themselves. 
Here's the beginning of how I would write an expiring cache: https://play.golang.org/p/-2ArLCGvW4 There's a bit of hand waving in there, but it does compile and hopefully you can see how I mean for it to work. Basically, if there's one big for loop with a select statement in it that controls everything concurrent, that makes it really easy to reason about who is doing what when and prevent race conditions etc.
What was the reason to bring back type aliases after cancelling them a few releases ago? What changed between now and then? Not shitting on the feature, I'm just wondering.
jQuery is the best in the sense that its future releases aren't like to introduce severe breaking changes (unlike most modern JS frameworks).
&gt; which name servers are snitching on you That would benefit from some explanation.
Hmm, it looks cool, but I'm not convinced it's better than a mutex. :-) What does the loop of closures buy you in terms of code clarity that you couldn't get by just grabbing a lock?
I'd rather ditch the plugins altogether.
Another vote for Vue here, though they actually recommend axios for making requests now.
For one you follow the open-closed principle: the system is open to extensions, but closed to modifications (loop func).
I'll have to check it out. I just know vue-resource worked for me, but it's so simple, it can't be hard to replace if there's something better. edit: oh nice the api is pretty much the same
Docker and Syncthing.
What do I do with the random DNS name? Grab it, perform a DNS lookup and then wait and see if anyone else also looks it up? 
They really wanted them in 
Hello I would recommend you to read those articles/projets on clean/hexagonal architecture before implementing any projects :) http://manuel.kiessling.net/2012/09/28/applying-the-clean-architecture-to-go-applications/ https://github.com/CaptainCodeman/clean-go https://geeks.uniplaces.com/putting-clean-architecture-into-practice-20c47d8c76de
What's the advantage over simply using an online calendar? I heavily use one already anyway to manage my life.
"Share memory by communicating" is not a good description for the functionalities of channels. "Transfer value ownership" is a better one.
While one can learn a lot from the clean architecture, the implementation in those articles is full of Go anti-patterns so be careful.
I usually follow these patterns when interacting with third party apis: https://github.com/google/go-github
&gt;You can access memory with undefined contents via a variable which previously represented memory with well-defined contents How? &gt;you can create undefined behavior (quite easily) by accessing memory from different gorutines out of which one is a write Race conditions isn't memory safety. No one will deny that Go programs aren't guaranteed to not race. &gt;What exactly is that niche though A faster Python or (node.)JS (neither of which, by the way, have any type safety built in.) &gt;how exactly do generics affect program runtime negatively It affects compilation time and/or program size. 
That seems like a decent way to do it. You should use tabs for your Makefile. Another way to approach it is to write the templates as multiline strings in the first place. Just a couple of lines of Go and they're wrapped in variables and available from your package.
Definitely, definitely, definitely not Docker.
good eye - thanks man 
It's not exposed in my example or the article, but running close() on a channel will stop the range loop: https://gobyexample.com/range-over-channels
To be honest, while the compilation speed is much much better than, say, C++, I'm still waiting quite a while when a number of packages must be build.
You get a parking ticket when a street sweeper comes around? :'-D
Likely the best reference, for most of your requirements (besides the RDBMS stuff) is https://github.com/go-kit/kit
it's a quote from [effective go](https://golang.org/doc/effective_go.html#sharing). What they describe there is what you are describing as well.
Well, I'm guessing that a project with 4+ years of development will be overwhelming for anyone :D
It's a thought experiment.
Did you benchmark the mutex? Unless your application is handling hundreds of thousands of users per second I doubt locking will have a measurable impact on performance. If it has any impact, you can switch to a RWLock which should avoid blocking most of the time in your case. If this has a real impact on performance that matters, then you can consider lockless data structures, rather than just shrugging and not worrying about it.
Yes but sending on a closed channel will also panics. I guess you have to state that any call to the methods after a close will do.
I saw we had another Go room in stackoverflow, but it has been frozen due to inactivity. Don't you/we like to share and learn more stuff together? 
Yes. And in 1.9, you can use sync.map
I'd use defer m.(R)Unlock() myself. Some things might be optimized away by the compiler, but if you're just returning `v` from get, you might want to return just `return m.M[key];` ie: m.RLock() defer m.RUnlock() return m.M[key]; Also, is there even some point in using Mutex over RWMutex? Was RWMutex introduced later in the stdlib and this aims at some sort of early-go compatibility?
What would you be trading the correctness for? In most cases it's going to be more fun to write the couple of lines of code that locks the map/user while modifying it than to find than debugging a rare data race and cleaning up in the aftermath.
Trusty old vim hasn't let me down yet :)
Hey I'm the author of https://github.com/fern4lvarez/piladb, a humble Go project that I've been running for more an a year. I think it's a complete, yet simple piece of code that addresses many of your interests. It's easy to read, well modulated, with 100% of tests coverage and more or less well documented. If you have any question, please ask!
Seconding VS Code. It has great integration with the Go toolchain, and I haven't missed Atom even a little since switching about a year ago.
Maybe I should've added that the only time data is being written to the map, is when it's read from that database. The rest of the time, it's just read. So it just seemed unnecessary to add all that protection.
It just seems confusing; For example, do I add a lock before a for range loop? It seems like a hassle for some data where the only thing that could go wrong, is some information may be a few minutes out of data that is used from cache. I started implimenting it to my code, but there were many situations where I wasn't sure if I should add a lock or not, and if I should add a lock to the whole map, along with a lock for each value of it.
That's a good question. Right now the only advantage is text message reminders. Google calendar no longer has text message reminders on free accounts (as far as I can tell). If you have a smart phone, you can get push alerts. But some people don't have a smart phone (yes, it still happens), or don't have much data. I realize that's a pretty limited advantage, though It actually helps me (I don't have a smart phone). In the future I'm hoping there will be more advantages.
it works fine for me
yep, sucks. I've gotten a few hundred dollars in street sweeping tickets over the last 2 years
I switched to VS Code temporary, but now it might be permanent. It seems very good indeed!
Not sure why anyone would use Iris at this point, especially when there are alternatives around that accomplish the same thing without all of the crazy shenanigans, like my [ABCWeb](https://github.com/volatiletech/abcweb) project or [Buffalo](https://github.com/gobuffalo/buffalo). I'm not seeing any features that Iris has that these other frameworks don't have (only gave it a quick scan though).
Nice, so first he rewrites git history to make it look like he's the only contributor, then he sells it. Guess that was his plan all along.
Lol... that guy was something else
I have had absolutely zero problems with Atom, though I do a lot of work with Go in vim, so maybe I just haven't been using it with the language enough. I pretty much use Atom for all of my normal development with Python/Django though, and I love it. I have seen nothing but good recommendations for VS Code though, so I might have to give it a shot.
I haven't tried writing Go in Atom, but Atom does keep appearing to leak memory while I'm editing HTML+Javascript. I used Sublime for a little while which seemed alright. If you're comfortable with vim, give the vim-go plugin with neosnippets a try
&gt; It just seems confusing; For example, do I add a lock before a for range loop? Yes, if the application be mutating the data in the map or the map itself from another thread while you are ranging, you should. &gt; It seems like a hassle for some data where the only thing that could go wrong, is some information may be a few minutes out of data that is used from cache. It seems that you've fundamentally misunderstood the concept of a data race. Your data being out of date has nothing to do with the data race. Data races occur when two or more threads try to perform conflicting operations on data at the same time. For example, one thread could read the data while another is writing, meaning you can never be sure that the data is complete or consistent and read time. The worst case is not that your data is out of date, it's that your data is corrupt. You should always consider your data to be in an undefined state when you have a potential for data races. &gt; I started implimenting it to my code, but there were many situations where I wasn't sure if I should add a lock or not, and if I should add a lock to the whole map, along with a lock for each value of it. Add locks (or your preferred synchronization primitive) for any data that may otherwise be accessed simultaneously from more than one thread, where at least one of the threads could be mutating the data. If you know that to be true, it shouldn't be a question whether you should address the problem.
Don't you like using 500MB RAM for 5KB file editing?
&gt; &gt; I started implimenting it to my code, but there were many situations where I wasn't sure if I should add a lock or not, and if I should add a lock to the whole map, along with a lock for each value of it. &gt; Add locks (or your preferred synchronization primitive) for any data that may otherwise be accessed simultaneously from more than one thread, where at least one of the threads could be mutating the data. If you know that to be true, it shouldn't be a question whether you should address the problem. Thanks for all the info. If I have something like the following: type user struct { sync.Mutex Username string } var users = make(map[int]*user) and I want to range over each user, should I make a new mutex for the whole of the users map (var usersMutex sync.Mutex)? Or should I just lock each individual user within the map as I loop? for id, u := range users { u.Lock() // ... u.Unlock() } or var usersMutex sync.Mutex usersMutex.Lock() for id, u := range users { u.Lock() // ... u.Unlock() } usersMutex.Unlock() Example one (locking only each individual map value)? or Example two (locking the whole map, along with each individual map value)?
You could probably set something very similar up for yourself fairly trivially with AWS SNS and lambda triggers.
I all not really sure what's up here. Are you hiring? Or something else?
Check out Todd McLeod. He has great YouTube videos and $15 course on Udemy : https://github.com/GoesToEleven?tab=repositories 
Exactly. I'm pretty disappointed.
Just apply the same logic to the map. While one or more threads are ranging over it, could some other thread be mutating it, for example by adding or removing a value or replacing one of the values (in this case, user pointers)? You described a case where the user is missing from the map altogether, in which case it is retrieved from a database and added to the map. If that could possibly happen while you are ranging, #2 is the correct way to go about it.
Class act. Sorry, Type act. 
&gt; ABCWeb and Buffalo are Bootstraper Projects. Go-speedo is a basic web-framework beneath including Router, Template and some more convenient features. Not true, both ABCWeb and Buffalo have most (if not all) of the features that Iris has. &gt; Iris (or now Go-Speedo) has a very low latency and has a higher throughput than many other frameworks. Seems like a vague and unfounded assertion to be honest. Not to mention that I see no benchmarks on the Iris project and I find it hard to believe that Iris would bench better than ABCWeb because ABCWeb uses some of the fastest packages in the ecosystem (SQLBoiler, Chi, Zap, etc). Not sure how Buffalo benches, but again, I see no Iris benchmarks anyway.
You know you can lock onto one OS thread right? Nah just kidding, I bet you didn't know, because that would have been useful to you and you wouldn't be able to bash Go then :)
Exactly! Moreover, godofdream(aka [msowka-ninja](https://github.com/ACQUIRED-BY-DUBAI-BASED-TECH-COMPANY/go-template/issues/11)) has only iris-related contributions. What I can smell is called schizophrenia...
Awesome, this really helped me, thanks heaps!
Check staffjoy code at https://github.com/Staffjoy/v2 It is microservices architecture. 
Wouldn't that make the second time the author has done this? I seem to recall another post here a few weeks back that was very similar (can't find it now though) and the general consensus was that the "new maintainer" was once again the original author.
If you look at his profile, kataras works for Docker, Inc. now... http://i.imgur.com/sUDieKr.png think what you want of it :)
Yeah by a company named, ACQUIRED-BY-DUBAI-BASED-TECH-COMPANY. Sounds pretty legit.
You might also want to look at VueJS: https://vuejs.org
Yes I'm dissapointed too and I hope I can revive the project under a new name. That's why go-speedo is an organisation account. I hope more people gather together.
Lol, you can put anything in that field, it's meaningless.
&gt; race conditions means threads accessing memory at the same time whilst one or more of those threads have the intention to modify it. Tiny note, this is a *data race*, which is a special kind of race condition. Not all race conditions are memory unsafe; but data races are.
I like the logo you propose ;-) Yes It's the first time I created a reddit account. Please be patient.
I'm on Mac or Ubuntu mainly, so I'll have to give it a shot. 
It seems like midstack inlining is being released in a limited form under the "-l=4" compiler flag for 1.9. "The initial implementation goal is to make all tests pass with -l=4. We will then focus on bringing tools and DWARF information up-to-date with mid-stack inlining. Once this support is complete, we plan to make -l=4 the default setting [for go 1.10]." "CLs that add inlining info and fix stack traces have been merged into master. CLs that fix runtime.Callers are under submission." https://github.com/golang/proposal/blob/master/design/19348-midstack-inlining.md https://github.com/golang/go/issues/19348
Is kataras some evil warlord among go devs? Another scheme? This sounds like some mystery
I use it for about a year, works fine for me. Used Vim for many years before this, now I use them 50/50.
When I first opened a go file in vscode it automatically suggested and installed all the required extensions (1st Wow) .Then when I was using some go package in the code, it automatically inserted the *import* statement and ...I was instantly in love. It's looks as clean as sublime (with a minimap ;)) but has ide features. My fav is the integrated terminal.
The 2nd part I have in Atom and Vim both (auto insert imports).
I got so fed up with Atom that I switched to VS Code for Go development. Neither is perfect, but Atom is so slow it's painful, and it crashes regularly. VS Code also has much better Go debugger integration. I would recommend turning off Go reference counts in CodeLens; there's an open defect right now because it eats the CPU alive if it's on.
I tried Atom for a month or so as an alternative to Sublime, and found it too slow and buggy for my taste. A colleague tried it on Windows and it crashed. Atom is better now, but I haven't looked back. Doing web development and some minor Go projects in VS Code now, and I'm loving it. It's the best editor around. Sublime comes second, and Atom doesn't really rate high enough with me for me to pick it up again. 
In my opinion, articles about http.Handler overrides should generally try to point out that A: this is called the decorator pattern and B: there is nothing special about http.Handler, you can do this with any interface. Though it is easier with one-method ones. If you are an experienced developer, this may seem obvious to you, but in my experience this is exactly the sort of generalization that a younger developer needs to ensure that they get a deeper understanding.
https://youtu.be/L0MK7qz13bU
You'd better use gofmt to improve readability. Now it's just a nightmare...
I always wanted to work on the moon researching facility. Now I can say that and my GitHub account will support that. 
I added some complex128 and pulled the julia function out. https://gist.github.com/Redundancy/a32df6a6c03304e06259ff09310ab6ed I can't promise that it's correct or faster, but it feels a little easier to read to me. YMMV
No, they're advertising their agency.
Careful using channels as mutex, though (don't) -- you can introduce less obvious data races, namely, making atomic operations non-atomic, even if there's not technically a "memory race".
Huh. TIL. I'll be sure to do that with code I share in the future.
Both have their use cases
yeah you are probably right.
Not really. Calling him evil warlord is giving him way too much credit. Calling him a go dev is [an offence to all other legitimate Go devs](http://www.florinpatan.ro/2016/10/why-you-should-not-use-iris-for-your-go.html).
Use the standard tooling like [gofmt and go lint](https://goreportcard.com/report/github.com/mz2212/go-julia). Also [write tests](http://gocover.io/github.com/mz2212/go-julia/hsvrgb). There's standard tooling for [test coverage](https://blog.golang.org/cover) as well.
If you find yourself sprinkling locks and unlocks everywhere, consider encapsulating that logic inside a getter and setter. You can avoid the non-type safe atomic map in Go 1.9 and just have a UserContainer that is composed of a map of users and a mutex. Then you would have UserContainer.Update(...) or .Get() or whatever operations you need. In those functions, you would use UserContainer.mutex.Lock() and defer UserContainer.mutex.Unlock().
kubernetes is probably the most well written large project I've seen https://github.com/kubernetes/kubernetes/tree/master/pkg
It's worthwhile setting up a trigger to run `gofmt` whenever you save a .go file, it's a pretty common practice in the Go community.
I Personally just rent a VPS. hetzner.de is cheap but looks outdated, digitalocean if you want fancy stuff.. There are plenty of guides for installing psql on VPS.
This sort of thing isn't a big deal. Its just worth considering whether anything you are building could fit a standard interface.
[Heroku](https://www.heroku.com/) It's a PaaS like Google App Engine. They also have Postgres and even a free tier! You can get started [here](https://devcenter.heroku.com/articles/getting-started-with-go#introduction)
I modified your version to not use the gg package: https://gist.github.com/peterhellberg/e032fbba06fe7db42f3786252c62b23d
*You* don't need Kubernetes. Use Heroku as /u/flippeeer suggested, it's easy to use and there's a free tier.
Why the downvotes? Am I somehow stupid for not understanding how this is all supposed to work from the vague description given? 
Nice improvements
If you are an Atom user, look at the go-plus plugin https://atom.io/packages/go-plus
Who said it's "the correct approach to concurrency"? If by message passing, you mean channels, they serve different purposes than mutexes. Use channels for communicating and synchronizing the work of goroutines; use mutexes to share memory safely.
https://github.com/mz2212/go-julia/blob/master/main.go#L13 if you want them to be constants, declare as const not var and remove the const part of the names https://github.com/mz2212/go-julia/blob/master/main.go#L8 https://github.com/mz2212/go-julia/blob/master/main.go#L13-L14 https://github.com/mz2212/go-julia/blob/master/main.go#L35 I find it tougher to read with multiple var/const values being set per line, I think it would be more readable to break vars with assignments out to one per line 
See: https://blog.golang.org/share-memory-by-communicating, https://www.youtube.com/watch?v=PAAkCSZUG1c&amp;t=2m48s and https://www.youtube.com/watch?v=PAAkCSZUG1c&amp;t=4m20s for some more information on this.
Linode. Setup a Debian instance, install PostgreSQL and Go 1.8. Done.
Ah. In my defense, I'm used to Java and Ruby where that kind of stuff seems to be the norm. My bad naming the variable const instead of declaring it as such.
Anyone using Atom.io ~~as editor for Go~~ and find it constantly crashing? FTFY
If you need fast connection and a good price/quality ratio OVH is the place to go, their servers are anywhere between 3 to 10 times cheaper than do, heroku or AWS. Only downside is that their us data center are not all finished, but I assume you just need a machine to play around \w, not a couple of heavy trafic servers around the world, so that shouldn't be a problem.
No worries. It was brave of you to ask for a code review and everyone starts writing code in a new language with a style influenced by what they have used in the past. There is also a great Go community on Slack if you want to ask questions in real time. https://invite.slack.golangbridge.org/
Use channels when you need to pass information from one goroutine to another, and if you just need to hide access, mutexes or rwlocks will work just fine
Being a named return value doesn't have anything to do with that though. Go is following scoping rules when declaring a variable in a new block, the topics [example](https://play.golang.org/p/SsdRsjYj1G) is identical to [var declaration](https://play.golang.org/p/KmE1BqRczo). The fact it's declared in a different location may make it seem more confusing, but remove it and all you did is move your surprise down a line. 
Give Heroku a try. It supports latest Go versions and has a PostgreSQL DB. The prices are very competitive. 
Yes, crashes for PHP and Go, both vscode and Atom crashes constantly. Must be an Electron thing. Running Linux.
running vscode on linux, it crashes too from time to time... but seems lighter than Atom.
And thats also the underlying reason why defer is "expensive", correct :)
&gt; Will randomly affect the contents of the other slice, which I believe is undefined behavior The behavior is neither random, nor undefined. But I must admit that it looks very surprising at a first glance and can fool beginners and pros alike. So what is happening in the playground code? First, slices always have an underlying array. Two slices can happily share the same underlying array, and they can even overlap. Now why the difference between the `string` and `int` cases? This is the result of how `append()` works. `append()` adds values to the *same* array as long as the remaining capacity permits. If the capacity is reached, `append()` allocates a new, longer array, copies the old array over, and continues appending in the new array. So in the `string` case, `b = append(a, "1")` allocates a new array, wheras in the `int` case, `b = append(a, 1)` appends to the same array and the returned slice thus points to the same array as a points to. Ok, but why does `append()` behave differently in the two cases? To answer this, let's look at the internals of the slices. This modification of your playground code prints address, length, and capacity of both a and b after each slice operation. &gt; Will randomly affect the contents of the other slice, which I believe is undefined behavior The behavior is neither random, nor undefined. But I must admit that it looks very surprising at a first glance and can fool beginners and pros alike. So what is happening in the playground code? First, slices always have an underlying array. Two slices can happily share the same underlying array, and they can even overlap. Now why the difference between the `string` and `int` cases? This is the result of how `append()` works. `append()` adds values to the *same* array as long as the remaining capacity permits. If the capacity is reached, `append()` allocates a new, longer array, copies the old array over, and continues appending in the new array. https://play.golang.org/p/hFMe0tKsN9 When you run the code, you can see that after first append, string slice `a` has capacity 1, whereas the int slice `a` has a capacity of 2. Hence the second append will allocate a new array for the string slice but will happily append to the original array in the int case. So in the string case, `a` and `b` are finally using different arrays, whereas in the int case, `a` and `b` still share the same array. And that explains the different behavior. **TL;DR: Slices are more low-level than it may seem. Keep their memory model in mind when working with them, and always be aware that `append()` may or may not allocate a new array under the hood.** (Edit: emphasis)
My web app is simply storing a user's username, password, (general info), a machine's IP address and username and password and only things like this.
Neg
Use `gofmt` to fix formatting/readability, and `go vet` to point out the obvious issues. * https://golang.org/cmd/vet/ * https://golang.org/cmd/gofmt/ You can also configure Atom to use the plugins to fix formatting errors / warn about issues on save. 
You pay per instance running your app on heroku, not based on arbitrary usage calculations. 
Besides what was said by others, the channel's abstraction is a lot easier to apply without logical flaws (like deadlocks) than mutex and semaphore.
Using Atom on macOS for Go, now on 1.18 and never had any serious issues, bit of RTFM resolved things usually.
VS Code does this almost out of the box.
If you deploy using Docker, you can use Amazon Elastic Beanstalk which simplify a lot of things (HTTPS, Load balancing, etc.) It works in the free tier if you use a single instance. Amazon RDS has postgres too. We have a simple shell script which will build golang binary and scp it to the production VM (ec2 free tier).
FWIW I you are looking for a lightweight Go IDE I have been using LiteIde since Go 1.0 or 1.1. https://github.com/visualfc/liteide Its always supported syntax highlighting (selectable themes), auto-complete, and supports build, install, test, bench, vet, etc and lots of features such jump to declaration, re-factor under cursor, etc have been added. 
Yes, this is already what I use most of the time
I'm using Atom and no crashes (Windows10 on G4400/8GB/1TB). But Atom is very slow and I'd like to have function list (not mini-map).
Great video! And what about the scheduled tweeting? Does it worth a video? 
a RWLock would be better since reads are far more common than writes in your case. Using a regular lock, only one request can read from the map at any time; with a RWLock many can safely read at the same time, until your DB updater grabs the write lock, at which point readers will wait for the update to finish.
That's pretty useful!
Main use case is to enable slow refactoring in a huge codebase. You can add an alias to a type and ship it. Then slowly rename all instances where the type is used and once all places have the new type, you can remove the alias and rename the original type definition.
Using channels isn't less error prone either. Particularly for beginners and those unfamiliar with message passing paradigms. You could: - have a blocking channel and leak the goroutine - send on a closed or nil channel - close the channel non-idiomatically - do racy channel receive loops The API surface for channels is greater than that of mutexes. So _sometimes_ it's simpler to use a mutex and accurately get stuff done. &gt; A thread had an error and you want to send the to another thread, like the UI or controlling thread? Sure sounds like a message to me. Why bother with an error var that needs to get set/read with mutexes? However, this I agree +100.
I agree. Atom on Mac OS X with Go Plus is rock solid for me.
&gt; I think that we could argue here about what constitutes undefined behavior My definition of "unedfined": The result of an action is undefined if it is unpredictable, and the language specification either does not cover the topic, or explicitly says the outcome is undefined. None of these criteria applies to `append()`. But maybe we can agree to call the behavior at least surprising. &gt; Golang on the other hand has the advantage of having allowed itself breaking changes with version nr modification The Go 1 compatibility promise allows no breaking changes until Go 2 (or in extremely rare cases if an important security fix breaks existing code). And Go 2 is not yet on the horizon. So as much as immutability and ownership may benefit the language, these features will likely not appear in Go anytime soon.
&gt; I think that we could argue here about what constitutes undefined behavior My definition of "unedfined": The result of an action is undefined if it is unpredictable, and the language specification either does not cover the topic, or explicitly says the outcome is undefined. None of these criteria applies to `append()`. But maybe we can agree to call the behavior at least surprising. &gt; Golang on the other hand has the advantage of having allowed itself breaking changes with version nr modification The Go 1 compatibility promise allows no breaking changes until Go 2 (or in extremely rare cases if an important security fix breaks existing code). And Go 2 is not yet on the horizon. So as much as immutability and ownership may benefit the language, these features will likely not appear in Go anytime soon.
&gt; I think that we could argue here about what constitutes undefined behavior My definition of "unedfined": The result of an action is undefined if it is unpredictable, and the language specification either does not cover the topic, or explicitly says the outcome is undefined. None of these criteria applies to `append()`. But maybe we can agree to call the behavior at least surprising. &gt; Golang on the other hand has the advantage of having allowed itself breaking changes with version nr modification The Go 1 compatibility promise allows no breaking changes until Go 2 (or in extremely rare cases if an important security fix breaks existing code). And Go 2 is not yet on the horizon. So as much as immutability and ownership may benefit the language, these features will likely not appear in Go anytime soon.
&gt; I think that we could argue here about what constitutes undefined behavior My definition of "unedfined": The result of an action is undefined if it is unpredictable, and the language specification either does not cover the topic, or explicitly says the outcome is undefined. None of these criteria applies to `append()`. But maybe we can agree to call the behavior at least surprising. &gt; Golang on the other hand has the advantage of having allowed itself breaking changes with version nr modification The Go 1 compatibility promise allows no breaking changes until Go 2 (or in extremely rare cases if an important security fix breaks existing code). And Go 2 is not yet on the horizon. So as much as immutability and ownership may benefit the language, these features will likely not appear in Go anytime soon.
&gt; I think that we could argue here about what constitutes undefined behavior My definition of "unedfined": The result of an action is undefined if it is fundamentally unpredictable (in the sense of, "anything can happen"). If the language specification describes how a language element behaves, it is not undefined. So yes, our definitions of "undefined" clearly differ. But maybe we can agree to call the behavior of append() at least surprising. &gt; Golang on the other hand has the advantage of having allowed itself breaking changes with version nr modification The Go 1 compatibility promise allows no breaking changes until Go 2 (or in extremely rare cases if an important security fix breaks existing code). And Go 2 is not yet on the horizon. So as much as immutability and ownership may benefit the language, these features will likely not appear in Go anytime soon.
Nowadays I declare a function like this: type LogFn func(fmt string, args ...interface{}) and use that everywhere. I never use leveled logging so I have no need for the rest. With this interface consumers of my libraries can give it whatever they want, a std logger, logrus logger or anything else really as long as there's a Printf method. It has worked really well at my work, usually I define only one std logger in main and pass it around everywhere. 
Take a look at Gogland or vim-go :)
It really depends. I don't care as much about the logger itself ( logrus or log ) as much as how its used. As a project grows in size I have found that the global state ( in nates design ) can cause other packages to have external dependencies and can make the code more brittle, harder to change, and less maintainable in the long run. I prefer to pass my logger in via interfaces. Mind you that this is my opinion. TLDR I don't care about the logging implementation, just interfaces and no global state.
I do a similar thing as well. Do you do anything fancy with logging? Ie elk, oklog, or other magiks?
Does anyone know what extension he uses to replace characters in VS Code with unicode symbols? 
That is Fira Code font with Ligatures turned on.
Awesome, thank you.
Was using Atom, but certainly seem to have better performance on VSCode so using that atm...
Gogland is in beta phase right now but usable. Most of the go plugins use the same underlying tools like guru, godoc, goimports, etc. It is just a matter of preference. Personally, I use vim.
Emacs and go work great together in my experience.
Do you know what changed with the new implementation?
You could try out the Zeus IDE. It's fast, very stable and the support for Go includes automatic code formatting, code navigation and function lists. **NOTE:** Zeus is shareware, is *Windows only* and was created by me.
[removed]
Well it depends on your usecase, ie for things where in java you have a task that is geared towards shared memory, go for it, or use an atomic reference, if you are doing things that is just straight computation, or io, I would use Goroutines. In some scenarios like if you want to make a process group, that shares state, I would use both locks or atoms / and channels. Using straight message passing in a stateful service, is stupid and in my experience with systems programming, I often write stateful services. There is no one size fits all approach to concurrency, message passing is just a useful pattern. Just using locks isn't exactly smart either, it will really slow your shit down, and with over use is prone to deadlock. In all honesty however, I avoid using Go, for things that heavily deal with shared state, or needing a lot of logic in the control plane, and find it's sweet spot to be an area where you are writing something bruteforcey that requires high throughput. 
We built our own little level-based multi-logger (to stdout and file) with text filtering support, but I've been meaning to replace it with calls out to a more featured library.
I am interested in that bundle. I started learning golang 5 months ago, and like it so far. But looking for some help with designing and scaling large, complex APIs. 
I'm on OSX, so it's 64 bit, but I have to run 32 bit node on Windows from time to time, and the only difference I've noticed is that it uses much less memory: almost 50% less.
&gt; WARNNING: stay away from Eclipse/GoClipse on Mac. Most programmers know to stay away from bloated and clunky IDEs regardless of the platform. And the ones that don't, simply haven't used IDEs enough yet. I'd recommend vim + vim-go but if you don't already know vim then your best bet is probably Vscode.
I've forgot to mention, having named return values can be invaluable when returning multiple values of the same type. It increases the readability by 100x easily. 
We don't have aynthing fancy, we wrote a log shipper that simply sends every log line in a Kafka record, that way we can do a `tail -f` on all logs. It's not ideal, but we don't have time to test oklog unfortunately.
If you look at [log.Printf](https://golang.org/pkg/log/#Printf), args in my example is the same as v here. In both cases it allows you to pass arguments of any type for your format string. [Here](https://play.golang.org/p/Jj4n4UGBFk) is a more concrete example of what I meant. I can't test with logrus on the playground but it will work with it too. Hope that helps
&gt; based not on facts but personal feelings. [Facts](https://insights.stackoverflow.com/survey/2016#technology-development-environments). 
So... Notepad++ is as used as Visual Studio. Doesn't this render your point invalid?
I wrote my own version a different way. Only a few lines too https://gist.github.com/17twenty/5c1ab1fd8c454e49cdf3 Being able to do this is cool too for i := range Walk(10) { fmt.Println(i) } 
This is my opinion. Look at the [code comparison](https://speakerdeck.com/rebeccaskinner/monadic-error-handling-in-go) in slide 43. I cannot read the code but it is entirely possible that all this error handling that appears on the page could be abstracted away, some parts at least. But even as it right now, I think the first way is much more readable compared to the terse second version (if you take out that ugly red color). In fact the second version looks like a complex nightmare for the unfortunate souls that will have to maintain it a few months down the line. Also it seems that she has identified that the problem with Go's error handling is that it is verbose and it hides the business logic and she proposes a way that makes the business logic more apparent and effectively hides error handling. Error handling is a very big part of programming. Why does everyone who complains about Go's error handling seem to be proposing ways to shove error handling under the rug? Errors are values. Instead of trying to come up with ways to "improve" error handling in Go 2.0 why not blog and do talks about error handling best practices in Go today?
It's a variadic function, which means you can pass it any number of arguments of that type. In this case, the empty interface is used, which is implicitly satisfied by every type (as it has no methods). In other words: for args, you can pass any number of values of any type. https://gobyexample.com/variadic-functions https://tour.golang.org/methods/14
Do not communicate by sharing memory; instead, share memory by communicating.
SECTION | CONTENT :--|:-- Title | Migrating to Gogland from a Code Editor: Tips &amp; Tricks Description | Gogland is the codename of the new Go IDE announced a half a year ago by JetBrains. In this webinar we look at this IDE from the perspective of a user of an editor such as Code, Atom, Sublime Text or Vim. We'll see where an IDE is inferior to editors and where it surpasses them. Brian, as one who has migrated to Gogland from an editor, will share his experience: both good and bad. Florin, as an IDE advocate, will share share tips and tricks on how to get used to the IDE and get the most from i... Length | 1:19:40 **** ^(I am a bot, this is an auto-generated reply | )^[Info](https://www.reddit.com/u/video_descriptionbot) ^| ^[Feedback](https://www.reddit.com/message/compose/?to=video_descriptionbot&amp;subject=Feedback) ^| ^(Reply STOP to opt out permanently)
It's great to see how Go programmers learned to value simplicity so highly and fear monstrous language constructs. That's something that programmers from other languages don't seem to understand. That's why learning Go makes you a profoundly better programmer, just like learning functional languages makes you a profoundly better programmer.
Completely agree. Particularly for distributed systems, it's vital to handle errors properly. Retrying, exponential backoff, failing over to another machine/cluster, skipping the data, returning the error to caller, tracking it with metrics or logs, or fatally crashing your program, are all decisions a developer needs to make when writing their program. I don't see how the compiler could make that decision for you, as what to do with an error depends on the circumstance. Not handling errors and throwing panics instead means your program is brittle and crashes all the time due to occasional, recoverable errors. On the other hand ignoring errors means your program continues on its merry way, dropping data, writing inconsistent files, hammering broken systems to death -- all with little or no evidence that something has gone wrong. I don't see how an esoteric concept from functional programming is going to make this any easier.
&gt; I don't see how an esoteric concept from functional programming is going to make this any easier think of monads as programmable semicolons, and it'll make a lot more sense. Here's an example - the typical "monadic" way of error handling in Go is as such: type errWriter struct { w io.Writer e error } func (w *errWriter) Write(p []byte) { if w.e != nil { return } w.w.Write(p) } Now, that's ONE way of writing an error handling "monad" (I say this with much qualification because technically a monad should be generic, but you can quite trivially prove that `errWriter` above, with a bit more flourish, satisfies the three laws) Now, what if you have something like this? type errRetryWriter struct { *errWriter q [][]byte } func (w *errRetryWriter) Write(p []byte) { if w.e != nil { w.q = append(w.q, p) } // handle queue and write } I find that most people have no problems understanding code above. The consternation comes from wanting code that reads like `(&gt;&gt;=) :: (Monad m) =&gt; m a -&gt; (a -&gt; m b) -&gt; m b` instead of the many lines above. I used to be a hardcore lover of terse codes - my python programs are filled with one liners full of lambda and list comprehensions. The problem was coming back to the code 3-4 years later.
Is it just me or does simply saying "monads! monads! monads!" without any kind of example demonstrating actual complexity feel like a scare tactic? For example there are generics in C# and no one has ever said the word "monad".
The built-in map and slice types are very helpful to implement custom generic types. Their importances may be weakened a little by the custom generic feature, but not much. It is not bad that the built-in generic types have some privileges over custom generic types.
I _think_ he is referring to the error-handling model based on the monad interface that is in use by some languages like Rust, and not the "full" monad interface, as Haskell is pretty much the most practical language that can actually fully express that interface. It isn't the only one but most of the others are even _farther_ in Haskell's direction (from Go's perspective) than Haskell itself. There is zero chance that Go would ever be one of them. And I would point out that it is a pressure that those languages have been experiencing lately; having special-purpose monadic values for error handling or special-purpose ones for concurrency get people asking why they can't have full monadic values, in much the same way that Go programmers ask why they can't have generics even though the language can. But the type features required to have those features are really disruptive to most languages, if not outright unimplementable due to other earlier decisions.
I've been trying a different approach in my latest project. Log methods are static wrappers around the standard library functions, but they all take a context. I can manipulate the context to affect what and how I'm logging. The key thing is I can automatically include environmental information such as active user, security context, parent references, etc. without having to always explicitly specify them. It's a little bit of a pain in the ass to pass the context around, but I have to do it anyways for other reasons. Since there's no thread local storage I don't really see a better way, but I prefer this anyways since it's more explicit what is going on. I'm not sure if there is an open source library that follows the same pattern, I haven't looked yet since I wasn't sure I was going to stick to this approach. If I don't find one I'll consider open sourcing what I have even though there isn't much to it. It might not be the best approach for every situation but it's working out well for this project.
I wrote a [logging library](https://github.com/skillian/logging) that nobody uses! The problem I perceived with the `log` library wasn't just the lack of levels but of the ability to log different levels to multiple targets, like logging everything (including debug) to a file (if desired), logging info through error to a database, and logging everything from warning to error to the console. I started off with wrapping multiple `log.Logger` structs depending on the level, but then I wanted the ability to fine-tune the output more than what I could figure out how to do with just the logger's flags. Eventually, I thought it made sense to just write my own. It's based on Python's `logging` package, so Pythonistas should find it easy to use. It's the first real project I've done in Go, so I don't know if it's all idiomatic Go, but I tried to make it correct in that regard.
Since the LiteIDE author(s) does not attempt to aggressively advertise his (their) project, allow me to humbly list it here, as a very simple, straight-forward alternative to the other (good) IDEs. It's something that has served me well over 4 years now. Version x.32 recently out as per a golang-nuts announcement: https://groups.google.com/forum/#!searchin/golang-nuts/liteide%7Csort:date/golang-nuts/brIuvlnWnqA/4NdKM5oaCgAJ
What do different data structures have to do with generics?
Nothing at all. OP is the stereotypical retarded gopher.
I think he is referring to the actual size in memory of the platform. So probably not so much you can change about that 
I use C# and nlog a lot. I love nlog's ability to specify different logging levels and targets for different parts of the code on the fly via a config file change. Unfortunately, I have been unable to find a golang equivalent. So I'm writing my own. That's what I use.
I see what you are saying and I agree with you to an extent. My if I where speaking directly with the authors your approach would be the one to follow. My intent however was to post the kind of warning to the general public that I wish someone had posted for me to read. It wouldn't have been so bad if there description/instructions had contained a warning that the current version was still very buggy and they where looking for lots of feedback. Or something to that effect. (Note: I am only talking about the Mac version I don't know anything about the windows version.) You see when I downloaded it I was looking for something to simplify my life not more work helping ppl debug program. (Note: at other times and places I have enjoyed helping find bugs and reporting them in free software.) With that said I am happy to list some of the specific problems I had. 1. I downloaded and did the basic setup from there instruction then put my computer to sleep and went to bed the next day I found the GoClipse add on had uninstalled itself somehow so I had to do that all over again. 2. None of its default paths lead to the default locations of the programs there supposed to use. This is referring to the paths for its recommended add ons that it requires. 3. Its use Gopath doesn't actually use your Gopath. You have to turn this off and enter your Gopath. 4. It doesn't use your actual Path. Like Gopath it seems to have its own Path. The only way I found to fix this involved changing the Path every time you wrote a new program. No way to fix it for the system as a whole. (Note: this may be a problem with Eclipse not the Goclipse add on). 5. Its instructions are incomplete. An important example of this is it tells you to download and use gometalinter but has no interface of instructions on how to integrate it. Gometalinters instructions tell you how to integrate with a lot of IDE's but not Goclipse. After a great deal of working and fiddling with it I finally found a way to get it to work but this involved adding gometalinter to its Path on every project. (Note: see 4.). When it does use gometalinter it runs it on lots of things it should not causing lots more output and errors. (Note: see 6.). 6. Its project saving system is bulky, messy and requires you to include lots of additional files and programs. It seems to also include every file it can find on any path in its builds. (Note: I did not include problems with GDB because that is a problem caused by apple not Goclipse. Also Goclipses instructions warn about this problem which was the only good surprise I found.) I have to go now Ill be back later.
When he says "Maybe Monad", he isn't talking to C#ies, he is talking to rusty people or Haskells. And thus it's not a scare-tactic, because those love themselves some Monads. Note, that he doesn't use it as a perogative; he borrows it from a talk he links to and then just describes what his problem with the pattern are. It's only a dirty word, if you have a dirty mind :)
That's just plain wrong. Learning go has exactly one effect on you: You know go afterwards. Lots of shitty go programmers and lots of *amazing* PHP/Haskell/C/Brainfuck… programmers. I think arrogant sentiments like this give the go community a bad rep.
If you're writing libraries, *don't* use logrus. Instead just use the standard logging interface and let the application control which logger they want to use. I've been using Oxy in an application and it's a pain because they use logrus, and use the default global logrus logger at that, which forces my application to know and care about logrus. Now I have to deal with 2 logging systems—the stdlib default logger (which other libs use) and the logrus default logger. It's really stupid.
I think OP's app is a single running binary with an in-memory cache. If OP is running multiple instances behind a load balancer, not leveraging a distributed cache, and is still using in-memory cache, then they are going to be having consistency issues. 
well, also at Hidden Monster Games haha :) Amsterdam is beautiful, you will love it
"Senior go game developer" is a very specific title. Given how easy it is for someone to learn Go from scratch, I'd suggest dropping the language requirement - just look for a senior game developer that shows a history of being able to learn new technology rapidly.
I interpreted no arrogance. There are different lessons to learn from different languages/paradigms/communities. From functional languages I learned to minimize state. From Go I learned to value and defend simplicity. I don't think the intent was to say "all Go programmers are gods of simplicity."
I second this. I'd also abandon the senior prefix, it might scare potentially good mid-level programmers from applying.
m( Realized, that I grammared wrong in the title after submitting. Reddit doesn't edit the title to reflect the changed one of the post…
I think he's suggesting to to allow the user just to type something like "Open Sans" then in your library add the "+" along with other necessary escape characters it's fairly easy to do with URL.PathEscape
I'll choose gorilla/mux (or other simple muxers) over the stdlib duplication for routing every single day, even if that means I'll have to read the code to see what it does or, worse, contribute to the documentation.
ah, yeah.... already did that. just need to push :).
LiteIDE is one very fine piece of software. Fast, simple and very efficient for work with Go (same qualities Go have as language).
I've already applied via stack overflow:)
I think [golang-dev](https://groups.google.com/forum/#!forum/golang-dev) might be the place to ask.
&gt; Is it just me or does simply saying "monads! monads! monads!" without any kind of example demonstrating actual complexity feel like a scare tactic? It is. He just added fuel to the fire. Notice how a lot of Go programmers here and in other sites (HN) are talking about how hard and different monads are, instead of talking about generics. Now a large part of the Go community will oppose to generics on grounds of someone using them to implement monads someday.
Hello, I have 2000 years of experience in Go Game and my preferred frameworks are tenuki, sabaki and shicho.
Great article! I strongly agree with Dave that adding generics would add a great deal of complexity to the language. People who argue for generics need to explain how they're going to be smoothly integrated into the language.
&gt;Unlike expvar, the HTTP handler for Prometheus is available and can be attached to any HTTP server. That's not true, you can also get the handler from expvar. https://golang.org/pkg/expvar/#Handler I was looking more for an explanation on how to put metrics into production. Exposing and incrementing metrics are easy but how do I secure the exposed metrics (in the pull model) and how to I get them to the server to show them into neat graphs?
I switched to VSCode because I think Atom is too slow and the Go plugin for vscode is better.
&gt; It is not bad that the built-in generic types have some privileges over custom generic types. Just to take one simple/obvious example: There is a new sync.Map container, do you really think it's better that it is used entirely differently to the builtin map type?
You are not presenting the real arguments honestly. https://research.swtch.com/generic
Not only that, they completely invented imaginary Rust syntax? It's one thing to attempt to implement monads in Rust and get summarily smacked down by the type checker, but I can't imagine the level of confusion that would lead one to believe such a code example would even parse.
&gt; I cannot read the code The PDF version of the slides contains all code in full resolution. The monadic code on the right side of slide #43 (PDF page #61) roughly looks like get(f1). Next(f2). Next(f3). Next(f4). and so on, where `f&lt;n&gt;` are functions. (I.e., it is a long dot-chain of wrapped function calls.) There is no visible error handling.
It's a rite of passage for new Go devs. You look at the stdlib log package and scoff gently at how such a simple package can possibly do all the complex things you need it to. So you create your own logging package that does all the things you think you need. Then you get more into the Go mindset, and stop using half the things you thought you'd need. Then eventually you understand why the log package is so simple. Then you delete your logging package with a small blush of embarrassment. I have trod this path. Many others have too :)
&gt; I think we are all "programmers from other languages" in Go... Indeed. :) I would guess that "programmers from other languages" in /u/faiface's comment means "programmers from other languages who take a brief look at Go" (as opposed to "Go programmers who learned another language before")
So your point is that if one uses routes that could collide in the router, you could get problems? I had your Problem too, but i just changed my routes in a way that dont have the risk of confusing the router. That was certainly less work than rewriting everything to use the stdlib
if it makes it clearer... maps are effectively a list of pointers to items sitting in memory. When writing to the map, the system may well reallocate these pointers, meaning it changes the location of the data and changes the value of the pointer. If you're reading from the map at the same time as these pointers change then you may well read an invalid pointer. You're not reading "out of date" data. You're reading random contents of memory. If you're very lucky the GC hasn't cleaned it up yet and it's just old data. If not, then it has been reused and your program will attempt to interpret it to the expected values, fail, and panic. Your program will crash badly. I would lock around the loop, rather than inside it, and use a RWMutex. This will (promise!) have no bad effects on your performance, and will stop your entire program from crashing unexpectedly.
I fully agree - if, at the same time, naked return statements are avoided.
Praytell, Mr. Kibwen, if you put into the machine wrong figures, will the right answers come out?
Java did it in 2004.
Nice looking bundle, I purchased it, very reasonably priced. Looking forward to reading them.
Yup. Naked returns are good for 5-8 lines of code, after that it's probably better to explicitly return. Iirc, this was one of the code review recommendations.
I'm with you there. Whenever I need to write anything in another editor, like a quick mail in Gmail, or a jupiter notebook, i have 20 sec where I have to adapt. And on many occasions I've send my friends 'jk' in chat, not to say joke, but because I've configured that to be escape. I have some hope for neovim to be available anywhere. If only w3c would embrace a modular design where the &lt;input&gt; tag when the environment variable $EDITOR is set it uses said editor for the input. Or in neovim's case even better, uses a headless neovim instance, and sends all keyboard events to it. And loads the buffer into the input field on change. The plan9 operating system had this figured out with something like an event based filesystem which you could configure however you wanted to connect programs together. But alas Unix won the Unix wars. Anyway a man can dream. Im sometimes temped to switch to an ide as well. But I'm damn happy when I have to work in remote server that I haven't. But with the amount of time I've spent configuring my setup just right, I'm not sure I've come out on top. Edit: some spelling errors, I don't have vim on my mobile phone. :p
https://github.com/golang/proposal/blob/master/design/15292-generics.md
Why the downvotes, I thought it was quite entertaining!
No, my point is, that it's hard to impossible to "rewrite your routes to not collide" (see the toy example in the post I linked to; the routes in there are *inherently* colliding), that the mux doesn't have enough information to correctly give specific, protocol-compliant error codes if routing fails for some reason, that using muxes obscures the control flow of your app, that you are importing an incredibly complicated component into your code and lastly, that you don't even get a lot out of it. Writing `mux.Methods("GET").PathPrefix("/foo").Handle(FooHandler)` is not significantly better than writing if !strings.HasPrefix(req.URL.Path, "/foo") { http.Error(res, "Not Found", http.StatusNotFound) return } if req.Method != "GET { http.Error(res, "Only GET is allowed", http.StatusMethodNotAllowed) return } on the axis of "how hard is it write", but fares significantly worse on all of readability, debuggability, maintainability and correctnes. If it is too much boilerplate for you, you might add `func AcceptMethods(res http.ResponseWriter, req *http.Request, methods ...string)` to your `ShiftPath` toolbox. Or `AcceptPathPrefix(…)`. Instead of making all of these routing helpers methods on a mux, make them functions that operate on a ResponseWriter and a Request and are used *inside your handler*; because a) that allows them to give more specific error messages when possible, b) they are still easier to understand and debug and c) they still allow static analysis and compile-time safety of routing decisions. Basically all axis that people pretend to care about, making these decisions locally in your handler is just strictly better than putting them into one giant component of spaghetti-logic. YMMV
we want 3 years of programming experience. However, if you have a killer portfolio, that is a more important requirement. At this moment we are searching for a programmer onsite only
You should replace "If you don't write web-thingies in go you can stop reading now." by "Even if you don't write web-thingies in go you can continue to read now and apply the sames refreshing principles to other domains" 
Somewhere in this mix you have the application server that is serving the http endpoint. It may be "A", which would need to delegate part of the request to "B". Or "B" to "A". Or even a "C" that serves http and will call "A" and "B" in order to form a response. But in a nutshell, whoever is handling the http request will be able to delegate to any number of microservices in order to ask extra questions, and then collect everything into a response. 
More details: https://stackimpact.com/blog/stackimpact-golang-agent-2-0/
Other people's code *is* my business. I use open source software and as such I need to read code to fix problems I encounter or make improvements I need. I get paid to develop enterprise software so I need to read code and maintain code that other people wrote. Given that, I and other people in the go community have a vested interest in promoting healthy, maintainable and readable go-code; part of that is providing advice and guidance on how to do write such code. The fact that every newcomer to the language is writing their own high-performance, convenient, feature rich and totally awesome™ muxer points to the fact, that this area is one where the community is currently experiencing a systematic wide-spread problem that needs a systematic solution. We need to, as a community, figure out how we prevent this kind of duplication of effort and fragmentation, while also enabling people to be productive. And that is precisely what I'm trying to do here. Showing people how they can both be productive *and* avoid first wasting their time to write yet another muxer. But in the end, I'm not your parent or your boss; if my advice isn't welcomed by you, you are free to simply ignore it.
I can confirm that. The Netherlands is an IT dead zone. Booking.com is always looking for perl5 people but other than that it's all quiet.
That's nothing. I have 3000 years experience of windows 2000. My preferred frameworks are minesweeper and rebooting the thing.
Underrated post. Sad to see someone finally showing a way to use the standard library for (complex) routing and people dismissing it so easily and saying "Meh, I'm still gonna use X router". We need more articles like these. Except the animated pics. Those can go to back to annoya-land where they belong.
&gt; You can blog all about the how to best handle errors in Go's current state and still argue for a better future version. Sure. Yet somehow we never get posts like these.
I don't believe the browser can receive a request from B out of nowhere. Does the browser have a connection open to B like a websocket? Is this all behind an initial HTTP endpoint? Do you poll B and see if there is data? You could make the request to A. Then poll B for a response.
&gt; A one liner, against a 10 liner to achieve the same Job (for every Route you have) is significantly better in my opinion It's not, however, what we are talking about. At best, you are comparing Apples to Oranges, as the "verbose" code provides more nuanced errors. FWIW, the equivalent to my snippet above, using gorilla/mux would be m.PathPrefix("/foo").Methods("GET").HandlerFunc(FooHandler) m.PathPrefix("/foo").HandlerFunc(func(res http.ResponseWriter, req *http.Request) { http.Error(res, "Only GET is allowed", http.StatusMethodNotAllowed) }) m.HandlerFunc(http.NotFound) and with appropriate Helpers, if reducing boiler plate is your actual goal (it's not mine, I prefer the clarity), you could write in your handler AcceptPathPrefix(res, req, "/foo") AcceptMethods(res, req, "GET") FooHandler.ServeHTTP(res, req) while still maintaining all the properties I advocated for in my post. So, no, I disagree that there is any additional repetitiveness in my proposed pattern. :) &gt; In gin for example you operate on a context, thar exposes response and request so i dont think ypur points about that are valid, bc you can give specific errors nonetheless. I don't know gin (and that's pretty much the point). But that also means that your Handlers won't be http.Handlers, making them non-composible with the rest of the ecosystem and *even worse*. Also, looking at [the README](https://github.com/gin-gonic/gin) it doesn't actually solve the issue I pointed out, which is that the router won't use appropriate status codes, if you just naively define your routes, because it can't because that's a complicated problem. You have to either resort to the same thing I am doing, by checking methods and the like in the handler and writing the correct error code (in which case, why use a muxer in the first place, if it gets you the same boilerplate you claim to hate?) or have to tediously compose your routes as I demonstrate above, by adding extra routes for any error condition. &gt; I'll give you your point about static analysis, but i dont see any advantage from compiletime safety of routes. Ever tried to debug a multi-million SLOC web application? static analysis of routes is *awesome* and incredibly important. As an ops-person, if my prober reports a failing request, I want to be able to click myself through code-search to follow it from the root to the actual failing site. All the generic Handlers and dynamic wiring of routes makes that totally tedious if not impossible :)
"writing gameplay for our servers in Go" This is a very generic requirement :). I am actually surprised you would want to write "game logic" in a language like Go. Do you have some examples of how this works for you ?
I do as well. But not in articles. They are distracting. Still images might be more appropriate. Or maybe it is because I think highly of the article, I don't know.
Most of those posts are old. As someone who has been following Go since the early days, those posts are not helpful to me anymore and judging by all the complaining about errors they are not useful to newcomers either. We need more blog posts about error handling best practices with new examples and not going back to the Rob Pike article. Also if we want to be technical, only like one of those articles shows best practices *and* talks about new ways.
Some comments about translation: &gt;Когда вы готовы продолжить, нажмите на стрелку вправо внизу или клавишу PageDown. Следует заменить на &gt; Когда вы будете готовы продолжить &gt; Вы можете переключаться между ними используя на &gt; Вы можете переключаться между ними используя: &gt; Нажмите сейчас на кнопку Запустить на &gt; Нажмите на кнопку Запустить И так по всему тексту. Перевод больше смахивает на машинный. For english speakers: The translation looks much more like a google translate. I wouldn't recommend anyone to include this translation until it's polished. Source: native Russian speaker.
Thank you. Actually I'm using RPC calls right now. Was just wondering if there was another way of replaying to the HTTP request from another microservice. But you are right, I need to close the TCP connection to send the data, so no benefit on this approach I said.
&gt; Most of those posts are old. So? Very little (if anything) about error handling has changed since Go 1.0. &gt; judging by all the complaining about errors they are not useful to newcomers either Those who complain about error handling are not complaining about lack of "best practices", they just want different ways of error handling that can only be implemented in a theoretical Go 2.
&gt; Those who complain about error handling are not complaining about lack of "best practices", they just want different ways of error handling that can only be implemented in a theoretical Go 2. Possibly. But I strongly believe that if we had more articles showcasing error handling best practices, we would have less complaining.
I don't know of any Gophers (or in fact, anybody who deals with many other languages nowadays other than PHP) that use anything like CPanel or Plesk. They're a bit of a relic these days. You might want to look into things like containerisation via solutions like Docker, and then look into how you can deploy containers to your infrastructure with something like Docker Swarm, Kubernetes, or Rancher, for example. For some of the other functions that Plesk / CPanel provide, you may want to look into alternative solutions that specifically handle the tasks you have in mind, or for things like DNS management, maybe let someone like Amazon take care of it for you. Route53 is excellent, and along with a bunch of other services you have in AWS (or even in other providers' suites, such as Google's Cloud Platform) you'll have a control panel to manage these things with.
Yes, it is our source code :) Unable to share though...
A VPS from DigitalOcean, Vultr, Scaleway, Linode, Lightsail, or w/e will be fine. They're very cheap, and you can install Postgres easily along with your Go application. SUPER easily if you use Docker.
Thanks for the suggestion. I've tried DigitalOcean and it is indeed easy. It looks like a very good solution. &gt; SUPER easily if you use Docker. I am probably missing something but I find Docker very complex. It's probably super easy after you already know it.
http://www.enterpriseintegrationpatterns.com/patterns/messaging/ProcessManager.html ?
It has some positions, but it's a dead zone compared to the UK to the west or Germany to the east. However the cost of living in the UK is far higher. If you are looking for web or app related positions try Berlin, the job market is overheated there.
I'm being thick here, but what is SPA?
Single Page Applications. You might have also heard the term progressive web apps (technically they are not the same thing but I digress). Essentially keeping the back-end Go API and the front-end code separate. The front-end code acts like a ["shell"](https://developers.google.com/web/fundamentals/getting-started/codelabs/your-first-pwapp/#what_is_the_app_shell) and asks the API for the data it needs.
I don't really understand what your goal is here. You ramble on and on about opinions and that people should just decide what they want to use. That is exactly what I did; I stated my opinion and provided advice for people who need it. If you don't, that's great, all the more power to you. Other people might. I did nothing but add my own voice to the chorus, there is no need to attack me for it - *especially* not if you are doing it under the pretense of defending freedom of expression and choice. Again, I'm not your parent, I'm not your boss. I'm just stating my opinion about a) what good, maintainable, healthy code looks like and b) what would be best for the ecosystem as a whole to solve this problem. I have no power to force my opinion on anyone, so I don't understand why you are taking such offense with me saying what I think.
Ah right, update-in-place rather than refresh then?!
Do you count back end development as game development? I don't. Epic also uses Go on their backend too, but they don't advertise for game developers in their job listings. 
Yep. It makes things like Gmail really nice in the browser.
From the description, it sounds like a very light way to achieve distributed clusters (lighter even than MySQL). I'm sure it's decently performant, considering it's built on SQLite with the communications wrapper being the addition. You lose insert performance for network round trips (so you should batch all the inserts you can) and you can only use SQL statements that are deterministic. Also, you won't have stored procedures. If you have the resources to manage Postgres clusters, then you should do that instead, but the administrative complexity will be higher.
You could give the course for free for a limited time. I don't think it's very ethical to be advertising paid-for products in here, especially something as expensive as $200. It's not really in the spirit of open source contribution. The main reason why I think it's a bad idea is because it sets a certain precedent. I don't really want to be inundated with advertisements for paid products whenever I browse this sub. Maybe other people will see it differently to me though.
We write game logic in Go, so yeah, I consider that game development
Full details on the API, including batching, are here: https://github.com/rqlite/rqlite/blob/master/doc/DATA_API.md https://github.com/rqlite/rqlite/blob/master/doc/BULK.md
IBM Bluemix [supports Go](https://www.ibm.com/blogs/bluemix/2015/10/getting-started-with-golang-on-bluemix/), offers [PostgreSQL](https://console.bluemix.net/docs/services/PostgreSQL/index.html), and [has a free tier](https://www.ibm.com/cloud-computing/bluemix/pricing). It's built on Cloud Foundry, so you can just `cf push` your application to deploy it. Disclaimer: I work for IBM. But I've had an application deployed for months and not had to pay anything yet, because of Go's low resource requirements.
Yep, and I appreciate your understanding. Oh and just fyi - if there are specific videos you (or anyone else) are interested in I'm happy to create a custom sample of a few videos and email them to you. Just pm me with 2-3 videos you would like to check out and your email address.
I like this approach, we have been using it with some non-golang backed projects and it's allowing great separation and testing. 
https://github.com/hajimehoshi/go-mp3/tree/master/example/main.go There is an example to play MP3 with `io.Copy`.
This is what I do, too. I think there are good reasons to keep them separate. The front and the back really are separate applications that communicate. It's possible to write/test/deploy them from completely separate machines/environments. It's possible to write different front ends that communicate with the same back end. Putting all of those different front ends into the same repo would be messy. The front and back ends can be deployed to different machines.
That's exactly what I did. I announced it in golang-nuts group https://groups.google.com/forum/#!msg/golang-nuts/6MN5esr08Sw/wO_rLiqmCQAJ;context-place=forum/golang-nuts. I guess the email is sent automatically. 
Hm, I see the formatting is broken in the beginning, don't know how this happened - I'll fix this. But it's not "most" tour pages. I'll re-cheak. Thanks for the feedback. 
I LOVE THIS. But how can I build bootable img(or iso) from this source?
This post is the embodiment of arrogance in the go community. 
I'll defer to your judgement then since I'm not a game developer.
Can you elaborate? What specifically is it I'm saying you perceive as arrogance? I might be able to correct myself :)
I don't know what I said that gave you this impression. Feel free to let me know, so I can watch out for it in the future. While it's obviously a discussion about opinions (approximately everything is, especially if it's "how to solve X well"), I believe I gave precise and specific technical arguments for why I'm holding my opinion. You are also invited to reply to them, instead of staying with ad-hominem attacks.
If you were an anonymous rando then this wouldn't be cool, but you're a frequent contributor and commentor, so this is perfectly kosher.
&gt; Go’s Pascal-like array type has a fixed size known at compile time. How could you implement a growable vector without resorting to unsafe hacks? I’ll leave that as an exercise to the reader. But I put it to you that if you cannot implement simple templated vector type with the memory safety we enjoy today with slices, then that is a very strong design smell. I'm not sure I understand what the problem is here. That seems like asking how you would implement the slice type with current memory safety. You don't, but we trust the implementation anyways. Isn't a vector just a slice that owns the backing array? And is defined in the standard library instead of a builtin? And it isn't like slices are magically guaranteed to be implemented in a memory-safe way. [The code that actually grows a slice during a call to `append`](https://github.com/golang/go/blob/master/src/runtime/slice.go#L72) makes use of unsafe pointers. But, again, we trust that it was implemented in a way that ensures that it is safe. 
Sorry for off-topic question, but: if _, err := io.Copy(p, d); err != nil &amp;&amp; err != io.EOF { return err } [`io.Copy`](https://godoc.org/io#Copy) docs say: &gt; A successful Copy returns err == nil, not err == EOF. Because Copy is defined to read from src until EOF, it does not treat an EOF from Read as an error to be reported. So is that `err != io.EOF` needed?
Thank you for pointing out! I've fixed not to check EOF.
This all day. Coming from log4* land, I saw the log package and balked at the lack of, well... everything. But using it for a while I've noticed that I just don't need it, the only two log levels I really need are log message and crash message, and the stdlib logger does both just fine.
Great, thanks. :)
To be more accurate, you likely don't see a lot of *greenfield* projects that use things like CPanel. I know for a fact that many older projects still use CPanel. I, for one, am kinda glad that these janky dashboards are being phased out, but it would surprise me if there weren't at least a few of them out there for Go applications. I haven't been able to find one with a quick Google search, though. 
One advantage of using a router is readability. I can go and see that `/hello/world` directly maps to the `HelloHandler`. With your proposed scheme, that seems much more involved. I just did a count of the number of routes we have at out largish webapp at $dayjob, and we currently have 342 routes. It'll be a lot of code and `switch`es to make that all work! This isn't to say that I'm completely happy with various routers. I once had to fix a bug in one of them and fixing it was not a happy affair. I'm not entirely convinced that this proposed solution – while interesting – is the answer to any and all routing problems.
This is, to exactly 0%, an answer to anything. My issue is with muxers, not with "other people's muxers". In fact, I started writing my own and figured out pretty quickly that it's a dead-end for the reasons outlined in my post. It doesn't matter *who* writes them. They are a bad idea. That being said, I also honestly believe that my current approach takes a sum-total of maybe 100 SLOC to get feature-parity with something like gorilla/mux, so I don't know why I'd need anyone to write them for me either :)
I've never had a shortage of job offers as a developer in the Netherlands. I see [plenty of jobs at e.g. Stack Overflow](https://stackoverflow.com/jobs/developer-jobs-in-netherlands?sort=i) You could perhaps argue that the UK has *more * jobs, but that's quite a difference from "being a dead zone". Remember that the UK is a lot larger. The London area alone has more than 13 million people living in it!
&gt; update-in-place rather than refresh then?! As far as Single page applications are concerned then yes, everything is done with Ajax. But SPAs has been a thing for a while now. Proggressive Web Apps seem to be the evolution of SPAs and they are much more than that. They deal with things like fast load times, offline access, provide a native feel (like a native phone app), be installable etc. There's a [lot](https://www.youtube.com/watch?v=fKsVXO3AztY&amp;feature=youtu.be&amp;t=16m47s) of [info](https://developers.google.com/web/progressive-web-apps/) [online](https://developers.google.com/web/fundamentals/getting-started/codelabs/your-first-pwapp/) and there's even a very nice chrome extension called [lighthouse](https://chrome.google.com/webstore/detail/lighthouse/blipmdconlkpinefehnmjammfjpmpbjk?hl=en) that measures how fast your app loads, if it provides offline access, if it is installable if it provides phone icons and in general just how "Progressive" it is. It seems progressive web apps are the future so much that mobile phones now allow to install them and make them indistinguishable from other native apps (at least Android does it).
I'm not a Mac guy, sorry. I use it only on Linux and Windows.
It was my personal opinion that once you start liking a particular language or tool, you may end up learning in depth about it like the philosophy, the design decisions etc., There is depth of knowledge in everything. If you need to host a website, you'd know what libraries/frameworks to use which comes from experience or work related knowledge. Let me give you an example: If you have been working on C, say for 3-5 years in your job, you learn many things outside of the business logic which may be related to code organisation, best practices, design patterns etc., You are now presented a new problem which is related to say HTML/REST which is not C is famous for. You may ask 5 different developers, you'd get 5 different suggestions. There is no one right of doing anything. If you want to get something done fast or an efficient way, you would try to use the tools you already know, which may be C in this case. When you chose C, you are avoiding the learning cost for the Non functional requirements of tuning the application (like Java), deploying, setting up the infrastructure, failover, configuration etc., Because getting to production means lots of hours of work to get it stable after load testing etc., (of course there may be ready made solutions for the same). Developers/Engineers try to use different tools depending the problem they are solving. Go was originally intended for Systems Programming. Erlang(which Elixir is built on top of), was originally designed for telephone system communication. Use the best language/tool you want to use for a problem. With experience, you can make better decisions on what to use for a use case. You need to learn about what is good or bad about other systems before you can make a better decision. 
Please do not blindly follow patterns. Surely the clean achitecture is an excellent pattern but it needs to be applied in the context of Go. By blindly following the pattern, you are missing out on Go's strengths and you end up writing Java with Go syntax. There's been many other [implementations](https://github.com/roblaszczak/go-cleanarch) already and most of them suffer from bad package naming making the codebase quite the opposite of clean. If you want something truly clean and simple, I'd recommend following some of Ben Johnson's [tips](https://medium.com/@benbjohnson/standard-package-layout-7cdbc8391fc1).
I didn't think Xcode supported Go. Can you tell me what is needed to set it up for go? Does Gogland use GDB on macs or a different debugger? dlsniper you said &gt; As a heads up, Gogland does not, which has its own advantages and disadvantages. Would you be willing and able to list some of these pros and cons ?
Ah, thank you. I should have checked gorilla's handlers readme, it had an example right in there: https://github.com/gorilla/handlers#example
Or register your health check handler as a Middleware just before your logging Middleware. Easy.
Go is just a language. Do you have a Plesk equivalent for C++?
You're right, should have added StackImpact to avoid confusion with built-in profilers.
That *is* the built-in profiler, just transferring the results to a SaaS UI.
&gt; cat pictures Those don't make money? ;) 
I have so far liked exactly two structured logging mechanisms in Go: 1) https://godoc.org/go.uber.org/zap 2) just lines of JSON via a `func(interface{} msg)`, wrapped in an envelope that has timestamps etc (before zap existed; zap has now subsumed this) 
Thanks that helps.
I suspect this might be hard to debug w/out knowing the migrations along with your existing DB structure. Any chance you can share more info?
Love your ebiten so much.
The "right" way to do this is to return a 202 (Accepted) response as soon as the message is safely in Kafka, with a Location header set to a URL that can be polled for status and the final entity that results from the Kafka processing pipeline. That Location should return 202 as well until the response is ready, potentially including status/progress in the body, until it's complete. Once it is complete, return the final entity with a 200. You really should not build an asynchronous system that masquerades as a synchronous system, it'll only cause you heartache in the future. 😲 EDIT: 202 is "Accepted", not "Processing"
I also like gountries for this kind of info https://github.com/pariz/gountries 
The NYTimes Crossword platform backend is written in go. source: helped write it. 
[removed]
Monads in the error handling sense, or existential predicate sense (e.g. Rust's `Ok`/`Err` or `Some`/`None`) aren't so popular because everyone is a secret Haskell admirer. It's because `nil`/`null`/etc. [belongs in the dustbin of history](https://www.lucidchart.com/techblog/2015/08/31/the-worst-mistake-of-computer-science/). A nullptr is a "thing". A zero is a "thing". An empty string is a "thing". A `nil` *is not a "thing"*, and shouldn't be passed around as one! The difference between monadic `None` and value `nil` is the same the difference between me telling you, "I have nothing to give you", and "Here, take this physical thing which happens to be *nothing*. Don't spend it all in one place!" *(in fact, don't spend it at all or get a nasty runtime exception)*.
Way to toot your own horn, while patting yourself on the back. You make a bunch of assumptions to prove your point. After reading the article, I am making a few assumptions that put you in the same group that you belittle. 
It also makes a bunch of assumptions about what a constructor must return by convention, which is a load of crap. Who says that a constructor must return a pointer-type or an error.
Looks OK to me. Your NewSensor function is probably unnecessary; anywhere you call that you could just use x := Sensor{&lt;values&gt;} Abstraction-wise it looks OK. You've pulled the only command out into an interface so you can call it for different implementations. I would rename it to Reader though. If you add more commands you'll be tempted to add them to a common interface. Instead of grouping functionality by source, group it by use. So instead of having a single interface for all sensors, have an interface for all the functions that a caller will call on an interface during an operation. That's not very clear, let me give an example: Let's say you decide to abstract the configuration more. So you implement a Configure function to take a chunk of JSON and set the sensor up. You'd be tempted to do this: type InputSensor interface { Configure(String) error Read() (measurement, error) } because that's the things a Sensor does, right? But it makes much more sense to separate them into Configurable and Readable interfaces. That way when you start playing with motors you can re-use the Configurable interface. Or when you start reading from StdIn which isn't Configurable you don't break anything. You might have a Calibrate operation that needs to happen for all reading sensors (for example). Your code doesn't want to work out if the sensor needs to be calibrated or not, so it makes sense to add that to the Readable interface, like so: type Readable interface { Calibrate(Int, Int) error Read() (measurement, error) } Because these things are related to the Read operation, they belong together. I hope that makes sense...
This is gnarly. Interesting job, man.
agree. This is Go written by a Java programmer. Go programmers typically put tests right next to the file that they test, rather than in a separate "tests" directory, for example. Go has semantics around vendoring that mean "lib" is badly named If you're going to build a huge sprawling project, then Clean Architecture is worth knowing about. But I think applying it this rigidly from the start is a mistake. Like any pattern, it's a guideline, not dogma.
Thank you, guys. I already solved this problem. By upgrading Golang version 1.7.* to 1.8.* Here the issue I created on goose repository [ https://github.com/pressly/goose/issues/49 ]
Thanks :-)
With this you can boot to Golang without a kernel or linux os. 
Did you mean to add a defer to 2nd code listing? It looks identical to the first. The third code listing adds both the defer and the signal handler.
Near as I can tell from reading the README, the bare minimum OS pieces from Plan 9 were added directly to the Go Runtime so it it's own operating system.
Near the bottom of the sales page there are all the options listed, including a "just the book" option.
Cool work!
Camlistore is an artifact from Go pre-1.0, I wouldn't look to it as a place to learn.
This is great work! I am guessing from your example and a brief skim of this code I could use `(*Decoded).Read([]uint8)` to create streaming by reading it chunk by chunk. I may have to fiddle around with my own code to make it all work with uint8 instead of byte though.
Anyone using Atom.io ~~as editor for Go~~ and find it constantly crashing? FTFY!
Now try using another integer type lol! Yeah, you're kinda stuck without generics. Seriously though, just use a `for` loop.
Whoops, typo :) FWIW, none of the code-snippets in the post are actually tested ;)
What does this have to do with code quality? Many pre-1.0 patterns are still valid today.
Yes, you are right, I'm working with currency. I will try out the library you suggest. But I'm still interested why is it only about this "magic" number?
Never mind. I see that the current implementation lists it requiring a specific piece of hardware: the Freescale iMX6 Quad SOC. He states that he's plans to bring it to the Pi eventually. Cool!
Different versions had different performance characteristics regarding the garbage collector... So it is somewhat useful in certain scenarios. 
Be careful though. Some of the standard library is quite old and is not necessarily "good" Go code. 
Thanks for the feedback from you and TheMerovius. The "for DevOps" part is because we built our DevOps monitoring platform's system agent in golang and shared significant amounts of our code from that agent in the post (the first one at least). We wanted to share our experience with the DevOps community to show the advantages and pitfalls of using golang for DevOps-focused applications. We're currently writing our next series in the post. To make it more "ops" focused, what would you like to see in the series going forward?
You could also just close the original channel on the quit signal. All goroutines listening on that channel will get the empty value once the signal handler closes it and can exit. 
If speed weren't noticeable in a web application, the New York Times website could be hosted on a Raspberry Pi. When it comes to servers, a lot of the time, performance is more in terms of efficiency than speed - i.e. how many requests per second can be handled by the same amount of hardware. As to whether it's "worth it", that's up to each developer to decide for each specific situation. Maybe the performance alone makes it worth it, maybe it doesn't. Maybe the scalability makes it worth it, maybe it doesn't. Maybe the ease of deploying a Go app makes it worth it, maybe it doesn't. Maybe one developer prefers a strongly-typed compiled language while another prefers a dynamic-typed interpreted language. It's largely a matter of personal preference and project requirements.
I found this link on HN just recently: https://github.com/gophersgang/go-non-trivial-apps
&gt; A nullptr is a "thing". A zero is a "thing". An empty string is a "thing". A nil is not a "thing", and shouldn't be passed around as one! In Go, `nil` is the zero value of a variable of pointer type. Surely it's just as much a thing as a zero value of any other type?
The required OS calls were re-implemented in Go and are included in your binary. This project in theory bootstraps bare metal directly to your application. No word yet on if that is a good idea or not.
**Generics in Java: Problems with type erasure** Generics are checked at compile-time for type-correctness. The generic type information is then removed in a process called type erasure. For example, List&lt;Integer&gt; will be converted to the non-generic type List, which ordinarily contains arbitrary objects. The compile-time check guarantees that the resulting code is type-correct. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/golang/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot/) ^] ^Downvote ^to ^remove ^| ^v0.22
just starting out with go... could i read your bundle for free? thanks
Why not a V1 UUID? You can store it as a string, it's time-based, and it's random (enough?). If displaying a long ID is a problem, you can just Base64 encode it to be used in a URL.
TL;DR: Never use floating point if rounding errors (small or large) are a concern. Accurate math requires integers and safe integer operations (addition, subtraction, multiplication). Floating point can only represent some values precisely due to its design. In its simplified form, a floating point value is calculated as s * b^e, where s is the significand, e is the exponent and b is the base. In our case, the base is two, turning it the equation into s * 2^e. You can't express the value 1/3 using when the base is 2, although you can get awfully close if with some crazy large and obscure values of s and e. Also note that using integer operands is not enough, but you may only use "safe" integer operations if you need to maintain an accurate value. A division of integer operations always rounds towards zero—that is, 2/3 yields 0—which is basically a guaranteed rounding error. Likewise, casting a floating point value to an integer also round towards zero.
We build our Go binaries in a docker image because we cross compile using cgo (we use `xgo` in the docker image), so having one environment across our team makes a lot of sense. Recently, a coworker's build failed. He hadn't run a build for quite some time (6 months or more), and it turned out that his docker image was old (running 1.6 instead of 1.8), and we recently introduced a change that required a more recent compiler. It would have been very easy to check the binary for the Go version number, but instead we had to look through release documentation to figure out what version introduced the change (I think it was 1.7). Basically, we ended up spending quite a bit of time on something that should have taken 2. In the end, I think I ended up using `strings` and grepping for something that looks like the version number, but it would've been nice to know that `gdb` could do it too. Another thing that could've helped in this situation is including which version a particular API was added in, but that's more specific to our use case than anything. Also, like /u/dericofilho said, different versions have different performance characteristics. We *must* build with something &gt;= 1.4 because of GC performance (and we must build with something &gt;= 1.6 for the cross compile to work), and in the past it had been hard to track down whether problems we were seeing were due to our build process having the wrong version or if we introduced another bug. There's also the problem of checking whether a binary has a security patch. We use SSL and a few other crypto things and we install on secured sites, so we need to know that our package was built with a version of Go that had the security vulnerability patched. In short, it's occasionally useful to check the version of Go a package was built with.
Session per Request is a very well known pattern in Java and C# that does exactly what @kaeshiwaza replied with. Would love to hear your feedback on my take of doing it in Go https://goenning.net/2017/06/20/session-per-request-pattern-go/
Glad you found it useful :)
It's absolutely noticeable and it's one of the reasons I'm switching to Go from Ruby on Rails. Now Ruby on Rails is known to be quite slow (as mostly anything written in Ruby is) and I'm not sure about Django's performance, so you may want to do some research and check out some benchmarks before making the leap. In my experience so far, Go has been a harder language to learn than Ruby was. I tried my hand at Python awhile back and it wasn't much harder than Ruby, so keep in mind that you might have to spend more time learning the actual language before you can make sense of a web framework written in it.
Depending on the framework, that might be the problem. I found Go's stdlib web components very easy to learn.
You could base it partially on the current geographic coordinates of the computer so two computers have to be in the same place to collide (physically colliding) and then you can have smaller IDs without worrying about collisions.
It depends on data that Sensor holds. If, for example, Sensor is just some sensor id, then I prefer to pass it as an argument. You could try to name that function more implicitly. That is, technically those calls the same: func read(a, b) m func read(b, a) m
Now this is interesting. Could this be modified to be hard real-time? Because a HRT kernel with language-native concurrency primitives would be basically the best thing ever. With a reference counter instead of mark-and-sweep, I imagine you could get basically the same memory management schema as in regular Go but without the worldstopping, which is crucial in HRT. Then again, GC is too damn complicated to speculate about.
I'm working on a OSS web project written in Go that you might find useful https://github.com/getfider/fider This repo also contains a nice collection of libraries and apps written in Go https://github.com/avelino/awesome-go
How about using an interface like io.Reader to read. You can then use some decoder to decode the content. That way you keep your code clean an separate without binding too much logic to entities at all. There are decoders for hex and base64 in the stdlib that you can use as examples.
interesting, what is this kind of stack database useful for? what are the use-cases?
The way floating point values work is that they take a big number range, and break it up into as many buckets as there are bits in the representation. So, as a thought experiment -- because this is NOT the way it's actually done, simplification to aid in understanding -- imagine you had a 3 bit floating point number that represented values between -75 and 75. The first bit represent positive or negative. I'll use 0 for positive values, 1 for negative values. The ONLY values representable would be: 011 = 75.0 010 = 50.0 001 = 25.0 000 = 0.0 100 = -18.75 101 = -37.5 110 = -56.25 111 = -75.0 And here's the point: those are the ONLY numbers that can be represented in this "floating point" system. If you use 32 bit floats, 2^32 numbers are representable. With 64 bit floats, 2^64 numbers are representable. As far as floats are concerns, all numbers that do not happen to be represented, simply don't exist! Here's a concrete example in the [Go Playground](https://play.golang.org/p/-oENvtuLSB)
I'm working with python/django for +7 years, but now i'm using Go whenever it's viable. There's a lot of web frameworks in Go, but you really don't need them. The standard library is awesome. I would recommend Go if you: * have performance problems with django/python or performance is a **big** concern; * are working with a huge project and/or have a large number of developers working with it; * need a really good first-class concurency. But there's no magic inside. If you use a lot of meta-programming, generics and DRY concept, you'll miss some "features" in Go. And you'll need to forget a lot of the *django way of do things*, it's another language, with another concepts, and you'll need another mindset too. I think that if django is OK for your projects, use the right tool for the job and don't blindly follow the hype. Except for fun or learning purposes, of course. 
I was really happy to see this but then I noticed it still used cgo to actually play the audio :(. It's obviously a lot more work but I wouldn't call this 'pure go' while advertising the ability to play the mp3. The decoding part is, so the headline isn't wrong I guess.
I like the bindata approach more than to have json file somewhere on the disk.
The description of this job is darn near exactly my dream job. Doing backend development for a video game. I'm seriously envious of whomever lands this. Only reason it couldn't be me, is that I'm nowhere near a "senior" level developer (indeed, I am only a non-professional hobbyist). Nor can I relocate anywhere for the task. I'm truly remorseful that I can't find something similar meeting my requirements of experience and location/remote.
The player is not part of the decoder. I think we can still say go-mp3 is pure Go, right?
I'm coming from all those P languages as well (Perl, PowerShell, Python, PHP) and I've been writing Go exclusively for the last 6 months and love it. In no other language have I been able to write so many lines of code without a face plant as I have in this language. Gopher for life.
I wrote PHP for 10 years then switched to Go 5 years ago and never looked back. Not once. Not even tempting. Lot would have been impressed. 😊
Whole lotta problems with this though. How do you get the coordinates? Only a select few devices even have a remote guess as to your location. What do you for computers in space (I'm thinking satellites, spacecraft, the space station, and future Mars or moon colonies)? A computer in a certain location one minute will be in a different location in another minute, even if it doesn't move relative to the Earth, because the Earth is moving. You'd have to combine it with time, which is another hard problem, and it's what we're already using.
Why do you believe I don't k ow what you're doing? As I mentioned you are, of course, welcome to do as you please. Which doesn't meant your application is HTTP compliant. Have you considered any of what I've said, and what the HTTP specification sections I've quoted mean?
I'm not gonna say any language is just better than any other, but I do want to mention that if you're considering PHP, you may want to consider Hack instead: http://hacklang.org/ It's a super-set of PHP and what Facebook uses these days. But that said, for most projects I would say Golang is the way to go.
I'll go and take a look to address your comments. Thanks.
Do you mean pass the `c` channel to each goroutine, then close it after it received the os.Interrupt? Yeah, that sounds like a great idea. Essentially getting rid of `stopChan`?
I'm happy to update the article to include more ideas/libraries but I haven't encountered more. Not saying they don't exist, just that in my research I found the ones I described. I do have an article in the pipeline about go-hashid, which is what you described at the end, but it's a different kind of animal, used for a different purpose. Notice that all those libraries are about un-coordinated generation of IDs, not cloaking the ID. Again, not saying cloaking is not important in some cases, it's just not what those libraries are about. I'm not a cryptographer, but that one sentence about "seeding random from time" packs so much FUD, I don't even know where to begin. Actually, I do know, from the start: 1. Random value part is meaningless. It carries no information. Its only purpose is to be unique with high degree of certainty. There's no "privacy implication" because there's literally no data in it. Not to mention the attacker has no idea when the value was seeded. Could be minutes ago, could be hours or months. 2. That's not even what happens. ksid reads from rand.Reader, which is not time-seeded. So does xid. ulid leaves that to the caller. Only betterguid seeds with time. The part about leaking time: you're absolutely correct but then again, when does it state otherwise? I trust that people can read. If I were to publish a steak recipe, I don't think I need to warn vegetarians that it contains meat. If leaking time in the id is not appropriate for your use-case, then do you really need some special warnings in addition to: * "is time-clustered i.e. ids generated at the same time are close to each other when sorted" * "use time as part of the id to achieve time-clustering" * format "4 bytes of time (seconds) + 16 random bytes" 
Post your question to /r/php and hear the other side of the story... Not everything in golang is as shiny as it seems. 
I am playing with scat :) right now. Its super cool! After uploading to Google Drive using rclone, the number of chunks in index and the number of files uploaded in the Google Drive folder is different: - the Google Drive folder was empty before backup - this is the first, full backup to that folder - restore worked successfully. Could you please explain why? In my case, there are 810 chunks in index and 784 files in remote folder. What are those "redundant files"? Backup command: tar c "src" | scat -stats "split2(1mb 4mb) | backlog 8 { checksum | index index | cmd xz -z -T 4 | checksum | cmd triplesec -b enc -k $key # to encrypt chunks | concur 4 stripe(1 1 gdr1=rclone(gdr1:test) ) }" And a feature request: ability to restore single/multiple file(s) of a snapshot (like [duplicacy](https://github.com/gilbertchen/duplicacy)). Thanks for making this awesome app.
Exactly my thoughts. Rest assured it works perfectly well for us in Production, with millions, if not billions, served so far.
Maybe this depends, but I would think most serious deployments will have some sort of proxy and routes should be whitelisted. Is that not as common as I'm thinking?
This is really nice! Needed something like this a month ago. Damnit :D
I still do PHP at my day job, but have all but abandoned it in my personal time, only touching it when I have to on older projects of mine. I've been churning out Go projects for a few months now and it's been much more enjoyable. I would still consider PHP for a web application, but may also choose something like Kotlin w/ Play Framework too, as I don't really think that Go is too great at web applications just yet. Web services on the other hand, it is awesome at IMO. A lot of the things I'm interested in developing now are CLI tools, or backend projects. I'm also keen to get on with more Angular, so I'm hoping to combine Go and Angular into something reasonably soon. After having dealt with Go, PHP has lost a lot of appeal.
I don't know. I want to get to know.
Thanks, I've added sonyflake to the comparison. Although they give you uint64, which is reasonable, but don't have built-in compact encoding to a string, so to get a really short string representation, one has to implement his own base62 or base64 encoding.
&gt; But is the scheduler really nondeterministic? I think so. Maybe it is possible to build your own deterministic scheduling policy as was proposed by Dmitry Vyukov in the below link: https://groups.google.com/d/msg/Golang-nuts/qwWhvQDdnZg/mGP9hXKDeGYJ
Go does not have exceptions, how to you capture the error from open?
Whilst Go do not have the 'Try {} Catch (This) {} Catch (That) {} Catch (The Other Thing) {} Finally {}' of say C#, most standard lib functions that may cause trouble also returns an error. So in Go, error handling is more granular. The advantage is that each and every time you ignore checking for an error, you do so consciously. You can't 'forget' to check for error. There is no ignoring a potential fatal error by mistake. It also makes error-logging a bit easier, but that is another topic. On the downside, it do make for a lot of boilerplate code repeating this pattern all over the place: f, err := os.Open(credFile) if err != nil { log.Printf("No file %s found",credFile) log.Fatal(err) } defer f.Close() but then again, you can use the err return to do all kinds of nifty things. Checking for EOF for instance. Setting initial state for when testing on local and the TSL certs are nowhere to be found is another. Whilst I like the C# method of error handling, I love the Go way of doing it :)
What about using math/big.Rat?
$39 for ebook &amp; another $40 for `3 Bonus Chapters*` , so the ebook itself is not complete?
Here's a [version](https://play.golang.org/p/ybo1P2K2nb) that's modified to capture Errors. Note: If there is an error during *enter*, it's up to to *exit* to either not do anything, or have exit behave in a way that is idempotent to enter.
We can code together, i'm looking for contributors: https://github.com/orderbynull/lottip
&gt; It seems a little backwards to keep a persistent HTTP connection open and for the server to send down to the client. That's exactly how it works though. It's a chunked http connection, there's not much more to it.
The book itself is complete. In it you learn how to create a web app, make it prod ready, and deploy it. The bonus content includes interviews and other resources, plus the 3 bonus chapters, so it is more than just 3 bonus chapters. In the bonus chapters I am covering an integration with a third party API, OAuth, and other things that you may or may not be interested in once you have built an app. These are more advanced topics so you could almost view them as a follow-up course. I know $39 sounds like a lot, but you will get tons of value out of the book. I have had college students tell me they learned more from this book than in multiple comp sci classes put together. I have had experienced devs buy multiple copies for peers because they enjoyed it that much. What I haven't experienced is a customer buying any package and telling me they didn't think it was worth the price they paid. But if that does happen I will happily issue a refund.
&gt; What I haven't experienced is a customer buying any package and telling me they didn't think it was worth the price they paid. But if that does happen I will happily issue a refund. Does it count if your wife doesn't think it's worth it? She sounded a bit unhappy when she saw the 40$ bill. ;)
&gt; You can't 'forget' to check for error. There is no ignoring a potential fatal error by mistake. package main import ( "fmt" "os" ) func doSomething(f *os.File) { bytes := make([]byte, 5) num, _ := f.Read(bytes) fmt.Printf("Read %d bytes\n", num) defer f.Close() } func main() { f, _ := os.Open("/lolthisfiledoesntexist") doSomething(f) } 
I just wanted to mention that pila in Portuguese means cock (not the animal)
Not only there's `_` in your code which looks like something is missing there but go lint will (probably) complain too. Compare that with the exception approach, for example in Java where you'd end up catching an IOException and the "standard" way of handling that is by printing the stack trace because "ain't nobody got time for that!". So we end up with a program that treats a missing file as something exceptional and throws a stack trace in your face. The Go approach while it might be more boring/verbose it creates much more robust codebases.
Or you can use a language with a proper type system like Rust, where it genuinely *is* impossible to ignore errors.
PHP or Python are fast enough for Web sites that I am building. The reason I am using Go is its deployment story. Copy build artifacts to server and you are done, no need to check runtime versions or dependencies. Easy maintenance. And with Web sites, maintenance after going live is a huge chunk of work you are going to do. 
You could just close `stop` in the signal handler in your third example . Even with multiple tick() goroutines running, each would get an empty value in the select case for stop. Closing a channel basically acts as a one-time broadcast to everything listening on that channel -- it's a useful way to signal multiple routines to stop. 
More magical :)
There are some valid use cases for encrypting passwords; but they are few and far in-between.
That may be the case, but despite the name this package doesn't do encryption, it's just a simple (broken) wrapper around pbkdf2.
I believe there are static analyzers for Java that can tell possible exceptions, at least to some degree. Anyway, Go's error handling style isn't new, it's basically C-style error handling adapted for Go. In C, it is often also immediately visible whether error is handled. When someone mallocs, you can see whether they check for `NULL` (the simplest example of the top of my head), yet it doesn't prevent shitty error handling. I'm fond of Rust's style of error handling, for example, which is also the "can't ignore" type, yet I'm pretty sure sooner or later there's gonna be problems with `unwrap()s` left somewhere in code... I guess I'm too much of a skeptic at this point... 
Wasn't suggesting comparing passwords directly. Just the verify methods take a password and a hash to function. 
I'm comfortable with func YesIHaveNamedReturnVals() (err error) { f, err := os.Open(...) // handle err, of course defer func() { closeErr := f.Close() if err == nil { err = closeErr } }() } except for its verbosity; unfortunately you really shouldn't "err = f.Close()" because if there was already an error, that error is the one you care about, so you need to take some care to not whack that one. I've never had this come up enough to abstract it but I suppose you could func SafeErrClose(closer io.Closer, errP *error) { err := closer.Close() if err != nil &amp;&amp; *errP == nil { *errP = err } } func IAlsoHaveNameReturnVals() (err error) { f, err := os.Open(...) // handle err, of course defer SafeErrClose(f, &amp;err) } [Seems to work](https://play.golang.org/p/ah26QTj8sQ). As I [said recently](https://www.reddit.com/r/golang/comments/6gsjlf/dont_defer_close_on_writable_files/disz30p/), I think this is an acceptable use of named return values. If the rule is "only use named return values when a defer is modifying them" it seems to me the community opprobrium on them should be lifted; a rare syntax for a rare-but-necessary use case isn't necessarily a problem. 
You also checkout [nchan](http://www.nchan.io). It supports more than persistent http connections.
I agree that the name `rune` might be odd, but the odd part is just the name (this could be a bike shed problem and I don't have a better idea, but I'm fine with the name as long as everyone knows that `rune` indicates characters in Go). I feel like an alias for characters is not unnatural. On the other hand, `byte`doesn't hide any details and that's why I think `uint8` is enough.
&gt; ...it is free for individual users or any company or organization with less than 5 users. If your company or organization has 5 or more users, then a license for the actual number of users must be purchased from duplicacy.com. i.e. if you work for a really big company, you can't use it unless by some miracle you can get company-wide approval to buy and manage licenses. #savedyouaclick 
I think I'll be using that for my code, thanks.
I prefer golang's defer over Python's with statement. Having to add an indentation level for every managed resources is a PITA, especially when you use multiple resources. To keep it clean,code usually ends up looking like. def dostuff(): with resource() as r: dotherealstuff(r) def dotherealstuff(r): # real work 
You can still use the software to back up your personal files.
You can see it live here http://demo.fider.io/ And this is how Google sees my page http://i.imgur.com/9kT9qu8.png Source code is here https://github.com/getfider/fider 
Same what? The google rendered image? It should be the same. Which means google crawler has the same view as a human and can index it properly.
Sorry, thought I was responding to /u/mcouturier who I responded to. You and I see eye-to-eye on this. There was probably a time when Google couldn't handle this, but today it's an old wives' tale.
I don't understand, why would anyone need a server that has a bunch of stacks? And why would you use a stack for caching when you can only retrieve the top item efficiently?
Maybe you don't realize this, but you can do the same identification of exceptions as in Java... switch err.(type) { case *myError: ... Error is just an interface, you can return anything that satisfies it and type check later. 
You didn't forget anything - you *explicitly ignored the errors*. That's an important distinction.
I apologize for the misinterpretation of your post, I wasn't contending your statement though. Just wanted to clarify so people didn't feel compelled to use subtle package by mistake.
Redis is a server that has a bunch of data structures, right? At the end, a stack can be used as a key-value store, where the ID or Name of the Stack is the key, and the peek of the Stack is the value, but storing old versions of it, and we can agree that key-value stores are a thing that people use. Said this, next version of the project (0.2) will expand the functionality of the stacks, being able to push elements at the bottom (thus, they'd become queues too), rotate elements, and more. 
Neither of these function signatures make sense to me. In (1) you're passing in a sensor and then reading from it, on a function that's on a GrovePi. The function doesn't have anything to do with the object that it's on, which is odd. In (2) you're passing a GrovePi to a sensor and then reading from the GrovePi. Again, it has nothing to do with the object that it's on. Unused arguments are a code smell, especially if you're not trying to satisfy an arkward interface.
Out of curiosity, why not go with websockets?
I feel the same, but I can't find a solution. Can you?
Remember that over all these crappy stacks you have a HTTP layer, so you can actually share them between applications. Thanks for your feedback, believe me I'm working on making this software less terrible. And I take that _almost_ as a compliment ;)
The link doesn't seem to always work quite right. I'm specifically referencing the following comment by griesemer: &gt; @rsc will talk about "The future of Go" at GopherCon in Denver (https://www.gophercon.com/schedule, Day 1, Main Stage). I you're not attending, all talks will be recorded; and I'm sure important things will be tweeted as well. That's probably a good talk to listen to regarding a future Go 2.
Believe what you want. Ignore mathematicians at your own risk. HTTP isn't an abstraction, it's an APPLICATION level protocol. REST isn't even a thing, it's just a way to get people to exams what is already in the HTTP spec. &gt; You're getting mired down in semantics No, I'm reading the SPECIFICATION. &gt; and missing the bigger picture Haha. Your bigger picture is "I'm free to ignore standards and do whatever I want." The big picture IS the HTTP spec.
I'm not sure I understand the problem well enough to do that. If the relationship is that sensors belong to a board, you have the questions - * Does my board have an array of sensors, or a way to look them up? * Does a sensor know enough to handle reading by itself? * Does it make sense to expose sensors to things that interact with a board? * Can I encapsulate details of that relationship by having the board handle things? 
I thought that websockets were generally more efficient than long-polling connections, and have built in support in a number of languages. 
Hi thank you for looking at the code, it's appreciated. Regarding the garbage collector, the problem with building an evicting cache in a garbage collected language is that while you wait for the runtime to schedule a GC event, both the allocated elements in the cache and the evicted elements are residing in memory. What I was seeing was that the program was actually allocating double the amount of memory it was actually using. That's why I found the solution of forcing a GC periodically. You can see the results of different tests with this in the simulation here https://github.com/emluque/dscache/tree/master/simulation . And it's also available to run with different parameters. Regarding the use of Panic, what I'm trying to express is that this is a condition that should never arise in sane code. According to the Go Programming Language book "A panic is often the best thing to do when something "impossible" happen, for instance, execution reaches a case that logically can't happen". Even in the link you have provided there is an example similar to how I use it: func fields2numbers(fields []string) (numbers []int) { if len(fields) == 0 { panic("no words to parse") } .... My rationale is that the only way you could be calling the function with a zero value for size is that your code is seriously wrong or somebody is messing with your binaries. In this type of case, I'd rather fail fast and fail early so that the calling code that causes the panic is fixed immediately ideally during testing. 
I am aware, I also know that Go will still play games behind your back with threads when calling potentially blocking external code to keep everything running. And I spent a couple of days tearing my hair out, trying to figure out who was doing what and when inside the Go runtime when it occasionally crashed because some goroutine stepped on someones toes when calling C. It's not worth it to me, there are better compromises.
It's happening! 
Not as main lang, but there's some Go in https://github.com/gophercon/gophercon.com, https://github.com/gophercon/2014-talks and https://github.com/gophercon/2016-talks. Well, this is mostly website (which obviously includes load of HTML/CSS and JS) and slides from the talks.
That's fine, keep up the good work. I had problems, and I tried my best to solve them but in the end decided that kind of complexity just isn't what I'm looking for in a system language. It's obvious you could benefit from opening your mind a tiny bit and not defending your choices so desperately.
[go-fuzz](https://github.com/dvyukov/go-fuzz) 
what are the obvious reasons?
When people blame a language runtime, most of the time the problem is not in the runtime itself. Sorry. Good luck.
I'd assume that moving from Jekyll to Hugo isn't high on their list of priorities. It wouldn't be high on mine. 
The link reveals: Day 1 July 13, 2017 9:40 AM - 10:05 AM The Future of Go Let's start talking about what we - the Go community - might want to change about Go. Russ Cox And just before @griesemer comment is the @rsc comment: We're not considering any significant language changes today. I'm just organizing. Doesn't sound like anything more than hot air. 
If you can get it to work. I have a Windows box and tried backing up to b2. It only goes so far, then stops. I can't find any log files to tell me what is going on. I gave up on it and am looking for something else. I wish Arq supported b2. 
Right, because the GopherCon website should be a Go program that talks gRPC to their Go API server to buy tickets. That's all really important. And of course Go (and Linux apparently) is the best for everything and if it's not we should all suffer and use Go ANYWAY because we're confusing liking using something and being single minded lunatics. 
Thanks. With golang gaining popularity for command line tools and scripting, and with our additions of code samples from our smart agent (written for a very specific DevOps purpose), we felt that it tied into "for DevOps" nicely. However, your points are valid. We're publishing our next post (#3) next week, so I'd be interested to see what you think of that one after we implement some of your feedback. -Philip
Interesting info on the simulation. The article section talking about fields2numbers specifically says about the panic being within a package, not across boundaries. ..."Within a package, however, especially if there are deeply nested calls to non-exported functions, it can be useful (and improve readability) to use panic to indicate error conditions which should be translated into error for the calling function" and in the example code, they are using recover to catch it, so I don't find that similar to the DScache style defer func() { if r := recover(); r != nil { ... 
It's been every year in Denver for like 4 - 5 years. 
Oh, I wasn't aware. I'm a fairly new Gopher and so haven't done all my research yet. 
Exactly. OP, can you articulate what you don't like about https://play.golang.org/p/F_Hu8HGlqu ? (Beyond "It doesn't look like python") 
https://www.gophercon.com/ is run by https://gopheracademy.com/ and the website's repo is available https://github.com/gopheracademy/gcon - here's some "Go code" in the root repo: https://github.com/gopheracademy/gcon/blob/master/main.go But the repos you're specifically referring to also has "Go code" here: https://github.com/gophercon/gophercon.com/tree/master/app/controllers But /u/ask probably says it best https://www.reddit.com/r/golang/comments/6iokcq/til_there_is_no_go_code_in_any_of_the_gophercon/dj80wps/
Typed quickly straight into reddit but something like this: import "github.com/tv42/topic" type MyApp struct { msgs *topic.Topic } func NewApp() *MyApp { app := &amp;MyApp{ msgs: topic.New(), } // simulate activity; this silly example leaks a goroutine go func() { for { time.Sleep(100*time.Millisecond) app.msgs.Broadcast &lt;- "hello, world" } }() return app } func (a *MyApp) ServeHTTP(w http.ResponseWriter, req *http.Request) { ctx := req.Context() enc := json.NewEncoder(w) ch := make(chan interface{}, 100) a.msgs.Register(ch) defer a.msgs.Unregister(ch) for { select { case msg, ok := &lt;-ch: if !ok { log.Printf("kicking slow client") return } if err := enc.Encode(msg); err != nil { log.Printf("cannot marshal json: %v", err) return } if f, ok := w.(http.Flusher); ok { f.Flush() } case &lt;-ctx.Done(): // client canceled request return } } } 
I believe tickets are still on sale until June 30th.
Depends on the organization and their resources. A small organization would probably prefer a self contained app that is easy to deploy and configure. If there's multiple apps on the same server I would prefer having a proxy. However, it's always comforting knowing that your individual apps could be shipped as independent components without worrying about security or running out of sockets.
For what it's worth I switched a site recently from Jekyll to Hugo and am quite thrilled with how it went. LOVE Hugo. Not a big fan of the Ruby environment Jekyll requires. 
They've had a pattern of moving issues to the "Go2" tag for the last few months, even if the change is backward compatible. (It happened to my proposal too.) This doesn't really add any new substantive proof, but it's more circumstantial evidence that Go 2 is being discussed inside Google. 
Sorry this is delayed (I thought I sent the message earlier). If you are interested in the course and the price is a major barrier email me - jon@calhoun.io My goal wasn't to price anyone out, so I'm happy to work with you or anyone else who wants to learn but can't afford the price tag.
Yeah, unfortunately a student budget doesn't allocate for an $800 ticket, haha. Maybe after I graduate. =) 
I think the way to go is to have an employer bring you there. As I understand it, that's how most professional conventions like this expect you to pay.
Regrettably I don't have one of those yet either, haha. Soon! 
Best of luck out there :)
thanks for offering! I'll take a look
which standard library do you guys recommend to start with?
I strongly disagree with your argument. Without saying that the op is right, I don't see why the fact that it exists in Python make it unsuitable to use for Go. It's like saying hey there are pointers in C, but this is Go not C, so let's avoid pointers to be different. There is no problem in taking ideas from other languages. Whether taking a particular idiom is a good idea or not is an other discussion.
Nice job! I was motivated to do it myself, so it might interest you to compare what I used: https://github.com/200sc/klangsynthese/blob/master/audio/audio_windows.go (my implementation is making no effort to conform to io.Writer, etc interfaces, so they're a bit different. You might also find some of the utils you made in the dsound library I used)
our first websites 2014-2016 were in hugo - they're in the gc15 repo. Current site (in GO) is at github.com/gopheracademy/gcon What's the point of this troll post?
You can pipe the logs to a set of fewer goroutines dedicated to writing via logrus API, less log contention but will have some.memory penalty. Or just don't use logrus, use something like zap or similar. 
You missed the point. Who is to say what is spammy? This is a content aggregation site fueled by the users - not the mods. Recently an article/blog by peter was posted here. It read like noise. Made a metric shit-ton of assumptions. Had an overtone of self-superiority. Just a terrible read. Some liked it, some didn't like it. It gave peter exposure. That exposure created opportunities, whether directly or indirectly. Those opportunities have potential to create monetary value. Should we remove articles that create exposure for peter?
Thanks for replying. &gt;You can pipe the logs to a set of fewer goroutines dedicated to writing via logrus API, less log contention but will have some.memory penalty Ya, that will require me to write some code. Does zap not block the calling goroutine?
&gt; A user is defined as the owner of any files to be backed up by Duplicacy. If you are an IT administrator who uses Duplicacy to back up files for your colleagues, then each colleague will be counted in the user limit permitted by the license. This directly contradicts the FAQ on the [fair.io](https://fair.io/#faq) info page, which defines "use" as directly interacting with the software. So this is not actualy a Fair Source 5 License but a derivative of it and should be declared as such. Additionally, this brings significant risk for users of the software. If you define "use" as anyone who has access to the files^(1), does that mean if I back up files from my public webserver I need ~1 billion licenses? Even if that's not the intention, could a windy lawyer *make* it mean that in a dispute? --- [1] **Note:** The quoted text refers to *owner* of the file, but that is self-contradictory, since the *owner* of those files is the organisation, not the individual employee who is merely granted access to the company's property for work purposes.
&gt; Coca means cocaine That part is quite intentional, since Coca Cola contained actual cocaine (well, coca plant extract) in its earlier forms. It was later substituted due to changing laws and health concerns as medical science learned more about the stuff...
Please God, make it so. I do not want a replay of Python 2-&gt;3.
All I want is generics for low level libs. I'll use interfaces when I can, I promise!
This package is provided by awesome web development package [gobuffalo](http://gobuffalo.io).
I am confused, are those tips for the standard json package or can they only be done with jsoniter?
It really depends on what sophistication means for you/others. For example. If you have two slices of type `[]T`, one would very much like to have an easy way to append these two slices together, like: s := s1 + s2 which today needs to be: s := append(s1, s2...) I see this as a sophistacated language feature, an operator on the slice type, which is as type safe as it gets (you still can't join two slices with different types). From what I see, at least supporting this kind of operator is reasonably possible, but I'm not completely sure if the compiler would just need to translate this case into an append() behind the scenes. I actually took a stab at implementing this once, and besides finding where to allow these kind of operations on slices, I didn't find out unfortunately how to actually implement it. Either way, if Go2 ever comes, I'd hope this would be included. Edit: fix code sample as per @KenjiTakahashi's comment :)
Why not just use https://godoc.org/golang.org/x/crypto/acme/autocert for the certificate reloading? I think robust routing is gonna have to wait till Go 2. 
AFAIR, the reason for leaving out `+` for complex types was to make the complexity more explicit. Apparently many people, when they see a `+` operator, they think it's a constant time operation, which it is not for slices. Not my thoughts, just sth I've read some time ago. BTW: I think you wanted `s := append(s1, s2...)` out there :-).
Very good and informative article. Keep up the good job.
Operator overloading is evil. It starts with innocent stuff like pretending concatenation is addition, and two versions later you use modulo for string formatting and floating-point division for string concatenation, but only *special* strings … hurf. If I wanted to use python, I'd use python.
Whoa this looks very useful! Thanks! If you know any more please let me know!
Instead of goroutines and complicated in-process logging, you could write the logs to stdout and redirect to a file where maybe you have a log shipper waiting to move log data to the ultimate destination yourbinary &gt; logfile.log ... or pipe the output into another binary that might (for example) push log data to a UDP endoint yourbinary | shiptoudp ... or use the local syslog mechanism if it is available to you.
I was planning on participating but as usual work/school slaps my plans in the face. I hope to see some submissions that I can use as inspiration when I have time to play with engo
I need to deduplicate large amounts of data entries on a cpu/mem budget, so I implemented a probabilistic approach using bloom filters. It's my first go project and I'm still learning, so any feedback is welcome. 
May I ask how do your write in stdout in Go?
That is a good point, but unrelated to the problem in the OP. Whatever is on the receiving end of the redirection is going to be the bottleneck that OP is already experiencing in-process, unless it solves the problem that OP is asking about. For all we know, OP may be the guy implementing the `shiptoudp` application.
My apology for not including B2 and Swift in the backends supported by restic -- they implemented both earlier this year and my page is a bit outdated. Regarding the multiple client use case, I can see two problems with restic because of their lock-based approach: first, the prune and forget operations will basically block any other clients from doing their regular backups; second, I don't know how reliable a lock implementation is on services like S3, B2, or Swift; distributed locking is a hard problem (https://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html) Disclaimer: this is based on on my read of their design documents. I don't have first-hand experience with restic. My attempts this morning to try it out failed on my Mac and Linux machines failed due to errors like `subprocess ssh: Permission denied, please try again` or `subprocess ssh: ssh_askpass: exec(/usr/X11R6/bin/ssh-askpass): No such file or directory`.
In essence, what you want to do is buffer the messages so that short term congestion won't hang the processes that are logging. For example, have all your logging directed to a goroutine via a buffered channel: package main import ( "log" "time" ) func main() { logger := make(chan string, 10000) go func() { for msg := range logger { log.Println(msg) } }() for { logger &lt;- "hello" time.Sleep(1 * time.Second) } } This means that there could be 10000 pending log messages before this starts blocking any thread sending log messages. Adjust the buffer size to fit the characteristics of your system.
That's correct. I was wondering if there's a logging library in Go which already has that implementation.
The `owner` of a file is the user account who owns the file in computer terminology, therefore for your web server only the user account that runs the web server counts as a user.
I will have to test this out, it would be very useful within a corporate network for authing users without having them pass any credentials.
Comments are very welcome! There's my email in there, or [here's my Twitter](https://twitter.com/TitPetric) if you prefer that :)
Thank you very much! :)
Currently reading the 12fa book as your reply popped up. I enjoy the language, its not formal which makes is quite an easy read. 
I sent you a bundle as well, but I felt that I should add something here - if you need help, you should post questions on the subreddit, and my inbox it always open for interesting problems :)
`array_merge` is nowhere close to append, it creates the union of two maps, as the function name clearly indicates. Or not. The operation is not even commutative! What the fuck PHP, you're the only language that has a dedicated concatenation operator with `.` and you *still* fuck this up! …q.e.d., *fuck* that level of magical behaviour.
github.com/inconshreveable/log15 has code that uses buffered channels. See http://godoc.org/github.com/inconshreveable/log15#BufferedHandler.
I worked on adding similar capabilities to github.com/go-kit/kit/log last year in https://github.com/go-kit/kit/pull/273, but ultimately abandoned it because the error handling didn't meet our standards. The log15 code just discards logging errors, and if that's OK and you would rather use Go kit's log, then you can copy the AsyncLogger type from here: https://github.com/go-kit/kit/blob/2a348cc41662e402da909dd91146435171d44bbc/log/sync.go#L84
and there's `array_merge_recursive` as well
There's no need to switch to another library. logrus already supports setting your own output writer, so just implement the above as an `io.Writer`: package main import ( "github.com/sirupsen/logrus" "os" "time" ) type bufwriter chan []byte func (bw bufwriter) Write(p []byte) (int, error) { bw &lt;- p return len(p), nil } func NewBufwriter(n int) bufwriter { w := make(bufwriter, n) go func() { for p := range w { os.Stdout.Write(p) } }() return w } func main() { logrus.SetOutput(NewBufwriter(10000)) for { logrus.WithFields(logrus.Fields{ "animal": "walrus", "size": 10, }).Info("A group of walrus emerges from the ocean") time.Sleep(1 * time.Second) } } So that's 16 lines of code, IMO too trivial to justify a new dependency
If you have hundreds of goroutines hung on logging, I have to wonder: is your logging too verbose? And if not, have you outgrown simple stdout/file-based logging? If you've got that much valuable log data, it might be time to ship directly to a logging service like Logstash, Graylog (GELF), Loggly, etc. or an intermediate log buffer like Redis or RabbitMQ, to be consumed by something like Logstash or Graylog. Like everything else, logging necessitates different approaches at larger scale.
Thanks for the article. These are not really random ids, they use some random bytes for uniqueness, but that doesn't make the full uuid random as it is has a predictable part (the time), so your title is pretty misleading. 
Why do you need templating in SPAs?
Yo don't. I was pointing out, perhaps not very clearly, that if you did want to render HTML from go that the template engine isn't as flexible as something like jade or ejs
Looks good! You should try comparing the performance of your bloom filters to that of other go implementations.
I'd just make the observation that a lot of the OO *principles* work in Go, the major difference is that you don't use inheritance.
Ok this is great, but do you have any tips to get me pointed to the right direction?
If your 500 employees use one shared user account to create/modify files and then use Duplicacy to back up these files, then yes, according to the definition it is only one user.
I've never heard of bloom filters before so that's very interesting, thanks!
+1 same situation
Beware passing mutable data to such an asynchronous logging mechanism, those races will hurt you. On another angle to solve your problem, https://github.com/uber-go/zap is blazing fast.
Anyone know why they bothered? I didn't really have an issue with Go-bindata, and it seems like writing a bindata packer is the hello-eorld of go libs
We use logrus and notice that with logrus enabled the throughput of the system reduces by 60%, we profiled and found that it is the json encoding which takes most of the time instead of lock contention. When you say you are having issue because of locking, did you profile your code? That said most of these libraries have their limitations, luckily you can work around them by writing your own. That is why zap was written. 
It's what they did before 1.0, every time they made a breaking change to the language (ie weekly) you could go fix it. Go was specifically designed for good tooling.
This started as a simple way to measure code performance and find possible bottlenecks (as well as goroutines that don't exit properly). I'm using it in conjunction with gorilla-mux (see the example in README.md) and have added it to all the important code paths.
Does this give you anything `grpc-gateway` doesn't? https://github.com/grpc-ecosystem/grpc-gateway
I like the API. I've used bindata before but this seems more natural to me. Nice to have options for sure! Thanks for the work / contribution.
Thanks! I was actually just looking through and wondering about the 40+ unresolved issues
Oh, I see. You've discovered that you found a better solution to stateless application design than HTTP. Good for you!
&gt; It may be better to write to stderr, though, because the log package uses it by default. Nice! Thanks!
Hi, sorry, yesterday I was sort of in a hurry when I read the article you provided. Actually, I was not aware of the convention of not panicking cross the boundary of packages. So it seems you are right, I will update the code, thank you for the suggestion. 
That will work but is much more complicated than I would have hoped. I was hoping I wouldn't have to resort to a pre-processor or macros. For my use case it is still easier to make a bunch of interfaces. Alternatively, I can use one interface with a bunch of concrete type switches to change the behavior depending on the concrete type.
How do you know no one at google is working on go2 ?
[removed]
The use case is that I have handlers that need to get info from different databases depending on the environment (e.g. test, dev). I want to abstract away the database connection using an interface so I can swap out the database without having to change the handler. Using a generic interface works fine usually, but for some of the models I want to do some things like field validation differently than in the generic.
I fail to see how a context managed world could "clean that up". Show me an example that actually handles errors on close better than the solution provided by /u/jerf. From what I can tell, your interface hides all the errors from the caller, which is distinctly worse than defer. 
Rather then abstracting the objects you are storing, try abstracting the database itself.
Yah, I could do that. It makes more sense. I could pass in a query string and a function for turning the results into the desired struct. Is there a canonical way to do this?
I like the fact that this very discussion is happening, among other discussions for improvements in Go 2.0. Bryan Mills followed up with information on overflow handling in other languages -- quite interesting. The related thread on arbitrary precision ints is also worth at look: https://github.com/golang/go/issues/19623
This is the opposite of the convention: // Get the string representation of a file: html := box.String("index.html") // Get the string representation of a file, or an error if it doesn't exist: html, err := box.MustString("index.html")
It is the GUI program and it was supposed to be running as a service. The logs tab only tells me that it paused the service. I can't find any log about what the service did. I searched for documentation on it and there was very little. I searched the forums and found nothing. So I deleted the application. It seemed like the appropriate thing to do. 
FYI, the Ariane 5 rocket reference comes from the type conversion lesson of my Go book. I hope it's helpful -- and entertaining -- to those new to Go. https://yng.mn/programminggo
Woah, didn't know about that! Is this already cross-posted to https://www.reddit.com/r/gogamedev/ ?
https://youtu.be/sXJ8tKRlW3E
It wasn't PHP's idea. It was stolen from Perl (poorly). 
&gt; You can ignore errors in rust like any other language. No, you can't. In Go, you can do `result, err := some_function()` and `result` is now a variable which may contain undefined junk. The compiler won't stop you from using this junk, it'll just squawk if you don't do something with`err`. That something does not have to be a valid check. Rust, on the other hand, makes it fundamentally impossible to mistakenly use an invalid result. This is a big difference, and it's the way Go should have done it if only its designers had understood sum types and pattern matching.
&gt;reflection based codebase would break That's the dangerous part of reflection. It's somewhat like (though less dangerous than) the pre-processor. Sure, you get to do cool things with it, but you loose optimization and safety. 
restic doesn't support b2 yet. Their documentation says it does, but it's not in the released code. :( Odd that it is in the docs but not in the code. 
Plan9 is slowly but steadily being rebuilt.
We usually suggest running the GUI program in the foreground to make sure the backup works before running as a service. That way you can immediately see what goes wrong. The log files can always be found under the .duplicacy/logs directory in the repository.
That is the weird thing I mean. I don't like debug flags deliberately changing behavior in the code by default. Yes, I would simply turn it on always, and be happy. But I still don't like the default. I also extra-freely acknowledge this is my opinion, and everyone is welcome to theirs.
ideally, it helps you track down broken behaviors during unit testing and manual testing of debug builds, giving you a stack trace and everything of where the mistake occurs, rather than just trying to understand some secondary effect that happens way later in the code as a result of unintentional wrapping. At release time, you've hopefully checked your numeric algorithms, and the small performance penalty is no longer desirable. I would prefer the default to be always checking for overflow, but I understand why they chose to default to silently wrapping in release mode. Release mode still has bounds checking on array access and other safety measures, so memory safety isn't at risk because of silent wrapping.
https://github.com/golang/go/blob/master/CONTRIBUTORS#L229 https://github.com/golang/go/blob/master/CONTRIBUTORS#L437 L O L
After much consideration, gnashing of teeth and what have you, I have come to a decision. I like it. Good show.
How does this compare to Go's built-in profiling abilities?
I have that shirt. I like the color. ^(It would be nice if the mascot didn't look like they've got a cold, though...)
Very nice cheatsheet. Thank you.
Honestly I think it depends how much integration you need in your dev environment. If you want anything more than syntax highlighting, fmt, and a file browser you're probably going to have difficulties one way or the other because Go uses the directory structure, a unique scope, things like that. If you're just now learning Go I would really suggest a plain text editor (Text Wrangler, Gedit, etc...) and a terminal. and also learn to develop with those in general. Most of the developers I know, including myself, are so much more productive when theres no fancy gimmicks between the code and the developer. When you first start developing like that its going to SUCK and you'll spend the majority of your time being confused and frustrated. In a week of full time development you wouldnt want to trade the terminal and text editor in for a $10,000 IDE. As far as any must have features that you want you can script them or use your current IDE to do them and switch over to your text editor to actually write the code until you wean yourself off them. In previous comments I saw you asking about a Debugger. This is where familiarity with the terminal is going to help. in go when panic(err) happens, it gets passed up through the stack. but pas all the error messages you also see packagename line number: column number. Thats generally where your error is. Never after, sometimes before. and adding a few fmt.Println(function called) ...fmt.Println(function returning) never hurt. It also sounds like you are having issues with your go installation and your go path. I have used go almost exclusively on mac (with very old free Xcode) with no problems at all. Editors like atom and sublime are great, but you need to know what packages to get what you want out of it.
I could live with that.
To be honest, I wasn't aware of the `x/net/trace` package. I've extended my `gorillamux` example to use both GoRef and x/net/trace and posted it here: https://gist.github.com/mreithub/ffc3356b10f44764a61d465834efee2e To point out a few (apparent) differences: * x/net/trace stores individual invocations (and seems to garbage collect them after exceeding a certain limit), GoRef tries not to (but I will probably add rolling averages) * GoRef is easy to parse programmatically (e.g. throw the JSON data it into your favorite monitoring tool and call `Reset()`). For x/net/trace I've only found the /debug/events HTML output (correct me if I'm wrong) * the 'dashboard' x/net/trace looks quite nice to be honest /edit: formatting
PlanCloud9.
Oh can this be used (extended to) for integrated security on Windows ? cc /r/kardianos
Uhh..... I think you completely misunderstood me. When I said that I think the owners are Ruby people I didn't mean anything else beyond that. I am a firm believer that languages are just tools. If someone has tons of experience in Ruby, even if now they have moved to Go, I wouldn't be surprised at all if they made a website in Ruby. There's nothing wrong with that. In fact it might be the right thing to do from a developer's stand point because Ruby (or any other language really) might have been more appropriate for that specific case. Just because this is a Go subreddit does not mean that the people involved have to write every little thing ever in Go. Because you know, Go might not be the best tool for the job &lt;gasp&gt;. &gt; As a community we need to do better Indeed. I was saddened when I saw that this thread was deleted. It is about a topic that has to do with Go so I'd really like to know the reason why it was deleted, (thought I am pretty sure I already know it). From your point of view, this was a post aimed at "tearing down" people and I cannot blame you for thinking that. But from my point of view, some really good discussion could have been generated from such a post. 1) People should understand that languages are just tools and Go is not always the solution. 2) People involved in this community are writing other languages beyond Go. 3) Right now there is a big "hole" in the Go community when it comes to best practices for building modern web sites/apps with Go. Not only there's a lack of articles but also a lack of code repositories to act as "definitive" guides. If a person that is new to Go but with a strong background in Java/Python/Ruby/Node or whatever came and asked me "Should I write my new production web app in Go?", if I wanted to be bluntly honest I'd say no. There's simply not enough good (and complete) material out there to guide that new gopher towards in order to learn how to build a modern web app in Go from top to bottom. &gt; we need to lift people up, not tear them down. I understand what you are saying but I do not completely agree. I mean sure of course we should not tear people up just for the sake of it but in this day and age we have come to completely reject the way the masculine grows and expresses love for others. The masculine grows with challenge; the feminine grows with love. Each person is comprised of both masculine and feminine and both of them are required at different amounts for each daily task. Yet somehow we have come to always suppress one side, publicly shaming it, thinking that it is poison, "evil" and whatnot yet in reality they are both sides of the same coin. But this can get quite philosophical so I'd rather not get into this. 
That's not practical when backing up to a remote service like s3 or b2 and the backup will take multiple days or even weeks. I was trying to backup 120gb to b2 and the estimate your tool gave was 3 days. 
Nice. Although I don't think I want to do something like recreate Javascript in Go.
This comment may answer that question. It is toward the end of a lengthy discussion about a proposal for Go to clean up "dead" goroutines: https://github.com/golang/go/issues/19702#issuecomment-289825220.
According to the changelog B2 support should be included in the official binaries since 0.6.x Do you use a prebuilt binary or did you build restic yourself?
It looks like the youtube video here linked to a playlist, rather than the video directly, so I'm getting "The State of Go" rather than Upspin. [The Upspin presentation should be here](https://www.youtube.com/watch?list=PLtLJO5JKE5YAeVbgwCkgUWyOBsMvZu4UB&amp;v=ENLWEfi0Tkg).
Wow. Talk about Throwback Thursday. FWIW, my opinions changed quite a bit since I wrote this three years ago. :)
Neat project! https://github.com/F483/dejavu/blob/master/dejavu.go#L120 would it make sense to replace that with if f.Test(d) { familiar = true break } so there isn't a need to run against remaining filters as soon as one is a match?
;-) What changed since you wrote it?
I was the author of the post. I would love to discuss the interfaces further. One of the things I tried to do was make it easy to mix and match formats and even convert between formats to better suit different types of operations.
Thanks a lot for the link. This is exactly the answer I was looking for.
absolutely. from the project page: &gt; ## Disclaimer &gt; &gt; This is not an official Google product (experimental or otherwise), it is just code that happens to be owned by Google. &gt; &gt; This project is not affiliated with the Go project.
So if you work at Google do you have to hand over all of your projects even if they aren't made on company time?
Are they selling open source tools?
alpine uses alternative libc implementation (musl), and looks like you've used cgo - resulted binary links to libc. Centos uses glibc. Ether disable cgo, or build on target glibc
As a part of a DB engine?
Yes, but when that's their recommended style, it makes the entire framework seem suspect. If that's how they think go should be used, I don't trust their go code.
It is in the documentation but it is not supported in the current release version 0.6.1. You can try it if you like. I tried the Windows and Mac executables and neither worked. Both tried to create a folder named "b2:xxxx". On windows it failed because it's an invalid folder name. On the mac, it succeeded but the repo was in the current directory. I went ahead and built it from GitHub and it works building from HEAD. 
A DB engine would probably need to worry about the file format and durability more than what this relatively simple layer provides.
See: https://opensource.google.com/docs/creating/ and https://opensource.google.com/docs/iarc/ for the details.
I've been working on something similar at NYT with Gizmo. The latest version of the Gizmo server uses go-kit under the hood to wrap and expose endpoints as both JSON and gRPC: http://godoc.org/github.com/NYTimes/gizmo/server/kit#Service Here's an example using NYT APIs to retrieve recent articles about "cats": https://github.com/NYTimes/gizmo/tree/master/examples/servers/kit
Example server: https://github.com/NYTimes/gizmo/tree/master/examples/servers/kit The service was documented with Open API and https://github.com/NYTimes/openapi2proto was used to generate HTTP annotated protobuf definitions.
Website is working but looks like bait. The chapter list isn't indicative of black hat hacking and was likely used as a bait title as this seems to focus almost entirely on pentesting. There is a big difference between a pentest and black hat activities though pentesters often don't see it. Additionally using a compile and test required language(and strict at that) such as Go is not effective for variable programming often associated with hacking.
They put that on all oss code that isn't a google product, even code they staff and deploy internally. 
This is cool. There is also [go-slab](https://github.com/couchbase/go-slab) which is a slab allocator. I wrote something really similar yesterday that is simpler and would be worse for fragmentation in the general case than this. The tradeoff is that it will pack denser if you know you can get away with a restricted set of allocation lengths at the application level. I've been thinking about doing this recently with allocation areas backed by [pmem](https://pmem.io) but there are thusfar no Go bindings for it and I didn't want to get into a big yak shave.
I believe that go by default will still iink the system libc dynamically. But alpine uses musl -- so the way I've dealt with this in the past is to statically link libc when cross-compiling for alpine. `GOOS=linux GOARCH=amd64 go build --ldflags '-extldflags "-static"' foo.go` EDIT: When cross-compiling. Should run on either.
They even seize existing projects you created before ever working for them. That's actually disgusting and I don't really understand how that is allowed.
Please do not use Ginkgo nor Gomega, tests written with the use of those frameworks are totally unreadable. If such test is flaky, I always rewrite it to testing before troubleshooting the root cause. It's a waste of time and effort.
Hi, I'm the author of gokrb5. The client side code cannot currently pick up tickets and credentials from a Windows OS it is runnng on. I'm not sure how you access this data, if you can provide any pointers I can try and take a look. However on the server side the additional microsoft PAC information in tickets issued by Microsoft AD can be processed. If you are creating a golang web service then SPNEGO is supported so a web browser on a windows machine (or any OS that is configured accordingly) will be able to perform SSO from the browser.
Can you cite an example? Because that's true afaik.
Thank you very much. This worked perfectly! 
Damn. I wanted to do a little web programming in the future. Can you personally recommend something for me to look at?
Disabling autocomplete won save you if there's an XSS. Instead of submitting automatically the form, you can just wait for the user to fill it and submit it. It doesn't change anything. It's just annoying for users.
&gt; That includes new development on personal projects you created prior to employment at Google. https://opensource.google.com/docs/iarc/
Most godoc's are simply api reference, they do not say what this package is for, where the examples are, etc.
Yeah and they're an **Application Security** software company. Seems like they just want to hop on the Go bandwagon as quickly as possible since they haven't added Go as a supported language for their static code analysis tool. 
One should not trust data from the front end (browser) because an attacker can forge/modify data sent by the front end to the back end (web server). The attacker has full access to the code and data in the front end. It is a big mistake to assume that checking the data validity at the front end is contributing to the security of the web app. This should be the first data validation principle of web development security (aka first thermodynamic principle). You look overly confident in our competence in web site security. 
Huh I just wrote something similar to this in go too
&gt; In C, a failure to free is a memory leak - the only thing that went wrong is you forgot to free the memory, and GC eliminated that concern. Deadlocks aren't a case of "you forgot to return from a goroutine". They may be a symptom of defective concurrency handling Then let's talk about double-free or use-after-free, both of which are symptoms of a defective ownership model - just as leaked memory most often is, BTW. A GC would solve the symptom (crashes), but not the underlying problem. How do you distinguish, when a pointer wasn't freed because someone intentionally relied on the GC vs. when it indicated that the programmer didn't think enough about who owns that piece of memory? Note, that memory ownership is not only important for when things get freed (or not), but also, for example, for data races or mutability. Every assistive technology like this will pave over some bugs and will hide some mistakes; that's pretty much the point of it. The point of a GC is, to free the programmer from having to think about ownership so much and to be more forgiving about mistakes in that area. By collecting goroutines, we could free a programmer from having to think about concurrency management so much ("how can I make sure that this goroutine always returns/this channel is always closed/never double-closed/…") and be more forgiving about mistakes. But just do be clear, again: I'm not actually proposing anything. Because I know the kinds of questions that would need to be answered are too hard to answer for me. I'm just saying, that I don't understand why people view "manual goroutine management" as a *fundamentally* different thing from "manual memory management". Sure, we might not have as good answers for it yet, but in it's *essence* it's the same kind of problem and I don't see why it would be more or less possible, in principle. But, yeah. As I said, not really something I want to vehemently debate… I'll be quiet now :)
I was talking about sanitization. You should sanitize your data in the front-end or templates (think html/template). What's the point of storing HTML representations of data in the database? You'd have to use unsafe methods to compose HTML later. I have experience to confirm my competence. What is most relevant, I happen to be an ex-lead developer of a security startup in the privacy space.
that exemption is not very hard to get, most people just don't bother to (they don't mind Google "owning" their open source project)
Maybe if it wasn't a promotion of their company, then people would contribute :) I'd totally help improve it if that wasn't the case.
I've been waiting for a solution like this for quite some time. I was even thinking of building one on top of key base. I am ecstatic to see a neutral self hostable solution. I wonder how the data can be streamable and searchable. 
I've used the ssh library a ton, so awesome that it is a thing
You're not worried about the person writing the frontend. You're worried about the person who's watching the requests to the backend via inspector, then will use raw http to inject bad input into your API. Anyone can reach your backend at the end of the day, so if that's not secure, then nothing is.
I think the author needs to look into the -J flag on ssh His command line: &gt; sshThru proxy.example.com example.com ssh version: &gt; ssh -J proxy.example.com example.com [OpenSSH man page](http://man.openbsd.org/ssh)
Sadly it was for work and they won't let me open source it :'(
Does the standard library verify host keys yet? Still looks like an oversight to me.
Please, do me a favor and read up on security tools like Burp Proxy. In every pentest, I circumvent the frontend completely. No developer can save you from this.
Im not sure I see why you wouldn't be willing to contribute to something that helps everyone just because it also helps there company. It seems like saying you wouldn't report bugs in go because go promotes google.
I've never met anyone who thinks Go kit will be a panacea. For my part I've always tried to caution new developers to think before coding :) With those things said, I hope Go kit is useful to intermediate devs! And beginner devs too. it probably needs a reasonably senior/lead dev to drive it at scale, but the whole point is to help make complicated application architectures more tractable. 👍
That sucks, thanks anyway!
Go doesn't have a paragraph on their homepage explicitly promoting Google.
Backend is not vulnerable to XSS. The frontend is.
How are XSS and anti-XSS practices relevant to backend?
Source: https://twitter.com/rob_pike/status/878412416127606784
Thats because there are so many connections that explicitly stating it in there case would be a waste of time. I would say that in an objective analyses go does far more to promote google than this book will ever do for this company. But irrelevant of anything else it seems to me like splitting mostly unimportant hairs.
The post is word as to not take away the punchline...
Oh my God people it's called a "joke." The title is not the entire tweet because jokes have setups, and then punchlines. Much like Go has setups, and then terminating compiler warnings.
Humor man... It's called humor...
What project got 100 times faster? And was the speedup the result of design changes or was nothing but the language changed?
I thought that theory died back in 19th century?
Their `time-till-lunch` command?
I did actually write one of those years ago when I was in a helpdesk/operations role. It was a time until hometime, not lunch, though. In a really unpleasant job it improved my quality of life. I also wrote something to calculate how much they paid me to take coffee and toilet breaks. It's strangely motivating to know some idiot who hates you just paid you $cents to take a dump. Sadly $cents was a very small number. 
But ns is nanoseconds, not microseconds...
How does kotlin implement reified generics on JVM?
THIS.
With inlined functions... but you obviously won't be able to use either when using Java interop.
Personally there are a lot of times I will quickly throw together a proof of concept in PHP and later formalize it in Go. It might in part be my comfort of years with PHP but I personally believe the language is awesome for rapid iteration. To quote Pike possibly quoting Kent Beck "Make it work, make it right, make it fast". The making it fast for me often involves rewriting it in Go.
With Java I'd use Spring and/or the Apache libraries. I've never had the need to use anything else of questionable source. And honestly; I think go has a lower barrier of entry than Java. If you come across a genericified DefaultAbstractFactoryServiceSingletonImplementation class without familiarity of the concepts behind it you'd get lost. Go thankfully isn't an OOP circlejerk like Java and doesn't do shit like this.
That isn't that case. A lot of services on a *nix machine are writing logs to stdout, and redirecting to logs. You don't see those logs getting mixed up. 
The process is free of logging concerns, and is writing to stdout. Nice that you don't need to complicate your app with complicated logging, yes? Try this one. Super simple. Tell me when it breaks :) https://github.com/scottjbarr/shipper
Just normal `fmt` or `log` usage.
If that's really the case, why do you think that all logging libraries has locking built-in? If two go routines are writing simultaneously, there is a chance for output to be jumbled up. If you have not observed that, it's probably because the application is not concurrent enough, meaning there are not enough go routines writing at the same time. https://stackoverflow.com/questions/14694088/is-it-safe-for-more-than-one-goroutine-to-print-to-stdout
An unnamed return type list for a function signature like "Demo() (string, string, string, error)" tells me nothing about what the function is supposed to return and in which order. When in a type definition for either a function type or a method inside an interface is exactly where you want to have named returns more than anywhere else. "continue" is just that, a "continue" for the current for loop scope, pretty much clear what happens there. A naked return, not to be confused with named return type list, on the other hand is ok to use in small functions, say 5-8 lines, where it's pretty much clear what happened, whereas they can get hard to follow as soon as you need to declare multiple variables in the function or you start shadowing them. So no, they cover fundamentally different use-cases and has nothing to do with the programmer or the program in the way you suggest it.
Whereas with Go you don't yet have that problem because silly people like me still insist on best practices and detract people as much as they can from reinventing the wheel. Yet we have 12+ vendoring projects, 12+ routers / muxers / frameworks (each awful in their own way) and the list goes on... 
I'm french. So please accept my excuse if there is a misunderstanding. I don't understand this &gt; I was talking about sanitization. You should sanitize your data in the front-end or templates (think html/template). What template are you talking about ? As I understnad it, we sanitize input data. Templates are for output data. I was assuming that data in the DB or provided by the server is sanitized. It is the data sent from the front end to the backend, thta needs to ae sanitized because it's unsafe. 
&gt;because it's unsafe How? Is your _server_ vulnerable to XSS? How do you want to show sanitized content?
Ginkgo is alright, but Gomega is awesome. The matchers make writing tests much easier.
&gt; because silly people like me still insist on best practices Where's the best practices?
FWIW, one of the properties of Java I despise the most is that EVERYTHING must be in a class. When you use Go (yes types not classes) or Python, you feel how well it works to be able to define standalone functions. 
The commodity is your time. Even though you are not working at work you are still not able to do what you want.
I agree with you and I'm not just talking about large libraries that exist outside of the standard library (e.g. the Apache stuff), I'm talking about the greater Java community which as tetroxid stated, is vast compared to Go. Now, that isn't to say that Go's community won't someday be that big, although I suspect that it won't. But to imply that not having such a large ecosystem is *desired* is crazy. The Java ecosystem may be full of garbage and awful verbose enterprise bloatware but there are lots of great libraries out there too. . . for example the CodeHale metrics library is insanely good. Also, while I love that Go compiles to native code, I also love what I get from the JVM. . . access to ALL of the Java ecosystem and the ability to use many different languages like Kotlin, Groovy, Scala, Clojure, etc. I actually wish the default implementations of Python, Ruby, PHP, Perl and other scripting languages were the JVM versions. It would be wonderful to be able to just put the JVM on a host and know that you can use the latest and greatest Ruby with Java and Kotlin, etc. However, lots of developers who use other languages hate the JVM and everything it stands for i.e. we'll never see Jython become as popular as CPython. 
Those are two different tweets talking about micro and nano respectively.
This sounds a lot like Beehive, which I've worked on in the last couple years: https://github.com/muesli/beehive It intentionally doesn't do concurrent execution currently, but you could easily adapt it. Feel free to contribute, too!
Xcode is not used for go, however when you install Xcode, you can then install XCode command line tools. Go needs these (at least last time I installed go) these are tools like GDB and GCC that run from the terminal. Sublime is great but its paid. I cant tell you what packages you need because IMHO its a personal thing. Also I use the bare minimum. spend a weekend installing stuff, try it out and if you dont like it uninstall it. 
It's simply written to work that way, so you don't have to worry too much about what you're getting back from a function.
This is great! will definitely check it out
I'm a little sad to see how well a clickbait-y title works at generating upvotes and attention. :(
`go-mode.el` is very active...if you submit a patch for this I am sure I will be using it from the melpa pkg within a few days.
This website is/will be 100% clickbait.
Interesting idea. I had not considered this. Thanks
I think the other comments are answering different questions than you're asking. Go does not have something like `-&gt;` in C or C++ to access members of things you have pointers to, just `.`. You don't need to "dereference" anything, just access the struct's member through one simplified syntax. See the language spec for selectors: https://golang.org/ref/spec#Selectors
There's a simple syntax rule that transforms . on a pointer to first dereference the pointer like -&gt; would in C. The same thing happens when you pass a pointer to a method that expects a value. 
Ginkgo is a bunch of useless/harmful abstractions from BDD true believers. Please just use the stdlib `testing` package.
x *T. (x is var of type pointer to T, where T can be anything ). x.a and x-&gt;a are same in Go. No difference unlike C and C++. 
Nats by itself is not really a queue or persistent streaming server may work a bit differently but yeah. the default with the super backpressure is not a queue
He addressed this when they first announced upspin: https://news.ycombinator.com/item?id=13700968
Ah, good point on the WaitGroup for the webserver, I'll go and change that and make sure it works as I expect. Many thanks again.
https://stackoverflow.com/a/16609580/477693 Don't sweat trying to catch errors on `close`
You created a reddit account just to promote [your](https://github.com/sleaze) bitching on a github issue that was closed over a year ago? Do you seriously have nothing better to do? Learn to accept disappointment like an adult.
This [playcode](https://play.golang.org/p/neCTVlOCRI) shows that everything works as it should. So I think a problem have hidden somewhere in other place.
Thank you very much! I will definitely look into and read about the "DecodeRuneInString" You are right, but I am not sure what to rename the packages to. Any ideas?
Is there something that makes this more complex than a basic event bus? There are a few implementations out there in Go
I don't see the defect, or anything that needs to be fixed here. Having to use 'Id' vs 'ID' is a really insignificant issue, and the response that there will always be more things that they would need to special case to be capitalized is absolutely true. If anything some sort of option flag to force the variable to be generated capitalized would make way more sense.
Thanks for the suggestion. However, in this case, that's not the way to go. In my case, this is a highly concurrent DNS server serving thousands of requests per second, sitting in a DC of one of the top world internet companies. The point I'm trying to make is, the scale is pretty high. Goroutines are high because they're all needed here. 
I'm not 100% sure, but perhaps ZeroMQ or Nanomsg could do this.
[golang.org/x/sync/errgroup](https://godoc.org/golang.org/x/sync/errgroup) is a good example of a better way to implement this. For example using context instead of a time.Duration is much nicer to work with. 
I don't get this... The SafeCloser proposed here makes sure that Close() is only called once on each resource. Close() is usually intended to be safe to call more than once on a resource (for exactly this reason). But the error returned by Close() still isn't handled, which was the reason for proposing this in the first place? Using an deferred anonymous function and named return variables is really well-known as the solution for this: func DoTheThing(thing Thing) (result Whatever, err error) { err = thing.open() if err != nil { return } defer func(){ err = thing.close() if err != nil { return } } result, err = thing.whateverNeededToBeDone() return } I leave handling multiple resources as an exercise for the reader. 
A small mention here, when people say 'pointer' (and I believe in go this is the only meaning for pointer), they generally mean 'pointer to dynamically allocated memory'. So, in that sense, every language that you probably used until now, languages like java, python or js basically 'force' you to use a pointer for everything, that is to say, all objects will be heap allocated and you will be working only with pointers to those (garbage collected) objects.
Corrected, thanks.
I'd consider a `util` suffix if your package is meant to augment an existing one. Similar to how `ioutil` augments `io`. So, `stringsutil`. Better yet, if your package is dedicated to reversing things, call it `reverse`. A function it can export is `Strings`, so it becomes `reverse.Strings`.
You probably don't want to override an existing error though. Perhaps something more like this: func DoTheThing(thing Thing) (result Whatever, err error) { err = thing.open() if err != nil { return } defer func(){ e := thing.close() if err == nil { err = e } return }() result, err = thing.whateverNeededToBeDone() return }
&gt; Have you actually tried running a Go binary with QEMU and encountered an issue? Yeah! ``` $ qemu-arm test runtime: failed to create new OS thread (have 2 already; errno=22) fatal error: newosproc runtime stack: runtime.throw(0x717eb, 0x9) /usr/lib/go/src/runtime/panic.go:596 +0x70 runtime.newosproc(0x10326000, 0x10336000) /usr/lib/go/src/runtime/os_linux.go:163 +0x158 runtime.newm(0x7598c, 0x0) /usr/lib/go/src/runtime/proc.go:1628 +0x10c runtime.main.func1() /usr/lib/go/src/runtime/proc.go:126 +0x24 runtime.systemstack(0xa1100) /usr/lib/go/src/runtime/asm_arm.s:264 +0x80 runtime.mstart() /usr/lib/go/src/runtime/proc.go:1132 goroutine 1 [running]: runtime.systemstack_switch() /usr/lib/go/src/runtime/asm_arm.s:209 +0x4 fp=0x103227bc sp=0x103227b8 runtime.main() /usr/lib/go/src/runtime/proc.go:127 +0x58 fp=0x103227e4 sp=0x103227bc runtime.goexit() /usr/lib/go/src/runtime/asm_arm.s:1017 +0x4 fp=0x103227e4 sp=0x103227e4 ```
It's fair to consider changing the linter I don't understand exactly what triggers the warnings off top of my head to be against it. I remember recently seeing a simple proposal accepted to standardize on a way to mark compiled code with a comment. Might make sense if linter ignored the lower impact warnings for files with that tag. Maybe the linters known identifier list should exist in a more official capacity in go/* sub pkg or the linter pkg via public export. Honestly would have been nice if there was a go/linter pkg to compliment the rest of Go/* sub pkgs.
I realized that there isn't actually any open source, one-line deploy file server out there with no database dependencies, so dependencies and so on.... or at least none that I could find, so I decided to make one. I wouldn't say this is quite production ready yet, but I've ran a few basic tests and today I've started using it to hold some of my files without many problems, but there might be a slip up here and there in regards to permission and what not. Anyway, I would be really glad if anyone could give me some input on the go code I used for writing this ,[which can be found in the server dir](https://github.com/George3d6/Hermes/tree/master/server). Its no the nicest looking, has some global variables which should be contained in a struct, has a bit too much boilerplate and at times it sacrifices a bit of efficiency... but overall its still probably faster than a querying data from a database and fast enough that no end user should care. But, as I said, any input is more than welcome (Input about the client is also good, but that one is even less finished than the server side component).
I've been puzzling over this - it feels very complicated for such a simple thing. In my own experimentation, I can accomplish the same results with a very simple helper function: func SafeClose(err *error, closer io.Closer) { if err != nil &amp;&amp; *err == nil { *err = closer.Close() } else { closer.Close() } } Then all you have to do is modify the example on the Go website that the blog article pointed to ever so slightly and you get the expected Close() behaviour: func CopyFile(dstName, srcName string) (written int64, err error) { src, err := os.Open(srcName) if err != nil { return } defer SafeClose(&amp;err, src) dst, err := os.Create(dstName) if err != nil { return } defer SafeClose(&amp;err, dst) return io.Copy(dst, src) } Am I missing something here? Well, I mean apart from the fact that the blog post's version adds some extra error context... but that hardly seems worth the cost. I'm not wild about the named return, but this seems very much like a "less worse" option in this case.
An unfortunate reality. Everytime I use protobuf code, it annoys me to see `Id` etc. But what is even worse is being forced to use https://godoc.org/golang.org/x/net/context in the codebase.
Few dependencies - yeah because you keep reinventing the wheel because lol no generics.
SECTION | CONTENT :--|:-- Title | Go Proverbs - Rob Pike - Gopherfest - November 18, 2015 Description | See the full list of proverbs here: http://go-proverbs.github.io/ Length | 0:22:29 **** ^(I am a bot, this is an auto-generated reply | )^[Info](https://www.reddit.com/u/video_descriptionbot) ^| ^[Feedback](https://www.reddit.com/message/compose/?to=video_descriptionbot&amp;subject=Feedback) ^| ^(Reply STOP to opt out permanently)
I think [errcheck](https://github.com/kisielk/errcheck) should be added to the (very comprehensive) list. Good job listing these! :)
Or just use https://github.com/alecthomas/gometalinter ;-)
This is a good indication that generics are on they're way! Hurray!!! https://research.swtch.com/go2017#generics &gt; But we do certainly understand that for a certain subset of Go use cases, the lack of parametric polymorphism is a significant hindrance. 
The video thumbnail made me laugh, as always, relevant XKCD: https://xkcd.com/927/ Jokes aside, I agree with /u/Improvotter, Go tools suit Go well. Introducing the JVM of all things into the mix sounds like a _horrific_ idea. When I've used Gradle in the past, it's been fine, but I would never introduce it into a Go project over the existing Go tools. I'm using Glide right now, as are many others - eagerly awaiting Dep, provided that Dep is as good as Glide.
So, it would make sense to put any shared code into the full path (github.com/blah/blah)? So it's easier to use between projects?
I know it's verbose, but I'd suggest putting everything under the domain. You'll be glad you did later. In case you missed my edit: [This section of the docs](https://golang.org/doc/articles/go_command.html#tmp_2) explains the rationale.
RAII is something that I still miss from C++, but I think it gets a lot easier when you realize that most of the time if you have a resource, you manage it through a goroutine, which will sit in a loop function selecting requests, at which point defer works like a charm. You can also do things in closures if you want a particular scope (which only mitigates the complaint) I feel like saying interface{} isn't type safe misses the fact that you can always determine the type (it's a bit like RTTI). You're never in a position where you're unsure what you can safely cast it to, you can always do a tested type assertion / switch. That's not an argument that there's no use in generics, but there's some subtlety missing. 
I don't think you are missing anything. I threw together a playground example at https://play.golang.org/p/eXJUSJn84D to show that this does totally catch the close error as expected, and AFAICT it doesn't have any unexpected side effects. This is the cleanest way I've seen so far to capture return values from deferred functions. 